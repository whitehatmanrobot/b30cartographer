void CReceiveWaitDialog::CenterWindow()
{
    CWnd * pParent = GetParent();
    RECT parentRect;
    RECT childRect;

    pParent->GetWindowRect(&parentRect);
    int dxP = parentRect.right-parentRect.left;
    int dyP = parentRect.bottom - parentRect.top;

    GetWindowRect(&childRect);
    int dxC = childRect.right-childRect.left;
    int dyC = childRect.bottom - childRect.top;

    childRect.left = dxP/2-dxC/2;
    childRect.right = childRect.left+dxC;

    childRect.top = dyP/2-dyC/2;
    childRect.bottom = childRect.top+dyC;

    MoveWindow(&childRect);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\mqapitst.h ===
// test.h : main header file for the TEST application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

#include "mq.h"

/////////////////////////////////////////////////////////////////////////////
// CTestApp:
// See test.cpp for the implementation of this class
//

class CTestApp : public CWinApp
{
public:
	CTestApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTestApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CTestApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

#define BUFFERSIZE 256
#define MAX_Q_PATHNAME_LEN 256
#define MAX_Q_FORMATNAME_LEN 256
#define DEFAULT_M_TIMETOREACHQUEUE -1
#define DEFAULT_M_TIMETOBERECEIVED -1
#define MAX_VAR		 20

//
// A structure for the array of queues that the application handles.
//
typedef struct {
	TCHAR szPathName[MAX_Q_PATHNAME_LEN];     // holds the Queue path name.
	TCHAR szFormatName[MAX_Q_FORMATNAME_LEN]; // holds the Queue format name.
	QUEUEHANDLE hHandle;                         // a handle for an open Queue.
	DWORD dwAccess;                              // access for the queue.
} ARRAYQ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\openqdlg.cpp ===
// OpenQDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MQApitst.h"
#include "OpenQDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COpenQueueDialog dialog


COpenQueueDialog::COpenQueueDialog(CArray <ARRAYQ*, ARRAYQ*>* pStrArray, CWnd* pParent /*=NULL*/)
	: CDialog(COpenQueueDialog::IDD, pParent)
{
	m_pStrArray = pStrArray;

	//{{AFX_DATA_INIT(COpenQueueDialog)
	m_bReceiveAccessFlag = FALSE;
	m_bPeekAccessFlag = FALSE;
	m_SendAccessFlag = FALSE;
	m_szPathName = _T("");
	//}}AFX_DATA_INIT
}


void COpenQueueDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COpenQueueDialog)
	DDX_Control(pDX, IDC_PATHNAME_COMBO, m_PathNameCB);
	DDX_Check(pDX, IDC_IDC_MQ_RECEIVE_ACCESS, m_bReceiveAccessFlag);
	DDX_Check(pDX, IDC_MQ_PEEK_ACCESS, m_bPeekAccessFlag);
	DDX_Check(pDX, IDC_MQ_SEND_ACCESS, m_SendAccessFlag);
	DDX_CBString(pDX, IDC_PATHNAME_COMBO, m_szPathName);
	DDV_MaxChars(pDX, m_szPathName, 128);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COpenQueueDialog, CDialog)
	//{{AFX_MSG_MAP(COpenQueueDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COpenQueueDialog message handlers

BOOL COpenQueueDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

	int i;
	
	for  (i=0 ; i<m_pStrArray->GetSize() ; i++)
		VERIFY (m_PathNameCB.AddString((*m_pStrArray)[i]->szPathName) != CB_ERR);

    if (m_PathNameCB.GetCount() > 0) m_PathNameCB.SetCurSel(0);        

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\recvmdlg.h ===
// RecvMDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CReceiveMessageDialog dialog

class CReceiveMessageDialog : public CDialog
{
// Construction
public:
	CReceiveMessageDialog(CArray <ARRAYQ*, ARRAYQ*>*, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CReceiveMessageDialog)
	enum { IDD = IDD_RECEIVE_MESSAGE_DIALOG };
	CComboBox	m_PathNameCB;
	CString	m_szPathName;
	int		m_iTimeout;
	DWORD	m_dwBodySize;
	//}}AFX_DATA

	/* pointer to the array with the strings for the combo box (Queues PathName). */
	CArray <ARRAYQ*, ARRAYQ*>* m_pStrArray ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CReceiveMessageDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CReceiveMessageDialog)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:

	// BUGBUG - set the 256 to BUFFERSIZE definition
	void GetPathName(TCHAR szPathName[256])
	{
		_tcscpy (szPathName, m_szPathName);
	}

	DWORD GetTimeout()
	{
      if (m_iTimeout < 0)
      {
         m_iTimeout = INFINITE;
      }
		return (m_iTimeout);
	}

	DWORD GetBodySize()
	{
      if (m_dwBodySize == 0)
      {
         m_dwBodySize = BUFFERSIZE ;
      }
		return (m_dwBodySize) ;
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////


class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnApiCreateQueue();
	afx_msg void OnApiDeleteQueue();
	afx_msg void OnApiOpenQueue();
	afx_msg void OnApiCloseQueue();
	afx_msg void OnApiSendMessage();
	afx_msg void OnApiReceiveMessage();
	afx_msg void OnApiLocate();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:

    void OnUpdateFrameTitle(BOOL bAddToTitle);

protected:
	//
	// An array to hold the pathnames of the queues that were created so far.
	//

    //
    // Holds information about all "located" queues
    //
	CArray<ARRAYQ*, ARRAYQ*> m_PathNameArray;

    //
    // Holds information about all "opened" queues
    //
	CArray<ARRAYQ*, ARRAYQ*> m_OpenedQueuePathNameArray;

public:

	//
	// Utility function to display status string based on received msg Class property
	//
	void ClassToString(unsigned short MsgClass,LPTSTR pszStatus);



	//
	// functions to manipulate the path names array.
	//

    //
    // Adds a given ARRAYQ pointer to the PathName array.
    //
	void Add2PathNameArray(ARRAYQ* NewPath) {m_PathNameArray.Add(NewPath);}
    //
    // Removes an ARRAYQ pointer whose pathname matches
    // the given pathname form the PathName array.
    //
	ARRAYQ* RemoveFromPathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN]);
    //
    // Empties the PathName array and frees all allocated memory.
    //
	void CleanPathNameArray();
    //
    // Looks for an ARRAYQ pointer whose pathname matches the given one,
    // and returns the formatname of that ARRAYQ.
    //
    BOOL TranslatePathNameToFormatName(TCHAR szPathName[MAX_Q_PATHNAME_LEN],
                                       TCHAR szFormatName[MAX_Q_FORMATNAME_LEN]);
    //
    // Prints to screen the pathname of all ARRAYQ's in the PathName array.
    //
    void DisplayPathNameArray();

	//
	// functions to manipulate the opened queues path name array.
	//
	
    //
    // Adds a given ARRAYQ pointer to the Opened Queue PathName array.
    //
    void Add2OpenedQueuePathNameArray(ARRAYQ* NewPath)
											{m_OpenedQueuePathNameArray.Add(NewPath);}
    //
    // Removes an ARRAYQ pointer whose pathname matches
    // the given pathname form the Opened Queue PathName array.
    //
	ARRAYQ* RemoveFromOpenedQueuePathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN]);
    //
    // Checks if the Opened Queue PathName array is Empty.
    //
	BOOL IsOpenedQueueArrayEmpty();
    //
    // Looks for an ARRAYQ pointer whose pathname matches the given one,
    // and returns the formatname of that ARRAYQ.
    //
    BOOL TranslateOpenedQueuePathNameToFormatName(
                                           TCHAR szPathName[MAX_Q_PATHNAME_LEN],
                                           TCHAR szFormatName[MAX_Q_FORMATNAME_LEN]);
    //
    // Looks for an ARRAYQ pointer whose pathname matches the given one,
    // and returns the Queue Handle of that ARRAYQ.
    //
	BOOL GetQueueHandle(TCHAR szPathName[MAX_Q_PATHNAME_LEN],
													 QUEUEHANDLE* phClosedQueueHandle);
    //
    // Prints to screen the pathname of all ARRAYQ's in the PathName array.
    //
    void DisplayOpenedQueuePathNameArray();


	//
	// functions to manipulate both of the queues.
	//
	
    //
    // Moves an ARRAYQ pointer from the PathName array to the Opened Queue PathName array.
    //
    void MoveToOpenedQueuePathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN],
		                                           QUEUEHANDLE hQueue, DWORD dwAccess);
    //
    // Moves an ARRAYQ pointer from the Opened Queue PathName array array to the PathName.
    //
	void MoveToPathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN]);
    //
    // Looks for ARRAYQ's that are found in both arrays
    // and removes them from the PathName array.
    //
    void UpdatePathNameArrays();

};

extern "C" void  PrintToScreen(const TCHAR * Format, ...);
extern CWnd* pMainView;

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MQApitst.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_TESTTYPE                    129
#define IDD_CREATE_QUEUE_DIALOG         130
#define IDD_DELETE_QUEUE_DIALOG         131
#define IDD_OPEN_QUEUE_DIALOG           132
#define IDD_CLOSE_QUEUE_DIALOG          133
#define IDD_SEND_MESSAGE_DIALOG         134
#define IDD_RECEIVE_MESSAGE_DIALOG      135
#define IDD_WAIT_DIALOG                 136
#define IDD_LOCATE_DIALOG               137
#define IDC_QUEUE_PATHNAME              1000
#define IDC_QUEUE_LABEL                 1001
#define IDC_DELETE_QUEUE_COMBO          1003
#define IDC_MQ_PEEK_ACCESS              1007
#define IDC_MQ_SEND_ACCESS              1008
#define IDC_IDC_MQ_RECEIVE_ACCESS       1009
#define IDC_PATHNAME_COMBO              1010
#define IDC_COMBO                       1011
#define IDC_ADMIN_COMBO                 1012
#define IDC_MESSAGE_PRIORITY            1013
#define IDC_DELIVERY_EXPRESS_RADIO      1014
#define IDC_DELIVERY_RECOVERABLE_RADIO  1015
#define IDC_ACK_FULL_RADIO              1016
#define IDC_ACK_FULL_REACH_QUEUE_RADIO  1016
#define IDC_ACK_NEG_RADIO               1017
#define IDC_ACK_FULL_RECEIVE_RADIO      1017
#define IDC_ACK_NONE_RADIO              1018
#define IDC_LABEL                       1020
#define IDC_BODY                        1021
#define IDC_TIMEOUT                     1022
#define IDC_TARGET_COMBO                1024
#define IDC_LOCATE_LABEL                1025
#define IDC_JOURNAL                     1026
#define IDC_DEAD_LETTER                 1027
#define IDC_AUTHENTICATED               1029
#define IDC_TIME_TO_BE_RECEIVED         1030
#define IDC_NACK_REACH_QUEUE_RADIO      1031
#define IDC_NACK_RECEIVE_RADIO          1032
#define IDC_TIME_TO_REACH_QUEUE         1033
#define IDC_EDIT1                       1035
#define IDC_RADIO3                      1036
#define IDC_EDT_BODY_SIZE               1037
#define IDC_ENCRYPTED                   1038
#define ID_API_CREATE_QUEUE             32771
#define ID_API_DELETE_QUEUE             32772
#define ID_API_OPEN_QUEUE               32773
#define ID_API_CLOSE_QUEUE              32774
#define ID_API_SEND_MESSAGE             32775
#define ID_API_RECEIVE_MESSAGE          32776
#define ID_API_LOCATE                   32777

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        141
#define _APS_NEXT_COMMAND_VALUE         32785
#define _APS_NEXT_CONTROL_VALUE         1039
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxtempl.h>
#include <afxole.h>

#include "mq.h"				// MSMQ
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\testdoc.cpp ===
// testDoc.cpp : implementation of the CTestDoc class
//

#include "stdafx.h"
#include "MQApitst.h"

#include "testDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTestDoc

IMPLEMENT_DYNCREATE(CTestDoc, CDocument)

BEGIN_MESSAGE_MAP(CTestDoc, CDocument)
	//{{AFX_MSG_MAP(CTestDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTestDoc construction/destruction

CTestDoc::CTestDoc()
{
	// TODO: add one-time construction code here

}

CTestDoc::~CTestDoc()
{
}

BOOL CTestDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	((CEditView*)m_viewList.GetHead())->SetWindowText(NULL);

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CTestDoc serialization

void CTestDoc::Serialize(CArchive& ar)
{
	// CEditView contains an edit control which handles all serialization
	((CEditView*)m_viewList.GetHead())->SerializeRaw(ar);
}

/////////////////////////////////////////////////////////////////////////////
// CTestDoc diagnostics

#ifdef _DEBUG
void CTestDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CTestDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTestDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\recwdlg.h ===
// RecWDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CReceiveWaitDialog dialog

class CReceiveWaitDialog : public CDialog
{
// Construction
public:
	CReceiveWaitDialog(CWnd* pParent = NULL);   // standard constructor
    void CenterWindow();

// Dialog Data
	//{{AFX_DATA(CReceiveWaitDialog)
	enum { IDD = IDD_WAIT_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CReceiveWaitDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CReceiveWaitDialog)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\sendmdlg.cpp ===
// SendMDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MQApitst.h"
#include "SendMDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSendMessageDialog dialog


CSendMessageDialog::CSendMessageDialog(CArray<ARRAYQ*, ARRAYQ*>* pStrArray, CWnd* pParent /*=NULL*/)
	: CDialog(CSendMessageDialog::IDD, pParent)
{
	m_pStrArray = pStrArray;

	//{{AFX_DATA_INIT(CSendMessageDialog)
	m_strBody = szLastMessageBody;
	m_strLabel = szLastMessageLabel;
	m_bPriority = (MQ_MAX_PRIORITY - MQ_MIN_PRIORITY)/2;
	m_iAck = MQMSG_ACKNOWLEDGMENT_NONE;
	m_iDelivery = MQMSG_DELIVERY_EXPRESS;
	m_szPathName = _T("");
	m_szAdminPathName = _T("");
	m_Journal = FALSE;
	m_DeadLetter = FALSE;
	m_Authenticated = FALSE;
	m_Encrypted = FALSE;
	m_dwTimeToReachQueue = (DWORD)DEFAULT_M_TIMETOREACHQUEUE;
	m_dwTimeToBeReceived = (DWORD)DEFAULT_M_TIMETOBERECEIVED;
	//}}AFX_DATA_INIT
}


void CSendMessageDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSendMessageDialog)
	DDX_Control(pDX, IDC_ADMIN_COMBO, m_AdminPathNameCB);
	DDX_Control(pDX, IDC_TARGET_COMBO, m_PathNameCB);
	DDX_Text(pDX, IDC_BODY, m_strBody);
	DDV_MaxChars(pDX, m_strBody, 128);
	DDX_Text(pDX, IDC_LABEL, m_strLabel);
	DDV_MaxChars(pDX, m_strLabel, 128);
	DDX_Text(pDX, IDC_MESSAGE_PRIORITY, m_bPriority);
	DDV_MinMaxByte(pDX, m_bPriority, MQ_MIN_PRIORITY, MQ_MAX_PRIORITY);
	DDX_Radio(pDX, IDC_ACK_NONE_RADIO, m_iAck);
	DDX_Radio(pDX, IDC_DELIVERY_EXPRESS_RADIO, m_iDelivery);
	DDX_CBString(pDX, IDC_TARGET_COMBO, m_szPathName);
	DDV_MaxChars(pDX, m_szPathName, 128);
	DDX_CBString(pDX, IDC_ADMIN_COMBO, m_szAdminPathName);
	DDV_MaxChars(pDX, m_szAdminPathName, 128);
	DDX_Check(pDX, IDC_JOURNAL, m_Journal);
	DDX_Check(pDX, IDC_DEAD_LETTER, m_DeadLetter);
	DDX_Check(pDX, IDC_AUTHENTICATED, m_Authenticated);
	DDX_Check(pDX, IDC_ENCRYPTED, m_Encrypted);
	DDX_Text(pDX, IDC_TIME_TO_REACH_QUEUE, m_dwTimeToReachQueue);
	DDX_Text(pDX, IDC_TIME_TO_BE_RECEIVED, m_dwTimeToBeReceived);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSendMessageDialog, CDialog)
	//{{AFX_MSG_MAP(CSendMessageDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSendMessageDialog message handlers

BOOL CSendMessageDialog::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	int i;
	
	// TODO: Add extra initialization here
	for  (i=0 ; i<m_pStrArray->GetSize() ; i++)
	{
		if (((*m_pStrArray)[i]->dwAccess & MQ_SEND_ACCESS) != FALSE)
		{
			VERIFY (m_PathNameCB.AddString((*m_pStrArray)[i]->szPathName) != CB_ERR);
		}
        VERIFY (m_AdminPathNameCB.AddString((*m_pStrArray)[i]->szPathName) != CB_ERR);
	}
	
    //
    // Set the first PathName as default selection.
    //
    if (m_PathNameCB.GetCount() > 0) m_PathNameCB.SetCurSel(0);
    if (m_AdminPathNameCB.GetCount() > 0) m_AdminPathNameCB.SetCurSel(0);

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\sendmdlg.h ===
// SendMDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSendMessageDialog dialog

class CSendMessageDialog : public CDialog
{
// Construction
public:
	CSendMessageDialog(CArray <ARRAYQ*, ARRAYQ*>*, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSendMessageDialog)
	enum { IDD = IDD_SEND_MESSAGE_DIALOG };
	CComboBox	m_AdminPathNameCB;
	CComboBox	m_PathNameCB;
	CString	m_strBody;
	CString	m_strLabel;
	BYTE	m_bPriority;
	int		m_iAck;
	int		m_iDelivery;
	CString	m_szPathName;
	CString	m_szAdminPathName;
	BOOL	m_Journal;
	BOOL	m_DeadLetter;
	BOOL    m_Authenticated;
	BOOL    m_Encrypted;
	long	m_dwTimeToReachQueue;
	long    m_dwTimeToBeReceived;
	//}}AFX_DATA

	/* pointer to the array with the strings for the combo box (Queues PathName). */
	CArray <ARRAYQ*, ARRAYQ*>* m_pStrArray ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSendMessageDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSendMessageDialog)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	// BUGBUG - set the 256 to BUFFERSIZE definition
	void GetPathName(TCHAR szPathName[256])
	{
		_tcscpy (szPathName, m_szPathName);
	}

	// BUGBUG - set the 256 to BUFFERSIZE definition
	void GetAdminPathName(TCHAR szAdminPathName[256])
	{
		_tcscpy (szAdminPathName, m_szAdminPathName);
	}

	unsigned char GetDelivery()
	{
		return (m_iDelivery);
	}

    unsigned char GetJournal()
	{
		return (m_Journal);
	}

    unsigned char GetDeadLetter()
	{
		return (m_DeadLetter);
	}

	unsigned char GetAuthenticated()
	{
		return (m_Authenticated);
	}

	unsigned char GetEncrypted()
	{
		return (m_Encrypted);
	}

	unsigned char GetPriority()
	{
		return (m_bPriority);
	}

	unsigned char GetAcknowledge()
	{
		switch (m_iAck)
		{
		case 1 : return MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE;
		case 2 : return MQMSG_ACKNOWLEDGMENT_FULL_RECEIVE;
		case 3 : return MQMSG_ACKNOWLEDGMENT_NACK_REACH_QUEUE;
		case 4 : return MQMSG_ACKNOWLEDGMENT_NACK_RECEIVE;
		default: return MQMSG_ACKNOWLEDGMENT_NONE;
		}
	}

	void GetMessageBody(TCHAR* pszMessageBodyBuffer)
	{
		_tcsncpy (pszMessageBodyBuffer, m_strBody, BUFFERSIZE);
	}

	void GetMessageLabel(TCHAR szMessageLabelBuffer[BUFFERSIZE])
	{
		_tcsncpy (szMessageLabelBuffer, m_strLabel, BUFFERSIZE);
	}

	DWORD GetTimeToReachQueue()
	{
		return (m_dwTimeToReachQueue);
	}

	DWORD GetTimeToBeReceived()
	{
		return (m_dwTimeToBeReceived);
	}

};

//
// Two buffers to hold the last message label and body.
//
extern TCHAR szLastMessageLabel[BUFFERSIZE];
extern TCHAR szLastMessageBody[BUFFERSIZE];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\testview.cpp ===
// testView.cpp : implementation of the CTestView class
//

#include "stdafx.h"
#include "MQApitst.h"
#include "mainfrm.h"

#include "testDoc.h"
#include "testView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTestView

IMPLEMENT_DYNCREATE(CTestView, CEditView)

BEGIN_MESSAGE_MAP(CTestView, CEditView)
	//{{AFX_MSG_MAP(CTestView)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTestView construction/destruction

CTestView::CTestView()
{
	// TODO: add construction code here

}

CTestView::~CTestView()
{
}

BOOL CTestView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	BOOL bPreCreated = CEditView::PreCreateWindow(cs);
	cs.style &= ~(ES_AUTOHSCROLL|WS_HSCROLL);	// Enable word-wrapping

	return bPreCreated;
}

/////////////////////////////////////////////////////////////////////////////
// CTestView drawing

void CTestView::OnDraw(CDC* pDC)
{
	CTestDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// TODO: add draw code for native data here
}

/////////////////////////////////////////////////////////////////////////////
// CTestView diagnostics

#ifdef _DEBUG
void CTestView::AssertValid() const
{
	CEditView::AssertValid();
}

void CTestView::Dump(CDumpContext& dc) const
{
	CEditView::Dump(dc);
}

CTestDoc* CTestView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CTestDoc)));
	return (CTestDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTestView message handlers

int CTestView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CEditView::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// TODO: Add your specialized creation code here
	
	pMainView = this;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\testview.h ===
// testView.h : interface of the CTestView class
//
/////////////////////////////////////////////////////////////////////////////

class CTestView : public CEditView
{
protected: // create from serialization only
	CTestView();
	DECLARE_DYNCREATE(CTestView)

// Attributes
public:
	CTestDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTestView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTestView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CTestView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in testView.cpp
inline CTestDoc* CTestView::GetDocument()
   { return (CTestDoc*)m_pDocument; }
#endif


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqapitst\testdoc.h ===
// testDoc.h : interface of the CTestDoc class
//
/////////////////////////////////////////////////////////////////////////////

class CTestDoc : public CDocument
{
protected: // create from serialization only
	CTestDoc();
	DECLARE_DYNCREATE(CTestDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTestDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTestDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CTestDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqbench\excel.h ===
#pragma warning (disable: 4146)
#pragma warning (disable: 4192)

#import <C:\Program Files\Microsoft Office\Office\mso97.dll> no_namespace rename("DocumentProperties", "DocumentPropertiesXL")   
#import <C:\Program Files\Common Files\Microsoft Shared\VBA\vbeext1.olb> no_namespace   
#import <C:\Program Files\Microsoft Office\Office\excel8.olb> rename("DialogBox", "DialogBoxXL") rename("RGB", "RBGXL") rename("DocumentProperties", "DocumentPropertiesXL") no_dual_interfaces

#include <tchar.h>
#include <stdio.h>
#include <math.h>

inline float Round (float number)
{
	float tmp = abs(number);
	if ((number - tmp) < 0.5)
		return tmp;
	else
		return tmp+1;
}

inline void
SaveBenchMarkToExcel (float Benchmark, LPSTR szFileName, LPSTR szWsName, LPSTR szCell)
{
	Benchmark = Round(Benchmark);
	bool found = false;

	using namespace Excel;

    _ApplicationPtr pXL;

	CoInitialize(NULL);

    try {
		pXL.CreateInstance(L"Excel.Application.8");
	    pXL->Visible = VARIANT_FALSE;
	    WorkbooksPtr pBooks = pXL->Workbooks;    
		pBooks->Open(szFileName);
	    
		_WorksheetPtr pSheet = pXL->ActiveSheet;
		_WorksheetPtr pSheetLookahead = pSheet;
		
		while (pSheetLookahead != NULL)
		{
			if(!strcmp(pSheetLookahead->Name, szWsName))
			{
				found = true;
				break;
			}
			pSheetLookahead = pSheetLookahead->Next;			
		}
		
		if (!found)
		{
			pSheetLookahead = pSheet->Previous;
			while (pSheetLookahead != NULL)
			{
				if(!strcmp(pSheetLookahead->Name, szWsName))
				{
					found = true;
					break;
				}
				pSheetLookahead = pSheetLookahead->Previous;			
			}
		}

		if (!found)
		{
			printf("can't find worksheet %s in spreadsheet %s\n", szWsName, szFileName);
			return;
		}
		
		pSheet = pSheetLookahead;
		pSheet->Range[szCell]->Value = Benchmark;
		_WorkbookPtr pBook = pXL->ActiveWorkbook;
		pBook->Close(VARIANT_TRUE, szFileName, VARIANT_FALSE);
		pXL->Quit();
    } 
	catch(_com_error &e) 
	{	
		printf("error 0x%x saving to spreasheet (%s)\n", e.Error(), e.ErrorMessage());
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\array.cpp ===
//
// CArr is used to keep in an simple way the list of all known files
//
typedef struct CFile
{
	WCHAR wszName[MAX_PATH];
	WIN32_FIND_DATAW find_data;
} CFile;

class CArr 
{
public:
	CArr();
	~CArr();

	void Keep(LPWSTR wszPath, WIN32_FIND_DATAW *pData);
	BOOL Lookup(LPWSTR wszPath, WIN32_FIND_DATAW *pData);
	void StartEnumeration();
	LPWSTR Next(WIN32_FIND_DATAW **ppData);

private:
	void Double();

	CFile *pfiles;
	ULONG  ulAllocated;
	ULONG  ulUsed;
	ULONG  ulCur;
};

CArr::CArr()
{
	ulAllocated = 500;
	ulUsed      = 0;
	ulCur       = 0;
	pfiles     = new CFile[ulAllocated];
}

CArr::~CArr()
{
	delete [] pfiles; 
}	

void CArr::Keep(LPWSTR wszPath, WIN32_FIND_DATAW *pData)
{
	if (ulUsed == ulAllocated)
	{
		Double();
	}

	wcscpy(pfiles[ulUsed].wszName, wszPath);
	memcpy(&pfiles[ulUsed].find_data, pData, sizeof(WIN32_FIND_DATAW));
	ulUsed++;
}

BOOL CArr::Lookup(LPWSTR wszPath, WIN32_FIND_DATAW *pData)
{
	for (ULONG i=0; i<ulUsed; i++)
	{
		if (wcscmp(pfiles[i].wszName, wszPath) == 0)
		{
			pData = &pfiles[i].find_data;
			return TRUE;
		}
	}

	return FALSE;
}

void CArr::StartEnumeration()
{
	ulCur       = 0;
}

LPWSTR CArr::Next(WIN32_FIND_DATAW **ppData)
{
	if (ulCur == ulUsed)
	{
		return NULL;
	}


	*ppData = &pfiles[ulCur].find_data;
	return pfiles[ulCur++].wszName;
}

void CArr::Double()
{

	CFile *pfiles1 = new CFile[ulAllocated * 2];
	memcpy(pfiles1, pfiles, sizeof(CFile) * ulAllocated);

	ulAllocated *= 2;

	delete [] pfiles;
	pfiles = pfiles1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqattrib\main.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    

Author:

    ronith 11-Oct-99

--*/

#pragma warning(disable: 4201)

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <iads.h>
#include <adshlp.h>
extern BOOL VerifySchema( OUT WCHAR** ppwszSchemaContainer);
extern HRESULT ConvertQueueLabels(
       IN LPCWSTR pwszSchemaContainer,
       IN BOOL    fRemoveOldLabel,
       IN BOOL    fOverwriteNewLabelIfSet
       );


const WCHAR x_help[] = L"Microsoft (R) Message Queue Label Conversion Utility Version 1.00\nCopyright (C) Microsoft 1985-1999. All rights reserved.\n\nUsage:\tmqattrib [-r] [-o]\n\nArguments:\n-r\tremove queue label from old attribute\n-o\toverwrite value of new queue label attribute, if set\n-?\tprint this help\n";
static void Usage()
{
    printf("%S", x_help);
	exit(-1);
}

extern "C" int _tmain(int argc, TCHAR* argv[])
{
    //
    // If you add/change these constants, change also
    // the usage message.
    //
    const TCHAR x_cRemoveOldLabel = _T('r');
    const TCHAR x_cOverwriteNewLabel = _T('o');
    BOOL  fRemoveOldLabel = FALSE;
    BOOL  fOverwriteNewLabelIfSet = FALSE;


    for (int i=1; i < argc; ++i)
    {
        TCHAR c = argv[i][0];
        if (c == _T('-') || c == _T('/'))
        {
            if (_tcslen(argv[i]) != 2)
            {
                Usage();
            }

            c = static_cast<TCHAR>(_totlower(argv[i][1]));
            switch (c)
            {
                case x_cRemoveOldLabel:
                {
                    fRemoveOldLabel = TRUE;
                    break;
                }

                case x_cOverwriteNewLabel:
                {
                    fOverwriteNewLabelIfSet = TRUE;
                    break;
                }

                default:
                {
                    Usage();
                    break;
                }
            }
        }
        else
        {
            Usage();
        }
    }
    HRESULT hr;
    hr = ::CoInitialize(NULL);
    if (FAILED(hr))
    {
        printf("CoInitialize failed, hr=%lx\n", hr);
        return(0);
    }

    WCHAR * pwszSchemaContainer; 
    if (!VerifySchema( &pwszSchemaContainer))
    {
        printf("\nSchema doesn't contain new attributes, or failure to access the Active Directory.\n");
        printf("    Quitting without performing migration\n");
        return 0;
    }

    //
    //  Convert queue labels
    //
    hr = ConvertQueueLabels(
                pwszSchemaContainer,
                fRemoveOldLabel,
                fOverwriteNewLabelIfSet
                );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqconfig\mqconfig.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    mqconfig.cpp

Abstract:

    Execute actions on computers and queues and retrieve
    queue and computer information.
    Activated from command line.

Author:

    Alon Golan (t-along) 25-Mar-1999

--*/ 
  

#include <_stdh.h> 
#include <mq.h> 
#include <mqprops.h>
#include <uniansi.h>
#include "resource.h"

#define OUTGOING            0
#define PRIVATE             1
#define PUBLIC              2
#define COMP_INFO           3

enum 
{
     PROPID_MGMT_QUEUE_PATHNAME_POSITION,  
     PROPID_MGMT_QUEUE_TYPE_POSITION,
     PROPID_MGMT_QUEUE_LOCATION_POSITION,
     PROPID_MGMT_QUEUE_XACT_POSITION,
     PROPID_MGMT_QUEUE_FOREIGN_POSITION,
     PROPID_MGMT_QUEUE_MESSAGE_COUNT_POSITION,
     PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT_POSITION,
     PROPID_MGMT_QUEUE_STATE_POSITION,
     PROPID_MGMT_QUEUE_NEXTHOPS_POSITION,
     PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT_POSITION,
     PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT_POSITION
};

enum
{
     PROPID_Q_AUTHENTICATE_POSITION,
     PROPID_Q_INSTANCE_POSITION,
     PROPID_Q_JOURNAL_POSITION,
     PROPID_Q_JOURNAL_QUOTA_POSITION,
     PROPID_Q_LABEL_POSITION,
     PROPID_Q_PRIV_LEVEL_POSITION,
     PROPID_Q_QUOTA_POSITION,
     PROPID_Q_TRANSACTION_POSITION
};

enum
{
     PROPID_MGMT_MSMQ_ACTIVEQUEUES_POSITION,
     PROPID_MGMT_MSMQ_PRIVATEQ_POSITION,
     PROPID_MGMT_MSMQ_CONNECTED_POSITION,
     PROPID_MGMT_MSMQ_DSSERVER_POSITION,
     PROPID_MGMT_MSMQ_TYPE_POSITION
};

enum
{
    PROPID_MGMT_QUEUE_PATHNAME_POSITION_2,
    PROPID_MGMT_QUEUE_MESSAGE_COUNT_POSITION_2,
    PROPID_MGMT_QUEUE_STATE_POSITION_2,
    PROPID_MGMT_QUEUE_TYPE_POSITION_2
};


extern "C"
{
/*========================================================

Global variables  

========================================================*/
const DWORD x_dwMaxStringSize      = 256;
const DWORD x_dwArgvSize           = 100;
const DWORD x_dwMaxNoOfProperties  = 10;
const DWORD x_dwDefaultWindowWidth = 70;

const DWORD x_dwMaxNumberOfParams   = 6;
const DWORD x_dwMinNumberOfParams   = 3;
const DWORD x_dwCmdLineComputerName = 2;	   //Location of parameters in command line
const DWORD x_dwCmdLineQueueParam   = 3;
const DWORD x_dwCmdLineQueueName    = 4;
const DWORD x_dwCmdLineDisplayParam = 4;

const DWORD x_dwActConnect    = 0;
const DWORD x_dwActDisconnect = 1;
const DWORD x_dwActPause      = 2;
const DWORD x_dwActResume     = 3;

const DWORD x_dwDisplayNameOnly = 1;


HINSTANCE g_hInstance;
WCHAR g_wcsLocalComputerName[x_dwMaxStringSize];


/*========================================================

class CResourceString

    Loading strings from resource

========================================================*/
class CResourceString
{       
private:
    TCHAR m_wcs[x_dwMaxStringSize];

public:
    CResourceString(UINT nID)
    {
        LoadString(g_hInstance, nID, m_wcs, x_dwMaxStringSize);
    }

    operator LPCTSTR()
    {
        return m_wcs;
    }

    operator LPWSTR()
    {
        return m_wcs;
    }
};


static CResourceString idsArgConnect(IDS_PARAM_CONN);
static CResourceString idsArgQueue(IDS_PARAM_QUEUE);
static CResourceString idsArgOutQ(IDS_PARAM_LIST_OUTGOING);
static CResourceString idsArgPrivQ(IDS_PARAM_LIST_PRIVATE);
static CResourceString idsArgPubQ(IDS_PARAM_LIST_PUBLIC);
static CResourceString idsTotalMessageCount(IDS_TOTAL_MESSAGE_COUNT);   
static CResourceString idsArgOnline(IDS_PARAM_ONLINE);
static CResourceString idsArgOffline(IDS_PARAM_OFFLINE);
static CResourceString idsPathName(IDS_PATH_NAME);
static CResourceString idsFormatName(IDS_FORMAT_NAME);
static CResourceString idsNumberOfMessages(IDS_NUMBER_OF_MESSAGES);
static CResourceString idsUnackedMsgs(IDS_UNACKED_MSGS);
static CResourceString idsState(IDS_STATE);
static CResourceString idsNextHops(IDS_NEXT_HOPS);
static CResourceString idsNextHopsBlank(IDS_NEXT_HOPS_BLANK);
static CResourceString idsLocation(IDS_LOCATION);
static CResourceString idsForeign(IDS_FOREIGN);
static CResourceString idsNoOfMsgsInJournalQ(IDS_NO_OF_MSGS_IN_JOURNAL_Q);
static CResourceString idsNotProcessed(IDS_NOT_PROCESSED);
static CResourceString idsTransacted(IDS_TRANSACTED);

/*==================================================

  FormatLongOutput

==================================================*/
void
FormatLongOutput(LPWSTR pzString)
{
    if(wcslen(pzString) == 0)
    {
        return;
    }

    WCHAR wcsOutput[x_dwMaxStringSize];
    LPWSTR pzOutput;
    DWORD dwLen;
    wcscpy(wcsOutput, pzString);
    dwLen = wcslen(wcsOutput);
    pzOutput = &wcsOutput[0];

    while(dwLen > 0)
    {
        if(dwLen < x_dwDefaultWindowWidth)   // Default cmd window width
        {
            wprintf(L"%s\n", pzOutput);
            break;
        }
        else
        {
            DWORD i;
            for(i = x_dwDefaultWindowWidth; 
                pzOutput[i] != L' '  &&  i > x_dwDefaultWindowWidth/2; 
                --i)
                ;

            if(i ==  x_dwDefaultWindowWidth/2)
            {
                wprintf(L"%s\n", pzOutput);
                break;
            }         
            else
            {
                wcsOutput[i] = L'\0';
                wprintf(L"%s\n", wcsOutput);
                pzOutput += i + 1;
                dwLen -= i;
            }
        }
    }
    
    return;
}


DWORD
CfErrorToString( 
    HRESULT err
    )
/*++

Routine Description:

    Translate an error code to a string.

Arguments:

    err - Error code.

Return Value:

    true - Success
    false - Failure

--*/
{
    DWORD rc;

    //
    // For MSMQ error code, we will take the message from MQUTIL.DLL based on the full
    // HRESULT. For Win32 error codes, we get the message from the system..
    // For other error codes, we assume they are DS error codes, and get the code
    // from ACTIVEDS dll.
    //

    DWORD dwErrorCode = err;
    HMODULE hLib = 0;
    DWORD dwFlags = FORMAT_MESSAGE_MAX_WIDTH_MASK;

    switch (HRESULT_FACILITY(err))
    {
        case FACILITY_MSMQ:
            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
            hLib = LoadLibrary(TEXT("MQUTIL.DLL"));
            break;

        case FACILITY_NULL:
        case FACILITY_WIN32:
            dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
            dwErrorCode = HRESULT_CODE(err);
            break;

        default:
            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
            hLib = LoadLibrary(TEXT("ACTIVEDS.DLL"));
            break;
    }

	
    WCHAR wcsErrorMessage[x_dwMaxStringSize];
	WCHAR wcsErr[x_dwMaxStringSize];
	wcsErr[0] = L'\0';
    rc = FormatMessage(dwFlags,
                       hLib,
                       err,
                       0,
                       wcsErr,
                       x_dwMaxStringSize,
                       NULL);
    
    static CResourceString idsError(IDS_ERROR);
    wsprintf(wcsErrorMessage, L"%s%s", LPCTSTR(idsError), wcsErr);
    
    if(rc == 0)
    {
        static CResourceString idsUnknownError(IDS_UNKNOWN_ERROR);
        wprintf(L"%s\n", LPCTSTR(idsUnknownError));
    }
    else
    {
        FormatLongOutput(wcsErrorMessage);
    }

    if (0 != hLib)
    {
        FreeLibrary(hLib);
    }

    return(rc);
}


/*========================================================

DisplayIncorrectParams

========================================================*/
void
DisplayIncorrectParams(void)
{
	static CResourceString idsIncorrectParams(IDS_INCORRECT_PARAMS);
    wprintf(L"%s", LPWSTR(idsIncorrectParams));

	return;
}


/*========================================================

GetFirstWord

    Gets command line, returns a pointer 
    to the first word and its length

========================================================*/
DWORD
GetFirstWord(
        WCHAR *wcsLine,
        WCHAR* &wcsWord
        )
{
    DWORD dwLen = 0;
    while(isspace(*wcsLine))
    {
        ++wcsLine;
    }
    while(!isspace(*(wcsLine + dwLen)) && (*(wcsLine + dwLen)!=L'\0'))
    {
        ++dwLen;
    }
    wcsWord = wcsLine;
    return dwLen;
}


/*========================================================

GenerateFormatName

    Add "QUEUE=" to the beginning of a queue format
    name, to retrieve pathname.

========================================================*/
void
GenerateFormatName(WCHAR *wcsName)
{
    WCHAR wcsNewName[x_dwMaxStringSize];
    DWORD i;

    wcscpy(wcsNewName, L"QUEUE=");
    for(i = 0; i < 6; ++i)
    {
        if(wcsNewName[i] != wcsName[i])
        {
            wcscpy(wcsNewName+6, wcsName);
            wcscpy(wcsName, wcsNewName);
            break;
        }
    }       
    return;
}


/*========================================================

GeneratePathName

    Add "QUEUE=DIRECT=OS:" to the beginning of a queue
    pathname, to retrieve pathname.

========================================================*/
void
GeneratePathName(WCHAR *wcsName)
{
    WCHAR wcsNewName[x_dwMaxStringSize];

    wcscpy(wcsNewName, L"QUEUE=DIRECT=OS:");
    wcscpy(wcsNewName + wcslen(wcsNewName), wcsName);
    wcscpy(wcsName, wcsNewName);
    
    return;
}


/*========================================================

GenerateQueueName

    Call GeneratePathName or GenerateFormatName, 
    according to appearance of '=' in queue name.

========================================================*/
void
GenerateQueueName(WCHAR *wcsName)
{
    if(wcsstr(wcsName, L"="))
    {
        GenerateFormatName(wcsName);      
    }

    else
    {
        GeneratePathName(wcsName);
    }
    
    return;
}


/*========================================================

StateTranslator

  Translates MSMQ MGMT_QUEUE_STATE string macros into 
  loaded resource strings.
  In the English version this is used for cutting these
  strings off to column width.

========================================================*/
typedef struct statetranslator
{
    LPWSTR wcsState;
    DWORD dwIds;
} StateTranslator;

const StateTranslator aStateTranslator[] =
{
    {MGMT_QUEUE_STATE_LOCAL,         IDS_MGMT_QUEUE_STATE_LOCAL},
    {MGMT_QUEUE_STATE_NONACTIVE,     IDS_MGMT_QUEUE_STATE_NONACTIVE},
    {MGMT_QUEUE_STATE_WAITING,       IDS_MGMT_QUEUE_STATE_WAITING},
    {MGMT_QUEUE_STATE_NEED_VALIDATE, IDS_MGMT_QUEUE_STATE_NEED_VALIDATE},
    {MGMT_QUEUE_STATE_ONHOLD,        IDS_MGMT_QUEUE_STATE_ONHOLD},
    {MGMT_QUEUE_STATE_CONNECTED,     IDS_MGMT_QUEUE_STATE_CONNECTED},
    {MGMT_QUEUE_STATE_DISCONNECTING, IDS_MGMT_QUEUE_STATE_DISCONNECTING},
    {MGMT_QUEUE_STATE_DISCONNECTED,  IDS_MGMT_QUEUE_STATE_DISCONNECTED},
    {NULL, NULL}
};


/*==========================================================================

CheckParameter

	Checks if given parameter is a valid one.
    Optional parameters:
    English version   resource macro        meaning
    ---------------   -------------------   -------
    /b                IDS_PARAM_NAME_ONLY   display full queue names 
                                            instead of other properties

==========================================================================*/
bool
CheckParameter(LPWSTR pwzParam)
{
    static CResourceString idsArgNameOnly(IDS_PARAM_NAME_ONLY);

    if(CompareStringsNoCaseUnicode(LPCTSTR(idsArgNameOnly), pwzParam) == 0 ||
	   pwzParam[0] == 0)
    {
        return true;
    }

	return false;
}


/*========================================================

DisplayHelpOutsideEnvironment

========================================================*/
void
DisplayHelpOutsideEnvironment()
{
    static CResourceString idsHelpHeader(IDS_HELP_HEADER);
    static CResourceString idsHelpUsage(IDS_HELP_USAGE);
	static CResourceString idsHelpOptions1(IDS_HELP_OPTIONS1);
    static CResourceString idsHelpOptions2(IDS_HELP_OPTIONS2);
    static CResourceString idsHelpOptions3(IDS_HELP_OPTIONS3);
	static CResourceString idsHelpExamples(IDS_HELP_EXAMPLES);
    wprintf(idsHelpHeader);
	wprintf(idsHelpUsage);
	wprintf(idsHelpOptions1);
    wprintf(idsHelpOptions2);
    wprintf(idsHelpOptions3);
	wprintf(idsHelpExamples);

    return;
}


/*========================================================

DisplayHelpInEnvironment

========================================================*/
void
DisplayHelpInEnvironment()
{
    static CResourceString idsHelpEnvironmentHeader(IDS_HELP_ENVIRONMENT_HEADER);
    static CResourceString idsHelpEnvironmentUsage1(IDS_HELP_ENVIRONMENT_USAGE1);
    static CResourceString idsHelpEnvironmentUsage2(IDS_HELP_ENVIRONMENT_USAGE2);
	static CResourceString idsHelpEnvironmentOptions1(IDS_HELP_ENVIRONMENT_OPTIONS1);
    static CResourceString idsHelpEnvironmentOptions2(IDS_HELP_ENVIRONMENT_OPTIONS2);
    static CResourceString idsHelpEnvironmentOptions3(IDS_HELP_ENVIRONMENT_OPTIONS3);
	static CResourceString idsHelpEnvironmentExamples(IDS_HELP_ENVIRONMENT_EXAMPLES);
    wprintf(idsHelpEnvironmentHeader);
	wprintf(idsHelpEnvironmentUsage1);
	wprintf(idsHelpEnvironmentUsage2);
	wprintf(idsHelpEnvironmentOptions1);
    wprintf(idsHelpEnvironmentOptions2);
    wprintf(idsHelpEnvironmentOptions3);
	wprintf(idsHelpEnvironmentExamples);

    return;
}


/*========================================================

DisplayHelpFile

========================================================*/
bool
DisplayHelpFile(LPWSTR wcsParam, DWORD dwInEnvironment)
{
    if(wcsParam[0] == 0)
    {
        return false;
    }

    static CResourceString idsHelp(IDS_HELP);
    if(CompareStringsNoCaseUnicode(LPCTSTR(idsHelp), wcsParam) == 0 ||
       wcscmp(wcsParam, L"?") == 0)
    {
        if(dwInEnvironment)
		{
			DisplayHelpInEnvironment();
		}
		else
		{
			DisplayHelpOutsideEnvironment();
		}
        return true;
    }
 
    return false;
}


/*=========================================================================

Action

    Executes actions on computers and queues  
    Optional parameters:
    English version   resource macro                meaning
    ---------------   -------------------           -------
    online            MACHINE_ACTION_CONNECT        connect machine
    offline           MACHINE_ACTION_DISCONNECT     disconnect machine

    /p                QUEUE_ACTION_PAUSE            pause queue
    /r                QUEUE_ACTION_RESUME           resume queue

=========================================================================*/
bool 
Action(
	LPWSTR wcsComputerName,
	LPCWSTR wcsObjectName,
    DWORD dwAction
	)
{	
	WCHAR wcsAction[x_dwMaxStringSize];
    
	if(dwAction == x_dwActConnect)
    {
		wcscpy(wcsAction, MACHINE_ACTION_CONNECT);
    }
	if(dwAction == x_dwActDisconnect)
    {
		wcscpy(wcsAction, MACHINE_ACTION_DISCONNECT);	
    }
	if(dwAction == x_dwActPause)
    {
		wcscpy(wcsAction, QUEUE_ACTION_PAUSE);
    }
    if(dwAction == x_dwActResume)
    {
		wcscpy(wcsAction, QUEUE_ACTION_RESUME);
    }	
    
    HRESULT hr; 
	hr = MQMgmtAction(wcsComputerName, wcsObjectName, wcsAction);   
    if (FAILED(hr))
    {   
        CfErrorToString(hr);
        return true;
    }

    static CResourceString idsDone(IDS_ACTION_DONE);
	wprintf(L"%s %s %s.", wcsObjectName, wcsAction, LPWSTR(idsDone));
	return true;
}


/*========================================================

GetComputerGuid

========================================================*/

bool
GetComputerGuid(LPWSTR wcsComputerName, GUID* pguidMachineId)
{
    HRESULT hr;   
    DWORD cPropId=0;
    QMPROPID aQMPropId[x_dwMaxNoOfProperties];
    PROPVARIANT aQMPropVar[x_dwMaxNoOfProperties];
    HRESULT aQMStatus[x_dwMaxNoOfProperties];

    aQMPropId[cPropId] = PROPID_QM_MACHINE_ID;
    aQMPropVar[cPropId].vt = VT_CLSID;    
    aQMPropVar[cPropId].puuid = pguidMachineId;
    cPropId++;

    MQQMPROPS QMProps;

    QMProps.cProp = cPropId;
    QMProps.aPropID = aQMPropId;
    QMProps.aPropVar = aQMPropVar;
    QMProps.aStatus = aQMStatus;

    hr = MQGetMachineProperties(wcsComputerName,
                                NULL,
                                &QMProps);
    if (FAILED(hr))
    {   
       /*
        CfErrorToString(hr);
        */
        return false;
    }

    return true;
}


/*========================================================

GetQueueProps

    Gets queue properties with MQMgmtGetInfo.

========================================================*/
bool
GetQueueProps(
       MQMGMTPROPS *pQueueProps,
       MGMTPROPID aQPropId[],
       MQPROPVARIANT aQPropVar[],
       LPWSTR pwzComputerName, 
       LPWSTR pwzQueueName
       )
{
    DWORD cQProp = 0;
	
    aQPropId[PROPID_MGMT_QUEUE_PATHNAME_POSITION] = PROPID_MGMT_QUEUE_PATHNAME;   
    aQPropVar[PROPID_MGMT_QUEUE_PATHNAME_POSITION].vt = VT_NULL;
    ++cQProp;
    
    aQPropId[PROPID_MGMT_QUEUE_TYPE_POSITION] = PROPID_MGMT_QUEUE_TYPE;       
    aQPropVar[PROPID_MGMT_QUEUE_TYPE_POSITION].vt = VT_NULL;
    ++cQProp;
	
    aQPropId[PROPID_MGMT_QUEUE_LOCATION_POSITION] = PROPID_MGMT_QUEUE_LOCATION;
    aQPropVar[PROPID_MGMT_QUEUE_LOCATION_POSITION].vt = VT_NULL;
    ++cQProp;
	
    aQPropId[PROPID_MGMT_QUEUE_XACT_POSITION] = PROPID_MGMT_QUEUE_XACT;
    aQPropVar[PROPID_MGMT_QUEUE_XACT_POSITION].vt = VT_NULL;
    ++cQProp;
	
    aQPropId[PROPID_MGMT_QUEUE_FOREIGN_POSITION] = PROPID_MGMT_QUEUE_FOREIGN;
    aQPropVar[PROPID_MGMT_QUEUE_FOREIGN_POSITION].vt = VT_NULL;
    ++cQProp;
	
    aQPropId[PROPID_MGMT_QUEUE_MESSAGE_COUNT_POSITION] = PROPID_MGMT_QUEUE_MESSAGE_COUNT;
    aQPropVar[PROPID_MGMT_QUEUE_MESSAGE_COUNT_POSITION].vt = VT_NULL;
    ++cQProp;
	
    aQPropId[PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT_POSITION] = PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT;
    aQPropVar[PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT_POSITION].vt = VT_NULL;
    ++cQProp;
    
    aQPropId[PROPID_MGMT_QUEUE_STATE_POSITION] = PROPID_MGMT_QUEUE_STATE;
    aQPropVar[PROPID_MGMT_QUEUE_STATE_POSITION].vt = VT_NULL;
    ++cQProp;
	
    aQPropId[PROPID_MGMT_QUEUE_NEXTHOPS_POSITION] = PROPID_MGMT_QUEUE_NEXTHOPS;
    aQPropVar[PROPID_MGMT_QUEUE_NEXTHOPS_POSITION].vt = VT_NULL;
    ++cQProp;
	   
    aQPropId[PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT_POSITION] = PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT;
    aQPropVar[PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT_POSITION].vt = VT_NULL;
    ++cQProp;
    
    aQPropId[PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT_POSITION] = PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT;
    aQPropVar[PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT_POSITION].vt = VT_NULL;
    ++cQProp;

    pQueueProps->cProp = cQProp;
    pQueueProps->aPropID = aQPropId;
    pQueueProps->aPropVar = aQPropVar;

    WCHAR wcsQueueName[x_dwMaxStringSize];
    wcscpy(wcsQueueName, pwzQueueName);
    GenerateQueueName(wcsQueueName);
    
    WCHAR wcsComputerName[x_dwMaxStringSize];
    wcscpy(wcsComputerName, pwzComputerName);    

    HRESULT hr;
    hr = MQMgmtGetInfo(pwzComputerName, wcsQueueName, pQueueProps);
    if(FAILED(hr))
    {           
        CfErrorToString(hr);        
        return false;
    }

    return true;
}


/*========================================================

DisplayPrivateOrPublicQueuePropsFromDS    

========================================================*/
bool
DisplayPrivateOrPublicQueuePropsFromDS(
                 MQMGMTPROPS *pQueueProps,
                 LPWSTR pwzQueueName
                 )
{
    DWORD cQProp = 0;
    MGMTPROPID aPropId[x_dwMaxNoOfProperties];
    MQPROPVARIANT aPropVar[x_dwMaxNoOfProperties];
    MQQUEUEPROPS mqQueueProps;


    aPropId[PROPID_Q_AUTHENTICATE_POSITION] = PROPID_Q_AUTHENTICATE;
    aPropVar[PROPID_Q_AUTHENTICATE_POSITION].vt = VT_NULL;
    cQProp++;
    
    aPropId[PROPID_Q_INSTANCE_POSITION] = PROPID_Q_INSTANCE;
    aPropVar[PROPID_Q_INSTANCE_POSITION].vt = VT_NULL;
    cQProp++;
    
    aPropId[PROPID_Q_JOURNAL_POSITION] = PROPID_Q_JOURNAL;
    aPropVar[PROPID_Q_JOURNAL_POSITION].vt = VT_NULL;
    cQProp++;
 
    aPropId[PROPID_Q_JOURNAL_QUOTA_POSITION] = PROPID_Q_JOURNAL_QUOTA;
    aPropVar[PROPID_Q_JOURNAL_QUOTA_POSITION].vt = VT_NULL;
    cQProp++;

    aPropId[PROPID_Q_LABEL_POSITION] = PROPID_Q_LABEL;
    aPropVar[PROPID_Q_LABEL_POSITION].vt = VT_NULL;
    cQProp++;

    aPropId[PROPID_Q_PRIV_LEVEL_POSITION] = PROPID_Q_PRIV_LEVEL;
    aPropVar[PROPID_Q_PRIV_LEVEL_POSITION].vt = VT_NULL;
    cQProp++;

    aPropId[PROPID_Q_QUOTA_POSITION] = PROPID_Q_QUOTA;
    aPropVar[PROPID_Q_QUOTA_POSITION].vt = VT_NULL;
    cQProp++;

    aPropId[PROPID_Q_TRANSACTION_POSITION] = PROPID_Q_TRANSACTION;
    aPropVar[PROPID_Q_TRANSACTION_POSITION].vt = VT_NULL;
    cQProp++;

    mqQueueProps.cProp = cQProp;
    mqQueueProps.aPropID = aPropId;
    mqQueueProps.aPropVar = aPropVar;
   
    HRESULT hr;
    WCHAR wcsFormatName[x_dwMaxStringSize];
    DWORD dwFormatNameLen = x_dwMaxStringSize;
    wcsFormatName[0] = L'\0';

    if(wcsstr(pwzQueueName, L"=") == 0)
    {
        MQPathNameToFormatName(pwzQueueName, wcsFormatName, &dwFormatNameLen);
    }
    else
    {
        wcscpy(wcsFormatName, pwzQueueName);
    }               

    hr = MQGetQueueProperties(wcsFormatName, &mqQueueProps);

    if (FAILED(hr))
    {
        return false;
    }
    static CResourceString idsPrivateQueueProps1(IDS_PRIVATE_QUEUE_PROPS1);
    static CResourceString idsPrivateQueueProps2(IDS_PRIVATE_QUEUE_PROPS2);

    wprintf(idsPrivateQueueProps1,
            pwzQueueName,               
            aPropVar[PROPID_Q_LABEL_POSITION].pwszVal);
    MQFreeMemory(aPropVar[PROPID_Q_LABEL_POSITION].pwszVal);

    if(aPropVar[PROPID_Q_INSTANCE_POSITION].puuid)
    {    
        LPWSTR pwzGuidString = NULL;    
        GUID* pGuid = aPropVar[PROPID_Q_INSTANCE_POSITION].puuid;    
        UuidToStringW(pGuid, &pwzGuidString);
        static CResourceString idsInstance(IDS_INSTANCE);

        wprintf(idsInstance, pwzGuidString);
        
        RpcStringFreeW(&pwzGuidString);   
        MQFreeMemory(aPropVar[PROPID_Q_INSTANCE_POSITION].puuid);
    }
    wprintf(idsPrivateQueueProps2,
            (pQueueProps->aPropVar[PROPID_MGMT_QUEUE_MESSAGE_COUNT_POSITION]).ulVal,
            aPropVar[PROPID_Q_AUTHENTICATE_POSITION].bVal,
            aPropVar[PROPID_Q_PRIV_LEVEL_POSITION].ulVal, 
            aPropVar[PROPID_Q_QUOTA_POSITION].ulVal, 
            aPropVar[PROPID_Q_TRANSACTION_POSITION].bVal,
            aPropVar[PROPID_Q_JOURNAL_POSITION].bVal,
            aPropVar[PROPID_Q_JOURNAL_QUOTA_POSITION].ulVal); 
   
    return true;
}


/*========================================================

DisplayPrivateOrPublicQueueProps

    Display private or public queue properties

========================================================*/
void
DisplayPrivateOrPublicQueueProps(
			 MQMGMTPROPS *pQueueProps,
			 LPWSTR wcsQueueName
			 )
{
    // First try getting queue properties from the DS
    bool fResult;
    fResult = DisplayPrivateOrPublicQueuePropsFromDS(pQueueProps, wcsQueueName);
    if(fResult == true)
    {
        return;
    }

    //
    // If information retrieval from DS failed, display cache info.
    // This information was already retrieved by GetQueueProps()
    //
    WCHAR wcsFormatName[x_dwMaxStringSize];
    DWORD dwCount = x_dwMaxStringSize;
    wcsFormatName[0] = L'\0';
    if((pQueueProps->aPropVar[PROPID_MGMT_QUEUE_PATHNAME_POSITION]).pwszVal)
        // Pathname retrieved
    {
        wprintf(L"%s%s\n", LPCTSTR(idsPathName), 
                         (pQueueProps->aPropVar[PROPID_MGMT_QUEUE_PATHNAME_POSITION]).pwszVal);
        
        HRESULT hr;                                     // get Format name
        hr = MQPathNameToFormatName(
                    (pQueueProps->aPropVar[PROPID_MGMT_QUEUE_PATHNAME_POSITION]).pwszVal,  
                    wcsFormatName, 
                    &dwCount);
        if(wcsFormatName[0])
        {
            wprintf(L"%s%s\n", LPCTSTR(idsFormatName), wcsFormatName);
        }

    }
    else
    {
        wprintf(L"%s%s\n", LPCTSTR(idsFormatName), wcsQueueName);
    }
	
	wprintf(L"%s%ld\n", LPWSTR(idsNumberOfMessages), 
            (pQueueProps->aPropVar[PROPID_MGMT_QUEUE_MESSAGE_COUNT_POSITION]).ulVal);
    wprintf(L"%s%s\n", LPWSTR(idsTransacted),
            (pQueueProps->aPropVar[PROPID_MGMT_QUEUE_XACT_POSITION]).pwszVal);
    wprintf(L"%s%ld\n", LPWSTR(idsNoOfMsgsInJournalQ),
            (pQueueProps->aPropVar[PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT_POSITION]).ulVal);

	return;
}


/*========================================================

DisplayOutgoingQueueProps

    Displays outgoing queue properties

========================================================*/
void
DisplayOutgoingQueueProps(
			MQMGMTPROPS *pQueueProps,
			LPWSTR wcsQueueName
			)
{
    WCHAR wcsFormatName[x_dwMaxStringSize];
    DWORD dwCount = x_dwMaxStringSize;

	wcsFormatName[0] = L'\0';
    if((pQueueProps->aPropVar[PROPID_MGMT_QUEUE_PATHNAME_POSITION]).pwszVal != NULL)
        // Pathname retrieved
    {
        wprintf(L"%s%s\n", LPWSTR(idsPathName),
                           (pQueueProps->aPropVar[PROPID_MGMT_QUEUE_PATHNAME_POSITION]).pwszVal);

        HRESULT hr;                                     // get Format name
        hr = MQPathNameToFormatName(
                    (pQueueProps->aPropVar[PROPID_MGMT_QUEUE_PATHNAME_POSITION]).pwszVal,  
                    wcsFormatName, 
                    &dwCount);
        if(FAILED(hr))
        { 
            wcsFormatName[0] = 0;        
        }
    }
 
    if(wcsFormatName[0])
    {
        wprintf(L"%s%s\n", LPWSTR(idsFormatName), wcsFormatName);
    }
    else
    {       
        wprintf(L"%s%s\n", LPWSTR(idsFormatName), wcsQueueName);
    }
    

	wprintf(L"%s%ld\n", LPWSTR(idsNumberOfMessages),
                        (pQueueProps->aPropVar[PROPID_MGMT_QUEUE_MESSAGE_COUNT_POSITION]).ulVal);
	wprintf(L"%s%ld\n", LPWSTR(idsUnackedMsgs), 
                        (pQueueProps->aPropVar[PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT_POSITION]).ulVal);
	wprintf(L"%s%s\n",  LPWSTR(idsState), 
                        (pQueueProps->aPropVar[PROPID_MGMT_QUEUE_STATE_POSITION]).pwszVal);

    if(((pQueueProps->aPropVar[PROPID_MGMT_QUEUE_NEXTHOPS_POSITION]).calpwstr).cElems > 0)
    {
        wprintf(L"%s", LPWSTR(idsNextHops));
        wprintf(L"%s\n", 
                ((pQueueProps->aPropVar[PROPID_MGMT_QUEUE_NEXTHOPS_POSITION]).calpwstr).pElems[0]);
        DWORD i;
        for(i=1; 
            i<((pQueueProps->aPropVar[PROPID_MGMT_QUEUE_NEXTHOPS_POSITION]).calpwstr).cElems; 
            ++i)
        {
            wprintf(L"%s%s\n", LPWSTR(idsNextHopsBlank),
                   ((pQueueProps->aPropVar[PROPID_MGMT_QUEUE_NEXTHOPS_POSITION]).calpwstr).pElems[i]);
        }
    }

    wprintf(L"%s%s\n", LPWSTR(idsLocation), 
                       (pQueueProps->aPropVar[PROPID_MGMT_QUEUE_LOCATION_POSITION]).pwszVal);
    wprintf(L"%s%s\n", LPWSTR(idsForeign), 
                       (pQueueProps->aPropVar[PROPID_MGMT_QUEUE_FOREIGN_POSITION]).pwszVal);
    wprintf(L"%s%ld\n", LPWSTR(idsNoOfMsgsInJournalQ),
                        (pQueueProps->aPropVar[PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT_POSITION]).ulVal);
    wprintf(L"%s%ld\n",LPWSTR(idsNotProcessed),
                       (pQueueProps->aPropVar[PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT_POSITION]).ulVal);
    wprintf(L"%s%s\n", LPWSTR(idsTransacted),
                       (pQueueProps->aPropVar[PROPID_MGMT_QUEUE_XACT_POSITION]).pwszVal);
 
	return;
}


/*========================================================

DisplayQueueProps

    Prints queue properties

========================================================*/
bool
DisplayQueueProps(
		LPWSTR wcsComputerName,
		LPWSTR wcsQueueName
		)
{   
    bool fResult;
    MQMGMTPROPS mqQueueProps;
    MGMTPROPID aQPropId[50];
    MQPROPVARIANT aQPropVar[50];

    fResult = GetQueueProps(&mqQueueProps, 
                           aQPropId,
                           aQPropVar,
                           wcsComputerName,
                           wcsQueueName);
    if(fResult == false)
    {
        return true;
    }

    if(wcscmp((mqQueueProps.aPropVar[PROPID_MGMT_QUEUE_STATE_POSITION]).pwszVal,
               MGMT_QUEUE_STATE_LOCAL)==0 
               &&  
      (wcscmp((mqQueueProps.aPropVar[PROPID_MGMT_QUEUE_TYPE_POSITION]).pwszVal,
               MGMT_QUEUE_TYPE_PUBLIC)==0       || 
       wcscmp((mqQueueProps.aPropVar[PROPID_MGMT_QUEUE_TYPE_POSITION]).pwszVal,
               MGMT_QUEUE_TYPE_PRIVATE)==0))
    													// Private or public queue
	{   
		DisplayPrivateOrPublicQueueProps(&mqQueueProps, wcsQueueName);
    }
    else												// Outgoing queue
	{
		DisplayOutgoingQueueProps(&mqQueueProps, wcsQueueName);
	}
    
    MQFreeMemory(aQPropVar[PROPID_MGMT_QUEUE_PATHNAME_POSITION].pwszVal);
    MQFreeMemory(aQPropVar[PROPID_MGMT_QUEUE_TYPE_POSITION].puuid);
  
    return true;
}


/*========================================================

DisplayOutgoingQueuesHeader

========================================================*/
void
DisplayOutgoingQueuesHeader(DWORD dwDisplayFlag)
{
    static CResourceString idsOutgoingQueues(IDS_OUTGOING_QUEUES);
    wprintf(L"%s\n", LPCTSTR(idsOutgoingQueues));

    if(dwDisplayFlag == x_dwDisplayNameOnly)
    {
        static CResourceString idsNameOnlyHeader1(IDS_NAME_ONLY_HEADER_TEXT);
        static CResourceString idsNameOnlyHeader2(IDS_NAME_ONLY_HEADER_UNDERLINE);    
        wprintf(L"\n%s\n%s\n", LPCTSTR(idsNameOnlyHeader1), LPCTSTR(idsNameOnlyHeader2));
    }
    else
    {
        static CResourceString idsCompInfoHeaderOut1(IDS_COMP_INFO_HEADER_TEXT);
        static CResourceString idsCompInfoHeaderOut2(IDS_COMP_INFO_HEADER_UNDERLINE);       
        wprintf(L"\n%s\n%s\n", LPCTSTR(idsCompInfoHeaderOut1), LPCTSTR(idsCompInfoHeaderOut2));
    }

    return;
}


/*========================================================

DisplayPrivateQueuesHeader

========================================================*/
void
DisplayPrivateQueuesHeader(DWORD dwDisplayFlag)
{
    if(dwDisplayFlag == x_dwDisplayNameOnly)
    {
        static CResourceString idsNameOnlyHeader1(IDS_NAME_ONLY_HEADER_TEXT);
        static CResourceString idsNameOnlyHeader2(IDS_NAME_ONLY_HEADER_UNDERLINE);    
        wprintf(L"\n%s\n%s\n", LPCTSTR(idsNameOnlyHeader1), LPCTSTR(idsNameOnlyHeader2));
    }
    
    else
    {
        static CResourceString idsCompInfoHeaderPriv1(IDS_COMP_INFO_HEADER_TEXT_PRIV);
        static CResourceString idsCompInfoHeaderPriv2(IDS_COMP_INFO_HEADER_UNDERLINE_PRIV);       
        wprintf(L"\n%s\n%s\n", LPCTSTR(idsCompInfoHeaderPriv1), 
                               LPCTSTR(idsCompInfoHeaderPriv2));
    }

    return;
}


/*========================================================

DisplayOutgoingQueues

    Display outgoing queues list on requested computer  

========================================================*/
bool
DisplayOutgoingQueues(
           LPWSTR wcsComputerName, 
           CALPWSTR wcspOutgoingQueues, 
           LPWSTR wcsParam
           )
{   
    if(wcspOutgoingQueues.cElems == 0)
    {
        static CResourceString idsNoOutgoingQueues(IDS_NO_OUTGOING_QUEUES);
        wprintf(L"\n%s\n", LPWSTR(idsNoOutgoingQueues));
        return false;
    }

    static CResourceString idsArgNameOnly(IDS_PARAM_NAME_ONLY);
    DWORD dwDisplayFlag = 0;

    if(CompareStringsNoCaseUnicode(LPCTSTR(idsArgNameOnly), wcsParam) == 0)
    {
        dwDisplayFlag = x_dwDisplayNameOnly;
    }
    
    CALPWSTR wcspNextHops; 
    LPWSTR wcsNextHop;
    LPWSTR wcsPathName;     
    LPWSTR wcsState;
    MQMGMTPROPS mqQueueProps;
    MGMTPROPID aQPropId[50];
    MQPROPVARIANT aQPropVar[50];

    WCHAR wcsNullString[] = L"";

    ULONG ulTotalMessageCount = 0;	
    ULONG ulMessageCount;
	ULONG i;
    DWORD dwNumberOfQueues = 0;
    bool fResult;

	for (i=0; i < wcspOutgoingQueues.cElems; ++i)
	{		    		    			                   
        fResult = GetQueueProps(&mqQueueProps, 
                               aQPropId,
                               aQPropVar,
                               wcsComputerName, 
                               wcspOutgoingQueues.pElems[i]);
        if(fResult == false)
        {
            return false;
        }

        if(wcscmp((mqQueueProps.aPropVar[PROPID_MGMT_QUEUE_TYPE_POSITION]).pwszVal, 
                   MGMT_QUEUE_TYPE_PRIVATE) == 0  
                   &&
           wcscmp((mqQueueProps.aPropVar[PROPID_MGMT_QUEUE_STATE_POSITION]).pwszVal,
                   MGMT_QUEUE_STATE_LOCAL) == 0)
        {
            continue;                                   // Do not display private-local queues
        }                                               

        ++dwNumberOfQueues;                               // Count the queues displayed

        if(dwNumberOfQueues == 1)                         // Display header only on first time
        {
            DisplayOutgoingQueuesHeader(dwDisplayFlag);
        }

        wcsPathName = (mqQueueProps.aPropVar[PROPID_MGMT_QUEUE_PATHNAME_POSITION]).pwszVal;           
        ulMessageCount = (mqQueueProps.aPropVar[PROPID_MGMT_QUEUE_MESSAGE_COUNT_POSITION]).ulVal;
        wcsState = (mqQueueProps.aPropVar[PROPID_MGMT_QUEUE_STATE_POSITION]).pwszVal;   
        wcspNextHops = (mqQueueProps.aPropVar[PROPID_MGMT_QUEUE_NEXTHOPS_POSITION]).calpwstr;
                    
        if((mqQueueProps.aPropVar[PROPID_MGMT_QUEUE_PATHNAME_POSITION]).vt == 1)
            // Display format name if no pathname retrieved
        {
            wcsPathName = wcspOutgoingQueues.pElems[i];
        }             
                    
        DWORD j;
        for(j = 0; aStateTranslator[j].wcsState != NULL; ++j)
        {
            if(wcscmp(wcsState, aStateTranslator[j].wcsState) == 0)
            {                
                CResourceString idsState(aStateTranslator[j].dwIds);
                wcscpy(wcsState, LPWSTR(idsState));
                break;
            }
        }
        
        ulTotalMessageCount += ulMessageCount;
        
        switch(wcspNextHops.cElems)
        {
        case 0:
            wcsNextHop = wcsNullString;
            break;
        case 1:
            wcsNextHop = wcspNextHops.pElems[0];
            break;
        default:                                    // Display only first next hop 
            wcsNextHop = wcspNextHops.pElems[0];
            wcscpy(wcsNextHop + wcslen(wcsNextHop), L" ...");
        }

        if(dwDisplayFlag == x_dwDisplayNameOnly)
        {
            wprintf(L"%s\n", wcsPathName);
        }
        else
        {
            // Cut off format name or path name to tablesize
            if(wcslen(wcsPathName) > IDS_FORMAT_NAME_MAX_LEN)
            {
                wcsPathName[IDS_FORMAT_NAME_MAX_LEN] = L'\0';
            }
            
            static CResourceString idsPublicInfoLine(IDS_PUBLIC_INFO_LINE);
            wprintf(idsPublicInfoLine, wcsPathName, ulMessageCount, 
                    wcsState, wcsNextHop); 
        }
	}

    if(dwNumberOfQueues == 0)
    {
        static CResourceString idsNoOutgoingQueues(IDS_NO_OUTGOING_QUEUES);
        wprintf(L"\n%s\n", LPWSTR(idsNoOutgoingQueues));
        return false;
    }
    wprintf(L"\n%s %ld", LPWSTR(idsTotalMessageCount), ulTotalMessageCount);       

    MQFreeMemory(aQPropVar[PROPID_MGMT_QUEUE_PATHNAME_POSITION].pwszVal);
    MQFreeMemory(aQPropVar[PROPID_MGMT_QUEUE_TYPE_POSITION].puuid);
 
    return true;
}


/*========================================================

GetPrivateQueuePropertiesFromDS

    Get message count property on private queue from DS  

========================================================*/
bool
GetPrivateQueuePropertiesFromDS(
              CALPWSTR wcspPrivateQueues,
              LPWSTR pwzQueueName,
              DWORD cQProp,
              QUEUEPROPID* aQPropId,
              PROPVARIANT* aQPropVar,
              ULONG* pulMessageCount,
              ULONG i
              )
{              
    MQQUEUEPROPS mqQueueProps;
    mqQueueProps.cProp = cQProp;
    mqQueueProps.aPropID = aQPropId;
    mqQueueProps.aPropVar = aQPropVar;

    WCHAR wcsFormatName[x_dwMaxStringSize];
    DWORD dwFormatNameLen = x_dwMaxStringSize;
    wcscpy(pwzQueueName, wcspPrivateQueues.pElems[i]);

    HRESULT hr;
    if(wcsstr(pwzQueueName, L"=") == 0)
    {
        hr = MQPathNameToFormatName(pwzQueueName, wcsFormatName, &dwFormatNameLen);
        if (FAILED(hr))
        {   
            return false;
        }                            
    } 
    else
    {
        wcscpy(wcsFormatName, pwzQueueName);
    }
    GenerateQueueName(wcsFormatName);
    
    hr = MQGetQueueProperties(wcsFormatName, &mqQueueProps);
    if (FAILED(hr))
    { 
        *pulMessageCount = 0;
        return true;
    }
    *pulMessageCount = (mqQueueProps.aPropVar[0]).ulVal;

    return true;
}


/*========================================================

DisplayPrivateQueues

    Display private queues list on requested computer  

========================================================*/
bool
DisplayPrivateQueues(
          LPWSTR pwzComputerName, 
          CALPWSTR wcspPrivateQueues, 
          LPWSTR wcsParam
          )
{    
    if(wcspPrivateQueues.cElems == 0)                   // No private queues to display
    {
        static CResourceString idsNoPrivateQueues(IDS_NO_PRIVATE_QUEUES);
        wprintf(L"\n%s\n", idsNoPrivateQueues);
        return false;
    }
      
    static CResourceString idsPrivateQueues(IDS_PRIVATE_QUEUES);
    static CResourceString idsArgNameOnly(IDS_PARAM_NAME_ONLY);
    
    DWORD dwDisplayFlag = 0;

    if(CompareStringsNoCaseUnicode(LPCTSTR(idsArgNameOnly), wcsParam) == 0)
    {
        dwDisplayFlag = x_dwDisplayNameOnly;            // set the flag for wide queuename list
    }

    wprintf(L"%s\n", LPCTSTR(idsPrivateQueues));
    
    DisplayPrivateQueuesHeader(dwDisplayFlag);

	WCHAR wcsQueueName[x_dwMaxStringSize];
    LPWSTR wcsMachineName; 
    ULONG ulMessageCount; 
    ULONG ulTotalMessageCount = 0;   
    ULONG i;           
    MQMGMTPROPS mqMgmtProps;
    MGMTPROPID aQPropId[x_dwMaxNoOfProperties];
    MQPROPVARIANT aQPropVar[x_dwMaxNoOfProperties];
    DWORD cQProp;

    wcsQueueName[0] = L'\0';
    if(wcscmp(pwzComputerName, g_wcsLocalComputerName) == 0)
    {
        wcsMachineName = NULL;
    }
    else
    {
        wcsMachineName = pwzComputerName;
    }

	for (i=0; i < wcspPrivateQueues.cElems; i++)
	{		    		    			                   
        cQProp = 0;

        aQPropId[cQProp] = PROPID_MGMT_QUEUE_MESSAGE_COUNT;
        aQPropVar[cQProp].vt = VT_NULL;
        ++cQProp;
                  
        mqMgmtProps.cProp = cQProp;
        mqMgmtProps.aPropID = aQPropId;
        mqMgmtProps.aPropVar = aQPropVar;

        ASSERT(wcslen(wcspPrivateQueues.pElems[i]));
 
        wcscpy(wcsQueueName, wcspPrivateQueues.pElems[i]);
        GenerateQueueName(wcsQueueName);
       
	    HRESULT hr;
        hr = MQMgmtGetInfo(wcsMachineName, wcsQueueName, &mqMgmtProps);            

        if (FAILED(hr))
        {
            // Get message count from DS
            bool fResult; 
            fResult = GetPrivateQueuePropertiesFromDS(wcspPrivateQueues,
                                                      wcsQueueName,
                                                      cQProp,
                                                      aQPropId,
                                                      aQPropVar,
                                                      &ulMessageCount,
                                                      i);
            if(fResult == false)
            {
                continue;
            }
        }
        else
        {
            ulMessageCount = (mqMgmtProps.aPropVar[0]).ulVal;            
        }

        ulTotalMessageCount += ulMessageCount;

        if(dwDisplayFlag == x_dwDisplayNameOnly)
        {
            wprintf(L"%s\n", wcspPrivateQueues.pElems[i]);
        }
        else
        {
            if(wcslen(wcspPrivateQueues.pElems[i]) > 61)
            {
                (wcspPrivateQueues.pElems[i])[61] = L'\0';
            }

            wprintf(L"%-62s   %12ld\n", wcspPrivateQueues.pElems[i], ulMessageCount);
        }
    }
    wprintf(L"\n%s %ld", LPWSTR(idsTotalMessageCount), ulTotalMessageCount);       

    return true;
}


/*========================================================

GetPublicQueueMessageCountFromCache

  Called because message count property can't be 
  retrieved from DS

========================================================*/
ULONG
GetPublicQueueMessageCountFromCache(
                    LPWSTR pwzQueueName,
                    LPWSTR pwzComputerName
                    )
{
	MQMGMTPROPS mqQueueProps;
    MGMTPROPID aQPropId[x_dwMaxNoOfProperties];
    MQPROPVARIANT aQPropVar[x_dwMaxNoOfProperties];
    DWORD cQProp;

    cQProp = 0;

    aQPropId[PROPID_MGMT_QUEUE_MESSAGE_COUNT_POSITION_2] = PROPID_MGMT_QUEUE_MESSAGE_COUNT;
    aQPropVar[PROPID_MGMT_QUEUE_MESSAGE_COUNT_POSITION_2].vt = VT_NULL;
    ++cQProp;
    
    mqQueueProps.cProp = cQProp;
    mqQueueProps.aPropID = aQPropId;
    mqQueueProps.aPropVar = aQPropVar;
    
    WCHAR wcsFormatName[x_dwMaxStringSize];
    wcscpy(wcsFormatName, pwzQueueName);
    GenerateFormatName(wcsFormatName);      

	HRESULT hr;
    hr = MQMgmtGetInfo(pwzComputerName, wcsFormatName, &mqQueueProps);            
    if (FAILED(hr))
    {
        return 0;
    }
    return (mqQueueProps.aPropVar[0].ulVal);
}


/*========================================================

DisplayPublicQueuesFromCache

  Called when information retrieval from DS
  is unavailable

========================================================*/
bool
DisplayPublicQueuesFromCache(
          LPWSTR wcsComputerName,
          CALPWSTR wcspOutgoingQueues,
          LPWSTR wcsParam
          )
{
    if(wcspOutgoingQueues.cElems == 0)
    {
        static CResourceString idsNoPublicQueues(IDS_NO_PUBLIC_QUEUES);
        wprintf(L"\n%s\n", LPWSTR(idsNoPublicQueues));
        return false;
    }
    
    static CResourceString idsOutgoingQueues(IDS_OUTGOING_QUEUES);
    static CResourceString idsArgNameOnly(IDS_PARAM_NAME_ONLY);
    DWORD dwDisplayFlag = 0;

    if(CompareStringsNoCaseUnicode(LPCTSTR(idsArgNameOnly), wcsParam) == 0)
    {
        dwDisplayFlag = x_dwDisplayNameOnly;
    }
    

    WCHAR wcsQueueName[x_dwMaxStringSize];
    LPWSTR wcsPathName;    
    ULONG ulMessageCount;
    ULONG ulTotalMessageCount = 0;   
	MQMGMTPROPS mqQueueProps;
    ULONG i;             // Because wcspOutgoingQueues.cElems is ULONG
    MGMTPROPID aQPropId[50];
    MQPROPVARIANT aQPropVar[50];
    DWORD dwNumberOfQueues = 0;
    bool fResult;
    wcsQueueName[0] = L'\0';

	for (i=0; i < wcspOutgoingQueues.cElems; ++i)
	{		    		    			                   
        wcscpy(wcsQueueName, wcspOutgoingQueues.pElems[i]);
        fResult = GetQueueProps(&mqQueueProps, 
                               aQPropId,
                               aQPropVar,
                               wcsComputerName,
                               wcsQueueName);
        if(fResult == false)
        {
            return false;
        }
        if(wcscmp((mqQueueProps.aPropVar[PROPID_MGMT_QUEUE_TYPE_POSITION]).pwszVal,
                   MGMT_QUEUE_TYPE_PUBLIC) ||
           wcscmp((mqQueueProps.aPropVar[PROPID_MGMT_QUEUE_STATE_POSITION]).pwszVal, 
                   MGMT_QUEUE_STATE_LOCAL))
        {
            continue;                                   // Do not display non-public-local queues
        }                                               

        ++dwNumberOfQueues;                               // Count the queues displayed
        
        
        if(dwNumberOfQueues == 1)                         // Display header on first time only
        {
            static CResourceString idsPublicQueues(IDS_PUBLIC_QUEUES);
            wprintf(L"%s\n", LPCTSTR(idsPublicQueues));

            DisplayPrivateQueuesHeader(dwDisplayFlag);
        }


        wcsPathName = (mqQueueProps.aPropVar[PROPID_MGMT_QUEUE_PATHNAME_POSITION]).pwszVal;           
        ulMessageCount = (mqQueueProps.aPropVar[PROPID_MGMT_QUEUE_MESSAGE_COUNT_POSITION]).ulVal;
        ulTotalMessageCount += ulMessageCount;
             
        if((mqQueueProps.aPropVar[PROPID_MGMT_QUEUE_PATHNAME_POSITION]).vt == 1)
            // Display format name if no pathname retrieved
        {
            wcsPathName = wcspOutgoingQueues.pElems[i];
        }             

        if(dwDisplayFlag == x_dwDisplayNameOnly)
        {
            wprintf(L"%s\n", wcsPathName);
        }
        else
        {
            // Cut off format name or path name to tablesize
            if(wcslen(wcsPathName) > 61)
            {
                wcsPathName[61] = L'\0';
            }
                                       
            wprintf(L"%-62s   %12ld\n", wcsPathName, ulMessageCount);
        }
	}
    
    if(dwNumberOfQueues == 0)
    {
        static CResourceString idsNoOutgoingQueues(IDS_NO_OUTGOING_QUEUES);
        wprintf(L"\n%s\n", LPWSTR(idsNoOutgoingQueues));
        return false;
    }
    wprintf(L"\n%s %ld", LPWSTR(idsTotalMessageCount), ulTotalMessageCount);       
  
    MQFreeMemory(aQPropVar[PROPID_MGMT_QUEUE_PATHNAME_POSITION].pwszVal);
    MQFreeMemory(aQPropVar[PROPID_MGMT_QUEUE_TYPE_POSITION].puuid);
  
    return true;
}


/*========================================================

DisplayPublicQueuesFromDSPrint

  Does the printing part for DisplayPublicQueuesFromDS(), 
  using MQLocateNext()

========================================================*/
void
DisplayPublicQueuesFromDSPrint(
                 LPWSTR wcsComputerName, 
                 HANDLE hEnum,
                 DWORD dwColumnCount,
                 DWORD dwDisplayFlag
                 )
{
    PROPVARIANT aPropVar[x_dwMaxNoOfProperties];
    LPWSTR pwzQueueName;
    ULONG ulMessageCount;
    DWORD cProps;
    DWORD i;
    bool fFirstEntry = true;
    HRESULT hr;
    
    do
    {
        cProps = x_dwMaxNoOfProperties;    
        hr = MQLocateNext(hEnum, &cProps, aPropVar);
        if (FAILED(hr))
        {
            break;
        }

        for(i = 0; i < cProps; i += dwColumnCount)
        {           
            if(i == 0 && fFirstEntry == true)               // Display header on first time only
            {
                static CResourceString idsPublicQueues(IDS_PUBLIC_QUEUES);
                wprintf(L"%s\n", LPCTSTR(idsPublicQueues));
 
                DisplayPrivateQueuesHeader(dwDisplayFlag);

                fFirstEntry = false;
            }

            pwzQueueName = aPropVar[i].pwszVal;         // a destructive assignment

            if(dwDisplayFlag == x_dwDisplayNameOnly)
            {
                wprintf(L"%s\n", pwzQueueName);
            }
            else
            {
                ulMessageCount = GetPublicQueueMessageCountFromCache(
                                                            pwzQueueName,
                                                            wcsComputerName);
                if(wcslen(pwzQueueName) > 61)
                {
                    pwzQueueName[61] = L'\0';
                }

                wprintf(L"%-62s   %12ld\n", pwzQueueName, ulMessageCount);
            }
        }
    } 
    while (cProps > 0);

    return;
}


/*========================================================

DisplayPublicQueuesFromDS

    Display public queues list on requested computer  

========================================================*/
bool
DisplayPublicQueuesFromDS(
         LPWSTR wcsComputerName, 
         LPWSTR wcsParam
         )
{                                
    static CResourceString idsArgNameOnly(IDS_PARAM_NAME_ONLY);
 
    DWORD dwDisplayFlag = 0;
    if(CompareStringsNoCaseUnicode(LPCTSTR(idsArgNameOnly), wcsParam) == 0)
    {
        dwDisplayFlag = x_dwDisplayNameOnly;
    }
    
    GUID guidMachineId;
    bool fResult; 
    
    //
    // Get computer ID. Used later for MQLocateBegin.
    //
    fResult = GetComputerGuid(wcsComputerName, &guidMachineId);
    if(fResult == false)
    {
        return false;
    }

    //
    // Locating public queues on requested computer
    //
    MQPROPERTYRESTRICTION aPropRestriction[x_dwMaxNoOfProperties];
    ULONG cRes = 0;

    aPropRestriction[cRes].rel = PREQ;
    aPropRestriction[cRes].prop = PROPID_Q_QMID;
    aPropRestriction[cRes].prval.vt = VT_CLSID;
    aPropRestriction[cRes].prval.puuid = &guidMachineId;
    ++cRes;
    
    MQRESTRICTION mqRestriction;

    mqRestriction.cRes = cRes; 
    mqRestriction.paPropRes = aPropRestriction;

    QUEUEPROPID aPropId[x_dwMaxNoOfProperties];
    DWORD dwColumnCount = 0;
    
    aPropId[dwColumnCount] = PROPID_Q_PATHNAME; 
    dwColumnCount++;

    MQCOLUMNSET Column;

    Column.cCol = dwColumnCount;
    Column.aCol = aPropId;

    HANDLE hEnum;
    HRESULT hr;
    hr = MQLocateBegin(NULL,   
                       &mqRestriction,   
                       &Column,
                       NULL,
                       &hEnum);     
    if(FAILED(hr))
    {        
        return false;
    }

    DisplayPublicQueuesFromDSPrint(wcsComputerName, hEnum, dwColumnCount, dwDisplayFlag);

    MQLocateEnd(hEnum);

    return true;
}


/*========================================================

DisplayPublicQueues

========================================================*/
bool
DisplayPublicQueues(
         LPWSTR wcsComputerName, 
         CALPWSTR wcspOutgoingQueues, 
         LPWSTR wcsParam
         )
{
    bool fResult;
    fResult = DisplayPublicQueuesFromDS(wcsComputerName, 
                                        wcsParam);    
    if(fResult == false)
    {
        fResult = DisplayPublicQueuesFromCache(wcsComputerName, 
                                               wcspOutgoingQueues, 
                                               wcsParam);
    }

    return fResult;
}


/*========================================================

GetComputerPropsDisplayConnection

========================================================*/
void
GetComputerPropsDisplayConnection(MQMGMTPROPS mqProps, LPWSTR wcsComputerName)
{
    if(wcscmp((mqProps.aPropVar[2]).pwszVal, MSMQ_CONNECTED) == 0)                    
    {
        if((mqProps.aPropVar[PROPID_MGMT_MSMQ_DSSERVER_POSITION]).vt != 1)
        {
            static CResourceString idsComputerPropsConnected1(IDS_COMPUTER_PROPS_CONNECTED1);
            wprintf(idsComputerPropsConnected1, 
                    wcsComputerName, 
                    (mqProps.aPropVar[PROPID_MGMT_MSMQ_DSSERVER_POSITION]).pwszVal);
        }
        else
        {
            static CResourceString idsComputerPropsConnected2(IDS_COMPUTER_PROPS_CONNECTED2);
            wprintf(idsComputerPropsConnected2, wcsComputerName);
        }
    }

    else if(wcscmp((mqProps.aPropVar[PROPID_MGMT_MSMQ_CONNECTED_POSITION]).pwszVal,
                    MSMQ_DISCONNECTED) == 0)                    
    {
        static CResourceString idsComputerPropsDisconnected(IDS_COMPUTER_PROPS_DISCONNECTED);
        wprintf(idsComputerPropsDisconnected, wcsComputerName); 
    }
    
    else
    {
        static CResourceString idsComputerPropsUnknown(IDS_CONNECTION_STATE_UNKNOWN);
        wprintf(idsComputerPropsUnknown, wcsComputerName);
    }

    return;
}


/*========================================================

GetComputerPropsFreeMemory
  
    Frees memory allocated by ComputerProps function

========================================================*/
bool
GetComputerPropsFreeMemory(MQPROPVARIANT* aPropVar)
{
    int i;
    int elements;

    elements = aPropVar[PROPID_MGMT_MSMQ_ACTIVEQUEUES_POSITION].calpwstr.cElems;
    for(i=0; i < elements; ++i)
    {
        MQFreeMemory(aPropVar[PROPID_MGMT_MSMQ_ACTIVEQUEUES_POSITION].calpwstr.pElems[i]);
    }

    elements = aPropVar[PROPID_MGMT_MSMQ_PRIVATEQ_POSITION].calpwstr.cElems;
    for(i=0; i < elements; ++i)
    {
        MQFreeMemory(aPropVar[PROPID_MGMT_MSMQ_PRIVATEQ_POSITION].calpwstr.pElems[i]);
    }

    MQFreeMemory(aPropVar[PROPID_MGMT_MSMQ_CONNECTED_POSITION].pwszVal);
    MQFreeMemory(aPropVar[PROPID_MGMT_MSMQ_DSSERVER_POSITION].pwszVal);
    MQFreeMemory(aPropVar[PROPID_MGMT_MSMQ_TYPE_POSITION].pwszVal);

    return true;
}


/*========================================================

GetComputerPropsDisplay
  
    Gets and prints computer properties 

========================================================*/
bool
GetComputerPropsDisplay(
              MQMGMTPROPS mqProps,
              LPWSTR pwzComputerName,
              DWORD dwTypeOfQueues,
              LPWSTR pwzParam
              )
{
    GetComputerPropsDisplayConnection(mqProps, pwzComputerName);

	bool fResult = false;

    switch (dwTypeOfQueues)
    {
    case OUTGOING:
        fResult = DisplayOutgoingQueues(
                        pwzComputerName, 
                        (mqProps.aPropVar[PROPID_MGMT_MSMQ_ACTIVEQUEUES_POSITION]).calpwstr,
                        pwzParam);
        break;

    case PRIVATE:
        fResult = DisplayPrivateQueues(
                        pwzComputerName, 
                        (mqProps.aPropVar[PROPID_MGMT_MSMQ_PRIVATEQ_POSITION]).calpwstr,
                        pwzParam);
        break;

    case PUBLIC:
        fResult = DisplayPublicQueues(
                        pwzComputerName, 
                        (mqProps.aPropVar[PROPID_MGMT_MSMQ_ACTIVEQUEUES_POSITION]).calpwstr,
                        pwzParam);
        break;

    case COMP_INFO:
        wprintf(L"\n%s", (mqProps.aPropVar[PROPID_MGMT_MSMQ_TYPE_POSITION]).pwszVal);
        break;

    default:
        static CResourceString idsErrorDisplayingQueues(IDS_ERROR_DISPLAYING_QUEUES);
        wprintf(L"\n%s\n", LPWSTR(idsErrorDisplayingQueues));
        return false;
    }
    
    // Note: dwResult return value is not used.

    return true;
}



/*========================================================

GetComputerProps
  
    Gets and prints computer properties 

========================================================*/
bool
GetComputerProps(LPWSTR wcsComputerName, DWORD dwTypeOfQueues, LPWSTR wcsParam)
{       
    if(CheckParameter(wcsParam) == false)
	{
		return false;
	}

	MGMTPROPID aPropId[x_dwMaxNoOfProperties];          // Get computer properties
    MQPROPVARIANT aPropVar[x_dwMaxNoOfProperties];
    DWORD cProp = 0;

    aPropId[PROPID_MGMT_MSMQ_ACTIVEQUEUES_POSITION] = PROPID_MGMT_MSMQ_ACTIVEQUEUES;  
    aPropVar[PROPID_MGMT_MSMQ_ACTIVEQUEUES_POSITION].vt = VT_NULL;
    ++cProp;
 
    aPropId[PROPID_MGMT_MSMQ_PRIVATEQ_POSITION] = PROPID_MGMT_MSMQ_PRIVATEQ; 
    aPropVar[PROPID_MGMT_MSMQ_PRIVATEQ_POSITION].vt = VT_NULL;
    ++cProp;
    
    aPropId[PROPID_MGMT_MSMQ_CONNECTED_POSITION] = PROPID_MGMT_MSMQ_CONNECTED;
    aPropVar[PROPID_MGMT_MSMQ_CONNECTED_POSITION].vt = VT_NULL;
    ++cProp;

    aPropId[PROPID_MGMT_MSMQ_DSSERVER_POSITION] = PROPID_MGMT_MSMQ_DSSERVER;
    aPropVar[PROPID_MGMT_MSMQ_DSSERVER_POSITION].vt = VT_NULL;
    ++cProp;
    
    aPropId[PROPID_MGMT_MSMQ_TYPE_POSITION] = PROPID_MGMT_MSMQ_TYPE;
    aPropVar[PROPID_MGMT_MSMQ_TYPE_POSITION].vt = VT_NULL;
    ++cProp;

    MQMGMTPROPS mqProps;
    mqProps.cProp = cProp;
    mqProps.aPropID = aPropId;
    mqProps.aPropVar = aPropVar;
       
    HRESULT hr;
	hr = MQMgmtGetInfo(wcsComputerName, MO_MACHINE_TOKEN, &mqProps);     
    if(FAILED(hr))
    {          
        CfErrorToString(hr);       
        return false;
    }

    bool fResult = GetComputerPropsDisplay(mqProps,
                                       wcsComputerName,
                                       dwTypeOfQueues,
                                       wcsParam);
  
    GetComputerPropsFreeMemory(aPropVar);

    return fResult;
}


/*========================================================

ParseCmdLineQueueHandleQueueName

  Handles given queue name (e.g. with spaces)

========================================================*/
bool
ParseCmdLineQueueHandleQueueName(
             int argc,
	         WCHAR *argv[],
             LPWSTR pwzQueueName,
             int *param
             )
{   
    if(wcslen(argv[x_dwCmdLineQueueName]) == 0)
    {
        return false;
    }

    int i;

    if(wcsstr(argv[x_dwCmdLineQueueName], L"\""))
    {
        swprintf(pwzQueueName, L"%s ", argv[x_dwCmdLineQueueName] + 1);
        int len;
        len = wcslen(pwzQueueName);

		if(wcsstr(pwzQueueName, L"\""))
            //
            // A quoted queue name without spaces
            //
        {            
            i = x_dwCmdLineQueueName;
            pwzQueueName[len - 2] = L'\0';
        }

        else
        {
            if(argc == x_dwCmdLineQueueName + 1)
                // No matching closing quotes were found
            {
                return false;
            }

            for(i = x_dwCmdLineQueueName + 1; wcsstr(argv[i], L"\"") == 0; ++i)
	        {			
                if(i == argc - 1)
                    // No matching closing quotes were found
                {
                    return false;
                }
		        swprintf(pwzQueueName+len, L"%s ", argv[i]);
		        len += wcslen(argv[i]) + 1;
	        }
		    swprintf(pwzQueueName+len, L"%s", argv[i]);            
		    len += wcslen(argv[i]);
            pwzQueueName[--len] = L'\0';
        }
    }
    else
    {
        i = x_dwCmdLineQueueName;
        swprintf(pwzQueueName, L"%s", argv[i]);	
    }

    *param = ++i;

    return true;
}


/*========================================================

ParseCmdLineQueue

  Decodes arguments

========================================================*/
bool
ParseCmdLineQueue(
	 int argc,
	 WCHAR *argv[]
	 )        
{       
    static CResourceString idsArgPause(IDS_PARAM_PAUSE);
    static CResourceString idsArgResume(IDS_PARAM_RESUME);   
    WCHAR wcsQueueName[x_dwMaxStringSize];
    int param;
    bool fResult;

    wcsQueueName[0] = L'\0';

	//
	// If a Queue Name contains spaces, it must be quoted.
	//
		
	fResult = ParseCmdLineQueueHandleQueueName(argc,
	                                          argv,
                                              wcsQueueName,
                                              &param);
    if(fResult == false)
    {
        return fResult;
    }
	
    fResult = false;
    if(param < argc)                                    // Get "action" parameter
    {
        if(CompareStringsNoCaseUnicode(LPCTSTR(idsArgPause), argv[param]) == 0)
        {
		    GenerateQueueName(wcsQueueName);
	        fResult = Action(argv[x_dwCmdLineComputerName], wcsQueueName, x_dwActPause);           
        }

        else if(CompareStringsNoCaseUnicode(LPCTSTR(idsArgResume), argv[param]) == 0)
        {
		    GenerateQueueName(wcsQueueName);
	        fResult = Action(argv[x_dwCmdLineComputerName], wcsQueueName, x_dwActResume);
        }
    }
	else 
	{	
		fResult = DisplayQueueProps(argv[x_dwCmdLineComputerName], wcsQueueName);
	}

    return fResult;										// Value returned has no meaning
}


/*========================================================

ParseCmdLineConnect

  Decodes arguments

========================================================*/
bool 
ParseCmdLineConnect(
	 int argc,
	 WCHAR *argv[]
	 )        
{   
    bool fResult;
    WCHAR wcsNullString[1];
    wcscpy(wcsNullString, L"");
    
	fResult = false;
    if(argc <= x_dwCmdLineDisplayParam)
    {
        argv[x_dwCmdLineDisplayParam] = wcsNullString; 
    }
    
    if(argc == x_dwMinNumberOfParams)
    {
        fResult = GetComputerProps(argv[2], COMP_INFO, argv[4]);
        return fResult;
    }    

    if(argc < x_dwMaxNumberOfParams)
	{	
		if(CompareStringsNoCaseUnicode(LPCTSTR(idsArgOutQ), argv[x_dwCmdLineQueueParam]) 
																				   == 0)
		{                             
			fResult = GetComputerProps(argv[x_dwCmdLineComputerName], 
								   OUTGOING, argv[x_dwCmdLineDisplayParam]);                             
		}
    
		else if(CompareStringsNoCaseUnicode(LPCTSTR(idsArgPrivQ), argv[x_dwCmdLineQueueParam]) 
																						 == 0)
		{
			fResult = GetComputerProps(argv[x_dwCmdLineComputerName], 
				                   PRIVATE, argv[x_dwCmdLineDisplayParam]);			
		}
    
		else if(CompareStringsNoCaseUnicode(LPCTSTR(idsArgPubQ), argv[x_dwCmdLineQueueParam])
																						== 0)             
		{  
			fResult = GetComputerProps(argv[x_dwCmdLineComputerName], 
				                   PUBLIC, argv[x_dwCmdLineDisplayParam]);
		}
	}

    if(CompareStringsNoCaseUnicode(LPCTSTR(idsArgQueue), argv[x_dwCmdLineQueueParam]) 
																				== 0)          
	{  
        fResult = ParseCmdLineQueue(argc, argv);			// Value returned here has no meaning
    }

    if(fResult == false)
	{
		DisplayIncorrectParams();
	}

    return fResult;
}


/*========================================================

ParseCmdLineAction

    Decodes arguments

========================================================*/
bool
ParseCmdLineAction(	 
     int argc,
	 WCHAR *argv[]
	 )        
{    
    if(argc > 3)
    {
        return false;
    }    

    if(CompareStringsNoCaseUnicode(LPCTSTR(idsArgOnline), argv[1]) == 0)
    {
		Action(argv[2], MO_MACHINE_TOKEN, x_dwActConnect);
        return true;
    }

    if(CompareStringsNoCaseUnicode(LPCTSTR(idsArgOffline), argv[1]) == 0)
	{			
	   Action(argv[2], MO_MACHINE_TOKEN, x_dwActDisconnect);
       return true;
	}

    return false;
}


/*========================================================

ParseCmdLine

  Decodes arguments

========================================================*/
bool 
ParseCmdLine(
	 int argc,
	 WCHAR *argv[]
	 )        
{
	bool fResult = false;
	DWORD dwInEnvironment = 0;

    if(argc < x_dwMinNumberOfParams)
    {
        return DisplayHelpFile(argv[1], dwInEnvironment);
    }
    else
    {   
        if(CompareStringsNoCaseUnicode(LPCTSTR(idsArgConnect), argv[1]) == 0) 
        {	 
			fResult = ParseCmdLineConnect(argc, argv);           
        }                      
        else
        {
            fResult = ParseCmdLineAction(argc, argv);
        }
    }

   	return fResult;
}


/*========================================================

EnvironmentCommandsConnect

    Deals with commands in msmqAdmin prompt environment
    which start with "connect" or with no parameters

========================================================*/
bool
EnvironmentCommandsConnect(
        int argc,
        WCHAR *argv[],
        LPWSTR wcsComputerName
        )
{ 
    bool fResult;
    WCHAR wcsConnect[x_dwMaxStringSize];
    wcscpy(wcsConnect, LPCTSTR(idsArgConnect));

    switch(argc)
    {
    case 1:                     
        // No parameters entered - get CURRENT COMPUTER properties    
        argv[1] = wcsConnect;
        argv[2] = wcsComputerName;
        argc = 3;
        break;
    case 2:
        // Only 'connect' parameter entered with no computername - 
        //                          get LOCAL COMPUTER properties
        argv[2] = g_wcsLocalComputerName;
        argc = 3;
        break;
    //default:
        // Pass parameters as they are                               
    }

    fResult = ParseCmdLine(argc, argv);                

    if(fResult == true)
    {
        wcscpy(wcsComputerName, argv[2]);  
    }

    return fResult;
}


/*========================================================

EnvironmentCommandsQueue

    Deals with commands in msmqAdmin prompt environment
    which start with "queue"

========================================================*/
bool
EnvironmentCommandsQueue(
        int argc,
        WCHAR *argv[],             
        LPWSTR wcsComputerName
        )
{ 
    DWORD i;
    WCHAR wcsConnect[x_dwMaxStringSize];
    wcscpy(wcsConnect, LPCTSTR(idsArgConnect));

    for(i = argc-1; i >= 1; --i)
    {
        argv[i+2] = argv[i];   
    }

    argv[1] = LPWSTR(idsArgConnect);
    argv[2] = wcsComputerName;
    argc += 2;
    
    return ParseCmdLine(argc, argv); 
}


/*========================================================

EnvironmentCommandsConnection

  Deals with request to connect or disconnect a computer

========================================================*/
bool
EnvironmentCommandsConnection(
					  int argc,
                      WCHAR *argv[],
                      LPWSTR wcsComputerName
                      )
{
	if(argc == 2)
	{
		argv[x_dwCmdLineComputerName] = wcsComputerName;
		argc = 3;
	}

    return ParseCmdLine(argc, argv); 
}


/*========================================================

EnvironmentCommandsFirstParsing

    Deals with commands in msmqAdmin prompt environment

========================================================*/
bool
EnvironmentCommandsFirstParsing(
                   int argc,
                   WCHAR* argv[],
                   LPWSTR wcsComputerName,
                   LPWSTR wcsParam
                   )
{
    if(argc == 1 || CompareStringsNoCaseUnicode(LPCTSTR(idsArgConnect), wcsParam) == 0)

     // Connect parameter entered
     // or no parameters entered
    {
        bool fResult;
        fResult = EnvironmentCommandsConnect(argc,
                                             argv,
                                             wcsComputerName);
        return true;
    }

    if(CompareStringsNoCaseUnicode(LPCTSTR(idsArgQueue), wcsParam) == 0 || 
       CompareStringsNoCaseUnicode(LPCTSTR(idsArgOutQ),  wcsParam) == 0 ||   
       CompareStringsNoCaseUnicode(LPCTSTR(idsArgPrivQ), wcsParam) == 0 ||   
       CompareStringsNoCaseUnicode(LPCTSTR(idsArgPubQ),  wcsParam) == 0)   
    { 
        EnvironmentCommandsQueue(argc,
                                 argv,
                                 wcsComputerName);
        return true;
    }
    
    if(CompareStringsNoCaseUnicode(LPCTSTR(idsArgOnline), wcsParam) == 0 ||
       CompareStringsNoCaseUnicode(LPCTSTR(idsArgOffline), wcsParam) == 0) 
    {
        EnvironmentCommandsConnection(argc,
                                      argv,
                                      wcsComputerName);
        return true;
    }
    
    return false;
}


/*========================================================

EnvironmentCommands

    Deals with commands in environment.
    Generates input into string vector, ready for
    ParseCmdLine() to parse

========================================================*/
void
EnvironmentCommands(void)
{   
    static CResourceString idsMsmqAdmin(IDS_MSMQADMIN); // for prompt
    static CResourceString idsQuit(IDS_QUIT);    

    LPWSTR wcsParam;
    WCHAR *argv[x_dwArgvSize];
                  
    WCHAR wcsComputerName[x_dwMaxStringSize];    
    DWORD adwLength[x_dwArgvSize];  
    int argc;
    bool fResult;
	DWORD dwInEnvironment = 1;
    DWORD i;
    // Environment initialization is to local computer    
    wcscpy(wcsComputerName, g_wcsLocalComputerName); 
    
    for(;;)                         // Getting command line arguments until 'quit' is entered
    {	
		WCHAR wcsCmdLine[x_dwMaxStringSize]; 
        wcsParam = NULL;
		for(i=0; i<x_dwArgvSize; ++i)
		{
			argv[i] = NULL;
			adwLength[i] = 0;
		}
		
		wprintf(L"\n%s %s>", LPWSTR(idsMsmqAdmin), wcsComputerName);
        _getws(wcsCmdLine);        
        
        argv[0] = wcsCmdLine;
        i=0;		
		do
        {	
			++i;
            adwLength[i] = GetFirstWord(argv[i-1] + adwLength[i-1], argv[i]); 			          
        }
        while(adwLength[i] > 0);

        argc = 1;
        for(i=1; i<x_dwArgvSize && adwLength[i]>0; ++i)					// Insert EOS
        {
            *(argv[i] + adwLength[i]) = 0;
            ++argc;
        }       
        
        wcsParam = argv[1];

        if(argc == 2) 
        {   
            if(CompareStringsNoCaseUnicode(LPCTSTR(idsQuit), wcsParam) == 0) 
            {            
                break;                                  // if 'quit' is entered                
            }
        
            if(DisplayHelpFile(wcsParam, dwInEnvironment) == true)
            {
                continue;
            }
        }
        fResult = EnvironmentCommandsFirstParsing(argc,                  
                                                  argv,
                                                  wcsComputerName,
                                                  wcsParam);
        if(fResult == false)
        {
            DisplayIncorrectParams();
        }
    }                                                   // End of "endless" for-loop
        
    return;
}    

     
/*========================================================

DetectDsConnection
  
    Check if local computer is connected to a DS

========================================================*/ 
bool DetectDsConnection(void)
{
    MQPRIVATEPROPS PrivateProps;
    QMPROPID       aPropId[x_dwMaxNoOfProperties];
    MQPROPVARIANT  aPropVar[x_dwMaxNoOfProperties];
    HRESULT        aStatus[x_dwMaxNoOfProperties];
    DWORD          cProp;
    
    HRESULT        hr;

    cProp = 0;

    aPropId[cProp] = PROPID_PC_DS_ENABLED;
    aPropVar[cProp].vt = VT_NULL;
    ++cProp;	

    PrivateProps.cProp = cProp;
	PrivateProps.aPropID = aPropId;
	PrivateProps.aPropVar = aPropVar;
    PrivateProps.aStatus = aStatus;

	hr = MQGetPrivateComputerInformation(
				     NULL,
					 &PrivateProps);
	if(FAILED(hr))
	{
        CfErrorToString(hr);        
        return false;
    }
	    
    if(PrivateProps.aPropVar[0].boolVal == 0)
        return false;
    

    return true;
}


/*========================================================

wmain
 
========================================================*/
int 
wmain(
     int argc,
     WCHAR *argv[] 
     )
{
    DWORD sz = x_dwMaxStringSize;
    GetComputerName(g_wcsLocalComputerName, &sz);
   
    g_hInstance = GetModuleHandle(NULL);                // Get a handle to this file

    if(DetectDsConnection() == false)                   // Check if in workgroup mode
    {
        static CResourceString idsWorkgroupMode(IDS_WORKGROUP_MODE);
        wprintf(L"%s\n", LPWSTR(idsWorkgroupMode));
        return 0;
    }
       
    if (argc != 1)
    {
        bool fResult;

        fResult = ParseCmdLine(argc, argv);
        if(fResult == true)
        {
            return 0;
        }
        return 1;
    }

    EnvironmentCommands();
    return 0;
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqattrib\verify.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    verify.cpp

Abstract:
	Verify that the schema contains the new msmq attributes
    

Author:

    ronith 11-Oct-99

--*/
#pragma warning(disable: 4201)

#include <windows.h>
#include <tchar.h>
#include <stdio.h>

#include "\msmq\src\inc\mqtempl.h"
#include "activeds.h"

BOOL VerifySchema(
        OUT WCHAR** ppwszSchemaContainer)
{
    HRESULT hr;
    R<IADs> pADs;
    BSTR      bstrSchemaNamingContext;
    VARIANT    varSchemaNamingContext;
    AP<WCHAR>       lpwszSchema;
    R<IADsContainer>    pADsContainer;
    ULONG cchSchemaPath;

    //
    // Bind to the RootDSE to obtain information about the schema container
    //
    hr = ADsGetObject(L"LDAP://RootDSE", IID_IADs, (void **)&pADs);
    if (FAILED(hr))
    {
        printf("Failed to bind to RootDSE,hr= %lx \n", hr);
        return FALSE;
    }

    //
    // Setting value to BSTR Schema
    //
    bstrSchemaNamingContext = TEXT("schemaNamingContext");
    //
    // Reading the schema name property
    //
    VariantClear(&varSchemaNamingContext);
    hr = pADs->Get(bstrSchemaNamingContext, &varSchemaNamingContext);
    if (FAILED(hr))
    {
        printf("Failed to read the schemaNamingContext, hr=%lx \n", hr);
        return FALSE;
    }
    *ppwszSchemaContainer =  varSchemaNamingContext.bstrVal;

    //
    // Build the ADsPath of the schema
    //
    cchSchemaPath = wcslen(L"LDAP://") + wcslen( varSchemaNamingContext.bstrVal) + 50;
    lpwszSchema = new WCHAR[cchSchemaPath+1];
    swprintf(lpwszSchema, L"LDAP://CN=MSMQ-Label-Ex,%ls", ((VARIANT &)varSchemaNamingContext).bstrVal);
    {
        R<IADs>pADsSchema;
        hr = ADsGetObject(lpwszSchema, IID_IADs, (void**)&pADsSchema);
    }
    if (FAILED(hr))
    {
        printf("Failed to read new attribute mSMQLabelEx, hr=%lx\n", hr);
        return FALSE;
    }
 
    swprintf(lpwszSchema, L"LDAP://CN=MSMQ-Computer-Type-Ex,%ls", ((VARIANT &)varSchemaNamingContext).bstrVal);
    {
        R<IADs>pADsSchema;
        hr = ADsGetObject(lpwszSchema, IID_IADs, (void**)&pADsSchema);
    }
    if (FAILED(hr))
    {
        printf("Failed to read new attribute mSMQComputerTypeEx, hr=%lx\n", hr);
        return FALSE;
    }

    swprintf(lpwszSchema, L"LDAP://CN=MSMQ-Site-Name-Ex,%ls", ((VARIANT &)varSchemaNamingContext).bstrVal);
    {
        R<IADs>pADsSchema;
        hr = ADsGetObject(lpwszSchema, IID_IADs, (void**)&pADsSchema);
    }
    if (FAILED(hr))
    {
        printf("Failed to read new attribute mSMQSiteNameEx, hr=%lx\n", hr);
        return FALSE;
    }

    printf("Verified that the schema contains the new attributes. \n");
    return TRUE;

}


HRESULT BindRootOfForest(
                    OUT void           *ppIUnk)
{
    HRESULT hr;
    R<IADsContainer> pDSConainer = NULL;

    hr = ADsGetObject(
            L"GC:",
            IID_IADsContainer,
            (void**)&pDSConainer);
    if FAILED((hr))
    {
        printf("BindRootOfForest failed to get object %lx\n", hr);
        return hr;
    }
    R<IUnknown> pUnk = NULL;
    hr =  pDSConainer->get__NewEnum(
            (IUnknown **)&pUnk);
    if FAILED((hr))
    {
        printf("BindRootOfForest failed to get enum %lx\n", hr);
        return hr;
    }

    R<IEnumVARIANT> pEnumerator = NULL;
    hr = pUnk->QueryInterface(
                    IID_IEnumVARIANT,
                    (void **)&pEnumerator);

    VARIANT varOneElement;
    VariantInit(&varOneElement);

    ULONG cElementsFetched;
    hr =  ADsEnumerateNext(
            pEnumerator,  //Enumerator object
            1,             //Number of elements requested
            &varOneElement,           //Array of values fetched
            &cElementsFetched  //Number of elements fetched
            );
    if (FAILED(hr))
    {
        printf("BindRootOfForest failed to enumerate next %lx\n", hr);
        return hr;
    }
    if ( cElementsFetched == 0)
    {
        printf("BindRootOfForest : enumeration returned 0 elements\n");
        return ERROR_DS_NO_RESULTS_RETURNED;
    }

    hr = ((VARIANT &)varOneElement).punkVal->QueryInterface(
            IID_IDirectorySearch,
            (void**)ppIUnk);
    if (FAILED(hr))
    {
        printf("BindRootOfForest failed to query interface %lx\n", hr);
    }

    return hr;

}


void FillSearchPrefs(
            OUT ADS_SEARCHPREF_INFO *pPrefs,        // preferences array
            OUT DWORD               *pdwPrefs)      // preferences counter
{
    HRESULT hr = ERROR_SUCCESS;
    ADS_SEARCHPREF_INFO *pPref = pPrefs;

    //  Search preferences: Attrib types only = NO

    pPref->dwSearchPref   = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
    pPref->vValue.dwType  = ADSTYPE_BOOLEAN;
    pPref->vValue.Boolean = FALSE;

    pPref->dwStatus       = ADS_STATUS_S_OK;
    (*pdwPrefs)++;
	pPref++;

    //  Asynchronous

    pPref->dwSearchPref   = ADS_SEARCHPREF_ASYNCHRONOUS;
    pPref->vValue.dwType  = ADSTYPE_BOOLEAN;
    pPref->vValue.Boolean = TRUE;

    pPref->dwStatus       = ADS_STATUS_S_OK;
    (*pdwPrefs)++;
	pPref++;

    // Do not chase referrals

    pPref->dwSearchPref   = ADS_SEARCHPREF_CHASE_REFERRALS;
    pPref->vValue.dwType  = ADSTYPE_INTEGER;
    pPref->vValue.Integer = ADS_CHASE_REFERRALS_NEVER;

    pPref->dwStatus       = ADS_STATUS_S_OK;
    (*pdwPrefs)++;
	pPref++;

    // Search preferences: Scope

    pPref->dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE; //ADS_SEARCHPREF
    pPref->vValue.dwType= ADSTYPE_INTEGER;
    pPref->vValue.Integer = ADS_SCOPE_SUBTREE;

    pPref->dwStatus = ADS_STATUS_S_OK;
    (*pdwPrefs)++;
	pPref++;

}

HRESULT  ReplaceLabelAttributes(
             LPCWSTR pwszQueueDN,
             LPCWSTR pwszQueueLabel,
             BOOL    fRemoveOldLabel
             )
{
    //
    //  Bind to the queue
    //
    AP<WCHAR> pwdsADsPath = new WCHAR [  wcslen(pwszQueueDN) + 10];
    swprintf(
        pwdsADsPath,
        L"LDAP://%s",
        pwszQueueDN);

    R<IADs> pAdsObj;
    HRESULT hr;

    hr = ADsGetObject(
            pwdsADsPath,
            IID_IADs,
            (void**)&pAdsObj);
    if (FAILED(hr))
    {
        return(hr);
    }
    //
    //  set new attribute with old attribute value, and 
    //  clear old attribute
    //
    VARIANT var;

    V_BSTR(&var) = SysAllocString(pwszQueueLabel);
    V_VT(&var) = VT_BSTR;
    hr = pAdsObj->Put( L"mSMQLabelEx", var ); 
    VariantClear(&var);
    if (FAILED(hr))
    {
        return(hr);
    }
    //
    //  the old label attribute is cleared, only if the user has requested so
    //
    if ( fRemoveOldLabel)
    {
        V_VT(&var) = VT_EMPTY;
        hr = pAdsObj->PutEx( ADS_PROPERTY_CLEAR,
                           L"mSMQLabel",
                           var);
        if (FAILED(hr))
        {
            return(hr);
        }
    }
    //
    // commit
    //
    hr = pAdsObj->SetInfo();

    return(hr);
}


HRESULT ConvertQueueLabels( IN LPCWSTR pwszSchemaContainer,
                            IN BOOL    fRemoveOldLabel,
                            IN BOOL    fOverwriteNewLabelIfSet
                            )
{
    //
    //  Bind to root of forest
    //
    R<IDirectorySearch> pDSSearch = NULL;

    HRESULT hr;

    hr = BindRootOfForest( &pDSSearch);

    if (FAILED(hr))
    {
        printf("Failed to bind to root of forest,hr=%lx\n",hr);
        return hr;
    }
    //
    //  Set search prefernces
    //
    ADS_SEARCHPREF_INFO prefs[15];
    DWORD dwNumPrefs = 0;
    FillSearchPrefs(prefs,
                    &dwNumPrefs);

    hr = pDSSearch->SetSearchPreference( prefs, dwNumPrefs);
    if (FAILED(hr))
    {
        printf("Failed to set search preference, hr=%lx\n",hr);
        return hr;
    }
    //
    //  Prepare query restriction, any queue with old label attribute set
    //
    WCHAR filter[1500];
    swprintf(
        filter,
        L"(&(objectCategory=CN=MSMQ-Queue,%s)(mSMQLabel=*))",
        pwszSchemaContainer);


    //
    //  Query all queues which have mSMQLabel attribute set
    //
    ADS_SEARCH_HANDLE   hSearch;
    LPWSTR pszAttr[] = { L"mSMQLabelEx",L"distinguishedName",L"mSMQLabel"};
    DWORD dwCount= sizeof(pszAttr)/sizeof(LPWSTR);
 

    hr = pDSSearch->ExecuteSearch(
                         filter,
                         pszAttr,
                         dwCount,
                        &hSearch);
    if (FAILED(hr))
    {
        printf("Failed to execute search, hr=%lx\n",hr);
        return hr;
    }
    //
    //  Go over the results
    //
    while (1)
    {
        //
        //  Get next result
        //
        hr = pDSSearch->GetNextRow(hSearch);

        if ( FAILED(hr) || (hr == S_ADS_NOMORE_ROWS))
        {
            if (hr !=  S_ADS_NOMORE_ROWS)
            {
                printf("Failed to get next result, hr=%lx\n",hr);
            }
            break;
        }

        //
        //  read the distingueshedName
        //
        ADS_SEARCH_COLUMN ColumnDN;
        hr = pDSSearch->GetColumn(
                     hSearch,
                     L"distinguishedName",
                     &ColumnDN);
        if (FAILED(hr))
        {
            printf("Failed to read distingueshedName value, hr=%lx\n", hr);
            continue;
        }
        // printf("Queue = %S\n", Column.pADsValues->DNString);
        
        //
        //  has the user asked to overwrite label if it is already set
        //  in the new label attribute
        //
        //
        // Ask for mSMQLabelEx, just to verify that it is not set
        //
        ADS_SEARCH_COLUMN Column;
        hr = pDSSearch->GetColumn(
                     hSearch,
                     L"mSMQLabelEx",
                     &Column);
        if ( FAILED(hr))
        {    
            
            if ( hr != E_ADS_COLUMN_NOT_SET)
            {
                printf("Failed to read mSMQLabel of queue '%S', hr =%lx. This queue is left as is\n", ColumnDN.pADsValues->DNString, hr);
                continue;
            }
        }
        else
        {
            //
            //  if the user didn't specify to overwrite queues where new label
            //  attribute is already set, then ignore the queue
            //
            if ( !fOverwriteNewLabelIfSet)
            {
                printf("LabelEx is SET in queue '%S'. This queue is left as is\n", ColumnDN.pADsValues->DNString);
                continue;
            }
        }

        //
        //  read the old label attribute 
        //
        ADS_SEARCH_COLUMN ColumnLabel;
        hr = pDSSearch->GetColumn(
                     hSearch,
                     L"mSMQLabel",
                     &ColumnLabel);
        if (FAILED(hr))
        {
            printf("Failed to read mSMQLabel value for queue '%S'. This queue is left as is, hr=%lx\n", 
                    ColumnDN.pADsValues->DNString, hr);
            pDSSearch->FreeColumn(&ColumnDN);
            continue;
        }

        //
        //  Set the old vale in the new attribute
        //
        hr = ReplaceLabelAttributes(
                   ColumnDN.pADsValues->DNString,
                   ColumnLabel.pADsValues->DNString,
                   fRemoveOldLabel
                   );
        if (FAILED(hr))
        {
            printf("Failed to update queue '%S', hr=%lx\n",  ColumnDN.pADsValues->DNString, hr);
        }

        pDSSearch->FreeColumn(&ColumnDN);
        pDSSearch->FreeColumn(&ColumnLabel);

    }


    printf("ConvertQueueLabels: completed\n");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqconfig\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mqconfig.rc
//
#define IDS_COMPUTER_PROPS              1
#define IDS_COMPUTER_PROPS_CONNECTED1   1
#define IDS_COMP_INFO_HEADER_TEXT       2
#define IDS_COMP_INFO_HEADER_UNDERLINE  3
#define IDS_COMP_TOT_MESSAGE_COUNT      4
#define IDS_TOTAL_MESSAGE_COUNT         4
#define IDS_PARAM_COMPUTER              5
#define IDS_PARAM_CONN                  5
#define IDS_PARAM_QUEUE                 6
#define IDS_PARAM_CONNECT               7
#define IDS_PARAM_ONLINE                7
#define IDS_PARAM_DISCONNECT            8
#define IDS_PARAM_OFFLINE               8
#define IDS_PARAM_PAUSE                 9
#define IDS_PARAM_RESUME                10
#define IDS_PARAM_LIST_PUBLIC           11
#define IDS_PARAM_LIST_PRIVATE          12
#define IDS_QUIT                        13
#define IDS_MESSAGE_ENTER_COMP_NAME     14
#define IDS_PARAM_NAME_ONLY             14
#define IDS_PRIVATE_QUEUES              15
#define IDS_OUTGOING_QUEUES             16
#define IDS_PUBLIC_QUEUES               17
#define IDS_COMP_INFO_HEADER_TEXT_PRIV  18
#define IDS_COMP_INFO_HEADER_UNDERLINE_PRIV 19
#define IDS_DISPLAY_ERROR_FORMAT        20
#define IDS_TOO_MANY_PARAMETERS         21
#define IDS_MSMQADMIN                   22
#define IDS_PUBLIC_INFO_LINE            23
#define IDS_INCORRECT_PARAMS            24
#define IDS_NO_OUTGOING_QUEUES          25
#define IDS_NO_PRIVATE_QUEUES           26
#define IDS_NO_PUBLIC_QUEUES            27
#define IDS_MGMT_QUEUE_STATE_LOCAL      28
#define IDS_MGMT_QUEUE_STATE_NONACTIVE  29
#define IDS_MGMT_QUEUE_STATE_WAITING    30
#define IDS_MGMT_QUEUE_STATE_NEED_VALIDATE 31
#define IDS_MGMT_QUEUE_STATE_ONHOLD     32
#define IDS_MGMT_QUEUE_STATE_CONNECTED  33
#define IDS_MGMT_QUEUE_STATE_DISCONNECTING 34
#define IDS_MGMT_QUEUE_STATE_DISCONNECTED 35
#define IDS_FORMAT_NAME_MAX_LEN         36
#define IDS_ACTION_DONE                 37
#define IDS_PARAM_LIST_OUTGOING         38
#define IDS_PRIVATE_Q_NAME_MAX_LEN      39
#define IDS_ENTER_QUEUE_NAME            39
#define IDS_ERROR_DISPLAYING_QUEUES     40
#define IDS_COMPUTER_PROPS_DISCONNECTED 41
#define IDS_NAME_ONLY_HEADER_TEXT       42
#define IDS_NAME_ONLY_HEADER_UNDERLINE  43
#define IDS_CONNECTION_STATE_UNKNOWN    44
#define IDS_COMPUTER_PROPS_CONNECTED2   45
#define IDS_HELP                        46
#define IDS_ERROR                       47
#define IDS_USAGE                       48
#define IDS_HELP_USAGE                  48
#define IDS_OPTIONS1                    49
#define IDS_HELP_OPTIONS1               49
#define IDS_EXAMPLES                    50
#define IDS_HELP_EXAMPLES               50
#define IDS_PATH_NAME                   51
#define IDS_FORMAT_NAME                 52
#define IDS_NUMBER_OF_MESSAGES          53
#define IDS_UNACKED_MSGS                54
#define IDS_STATE                       55
#define IDS_NEXT_HOPS                   56
#define IDS_LOCATION                    57
#define IDS_FOREIGN                     58
#define IDS_NO_OF_MSGS_IN_JOURNAL_Q     59
#define IDS_NOT_PROCCESSED              60
#define IDS_NOT_PROCESSED               60
#define IDS_TRANSACTED                  61
#define IDS_OPTIONS2                    62
#define IDS_HELP_OPTIONS2               62
#define IDS_HELP_HEADER                 63
#define IDS_HELP_OPTIONS3               64
#define IDS_HELP_ENVIRONMENT_HEADER     65
#define IDS_HELP_ENVIRONMENT_USAGE1     66
#define IDS_HELP_ENVIRONMENT_USAGE2     67
#define IDS_HELP_ENVIRONMENT_OPTIONS1   68
#define IDS_HELP_ENVIRONMENT_OPTIONS2   69
#define IDS_HELP_ENVIRONMENT_OPTIONS3   70
#define IDS_HELP_ENVIRONMENT_EXAMPLES   71
#define IDS_NEXT_HOPS_BLANK             72
#define IDS_PRIVATE_QUEUE_PROPS         73
#define IDS_PRIVATE_QUEUE_PROPS1        73
#define IDS_UNKNOWN_ERROR               74
#define IDS_PRIVATE_QUEUE_PROPS2        75
#define IDS_INSTANCE                    76
#define IDS_WORKGROUP_MODE              77

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqbench\mqbench.cpp ===
/*++

Copyright (c) 1995-98 Microsoft Corporation. All rights reserved

Module Name:
    mqbench.cpp

Abstract:
    Benchmark MSMQ message performance

Author:
    Microsoft Message Queue Team

Environment:
	Platform-independent.

--*/

#pragma warning (disable:	4201) 
#pragma warning (disable:	4514)
#define INITGUID

#include <string.h>
#include <stdio.h>
#include <limits.h>
#include <windows.h>
#include "excel.h"
#include <assert.h>

#include <transact.h>
#include <xolehlp.h>
#include <mq.h>



enum OPERATION			{ SEND, RECEIVE };
enum TRANSACTIONTYPE	{ NO_TRANSACTION, INTERNAL, COORDINATED, SINGLE };		

struct _params {
	UCHAR MsgType;
	OPERATION Operation;
	TRANSACTIONTYPE TransactionType;
	ULONG ulMsgNumber;
	ULONG ulTransactionNum;
	ULONG ulThreadNum;
	ULONG ulMsgSize;
	ULONG ulTimeLimit;
	ULONG ulTotalMessages;
	ULONG ulTotalTransactions;
	WCHAR wcsQueuePathName[MQ_MAX_Q_NAME_LEN];
	BOOL fWaitForReceivedMsg;
	BOOL fOperationSpecified;
	BOOL fOneLineFormat;
	BOOL fFormatName;
    DWORD dwCommitFlags;
};
typedef _params PARAMS;
//
// Command line parsed parameters
//
PARAMS g_Params;
LPSTR  g_FileName = 0;
LPSTR  g_WorksheetName = 0;
LPSTR  g_Cell = 0;

//
// Traget queue handle used by the benchmark
//
QUEUEHANDLE g_hQueue;

//
// Timer start interlocked, used to messure receive start time
// after waiting to first message
//
BOOL g_fTimerStarted = FALSE;

//
// Synchronization Events. These events synchronize orchestrated start of all
// test threads.
//
HANDLE g_hStart;
HANDLE g_hEnd;

//
// Thread counter used to indentify the last thread in the bunch
//
LONG g_ThreadCounter;

//
// Stop execution. Used by time limit to indicate thread termination.
//
BOOL g_fStop;

//
// Benchmarck start and end time.
//
LONGLONG g_StartTime;
LONGLONG g_EndTime;

//
// Transaction Dispenser DTC's interface
//
ITransactionDispenser* g_pDispenser = NULL;

#ifdef PERF_TIMESTAMP
void TimeStamp(char *s) {
	static LARGE_INTEGER o;
	static DWORD od = 0;
	LARGE_INTEGER l;
	
	if(QueryPerformanceCounter(&l)) {
		printf("%s: %u:%u", s, l.HighPart, l.LowPart / 100000);
		if(l.HighPart == o.HighPart)
			printf(" delta %u\n", (l.LowPart - o.LowPart) / 100000);
		else
			printf(" delta %u:%u\n", l.HighPart - o.HighPart, l.LowPart - o.LowPart);
		o = l;
	} else {
		DWORD dw = GetTickCount();
		printf("%s: %d delta %d\n", s, dw, od - dw);
		od = dw;
	}
}
#else
#define TimeStamp(s)
#endif


void Usage()
{
    printf("Microsoft (R) Message Queue Benchmark Version 1.00\n");
    printf("Copyright (C) Microsoft 1985-1998. All rights reserved.\n\n");

	printf("Usage:\tmqbench [-s[e|r] count size] [-r count size] [-p[f] queue] [-l seconds]\n");
    printf("\t[-x[i|c|s] count] [-t count] [-w] [-o filename worksheet cell] [-f] [-?]\n\n");

    printf("Arguments:\n");
	printf("-se\tsend 'count' express messages of length 'size' (in bytes)\n");
	printf("-sr\tsend 'count' recoverable messages of length 'size' (in bytes)\n");
	printf("-r \treceive 'count' messages of length 'size' (in bytes)\n");
	printf("-xi\tuse 'count' internal transactions\n");
	printf("-xc\tuse 'count' coordinated (DTC) transactions\n");
	printf("-xs\tuse single message transaction\n");
    printf("-a \tasynchronous commit\n");
	printf("-t \trun benchmark using 'count' threads\n");
	printf("-p \tpath name of an existing queue\n");
	printf("-pf\tformat name of an existing queue\n");
	printf("-l \tlimit processing time to 'seconds'\n");
	printf("-w \tstart benchmark at first received message\n");
	printf("-f \toutput resutls to stdout in 1 line format\n");
	printf("-o \toutput the result to an excel file 'filename' to the 'worksheet'\n\tspecified and at the right 'cell'\n");
	printf("-? \tprint this help\n\n");

	printf("e.g., mqbench -sr 100 10  -t 5  -xi 3  -p .\\q1  -o c:\\bench.xls Express C4 \n");
	printf("benchmarks 1500 recoverable messages sent locally using 5 threads and 15 internal transactions and saves it to 'bench.xls' worksheet 'Express' cell 'C4'.\n");
	exit(-1);
}

void ErrorExit(char *pszErrorMsg, HRESULT hr)
{
	printf ("ERROR: %s (0x%x).\n", pszErrorMsg, hr);

    HINSTANCE hLib = LoadLibrary("MQUTIL.DLL");
    if(hLib == NULL)
    {
        exit(-1);
    }

    char* pText;
    DWORD rc;
    rc = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE |
				FORMAT_MESSAGE_FROM_SYSTEM |
				FORMAT_MESSAGE_IGNORE_INSERTS |
				FORMAT_MESSAGE_ALLOCATE_BUFFER |
				FORMAT_MESSAGE_MAX_WIDTH_MASK,
            hLib,
            hr,
            0,
            reinterpret_cast<char*>(&pText),
            0,
            NULL
            );

    if(rc == 0)
    {
        exit(-1);
    }

    printf("%s\n", pText);

	exit(-1);
}

void InitParams()
{
	g_Params.MsgType = MQMSG_DELIVERY_EXPRESS;
	g_Params.Operation = SEND;
	g_Params.TransactionType = NO_TRANSACTION;
	g_Params.ulMsgNumber = 0;
	g_Params.ulTransactionNum = 1;
	g_Params.ulThreadNum = 1;
	g_Params.ulTotalMessages = 0;
	g_Params.ulTotalTransactions = 0;
	g_Params.ulTimeLimit = 0;
	g_Params.wcsQueuePathName[0] = '\0';
	g_Params.ulMsgSize = 0;
	g_Params.fWaitForReceivedMsg = FALSE;
	g_Params.fOperationSpecified = FALSE;
	g_Params.fOneLineFormat = FALSE;
	g_Params.fFormatName = FALSE;
    g_Params.dwCommitFlags = 0;
}

BOOL IsValidParam (int Cur, int ParamNum, char *pszParams[])
{
	if (Cur+1 == ParamNum)
		return FALSE;

    if(*pszParams[Cur+1] == '-')
        return FALSE;

	return TRUE;
}

void GetMsgType(char chMsgType)
{
	switch (chMsgType)
	{
	    case 'e':
		    g_Params.MsgType = MQMSG_DELIVERY_EXPRESS;
		    break;

	    case 'r':
		    g_Params.MsgType = MQMSG_DELIVERY_RECOVERABLE;
		    break;

	    default:
            printf("Invalid message type '%c'.\n\n", chMsgType);
            Usage();
	}
}

void GetMessageParams(int Cur, int ParamNum, char *pszParams[])
{
	//
	// Get number of messages
	//
	if (!IsValidParam (Cur, ParamNum, pszParams))
	{
		printf("Missing number of messages.\n\n");
        Usage();
	}

	g_Params.ulMsgNumber = atol(pszParams[Cur+1]);
	if (g_Params.ulMsgNumber == 0) 
	{
		printf("Invalid number of messages.\n\n");
        Usage();
	}
	
	//
	// Get size of body
	//
	if (!IsValidParam (Cur+1, ParamNum, pszParams))
	{
		printf("Missing message body size.\n\n");
        Usage();
	}

	g_Params.ulMsgSize = atol(pszParams[Cur+2]);
	if (g_Params.ulMsgSize == 0) 
	{
		printf("Invalid message body size.\n\n");
        Usage();
	}
}

int ParseSendParams (int Cur, int ParamNum, char *pszParams[])
{
	if (g_Params.fOperationSpecified)
	{
		printf("Invalid operation. Specify either send or receive.\n\n");
        Usage();
	}
	
	g_Params.Operation = SEND;
	g_Params.fOperationSpecified = TRUE;
	
	//
	// Get message type
	//
	char *pszMsgType = pszParams[Cur];
	GetMsgType ((char)tolower(pszMsgType[1]));
	GetMessageParams (Cur, ParamNum, pszParams);
	
	return Cur + 3;
}

int ParseReceiveParams (int Cur, int ParamNum, char *pszParams[])
{
	if (g_Params.fOperationSpecified)
	{
		printf("Invalid operation. Specify either send or receive.\n\n");
        Usage();
	}
	
	g_Params.Operation = RECEIVE;
	g_Params.fOperationSpecified = TRUE;
	
	GetMessageParams (Cur, ParamNum, pszParams);

	return Cur + 3;
}

int ParsePathParams(int Cur, int ParamNum, char *pszParams[])
{
	if (!IsValidParam(Cur, ParamNum, pszParams))
	{
		printf("Missing queue path name.\n\n");
        Usage();
	}		
	
	if ((strlen(pszParams[Cur]) > 1) &&
		(pszParams[Cur][1] == 'f')) 
	{
		g_Params.fFormatName = TRUE;
	}
	mbstowcs(g_Params.wcsQueuePathName, pszParams[Cur+1], MQ_MAX_Q_NAME_LEN);
	
	return Cur + 2;
}

void GetTransactionType(char chTransactionType)
{
	switch (chTransactionType)
	{
	    case 'i':
		    g_Params.TransactionType = INTERNAL;
		    break;

	    case 'c':
		    g_Params.TransactionType = COORDINATED;
		    break;

	    case 's':
		    g_Params.TransactionType = SINGLE;
		    break;

	    default:
		    printf("Invalid transaction type '%c'.\n\n", chTransactionType);
            Usage();
	}
}

int ParseTransactionParams(int Cur, int ParamNum, char *pszParams[])
{
	//
	// Get transaction type
	//
	char *pszTransactionType = pszParams[Cur];
	GetTransactionType ((char)tolower(pszTransactionType[1]));
	
	//
	// Get number of transaction
	// 
	if(g_Params.TransactionType == SINGLE)
	{
		return Cur + 1;
	}

	if (!IsValidParam (Cur, ParamNum, pszParams))
	{
		printf("Missing number of transactions.\n\n");
        Usage();
	}

	g_Params.ulTransactionNum = atol(pszParams[Cur+1]);
	if (g_Params.ulTransactionNum == 0)
	{
		printf("Invalid number of transactions.\n\n");
        Usage();
	}

	return Cur + 2;
}

int ParseThreadParams(int Cur, int ParamNum, char *pszParams[])
{
	if (!IsValidParam(Cur, ParamNum, pszParams))
	{
		printf("Missing number of threads.\n\n");
        Usage();
	}

	g_Params.ulThreadNum = atol(pszParams[Cur+1]);
	if (g_Params.ulThreadNum == 0)  
	{
		printf("Invalid number of threads.\n\n");
        Usage();
	}

	return Cur + 2;
}

int ParseWaitParams(int Cur)
{
	g_Params.fWaitForReceivedMsg = TRUE;
	return Cur + 1;
}

int ParseFormatParams(int Cur)
{
	g_Params.fOneLineFormat = TRUE;
	return Cur + 1;
}

int ParseAsyncParams(int Cur)
{
	g_Params.dwCommitFlags = XACTTC_ASYNC;
	return Cur + 1;
}

ParseExcelParams(int Cur, int ParamNum, char *pszParams[])
{
	if (!IsValidParam(Cur, ParamNum, pszParams))
	{
		printf("Missing Excel file.\n\n");
        Usage();
	}


	g_FileName = pszParams[Cur+1];

	if (!IsValidParam(Cur+1, ParamNum, pszParams))
	{
		printf("Missing Excel spreadsheet.\n\n");
        Usage();
	}

	g_WorksheetName = pszParams[Cur+2];

	if (!IsValidParam(Cur+2, ParamNum, pszParams))
	{
		printf("Missing Excel cell definition.\n\n");
        Usage();
	}

	g_Cell = pszParams[Cur+3];
	
	return Cur + 4;
}

int ParseTimeLimitParams(int Cur, int ParamNum, char *pszParams[])
{
	if (!IsValidParam(Cur, ParamNum, pszParams))
	{
		printf("Missing time limit.\n\n");
        Usage();
	}

	g_Params.ulTimeLimit = atol(pszParams[Cur+1]);
	if (g_Params.ulTimeLimit == 0)  
	{
		printf("Invalid time limit.\n\n");
        Usage();
	}

	return Cur + 2;
}
	
void ParseParams (int ParamNum, char *pszParams[])
{
	if (ParamNum < 6)
	{
		Usage();
	}

	int i = 1;

	while (i < ParamNum)
	{
		if (*pszParams[i] != '-')
		{
			printf("Invalid parameter '%s'.\n\n", pszParams[i]);
            Usage();
		}

		switch (tolower(*(++pszParams[i])))
		{
		    case 's':
			    i = ParseSendParams(i, ParamNum, pszParams);
			    break;

		    case 'r':
			    i = ParseReceiveParams(i, ParamNum, pszParams);
			    break;
		    
		    case 'p':
			    i = ParsePathParams(i, ParamNum, pszParams);
			    break;

		    case 'x':
			    i = ParseTransactionParams(i, ParamNum, pszParams);
			    break;

		    case 't':
			    i = ParseThreadParams(i, ParamNum, pszParams);
			    break;
			    
		    case 'w':
			    i = ParseWaitParams(i);
			    break;

            case 'a':
                i = ParseAsyncParams(i);
                break;

	        case 'o':
	            i = ParseExcelParams(i, ParamNum, pszParams);
                break;

			case 'l':
				i = ParseTimeLimitParams(i, ParamNum, pszParams);
				break;

			case 'f':
				i = ParseFormatParams(i);
				break;

		    case '?':
			    Usage();
			    break;

		    default:
			    printf("Unknown switch '%s'.\n\n", pszParams[i]);
                Usage();
			    break;
		}
	}

	//
	// check parameters
	//
	if (!g_Params.fOperationSpecified)
	{
		printf("Invalid operation. Specify either send or receive.\n\n");
        Usage();
	}

	if (g_Params.wcsQueuePathName[0] == L'\0')
	{
		printf("Missing queue path name.\n\n");
        Usage();
	}
	
	//
	// if time limit is set, then update number of transactions/messages to send to MAX
	//
	if (g_Params.ulTimeLimit > 0) 
	{
		if (g_Params.TransactionType != NO_TRANSACTION) 
		{
			g_Params.ulTransactionNum = LONG_MAX;
		}
		else 
		{
			g_Params.ulMsgNumber = LONG_MAX;
		}
	}
	
#ifdef _DEBUG
	printf("Operation: %d\n", g_Params.Operation);
	printf("Message type: %d\n", g_Params.MsgType);
	printf("Number of messages %lu\n", g_Params.ulMsgNumber);
	printf("Size of message %lu\n", g_Params.ulMsgSize);							
	printf("Queue Path Name: %ls\n", g_Params.wcsQueuePathName);
	printf("Transaction type: %d\n", g_Params.TransactionType);
	printf("Number of transactions: %d\n", g_Params.ulTransactionNum);
	printf("Number of threads: %d\n", g_Params.ulThreadNum);
	printf("Time limit (seconds): %lu\n", g_Params.ulTimeLimit);
#endif
}

void CreateTheQueue()
{
    MQQUEUEPROPS QueueProps;
    MQPROPVARIANT aVariant[10];
    QUEUEPROPID aPropId[10];
    DWORD PropIdCount = 0;
    HRESULT hr;

    PSECURITY_DESCRIPTOR pSecurityDescriptor;


    //
    // Set the PROPID_Q_PATHNAME property
    //
    aPropId[PropIdCount] = PROPID_Q_PATHNAME;
    aVariant[PropIdCount].vt = VT_LPWSTR;
    aVariant[PropIdCount].pwszVal = new WCHAR[MAX_PATH];
    wcscpy(aVariant[PropIdCount].pwszVal, g_Params.wcsQueuePathName);

    PropIdCount++;

    //
    // Set the PROPID_Q_TRANSACTION property
    //
    aPropId[PropIdCount] = PROPID_Q_TRANSACTION;    //PropId
    aVariant[PropIdCount].vt = VT_UI1;     //Type
    aVariant[PropIdCount].bVal = g_Params.TransactionType != NO_TRANSACTION;

    PropIdCount++;

    //
    // Set the PROPID_Q_LABEL property
    //
    aPropId[PropIdCount] = PROPID_Q_LABEL;    //PropId
    aVariant[PropIdCount].vt = VT_LPWSTR;     //Type
    aVariant[PropIdCount].pwszVal = new WCHAR[MAX_PATH];
    wcscpy(aVariant[PropIdCount].pwszVal, L"mqbench test queue"); //Value

    PropIdCount++;

    //
    // Set the MQEUEUPROPS structure
    //
    QueueProps.cProp = PropIdCount;           //No of properties
    QueueProps.aPropID = aPropId;             //Id of properties
    QueueProps.aPropVar = aVariant;           //Value of properties
    QueueProps.aStatus = NULL;                //No error reports

    //
    // No security (default)
    //
    pSecurityDescriptor = NULL;

    //
    // Create the queue
    //	
    WCHAR szFormatNameBuffer[MAX_PATH];
    DWORD dwFormatNameBufferLength = MAX_PATH;
    hr = MQCreateQueue(
            pSecurityDescriptor,            //Security
            &QueueProps,                    //Queue properties
            szFormatNameBuffer,             //Output: Format Name
            &dwFormatNameBufferLength       //Output: Format Name len
            );

    if(FAILED(hr))
    {
        ErrorExit("MQCreateQueue failed", hr);
    }
}


void GetQueueHandle()
{
	HRESULT hr;
	
	DWORD dwFormatNameLength = MAX_PATH;
	WCHAR wcsFormatName[MAX_PATH];

	if (!g_Params.fFormatName) 
	{
		hr= MQPathNameToFormatName(
				g_Params.wcsQueuePathName, 
				wcsFormatName, 
				&dwFormatNameLength
				);

		if (FAILED(hr)) 
		{
			if(hr == MQ_ERROR_QUEUE_NOT_FOUND)
			{
				CreateTheQueue();
				GetQueueHandle();
				return;
			}


			ErrorExit("MQPathNameToFormatName failed", hr);
		}
	}
	else 
	{
		wcscpy(wcsFormatName, g_Params.wcsQueuePathName);
	}

	DWORD dwAccess;
	if (g_Params.Operation == SEND)
	{
		dwAccess = MQ_SEND_ACCESS;
	}
	else
	{
		dwAccess = MQ_RECEIVE_ACCESS;
	}

	hr = MQOpenQueue(
			wcsFormatName,
			dwAccess,
			MQ_DENY_NONE,
			&g_hQueue
			);

	if (FAILED(hr)) 
	{
		ErrorExit("MQOpenQueue failed", hr);
	}
}


void SetMessageProps(MQMSGPROPS *pMessageProps)
{
	assert(pMessageProps->cProp == 3);
	//
	// Set the message body buffer
	//
	assert(pMessageProps->aPropID[0] == PROPID_M_BODY);

	pMessageProps->aPropVar[0].caub.cElems = g_Params.ulMsgSize;
	pMessageProps->aPropVar[0].caub.pElems = new unsigned char[g_Params.ulMsgSize];
	
	if (g_Params.Operation == SEND)
	{
		//
		// Build message body
		//
		memset(pMessageProps->aPropVar[0].caub.pElems, 'a', g_Params.ulMsgSize);
	}

	//
	// Set message body size
	//
	assert(pMessageProps->aPropID[1] == PROPID_M_BODY_SIZE);
	pMessageProps->aPropVar[1].ulVal = g_Params.ulMsgSize;

	//
	// Set message delivery
	//
	assert(pMessageProps->aPropID[2] == PROPID_M_DELIVERY);
	pMessageProps->aPropVar[2].bVal = g_Params.MsgType;

}

void TransactionInit()
{
	HRESULT hr;
	hr = DtcGetTransactionManager ( 
			NULL,						//Host Name
			NULL,						//TmName
			IID_ITransactionDispenser,
			0,							//reserved
			0,							//reserved
			0,							//reserved
			(LPVOID*)&g_pDispenser
			);

	if (FAILED(hr))
	{
		ErrorExit("DtcGetTransactionManager failed", hr);
	}
}

void CreateEvents()
{
	g_hStart = CreateEvent(  
				0,			// no security attributes
				TRUE,		// use manual-reset event
				FALSE,		// event is reset initally
				NULL		// unnamed event
				);

	if (g_hStart == NULL)
	{
		ErrorExit("CreateEvent failed", GetLastError());
	}

	g_hEnd  = CreateEvent(  
				0,			// no security attributes
				TRUE,		// use manual-reset event
				FALSE,		// event is reset initally
				NULL		// unnamed event
				);
	if (g_hEnd == NULL)
	{
		ErrorExit("CreateEvent failed", GetLastError());
	}
}

void GetTime(LONGLONG* pFT)
{
	GetSystemTimeAsFileTime((FILETIME*)pFT);
}


static
HRESULT
DTCBeginTransaction(
	ITransaction** ppXact
	)
{
	return g_pDispenser->BeginTransaction (
						    NULL,                       // IUnknown __RPC_FAR *punkOuter,
						    ISOLATIONLEVEL_ISOLATED,    // ISOLEVEL isoLevel,
						    ISOFLAG_RETAIN_DONTCARE,    // ULONG isoFlags,
						    NULL,                       // ITransactionOptions *pOptions
						    ppXact
						    );
}

ITransaction*
GetTransactionPointer(
	void
	)
{
	ITransaction *pXact;
	HRESULT hr = MQ_OK;
	switch (g_Params.TransactionType)
	{
		case INTERNAL:
			hr = MQBeginTransaction (&pXact);
			break;

		case COORDINATED:
			hr = DTCBeginTransaction(&pXact);
			break;

		case SINGLE:
			pXact = MQ_SINGLE_MESSAGE;
			break;

		case NO_TRANSACTION:
			pXact = MQ_NO_TRANSACTION;
			break;

		default:
			assert(0);
	}

	if (FAILED(hr)) 
	{
		ErrorExit("Can not create transaction", hr);
	}

	return pXact;
}


static
DWORD
APIENTRY
TestThread(
	PVOID /*pv*/
	)
{
	//
	// Properties passed to MQSendMessage or MQReceiveMessage
	//
	const int x_PropCount = 3;

	MSGPROPID MessagePropId[x_PropCount] = {
		PROPID_M_BODY,
		PROPID_M_BODY_SIZE,
		PROPID_M_DELIVERY
	};

	MQPROPVARIANT MessagePropVar[x_PropCount] = {
		{VT_VECTOR | VT_UI1, 0, 0, 0},
		{VT_UI4, 0, 0, 0},
		{VT_UI1, 0, 0, 0}
	};

	MQMSGPROPS MessageProperties = {
		x_PropCount,
		MessagePropId,
		MessagePropVar,
		0
	};
	
	SetMessageProps( &MessageProperties);

	if(InterlockedDecrement(&g_ThreadCounter) == 0)
	{
		//
		// Last test thread sample start time, and enable all test
		// threads to run.
		//
		GetTime(&g_StartTime);
		g_ThreadCounter = g_Params.ulThreadNum;
		SetEvent(g_hStart);
	}

	//
	// Synchronize all threads to wait for a start signal
	//
	WaitForSingleObject(g_hStart, INFINITE);

	HRESULT hr;
	BOOL fBreak = FALSE;
	ULONG ulTotalMsgCount = 0;
	ULONG ulTotalTransCount = 0;
	ULONG ulTransCount = 0;
	ULONG ulMsgCount = 0;

	for (	ulTransCount = 0; 
			ulTransCount < g_Params.ulTransactionNum; 
			ulTransCount++ )
	{
		//
		//BeginTransaction
		//
		ITransaction* pXact = GetTransactionPointer();

		//
		// Send/Receive Messages
		//
		for (	ulMsgCount=0; 
				ulMsgCount < g_Params.ulMsgNumber; 
				ulMsgCount++)
		{
			if (g_Params.Operation == SEND)
			{
				hr = MQSendMessage(	
						g_hQueue,
						&MessageProperties,
						pXact
						);

				if (FAILED(hr)) 
				{
					ErrorExit("MQSendMessage failed", hr);
				}

				if (g_fStop && !fBreak)
				{
					fBreak = TRUE;
					memset(MessageProperties.aPropVar[0].caub.pElems, 's', g_Params.ulMsgSize);
					ulMsgCount = g_Params.ulMsgNumber - 2;
				}
			}
			else
			{
				hr = MQReceiveMessage(
						g_hQueue,
						INFINITE,			//dwTimeout
						MQ_ACTION_RECEIVE,  //dwAction,
						&MessageProperties,
						NULL,				//IN OUT LPOVERLAPPED lpOverlapped,
						NULL,				//IN PMQRECEIVECALLBACK fnReceiveCallback,
						NULL,				//IN HANDLE hCursor,
						pXact
						);

				if (FAILED(hr)) 
				{
					ErrorExit("MQReceiveMessage failed", hr);
				}

				if(g_Params.fWaitForReceivedMsg && !g_fTimerStarted)
				{
					//
					//	Start time is sampled after first receive, only by the
					//  first thread.
					//
					if(InterlockedExchange((LONG *)&g_fTimerStarted, TRUE) == FALSE)
					{
						GetTime(&g_StartTime);
					}
				}

				if (MessageProperties.aPropVar[0].caub.pElems[0] == 's')
				{
					ulMsgCount = g_Params.ulMsgNumber - 1;
					fBreak = TRUE;
				}
			}

			ulTotalMsgCount++;
		}
		
		if (g_Params.TransactionType == INTERNAL || 
			g_Params.TransactionType == COORDINATED ) 
		{
			hr = pXact->Commit(0, g_Params.dwCommitFlags, 0);
			if (FAILED(hr))
			{
				ErrorExit("Commit failed", hr);
			}
			pXact->Release();

			ulTotalTransCount++;
		}
		if (fBreak)
		{
			break;
		}
	}

	InterlockedExchangeAdd( (PLONG)&g_Params.ulTotalMessages, ulTotalMsgCount);
	InterlockedExchangeAdd( (PLONG)&g_Params.ulTotalTransactions, ulTotalTransCount);

	//
	// Last thread sample end time and signal main thread to continue.
	//
	if(InterlockedDecrement(&g_ThreadCounter) == 0)
	{
		GetTime(&g_EndTime);
		SetEvent(g_hEnd);
	}

	return 0;
}


void RunTest()
{
	//
	// Set thread counter to control TestThread.
	//
	g_ThreadCounter = g_Params.ulThreadNum;
	g_fStop = FALSE;

	for(UINT i = 0; i < g_Params.ulThreadNum; i++)
	{
		HANDLE hThread;
		DWORD dwThreadId;
		hThread = CreateThread(
					NULL,		// no thread security attributes
					0,			// use default thread stack size
					TestThread, // the thread function
					0,			// no arguments for the new thread
					0,			// creation flags, create running thread
					&dwThreadId	// thread identifier
					);
		if (hThread == NULL)
		{
			ErrorExit("Create Thread failed", GetLastError());
		}
 
		CloseHandle(hThread);
	}

	//
	// Wait for all test threads to complete
	//
	if (g_Params.ulTimeLimit > 0 && g_Params.Operation == SEND)
	{
		if (WaitForSingleObject(g_hEnd, g_Params.ulTimeLimit * 1000) == WAIT_TIMEOUT) 
		{
			g_fStop = TRUE;
			WaitForSingleObject(g_hEnd, INFINITE);
		}
	}
	else
	{
		WaitForSingleObject(g_hEnd, INFINITE);
	}
}

void ResultOutput()
{
	//
	// convert to seconds
	//
	float Time = ((float)(g_EndTime - g_StartTime)) / 10000000;
	float Benchmark = g_Params.ulTotalMessages / Time;
	float Throughput = g_Params.ulTotalMessages * g_Params.ulMsgSize / Time;
	
	if (g_Params.fOneLineFormat) 
	{
		char cXactType;
		switch(g_Params.TransactionType) 
		{
			case NO_TRANSACTION: 
				cXactType = 'N';
				break;	
			case INTERNAL: 
				cXactType = 'I';
				break;
			case COORDINATED:
				cXactType = 'C';
				break;
			case SINGLE:
				cXactType = 'S';
				break;
		}

		printf( "%s %c %c%7lu%7lu%7lu%7lu%7lu\t%.3f\t%.0f\t%.0f\n",
				(g_Params.Operation == SEND) ? "Send" : "Recv",
				(g_Params.MsgType == MQMSG_DELIVERY_EXPRESS) ? 'E' : 'R',
				cXactType,
				g_Params.ulTotalMessages,
				g_Params.ulTotalTransactions,
				g_Params.ulMsgSize,
				(g_Params.TransactionType != NO_TRANSACTION) ? g_Params.ulMsgNumber : 0,
				g_Params.ulThreadNum,
				Time,
				Benchmark,
				Throughput);
	}
	else 
	{
		printf("\nTotal messages:\t%lu %s\n", g_Params.ulTotalMessages, 
				(g_Params.Operation == SEND) ? "Sent" : "Received");
		printf("Test time:\t%.3f seconds\n", Time);
		printf("Benchmark:\t%.0f messages per second\n", Benchmark);
		printf("Throughput:\t%.0f bytes per second\n", Throughput);
	}

	if (g_FileName)
	{
		SaveBenchMarkToExcel(Benchmark, g_FileName, g_WorksheetName, g_Cell);
	}
}

void InitTest()
{
	GetQueueHandle();
	if (g_Params.TransactionType == COORDINATED)
	{
		TransactionInit();
	}

	CreateEvents();
}

void FinitTest()
{
	MQCloseQueue(g_hQueue);
	CloseHandle(g_hStart);
	CloseHandle(g_hEnd);
	if(g_pDispenser != NULL)
	{
		g_pDispenser->Release();
	}
}

void main(int argc, char *argv[])
{
	InitParams();
	ParseParams(argc, argv);
	InitTest();
	RunTest();
	FinitTest();
	ResultOutput();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\array.h ===
//
// CArr is used to keep in an simple way the list of all known files
//
typedef struct CFile
{
	WCHAR wszName[MAX_PATH];
	WIN32_FIND_DATAW find_data;
} CFile;

class CArr 
{
public:
	CArr();
	~CArr();

	void Keep(LPWSTR wszPath, WIN32_FIND_DATAW *pData);
	BOOL Lookup(LPWSTR wszPath, WIN32_FIND_DATAW *pData);
	void StartEnumeration();
	LPWSTR Next(WIN32_FIND_DATAW **ppData);

private:
	void Double();

	CFile *pfiles;
	ULONG  ulAllocated;
	ULONG  ulUsed;
	ULONG  ulCur;
};

CArr::CArr()
{
	ulAllocated = 500;
	ulUsed      = 0;
	ulCur       = 0;
	pfiles     = new CFile[ulAllocated];
}

CArr::~CArr()
{
	delete [] pfiles; 
}	

void CArr::Keep(LPWSTR wszPath, WIN32_FIND_DATAW *pData)
{
	if (ulUsed == ulAllocated)
	{
		Double();
	}

	wcscpy(pfiles[ulUsed].wszName, wszPath);
	memcpy(&pfiles[ulUsed].find_data, pData, sizeof(WIN32_FIND_DATAW));
	ulUsed++;
}

BOOL CArr::Lookup(LPWSTR wszPath, WIN32_FIND_DATAW *pData)
{
	for (ULONG i=0; i<ulUsed; i++)
	{
		if (wcscmp(pfiles[i].wszName, wszPath) == 0)
		{
			pData = &pfiles[i].find_data;
			return TRUE;
		}
	}

	return FALSE;
}

void CArr::StartEnumeration()
{
	ulCur       = 0;
}

LPWSTR CArr::Next(WIN32_FIND_DATAW **ppData)
{
	if (ulCur == ulUsed)
	{
		return NULL;
	}


	*ppData = &pfiles[ulCur].find_data;
	return pfiles[ulCur++].wszName;
}

void CArr::Double()
{

	CFile *pfiles1 = new CFile[ulAllocated * 2];
	memcpy(pfiles1, pfiles, sizeof(CFile) * ulAllocated);

	ulAllocated *= 2;

	delete [] pfiles;
	pfiles = pfiles1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\binpatch.h ===
BOOL BinPatch(LPWSTR wszPath, ULONG ulOffset, ULONG ulVersion, ULONG ulSignOffset, ULONG ulSignature);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\dsstuff.h ===
BOOL GetMyMsmqConfigProperty(
							 LPWSTR wszBuf, 
							 DWORD cbLen, 
							 LPWSTR wszADsProp, 
							 LPWSTR wszSrvName);
							 
BOOL SetMyMsmqConfigProperty(
							 VARIANT varProperty, 
							 LPWSTR  wszADsProp, 
							 LPWSTR  wszSrvName);
							 
BOOL GetSiteProperty(
							LPWSTR wszBuf, 
							DWORD cbLen, 
							LPWSTR wszSiteName, 
							LPWSTR wszADsProp, 
							LPWSTR wszSrvName);
							
BOOL GetDSproperty(			LPWSTR wszBuf, 
							DWORD cbLen, 
							LPWSTR wszADsPath, 
							LPWSTR wszADsProp);
							
BOOL FormThisComputerDN(	
							BOOL fDC, 
							LPWSTR wszDN, 
							DWORD cbLen);
							
HRESULT DumpObject(			IADs * pADs);

void GUID2reportString(		LPWSTR wszBuf, 
							GUID *pGuid);

void ReportString2GUID(		GUID *pGuid, 
							LPWSTR wszBuf);

BOOL PrepareGuidAsVariantArray(
							LPWSTR wszGuid, 
							VARIANT *pv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\binpatch.cpp ===
BOOL BinPatch(LPWSTR wszPath, ULONG ulOffset, ULONG ulVersion, ULONG ulSignOffset, ULONG ulSignature)
{
	BOOL fSuccess = TRUE;
	ULONG *pul = NULL;
	DWORD dwRead;
	DWORD dwRequest = (ulSignOffset > ulOffset ? ulSignOffset : ulOffset) + sizeof(ULONG);
	char *p = new char[dwRequest];
	
	HANDLE f =  CreateFile(wszPath, 
	                       GENERIC_READ | GENERIC_WRITE, 
	                       0, // no sharing, we are exclusive
	                       NULL, 
	                       OPEN_EXISTING, 
	                       0, 
	                       NULL);
	if (f == INVALID_HANDLE_VALUE)
	{
		Failed(L"Open file %s , error 0x%x", wszPath, GetLastError());
		fSuccess = FALSE;
	}

	if (fSuccess)
	{
		BOOL b = ReadFile(f, p, dwRequest, &dwRead, NULL);
		
		if (!b || dwRead != dwRequest)
		{
			Failed(L"Read file %s , error 0x%x", wszPath, GetLastError());
			fSuccess = FALSE;
		}
	}

	if (fSuccess)
	{
		pul = (PULONG)(p+ulSignOffset);
		if (*pul != ulSignature)
		{
			Failed(L"Find signature %d in file %s, offset 0x%x: 0x%x is there instead ", 
					 ulSignature, wszPath, ulSignOffset, *pul);
			fSuccess = FALSE;
		}
	}

	if (fSuccess)
	{
		*pul = ulVersion;

		if (SetFilePointer(f, ulOffset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
		{
			Failed(L"SetFilePointer %d in file %s: 0x%x", ulOffset, wszPath, GetLastError());
			fSuccess = FALSE;
		}
	}

	if (fSuccess)
	{
		DWORD dwWritten = 0;
		BOOL b = WriteFile(f, pul, sizeof(ULONG), &dwWritten, NULL);
		if (!b || dwWritten!=sizeof(ULONG))
		{
			Failed(L"Write to file %s, error 0x%x", wszPath, GetLastError());
			fSuccess = FALSE;
		}
	}


	if (f != INVALID_HANDLE_VALUE)
	{
		CloseHandle(f);
	}

	if (p)
	{
		delete [] p;
	}

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\dsstuff.cpp ===
//  This module holds utilities for DS access
//
//  AlexDad, March 2000
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <winbase.h>
#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>
#include <limits.h>
#include <objbase.h>
#include <activeds.h>
#include <iads.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include "..\base\base.h"

#include "mqtempl.h"

#include "dsstuff.h"

#define HEX_DIGIT_FORMAT L"%02x "

extern LPWSTR wszRecognizedSiteName;

BOOL IsDsServer();

BOOL PrepareVariantArray(LPWSTR  wszBuf, DWORD cbLen, VARIANT var);
BOOL PrepareOctetString (LPWSTR  wszBuf, DWORD cbLen, VARIANT var);
BOOL PrepareVariant(     LPWSTR  wszBuf, DWORD cbLen, VARIANT varPropData);
BOOL PrepareProperty(    LPWSTR  wszBuf, DWORD cbLen, BSTR bstrPropName, HRESULT hRetVal, VARIANT varPropData);

HRESULT GetPropertyList(IADs * pADs, VARIANT * pvar);

//
//  Failure control macros
//
#define BAIL_ON_FAILURE(hr)   \
     if (FAILED(hr)) 		  \
     { 					      \
             return FALSE;    \
     }


#define BAIL_ON_NULL(p)       \
     if (!(p)) 				  \
     {           			  \
             return FALSE;    \
     }

//
// helper class for COInit auto release
//
class CCoInit
{
public:
    CCoInit()
    {
        CoInitialize(NULL);
    }

    ~CCoInit()
    {
        CoUninitialize();
    }
};

static class CCoInit coInit;

//
// Helper class to auto-release variants
//

class CAutoVariant
{
public:
    CAutoVariant()                          { VariantInit(&m_vt); }
    ~CAutoVariant()                         { VariantClear(&m_vt); }
    operator VARIANT&()                     { return m_vt; }
    VARIANT* operator &()                   { return &m_vt; }
    VARIANT detach()                        { VARIANT vt = m_vt; VariantInit(&m_vt); return vt; }
private:
    VARIANT m_vt;
};

//
// BSTRING auto-free wrapper class
//
class BS
{
public:
    BS()
    {
        m_bstr = NULL;
    };

    BS(LPCWSTR pwszStr)
    {
        m_bstr = SysAllocString(pwszStr);
    };

    BS(LPWSTR pwszStr)
    {
        m_bstr = SysAllocString(pwszStr);
    };

    BSTR detach()
    {
        BSTR p = m_bstr;
        m_bstr = 0;
        return p;
    };

    ~BS()
    {
        if (m_bstr)
        {
            SysFreeString(m_bstr);
        }
    };

public:
    BS & operator =(LPCWSTR pwszStr)
    {
        if (m_bstr) { SysFreeString(m_bstr); };
        m_bstr = SysAllocString(pwszStr);
        return *this;
    };

    BS & operator =(LPWSTR pwszStr)
    {
        if (m_bstr) { SysFreeString(m_bstr); };
        m_bstr = SysAllocString(pwszStr);
        return *this;
    };

    BS & operator =(BS bs)
    {
        if (m_bstr) { SysFreeString(m_bstr); };
        m_bstr = SysAllocString(LPWSTR(bs));
        return *this;
    };

    operator LPWSTR()
    {
        return m_bstr;
    };

private:
    BSTR  m_bstr;
};

//
// helper routines for GUID/text transformations
//
void GUID2reportString(LPWSTR wszBuf, GUID *pGuid)
{
	PUCHAR p = (PUCHAR) pGuid;
	WCHAR  wsz[10];

	for (int i=0; i<sizeof(GUID); i++)
	{
       	wsprintf(wsz, HEX_DIGIT_FORMAT, *p++);
       	wcscat(wszBuf, wsz);
	}
}

void ReportString2GUID(GUID *pGuid, LPWSTR wszBuf)
{
	PUCHAR  p = (PUCHAR) pGuid;
	WCHAR   digits[] = L"0123456789abcdef";

	for (int i=0; i<sizeof(GUID); i++)
	{
		int spart = wcschr(digits, wszBuf[3*i])   - digits;
		int lpart = wcschr(digits, wszBuf[3*i+1]) - digits;
       	*p++ = (UCHAR)(spart * 16 + lpart);
	}
}

//
// General routine for search in DS
//
#pragma warning(disable: 4702) // unreachable code
BOOL FindObjectInDs(LPWSTR wszDN, DWORD cbLen, LPWSTR pwcsObjectName, LPWSTR pwcsObjectType)
{
    HRESULT hr;
    R<IADs> pADs;
    hr = CoInitialize(NULL);

	GoingTo(L"get Root Domain Naming Context");
    BS bstrRootDomainNamingContext( L"rootDomainNamingContext");

    // Bind to the RootDSE to obtain information about the schema container
    //
    hr = ADsGetObject(L"LDAP://RootDSE", IID_IADs, (void **)&pADs);
    if (FAILED(hr))
    {
        Failed(L"ADsGetObject(LDAP://RootDSE), hr=0x%lx", hr);
        return false;
    }

    //
    // Read the root domain name property
    //
    CAutoVariant    varRootDomainNamingContext;

    hr = pADs->Get(bstrRootDomainNamingContext, &varRootDomainNamingContext);
    if (FAILED(hr))
    {
        Failed(L"CADSI::get for %s, hr=0x%lx", bstrRootDomainNamingContext, hr);
        return false;
    }

    Succeeded(L"get Root Domain Naming Context: %s", (&varRootDomainNamingContext)->bstrVal);




	GoingTo(L"get Default Domain Naming Context");
    BS bstrDefaultNamingContext( L"DefaultNamingContext");

    //
    // Read the default name property
    //
    CAutoVariant    varDefaultNamingContext;

    hr = pADs->Get(bstrDefaultNamingContext, &varDefaultNamingContext);
    if (FAILED(hr))
    {
        Failed(L"CADSI::Get %s, hr=0x%lx", bstrDefaultNamingContext, hr);
        return false;
    }

    Succeeded(L"get Default Naming Context: %s ", (&varDefaultNamingContext)->bstrVal);


    //
    //  Try to find the object the GC under root domain naming context
    //
    GoingTo(L"find %s %s under context %s", 
		    pwcsObjectType, pwcsObjectName,((VARIANT &)varRootDomainNamingContext).bstrVal);

    WCHAR * pwdsADsPath = new WCHAR [ 5 + wcslen( ((VARIANT &)varRootDomainNamingContext).bstrVal)];
    wcscpy(pwdsADsPath, TEXT("GC://"));
    wcscat(pwdsADsPath,((VARIANT &)varRootDomainNamingContext).bstrVal);

    IDirectorySearch * pDSSearch = NULL;

    hr = ADsGetObject(
            pwdsADsPath,
            IID_IDirectorySearch,
            (void**)&pDSSearch);
    if FAILED((hr))
    {
        Failed(L" bind to GC root, hr=0x%lx",hr);
        return false;
    }

    //
    //  Prepare filter - the specific object
    //

    WCHAR filter[1000] = L"";  
    wcscat(filter, L"(&(objectClass=");
	wcscat(filter, pwcsObjectType);
	wcscat(filter, L")(cn=");
    wcscat(filter, pwcsObjectName);
    wcscat(filter, L"))");
    WCHAR AttributeName[] = L"distinguishedName";
    WCHAR * pAttributeName = AttributeName;

	GoingTo(L"execute search: filter %s, attribute %s", filter, pAttributeName);

    ADS_SEARCH_HANDLE   hSearch;
    hr = pDSSearch->ExecuteSearch(
        filter,
        &pAttributeName,
        1,
        &hSearch);
    if FAILED((hr))
    {
        Failed(L"execute search, hr=0x%lx", hr);
        return false;
    }

    while ( SUCCEEDED(  hr = pDSSearch->GetNextRow( hSearch)))
    {
            ADS_SEARCH_COLUMN Column;

            // Ask for the column itself
            hr = pDSSearch->GetColumn(
                         hSearch,
                         AttributeName,
                         &Column);
            if (hr == S_ADS_NOMORE_ROWS)
            {
                break;
            }

            if (FAILED(hr))
            {
                break;
            }

            Succeeded(L" find object: %s", Column.pADsValues->CaseIgnoreString);

			if (wcslen(Column.pADsValues->CaseIgnoreString) < cbLen)
			{
				wcscpy(wszDN, Column.pADsValues->CaseIgnoreString);
				return true;    // what if we want all of findings? 
			}
			else
			{
				return false;
			}


    }

    //
    //  Try to find the object the GC:
    //
    GoingTo(L"to find %s %s under context %s\n", pwcsObjectType, pwcsObjectName, L"GC:");

    pwdsADsPath = new WCHAR [ 5 + wcslen( ((VARIANT &)varDefaultNamingContext).bstrVal)];
    wcscpy(pwdsADsPath, TEXT("GC:"));

    IADsContainer * pDSContainer = NULL;

    hr = ADsGetObject(
            pwdsADsPath,
            IID_IADsContainer,
            (void**)&pDSContainer);
    if FAILED((hr))
    {
        Failed(L" bind to GC (IID_IADsContainer): hr=0x%lx",hr);
        return false;
    }

    IEnumVARIANT * pEnumerator;
    hr =  pDSContainer->get__NewEnum((IUnknown **)&pEnumerator);
    if FAILED((hr))
    {
        Failed(L"to get enumerator on GC: 0x%lx",hr);
        return false;
    }

    VARIANT varOneElement;
    ULONG cElementsFetched;
    hr =  ADsEnumerateNext(
            pEnumerator,  //Enumerator object
            1,             //Number of elements requested
            &varOneElement,           //Array of values fetched
            &cElementsFetched  //Number of elements fetched
            );
    if (FAILED(hr))
    {
        Failed(L"enumerate on GC: hr=0x%lx",hr);
        return false;
    }
    
	if ( cElementsFetched == 0)
    {
        Failed(L" get anything enumerated");
        return false;
    }

    hr = varOneElement.punkVal->QueryInterface(
            IID_IDirectorySearch,
            (void**)&pDSSearch);
    if (FAILED(hr))
    {
        Failed(L" query interface: hr=0x%lx",hr);
        return false;
    }

	GoingTo(L"execute search on GC");

    for (;;)
    {
        hr = pDSSearch->ExecuteSearch(filter, &pAttributeName, 1, &hSearch);

        if FAILED((hr))
        {
            Failed(L" execute search on GC: hr=0x%lx",hr);
            return false;
        }

        while ( SUCCEEDED(  hr = pDSSearch->GetNextRow( hSearch)))
        {
            ADS_SEARCH_COLUMN Column;

            // Ask for the column itself
            hr = pDSSearch->GetColumn(
                         hSearch,
                         AttributeName,
                         &Column);
            if (hr == S_ADS_NOMORE_ROWS)
            {
                break;
            }

            if (FAILED(hr))
            {
                break;
            }

            Succeeded(L" find object: %s", Column.pADsValues->CaseIgnoreString);

			if (wcslen(Column.pADsValues->CaseIgnoreString) < cbLen)
			{
				wcscpy(wszDN, Column.pADsValues->CaseIgnoreString);
				return true;    // what if we want all of findings? 
			}
				
            return false;
        }
    }
}
#pragma warning(default: 4702) // unreachable code


BOOL FormThisSiteDN(LPWSTR wszDN, DWORD cbLen)
{
	// find site in the Active Directory tree and get its DN
	//  (redmond --> CN=redmond,cn=Sites,CN=configuration, DC=ntdev,DC=microsoft,DC=com)
	
	BOOL b = FindObjectInDs(wszDN, cbLen, wszRecognizedSiteName, L"site");
	if (!b)
	{
		Failed(L"find site %s in the DS", wszRecognizedSiteName);
		return false;
	}
	Succeeded(L" find site in DS: %s", wszDN);
	
	return true;
}



BOOL FormThisComputerMsmqDN(LPWSTR wszMsmqConfigDN, DWORD cbLen)
{
	WCHAR wszNetbiosName[50], wszCompDN[500];
	DWORD dwLen;

	// get computer's Netbios name (like alexdad2)

	dwLen = sizeof(wszNetbiosName);
	BOOL b = GetComputerNameEx(ComputerNameNetBIOS, wszNetbiosName, &dwLen);
	if (!b)
	{
		Failed(L"get ComputerNameNetBIOS: 0x%x", GetLastError());
		return FALSE;
	}
	Succeeded(L" find computer NetBIOS name: %s", wszNetbiosName);

	// find computer in the Active Directory tree and get its DN
	//  (alexdad2 --> CN=alexdad2,cn=Computers,DC=ntdev,DC=microsoft,DC=com)
	
	b = FindObjectInDs(wszCompDN, sizeof(wszCompDN)/sizeof(WCHAR), wszNetbiosName, L"computer");
	if (!b)
	{
		Failed(L"find computer %s in the DS", wszNetbiosName);
		return FALSE;
	}
	Succeeded(L" find computer in DS: %s", wszCompDN);
	
	wcscpy(wszMsmqConfigDN, L"CN=msmq,");

	if (wcslen(wszMsmqConfigDN) + wcslen(wszCompDN) > cbLen)
	{
		return false;
	}
	wcscat(wszMsmqConfigDN, wszCompDN);

	return true;
}

//
// General UNICODE/ANSI translation functions
//

// Translation of the ANSI string to UNICODE 

int AnsiToUnicodeString(LPSTR pAnsi, LPWSTR pUnicode, DWORD StringLength)
{
    int iReturn;

    if( StringLength == 0 )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}

// Translation of the UNICODE string to ANSI

int UnicodeToAnsiString(LPWSTR pUnicode, LPSTR pAnsi, DWORD StringLength)
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;

    if( StringLength == 0 ) 
    {
        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }

    //
    // WideCharToMultiByte doesn't NULL terminate if we're copying
    // just part of the string, so terminate here.
    //

    pUnicode[StringLength] = 0;

    //
    // Include one for the NULL
    //
    StringLength++;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //

    if( pAnsi == (LPSTR)pUnicode )
    {
        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength );
        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength,
                                  NULL,
                                  NULL );
    }

    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf && ( rc > 0 ) )
    {
        pAnsi = (LPSTR)pUnicode;
        strcpy( pAnsi, pTempBuf );
        LocalFree( pTempBuf );
    }

    return rc;
}

// Allocating and translation of the Unicode string from ANSI string

LPWSTR AllocateUnicodeString(LPSTR  pAnsiString)
{
    LPWSTR  pUnicodeString = NULL;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR)LocalAlloc(
                        LPTR,
                        strlen(pAnsiString)*sizeof(WCHAR) + sizeof(WCHAR)
                        );

    if (pUnicodeString) 
    {
        AnsiToUnicodeString(
            pAnsiString,
            pUnicodeString,
            0
            );
    }

    return pUnicodeString;
}

// Free Unicode string

void FreeUnicodeString(LPWSTR  pUnicodeString)
{
    LocalFree(pUnicodeString);
    return;
}


//
// Misc helper functions for displaying data.
//

// Prepare Octet String (BLOB) variant value in the UNICODE buffer

BOOL PrepareOctetString(LPWSTR  wszBuf, DWORD cbLen, VARIANT var)
{
    LONG    dwSLBound = 0, 
            dwSUBound = 0,
            i;
    DWORD   cb        = 0;
    HRESULT hr;
    WCHAR   wsz[10];

    wcscpy(wszBuf, L"");

    if(!((V_VT(&var) &  VT_UI1) &&  V_ISARRAY(&var))) 
    {
        return FALSE;
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) 
    {
        return FALSE;
    }

    //
    // Check that there is at least one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0)
    {
        wcscpy(wszBuf, L"<empty>");;
        return TRUE;
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var), 1,  (long FAR *)&dwSLBound);
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var), 1, (long FAR *)&dwSUBound);
    BAIL_ON_FAILURE(hr);

    for (i = dwSLBound; i <= dwSUBound; i++) {
		unsigned char b;
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &b
                                );
        if (FAILED(hr)) 
        {
            continue;
        }

       	wsprintf(wsz, L"%02x ", b);
       	cb += wcslen(wsz);

		if (cb < cbLen - 2 * wcslen(wsz))
		{
	       	wcscat(wszBuf, wsz);
		}
		else if (cb < cbLen)
		{
	       	wcscat(wszBuf, L"...");
		}
    }
    return TRUE;
}

BOOL PrepareVariant(LPWSTR  wszBuf, DWORD cbLen, VARIANT varPropData)
{
    HRESULT hr;
    BSTR    bstrValue;

	if (cbLen < 20)
	{
		return FALSE;
	}

    switch (varPropData.vt) {
    case VT_I4:
        wsprintf(wszBuf, L"%d", varPropData.lVal);
        break;
    case VT_BSTR:
    	if (wcslen(varPropData.bstrVal) < cbLen)
    	{
	        wsprintf(wszBuf, L"%s", varPropData.bstrVal);
	    }
	    else
	    {
	    	wcscpy(wszBuf, L"<...BSTR...>");
	    }
        break;

    case VT_BOOL:
        wsprintf(wszBuf, L"%d", V_BOOL(&varPropData));
        break;

    case (VT_ARRAY | VT_VARIANT):
        PrepareVariantArray(wszBuf, cbLen, varPropData);
        break;

    case (VT_ARRAY | VT_UI1):
        PrepareOctetString(wszBuf, cbLen, varPropData);
        break;
        
    case VT_DATE:
        hr = VarBstrFromDate(
                 varPropData.date,
                 LOCALE_SYSTEM_DEFAULT,
                 LOCALE_NOUSEROVERRIDE,
                 &bstrValue
                 );
        wsprintf(wszBuf, L"%S", bstrValue);
        break;

    default:
        wsprintf(wszBuf, L"Data type is %d\n", varPropData.vt);
        break;

    }

    return TRUE;
}

BOOL PrepareVariantArray(LPWSTR  wszBuf, DWORD cbLen, VARIANT var)
{
    LONG    dwSLBound = 0, 
            dwSUBound = 0,
            i;
    DWORD   cb        = 0;
    HRESULT hr = S_OK;
    VARIANT v;
    WCHAR   wsz[100];
    
    wcscpy(wszBuf, L"");

    if(!((V_VT(&var) &  VT_VARIANT) &&  V_ISARRAY(&var))) 
    {
        return FALSE;
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) 
    {
        return FALSE;
    }
    
    //
    // Check that there is at least one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0)
    {
        wcscpy(wszBuf, L"<empty>");
        return TRUE;
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var), 1, (long FAR *)&dwSLBound);
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var), 1, (long FAR *)&dwSUBound);
    BAIL_ON_FAILURE(hr);

    for (i = dwSLBound; i <= dwSUBound; i++) 
    {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var), (long FAR *)&i, &v);
        if (FAILED(hr)) 
        {
            continue;
        }

		//
		hr = PrepareVariant(wsz, sizeof(wsz), v);
     	cb += wcslen(wsz);

		if (cb < cbLen - 2 * wcslen(wsz))
		{
	       	wcscat(wszBuf, wsz);
		}
		else if (cb < cbLen)
		{
	       	wcscat(wszBuf, L"...");
		}
    }
    
    return TRUE;
}


BOOL PrepareProperty(
    LPWSTR  wszBuf,
    DWORD   cbLen,
    BSTR    /* bstrPropName */,
    HRESULT hRetVal,
    VARIANT varPropData)
{
    switch (hRetVal) {

    case 0:
        return PrepareVariant(wszBuf, cbLen, varPropData);

    case E_ADS_CANT_CONVERT_DATATYPE:
        wcscpy(wszBuf, L"<E_ADS_CANT_CONVERT_DATATYPE>");
        return TRUE;

    default:
        wcscpy(wszBuf, L"<Data not available>");
        return TRUE;
    }
}



//
// Given an ADsPath, bind to the object and get the named property.
//

BOOL GetDSproperty(LPWSTR wszBuf, DWORD cbLen, LPWSTR wszADsPath, LPWSTR wszADsProp)
{
 	HRESULT hr = E_OUTOFMEMORY ;
 	IADs * pADs = NULL;
 	BOOL b = FALSE;

 	//
 	// Convert path to unicode and then bind to the object.
 	//
 	hr = ADsGetObject(
             wszADsPath,
             IID_IADs,
             (void **)&pADs
             );

 	if (FAILED(hr)) 
 	{
     	Failed(L"bind to object: %s\n", wszADsPath);
     	return FALSE;
	}
 	else 
 	{
	  	 VARIANT varProperty;
	  	 
	     hr = pADs->Get(
    	         wszADsProp,
        	     &varProperty);

       	 switch (hr) {
    	 case 0:
        	b = PrepareVariant(wszBuf, cbLen, varProperty);
        	break;

    	case E_ADS_CANT_CONVERT_DATATYPE:
        	wcscpy(wszBuf, L"<E_ADS_CANT_CONVERT_DATATYPE>");
        	break;

    	default:
        	wsprintf(wszBuf, L"<Data not available: 0x%x>", hr);
        	break;
    	}

    	pADs->Release();
 	}

 	return b;
}

//
// Given an ADsPath, bind to the object and get the named property.
//

BOOL SetDsProperty(VARIANT varProperty, LPWSTR wszADsPath, LPWSTR wszADsProp)
{
 	HRESULT hr = E_OUTOFMEMORY ;
 	IADs * pADs = NULL;
 	BOOL b = FALSE;

 	//
 	// Convert path to unicode and then bind to the object.
 	//
 	hr = ADsGetObject(
             wszADsPath,
             IID_IADs,
             (void **)&pADs
             );

 	if (FAILED(hr)) 
 	{
     	Failed(L"bind to object: %s\n", wszADsPath);
     	return FALSE;
	}
 	else 
 	{
	     hr = pADs->Put(
    	         wszADsProp,
        	     varProperty);

   		 if (SUCCEEDED(hr))
   		 {
        		hr = pADs->SetInfo();
		 }

		 if (SUCCEEDED(hr))
		 {
		 	 b = TRUE;
		 }
		 else
		 {
		 	Failed(L"set DS property %s for %s : 0x%x", wszADsProp, wszADsPath, hr);
		 }
		 
    	 pADs->Release();
 	}

 	return b;
}

//
// Given an ADs pointer, dump the contents of the object
//

HRESULT DumpObject(IADs * pADs)
{
 	HRESULT hr;
	HRESULT hrSA;
 	VARIANT var;
	ZeroMemory(&var,sizeof(var));
	VARIANT *   pvarPropName = NULL;
 	DWORD i = 0;
	VARIANT varProperty;


 	//
 	// Access the schema for the object
 	//

 	hr = GetPropertyList(pADs, &var);
 	BAIL_ON_FAILURE(hr);

 	//
 	// List the Properties
	//
	hr = SafeArrayAccessData(var.parray, (void **) &pvarPropName);
	BAIL_ON_FAILURE(hr);

	for (i = 0; i < var.parray->rgsabound[0].cElements; i++)
	{
     	//
     	// Get a property and print it out. The HRESULT is passed to
     	// PrintProperty.
     	//

	 	if (_wcsnicmp(pvarPropName[i].bstrVal, L"msmq", 4) == 0)
	 	{
	     	hr = pADs->Get(
    	    	     pvarPropName[i].bstrVal,
        	    	 &varProperty
            	 	);
 	        WCHAR wszBuf[5000];
			PrepareProperty(
			 		wszBuf,
			 		sizeof(wszBuf),
	        	 	pvarPropName[i].bstrVal,
    		    	hr,
	         		varProperty
    	     		);
        	 printf("%S: %S\n", pvarPropName[i].bstrVal, wszBuf);
      }
	}

	hr = SafeArrayUnaccessData(var.parray);

	if(var.parray) hrSA = SafeArrayDestroy(var.parray);

	return(hr);
}


HRESULT GetPropertyList(IADs * pADs, VARIANT * pvar)
{
 	HRESULT hr= S_OK;
 	BSTR bstrSchemaPath = NULL;
	IADsClass * pADsClass = NULL;

 	hr = pADs->get_Schema(&bstrSchemaPath);
 	BAIL_ON_FAILURE(hr);

 	hr = ADsGetObject(
             bstrSchemaPath,
             IID_IADsClass,
             (void **)&pADsClass);
	if (SUCCEEDED(hr))
	{
		hr = pADsClass->get_OptionalProperties(pvar);
	}
	
	if (bstrSchemaPath) 
	{
     	SysFreeString(bstrSchemaPath);
 	}

 	if (pADsClass) {
     	pADsClass->Release();
 	}

 	return(hr);
}


BOOL GetMyMsmqConfigProperty(LPWSTR wszBuf, 
							 DWORD cbLen, 
							 LPWSTR wszADsProp, 
							 LPWSTR wszSrvName)
{
	WCHAR wszDN[200], wszLdapRequest[250];

	if (!FormThisComputerMsmqDN(wszDN, sizeof(wszDN)))
	{
		Failed(L"FormThisComputerMsmqDN");
		return FALSE;
	}

	wsprintf(wszLdapRequest, L"LDAP://%s/%s", wszSrvName, wszDN);

	
	return GetDSproperty(wszBuf, cbLen, wszLdapRequest, wszADsProp);
}

BOOL SetMyMsmqConfigProperty(
							 VARIANT varProperty, 
							 LPWSTR  wszADsProp, 
							 LPWSTR  wszSrvName)
{
	WCHAR wszDN[200], wszLdapRequest[250];

	if (!FormThisComputerMsmqDN(wszDN, sizeof(wszDN)))
	{
		Failed(L"FormThisComputerMsmqDN");
		return FALSE;
	}

	wsprintf(wszLdapRequest, L"LDAP://%s/%s", wszSrvName, wszDN);

	
	return SetDsProperty(varProperty, wszLdapRequest, wszADsProp);
}


BOOL GetSiteProperty(LPWSTR wszBuf, 
					 DWORD cbLen, 
					 LPWSTR /* wszSiteName */, 
                     LPWSTR wszADsProp, 
                     LPWSTR wszSrvName)
{
	WCHAR wszDN[200], wszLdapRequest[250];

	if (!FormThisSiteDN(wszDN, sizeof(wszDN)))
	{
		Failed(L"FormThisSiteDN");
		return FALSE;
	}

	wsprintf(wszLdapRequest, L"LDAP://%s/%s", wszSrvName, wszDN);

	
	return GetDSproperty(wszBuf, cbLen, wszLdapRequest, wszADsProp);
}


BOOL PrepareGuidAsVariantArray(LPWSTR wszGuid, VARIANT *pv)
{
	HRESULT hr = 0;
	union {
	   GUID  guid;
	   UCHAR bytes[16];
	} guid_bytes;

	ReportString2GUID(&guid_bytes.guid, wszGuid);

    SAFEARRAYBOUND  saBounds;
    saBounds.lLbound   = 0;
    saBounds.cElements = 1;
    pv->parray = SafeArrayCreate(VT_VARIANT, 1, &saBounds);
    pv->vt = VT_VARIANT | VT_ARRAY;

    // Fill safe array with GUIDs ( each GUID is a safe array)
    LONG   lTmp, lNum;
    lNum = 1;
    for (lTmp = 0; lTmp < lNum; lTmp++)
    {
    	VARIANT varTmp;

		varTmp.parray = SafeArrayCreateVector(VT_UI1, 0, 16);
		if (varTmp.parray == NULL)
		{
           	Failed(L"SafeArrayPutElement");
           	return FALSE;
        }
		varTmp.vt = VT_ARRAY | VT_UI1;

		for (long i=0; i<16; i++)
		{
		    hr = SafeArrayPutElement(
		            varTmp.parray,
			        &i,
			        guid_bytes.bytes +i);
            if (FAILED(hr))
            {
           		Failed(L"SafeArrayPutElement");
	           	return FALSE;
            }
		}

        //
        // Add safearray variant to safe array
        //
        hr = SafeArrayPutElement(pv->parray, &lTmp, &varTmp);
        if (FAILED(hr))
        {
        	Failed(L"SafeArrayPutElement");
	       	return FALSE;
        }
    }

    return TRUE;
}



#if 0
bool FindObject(
	 IDirectorySearch *pContainerToSearch,  //IDirectorySearch pointer to the container to search.
     LPOLESTR szFilter,						//Filter for finding specific users, NULL returns all user objects.
     LPOLESTR *pszPropertiesToReturn,		//Properties to return for user objects found, NULL returns all set properties.
     BOOL bIsVerbose    //TRUE means all properties for the found objects are displayed, FALSE means only the RDN
              )
{
	if (!pContainerToSearch)
		return false;

	//Create search filter
	LPOLESTR pszSearchFilter = new OLECHAR[MAX_PATH*2];
 
	//Add the filter.
	wsprintf(pszSearchFilter, L"(&(objectClass=computer)(objectCategory=person)%s)",szFilter);

    WCHAR filter[1000];  
    wcscat(filter, L"(&(objectClass=computer)(cn=");
    wcscat(filter, pwcsComputerName);
    wcscat(filter, L"))");
    WCHAR AttributeName[] = L"distinguishedName";

	

  //Specify subtree search
  ADS_SEARCHPREF_INFO SearchPrefs;
  SearchPrefs.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
  SearchPrefs.vValue.dwType = ADSTYPE_INTEGER;
  SearchPrefs.vValue.Integer = ADS_SCOPE_SUBTREE;
  DWORD dwNumPrefs = 1;
 
  // COL for iterations
  LPOLESTR pszColumn = NULL;  
  ADS_SEARCH_COLUMN col;
  HRESULT hr;
  
  // Interface Pointers
  IADs  *pObj = NULL;
  IADs  * pIADs = NULL;
 
  // Handle used for searching.
  ADS_SEARCH_HANDLE hSearch = NULL;
  
  // Set the search preference.
  hr = pContainerToSearch->SetSearchPreference( &SearchPrefs, dwNumPrefs);
  if (FAILED(hr))
    return hr;
 
  LPOLESTR pszBool = NULL;
  DWORD dwBool;
  PSID pObjectSID = NULL;
  LPOLESTR szSID = NULL;
  LPOLESTR szDSGUID = new WCHAR [39];
  LPGUID pObjectGUID = NULL;
  FILETIME filetime;
  SYSTEMTIME systemtime;
  DATE date;
  VARIANT varDate;
  LARGE_INTEGER liValue;
  LPOLESTR *pszPropertyList = NULL;
  LPOLESTR pszNonVerboseList[] = {L"name",L"distinguishedName"};
 
  LPOLESTR szName = new OLECHAR[MAX_PATH];
  LPOLESTR szDN = new OLECHAR[MAX_PATH];
 
  int iCount = 0;
  DWORD x = 0L;
 
 
 
  if (!bIsVerbose)
  {
     //Return non-verbose list properties only.
     hr = pContainerToSearch->ExecuteSearch(pszSearchFilter,
                  pszNonVerboseList,
                  sizeof(pszNonVerboseList)/sizeof(LPOLESTR),
                  &hSearch
                  );
  }
  else
  {
    if (!pszPropertiesToReturn)
    {
      //Return all properties.
      hr = pContainerToSearch->ExecuteSearch(pszSearchFilter,
                  NULL,
                  0L,
                  &hSearch
                  );
    }
    else
    {
      //Specified subset.
      pszPropertyList = pszPropertiesToReturn;
       //Return specified properties.
       hr = pContainerToSearch->ExecuteSearch(pszSearchFilter,
                  pszPropertyList,
                  sizeof(pszPropertyList)/sizeof(LPOLESTR),
                  &hSearch
                  );
    }
  }
   if ( SUCCEEDED(hr) )
  {  
  // Call IDirectorySearch::GetNextRow() to retrieve the next row 
  //of data.
    hr = pContainerToSearch->GetFirstRow( hSearch);
    if (SUCCEEDED(hr))
    {
    while( hr != S_ADS_NOMORE_ROWS )
    {
      //Keep track of count.
      iCount++;
      if (bIsVerbose)
        wprintf(L"----------------------------------\n");
      // Loop through the array of passed column names,
      // print the data for each column.
 
      while( pContainerToSearch->GetNextColumnName( hSearch, &pszColumn ) != S_ADS_NOMORE_COLUMNS )
      {
        hr = pContainerToSearch->GetColumn( hSearch, pszColumn, &col );
        if ( SUCCEEDED(hr) )
        {
          // Print the data for the column and free the column.
          if(bIsVerbose)
          {
          // Get the data for this column.
          wprintf(L"%s\n",col.pszAttrName);
          switch (col.dwADsType)
          {
            case ADSTYPE_DN_STRING:
              for (x = 0; x< col.dwNumValues; x++)
              {
                wprintf(L"  %s\r\n",col.pADsValues[x].DNString);
              }
              break;
            case ADSTYPE_CASE_EXACT_STRING:    
            case ADSTYPE_CASE_IGNORE_STRING:    
            case ADSTYPE_PRINTABLE_STRING:    
            case ADSTYPE_NUMERIC_STRING:      
            case ADSTYPE_TYPEDNAME:        
            case ADSTYPE_FAXNUMBER:        
            case ADSTYPE_PATH:          
            case ADSTYPE_OBJECT_CLASS:
              for (x = 0; x< col.dwNumValues; x++)
              {
                wprintf(L"  %s\r\n",col.pADsValues[x].CaseIgnoreString);
              }
              break;
            case ADSTYPE_BOOLEAN:
              for (x = 0; x< col.dwNumValues; x++)
              {
                dwBool = col.pADsValues[x].Boolean;
                pszBool = dwBool ? L"TRUE" : L"FALSE";
                wprintf(L"  %s\r\n",pszBool);
              }
              break;
            case ADSTYPE_INTEGER:
              for (x = 0; x< col.dwNumValues; x++)
              {
                wprintf(L"  %d\r\n",col.pADsValues[x].Integer);
              }
              break;
            case ADSTYPE_OCTET_STRING:
              if ( _wcsicmp(col.pszAttrName,L"objectSID") == 0 )
              {
                for (x = 0; x< col.dwNumValues; x++)
                {
                  pObjectSID = (PSID)(col.pADsValues[x].OctetString.lpValue);
                  //Convert SID to string.
                  ConvertSidToStringSid(pObjectSID, &szSID);
                  wprintf(L"  %s\r\n",szSID);
                  LocalFree(szSID);
                }
              }
              else if ( (_wcsicmp(col.pszAttrName,L"objectGUID") == 0) )
              {
                for (x = 0; x< col.dwNumValues; x++)
                {
                //Cast to LPGUID
                pObjectGUID = (LPGUID)(col.pADsValues[x].OctetString.lpValue);
                //Convert GUID to string.
                ::StringFromGUID2(*pObjectGUID, szDSGUID, 39); 
                //Print the GUID
                wprintf(L"  %s\r\n",szDSGUID);
                }
              }
              else
                wprintf(L"  Value of type Octet String. No Conversion.");
              break;
            case ADSTYPE_UTC_TIME:
              for (x = 0; x< col.dwNumValues; x++)
              {
              systemtime = col.pADsValues[x].UTCTime;
              if (SystemTimeToVariantTime(&systemtime,
                            &date) != 0) 
              {
                //Pack in variant.vt.
                varDate.vt = VT_DATE;
                varDate.date = date;
                VariantChangeType(&varDate,&varDate,VARIANT_NOVALUEPROP,VT_BSTR);
                wprintf(L"  %s\r\n",varDate.bstrVal);
                VariantClear(&varDate);
              }
              else
                wprintf(L"  Could not convert UTC-Time.\n",pszColumn);
              }
              break;
            case ADSTYPE_LARGE_INTEGER:
              for (x = 0; x< col.dwNumValues; x++)
              {
              liValue = col.pADsValues[x].LargeInteger;
              filetime.dwLowDateTime = liValue.LowPart;
              filetime.dwHighDateTime = liValue.HighPart;
              if((filetime.dwHighDateTime==0) && (filetime.dwLowDateTime==0))
                {
                wprintf(L"  No value set.\n");
                }
              else
              {
                //Check for properties of type LargeInteger that represent time.
                //If TRUE, then convert to variant time.
                if ((0==wcscmp(L"accountExpires", col.pszAttrName))|
                  (0==wcscmp(L"badPasswordTime", col.pszAttrName))||
                  (0==wcscmp(L"lastLogon", col.pszAttrName))||
                  (0==wcscmp(L"lastLogoff", col.pszAttrName))||
                  (0==wcscmp(L"lockoutTime", col.pszAttrName))||
                  (0==wcscmp(L"pwdLastSet", col.pszAttrName))
                   )
                {
                  //Handle special case for Never Expires where low part is -1
                  if (filetime.dwLowDateTime==-1)
                  {
                    wprintf(L"  Never Expires.\n");
                  }
                  else
                    {
                    if (FileTimeToLocalFileTime(&filetime, &filetime) != 0) 
                      {
                      if (FileTimeToSystemTime(&filetime,
                                 &systemtime) != 0)
                        {
                        if (SystemTimeToVariantTime(&systemtime,
                                      &date) != 0) 
                          {
                          //Pack in variant.vt.
                          varDate.vt = VT_DATE;
                          varDate.date = date;
                          VariantChangeType(&varDate,&varDate,VARIANT_NOVALUEPROP,VT_BSTR);
                          wprintf(L"  %s\r\n",varDate.bstrVal);
                          VariantClear(&varDate);
                          }
                        else
                          {
                          wprintf(L"  FileTimeToVariantTime failed\n");
                          }
                        }
                      else
                        {
                        wprintf(L"  FileTimeToSystemTime failed\n");
                        }
 
                      }
                    else
                      {
                      wprintf(L"  FileTimeToLocalFileTime failed\n");
                      }
                    }
                  }
                else
                  {
                  //Print the LargeInteger.
                  wprintf(L"  high: %d low: %d\r\n",filetime.dwHighDateTime, filetime.dwLowDateTime);
                  }
                }
              }
              break;
            case ADSTYPE_NT_SECURITY_DESCRIPTOR:
              for (x = 0; x< col.dwNumValues; x++)
                {
                wprintf(L"  Security descriptor.\n");
                }
              break;
            default:
              wprintf(L"Unknown type %d.\n",col.dwADsType);
            }
          }
          else
          {
          //Verbose handles only the two single-valued attributes: cn and ldapdisplayname
          //so this is a special case.
          if (0==wcscmp(L"name", pszColumn))
          {
            wcscpy(szName,col.pADsValues->CaseIgnoreString);
          }
          if (0==wcscmp(L"distinguishedName", pszColumn))
            {
            wcscpy(szDN,col.pADsValues->CaseIgnoreString);
            }
          }
          pContainerToSearch->FreeColumn( &col );
        }
        FreeADsMem( pszColumn );
      }
       if (!bIsVerbose)
         wprintf(L"%s\n  DN: %s\n\n",szName,szDN);
       //Get the next row
       hr = pContainerToSearch->GetNextRow( hSearch);
    }
 
    }
    // Close the search handle to clean up
    pContainerToSearch->CloseSearchHandle(hSearch);
  } 
  if (SUCCEEDED(hr) && 0==iCount)
    hr = S_FALSE;
 
  return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\hauthen.h ===
//
// file: hauthen.h
//

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>

extern "C" RPC_IF_HANDLE hauthen_i_v1_0_s_ifspec ;
extern const char  x_szUsage[];

typedef unsigned char * LPUSTR ;

#define PROTOSEQ_TCP   ((LPUSTR) "ncacn_ip_tcp")
#define ENDPOINT_TCP   ((LPUSTR) "4000")
#define OPTIONS_TCP    ((LPUSTR) "")

#define PROTOSEQ_LOCAL   ((LPUSTR) "ncalrpc")
#define ENDPOINT_LOCAL   ((LPUSTR) "MyLocalTestEP")
#define OPTIONS_LOCAL    ((LPUSTR) "Security=Impersonation Dynamic True")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\hauthen1.h ===
const char  x_szUsage[] = { "\n\n"
                      "\tTMQ RPC tool helps eveluate the health of RPC connection\n"
                      "\tOn the server side, run TMQ RPCS; \n"
                      "\tOn the client side, run TMQ RPCC with the server machine name\n"
                      "\tServer starts listening to incoming RPC calls\n"
                      "\tClient makes RPC call with specified charaqcteristics\n"
                      "\tFinal result is printed on the client side \n"
                      "\tDetailed diagnostics can be found on both sides\n"
                      "\tIf msmq1.0 or local users are not involved, then always use kerberos (default).\n"
                      "\tTo distinguish network and security problems, try -t (no authentication)\n"
                      };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\base\base.h ===
// This library containg common services fpr the tools
// for now, it is mainly reporting; it can grow though
//
// AlexDad, February 2000
// 

#ifndef _TMQBASE__
#define _TMQBASE__

// these functions are provided by tmqbase.lib

void Output(LPSTR pszStr);
void DebugMsg(WCHAR * Format, ...);
void GoingTo(WCHAR * Format, ...);
void Succeeded(WCHAR * Format, ...);
void Failed(WCHAR * Format, ...);
void Warning(WCHAR * Format, ...);
void Inform(WCHAR * Format, ...);
BOOL IsMsmqRunning(LPWSTR wszServiceName);
void LogRunCase();


// these functions are provided by caller and used in tmqbase.lib

extern FILE *ToolLog();
extern BOOL ToolVerbose();
extern BOOL ToolVerboseDebug();
extern BOOL ToolThreadReport();

//
// this is a standard entry point for each tool dll
//
int _stdcall run(int argc, char* argv[]);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\ping.cpp ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ping.cpp - 	Borrowed from windows\spooler\inetpp\ping.cxx 

Abstract:

    Packet INternet Groper utility for TCP/IP.

Author:
    Numerous TCP/IP folks.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    WeihaiC     5-Dec-98.   Moved from \nt\private\net\sockets\tcpcmd\ping
    MohsinA,    21-Oct-96.  INADDR_NONE check to avoid broadcast.
    MohsinA,    13-Nov-96.  Max packet size < 64K.

Notes:

--*/

//:ts=4
typedef unsigned long   ulong;
typedef unsigned short  ushort;
typedef unsigned int    uint;
typedef unsigned char   uchar;

#define NOGDI
#define NOMINMAX
#include    <windows.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <ctype.h>
#include    <io.h>
#include    <winsock.h>
#include    "ipexport.h"

extern "C" {
#include    "icmpapi.h"
}


#define MAX_BUFFER_SIZE       (sizeof(ICMP_ECHO_REPLY) + 0xfff7 + MAX_OPT_SIZE)
#define DEFAULT_BUFFER_SIZE         (0x2000 - 8)
#define DEFAULT_SEND_SIZE           32
#define DEFAULT_COUNT               4
#define DEFAULT_TTL                 32
#define DEFAULT_TOS                 0
#define DEFAULT_TIMEOUT             5000L
#define MIN_INTERVAL                1000L
#define TRUE                        1
#define FALSE                       0
#define STDOUT                      1

#define net_long(x) (((((ulong)(x))&0xffL)<<24) | \
                     ((((ulong)(x))&0xff00L)<<8) | \
                     ((((ulong)(x))&0xff0000L)>>8) | \
                     ((((ulong)(x))&0xff000000L)>>24))

#ifdef VXD

#define FAR _far

#endif // VXD


WSADATA WsaData;


// ========================================================================
// Caveat: return 0 for invalid, else internet address.
//         I would prefer -1 for error. - MohsinA, 21-Nov-96.

unsigned long
get_pingee(char *ahstr, char **hstr, int *was_inaddr, int dnsreq)
{
        struct hostent *hostp = NULL;
        long            inaddr;

        if( strcmp( ahstr, "255.255.255.255" ) == 0 ){
            return 0L;
        }

        if ((inaddr = inet_addr(ahstr)) == -1L) {
            hostp = gethostbyname(ahstr);
            if (hostp) {
                /*
                 * If we find a host entry, set up the internet address
                 */
                inaddr = *(long *)hostp->h_addr;
                *was_inaddr = 0;
            } else {
                // Neither dotted, not name.
                return(0L);
            }

        } else {
            // Is dotted.
            *was_inaddr = 1;
            if (dnsreq == 1) {
                hostp = gethostbyaddr((char *)&inaddr,sizeof(inaddr),AF_INET);
            }
        }

        *hstr = hostp ? hostp->h_name : (char *)NULL;
        return(inaddr);
}




// ========================================================================

BOOL Ping (LPTSTR pszServerName) 
{
    uint    i;
    int     dnsreq = 0;
    char    *hostname = NULL;
    int     was_inaddr;
    DWORD   numberOfReplies;
    uchar   TTL = DEFAULT_TTL;
    uchar FAR  *Opt = (uchar FAR *)0;         // Pointer to send options
    uint    OptLength = 0;
    uchar   TOS = DEFAULT_TOS;
    uchar   Flags = 0;
    ulong   Timeout = DEFAULT_TIMEOUT;
    IP_OPTION_INFORMATION SendOpts;
    DWORD   errorCode;
    HANDLE  IcmpHandle = NULL;
    struct in_addr addr;
    PICMP_ECHO_REPLY  reply;
    char    *SendBuffer = NULL;
    char    *RcvBuffer = NULL;
    uint    RcvSize;
    uint    SendSize = DEFAULT_SEND_SIZE;
    BOOL    bRet = FALSE;
    IPAddr  address = 0;   // was local to main earlier.
    char    *arg;

    // ====================================================================

#ifdef UNICODE

    LPSTR pszAnsiServerName = NULL;

    if (pszServerName)
    {
        DWORD uSize = WideCharToMultiByte(CP_ACP,
                                          0,
                                          pszServerName, 
                                          -1,
                                          NULL, 
                                          0,
                                          NULL,
                                          NULL);
        if (uSize != 0) {
    
            pszAnsiServerName = (LPSTR) LocalAlloc(LPTR, uSize);
            if (pszAnsiServerName != 0) {
                if (!WideCharToMultiByte (CP_ACP,
                                          0,
                                          pszServerName, 
                                          -1,
                                          pszAnsiServerName, 
                                          uSize,
                                          NULL,
                                          NULL))
                
                    goto CleanUp;

            }
            else
                goto CleanUp;
        }

    }

    arg = pszAnsiServerName;

#else
    arg = pszServerName;
#endif


    if (WSAStartup( 0x0101, &WsaData))
        goto CleanUp;

    // Added check for INADDR_NONE, MohsinA, 21-Oct-96.

    address = get_pingee(arg, &hostname, &was_inaddr, dnsreq);
    if(!address || (address == INADDR_NONE) ){
        SetLastError (DNS_ERROR_INVALID_IP_ADDRESS);
        goto CleanUp;
    }

    IcmpHandle = IcmpCreateFile();

    if (IcmpHandle == INVALID_HANDLE_VALUE) {
        goto CleanUp;
    }

    SendBuffer = (char *) LocalAlloc(LMEM_FIXED, SendSize);
    if (!SendBuffer) {
        goto CleanUp;
    }

    //
    // Calculate receive buffer size and try to allocate it.
    //
    if (SendSize <= DEFAULT_SEND_SIZE) {
        RcvSize = DEFAULT_BUFFER_SIZE;
    }
    else {
        RcvSize = MAX_BUFFER_SIZE;
    }

    RcvBuffer = (char *)LocalAlloc(LMEM_FIXED, RcvSize);
    if (!RcvBuffer) {
        goto CleanUp;
    }
    
    //
    // Initialize the send buffer pattern.
    //
    for (i = 0; i < SendSize; i++) {
        SendBuffer[i] = (char)('a' + (i % 23));
    }

    //
    // Initialize the send options
    //
    SendOpts.OptionsData = Opt;
    SendOpts.OptionsSize = (uchar)OptLength;
    SendOpts.Ttl = TTL;
    SendOpts.Tos = TOS;
    SendOpts.Flags = Flags;

    addr.s_addr = address;

#if 0
    if (hostname) {
        NlsPutMsg(
            STDOUT,
            PING_HEADER1,
            hostname,
            inet_ntoa(addr),
            SendSize
        );
        // printf("Pinging Host %s [%s]\n", hostname, inet_ntoa(addr));
    } else {
        NlsPutMsg(
            STDOUT,
            PING_HEADER2,
            inet_ntoa(addr),
            SendSize
        );
        // printf("Pinging Host [%s]\n", inet_ntoa(addr));
    }
#endif

//    for (i = 0; i < Count; i++) {
    numberOfReplies = IcmpSendEcho(
        IcmpHandle,
        address,
        SendBuffer,
        (unsigned short) SendSize,
        &SendOpts,
        RcvBuffer,
        RcvSize,
        Timeout
    );

    if (numberOfReplies == 0) {

        errorCode = GetLastError();

        goto CleanUp;
        // Need to try again? - weihaic
    }
    else {

        reply = (PICMP_ECHO_REPLY) RcvBuffer;

        while (numberOfReplies--) {
            struct in_addr addr;

            addr.S_un.S_addr = reply->Address;

            // printf(
            //     "Reply from %s:",
            //     inet_ntoa(addr),
            //         );

            if (reply->Status == IP_SUCCESS) {
                
                // printf(
                //     "Echo size=%d ",
                //         reply->DataSize
                //         );

                bRet = TRUE;
                break;


                // printf("\n time rt=%dms min %d, max %d, total %d\n",
                //        reply->RoundTripTime,
                //        time_min, time_max, time_total );

                // printf("TTL=%u\n", (uint)reply->Options.Ttl);

                //
                // Ignore Option fields
                // if (reply->Options.OptionsSize) {
                //    ProcessOptions(reply, (BOOLEAN) dnsreq);
                //}
            }
/*                else {
                for (j=0; ErrorTable[j].Error != IP_GENERAL_FAILURE; j++) {
                    if (ErrorTable[j].Error == reply->Status) {
                        break;
                    }
                }

            }    */

            reply++;
        }

    }
//    }

CleanUp:

#ifdef UNICODE
    if (pszAnsiServerName) {
        LocalFree(pszAnsiServerName);
    }
#endif
    
    if (IcmpHandle) {
        IcmpCloseHandle(IcmpHandle);
    }

    if (SendBuffer) {
        LocalFree(SendBuffer);
    }

    if (RcvBuffer) {
        LocalFree(RcvBuffer);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\comapps\mqsendex\mqsendex.cpp ===
// MQSENDEX.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "MQSENDEX.h"
#include "MQSENDEXDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMQSENDEXApp

BEGIN_MESSAGE_MAP(CMQSENDEXApp, CWinApp)
	//{{AFX_MSG_MAP(CMQSENDEXApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMQSENDEXApp construction

CMQSENDEXApp::CMQSENDEXApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMQSENDEXApp object

CMQSENDEXApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMQSENDEXApp initialization

BOOL CMQSENDEXApp::InitInstance()
{
	AfxEnableControlContainer();

	// Initialize OLE libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(TEXT("Unable to initialize OLE"));
		return FALSE;
	}

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CMQSENDEXDlg dlg;
	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\base\base.cpp ===
// This library containg common services fpr the tools
// for now, it is mainly reporting; it can grow though
//
// AlexDad, February 2000
// 

#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <tchar.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>
#include <winsvc.h>

#include "base.h"

void Output(LPSTR pszStr)
{
    DWORD dwtid = GetCurrentThreadId();

    if (ToolLog())
    {
    	if (ToolThreadReport())
    	{
	        fprintf(ToolLog(), "t%04x   %s\n", dwtid, pszStr);
	    }
	    else
	    {
	        fprintf(ToolLog(), "%s\n", pszStr);
	    }
    }

	if (ToolThreadReport())
  	{
    	printf("t%03x   %s\n", dwtid, pszStr);
    }
    else
    {
    	printf("%s\n", pszStr);
    }
}


void DebugMsg(WCHAR * Format, ...)
{
    va_list Args;
	WCHAR buf[500];
    char szBuf[500];

    if ( ToolVerboseDebug() )
    {
        //
        // set the Format string into a buffer
        //
        va_start(Args,Format);
        _vsntprintf(buf, 500, Format, Args);

        //
        // output the buffer
        //
        sprintf( szBuf, "%ws", buf);
        Output(szBuf);
    }
}


void GoingTo(WCHAR * Format, ...)
{
    va_list Args;
	WCHAR buf[500];
    char szBuf[500];

    va_start(Args,Format);
    _vsntprintf(buf, 500, Format, Args);

    if (ToolVerboseDebug())
    {
        sprintf( szBuf, "--- Going to %ws", buf);
        Output(szBuf);
    }
}

void Succeeded(WCHAR * Format, ...)
{
    va_list Args;
	WCHAR buf[500];
    char szBuf[500];

    va_start(Args,Format);
    _vsntprintf(buf, 500, Format, Args);

    if (ToolVerboseDebug())
    {
        sprintf( szBuf, "+++ Succeeded: %ws", buf);
        Output(szBuf);
    }
}

void Failed(WCHAR * Format, ...)
{
    va_list Args;
	WCHAR buf[500];
    char szBuf[500];

    va_start(Args,Format);
    _vsntprintf(buf, 500, Format, Args);

    sprintf( szBuf, "!!! Failed to %ws", buf);
    Output(szBuf);

//  exit(0);
}

void Warning(WCHAR * Format, ...)
{
    va_list Args;
	WCHAR buf[500];
    char szBuf[500];

    va_start(Args,Format);
    _vsntprintf(buf, 500, Format, Args);

    sprintf( szBuf, "!*! Warning: %ws", buf);
    Output(szBuf);
}

void Inform(WCHAR * Format, ...)
{
    va_list Args;
	WCHAR buf[500];
    char szBuf[500];

    va_start(Args,Format);
    _vsntprintf(buf, 500, Format, Args);

    sprintf( szBuf, "%ws", buf);
    Output(szBuf);
}

BOOL 
IsMsmqRunning(LPWSTR wszServiceName)
{
    SC_HANDLE ServiceController;
    SC_HANDLE Csnw;
    SERVICE_STATUS ServiceStatus;

    ServiceController = OpenSCManager (NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);
    if (NULL == ServiceController)
    {
        return FALSE;
    }

    Csnw = OpenService (ServiceController, wszServiceName, SERVICE_QUERY_STATUS);
    if (NULL == Csnw)
    {
        CloseServiceHandle(ServiceController);
        return FALSE;
    }

    if (FALSE == QueryServiceStatus (Csnw, &ServiceStatus))
    {
        CloseServiceHandle(ServiceController);
        CloseServiceHandle(Csnw);

        return FALSE;
    }

    BOOL f = (ServiceStatus.dwCurrentState != SERVICE_STOPPED);

    CloseServiceHandle(ServiceController);
    CloseServiceHandle(Csnw);

    return f;
}

void LogRunCase()
{
	// Machine name
	//
    WCHAR wszMachine[MAX_COMPUTERNAME_LENGTH + 1]; 
    DWORD dwMachineNamesize =  sizeof(wszMachine) / sizeof(TCHAR);
    if (!GetComputerName(wszMachine, &dwMachineNamesize))
    {
    	wcscpy(wszMachine, L"--unknown--");
    }

    // Time and date.
    //
    time_t  lTime ;
    WCHAR wszTime[ 128 ] ;
    time( &lTime ) ;
    swprintf(wszTime, L"%s", _wctime( &lTime ) );
    wszTime[ wcslen(wszTime)-1 ] = 0 ; // remove line feed.

	Inform(L"Machine %s , time is %s", wszMachine, wszTime);

    // OS info
    //
    OSVERSIONINFOEX verOsInfo;
    verOsInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if (GetVersionEx(( LPOSVERSIONINFO )&verOsInfo))
    {
        Inform(L"*** OS: %d.%d  Build: %d  Product type (%d):  %s",
               verOsInfo.dwMajorVersion, 
               verOsInfo.dwMinorVersion,
               verOsInfo.dwBuildNumber,
               verOsInfo.wProductType,
               (verOsInfo.wProductType == VER_NT_WORKSTATION ? L"Windows 2000 Professional" : 
               (verOsInfo.wProductType == VER_NT_SERVER      ? L"Windows 2000 Server" :
               (verOsInfo.wProductType == VER_NT_DOMAIN_CONTROLLER ? L"Windows 2000 domain controller" : 
               L"*** Unknown product type***"))));

		if (verOsInfo.dwPlatformId != VER_PLATFORM_WIN32_NT)
		{
			Warning(L"***Platform: %d ",  verOsInfo.dwPlatformId);
		}

		if (verOsInfo.wServicePackMajor!=0 || verOsInfo.wServicePackMinor!=0)
		{
	        Inform(L"*** OS Service Pack: %d.%d  %s",
               verOsInfo.wServicePackMajor, 
               verOsInfo.wServicePackMinor,
               verOsInfo.szCSDVersion);
        }

		if (verOsInfo.wSuiteMask & VER_SUITE_BACKOFFICE)
		{
			Inform(L"*** %s in installed", L"Backoffice");
		}

		if (verOsInfo.wSuiteMask & VER_SUITE_DATACENTER)
		{
			Inform(L"*** %s in installed", L"Datacenter Server");
		}

		if (verOsInfo.wSuiteMask & VER_SUITE_ENTERPRISE)
		{
			Inform(L"*** %s in installed", L"Advanced Server");
		}

		if (verOsInfo.wSuiteMask & VER_SUITE_SMALLBUSINESS)
		{
			Inform(L"*** %s in installed", L"Small Business Server");
		}

		if (verOsInfo.wSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED)
		{
			Inform(L"*** %s in installed", L"Small Business Server Restricted");
		}

		if (verOsInfo.wSuiteMask & VER_SUITE_TERMINAL)
		{
			Inform(L"*** %s in installed", L"Terminal Server");
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\comapps\mqsendex\mqsendex.h ===
// MQSENDEX.h : main header file for the MQSENDEX application
//

#if !defined(AFX_MQSENDEX_H__B1868375_6FEA_4BB2_9790_03F038C81EC5__INCLUDED_)
#define AFX_MQSENDEX_H__B1868375_6FEA_4BB2_9790_03F038C81EC5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CMQSENDEXApp:
// See MQSENDEX.cpp for the implementation of this class
//

class CMQSENDEXApp : public CWinApp
{
public:
	CMQSENDEXApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMQSENDEXApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMQSENDEXApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MQSENDEX_H__B1868375_6FEA_4BB2_9790_03F038C81EC5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\comapps\mqsendex\mqsendexdlg.h ===
// MQSENDEXDlg.h : header file
//

#if !defined(AFX_MQSENDEXDLG_H__DE3219B2_6520_4C93_BC65_9EBE190C1C75__INCLUDED_)
#define AFX_MQSENDEXDLG_H__DE3219B2_6520_4C93_BC65_9EBE190C1C75__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CMQSENDEXDlg dialog

class CMQSENDEXDlg : public CDialog
{
// Construction
public:
	CMQSENDEXDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CMQSENDEXDlg)
	enum { IDD = IDD_MQSENDEX_DIALOG };
	CString	m_szQueueName;
	BOOL	m_bTransactional;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMQSENDEXDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation

	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CMQSENDEXDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnSendMsg();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	IMSMQQueueInfo2Ptr		pQueueInfo;
	IMSMQQueue2Ptr			pQueue;
	IMSMQMessage2Ptr		pMsg;
	IMSMQEvent2Ptr			pEvent;
	IMSMQTransactionDispenser2Ptr pTransactionObj;
	IMSMQTransaction2Ptr		trans;

	
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MQSENDEXDLG_H__DE3219B2_6520_4C93_BC65_9EBE190C1C75__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\comapps\mqsendex\mqsendexdlg.cpp ===
// MQSENDEXDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MQSENDEX.h"
#include "MQSENDEXDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMQSENDEXDlg dialog

CMQSENDEXDlg::CMQSENDEXDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CMQSENDEXDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMQSENDEXDlg)
	m_szQueueName = _T("");
	m_bTransactional = FALSE;
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CMQSENDEXDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMQSENDEXDlg)
	DDX_Text(pDX, IDC_QUEUE_NAME, m_szQueueName);
	DDX_Check(pDX, IDC_TRANSACTIONAL, m_bTransactional);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMQSENDEXDlg, CDialog)
	//{{AFX_MSG_MAP(CMQSENDEXDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_SEND_MSG, OnSendMsg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMQSENDEXDlg message handlers

BOOL CMQSENDEXDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CMQSENDEXDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CMQSENDEXDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CMQSENDEXDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CMQSENDEXDlg::OnSendMsg() 
{
	HRESULT hr;

	UpdateData(TRUE);
	hr = pQueueInfo.CreateInstance(CLSID_MSMQQueueInfo);

	hr = pMsg.CreateInstance(CLSID_MSMQMessage);

	hr = pTransactionObj.CreateInstance(CLSID_MSMQTransactionDispenser);


	CComBSTR	bstrQueueName;
	bstrQueueName = m_szQueueName;
//	pQueueInfo->PathName = (LPCTSTR)m_szQueueName;	
	pQueueInfo->FormatName = (LPCTSTR)m_szQueueName;	
	pQueue = pQueueInfo->Open(MQ_SEND_ACCESS, MQ_DENY_NONE);

	pMsg->Body = "ABCDEFG";


	if(pQueue)
	{
	CComVariant	var;
	CComVariant varEmpty;
	IMSMQTransactionPtr pTransObj;

//		hr = pTransObj.CreateInstance(CLSID_MSMQTransaction);

		if(SUCCEEDED(hr))
		{
//		long TxID, TxID1;
//			pTransObj = pTransactionObj->BeginTransaction();
//			TxID = pTransObj->Transaction;
			
			if(m_bTransactional)
			{
				var = MQ_SINGLE_MESSAGE;
			}
			pMsg->Send(pQueue, &var);
//			pTransObj->Commit();

		}

		pQueue->Close();
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\comapps\mqsendex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MQSENDEX.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_MQSENDEX_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDC_QUEUE_NAME                  1000
#define IDC_TRANSACTIONAL               1001
#define IDC_SEND_MSG                    1002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\comapps\mqsendex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	MQSENDEX.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\registry.h ===
//
// Registry section of MSMQ is based on the service name.
// This allows multiple QMs to live on same machine, each
// with its own registry section. (ShaiK)
//

//-------------------------------------------------------
//
//  LONG OpenFalconKey(void)
//
//-------------------------------------------------------
LONG OpenFalconKey()
{
    LONG rc;

    wcscpy(g_tRegKeyName, FALCON_REG_KEY) ;

    if (0 != CompareStringsNoCase(g_tszService, QM_DEFAULT_SERVICE_NAME))
    {
        //
        // Multiple QMs environment. I am a clustered QM !
        //
        wcscpy(g_tRegKeyName, FALCON_CLUSTERED_QMS_REG_KEY);
        wcscat(g_tRegKeyName, g_tszService);
        wcscat(g_tRegKeyName, FALCON_REG_KEY_PARAM);
    }

    rc = RegOpenKeyEx (FALCON_REG_POS,
                       g_tRegKeyName,
                       0L,
                       KEY_READ | KEY_WRITE,
                       &g_hKeyFalcon);

    if (rc != ERROR_SUCCESS)
    {
       rc = RegOpenKeyEx (FALCON_REG_POS,
                          g_tRegKeyName,
                          0L,
                          KEY_READ,
                          &g_hKeyFalcon);
    }

    //ASSERT(rc == ERROR_SUCCESS);

    return rc;
}

/*=============================================================

  FUNCTION:  GetValueKey

  the function returns an handle to open key and the value name.
  If the use value name contains a sub key, it create/open it and returns
  an handle to the subkey; otherwise an handel to Falcon key is returned.

  PARAMETERS:
     pszValueName - Input, user value name. can contain a sub key

     pszValue - pointer to null terminated string contains the value name.

     hKey - pointer to key handle

================================================================*/

LONG GetValueKey(IN LPCTSTR pszValueName,
                 OUT LPCTSTR* lplpszValue,
                 OUT HKEY* phKey)
{
	WCHAR KeyName[100];


    *lplpszValue = pszValueName;
    LONG rc = ERROR_SUCCESS;

    //
    // Open Falcon key, if it hasn't opened yet.
    //
    if (g_hKeyFalcon == NULL)
    {
        rc = OpenFalconKey();
        if ( rc != ERROR_SUCCESS)
        {
            return rc;
        }
    }

    *phKey = g_hKeyFalcon;

    // look for a sub key
    LPCWSTR lpcsTemp = wcschr(pszValueName,L'\\');
    if (lpcsTemp != NULL)
    {
        // Sub key is exist
        DWORD dwDisposition;

        // update the return val
        *lplpszValue = lpcsTemp +1;

        wcsncpy(KeyName, pszValueName, (lpcsTemp - pszValueName));
        KeyName[(lpcsTemp - pszValueName)] = L'\0';

        rc = RegCreateKeyEx (g_hKeyFalcon,
                             KeyName,
                             0L,
                             L"",
                             REG_OPTION_NON_VOLATILE,
                             KEY_READ | KEY_WRITE,
                             NULL,
                             phKey,
                             &dwDisposition);

        if (rc != ERROR_SUCCESS)
        {
            rc = RegCreateKeyEx (g_hKeyFalcon,
                                 KeyName,
                                 0L,
                                 L"",
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_READ,
                                 NULL,
                                 phKey,
                                 &dwDisposition);
        }
    }

    return rc;
}

//-------------------------------------------------------
//
//  GetFalconKey
//
//-------------------------------------------------------

LONG
GetFalconKey(LPCWSTR  pszKeyName,
             HKEY *phKey)
{
	WCHAR szValueKey[100];
    LPCWSTR szValue;

    wcscat(wcscpy(szValueKey, pszKeyName), TEXT("\\"));
    return GetValueKey(szValueKey, &szValue, phKey);
}

//-------------------------------------------------------
//
//  GetFalconKeyValue
//
//-------------------------------------------------------

LONG
GetFalconKeyValue(
    LPCTSTR pszValueName,
    PDWORD  pdwType,
    PVOID   pData,
    PDWORD  pdwSize,
    LPCTSTR pszDefValue
    )
{
    //
    // NOTE: registry routines in mqutil do not provide
    // thread or other synchronization. If you change
    // implementation here, carefully verify that
    // registry routines in mqutil's clients are not
    // broken, especially the wrapper routines in
    // mqclus.dll  (ShaiK, 19-Apr-1999)
    //

    LONG rc;
    HKEY hKey;
    LPCWSTR lpcsValName;

    // ASSERT(pdwSize != NULL);

    rc = GetValueKey(pszValueName, &lpcsValName, &hKey);
    if ( rc != ERROR_SUCCESS)
    {
        return rc;
    }

    DWORD dwTempType;
    DWORD *pdwTempType = &dwTempType;

    dwTempType = (pdwType == NULL) ? 0 : *pdwType;


    {
        rc = RegQueryValueEx( hKey,
                          lpcsValName,
                          0L,
                          pdwTempType,
                          static_cast<BYTE*>(pData),
                          pdwSize ) ;
    }

    if ((rc != ERROR_SUCCESS) && pszDefValue)
    {
       if ((rc != ERROR_MORE_DATA) && pdwType && (*pdwType == REG_SZ))
       {
          // Don't use the default if caller buffer was too small for
          // value in registry.
          if ((DWORD) wcslen(pszDefValue) < *pdwSize)
          {
             wcscpy((WCHAR*) pData, pszDefValue) ;
             rc = ERROR_SUCCESS ;
          }
       }
       if (*pdwType == REG_DWORD)
       {
          *((DWORD *)pData) = *((DWORD *) pszDefValue) ;
          rc = ERROR_SUCCESS ;
       }
    }

    return rc;
}

//-------------------------------------------------------
//
//  SetFalconKeyValue
//
//-------------------------------------------------------

LONG
SetFalconKeyValue(
    LPCTSTR pszValueName,
    PDWORD  pdwType,
    const VOID * pData,
    PDWORD  pdwSize
    )
{
    //ASSERT(pData != NULL);
    //ASSERT(pdwSize != NULL);

    DWORD dwType = *pdwType;
    DWORD cbData = *pdwSize;
    HRESULT rc;

    HKEY hKey;
    LPCWSTR lpcsValName;

    rc = GetValueKey(pszValueName, &lpcsValName, &hKey);
    if ( rc != ERROR_SUCCESS)
    {
        return rc;
    }

    //CS lock(g_critRegistry);
    rc =  RegSetValueEx( hKey,
                         lpcsValName,
                         0,
                         dwType,
                         reinterpret_cast<const BYTE*>(pData),
                         cbData);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqactive\actions.cpp ===
#include "stdafx.h"

#define MO_MACHINE_TOKEN    L"MACHINE"
#define MO_QUEUE_TOKEN      L"QUEUE"

BOOL MachineAction(LPSTR szAction)
{
	BOOL b = TRUE;
	HRESULT hr;
	
    if (_stricmp(szAction, "connect") == 0)
    {
        hr = MQMgmtAction(NULL, MO_MACHINE_TOKEN, MACHINE_ACTION_CONNECT);
        if (FAILED(hr))
        {
            Failed(L"connect machine. Error 0x%x\n", hr);
	        b =  FALSE;
        }
    }
	else if (_stricmp(szAction, "disconnect") == 0)
    {
        hr = MQMgmtAction(NULL, MO_MACHINE_TOKEN, MACHINE_ACTION_DISCONNECT);
        if (FAILED(hr))
        {
            Failed(L"disconnect machine. Error 0x%x\n", hr);
	        b =  FALSE;
        }
    }
    else
    {
    	Failed(L"recognize action: %S", szAction);
        b =  FALSE;
    }

    return b;
}


BOOL QueueAction(LPSTR szAction, LPSTR szQueue)
{
    WCHAR ObjectName[100];
    swprintf(ObjectName, L"QUEUE=%S", szQueue);
	BOOL b = TRUE;
	HRESULT hr;
    
    if (_stricmp(szAction, "pause") == 0)
    {
        hr = MQMgmtAction(NULL, ObjectName, QUEUE_ACTION_PAUSE);
        if (FAILED(hr))
        {
            Failed(L"pause the queue %S. Error 0x%x\n", szQueue, hr);
	        b =  FALSE;
        } 
    }
    else  if (_stricmp(szAction, "resume") == 0)
    {
        hr = MQMgmtAction(NULL, ObjectName, QUEUE_ACTION_RESUME);
        if (FAILED(hr))
        {
            Failed(L"resume the queue %S. Error 0x%x\n", szQueue, hr);
	        b =  FALSE;
        } 
    }
    else  if (_stricmp(szAction, "resend") == 0)
    {
        hr = MQMgmtAction(NULL, ObjectName, QUEUE_ACTION_EOD_RESEND);
        if (FAILED(hr))
        {
            Failed(L"resend the queue %S. Error 0x%x\n", szQueue, hr);
	        b =  FALSE;
        } 
    }
    else
    {
    	Failed(L"recognize action: %S", szAction);
        b =  FALSE;
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqactive\qmstate.cpp ===
#include "stdafx.h"
#define ASSERT(a) 

#include "..\mqstate\qmstate.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\comapps\mqsendex\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__F140D648_4296_4F19_AFC1_78564C4D9072__INCLUDED_)
#define AFX_STDAFX_H__F140D648_4296_4F19_AFC1_78564C4D9072__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#import "mqoa.dll"  no_namespace named_guids
#include  <atlbase.h>
extern CComModule  _Module;
#include  <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F140D648_4296_4F19_AFC1_78564C4D9072__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqactive\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mqstore.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqactive\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
#define AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <tchar.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>
#include <wtypes.h>
#include <propidl.h>
#include <mq.h>

#include "..\\base\\base.h" 


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqping\ping.cpp ===
// This tool helps to diagnose problems with network or MSMQ conenctivity 
//
// AlexDad, April 2000 - based on the NT's ping sample
//

#include "..\ping.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqping\mqping.cpp ===
// This tool helps to diagnose problems with network or MSMQ conenctivity 
//
// AlexDad, April 2000
// 

#include "stdafx.h"
#include <winsvc.h>

//
// Log control. The get functions below are called from tmqbase.lib
//
bool fVerbose = false;
bool fDebug   = false;
FILE *g_fileLog = NULL;
TCHAR g_tszService[100] = L"MSMQ";
PCHAR g_pszTarget = NULL;

TCHAR g_tszTarget[100];
DWORD g_dwTimeout          = 30000;
bool  g_fQuietMode         = false;
bool  g_fUseDirectTarget   = true;
bool  g_fUseDirectResponse = true;

FILE *ToolLog()			{	return g_fileLog;	}
BOOL ToolVerbose()		{ 	return fVerbose;	}
BOOL ToolVerboseDebug() { 	return fDebug;		}
BOOL ToolThreadReport() { 	return FALSE;		} 

void OpenLogFile()
{
    g_fileLog = fopen( "tmqping.log", "w" );

    if (g_fileLog)
    {
        time_t  lTime ;
        time( &lTime ) ;
        fprintf(g_fileLog, "tmqping run at: %ws", _wctime( &lTime ) );
    }
}

void CloseLogFile()
{
    fflush(g_fileLog);
    fclose(g_fileLog);
}


extern BOOL Resolve(LPSTR pszServerName);
extern BOOL Ping (LPTSTR pszServerName);
extern BOOL MqPing();


// 
// Main logic of the tool
//
BOOL DoTheJob()
{
	BOOL fSuccess = TRUE, b;

	Inform(L"\n");

	//--------------------------------------------------------------------------------
	GoingTo(L"resolve name for %s", g_tszTarget); 
	//--------------------------------------------------------------------------------
	b = Resolve(g_pszTarget);
	if (b)
	{
		Inform(L"Successfully resolved name %s\n", g_tszTarget);
	}
	else
	{
		Failed(L"resolve name  %s", g_tszTarget);
		fSuccess = FALSE;
	}


	//--------------------------------------------------------------------------------
	GoingTo(L"ping (usual Internet ping) %s", g_tszTarget); 
	//--------------------------------------------------------------------------------

	b = Ping(g_tszTarget);
	if (b)
	{
		Inform(L"Successfully pinged   %s\n", g_tszTarget);
	}
	else
	{
		Failed(L"ping %s", g_tszTarget);
		fSuccess = FALSE;
	}


	//--------------------------------------------------------------------------------
	GoingTo(L"MqPing (via MSMQ) %s", g_tszTarget); 
	//--------------------------------------------------------------------------------
	b = MqPing();

	if(b)
	{
		Inform(L"Successfully MqPinged %s\n", g_tszTarget);
	}
	else
	{
		fSuccess = FALSE;
		Failed(L"MqPing %s", g_tszTarget);
	}

	return fSuccess;
}

//
//  help
//
void Usage()
{
	printf("usage: ping <target_machine> [-v] [-d] [-t <timeout>] [-q] [-r] [-s:<service_name>] \n");
	printf("Resolves name and address, PINGs and MQPINGs the remote machine\n\n");
	printf("             -v : verbose\n");
	printf("             -q : use non-direct name for the destination queue\n");
	printf("             -r : use non-direct name for the response queue\n");
	printf("             -t <milliseconds>: timeout for getting answer (default: 30 sec) \n" );
}

//
//  Main entry point - called from the tmq.exe 
//
int _stdcall run( int argc, char *argv[ ])
{
    //
    // Parse parameters
    //

	// Find out the target
	if (argc < 3 || (argc == 3 && argv[2][1] == '?' && (argv[2][0] == '/' || argv[2][0] == '-')))
	{
		Usage();
		exit(0);
	}


	for (int i=2; i<argc; i++)
	{
		if (*argv[i] != '-' && *argv[i] != '/')
		{
			if (g_pszTarget)
			{
				printf("Invalid parameter '%S'.\n\n", argv[i]);
		        Usage();
				exit(0);
			}
			else
			{
				g_pszTarget = argv[i];
				mbstowcs(g_tszTarget, g_pszTarget, sizeof(g_tszTarget));
			}

			continue;
		}

		switch (tolower(*(++argv[i])))
		{
		    case 'v':
			    fVerbose = true;
			    fDebug = true;
			    break;

		    case 't':
				g_dwTimeout = atoi(argv[++i]);
			    break;

		    case 'r':
			    g_fUseDirectResponse = false;
			    break;

		    case 'q':
			    g_fUseDirectTarget = false;
			    break;

			default:
			    printf("Unknown switch '%s'.\n\n", argv[i]);
                Usage();
			    exit(0);
		}
	}

    //
    // Create mqping.log - log file in current directory
    //
    OpenLogFile();

    Inform(L"TMQ Ping targets machine %S ", g_pszTarget);

	// Log down time , date, machine, OS
	LogRunCase();

	
	// actual work
    BOOL b = DoTheJob();

	if (b)
	{
		Inform(L"\n\n+++++++ TMQ Ping %S: healthy ++++++++\n", g_pszTarget);
	}
	else
	{
		Inform(L"\n\n-------- TMQ Ping %S  failed---------\n", g_pszTarget);
	}

	CloseLogFile();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqping\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mqstore.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqping\msmqping.cpp ===
// This tool helps to diagnose problems with network or MSMQ conenctivity 
//
// AlexDad, April 2000 - based on the mqping tool by RonenB
//

#include "stdafx.h"
#include <sys/types.h> 
#include <sys/timeb.h>

#include "resource.h"
#include <mq.h>
#include "sim.h"

#define ADMINQUEUENAME		L"admin_queue$"
#define	ADMIN_QUEUE_ID		(L"2")
#define RESPONSEQUEUENAME	L"private_response_queue"
#define QLABEL				L"ping rsponse queue"
#define QMCOMMANDLABEL		L"QM-Admin Commands"
#define	MAXNAMELEN				1000
#define MAXFORMATNAME		MAXNAMELEN
#define MAXPATHNAME			MAXNAMELEN
#define PINGTEXT			L"Ping"
#define TIMEOUT				30 //seconds

extern TCHAR g_tszTarget[];
extern DWORD g_dwTimeout;
extern bool  g_fUseDirectTarget;
extern bool  g_fUseDirectResponse;
extern bool  fVerbose;
extern bool  fDebug;


struct _timeb SendTime;		// when did we send msg?
TCHAR tcsErrorMsg[500];		// assume no multithreading

//----------------------------------
//
//   class CResString - handle resource strings
//
//----------------------------------
class CResString
{
public:
    explicit CResString(UINT id=0) { Load(id); }

    TCHAR * const Get() { return m_sz; }

    void Load(UINT id)
    {
        m_sz[0] = 0;
        if (id != 0)
        {
            LoadString(GetModuleHandle(NULL), id, m_sz, sizeof(m_sz) / sizeof(m_sz[0]));
        }
    }
        
private:
    TCHAR m_sz[1024];
};



TCHAR *ErrToStr( DWORD dwErr )
{
	LCID locale;
	DWORD hr = 1;
	HINSTANCE hInst;

	locale =  GetUserDefaultLCID();

	if ( HRESULT_FACILITY(dwErr) == FACILITY_MSMQ )
	{
		hInst = LoadLibrary( TEXT("MQUTIL.DLL") );
		if(hInst != 0)
		{
			hr = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK,
							   hInst,
							   dwErr,
							   locale,
							   tcsErrorMsg,
							   sizeof(tcsErrorMsg)/sizeof(*tcsErrorMsg),
							   NULL );
		}

		FreeLibrary(hInst);
	}
	else
	{
		hr = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_MAX_WIDTH_MASK,
						   NULL,
						   dwErr,
						   locale,
						   tcsErrorMsg,
						   sizeof(tcsErrorMsg)/sizeof(*tcsErrorMsg),
						   NULL );
	}

	if( hr == 0 )
	{
		*tcsErrorMsg = 0;	// reset string
	}

	if ( !(*tcsErrorMsg) )
	{
		int radix = 10;
		TCHAR *ptcs = tcsErrorMsg;

		CResString str(IDS_STRING_ERROR);

		memcpy( ptcs, str.Get(), sizeof(str.Get()) );
		ptcs += sizeof(str.Get());

		if ( HRESULT_FACILITY(dwErr) )
		{
			radix = 16;
			CResString str(IDS_STRING_HEX);
			memcpy( ptcs, str.Get(), sizeof(str.Get()) );
			ptcs += sizeof(str.Get());
		}

		_itot( dwErr, tcsErrorMsg, radix );
	}

	return( tcsErrorMsg );
}


void PrintErrMessageWithFormat(TCHAR * FormatErrStr, TCHAR * ErrStr, TCHAR * ErrStr2 = L"")
{
	TCHAR tTmp[1024];
	_stprintf(
		tTmp,
		_T("%s\n"),
		FormatErrStr);
	_tprintf(tTmp,ErrStr,ErrStr2);
}

//
// this function retreives the guid of the given machine name
// the guid is returned in the buffer specified with wcResult
//
HRESULT GetMachineGuid(WCHAR * wcMachineName,LPWSTR wszGuid)
{
	MQPROPVARIANT MPropVar[1];		//property values structure for machine
	MPropVar[0].vt = VT_NULL;

	QUEUEPROPID MPropId[] = {PROPID_QM_MACHINE_ID};
	MQQMPROPS MMProps = {1, 
						MPropId, 
						MPropVar, 
						NULL};
	GoingTo(L"MQGetMachineProperties %s", wcMachineName); 

	HRESULT	hr = MQGetMachineProperties( 
					wcMachineName,
					NULL,
					&MMProps
					);
	if (FAILED(hr))
	{
		Failed(L"MQGetMachineProperties %s: hr=0x%x  %s", wcMachineName, hr, ErrToStr(hr)); 
		return hr;
	}

	Succeeded(L"MQGetMachineProperties %s", wcMachineName); 

	LPWSTR wsz;
	if (RPC_S_OUT_OF_MEMORY == UuidToString(MPropVar[0].puuid, &wsz))
		return RPC_S_OUT_OF_MEMORY;

	wcscpy(wszGuid, wsz);

	return 0;
}

//
//this function retrieves the direct response name if it succeeds otherwise 
//retruns error and indictes with printing that direct will not be used for response
int GetDirectResponseName(WCHAR * wcPathName)
{
	WORD wVersionRequested;
	WSADATA wsaData;
	int err; 
	wVersionRequested = MAKEWORD( 1, 1 ); 
	err = WSAStartup( wVersionRequested, &wsaData );
	if (err)
	{
		CResString str1(IDS_WSASTARTUP_ERROR);
		PrintErrMessageWithFormat(str1.Get(), ErrToStr(WSAGetLastError ()));
		return -1;
	}
		
	char wcLocalComputerName[MAXPATHNAME] = {0};

	GoingTo(L"gethostname");

	if (gethostname(wcLocalComputerName,MAXPATHNAME)) 
	{
		CResString str1(IDS_GETHOSTNAME_ERROR);
		PrintErrMessageWithFormat(str1.Get(), ErrToStr(WSAGetLastError ()));
		WSACleanup( );
		return -1;
	}
	Succeeded(L"gethostname");

	struct hostent * pHostent = NULL;

	GoingTo(L"gethostbyname %s", wcLocalComputerName);
	pHostent = gethostbyname( wcLocalComputerName);
	
	if (pHostent == NULL)
	{
		Failed(L"gethostbyname %s", wcLocalComputerName);

		CResString str1(IDS_GETHOSTBYNAME_ERROR);
		PrintErrMessageWithFormat(str1.Get(),ErrToStr(WSAGetLastError ()));

		swprintf(
			wcPathName, 
			L"DIRECT=OS:%S\\PRIVATE$\\%s", 
			wcLocalComputerName, 
			RESPONSEQUEUENAME);

		WSACleanup( );
	}
	else
	{
		Succeeded(L"gethostbyname %s", wcLocalComputerName);

		swprintf(
			wcPathName, 
			L"DIRECT=OS:%S\\PRIVATE$\\%s", 
			pHostent->h_name, 
			RESPONSEQUEUENAME);
		WSACleanup( );
		Succeeded(L"gethostname");
	}

	return 0;
}


//
// create and open response queue init formatname array of it, send ping messages to all machines
// count the number of failed machines and return this number
// 

bool InitPingMessage(QUEUEHANDLE *hResponseQ, WCHAR *ResponseFormatName)
{
	WCHAR	wcPathName[MAXPATHNAME]={0};

	if (g_fUseDirectResponse)
	{
		if (GetDirectResponseName( wcPathName))
		{
			CResString str1(IDS_NOT_USING_DIRECT_NOTE);
			PrintErrMessageWithFormat(_T("%s\n"),str1.Get());
		}
	}

	DWORD	FormatNameLen = MAXFORMATNAME;
	WCHAR	FormatName[MAXFORMATNAME];

	//
	// open reponse queue (private queue, flush old if exists)
	//
	GoingTo(L"Create response queue");
	*hResponseQ = CreateQ(
					NULL,
					RESPONSEQUEUENAME,
					NULL,
					QLABEL,
					&FormatNameLen,
					ResponseFormatName,
					MAXFORMATNAME,
					MQ_RECEIVE_ACCESS,
					NULL,
					CREATEQ_PRIVATE | CREATEQ_ALWAYS | CREATEQ_FLUSH_MSGS
					);

	if (*hResponseQ == NULL)
	{
		Failed(L"Create response queue %s", ResponseFormatName);

		CResString strAbort(IDS_ERROR_OPEN_CLEAN);
		PrintErrMessageWithFormat(strAbort.Get(), ErrToStr(GetLastError()));
		exit(100);
	}

	//
	//define message properties for ping message
	//

	SIMPLEMSGPROPS	*out_message = NewMsgProps();
	WCHAR	wcMessageLabel[] = {QMCOMMANDLABEL};
	MsgProp_LABEL(out_message, wcMessageLabel);
	if (g_fUseDirectResponse && (*wcPathName))
	{
		MsgProp_RESP_QUEUE(out_message, wcPathName);
		Succeeded(L"set response queue as %s", wcPathName);
	}
	else
	{
		MsgProp_RESP_QUEUE(out_message, ResponseFormatName);
		Succeeded(L"set response queue as %s", ResponseFormatName);
	}

	MsgProp_TIME_TO_REACH_QUEUE(out_message,g_dwTimeout );

	//
	// ping 
	//
	HRESULT	hr;
	if (g_fUseDirectTarget)
	{
		swprintf(FormatName, L"DIRECT=OS:%s\\PRIVATE$\\%s",	g_tszTarget, ADMINQUEUENAME);
	}
	else
	{
		WCHAR  WCtmp[MAXNAMELEN];
		hr = GetMachineGuid(g_tszTarget, WCtmp);
		if (FAILED(hr))
		{
			TCHAR tTmp[1024];
			CResString str(IDS_ERROR_GETMACHINEGUID);
			_stprintf(tTmp,_T("%s\n"), str.Get());
			_tprintf(tTmp, g_tszTarget, ErrToStr(hr));

			return false ;
		}

		swprintf(FormatName, L"PRIVATE=%s\\%s", WCtmp, ADMIN_QUEUE_ID);
	}

	QUEUEHANDLE	hAdminQ = NULL;

	GoingTo(L"Open Admin queue %s", FormatName);

	hr = MQOpenQueue(FormatName, MQ_SEND_ACCESS, 0, &hAdminQ);

	if (FAILED(hr))
	{
		Failed(L"Open Admin queue %s: hr=0x%x  %s", FormatName, hr, ErrToStr(hr));

		CResString str(IDS_ERROR_OPEN_ADMINQUEUE);
		PrintErrMessageWithFormat(str.Get(),g_tszTarget, ErrToStr(hr));

		return false;
	}
	else 
	{
		Succeeded(L"Open Admin queue %s", FormatName);

		WCHAR	wcMessageBody[MAXNAMELEN] = {PINGTEXT};
		swprintf(wcMessageBody,L"%s=%s",PINGTEXT,g_tszTarget);
		DWORD	Body_Size	= (DWORD)(2*(wcslen(wcMessageBody)+1));
		MsgProp_BODY(out_message,wcMessageBody, Body_Size);

		GoingTo(L"Send probe message to the admin queue");

		hr = MQSendMessage(hAdminQ, &out_message->Props, NULL );

		if (FAILED(hr))
		{
			Failed(L"Send probe message to the admin queue");

			CResString str(IDS_ERROR_SEND_MESSAGE);
			PrintErrMessageWithFormat(str.Get(), g_tszTarget, ErrToStr(hr));

			return false;
		}
		else
		{
			Succeeded(L"Send probe message to the admin queue");
		}
		
		_ftime(&SendTime);

		GoingTo(L"Close Admin queue");

		MQCloseQueue(hAdminQ);

		Succeeded(L"Close Admin queue");
	}

	return true;
}



bool FindPingAnswers(QUEUEHANDLE hResponseQ)
{
	SIMPLEMSGPROPS	*in_message = NewMsgProps();

	struct CPingResponse {
		UCHAR bStatus;
		UCHAR wcsText[MAXNAMELEN * sizeof(WCHAR)];
	};

	CPingResponse PingResponse;

	MsgProp_BODY(in_message,&PingResponse, sizeof(PingResponse));
	MsgProp_BODY_SIZE(in_message);
	
	GoingTo(L"Receive message from response queue");
	bool b;

	HRESULT hr = RecvMsg( 
					hResponseQ,
					g_dwTimeout,
					MQ_ACTION_RECEIVE,
					NULL,
					in_message,
					NULL);
	if (SUCCEEDED(hr))
	{
		Succeeded(L"Receive message from response queue");
		b = true;
	}
	else
	{
		Failed(L"Receive message from response queue, hr=0x%x  %s", hr, ErrToStr(hr));
		b = false;
	}

	return b;
}


BOOL MqPing()
{
	QUEUEHANDLE hResponseQ = NULL;
	WCHAR FormatName[MAXNAMELEN];
	bool b = InitPingMessage(&hResponseQ, FormatName);

	if (b)
	{
		b = FindPingAnswers(hResponseQ);
	}

	GoingTo(L"Delete response queue");
	MQDeleteQueue(FormatName);
	Succeeded(L"Delete response queue");

	return b; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqactive\mqactive.cpp ===
// This tool helps to diagnose problems with MSMQ storage
// Shows active queues and provides management actions on them
//
// AlexDad, February 2000
// 

#include "stdafx.h"
#include <winsvc.h>

BOOL  fQueue   = FALSE;
BOOL  fMachine = FALSE;
LPSTR szAction = "";
LPSTR szQueue  = "";
ULONG g_cOpenQueues = 100;

extern BOOL QueueAction(LPSTR szAction, LPSTR szQueue);
extern BOOL MachineAction(LPSTR szAction);

void MachineGetInfo(LPCWSTR MachineName);

//
// Log control. The get functions below are called from tmqbase.lib
//
bool fVerbose = TRUE;
bool fDebug   = false;
FILE *g_fileLog = NULL;
TCHAR g_tszService[100] = L"MSMQ";

FILE *ToolLog()			{	return g_fileLog;	}
BOOL ToolVerbose()		{ 	return fVerbose;	}
BOOL ToolVerboseDebug() { 	return fDebug;		}
BOOL ToolThreadReport() { 	return FALSE;		} 

void OpenLogFile()
{
    g_fileLog = fopen( "tmqactive.log", "w" );

    if (g_fileLog)
    {
        time_t  lTime ;
        time( &lTime ) ;
        fprintf(g_fileLog, "tmqactive run at: %ws", _wctime( &lTime ) );
    }
}

void CloseLogFile()
{
    fflush(g_fileLog);
    fclose(g_fileLog);
}

//
//  help
//
void Usage()
{
	printf("to get list of active queues &their state:  active   \n");
	printf("to execute machine management action     :  active -m        -a [connect | disconnect ]  \n");
	printf("to execute queue   management action     :  active -q <name> -a [pause   | resume     | resend]\n");
	printf("Machine actions: \n");
    printf("    connect    - connects    the machine to   network and to   the DS \n");
    printf("    disconnect - disconnects the machine from network and from the DS\n");
	printf("Queue actions: \n");
    printf("    pause      - stops   messages delivery from this outgoing queue \n");
    printf("    resume     - resumes messages delivery from this outgoing queue \n");
    printf("    resend     - resends all messages from this outgoing transactional queue\n");
}

//
//  Main entry point - called from the tmq.exe 
//
int _stdcall run( int argc, char *argv[ ])
{
    //
    // Parse parameters
    //

	for (int i=2; i<argc; i++)
	{
		if (*argv[i] != '-' && *argv[i] != '/')
		{
			printf("Invalid parameter %s.\n\n", argv[i]);
            Usage();
            return FALSE;
		}

		switch (tolower(*(++argv[i])))
		{
		    case 'm':
			    fMachine = TRUE;
			    break;

            case 'q':
			    fQueue   = TRUE;

				if (i+1 < argc)
				{
					szQueue = argv[++i];
				}
				else
				{
					Usage();
					exit(0);
				}
			    break;

            case 'a':
				if (i+1 < argc)
				{
					szAction = argv[++i];
				}
				else
				{
					Usage();
					exit(0);
				}
			    break;
			    
		    default:
			    printf("Unknown switch '%s'.\n\n", argv[i]);
                Usage();
			    exit(0);
		}
	}

	if (fQueue && fMachine || strlen(szAction)==0 && (fQueue || fMachine))
	{
		Usage();
		return FALSE;
	}

    //
    //  we don't want to run in parallel with MSMQ service 
    //
    if (IsMsmqRunning(g_tszService))
    {
        Failed(L"run the test - the msmq service is not running");
    }

    //
    // Create tmqactive.log - log file in current directory
    //
    OpenLogFile();

    Inform(L"TMQ Active executes queue/machine management actions");

	// Log down time , date, machine, OS
	LogRunCase();

	
	// actual work
	BOOL b = FALSE;
	
	if (strlen(szAction)==0 && !fQueue && !fMachine)
	{
		MachineGetInfo(NULL);
		b = TRUE;
	}
	else if (fQueue)
	{
		b = QueueAction(szAction, szQueue);
	}
	else if (fMachine)
	{
	    b = MachineAction(szAction);
	}

	if (b)
	{
		Inform(L"\n\n+++++++ Action %S (%S) has been executed ++++++++\n", szAction, szQueue);
	}
	else
	{
		Inform(L"\n\n-------- Action %S (%S) has failed  ---------\n", szAction, szQueue);
	}

	CloseLogFile();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqping\resolve.cpp ===
// This tool helps to diagnose problems with network or MSMQ conenctivity 
//
// AlexDad, April 2000 
//

#include "stdafx.h"

extern TCHAR g_tszTarget[];
extern DWORD g_dwTimeout;
extern bool  g_fUseDirectTarget;
extern bool  g_fUseDirectResponse;

#define IP_ADDRESS_LEN           4

BOOL Resolve(LPSTR pszServerName) 
{
	// Array for keeping first 10 IP addresses: each entry uses 4 bytes
	int  cIpAddresses = 0;
	char arrIpAddresses[40];
	char szHostName[500];
	int  ipAddrType;
	
	//---------------------------------------------------
    GoingTo(L"WSAStartup");
	//---------------------------------------------------

	WORD wVersionRequested;
	WSADATA wsaData;
	int err; 
	wVersionRequested = MAKEWORD( 1, 1 ); 

	err = WSAStartup( wVersionRequested, &wsaData );
	if (err)
	{
		Failed(L"WSAStartup, err=0x%x, WSAGetLastError=0x%x", err, WSAGetLastError ());
		return false;
	}



	//---------------------------------------------------
    GoingTo(L"gethostbyname(%S)", pszServerName);
	//---------------------------------------------------

    PHOSTENT pHostEntry = gethostbyname(pszServerName);
    if ((pHostEntry == NULL) || (pHostEntry->h_addr_list == NULL))
    {
        Failed(L" resolve name %S - gethostbyname found no IP addresses: WSAGetLastError=0x%x", pszServerName, WSAGetLastError());
		WSACleanup( );
        return false;
    }
    else
    {
		strcpy(szHostName, pHostEntry->h_name);
		ipAddrType = pHostEntry->h_addrtype;

		if (ipAddrType != AF_INET)
		{
			Warning(L"Strange address type %d returned by gethostname", ipAddrType);
		}

		for ( DWORD uAddressNum = 0 ;
			  pHostEntry->h_addr_list[uAddressNum] != NULL ;
			  uAddressNum++)
		{
			Inform(L"gethostbyname(%S) found host %S, IP address: %S", 
					 pszServerName, 
					 szHostName,
					 inet_ntoa(*(struct in_addr *)pHostEntry->h_addr_list[uAddressNum]));
		
			if (cIpAddresses < sizeof(arrIpAddresses) / IP_ADDRESS_LEN )
			{
				memcpy( arrIpAddresses + cIpAddresses * IP_ADDRESS_LEN, 
					    pHostEntry->h_addr_list[uAddressNum], 
						IP_ADDRESS_LEN);
				cIpAddresses++;
			}
		}
    }

	//-------------------------------------------------------------------------------------
    GoingTo(L"gethostbyaddr(%S) in order to see we get to the right place", pszServerName);
	//--------------------------------------------------------------------------------------

	bool b = true;

	for (int i=0; i<cIpAddresses; i++)
	{
		char    *pchIP = arrIpAddresses + i * IP_ADDRESS_LEN;
		in_addr *pinetaddr = (struct in_addr *) pchIP;

		//---------------------------------------------------
		GoingTo(L"gethostbyaddr (%S)", inet_ntoa(*pinetaddr));
		//---------------------------------------------------
		pHostEntry = gethostbyaddr(pchIP, IP_ADDRESS_LEN, ipAddrType);

		if ((pHostEntry == NULL) || (pHostEntry->h_addr_list == NULL))
		{
			Failed(L" resolve address back - gethostbyaddr found no host: WSAGetLastError=0x%x", WSAGetLastError());
			WSACleanup( );
			return false;
		}
		else
		{
			Inform(L"Address %S belongs to the host %S", inet_ntoa(*pinetaddr), pHostEntry->h_name);

			if (_stricmp(szHostName, pHostEntry->h_name) != NULL)
			{
				Warning(L"The host name is reported differently by gethostbyaddr and gethostbyname");

				// It may be because one name is fully qualified, another is not.
				char szNameFromGethostbyaddr[1000], szNameFromGethostbyname[1000], *p;

				strcpy(szNameFromGethostbyaddr, pHostEntry->h_name); 
				p = strchr(szNameFromGethostbyaddr, '.');
				if (p)
				{
					*p = '\0';
				}

				strcpy(szNameFromGethostbyname, szHostName); 
				p = strchr(szNameFromGethostbyname, '.');
				if (p)
				{
					*p = '\0';
				}

				if (_stricmp(szNameFromGethostbyaddr, szNameFromGethostbyname) != NULL)
				{
					Failed(L"reconcile name and address - please check DNS configuration");
					b = false;
				}
			}
		}
	}

	WSACleanup();
	return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqping\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mqping.rc
//
#define IDS_STRING1                     1
#define IDS_USAGE_1                     1
#define IDS_USAGE_2                     2
#define IDS_USAGE_3                     3
#define IDS_USAGE_4                     4
#define IDS_USAGE_5                     5
#define IDS_USAGE_6                     6
#define IDS_RESPONSE_QUEUE_NAME         7
#define IDS_RESPONSE_QUEUE_LABEL        8
#define IDS_GETHOSTBYNAME_ERROR         9
#define IDS_NOT_USING_DIRECT_NOTE       10
#define IDS_ERROR_OPEN_CLEAN            11
#define IDS_ERROR_ALLOC                 12
#define IDS_ERROR_GETMACHINEGUID        13
#define IDS_ERROR_OPEN_ADMINQUEUE       14
#define IDS_ERROR_SEND_MESSAGE          15
#define IDS_DEBUG_ERROR_RECORD          16
#define IDS_OUTPUT_FORMAT_SUCCESS1      17
#define IDS_OUTPUT_FORMAT_SUCCESS2      18
#define IDS_OUTPUT_FORMAT_FAIL          19
#define IDS_HEADER                      20
#define IDS_STRING_ERROR                21
#define IDS_STRING_HEX                  22
#define IDS_WSASTARTUP_ERROR            23
#define IDS_GETHOSTNAME_ERROR           24

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqping\sim.h ===
// This tool helps to diagnose problems with network or MSMQ conenctivity 
//
// Simple MQ API interface
//
// RonenB, April 2000
//


#ifndef _SIMPLE_H
#define _SIMPLE_H

#ifdef __cplusplus
extern "C" {
#endif


#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef LONG HRESULT;
#endif

#define LEN_OF(var) ( sizeof(var) / sizeof(*(var)) )


#define PROP_NOT_APPLICABLE	(unsigned)( -126 )

#define GUID_0 { 0L, 0,0, {0,0,0,0,0,0,0,0} }

// time constants
#define MINUTEs_TIMEOUT			(60*1000)	// timout is in mili sec
#define MINUTEs_TIMETOLIVE		(60)		// time to live is in seconds
#define HOURs_TIMEOUT			(60 * MINUTEs_TIMEOUT)
#define HOURs_TIMETOLIVE		(60 * MINUTEs_TIMETOLIVE)

#define WAIT_FOREVER	0xFFFFFFFF
#define LIVE_FOREVER	0xFFFFFFFF


// OpenQ flags
#define CREATEQ_NEW					0x0001
#define CREATEQ_EXISTING			0x0002
#define CREATEQ_ALWAYS				0x0003
#define CREATEQ_OPEN_ONLY			0x0004
#define CREATEQ_CREATION_FLAGS		0x0007

#define CREATEQ_FLUSH_MSGS			0x0008

#define CREATEQ_PUBLIC				0x0000
#define CREATEQ_PRIVATE				0x0010
#define CREATEQ_DIRECT				0x0020
#define CREATEQ_TEMPORARY			0x0030
#define CREATEQ_MACHINEQ			0x0040
#define CREATEQ_QTYPE_MASK			0x0070

// direct open modifiers
#define CREATEQ_MACHINE				0x0000	// OS:
#define CREATEQ_TCP					0x0100
#define CREATEQ_SPX					0x0200
#define CREATEQ_PROTOCOLS_MASK		0x0300

#define OPENQ_JOURNAL				0x0400
#define OPENQ_DEADLETTER			0x0800
#define OPENQ_QSUBTYPE_MASK			0x0C00

#define OPENQ_EXCLUSIVE				0x1000
#define CREATEQ_JOURNAL_ENABLE		0x2000
#define CREATEQ_AUTHENTICATE		0x4000
#define CREATEQ_TRANSACTION			0x8000


#define MAX_PATH_PREFIX_LEN			11
#define MAX_GUID_NAME_LEN			36
#define MAX_PATH_NAME_LEN			( MAX_COMPUTERNAME_LENGTH + 1 + MQ_MAX_Q_NAME_LEN )
#define MAX_FORMAT_NAME_LEN			( MAX_PATH_PREFIX_LEN + 1 + MAX_GUID_NAME_LEN + 1 + MAX_PATH_NAME_LEN )

#define CREATEQ_PRIVATE_NAME		L"PRIVATE$"
#define CREATEQ_TEMPORARY_NAME		CREATEQ_PRIVATE_NAME	// L"TEMPORARY$"

#define CREATEQ_JOURNAL_NAME		L";JOURNAL"
#define CREATEQ_DEADLETTER_NAME		L";DEADLETTER"

#define CREATEQ_PUBLIC_FORMAT_PREFIX	L"PUBLIC="
#define CREATEQ_PRIVATE_FORMAT_PREFIX	L"PRIVATE="

#define CREATEQ_DIRECT_FORMAT_PREFIX	L"DIRECT="
#define CREATEQ_MACHINE_FORMAT		L"OS:"
#define CREATEQ_TCP_FORMAT			L"TCP:"
#define CREATEQ_SPX_FORMAT			L"SPX:"

#define CREATEQ_MACHINEQ_FORMAT_PREFIX	L"MACHINE="

	
// search for queue
// 1. if queue guid is valid try it first
// 2. if no queue with guid then try path
HRESULT							// return MQ locate status
	LocateQ(
		WCHAR	*pwcsFormatName,		// output format name
		DWORD	*pdwFormatNameLen,		// in/out length of format name
		GUID	*pQId,					// guid of required queue, may be NULL or 0
		WCHAR	*pwcsQPath,				// path information
		GUID	*pQType,				// queue type information
		WCHAR	*pwcsQName );			// queue name

// open queue
// 1. try to find a matching queue (use LocateQ)
// 2. if there is no queue create one
// 3. open the queue and return the handle
QUEUEHANDLE							// return queue handle or NULL for error
	CreateQ(
		GUID	*pQId,					// guid of required queue, may be NULL or 0
		WCHAR	*pwcsQPath,				// pointer to queue path information
		GUID	*pQType,				// guid of queue type, may be NULL
		WCHAR	*pwcsQName,				// pointer to queue name
		DWORD	*pdwFormatNameLen,		// out = length of format len
		WCHAR	*pwcsFormatName,		// format name
		DWORD	dwFormatNameLen,		// format name buf len
		const DWORD dwAccess,			// QM access rights
		PSECURITY_DESCRIPTOR pSecurityDescriptor,
		ULONG	ulOpenFlags);			// Q opened flags


HRESULT
	SetQProps(
		QUEUEHANDLE	 hQ,				// input handle to queue
		WCHAR	*pwcsQPath,				// pointer to queue path information
		GUID	*pQType,				// guid of queue type, may be NULL
		WCHAR	*pwcsQLabel,			// pointer to queue label
		ULONG	ulQuota,				// Q quota
		UCHAR	bJournal,				// Q journaling (yes/no)
		int		iBasePrio,				// msg base priority
		ULONG	ulJournalQuota,			// Q journal quote
		UCHAR	bAuthenticate,			// Q authentication requirement
		ULONG	ulPrivLevel );			// msg privacy requirement

HRESULT
	GetQProps(
		QUEUEHANDLE	 hQ,			// input handle to queue
		GUID	*pQInstance,		// guid of queue instance
		WCHAR	*pwcsQPath,			// pointer to queue path information
		GUID	*pQType,			// guid of queue type
		WCHAR	*pwcsQLabel,		// pointer to queue label
		ULONG	*pulQuota,			// Q quota
		UCHAR	*pbJournal,			// Q journaling (yes/no)
		int		*piBasePrio,		// msg base priority
		ULONG	*pulJournalQuota,	// Q journal quote
		LONG	*plCreationTime,	// time the Q was created
		LONG	*plModifyTime,		// time the Q was modified
		UCHAR	*pbAuthenticate,	// Q authentication requirement
		ULONG	*pulPrivLevel,		// msg privacy requirement
		UCHAR	*pucTransaction );	// Q used for transactions


HRESULT
	GetQSecurity(
		QUEUEHANDLE	 hQ,		// input handle to queue
		SECURITY_INFORMATION RequestedInformation,
		PSECURITY_DESCRIPTOR pSecurityDescriptor,
		DWORD nLength,
		DWORD *pnLengthNeeded );

HRESULT
	SetQSecurity(
		QUEUEHANDLE	 hQ,		// input handle to queue
		SECURITY_INFORMATION SecurityInformation,
		PSECURITY_DESCRIPTOR pSecurityDescriptor );

/*****************************************************************************

  SimpleMsgProps

******************************************************************************/
#define PROP_SET	1
#define PROP_RESET	0
#define SIMPLEMSGPROPS_COUNT	49
#define PROP_INDEX_FREE	( 0x80000000L / sizeof(MQPROPVARIANT) )

typedef struct tagSIMPLEMSGPROPS
{
	MQMSGPROPS		Props;
    MSGPROPID		PropID[SIMPLEMSGPROPS_COUNT];
    MQPROPVARIANT	PropVar[SIMPLEMSGPROPS_COUNT];
    HRESULT			hStatus[SIMPLEMSGPROPS_COUNT];

	int		iPropIndex[SIMPLEMSGPROPS_COUNT+1];

	OBJECTID obidMsgId;
	OBJECTID obidPrevMsgId;
	OBJECTID obidCorlId;

	GUID	guidProxyType;
	GUID	guidMachineId;

	ULONG	ulLabelLen;
	WCHAR	*pwcsLabel;		// MQ_MAX_MSG_LABEL_LEN

	QUEUEHANDLE hRespQ;
	DWORD	dwRespQLen;
	WCHAR	*pwcsRespQ;

	DWORD	dwCurrentRespQLen;
	WCHAR	*pwcsCurrentRespQ;

	QUEUEHANDLE hAdminQ;
	DWORD	dwAdminQLen;
	WCHAR	*pwcsAdminQ;

	HANDLE hEvent;
	OVERLAPPED Overlapped;
} SIMPLEMSGPROPS;

//
#define IsMsgPropValid(pMsgDsc,PropID) \
  ( (pMsgDsc)->iPropIndex[PropID] != PROP_INDEX_FREE )

// message properties
SIMPLEMSGPROPS
	*NewMsgProps();

void
	FreeMsgProps(
		SIMPLEMSGPROPS *pMsgDsc );

void
	MsgPropRemove(
		SIMPLEMSGPROPS *pMsgDsc,
		MSGPROPID	PropID );		// property ID to remove


// MQMSGPROPS
#define Msg_PROPS(pMsgDsc)	\
	(pMsgDsc)->Props
		

// PROPID_M_CLASS
#define Msg_CLASS(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_CLASS] ].uiVal

void
	MsgProp_CLASS(
		SIMPLEMSGPROPS *pMsgDsc,
		USHORT	uiClass );


// PROPID_M_MSGID
#define Msg_MSGID(pMsgDsc)	\
	&( (pMsgDsc)->obidMsgId )
// (OBJECTID *)( (pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_MSGID] ].caub.pElems )

void
	MsgProp_MSGID(
		SIMPLEMSGPROPS *pMsgDsc );


// PROPID_M_CORRELATIONID
#define Msg_CORRELATIONID(pMsgDsc)	\
	(OBJECTID *)( (pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_CORRELATIONID] ].caub.pElems )

void
	MsgProp_CORRELATIONID(
		SIMPLEMSGPROPS *pMsgDsc,
		OBJECTID	*pCorrelID );


// PROPID_M_PRIORITY
#define Msg_PRIORITY(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_PRIORITY] ].bVal

void
	MsgProp_PRIORITY(
		SIMPLEMSGPROPS *pMsgDsc,
		UCHAR	bPrio );


// PROPID_M_DELIVERY
#define Msg_DELIVERY(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_DELIVERY] ].bVal

void
	MsgProp_DELIVERY(
		SIMPLEMSGPROPS *pMsgDsc,
		UCHAR	ucDelivery );


// PROPID_M_ACKNOWLEDGE
#define Msg_ACKNOWLEDGE(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_ACKNOWLEDGE] ].bVal

void
	MsgProp_ACKNOWLEDGE(
		SIMPLEMSGPROPS *pMsgDsc,
		UCHAR	bAck );


// PROPID_M_JOURNAL
#define Msg_JOURNAL(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_JOURNAL] ].bVal

void
	MsgProp_JOURNAL(
		SIMPLEMSGPROPS *pMsgDsc,
		UCHAR	bJounal);


// PROPID_M_APPSPECIFIC
#define Msg_APPSPECIFIC(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_APPSPECIFIC] ].ulVal

void
	MsgProp_APPSPECIFIC(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulApp);


// PROPID_M_BODY
#define Msg_BODY(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_BODY] ].caub.pElems

void
	MsgProp_BODY(
		SIMPLEMSGPROPS *pMsgDsc,
		LPVOID	pBody,
		ULONG	ulSize );


// PROPID_M_BODY_SIZE
#define Msg_BODY_SIZE(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_BODY_SIZE] ].ulVal

void
	MsgProp_BODY_SIZE(
		SIMPLEMSGPROPS *pMsgDsc );


// PROPID_M_LABEL
#define Msg_LABEL(pMsgDsc)	\
	(pMsgDsc)->pwcsLabel
//	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_LABEL] ].pwszVal

void
	MsgProp_LABEL(
		SIMPLEMSGPROPS *pMsgDsc,
		WCHAR *wcsLabel );


// PROPID_M_LABEL_LEN
#define Msg_LABEL_LEN(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_LABEL_LEN] ].ulVal

void
	MsgProp_LABEL_LEN(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulLabelLen );


// PROPID_M_TIME_TO_REACH_QUEUE
#define Msg_TIME_TO_REACH_QUEUE(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_TIME_TO_REACH_QUEUE] ].ulVal

void
	MsgProp_TIME_TO_REACH_QUEUE(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulSecToReachQ );


// PROPID_M_TIME_TO_BE_RECEIVED
#define Msg_TIME_TO_BE_RECEIVED(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_TIME_TO_BE_RECEIVED] ].ulVal

void
	MsgProp_TIME_TO_BE_RECEIVED(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulSecToLive);


// PROPID_M_RESP_QUEUE
#define Msg_RESP_QUEUE(pMsgDsc)	\
	(WCHAR *)((pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_RESP_QUEUE] ].pwszVal)

void
	MsgProp_RESP_QUEUE(
		SIMPLEMSGPROPS *pMsgDsc,
		WCHAR	*pwcsRespQ );


// PROPID_M_RESP_QUEUE_LEN
#define Msg_RESP_QUEUE_LEN(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_RESP_QUEUE_LEN] ].ulVal

void
	MsgProp_RESP_QUEUE_LEN(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulRespQLen );


// PROPID_M_ADMIN_QUEUE
#define Msg_ADMIN_QUEUE(pMsgDsc)	\
	(WCHAR *)((pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_ADMIN_QUEUE] ].pwszVal)

void
	MsgProp_ADMIN_QUEUE(
		SIMPLEMSGPROPS *pMsgDsc,
		WCHAR	*pwcsAdminQ );


// PROPID_M_ADMIN_QUEUE_LEN
#define Msg_ADMIN_QUEUE_LEN(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_ADMIN_QUEUE_LEN] ].ulVal

void
	MsgProp_ADMIN_QUEUE_LEN(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulAdminQLen );


// PROPID_M_VERSION
#define Msg_VERSION(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_VERSION] ].ulVal

void
	MsgProp_VERSION(
		SIMPLEMSGPROPS *pMsgDsc );


// PROPID_M_SENDERID
#define Msg_SENDERID(pMsgDsc)	\
	(SID *)((pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_SENDERID] ].caub.pElems)

void
	MsgProp_SENDERID(
		SIMPLEMSGPROPS *pMsgDsc,
		PSID	psid,
		ULONG	ulSidSize );


// PROPID_M_SENDERID_LEN
#define Msg_SENDERID_LEN(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_SENDERID_LEN] ].ulVal

void
	MsgProp_SENDERID_LEN(
		SIMPLEMSGPROPS *pMsgDsc );


// PROPID_M_SENDERID_TYPE
#define Msg_SENDERID_TYPE(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_SENDERID_TYPE] ].ulVal

void
	MsgProp_SENDERID_TYPE(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulSenderType );


// PROPID_M_PRIV_LEVEL
#define Msg_PRIV_LEVEL(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_PRIV_LEVEL] ].ulVal

void
	MsgProp_PRIV_LEVEL(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulPrivLevel );


// PROPID_M_AUTH_LEVEL
#define Msg_AUTH_LEVEL(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_AUTH_LEVEL] ].ulVal

void
	MsgProp_AUTH_LEVEL(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulAuthLevel );


// PROPID_M_AUTHENTICATED
#define Msg_AUTHENTICATED(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_AUTHENTICATED] ].bVal

void
	MsgProp_AUTHENTICATED(
		SIMPLEMSGPROPS *pMsgDsc );


// PROPID_M_HASH_ALG
#define Msg_HASH_ALG(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_HASH_ALG] ].ulVal

void
	MsgProp_HASH_ALG(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulHashAlg );


// PROPID_M_ENCRYPTION_ALG
#define Msg_CRYPT_ALG(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_ENCRYPTION_ALG] ].ulVal

void
	MsgProp_CRYPT_ALG(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulCryptAlg );


// PROPID_M_SENDER_CERT
#define Msg_SENDER_CERT(pMsgDsc)	\
	(UCHAR *)((pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_SENDER_CERT] ].caub.pElems)

void
	MsgProp_SENDER_CERT(
		SIMPLEMSGPROPS *pMsgDsc,
		BYTE	*pCert,
		ULONG	ulCertSize );


// PROPID_M_SENDER_CERT_LEN
#define Msg_SENDER_CERT_LEN(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_SENDER_CERT_LEN] ].ulVal

void
	MsgProp_SENDER_CERT_LEN(
		SIMPLEMSGPROPS *pMsgDsc );


// PROPID_M_SRC_MACHINE_ID
#define Msg_SRC_MACHINE_ID(pMsgDsc)	\
	&( (pMsgDsc)->guidMachineId )
//	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_SRC_MACHINE_ID] ].puuid

void
	MsgProp_SRC_MACHINE_ID(
		SIMPLEMSGPROPS *pMsgDsc );


// PROPID_M_SENTTIME
#define Msg_SENTTIME(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_SENTTIME] ].ulVal

void
	MsgProp_SENTTIME(
		SIMPLEMSGPROPS *pMsgDsc );


// PROPID_M_ARRIVEDTIME
#define Msg_ARRIVEDTIME(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_ARRIVEDTIME] ].ulVal

void
	MsgProp_ARRIVEDTIME(
		SIMPLEMSGPROPS *pMsgDsc );


// PROPID_M_DEST_QUEUE
#define Msg_DEST_QUEUE(pMsgDsc)	\
	(WCHAR *)((pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_DEST_QUEUE] ].pwszVal)

void
	MsgProp_DEST_QUEUE(
		SIMPLEMSGPROPS *pMsgDsc,
		WCHAR	*pwcsDestQ );


// PROPID_M_DEST_QUEUE_LEN
#define Msg_DEST_QUEUE_LEN(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_DEST_QUEUE_LEN] ].ulVal

void
	MsgProp_DEST_QUEUE_LEN(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulDestQLen );


// PROPID_M_EXTENSION
#define Msg_EXTENSION(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_EXTENSION] ].caub.pElems

void
	MsgProp_EXTENSION(
		SIMPLEMSGPROPS *pMsgDsc,
		LPVOID	pExtension,
		ULONG	ulSize );


// PROPID_M_EXTENSION_LEN
#define Msg_EXTENSION_LEN(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_EXTENSION_LEN] ].ulVal

void
	MsgProp_EXTENSION_LEN(
		SIMPLEMSGPROPS *pMsgDsc );


// PROPID_M_SECURITY_CONTEXT
#define Msg_SECURITY_CONTEXT(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_SECURITY_CONTEXT] ].ulVal

void
	MsgProp_SECURITY_CONTEXT(
		SIMPLEMSGPROPS *pMsgDsc,
		HANDLE hSecurityContext );	// from MQGetSecurityContext(...);


// PROPID_M_CONNECTOR_TYPE
#define Msg_CONNECTOR_TYPE(pMsgDsc)	\
	&( (pMsgDsc)->guidProxyType )
//	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_CONNECTOR_TYPE] ].puuid

void
	MsgProp_CONNECTOR_TYPE(
		SIMPLEMSGPROPS *pMsgDsc,
		GUID *pguidProxyType );


// PROPID_M_XACT_STATUS_QUEUE
#define Msg_XACT_STATUS_QUEUE(pMsgDsc)	\
	(WCHAR *)((pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_XACT_STATUS_QUEUE] ].pwszVal)

void
	MsgProp_XACT_STATUS_QUEUE(
		SIMPLEMSGPROPS *pMsgDsc,
		WCHAR	*pwcsXactStatQ );


// PROPID_M_XACT_STATUS_QUEUE_LEN
#define Msg_XACT_STATUS_QUEUE_LEN(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_XACT_STATUS_QUEUE_LEN] ].ulVal

void
	MsgProp_XACT_STATUS_QUEUE_LEN(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulXactStatQLen );


// PROPID_M_TRACE
#define Msg_TRACE(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_TRACE] ].bVal

void
	MsgProp_TRACE(
		SIMPLEMSGPROPS *pMsgDsc,
		UCHAR	bTrace );

// PROPID_M_BODY_TYPE
#define Msg_BODY_TYPE(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_BODY_TYPE] ].ulVal

void
	MsgProp_BODY_TYPE(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulBodyType );

// PROPID_M_DEST_SYMM_KEY
#define Msg_DEST_SYMM_KEY(pMsgDsc)	\
	(UCHAR *)((pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_DEST_SYMM_KEY] ].caub.pElems)

void
	MsgProp_DEST_SYMM_KEY(
		SIMPLEMSGPROPS *pMsgDsc,
		BYTE	*pSymmKey,
		ULONG	ulSymmKeySize );

// PROPID_M_DEST_SYMM_KEY_LEN
#define Msg_DEST_SYMM_KEY_LEN(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_DEST_SYMM_KEY_LEN] ].ulVal

void
	MsgProp_DEST_SYMM_KEY_LEN(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulSymmKeyLen );

// PROPID_M_SIGNATURE
#define Msg_SIGNATURE(pMsgDsc)	\
	(UCHAR *)((pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_SIGNATURE] ].caub.pElems)

void
	MsgProp_SIGNATURE(
		SIMPLEMSGPROPS *pMsgDsc,
		BYTE	*pSignature,
		ULONG	ulSignatureSize );

// PROPID_M_SIGNATURE_LEN
#define Msg_SIGNATURE_LEN(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_SIGNATURE_LEN] ].ulVal

void
	MsgProp_SIGNATURE_LEN(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulSignatureLen );


// PROPID_M_PROV_TYPE
#define Msg_PROV_TYPE(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_PROV_TYPE] ].ulVal

void
	MsgProp_PROV_TYPE(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulProvType );

// PROPID_M_PROV_NAME
#define Msg_PROV_NAME(pMsgDsc)	\
	(WCHAR *)((pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_PROV_NAME] ].pwszVal)

void
	MsgProp_PROV_NAME(
		SIMPLEMSGPROPS *pMsgDsc,
		WCHAR	*pwcsProvName );


// PROPID_M_PROV_NAME_LEN
#define Msg_PROV_NAME_LEN(pMsgDsc)	\
	(pMsgDsc)->PropVar[ (pMsgDsc)->iPropIndex[PROPID_M_PROV_NAME_LEN] ].ulVal

void
	MsgProp_PROV_NAME_LEN(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulProvNameLen );


// overlapped I/O event handle
#define Msg_hEvent(pMsgDsc)	\
	(pMsgDsc)->hEvent

void
	MsgProp_hEvent(
		SIMPLEMSGPROPS *pMsgDsc,
		HANDLE	hEvent );

#define Msg_Async_hStat(pMsgDsc)	\
	(pMsgDsc)->Overlapped.Internal


// response queue
void
	MsgProp_RespQ(
		SIMPLEMSGPROPS *pMsgDsc,
		QUEUEHANDLE	hRespQ,
		BOOL		bUseDirect );

void
	MsgPropRmv_RespQ(
		SIMPLEMSGPROPS *pMsgDsc );

HRESULT
	MsgPropClose_RespQ(
		SIMPLEMSGPROPS *pMsgDsc );

void
	MsgPropReset_RespQ(
		SIMPLEMSGPROPS *pMsgDsc );

QUEUEHANDLE
	Msg_RespQ(
		SIMPLEMSGPROPS *pMsgDsc, ULONG ulTimeout );

#define Msg_RespQ_FormatName(pMsgDsc)	\
	(pMsgDsc->pwcsRespQ)


// admin queue
void
	MsgProp_AdminQ(
		SIMPLEMSGPROPS *pMsgDsc,
		QUEUEHANDLE hAdminQ );

#define Msg_AdminQ(pMsgDsc)	\
	(pMsgDsc)->hAdminQ

void
	MsgPropRmv_AdminQ(
		SIMPLEMSGPROPS *pMsgDsc );

HRESULT
	MsgPropClose_AdminQ(
		SIMPLEMSGPROPS *pMsgDsc );

#define Msg_AdminQ_FormatName(pMsgDsc)	\
	(pMsgDsc->pwcsAdminQ)


// send message to queue
HRESULT
	SendMsg(
		const QUEUEHANDLE hDest,	// handle of destination queue
		ULONG ulTimeout,			// timeout to send the message, may be INFINITE
		SIMPLEMSGPROPS *pMsgDsc,	// message properties information
		ITransaction *pTransaction );	// transaction pointer from DTC


// receive message from queue
HRESULT
	RecvMsg(
		const QUEUEHANDLE hQueue,	// handle of queue
		const DWORD dwTimeout,		// timeout to receive the message, may be INFINITE
		const DWORD dwAction,		// MQ_ACTION_RECEIVE, MQ_ACTION_PEEK_CURRENT, MQ_ACTION_PEEK_NEXT
		const HANDLE hCursor,		// used for filtering messages
		SIMPLEMSGPROPS *pMsgDsc,	// message properties information
		ITransaction *pTransaction );	// transaction pointer from DTC


HRESULT
	DeleteQ(
		const GUID *pQId,
		const WCHAR *pwcsQPath );

HRESULT
	RemoveQ(
		const QUEUEHANDLE hQ );


/*
 * For dynamic simple only
 */
BOOL SimpleInit(void);
HRESULT sMQCloseQueue( IN HANDLE hQueue );


#ifdef __cplusplus
}
#endif

#endif		// _SIMPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqrpcc\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
#define AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <tchar.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>
//#define _WIN32_WINNT 0x0500

#include "..\\base\\base.h" 


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqrpcc\hauthenc.cpp ===
//
// file:  hauthenc.cpp
//
#include "stdafx.h"
#include "..\hauthen.h"
#include "authni.h"

ULONG  RunRpcTest( int    i,
                   WCHAR *wszProtocol,
                   WCHAR *wszServerName,
                   WCHAR *wszEndpoint,
                   WCHAR *wszOptions,
                   WCHAR *wszPrincipalNameIn,
                   ULONG ulAuthnService,
                   ULONG ulAuthnLevel,
                   BOOL  fImpersonate,
                   BOOL  fAuthen,
                   BOOL  fKerbDelegation )
{
    WCHAR *wszStringBinding = NULL;

    GoingTo(L"RpcStringBindingCompose");
    RPC_STATUS status = RpcStringBindingCompose( NULL,  // pszUuid,
                                                 wszProtocol,
                                                 wszServerName,
                                                 wszEndpoint,
                                                 wszOptions,
                                                 &wszStringBinding);

	if (ToolVerbose())
	    Inform(L"RpcStringBindingCompose() return %s, %lut", wszStringBinding, status) ;
    if (status != RPC_S_OK)
    {
    	Failed(L"RpcStringBindingCompose returned %s, error=%lut", wszStringBinding, status);
        return status ;
    }
    else
    {
    	Succeeded(L"RpcStringBindingCompose, returned %s", wszStringBinding);
    }

    handle_t hBind = NULL ;

    GoingTo(L"RpcBindingFromStringBinding");
    status = RpcBindingFromStringBinding( wszStringBinding,  &hBind);

    if (ToolVerbose())
		Inform(L"RpcBindingFromStringBinding() return %lut", status) ;
    if (status != RPC_S_OK)
    {
    	Failed(L"RpcBindingFromStringBinding, return %lut", status);
        return status ;
    }
    else
    {
    	Succeeded(L"RpcBindingFromStringBinding");
    }

    status = RpcStringFree(&wszStringBinding);
    if (status != RPC_S_OK)
    {
    	Failed(L"RpcStringFree(), return %lut", status) ;
    }
    else
    {
    	Succeeded(L"RpcBindingFromStringBinding");
    }

    if (fAuthen)
    {
        RPC_SECURITY_QOS   SecQOS;

        SecQOS.Version = RPC_C_SECURITY_QOS_VERSION;
        SecQOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
        SecQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
        SecQOS.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;

        LPWSTR pwszPrincipalName = NULL;
        if (wszPrincipalNameIn[0] != 0)
        {
            pwszPrincipalName = wszPrincipalNameIn ;
        }
		if (ToolVerbose())
			Inform(L"Using principal name %s", pwszPrincipalName);

        if ((ulAuthnService == RPC_C_AUTHN_GSS_NEGOTIATE) ||
            (ulAuthnService == RPC_C_AUTHN_GSS_KERBEROS))
        {
            if (fKerbDelegation)
            {
                SecQOS.ImpersonationType = RPC_C_IMP_LEVEL_DELEGATE;
            }

            if (pwszPrincipalName == NULL)
            {
            	GoingTo(L"RpcMgmtInqServerPrincName");
                status = RpcMgmtInqServerPrincName( hBind,
                                                    ulAuthnService,
                                                    &pwszPrincipalName );
                if (status != RPC_S_OK)
                {
                    Failed(L"RpcMgmtInqServerPrincName(), err- %lut, ATTENTION !!! test continues...",
                                                            status) ;
                }
				else
				{
					Succeeded(L"RpcMgmtInqServerPrincName");
				}
				if (ToolVerbose())
        	        Inform(L"RpcMgmtInqServerPrincName() return %s, Delegate- %lut",
                                     pwszPrincipalName, fKerbDelegation) ;
            }
            else
            {
                Inform(L"Using user supplied Principal name- %s, Delegate- %lut",
                                     pwszPrincipalName, fKerbDelegation) ;
            }
        }

		GoingTo(L"RpcBindingSetAuthInfoEx");
        status = RpcBindingSetAuthInfoEx( hBind,
                                          pwszPrincipalName,
                                          ulAuthnLevel,
                                          ulAuthnService,
                                          NULL,
                                          RPC_C_AUTHZ_NONE,
                                          &SecQOS );
		if (status != RPC_S_OK)
		{
			Failed(L"RpcBindingSetAuthInfoEx, error %lut", status);
		}
		else
		{	
			Succeeded(L"RpcBindingSetAuthInfoEx");
		}
		if (ToolVerbose())
	        Inform(L"RpcBindingSetAuthInfoEx(Service- %lut, Level- %lut) returned %lut",
                                  ulAuthnService, ulAuthnLevel, status) ;
    }
    else
    {
		if (ToolVerbose())
	        Inform(L"Not using authentication !!!") ;
    }

    ULONG ul ;
    RpcTryExcept
    {
    	GoingTo(L"call remote function");
        ul =  RemoteFunction( hBind, fImpersonate ) ;
        if (ul == 0)
        {
        	Succeeded(L"call remote function");
        }
        else
        {
        	Failed(L"call remote function, returned %lut", ul);
        }
    	if (ToolVerbose())
    		Inform(L"%4lut: RemoteFunction() returned %lut", i, ul) ;
    }
    RpcExcept(1)
    {
        ul = RpcExceptionCode();
        Failed(L"ERROR: %4lut- Exception while calling RemoteFunction(), err- %lut",
                                                                  i, ul) ;
    }
    RpcEndExcept

    status = RpcBindingFree( &hBind ) ;
	if (ToolVerbose())
    	Inform(L"RpcBindingFree() return %lut", status) ;

    return ul ;
}

/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqping\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
#define AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>
#include <rpc.h>

//#define _WIN32_WINNT 0x0500

#include "..\\base\\base.h" 
#include "mq.h"


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqrpcs\sidtext.cpp ===
//
// file:  sidtext.cpp
//

#include <windows.h>
#include <stdio.h>
#include <tchar.h>

//+---------------------------
//
//  BOOL GetTextualSid()
//
// Routine Description:
//
//    This function generates a printable unicode string representation
//    of a SID.
//
//    The resulting string will take one of two forms.  If the
//    IdentifierAuthority value is not greater than 2^32, then
//    the SID will be in the form:
//
//        S-1-281736-12-72-9-110
//              ^    ^^ ^^ ^ ^^^
//              |     |  | |  |
//              +-----+--+-+--+---- Decimal
//
//    Otherwise it will take the form:
//
//        S-1-0x173495281736-12-72-9-110
//            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
//             Hexidecimal    |  | |  |
//                            +--+-+--+---- Decimal
//
//+---------------------------

BOOL GetTextualSid(
        PSID    pSid,          // binary Sid
        LPTSTR  TextualSid,    // buffer for Textual representaion of Sid
        LPDWORD dwBufferLen    // required/provided TextualSid buffersize
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    //
    // test if Sid passed in is valid
    //
    if(!IsValidSid(pSid)) return FALSE;

    // obtain SidIdentifierAuthority
    psia=GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities=*GetSidSubAuthorityCount(pSid);

    //
    // compute buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    dwSidSize = (15 + 12 + (12 * dwSubAuthorities) + 1) ;

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if (*dwBufferLen < dwSidSize)
    {
        *dwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    dwSidSize = _stprintf(TextualSid, TEXT("S-%lu-"), dwSidRev );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        dwSidSize += _stprintf(TextualSid + lstrlen(TextualSid),
                       TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                       (USHORT)psia->Value[0],
                       (USHORT)psia->Value[1],
                       (USHORT)psia->Value[2],
                       (USHORT)psia->Value[3],
                       (USHORT)psia->Value[4],
                       (USHORT)psia->Value[5]);
    }
    else
    {
        dwSidSize += _stprintf(TextualSid + lstrlen(TextualSid),
                       TEXT("%lu"),
                      (ULONG)(psia->Value[5]      )   +
                      (ULONG)(psia->Value[4] <<  8)   +
                      (ULONG)(psia->Value[3] << 16)   +
                      (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        dwSidSize += _stprintf(TextualSid + dwSidSize, TEXT("-%lu"),
                                *GetSidSubAuthority(pSid, dwCounter) ) ;
    }

    return TRUE;
}

//+---------------------------
//
//  BOOL GetTextualSidW()
//
//+---------------------------

BOOL GetTextualSidW(
        PSID    pSid,          // binary Sid
        LPWSTR  TextualSid,    // buffer for Textual representaion of Sid
        LPDWORD pdwBufferLen   // required/provided TextualSid buffersize
    )
{
    TCHAR *pBuf = new TCHAR[ *pdwBufferLen ] ;
    BOOL f = GetTextualSid( pSid,
                            pBuf,
                            pdwBufferLen ) ;
    if (!f)
    {
        delete pBuf ;
        return FALSE ;
    }

#if defined(UNICODE) || defined(_UNICODE)
    wcscpy(TextualSid, pBuf) ;
#else
    mbstowcs( TextualSid, pBuf, (*pdwBufferLen)+1 ) ;
#endif

    delete pBuf ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqrpcc\mqrpcc.cpp ===
// This tool helps to diagnose problems with MSMQ RPC (client side)
//
// AlexDad, September 2000
// 

#include "stdafx.h"
#include "_mqini.h"
#include <winsvc.h>

#include "..\hauthen.h"
#include "..\hauthen1.h"
#include "authni.h"

extern ULONG  RunRpcTest(
				   int   i,
                   WCHAR *wszProtocol,
                   WCHAR *wszServerName,
                   WCHAR *wszEndpoint,
                   WCHAR *wszOptions,
                   WCHAR *wszPrincipalNameIn,
                   ULONG ulAuthnService,
                   ULONG ulAuthnLevel,
                   BOOL  fImpersonate,
                   BOOL  fAuthen,
                   BOOL  fKerbDelegation );

const char  x_szAuthnSrvConstants[] = { "\n\n"
                      "\t#define RPC_C_AUTHN_NONE          0\n"
                      "\t#define RPC_C_AUTHN_DCE_PRIVATE   1\n"
                      "\t#define RPC_C_AUTHN_DCE_PUBLIC    2\n"
                      "\t#define RPC_C_AUTHN_DEC_PUBLIC    4\n"
                      "\t#define RPC_C_AUTHN_GSS_NEGOTIATE 9\n"
                      "\t#define RPC_C_AUTHN_WINNT        10\n"
                      "\t#define RPC_C_AUTHN_GSS_SCHANNEL 14\n"
                      "\t#define RPC_C_AUTHN_GSS_KERBEROS 16\n"
                      "\t#define RPC_C_AUTHN_MSN          17\n"
                      "\t#define RPC_C_AUTHN_DPA          18\n"
                      "\t#define RPC_C_AUTHN_MQ          100\n"
                      "\t#define RPC_C_AUTHN_DEFAULT     0xFFFFFFFFL\n" } ;

const char  x_szAuthnLvlConstants[] = { "\n\n"
                      "\t#define RPC_C_AUTHN_LEVEL_DEFAULT       0\n"
                      "\t#define RPC_C_AUTHN_LEVEL_NONE          1\n"
                      "\t#define RPC_C_AUTHN_LEVEL_CONNECT       2\n"
                      "\t#define RPC_C_AUTHN_LEVEL_CALL          3\n"
                      "\t#define RPC_C_AUTHN_LEVEL_PKT           4\n"
                      "\t#define RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5\n"
                      "\t#define RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6\n" } ;

//
// Log control. The get functions below are called from tmqbase.lib
//
bool fVerbose = false;
bool fDebug   = false;
FILE *g_fileLog = NULL;
TCHAR g_tszService[100] = L"MSMQ";

FILE *ToolLog()			{	return g_fileLog;	}
BOOL ToolVerbose()		{ 	return fVerbose;	}
BOOL ToolVerboseDebug() { 	return fDebug;		}
BOOL ToolThreadReport() { 	return FALSE;		} 

void OpenLogFile()
{
    g_fileLog = fopen( "tmqrpcc.log", "w" );

    if (g_fileLog)
    {
        time_t  lTime ;
        time( &lTime ) ;
        fprintf(g_fileLog, "tmqrpcc run at: %ws", _wctime( &lTime ) );
    }
}

void CloseLogFile()
{
    fflush(g_fileLog);
    fclose(g_fileLog);
}

// 
// Main logic of the tool
//
BOOL DoTheJob(
	ULONG  ulAuthnService,
    ULONG  ulAuthnLevel,
    LPUSTR pszProtocol,
    LPUSTR pszEndpoint,
    LPUSTR pszServerName,
    LPUSTR pszPrincipalName,
	LPUSTR pszOption,
    ULONG ulIterations,
    BOOL  fAuthen,
    BOOL  fRegister,
    BOOL  fImpersonate,
    BOOL  fKerbDelegation,
    BOOL  fLocalRpc
)
{
	BOOL fSuccess = TRUE, b;
	
	//-----------------------------------------------------------------------------
	GoingTo(L"client remote call "); 
	
	//-----------------------------------------------------------------------------

	b = TRUE;

    if (fLocalRpc)
    {
        pszServerName = NULL ;
    }
    else if (!pszServerName)
    {
        Failed(L"execute: you must specify the server") ;
        return FALSE;
    }

    WCHAR wszProtocol[ 512 ] ;
    mbstowcs( wszProtocol,
              (char*) (const_cast<unsigned char*> (pszProtocol)),
              sizeof(wszProtocol)/sizeof(WCHAR)) ;

    WCHAR wszEndpoint[ 512 ] ;
    mbstowcs( wszEndpoint,
              (char*) (const_cast<unsigned char*> (pszEndpoint)),
              sizeof(wszEndpoint)/sizeof(WCHAR)) ;

    WCHAR wszOptions[ 512 ] ;
    mbstowcs( wszOptions,
              (char*) (const_cast<unsigned char*> (pszOption)),
              sizeof(wszOptions)/sizeof(WCHAR)) ;

    WCHAR wszServerName[ 512 ] = {0} ;
    if (pszServerName)
    {
        mbstowcs( wszServerName,
                  (char*) (const_cast<unsigned char*> (pszServerName)),
                  sizeof(wszServerName)/sizeof(WCHAR)) ;
    }

    WCHAR wszPrincipalName[ 512 ] = {0} ;
    if (pszPrincipalName)
    {
        mbstowcs( wszPrincipalName,
                  (char*) (const_cast<unsigned char*> (pszPrincipalName)),
                  sizeof(wszPrincipalName)/sizeof(WCHAR)) ;
    }

    for ( int i = 0 ; i < (int) ulIterations ; i++ )
    {
        ULONG ul = RunRpcTest( 
        				 i,
                         wszProtocol,
                         wszServerName,
                         wszEndpoint,
                         wszOptions,
                         wszPrincipalName,
                         ulAuthnService,
                         ulAuthnLevel,
                         fImpersonate,
                         fAuthen,
                         fKerbDelegation ) ;
		b = (ul == 0);
		if(!b)
		{
			fSuccess = FALSE;
			Failed(L"execute remote call #%d", i);
		}
		else
		{
			Succeeded(L"execute remote call #%d", i);
		}
    }
	

	return fSuccess;
}

//
//  help
//
void Usage()
{
	printf("usage: rpcc <see options below>  \n");

    printf("\t  -n <Server name>\n");
    printf("\t  -a <authentication service, decimal number>\n") ;
    printf("\t  -c <number of iterations, decimal number>\n") ;
    printf("\t  -e (enable Kerberos delegation)\n") ;
    printf("\t  -i (do NOT impersonate on server)\n");
    printf("\t  -l <authentication Level, decimal number>\n") ;
    printf("\t  -o (use local rpc, tcpip being the default)\n");
    printf("\t  -p <principal name, for nego>\n\n");
    printf("\t  -t (do NOT use authentication)\n\n");
    printf("\t  -s (show authentication Services and Levels)\n") ;
    printf("\t  -v verbose\n");
    printf("\t  -d most verbose\n");

    printf(x_szUsage);
}


//
//  Main entry point - called from the tmq.exe 
//
int _stdcall run( int argc, char *argv[ ])
{
    //
    // Parse parameters
    //
    ULONG  ulAuthnService   = RPC_C_AUTHN_WINNT;               // RPC_C_AUTHN_NONE ;
    ULONG  ulAuthnLevel     = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY; // RPC_C_AUTHN_LEVEL_NONE ;
    LPUSTR pszProtocol      =  PROTOSEQ_TCP ;
    LPUSTR pszEndpoint      =  ENDPOINT_TCP ;
    LPUSTR pszServerName    = NULL ;
    LPUSTR pszPrincipalName = NULL ;
    LPUSTR pszOption        =  OPTIONS_TCP ;
    ULONG ulIterations = 1 ;
    BOOL  fAuthen      = TRUE ;
    BOOL  fRegister    = TRUE ;
    BOOL  fImpersonate = TRUE ;
    BOOL  fKerbDelegation = FALSE ;
    BOOL  fLocalRpc       = FALSE ;

	for (int i=2; i<argc; i++)
	{
		if (*argv[i] != '-' && *argv[i] != '/')
		{
			printf("Invalid parameter '%S'.\n\n", argv[i]);
            Usage();
		}

		switch (tolower(*(++argv[i])))
		{
		    case 'v':
			    fVerbose = true;
			    break;

		    case 'd':
			    fDebug = true;
			    fVerbose = true;
			    break;

            case 'a':
                sscanf(argv[++i], "%lu", &ulAuthnService) ;
                break ;

            case 'c':
                sscanf(argv[++i], "%lu", &ulIterations) ;
                break ;

            case 'e':
                fKerbDelegation = TRUE ;
                break ;

            case 'i':
                fImpersonate = FALSE ;
                break ;

            case 'l':
                sscanf(argv[++i], "%lu", &ulAuthnLevel) ;
                break ;

            case 'n':
                pszServerName = (LPUSTR) argv[++i] ;
                break ;

            case 'o':
                fLocalRpc = TRUE ;
                pszProtocol =  PROTOSEQ_LOCAL ;
                pszEndpoint =  ENDPOINT_LOCAL ;
                pszOption   =  OPTIONS_LOCAL ;
                break ;

            case 'p':
                pszPrincipalName = (LPUSTR) argv[++i] ;
                break ;

            case 's':
                printf(x_szAuthnSrvConstants) ;
                printf(x_szAuthnLvlConstants) ;
                exit(0);

            case 't':
                fAuthen = FALSE ;
                break ;


            case 'h':
            case '?':
                Usage();
			    exit(0);
			    
		    default:
			    printf("Unknown switch '%s'.\n\n", argv[i]);
                Usage();
			    exit(0);
		}
	}


    //
    // Create tmqrpcc.log - log file in current directory
    //
    OpenLogFile();

    Inform(L"TMQ Rpcc tests RPC (client side)");

	// Log down time , date, machine, OS
	LogRunCase();

	
	// actual work
	BOOL b = DoTheJob(
 			    ulAuthnService,
			    ulAuthnLevel,
			    pszProtocol,
			    pszEndpoint,
			    pszServerName,
			    pszPrincipalName,
			    pszOption,
			    ulIterations ,
			    fAuthen,
			    fRegister,
			    fImpersonate,
			    fKerbDelegation,
			    fLocalRpc);

	if (b)
	{
		Inform(L"\n\n+++++++ Rpc seems healthy ++++++++\n");
	}
	else
	{
		Inform(L"\n\n-------- TMQ Rpcc has found problems with the RPC ---------\n");
	}

	CloseLogFile();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqrpcs\sidtext.h ===
//
// file:  sidtext.h
//

BOOL GetTextualSid(
        PSID    pSid,          // binary Sid
        LPTSTR  TextualSid,    // buffer for Textual representaion of Sid
        LPDWORD pdwBufferLen   // required/provided TextualSid buffersize
        ) ;

BOOL GetTextualSidW(
        PSID    pSid,          // binary Sid
        LPWSTR  TextualSid,    // buffer for Textual representaion of Sid
        LPDWORD pdwBufferLen   // required/provided TextualSid buffersize
        ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqrpcs\hauthens.cpp ===
//
// file:  hauthens.cpp
//
#include "stdafx.h"
#include "..\hauthen.h"
#include "authni.h"
#include "sidtext.h"

struct ThreadData
{
    HANDLE hAccessToken;
    BOOL   fSetToken ;
} ;

//+---------------------------
//
//  void ShowThreadUser()
//
//+---------------------------

void ShowThreadUser()
{
   ULONG ulErr = 0 ;
   HANDLE hToken = NULL ;

   GoingTo(L"OpenThreadToken");
   if (OpenThreadToken( GetCurrentThread(),
                        TOKEN_QUERY,
                        FALSE,
                        &hToken))
   {
      Succeeded(L"OpenThreadToken");
      
      TCHAR tuBuf[128] ;
      TOKEN_USER *ptu = (TOKEN_USER*) tuBuf ;
      DWORD  dwSize ;

	  GoingTo(L"GetTokenInformation");
      if (GetTokenInformation( hToken,
                               TokenUser,
                               ptu,
                               sizeof(tuBuf),
                               &dwSize ))
      {
	     Succeeded(L"GetTokenInformation");
	     
         DWORD dwASize = 1024 ;
         DWORD dwDSize = 1024 ;
         TCHAR szAccount[ 1024 ] = {0} ;
         TCHAR szDomain[ 1024 ] = {0} ;
         SID_NAME_USE su ;

         SID *pSid = (SID*) ptu->User.Sid ;
         
   		 GoingTo(L"LookupAccountSid");
         if (LookupAccountSid( NULL,
                               pSid,
                               szAccount,
                               &dwASize,
                               szDomain,
                               &dwDSize,
                               &su ))
         {
            Inform(L"LookupAccountSid(): Account- %s, Domain- %s", szAccount, szDomain);
         }
         else
         {
            ulErr = GetLastError() ;
            Failed(L"LookupAccountSid. err- %ldt", ulErr);
         }

         TCHAR  tBuf[ 256 ] ;
         DWORD  dwBufferLen = 256 ;

   		 GoingTo(L"GetTextualSid");
         BOOL fText = GetTextualSid( pSid,
                                     tBuf,
                                     &dwBufferLen ) ;
		 if (fText)
		 {
	         Inform(L"sid- %s", tBuf);
	     }
	     else
	     {
	     	 Failed(L"GetTextualSid");
	     }
      }
      else
      {
         	ulErr = GetLastError() ;
         	Failed(L"GetTokenInformation. err- %lut, size- %ldt",ulErr, dwSize);
      }
   }
   else
   {
      ulErr = GetLastError() ;
      if (ulErr == ERROR_NO_TOKEN)
      {
        	Failed(L"OpenThreadToken(), thread does not have a token");
      }
      else
      {
        	Failed(L"OpenThreadToken(), err- %lut", ulErr);
      }
   }

   if (hToken)
   {
       CloseHandle(hToken) ;
   }
}

//+-------------------------
//
//  ULONG WhoCalledUs()
//
//+-------------------------

ULONG WhoCalledUs()
{
    RPC_STATUS status ;

    GoingTo(L"RpcImpersonateClient");
    status = RpcImpersonateClient(NULL) ;
    if (status != RPC_S_OK)
    {
   	   Failed(L"RpcImpersonateClient, error=%ldt", status);
       return status ;
    }
    else
    {
   		Succeeded(L"RpcImpersonateClient");
    }

    GoingTo(L"ShowThreadUser");
    ShowThreadUser() ;
    Succeeded(L"ShowThreadUser");

	GoingTo(L"RpcRevertToSelf");
    status = RpcRevertToSelf() ;
    if (status != RPC_S_OK)
    {
    	Failed(L"RpcRevertToSelf, error=%ldt", status);
        return status ;
    }
    else
    {
    	Succeeded(L"RpcRevertToSelf");
    }

    return 0;
}

//+----------------------------
//
//  ULONG RemoteFunction()
//
//+----------------------------

ULONG RemoteFunction( handle_t       /* hBind */,
                      unsigned long  fImpersonate )
{
    ULONG status = 0 ;
    Inform(L"\nIn RemoteFunction()");
    if (fImpersonate)
    {
    	GoingTo(L"call WhoCalledUs");
        status = WhoCalledUs() ;
	    if (status != RPC_S_OK)
    	{
    		Failed(L"call WhoCalledUs, error=%ldt", status);
		}
	    else
    	{
    		Succeeded(L"call WhoCalledUs");
	    }
    }
    return status  ;
}


RPC_STATUS TryRemoteCall(LPUSTR pszProtocol, 
						 LPUSTR pszEndpoint, 
						 BOOL   fRegister, 
						 ULONG  ulAuthnService)
{
    ULONG ulMaxCalls = 1000 ;
    ULONG ulMinCalls = 1 ;

    WCHAR wszProtocol[ 512 ] ;
    mbstowcs( wszProtocol,
              (char*) (const_cast<unsigned char*> (pszProtocol)),
              sizeof(wszProtocol)/sizeof(WCHAR)) ;

    WCHAR wszEndpoint[ 512 ] ;
    mbstowcs( wszEndpoint,
              (char*) (const_cast<unsigned char*> (pszEndpoint)),
              sizeof(wszEndpoint)/sizeof(WCHAR)) ;

	GoingTo(L"RpcServerUseProtseqEp");
    RPC_STATUS status = RpcServerUseProtseqEp( wszProtocol,
                                               ulMaxCalls,
                                               wszEndpoint,
                                               NULL ) ;  // Security descriptor
	if (ToolVerbose())
	    Inform(L"RpcServerUseProtseqEp(%s, %s) returned %lut",
                                      wszProtocol, wszEndpoint, status);
    if (status != RPC_S_OK)
    {
	    Failed(L"RpcServerUseProtseqEp(%s, %s), status=%lut",
                                      wszProtocol, wszEndpoint, status);
        return status;
    }
    else
    {
    	Succeeded(L"RpcServerUseProtseqEp");
    }


	GoingTo(L"RpcServerRegisterIf");
    status = RpcServerRegisterIf( hauthen_i_v1_0_s_ifspec,
                                  NULL,    // MgrTypeUuid
                                  NULL );  // MgrEpv; null means use default
	if (ToolVerbose())
	    Inform(L"RpcServerRegisterIf returned %lut", status);
    if (status != RPC_S_OK)
    {
	    Failed(L"RpcServerRegisterIf, status=%lut", status);
        return status ;
    }
    else
    {
    	Succeeded(L"RpcServerRegisterIf");
    }


    if (fRegister)
    {
        LPWSTR pwszPrincipalName = NULL;
        if ((ulAuthnService == RPC_C_AUTHN_GSS_NEGOTIATE) ||
            (ulAuthnService == RPC_C_AUTHN_GSS_KERBEROS))
        {
        	GoingTo(L"RpcServerInqDefaultPrincName");
            //
            // kerberos needs principal name
            //
            status = RpcServerInqDefaultPrincName( ulAuthnService,
                                                  &pwszPrincipalName );
			if (ToolVerbose())
    	        Inform(L"RpcServerInqDefaultPrincName() return %s", pwszPrincipalName);
            
            if (status != RPC_S_OK)
            {
               Failed(L"RpcServerInqDefaultPrincName(), status %lut",status);
               return(status);
            }
            else
            {
	            Succeeded(L"RpcServerInqDefaultPrincName(), return %s", pwszPrincipalName);
            }
       }

	   GoingTo(L"RpcServerRegisterAuthInfo");
       status = RpcServerRegisterAuthInfo( pwszPrincipalName,
                                           ulAuthnService,
                                           NULL,
                                           NULL );
		if (ToolVerbose())
    	   Inform(L"RpcServerRegisterAuthInfo(Service- %lut) returned %lut",ulAuthnService, status);
        if (status != RPC_S_OK)
        {
        	Failed(L"RpcServerRegisterAuthInfo(Service- %lut) returned %lut",ulAuthnService, status);
            return status ;
        }
    }

    GoingTo(L"Call RpcServerListen");
    status = RpcServerListen(ulMinCalls,
                             ulMaxCalls,
                             FALSE) ;
    Inform(L"RpcServerListen returned %lut", status);

    return 0 ;

} // end main()


/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file hauthens.cpp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqrpcs\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
#define AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <tchar.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>
//#define _WIN32_WINNT 0x0500

#include "..\\base\\base.h" 


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqping\sim.cpp ===
// This tool helps to diagnose problems with network or MSMQ conenctivity 
//
// AlexDad, April 2000 - based on the mqping tool by RonenB
//

#include "stdafx.h"
#include <sys/timeb.h>
#include "sim.h"

extern bool  fVerbose;
extern bool  fDebug;

extern TCHAR *ErrToStr( DWORD dwErr );


// Get pointer to property location
MQPROPVARIANT *
	MsgPropVariant(
		SIMPLEMSGPROPS *pMsgDsc,
		MSGPROPID	PropID )
{
	int iPropIndex;

	if ( !IsMsgPropValid(pMsgDsc, PropID) )
		(pMsgDsc)->iPropIndex[PropID] = (pMsgDsc)->Props.cProp++;

	iPropIndex = pMsgDsc->iPropIndex[PropID];
	pMsgDsc->PropID[iPropIndex] = PropID;

	return( &pMsgDsc->PropVar[iPropIndex] );
}

// PROPID_M_BODY
void
	MsgProp_BODY(
		SIMPLEMSGPROPS *pMsgDsc,
		LPVOID	pBody,
		ULONG	ulSize )
{
	MQPROPVARIANT	*pPropVar = MsgPropVariant( pMsgDsc, PROPID_M_BODY );

	pPropVar->vt = VT_UI1 | VT_VECTOR;
	pPropVar->caub.cElems = ulSize;
	pPropVar->caub.pElems = (unsigned char *)(pBody);
}

// PROPID_M_BODY_SIZE
void
	MsgProp_BODY_SIZE(
		SIMPLEMSGPROPS *pMsgDsc )
{
	MQPROPVARIANT	*pPropVar = MsgPropVariant( pMsgDsc, PROPID_M_BODY_SIZE );

	pPropVar->vt = VT_UI4;
}

// PROPID_M_LABEL
void
	MsgProp_LABEL(
		SIMPLEMSGPROPS *pMsgDsc,
		WCHAR *wcsLabel )
{
	MQPROPVARIANT	*pPropVar;
	ULONG	ulLabelLen = pMsgDsc->ulLabelLen;

	// if there is no label or it's not at the maximum size
	if ( !pMsgDsc->pwcsLabel ||
			pMsgDsc->ulLabelLen < (MQ_MAX_MSG_LABEL_LEN + 1) )
	{
		// this is the length we want
		if ( wcsLabel )			// want to send a message with a label
		{
			ulLabelLen = (DWORD)wcslen(wcsLabel) + 1;
			if ( ulLabelLen > (MQ_MAX_MSG_LABEL_LEN + 1) )
				ulLabelLen = MQ_MAX_MSG_LABEL_LEN + 1;
		}
		else					// want to receive a message with a label
			ulLabelLen = MQ_MAX_MSG_LABEL_LEN + 1;

		// check previous label length
		if ( !pMsgDsc->pwcsLabel ||
				ulLabelLen > pMsgDsc->ulLabelLen )
		{
			// free previously allocated label
			if ( pMsgDsc->pwcsLabel )
			{
				free( pMsgDsc->pwcsLabel );
				pMsgDsc->ulLabelLen = 0;	// reset message label length
			}

			// alocate memory for the message label
			pMsgDsc->pwcsLabel = (unsigned short *) malloc( ulLabelLen * sizeof(*wcsLabel) );
		}
	}


	// if memory allocated then update property
	if ( pMsgDsc->pwcsLabel )
	{
		pMsgDsc->ulLabelLen = ulLabelLen;	// keep message label length

		pPropVar = MsgPropVariant( pMsgDsc, PROPID_M_LABEL );

		// sending a message
		if ( wcsLabel )
		{
			// copy label
			wcsncpy( pMsgDsc->pwcsLabel, wcsLabel, ulLabelLen );
			pMsgDsc->pwcsLabel[ulLabelLen-1] = L'\0';	// explicit terminator

			// remove LABEL_LEN property
			MsgPropRemove( pMsgDsc, PROPID_M_LABEL_LEN );
		}
		else	// receiving a message
		{
			// clear label
			wcscpy( pMsgDsc->pwcsLabel, L"" );

			//set max label length
			MsgProp_LABEL_LEN( pMsgDsc, ulLabelLen );
		}

		pPropVar->vt = VT_LPWSTR;
		pPropVar->pwszVal = pMsgDsc->pwcsLabel;
	}
	// no memory -> remove property
	else
	{
		MsgPropRemove( pMsgDsc, PROPID_M_LABEL );
	}
}

// PROPID_M_TIME_TO_REACH_QUEUE
void
	MsgProp_TIME_TO_REACH_QUEUE(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulSecToReachQ)
{
	MQPROPVARIANT	*pPropVar = MsgPropVariant( pMsgDsc, PROPID_M_TIME_TO_REACH_QUEUE );

	pPropVar->vt = VT_UI4;
	pPropVar->ulVal = ulSecToReachQ;
}

// PROPID_M_RESP_QUEUE
void
	MsgProp_RESP_QUEUE(
		SIMPLEMSGPROPS *pMsgDsc,
		WCHAR	*pwcsRespQ )
{
	MQPROPVARIANT	*pPropVar = MsgPropVariant( pMsgDsc, PROPID_M_RESP_QUEUE );

	pPropVar->vt = VT_LPWSTR;
	pPropVar->pwszVal = pwcsRespQ;
}

// PROPID_M_LABEL_LEN
void
	MsgProp_LABEL_LEN(
		SIMPLEMSGPROPS *pMsgDsc,
		ULONG	ulLabelLen )
{
	MQPROPVARIANT	*pPropVar = MsgPropVariant( pMsgDsc, PROPID_M_LABEL_LEN );

	// keep real label length
	pMsgDsc->ulLabelLen = ulLabelLen;

	pPropVar->vt = VT_UI4;
	pPropVar->ulVal = ulLabelLen;
}

/*****************************************************************************

	NewMsgProps

locate a new message properties structure

******************************************************************************/
SIMPLEMSGPROPS
	*NewMsgProps()
{
	SIMPLEMSGPROPS *pMsgDsc;

	pMsgDsc = (struct tagSIMPLEMSGPROPS *) malloc( sizeof(*pMsgDsc) );

	if ( pMsgDsc )
	{
		int i;

		// reset all information
		memset( pMsgDsc, 0, sizeof(*pMsgDsc) );

		pMsgDsc->Props.aPropID = pMsgDsc->PropID;
		pMsgDsc->Props.aPropVar = pMsgDsc->PropVar;
		pMsgDsc->Props.aStatus = pMsgDsc->hStatus;

		// reset all property indexs
		for( i=0; i<=SIMPLEMSGPROPS_COUNT; i++ )
		{
			pMsgDsc->iPropIndex[i] = PROP_INDEX_FREE;
		}
	}

	return( pMsgDsc );
}

/*****************************************************************************

	MsgPropRemove

update message property index

******************************************************************************/
void
	MsgPropRemove(
		SIMPLEMSGPROPS *pMsgDsc,
		MSGPROPID	PropID )		// property ID to remove
{
	// remove this property
	int iIndex = pMsgDsc->iPropIndex[PropID];

	if ( iIndex != PROP_INDEX_FREE )
	{
		// keep index and decrease property count
		int iLast = --pMsgDsc->Props.cProp;

		// set this property to unused
		pMsgDsc->iPropIndex[PropID] = PROP_INDEX_FREE;

		// move last property to free location
		if ( iIndex != iLast )
		{
			pMsgDsc->PropID[iIndex] = pMsgDsc->PropID[iLast];
			pMsgDsc->PropVar[iIndex] = pMsgDsc->PropVar[iLast];
			pMsgDsc->hStatus[iIndex] = pMsgDsc->hStatus[iLast];

			// set property pointer to new index
			pMsgDsc->iPropIndex[ pMsgDsc->PropID[iIndex] ] = iIndex;
		}
	}
}

/*****************************************************************************

	LocateQbyRestriction

 Locate a queue according to a given restriction

******************************************************************************/
HRESULT
	LocateQbyRestriction(
		const WCHAR *pwcsContext,
		MQPROPERTYRESTRICTION * pRestriction,
		const ULONG nRes,
		MQSORTSET *pSort,
		GUID	*pQId )
{
#define NUM_SRCH_PROPS	1
	HRESULT stat, SrchStat = (HRESULT)-1;
	HANDLE hLocate=NULL;

	MQRESTRICTION ResObj;
	DWORD cp = NUM_SRCH_PROPS;

	// declare the properties that nead to be returned
	PROPID PropSpec[NUM_SRCH_PROPS] =
		{ PROPID_Q_INSTANCE };


	// the search should return the information pointed by this list
	MQCOLUMNSET Columns =
		{ NUM_SRCH_PROPS, PropSpec };


	MQPROPVARIANT QueuePVar[NUM_SRCH_PROPS] =
	{
		{ VT_NULL,	0,0,0 }
	};


	// Initiate the search

	ResObj.cRes = nRes;
	ResObj.paPropRes = pRestriction;

	GoingTo(L"MQLocateBegin");
	SrchStat = MQLocateBegin( pwcsContext, &ResObj, &Columns, pSort, &hLocate );


	if ( SUCCEEDED(SrchStat) )
	{

		GoingTo(L"MQLocateNext");

		SrchStat = MQLocateNext( hLocate, &cp, QueuePVar );
		if ( SUCCEEDED(SrchStat) )
		{
			Succeeded(L"MQLocateNext");
			if ( cp > 0 )
			{
				if ( pQId )
					*pQId = *QueuePVar[0].puuid;
				MQFreeMemory( QueuePVar[0].puuid );
			}
			else
				SrchStat = MQ_ERROR_QUEUE_NOT_FOUND;
		}

		// end of search
		GoingTo(L"MQLocateEnd");
		stat = MQLocateEnd( hLocate );
	}
	Succeeded(L"LocateQbyRestriction: hr=0x%x  %s", SrchStat, ErrToStr(SrchStat));

	return SrchStat;
#undef	NUM_SRCH_PROPS
}
/*****************************************************************************

	LocateQ

 Locate a queue

******************************************************************************/
HRESULT
	LocateQ(
		WCHAR	*pwcsFormatName,		// output format name
		DWORD	*pdwFormatNameLen,		// in/out length of format name
		GUID	*pQId,					// guid of required queue, may be NULL or 0
		WCHAR	*pwcsQPath,			// path information
		WCHAR	*pwcsQName )			// queue name
{
	HRESULT SrchStat = (HRESULT)-1;
	GUID	guidQId = GUID_NULL;


	// build a query for finding a queue with given Queue Path, only if required
	if ( pwcsQPath && *pwcsQPath )
	{
		SrchStat = MQPathNameToFormatName( pwcsQPath,
				pwcsFormatName, pdwFormatNameLen );

		return SrchStat;
	}


	// build a quey for finding a queue with given Queue Name, only if required
	if ( pwcsQName && *pwcsQName )
	{
		long lRestrictions = 1;
		MQPROPERTYRESTRICTION ResNameType[2];

		// if no output queue guid, use our's
		if ( !pQId )
			pQId = &guidQId;

		ResNameType[0].rel = PREQ;					// this means "==" (equals)
		ResNameType[0].prop = PROPID_Q_LABEL;
		ResNameType[0].prval.vt = VT_LPWSTR;
		ResNameType[0].prval.pwszVal = pwcsQName;	// This is the name


		SrchStat = LocateQbyRestriction( NULL, ResNameType, lRestrictions, NULL, pQId );

		return SrchStat;
	}

	return SrchStat;
}


/*****************************************************************************

	CreateQ

  Locate / Create queue and open a handle to it

******************************************************************************/
QUEUEHANDLE							// return queue handle or NULL for error
	CreateQ(
		GUID	*pQId,					// guid of required queue, may be NULL or 0
		WCHAR	*pwcsQPath,				// pointer to queue path information
		GUID	*pQType,				// guid of queue type, may be NULL
		WCHAR	*pwcsQName,				// pointer to queue name
		DWORD	*pdwFormatNameLen,		// out = length of format len
		WCHAR	*pwcsFormatName,		// format name
		DWORD	dwFormatNameLen,		// format name buf len
		const DWORD dwAccess,			// QM access rights
		PSECURITY_DESCRIPTOR pSecurityDescriptor,
		ULONG	ulOpenFlags)			// Q opened flags
{
	HRESULT hr;
	BOOL	bNewQueue = FALSE;		// flag indicates that the queue is newly created
	QUEUEHANDLE hqOpen=NULL;
//	GUID MyQId = GUID_NULL;
	GUID MyQType = GUID_NULL;
	
	WCHAR wcsFormatName[MAX_FORMAT_NAME_LEN+1];
 
	if ( !pQType )
		pQType = &MyQType;

	if ( !pwcsFormatName )
	{
		wcscpy( wcsFormatName, L"" );
		dwFormatNameLen = LEN_OF(wcsFormatName);
		pwcsFormatName = wcsFormatName;
	}


	{
		WCHAR wcsPathName[MAX_PATH_NAME_LEN+1];

		// make the full path
		if ( pwcsQPath && *pwcsQPath )			// there is a given queue path
		{
			WCHAR *pwcsPathSeperator = wcsrchr( pwcsQPath, L'\\' );

			// if there is no name sperator then use local computer name
			if ( !pwcsPathSeperator  )
				wcscpy( wcsPathName, L".\\" );		// default use local computer

			else
				wcscpy( wcsPathName, L"" );


			if ( (ulOpenFlags & CREATEQ_QTYPE_MASK) == CREATEQ_PRIVATE )
			{
				wcscat( wcsPathName, CREATEQ_PRIVATE_NAME L"\\" );
			}

			
			// add the input path name
			wcscat( wcsPathName, pwcsQPath );

		}
		else
			wcscpy( wcsPathName, L"" );

		// try to find the queue, or mybe it's a temp
		hr = MQ_ERROR_QUEUE_NOT_FOUND;
		if ( (ulOpenFlags & CREATEQ_QTYPE_MASK) != CREATEQ_TEMPORARY )
		{
			hr = LocateQ( pwcsFormatName, &dwFormatNameLen, pQId, wcsPathName, pwcsQName);
		}

		// try to find the queue, or mybe it's a temp
		if ( FAILED(hr) )
		{

			if ( *wcsPathName )			// there is a given queue path
			{
#define CREATEQ_CREATE_PROPS	12
				// create parameters
				int iProps;
				MQQUEUEPROPS aQueueProps;
				QUEUEPROPID aQueuePID[CREATEQ_CREATE_PROPS] =
					{ PROPID_Q_PATHNAME, PROPID_Q_TYPE,
					  0, 0, 0, 0, 0, 0, 0 };
				MQPROPVARIANT aQueuePVar[CREATEQ_CREATE_PROPS];
				HRESULT aQueueResult[CREATEQ_CREATE_PROPS];
#undef	CREATEQ_CREATE_PROPS


				aQueuePVar[0].vt = VT_LPWSTR;	aQueuePVar[0].pwszVal = wcsPathName;
				aQueuePVar[1].vt = VT_CLSID;	aQueuePVar[1].puuid = pQType;

				iProps = 2;

				if ( pwcsQName )
				{
					aQueuePID[iProps] = PROPID_Q_LABEL;
					aQueuePVar[iProps].vt = VT_LPWSTR;
					aQueuePVar[iProps].pwszVal = pwcsQName;
					iProps++;
				}


				// Create the queue
				aQueueProps.cProp = iProps;
				aQueueProps.aPropID = aQueuePID;
				aQueueProps.aPropVar = aQueuePVar;
				aQueueProps.aStatus = aQueueResult;

				GoingTo(L"Create queue %s", wcsPathName);

				hr = MQCreateQueue( pSecurityDescriptor, &aQueueProps, pwcsFormatName, &dwFormatNameLen );

				if (SUCCEEDED(hr))
				{
					Succeeded(L"MQCreateQueue: FN=%s", pwcsFormatName);
				}
				else
				{
					Failed(L"MQCreateQueue - hr=0x%x  %s", hr, ErrToStr(hr));
				}

				if ( pdwFormatNameLen )
					*pdwFormatNameLen = dwFormatNameLen;

				// someone was faster, queue created by someone else
				if ( hr == MQ_ERROR_QUEUE_EXISTS &&
						(ulOpenFlags & CREATEQ_CREATION_FLAGS) != CREATEQ_NEW )
				{
					Warning(L"Queue already existed");

					GoingTo(L"MQPathNameToFormatName for %s", wcsPathName);

					// someone was faster, queue created by someone else
					hr = MQPathNameToFormatName( 
												wcsPathName,
												pwcsFormatName, 
												&dwFormatNameLen 
												);

					if (SUCCEEDED(hr))
					{
						Succeeded(L"MQPathNameToFormatName: FN=%s", pwcsFormatName);
					}
					else
					{
						Failed(L"MQPathNameToFormatName - hr=0x%x   %s", hr, ErrToStr(hr));
					}
				}
				else
				{
					bNewQueue = TRUE;
				}

				if ( FAILED(hr) )
				{
					SetLastError( hr );
					return NULL;
				}
			}
			else
			{
				SetLastError( (DWORD)-1 );
				return NULL;
			}
		}
	}

	// now open the queue
	{
		DWORD dwShareMode = 0 ;

		GoingTo(L"MQOpenQueue %s", pwcsFormatName);

		hr = MQOpenQueue( 
						pwcsFormatName,
						dwAccess, 
						dwShareMode, 
						&hqOpen 
						);


		if ( FAILED(hr) )
		{
			Failed(L"MQOpenQueue, hr=0x%x  %s", hr, ErrToStr(hr));
			SetLastError( hr );
		}
		else
		{
			Succeeded(L"MQOpenQueue");

			// flush only if the queue is not new
			if ( !bNewQueue && (ulOpenFlags & CREATEQ_FLUSH_MSGS) )
			{
				// read all messages from the queue to flush it's contents
				while (  MQ_OK ==
					MQReceiveMessage( hqOpen, 0, MQ_ACTION_RECEIVE, NULL, NULL, NULL, NULL, NULL )  );
			}
		}
	}

	return hqOpen;
}

/*****************************************************************************

	RecvMsg

  Receive a message

******************************************************************************/
HRESULT
	RecvMsg(
		const QUEUEHANDLE hQueue,	// handle of queue
		const DWORD dwTimeout,		// timeout to receive the message, may be INFINITE
		const DWORD dwAction,		// MQ_ACTION_READ, MQ_ACTION_PEEK_CURRENT, MQ_ACTION_PEEK_NEXT
		const HANDLE hCursor,		// used for filtering messages
		SIMPLEMSGPROPS *pMsgDsc,	// message properties information
		ITransaction *pTransaction )	// transaction pointer from DTC
{
	HRESULT hr;
	OVERLAPPED *pOverlapped;
	PMQRECEIVECALLBACK pfnReceiveCallback = NULL;


	if ( pMsgDsc->hEvent )
	{
		pMsgDsc->Overlapped.Offset = 0; 
		pMsgDsc->Overlapped.OffsetHigh = 0; 
		pMsgDsc->Overlapped.hEvent = pMsgDsc->hEvent;
		pOverlapped = &pMsgDsc->Overlapped;
	}
	else
		pOverlapped = NULL;


	// update label with actual length
	if ( IsMsgPropValid(pMsgDsc,PROPID_M_LABEL) )
		pMsgDsc->PropVar[pMsgDsc->iPropIndex[PROPID_M_LABEL_LEN]].ulVal = pMsgDsc->ulLabelLen;

	// receive the message
	GoingTo(L"MQReceiveMessage");

	hr = MQReceiveMessage( hQueue, dwTimeout, dwAction,
			&pMsgDsc->Props,
			pOverlapped, pfnReceiveCallback,
			hCursor, pTransaction );

	if (SUCCEEDED(hr))
	{
		Succeeded(L"MQReceiveMessage");
	}
	else
	{
		Failed (L"MQReceiveMessage, hr=0x%x  %s", hr, ErrToStr(hr));
	}

	return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsite\getmqds.cpp ===
#include "..\..\..\ds\getmqds\getmqds.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsite\dsstuff.cpp ===
#include "..\dsstuff.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsite\dsreg.cpp ===
#include "..\..\..\ds\getmqds\dsreg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsite\getrelax.cpp ===
#include "..\..\..\ds\getmqds\getrelax.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsite\dsliblog.cpp ===
#include "..\..\..\ds\getmqds\dsliblog.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsite\autorec.cpp ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>
#include <objbase.h>
#include <oaidl.h>
#include <activeds.h>
#include <iads.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include "_mqini.h"

#define ASSERT(x)
#include "mqtempl.h"

#pragma warning(disable: 4511) // copy constructor could not be generated
#pragma warning(disable: 4512) // assignment operator could not be generated

#include "getmqds.h"

#include "dsstuff.h"

#include "..\base\base.h"

// from ds\h\mqattrib.h
#define MQ_QM_SITES_ATTRIBUTE  L"mSMQSites"

extern LONG GetFalconKeyValue(  
					LPCWSTR  pszValueName,
                    PDWORD   pdwType,
                    PVOID    pData,
                    PDWORD   pdwSize,
                    LPCWSTR  pszDefValue = NULL ) ;
extern LONG SetFalconKeyValue(
    LPCTSTR pszValueName,
    PDWORD  pdwType,
    const VOID * pData,
    PDWORD  pdwSize);

extern bool fFix;
extern WCHAR g_wszUseServer[];               // DS server to use for DS queries

extern BOOL Ping (LPTSTR pszServerName);

ULONG           	cServers    = 0;
AP<MqDsServerInAds> rgServers;
LPWSTR 			wszRecognizedSiteName = NULL;
WCHAR           wszSiteNameFromRegistry[MAX_PATH] = L"";    // site name
WCHAR           wszCurrentMQISServer[MAX_PATH] = L"";       // currently used  DS server
WCHAR           wszLkgMQISServer[MAX_PATH] = L"";			// last known good DS server
WCHAR           wszAllMQISServers[10*MAX_PATH] = L"";		// list of known DS servers in current site
WCHAR           wszDSServerFromServerCache[10*MAX_PATH] = L"";	// DS server for current site noted in ServersCache
WCHAR           wszStaticMQISServer[MAX_PATH] = L"";		// statically preassigned DS server
WCHAR           wszForcedDSServer[MAX_PATH] = L"";			// forecefully used DS server
WCHAR           wszPerThreadDSServer[MAX_PATH] = L"";		// per thread assigned DS server
WCHAR			wszSiteIDfromRegistry[100]=L"";				// site ID as read from registry
GUID            guidSiteIDfromRegistry;

BOOL fNeedToFixRegSiteID        = FALSE;
BOOL fNeedToFixRegSiteName      = FALSE;
BOOL fNeedToFixDsConfigSiteName = FALSE;


void DropDomainQualification(LPWSTR wsz)
{
	// drop domain qualification from the server names
   	WCHAR *p = wcschr(wsz, L'.');
   	if (p)
   	{
   		*p = L'\0';
   	}

	if ((wsz[0] == L'0' || wsz[0]  == L'1')  &&  (wsz[1] == L'0' || wsz[1]  == L'1')) 
	{
		WCHAR wsz1[MAX_PATH];

		wcscpy(wsz1, wsz+2);
		wcscpy(wsz, wsz1);
	}
}

BOOL IsDsServer()
{
	DWORD dw;
	DWORD dwSize = sizeof(dw), dwType = REG_DWORD;
	LONG  rc;
	
    rc = GetFalconKeyValue(MSMQ_MQS_DSSERVER_REGNAME, &dwType, &dw, &dwSize);
    if(rc != ERROR_SUCCESS)
	{
		return FALSE;
	}

	return (dw == 1);
}


HRESULT autorec()
{
    Inform(L"\n");
    
    DWORD rc = DsGetSiteName(NULL, &wszRecognizedSiteName);
    if (rc == NO_ERROR)
    {
        Inform(L"Site name (as reported by DS): \t\t%s", wszRecognizedSiteName);
        //NetApiBufferFree(wszRecognizedSiteName);
    }
    else if (rc == ERROR_NO_SITENAME)
    {
        Inform(L"DsGetSiteMame() returned ERROR_NO_SITENAME (%lx). The computer is not in a site.", rc);
    }
    else
    {
        Inform(L"DsGetSiteMame() failed with error code = %lx", rc);
    }

    CGetMqDS cGetMqDS;
    HRESULT hr;

    hr = cGetMqDS.FindMqDsServersInAds(&cServers, &rgServers);
    if (FAILED(hr)) 
    {
      Inform(L"cGetMqDS.FindMqDsServersInAds()=%lx", hr);
      return hr;
    }

	// drop domain qualification from the server names
    for (ULONG ulTmp = 0; ulTmp < cServers; ulTmp++) 
    {
    	DropDomainQualification(rgServers[ulTmp].pwszName);
    }
	

    Inform(L"DS servers (as reported by DS): \t%lu ", cServers);
    for (ulTmp = 0; ulTmp < cServers; ulTmp++) 
    {
		// If user did not specify DC-to-use via -c, we'll take first if reported 
		if (wcslen(g_wszUseServer) == 0)
		{
			wcscpy(g_wszUseServer, rgServers[ulTmp].pwszName);
			Inform(L"\t\t\tChoosing reported DS server %s for DS queries", g_wszUseServer);
		}

		Inform(L"\t%ls %s", rgServers[ulTmp].pwszName, (rgServers[ulTmp].fIsADS ? L"(Win2K)" : L"(NT4)"));
    }

    return NOERROR;
}

BOOL DoTheJob()
{
  	HRESULT hr;
    LONG rc;
  	BOOL fSuccess = TRUE, b;
   	DWORD dwType, dwSize;
   	BOOL  fDSServer = FALSE;

	//
	//  get site and server names from DS
	// 	

  	hr = autorec();
  	if (hr == NOERROR)
  	{
  		Succeeded(L"find site from DS");
  	}
  	else
  	{
  		Failed(L"find site from DS: autorec returned 0x%x", hr);
  		fSuccess = FALSE;
  	}

  	//
  	// found out whether this computer is DC
  	//
	if (IsDsServer())
	{
		// It is DS server 
		fDSServer = TRUE;
		Inform(L"This machine is DS server");
		if (ToolVerbose())
			Inform(L"\t\t\t\t\t\t(from registry %s", MSMQ_MQS_DSSERVER_REGNAME);
	}
	else
	{
		// It is not DS server
		//
   		fDSServer = FALSE;
		Inform(L"This machine is not DS server");
		if (ToolVerbose())
			Inform(L"\t\t\t\t\t\t(from registry %s", MSMQ_MQS_DSSERVER_REGNAME);
    }

	Inform(L"");
	
	//
	// get site name, ID and server name from registry
	//
   	dwType = REG_SZ;
   	dwSize = sizeof(wszSiteNameFromRegistry);
    
	rc = GetFalconKeyValue(
			MSMQ_SITENAME_REGNAME,
       	    &dwType,
           	 wszSiteNameFromRegistry,
            &dwSize);     

   	if(rc != ERROR_SUCCESS)
	{
		if (!fDSServer)
		{
			Failed(L"Find site name %s in registry: 0x%x", MSMQ_SITENAME_REGNAME, rc);
			fSuccess = FALSE;
		}
	}
	else
	{
        Inform(L"Site name (as reported by registry) is %s", wszSiteNameFromRegistry);
		if (ToolVerbose())
			Inform(L"\t\t\t\t\t\t(from registry %s", MSMQ_SITENAME_REGNAME);
	}
	 
   	BOOL fGotSiteIdFromMachineCache = FALSE;

   	dwType = REG_BINARY;
   	dwSize = sizeof(GUID);
    
	rc = GetFalconKeyValue(
			MSMQ_SITEID_REGNAME,
       	    &dwType,
           	&guidSiteIDfromRegistry,
            &dwSize);     

   	if(rc != ERROR_SUCCESS)
	{
		Failed(L"Find %s in registry: 0x%x", MSMQ_SITEID_REGNAME, rc);
	}
	else
	{
		GUID2reportString(wszSiteIDfromRegistry, &guidSiteIDfromRegistry);

		fGotSiteIdFromMachineCache = TRUE;
		
        Inform(L"Site ID (as reported by registry) is \"%s\"", wszSiteIDfromRegistry);
		if (ToolVerbose())
			Inform(L"\t\t\t\t\t\t(from registry %s", MSMQ_SITEID_REGNAME);
	}

	// 
	// Compare site and server from DS and registry
	//
	if (wcslen(wszSiteNameFromRegistry)>0 && 
    	wszRecognizedSiteName!=NULL && wcslen(wszRecognizedSiteName)>0)
	{
		b = (_wcsicmp(wszSiteNameFromRegistry, wszRecognizedSiteName)==0);

		if (b)
		{
			Inform(L"Successfully verified the site"); 
			if (ToolVerbose())
				Inform(L"\t\tRegistry (%s) points to the correct site: %s\n\n", 
			         MSMQ_SITENAME_REGNAME, wszSiteNameFromRegistry);
		}
		else
		{
			Failed(L"verify site name - registry (%s) site %s conflicts with actual site", 
			       MSMQ_SITENAME_REGNAME, wszSiteNameFromRegistry);
			fSuccess = FALSE;
			fNeedToFixRegSiteName = TRUE;
		}
	}

	Inform(L"\n"); 

	// 
	// get CurrentMQISServer from registry - the currently used one
	//
   	dwType = REG_SZ;
   	dwSize = sizeof(wszCurrentMQISServer);
   
	rc = GetFalconKeyValue(
			MSMQ_DS_CURRENT_SERVER_REGNAME,
       	    &dwType,
           	 wszCurrentMQISServer,
            &dwSize);     

   	if(rc != ERROR_SUCCESS)
	{
		Failed(L"find %s in registry: 0x%x", 
		       MSMQ_DS_CURRENT_SERVER_REGNAME, rc);
	}
	else
	{
		DropDomainQualification(wszCurrentMQISServer);

		Inform(L"Currently selected Ds Server: \t\t%s", wszCurrentMQISServer);
		if (ToolVerbose())
			Inform(L"\t\t\t\t\t\t(from registry %s)", MSMQ_DS_CURRENT_SERVER_REGNAME);
			
	   	DropDomainQualification(wszCurrentMQISServer);

		// If user did not specify DC-to-use via -c, and DS did no report it, we'll take current 
		if (wcslen(g_wszUseServer) == 0)
		{
			wcscpy(g_wszUseServer, wszCurrentMQISServer);
			Inform(L"Choosing current DS server %s for DS queries", g_wszUseServer);
		}

	}

	if (ToolVerbose())
	{
		// 
		// get list of all known DS servers in the current site from registry		
		//
   		dwType = REG_SZ;
   		dwSize = sizeof(wszAllMQISServers);
   
		rc = GetFalconKeyValue(
				MSMQ_DS_SERVER_REGNAME,
       		    &dwType,
           		 wszAllMQISServers,
            	&dwSize);     

    	if(rc == ERROR_SUCCESS)
		{
			Inform(L"Known DS Servers in the current site:\t%s", wszAllMQISServers);
			Inform(L"\t\t\t\t\t\t(from registry %s)", MSMQ_DS_SERVER_REGNAME);
		}
	}

	//
	// Compare DS-reported servers to the currently used one
	//
	BOOL fFound = FALSE;
	if (wcslen(wszCurrentMQISServer) > 0)
	{
	    for (ULONG ulTmp = 0; ulTmp < cServers; ulTmp++) 
	    {
	    	if (rgServers[ulTmp].pwszName && 
	    	    _wcsicmp(wszCurrentMQISServer, rgServers[ulTmp].pwszName) == 0)
	    	fFound = TRUE;    
	    }
	}

	if (!fFound)
	{
		Failed(L"find currently used DS server in the GetMsDS-reported list of site servers");
		fSuccess = FALSE;
	}

	//
	// Search for strange settings
	//
	
	// 
	// get StaticMQISServer from registry - the preassigned one
	//
   	dwType = REG_SZ;
   	dwSize = sizeof(wszStaticMQISServer);
    
	rc = GetFalconKeyValue(
			MSMQ_STATIC_DS_SERVER_REGNAME,
       	    &dwType,
           	 wszStaticMQISServer,
            &dwSize);     

   	if(rc == ERROR_SUCCESS)
	{
		Warning(L"Statically preassigned DS server: \t\t%s ", wszStaticMQISServer);
		Warning(L"\t\t\t\t\t\t(from registry %s)", MSMQ_STATIC_DS_SERVER_REGNAME);
	}

	// 
	// get ForcedDSServer from registry - forcefully used DS server
	//
   	dwType = REG_SZ;
   	dwSize = sizeof(wszForcedDSServer);
    
	rc = GetFalconKeyValue(
			MSMQ_FORCED_DS_SERVER_REGNAME,
       	    &dwType,
           	 wszForcedDSServer,
            &dwSize);     

   	if(rc == ERROR_SUCCESS)
	{
		Warning(L"Forcefully used DS server: \t\t%s ", wszForcedDSServer);
		Warning(L"\t\t\t\t\t\t(from registry %s)", MSMQ_FORCED_DS_SERVER_REGNAME);
	}

	// 
	// get PerThreadDSServer from registry - per thread assigned DS server
	//
   	dwType = REG_SZ;
   	dwSize = sizeof(wszPerThreadDSServer);
    
	rc = GetFalconKeyValue(
			MSMQ_THREAD_DS_SERVER_REGNAME,
       	    &dwType,
           	 wszPerThreadDSServer,
            &dwSize);     

   	if(rc == ERROR_SUCCESS)
	{
		Warning(L"Per thread assigned DS server: \t\t%s ", wszPerThreadDSServer);
		Warning(L"\t\t\t\t\t\t(from registry %s)", MSMQ_THREAD_DS_SERVER_REGNAME);
	}

	//
	// Get the known site DS server from registry ServerCache for the current site
	//
	if (wszRecognizedSiteName)
	{
	   	dwType = REG_SZ;
   		dwSize = sizeof(wszDSServerFromServerCache);
		WCHAR wszMachCacheSiteListName[MAX_PATH];
		wcscpy(wszMachCacheSiteListName, TEXT("ServersCache\\"));
		wcscat(wszMachCacheSiteListName, wszRecognizedSiteName);
		    
		rc = GetFalconKeyValue(
				wszMachCacheSiteListName,
       		    &dwType,
           		 wszDSServerFromServerCache,
	            &dwSize);     

	   	if(rc == ERROR_SUCCESS)
		{
			Inform(L"Known DS Servers in the site %s: \t%s", wszRecognizedSiteName, wszDSServerFromServerCache);
			if (ToolVerbose())
				Inform(L"\t\t\t\t\t\t(from registry %s)", wszMachCacheSiteListName);
		}
	}
	
	//
	// try to ping DS server
	//
	if (wcslen(wszCurrentMQISServer) > 0)
	{
		Inform(L"\n");
		b = Ping(wszCurrentMQISServer);
		if (b)
		{
			Inform(L"Successfully pinged current DS server %s", wszCurrentMQISServer);
		}
		else
		{
			Failed(L"ping current DS server %s", wszCurrentMQISServer);
			b = FALSE;
		}
	}

	Inform(L"\n\n");

	//
	// Verify site placement of this computer.
	//   1. Ask DS what is SiteID of the site recognized by AutoRec.
	//   2. Ask DS what SiteID is written in MSMQ computer configuration object
	//   3. Look what SiteID is written in registry under MachineCache
	//
	//  Do 1 and 2 with each of known DCs
	//
	//  All SiteIDs should be equal!   
	//

	WCHAR wszRecognizedSiteID[100] = L"";
	WCHAR wszFirstSiteID[100]      = L"";
	BOOL  fFirstSiteID     = FALSE;
	BOOL  fGotSiteIDFromDS = FALSE;

	//
	// Go to DS and ask for ObjectGUID for the AutoRecognized site
	//
	if (wszRecognizedSiteName)
	{
	    b = GetSiteProperty(wszRecognizedSiteID, 
	    					sizeof(wszRecognizedSiteID), 
							wszRecognizedSiteName,
	    	                L"objectGUID", 
	    	                g_wszUseServer);
	    if (!b)
    	{
			Failed(L" get objectGUID for site %s from %s", 
				   wszRecognizedSiteName, 
				   g_wszUseServer);
	    }
		else
		{
    		Inform(L"Site %s has objectGUID=\"%s\"", 
    			   wszRecognizedSiteName, 
    			   wszRecognizedSiteID);
			if (ToolVerbose())
			{
				Inform(L"\t\t\t\t\t\t(learned from server %s", g_wszUseServer);
				Inform(L"\t\t\t\t\t\t  <Domain>\\Configuration\\Sites\\<site>", g_wszUseServer);
			}

			fGotSiteIDFromDS = TRUE;

			// reconcile recognized site ID
			if (fFirstSiteID)
			{
				if (_wcsicmp(wszRecognizedSiteID, wszFirstSiteID) != 0)
				{
					Failed(L" reconcile site: AutoRecognition - site mismatch: \n%s\n%s",
						   wszRecognizedSiteID, wszFirstSiteID);
				  	fSuccess = FALSE;
				}
			}
			else
			{
				wcscpy(wszFirstSiteID, wszRecognizedSiteID);
				fFirstSiteID = TRUE;
			}
    	}
	}
	

	//
	// Go to DS and ask for the mSMQSites property for the MSMQ configuration object under computer 
	//
	WCHAR wszSiteID[100];
		      
	b = GetMyMsmqConfigProperty(wszSiteID, sizeof(wszSiteID), MQ_QM_SITES_ATTRIBUTE, g_wszUseServer);
    if (!b)
    {
		Failed(L" get %s from MSMQ configuration object in DS (server %s)", 
			      MQ_QM_SITES_ATTRIBUTE, g_wszUseServer);

		if (_wcsicmp(wszCurrentMQISServer, g_wszUseServer) == 0)
		{
			Inform(L"Currently used DS server has no mSMQSites in computer's msmq config object");
			// we need a fix in this case
			fNeedToFixDsConfigSiteName = TRUE;
	  	}
	  	else
	  	{
			Inform(L"Additional (not used currently by MSMQ) server does not know about");
			Inform(L"            this computer's msmq configuration  object");
			Warning(L"Probably replication problem - please follow up");				
	  	}
		fSuccess = FALSE;
    }
	else
	{
    	Inform(L"MSMQ Configuration object contains Site ID \"%s\"", wszSiteID);
		if (ToolVerbose())
		{
			Inform(L"\t\t\t\t\t\t(learned from server %s", g_wszUseServer);
			Inform(L"\t\t\t\t\t\t  <Domain>\\Computers\\<computer>\\msmq)");
		}
		if (fFirstSiteID)
		{
			// reconcile MSMQ Configuration Object - originated SiteID 
			if (_wcsicmp(wszSiteID, wszFirstSiteID) != 0)
			{
				Failed(L" reconcile site: MSMQ Configuration - site mismatch: \n%s\n%s",
					   wszSiteID, wszFirstSiteID);
			  	fSuccess = FALSE;

				Inform(L"Currently used DS server points to wrong site in computer's msmq config object");

				fNeedToFixDsConfigSiteName = TRUE;

			}
		}
		else
		{
			wcscpy(wszFirstSiteID, wszRecognizedSiteID);
			fFirstSiteID = TRUE;
		}
    }

	//
	// reconcile registry-originating MachineCache\site ID
	//

	if (_wcsicmp(wszFirstSiteID, wszSiteIDfromRegistry) != 0)
	{
		Failed(L" reconcile SiteID from registry  - site mismatch:  \n%s\n%s",
					       wszSiteIDfromRegistry, wszFirstSiteID);
  		fSuccess = FALSE;
	}


	//
	// Specificly compare SiteID from MachineCache against what DS keeps for the recognized site
	//

	if (fGotSiteIdFromMachineCache && fGotSiteIDFromDS)
	{
		if (_wcsicmp(wszRecognizedSiteID, wszSiteIDfromRegistry) != 0)
		{
			Failed(L" reconcile SiteID from registry Machine Cache and from DS for recognized site\n%s\n%s",
						       wszSiteIDfromRegistry, wszRecognizedSiteID);
	  		fSuccess = FALSE;
	  		fNeedToFixRegSiteID = TRUE;
		}
		else
		{
			Succeeded(L"reconcile SiteID from registry Machine Cache and from DS for recognized site");
		}

	}
	else
	{
		if (!fGotSiteIdFromMachineCache)
			Failed(L" get  SiteId From the local registry Machine Cache");
		if (!fGotSiteIDFromDS)
			Failed(L" get  SiteId From the the DS for the recognized site");
			
		fSuccess = FALSE;
	}

	if (fNeedToFixRegSiteID || fNeedToFixRegSiteName || fNeedToFixDsConfigSiteName)
	{
		Warning(L"");
		Warning(L"MSMQ thinks it is in wrong site. It may cause problems for MSMQ.");
		if (!fFix)
	  	{
		  	Inform(L"\nYou can use the same tool with -f key to fix the registry\n");
		}
		else
		{
			Warning(L"Do you want to fix it?");
			Warning(L"If you agree, the tool will WRITE to registry and/or to DS \n");

			int c = ' ';
			while (c!='Y' && c!='N')
			{
				printf("Do you want that the Site tool will propagate recognized site into registry and DS?\n");
				printf("Specifically, it will fix:\n");
				if (fNeedToFixRegSiteID)
					printf("\t%S in local registry\n", MSMQ_SITEID_REGNAME);
				if (fNeedToFixRegSiteName)
					printf("\t%S in local registry\n", MSMQ_SITENAME_REGNAME);
				if (fNeedToFixDsConfigSiteName)
					printf("\t%S in the MsmqConfig object under the computer in DS\n", MQ_QM_SITES_ATTRIBUTE);
				
				printf("Do you want that the Site tool will propagate recognized site into registry and DS?\n");
				printf("Answer Y or N  : ");

				c = toupper(getchar());
			}

			if (c == 'Y')
			{
				if (fNeedToFixRegSiteID)
				{
					// writing site GUID to registry
					GUID guid;
					ReportString2GUID(&guid, wszRecognizedSiteID);
	
		 	   		dwType = REG_BINARY;
   					dwSize = sizeof(GUID);
    
					rc = SetFalconKeyValue(
					    MSMQ_SITEID_REGNAME,
   	    				&dwType,
					    &guid,
				    	&dwSize);

				   	if(rc != ERROR_SUCCESS)
					{
						Failed(L"write %s to the registry: 0x%x", MSMQ_SITEID_REGNAME, rc);
						Inform(L"Please stop msmq service and try once more");
						fSuccess = FALSE;
					}
					else
					{
						Warning(L"Successfully fixed wrong SiteID in registry!");
						Warning(L"You must restart msmq now\n");
					}
				}

				if (fNeedToFixRegSiteName)
				{
					// writing site name to registry
	 	   			dwType = REG_SZ;
   					dwSize = (wcslen(wszRecognizedSiteName)+1) * sizeof(WCHAR);
    
					rc = SetFalconKeyValue(
					    MSMQ_SITENAME_REGNAME,
   	    				&dwType,
					    wszRecognizedSiteName,
			    		&dwSize);

				   	if(rc != ERROR_SUCCESS)
					{
						Failed(L"write %s to the registry: 0x%x", MSMQ_SITENAME_REGNAME, rc);
						Inform(L"Please stop msmq service and try once more");
						fSuccess = FALSE;
					}
					else
					{
						Warning(L"Successfully fixed wrong SiteName in registry - now it is %s", wszRecognizedSiteName);
						Warning(L"You must restart msmq now\n");
					}
				}

				if (fNeedToFixDsConfigSiteName)
				{
					VARIANT v;
					b = PrepareGuidAsVariantArray(wszRecognizedSiteID, &v);
					if (b)
					{
						b = SetMyMsmqConfigProperty(v, MQ_QM_SITES_ATTRIBUTE, rgServers[0].pwszName);
					}

				   	if(!b)
					{
						Failed(L"write %s to the MSMQ configuration object in DS", MQ_QM_SITES_ATTRIBUTE);
						fSuccess = FALSE;
					}
					else
					{
						Warning(L"Successfully fixed wrong %s in DS - now it is %s", MQ_QM_SITES_ATTRIBUTE, wszRecognizedSiteID);
						Warning(L"You must restart msmq now\n");
					}
				}
			}
			else
			{
				Warning(L"You have refused to let the tool to fix the registry and/or DS");
			}
		}
	}
	
  	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqrpcs\mqrpcs.cpp ===
// This tool helps to diagnose problems with MSMQ storage
//
// AlexDad, February 2000
// 

#include "stdafx.h"
#include "_mqini.h"
#include <winsvc.h>

#include "..\hauthen.h"
#include "..\hauthen1.h"
#include "authni.h"

extern RPC_STATUS TryRemoteCall(
			LPUSTR pszProtocol, 
			LPUSTR pszEndpoint, 
			BOOL   fRegister, 
			ULONG  ulAuthnService);

const char  x_szAuthnConstants[] = { "\n\n"
                      "\t#define RPC_C_AUTHN_NONE          0\n"
                      "\t#define RPC_C_AUTHN_DCE_PRIVATE   1\n"
                      "\t#define RPC_C_AUTHN_DCE_PUBLIC    2\n"
                      "\t#define RPC_C_AUTHN_DEC_PUBLIC    4\n"
                      "\t#define RPC_C_AUTHN_GSS_NEGOTIATE 9\n"
                      "\t#define RPC_C_AUTHN_WINNT        10\n"
                      "\t#define RPC_C_AUTHN_GSS_SCHANNEL 14\n"
                      "\t#define RPC_C_AUTHN_GSS_KERBEROS 16\n"
                      "\t#define RPC_C_AUTHN_MSN          17\n"
                      "\t#define RPC_C_AUTHN_DPA          18\n"
                      "\t#define RPC_C_AUTHN_MQ          100\n"
                      "\t#define RPC_C_AUTHN_DEFAULT     0xFFFFFFFFL\n" } ;

//
// Log control. The get functions below are called from tmqbase.lib
//
bool fVerbose = false;
bool fDebug   = false;
FILE *g_fileLog = NULL;
TCHAR g_tszService[100] = L"MSMQ";

FILE *ToolLog()			{	return g_fileLog;	}
BOOL ToolVerbose()		{ 	return fVerbose;	}
BOOL ToolVerboseDebug() { 	return fDebug;		}
BOOL ToolThreadReport() { 	return FALSE;		} 

void OpenLogFile()
{
    g_fileLog = fopen( "tmqrpcs.log", "w" );

    if (g_fileLog)
    {
        time_t  lTime ;
        time( &lTime ) ;
        fprintf(g_fileLog, "tmqrpcs run at: %ws", _wctime( &lTime ) );
    }
}

void CloseLogFile()
{
    fflush(g_fileLog);
    fclose(g_fileLog);
}

// 
// Main logic of the tool
//
BOOL DoTheJob(LPUSTR pszProtocol, 
			  LPUSTR pszEndpoint, 
			  BOOL   fRegister, 
			  ULONG  ulAuthnService)
{
	BOOL fSuccess = TRUE, b;

	//--------------------------------------------------------------------------------
	GoingTo(L"server remote call "); 
	//--------------------------------------------------------------------------------

	b = TRUE;

	RPC_STATUS status = TryRemoteCall(
			pszProtocol, 
			pszEndpoint, 
			fRegister, 
			ulAuthnService);
			
	b = (status == 0);
	
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L"serve remote call");
	}
	else
	{
		Succeeded(L"serve remote call");
	}



	return fSuccess;
}

//
//  help
//
void Usage()
{
	printf("usage: rpcs [-v] [-d] [-a ii] [-l] [-n] [-s] \n");

    printf("\t  -a <authentication service, decimal number>\n") ;
    printf("\t  -l (use local rpc, tcpip being the default)\n") ;
    printf("\t  -n do NOT register authentication service\n\n") ;
    printf("\t  -s show numbers of authentication services\n") ;
    printf("\t  -v verbose\n");
    printf("\t  -d most verbose\n");

    printf(x_szUsage);
}

//
//  Main entry point - called from the tmq.exe 
//
int _stdcall run( int argc, char *argv[ ])
{
    //
    // Parse parameters
    //
    BOOL   fRegister = TRUE ;
    ULONG  ulAuthnService = RPC_C_AUTHN_WINNT;  //RPC_C_AUTHN_NONE ;
    LPUSTR pszProtocol = NULL ;
    LPUSTR pszProtocolTcp =  PROTOSEQ_TCP ;
    LPUSTR pszEndpoint = NULL ;
    LPUSTR pszEndpointTcp =  ENDPOINT_TCP ;

    pszProtocol
= pszProtocolTcp ;
    pszEndpoint = pszEndpointTcp ;

	for (int i=2; i<argc; i++)
	{
		if (*argv[i] != '-' && *argv[i] != '/')
		{
			printf("Invalid parameter '%S'.\n\n", argv[i]);
            Usage();
		}

		switch (tolower(*(++argv[i])))
		{
		    case 'v':
			    fVerbose = true;
			    break;

		    case 'd':
			    fDebug = true;
			    fVerbose = true;
			    break;

            case 'a':
                sscanf(argv[++i], "%lu", &ulAuthnService) ;
                break ;

            case 'l':
                pszProtocol = PROTOSEQ_LOCAL ;
                pszEndpoint = ENDPOINT_LOCAL ;
                break ;

            case 'n':
                fRegister = FALSE ;
                break ;

            case 's':
			    printf(x_szAuthnConstants) ;
  			    exit(0);
  			    
            case 'h':
            case '?':
                Usage();
			    exit(0);
			    
		    default:
			    printf("Unknown switch '%s'.\n\n", argv[i]);
                Usage();
			    exit(0);
		}
	}


    //
    // Create mqstore.log - log file in current directory
    //
    OpenLogFile();

    Inform(L"TMQ Rpcs tests RPC (server side)");

	// Log down time , date, machine, OS
	LogRunCase();

	
	// actual work
	BOOL b = DoTheJob(
			   		 pszProtocol, 
			  		 pszEndpoint, 
			  		 fRegister, 
 			                 ulAuthnService);

	if (b)
	{
		Inform(L"\n\n+++++++ Rpcs seems healthy ++++++++\n");
	}
	else
	{
		Inform(L"\n\n-------- TMQ Rpcs has found problems with the RPC ---------\n");
	}

	CloseLogFile();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsite\ping.cpp ===
#include "..\ping.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\main.h ===
extern HANDLE  g_evActive, g_evPassive;
extern UINT  g_dwIPPort ;

extern LPTSTR  g_szMachineName;
extern DWORD   g_dwOperatingSystem;       

extern SOCKET g_sockListen;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\main.cpp ===
//
// Top-level caller (provides exe linkage) 
//

#include "stdafx.h"

int _cdecl main( int argc, char *argv[ ])
{
    return run( argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\mqreport.h ===
#ifndef _REPORT_H_
#define _REPORT_H_

#include <fstream.h>
void DebugMsg(DWORD dwMdl, DBGLVL uiLvl, WCHAR * Format, ...);

#endif  // of _REPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsite\registry.cpp ===
//
// AlexDad, March 2000
// 

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>
#include "_mqini.h"

#include <winreg.h>
#include <uniansi.h>

#include "_mqreg.h"

TCHAR  g_tRegKeyName[ 256 ] = {0} ;
HKEY   g_hKeyFalcon = NULL ;
extern WCHAR  g_tszService[];

#include "..\registry.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\myreg.h ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:

    _registr.h

Abstract:


--*/

#ifndef __REGISTER_H__
#define __REGISTER_H__

#include "_mqini.h"


DWORD
GetFalconServiceName(
    LPWSTR pwzServiceNameBuff,
    DWORD dwServiceNameBuffLen
    );

LONG
GetFalconKey(LPCWSTR  pszKeyName,
             HKEY *phKey);


LONG
GetFalconKeyValue(  LPCWSTR  pszValueName,
                    PDWORD   pdwType,
                    PVOID    pData,
                    PDWORD   pdwSize,
                    LPCWSTR  pszDefValue = NULL ) ;



//
//  Macros for reading registry/ini file
//
#define MAX_REG_DEFAULT_LEN  30

#define READ_REG_STRING(string, ValueName, default)            \
   WCHAR  string[ MAX_REG_DEFAULT_LEN ] = default;             \
   {                                                           \
     DWORD  dwSize = MAX_REG_DEFAULT_LEN * sizeof(WCHAR)  ;    \
     DWORD  dwType = REG_SZ ;                                  \
                                                               \
     ASSERT(wcslen(default) < MAX_REG_DEFAULT_LEN) ;           \
                                                               \
     LONG res = GetFalconKeyValue( ValueName,                  \
                                   &dwType,                    \
                                   string,                     \
                                   &dwSize,                    \
                                   default ) ;                 \
	 if(res == ERROR_MORE_DATA)									\
	{															\
		wcscpy(string, default);								\
	}															\
     ASSERT(res == ERROR_SUCCESS || res == ERROR_MORE_DATA) ;   \
     ASSERT(dwType == REG_SZ) ;                                \
   }

#define READ_REG_DWORD(outvalue, ValueName, default)           \
   {                                                           \
     DWORD  dwSize = sizeof(DWORD) ;                           \
     DWORD  dwType = REG_DWORD ;                               \
                                                               \
     LONG res = GetFalconKeyValue( ValueName,                  \
                                   &dwType,                    \
                                   &outvalue,                  \
                                   &dwSize,                    \
                                   (LPCTSTR) default ) ;       \
     DBG_USED(res);                                            \
     ASSERT(res == ERROR_SUCCESS) ;                            \
     ASSERT(dwType == REG_DWORD) ;                             \
   }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsite\mqsite.cpp ===
// This tool helps to diagnose problems with MSMQ storage
// Automatically recognizes the site and domain controller
//
// AlexDad, February 2000
// 
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <tchar.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>
#include "..\\base\\base.h" 
#include "_mqini.h"
#include <winsvc.h>

extern BOOL DoTheJob();

//
// Log control. The get functions below are called from tmqbase.lib
//
bool fVerbose = false;
bool fDebug   = false;
bool fFix     = false;
FILE *g_fileLog = NULL;
TCHAR g_tszService[100] = L"MSMQ";
WCHAR g_wszUseServer[MAX_PATH] = L"";               // DS server to use for DS queries

FILE *ToolLog()			{	return g_fileLog;	}
BOOL ToolVerbose()		{ 	return fVerbose;	}
BOOL ToolVerboseDebug() { 	return fDebug;		}
BOOL ToolThreadReport() { 	return FALSE;		} 

void OpenLogFile()
{
    g_fileLog = fopen( "tmqsite.log", "w" );

    if (g_fileLog)
    {
        time_t  lTime ;
        time( &lTime ) ;
        fprintf(g_fileLog, "tmqsite run at: %ws", _wctime( &lTime ) );
    }
}

void CloseLogFile()
{
    fflush(g_fileLog);
    fclose(g_fileLog);
}

//
//  help
//
void Usage()
{
	printf("usage: site [-v] [-d] [-f] [-s <service name>] [-c <DC-to-use>]\n");
	printf("The tool gathers data about the current site and DS servers from registry and DS,  \n");
	printf("    then compares them and warns about any wrong or suspicuos values\n");
	printf("It also pings the currently selected DS server \n\n");
	printf("-f key allows the tool to fix SiteId in registry if it is wrong \n");
	printf("Without -f, the tool never writes or changes anything \n");
}

//
//  Main entry point - called from the tmq.exe 
//
int _stdcall run( int argc, char *argv[ ])
{
    //
    // Parse parameters
    //

	for (int i=2; i<argc; i++)
	{
		if (*argv[i] != '-' && *argv[i] != '/')
		{
			printf("Invalid parameter '%S'.\n\n", argv[i]);
            Usage();
		}

		switch (tolower(*(++argv[i])))
		{
		    case 'v':
			    fVerbose = true;
			    break;

		    case 'd':
			    fDebug = true;
			    fVerbose = true;
			    break;

		    case 'f':
			    fFix = true;
			    break;
			    
            case 's':
				if (strlen(argv[i]) > 3)
				{
					mbstowcs(g_tszService, argv[i] + 2, sizeof(g_tszService));
				}
				else if (i+1 < argc)
				{
					mbstowcs(g_tszService, argv[++i], sizeof(g_tszService));
				}
				else
				{
					Usage();
					exit(0);
				}
			    break;
			    
            case 'c':
				if (strlen(argv[i]) > 3)
				{
					mbstowcs(g_wszUseServer, argv[i] + 2, sizeof(g_wszUseServer));
				}
				else if (i+1 < argc)
				{
					mbstowcs(g_wszUseServer, argv[++i], sizeof(g_wszUseServer));
				}
				else
				{
					Usage();
					exit(0);
				}
			    break;
			    
		    default:
			    printf("Unknown switch '%s'.\n\n", argv[i]);
                Usage();
			    exit(0);
		}
	}

    //
    // Create tmqsite.log - log file in current directory
    //
    OpenLogFile();

    Inform(L"TMQ Site looks for the current site and domain controller");

	// Log down time , date, machine, OS
	LogRunCase();

	
	// actual work
    BOOL b = DoTheJob();

	if (b)
	{
		Inform(L"\n\n+++++++ MSMQ site information seems healthy ++++++++\n");
	}
	else
	{
		Inform(L"\n\n-------- TMQ Site has found problems with site data ---------\n");
	}

	CloseLogFile();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\mqsock.cpp ===
// This tool helps to diagnose socket connection problems
// It closely mimics MSMQ2 
// Most of the code is copy/paste from MSMQ2 RTM
//
// Alexander Dadiomov, February 2000
// 
// The same test program should be run on 2 machines, pointing ("r:machine" )to each other
// Each machine connects to other, sends request and receives back reply 
// After sending & getting reply AND getting request & replying back , test finishes
//

#include "stdafx.h"
#include "session.h"
#include "sessmgr.h"
#include "qmthrd.h"
#include "mqprops.h"

//
// Log control. The get functions below are called from tmqbase.lib
//
bool fVerbose = false;
bool fDebug   = false;
FILE *g_fileLog = NULL;
LPTSTR  g_tszMachineName = NULL;
TCHAR g_tszService[256] = L"MSMQ";

FILE *ToolLog()			{	return g_fileLog;	}
BOOL ToolVerbose()		{ 	return fVerbose;	}
BOOL ToolVerboseDebug() { 	return fDebug;		}
BOOL ToolThreadReport() { 	return TRUE;		}

void OpenLogFile()
{
    g_fileLog = fopen( "tmqsock.log", "w" );

    if (g_fileLog)
    {
        time_t  lTime ;
        time( &lTime ) ;
        fprintf(g_fileLog, "tmqsock run at: %ws", _wctime( &lTime ) );
    }
}

void CloseLogFile()
{
    fflush(g_fileLog);
    fclose(g_fileLog);
}


//
// Events showing finished tests (go out when both are ready)
//
HANDLE  g_evActive,      // Active: send request - get reply
        g_evPassive;     // PAssive: get request - send back reply

//
// QM's globals
//
LPTSTR  g_szMachineName = NULL;
AP<WCHAR> g_szComputerDnsName;

UINT  g_dwIPPort = 0 ;
SOCKET g_sockListen;

DWORD   g_dwOperatingSystem;        // Holds the OS we are running on

CSessionMgr     SessionMgr;

//
// Mimics MSMQ startup - whatever is important for the socket issue
//
HRESULT WinSockPrepare(WCHAR * /* pwcsOtherComputerName */)
{
    HRESULT hr ;

    //
    // Recognize OS
    //
    GoingTo(L"Recognize OS");
    
    g_dwOperatingSystem = MSMQGetOperatingSystem();
    if (g_dwOperatingSystem == MSMQ_OS_NONE)
    {
        Failed(L"recognise OS: 0x%x", g_dwOperatingSystem);
    }
    Inform(L"OS code: 0x%x", g_dwOperatingSystem); 


    //
    // Retrieve name of the machine (Always UNICODE)
    //
    GoingTo(L"Retrieve machine name");
    
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    g_szMachineName = new WCHAR[dwSize];

    hr = GetComputerNameInternal(g_szMachineName, &dwSize);
    if(FAILED(hr))
    {
        Failed(L"GetComputerNameInternal, hr=%x", hr);
    }
    Inform(L"Machine name: %s", g_szMachineName);


    //
    // Retrieve the DNS name of this computer ( in unicode).
    // Clustered QM does not have DNS name.
    //
    GoingTo(L"Retrieve DNS name");

	//
	// Get ComputerDns Size, ignore the returned error
	// 
	dwSize = 0;
	GetComputerDnsNameInternal(NULL, &dwSize);

    g_szComputerDnsName = new WCHAR[dwSize];

    hr = GetComputerDnsNameInternal(g_szComputerDnsName, &dwSize);
    if(FAILED(hr))
    {
        Warning(L"Failed GetComputerDnsNameInternal, hr=%x, this computer has no DNS name", hr);
        g_szComputerDnsName.detach();
        //
        //	this can be a valid situation, where a computer doesn't
        //	have DNS name.
        //
    }
    Inform(L"Computer's DNS name: %s", g_szComputerDnsName);

    //
    //Init the winsocket
    //
    GoingTo(L"initiate socket 1.1  - WSAStartup");
    WSADATA WSAData;

    int rc = WSAStartup(MAKEWORD(1,1), &WSAData);
    if(rc != 0)
    {
	   Failed(L"WSAStartup, rc=0x%x", rc);
    }
    Succeeded(L"WSAStartup");

    //
    // Create some actual handle - anything for creating g_hIOPort
    //
    GoingTo(L"Create auxiliary socket");

    SOCKET tempSock = socket( AF_INET, SOCK_STREAM, 0);
    if(tempSock == INVALID_SOCKET)
    {
        DWORD dwErr = WSAGetLastError();
        Failed(L"Create socket: err = %d", dwErr);
    }

    ExAttachHandle((HANDLE)tempSock);  
    
    Succeeded(L"Created socket 0x%x for completion port", (int)tempSock);


    //
    // Initialize SessionMgr
    //
    GoingTo(L"Initialize SessionMgr");

    hr = SessionMgr.Init();
    if (FAILED(hr))
    {
        Failed(L"SessionMgr.Init, hr=%x", hr);
    }
    Succeeded(L" initialized WinSocket and SessionMgr");

    //
    // read IP port from registry.
    //
    DWORD dwDef = FALCON_DEFAULT_IP_PORT ;
    READ_REG_DWORD(g_dwIPPort,
                   FALCON_IP_PORT_REGNAME,
                   &dwDef ) ;
    Inform(L"Falcon IP port: %d", g_dwIPPort);

	return MQ_OK;
}

void Usage()
{
	printf("usage: mqsock [-v]  [-d] [-s:<service_name>] -r:remote_machine_name\n");
	printf("The tool helps troubleshoot network conenction between 2 MsMQ machines. \n");
	printf("It is not intended for troubleshooting RPC ckient/server connection, \n");
	printf("   but rather direct message path between 2 MSMQ machines.\n");
	printf("The tool closely simulates MSMQ networking stuff and stages 2 handshaking scenarios.\n");
	printf("It should be started on 2 machines, pointing one to another. \n");
	printf("The tool will report any problems it meets.\n");
	printf("It cannot run concurrently with MSMQ, though it does not write or change anything.\n");
	printf(" -v gives more information, and the most verbose mode is -d\n");
}

int _stdcall run( int argc, char *argv[ ])
{
    HRESULT hr;
	WCHAR wszOther[MQSOCK_MAX_COMPUTERNAME_LENGTH];
    LPSTR pszOther = NULL;

    //
    // Parse parameters
    //

	for (int i=2; i<argc; i++)
	{
		if (*argv[i] != '-' && *argv[i] != '/')
		{
			printf("Invalid parameter '%S'.\n\n", argv[i]);
            Usage();
		}

		switch (tolower(*(++argv[i])))
		{
		    case 'v':
			    fVerbose = true;
			    break;

		    case 'd':
			    fDebug = true;
			    fVerbose = true;
			    break;

            case 's':
				if (strlen(argv[i]) > 3)
				{
					mbstowcs(g_tszService, argv[i] + 2, sizeof(g_tszService));
				}
				else if (i+1 < argc)
				{
					mbstowcs(g_tszService, argv[++i], sizeof(g_tszService));
				}
				else
				{
					Usage();
					exit(0);
				}
			    break;

            case 'r':
				if (strlen(argv[i]) > 3)
				{
					pszOther = argv[i] + 2;
				}
				else if (i+1 < argc)
				{
					pszOther = argv[++i];
				}
				else
				{
					Usage();
					exit(0);
				}
			    break;

		    default:
			    printf("Unknown switch '%s'.\n\n", argv[i]);
                Usage();
			    exit(0);
		}
	}

    if (pszOther == NULL)
    {
        Usage();
        exit(0);
    }


    //
    //  we don't want to run in parallel with MSMQ service 
    //
    if (IsMsmqRunning(g_tszService))
    {
        Failed(L"run the test - please stop the msmq service and try once more");
    }

	Inform(L"Starting Thread is t%3x", GetCurrentThreadId());

    //
    // Create mqsoc.log - log file in current directory
    //
    OpenLogFile();

    Inform(L"TMQ sock tries socket connection to %S", pszOther);

	// Log down time , date, machine, OS
	LogRunCase();
	
	mbstowcs(wszOther, pszOther, MQSOCK_MAX_COMPUTERNAME_LENGTH);

    //
    // Prepare events for coordinating exit
    //

	g_evActive = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (g_evActive == NULL)
    {
        Failed(L"create event, err=0x%x", GetLastError());
    }

	g_evPassive = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (g_evPassive == NULL)
    {
        Failed(L"create event, err=0x%x", GetLastError());
    }

    //
    //  Do whatever QM does on startup, that  relates to the socket connectivity
    // 
    GoingTo(L"WinSockPrepare");

    hr = WinSockPrepare(wszOther);
    if (FAILED(hr))
    {
        Failed(L"WinSockPrepare, hr=%x", hr);
    }
    Succeeded(L"WinSockPrepare");


    //
    // Create QM working thread - one is enough
    //
    DebugMsg(L"Going to create QmMainThread");
    DWORD dwThreadNo = 1;
    DWORD dwThreadId;

    for (DWORD dwI=0; dwI < dwThreadNo; dwI++)
    {
        HANDLE hThread = CreateThread(NULL,
                               0,
                               QmMainThread,
                               0,
                               0,
                               &dwThreadId);
        if (hThread == NULL) 
        {
            Failed(L"create QmMainThread, err=%x", GetLastError());
        }

		Inform(L"QmMainThread is t%3x", dwThreadId);
    }

    // 
    // BeginAccept - start accepting thread
    //
    GoingTo(L"BeginAccept");

    SessionMgr.BeginAccept();
    Succeeded(L"BeginAccept");

    // 
    // Resolve other machine name
    //
    CAddressList al;


    // 
    // Resolve IP address of the other machine
    //
    GoingTo(L"GetMachineIPAddresses");
    
    hr = GetMachineIPAddresses(pszOther, &al);
    if (FAILED(hr))
    {
        Failed(L"GetMachineIPAddresses, hr=%x", hr);
    }
    Succeeded(L"GetMachineIPAddresses");

    bool fAddr = false;
    Inform(L"Following addresses found:");
    POSITION pos = al.GetHeadPosition();
    while(pos != NULL)
    {
        TA_ADDRESS *pa = al.GetNext(pos);
        TCHAR szAddr[30];
    
        TA2StringAddr(pa, szAddr);
        Inform(L"Found address: %s", szAddr);
        fAddr = true;
    }    

    if (!fAddr)
    {
        Failed(L"connect: IP address wasn't found");
    }

    //
    // Actively connect to other machine (send & receive)
    //
    GoingTo(L"TryConnect");
    hr = SessionMgr.TryConnect(&al);
    if (FAILED(hr))
    {
        Failed(L"TryConnect, hr=%x", hr);
    }
    Succeeded(L"TryConnect");


    //
    // Wait till both active and passive parts are done
    //
	DWORD dw = WaitForSingleObject(g_evActive,   INFINITE);
    Succeeded(L"get Active part of the test done");


	dw = WaitForSingleObject(g_evPassive,   INFINITE);
    Succeeded(L"get Passive part of the test done");

    // Giving more time to settle
	dw = SleepEx(2000, FALSE);

    Inform(L"\n\n+++++++ Socket Connection to %S is healthy ++++++++\n", pszOther);

	CloseLogFile();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\ping.h ===
#ifndef _PING_H_
#define _PING_H_


BOOL ping(const SOCKADDR* pAddr, DWORD dwTimeout);
HRESULT StartPingClient();
HRESULT StartPingServer();

#endif // _PING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\ping.cpp ===
#include "stdafx.h"

#include <winsock.h>
#include <nspapi.h>
#include <wsnwlink.h>
#include "ping.h"
#include "main.h"
//#include "license.h"

#include <mqprops.h>

#define PING_SIGNATURE       'UH'

//---------------------------------------------------------
//
//  class CPingPacket.
//
//---------------------------------------------------------
struct CPingPacket{
public:
    CPingPacket();
    CPingPacket(DWORD, USHORT, USHORT);

    DWORD Cookie() const;
    BOOL IsOtherSideClient() const;
    BOOL IsRefuse() const;
    BOOL IsValidSignature(void) const;

private:
    union {
        USHORT m_wFlags;
        struct {
            USHORT m_bfIC : 1;
            USHORT m_bfRefuse : 1;
        };
    };
    USHORT  m_ulSignature;
    DWORD   m_dwCookie;
};

//
// CPingPacket Implementation
//
inline
CPingPacket::CPingPacket()
{
}

inline
CPingPacket::CPingPacket(DWORD dwCookie, USHORT fIC, USHORT fRefuse):
        m_bfIC(fIC),
        m_bfRefuse(fRefuse),
        m_ulSignature(PING_SIGNATURE),
        m_dwCookie(dwCookie)
{

}

inline DWORD
CPingPacket::Cookie() const
{
    return m_dwCookie;
}

inline BOOL
CPingPacket::IsOtherSideClient() const
{
    return m_bfIC;
}

inline BOOL
CPingPacket::IsValidSignature(void) const
{
    return(m_ulSignature == PING_SIGNATURE);
}


inline BOOL
CPingPacket::IsRefuse(void) const
{
    return m_bfRefuse;
}

//---------------------------------------------------------
//
//  class CPing
//
//---------------------------------------------------------

class CPing
{
    public:
        HRESULT Init(DWORD dwPort, BOOL fIP) ;

        SOCKET Select();
        virtual void Run() = 0;

    public:
        static HRESULT Receive(SOCKET sock,
                               SOCKADDR* pReceivedFrom,
                               CPingPacket* pPkt);
        static HRESULT Send(SOCKET sock,
                            const SOCKADDR* pSendTo,
                            DWORD dwCookie,
                            BOOL  fRefuse);

    private:
        static SOCKET CreateIPPingSocket(UINT dwPortID);

        static DWORD WINAPI WorkingThread(PVOID pThis);

    protected:
        SOCKET m_socket;
};

SOCKET CPing::CreateIPPingSocket(UINT dwPortID)
{
    GoingTo(L"Create IP Ping socket");
    SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);
    if(sock == INVALID_SOCKET)
    {
        Warning(TEXT("failed to create IP ping socket, WSAGetLastError=%d"), WSAGetLastError());
        return INVALID_SOCKET;
    }
    Succeeded(L"Create IP Ping Socket 0x%x", sock);

    int rc;
    BOOL reuse = TRUE;
    GoingTo(L"setsockopt for the IP ping socket");
    rc = setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*)&reuse, sizeof(reuse));
    if(rc != 0)
    {
        Warning(TEXT("failed setsockopt rc = %d for ping IP socket"), WSAGetLastError());
        return INVALID_SOCKET;
    }
    Succeeded(L"setsockopt for the IP ping socket");

    SOCKADDR_IN local_sin;
    local_sin.sin_family = AF_INET;
    local_sin.sin_port = htons((unsigned short) dwPortID);

    if (IsLocalSystemCluster())
    {
        //
        // BUGBUG:
        //
        // On cluster we can not use INADDR_ANY because we will bind to
        // all addresses on the machine, including addresses in cluster
        // groups that are currently hosted on this machine.
        // We need to iterate the IP addresses and explicitly bind to each.
        // This way we are cluster-safe and do not need to know if we're on
        // cluster or not (thus our service would not depend on cluster service).
        // That means listenning on a different socket for each IP address.
        // This is too risky / complex at this point, so on cluster we bind
        // only to one IP address.  (ShaiK, 26-Apr-1999)
        //
        char szBuff[1000];
        DWORD dwSize = sizeof(szBuff);

        size_t res = wcstombs(szBuff, g_szMachineName, dwSize);
        DBG_USED(res);
        ASSERT(res != (size_t)(-1));

        PHOSTENT phe;
        GoingTo(L"gethostbyname by IP ping for %S", szBuff);

        phe = gethostbyname(szBuff);
        ASSERT(("must have an IP address", NULL != phe));
        if (NULL != phe)
        {
            Inform(L"gethostbyname by IP ping for %S: %S",
                        szBuff, inet_ntoa(*(struct in_addr *)phe->h_addr_list[0]));
        }
        else
        {
            Warning(L"gethostbyname by IP ping for %S - no IP addresses found, WSAGetLastError=%d",
                 szBuff, WSAGetLastError());
        }

        memcpy(&local_sin.sin_addr.s_addr, phe->h_addr_list[0], IP_ADDRESS_LEN);
    }
    else
    {
        local_sin.sin_addr.s_addr = INADDR_ANY;
    }

    //
    //  Bind to IP address
    //
    GoingTo(L"Bind IP ping socket");

    rc = bind(sock, (sockaddr*)&local_sin, sizeof(local_sin));
    if (rc != 0)
    {
        Warning(TEXT("failed bind IP ping sicket, rc=0x%x, WSAGetLastError = %d "), rc, WSAGetLastError());
        return INVALID_SOCKET;
    }
    else
    {
        Succeeded(L"Bind IP ping socket");
    }

    return sock;
}


HRESULT CPing::Init(DWORD dwPort, BOOL /* fIP */)
{
    m_socket  = CreateIPPingSocket(dwPort);

    if(m_socket == INVALID_SOCKET)
    {
        DWORD dwerr = WSAGetLastError();
        DebugMsg(L"Failed to create ping socket, WSAGetLastError=%d", dwerr);
        return MQ_ERROR;
    }

    DebugMsg(L"Going to create ping thread");
    DWORD dwThreadID;
    HANDLE hThread = CreateThread(
                        0,
                        0,
                        WorkingThread,
                        this,
                        0,
                        &dwThreadID
                        );
    if(hThread == NULL)
    {
        DWORD dwerr = GetLastError();
        Warning(L"failed to create ping thread, GetLastError=0x%x", dwerr);
        return MQ_ERROR;
    }
    else
    {
		Inform(L"Ping thread is t%3x", dwThreadID);
    }

    CloseHandle(hThread);
    return MQ_OK;
}


SOCKET CPing::Select()
{
    fd_set sockset;
    FD_ZERO(&sockset);
    FD_SET(m_socket, &sockset);

    int rc;
    GoingTo(L"select ping socket 0x%x", m_socket);
    rc = select(0, &sockset, NULL, NULL, NULL);
    if(rc == SOCKET_ERROR)
    {
        ASSERT(m_socket != INVALID_SOCKET) ;
        Warning(TEXT("Ping Server listen: select failed, WSAGetLastError = %d"), WSAGetLastError()) ;
        return INVALID_SOCKET;
    }
    else
    {
        Succeeded(L"select ping socket");
    }

    ASSERT(FD_ISSET(m_socket, &sockset)) ;
    return m_socket;
}


HRESULT CPing::Receive(SOCKET sock,
                       SOCKADDR* pReceivedFrom,
                       CPingPacket* pPkt)
{
    int fromlen = sizeof(SOCKADDR);
    GoingTo(L"recvfrom ping socket 0x%x", sock);

    int len = recvfrom(sock, (char*)pPkt, sizeof(CPingPacket), 0, pReceivedFrom, &fromlen);

    if((len != sizeof(CPingPacket)) || !pPkt->IsValidSignature())
    {
        Warning(TEXT("CPing::Receive failed, rc=%d, len=0x%x"), WSAGetLastError(), len);
        return MQ_ERROR;
    }
    else
    {
        Succeeded(L"recvfrom ping socket");
    }

    return MQ_OK;
}


HRESULT CPing::Send(SOCKET sock,
                    const SOCKADDR* pSendTo,
                    DWORD dwCookie,
                    BOOL  fRefuse)
{
    CPingPacket Pkt( dwCookie,
                     !OS_SERVER(g_dwOperatingSystem),
                     (USHORT) fRefuse ) ;

    GoingTo(L"sendto ping socket 0x%x", sock);

    int len = sendto(sock, (char*)&Pkt, sizeof(Pkt), 0, pSendTo, sizeof(SOCKADDR));
    if(len != sizeof(Pkt))
    {
        Warning(TEXT("CPing::Send failed, WSAGetLastError=%d"), WSAGetLastError());
        return MQ_ERROR;
    }
    else
    {
        Succeeded(L"sendto ping socket");
    }

    return MQ_OK;
}


//
// ISSUE-2000/7/24-erezh bad compiler pragma
// This is a bug in the compiler, waiting for a fix
//
#pragma warning(disable: 4715)

DWORD WINAPI CPing::WorkingThread(PVOID pThis)
{
    for(;;)
    {
        static_cast<CPing*>(pThis)->Run();
    }
    return 0;
}

//
// ISSUE-2000/7/24-erezh bad compiler pragma
// This is a bug in the compiler, waiting for a fix
//
#pragma warning(default: 4715)


//---------------------------------------------------------
//
//  class CPingClient
//
//---------------------------------------------------------

class CPingClient : public CPing
{
    public:
        HRESULT Init(DWORD dwServerPort, BOOL fIP) ;
        BOOL Ping(const SOCKADDR* pAddr, DWORD dwTimeout);

    private:
        virtual void Run();
        void Notify(DWORD dwCookie,
                    BOOL fRefuse,
                    BOOL fOtherSideClient);
        void SetPingAddress(IN const SOCKADDR* pAddr,
                            OUT SOCKADDR * pPingAddr);

    private:
        HANDLE m_hNotification;
        BOOL m_fPingSucc;
        DWORD m_dwCurrentCookie;
        UINT m_server_port;
};

//
//

//---------------------------------------------------------
//
//  CPingClient IMPLEMENTATION
//
//---------------------------------------------------------
HRESULT CPingClient::Init(DWORD dwServerPort, BOOL fIP)
{
    m_server_port = dwServerPort;
    m_fPingSucc = FALSE;
    m_dwCurrentCookie = 0;
    m_hNotification = ::CreateEvent(0, FALSE, FALSE, 0);
    ASSERT(m_hNotification != 0);
    HRESULT hr = CPing::Init(0, fIP);
    if (FAILED(hr))
    {
        DebugMsg(L"Failed to CPing::Init for CPingClient: hr=0x%x", hr);
    }
    return hr;
}

void CPingClient::SetPingAddress(IN const SOCKADDR* pAddr,
                                 OUT SOCKADDR * pPingAddr)
{
    memcpy(pPingAddr, pAddr, sizeof(SOCKADDR));
    if(pAddr->sa_family == AF_INET)
    {
        ((SOCKADDR_IN*)pPingAddr)->sin_port =
                                   htons((unsigned short) m_server_port);
    }
    else
    {
        ASSERT(0);
    }
}


BOOL CPingClient::Ping(const SOCKADDR* pAddr, DWORD dwTimeout)
{
    {
        m_fPingSucc = FALSE;
        ResetEvent(m_hNotification);
        SOCKADDR ping_addr;
        SetPingAddress(pAddr,&ping_addr);
        m_dwCurrentCookie++;
        Send(m_socket, &ping_addr, m_dwCurrentCookie, FALSE);
    }

    if(WaitForSingleObject(m_hNotification, dwTimeout) != WAIT_OBJECT_0)
    {
        DebugMsg(L"Wait failed for CPingClient::Ping");
        return FALSE;
    }

    Succeeded(L"CPingClient::Ping result: 0x%x", m_fPingSucc);
    return m_fPingSucc;
}


void CPingClient::Notify(DWORD dwCookie,
                         BOOL  fRefuse,
                         BOOL  /* fOtherSideClient */)
{

    if(dwCookie == m_dwCurrentCookie)
    {
        if (fRefuse)
        {
            m_fPingSucc = !fRefuse;
        }
        else
        {
            m_fPingSucc = TRUE;
				//g_QMLicense.NewConnectionAllowed(fOtherSideClient,
                //                                           pOtherGuid);
        }

        if (!m_fPingSucc)
        {
            Warning(_T("::PING, Client Get refuse to create a new session "));
        }

        SetEvent(m_hNotification);
        Succeeded(L"CPingClient::Notify");
    }
}

void CPingClient::Run()
{
    SOCKET sock = Select();
    if(sock == INVALID_SOCKET)
    {
        return;
    }

    SOCKADDR addr;
    HRESULT rc;
    CPingPacket PingPkt;
    rc = Receive(sock, &addr, &PingPkt);
    if(FAILED(rc))
    {
        DebugMsg(L"CPingClient::Run failed, hr=0x%x", rc);
        return;
    }

    Notify( PingPkt.Cookie(),
            PingPkt.IsRefuse(),
            PingPkt.IsOtherSideClient());
}


//---------------------------------------------------------
//
//  class CPingServer
//
//---------------------------------------------------------

class CPingServer : public CPing
{
    private:
        virtual void Run();
};

//---------------------------------------------------------
//
//  CPingServer IMPLEMENTATION
//
//---------------------------------------------------------
void CPingServer::Run()
{
    SOCKET sock = Select();
    if(sock == INVALID_SOCKET)
    {
        Warning(L"Select failed in CPingServer::Run");
        return;
    }

    SOCKADDR addr;
    HRESULT rc;
    CPingPacket PingPkt;

    rc = Receive(sock, &addr, &PingPkt);
    if(FAILED(rc))
    {
        Warning(L"Receive failed in CPingServer::Run");
        return;
    }

    BOOL fRefuse = FALSE;

    if (fRefuse)
    {
        Warning(_T("::PING, Server side refuse to create a new session"));
    }
    Send(sock, &addr, PingPkt.Cookie(), fRefuse);
}


//---------------------------------------------------------
//
//  Interface Functions
//
//---------------------------------------------------------

CPingServer s_PingServer_IP ;
CPingClient s_PingClient_IP ;

//---------------------------------------------------------
//
//  ping(...)
//
//---------------------------------------------------------

BOOL ping(const SOCKADDR* pAddr, DWORD dwTimeout)
{
   if (pAddr->sa_family == AF_INET)
   {
       return s_PingClient_IP.Ping(pAddr, dwTimeout);
   }
   else
   {
       ASSERT(0) ;
       return FALSE;
   }
}

//---------------------------------------------------------
//
//  StartPingClient(...)
//
//---------------------------------------------------------

HRESULT StartPingClient()
{
    //
    // read IP port from registry.
    //
    DWORD dwIPPort ;

    DWORD dwDef = FALCON_DEFAULT_PING_IP_PORT ;
    READ_REG_DWORD(dwIPPort,
                   FALCON_PING_IP_PORT_REGNAME,
                   &dwDef ) ;

    Inform(L"StartPingClient: PING_IP_PORT  is %d", dwIPPort);

    s_PingClient_IP.Init(dwIPPort, TRUE);

    return MQ_OK ;
}

//---------------------------------------------------------
//
//  StartPingServer(...)
//
//---------------------------------------------------------

HRESULT StartPingServer()
{
    //
    // read IP port from registry.
    //
    DWORD dwIPPort ;

    DWORD dwDef = FALCON_DEFAULT_PING_IP_PORT ;
    READ_REG_DWORD(dwIPPort,
                   FALCON_PING_IP_PORT_REGNAME,
                   &dwDef ) ;

    Inform(L"StartPingServer: PING_IP_PORT  is %d", dwIPPort);

    s_PingServer_IP.Init(dwIPPort, TRUE) ;

    return MQ_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\qmutil.h ===
#ifndef _QMUTIL1__
#define _QMUTIL1__

extern bool fVerbose ;
extern bool fDebug ;

#include "..\\base\base.h"

extern bool IsLocalSystemCluster();
extern DWORD MSMQGetOperatingSystem();

#define OS_SERVER(os)	(os == MSMQ_OS_NTS || os == MSMQ_OS_NTE)

#define ExAttachHandle(hAssociate)   \
        QmIoPortAssociateHandle(hAssociate)

VOID QmIoPortAssociateHandle(HANDLE AssociateHandle);

class CAddressList;

HRESULT GetMachineIPAddresses(IN const char * szHostName,
                           OUT CAddressList* plIPAddresses);

HRESULT  GetComputerNameInternal( 
    WCHAR * pwcsMachineName,
    DWORD * pcbSize);

HRESULT GetComputerDnsNameInternal( 
    WCHAR * pwcsMachineDnsName,
    DWORD * pcbSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\qmutil.cpp ===
#include "stdafx.h"

#include "session.h"
#include "sessmgr.h"

#include "wsnwlink.h"
#include <clusapi.h>

#include <time.h>
#include <rpc.h>
#include <rpcdce.h>

#include <mqprops.h>

#include <nspapi.h>
#include <wsnwlink.h>

#define GUID_STR_BUFFER_SIZE (8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1)

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToStringA (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringUuid
    );

void ChangeGuidToString(LPTSTR pszGUID, const GUID* pGUID)
{
    TBYTE* pszUuid = 0;
    *pszGUID = 0;
    if(UuidToString((GUID *)pGUID, &pszUuid) != RPC_S_OK)
    {
        DebugMsg(TEXT("Failed to convert UUID to string (alloc failed)"));
        // BUGBUG: throw memory exception ...
    }
    else
    {
        _tcscpy(pszGUID, pszUuid);
        RpcStringFree(&pszUuid);
    }
}


HRESULT GetMachineIPAddresses(IN const char * szHostName,
                           OUT CAddressList* plIPAddresses)
{
    TA_ADDRESS * pAddr;
    //
    // Obtain the IP information for the machine
    //
    GoingTo(L"gethostbyname");

    PHOSTENT pHostEntry = gethostbyname(szHostName);
    if ((pHostEntry == NULL) || (pHostEntry->h_addr_list == NULL))
    {
        Warning(L"gethostbyname in GetMachineIPAddresses - no IP addresses found");
        return MQ_OK;
    }
    else
    {
        Inform(L"gethostbyname in GetMachineIPAddresses for %S: %S", 
                        szHostName, inet_ntoa(*(struct in_addr *)pHostEntry->h_addr_list[0]));
    }

    //
    // Add each IP address to the list of IP addresses
    //
    for ( DWORD uAddressNum = 0 ;
          pHostEntry->h_addr_list[uAddressNum] != NULL ;
          uAddressNum++)
    {
        //
        // Keep the TA_ADDRESS format of local IP address
        //
        pAddr = (TA_ADDRESS *)new char [IP_ADDRESS_LEN + TA_ADDRESS_SIZE];
        pAddr->AddressLength = IP_ADDRESS_LEN;
        pAddr->AddressType = IP_ADDRESS_TYPE;
        memcpy( &(pAddr->Address), pHostEntry->h_addr_list[uAddressNum], IP_ADDRESS_LEN);
        plIPAddresses->AddTail(pAddr);
    }
    return MQ_OK;
}


CAddressList* GetIPAddresses(void)
{
    CAddressList* plIPAddresses = new CAddressList;

    //
    // Check if TCP/IP is installed and enabled
    //
    char szHostName[ MQSOCK_MAX_COMPUTERNAME_LENGTH ];
    DWORD dwSize = sizeof( szHostName);

    //
    //  Just checking if socket is initialized
    //
    GoingTo(L"gethostname in GetIPAddresses");
    if (gethostname(szHostName, dwSize) != SOCKET_ERROR)
    { 
        Succeeded(L"gethostname in GetIPAddresses");
        GetMachineIPAddresses(szHostName,plIPAddresses);
    }
    else
    {
        Warning(L"gethostname in GetIPAddresses failed, WSAGetLastError=%d", WSAGetLastError());
    }

    return plIPAddresses;
}

void TA2StringAddr(IN const TA_ADDRESS * pa,
                   OUT LPTSTR psz)
{
    WCHAR  szTmp[100];

    ASSERT(psz != NULL);
    ASSERT(pa != NULL);
    ASSERT(pa->AddressType == IP_ADDRESS_TYPE ||
           pa->AddressType == FOREIGN_ADDRESS_TYPE);

    switch(pa->AddressType)
    {
        case IP_ADDRESS_TYPE:
            {
                char * p = inet_ntoa(*(struct in_addr *)(pa->Address));
                swprintf(szTmp, TEXT("%S"), p);
                break;
            }
        case FOREIGN_ADDRESS_TYPE:
            {
                WCHAR strUuid[GUID_STR_BUFFER_SIZE+2],
                     *GuidStr = &strUuid[0];

                ChangeGuidToString(strUuid, (GUID*)(pa->Address));
                swprintf(szTmp, L"%s",GuidStr);
                break;
            }

        default:
            ASSERT(0);
    }

    swprintf(psz, TEXT("%d %s"), pa->AddressType, szTmp);
}

/* from mqutil */
bool
IsLocalSystemCluster()
/*++

Routine Description:

    Check if local machine is a cluster node.

    The only way to know that is try calling cluster APIs.
    That means that on cluster systems, this code should run
    when cluster service is up and running. (ShaiK, 26-Apr-1999)

Arguments:

    None

Return Value:

    true - The local machine is a cluster node.

    false - The local machine is not a cluster node.

--*/
{
    HINSTANCE hLib = LoadLibrary(L"clusapi.dll");

    if (hLib == NULL)
    {
        DebugMsg(_T("Local machine is NOT a Cluster node"), 0);
        return false;
    }

    typedef DWORD (WINAPI *GetState_fn) (LPCWSTR, DWORD*);
    GetState_fn pfGetState = (GetState_fn)GetProcAddress(hLib, "GetNodeClusterState");

    if (pfGetState == NULL)
    {
        DebugMsg( _T("Local machine is NOT a Cluster node"), 0);
        return false;
    }

    DWORD dwState = 0;
    if (ERROR_SUCCESS != pfGetState(NULL, &dwState))
    {
        DebugMsg( _T("Local machine is NOT a Cluster node"), 0);
        return false;
    }

    if (dwState == ClusterStateNotInstalled)
    {
        DebugMsg(_T("Local machine is NOT a Cluster node"), 0);
        return false;
    }


    DebugMsg( _T("Local machine is a Cluster node !!"), 0);
    return true;

} //IsLocalSystemCluster

DWORD MSMQGetOperatingSystem()
{
#ifdef MQWIN95
    return(MSMQ_OS_95);
#else
    HKEY  hKey ;
    DWORD dwOS = MSMQ_OS_NONE;
    WCHAR szNTType[32];

    LONG rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 L"System\\CurrentControlSet\\Control\\ProductOptions",
                           0L,
                           KEY_READ,
                           &hKey);
    if (rc == ERROR_SUCCESS)
    {
        DWORD dwNumBytes = sizeof(szNTType);
        rc = RegQueryValueEx(hKey, TEXT("ProductType"), NULL,
                                  NULL, (BYTE *)szNTType, &dwNumBytes);

        if (rc == ERROR_SUCCESS)
        {

            //
            // Determine whether Windows NT Server is running
            //
            if (_wcsicmp(szNTType, TEXT("SERVERNT")) != 0 &&
                _wcsicmp(szNTType, TEXT("LANMANNT")) != 0 &&
                _wcsicmp(szNTType, TEXT("LANSECNT")) != 0)
            {
                //
                // Windows NT Workstation
                //
                ASSERT (_wcsicmp(L"WinNT", szNTType) == 0);
                dwOS =  MSMQ_OS_NTW ;
            }
            else
            {
                //
                // Windows NT Server
                //
                dwOS = MSMQ_OS_NTS;
                //
                // Check if Enterprise Edition
                //
                BYTE  ch ;
                DWORD dwSize = sizeof(BYTE) ;
                DWORD dwType = REG_MULTI_SZ ;
                rc = RegQueryValueEx(hKey,
                                     L"ProductSuite",
                                     NULL,
                                     &dwType,
                                     (BYTE*)&ch,
                                     &dwSize) ;
                if (rc == ERROR_MORE_DATA)
                {
                    P<WCHAR> pBuf = new WCHAR[ dwSize + 2 ] ;
                    rc = RegQueryValueEx(hKey,
                                         L"ProductSuite",
                                         NULL,
                                         &dwType,
                                         (BYTE*) &pBuf[0],
                                         &dwSize) ;
                    if (rc == ERROR_SUCCESS)
                    {
                        //
                        // Look for the string "Enterprise".
                        // The REG_MULTI_SZ set of strings terminate with two
                        // nulls. This condition is checked in the "while".
                        //
                        WCHAR *pVal = pBuf ;
                        while(*pVal)
                        {
                            if (_wcsicmp(L"Enterprise", pVal) == 0)
                            {
                                dwOS = MSMQ_OS_NTE ;
                                break;
                            }
                            pVal = pVal + wcslen(pVal) + 1 ;
                        }
                    }
                }
            }
        }
        RegCloseKey(hKey);
    }

    return dwOS;
#endif
}

/* from mqutil */

HRESULT  GetComputerNameInternal( 
    WCHAR * pwcsMachineName,
    DWORD * pcbSize
    )
{
    GoingTo(L"GetComputerName");
    if (GetComputerName(pwcsMachineName, pcbSize))
    {
        Succeeded(L"GetComputerName: %s", pwcsMachineName);
        CharLower(pwcsMachineName);
        return MQ_OK;
    }
    else
    {
        Warning(L"Failed GetComputerName, GetLastError=0x%x", GetLastError());
    }

    return MQ_ERROR;

}

HRESULT 
GetComputerDnsNameInternal( 
    WCHAR * pwcsMachineDnsName,
    DWORD * pcbSize
    )
{
    GoingTo(L"GetComputerNameEx");
    if (GetComputerNameEx(ComputerNameDnsFullyQualified,
						  pwcsMachineDnsName,
						  pcbSize))
    {
        Succeeded(L"GetComputerNameEx: %s", pwcsMachineDnsName);
        CharLower(pwcsMachineDnsName);
        return MQ_OK;
    }
    else
    {
        Warning(L"Failed GetComputerDnsNameInternal, GetLastError=0x%x", GetLastError());
    }

    return MQ_ERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\qmthrd.h ===
#include "qmov.h"

DWORD WINAPI QmMainThread(LPVOID Param);


typedef struct _QMOV_WriteSession
{
    EXOVERLAPPED               qmov;
    CTransportBase*             pSession;
    PVOID                       lpBuffer;       // pointer to Release Buffer
    PVOID                       lpWriteBuffer;  // Pointer to write buffer
    DWORD                       dwWriteSize;    // How many bytes should be writen
    DWORD                       dwWrittenSize;  // How many bytes was written

    _QMOV_WriteSession(IN EXOVERLAPPED::COMPLETION_ROUTINE lpComplitionRoutine,
                       IN HANDLE hSock
                      ) : qmov(lpComplitionRoutine, hSock) {}

} QMOV_WriteSession, *LPQMOV_WriteSession;

//
// QMOV_ReadSession
//
typedef struct _QMOV_ReadSession
{
    EXOVERLAPPED    qmov;
    CTransportBase*   pSession;  // Pointer to session object
    PVOID            pbuf;       // Pointer to buffer
    DWORD            dwReadSize; // Size of buffer
    DWORD            read;       // How many bytes already read
    LPREAD_COMPLETION_ROUTINE  lpReadCompletionRoutine;

    _QMOV_ReadSession(IN EXOVERLAPPED::COMPLETION_ROUTINE lpComplitionRoutine,
                      IN HANDLE hSock
                     ) : qmov(lpComplitionRoutine, hSock) {}

} QMOV_ReadSession, *LPQMOV_ReadSession;


VOID WINAPI HandleWritePacket(EXOVERLAPPED* pov);

VOID WINAPI HandleReadPacket(EXOVERLAPPED* pov);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\qmthrd.cpp ===
#include "stdafx.h"

#include "qmov.h"
#include "session.h"
#include "sessmgr.h"
#include "qmthrd.h"


#define GetIoCompletionStatus(hIoPort, pdwNoOfBytes, pdwKey, ppov, dwTime) \
        GetQueuedCompletionStatus(hIoPort, pdwNoOfBytes, pdwKey, ppov, dwTime)

// HANDLE to Io Completion Port
HANDLE g_hIoPort;


VOID QmIoPortAssociateHandle(HANDLE  hAssociate)
{
    HANDLE hTemp;

    hTemp = CreateIoCompletionPort(hAssociate,
                                   g_hIoPort,
                                   0,
                                   0
                                  );
    if (hTemp == NULL)
    {
        Failed(L"CreateIoCompletionPort, err=0x%x", GetLastError());
    }
    else
    {
        g_hIoPort = hTemp;
        Succeeded(L"CreateIoCompletionPort, g_hIoPort=0x%x", g_hIoPort);
    }
}


//
// ISSUE-2000/7/24-erezh bad compiler pragma
// This is a bug in the compiler, waiting for a fix
//
#pragma warning(disable: 4715)

DWORD WINAPI QmMainThread(LPVOID)
{
    DWORD           dwNoOfBytes;
    DWORD           dwKey;
    EXOVERLAPPED* pov;
    BOOL fSuccess;

    for(;;)
    {
        try
        {
            //
            // waits until IO completes.
            //
            fSuccess = GetIoCompletionStatus(g_hIoPort,
                                             &dwNoOfBytes,
                                             &dwKey,
                                             (LPOVERLAPPED *)(&pov),
                                             INFINITE);

            //
            // Check in debug version if the operation pass successfully.
            // Since we use INFINITE waiting time the only reason for failure
            // is illegal parameters
            //
            if (pov == NULL)
            {
                Warning(_TEXT("GetQueuedCompletionStatus failed, Error 0x%x"), GetLastError());
                continue;
            }

            if (fSuccess)
            {
                Succeeded(L"GetQueuedCompletionStatus");
            }

            //
            // N.B. Don't call any debug trace or io function that
            //      might change LastError.
            //
            pov->m_lpComplitionRoutine(pov);

            DebugMsg(_TEXT("%x: Completion routine ended. Time %d"), GetCurrentThreadId(), GetTickCount());
        }
        catch(const bad_alloc&)
        {
            //
            //  No resources; handle next completion event.
            //
            Failed(L"No resources in QmMainThread");
        }
    }  

    return(MQ_OK);
}

//
// ISSUE-2000/7/24-erezh bad compiler pragma
// This is a bug in the compiler, waiting for a fix
//
#pragma warning(default: 4715)


VOID WINAPI HandleWritePacket(EXOVERLAPPED* pov)
{
    //
    // First call GetLastError, don't call any debug trace or io function
    // that might change LastError.
    //
    DWORD dwErrorCode = FAILED(pov->GetStatus()) ? GetLastError() : ERROR_SUCCESS;

    LPQMOV_WriteSession pParam = CONTAINING_RECORD (pov, QMOV_WriteSession, qmov);
    (pParam->pSession)->WriteCompleted(dwErrorCode,
                                       pov->InternalHigh,
                                       pParam);
}

VOID WINAPI HandleReadPacket(EXOVERLAPPED* pov)
{
    //
    // First call GetLastError, don't call any debug trace or io function
    // that might change LastError.
    //
    DWORD dwErrorCode = FAILED(pov->GetStatus()) ? GetLastError() : ERROR_SUCCESS;

    LPQMOV_ReadSession pParam = CONTAINING_RECORD (pov, QMOV_ReadSession, qmov);
    (pParam->pSession)->ReadCompleted(dwErrorCode,
                                      pov->InternalHigh,
                                      pParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\qmov.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    qmov.h

Abstract:
    Decleration of QM Overlapped structure

Author:
    Uri Habusha (urih)

--*/

#ifndef __QMOV_H__
#define __QMOV_H__

struct EXOVERLAPPED : public OVERLAPPED
{
public:

    typedef VOID (WINAPI *COMPLETION_ROUTINE)(EXOVERLAPPED* pov);

public:
    EXOVERLAPPED(
            IN COMPLETION_ROUTINE lpComplitionRoutine,
            IN HANDLE hSock); 

    ~EXOVERLAPPED();
    void ResetOverlapped(void);
    HRESULT GetStatus() const;

public: 
    COMPLETION_ROUTINE m_lpComplitionRoutine;

#ifdef MQWIN95
    HANDLE                m_hSock ;
    HANDLE                m_hEvent ;
#endif
};

/*======================================================

  Function:      EXOVERLAPPED::EXOVERLAPPED

  Description:   constructor

        The routine initilize the Overlapped structure and set the call back
        routine pointer. For win95 it allocates an event and set its index on
        the EXOVERLAPPED structure.

========================================================*/
inline
EXOVERLAPPED::EXOVERLAPPED(
    IN COMPLETION_ROUTINE lpComplitionRoutine,
    IN HANDLE hSock
    )
{
    ResetOverlapped();
    hEvent   = 0;
    m_lpComplitionRoutine = lpComplitionRoutine;
#ifdef MQWIN95
    m_hSock  = hSock;
    EventMgr.GetFreeEvent(this);
#else
    UNREFERENCED_PARAMETER(hSock);
#endif
}


/*======================================================

  Function:      EXOVERLAPPED::~EXOVERLAPPED

  Description:   destructor

  For win95 free the event before delete the class

========================================================*/
inline EXOVERLAPPED::~EXOVERLAPPED()
{
#ifdef MQWIN95
    ASSERT (m_Overlapped.hEvent);

    EventMgr.FreeEvent(this);
#endif
}

/*======================================================

  Function:      EXOVERLAPPED::ResetOverlapped

  Description:   reset overlapped fields

========================================================*/
inline void
EXOVERLAPPED::ResetOverlapped(void)
{
    Internal       = 0;
    InternalHigh   = 0;
    Offset         = 0;
    OffsetHigh     = 0;
}


/*======================================================

  Function:      EXOVERLAPPED::GetStatus()

  Description:   return the internal status

========================================================*/
inline HRESULT EXOVERLAPPED::GetStatus() const
{
    return DWORD_PTR_TO_DWORD(Internal);
}


#endif //__QMOV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\session.cpp ===
#include "stdafx.h"

#include "session.h"
#include "sessmgr.h"
#include "qmthrd.h"
#include "ping.h"
#include <uniansi.h>

#define PING_TIMEOUT 1000

char *szRequest = "Sasha";
char *szReply   = "Galia";

TCHAR tempBuf[100];

CTransportBase::CTransportBase()
{
	    m_sock          = 0;
}

CTransportBase::~CTransportBase()
{
}

void
CTransportBase::ReadCompleted(IN DWORD         fdwError,          // completion code
                              IN DWORD         cbTransferred,     // number of bytes transferred
                              IN LPQMOV_ReadSession  po)          // address of structure with I/O information
{
    BOOL                rc;
    HRESULT             hr = MQ_OK;
    DWORD               NoBytesRead;

    ASSERT(po != NULL);


    if (((fdwError != ERROR_SUCCESS) && (fdwError != ERROR_MORE_DATA)) ||
        cbTransferred == 0)
    {

        ASSERT((fdwError == ERROR_OPERATION_ABORTED) ||
               (fdwError ==  ERROR_NETNAME_DELETED)  ||
               (cbTransferred == 0));

        //
        // Error or Connection closed - do whatever is necessary
        // Notify the session that it is done
        //
        Warning(_TEXT("::ReadCompleted- Read from socket Failed. Error %xh"), fdwError);
        CloseConnection(L"Read packet from socket Failed");
    }
    else
    {
        //
        //  we've received a packet, i.e., the session is in use
        //
        po->read += cbTransferred;
        ASSERT(po->read <=  po->dwReadSize);
        //
        // Check if we read all the expected data
        //
        DebugMsg(_TEXT("Read Completed from session %s,. Read 0x%x"),GetStrAddr(), po->read);
        if(po->read == po->dwReadSize)
        {
            //
            // A buffer was completely read. Call the completed function
            // to handle the current state
            //
            Inform(_T("Read from socket Completed. Read 0x%x bytes"), po->dwReadSize);
            //po->lpReadCompletionRoutine(po);

            if (memcmp(po->pbuf, szRequest, strlen(szRequest)) == 0)
            {
			    Inform(L"Received request - sending reply");

                Send (szReply);

            }
            else if (memcmp(po->pbuf, szReply, strlen(szReply)) == 0)
            {
				SetEvent(g_evActive);
                Inform(L"Receive reply completed - Active part has finished");

            }
            else
            {
				Failed(L"Received wrong data");
            }
        }

        if (SUCCEEDED(hr) && (m_sock != NULL))
        {
            //
            // Reissue a read until all data is received
            //
            po->qmov.ResetOverlapped();
            rc = ReadFile((HANDLE) m_sock,
                           (char *) po->pbuf + po->read,
                           po->dwReadSize - po->read,
                           &NoBytesRead,
                           &po->qmov);

            //
            // Check if the connection has been closed
            //
            if (rc == FALSE &&
                (GetLastError() != ERROR_IO_PENDING) &&
                //
                // If a IPX socket is being read and the next packet is longer than
                // the Size parameter specifies, ReadFile returns FALSE and
                // GetLastError returns ERROR_MORE_DATA. The remainder
                // of the packet may be read by a subsequent call to the ReadFile.
                //
                GetLastError() != ERROR_MORE_DATA )
            {
                DebugMsg(L"read from session %s, error 0x%x",GetStrAddr(), GetLastError());
                CloseConnection( L"Read from socket Failed");
            }
            else
            {
                 DebugMsg(_TEXT("Begin new Read phase from session %s,. Read 0x%x. (time %d)"),
                              GetStrAddr(), (po->dwReadSize - po->read), GetTickCount());

                return;
            }
        }
    }
}



HRESULT CTransportBase::BeginReceive()
{
    BOOL rc;
    DWORD NoBytesRead = 0;

    ASSERT(m_sock != 0);

    QMOV_ReadSession* lpQmOv = new QMOV_ReadSession(HandleReadPacket, (HANDLE) m_sock);

    lpQmOv->pSession =  this;
    lpQmOv->pbuf =      new UCHAR[100];
    lpQmOv->dwReadSize =          5 ;    // reading 7 characters
    lpQmOv->read =                0;

    //
    // Issue a read until all data is received
    //
    DebugMsg(TEXT("::BeginReceive- call ReadFile, %lut bytes, from socket- %lxh"),
                                       lpQmOv->dwReadSize, (DWORD) m_sock) ;

    rc = ReadFile((HANDLE) m_sock,
                  (char *) lpQmOv->pbuf,
                  lpQmOv->dwReadSize,
                  &NoBytesRead,
                  &lpQmOv->qmov);

    //
    // Check if the connection has been closed
    //
    if (rc == FALSE &&
        GetLastError() != ERROR_IO_PENDING &&
        //
        // If a IPX socket is being read and the next packet is longer than
        // the lpQmOv->dwReadSize parameter specifies, ReadFile returns
        // FALSE and GetLastError returns ERROR_MORE_DATA. The remainder
        // of the packet may be read by a subsequent call to the ReadFile.
        //
        GetLastError() != ERROR_MORE_DATA )
    {
        Warning(_TEXT("::BeginReceive- Read from socket %s failed, error = 0x%xt"),
                                           GetStrAddr(), GetLastError());

        CloseConnection(L"Read from socket failed");

        delete lpQmOv->pbuf;
        delete lpQmOv;

        return MQ_ERROR;
    }

    //
    // Check if the connection has been closed
    //
    if (rc == FALSE &&
        GetLastError() != ERROR_IO_PENDING &&
        //
        // If a IPX socket is being read and the next packet is longer than
        // the lpQmOv->dwReadSize parameter specifies, ReadFile returns
        // FALSE and GetLastError returns ERROR_MORE_DATA. The remainder
        // of the packet may be read by a subsequent call to the ReadFile.
        //
        GetLastError() != ERROR_MORE_DATA )
    {
        Warning(_TEXT("::BeginReceive- Read from socket %s failed, error = 0x%xt"),
                                           GetStrAddr(), GetLastError());

        CloseConnection(L"Read from socket failed");
    }

    return MQ_OK;
}



HRESULT CTransportBase::NewSession(void)
{
    TCHAR szAddr[30];
    HRESULT hr;

    //
    // Create Stats structure
    //
    TA2StringAddr(GetSessionAddress(), szAddr);

	//
	// Optimize buffer size
	//
    GoingTo(L"setsockopt buffer size in NewSession");
    int opt = 18 * 1024;
    int rc = setsockopt(m_sock, SOL_SOCKET, SO_SNDBUF, (const char *)&opt, sizeof(opt));
    if (rc != 0)
    {
        Warning(L"Failed setsockopt buffer size in NewSession, err=%d", WSAGetLastError());
    }
    else
    {
        Succeeded(L"setsockopt buffer size in NewSession");
    }

	//
	// Optimize to no Nagling (based on registry)
	//
	extern BOOL g_fTcpNoDelay;
    GoingTo(L"setsockopt Nagling in NewSession");
    rc = setsockopt(m_sock, IPPROTO_TCP, TCP_NODELAY, (const char *)&g_fTcpNoDelay, sizeof(g_fTcpNoDelay));
    if (rc != 0)
    {
        Warning(L"Failed setsockopt Naglingin NewSession, err=%d", WSAGetLastError());
    }
    else
    {
        Succeeded(L"setsockopt Nagling in NewSession");
    }

    //
    // Connect the socket to completion port
    //
    ExAttachHandle((HANDLE)m_sock);

    //
    // Begin read from a session
    //
    hr = BeginReceive();

    return hr;
}

HRESULT
CTransportBase::WriteToSocket(LPQMOV_WriteSession po)
{
    po->qmov.ResetOverlapped();

    DWORD dwWrites = po->dwWriteSize - po->dwWrittenSize;
#ifdef MQWIN95
    int rcSend = send( m_sock,
                       (const char *) po->lpWriteBuffer + po->dwWrittenSize,
                       dwWrites,
                       0) ;
    BOOL fSucc = (rcSend == (int) dwWrites) ;

    if (fSucc)
    {
        ASSERT((po->qmov).m_Overlapped.hEvent);

        (po->qmov).m_Overlapped.Internal = ERROR_SUCCESS;
        (po->qmov).m_Overlapped.InternalHigh = dwWrites;
        BOOL rc = SetEvent((po->qmov).m_Overlapped.hEvent);
        ASSERT(rc == TRUE);

        return MQ_OK;
    }
#else

    DWORD dwNoBytesWritten;

    DebugMsg(TEXT("Write 0x%x bytes to Session %s"), dwWrites,(po->pSession)->GetStrAddr());

    BOOL fSucc = WriteFile((HANDLE) m_sock,
                           (PUCHAR) po->lpWriteBuffer + po->dwWrittenSize,
                           dwWrites,
                           &dwNoBytesWritten,
                           &po->qmov);
#endif
    //
    // Check if the connection has been closed
    //
    DWORD dwErrorCode;
    if (!fSucc && ((dwErrorCode =GetLastError()) != ERROR_IO_PENDING))
    {
        Warning(L"WriteToSocket failed, err=0x%x", dwErrorCode);

        ASSERT((dwErrorCode == ERROR_OPERATION_ABORTED)   ||
               (dwErrorCode == ERROR_NETNAME_DELETED)     ||
               (dwErrorCode == ERROR_INVALID_HANDLE)      ||
               (dwErrorCode == ERROR_NO_SYSTEM_RESOURCES) ||
               (dwErrorCode == WSAECONNRESET)             ||  // possible in win95
               (dwErrorCode == WSAENOTSOCK));                 // possible in win95

        //
        // Close the connection and move the queues to non-active state.
        //
        CloseConnection(L"Write on socket failed");
        return MQ_ERROR;
    }

    return MQ_OK;
}


HRESULT
CTransportBase::SendEstablishConnectionPacket()
{
    HRESULT hr;

    DebugMsg(_T("Write to socket %s Establish Connection Packet. Write 0x%x bytes"), GetStrAddr(),  strlen(szRequest));

    hr = CreateSendRequest(szRequest, szRequest, strlen(szRequest));

    return hr;
}

bool
CTransportBase::BindToFirstIpAddress(
    VOID
    )
{
    GoingTo(L"gethostbyname(NULL) in BindToFirstIpAddress");

    PHOSTENT    phe = gethostbyname(NULL);
    if (phe == NULL)
    {
        Warning(L"failed gethostbyname(NULL) in BindToFirstIpAddress: WSAGetLastError=%d", WSAGetLastError());
        return false;
    }
    else
    {
        Inform(L"gethostbyname(NULL) in BindToFirstIpAddress: %S",
                    inet_ntoa(*(struct in_addr *)phe->h_addr_list[0]));
    }

    SOCKADDR_IN local;
    memcpy(&local.sin_addr.s_addr, phe->h_addr_list[0], IP_ADDRESS_LEN);

    local.sin_family = AF_INET;
    local.sin_port   = 0;

    GoingTo(L"bind 0x%x in BindToFirstIpAddress", m_sock);
    if(bind(m_sock, (struct sockaddr FAR *)&local, sizeof(local)) == SOCKET_ERROR)
    {
        Warning(L"failed bind(0x%x) in BindToFirstIpAddress: WSAGetLastError=%d", m_sock, WSAGetLastError());
        return false;
    }
    else
    {
        Succeeded(L"bind 0x%x in BindToFirstIpAddress", m_sock);
    }

    return true;

} // CSockTransport::BindToFirstIpAddress


HRESULT CTransportBase::CreateConnection(
    IN const TA_ADDRESS* pa,
    BOOL fQuick /* = TRUE*/
    )
{
    ASSERT(m_sock == 0);

    //
    //Keep the TA_ADDRESS format
    //
    SetSessionAddress(pa);

    switch(pa->AddressType)
    {
        case IP_ADDRESS_TYPE:
        {
            SOCKADDR_IN dest_in;    //Destination Address
            DWORD dwAddress;

            dwAddress = * ((DWORD *) &(pa->Address));
            ASSERT(g_dwIPPort) ;
            m_uPort = (unsigned short) g_dwIPPort ;

            dest_in.sin_family = AF_INET;
            dest_in.sin_addr.S_un.S_addr = dwAddress;
            dest_in.sin_port = htons(m_uPort);

            if(fQuick)
            {
				if (CSessionMgr::m_fUsePing)
				{
	                BOOL f = FALSE;
	
					while (!f)
					{
						f = ping((SOCKADDR*)&dest_in, PING_TIMEOUT);

						if (!f)
						{
							Warning(TEXT("CreateConnection- ping to %s Failed."),GetStrAddr());
						}
					}
                    Inform(L"Succeeded ping to %s in CreateConnection",GetStrAddr());
				}
            }

            m_sock = socket( AF_INET, SOCK_STREAM, 0);
            if(m_sock == INVALID_SOCKET)
            {
                Warning(L"CreateConnection- Cant create a socket, WSAGetLastError=%d", WSAGetLastError());
                return MQ_ERROR;
            }

            //
            // If inside a cluster group, bind the socket to the first
            // IP address we depend upon
            //

            WCHAR wzServiceName[260] = {QM_DEFAULT_SERVICE_NAME};
            GetFalconServiceName(wzServiceName, TABLE_SIZE(wzServiceName));

            if (0 != CompareStringsNoCase(QM_DEFAULT_SERVICE_NAME, wzServiceName))
            {
                if (!BindToFirstIpAddress())
                {
                    Warning(L"CreateConnection- BindToFirstIpAddress");
                    return MQ_ERROR;
                }
            }

            GoingTo(L"connect in CreateConnection");

            int ret = connect(m_sock,(PSOCKADDR)&dest_in,sizeof(dest_in));

            if(ret == SOCKET_ERROR)
            {
                DWORD dwErrorCode = WSAGetLastError();

                Warning(TEXT("CreateConnection- connect to %s Failed. Error %d, fQuick=0x%x"),
                    GetStrAddr(), dwErrorCode, fQuick);

                closesocket(m_sock);
                m_sock = 0;
                return MQ_ERROR;
            }
            else
            {
                Succeeded(L"connect to %s in CreateConnection", GetStrAddr());
            }

            break;
        }



    default:
        ASSERT(0);
        return MQ_ERROR;
        break;

    }

    Succeeded(L"CreateConnection- Session created with %s", GetStrAddr());

    //
    // connect the session to complition port and begin read on the socket
    //
    NewSession();

    //
    // Send Establish connection packet.
    //
    HRESULT hr = SendEstablishConnectionPacket();
    if(FAILED(hr))
    {
        Warning(L"SendEstablishConnectionPacket failed");
    }

    return hr;
}

void CTransportBase::Connect(IN TA_ADDRESS *pa, IN SOCKET sock)
{
    ASSERT(m_sock == 0);

    m_sock = sock;
    SetSessionAddress(pa);
}

const TA_ADDRESS*
CTransportBase::GetSessionAddress(void) const
{
    return m_pAddr;
}


void
CTransportBase::SetSessionAddress(const TA_ADDRESS* pa)
{
    //Keep the TA_ADDRESS format
    m_pAddr = (TA_ADDRESS*) new char [pa->AddressLength + TA_ADDRESS_SIZE];
    memcpy(m_pAddr, pa, pa->AddressLength + TA_ADDRESS_SIZE);

    TA2StringAddr(pa, m_lpcsStrAddr);
}

LPCWSTR
CTransportBase::GetStrAddr(void) const
{
    return m_lpcsStrAddr;
}

void CTransportBase::CloseConnection(
                                     LPCWSTR lpcwsDebugMsg
                                     )
{
    //
    // Check if the connection has already been closed
    //
    if (m_sock == 0)
    {
        return;
    }

    Warning(L"Close Connection with %ws at %s. %s",
                      GetStrAddr(),  _tstrtime(tempBuf), lpcwsDebugMsg);

    closesocket(m_sock);
    m_sock = 0;

}



HRESULT CTransportBase::Send(char *str)
{
    HRESULT hr = MQ_OK;

    hr = CreateSendRequest(str, str, strlen(str));
	return hr;
}

void
CTransportBase::WriteCompleted(IN DWORD         fdwError,          // completion code
                               IN DWORD         cbTransferred,     // number of bytes transferred
                               IN LPQMOV_WriteSession  po)         // address of structure with I/O information
{
    ASSERT(po != NULL);

    HRESULT             hr = MQ_OK;

    if ((fdwError != ERROR_SUCCESS) || (cbTransferred == 0))
    {

        ASSERT((fdwError == ERROR_OPERATION_ABORTED) ||
               (fdwError ==  ERROR_NETNAME_DELETED)  ||
               (cbTransferred == 0));

        //
        // Error or Connection closed - do whatever is necessary
        // Notify the session that it is done
        //
        Warning(_T("::WriteCompleted - Write to socket Failed. Error %xh"), fdwError);

        delete po->lpBuffer;
        delete po;

        CloseConnection(L"Write packet to socket Failed");
    }
    else
    {

        po->dwWrittenSize += cbTransferred;
        ASSERT(po->dwWrittenSize <=  po->dwWriteSize);

        //
        // Check if we wrote all the expected data
        //

        Inform(_T("Write to socket %s Completed. Wrote 0x%x bytes"),GetStrAddr(), po->dwWrittenSize);

        if(po->dwWrittenSize ==  po->dwWriteSize)
        {
            //
            // Write was completely. If it was reply - passive part  has finished.
            //
            if (memcmp(po->lpWriteBuffer, szReply, strlen(szReply)) == 0)
            {
                SetEvent(g_evPassive);
                Inform(L"Write reply completed - Passive part  has finished");
            }

			delete po;
        }
        else
        {
            hr = WriteToSocket(po);
            if (FAILED(hr))
            {
                //
                // write to socket failed ==> close of session ==> requeue the packet
                //
                Warning(L"write to socket failed");
                ASSERT(m_sock == 0);
                delete po;
            }
        }
    }
}

HRESULT
CTransportBase::CreateSendRequest(PVOID                       lpReleaseBuffer,
                                  PVOID                       lpWriteBuffer,
                                  DWORD                       dwWriteSize
                                )
{
    LPQMOV_WriteSession po = NULL;
    HRESULT hr;

    try
    {
        po = new QMOV_WriteSession(HandleWritePacket, (HANDLE) m_sock);
    }
    catch(const bad_alloc&)
    {
        //
        // Close the connection and move the queues to non-active state.
        //
        Failed(L"No reosiurces in CreateSendRequest");
    }

    po->pSession = this;
    po->lpBuffer = lpReleaseBuffer;
    po->lpWriteBuffer = lpWriteBuffer;
    po->dwWrittenSize = 0;
    po->dwWriteSize = dwWriteSize;

    hr = WriteToSocket(po);


    if (FAILED(hr))
    {
        Warning(L"Failed WriteToSocket: hr=0x%x", hr);
        delete po;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\register.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
        register.c

Abstract:
        handle registery

Autor:
        Uri Habusha

--*/


//
// NOTE: registry routines in mqutil do not provide
// thread or other synchronization. If you change
// implementation here, carefully verify that
// registry routines in mqutil's clients are not
// broken, especially the wrapper routines in
// mqclus.dll  (ShaiK, 19-Apr-1999)
//


#include "stdafx.h"
#include <_mqreg.h>
#include <autorel.h>
#include <uniansi.h>

void AFXAPI DestructElements(HKEY *phKey, int nCount)
{
    for (; nCount--; phKey++)
    {
        RegCloseKey(*phKey);
    }
}

TCHAR g_tRegKeyName[ 256 ] = {0} ;
BOOL  g_fIniFileExist = FALSE ;
CAutoCloseRegHandle g_hKeyFalcon = NULL ;
static CMap<LPCWSTR, LPCWSTR, HKEY, HKEY&> s_MapName2Handle;

#ifdef _DEBUG
extern void SetTitleText(HWND);
extern HWND g_hThreadWnd ;
#endif

extern TCHAR g_tszService[256];

/*====================================================

CompareElements  of LPCTSTR

Arguments:

Return Value:

=====================================================*/

BOOL AFXAPI CompareElements(const LPCTSTR* MapName1, const LPCTSTR* MapName2)
{

    return (_tcscmp(*MapName1, *MapName2) == 0);

}

/*====================================================

DestructElements of LPCTSTR

Arguments:

Return Value:

=====================================================*/

void AFXAPI DestructElements(LPCTSTR* ppNextHop, int n)
{

    int i;
    for (i=0;i<n;i++)
        delete [] (WCHAR*) *ppNextHop++;

}

/*====================================================

hash key  of LPCTSTR

Arguments:

Return Value:


=====================================================*/
UINT AFXAPI HashKey(LPCTSTR key)
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}

//-------------------------------------------------------
//
//  MQGetRegistrySectionName
//
//-------------------------------------------------------
TCHAR  *MQGetRegistrySectionName()
{
   return g_tRegKeyName ;
}



//
// Registry section of MSMQ is based on the service name.
// This allows multiple QMs to live on same machine, each
// with its own registry section. (ShaiK)
//

DWORD
GetFalconServiceName(
    LPWSTR pwzServiceNameBuff,
    DWORD dwServiceNameBuffLen
    )
{
    ASSERT(("must point to a valid buffer", NULL != pwzServiceNameBuff));

    DWORD dwLen = wcslen(g_tszService);

    ASSERT(("out buffer too small!", dwLen < dwServiceNameBuffLen));
    if (dwLen < dwServiceNameBuffLen)
    {
        wcscpy(pwzServiceNameBuff, g_tszService);
    }

    return(dwLen);

} //GetFalconServiceName


//-------------------------------------------------------
//
//  LONG OpenFalconKey(void)
//
//-------------------------------------------------------
LONG OpenFalconKey(void)
{
    LONG rc;
    WCHAR szServiceName[256];

    wcscpy(g_tRegKeyName, FALCON_REG_KEY) ;

    GetFalconServiceName(szServiceName, sizeof(szServiceName) / sizeof(WCHAR));
    if (0 != CompareStringsNoCase(szServiceName, QM_DEFAULT_SERVICE_NAME))
    {
        //
        // Multiple QMs environment. I am a clustered QM !
        //
        wcscpy(g_tRegKeyName, FALCON_CLUSTERED_QMS_REG_KEY);
        wcscat(g_tRegKeyName, szServiceName);
        wcscat(g_tRegKeyName, FALCON_REG_KEY_PARAM);
    }

    {
        rc = RegOpenKeyEx (FALCON_REG_POS,
                           g_tRegKeyName,
                           0L,
                           KEY_READ | KEY_WRITE,
                           &g_hKeyFalcon);

        if (rc != ERROR_SUCCESS)
        {
            rc = RegOpenKeyEx (FALCON_REG_POS,
                               g_tRegKeyName,
                               0L,
                               KEY_READ,
                               &g_hKeyFalcon);
        }
    }
    ASSERT(rc == ERROR_SUCCESS);

    return rc;
}

/*=============================================================

  FUNCTION:  GetValueKey

  the function returns an handle to open key and the value name.
  If the use value name contains a sub key, it create/open it and returns
  an handle to the subkey; otherwise an handel to Falcon key is returned.

  PARAMETERS:
     pszValueName - Input, user value name. can contain a sub key

     pszValue - pointer to null terminated string contains the value name.

     hKey - pointer to key handle

================================================================*/

LONG GetValueKey(IN LPCTSTR pszValueName,
                 OUT LPCTSTR* lplpszValue,
                 OUT HKEY* phKey)
{
    *lplpszValue = pszValueName;
    LONG rc = ERROR_SUCCESS;

    //
    // Open Falcon key, if it hasn't opened yet.
    //
    if (g_hKeyFalcon == NULL)
    {
        rc = OpenFalconKey();
        if ( rc != ERROR_SUCCESS)
        {
            return rc;
        }
    }

    *phKey = g_hKeyFalcon;

    // look for a sub key
    LPCWSTR lpcsTemp = wcschr(pszValueName,L'\\');
    if (lpcsTemp != NULL)
    {
        // Sub key is exist
        DWORD dwDisposition;

        // update the return val
        *lplpszValue = lpcsTemp +1;

        AP<WCHAR> KeyName = new WCHAR[(lpcsTemp - pszValueName) + 1];
        wcsncpy(KeyName, pszValueName, (lpcsTemp - pszValueName));
        KeyName[(lpcsTemp - pszValueName)] = L'\0';

        // Check if the key already opened
        if (!s_MapName2Handle.Lookup(KeyName, *phKey))
        {
            rc = RegCreateKeyEx (g_hKeyFalcon,
                               KeyName,
                               0L,
                               L"",
                               REG_OPTION_NON_VOLATILE,
                               KEY_READ | KEY_WRITE,
                               NULL,
                               phKey,
                               &dwDisposition);

            if (rc != ERROR_SUCCESS)
            {
                rc = RegCreateKeyEx (g_hKeyFalcon,
                                   KeyName,
                                   0L,
                                   L"",
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_READ,
                                   NULL,
                                   phKey,
                                   &dwDisposition);
            }

            if (rc == ERROR_SUCCESS)
            {
                // save the handle in hash
                s_MapName2Handle[KeyName] = *phKey;
                KeyName.detach();
            }
            else
            {
                ASSERT(0);
            }
        }
    }

    return rc;

}

//-------------------------------------------------------
//
//  GetFalconKey
//
//-------------------------------------------------------

LONG
GetFalconKey(LPCWSTR  pszKeyName,
             HKEY *phKey)
{
    AP<WCHAR> szValueKey = new WCHAR[wcslen(pszKeyName) + 2];
    LPCWSTR szValue;

    wcscat(wcscpy(szValueKey, pszKeyName), TEXT("\\"));
    return GetValueKey(szValueKey, &szValue, phKey);
}

//-------------------------------------------------------
//
//  GetFalconKeyValue
//
//-------------------------------------------------------

LONG 
GetFalconKeyValue(
    LPCTSTR pszValueName,
    PDWORD  pdwType,
    PVOID   pData,
    PDWORD  pdwSize,
    LPCTSTR pszDefValue
    )
{
    //
    // NOTE: registry routines in mqutil do not provide
    // thread or other synchronization. If you change
    // implementation here, carefully verify that
    // registry routines in mqutil's clients are not
    // broken, especially the wrapper routines in
    // mqclus.dll  (ShaiK, 19-Apr-1999)
    //

    LONG rc;
    HKEY hKey;
    LPCWSTR lpcsValName;

    ASSERT(pdwSize != NULL);

    rc = GetValueKey(pszValueName, &lpcsValName, &hKey);
    if ( rc != ERROR_SUCCESS)
    {
        return rc;
    }

    DWORD dwTempType;
    DWORD *pdwTempType = &dwTempType;

    dwTempType = (pdwType == NULL) ? 0 : *pdwType;


    {
        rc = RegQueryValueEx( hKey,
                          lpcsValName,
                          0L,
                          pdwTempType,
                          static_cast<BYTE*>(pData),
                          pdwSize ) ;
    }

    if ((rc != ERROR_SUCCESS) && pszDefValue)
    {
       if ((rc != ERROR_MORE_DATA) && pdwType && (*pdwType == REG_SZ))
       {
          // Don't use the default if caller buffer was too small for
          // value in registry.
          if ((DWORD) wcslen(pszDefValue) < *pdwSize)
          {
             wcscpy((WCHAR*) pData, pszDefValue) ;
             rc = ERROR_SUCCESS ;
          }
       }
       if (*pdwType == REG_DWORD)
       {
          *((DWORD *)pData) = *((DWORD *) pszDefValue) ;
          rc = ERROR_SUCCESS ;
       }
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#define _REPORT_H_

#include <_stdh.h>


#include <stdio.h>

// TODO: reference additional headers your program requires here

#include <winsock.h>
#include "mqsocket.h"
#include "_mqini.h"
#include "mqsymbls.h"
#include "myreg.h"
#include "qmutil.h"
#include "_ta.h"
#include "main.h"
#include "..\\base\\base.h"

#include <winsock.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\dc.cpp ===
// MQState tool reports general status and helps to diagnose simple problems
// This file ...
//
// AlexDad, March 2000
// 

#include "stdafx.h"
#include "_mqini.h"

BOOL VerifyDC(MQSTATE * /* MqState */)
{
	BOOL fSuccess = TRUE;

	
	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	connect.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\sessmgr.h ===
/*++
	from qm\sessmgr.cpp
--*/
#ifndef __SESSIONMGR_H__
#define __SESSIONMGR_H__

class CAddressList : public CList<TA_ADDRESS*, TA_ADDRESS*&> {/**/};

class CSessionMgr
{
    public:

        CSessionMgr();
        ~CSessionMgr();

        HRESULT Init();
        void    BeginAccept();

        HRESULT TryConnect(CAddressList *pal);

        void    AcceptSockSession(IN TA_ADDRESS *pa, IN SOCKET sock);

        const   CAddressList* GetIPAddressList(void);

        void    NetworkConnection(BOOL fConnected);

        static HANDLE m_hAcceptAllowed;

        static BOOL  m_fUsePing;

    private:           //Private Methods

        static void IPInit(void);

    private:         // Private Data Member

        //
        // List of opened sessions
        //
        CList<CTransportBase*, CTransportBase*&>         m_listSess;

        CAddressList*    m_pIP_Address;   // List of machine IP Address

};

#endif __SESSIONMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\session.h ===
struct _QMOV_WriteSession;
struct _QMOV_ReadSession;

class CTransportBase
{
    public:
        CTransportBase();
        ~CTransportBase();

	HRESULT CreateConnection(
		    IN const TA_ADDRESS* pa,
			BOOL fQuick = TRUE);

    void Connect(IN TA_ADDRESS *pAddr, IN SOCKET sock);
    void CloseConnection(LPCWSTR);
    void SetSessionAddress(const TA_ADDRESS*);
    LPCWSTR GetStrAddr(void) const;
    bool BindToFirstIpAddress(VOID);
	HRESULT NewSession(void);
	HRESULT BeginReceive();
    const TA_ADDRESS* GetSessionAddress(void) const;
    HRESULT CreateSendRequest(PVOID          lpReleaseBuffer,
                              PVOID          lpWriteBuffer,
                              DWORD          dwWriteSize
                            );
    HRESULT SendEstablishConnectionPacket();
    HRESULT WriteToSocket(_QMOV_WriteSession*  po);
    void ReadCompleted(IN DWORD         fdwError,          // completion code
                       IN DWORD         cbTransferred,     // number of bytes transferred
                       IN _QMOV_ReadSession*  po);         // address of structure with I/O information
    void WriteCompleted(IN DWORD         fdwError,          // completion code
                        IN DWORD         cbTransferred,     // number of bytes transferred
                        IN _QMOV_WriteSession*  po);         // address of structure with I/O information

    HRESULT Send(char *str);  // testing probe

	private: 
        SOCKET			m_sock;                 // Connected socket
        TA_ADDRESS*     m_pAddr;                // TA_ADDRESS format address
        WCHAR           m_lpcsStrAddr[50];
        USHORT			m_uPort;                // Conection port
        BOOL			m_fOtherSideServer;     // True if the other side of the connection
								                // is MSMQ server

};

typedef
VOID
(WINAPI *LPWRITE_COMPLETION_ROUTINE)(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    struct _QMOV_WriteSession* lpOverlapped
);

typedef
HRESULT
(WINAPI *LPREAD_COMPLETION_ROUTINE)(
    struct _QMOV_ReadSession* po
);


extern void TA2StringAddr(IN const TA_ADDRESS *pa, OUT LPTSTR pString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqsock\sessmgr.cpp ===
/*++
	sessmgr.cpp
--*/


#include "stdafx.h"

#include "session.h"
#include "sessmgr.h"
#include "ping.h"

//
// Extern variables
//
extern CSessionMgr SessionMgr;
extern char *szRequest;


HANDLE CSessionMgr::m_hAcceptAllowed = NULL;
BOOL   CSessionMgr::m_fUsePing = TRUE;

BOOL g_fTcpNoDelay = FALSE;

#define MAX_ADDRESS_SIZE 16

bool IsLocalSystemCluster(VOID);
CAddressList* GetIPAddresses(void);


STATIC void AcceptIPThread(DWORD)
{

    SOCKADDR_IN acc_sin;
    int acc_sin_len = sizeof(acc_sin);
    SOCKET RcvSock;

    char buff[TA_ADDRESS_SIZE + IP_ADDRESS_LEN];
    TA_ADDRESS* pa = (TA_ADDRESS*)&buff[0];

    for(;;)
    {
        try
        {
            GoingTo(L"accept from socket 0x%x",  g_sockListen);

            RcvSock = accept( g_sockListen, (struct sockaddr FAR *)&acc_sin,
                            (int FAR *) &acc_sin_len );

            ASSERT(RcvSock != NULL);
            if (RcvSock == INVALID_SOCKET)
            {
                DWORD rc = WSAGetLastError();
                Warning(TEXT("IP accept failed, WSAGetLastError=%d"),rc);
                continue;
            }
            else
            {
                Succeeded(L"accept from socket 0x%x",  g_sockListen);
            }

            //
            // If the machine is in disconnected state, don't accept the incoming
            // connection.
            //
            DWORD dwResult = WaitForSingleObject(CSessionMgr::m_hAcceptAllowed, INFINITE);
            if (dwResult != WAIT_OBJECT_0)
            {
                Warning(L"Invalid result of wait for socket accept: 0x%x", dwResult);
            }

            //
            // Build a TA format address
            //
            pa->AddressLength = IP_ADDRESS_LEN;
            pa->AddressType =  IP_ADDRESS_TYPE;
            * ((DWORD *)&(pa->Address)) = acc_sin.sin_addr.S_un.S_addr;

            //
            // Tell the session manager to create an Sock sesion object
            //
            SessionMgr.AcceptSockSession(pa, RcvSock);
        }
        catch(const bad_alloc&)
        {
            //
            //  No resources; accept next
            //
            Warning(L"No resources in AcceptIPThread");
        }
    }
}

void
CSessionMgr::IPInit(void)
{
    char szBuff[1000];
    DWORD dwSize;
    SOCKADDR_IN local_sin;  /* Local socket - internet style */
    DWORD  dwThreadId,rc;
    BOOL reuse = TRUE;

    GoingTo(L"create IP listen socket");

    g_sockListen = socket( AF_INET, SOCK_STREAM, 0);
    if(g_sockListen == INVALID_SOCKET)
    {
        Warning(L"Failed to create IP listen socket, err=%d", WSAGetLastError());
        return;
    }
    else
    {
        Succeeded(L"create IP listen socket 0x%x", g_sockListen);

    }

    local_sin.sin_family = AF_INET;

    dwSize = sizeof(szBuff);

    size_t res = wcstombs(szBuff, g_szMachineName, dwSize);
    DBG_USED(res);
    ASSERT(res != (size_t)(-1));


    ASSERT(g_dwIPPort);
    local_sin.sin_port = htons((USHORT) g_dwIPPort);        /* Convert to network ordering */

    // to make sure that binding to falcon port will not fail
    GoingTo(L"binding to falcon port");
    rc = setsockopt( g_sockListen, SOL_SOCKET, SO_REUSEADDR, (char *)&reuse, sizeof(reuse));
    if (rc != 0)
    {
        rc = WSAGetLastError();
        Warning(TEXT("setsocketopt for falcon port failed, rc = %d"),rc);
        return;
    }
    else
    {
        Succeeded(L"setsocketopt for falcon port");
    }

    if (IsLocalSystemCluster())
    {
        //
        // BUGBUG:
        //
        // On cluster we can not use INADDR_ANY because we will bind to
        // all addresses on the machine, including addresses in cluster
        // groups that are currently hosted on this machine.
        // We need to iterate the IP addresses and explicitly bind to each.
        // This way we are cluster-safe and do not need to know if we're on
        // cluster or not (thus our service would not depend on cluster service).
        // That means listenning on a different socket for each IP address.
        // This is too risky / complex at this point, so on cluster we bind
        // only to one IP address.  (ShaiK, 26-Apr-1999)
        //
        PHOSTENT phe;

        GoingTo(L"gethostbyname(%S)", szBuff);

        phe = gethostbyname(szBuff);
        ASSERT(("must have an IP address", NULL != phe));
        if(NULL != phe)
        {
            Succeeded(L"gethostbyname(%S) in IPInit: %S", szBuff,
                    inet_ntoa(*(struct in_addr *)phe->h_addr_list[0]));
        }
        else
        {
            Warning(L"Failed gethostbyname(%S), err=%d", szBuff, WSAGetLastError());
        }

        memcpy(&local_sin.sin_addr.s_addr, phe->h_addr_list[0], IP_ADDRESS_LEN);
    }
    else
    {
        //
        //  Bind to all IP addresses
        //
        local_sin.sin_addr.s_addr = INADDR_ANY;
    }

    GoingTo(L"bind to listensock 0x%x", g_sockListen);

    rc = bind( g_sockListen, (struct sockaddr FAR *) &local_sin, sizeof(local_sin));
    if (rc != 0)
    {
        Warning(L"bind to listen sock 0x%x failed, rc = %d",g_sockListen, WSAGetLastError());
        return;
    }
    else
    {
        Succeeded(L"bind to listensock 0x%x", g_sockListen);
    }


    GoingTo(L"listen for the socket 0x%x", g_sockListen);

    rc = listen( g_sockListen, 5 ); // 5 is the maximum allowed length the queue of pending connections may grow
    if (rc != 0)
    {
        Warning(L"Listen failed, rc = %d",WSAGetLastError());
        return;
    }
    else
    {
        Succeeded(L"listen for the socket 0x%x", g_sockListen);
    }

    DebugMsg(L"Going to create AcceptIPThread");
    HANDLE hThread = NULL;
    hThread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)AcceptIPThread,
                    NULL,
                    0,
                    &dwThreadId
                    );

    if (hThread == NULL)
    {
        Warning(L"Failed Create AcceptIPThread, err=0x%x", GetLastError());
    }
    else
    {
		Inform(L"AcceptIPThread is t%3x", dwThreadId);
    }
    CloseHandle(hThread);
}





/*====================================================

CSessionMgr::BeginAccept

Arguments:

Return Value:

Thread Context: Main

=====================================================*/
void CSessionMgr::BeginAccept()
{

    StartPingServer();
    StartPingClient();

    //
    // Init various protocols
    //
    m_pIP_Address = GetIPAddresses();

    //
    // In WIN95/SP4 RAS, it is possible that the list is empty
    // if we are currently offline, and the IP RAS addresses are released.
    // However later we may dial.
    // We want to have an accept thread on IP even if the list is empty.
    //
    IPInit();
}





/********************************************************************************/
/*           I P     H E L P E R     R O U T I N E S                            */
/********************************************************************************/

/*====================================================

CSessionMgr::CSessionMgr  - Constructor

Arguments:

Return Value:

=====================================================*/
CSessionMgr::CSessionMgr() :
    m_pIP_Address(NULL)
{
    m_hAcceptAllowed = CreateEvent(NULL, TRUE, TRUE, NULL);
}

/*====================================================

CSessionMgr::~CSessionMgr

arguments:

Return Value:

=====================================================*/
CSessionMgr::~CSessionMgr()
{
    POSITION        pos;
    TA_ADDRESS*     pAddr;

    if (m_pIP_Address)
    {
       pos = m_pIP_Address->GetHeadPosition();
       while(pos != NULL)
       {
           pAddr = m_pIP_Address->GetNext(pos);
           delete pAddr;
       }
       m_pIP_Address->RemoveAll();

       delete m_pIP_Address;
    }
}

/*====================================================

CSessionMgr::Init

Arguments:

Return Value:

Thread Context: Main

=====================================================*/

HRESULT CSessionMgr::Init()
{
    //
    // use ping mechanism
    //
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
    DWORD dwUsePing;

    HRESULT rc = GetFalconKeyValue(FALCON_USING_PING_REGNAME,
                           &dwType,
                           &dwUsePing,
                           &dwSize
                          );
    if  ((rc != ERROR_SUCCESS) || (dwUsePing != 0))
    {
        m_fUsePing = TRUE;
    }
    else
    {
        m_fUsePing = FALSE;
    }

	//
	// Use TCP_NODELAY socket option flag
	//
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    DWORD dwNoDelay = 0;

    rc = GetFalconKeyValue(
			MSMQ_TCP_NODELAY_REGNAME,
            &dwType,
            &dwNoDelay,
            &dwSize
            );

    if((rc == ERROR_SUCCESS) && (dwNoDelay != 0))
    {
        g_fTcpNoDelay = TRUE;
    }
    else
    {
        g_fTcpNoDelay = FALSE;
    }

    return(MQ_OK);
}



/*====================================================

CSessionMgr::TryConnect

Arguments:

Return Value:

Check if there are some waiting sessions, and try to connect
to them

Thread Context: Scheduler

=====================================================*/
HRESULT CSessionMgr::TryConnect(CAddressList *pal)
{
    TA_ADDRESS *pa;
    POSITION pos;
    HRESULT hr = MQ_OK;

    //
    // Enumerate all addresses
    //
    pos = pal->GetHeadPosition();
    while(pos != NULL)
    {
        pa = pal->GetNext(pos);

        //
        // And try to open a session with every address
        //
        CTransportBase *pSess = new CTransportBase();
        hr = pSess->CreateConnection(pa);
        if(SUCCEEDED(hr))
        {
            // Start testing protocol
            hr = pSess->Send(szRequest);
        }

        //
        // Close session
        //
        delete pSess;
    }

    return hr;
}

/*====================================================

CSessionMgr::AcceptSockSession

Arguments:

Return Value:

Called when a Sock connection was accepted.

=====================================================*/
void CSessionMgr::AcceptSockSession(IN TA_ADDRESS *pa,
                                    IN SOCKET sock)
{
    ASSERT(pa != NULL);

    //
    // Create a new session
    //
    CTransportBase* pSess = new CTransportBase;

    //
    // And pass to the session object
    //
    pSess->Connect(pa, sock);

    //
    // Notify of a newly created session
    //
    pSess->NewSession();
}


/*======================================================

   FUNCTION: CSessionMgr::GetIPAddressList

========================================================*/
const CAddressList*
CSessionMgr::GetIPAddressList(void)
{
    return m_pIP_Address;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\dssec.cpp ===
// MQState tool reports general status and helps to diagnose simple problems
// This file ...
//
// AlexDad, March 2000
// 

#include "stdafx.h"
#include "_mqini.h"

BOOL VerifyDsSecurity(MQSTATE * /* MqState */)
{
	BOOL fSuccess = TRUE;

	
	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\dsconn.cpp ===
// MQState tool reports general status and helps to diagnose simple problems
// This file ...
//
// AlexDad, March 2000
// 

#include "stdafx.h"
#include "_mqini.h"

BOOL VerifyDsConnection(MQSTATE * /* MqState */)
{
	BOOL fSuccess = TRUE;

	
	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\domstate.cpp ===
// MQState tool reports general status and helps to diagnose simple problems
// This file ...
//
// AlexDad, March 2000
// 

#include "stdafx.h"
#include "_mqini.h"
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <lmjoin.h>

//-	Machine in domain or workgroup (compare to registry setting and join status)
	

BOOL VerifyDomainState(MQSTATE * /* MqState */)
{
	BOOL fSuccess = TRUE;


	// join status
	//
	LPWSTR pNameBuffer;
	NETSETUP_JOIN_STATUS  join_status;

	NET_API_STATUS status = NetGetJoinInformation( NULL,   &pNameBuffer, &join_status);
	if (status == NERR_Success)
	{
		switch (join_status)
		{
		case NetSetupUnjoined:
			Inform(L"\tThe computer is not joined neither to domain nor to a workgroup");
			break;
		case NetSetupWorkgroupName:
			Inform(L"\tThe computer is joined to workgroup %s", pNameBuffer);
			break;
		case NetSetupDomainName:
			Inform(L"\tThe computer is joined to domain %s", pNameBuffer);
			break;
		case NetSetupUnknownStatus:
		default:
			Warning(L"\tThe join status of this computer is unknown");
			break;
		}
		NetApiBufferFree( pNameBuffer);
	}
	else
	{
		Failed(L"NetGetJoinInformation: 0x%x ", GetLastError());
	}



	
	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\diskusage.cpp ===
// MQState tool reports general status and helps to diagnose simple problems
// This file ...
//
// AlexDad, March 2000
// 

#include "stdafx.h"
#include "_mqini.h"

#include "..\array.h"

// memory reporting stuff

// Use to change the divisor from Kb to Mb.
#define DIV 1024
static char *divisor = "K";
#define WIDTH 7


// List of all known files
//
CArr mapfiles;

// FROM inc\Acdef.h
//
//  Number of pools used for storage
//  Reliable, Persistant, Journal, Deadletter
//
enum ACPoolType {
    ptReliable,
    ptPersistent,
    ptJournal,
    ptLastPool
};

//
//  Path count is pool count plus one for the log path
//
#define AC_PATH_COUNT (ptLastPool + 1)

BOOL GatherLocationsFromRegistry(MQSTATE *pMqState)
{
	BOOL fSuccess = TRUE;
    HRESULT rc;
    DWORD dwType = REG_SZ, dwSize;

    // Get the path for persistent messages
    dwSize = sizeof(pMqState->g_tszPathPersistent);
    rc = GetFalconKeyValue(MSMQ_STORE_PERSISTENT_PATH_REGNAME,&dwType,pMqState->g_tszPathPersistent,&dwSize);
    if(rc != ERROR_SUCCESS)
	{
		fSuccess = FALSE;
		Failed(L"get from registry persistent storage location, rc=0x%x", rc);
	}
	else
	{
		Succeeded(L"Storage location - persistent data : %s (set by %s)", 
			   pMqState->g_tszPathPersistent, MSMQ_STORE_PERSISTENT_PATH_REGNAME);
	}

    // Get the path for journal messages.
    dwSize = sizeof(pMqState->g_tszPathJournal);
    rc = GetFalconKeyValue(MSMQ_STORE_JOURNAL_PATH_REGNAME,&dwType,pMqState->g_tszPathJournal,&dwSize);
    if(rc != ERROR_SUCCESS)
	{
		fSuccess = FALSE;
		Failed(L"get from registry journal storage location, rc=0x%x", rc);
	}
	else
	{
		Succeeded(L"Storage location - journal data    : %s (set by %s)", 
			   pMqState->g_tszPathJournal, MSMQ_STORE_JOURNAL_PATH_REGNAME);
	}

    // Get the path for  reliable messages.
    dwSize = sizeof(pMqState->g_tszPathReliable);
    rc = GetFalconKeyValue(MSMQ_STORE_RELIABLE_PATH_REGNAME,&dwType,pMqState->g_tszPathReliable,&dwSize);
    if(rc != ERROR_SUCCESS)
	{
		fSuccess = FALSE;
		Failed(L"get from registry express storage location, rc=0x%x", rc);
	}
	else
	{
		Succeeded(L"Storage location - express data    : %s (set by %s)", 
			   pMqState->g_tszPathReliable, MSMQ_STORE_RELIABLE_PATH_REGNAME);
	}

    // Get the path for bitmap files.
    dwSize = sizeof(pMqState->g_tszPathBitmap);
    rc = GetFalconKeyValue(MSMQ_STORE_LOG_PATH_REGNAME,&dwType,pMqState->g_tszPathBitmap,&dwSize);
    if(rc != ERROR_SUCCESS)
	{
		fSuccess = FALSE;
		Failed(L"get from registry bitmal storage location, rc=0x%x", rc);
	}
	else
	{
		Succeeded(L"Storage location - bitmaps data    : %s (set by %s)", 
			   pMqState->g_tszPathBitmap, MSMQ_STORE_LOG_PATH_REGNAME);
	}

    // Get the path for transaction files.
    dwSize = sizeof(pMqState->g_tszPathXactLog);
    rc = GetFalconKeyValue(FALCON_XACTFILE_PATH_REGNAME,&dwType,pMqState->g_tszPathXactLog,&dwSize);
    if(rc != ERROR_SUCCESS)
	{
		fSuccess = FALSE;
		Failed(L"get from registry transactional storage location, rc=0x%x", rc);
	}
	else
	{
		Succeeded(L"Storage location - xact log data   : %s (set by %s)", 
			   pMqState->g_tszPathXactLog, FALCON_XACTFILE_PATH_REGNAME);
	}

	return fSuccess;
}


BOOL LookForExtraFiles(LPWSTR pwsPath)
{
	BOOL fSuccess = TRUE;
	WCHAR wszPattern[MAX_PATH+3];

	wcscpy(wszPattern, pwsPath); 
	wcscat(wszPattern, L"\\*.*"); 

	WCHAR *pN = wcsrchr( wszPattern, L'\\');

    HANDLE hEnum;
    WIN32_FIND_DATA FileData;
    hEnum = FindFirstFile(
                wszPattern,
                &FileData
                );

    if(hEnum == INVALID_HANDLE_VALUE)
	{
		// no extras
        return fSuccess;
	}

    do
    {
		if (wcscmp(L".",   FileData.cFileName)==0  || 
			wcscmp(L"..",  FileData.cFileName)==0  ||
			_wcsicmp(L"LQS", FileData.cFileName)==0    )
		{
			continue;
		}

        wcscpy(pN+1, FileData.cFileName);

		WIN32_FIND_DATA KnownFileData;
		if(mapfiles.Lookup( wszPattern, &KnownFileData )) 
		{
			// This file is known, no problem
		}
		else
		{
			fSuccess = FALSE;
			Warning(L"Extra file found: %s", wszPattern);
		}



    } while(FindNextFile(hEnum, &FileData));

    FindClose(hEnum);
	return fSuccess;
}



BOOL CheckForExtraFiles(MQSTATE *pMqState)
{
	BOOL fSuccess = TRUE, b;

	// Persistent location
	b = LookForExtraFiles(pMqState->g_tszPathPersistent);
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"make sure that there are no extra files in Persistent location");
	}
	else
	{
		Succeeded(L"No extra files in the Persistent location");
	}

	// Journal location
	if (wcscmp(pMqState->g_tszPathJournal, pMqState->g_tszPathPersistent)!=0)
	{
		b = LookForExtraFiles(pMqState->g_tszPathJournal);
		if(!b)
		{
			fSuccess = FALSE;
			Failed(L"make sure that there are no extra files in journal location");
		}
		else
		{
			Succeeded(L"No extra files in the journal location");
		}
	}


	// Reliable location
	if (wcscmp(pMqState->g_tszPathReliable, pMqState->g_tszPathPersistent)!=0 &&
		wcscmp(pMqState->g_tszPathReliable, pMqState->g_tszPathJournal)!=0)
	{
		b = LookForExtraFiles(pMqState->g_tszPathReliable);
		if(!b)
		{
			fSuccess = FALSE;
			Failed(L"make sure that there are no extra files in reliable location");
		}
		else
		{
			Succeeded(L"No extra files in the reliable location");
		}
	}

	// Bitmap location
	if (wcscmp(pMqState->g_tszPathBitmap, pMqState->g_tszPathPersistent)!=0 &&
		wcscmp(pMqState->g_tszPathBitmap, pMqState->g_tszPathJournal)!=0    &&
		wcscmp(pMqState->g_tszPathBitmap, pMqState->g_tszPathReliable)!=0)
	{
		b = LookForExtraFiles(pMqState->g_tszPathBitmap);
		if(!b)
		{
			fSuccess = FALSE;
			Failed(L"make sure that there are no extra files in bitmap location");
		}
		else
		{
			Succeeded(L"No extra files in the bitmap location");
		}
	}

	// Xact location
	if (wcscmp(pMqState->g_tszPathXactLog, pMqState->g_tszPathPersistent)!=0 &&
		wcscmp(pMqState->g_tszPathXactLog, pMqState->g_tszPathJournal)!=0    &&
		wcscmp(pMqState->g_tszPathXactLog, pMqState->g_tszPathBitmap)!=0    &&
		wcscmp(pMqState->g_tszPathXactLog, pMqState->g_tszPathReliable)!=0)
	{
		b = LookForExtraFiles(pMqState->g_tszPathXactLog);
		if(!b)
		{
			fSuccess = FALSE;
			Failed(L"make sure that there are no extra files in transactional location");
		}
		else
		{
			Succeeded(L"No extra files in the transactional location");
		}
	}

	return fSuccess;
}

BOOL ReviewFile(WIN32_FIND_DATAW *pDataParam, PWSTR pEPath, ULONG ulLen)
{
	BOOL fSuccess = TRUE;
	WCHAR wszPath[MAX_PATH+1];
	WIN32_FIND_DATAW Data;
	WIN32_FIND_DATAW *pData = &Data;

	if (pDataParam)
	{
		pData = pDataParam;
	}
	else
	{
		HANDLE hLogEnum = FindFirstFile(pEPath, pData);

		if(hLogEnum == INVALID_HANDLE_VALUE)
		{
			Failed(L"get data about the file %s, err=0x%x", pEPath, GetLastError());
			return FALSE;
		}
		FindClose(hLogEnum);
	}

	wcscpy(wszPath, pEPath);
    
	WCHAR *pN = wcsrchr( wszPath, L'\\');
	if (pN)
	{
		wcscpy(pN+1, pData->cFileName);
	}
	else
	{
		Failed(L"form file name");
	}

	if (ulLen == 0)
	{
		ulLen = pData->nFileSizeLow;  // using actual length
	}

	if (pData->nFileSizeLow != ulLen)
	{
		fSuccess = FALSE;
		Failed(L" verify the file %s : it has a wrong length 0x%x  0x%x", 
			   pData->cFileName, pData->nFileSizeHigh, pData->nFileSizeLow);
	}

	mapfiles.Keep(wszPath, pData);

	SYSTEMTIME stCreation, stAccess, stWrite;
	FileTimeToSystemTime(&pData->ftCreationTime,   &stCreation);
	FileTimeToSystemTime(&pData->ftLastAccessTime, &stAccess);
	FileTimeToSystemTime(&pData->ftLastWriteTime,  &stWrite);

    Succeeded(L"read %s:  Created at %d:%d:%d %d/%d/%d, Last written at %d:%d:%d %d/%d/%d,  Last accessed at  %d:%d:%d %d/%d/%d",
	     pData->cFileName, 
		 stCreation.wHour,	stCreation.wMinute, stCreation.wSecond, stCreation.wDay,stCreation.wMonth,	stCreation.wYear,      
	     stWrite.wHour,		stWrite.wMinute,	stWrite.wSecond,	stWrite.wDay,	stWrite.wMonth,		stWrite.wYear,      
	     stAccess.wHour,	stAccess.wMinute,	stAccess.wSecond,	stAccess.wDay,	stAccess.wMonth,	stAccess.wYear);    

	return fSuccess;
}

// from qm\recovery.cpp

inline PWSTR PathSuffix(PWSTR pPath)
{
    return wcsrchr(pPath, L'\\') + 2;
}

DWORD CheckFileName(PWSTR pPath, PWSTR pSuffix)
{
    wcscpy(PathSuffix(pPath), pSuffix);
    return GetFileAttributes(pPath);
}

DWORD GetFileID(PCWSTR pName)
{
    DWORD id = 0;
    _stscanf(pName, TEXT("%x"), &id);
    return id;
}


BOOL
LoadPacketsFile(
    PWSTR pLPath,
    PWSTR pPPath,
    PWSTR pJPath
    )
{
	BOOL b;

	PWSTR pName = PathSuffix(pLPath);

    DWORD dwResult;
    ACPoolType pt;
    if((dwResult = CheckFileName(pPPath, pName)) != 0xffffffff)
    {
        pName = pPPath;
        pt = ptPersistent;
		Succeeded(L"find persistent file %s", pName);
    }
    else if((dwResult = CheckFileName(pJPath, pName)) != 0xffffffff)
    {
        pName = pJPath;
        pt = ptJournal;
		Succeeded(L"find journal file %s", pName);
    }
    else
    {
        //
        //  Error condition we got a log file with no packet file
        //
        //DeleteFile(pLPath);
		Failed(L"find persistent or journal data file for the bitmap %s - bitmap will be deleted at recovery",  pLPath);
        return FALSE;
    }

    // rc = ACRestorePackets(g_hAc, pLPath, pName, dwFileID, pt);

	b = ReviewFile(NULL, pName, 0x400000);
	if (!b)
	{
		Failed(L"verify file %s", pName);
	}

	return b;
}

/*======================================================
Function:        GetRegistryStoragePath
Description:     Get storage path for Falcon data
========================================================*/
BOOL GetRegistryStoragePath(PCWSTR pKey, PWSTR pPath, PCWSTR pSuffix)
{
	GoingTo(L"GetRegistryStoragePath for %s (suffix %s)", pKey, pSuffix);

    DWORD dwValueType = REG_SZ ;
    DWORD dwValueSize = MAX_PATH;

    LONG rc;
    rc = GetFalconKeyValue(
            pKey,
            &dwValueType,
            pPath,
            &dwValueSize
            );

    if(rc != ERROR_SUCCESS)
    {
		Failed(L"GetFalconKeyValue for %s", pKey);
        return FALSE;
    }

    if(dwValueSize < (3 * sizeof(WCHAR)))
    {
		Failed(L"Too short vaue for %s: len=%d, val=%s", pKey, dwValueSize, pPath);
        return FALSE;
    }

    //
    //  Check for absolute path, drive or UNC
    //
    if(!(
        (isalpha(pPath[0]) && (pPath[1] == L':')) ||
        ((pPath[0] == L'\\') && (pPath[1] == L'\\'))
        ))
    {
		Failed(L"Invalid syntax for %s: val=%s", pKey, pPath);
        return FALSE;
    }

    wcscat(pPath, pSuffix);
	Succeeded(L"GetRegistryStoragePath: value is %s", pPath);
    return TRUE;
}

/*======================================================
Function:        GetStoragePath
Description:     Get storage path for mmf
========================================================*/
BOOL GetStoragePath(PWSTR PathPointers[AC_PATH_COUNT])
{
	GoingTo(L"Get Storage Path - in the same wway as QM will do at recovery");

    return (
        //
        //  This first one is a hack to verify that the registry key exists
        //
        GetRegistryStoragePath(FALCON_XACTFILE_PATH_REGNAME,        PathPointers[0], L"") &&

        GetRegistryStoragePath(MSMQ_STORE_RELIABLE_PATH_REGNAME,    PathPointers[0], L"\\r%07x.mq") &&
        GetRegistryStoragePath(MSMQ_STORE_PERSISTENT_PATH_REGNAME,  PathPointers[1], L"\\p%07x.mq") &&
        GetRegistryStoragePath(MSMQ_STORE_JOURNAL_PATH_REGNAME,     PathPointers[2], L"\\j%07x.mq") &&
        GetRegistryStoragePath(MSMQ_STORE_LOG_PATH_REGNAME,         PathPointers[3], L"\\l%07x.mq")
        );
}


BOOL DeleteExpressFiles(PWSTR pEPath)
{
	BOOL fSuccess = TRUE;

	GoingTo(L"Verify all files with express messages - they will be deleted by recovery");

    PWSTR pEName = PathSuffix(pEPath);
    wcscpy(pEName, L"*.mq");
    --pEName;

    HANDLE hEnum;
    WIN32_FIND_DATA ExpressFileData;
    hEnum = FindFirstFile(
                pEPath,
                &ExpressFileData
                );

    if(hEnum == INVALID_HANDLE_VALUE)
	{
		Succeeded(L"see - no express files");
        return TRUE;
	}

    do
    {
        wcscpy(pEName, ExpressFileData.cFileName);
		Succeeded(L"\texpress file %s will be deleted by the next QM recovery", pEName);

		// Add the file to the map
		//LPWSTR p = new WCHAR(wcslen(pEName)+1);
		//wcscpy(p, pEName);

		WIN32_FIND_DATAW *pData = new WIN32_FIND_DATAW;
		*pData = ExpressFileData;

		BOOL b = ReviewFile(pData, pEPath, 0x400000);
		if (!b)
		{
			fSuccess = b;
			Failed(L"Read the file %s of the length 0x%x", pEPath, ExpressFileData.nFileSizeLow);
		}
		else
		{
			Succeeded(L"Read the file %s of the length 0x%x", pEPath, ExpressFileData.nFileSizeLow);
		}

        //if(!DeleteFile(pEPath))
        //    break;

    } while(FindNextFile(hEnum, &ExpressFileData));

    FindClose(hEnum);

	Succeeded(L"No more express files");

	return fSuccess;
}



BOOL LoadPersistentPackets()
{
	BOOL fSuccess = TRUE;
	GoingTo(L"Pass over all message files");
	

    WCHAR StoragePath[AC_PATH_COUNT][MAX_PATH];
    PWSTR StoragePathPointers[AC_PATH_COUNT];
    for(int i = 0; i < AC_PATH_COUNT; i++)
    {
        StoragePathPointers[i] = StoragePath[i];
    }

    BOOL b = GetStoragePath(StoragePathPointers);
	if (b)
	{
		Succeeded(L"GetStoragePath");
	}
	else
	{
		fSuccess = b;
		Failed(L"GetStoragePath");
	}

	// Find and verify all wxpress message files
	// Be quite: it will not delete actually here
    b = DeleteExpressFiles(StoragePath[0]);
	if (!b) 
	{
		fSuccess = b;
	}
	else
	{
		Succeeded(L"verify express files");
	}




    PWSTR pPPath = StoragePath[1];
    PWSTR pJPath = StoragePath[2];
    PWSTR pLPath = StoragePath[3];

    PWSTR pLogName = PathSuffix(pLPath);
    wcscpy(pLogName, L"*.mq");
    --pLogName;

    //
    //  Ok now we are ready with the log path template
    //
    HANDLE hLogEnum;
    WIN32_FIND_DATA LogFileData;
    hLogEnum = FindFirstFile(
                pLPath,
                &LogFileData
                );

    if(hLogEnum == INVALID_HANDLE_VALUE)
    {
        //
        //  need to do something, check what happen if no file in directory
        //
		Failed(L"to find any bitmap files - it seems strange");
        return fSuccess;
    }

    do
    {
		b = ReviewFile(&LogFileData, pLPath, 8192);
		if (!b)
		{
			Failed(L"verify file %s", pLPath);
		}
   
        wcscpy(pLogName, LogFileData.cFileName);
		GoingTo(L"Verify bitmap file %s", pLogName);

		BOOL b = LoadPacketsFile(pLPath, pPPath, pJPath);
        if (!b)
        {
			fSuccess = FALSE;
            break;
        }

    } while(FindNextFile(hLogEnum, &LogFileData));

    FindClose(hLogEnum);
    return fSuccess;
}

BOOL ReviewXactStateFiles(MQSTATE *pMqState)
{
	BOOL fSuccess = TRUE, b;
	GoingTo(L"Pass over all xact state files");
	

	WCHAR wszPath[MAX_PATH], 	wszPath2[MAX_PATH];

	wcscpy(wszPath, pMqState->g_tszPathXactLog);
	wcscat(wszPath, L"\\");
	wcscat(wszPath, L"MQTrans.lg1");
	b = ReviewFile(NULL, wszPath, 0);
	if (!b)
	{
		fSuccess = b;
		Failed(L"verify file %s", wszPath);
	}

	wcscpy(wszPath2, pMqState->g_tszPathXactLog);
	wcscat(wszPath2, L"\\");
	wcscat(wszPath2, L"MQTrans.lg2");
	b = ReviewFile(NULL, wszPath2, 0);
	if (!b)
	{
		fSuccess = b;
		Failed(L"verify file %s", wszPath2);
	}

	wcscpy(wszPath, pMqState->g_tszPathXactLog);
	wcscat(wszPath, L"\\");
	wcscat(wszPath, L"MQInSeqs.lg1");
	b = ReviewFile(NULL, wszPath, 0);
	if (!b)
	{
		fSuccess = b;
		Failed(L"verify file %s", wszPath);
	}

	wcscpy(wszPath2, pMqState->g_tszPathXactLog);
	wcscat(wszPath2, L"\\");
	wcscat(wszPath2, L"MQInSeqs.lg2");
	b = ReviewFile(NULL, wszPath2, 0);
	if (!b)
	{
		fSuccess = b;
		Failed(L"verify file %s", wszPath2);
	}

	wcscpy(wszPath, pMqState->g_tszPathXactLog);
	wcscat(wszPath, L"\\");
	wcscat(wszPath, L"QMLog");
	b = ReviewFile(NULL, wszPath, 0x600000);
	if (!b)
	{
		fSuccess = b;
		Failed(L"verify file %s", wszPath);
	}

	return fSuccess;
}

BOOL ReportDiskFreeSpace(LPWSTR wszLoc, LPWSTR wszDone) 
{
	WCHAR wszDisk[5];

	wsprintf(wszDisk, L"%c:\\", wszLoc[0]);

	if (wcsstr(wszDone, wszDisk))
	{
		return TRUE;
	}

	wcscat(wszDone, wszDisk);

	ULARGE_INTEGER	FreeBytesAvailable, TotalNumberOfBytes, TotalNumberOfFreeBytes;

	BOOL b = GetDiskFreeSpaceEx(
		wszDisk,					// directory name
		&FreeBytesAvailable,		// bytes available to caller
		&TotalNumberOfBytes,		// bytes on disk
		&TotalNumberOfFreeBytes);	// free bytes on disk
		
	if (b)
	{
		LONGLONG llkb  = TotalNumberOfFreeBytes.QuadPart / 1024;
		LONGLONG llkbu = FreeBytesAvailable.QuadPart     / 1024;
		LONGLONG llmb  = llkb  / 1024;
		LONGLONG llmbu = llkbu / 1024;

		if (llmb > 0)
		{
			Inform(L"\tDisk %s has over %I64d MB free", wszDisk, llmb);
		}
		else
		{
			Inform(L"\tDisk %s has over %I64d KB", wszDisk, llkb);
		}

		if (llkb != llkbu)
		{
			if (llmb > 0)
			{
				Inform(L"\t     but only over %I64d MB are available to the current user", llmbu);
			}
			else
			{
				Inform(L"\t     but only over %I64d KB are available to the current user", llkbu);
			}
		}
	}
	else
	{
		Failed(L"get disk %s usage data from the OS", wszDisk);
	}

	return b;
}


BOOL VerifyDiskUsage(MQSTATE *pMqState)
{
	BOOL fSuccess = TRUE, b;

	//-	total size of message store 
	//-	separately - recoverable, express, journal
	//-	Enough free space on the disk?
	//-	Enough RAM? Compare Msgs/bytes number to kernel memory limits

	b = GatherLocationsFromRegistry(pMqState);
	if (!b)
	{
		Failed(L"Get storage locations from registry");
		return FALSE;
	}

	b = LoadPersistentPackets();
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"review the storage");
	}
	else
	{
		Succeeded(L"Persistent files are healthy");
	}


	//-------------------------------------------------------------------------------
	GoingTo(L"review transactional state files health");
	//-------------------------------------------------------------------------------

	b = ReviewXactStateFiles(pMqState);
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"review the xact state files");
	}
	else
	{
		Succeeded(L"Transactional state files are healthy");
	}

	//-------------------------------------------------------------------------------
	GoingTo(L"Check for extra files in the storage locations");
	//-------------------------------------------------------------------------------
	b = CheckForExtraFiles(pMqState);
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"make sure that there are no extra files");
	}
	else
	{
		Succeeded(L"No extra files");
	}


	//-------------------------------------------------------------------------------
	GoingTo(L"Check the LQS");
	//-------------------------------------------------------------------------------
	//b = CheckLQS();
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"make sure that LQS is healthy");
	}
	else
	{
		Succeeded(L"LQS is healthy");
	}
	
	// Calculate memory usage per types
	ULONG ulPersistent     = 0,		// all P files
		  ulExpress        = 0,		// all R files		
		  ulJournal        = 0,		// all J files
		  ulBitmap         = 0,		// all L files
		  ulXact           = 0,		// qmlog and snapshot files
		  ulLQS            = 0,		// LQS files
		  ulTotal          = 0;		// all valid files in storage directories
		  //ulDiskTotal      = 0,	//    --- total of the above
		  //ulDiskFree       = 0,	// 
		  //ulPhysicalMemory = 0,	// physical RAM
		  //ulKernelMemory   = 0;	// paged pool


    LPWSTR             pwszName;
    WIN32_FIND_DATAW   *pFind_data;
    mapfiles.StartEnumeration();
    for (pwszName = mapfiles.Next(&pFind_data); pwszName != NULL; pwszName = mapfiles.Next(&pFind_data))
    {
		if (pFind_data->nFileSizeHigh != 0)
		{
			Failed(L"File %s has high size: %d", pwszName, pFind_data->nFileSizeHigh);
			fSuccess = FALSE;
		}
		
		ulTotal += pFind_data->nFileSizeLow;
		switch(towlower(pFind_data->cFileName[0]))
		{
		case L'p':
			ulPersistent += pFind_data->nFileSizeLow;
			break;
		case L'r':
			ulExpress += pFind_data->nFileSizeLow;
			break;
		case L'j':
			ulJournal += pFind_data->nFileSizeLow;
			break;
		case L'l':
			ulBitmap += pFind_data->nFileSizeLow;
			break;
		case L'm':
		case L'q':
			ulXact += pFind_data->nFileSizeLow;
			break;
		case L'0':
		case L'1':
		case L'2':
		case L'3':
		case L'4':
		case L'5':
		case L'6':
		case L'7':
		case L'8':
		case L'9':
		case L'a':
		case L'b':
		case L'c':
		case L'd':
		case L'e':
		case L'f':
			ulLQS += pFind_data->nFileSizeLow;
			break;
		default:
			fSuccess = FALSE;
			Failed(L"Unclear file in summary: %s", pFind_data->cFileName);
		}
    }

	Inform(L"Storage size summary:"); 
	Inform(L"\ttotal       %d bytes (%d MB)", ulTotal, ulTotal/0x100000); 
	Inform(L"\tpersistent  %d bytes", ulPersistent); 
	Inform(L"\tjournal     %d bytes", ulJournal); 
	Inform(L"\texpress     %d bytes", ulExpress); 
	Inform(L"\tbitmaps     %d bytes", ulBitmap); 
	Inform(L"\txact logs   %d bytes", ulXact); 
	Inform(L"\tLQS data    %d bytes", ulLQS); 


	// For all different storage locations, get disk data
	WCHAR wszDone[50]=L"";
	Inform(L"Disk usage summary: ");

	// Find the disk data for all locations
	ReportDiskFreeSpace(pMqState->g_tszPathPersistent, wszDone);
	ReportDiskFreeSpace(pMqState->g_tszPathJournal, wszDone);
	ReportDiskFreeSpace(pMqState->g_tszPathReliable, wszDone);
	ReportDiskFreeSpace(pMqState->g_tszPathBitmap, wszDone);
	ReportDiskFreeSpace(pMqState->g_tszPathXactLog, wszDone);

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\events.cpp ===
// MQState tool reports general status and helps to diagnose simple problems.
// This file dumps the system and application error events and all msmq events
//  since last reboot. Since it merely dumps the events rather than checking
//  them, it always returns TRUE.
//
// AlexDad, March 2000
// 

#include "stdafx.h"
#include "_mqini.h"

// Actual events limit 
//
extern DWORD g_cEvents;	

// Constants
//
#define BUFFER_SIZE      0x1000
#define REBOOT_EVENT       6009
#define MSMQ_OFFLINE_READY 2062
#define MSMQ_ONLINE_READY  2060
#define MSMQ_DSDC_READY    2028
#define MAX_INSERT_STRS    20

#define SYSTEM_LOG      L"System"
#define APPLICATION_LOG L"Application"

// event types 
//
typedef struct event_type_text
{	
	DWORD  dwTypeNumber;
	LPWSTR wszTypeText;
} event_type_text; 

event_type_text  evTT[] = 
{
	{ EVENTLOG_SUCCESS,			L"Success" },
	{ EVENTLOG_WARNING_TYPE,	L"Warning" },
	{ EVENTLOG_ERROR_TYPE,		L"Error" },
	{ EVENTLOG_INFORMATION_TYPE,L"Information" },
};

// event sources
//
typedef struct event_source
{
	LPWSTR wszSource;
	HINSTANCE hMsgLib;
} event_source;

#define MAX_EVT_SOURCES 100
int      g_dwEvtSources = 0;
event_source g_wszeventSources[MAX_EVT_SOURCES];

// 
// Getting handle to the event source module
//
HINSTANCE GetHLib(LPWSTR pszEventLog, LPWSTR pszSource)
{
    WCHAR                           pszTemp[MAX_PATH];
    WCHAR                           pszMsgDll[MAX_PATH];
    HKEY                            hk = NULL;
    HINSTANCE                       hLib;
    DWORD                           dwcbData;
    DWORD                           dwType;
    DWORD                           cchDest;
    DWORD                           dwRet;

    // From the event log source name, we know the name of the registry
    // key to look under for the name of the message DLL that contains
    // the messages we need to extract with FormatMessage. So first get
    // the event log source name... 
    wcscpy(pszTemp, L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\");
    wcscat(pszTemp, pszEventLog);
    wcscat(pszTemp, L"\\");
    wcscat(pszTemp, pszSource);

    // Now open this key and get the EventMessageFile value, which is
    // the name of the message DLL. 
    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, pszTemp, &hk);
    if(dwRet != ERROR_SUCCESS)
        return(NULL);

    dwcbData = MAX_PATH;
    dwRet = RegQueryValueEx(hk,    // handle of key to query        
                            L"EventMessageFile",   // value name            
                            NULL,                 // must be NULL          
                            &dwType,              // address of type value 
                            (LPBYTE) pszTemp,     // address of value data 
                            &dwcbData);           // length of value data  
    if(dwRet != ERROR_SUCCESS)
        return(NULL);

    // Expand environment variable strings in the message DLL path name,
    // in case any are there. 
    cchDest = ExpandEnvironmentStrings(pszTemp, pszMsgDll, MAX_PATH);
    if(cchDest == 0 || cchDest >= MAX_PATH)
        return(NULL);
    
    // Now we've got the message DLL name, load the DLL.
    hLib = LoadLibraryEx(pszMsgDll, NULL, LOAD_LIBRARY_AS_DATAFILE | DONT_RESOLVE_DLL_REFERENCES);
    
    RegCloseKey(hk);
    return(hLib);
}


//
//  Loading and keeping event source module
//
HINSTANCE LoadEventSourceLibrary(LPWSTR wszLog, LPWSTR wszSource)
{
	for (int i=0; i<g_dwEvtSources; i++)
	{
		if (_wcsicmp(wszSource, g_wszeventSources[i].wszSource) == NULL)
		{
			return g_wszeventSources[i].hMsgLib;
		}
	}

	if (g_dwEvtSources == MAX_EVT_SOURCES)
	{
		Failed(L"LoadEventSourceLibrary - too many sources");
		return NULL;
	}

	HINSTANCE hLib = GetHLib(wszLog, wszSource);

	g_wszeventSources[g_dwEvtSources].wszSource = new WCHAR[wcslen(wszSource)+1];
	wcscpy(g_wszeventSources[g_dwEvtSources].wszSource, wszSource);
	g_wszeventSources[g_dwEvtSources].hMsgLib = hLib;

	g_dwEvtSources++;

	return hLib;
}


//
//  Free all loaded modules
//
void ReleaseEventLibs()
{
	for (int i=0; i<g_dwEvtSources; i++)
	{
		delete [] g_wszeventSources[i].wszSource;
		FreeLibrary(g_wszeventSources[i].hMsgLib);
	}
}

//
// Report one event
//
void ReportEvent(EVENTLOGRECORD *pEvent, LPWSTR wszLog)
{
	// Find message type
	LPWSTR wszType = L"Unknown event type";
	
	for (int i=0; i<sizeof(evTT)/sizeof(event_type_text); i++)
	{
		if (evTT[i].dwTypeNumber == pEvent->EventType)
		{
			wszType = evTT[i].wszTypeText;
		}
	}

	// Find message generation time
	struct tm *generated = localtime((time_t*)&pEvent->TimeGenerated);

    // Find originator 
    LPWSTR wszSourceName = (LPWSTR) ((LPBYTE) pEvent + sizeof(EVENTLOGRECORD));
    
    Inform(L"\t%2d/%2d/%02d  %2d:%02d  %s %5d from %s", 
    		 generated->tm_mon+1, generated->tm_mday, generated->tm_year%100,
             generated->tm_hour,  generated->tm_min, 
           	 wszType, 
           	 pEvent->EventID & 0xFFFF,
             wszSourceName);

	// Find sorurce and get event string from it
	HINSTANCE hMsgLib = LoadEventSourceLibrary(wszLog, wszSourceName);
	if (hMsgLib)
	{

		// Get insert strings
		LPWSTR  ppszInsertStrs[MAX_INSERT_STRS];
	    if(pEvent->NumStrings < MAX_INSERT_STRS)
	    {
			// Compile array of pointers to the insert strings
		    LPWSTR pszTemp = (WCHAR *) ((LPBYTE) pEvent + pEvent->StringOffset);
		    for (int i = 0; i < pEvent->NumStrings; i++)
		    {
    	    	ppszInsertStrs[i] = pszTemp;
	    	    pszTemp += wcslen(pszTemp) + 1;  
	    	}
		
			// print event text with inserted strings
			WCHAR wszBuf[0x1000];
		
			DWORD dw = FormatMessage(
				  FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,		// source and processing options
				  hMsgLib,   														// message source
				  (DWORD)pEvent->EventID,  											// message identifier
				  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),					    // language identifier
				  wszBuf,    														// message buffer
				  sizeof(wszBuf),         											// maximum size of message buffer
				  (va_list *) ppszInsertStrs);  									// array of message inserts

			if (dw)
			{
				Inform(L"\t\t%s", wszBuf);
			}
		}
		
	}
}


//
// General logic of events reporting
//
BOOL VerifyEvents(MQSTATE * /* MqState */)
{
    HANDLE h;
    EVENTLOGRECORD *pEvent; 
    BYTE bBuffer[BUFFER_SIZE]; 
    DWORD dwRead, dwNeeded;
    long  lRead;
    DWORD dwRebootTime = 0,
          dwMsmqStartTime = 0,
          dwMsmqOnlineTime = 0;
    DWORD dwSysErrors = 0, 
    	  dwAppErrors = 0, 
    	  dwMsmqEvnts = 0;

	// Define how many last events do we report
	//
    // Get recent system error events and find last reboot time
    //
    h = OpenEventLog(NULL, SYSTEM_LOG);                 
    if (h == NULL)
    {
        Failed(L"open the System event log");
 		ReleaseEventLibs();
        return FALSE;
    }

 	// Cycle backwards over n-record buffers
    while (ReadEventLog(
                h,                
                EVENTLOG_BACKWARDS_READ | EVENTLOG_SEQUENTIAL_READ, 
                0,           
                bBuffer,       
                BUFFER_SIZE, 
                &dwRead,     
                &dwNeeded))  
    {
	    pEvent = (EVENTLOGRECORD *) &bBuffer; 
        
        
        // cycle backwards over records in buffer
        for(lRead = (long)dwRead;  
            lRead > 0 && (dwRebootTime == 0 || dwSysErrors < g_cEvents); 
            lRead -= pEvent->Length, 
            pEvent = (EVENTLOGRECORD *) ((LPBYTE) pEvent + pEvent->Length))
        {
            if(pEvent->EventType == EVENTLOG_ERROR_TYPE && dwSysErrors++ < g_cEvents)
            { 
            	if (dwSysErrors == 1)
            	{
				    Inform(L"  ");
            	    Inform(L"Last %d system error events:\n---------------------------  ", g_cEvents);
            	 }

            	ReportEvent(pEvent, SYSTEM_LOG);
            }           
            
	        if(dwRebootTime == 0 && ((pEvent->EventID) & 0xFFFF) == REBOOT_EVENT)
    	    {
            	ReportEvent(pEvent, SYSTEM_LOG);
            	
	            dwRebootTime = pEvent->TimeGenerated; // remember the time of the last reboot
    	    }
        }  
    }  

    CloseEventLog(h); 

    // Get recent MSMQ events.
	//    
    h = OpenEventLog(NULL, APPLICATION_LOG);       
    
    if (h == NULL)
    {
        Failed(L"open the Application event log");
		ReleaseEventLibs();
        return FALSE;
    }

	// Cycle buffers backward
    while (ReadEventLog(h,                
                EVENTLOG_BACKWARDS_READ | EVENTLOG_SEQUENTIAL_READ, 
                0,            
                bBuffer,        
                BUFFER_SIZE,  
                &dwRead,      
                &dwNeeded))   
    {
	    pEvent = (EVENTLOGRECORD *) &bBuffer; 
        

        // Cycle backwards n-record buffers
        for(lRead = (long)dwRead; 
            lRead > 0 && (dwMsmqStartTime == 0 || dwMsmqOnlineTime == 0 || (dwMsmqEvnts < g_cEvents )); 
            lRead -= pEvent->Length, 
            pEvent = (EVENTLOGRECORD *) ((LPBYTE) pEvent + pEvent->Length)) 
        {    
    	    LPWSTR wszSourceName = (LPWSTR) ((LPBYTE) pEvent + sizeof(EVENTLOGRECORD));
        	int evt = (pEvent->EventID) & 0xFFFF;
        	BOOL fMsmq  = !_wcsicmp(wszSourceName, g_tszService);
        	//BOOL fError = (pEvent->EventType == EVENTLOG_ERROR_TYPE);

        	if (!fMsmq)
        	{
        		continue;
        	}

	        if(dwMsmqStartTime == 0 && (evt == MSMQ_OFFLINE_READY || evt == MSMQ_DSDC_READY))
    	    {
	            dwMsmqStartTime = pEvent->TimeGenerated; // remember the time of the last MSMQ offline ready
    	    }

	        if(dwMsmqOnlineTime == 0 && (evt == MSMQ_ONLINE_READY || evt == MSMQ_DSDC_READY))
    	    {
	            dwMsmqOnlineTime = pEvent->TimeGenerated; // remember the time of the last MSMQ online
    	    }

           	if (dwMsmqEvnts == 0)
           	{
			    Inform(L"  ");
			    Inform(L"Last %d MSMQ events: \n------------------- ", g_cEvents);
        	}
        	
        	if (dwMsmqEvnts++ < g_cEvents)
        	{
            	ReportEvent(pEvent, APPLICATION_LOG);
            }           
            
                        
        }
    }  

    CloseEventLog(h);

    // Get recent application error events .
	//    
    h = OpenEventLog(NULL, APPLICATION_LOG);       
    
    if (h == NULL)
    {
        Failed(L"open the Application event log");
		ReleaseEventLibs();
        return FALSE;
    }

	// Cycle buffers backward
    while (ReadEventLog(h,                
                EVENTLOG_BACKWARDS_READ | EVENTLOG_SEQUENTIAL_READ, 
                0,            
                bBuffer,        
                BUFFER_SIZE,  
                &dwRead,      
                &dwNeeded))   
    {
	    pEvent = (EVENTLOGRECORD *) &bBuffer; 
        

        // Cycle backwards n-record buffers
        for(lRead = (long)dwRead; 
            lRead > 0 && (dwAppErrors < g_cEvents); 
            lRead -= pEvent->Length, 
            pEvent = (EVENTLOGRECORD *) ((LPBYTE) pEvent + pEvent->Length)) 
        {    
    	    LPWSTR wszSourceName = (LPWSTR) ((LPBYTE) pEvent + sizeof(EVENTLOGRECORD));
        	BOOL fMsmq  = !_wcsicmp(wszSourceName, g_tszService);
        	BOOL fError = (pEvent->EventType == EVENTLOG_ERROR_TYPE);
        	
			if (fMsmq || !fError)
			{
				continue;
			}

           	if (dwAppErrors++ == 0)
           	{
			    Inform(L"  ");
			    Inform(L"Last %d Application error events: \n--------------------------------- ", g_cEvents);
           	}
           	
           	ReportEvent(pEvent, APPLICATION_LOG);
        }
    }  

    CloseEventLog(h);
    Inform(L"----------------------------------------------------------------------");
    
    // Report Last reboot time
	if (dwRebootTime)
	{
		struct tm *generated = localtime((time_t*)&dwRebootTime);

    	Inform(L"\tLast system reboot:\t\t\t%2d/%2d/%02d  %2d:%02d ", 
    			 generated->tm_mon+1, generated->tm_mday, generated->tm_year%100,
            	 generated->tm_hour,  generated->tm_min);
    }
    else
    {
    	Warning(L"Could not find last reboot system event");
    }

    // Report Last MSMQ initialization time
	if (dwMsmqStartTime)
	{
		struct tm *generated = localtime((time_t*)&dwMsmqStartTime);

    	Inform(L"\tLast MSMQ initialization:\t\t%2d/%2d/%02d  %2d:%02d ", 
    			 generated->tm_mon+1, generated->tm_mday, generated->tm_year%100,
            	 generated->tm_hour,  generated->tm_min);
    }
    else
    {
    	Warning(L"Could not find Last successful MSMQ initialization event");
    }

    // Report Last MSMQ online time
	if (dwMsmqOnlineTime)
	{
		struct tm *generated = localtime((time_t*)&dwMsmqOnlineTime);

    	Inform(L"\tLast MSMQ online initialization:\t%2d/%2d/%02d  %2d:%02d ", 
    			 generated->tm_mon+1, generated->tm_mday, generated->tm_year%100,
            	 generated->tm_hour,  generated->tm_min);
    }
    else
    {
    	Warning(L"Could not find Last successful MSMQ online event");
    }

	ReleaseEventLibs();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\locsec.cpp ===
// MQState tool reports general status and helps to diagnose simple problems
// This file ...
//
// AlexDad, March 2000
// 

#include "stdafx.h"
#include "_mqini.h"
#include "Wincrypt.h"

BOOL VerifyLocalSecurity(MQSTATE * /* MqState */)
{
	BOOL fSuccess = TRUE, 	     b;
    BOOL fFound = FALSE;
	DWORD dwError;
	HCRYPTPROV hProv;

    // -------------------
    //   Display providers
    // -------------------
	GoingTo(L" review the Crypto Security Providers"); 

    DWORD dwIndex = 0, dwType;
    b = fSuccess;
    
    if (ToolVerbose()) { Inform(L"Cryptographic Security Providers: "); };
    
	while (b)
	{
        WCHAR wszBuffer[10000];
        DWORD nBufferSize = sizeof(wszBuffer) / sizeof(WCHAR);
	
		b = CryptEnumProviders( dwIndex++,
                               NULL,
                               0,
                               &dwType,
                               wszBuffer,
                               &nBufferSize );
		dwError = GetLastError();

		if(b)
		{
            if (ToolVerbose()) { Inform(L"\t %s ", wszBuffer); };
			fFound = TRUE;
		}
		else
		{
			if(dwError != ERROR_NO_MORE_ITEMS)
			{
        		Failed(L" get CryptEnumProviders, GetLastError=0x%x", dwError);
        		fSuccess = FALSE;
			}
			b = FALSE;
		}
	}

    if (fFound)
    {
        Succeeded(L" list cryptographic security providers");
    }
    else
    {
    	Failed(L" find any cryptographic security providers");
    	fSuccess = FALSE;
    }


    // -------------------
    //   Display containers
    // -------------------
	GoingTo(L" review the Crypto Container Name list"); 
    fFound = FALSE;

	b = CryptAcquireContext(&hProv, NULL , NULL, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET); 
	dwError = GetLastError();	
	
	if(!b) 
	{
     	Failed(L" CryptAcquireContext for CRYPT_MACHINE_KEYSET, GetLastError=0x%x", dwError);
       	fSuccess = FALSE;
    }
	else
	{
        Succeeded(L" CryptAcquireContext");
	}

    b = fSuccess;
    
    if (ToolVerbose()) { Inform(L"Cryptographic keys containers: "); };
    
	DWORD dwMsmqCount = 0;
	DWORD dwFunc = CRYPT_FIRST;
	while (b)
	{
        char szBuffer[10000];
        DWORD nBufferSize = sizeof(szBuffer);
	
		b = CryptGetProvParam(hProv, PP_ENUMCONTAINERS, (unsigned char *)szBuffer, &nBufferSize, dwFunc);
		dwError = GetLastError();
		dwFunc = CRYPT_NEXT;

		if(b)
		{
            if (szBuffer[0]=='M' && szBuffer[1]=='S' && szBuffer[2]=='M' && szBuffer[3]=='Q')
            {
    			dwMsmqCount++;
            }
		    if (ToolVerbose()) {Inform(L"\t %S", szBuffer); };
		}
		else
		{
			if(dwError != ERROR_NO_MORE_ITEMS)
			{
        		Failed(L" get CryptGetProvParam, GetLastError=0x%x", dwError);
        		fSuccess = FALSE;
			}
			b = FALSE;
		}
	}

    if (dwMsmqCount > 1)
    {
        Inform(L"Found %d MSMQ security contexts", dwMsmqCount);
    }
    else
    {
    	Failed(L" find MSMQ security contexts (only %d are present)", dwMsmqCount);
    	fSuccess = FALSE;
    }

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\env.cpp ===
// MQState tool reports general status and helps to diagnose simple problems
// This file reports general environment settings
//
// AlexDad, March 2000
// 

#include "stdafx.h"
#include "_mqini.h"

#include "winreg.h"

	//+ Machine, date, time
	//+	W2K version, flavor (pro, srv, etc.), platform and type (release/checked)
	//+	Date + time
	//-	gflags
	
BOOL VerifyGeneralEnv(MQSTATE *pMqState)
{
	Inform(L"General environment data: ");
	
	// Machine name
	//
    DWORD dwMachineNamesize =  sizeof(pMqState->g_szMachineName) / sizeof(TCHAR);
    if (!GetComputerName(pMqState->g_szMachineName, &dwMachineNamesize))
    {
    	wcscpy(pMqState->g_szMachineName, L"--unknown--");
    }
    else
    {
    	pMqState->f_Known_MachineName = TRUE;
    }

    // Time and date.
    //
    time_t  lTime ;
    WCHAR wszTime[ 128 ] ;
    time( &lTime ) ;
    swprintf(wszTime, L"%s", _wctime( &lTime ) );
    wszTime[ wcslen(wszTime)-1 ] = 0 ; // remove line feed.

	Inform(L"\tMachine %s, time is %s", pMqState->g_szMachineName, wszTime);

	// OS version, platform, flavor
	//

    // Try calling GetVersionEx using the OSVERSIONINFOEX structure, which is supported on Windows 2000.
    // If that fails, try using the OSVERSIONINFO structure.
    //

    ZeroMemory(&pMqState->osvi, sizeof(OSVERSIONINFOEX));
    pMqState->osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    BOOL fVersionInfo = TRUE;
    BOOL fVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &pMqState->osvi);

    if( !fVersionInfoEx )
    {
      	// If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO.
   		pMqState->osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
     	fVersionInfo = GetVersionEx ( (OSVERSIONINFO *) &pMqState->osvi );
  	}

	if (!fVersionInfo)
	{
		Failed(L"get version information: GetVersionEx returned 0x%x", GetLastError());
		
       	HKEY hKey;
    	char szProductType[80];
    	DWORD dwBufLen;

    	RegOpenKeyEx( HKEY_LOCAL_MACHINE,
               		L"SYSTEM\\CurrentControlSet\\Control\\ProductOptions",
               		0, KEY_QUERY_VALUE, &hKey );
    	RegQueryValueEx( hKey, L"ProductType", NULL, NULL, (LPBYTE) szProductType, &dwBufLen);
    	RegCloseKey( hKey );
    	
        Inform(L"\tRegistry marks OS flavor as %S",  szProductType );
	}
	else
	{
		pMqState->f_Known_Osvi = TRUE;
		
        Inform(L"\tOS version: %d.%d  Build: %d  %s",
               pMqState->osvi.dwMajorVersion, 
               pMqState->osvi.dwMinorVersion,
               pMqState->osvi.dwBuildNumber & 0xFFFF,
               pMqState->osvi.szCSDVersion);
               
		switch(pMqState->osvi.dwPlatformId)
		{
		case VER_PLATFORM_WIN32_NT: 
			if (pMqState->osvi.dwMajorVersion == 5 )
			{
		        Inform(L"\tPlatform: %s ", L"Win32 on Windows 2000");
			}
			else if (pMqState->osvi.dwMajorVersion <= 4)
			{
		        Inform(L"\tPlatform: %s ", L"Win32 on Windows NT");
			}
			else
			{
		        Failed(L" recognize platform: %d ", pMqState->osvi.dwPlatformId);
		    }
	
			break;

		case VER_PLATFORM_WIN32_WINDOWS:
			if (pMqState->osvi.dwMajorVersion > 4 || (pMqState->osvi.dwMajorVersion == 4) && (pMqState->osvi.dwMinorVersion > 0))
			{
		        Inform(L"\tPlatform: %s ", L"Win32 on Win98");
			}
			else
			{
		        Inform(L"\tPlatform: %s ", L"Win32 on Win95");
			}
			
			break;

		case VER_PLATFORM_WIN32s:
	        Inform(L"Platform: %s ", L"Win32s");
			break;
		default:
	        Failed(L" recognize platform: %d ", pMqState->osvi.dwPlatformId);
		}

              
		if(fVersionInfoEx)
		{
	        Inform(L"\tFlavor: %s",
	               (pMqState->osvi.wProductType == VER_NT_WORKSTATION 		? L"Professional" : 
    	           (pMqState->osvi.wProductType == VER_NT_SERVER      		? L"Server" :
        	       (pMqState->osvi.wProductType == VER_NT_DOMAIN_CONTROLLER 	? L"Domain controller" : 
               														  L"Unknown product type***"))));

			if (pMqState->osvi.wServicePackMajor!=0 || pMqState->osvi.wServicePackMinor!=0)
			{
	    	    Inform(L"\tOS Service Pack: %d.%d",
            	   	pMqState->osvi.wServicePackMajor, 
               		pMqState->osvi.wServicePackMinor);
        	}

   		
			if (pMqState->osvi.wSuiteMask & VER_SUITE_BACKOFFICE)
			{
				Inform(L"\t%s in installed", L"Backoffice");
			}

			if (pMqState->osvi.wSuiteMask & VER_SUITE_DATACENTER)
			{
				Inform(L"\t%s in installed", L"Datacenter Server");
			}

			if (pMqState->osvi.wSuiteMask & VER_SUITE_ENTERPRISE)
			{
				Inform(L"\t%s in installed", L"Advanced Server");
			}

			if (pMqState->osvi.wSuiteMask & VER_SUITE_SMALLBUSINESS)
			{
				Inform(L"\t%s in installed", L"Small Business Server");
			}

			if (pMqState->osvi.wSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED)
			{
				Inform(L"\t%s in installed", L"Small Business Server Restricted");
			}

			if (pMqState->osvi.wSuiteMask & VER_SUITE_TERMINAL)
			{
				Inform(L"\t%s in installed", L"Terminal Server");
			}
		}
	
	}

	// Windows and System directories
	//
	if (GetWindowsDirectory(pMqState->g_szWinDir,   sizeof(pMqState->g_szWinDir   ))==0 ||
		GetSystemDirectory(pMqState->g_szSystemDir, sizeof(pMqState->g_szSystemDir))==0)
	{
		Failed(L"Get system or Windows directory");
	}
	else
	{
		Inform(L"\tSystem dir = %s ; windows dir = %s", pMqState->g_szSystemDir, pMqState->g_szWinDir);
		pMqState->f_Known_Windir = TRUE;
	}

	// User name
	//
	if (ExpandEnvironmentStrings(L"%USERNAME%", pMqState->g_szUserName, 
	                                            sizeof(pMqState->g_szUserName)/sizeof(WCHAR)) != 0 &&
        ExpandEnvironmentStrings(L"%USERDOMAIN%", pMqState->g_szUserDomain, 
	                                            sizeof(pMqState->g_szUserDomain)/sizeof(WCHAR)) != 0)
	{
		Inform(L"\tCurrent user is %s\\%s", pMqState->g_szUserDomain, pMqState->g_szUserName);
		pMqState->f_Known_UserName = TRUE;
	}
	else
	{
		Failed(L"Get user name");
	}

	//DWORD dwUserLen = sizeof(wszUser)/sizeof(WCHAR);	      
	// if (GetUserName(wszUser,   &dwUserLen) == 0)

	// System info
	//
	GetSystemInfo(&pMqState->SystemInfo);
	pMqState->f_Known_SystemInfo = TRUE;

	Inform(L"\t%d processors of the level %d , rev %d; app memory limits 0x%x - 0x%x",
				pMqState->SystemInfo.dwNumberOfProcessors, 
				pMqState->SystemInfo.wProcessorLevel, 
				pMqState->SystemInfo.wProcessorRevision, 
				pMqState->SystemInfo.lpMinimumApplicationAddress, 
				pMqState->SystemInfo.lpMaximumApplicationAddress); 

   return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\memory.cpp ===
// MQState tool reports general status and helps to diagnose simple problems
// This file ...
//
// AlexDad, March 2000
// 

#include "stdafx.h"


BOOL VerifyMemoryUsage(MQSTATE *pMqState)
{
	BOOL fSuccess = TRUE, b;
    NTSTATUS Status;

	// report physical memory usage
	
	SYSTEM_BASIC_INFORMATION        BasicInfo;
    //SYSTEM_PROCESS_INFORMATION      MsmqProcessInfo;
    SYSTEM_PERFORMANCE_INFORMATION  PerfInfo;
    //SYSTEM_FILECACHE_INFORMATION    FileCache;

    //
    // Get some non-process specific info, like memory status
    //
    Status = NtQuerySystemInformation(
                SystemBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL);

    if (!NT_SUCCESS(Status))
    {
    	Failed(L"Get basic information: NtQuerySystemInformation 0x%x", GetLastError());
        return FALSE;
    }
    else
	    pMqState->f_Known_BasicInfo = TRUE;

    DWORD dwPhysicalMemory = BasicInfo.NumberOfPhysicalPages * (BasicInfo.PageSize / 1024);

    Status = NtQuerySystemInformation(
                SystemPerformanceInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );

    if (!NT_SUCCESS(Status))
    {
    	Failed(L"Get performance information: NtQuerySystemInformation 0x%x", GetLastError());
        return FALSE;
    }
    else
	    pMqState->f_Known_PerfInfo = TRUE;

    DWORD dwPhysAvail   = PerfInfo.AvailablePages    * (BasicInfo.PageSize / 1024);
    DWORD dwCommitTotal = PerfInfo.CommittedPages    * (BasicInfo.PageSize / 1024);
    DWORD dwCommitLimit = PerfInfo.CommitLimit       * (BasicInfo.PageSize / 1024);
    DWORD dwCommitPeak  = PerfInfo.PeakCommitment    * (BasicInfo.PageSize / 1024);
    DWORD dwKernelPaged = PerfInfo.PagedPoolPages    * (BasicInfo.PageSize / 1024);
    DWORD dwKernelNP    = PerfInfo.NonPagedPoolPages * (BasicInfo.PageSize / 1024);
    DWORD dwKernelTotal = dwKernelNP + dwKernelPaged;


	Inform (L"Memory usage summary: ");
	Inform(L"\tPhysical Memory (K)");
	Inform(L"\t\tTotal         %d",   dwPhysicalMemory);
	Inform(L"\t\tAvailable     %d",   dwPhysAvail);
	Inform(L"\t\t%%             %d",   dwPhysAvail * 100 / dwPhysicalMemory);

	if (fVerbose)
	{
		Inform(L"\tCommit Charge (K)");
		Inform(L"\t\tTotal         %d", dwCommitTotal);
		Inform(L"\t\tLimit         %d", dwCommitLimit);
		Inform(L"\t\tPeak          %d", dwCommitPeak);
	}

	// Find the memory data from another system call - for paging data
	MEMORYSTATUSEX statex;

	statex.dwLength = sizeof (statex);
	b = GlobalMemoryStatusEx (&statex);
	if (b)
	{
		// Use to change the divisor from Kb to Mb.
		//#define DIV 1024
		//static char *divisor = "K";
		// #define WIDTH 7
		//Inform (L"Memory usage summary: ");
		//Inform(L"\t\t          %ld percent of physical memory is in use",			  statex.dwMemoryLoad);
		//Inform(L"\t\t          %*I64d total %sbytes of physical memory",	WIDTH, statex.ullTotalPhys/DIV, divisor);
		//Inform(L"\t\t          %*I64d free %sbytes of physical memory",	WIDTH, statex.ullAvailPhys/DIV, divisor);
		//Inform(L"\t\t          %*I64d total %sbytes of paging file",		WIDTH, statex.ullTotalPageFile/DIV, divisor);
		//Inform(L"\t\t          %*I64d free %sbytes of paging file",		WIDTH, statex.ullAvailPageFile/DIV, divisor);
		
		if (fVerbose)
		{
			Inform(L"\tPaging file (K)");
			Inform(L"\t\tTotal         %d", statex.ullTotalPageFile / 1024);
			Inform(L"\t\tFree          %d", statex.ullAvailPageFile / 1024);
		}
	}
	else
	{
		Failed(L"get  memory data from the OS (GlobalMemoryStatusEx)");
	}


	if (fVerbose)
	{
		Inform(L"\tKernel Memory (K)");
		Inform(L"\t\tTotal         %d", dwKernelTotal);
		Inform(L"\t\tPaged         %d", dwKernelPaged);
		Inform(L"\t\tNonpaged      %d", dwKernelNP);
	}

	// 
	// Calculate pool limits with algorithm from KB article Q126402 and diagnose low memory
	//

	/*
		MinimumNonPagedPoolSize = 256K
		MinAdditionNonPagedPoolPerMb = 32K
		DefaultMaximumNonPagedPool = 1 MB
		MaxAdditionNonPagedPoolPerMb = 400K
		PTE_PER_PAGE = 1024
		PAGE_SIZE=4096 


		NonPagedPoolSize = MinimumNonPagedPoolSize + ((Physical MB - 4) * MinAdditionNonPagedPoolPerMB) 

			EXAMPLE - On a 32 MB x86-based computer: 
				MinimumNonPagedPoolSize = 256K
				NonPagedPoolSize = 256K + ((32 - 4) * 32K) = 1.2 MB 

		MaximumNonPagedPoolSize = DefaultMaximumNonPagedPool + ((Physical MB - 4) * MaxAdditionNonPagedPoolPerMB) 

		If MaximumNonPagedPoolSize < (NonPagedPoolSize + PAGE_SIZE * 16),
		then MaximumNonPagedPoolSize = (NonPagedPoolSize + PAGE_SIZE * 16) 

		IF MaximumNonPagedPoolSize >= 128 MB MaximumNonPagedPoolSize = 128 MB 

			EXAMPLE - On a 32 MB x86-based computer: 
				MaximumNonPagedPoolSize = 1 MB + ((32 - 4) * 400K) = 12.5 MB 


		Size = (2 * MaximumNonPagedPoolSize) / PAGESIZE 
		Size = (Size + (PTE_PER_PAGE - 1)) / PTE_PER_PAGE PagedPoolSize = Size * PAGESIZE * PTE_PER_PAGE 
		IF PagedPoolSize >= 192 MB PagePoolSize = 192 MB 

			EXAMPLE - On a 32 MB x86-based computer: 
				Size = (2 * 12.5M) / 4096 = 6400
				Size = (6400 + (1024 - 1)) / 1024 = 7.25
				PagedPoolSize = 7.25 * 4096 * 1024 = 30MB 

		NOTE: If both values are set to zero in the registry, PagedPoolSize will calculate to approximately memory size) 
			HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management 	



		The Windows 2000 memory model increases the amount of nonpaged pool and paged pool memory available to the system. 
			A Windows 2000-based 32-bit x86 computer that is booted without the /3GB switch 
				is changed to a maximum paged pool of approximately 300-400 MB (from 192 MB in Windows NT 4.0). 

			With Windows 2000, the amount of nonpaged pool that the operating system can use 
				is increased to 256 MB (from 128 MB in Windows NT 4.0).

			If the server is booted with the /3GB switch enabled, the memory model remains that same 
				for nonpaged and paged pool as in Windows NT 4.0. 
	*/

	{
		DWORD kbMinimumNonPagedPoolSize      = 256;
		DWORD kbMinAdditionNonPagedPoolPerMb = 32;
		DWORD kbDefaultMaximumNonPagedPool   = 1024;
		DWORD kbMaxAdditionNonPagedPoolPerMb = 400;
		DWORD cPTE_PER_PAGE					 = 1024;
		DWORD kbPAGE_SIZE					 = 4096 / 1024;
		DWORD mbPhysicalMemory				 = dwPhysicalMemory / 1024;

		// Non-paged pool
		DWORD kbNonPagedPoolSize = kbMinimumNonPagedPoolSize + ((mbPhysicalMemory - 4) * kbMinAdditionNonPagedPoolPerMb);
		DWORD kbMaximumNonPagedPoolSize = kbDefaultMaximumNonPagedPool + ((mbPhysicalMemory - 4) * kbMaxAdditionNonPagedPoolPerMb);
	
		if (kbMaximumNonPagedPoolSize < (kbNonPagedPoolSize + kbPAGE_SIZE * 16))
		{
			kbMaximumNonPagedPoolSize = (kbNonPagedPoolSize + kbPAGE_SIZE * 16);
		}

		DWORD kbLimitNonPagedPoolSize = 256 * 1024;   // this value is for W2K - should be 128M for NT4  
												      // TBD: to calculate per OS per 3GB option

		if (kbMaximumNonPagedPoolSize >= kbLimitNonPagedPoolSize)
		{
			kbMaximumNonPagedPoolSize = kbLimitNonPagedPoolSize;
		}


		// Paged pool
		DWORD dwSize = (2 * kbMaximumNonPagedPoolSize) / kbPAGE_SIZE; 
		dwSize = (dwSize + (cPTE_PER_PAGE - 1)) / cPTE_PER_PAGE;

		DWORD kbPagedPoolSize = dwSize * kbPAGE_SIZE * cPTE_PER_PAGE;
		
		DWORD kbLimitPagedPoolSize = 300 * 1024;   // this value is for W2K - should be 192M for NT4 
												   // TBD: to calculate per OS per 3GB option

		if (kbPagedPoolSize >= kbLimitPagedPoolSize)
		{
			kbPagedPoolSize = kbLimitPagedPoolSize;
		}

		DWORD percentPaged    = dwKernelPaged*100 / kbPagedPoolSize;
		DWORD percentNonPaged = dwKernelNP * 100  / kbMaximumNonPagedPoolSize; 

		Inform(L"\tPools limitations (calculated approximately, in KB)");
		Inform(L"\t\tPaged    : limit %d, \tused for %d %S", kbPagedPoolSize,           percentPaged,     "%");
		Inform(L"\t\tNonpaged : limit %d, \tused for %d %S", kbMaximumNonPagedPoolSize, percentNonPaged,  "%");
		Inform(L"\t\t           Calculations are wrong (NIY) if you boot with /3GB or /4GB option");

		if (percentPaged >= 80 || percentNonPaged >= 80)
		{
			Failed(L"validate kernel memory usage - Low kernel memory!");
			fSuccess = FALSE;
		}

	}




	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\memusage.cpp ===
// MQState tool reports general status and helps to diagnose simple problems
// This file ...
//
// AlexDad, March 2000
// 

#include "stdafx.h"
#include "_mqini.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\perfcnt.cpp ===
// MQState tool reports general status and helps to diagnose simple problems
// This file ...
//
// AlexDad, March 2000
// 

#include "stdafx.h"
#include "_mqini.h"

extern BOOL PerfAction(char  *pObjPath, char  *pCntrPath, ULONG *pulResult);

BOOL VerifyPerfCnt(MQSTATE * /* MqState */)
{
	BOOL fSuccess = TRUE, b;

	ULONG ulRes;
	
	Inform(L"\n\tPerformance counters: ");

	b = PerfAction("MSMQ Service", "Total messages in all queues", &ulRes);
	if (b)
	{
		Inform(L"\t\tTotal messages in all queues:  %d", ulRes);
	}
	else
	{
		Failed(L"get perf counter for Total messages in all queues");
		fSuccess = FALSE;
	}

	b = PerfAction("MSMQ Service", "Total bytes in all queues", &ulRes);
	if (b)
	{
		Inform(L"\t\tTotal bytes    in all queues:  %d", ulRes);
	}
	else
	{
		Failed(L"get perf counter for Total bytes in all queues");
		fSuccess = FALSE;
	}

	//	rc = PerfAction(1, "MSMQ Queue", "0",  "IP Sessions",   &ulRes);

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\mqstate.h ===
#ifndef __MQSTATE_H_
#define __MQSTATE_H_

typedef enum MsmqType { mtServer, mtIndClient, mtDepClient, mtWorkgroup, mtLast }; 

typedef struct _MQSTATE
{
	BOOL fMsmqIsInstalled;   
	BOOL fMsmqIsRunning;   
	MsmqType g_mtMsmqtype;   
	BOOL fMsmqIsWorkgroup;   
	BOOL fMsmqIsInSetup;   
	BOOL f_MsmqIsInJoin;   
	
	TCHAR g_tszPathPersistent[MAX_PATH];
	TCHAR g_tszPathJournal[MAX_PATH];
	TCHAR g_tszPathReliable[MAX_PATH];
	TCHAR g_tszPathBitmap[MAX_PATH];
	TCHAR g_tszPathXactLog[MAX_PATH];

	TCHAR g_szMachineName[MAX_COMPUTERNAME_LENGTH + 1];
	BOOL  f_Known_MachineName;   
		
	TCHAR g_szSystemDir[MAX_PATH];
	TCHAR g_szWinDir[MAX_PATH];
	BOOL  f_Known_Windir;   
	
	TCHAR g_szUserName[MAX_PATH];
	TCHAR g_szUserDomain[MAX_PATH];
	BOOL  f_Known_UserName;   
	
	SYSTEM_INFO SystemInfo;
	BOOL        f_Known_SystemInfo;   

	OSVERSIONINFOEX osvi;
	BOOL            f_Known_Osvi;   

	BOOL            f_Known_BasicInfo;   
	BOOL            f_Known_MsmqProcessInfo;   
	BOOL            f_Known_PerfInfo;   
	BOOL            f_Known_FileCache;   

	TCHAR           g_wszVersion[20];
	DWORD          g_dwVersion;

    // MSMQ3 components
    DWORD          f_msmq_Core;
    DWORD          f_msmq_MQDSService;
    DWORD          f_msmq_TriggersService;
    DWORD          f_msmq_HTTPSupport;
    DWORD          f_msmq_ADIntegrated;
    DWORD          f_msmq_RoutingSupport;
    DWORD          f_msmq_LocalStorage;
	
} MQSTATE;

extern TCHAR g_tszService[50];

extern MQSTATE MqState;

extern bool fVerbose ;
extern bool fDebug ;
extern FILE *g_fileLog;

void OpenLogFile();

LONG GetFalconKeyValue(  
					LPCWSTR  pszValueName,
                    PDWORD   pdwType,
                    PVOID    pData,
                    PDWORD   pdwSize,
                    LPCWSTR  pszDefValue = NULL ) ;

BOOL
MqReadRegistryValue(
    IN     const TCHAR  * szEntryName,
    IN OUT       DWORD   dwNumBytes,
    IN OUT       PVOID   pValueData,
    IN const BOOL OPTIONAL bSetupRegSection /* = FALSE */
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mqstore.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\qmstate.cpp ===
// MQState tool reports general status and helps to diagnose simple problems
// This file gets what's possible from QM via admin API - if it is alive
//
// AlexDad, March 2000
// 

#include "stdafx.h"

#include <mq.h>
#include <mqnames.h>

extern DWORD g_cOpenQueues;

typedef HRESULT
( APIENTRY *MQMgmtGetInfo_ROUTINE)(
    IN LPCWSTR pMachineName,
    IN LPCWSTR pObjectName,
    IN OUT MQMGMTPROPS* pMgmtProps
    );

typedef HRESULT
(APIENTRY *MQMgmtAction_ROUTINE) (
    IN LPCWSTR pMachineName,
    IN LPCWSTR pObjectName,
    IN LPCWSTR pAction
    );

typedef void
(APIENTRY *MQFreeMemory_ROUTINE)(
    IN PVOID pvMemory
    );

static  MQMgmtGetInfo_ROUTINE  pfMqMgmtGetInfo = NULL ;
static  MQFreeMemory_ROUTINE   pfMQFreeMemory  = NULL ;

#ifdef MQSTATE_TOOL
#define MQMgmtGetInfo_FUNCTION (*pfMqMgmtGetInfo)
#define MQFreeMemory_FUNCTION  (*pfMQFreeMemory)
#else
#define MQMgmtGetInfo_FUNCTION MQMgmtGetInfo
#define MQFreeMemory_FUNCTION  MQFreeMemory
#endif

LPWSTR Time2String(time_t *pt)
{
    static WCHAR tm[26];
    wcscpy(tm, _wctime(pt));
	tm[24] = L'\0';
	return tm;
}

void DisplayQueueDisplayName(PROPVARIANT& propVar)
{
    if (propVar.vt != VT_NULL)
    {
        Inform(L"\tDisplay Name: \t\t\t%s", propVar.pwszVal);
        MQFreeMemory_FUNCTION(propVar.pwszVal);
    }
}

void DisplayQueueFormatName(PROPVARIANT& propVar)
{
    if (propVar.vt != VT_NULL)
    {
        Inform(L"\tFormat Name:\t\t\t%s", propVar.pwszVal);
        MQFreeMemory_FUNCTION(propVar.pwszVal);
    }
}

void DisplayQueueConnectionStatus(PROPVARIANT& propVar)
{
    if (propVar.vt != VT_NULL)
    {
        Inform(L"\tConnection Status: \t\t%s", propVar.pwszVal);
        MQFreeMemory_FUNCTION(propVar.pwszVal);
    }
}

void DisplayQueueNextHop(PROPVARIANT& propVar)
{
    if ((propVar.vt == VT_NULL) ||
        (propVar.calpwstr.cElems == 0))
        return ;

    if (propVar.calpwstr.cElems >1)
    {
        Inform(L"\tThe Queue is in Waiting mode. Next Possibles Hops:");
        for (DWORD i = 0; i < propVar.calpwstr.cElems; i++)
        {
            Inform(L"\t\t\t%s", propVar.calpwstr.pElems[i]);
            MQFreeMemory_FUNCTION(propVar.calpwstr.pElems[i]);
        }
    }
    else
    {
        Inform(L"\tThe Next Hope is: \t\t%s", propVar.calpwstr.pElems[0]);
        MQFreeMemory_FUNCTION(propVar.calpwstr.pElems[0]);
    }

    MQFreeMemory_FUNCTION(propVar.calpwstr.pElems);
}

void DisplayQueueType(PROPVARIANT& propVar)
{
    Inform(L"\tQueue Type: \t\t\t%s", propVar.pwszVal);
    MQFreeMemory_FUNCTION(propVar.pwszVal);
}

void DisplayQueueLocation(PROPVARIANT& propVar)
{
    Inform(L"\tQueue Location: \t\t%s", propVar.pwszVal);
    MQFreeMemory_FUNCTION(propVar.pwszVal);
}
                                

void DisplayReadCount(PROPVARIANT& propVar)
{
    if (propVar.vt == VT_NULL)
        return;

    Inform(L"\t\tDelivered & non-received: \t%d", propVar.ulVal);
}

void DisplayNoAckedCount(PROPVARIANT& propVar)
{
    if ( propVar.vt == VT_NULL)
        return;

    Inform(L"\t\tSent & non-acked: \t\t%d", propVar.ulVal);
}

void DisplayQueueMessageCount(PROPVARIANT& propVar)
{
    Inform(L"\tMessages Count: \t\t%d", propVar.ulVal);
}

void DisplayQueueUsedQuota(PROPVARIANT& propVar)
{
    Inform(L"\tQueue Used Quota: \t\t%d", propVar.ulVal);
}

void DisplayJournalQueueMessageCount(PROPVARIANT& propVar)
{
    Inform(L"\tJournal Queue Message Count: \t%d", propVar.ulVal);
}

void DisplayJournalQueueUsedQuota(PROPVARIANT& propVar)
{
    Inform(L"\tJournal Queue Used Quota: \t%d", propVar.ulVal);
}

void DisplayQueueXact(PROPVARIANT& propVar)
{
    if ( propVar.vt == VT_NULL)
        return;

    Inform(L"\tXACT Queue: \t\t\t%s", propVar.pwszVal);
    MQFreeMemory_FUNCTION(propVar.pwszVal);
}

void DisplayQueueForeign(PROPVARIANT& propVar)
{
    Inform(L"\tForeign Queue: \t\t\t%s", propVar.pwszVal);
    MQFreeMemory_FUNCTION(propVar.pwszVal);
}

void
DisplaySequence(PROPVARIANT& propVar, LPWSTR Title)
{
    if (propVar.vt == VT_NULL)
    {
        return;
    }

    SEQUENCE_INFO* SeqInfo;
    SeqInfo = reinterpret_cast<SEQUENCE_INFO*>(propVar.blob.pBlobData);

    Inform(L"\t\t%-20s\t\tSeqID=%I64x, SeqN=%6d, PrevSeqN=%6d",
            Title, SeqInfo->SeqID, SeqInfo->SeqNo, SeqInfo->PrevNo);
    
    MQFreeMemory_FUNCTION(propVar.blob.pBlobData);
}

void DisplayLastAckedTime(PROPVARIANT& propVar)
{   
    if ( propVar.vt == VT_NULL)
        return;

    time_t AckTime = propVar.lVal;
    Inform(L"\t\tLast Acknowledge time:  \t%s", Time2String(&AckTime));
}

void DisplayResendInterval(PROPVARIANT& propVar)
{   
    if ( propVar.vt == VT_NULL)
        return;

    Inform(L"\t\tResend Interval: \t\t%d", propVar.ulVal);
}


void DisplayResendIndex(PROPVARIANT& propVar)
{   
    if ( propVar.vt == VT_NULL)
        return;

    Inform(L"\t\tResend Index: \t\t\t%d", propVar.ulVal);
}


void DisplayEODSourceInfo(PROPVARIANT& propVar)
{
    if (propVar.vt == VT_NULL)
        return;

    DWORD size = propVar.capropvar.pElems[0].calpwstr.cElems;
    LPWSTR* pSendQueueFormatName = propVar.capropvar.pElems[0].calpwstr.pElems;

    GUID* pSenderId = propVar.capropvar.pElems[1].cauuid.pElems;

    ULARGE_INTEGER* pSeqId = propVar.capropvar.pElems[2].cauh.pElems;

    DWORD* pSeqN = propVar.capropvar.pElems[3].caul.pElems;

    time_t* pLastActiveTime = propVar.capropvar.pElems[4].cal.pElems;

    DWORD* pRejectCount = propVar.capropvar.pElems[5].caul.pElems;
    
    for (DWORD i = 0; i < size; ++i)
    {
        LPWSTR GuidString;
        UuidToString(&pSenderId[i], &GuidString);
        Inform(L"\t\tSender QM ID: \t\t\t%s", GuidString);
        RpcStringFree(&GuidString);

        Inform(L"\t\tLast accepted seq.data: \tSeqId=%I64x, SeqN=%d, at %s",
                   pSeqId[i].QuadPart, pSeqN[i], Time2String(&pLastActiveTime[i]));
        Inform(L"\t\tUsed format name: \t\t%s",
                   pSendQueueFormatName[i]);
        Inform(L"\t\tRejects count: \t\t\t%d",
                   pRejectCount[i]);
 
        MQFreeMemory_FUNCTION(pSendQueueFormatName[i]);
    }

    MQFreeMemory_FUNCTION(pSendQueueFormatName);
    MQFreeMemory_FUNCTION(pSenderId);
    MQFreeMemory_FUNCTION(pSeqId);
    MQFreeMemory_FUNCTION(pSeqN);
    MQFreeMemory_FUNCTION(pLastActiveTime);
    MQFreeMemory_FUNCTION(pRejectCount);
    MQFreeMemory_FUNCTION(propVar.capropvar.pElems);
}

void DisplayNextResendTime(PROPVARIANT& propVar)
{   
    if (propVar.vt == VT_NULL)
        return;

    time_t ResendTime = propVar.lVal;

    if (ResendTime == 0)
    {
    	Inform(L"\t\tNext resend time hadn't been scheduled: ");
        return;
    }

    Inform(L"\t\tNext resend time: \t\t%s", Time2String(&ResendTime));
}

void DisplayQueueInfo(MQMGMTPROPS* pmqProps, BOOL fXactOut, BOOL fXactIn)
{
	BOOL fEODsaid = FALSE;
	
    for (DWORD i = 0; i < pmqProps->cProp; ++i)
    {
        switch (pmqProps->aPropID[i])
        {
            case PROPID_MGMT_QUEUE_PATHNAME:
                DisplayQueueDisplayName(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_FORMATNAME:
                DisplayQueueFormatName(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_TYPE:
                DisplayQueueType(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_LOCATION:
                DisplayQueueLocation(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_XACT:
                DisplayQueueXact(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_FOREIGN:
                DisplayQueueForeign(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_STATE:
                DisplayQueueConnectionStatus(pmqProps->aPropVar[i]);
                break;


            case PROPID_MGMT_QUEUE_NEXTHOPS:
                DisplayQueueNextHop(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_MESSAGE_COUNT:
                DisplayQueueMessageCount(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_USED_QUOTA:
                DisplayQueueUsedQuota(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT:
                DisplayJournalQueueMessageCount(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA:
                DisplayJournalQueueUsedQuota(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_EOD_NEXT_SEQ:
            	if (fXactOut) 
            	{
            		if (!fEODsaid) { Inform(L"\tExactly-Once-Delivery:"); fEODsaid = TRUE; }
    	        	DisplaySequence(pmqProps->aPropVar[i], L"Next:");
    	        }
                break;

            case PROPID_MGMT_QUEUE_EOD_LAST_ACK:
                if (fXactOut) 
                {
                	if (!fEODsaid) { Inform(L"\tExactly-Once-Delivery:"); fEODsaid = TRUE; }
	                DisplaySequence(pmqProps->aPropVar[i], L"Last Acked:");
	            }
                break;

            case PROPID_MGMT_QUEUE_EOD_FIRST_NON_ACK:
                if (fXactOut) 
                {
                	if (!fEODsaid) { Inform(L"\tExactly-Once-Delivery:"); fEODsaid = TRUE; }
                	DisplaySequence(pmqProps->aPropVar[i], L"First non-acked:");
	            }
                break;

            case PROPID_MGMT_QUEUE_EOD_LAST_NON_ACK:
                if (fXactOut) 
                {
                	if (!fEODsaid) { Inform(L"\tExactly-Once-Delivery:"); fEODsaid = TRUE; }
	                DisplaySequence(pmqProps->aPropVar[i], L"Last non-acked:");
	            }
                break;

            case PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT:
                if (fXactOut) 
                {
                	if (!fEODsaid) { Inform(L"\tExactly-Once-Delivery:"); fEODsaid = TRUE; }
                	DisplayReadCount(pmqProps->aPropVar[i]);
	            }
                break;

            case PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT:
                if (fXactOut) 
                {
                	if (!fEODsaid) { Inform(L"\tExactly-Once-Delivery:"); fEODsaid = TRUE; }
                	DisplayNoAckedCount(pmqProps->aPropVar[i]);
	            }
                break;

            case PROPID_MGMT_QUEUE_EOD_LAST_ACK_TIME:
                if (fXactOut) 
                {
                	if (!fEODsaid) { Inform(L"\tExactly-Once-Delivery:"); fEODsaid = TRUE; }
                	DisplayLastAckedTime(pmqProps->aPropVar[i]);
	            }
                break;

            case PROPID_MGMT_QUEUE_EOD_RESEND_TIME:
                if (fXactOut) 
                {
                	if (!fEODsaid) { Inform(L"\tExactly-Once-Delivery:"); fEODsaid = TRUE; }
                 	DisplayNextResendTime(pmqProps->aPropVar[i]);
	            }
                break;

            case PROPID_MGMT_QUEUE_EOD_RESEND_INTERVAL:
                if (fXactOut) 
                {
                	if (!fEODsaid) { Inform(L"\tExactly-Once-Delivery:"); fEODsaid = TRUE; }
                 	DisplayResendInterval(pmqProps->aPropVar[i]);
	            }
                break;

            case PROPID_MGMT_QUEUE_EOD_RESEND_COUNT:
                if (fXactOut) 
                {
                	if (!fEODsaid) { Inform(L"\tExactly-Once-Delivery:"); fEODsaid = TRUE; }
                 	DisplayResendIndex(pmqProps->aPropVar[i]);
	            }
                break;

            case PROPID_MGMT_QUEUE_EOD_SOURCE_INFO:
                if (fXactIn) 
                {
                	if (!fEODsaid) { Inform(L"\tExactly-Once-Delivery:"); fEODsaid = TRUE; }
                  	DisplayEODSourceInfo(pmqProps->aPropVar[i]);
	            }
                break;
        }
    }
}

#define SETPROP(propid) 		   					\
    propId[cprop] = propid;							\
    propVar[cprop].vt = VT_NULL;					\
    int i##propid = cprop;							\
    ++cprop;										\



#pragma warning(disable: 4189) // local variable is initialized but not referenced

void  QueueGetInfo( LPCWSTR MachineName, LPCWSTR ObjectType)
{
    QUEUEPROPID propId[30];
    MQPROPVARIANT propVar[30];
    HRESULT propStatus[30];
    DWORD cprop = 0;

    SETPROP(PROPID_MGMT_QUEUE_PATHNAME);
    SETPROP(PROPID_MGMT_QUEUE_FORMATNAME);
    SETPROP(PROPID_MGMT_QUEUE_TYPE);
    SETPROP(PROPID_MGMT_QUEUE_LOCATION);
    SETPROP(PROPID_MGMT_QUEUE_XACT);
    SETPROP(PROPID_MGMT_QUEUE_FOREIGN);
    SETPROP(PROPID_MGMT_QUEUE_STATE);
    SETPROP(PROPID_MGMT_QUEUE_NEXTHOPS);
    SETPROP(PROPID_MGMT_QUEUE_MESSAGE_COUNT);
    SETPROP(PROPID_MGMT_QUEUE_USED_QUOTA);
    SETPROP(PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT);
    SETPROP(PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA);
    SETPROP(PROPID_MGMT_QUEUE_EOD_LAST_ACK);
    SETPROP(PROPID_MGMT_QUEUE_EOD_FIRST_NON_ACK);
    SETPROP(PROPID_MGMT_QUEUE_EOD_LAST_NON_ACK);
    SETPROP(PROPID_MGMT_QUEUE_EOD_NEXT_SEQ);
    SETPROP(PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT);
    SETPROP(PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT);
    SETPROP(PROPID_MGMT_QUEUE_EOD_LAST_ACK_TIME);
    SETPROP(PROPID_MGMT_QUEUE_EOD_RESEND_TIME);
    SETPROP(PROPID_MGMT_QUEUE_EOD_RESEND_INTERVAL);
    SETPROP(PROPID_MGMT_QUEUE_EOD_RESEND_COUNT);
    SETPROP(PROPID_MGMT_QUEUE_EOD_SOURCE_INFO);

    MQMGMTPROPS mqProps;

    mqProps.cProp = cprop;
    mqProps.aPropID = propId;
    mqProps.aPropVar = propVar;
    mqProps.aStatus = propStatus;

    HRESULT hr = MQMgmtGetInfo_FUNCTION(MachineName, ObjectType, &mqProps);

	BOOL fXactOut = FALSE;
    if (propVar[iPROPID_MGMT_QUEUE_XACT].vt == VT_LPWSTR && 
        wcscmp(propVar[iPROPID_MGMT_QUEUE_XACT].pwszVal, L"YES") == NULL &&
        
        propVar[iPROPID_MGMT_QUEUE_LOCATION].vt == VT_LPWSTR && 
        wcscmp(propVar[iPROPID_MGMT_QUEUE_LOCATION].pwszVal, L"REMOTE") == NULL)
    {
    	fXactOut = TRUE;
    }
    
	BOOL fXactIn = FALSE;
    if (propVar[iPROPID_MGMT_QUEUE_XACT].vt == VT_LPWSTR && 
        wcscmp(propVar[iPROPID_MGMT_QUEUE_XACT].pwszVal, L"YES") == NULL &&
        
        propVar[iPROPID_MGMT_QUEUE_LOCATION].vt == VT_LPWSTR && 
        wcscmp(propVar[iPROPID_MGMT_QUEUE_LOCATION].pwszVal, L"LOCAL") == NULL)
    {
    	fXactIn = TRUE;
    }

    DisplayQueueInfo(&mqProps, fXactOut, fXactIn);
}

#pragma warning(default: 4189) // local variable is initialized but not referenced

void DisplayConnectionStatus(PROPVARIANT& propVar)
{
    Inform(L"\tDS Connection status: %s", propVar.pwszVal);
    MQFreeMemory_FUNCTION(propVar.pwszVal);
}

void DisplayDSServer(PROPVARIANT& propVar)
{
    if (propVar.vt == VT_LPWSTR)
    {
	    Inform(L"\tDS Server: %s", propVar.pwszVal);
    }
    else
    {
    	Warning(L"DS Offline");
    }

    MQFreeMemory_FUNCTION(propVar.pwszVal);
}

void
DisplayMsmqType(PROPVARIANT& propVar)
{
    ASSERT(propVar.vt == VT_LPWSTR);
    Inform(L"\tMSMQ Type: %s", propVar.pwszVal);

    MQFreeMemory_FUNCTION(propVar.pwszVal);
}

void DisplayMachineOpenQueues(PROPVARIANT& propVar)
{
    ASSERT(propVar.vt == (VT_LPWSTR | VT_VECTOR));

    Inform(L"Currently Open Queues");

	DWORD dwOpenQueues = 0;
	
    for (DWORD i = 0; i < propVar.calpwstr.cElems; i++)
    {
    	if (ToolVerbose() && i < g_cOpenQueues)
    	{
	        Inform(L"\n\tOpen queue #%d:  \t\t%s", i+1, propVar.calpwstr.pElems[i]);

            WCHAR ObjectType[256];
            wsprintf(ObjectType, L"QUEUE=%s", propVar.calpwstr.pElems[i]);

			// print queue detail
            QueueGetInfo(NULL, ObjectType);
	    }
        MQFreeMemory_FUNCTION(propVar.calpwstr.pElems[i]);
        dwOpenQueues++;
    }

    Inform(L"MSMQ has %d open queues currently", dwOpenQueues);
}

void DisplayPrivateQueues(PROPVARIANT& propVar)
{
    ASSERT(propVar.vt == (VT_LPWSTR | VT_VECTOR));
	DWORD dwPrivateQueues = 0;

    for (DWORD i = 0; i < propVar.calpwstr.cElems; i++)
    {
        MQFreeMemory_FUNCTION(propVar.calpwstr.pElems[i]);
        dwPrivateQueues++;
    }

    Inform(L"\tMSMQ has %d private queues on this machine", dwPrivateQueues);
}

void DisplayMachineInfo(MQMGMTPROPS* pmqProps)
{
    for (DWORD i = 0; i < pmqProps->cProp; ++i)
    {
        switch (pmqProps->aPropID[i])
        {
            case PROPID_MGMT_MSMQ_ACTIVEQUEUES:
                DisplayMachineOpenQueues(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_MSMQ_DSSERVER:
                DisplayDSServer(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_MSMQ_CONNECTED:
                DisplayConnectionStatus(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_MSMQ_PRIVATEQ:
                DisplayPrivateQueues(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_MSMQ_TYPE:
                DisplayMsmqType(pmqProps->aPropVar[i]);
                break;

            default:
                ASSERT(0);
        }
    }
}

void MachineGetInfo(LPCWSTR MachineName)
{
    QUEUEPROPID propId[10];
    MQPROPVARIANT propVar[10];
    DWORD cprop = 0;

    propId[cprop] = PROPID_MGMT_MSMQ_TYPE;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_MSMQ_DSSERVER;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_MSMQ_CONNECTED;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_MSMQ_PRIVATEQ;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_MSMQ_ACTIVEQUEUES;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    
    MQMGMTPROPS mqProps;

    mqProps.cProp = cprop;
    mqProps.aPropID = propId;
    mqProps.aPropVar = propVar;

    HRESULT hr;
    hr = MQMgmtGetInfo_FUNCTION(MachineName, L"MACHINE", &mqProps);
    if (FAILED(hr))
    {
        Failed(L"Get Machine properties from management API: 0x%x", hr);
        return;
    }

    DisplayMachineInfo(&mqProps);
}


#ifdef MQSTATE_TOOL
BOOL VerifyQMAdmin(MQSTATE *pMqState)
{
	BOOL fSuccess = TRUE;
	
	if (!pMqState->fMsmqIsRunning || pMqState->g_mtMsmqtype == mtDepClient)
	{
		return TRUE;
	}

    HINSTANCE h = LoadLibrary(L"tmqrt.dll");
    if (!h)
    	 h = LoadLibrary(L"mqrt.dll");
	
	if (h)
	{
	   	pfMqMgmtGetInfo = (MQMgmtGetInfo_ROUTINE) GetProcAddress(h,"MQMgmtGetInfo");
	   	pfMQFreeMemory  = (MQFreeMemory_ROUTINE)  GetProcAddress(h,"MQFreeMemory");
	}
   	
   	if (!pfMqMgmtGetInfo || !pfMQFreeMemory)
   	{
    	Failed(L"get access to mqrt.dll");
    	if (h) FreeLibrary(h);
        return FALSE ;
    }

	Inform(L"\nQM Data from admin API:");
    MachineGetInfo(NULL);

	FreeLibrary(h);
	return fSuccess;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\perfstuff.cpp ===
////////////////////////////////////////////////////////////////////////////////
// GetPerf.cpp : sample code for performance monitor - borrowed from MSDN.
//               TBD: needs to be minimized yet

#include "stdafx.h"

#undef UNICODE
#undef _UNICODE

#include <process.h>

#include <winperf.h>
#include <winreg.h>

extern bool fDebug ;

////////////////////////////////////////////////////////////////////////////////
#define  KM_THIS_COMP      L"."

#define  PERFLIB_KEY       L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib"
#define  PERFLIB_KEY_009   L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009"

#define  KM_ERROR_FMT      "%s ERROR= %lx"

static   char           g_szKMVersion[]      = "V1.1.00";

static   char           g_szErrReturn[256];

//static   WCHAR          g_szComputerName[MAX_COMPUTERNAME_LENGTH];
//static   WCHAR          g_szVersionString[255];

// Used to access PerfMon counter data
static   char           *g_pszReplyList      = NULL;
static   DWORD          g_dwReplyMax         = 0;
static   DWORD          g_dwReplySize        = 0;
static   DWORD          g_dwReplyIndex       = 0;

// Receiver thread parameters
#define  MAX_FMT_BUFF_LEN  256
static   DWORD          g_dwFmtNameBuffLen;
static   WCHAR          g_wszFmtNameBuff[MAX_FMT_BUFF_LEN];

// Registry access to Performance data
static   char           *g_pNameStrings;
static   DWORD          g_dwNameStringsLen;
static   FILETIME       g_LastFileTime;

static   LPSTR          *g_pNamesArray;
static   DWORD          g_dwNamesArraySize;

static   char           g_szPerfData[256];

static   BYTE           *g_pbyPerfBuff;
static   DWORD          g_dwPerfBuffLen;
static   DWORD          g_dwPerfBuffMax;

typedef PERF_DATA_BLOCK          *PPERFDATA;
typedef PERF_OBJECT_TYPE         *PPERFOBJECT;
typedef PERF_COUNTER_DEFINITION  *PPERFCOUNTERDEF;
typedef PERF_INSTANCE_DEFINITION *PPERFINSTANCEDEF;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// Internal Registry access functions / Macros

#define FirstObject(pPerfData)         \
   ((PPERFOBJECT) ((PBYTE) pPerfData + pPerfData->HeaderLength))

#define NextObject(pObject)            \
   ((PPERFOBJECT) ((PBYTE) pObject + pObject->TotalByteLength))

#define FirstCounter(pObjectDef)       \
   ((PERF_COUNTER_DEFINITION *) ((PCHAR)pObjectDef + pObjectDef->HeaderLength))

#define NextCounter(pCounterDef)       \
   ((PERF_COUNTER_DEFINITION *) ((PCHAR)pCounterDef + pCounterDef->ByteLength))

PERF_INSTANCE_DEFINITION *FirstInstance(PERF_OBJECT_TYPE *pObjectDef)
{
    return (PERF_INSTANCE_DEFINITION *)
               ((PCHAR) pObjectDef + pObjectDef->DefinitionLength);
}

PERF_INSTANCE_DEFINITION *NextInstance(PERF_INSTANCE_DEFINITION *pInstDef)
{
    PERF_COUNTER_BLOCK *pCounterBlock;

    pCounterBlock = (PERF_COUNTER_BLOCK *)
                        ((PCHAR) pInstDef + pInstDef->ByteLength);

    return (PERF_INSTANCE_DEFINITION *)
               ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);
}

////////////////////////////////////////////////////////////////////////////////
// Build an array of pointers to the available strings.
//
void  GetNameStrings()
{
   long        lStatus;
   HKEY        hKey;
   DWORD       dwIndex;
   CHAR        *pszString;

   // Open the Perflib counter and title registry key
   lStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, PERFLIB_KEY, 0, KEY_READ, &hKey);

   // Get the last counter number
   DWORD    dwBufferSize = sizeof(g_dwNamesArraySize);
   lStatus = RegQueryValueEx(hKey, L"Last Counter", NULL, NULL,
                              (BYTE *)&g_dwNamesArraySize, &dwBufferSize);

   // Close the key
   lStatus = RegCloseKey(hKey);

   // Allocate the name array (allocate 1 extra entry) and zero all the entries.
   g_dwNamesArraySize++;
   g_pNamesArray  = new LPSTR[g_dwNamesArraySize];

   // Clear the array
   memset(g_pNamesArray, 0, (g_dwNamesArraySize * sizeof(LPSTR)));

   // Open the key to the ENGISH object and counter names (009)
   lStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, PERFLIB_KEY_009, 0, KEY_READ, &hKey);

   // Get the size of the "Counter" key
   g_dwNameStringsLen = 0;
   RegQueryValueEx(hKey, L"Counter", NULL, NULL, (BYTE *)g_pNameStrings, &g_dwNameStringsLen);

   // Allocate memory for the string table
   g_pNameStrings = new CHAR[g_dwNameStringsLen];

   // Get the counter text if the write time has changed
   RegQueryValueEx(hKey, L"Counter", NULL, NULL, (BYTE *)g_pNameStrings, &g_dwNameStringsLen);

   // Close the key
   lStatus = RegCloseKey(hKey);

   // Fill the array with pointers to the text (sorted by index)
   pszString = g_pNameStrings;
   do
   {
      // Get string index
      dwIndex     = atol(pszString);
      pszString   += strlen(pszString) + 1;

      // Put pointer to string into the array
      g_pNamesArray[dwIndex] = pszString;

      // Move to the next string
      pszString   += strlen(pszString) + 1;
   }
   while (*pszString != 0);
}

////////////////////////////////////////////////////////////////////////////////
// Return a pointer to the counter/object name
//
CHAR  *GetName(DWORD dwIndex)
{
   return(g_pNamesArray[dwIndex]);
}

//
// Return the index key for the object
//
static   WCHAR    wzObjIndex[100];

WCHAR    *GetIndex(char *pszObjName)
{
   BOOL     bItemFound = FALSE;
   CHAR     *pszListName;
   WCHAR    wzObjName[256];
   WCHAR    *pObjIndex;
   LONG     dwIndex;

   memset(wzObjName, 0, sizeof(wzObjName));
   mbstowcs(wzObjName, pszObjName, strlen(pszObjName));

   for (dwIndex = (LONG) (g_dwNamesArraySize - 1) ; dwIndex >= 0; dwIndex--)
   {
      pszListName = GetName(dwIndex);

      if (pszListName != NULL)
      {
         if (strcmp(pszObjName, pszListName) == 0)
         {
            bItemFound = TRUE;
            break;
         }
      }
   }

   if (bItemFound == TRUE)
   {
      pObjIndex = _itow(dwIndex, wzObjIndex, 10);
   }
   else
   {
      pObjIndex = NULL;
   }

   return(pObjIndex);
}

////////////////////////////////////////////////////////////////////////////////
// Get a list of performance data for the given object name
//
PERF_DATA_BLOCK   *GetObjectList(char *pObjPath)
{
   long              lStatus;
   DWORD             dwType;
//   HKEY              hKey    = HKEY_PERFORMANCE_DATA;
   WCHAR             *pObjIndex;
   PERF_DATA_BLOCK   *pDataBlock;

   pObjIndex = GetIndex(pObjPath);
   if (pObjIndex == NULL)
   {
      pDataBlock  = NULL;
   }
   else
   {
      do
      {
         g_dwPerfBuffLen = g_dwPerfBuffMax;
         lStatus = RegQueryValueExW(HKEY_PERFORMANCE_DATA, pObjIndex, NULL, &dwType, g_pbyPerfBuff,
                                 &g_dwPerfBuffLen);

         if (lStatus == ERROR_MORE_DATA)
         {
            // Delete the current buffer
            delete [] g_pbyPerfBuff;
            g_pbyPerfBuff  = NULL;

            // Increate the maximum size
            g_dwPerfBuffMax += 2048;

            // Allocate a new data buffer
            _try
            {
               g_pbyPerfBuff  = new BYTE[g_dwPerfBuffMax];
            }
            _except( " " ,1)
            {
               // clear all global variables
               g_pbyPerfBuff     = NULL;
               g_dwPerfBuffMax   = 0;
               g_dwPerfBuffLen   = 0;
               break;
            }
         }
      }
      while (lStatus != ERROR_SUCCESS);

      pDataBlock = (PERF_DATA_BLOCK *)g_pbyPerfBuff;
      if (pDataBlock == NULL)
      {
      }
      else
      if (wcsncmp(pDataBlock->Signature, L"PERF", 4) != 0)
      {
         pDataBlock  = NULL;
      }
   }

   return(pDataBlock);
}

////////////////////////////////////////////////////////////////////////////////
//
// Search the data block for the required object
//
PERF_OBJECT_TYPE  *SearchObjectList(PERF_DATA_BLOCK *pDataBlock, char *pszObjPath)
{
   BOOL              bItemFound;
   PERF_OBJECT_TYPE  *pObject;
   CHAR              *pszObjName;
   WCHAR             wzObjPath[256];
   DWORD             i;

   // Convert ASCII strint to WIDE string
   memset(wzObjPath, 0, sizeof(wzObjPath));
   mbstowcs(wzObjPath, pszObjPath, strlen(pszObjPath));

   // Get pointer to the first object
   pObject     = FirstObject(pDataBlock);
   bItemFound  = FALSE;

   // Search the object list list for a matching name
   for (i = 0; i < pDataBlock->NumObjectTypes; i++)
   {
      // Check the name of the object
      pszObjName = GetName(pObject->ObjectNameTitleIndex);

      if (pszObjName != NULL)
      {
         // Object has a name string
         if (strcmp(pszObjName, pszObjPath) == 0)
         {
            // Found the request object
            bItemFound = TRUE;
            break;
         }
      }

      // Get the next object
      pObject = NextObject(pObject);
   }

   // Check if the object was found
   if (bItemFound == FALSE)
   {
      pObject = NULL;
   }

   // return NULL or a pointer to the object
   return(pObject);
}

////////////////////////////////////////////////////////////////////////////////
// Format the data as a text string.
//
char *FormatCounterData(void *pData, DWORD dwCounterType)
{
   union _DataType
   {
      void     *pVoid;
      DWORD    *pdwData;
      LONG64   *pllData;
      char     *pszData;
      WCHAR    *pwzData;
   }  Counter;

   Counter.pVoid = pData;

   if ((dwCounterType & PERF_TYPE_TEXT) == PERF_TYPE_TEXT)
   {
      if ((dwCounterType & PERF_TEXT_ASCII) != 0)
      {
         // ASCII text
         sprintf(g_szPerfData, "%s", Counter.pszData);
      }
      else
      {
         // Unicode text
         wcstombs(g_szPerfData, Counter.pwzData, sizeof(g_szPerfData));
      }
   }
   else
   if ((dwCounterType & PERF_TYPE_ZERO) == PERF_TYPE_ZERO)
   {
      sprintf(g_szPerfData, "%s", "0");
   }
   else
   {
      if (dwCounterType & PERF_SIZE_LARGE)
      {
         sprintf(g_szPerfData, "%I64d", *Counter.pllData);
      }
      else
      {
         sprintf(g_szPerfData, "%d", *Counter.pdwData);
      }
   }

   return(g_szPerfData);
}

////////////////////////////////////////////////////////////////////////////////
// Return a formatted data string for the object counter
//
char *GetCounterData(PERF_OBJECT_TYPE *pObject,
                     PERF_COUNTER_DEFINITION *pCounter)
{
   PERF_COUNTER_BLOCK   *pCtrBlock;
   void                 *pData;

   pCtrBlock= (PERF_COUNTER_BLOCK *)((PCHAR)pObject + pObject->DefinitionLength);

   pData    = (PVOID)((PCHAR)pCtrBlock + pCounter->CounterOffset);

   return(FormatCounterData(pData, pCounter->CounterType));
}

////////////////////////////////////////////////////////////////////////////////
// Return a formatted data string for the object instance counter
//
char  *GetInstanceCounterData(PERF_INSTANCE_DEFINITION *pInstance,
                              PERF_COUNTER_DEFINITION *pCounter)
{
   PERF_COUNTER_BLOCK   *pCtrBlock;
   void                 *pData;

   pCtrBlock= (PERF_COUNTER_BLOCK *)((PCHAR)pInstance + pInstance->ByteLength);

   pData    = (PVOID)((PCHAR)pCtrBlock + pCounter->CounterOffset);

   return(FormatCounterData(pData, pCounter->CounterType));
}



////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// Get data for a given object, instance, and counter
//
BOOL xpcMmqGetCntrList(char *pObjPath, char *pInstPath, char *pCntrPath, char *pszResult, DWORD dwLen)
{
   DWORD    i;

   PERF_COUNTER_DEFINITION    *pCurrCounter;
   CHAR                       *pszName;
   WCHAR                      wzCntrPath[256];

   PERF_DATA_BLOCK            *pDataBlock;
   PERF_OBJECT_TYPE           *pObject;
   PERF_COUNTER_DEFINITION    *pCounter;

   FILETIME       FileTime;
   ULONGLONG      ullClockTime;

   // Insure all arguments were given
   if ((pObjPath           == NULL) ||
       (strlen(pObjPath)   == 0   ))
   {
      // An error occured - Do not continue
      strcpy(g_szErrReturn, "ERROR - No Object (arg1)");

      if (fDebug)
	      printf("   %s\n", g_szErrReturn);
      return FALSE;
   }

   if ((pInstPath          == NULL) ||
       (strlen(pInstPath)  == 0   ))
   {
      // An error occured - Do not continue
      strcpy(g_szErrReturn, "ERROR - No Instance (arg2)");

      if (fDebug)
	      printf("   %s\n", g_szErrReturn);
      return FALSE;
   }

   if ((pCntrPath          == NULL) ||
       (strlen(pCntrPath)  == 0   ))
   {
      // An error occured - Do not continue
      strcpy(g_szErrReturn, "ERROR - No Counter (arg3)");

      if (fDebug)
	      printf("   %s\n", g_szErrReturn);
      return FALSE;
   }
   memset(wzCntrPath, 0, sizeof(wzCntrPath));
   mbstowcs(wzCntrPath, pCntrPath, strlen(pCntrPath));

   // Clear the reply list
   memset(g_pszReplyList, 0, g_dwReplyMax);
   g_dwReplyIndex = 0;

   // Get a list of performance data for the given object name
   pDataBlock = (PERF_DATA_BLOCK *)GetObjectList(pObjPath);
   if (pDataBlock == NULL)
   {
      if (fDebug)
	      printf("   No data found object '%s'\n", pObjPath);
   }
   else
   {
      // Get the current system time
      GetSystemTimeAsFileTime(&FileTime);
      ullClockTime = ((ULONGLONG)(FileTime.dwHighDateTime) << 32) +
                      (ULONGLONG)(FileTime.dwLowDateTime);

      // Get pointer to the first object and try to locate the requested object
      if (fDebug)
	      printf("   Locating object '%s'\n", pObjPath);
      pObject  = SearchObjectList(pDataBlock, pObjPath);
      if (pObject == NULL)
      {
         // Desired object was not found
		  if (fDebug)
	         printf("   Object not found\n");
      }
      else
      {
         // Desired Object was found
		 if (fDebug)
	         printf("   Object found\n");

         // Get pointer to the fist counter
         pCounter = FirstCounter(pObject);

         if (pObject->NumInstances == PERF_NO_INSTANCES)
         {
            if (fDebug)
			   printf("   Object does not have instances\n");

            // Object cannot have instances - Return all counters
            pCurrCounter = pCounter;
            for (i = 0; i < pObject->NumCounters; i++)
            {
               if (pCurrCounter->CounterType & PERF_COUNTER_NODATA)
               {
                  // No data associated with this counter
               }
               else
               {
                  // Get the name of the counter
                  pszName    = GetName(pCurrCounter->CounterNameTitleIndex);

                  // Check for specific counter to be returned
                  if (strcmp(pCntrPath, "*") != 0)
                  {
                     // Check if this is the correct counter
                     if (strcmp(pCntrPath, pszName) != 0)
                     {
                        // Not the correct counter
                        // Get the next counter and continue
                        pCurrCounter   = NextCounter(pCurrCounter);
                        continue;
                     }
                  }

				    char *p = GetCounterData(pObject, pCurrCounter);
					if (p && strlen(p) < dwLen)
					{
						strcpy(pszResult, p);
						return TRUE;
					}
					else
						return FALSE;
               }

               // Get the next counter
               pCurrCounter   = NextCounter(pCurrCounter);
            }
         }
         else
         {
            // Object can have instances
			printf("error - using perf counter for object with instances - not in code");
			return FALSE;
		 }
      }
   }

   return FALSE;
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

BOOL PerfAction(char  *pObjPath, char  *pCntrPath, ULONG *pulResult)
{
   BOOL fSuccess = TRUE;
   char  *pInstPath = "0";

   //DWORD   iSize = sizeof(g_szComputerName) / sizeof(WCHAR);
   //GetComputerName(g_szComputerName, &iSize);

   //g_szVersionString[0] = 0;

   g_dwReplyMax         =
   g_dwReplySize        = 200;
   g_pszReplyList       = new char [g_dwReplySize];

   // Allocate a buffer for the performance data
   g_dwPerfBuffLen      =
   g_dwPerfBuffMax      = 1024 * 20;
   g_pbyPerfBuff        = new BYTE [g_dwPerfBuffMax];

   // Get the Object and Counter Names array
   g_pNamesArray        = NULL;
   g_dwNamesArraySize   = 0;

   g_pNameStrings       = NULL;
   g_dwNameStringsLen   = 0;
   GetNameStrings();

   memset(g_wszFmtNameBuff, 0, MAX_FMT_BUFF_LEN);

	char szResult[100];
	fSuccess = xpcMmqGetCntrList(pObjPath, pInstPath, pCntrPath, szResult, sizeof(szResult));
	if (fSuccess && pulResult)
	{
		int ii = atoi(szResult);
		*pulResult = (ii>=0? ii : 0xFFFFFFFF + ii);
	}

   if (g_pszReplyList != NULL)
   {
      delete [] g_pszReplyList;
   }

   if (g_pbyPerfBuff != NULL)
   {
      delete [] g_pbyPerfBuff;
   }

   if (g_pNamesArray != NULL)
   {
      delete [] g_pNamesArray;
   }

   if (g_pNameStrings != NULL)
   {
      delete [] g_pNameStrings;
   }

   return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\service.cpp ===
// MQState tool reports general status and helps to diagnose simple problems
// This file reports the MSMQ service state
//
// AlexDad, March 2000
// 

#include "stdafx.h"
#include "_mqini.h"

BOOL VerifyServiceState(MQSTATE * /* MqState */)
{
	BOOL fSuccess = TRUE;

	/*++
	Borrowed from nt\private\inet\iis\ui\setup\osrc\kill.cpp

	Routine Description:
    	Provides an API for getting a list of tasks running at the time of the
	    API call.  This function uses internal NT apis and data structures.  This
    	api is MUCH faster that the non-internal version that uses the registry.
	Arguments:
    	dwNumTasks       - maximum number of tasks that the pTask array can hold
	Return Value:
    	Number of tasks placed into the pTask array.
	--*/

    PUCHAR                       CommonLargeBuffer     = NULL;
	ULONG                        CommonLargeBufferSize = 64*1024;


    while (CommonLargeBuffer == NULL) 
    {
        CommonLargeBuffer = (PUCHAR) new UCHAR[CommonLargeBufferSize];
        if (CommonLargeBuffer == NULL) 
        {
        	Failed(L"get memoru for the process info");
            return FALSE;
        }
	    NTSTATUS status = NtQuerySystemInformation(SystemProcessInformation,
									  CommonLargeBuffer,
									  CommonLargeBufferSize,
									  NULL);
    	if (status == STATUS_INFO_LENGTH_MISMATCH) 
    	{
        	CommonLargeBufferSize += 8192;
        	delete [] CommonLargeBuffer;
        	CommonLargeBuffer = NULL;
    	}
    	else if (!NT_SUCCESS(status))
    	{
    		Failed(L"get process info, 0x%x", GetLastError());
    		delete [] CommonLargeBuffer;
    		return FALSE;
    	}
    }

    PSYSTEM_PROCESS_INFORMATION ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) CommonLargeBuffer;
    ULONG TotalOffset = 0;
    BOOL  fEnd = FALSE;
    while (!fEnd) 
    {
   
       ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&CommonLargeBuffer[TotalOffset];
       TotalOffset += ProcessInfo->NextEntryOffset;
       if (ProcessInfo->NextEntryOffset == 0) 
            fEnd = TRUE;

   	   if (ProcessInfo->ImageName.Buffer == NULL)
   	   		continue;
   	   
       if (_wcsicmp(ProcessInfo->ImageName.Buffer, L"mqsvc.exe")!=NULL)
        	continue;

 		// Here is the process

		Inform(L"Process data for the service:");
		Inform(L"\tPID:                       %d", ProcessInfo->UniqueProcessId);
		Inform(L"\tNumber Of Threads:         %d", ProcessInfo->NumberOfThreads);
		Inform(L"\tNumber Of Handles:         %d", ProcessInfo->HandleCount);

		Inform(L"\tWorking Set Size :         %d", ProcessInfo->WorkingSetSize);
		if (fVerbose)
		{
			Inform(L"\tPeak Working Set Size :    %d", ProcessInfo->PeakWorkingSetSize);
		}

		Inform(L"\tVirtual Size :             %d", ProcessInfo->VirtualSize);
		if (fVerbose)
		{
			Inform(L"\tPeak Virtual Size :        %d", ProcessInfo->PeakVirtualSize);
		}
		
		if (fVerbose)
		{
			Inform(L"\tPrivatePage Count:         %d", ProcessInfo->PrivatePageCount);
			Inform(L"\tPeak Pagefile Usage:       %d", ProcessInfo->PeakPagefileUsage);
			Inform(L"\tPagefile Usage:            %d", ProcessInfo->PagefileUsage);
			Inform(L"\tPeak Paged Pool Usage:     %d", ProcessInfo->QuotaPeakPagedPoolUsage);
			Inform(L"\tPaged Pool Usage:          %d", ProcessInfo->QuotaPagedPoolUsage);
			Inform(L"\tPeak NonPaged Pool Usage:  %d", ProcessInfo->QuotaPeakNonPagedPoolUsage);
			Inform(L"\tNon Paged Pool Usage:      %d", ProcessInfo->QuotaNonPagedPoolUsage);
		}

		//Inform(L"\tx :            %d", ProcessInfo->x);
	    //LARGE_INTEGER CreateTime;
	    //LARGE_INTEGER UserTime;
	    //LARGE_INTEGER KernelTime;
	    //KPRIORITY BasePriority;
	    //HANDLE InheritedFromUniqueProcessId;
	    //ULONG SessionId;
	    //ULONG PageFaultCount;
	    //LARGE_INTEGER ReadOperationCount;
	    //LARGE_INTEGER WriteOperationCount;
	    //LARGE_INTEGER OtherOperationCount;
	    //LARGE_INTEGER ReadTransferCount;
	    //LARGE_INTEGER WriteTransferCount;
	    //LARGE_INTEGER OtherTransferCount;

       	
      }


	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\regdata.h ===
mqRegKey g_aTableWorkgroup[] = 
{
    {L"CleanupInterval",								0x000493e0,			NULL,	MQKEY_MANDATORY,  TRUE },
    {L"Connection State",								1,					NULL,	MQKEY_MANDATORY,  TRUE },
    {L"CurrentBuild",									0,			  L"5.0.641",	MQKEY_MANDATORY,  FALSE},
    {L"DsSecurityCache",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"LastPrivateQueueId", 							0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MaxSysQueue",									0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MessageID",										0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"MsmqRootPath",									0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"LogDataCreated",									1,					NULL,	MQKEY_MANDATORY,  TRUE },
    {L"SeqID",											0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"StoreJournalPath",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"StoreLogPath",									0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"StorePersistentPath",							0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"StoreReliablePath",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"StoreXactLogPath",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"TransactionMode",								0,		L"DefaultCommit",	MQKEY_MANDATORY,  TRUE },
    {L"Workgroup",										1,					NULL,	MQKEY_MANDATORY,  TRUE },

    {L"CertificationAuthorities",						0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"CertificationAuthorities\\Certificates",			0,					NULL,	MQKEY_IGNORE,	  FALSE},

    {L"Debug",											0,					NULL,	MQKEY_OPTIONAL,   FALSE},

    {L"MachineCache",									0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"MachineCache\\MachineJournalQuota",				0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\MachineQuota",						0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\MQS",								0,					NULL,	MQKEY_MANDATORY,  TRUE },
    {L"MachineCache\\MQS_DepClients",					0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\MQS_Dsserver",						0,					NULL,	MQKEY_MANDATORY,  TRUE },
    {L"MachineCache\\MQS_Routing",						0,					NULL,	MQKEY_MANDATORY,  TRUE },
    {L"MachineCache\\QMID",								0,					NULL,	MQKEY_MANDATORY,  FALSE},

    {L"OCMSetup",										0,					NULL,	MQKEY_OPTIONAL,   FALSE},

    {L"OnHold Queues",									0,					NULL,	MQKEY_IGNORE,     FALSE},

    {L"Security",										0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"Security\\SecureDSCommunication",				0,					NULL,	MQKEY_MANDATORY,  FALSE},
	
    {L"Setup",											0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"Setup\\OSType",									0,					NULL,	MQKEY_MANDATORY,  FALSE},

    {L'\0',												0,					NULL,	MQKEY_MANDATORY,  FALSE}
};  

mqRegKey g_aTableDepClient[] = 
{
    {L"CurrentBuild",									0,			  L"5.0.641",	MQKEY_MANDATORY,  FALSE},
    {L"MsmqRootPath",									0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"RemoteQMMachine",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"SetupStatus",									1,					NULL,	MQKEY_MANDATORY,  TRUE },

    {L"CertificationAuthorities",						0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"CertificationAuthorities\\Certificates",			0,					NULL,	MQKEY_IGNORE,	  FALSE},

    {L"Debug",											0,					NULL,	MQKEY_OPTIONAL,   FALSE},

    {L"MachineCache",									0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"MachineCache\\EnterpriseID",						0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\LongLiveTime",						90,					NULL,	MQKEY_MANDATORY,  TRUE },
    {L"MachineCache\\MQISServer",						0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\QMID",								0,					NULL,	MQKEY_MANDATORY,  FALSE},

    {L"Security",										0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"Security\\SecureDSCommunication",				0,					NULL,	MQKEY_MANDATORY,  FALSE},
	
    {L"Setup",											0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"Setup\\MachineDomain",							0,					NULL,	MQKEY_MANDATORY,  FALSE},

    {L'\0',												0,					NULL,	MQKEY_MANDATORY,  FALSE}
};

mqRegKey g_aTableIndClient[] = 
{
    {L"CleanupInterval",								120000,				NULL,	MQKEY_MANDATORY,  TRUE },
    {L"Connection State",								1,					NULL,	MQKEY_MANDATORY,  TRUE },
    {L"CurrentBuild",									0,			  L"5.0.641",	MQKEY_MANDATORY,  FALSE},
    {L"DsSecurityCache",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"LastPrivateQueueId", 							0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MaxSysQueue",									0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MessageID",										0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"MsmqRootPath",									0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"LogDataCreated",									1,					NULL,	MQKEY_MANDATORY,  TRUE },
    {L"SeqID",											0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"StoreJournalPath",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"StoreLogPath",									0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"StorePersistentPath",							0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"StoreReliablePath",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"StoreXactLogPath",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"TransactionMode",								0,		L"DefaultCommit",	MQKEY_MANDATORY,  TRUE },

    {L"CertificationAuthorities",						0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"CertificationAuthorities\\Certificates",			0,					NULL,	MQKEY_IGNORE,	  FALSE},

    {L"Debug",											0,					NULL,	MQKEY_OPTIONAL,   FALSE},

    {L"MachineCache",									0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"MachineCache\\Address",							0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\CNs",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\CurrentMQISServer",				0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\EnterpriseID",						0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\LkgMQISServer",					0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\LongLiveTime",						90,					NULL,	MQKEY_MANDATORY,  TRUE },
    {L"MachineCache\\MachineJournalQuota",				0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\MachineQuota",						0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\MQISServer",						0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\MQS",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\MQS_DepClients",					1,					NULL,	MQKEY_MANDATORY,  TRUE },
    {L"MachineCache\\MQS_Dsserver",						0,					NULL,	MQKEY_MANDATORY,  TRUE },
    {L"MachineCache\\MQS_Routing",						0,					NULL,	MQKEY_MANDATORY,  FALSE },
    {L"MachineCache\\QMID",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\SiteID",							0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\SiteName",							0,					NULL,	MQKEY_MANDATORY,  FALSE},

    {L"OCMSetup",										0,					NULL,	MQKEY_OPTIONAL,  FALSE},

    {L"OnHold Queues",									0,					NULL,	MQKEY_IGNORE,	  FALSE},

    {L"Security",										0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"Security\\BaseContainerFixed",					0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"Security\\EnhContainerFixed",					0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"Security\\MachineAccount",						0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"Security\\SecureDSCommunication",				0,					NULL,	MQKEY_OPTIONAL,   FALSE},
	
    {L"Setup",											0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"Setup\\MachineDN",								0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"Setup\\MachineDomain",							0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"Setup\\OSType",									0,					NULL,	MQKEY_MANDATORY,  FALSE},

    {L"ServersCache",									0,					NULL,	MQKEY_IGNORE,     FALSE},

    {L'\0',												0,					NULL,	MQKEY_MANDATORY,  FALSE}
};

mqRegKey g_aTableDsDerver[] = 
{
    {L"CleanupInterval",								120000,				NULL,	MQKEY_MANDATORY,  TRUE },
    {L"Connection State",								1,					NULL,	MQKEY_MANDATORY,  TRUE },
    {L"CurrentBuild",									0,			  L"5.0.641",	MQKEY_MANDATORY,  FALSE},
    {L"DsSecurityCache",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"LastPrivateQueueId", 							0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"LogDataCreated",									1,					NULL,	MQKEY_MANDATORY,  TRUE },
    {L"MaxSysQueue",									0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MessageID",										0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"MsmqRootPath",									0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"SeqID",											0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"StoreJournalPath",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"StoreLogPath",									0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"StorePersistentPath",							0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"StoreReliablePath",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"StoreXactLogPath",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"TransactionMode",								0,		L"DefaultCommit",	MQKEY_MANDATORY,  TRUE },

    {L"Debug",											0,					NULL,	MQKEY_OPTIONAL,   FALSE},

    {L"MachineCache",									0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"MachineCache\\Address",							0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\CNs",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\CurrentMQISServer",				0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\EnterpriseID",						0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\LongLiveTime",						90,					NULL,	MQKEY_MANDATORY,  TRUE },
    {L"MachineCache\\MachineJournalQuota",				0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\MachineQuota",						0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\MQISServer",						0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\MQS",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\MQS_DepClients",					1,					NULL,	MQKEY_MANDATORY,  TRUE },
    {L"MachineCache\\MQS_Dsserver",						1,					NULL,	MQKEY_MANDATORY,  TRUE },
    {L"MachineCache\\MQS_Routing",						0,					NULL,	MQKEY_MANDATORY,  FALSE },
    {L"MachineCache\\QMID",								0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\SiteID",							0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"MachineCache\\SiteName",							0,					NULL,	MQKEY_OPTIONAL,   FALSE},

    {L"OnHold Queues",									0,					NULL,	MQKEY_IGNORE,	  FALSE},

    {L"Security",										0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"Security\\BaseContainerFixed",					0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"Security\\EnhContainerFixed",					0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"Security\\MachineAccount",						0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"Security\\SecureDSCommunication",				0,					NULL,	MQKEY_OPTIONAL,   FALSE},
	
    {L"Setup",											0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"Setup\\MachineDN",								0,					NULL,	MQKEY_OPTIONAL,   FALSE},
    {L"Setup\\MachineDomain",							0,					NULL,	MQKEY_MANDATORY,  FALSE},
    {L"Setup\\OSType",									0,					NULL,	MQKEY_MANDATORY,  FALSE},

    {L"ServersCache",									0,					NULL,	MQKEY_IGNORE,     FALSE},

    {L'\0',												0,					NULL,	MQKEY_OPTIONAL,   FALSE}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\mqstate.cpp ===
// This tool helps to report MSMQ state and diagnose some of the simplest problems 
//
// AlexDad, March 2000
// 

#include "stdafx.h"
#include "_mqini.h"
#include <winsvc.h>

#define QUEUES_LIMIT   5
#define EVENTS_LIMIT   5


// Globals
MQSTATE MqState;    				// What we know so far...
TCHAR g_tszService[50] = L"MSMQ";   // service name

DWORD g_cEvents     = EVENTS_LIMIT; // events limit
DWORD g_cOpenQueues = QUEUES_LIMIT; // quues limit

extern BOOL DoTheJob();
extern BOOL VerifyGeneralEnv(MQSTATE *MqState);
extern BOOL VerifySetup(MQSTATE *MqState);
extern BOOL VerifyVersions(MQSTATE *MqState);
extern BOOL VerifyServiceState(MQSTATE *MqState);
extern BOOL VerifyRegistrySettings(MQSTATE *MqState);
extern BOOL VerifyDiskUsage(MQSTATE *MqState);
extern BOOL VerifyMemoryUsage(MQSTATE *MqState);
extern BOOL VerifyDomainState(MQSTATE *MqState);
extern BOOL VerifyDsConnection(MQSTATE *MqState);
extern BOOL VerifyEvents(MQSTATE *MqState);
extern BOOL VerifyPerfCnt(MQSTATE *MqState);
extern BOOL VerifyLocalSecurity(MQSTATE *MqState);
extern BOOL VerifyDsSecurity(MQSTATE *MqState);
extern BOOL VerifyDC(MQSTATE *MqState);
extern BOOL VerifyQMAdmin(MQSTATE *MqState);
extern BOOL VerifyComponents(MQSTATE *pMqState);


//
// Log control. The get functions below are called from tmqbase.lib
//
bool fVerbose = false;
bool fDebug   = false;
FILE *g_fileLog = NULL;

FILE *ToolLog()			{	return g_fileLog;	}
BOOL ToolVerbose()		{ 	return fVerbose;	}
BOOL ToolVerboseDebug() { 	return fDebug;		}
BOOL ToolThreadReport() { 	return FALSE;		} 

void OpenLogFile()
{
    g_fileLog = fopen( "tmqstate.log", "w" );

    if (g_fileLog)
    {
        time_t  lTime ;
        time( &lTime ) ;
        fprintf(g_fileLog, "tmqstate run at: %ws", _wctime( &lTime ) );
    }
}

void CloseLogFile()
{
    fflush(g_fileLog);
    fclose(g_fileLog);
}

// 
// Main logic of the tool
//
BOOL DoTheJob()
{
	BOOL fSuccess = TRUE, b;

	//--------------------------------------------------------------------------------
	GoingTo(L"review general environment"); 
	
	//+	W2K version, flavor (pro, srv, etc.), platform and type (release/checked)
	//-	Machine in domain or workgroup (compare to registry setting and join status)
	//+	Machine, Date, Time
	//-	gflags
	//--------------------------------------------------------------------------------

	b = VerifyGeneralEnv(&MqState);
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L"review general environment");
	}
	else
	{
		Succeeded(L"review general environment");
	}


	//--------------------------------------------------------------------------------
	GoingTo(L" review domain state"); 
	//--------------------------------------------------------------------------------

	b = VerifyDomainState(&MqState);
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L" pass domain membership verification");
	}
	else
	{
		Succeeded(L" pass domain membership verification");
	}


	//--------------------------------------------------------------------------------
	GoingTo(L" review MSMQ setup"); 
	
	//-   is msmq installed?
	//-	Did setup leave msmqinst.log? 
	//-	Workgroup or not ?
	//-	State of join (join failed, succeeded, never done)
	//-	Service on cluster node is set to manual
	//-	Check CALs.
	//--------------------------------------------------------------------------------

	b =  VerifySetup(&MqState);
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L"pass MSMQ setup verification");
	}
	else
	{
		Succeeded(L"pass MSMQ setup verification");
	}

	if (!MqState.fMsmqIsInstalled) 
	{
		Inform(L"No need to continue - MSMQ is not installed");
		return FALSE;
	}


	//--------------------------------------------------------------------------------
	GoingTo(L" review MSMQ setup"); 
	
	//-	MSMQ version and type (release/checked)
	//-	Existence and correct versions of required program files
	//--------------------------------------------------------------------------------

	b =  VerifyVersions(&MqState);
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L"pass MSMQ versioning verification");
	}
	else
	{
		Succeeded(L"pass MSMQ versioning verification");
	}

	//--------------------------------------------------------------------------------
	GoingTo(L" review installed MSMQ setup components"); 
	
	//-	MSMQ version and type (release/checked)
	//-	Existence and correct versions of required program files
	//--------------------------------------------------------------------------------

	if (MqState.g_dwVersion >= 950)
	{
    	b =  VerifyComponents(&MqState);
    	if(!b)
    	{
    		fSuccess = FALSE;
    		Failed(L"pass MSMQ components verification");
    	}
    	else
    	{
    		Succeeded(L"pass MSMQ components verification");
    	}
	}
	
	//--------------------------------------------------------------------------------
	GoingTo(L"review MSMQ service state"); 
	
	// Verify current state of  MSMQ
	//-   is service running?
	//-	outgoing queues size and resend status. Draw attention to "on hold" queues
	//-	mqsvc process state (runs/not, # of handles, memory size, etc.)
	//-	low virtual memory?
	//--------------------------------------------------------------------------------

	if (MqState.g_mtMsmqtype != mtDepClient)
	{
		b = VerifyServiceState(&MqState);
		if(!b)
		{
			fSuccess = FALSE;
			Failed(L"...");
		}
		else
		{
			Succeeded(L"...");
		}
	}


	//--------------------------------------------------------------------------------
	GoingTo(L"review registry settings"); 

	//Registry
	//-	Existence of keys
	//-	Correct or reasonable values of keys
	//-	NB - non-standard keys set
	//--------------------------------------------------------------------------------

	b = VerifyRegistrySettings(&MqState);
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L"pass registry settings verification");
	}
	else
	{
		Succeeded(L"verify registry settings");
	}

	//--------------------------------------------------------------------------------
	GoingTo(L"review disk usage"); 
	//Storage (Existence & resources)
	//   Check files existence, used and available resources (disk space and memory)
	//-	Location of storage directory - per message type 
	//-	Total size of message store (cry if close to the constraints)
	//-	Separately - recoverable, express, journal
	//-	Correct P/L file pairs?
	//-	Enough free space on the disk?
	//-	Existence of  Qmlog, MQTrans, MQInseq files (maybe run dmp in verbose mode)
	//--------------------------------------------------------------------------------

	if (MqState.g_mtMsmqtype != mtDepClient)
	{
		b = VerifyDiskUsage(&MqState);
		if(!b)
		{
			fSuccess = FALSE;
			Failed(L" pass disk usage verification");
		}
		else
		{
			Succeeded(L" pass disk usage verification");
		}
	}

	//--------------------------------------------------------------------------------
	GoingTo(L" review memory usage"); 
	// - report sizes of physical memory
	// - report sizes and usage of paged/non-paged pool
	//-	Enough RAM? Compare Msgs/bytes number to kernel memory limits (find calculation in driver)
	//-	low virtual memory?
	//--------------------------------------------------------------------------------

	b = VerifyMemoryUsage(&MqState);
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L" pass memory usage verification");
	}
	else
	{
		Succeeded(L" pass memory usage verification");
	}


	//--------------------------------------------------------------------------------
	GoingTo(L" review DS connection "); 

	// Verify current state of  MSMQ
	//-	connection status (offline, connected,)
	//-	site (autorec) compare registry to actual site. DnsHostName on servers
	//-	outgoing queues size and resend status. Draw attention to "on hold" queues

	//DS static
	//Verify MSMQ-related DS data (regarding specific machine or generally)
	//-	msmq service object (adsi code, unrelated to msmq)
	//-	msmq settings objects in all relevant sites
	//-	msmq config objects in all relevant computers. 
	//-	DnsHostName of local computer
	//-	routing links

	//DS dynamic
	//Verify dynamics of distributed connections
	//-	known DS servers and their availability (ping each ds server with msmq rpc interface, e.g. S_DSIsServerGC())
	//-	success of LDAP queries to the relevant servers (for msmq3, where ldap client run on each msmq client)
	//--------------------------------------------------------------------------------

	b = VerifyDsConnection(&MqState);
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L" pass DS connection verification");
	}
	else
	{
		Succeeded(L"pass DS connection verification");
	}

	//--------------------------------------------------------------------------------
	GoingTo(L" review recent events"); 
	//-	Print all errors since last reboot (both system and app).
	//-	Print all msmq events since last reboot.
	//-	any past MSMQ errors (or all events in verbose mode)
	//--------------------------------------------------------------------------------

	b = VerifyEvents(&MqState);
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L" pass events verification");
	}
	else
	{
		Succeeded(L"pass events verification");
	}

	//--------------------------------------------------------------------------------
	GoingTo(L" review performance counters"); 
	// deadletter queues
	// total sizes and other statistics
	// current load inc/out/etc (wait a bit to gather)
	//--------------------------------------------------------------------------------

	b = VerifyPerfCnt(&MqState);
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L"pass performance counters verification");
	}
	else
	{
		Succeeded(L"pass performance counters verification");
	}


	//--------------------------------------------------------------------------------
	GoingTo(L" review local security"); 
	
	//-	Check account of msmq service
	//-	Check existence of machine crypto keys.
	//-	Check security of messages directory
	//-	Check that Kerberos is enabled and functional.
	//--------------------------------------------------------------------------------

	b = VerifyLocalSecurity(&MqState);
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L"verify local security");
	}
	else
	{
		Succeeded(L"verify local security");
	}

	//--------------------------------------------------------------------------------
	GoingTo(L"review DS security"); 
	
	//- Public key of local computer is registered in DS
	//- Check that security descriptor of object makes sense and gives enough 
	//   permissions to the msmq service. Check security descriptor of msmqConfiguration and of Computer object.
	//--------------------------------------------------------------------------------

	b = VerifyDsSecurity(&MqState);
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L"verify DS security");
	}
	else
	{
		Succeeded(L"verify DS security");
	}

	//--------------------------------------------------------------------------------
	GoingTo(L"review MSMQ on domain controller"); 
	
	//-	Trust delegation
	//-	GC or not
	//-	Check for msmq weaken security
	//-	Check for Win2k weaken security
	//-	Report NT4 stub sites
	//-	Check foreign sites (check correct configuration need for foreign, site gates, etc..)
	//-	Win2k subnets ?
	//Maybe verify correctness of topology: GC where needed, routing links get to all MSMQ computers, etc.)
	//--------------------------------------------------------------------------------

	b = VerifyDC(&MqState);
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L"verify MSMQ on domain controller");
	}
	else
	{
		Succeeded(L"verify MSMQ on domain controller");
	}


    //--------------------------------------------------------------------------------
	GoingTo(L"Use admin API to get QM state"); 
	//--------------------------------------------------------------------------------

	b = VerifyQMAdmin(&MqState);
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L"Use admin API to get QM state");
	}
	else
	{
		Succeeded(L"Use admin API to get QM state");
	}

    //--------------------------------------------------------------------------------
	GoingTo(L"..."); 
	//--------------------------------------------------------------------------------

	b = TRUE;
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L"...");
	}
	else
	{
		Succeeded(L"...");
	}


	return fSuccess;
}

//
//  help
//
void Usage()
{
	printf("usage: state [-v]  [-d] [-s <service_name>] [-e <events limit>] -q <queues limit>]\n");
	printf("\nThe tool gathers a lot of relevant MSMQ data, analyzes it and warns about any strange things\n");
	printf("Nothing is written, changed or touched, so the tool may run in parallel to MSMQ service\n");
	printf(" -v gives more information, and the most verbose mode is -d\n");
	printf(" -e limits printing of recent MSMQ or error events, the default is 5\n");
	printf(" -q limits printing of outgoing queues information (without -v or -d, only counter is printed)\n");
}

//
//  Main entry point - called from the tmq.exe 
//
int _stdcall run( int argc, char *argv[ ])
{
	ZeroMemory(&MqState, sizeof(MqState));

    //
    // Parse parameters
    //

	for (int i=2; i<argc; i++)
	{
		if (*argv[i] != '-' && *argv[i] != '/')
		{
			printf("Invalid parameter '%S'.\n\n", argv[i]);
            Usage();
		}

		switch (tolower(*(++argv[i])))
		{
		    case 'v':
			    fVerbose = true;
			    break;

		    case 'd':
			    fDebug = true;
			    fVerbose = true;
			    break;

            case 's':
				if (strlen(argv[i]) > 3)
				{
					mbstowcs(g_tszService, argv[i] + 2, sizeof(g_tszService));
				}
				else if (i+1 < argc)
				{
					mbstowcs(g_tszService, argv[++i], sizeof(g_tszService));
				}
				else
				{
					Usage();
					exit(0);
				}
			    break;

            case 'e':
				if (strlen(argv[i]) > 3)
				{
					g_cEvents = atoi(argv[i] + 2);
				}
				else if (i+1 < argc)
				{
					g_cEvents = atoi(argv[++i]);
				}
				else
				{
					Usage();
					exit(0);
				}
			    break;

            case 'q':
				if (strlen(argv[i]) > 3)
				{
					g_cOpenQueues = atoi(argv[i] + 2);
				}
				else if (i+1 < argc)
				{
					g_cOpenQueues = atoi(argv[++i]);
				}
				else
				{
					Usage();
					exit(0);
				}
			    break;

			    
		    default:
			    printf("Unknown switch '%s'.\n\n", argv[i]);
                Usage();
			    exit(0);
		}
	}

    //
    //  we don't want to run in parallel with MSMQ service 
    //
    if (IsMsmqRunning(g_tszService))
    {
        Inform(L"MSMQ service is running");
        MqState.fMsmqIsRunning = TRUE;   

    }
    else
    {
        Warning(L"MSMQ service is not running");
        MqState.fMsmqIsRunning = FALSE;   
    }

	//Inform(L"Starting Thread is t%3x", GetCurrentThreadId());

    //
    // Create tmqstate.log - log file in current directory
    //
    OpenLogFile();

    Inform(L"TMQ State reviews %s state", g_tszService);

	// actual work
    BOOL b = DoTheJob();

	if (b)
	{
		Inform(L"\n\n+++++++ MSMQ State seems healthy ++++++++\n");
	}
	else
	{
		Inform(L"\n\n-------- TMQ State has found problems  ---------\n");
	}

	CloseLogFile();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
#define AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

extern "C"
{
//	#include <winnt.h>                                            
	#include <nt.h>                                            
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <ntexapi.h>
}

// TODO: reference additional headers your program requires here
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <tchar.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>
#include <wtypes.h>
#include <propidl.h>

#include "..\\base\\base.h" 
#include "mqstate.h" 


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\setup.cpp ===
// MQState tool reports general status and helps to diagnose simple problems
// This file ...
//
// AlexDad, March 2000
// 

#include "stdafx.h"
#include "_mqini.h"

#define SECURITY_WIN32
#include <security.h>
#include "..\..\..\setup\msmqocm\setupdef.h"

// From msmqocm\setupdef.h
//
#define LOG_FILENAME            TEXT("msmqinst.log")

// Frpm mqutil\report.h
//
const WCHAR x_wszLogFileName[]   = L"\\debug\\msmq.log";

	//+   is msmq installed?
	//-	Did setup leave msmqinst.log? 
	//+	Workgroup or not ?
	//+	State of join (join failed, succeeded, never done)
	//-	Service on cluster node is set to manual
	//-	Check CALs.

BOOL CheckComponentsInstalled(MQSTATE *pMqState)
{
     BOOL b = TRUE;
     
     if (!MqReadRegistryValue(MSMQ_CORE_SUBCOMP, 
                              sizeof(DWORD), 
                              &pMqState->f_msmq_Core, 
                              TRUE))
   		b= FALSE;
	
     if (!MqReadRegistryValue(MQDSSERVICE_SUBCOMP, 
                              sizeof(DWORD), 
                              &pMqState->f_msmq_MQDSService, 
                              TRUE))
   		b= FALSE;
     
     if (!MqReadRegistryValue(TRIGGERS_SUBCOMP, 
                              sizeof(DWORD), 
                              &pMqState->f_msmq_TriggersService, 
                              TRUE))
   		b= FALSE;
     
     if (!MqReadRegistryValue(HTTP_SUPPORT_SUBCOMP, 
                              sizeof(DWORD), 
                              &pMqState->f_msmq_HTTPSupport, 
                              TRUE))
   		b= FALSE;
     
     if (!MqReadRegistryValue(AD_INTEGRATED_SUBCOMP, 
                              sizeof(DWORD), 
                              &pMqState->f_msmq_ADIntegrated, 
                              TRUE))
   		b= FALSE;
     
     if (!MqReadRegistryValue(ROUTING_SUBCOMP, 
                              sizeof(DWORD), 
                              &pMqState->f_msmq_RoutingSupport, 
                              TRUE))
   		b= FALSE;
     
     if (!MqReadRegistryValue(LOCAL_STORAGE_SUBCOMP, 
                              sizeof(DWORD), 
                              &pMqState->f_msmq_LocalStorage, 
                              TRUE))
   		b= FALSE;

	return b;
}


	
BOOL IsDependentClient(LPWSTR wszRemMachine)
{
	DWORD dwSize = MAX_PATH, dwType = REG_DWORD;
	LONG  rc;
	
    rc = GetFalconKeyValue(RPC_REMOTE_QM_REGNAME, &dwType, wszRemMachine, &dwSize);
    if(rc != ERROR_SUCCESS)
	{
		return FALSE;
	}

	return TRUE;
}


BOOL IsDsServer()
{
	DWORD dw;
	DWORD dwSize = sizeof(dw), dwType = REG_DWORD;
	LONG  rc;
	
    rc = GetFalconKeyValue(MSMQ_MQS_DSSERVER_REGNAME, &dwType, &dw, &dwSize);
    if(rc != ERROR_SUCCESS)
	{
		return FALSE;
	}

	return (dw == 1);
}


BOOL IsRoutingServer()
{
	DWORD dw;
	DWORD dwSize = sizeof(dw), dwType = REG_DWORD;
	LONG  rc;
	
    rc = GetFalconKeyValue(MSMQ_MQS_ROUTING_REGNAME, &dwType, &dw, &dwSize);
    if(rc != ERROR_SUCCESS)
	{
		return FALSE;
	}

	return (dw == 1);
}


BOOL IsDepClientsSupportingServer()
{
	DWORD dw;
	DWORD dwSize = sizeof(dw), dwType = REG_DWORD;
	LONG  rc;
	
    rc = GetFalconKeyValue(MSMQ_MQS_DEPCLINTS_REGNAME, &dwType, &dw, &dwSize);
    if(rc != ERROR_SUCCESS)
	{
		return FALSE;
	}

	return (dw == 1);
}


BOOL IsWorkgroupMode()
{
	DWORD dw;
	DWORD dwSize = sizeof(dw), dwType = REG_DWORD;
	LONG  rc;
	
    rc = GetFalconKeyValue(MSMQ_WORKGROUP_REGNAME, &dwType, &dw, &dwSize);
    if(rc != ERROR_SUCCESS)
	{
		return FALSE;
	}

	return (dw == 1);
}


DWORD GetSetupMode()
{
	DWORD dw;
	DWORD dwSize = sizeof(dw), dwType = REG_DWORD;
	LONG  rc;
	
    rc = GetFalconKeyValue(MSMQ_SETUP_STATUS_REGNAME, &dwType, &dw, &dwSize);
    if(rc != ERROR_SUCCESS)
	{
		return 999;
	}

	return dw;
}


DWORD GetJoinMode()
{
	DWORD dw;
	DWORD dwSize = sizeof(dw), dwType = REG_DWORD;
	LONG  rc;
	
    rc = GetFalconKeyValue(MSMQ_JOIN_STATUS_REGNAME, &dwType, &dw, &dwSize);
    if(rc != ERROR_SUCCESS)
	{
		return 999;
	}

	return dw;
}

BOOL IsThereSpecificFile(LPWSTR pwszPathName, LPWSTR pwszTitle)
{
	WCHAR wszLastWrite[50];
	
    HANDLE hEnum;
    WIN32_FIND_DATA FileData;
    hEnum = FindFirstFile(pwszPathName, &FileData);

    if(hEnum == INVALID_HANDLE_VALUE)
	{
        return FALSE;
	}
	
	SYSTEMTIME stWrite;
	FileTimeToSystemTime(&FileData.ftLastWriteTime,  &stWrite);
	
    wsprintf(wszLastWrite, L"%d:%d:%d %d/%d/%d",	 
	     stWrite.wHour, stWrite.wMinute, stWrite.wSecond, stWrite.wDay,	stWrite.wMonth, stWrite.wYear);

	FindClose(hEnum);
	
	Warning(L"%s %s exists - length %d, last written at %s - please look into it!", 
					pwszTitle, pwszPathName, FileData.nFileSizeLow, wszLastWrite);
					
	return TRUE;
}

BOOL IsThereMSMQINSTfile()
{
    TCHAR wszLogPath[MAX_PATH];
    GetSystemWindowsDirectory(wszLogPath, sizeof(wszLogPath)/sizeof(TCHAR)); 
    lstrcat(wszLogPath, _T("\\"));
    lstrcat(wszLogPath, LOG_FILENAME);

	return IsThereSpecificFile(wszLogPath, L"Setup log file");
}

BOOL IsThereMSMQLOGfile()
{
    TCHAR wszLogPath[MAX_PATH];
    GetSystemWindowsDirectory(wszLogPath, sizeof(wszLogPath)/sizeof(TCHAR)); 
    lstrcat(wszLogPath, x_wszLogFileName);

	return IsThereSpecificFile(wszLogPath, L"MSMQ error log file");
}

BOOL VerifyDnName()
{
	TCHAR wszDN1[524];
	ULONG ulDN1 = sizeof(wszDN1) / sizeof(TCHAR);

	BOOL b = GetComputerObjectName(NameFullyQualifiedDN, wszDN1, &ulDN1);
	if (b)
	{
		if (fVerbose)
		{
			Inform(L"\tGetComputerObjectName reports DN name:  %s", wszDN1);
		}
	}
	else
	{
		Failed(L"get  DN name from GetComputerObjectName: err=0x%x", GetLastError());
		return FALSE;
	}


	TCHAR wszDN2[524];
	DWORD dwSize = sizeof(wszDN2) / sizeof(TCHAR);
	DWORD dwType = REG_SZ;

    HRESULT rc = GetFalconKeyValue(MSMQ_MACHINE_DN_REGNAME, &dwType,wszDN2,&dwSize);
    if(rc != ERROR_SUCCESS)
	{
		Failed(L"get from registry machine DN name, rc=0x%x", rc);
		return FALSE;
	}
	else
	{
		if (fVerbose)
		{
			Inform(L"\tregistry shows DN name: %s", wszDN2);
		}
	}

	if (_wcsicmp(wszDN1, wszDN2) != 0)
	{
		Failed(L"reconcile DN name between registry and Active Directory: \n\t%s \n\t%s", wszDN1, wszDN2); 
		b = FALSE;
	}

	return b;
}

BOOL VerifySetup(MQSTATE *pMqState)
{
	BOOL fSuccess = TRUE, b;
	WCHAR wszRemMachine[MAX_PATH];

	BOOL fDepCl 	 = IsDependentClient(wszRemMachine);
	BOOL fDSServer 	 = IsDsServer();
	BOOL fRoutServer = IsRoutingServer();
	BOOL fSuppServer = IsDepClientsSupportingServer();

    pMqState->fMsmqIsWorkgroup = IsWorkgroupMode();

	//
	// recognize MSMQ type 
	//
	
	if (pMqState->fMsmqIsWorkgroup)
	{
		pMqState->fMsmqIsInstalled = TRUE;
		pMqState->g_mtMsmqtype     = mtWorkgroup;
		
		Inform(L"\tMSMQ installation type:  Workgroup");
	}
	// recognize Dep Client
	else if (fDepCl && !fDSServer && !fRoutServer && !fSuppServer)
	{
		pMqState->fMsmqIsInstalled = TRUE;
		pMqState->g_mtMsmqtype     = mtDepClient;
		
		Inform(L"\tMSMQ installation type:  Dependent client;  supported by %s", wszRemMachine);
	} 

	// recognize Ind Client/Server
	else if (!fDepCl && !fDSServer)
	{
		pMqState->fMsmqIsInstalled = TRUE;
		pMqState->g_mtMsmqtype     = mtIndClient;
		
		Inform(L"\tMSMQ installation type:  Independent client/server");
	}

	// recognize MSMQ server om DC 
	else if (!fDepCl && fDSServer)
	{
		pMqState->fMsmqIsInstalled = TRUE;
		pMqState->g_mtMsmqtype     = mtServer;
		
		Inform(L"\tMSMQ installation type:  Server on DC ");
	}

	// Bad - wrong case
	else  	
	{
		pMqState->fMsmqIsInstalled = FALSE;

		Failed(L" find installed MSMQ");
		return FALSE;
	}

	//
	// recognize setup state
	//
	DWORD dwStatus = GetSetupMode();

	LPWSTR wszSetupStates[4] = 
	{
		L"MSMQ_SETUP_DONE", 
		L"MSMQ_SETUP_FRESH_INSTALL", 
		L"MSMQ_SETUP_UPGRADE_FROM_NT ", 
		L"MSMQ_SETUP_UPGRADE_FROM_WIN9X" 
	};
	
	if (dwStatus == 999)
	{
		Warning(L"Setup has not finished:");
		pMqState->fMsmqIsInSetup = TRUE;
	}
	else
	{
       	Inform(L"\tSetup state is %s", wszSetupStates[dwStatus]);
	}

	//
	// recognize join state
	// 
	dwStatus = GetJoinMode();

	LPWSTR wszJoinStates[5] = 
	{
		L"illegal value of 0", 
		L"MSMQ_JOIN_STATUS_START_JOINING", 
		L"MSMQ_JOIN_STATUS_JOINED_SUCCESSFULLY", 
		L"MSMQ_JOIN_STATUS_FAIL_TO_JOIN ", 
		L"MSMQ_JOIN_STATUS_UNKNOWN" 
	};
	
	if (dwStatus != 999 && dwStatus != 2)   // registry key absent or says Joined-Successfully
	{
		Warning(L"MSMQ in join:");

		if (dwStatus <= 3)
		{
			Warning(L"\t\tJoin state is %s", wszJoinStates[dwStatus]);
			pMqState->f_MsmqIsInJoin = TRUE;
		}
		else 
		{
			Failed(L"\t\tInvalid join state: %d", dwStatus);
			pMqState->f_MsmqIsInJoin = TRUE;
		}
	}
	
	//
	// recognize installation problems
	// 
	b = IsThereMSMQINSTfile();
	if (b)
	{
		// reported in the routine itself
		// no need to fail, it is always now 
	}
	
	//
	// recognize error log file
	// 
	b = IsThereMSMQLOGfile();
	if (b)
	{
		// reported in the routine itself
	}
	
	//
	// Verify with AD (GetComputerObjectName) DN name from registry MSMQ\Parameters\setup\MachineDN
	// 
	b = VerifyDnName();
	if (!b)
	{
		Failed(L"\t\tReconcile computer DN between registry and Active Directory");
		fSuccess = FALSE;
	}
	else
	{
		Succeeded(L"\t\tReconcile computer DN between registry and Active Directory");
	}

       
	return fSuccess;
}

BOOL VerifyComponents(MQSTATE *pMqState)
{
	BOOL fSuccess = TRUE, b;

        b = CheckComponentsInstalled(pMqState);
    	if (!b)
    	{
    		Failed(L"\t\tVerify installed MSMQ components");
    		fSuccess = FALSE;
    	}
    	else
    	{
    	    if (pMqState->f_msmq_Core > 0) 
    	        Inform(L"\tInstalled component: %s", MSMQ_CORE_SUBCOMP);
    	    
    	    if (pMqState->f_msmq_MQDSService > 0) 
    	        Inform(L"\tInstalled component: %s", MQDSSERVICE_SUBCOMP);
    	    
    	    if (pMqState->f_msmq_TriggersService > 0) 
    	        Inform(L"\tInstalled component: %s", TRIGGERS_SUBCOMP);
    	    
    	    if (pMqState->f_msmq_HTTPSupport > 0) 
    	        Inform(L"\tInstalled component: %s", HTTP_SUPPORT_SUBCOMP);
    	    
    	    if (pMqState->f_msmq_ADIntegrated > 0) 
    	        Inform(L"\tInstalled component: %s", AD_INTEGRATED_SUBCOMP);
    	    
    	    if (pMqState->f_msmq_RoutingSupport > 0) 
    	        Inform(L"\tInstalled component: %s", ROUTING_SUBCOMP);
    	    
    	    if (pMqState->f_msmq_LocalStorage > 0) 
    	        Inform(L"\tInstalled component: %s", LOCAL_STORAGE_SUBCOMP);
    	    
    		Succeeded(L"\t\tVerify installed MSMQ components");
    	}

    	return fSuccess;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\registry.cpp ===
// MQState tool reports general status and helps to diagnose simple problems
// This file verifies default registry settings 
//
// Basically written by AlonG, then edited by AlexDad, April 2000
// 

#include "stdafx.h"
#include "_mqini.h"

#include <winreg.h>
#include <uniansi.h>

#include "_mqreg.h"

//
// Defines
//
#define MAX_BUF         300
#define MAX_VALUE_NAME  256
#define BUFF_SIZE       500

enum KeyType
{
    MQKEY_MANDATORY, 
	MQKEY_IGNORE,
    MQKEY_OPTIONAL, 
    MQKEY_SUSPICIOUS
};

typedef struct mqRegKey
{
    WCHAR *     strKeyName;
	DWORD       dwData;
    wchar_t*    strData;
    KeyType     enumType;
	BOOL        bValuePresent;
} mqRegKey;

typedef mqRegKey* pmqRegKey;

//
// Globals
//
TCHAR  g_tRegKeyName[ 256 ] = {0} ;
HKEY   g_hKeyFalcon = NULL ;
WCHAR *g_pwszPrefix = NULL;

#include "..\registry.h"

LPWSTR g_aMSMQKeys[3];

#include "regdata.h"

mqRegKey *g_aMSMQRegKeyTable = NULL;

void BLOB2reportString(LPWSTR wszReportSring, DWORD dwReportStringLen, PUCHAR pBlob, DWORD dwBlobLen)
{
	WCHAR  wsz[10];
	DWORD  i;

	for (i=0; i<dwBlobLen && i<(dwReportStringLen/3-6) ; i++)   // 3 characters are taken by each byte from the blob
	{
       	wsprintf(wsz, L"%02x ", *pBlob++);
       	wcscat(wszReportSring, wsz);
	}

	if (i >= (dwReportStringLen/3-6))
	{
		wcscat(wszReportSring, L"...");
	}
}

int FindKeyInTable(WCHAR *pszKeyName, mqRegKey aMSMQRegKeyTable[])
{
    int i;
	
	LPWSTR wszHk = L"HKEY_LOCAL_MACHINE\\";
	DWORD  dwHk = wcslen(wszHk);

	WCHAR *p;
	if (wcsncmp(pszKeyName, wszHk, dwHk) == 0)
		p = pszKeyName + dwHk;
	else
		p = pszKeyName;
    
	for(i=0; aMSMQRegKeyTable[i].strKeyName != 0; ++i)
    {        
        if(_wcsicmp(p, aMSMQRegKeyTable[i].strKeyName) == 0)
        {
            return i;
        }
    }

    return -1;
}

//
//Compare an REG_EXPAND_SZ type by calling the ExpandEnvironment strings api
//
BOOL CompareRegExpandSz(char* pszUnexpanded,
                        DWORD /* cbSize */,
                        mqRegKey aMSMQRegKeyTable[],
                        int location)
{
	WCHAR *pwszExpanded, wszStarter[10];
	WCHAR pwszUnexpanded[500];

	mbstowcs(pwszUnexpanded, pszUnexpanded, sizeof(pwszUnexpanded)/sizeof(WCHAR));


	// We'll call ExpandEnvironmentStrings twice, first to get the size
	// of the buffer we need, then again to actually get the string

	DWORD dwSize = ExpandEnvironmentStrings(pwszUnexpanded, wszStarter, sizeof(wszStarter)/sizeof(WCHAR));
	if(dwSize != 0)
	{
        // Allocate the buffer
		pwszExpanded = new WCHAR[dwSize+1];		
		// Call again
		ExpandEnvironmentStrings(pwszUnexpanded, pwszExpanded, dwSize);

        if(_wcsicmp(pwszExpanded, aMSMQRegKeyTable[location].strData))
        {
            Warning(L"Registry value %s for %s doesn't match default %s", 
				pwszExpanded, 
				aMSMQRegKeyTable[location].strKeyName, 
				aMSMQRegKeyTable[location].strData);
        }

		delete[] pwszExpanded;
	}
	else
	{
        DWORD dwErr = GetLastError();
        Failed(L"trying to expand strings: 0x%08X (%08d)\n", dwErr, dwErr);
        return dwErr;
	}

	return TRUE;
}

//
// Compare a REG_MULTI_SZ buffer to the table value
//
BOOL CompareMultiSz(char* /* pStrings */, DWORD /* cbSize */, mqRegKey /* aMSMQRegKeyTable */[], int /* location */)
{
/*	if(cbSize <= 0) return ERROR_SUCCESS;

    cstrResult += pStrings;
*/
    return TRUE;
}

// 
//  Compare the registry binary value
//
BOOL CompareRegBinary(LPBYTE pValueData, 
                      int cbValueData, 
                      mqRegKey aMSMQRegKeyTable[], 
                      int location)
{
	WCHAR str[10];
    WCHAR buff[20000];
    int count, len, oldlen = 0;

	for(count = 0; count < cbValueData; count += sizeof(int))
	{
        len = wsprintf(str, L"%x ", (int)(*(pValueData + count)));
        wsprintf(buff + oldlen, L"%s", str);
        oldlen += len;
	}
    buff[oldlen] = L'\0';

    if(_wcsicmp(buff, aMSMQRegKeyTable[location].strData))
    {
        Warning(L"Binary registry value for %s doesn't match default", 
				aMSMQRegKeyTable[location].strKeyName);
    }

    return TRUE;
}

bool IsWinNT4(OSVERSIONINFO* osvi)
{
	return((osvi->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
			(osvi->dwMajorVersion == 4));
}


bool IsWin9x(OSVERSIONINFO* osvi)
{
	return(osvi->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
}


bool IsWin2K(OSVERSIONINFO* osvi)
{
	return((osvi->dwPlatformId == VER_PLATFORM_WIN32_NT) && 
			(osvi->dwMajorVersion == 5));
}

//
//  Print the value based on it's type
//
void PrintValue(
          DWORD		dwValueType,
          LPBYTE	pValueData, 
          DWORD		cbValueData, 
          WCHAR*	pszKeyName
          )
{
	WCHAR wsz[200] = L"";
		
    switch(dwValueType)
	{
	case REG_DWORD:
		Inform(L"REG_DWORD     value %s: 0x%x",pszKeyName, *(DWORD *)pValueData);
        break;

	case REG_SZ:
		Inform(L"REG_SZ        value %s: %s",pszKeyName, (WCHAR *)pValueData);
        break;

    case REG_MULTI_SZ:
		Inform(L"REG_MULTI_SZ  value %s: print NIY", pszKeyName);
		break;
	
    case REG_EXPAND_SZ:
		Inform(L"REG_EXPAND_SZ value %s: %S",pszKeyName, (char*)pValueData);
		break;
	
    case REG_BINARY:
		BLOB2reportString(wsz, sizeof(wsz)/sizeof(WCHAR), pValueData, cbValueData);
		Inform(L"REG_BINARY    value %s: \'%s\'",pszKeyName, wsz);   

		break;
	
    case REG_NONE:
		Inform(L"REG_NONE      value %s: NIY",pszKeyName);   
	    // Fall through.
    default:
		Failed(L"recognize value type");
		break;
	}
}

//
//  Compare the value based on it's type
//
BOOL CompareValue(
          DWORD		dwValueType,
          LPBYTE	pValueData, 
          DWORD		cbValueData, 
          WCHAR*	pszKeyName, 
          mqRegKey	aMSMQRegKeyTable[]
          )
{
    int location = FindKeyInTable(pszKeyName, aMSMQRegKeyTable);
    if(location == -1)
    {
        Warning(L"Suspicious: unknown key %s ", pszKeyName);
        return FALSE;
    }

	if (!aMSMQRegKeyTable[location].bValuePresent)
	{
		// No need to compare
		return TRUE;
	}


	BOOL b = TRUE;

    switch(dwValueType)
	{
	case REG_DWORD:
        if(aMSMQRegKeyTable[location].dwData != *(DWORD *)pValueData)
        {
            Warning(L"Registry value %d for %s doesn't match default %d", *(DWORD *)pValueData, pszKeyName, aMSMQRegKeyTable[location].dwData);
			b = FALSE;
        }
        break;

	case REG_SZ:
        if(_wcsicmp(aMSMQRegKeyTable[location].strData, (WCHAR *)pValueData) != 0)
        {
            Warning(L"Registry value %s for %s doesn't match default %s", (WCHAR *)pValueData, pszKeyName, aMSMQRegKeyTable[location].strData);
			b = FALSE;
        }
        break;

    case REG_MULTI_SZ:
		b = CompareMultiSz((char*)pValueData, cbValueData, aMSMQRegKeyTable, location);
		break;
	
    case REG_EXPAND_SZ:
		b = CompareRegExpandSz((char*)pValueData, cbValueData, aMSMQRegKeyTable, location); 
		break;
	
    case REG_BINARY:
		b = CompareRegBinary(pValueData, cbValueData, aMSMQRegKeyTable, location);
		break;
	
    case REG_NONE:
	    // Fall through.
    default:
		Failed(L"recognize value type");
		break;
	}
	return b;
}

//
// FindsKeyValues
// 
// Arguments        : HKEY hKey				- key to find values for
//					: DWORD cValues			- number of values for this key
//					: DWORD cchMaxValue		- longest value name
//					: DWORD cbMaxValueData	- longest value data
//
BOOL FindKeyValues(
              HKEY		/* hParentKey */, 
              WCHAR*	szParentKeyName, 
              WCHAR*	pszKeyName, 
              HKEY		hKey, 
			  DWORD		cValues, 
			  DWORD		cchMaxValue, 
			  DWORD		cbMaxValueData, 
              mqRegKey	aMSMQRegKeyTable[]
              )
{
    if(cValues <= 0)
    {
        return TRUE;
    }

	BOOL fSuccess = TRUE;

	long	retCodeEnum;	
	DWORD	dwType, cchValue, cbValueData;
	WCHAR*	achValue = new WCHAR[cchMaxValue+1];
	LPBYTE	pData	 = new BYTE[cbMaxValueData];

	for(DWORD i=0; i<cValues; i++)
	{
		cchValue = cchMaxValue + 1;
		cbValueData = cbMaxValueData;

		retCodeEnum = RegEnumValue(
									hKey,			// key 
			                        i,				// index
									achValue,		// buffer for value name
									&cchValue,		// size of buffer for value name
									NULL,			// reserved
									&dwType,		// dword for type
									pData,			// pointer to data buffer
									&cbValueData	// size of data buffer
								  );

		if(retCodeEnum == ERROR_SUCCESS)
		{
			WCHAR wsz[500];
			wcscpy(wsz, szParentKeyName);
			
			int dw = wcslen(wsz);
			if (wsz[dw-1] != L'\\')
				wcscat(wsz, L"\\");
			
			wcscat(wsz, pszKeyName);
			
			dw = wcslen(wsz);
			if (wsz[dw-1] != L'\\')
				wcscat(wsz, L"\\");
			
			wcscat(wsz, achValue);

		    int location = FindKeyInTable(wsz, aMSMQRegKeyTable);
			if(location == -1)
			{
				Warning(L"Suspicious: unknown value %s ", wsz);
				fSuccess = FALSE;
				continue;
			}

			if (aMSMQRegKeyTable[location].enumType == MQKEY_IGNORE)
			{
				// No need to drill down
				continue;
			}

			
			if (fDebug)
			{
				PrintValue(dwType, pData, cbValueData, wsz);
			}
            
			CompareValue(dwType, pData, cbValueData, wsz, aMSMQRegKeyTable);
		}
		else 
		{
            Failed(L"enumerating value");
		}
	} 

	delete [] achValue;
	delete [] pData;
	
	return fSuccess;
}

//
// Forward declaration of FindKeyByName for recursive call
//
BOOL FindKeyByName(HKEY, WCHAR*, WCHAR*, mqRegKey*);

// 
// FindSubKeys
// Arguments        : HKEY hKey			- Key to find
//					: DWORD cSubKeys	- How many sub keys does this key have?
//					: DWORD cbMaxSubKey - Largest subkey size
//					: DWORD cchMaxClass - Largest class string size for subkeys
//
BOOL FindSubKeys(
                    HKEY /* hParentKey */, 
                    WCHAR* szParentKeyName, 
                    WCHAR* pszKeyName, 
                    HKEY hKey, 
				    DWORD cSubKeys, 
					DWORD cbMaxSubKey, 
					DWORD cchMaxClass, 
                    mqRegKey aMSMQRegKeyTable[]
                    )
{
	BOOL b = TRUE;

	WCHAR* achKey	= new WCHAR[cbMaxSubKey+1];
	WCHAR* achClass	= new WCHAR[cchMaxClass+1];

	// Enumerate all the child keys of hKey and find them.
	for (DWORD i=0; i<cSubKeys; i++)    
    { 
        long retCodeEnum = RegEnumKey(hKey, i, achKey, cbMaxSubKey+1);

        if (retCodeEnum == ERROR_SUCCESS) 
        {
			
			WCHAR szNewParentKeyName[500], wsz[600], *p;
            wcscpy(szNewParentKeyName, szParentKeyName);
			int dw = wcslen(szNewParentKeyName);
			if (szNewParentKeyName[dw-1] != L'\\')
				wcscat(szNewParentKeyName, L"\\");
            wcscat(szNewParentKeyName, pszKeyName);
			dw = wcslen(szNewParentKeyName);
			if (szNewParentKeyName[dw-1] != L'\\')
				wcscat(szNewParentKeyName, L"\\");

			wcscpy(wsz, szNewParentKeyName);
			wcscat(wsz, achKey);
			p = wcschr(wsz, L'\\') + 1;

			int location = FindKeyInTable(p, aMSMQRegKeyTable);
			if(location == -1)
			{
				Warning(L"Suspicious: unknown subkey %s", wsz);
				return FALSE;
			}

			if (aMSMQRegKeyTable[location].enumType == MQKEY_IGNORE)
			{
				// No need to drill down
				return TRUE;
			}
			

            FindKeyByName(hKey, szNewParentKeyName, achKey, aMSMQRegKeyTable);
        } 
		else 
		{
            Failed(L"enumerate subkeys");
			b = FALSE;
		}
    }
	delete [] achKey;
	delete [] achClass;

	return b;
}

// 
// FindKey - Find the information contained in hKey
//
//	Prints out the class name
//	Prints out the time information
//	Prints out any values
//	Finds  subkeys
//
BOOL FindKey(
         HKEY hParentKey, 
         WCHAR* szParentKeyName, 
         WCHAR* pszKeyName, 
         HKEY hKey, 
         mqRegKey aMSMQRegKeyTable[]
         )
{
	BOOL     fSuccess = TRUE, b;
    WCHAR    achClass[MAX_PATH] = L""; // buffer for class name 
    DWORD    cchClassName = MAX_PATH;  // length of class string 
    DWORD    cSubKeys;                 // number of subkeys 
    DWORD    cbMaxSubKey;              // longest subkey size 
    DWORD    cchMaxClass;              // longest class string 
    DWORD    cValues;              // number of values for key 
    DWORD    cchMaxValue;          // longest value name 
    DWORD    cbMaxValueData;       // longest value data 
    DWORD    cbSecurityDescriptor; // size of security descriptor 
    FILETIME ftLastWriteTime;      // last write time 

    // Get the class name and the value count. 

    DWORD dw = RegQueryInfoKey(hKey,        // key handle 
        achClass,                // buffer for class name 
        &cchClassName,           // length of class string 
        NULL,                    // reserved 
        &cSubKeys,               // number of subkeys 
        &cbMaxSubKey,            // longest subkey size 
        &cchMaxClass,            // longest class string 
        &cValues,                // number of values for this key 
        &cchMaxValue,            // longest value name 
        &cbMaxValueData,         // longest value data 
        &cbSecurityDescriptor,   // security descriptor 
        &ftLastWriteTime);       // last write time 

	if (dw != 0)
	{
		fSuccess = FALSE;
		return fSuccess;
	}


	// Find all value pairs for this key
	b = FindKeyValues(
		hParentKey, 
		szParentKeyName, 
		pszKeyName, 
        hKey, 
		cValues, 
		cchMaxValue, 
		cbMaxValueData, 
		aMSMQRegKeyTable);

	if (!b)
	{
		fSuccess = FALSE;
	}
	
	// Find the subkeys of this key

	b = FindSubKeys(
		hParentKey, 
		szParentKeyName, 
		pszKeyName, 
        hKey, 
		cSubKeys, 
		cbMaxSubKey, 
		cchMaxClass, 
		aMSMQRegKeyTable);
	
	if (!b)
	{
		fSuccess = FALSE;
	}

	return fSuccess;
}

// 
// FindKeyByName
//
BOOL FindKeyByName(
                   HKEY hParentKey, 
                   WCHAR* szParentKey, 
                   WCHAR* pszKey, 
                   mqRegKey aMSMQRegKeyTable[]
                   )
{
	BOOL fSuccess = TRUE, b;
	HKEY hKey;

	long ret = RegOpenKeyEx(hParentKey,
					   pszKey, 
					   0, 
					   KEY_READ, 
				       &hKey);

	if(ret != ERROR_SUCCESS)
	{		
        Failed(L"opening key: %s, error: %ld", pszKey, ret);
		return FALSE;
	}

    b = FindKey(hParentKey, szParentKey, pszKey, hKey, aMSMQRegKeyTable);
	if (!b)
	{
		fSuccess = FALSE;
	}


	ret = RegCloseKey(hKey);
	if(ret != ERROR_SUCCESS)
	{
        Failed(L"closing key: %s, error: %ld", pszKey, ret);
		fSuccess = FALSE;
		return ret;
	}

	return fSuccess;
}

//
// FindArrayOfKeyNames - find reg keys
//
BOOL FindArrayOfKeyNames(
       HKEY hParentKey, 
       WCHAR* szParentKey, 
       WCHAR* aKeyNames[], 
       mqRegKey aMSMQRegKeyTable[])
{
	BOOL fSuccess = TRUE, b;

	for(int i=0; aKeyNames[i] != 0; ++i)
	{
		b = FindKeyByName(hParentKey, szParentKey, aKeyNames[i], aMSMQRegKeyTable);
		if (!b)
		{
			fSuccess = FALSE;
		}
	}

	return fSuccess;
}

//
//  FindRegKeys
//
BOOL FindRegKeys(WCHAR* aKeyNames[], mqRegKey aMSMQRegKeyTable[])
{
    return FindArrayOfKeyNames(
		HKEY_LOCAL_MACHINE, 
        L"HKEY_LOCAL_MACHINE", 
        aKeyNames, 
        aMSMQRegKeyTable);
}

//
//  FindRegistryInTable
//
BOOL FindRegistryInTable()
{
	// TBD: table selection by installation type
    BOOL fSuccess = FindRegKeys(g_aMSMQKeys, g_aMSMQRegKeyTable);

    return fSuccess;
}

//
// FindTableInRegistry
//
BOOL FindTableInRegistry()
{
    BOOL  fSuccess = TRUE;

	DWORD   dwPrefixLen = wcslen(g_pwszPrefix);

	// TBD: select appropriate table by installation type

	// Enumerate all known values in the predefined table and look for each of them in registry
	
    for(int i=0; g_aMSMQRegKeyTable[i].strKeyName != 0; ++i)
    {
		// Checking here exostance of mandatory values only

		if (g_aMSMQRegKeyTable[i].enumType!=MQKEY_MANDATORY)
			continue;

	    DWORD dwSize = 0;

	    HRESULT hr = GetFalconKeyValue(g_aMSMQRegKeyTable[i].strKeyName + dwPrefixLen, 
			                           NULL,
									   NULL,
									   &dwSize);

        if(hr != ERROR_SUCCESS)
        {
			fSuccess = FALSE;
            Failed(L"get value of registry key: %s, return value: %d", g_aMSMQRegKeyTable[i].strKeyName, hr);
            continue;
        }
    }

    return fSuccess;
}

void PrepareTable(MQSTATE * /* pMqState */)
{
	g_pwszPrefix = new WCHAR[200];
	wcscpy(g_pwszPrefix, L"SOFTWARE\\Microsoft\\MSMQ\\");

	if (_wcsicmp(g_tszService, L"MSMQ") == 0)
	{
		// non-clustered case
		wcscat(g_pwszPrefix, L"Parameters\\");
	}
	else
	{
		// clustered case
		wcscat(g_pwszPrefix, L"Clustered QMs\\");
		wcscat(g_pwszPrefix, g_tszService);
		wcscat(g_pwszPrefix, L"\\Parameters\\");
	}

	g_aMSMQKeys[0] = g_pwszPrefix;
	g_aMSMQKeys[1] = L'\0';
	// TBD  L "System\\CurrentControlSet\\Services\\MSMQ",

	// Append prefix
    for(int i=0; g_aMSMQRegKeyTable[i].strKeyName != 0; ++i)
    {
		//if (wcschr(g_aMSMQRegKeyTable[i].strKeyName, L'\\')!=0)
		//	continue;

		DWORD dwLen = wcslen(g_pwszPrefix) + wcslen(g_aMSMQRegKeyTable[i].strKeyName) + 2;
		WCHAR *pwsz = new WCHAR[dwLen];

		wcscpy(pwsz, g_pwszPrefix);
		wcscat(pwsz, g_aMSMQRegKeyTable[i].strKeyName);

		g_aMSMQRegKeyTable[i].strKeyName = pwsz;
	}
}


BOOL VerifyRegistrySettings(MQSTATE *pMqState)
{
	BOOL fSuccess = TRUE, b;

	// select right registry verification table 
	switch (pMqState->g_mtMsmqtype)
	{
	case mtServer:
		g_aMSMQRegKeyTable = g_aTableDsDerver;
		break;
	case mtIndClient:
		g_aMSMQRegKeyTable = g_aTableIndClient;
		break;
	case mtDepClient:
		g_aMSMQRegKeyTable = g_aTableDepClient;
		break;
	case mtWorkgroup:
		g_aMSMQRegKeyTable = g_aTableWorkgroup;
		break;
	default :
		Failed(L"recognize installation type %d - not checking registry", pMqState->g_mtMsmqtype);
		return FALSE;
	}


	// prepare table for clustered/non-clustered cases
	PrepareTable(pMqState);

	//--------------------------------------------------------------------------------
	GoingTo(L"Find known values in registry"); 
	//--------------------------------------------------------------------------------

	b = FindTableInRegistry();
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L"find all appropriate entries in the registry");
	}
	else
	{
		Succeeded(L"All known entries have the appropriate values in the registry");
	}

   	//--------------------------------------------------------------------------------
	GoingTo(L"Find unknown registry values"); 
	//--------------------------------------------------------------------------------

	b = FindRegistryInTable();
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L"find appropriate match between the registry and the table");
	}
	else
	{
		Succeeded(L"verify registry values ");
	}


	return fSuccess;

}



//
// From setup\msmqocm\ocmreg.cpp
//
#include "..\..\..\setup\msmqocm\comreg.h"

//+-------------------------------------------------------------------------
//
//  Function:  GenerateSubkeyValue
//
//  Synopsis:  Creates a subkey in registry
//
//+-------------------------------------------------------------------------

BOOL
GenerateSubkeyValue(
    IN     const TCHAR  * szEntryName,
    IN OUT       TCHAR  * szValueName,
    IN OUT       HKEY    &hRegKey,
    IN const BOOL OPTIONAL bSetupRegSection = FALSE
    )
{
    //
    // Store the full subkey path and value name
    //
    TCHAR szKeyName[256] = {_T("")};
    _stprintf(szKeyName, TEXT("%s\\%s"), FALCON_REG_KEY, szEntryName);
    if (bSetupRegSection)
    {
        _stprintf(szKeyName, TEXT("%s\\%s"), MSMQ_REG_SETUP_KEY, szEntryName);
    }

    TCHAR *pLastBackslash = _tcsrchr(szKeyName, TEXT('\\'));
    if (szValueName)
    {
        lstrcpy(szValueName, _tcsinc(pLastBackslash));
        lstrcpy(pLastBackslash, TEXT(""));
    }

    //
    // Create the subkey, if necessary
    //
    DWORD dwDisposition;
    HRESULT hResult = RegCreateKeyEx(
        FALCON_REG_POS,
        szKeyName,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &hRegKey,
        &dwDisposition);

    if (hResult != ERROR_SUCCESS)
    {
        return FALSE;
    }

    return TRUE;
} // GenerateSubkeyValue


//+-------------------------------------------------------------------------
//
//  Function:  MqReadRegistryValue
//
//  Synopsis:  Gets a MSMQ value from registry (under MSMQ key)
//
//+-------------------------------------------------------------------------
BOOL
MqReadRegistryValue(
    IN     const TCHAR  * szEntryName,
    IN OUT       DWORD   dwNumBytes,
    IN OUT       PVOID   pValueData,
    IN const BOOL OPTIONAL bSetupRegSection /* = FALSE */
    )
{
    TCHAR szValueName[256] = {_T("")};
    HKEY hRegKey;

    if (!GenerateSubkeyValue(szEntryName, szValueName, hRegKey, bSetupRegSection))
        return FALSE;

    //
    // Get the requested registry value
    //
    HRESULT hResult = RegQueryValueEx( hRegKey, szValueName, 0, NULL,
                                      (BYTE *)pValueData, &dwNumBytes);

    RegCloseKey(hRegKey);

    return (hResult == ERROR_SUCCESS);

} //MqReadRegistryValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstore\binpatch.cpp ===
#include <stdafx.h>

#include "..\binpatch.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstore\main.cpp ===
//
// Top-level caller (provides exe linkage) 
//

#include "stdafx.h"

int _cdecl main( int argc, char *argv[ ])
{
    return run( argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\versions.cpp ===
// MQState tool reports general status and helps to diagnose simple problems
// This file ...
//
// AlexDad, March 2000
// 

#include "stdafx.h"
#include "_mqini.h"
#include "versions.h"

	//-	MSMQ version and type (release/checked)
	//-	Existence and correct versions of required program files

DWORD VerifyFileVersion(LPWSTR lptstrFilename, LPWSTR wszReqVersion, LPWSTR wszActualVersion)
{
	DWORD h;
	DWORD dwVerSize = GetFileVersionInfoSize(lptstrFilename, &h);

	if (dwVerSize == 0)
	{
		Failed(L" get version of file %s", lptstrFilename);
		return FALSE; 
	}

	PCHAR pVerInfo = new char[dwVerSize];

	BOOL b = GetFileVersionInfo(
  				lptstrFilename,         // file name
				h,         				// ignored
  				dwVerSize,            	// size of buffer
  				pVerInfo);           	// version information buffer

	if (b == 0)
	{
		Failed(L" get version of file %s", lptstrFilename);
		delete [] pVerInfo; 
		
		return FALSE; 
	}


	// Structure used to store enumerated languages and code pages.

	struct LANGANDCODEPAGE {
	  WORD wLanguage;
	  WORD wCodePage;
	} *lpTranslate;

	TCHAR  wszSubBlock[100];	
	LPTSTR pwszVersion;	
	UINT   dwVersionLength, cbTranslate;

	// Read the list of languages and code pages.

	VerQueryValue(pVerInfo, 
              TEXT("\\VarFileInfo\\Translation"),
              (LPVOID*)&lpTranslate,
              &cbTranslate);

	// Read the file description for the first language and code page.
	if ( cbTranslate>0 )
	{
		  wsprintf( wszSubBlock, 
        	    TEXT("\\StringFileInfo\\%04x%04x\\ProductVersion"),
            	lpTranslate[0].wLanguage,
	            lpTranslate[0].wCodePage);

		// Retrieve file description for language and code page "i". 
		b = VerQueryValue(
		  		pVerInfo, 					// buffer for version resource
			  	wszSubBlock,   				// value to retrieve
  				(void **)&pwszVersion,  // buffer for version value pointer
  				&dwVersionLength);  	// version length
  				
		if (!b || !pwszVersion)
		{
			Failed(L" get version of file %s", lptstrFilename);
			delete [] pVerInfo; 
			return FALSE; 
		}

		if (wcscmp(pwszVersion, wszReqVersion)!=0)
		{
			//Failed(L" wrong version of file %s: %s", lptstrFilename, pwszVersion);
			wcscpy(wszActualVersion, pwszVersion);
			delete [] pVerInfo; 
			return FALSE; 
		}
		
	}

	delete [] pVerInfo; 
	return TRUE;
}


BOOL VerifyVersions(MQSTATE *pMqState)
{
	BOOL fSuccess = TRUE;
	WCHAR wszPath[MAX_PATH];
	WCHAR wszActualVersion[100];
	WCHAR wszReqVersion[10];
	DropContents *pDrop = NULL;
	MsmqDrop mdDrop = mdLast;   //means Unknown { mdRTM, mdSP1, mdLast }; 


	//
	// Get version of mqutil.dll to guess the verson
	//
	wcscpy(wszPath, pMqState->g_szSystemDir);
	wcscat(wszPath, L"\\mqutil.dll");
	wcscpy(wszActualVersion, L"");

	VerifyFileVersion(wszPath, L"???", wszActualVersion);

	wcscpy(pMqState->g_wszVersion, wszActualVersion);

	DWORD dw1, dw2;
	swscanf(wszActualVersion, L"%d.%d.%d", &dw1, &dw2, &pMqState->g_dwVersion);

	mdDrop = mdLast;
	for (int i=0; i<mdLast; i++)
	{
		if (wcscmp(wszActualVersion, MqutilVersion[i])==NULL)
		{
			mdDrop = (MsmqDrop)i;
		}
	}
	if (mdDrop == mdLast)
	{
		Failed(L"Recognize official version of MSMQ: %s.  Assuming RTM though it is not!", wszActualVersion);
		mdDrop = mdRTM;
	}
	else
	{
		Inform(L"MSMQ version: %s  (%s)", MsmqDropNames[mdDrop], wszActualVersion);
	}

	//
	// Set expectations per mqutil.dll
	//
	pDrop = DropTable[mdDrop][pMqState->g_mtMsmqtype];

	//
	// Now, actually verify the files in system32
	//
	for (DropContents *pPair = pDrop; pPair->wszName;  pPair++)
	{
		wcscpy(wszPath, pMqState->g_szSystemDir);
		wcscat(wszPath, L"\\");
		wcscat(wszPath, pPair->wszName);

		WCHAR wszActualVersion[100];

		if (!VerifyFileVersion(wszPath, pPair->wszVersion, wszActualVersion))
		{
			Warning(L" Wrong version %s of the file %s", wszActualVersion, wszPath);
			fSuccess = FALSE;
		}
	}

	//
	// Verify system32\drivers\mqac.sys
	//
	if (pMqState->g_mtMsmqtype != mtDepClient)
	{
		wcscpy(wszPath, pMqState->g_szSystemDir);
		wcscat(wszPath, L"\\drivers\\mqac.sys");
		wcscpy(wszActualVersion, L"");

		wcscpy(wszReqVersion, MqacVersion[mdDrop]);

		if (!VerifyFileVersion(wszPath, wszReqVersion, wszActualVersion))
		{
				Warning(L" Wrong version %s of the file %s", wszActualVersion, wszPath);
				fSuccess = FALSE;
		}
	}


	//
	// Verify system32\setup\msmqocm.dll
	//
	wcscpy(wszPath, pMqState->g_szSystemDir);
	wcscat(wszPath, L"\\setup\\msmqocm.dll");
	wcscpy(wszActualVersion, L"");

	wcscpy(wszReqVersion, MsmqocmVersion[mdDrop]);

	if (!VerifyFileVersion(wszPath, wszReqVersion, wszActualVersion))
	{
			Warning(L" Wrong version %s of the file %s", wszActualVersion, wszPath);
			fSuccess = FALSE;
	}


	// TBD: to Verify cluster dll - if it is cluster
	// -ra-- W32i   DLL ENU       5.0.0.642 shp     49,424 10-21-1999 mqclus.dll

	
	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstore\lqs.h ===
#ifndef __LQS_DIAG_H
#define __LQS_DIAG_H

BOOL CheckLQS();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstate\versions.h ===
// MQState tool reports general status and helps to diagnose simple problems
// This file keeps versioning information for all drops we care of
//
// AlexDad, March 2000
// 

#ifndef __VERSIONS_H__
#define __VERSIONS_H__

typedef enum MsmqDrop 
{ 
	mdRTM, 
	mdSP1, 
	mdDTC, 
	mdSP2, 
	mdXPBeta1, 
	mdXPBeta2, 
	mdXPCurMain, 
	mdXPCur, 
	mdLast 
}; 

LPWSTR MsmqDropNames[] = 
{
	L"Windows 2000 RTM",
	L"Windows 2000 SP1",
	L"Windows 2000 DTC",
	L"Windows 2000 SP2",
	L"Whistler Beta1", 
	L"Whistler Beta2", 
	L"Whistler Current Main", 
	L"Whistler Current VBL", 
};

typedef struct DropContents 
{
	LPWSTR wszName;
	LPWSTR wszVersion;
	
} DropContents; 

//
//  Versioning for RTM
//
DropContents ServerRTM[] =
{
	{L"MQDSCLI.DLL",   	L"5.00.0641"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.00.0641"}, 
	{L"mqrt.dll",   	L"5.00.0641"}, 
	{L"MQOA.DLL",   	L"5.00.0641"}, 
	{L"mqoa10.tlb",   	L"5.00.0641"}, 
	{L"mqxp32.dll",   	L"5.00.0641"}, 
	{L"mqmailoa.dll",   L"5.00.0641"}, 
	{L"mqmailvb.dll",   L"5.00.0641"}, 
	{L"mqupgrd.dll",   	L"5.00.0641"}, 
	{L"mqbkup.exe",   	L"5.00.0641"}, 

	{L"mqcertui.dll",   L"5.00.0641"}, // [MsmqAppletFiles]
	{L"msmq.cpl",   	L"5.00.0641"}, 
	
	{L"mqsec.dll",   	L"5.00.0641"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.00.0641"}, 
	{L"mqqm.dll",   	L"5.00.0645"}, 
	{L"mqlogmgr.dll",   L"03.00.00.3413"}, 
	{L"mqperf.dll",   	L"5.00.0641"}, 
	
	{L"MQDSSRV.DLL",   	L"5.00.0641"}, //[MsmqSrvrFiles]
	{L"MQADS.DLL",   	L"5.00.0641"}, 
	
	{L"mqsnap.DLL",   	L"5.00.0643"}, //[MsmqAdminFiles]

	{NULL, NULL}
};
	
DropContents ClientRTM[] =
{
	{L"MQDSCLI.DLL",   	L"5.00.0641"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.00.0641"}, 
	{L"mqrt.dll",   	L"5.00.0641"}, 
	{L"MQOA.DLL",   	L"5.00.0641"}, 
	{L"mqoa10.tlb",   	L"5.00.0641"}, 
	{L"mqxp32.dll",   	L"5.00.0641"}, 
	{L"mqmailoa.dll",   L"5.00.0641"}, 
	{L"mqmailvb.dll",  	L"5.00.0641"}, 
	{L"mqupgrd.dll",   	L"5.00.0641"}, 
	{L"mqbkup.exe",   	L"5.00.0641"}, 

	{L"mqcertui.dll", 	L"5.00.0641"}, // [MsmqAppletFiles]
	{L"msmq.cpl",   	L"5.00.0641"}, 

	{L"mqsec.dll",   	L"5.00.0641"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.00.0641"}, 
	{L"mqqm.dll",   	L"5.00.0645"}, 
	{L"mqlogmgr.dll",   L"03.00.00.3413"}, 
	{L"mqperf.dll",   	L"5.00.0641"}, 
	
	{NULL, NULL}
};

DropContents WorkRTM[] =
{
	{L"MQDSCLI.DLL",   	L"5.00.0641"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.00.0641"}, 
	{L"mqrt.dll",   	L"5.00.0641"}, 
	{L"MQOA.DLL",   	L"5.00.0641"}, 
	{L"mqoa10.tlb",   	L"5.00.0641"}, 
	{L"mqxp32.dll",   	L"5.00.0641"}, 
	{L"mqmailoa.dll",   L"5.00.0641"}, 
	{L"mqmailvb.dll",  	L"5.00.0641"}, 
	{L"mqupgrd.dll",   	L"5.00.0641"}, 
	{L"mqbkup.exe",   	L"5.00.0641"}, 

	{L"mqcertui.dll", 	L"5.00.0641"}, // [MsmqAppletFiles]
	{L"msmq.cpl",   	L"5.00.0641"}, 

	{L"mqsec.dll",   	L"5.00.0641"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.00.0641"}, 
	{L"mqqm.dll",   	L"5.00.0645"}, 
	{L"mqlogmgr.dll",   L"03.00.00.3413"}, 
	{L"mqperf.dll",   	L"5.00.0641"}, 
	
	{NULL, NULL}
};

DropContents DepClientRTM[] =
{
	{L"MQDSCLI.DLL", 	L"5.00.0641"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.00.0641"}, 
	{L"mqrt.dll",   	L"5.00.0641"}, 
	{L"MQOA.DLL",   	L"5.00.0641"}, 
	{L"mqoa10.tlb",   	L"5.00.0641"}, 
	{L"mqxp32.dll",   	L"5.00.0641"}, 
	{L"mqmailoa.dll",   L"5.00.0641"}, 
	{L"mqmailvb.dll",   L"5.00.0641"}, 
	{L"mqupgrd.dll",   	L"5.00.0641"}, 
	{L"mqbkup.exe",   	L"5.00.0641"}, 

	{L"mqcertui.dll",   L"5.00.0641"}, // [MsmqAppletFiles]
	{L"msmq.cpl",   	L"5.00.0641"}, 
	
	{NULL, NULL}
};

//
//  Versioning for SP1
//

DropContents ServerSP1[] =
{
	{L"MQDSCLI.DLL",   	L"5.00.0702"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.00.0702"}, 
	{L"mqrt.dll",   	L"5.00.0702"}, 
	{L"MQOA.DLL",   	L"5.00.0702"}, 
	{L"mqoa10.tlb",   	L"5.00.0702"}, 
	{L"mqxp32.dll",   	L"5.00.0702"}, 
	{L"mqmailoa.dll",   L"5.00.0702"}, 
	{L"mqmailvb.dll",   L"5.00.0702"}, 
	{L"mqupgrd.dll",   	L"5.00.0702"}, 
	{L"mqbkup.exe",   	L"5.00.0702"}, 

	{L"mqcertui.dll",   L"5.00.0702"}, // [MsmqAppletFiles]
	{L"msmq.cpl",   	L"5.00.0702"}, 
	
	{L"mqsec.dll",   	L"5.00.0702"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.00.0702"}, 
	{L"mqqm.dll",   	L"5.00.0702"}, 
	{L"mqlogmgr.dll",   L"03.00.00.3413"}, 
	{L"mqperf.dll",   	L"5.00.0702"}, 
	
	{L"MQDSSRV.DLL",   	L"5.00.0702"}, //[MsmqSrvrFiles]
	{L"MQADS.DLL",   	L"5.00.0702"}, 
	
	{L"mqsnap.DLL",   	L"5.00.0702"}, //[MsmqAdminFiles]

	{NULL, NULL}
};
	
DropContents ClientSP1[] =
{
	{L"MQDSCLI.DLL",   	L"5.00.0702"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.00.0702"}, 
	{L"mqrt.dll",   	L"5.00.0702"}, 
	{L"MQOA.DLL",   	L"5.00.0702"}, 
	{L"mqoa10.tlb",   	L"5.00.0702"}, 
	{L"mqxp32.dll",   	L"5.00.0702"}, 
	{L"mqmailoa.dll",   L"5.00.0702"}, 
	{L"mqmailvb.dll",  	L"5.00.0702"}, 
	{L"mqupgrd.dll",   	L"5.00.0702"}, 
	{L"mqbkup.exe",   	L"5.00.0702"}, 

	{L"mqcertui.dll", 	L"5.00.0702"}, // [MsmqAppletFiles]
	{L"msmq.cpl",   	L"5.00.0702"}, 

	{L"mqsec.dll",   	L"5.00.0702"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.00.0702"}, 
	{L"mqqm.dll",   	L"5.00.0702"}, 
	{L"mqlogmgr.dll",   L"03.00.00.3413"}, 
	{L"mqperf.dll",   	L"5.00.0702"}, 
	
	{NULL, NULL}
};

DropContents WorkSP1[] =
{
	{L"MQDSCLI.DLL",   	L"5.00.0702"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.00.0702"}, 
	{L"mqrt.dll",   	L"5.00.0702"}, 
	{L"MQOA.DLL",   	L"5.00.0702"}, 
	{L"mqoa10.tlb",   	L"5.00.0702"}, 
	{L"mqxp32.dll",   	L"5.00.0702"}, 
	{L"mqmailoa.dll",   L"5.00.0702"}, 
	{L"mqmailvb.dll",  	L"5.00.0702"}, 
	{L"mqupgrd.dll",   	L"5.00.0702"}, 
	{L"mqbkup.exe",   	L"5.00.0702"}, 

	{L"mqcertui.dll", 	L"5.00.0702"}, // [MsmqAppletFiles]
	{L"msmq.cpl",   	L"5.00.0702"}, 

	{L"mqsec.dll",   	L"5.00.0702"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.00.0702"}, 
	{L"mqqm.dll",   	L"5.00.0702"}, 
	{L"mqlogmgr.dll",   L"03.00.00.3413"}, 
	{L"mqperf.dll",   	L"5.00.0702"}, 
	
	{NULL, NULL}
};

DropContents DepClientSP1[] =
{
	{L"MQDSCLI.DLL", 	L"5.00.0702"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.00.0702"}, 
	{L"mqrt.dll",   	L"5.00.0702"}, 
	{L"MQOA.DLL",   	L"5.00.0702"}, 
	{L"mqoa10.tlb",   	L"5.00.0702"}, 
	{L"mqxp32.dll",   	L"5.00.0702"}, 
	{L"mqmailoa.dll",   L"5.00.0702"}, 
	{L"mqmailvb.dll",   L"5.00.0702"}, 
	{L"mqupgrd.dll",   	L"5.00.0702"}, 
	{L"mqbkup.exe",   	L"5.00.0702"}, 

	{L"mqcertui.dll",   L"5.00.0702"}, // [MsmqAppletFiles]
	{L"msmq.cpl",   	L"5.00.0702"}, 
	
	{NULL, NULL}
};



//
//  Versioning for Current DTC
//
DropContents ServerDTC[] =
{
	{L"MQDSCLI.DLL",   	L"5.00.0702"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.00.0702"}, 
	{L"mqrt.dll",   	L"5.00.0702"}, 
	{L"MQOA.DLL",   	L"5.00.0702"}, 
	{L"mqoa10.tlb",   	L"5.00.0702"}, 
	{L"mqxp32.dll",   	L"5.00.0702"}, 
	{L"mqmailoa.dll",   L"5.00.0702"}, 
	{L"mqmailvb.dll",   L"5.00.0702"}, 
	{L"mqupgrd.dll",   	L"5.00.0702"}, 
	{L"mqbkup.exe",   	L"5.00.0702"}, 

	{L"mqcertui.dll",   L"5.00.0702"}, // [MsmqAppletFiles]
	{L"msmq.cpl",   	L"5.00.0702"}, 
	
	{L"mqsec.dll",   	L"5.00.0702"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.00.0702"}, 
	{L"mqqm.dll",   	L"5.00.0702"}, 
	{L"mqlogmgr.dll",   L"03.00.00.3413"}, 
	{L"mqperf.dll",   	L"5.00.0702"}, 
	
	{L"MQDSSRV.DLL",   	L"5.00.0702"}, //[MsmqSrvrFiles]
	{L"MQADS.DLL",   	L"5.00.0702"}, 
	
	{L"mqsnap.DLL",   	L"5.00.0702"}, //[MsmqAdminFiles]

	{NULL, NULL}
};
	
DropContents ClientDTC[] =
{
	{L"MQDSCLI.DLL",   	L"5.00.0702"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.00.0702"}, 
	{L"mqrt.dll",   	L"5.00.0702"}, 
	{L"MQOA.DLL",   	L"5.00.0702"}, 
	{L"mqoa10.tlb",   	L"5.00.0702"}, 
	{L"mqxp32.dll",   	L"5.00.0702"}, 
	{L"mqmailoa.dll",   L"5.00.0702"}, 
	{L"mqmailvb.dll",  	L"5.00.0702"}, 
	{L"mqupgrd.dll",   	L"5.00.0702"}, 
	{L"mqbkup.exe",   	L"5.00.0702"}, 

	{L"mqcertui.dll", 	L"5.00.0702"}, // [MsmqAppletFiles]
	{L"msmq.cpl",   	L"5.00.0702"}, 

	{L"mqsec.dll",   	L"5.00.0702"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.00.0702"}, 
	{L"mqqm.dll",   	L"5.00.0702"}, 
	{L"mqlogmgr.dll",   L"03.00.00.3413"}, 
	{L"mqperf.dll",   	L"5.00.0702"}, 
	
	{NULL, NULL}
};

DropContents WorkDTC[] =
{
	{L"MQDSCLI.DLL",   	L"5.00.0702"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.00.0702"}, 
	{L"mqrt.dll",   	L"5.00.0702"}, 
	{L"MQOA.DLL",   	L"5.00.0702"}, 
	{L"mqoa10.tlb",   	L"5.00.0702"}, 
	{L"mqxp32.dll",   	L"5.00.0702"}, 
	{L"mqmailoa.dll",   L"5.00.0702"}, 
	{L"mqmailvb.dll",  	L"5.00.0702"}, 
	{L"mqupgrd.dll",   	L"5.00.0702"}, 
	{L"mqbkup.exe",   	L"5.00.0702"}, 

	{L"mqcertui.dll", 	L"5.00.0702"}, // [MsmqAppletFiles]
	{L"msmq.cpl",   	L"5.00.0702"}, 

	{L"mqsec.dll",   	L"5.00.0702"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.00.0702"}, 
	{L"mqqm.dll",   	L"5.00.0702"}, 
	{L"mqlogmgr.dll",   L"03.00.00.3413"}, 
	{L"mqperf.dll",   	L"5.00.0702"}, 
	
	{NULL, NULL}
};

DropContents DepClientDTC[] =
{
	{L"MQDSCLI.DLL", 	L"5.00.0702"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.00.0702"}, 
	{L"mqrt.dll",   	L"5.00.0702"}, 
	{L"MQOA.DLL",   	L"5.00.0702"}, 
	{L"mqoa10.tlb",   	L"5.00.0702"}, 
	{L"mqxp32.dll",   	L"5.00.0702"}, 
	{L"mqmailoa.dll",   L"5.00.0702"}, 
	{L"mqmailvb.dll",   L"5.00.0702"}, 
	{L"mqupgrd.dll",   	L"5.00.0702"}, 
	{L"mqbkup.exe",   	L"5.00.0702"}, 

	{L"mqcertui.dll",   L"5.00.0702"}, // [MsmqAppletFiles]
	{L"msmq.cpl",   	L"5.00.0702"}, 
	
	{NULL, NULL}
};


//
//  Versioning for SP2
//

DropContents ServerSP2[] =
{
	{L"MQDSCLI.DLL",   	L"5.00.0720"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.00.0720"}, 
	{L"mqrt.dll",   	L"5.00.0720"}, 
	{L"MQOA.DLL",   	L"5.00.0720"}, 
	{L"mqoa10.tlb",   	L"5.00.0720"}, 
	{L"mqxp32.dll",   	L"5.00.0720"}, 
	{L"mqmailoa.dll",      L"5.00.0702"}, 
	{L"mqmailvb.dll",      L"5.00.0702"}, 
	{L"mqupgrd.dll",   	L"5.00.0720"}, 
	{L"mqbkup.exe",   	L"5.00.0720"}, 

	{L"mqcertui.dll",       L"5.00.0720"},   // [MsmqAppletFiles]
	{L"msmq.cpl",   	L"5.00.0720"}, 
	
	{L"mqsec.dll",   	L"5.00.0720"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.00.0720"}, 
	{L"mqqm.dll",   	L"5.00.0721"}, 
	{L"mqlogmgr.dll",     L"03.00.00.3413"}, 
	{L"mqperf.dll",   	L"5.00.0702"}, 
	
	{L"MQDSSRV.DLL",   	L"5.00.0720"}, //[MsmqSrvrFiles]
	{L"MQADS.DLL",   	L"5.00.0721"}, 
	
	{L"mqsnap.DLL",   	L"5.00.0720"}, //[MsmqAdminFiles]

	{NULL, NULL}
};
	
DropContents ClientSP2[] =
{
	{L"MQDSCLI.DLL",   	L"5.00.0720"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.00.0720"}, 
	{L"mqrt.dll",   	L"5.00.0720"}, 
	{L"MQOA.DLL",   	L"5.00.0720"}, 
	{L"mqoa10.tlb",   	L"5.00.0720"}, 
	{L"mqxp32.dll",   	L"5.00.0720"}, 
	{L"mqmailoa.dll",      L"5.00.0702"}, 
	{L"mqmailvb.dll",  	L"5.00.0702"}, 
	{L"mqupgrd.dll",   	L"5.00.0720"}, 
	{L"mqbkup.exe",   	L"5.00.0720"}, 

	{L"mqcertui.dll", 	L"5.00.0720"}, // [MsmqAppletFiles]
	{L"msmq.cpl",   	L"5.00.0720"}, 

	{L"mqsec.dll",   	L"5.00.0720"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.00.0720"}, 
	{L"mqqm.dll",   	L"5.00.0721"}, 
	{L"mqlogmgr.dll",      L"03.00.00.3413"}, 
	{L"mqperf.dll",   	L"5.00.0720"}, 
	
	{NULL, NULL}
};

DropContents WorkSP2[] =
{
	{L"MQDSCLI.DLL",   	L"5.00.0720"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.00.0720"}, 
	{L"mqrt.dll",   	L"5.00.0720"}, 
	{L"MQOA.DLL",   	L"5.00.0720"}, 
	{L"mqoa10.tlb",   	L"5.00.0720"}, 
	{L"mqxp32.dll",   	L"5.00.0720"}, 
	{L"mqmailoa.dll",      L"5.00.0702"}, 
	{L"mqmailvb.dll",  	L"5.00.0702"}, 
	{L"mqupgrd.dll",   	L"5.00.0720"}, 
	{L"mqbkup.exe",   	L"5.00.0720"}, 

	{L"mqcertui.dll", 	L"5.00.0720"}, // [MsmqAppletFiles]
	{L"msmq.cpl",   	L"5.00.0720"}, 

	{L"mqsec.dll",   	L"5.00.0720"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.00.0720"}, 
	{L"mqqm.dll",   	L"5.00.0721"}, 
	{L"mqlogmgr.dll",      L"03.00.00.3413"}, 
	{L"mqperf.dll",   	L"5.00.0720"}, 
	
	{NULL, NULL}
};

DropContents DepClientSP2[] =
{
	{L"MQDSCLI.DLL", 	L"5.00.0720"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.00.0720"}, 
	{L"mqrt.dll",   	L"5.00.0720"}, 
	{L"MQOA.DLL",   	L"5.00.0720"}, 
	{L"mqoa10.tlb",   	L"5.00.0720"}, 
	{L"mqxp32.dll",   	L"5.00.0720"}, 
	{L"mqmailoa.dll",      L"5.00.0702"}, 
	{L"mqmailvb.dll",      L"5.00.0702"}, 
	{L"mqupgrd.dll",   	L"5.00.0720"}, 
	{L"mqbkup.exe",   	L"5.00.0720"}, 

	{L"mqcertui.dll",       L"5.00.0720"}, // [MsmqAppletFiles]
	{L"msmq.cpl",   	L"5.00.0720"}, 
	
	{NULL, NULL}
};


//
//  Versioning for Whistler Beta1
//
DropContents ServerXPB1[] =
{
	{L"MQDSCLI.DLL",   	L"5.01.0935"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.01.0935"}, 
	{L"mqrt.dll",   	L"5.01.0936"}, 
	{L"mqrtdep.dll",   	L"5.01.0936"}, 
	{L"MQOA.DLL",   	L"5.01.0935"}, 
	{L"mqoa10.tlb",   	L"5.01.0935"}, 
	{L"mqoa20.tlb",   	L"5.01.0935"}, 
	{L"mqupgrd.dll",   	L"5.01.0935"}, 
	{L"mqbkup.exe",   	L"5.01.0935"}, 
	{L"MQAD.DLL",   	L"5.01.0935"}, 

	{L"mqsec.dll",   	L"5.01.0935"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.01.0935"}, 
	{L"mqqm.dll",   	L"5.01.0939"}, 
	{L"mqise.dll",   	L"5.01.0935"}, 
	{L"mqlogmgr.dll",   L"03.01.00.4090"}, 
	{L"mqperf.dll",   	L"5.01.0939"}, 
	
	{L"MQDSSRV.DLL",   	L"5.01.0935"}, //[MsmqSrvrFiles]
	{L"MQADS.DLL",   	L"5.01.0935"}, 
	{L"MQDSSVC.EXE",   	L"5.01.0935"}, 
	
	{L"mqsnap.DLL",   	L"5.01.0939"}, //[MsmqAdminFiles]
	{L"mqcertui.dll",       L"5.01.0935"}, 

	{NULL, NULL}
};
	
DropContents ClientXPB1[] =
{
	{L"MQDSCLI.DLL",   	L"5.01.0935"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.01.0935"}, 
	{L"mqrt.dll",   	L"5.01.0936"}, 
	{L"mqrtdep.dll",   	L"5.01.0936"}, 
	{L"MQOA.DLL",   	L"5.01.0935"}, 
	{L"mqoa10.tlb",   	L"5.01.0935"}, 
	{L"mqoa20.tlb",   	L"5.01.0935"}, 
	{L"mqupgrd.dll",   	L"5.01.0935"}, 
	{L"mqbkup.exe",   	L"5.01.0935"}, 
	{L"MQAD.DLL",   	L"5.01.0935"}, 

	{L"mqsec.dll",   	L"5.01.0935"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.01.0935"}, 
	{L"mqqm.dll",   	L"5.01.0939"}, 
	{L"mqise.dll",   	L"5.01.0935"}, 
	{L"mqlogmgr.dll",   L"03.01.00.4090"}, 
	{L"mqperf.dll",   	L"5.01.0939"}, 
	
	{L"mqsnap.DLL",   	L"5.01.0939"}, //[MsmqAdminFiles]
	{L"mqcertui.dll",       L"5.01.0935"}, 
	
	{NULL, NULL}
};

DropContents WorkXPB1[] =
{
	{L"MQDSCLI.DLL",   	L"5.01.0935"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.01.0935"}, 
	{L"mqrt.dll",   	L"5.01.0936"}, 
	{L"mqrtdep.dll",   	L"5.01.0936"}, 
	{L"MQOA.DLL",   	L"5.01.0935"}, 
	{L"mqoa10.tlb",   	L"5.01.0935"}, 
	{L"mqoa20.tlb",   	L"5.01.0935"}, 
	{L"mqupgrd.dll",   	L"5.01.0935"}, 
	{L"mqbkup.exe",   	L"5.01.0935"}, 
	{L"MQAD.DLL",   	L"5.01.0935"}, 

	{L"mqsec.dll",   	L"5.01.0935"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.01.0935"}, 
	{L"mqqm.dll",   	L"5.01.0939"}, 
	{L"mqise.dll",   	L"5.01.0935"}, 
	{L"mqlogmgr.dll",   L"03.01.00.4090"}, 
	{L"mqperf.dll",   	L"5.01.0939"}, 
	
	{L"mqsnap.DLL",   	L"5.01.0939"}, //[MsmqAdminFiles]
	{L"mqcertui.dll",       L"5.01.0935"}, 
	
	{NULL, NULL}
};

DropContents DepClientXPB1[] =
{
	{L"MQDSCLI.DLL",   	L"5.01.0935"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.01.0935"}, 
	{L"mqrt.dll",   	L"5.01.0936"}, 
	{L"mqrtdep.dll",   	L"5.01.0936"}, 
	{L"MQOA.DLL",   	L"5.01.0935"}, 
	{L"mqoa10.tlb",   	L"5.01.0935"}, 
	{L"mqoa20.tlb",   	L"5.01.0935"}, 
	{L"mqupgrd.dll",   	L"5.01.0935"}, 
	{L"mqbkup.exe",   	L"5.01.0935"}, 
	{L"MQAD.DLL",   	L"5.01.0935"}, 

	{L"mqsnap.DLL",   	L"5.01.0939"}, //[MsmqAdminFiles]
	{L"mqcertui.dll",       L"5.01.0935"}, 
	{NULL, NULL}
};


//
//  Versioning for Whistler Beta2
//
DropContents ServerXPB2[] =
{
	{L"MQDSCLI.DLL",   	L"5.01.0985"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.01.0985"}, 
	{L"mqrt.dll",   	L"5.01.0985"}, 
	{L"mqrtdep.dll",   	L"5.01.0985"}, 
	{L"MQOA.DLL",   	L"5.01.0985"}, 
	{L"mqoa10.tlb",   	L"5.01.0985"}, 
	{L"mqoa20.tlb",   	L"5.01.0985"}, 
	{L"mqupgrd.dll",   	L"5.01.0985"}, 
	{L"mqbkup.exe",   	L"5.01.0985"}, 
	{L"MQAD.DLL",   	L"5.01.0985"}, 

	{L"mqsec.dll",   	L"5.01.0985"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.01.0985"}, 
	{L"mqqm.dll",   	L"5.01.0985"}, 
	{L"mqise.dll",   	L"5.01.0985"}, 
	{L"mqlogmgr.dll",   L"03.01.00.4090"}, 
	{L"mqperf.dll",   	L"5.01.0985"}, 
	
	{L"MQDSSRV.DLL",   	L"5.01.0985"}, //[MsmqSrvrFiles]
	{L"MQADS.DLL",   	L"5.01.0985"}, 
	{L"MQDSSVC.EXE",   	L"5.01.0985"}, 
	
	{L"mqsnap.DLL",   	L"5.01.0985"}, //[MsmqAdminFiles]
	{L"mqcertui.dll",       L"5.01.0985"}, 

	{L"MQTRIG.DLL",   	L"5.01.0985"}, //[MsmqTriggerFiles]
	{L"MQTGSVC.EXE",   	L"5.01.0985"}, 
	{L"MQTRIG.TLB",   	L"5.01.0985"}, 
	{L"MQGENTR.DLL",   	L"5.01.0985"}, 
	
	{NULL, NULL}
};
	
DropContents ClientXPB2[] =
{
	{L"MQDSCLI.DLL",   	L"5.01.0985"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.01.0985"}, 
	{L"mqrt.dll",   	L"5.01.0985"}, 
	{L"mqrtdep.dll",   	L"5.01.0985"}, 
	{L"MQOA.DLL",   	L"5.01.0985"}, 
	{L"mqoa10.tlb",   	L"5.01.0985"}, 
	{L"mqoa20.tlb",   	L"5.01.0985"}, 
	{L"mqupgrd.dll",   	L"5.01.0985"}, 
	{L"mqbkup.exe",   	L"5.01.0985"}, 
	{L"MQAD.DLL",   	L"5.01.0985"}, 

	{L"mqsec.dll",   	L"5.01.0985"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.01.0985"}, 
	{L"mqqm.dll",   	L"5.01.0985"}, 
	{L"mqise.dll",   	L"5.01.0985"}, 
	{L"mqlogmgr.dll",   L"03.01.00.4090"}, 
	{L"mqperf.dll",   	L"5.01.0985"}, 
	
	{L"mqsnap.DLL",   	L"5.01.0985"}, //[MsmqAdminFiles]
	{L"mqcertui.dll",       L"5.01.0985"}, 
	
	{L"MQTRIG.DLL",   	L"5.01.0985"}, //[MsmqTriggerFiles]
	{L"MQTGSVC.EXE",   	L"5.01.0985"}, 
	{L"MQTRIG.TLB",   	L"5.01.0985"}, 
	{L"MQGENTR.DLL",   	L"5.01.0985"}, 

	{NULL, NULL}
};

DropContents WorkXPB2[] =
{
	{L"MQDSCLI.DLL",   	L"5.01.0985"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.01.0985"}, 
	{L"mqrt.dll",   	L"5.01.0985"}, 
	{L"mqrtdep.dll",   	L"5.01.0985"}, 
	{L"MQOA.DLL",   	L"5.01.0985"}, 
	{L"mqoa10.tlb",   	L"5.01.0985"}, 
	{L"mqoa20.tlb",   	L"5.01.0985"}, 
	{L"mqupgrd.dll",   	L"5.01.0985"}, 
	{L"mqbkup.exe",   	L"5.01.0985"}, 
	{L"MQAD.DLL",   	L"5.01.0985"}, 

	{L"mqsec.dll",   	L"5.01.0985"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.01.0985"}, 
	{L"mqqm.dll",   	L"5.01.0985"}, 
	{L"mqise.dll",   	L"5.01.0985"}, 
	{L"mqlogmgr.dll",   L"03.01.00.4090"}, 
	{L"mqperf.dll",   	L"5.01.0985"}, 
	
	{L"mqsnap.DLL",   	L"5.01.0985"}, //[MsmqAdminFiles]
	{L"mqcertui.dll",       L"5.01.0985"}, 
	
	{L"MQTRIG.DLL",   	L"5.01.0985"}, //[MsmqTriggerFiles]
	{L"MQTGSVC.EXE",   	L"5.01.0985"}, 
	{L"MQTRIG.TLB",   	L"5.01.0985"}, 
	{L"MQGENTR.DLL",   	L"5.01.0985"}, 
	
	{NULL, NULL}
};

DropContents DepClientXPB2[] =
{
	{L"MQDSCLI.DLL",   	L"5.01.0985"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.01.0985"}, 
	{L"mqrt.dll",   	L"5.01.0985"}, 
	{L"mqrtdep.dll",   	L"5.01.0985"}, 
	{L"MQOA.DLL",   	L"5.01.0985"}, 
	{L"mqoa10.tlb",   	L"5.01.0985"}, 
	{L"mqoa20.tlb",   	L"5.01.0985"}, 
	{L"mqupgrd.dll",   	L"5.01.0985"}, 
	{L"mqbkup.exe",   	L"5.01.0985"}, 
	{L"MQAD.DLL",   	L"5.01.0985"}, 

	{L"mqsnap.DLL",   	L"5.01.0985"}, //[MsmqAdminFiles]
	{L"mqcertui.dll",       L"5.01.0985"}, 
	{NULL, NULL}
};


//
//  Versioning for Current Whistler
//
DropContents ServerWhistler[] =
{
	{L"MQDSCLI.DLL",   	L"5.01.0991"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.01.0991"}, 
	{L"mqrt.dll",   	L"5.01.0991"}, 
	{L"mqrtdep.dll",   	L"5.01.0991"}, 
	{L"MQOA.DLL",   	L"5.01.0991"}, 
	{L"mqoa10.tlb",   	L"5.01.0991"}, 
	{L"mqoa20.tlb",   	L"5.01.0991"}, 
	{L"mqupgrd.dll",   	L"5.01.0991"}, 
	{L"mqbkup.exe",   	L"5.01.0991"}, 
	{L"MQAD.DLL",   	L"5.01.0991"}, 

	{L"mqsec.dll",   	L"5.01.0991"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.01.0991"}, 
	{L"mqqm.dll",   	L"5.01.0991"}, 
	{L"mqise.dll",   	L"5.01.0991"}, 
	{L"mqlogmgr.dll",   L"03.01.00.4090"}, 
	{L"mqperf.dll",   	L"5.01.0991"}, 
	
	{L"MQDSSRV.DLL",   	L"5.01.0991"}, //[MsmqSrvrFiles]
	{L"MQADS.DLL",   	L"5.01.0991"}, 
	{L"MQDSSVC.EXE",   	L"5.01.0991"}, 
	
	{L"mqsnap.DLL",   	L"5.01.0991"}, //[MsmqAdminFiles]
	{L"mqcertui.dll",       L"5.01.0991"}, 

	{L"MQTRIG.DLL",   	L"5.01.0991"}, //[MsmqTriggerFiles]
	{L"MQTGSVC.EXE",   	L"5.01.0991"}, 
	{L"MQTRIG.TLB",   	L"5.01.0991"}, 
	{L"MQGENTR.DLL",   	L"5.01.0991"}, 
	
	{NULL, NULL}
};
	
DropContents ClientWhistler[] =
{
	{L"MQDSCLI.DLL",   	L"5.01.0991"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.01.0991"}, 
	{L"mqrt.dll",   	L"5.01.0991"}, 
	{L"mqrtdep.dll",   	L"5.01.0991"}, 
	{L"MQOA.DLL",   	L"5.01.0991"}, 
	{L"mqoa10.tlb",   	L"5.01.0991"}, 
	{L"mqoa20.tlb",   	L"5.01.0991"}, 
	{L"mqupgrd.dll",   	L"5.01.0991"}, 
	{L"mqbkup.exe",   	L"5.01.0991"}, 
	{L"MQAD.DLL",   	L"5.01.0991"}, 

	{L"mqsec.dll",   	L"5.01.0991"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.01.0991"}, 
	{L"mqqm.dll",   	L"5.01.0991"}, 
	{L"mqise.dll",   	L"5.01.0991"}, 
	{L"mqlogmgr.dll",   L"03.01.00.4090"}, 
	{L"mqperf.dll",   	L"5.01.0991"}, 
	
	{L"mqsnap.DLL",   	L"5.01.0991"}, //[MsmqAdminFiles]
	{L"mqcertui.dll",       L"5.01.0991"}, 
	
	{L"MQTRIG.DLL",   	L"5.01.0991"}, //[MsmqTriggerFiles]
	{L"MQTGSVC.EXE",   	L"5.01.0991"}, 
	{L"MQTRIG.TLB",   	L"5.01.0991"}, 
	{L"MQGENTR.DLL",   	L"5.01.0991"}, 

	{NULL, NULL}
};

DropContents WorkWhistler[] =
{
	{L"MQDSCLI.DLL",   	L"5.01.0991"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.01.0991"}, 
	{L"mqrt.dll",   	L"5.01.0991"}, 
	{L"mqrtdep.dll",   	L"5.01.0991"}, 
	{L"MQOA.DLL",   	L"5.01.0991"}, 
	{L"mqoa10.tlb",   	L"5.01.0991"}, 
	{L"mqoa20.tlb",   	L"5.01.0991"}, 
	{L"mqupgrd.dll",   	L"5.01.0991"}, 
	{L"mqbkup.exe",   	L"5.01.0991"}, 
	{L"MQAD.DLL",   	L"5.01.0991"}, 

	{L"mqsec.dll",   	L"5.01.0991"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.01.0991"}, 
	{L"mqqm.dll",   	L"5.01.0991"}, 
	{L"mqise.dll",   	L"5.01.0991"}, 
	{L"mqlogmgr.dll",   L"03.01.00.4090"}, 
	{L"mqperf.dll",   	L"5.01.0991"}, 
	
	{L"mqsnap.DLL",   	L"5.01.0991"}, //[MsmqAdminFiles]
	{L"mqcertui.dll",       L"5.01.0991"}, 
	
	{L"MQTRIG.DLL",   	L"5.01.0991"}, //[MsmqTriggerFiles]
	{L"MQTGSVC.EXE",   	L"5.01.0991"}, 
	{L"MQTRIG.TLB",   	L"5.01.0991"}, 
	{L"MQGENTR.DLL",   	L"5.01.0991"}, 
	
	{NULL, NULL}
};

DropContents DepClientWhistler[] =
{
	{L"MQDSCLI.DLL",   	L"5.01.0991"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.01.0991"}, 
	{L"mqrt.dll",   	L"5.01.0991"}, 
	{L"mqrtdep.dll",   	L"5.01.0991"}, 
	{L"MQOA.DLL",   	L"5.01.0991"}, 
	{L"mqoa10.tlb",   	L"5.01.0991"}, 
	{L"mqoa20.tlb",   	L"5.01.0991"}, 
	{L"mqupgrd.dll",   	L"5.01.0991"}, 
	{L"mqbkup.exe",   	L"5.01.0991"}, 
	{L"MQAD.DLL",   	L"5.01.0991"}, 

	{L"mqsnap.DLL",   	L"5.01.0991"}, //[MsmqAdminFiles]
	{L"mqcertui.dll",       L"5.01.0991"}, 
	{NULL, NULL}
};

//
//  Versioning for Current Whistler VBL03
//
DropContents ServerVBL[] =
{
	{L"MQDSCLI.DLL",   	L"5.01.0994"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.01.0994"}, 
	{L"mqrt.dll",   	L"5.01.0994"}, 
	{L"mqrtdep.dll",   	L"5.01.0994"}, 
	{L"MQOA.DLL",   	L"5.01.0994"}, 
	{L"mqoa10.tlb",   	L"5.01.0994"}, 
	{L"mqoa20.tlb",   	L"5.01.0994"}, 
	{L"mqupgrd.dll",   	L"5.01.0994"}, 
	{L"mqbkup.exe",   	L"5.01.0994"}, 
	{L"MQAD.DLL",   	L"5.01.0994"}, 

	{L"mqsec.dll",   	L"5.01.0994"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.01.0994"}, 
	{L"mqqm.dll",   	L"5.01.0994"}, 
	{L"mqise.dll",   	L"5.01.0994"}, 
	{L"mqlogmgr.dll",   L"03.01.00.4090"}, 
	{L"mqperf.dll",   	L"5.01.0994"}, 
	
	{L"MQDSSRV.DLL",   	L"5.01.0994"}, //[MsmqSrvrFiles]
	{L"MQADS.DLL",   	L"5.01.0994"}, 
	{L"MQDSSVC.EXE",   	L"5.01.0994"}, 
	
	{L"mqsnap.DLL",   	L"5.01.0994"}, //[MsmqAdminFiles]
	{L"mqcertui.dll",       L"5.01.0994"}, 

	{L"MQTRIG.DLL",   	L"5.01.0994"}, //[MsmqTriggerFiles]
	{L"MQTGSVC.EXE",   	L"5.01.0994"}, 
	{L"MQTRIG.TLB",   	L"5.01.0994"}, 
	{L"MQGENTR.DLL",   	L"5.01.0994"}, 
	
	{NULL, NULL}
};
	
DropContents ClientVBL[] =
{
	{L"MQDSCLI.DLL",   	L"5.01.0994"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.01.0994"}, 
	{L"mqrt.dll",   	L"5.01.0994"}, 
	{L"mqrtdep.dll",   	L"5.01.0994"}, 
	{L"MQOA.DLL",   	L"5.01.0994"}, 
	{L"mqoa10.tlb",   	L"5.01.0994"}, 
	{L"mqoa20.tlb",   	L"5.01.0994"}, 
	{L"mqupgrd.dll",   	L"5.01.0994"}, 
	{L"mqbkup.exe",   	L"5.01.0994"}, 
	{L"MQAD.DLL",   	L"5.01.0994"}, 

	{L"mqsec.dll",   	L"5.01.0994"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.01.0994"}, 
	{L"mqqm.dll",   	L"5.01.0994"}, 
	{L"mqise.dll",   	L"5.01.0994"}, 
	{L"mqlogmgr.dll",   L"03.01.00.4090"}, 
	{L"mqperf.dll",   	L"5.01.0994"}, 
	
	{L"mqsnap.DLL",   	L"5.01.0994"}, //[MsmqAdminFiles]
	{L"mqcertui.dll",       L"5.01.0994"}, 
	
	{L"MQTRIG.DLL",   	L"5.01.0994"}, //[MsmqTriggerFiles]
	{L"MQTGSVC.EXE",   	L"5.01.0994"}, 
	{L"MQTRIG.TLB",   	L"5.01.0994"}, 
	{L"MQGENTR.DLL",   	L"5.01.0994"}, 

	{NULL, NULL}
};

DropContents WorkVBL[] =
{
	{L"MQDSCLI.DLL",   	L"5.01.0994"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.01.0994"}, 
	{L"mqrt.dll",   	L"5.01.0994"}, 
	{L"mqrtdep.dll",   	L"5.01.0994"}, 
	{L"MQOA.DLL",   	L"5.01.0994"}, 
	{L"mqoa10.tlb",   	L"5.01.0994"}, 
	{L"mqoa20.tlb",   	L"5.01.0994"}, 
	{L"mqupgrd.dll",   	L"5.01.0994"}, 
	{L"mqbkup.exe",   	L"5.01.0994"}, 
	{L"MQAD.DLL",   	L"5.01.0994"}, 

	{L"mqsec.dll",   	L"5.01.0994"}, //[MsmqCoreFiles]
	{L"mqsvc.exe",   	L"5.01.0994"}, 
	{L"mqqm.dll",   	L"5.01.0994"}, 
	{L"mqise.dll",   	L"5.01.0994"}, 
	{L"mqlogmgr.dll",   L"03.01.00.4090"}, 
	{L"mqperf.dll",   	L"5.01.0994"}, 
	
	{L"mqsnap.DLL",   	L"5.01.0994"}, //[MsmqAdminFiles]
	{L"mqcertui.dll",       L"5.01.0994"}, 
	
	{L"MQTRIG.DLL",   	L"5.01.0994"}, //[MsmqTriggerFiles]
	{L"MQTGSVC.EXE",   	L"5.01.0994"}, 
	{L"MQTRIG.TLB",   	L"5.01.0994"}, 
	{L"MQGENTR.DLL",   	L"5.01.0994"}, 
	
	{NULL, NULL}
};

DropContents DepClientVBL[] =
{
	{L"MQDSCLI.DLL",   	L"5.01.0994"}, // [MsmqReqFiles]
	{L"mqutil.dll",   	L"5.01.0994"}, 
	{L"mqrt.dll",   	L"5.01.0994"}, 
	{L"mqrtdep.dll",   	L"5.01.0994"}, 
	{L"MQOA.DLL",   	L"5.01.0994"}, 
	{L"mqoa10.tlb",   	L"5.01.0994"}, 
	{L"mqoa20.tlb",   	L"5.01.0994"}, 
	{L"mqupgrd.dll",   	L"5.01.0994"}, 
	{L"mqbkup.exe",   	L"5.01.0994"}, 
	{L"MQAD.DLL",   	L"5.01.0994"}, 

	{L"mqsnap.DLL",   	L"5.01.0994"}, //[MsmqAdminFiles]
	{L"mqcertui.dll",       L"5.01.0994"}, 
	{NULL, NULL}
};


DropContents *DropTable[mdLast][mtLast] = 
{
	{ServerRTM, 	 ClientRTM,  		DepClientRTM,		WorkRTM},           // W2K RTM
	{ServerSP1, 	 ClientSP1,  		DepClientSP1,		WorkSP1},           // W2K SP1
	{ServerDTC, 	 ClientDTC,  		DepClientDTC,		WorkDTC},           // W2K DTC
	{ServerSP2,      ClientSP2,  	    DepClientSP2,	    WorkSP2},           // W2K SP2
	{ServerXPB1,     ClientXPB1,  	    DepClientXPB1,	    WorkXPB1},          // Whistler Beta1
	{ServerXPB2,     ClientXPB2,  	    DepClientXPB2,	    WorkXPB2},          // Whistler Beta2
	{ServerWhistler,  ClientWhistler,  	DepClientWhistler,	WorkWhistler},       // Whistler Current MAIN
	{ServerVBL,       ClientVBL,  	    DepClientVBL,	    WorkVBL},            // Whistler Current VBL03
};

LPWSTR MqutilVersion[mdLast] = 
{
	L"5.00.0641",	// W2K RTM
	L"5.00.0702",	// W2K SP1
	L"5.00.0702",	// W2K DTC
	L"5.00.0720",	// W2K SP2
	L"5.01.0935",     // Whistler Beta1
	L"5.01.0985",     // Whistler Beta2
	L"5.01.0991",     // Whistler Current main
	L"5.01.0994"      // Whistler Current VBL
};


LPWSTR MqacVersion[mdLast] = 
{
	L"5.00.0641",	// RTM
	L"5.00.0702",	// SP1
	L"5.00.0702",	// DTC - For now the same as SP1
	L"5.00.0721",	// W2K SP2
	L"5.01.0937",     // Whistler Beta1
	L"5.01.0985",     // Whistler Beta2
	L"5.01.0991",      // Whistler Current main
	L"5.01.0994"      // Whistler Current VBL
};


LPWSTR MsmqocmVersion[mdLast] = 
{
	L"5.00.0641",	// RTM
	L"5.00.0702",	// SP1
	L"5.00.0702",	// DTC - For now the same as SP1
	L"5.00.0720",	// W2K SP2
	L"5.01.0935",     // Whistler Beta1
	L"5.01.0985",     // Whistler Beta2
	L"5.01.0991",      // Whistler Current main
	L"5.01.0994"      // Whistler Current main};
};

#endif   // __VERSIONS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstore\job.cpp ===
// MQStore tool helps to diagnose problems with MSMQ storage
// This file keeps main logic of the tool
//
// AlexDad, February 2000
// 

#include "stdafx.h"
#include "_mqini.h"
#include "msgfiles.h"
#include "lqs.h"
#include "xact.h"


BOOL DoTheJob()
{
	BOOL fSuccess = TRUE, b;

	//--------------------------------------------------------------------------------
	GoingTo(L"Gather from registry the storage locations - per data types"); 
	//--------------------------------------------------------------------------------

	b = GatherLocationsFromRegistry();
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"Gather from registry the storage locations");
	}
	else
	{
		Succeeded(L"Gather data from registry the storage locations");
	}


	//-------------------------------------------------------------------------------
	GoingTo(L"Review the storage directory in the same way as recovery will do it.\n   Please note: mqstore does not parse individual messages, works only on file level\n                use mq2dump if you suspect corrupted messages");
	//-------------------------------------------------------------------------------
	// detect and read all relevant files

	b = LoadPersistentPackets();
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"review the storage");
	}
	else
	{
		Inform(L"Persistent files are healthy");
	}


	//-------------------------------------------------------------------------------
	GoingTo(L"review transactional state files health");
	//-------------------------------------------------------------------------------

	b = LoadXactStateFiles();
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"review the xact state files");
	}
	else
	{
		Inform(L"Transactional state files are healthy");
	}

	//-------------------------------------------------------------------------------
	GoingTo(L"Check for extra files in the storage locations");
	//-------------------------------------------------------------------------------
	b = CheckForExtraFiles();
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"make sure that there are no extra files");
	}
	else
	{
		Inform(L"No extra files");
	}


	//-------------------------------------------------------------------------------
	GoingTo(L"Check the LQS");
	//-------------------------------------------------------------------------------
	b = CheckLQS();
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"make sure that LQS is healthy");
	}
	else
	{
		Inform(L"LQS is healthy");
	}
	
	//-------------------------------------------------------------------------------
	GoingTo(L"Calculate and assess storage sizes");
	//-------------------------------------------------------------------------------
	b = SummarizeDiskUsage();
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"positevely review disk usage");
	}
	else
	{
		Inform(L"Disk memory usage is healthy");
	}

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstore\log.h ===
#ifndef __LOG_DIAG_H
#define __LOG_DIAG_H

BOOL VerifyQMLogFileContents(LPWSTR wszPath);

extern ULONG LogXactVersions[];
extern ULONG LogInseqVersions[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstore\log.cpp ===
// MQStore tool helps to diagnose problems with MSMQ storage
// This file keeps verification of the transactional log (QMLog)
// Borrows heavily from MSMq itself (qm\xactlog.cpp) and old MSMQ1 toolbox - dmpxact\dmplog
// Uses log manager
//
// AlexDad, February 2000
// 

#include <stdafx.h>
#include "xact.h"
#include "msgfiles.h"

ULONG LogXactVersions[2];
ULONG LogInseqVersions[2];


//
// log manager specific header files
//
#define INITGUID
#include <initguid.h>
#include "logmgrgu.h" 		// this file defines GUIDs
#include "ilgstor.h"
#include "ilgread.h"
#include "ilrp.h"
#include "ilginit.h"

#define LOGBUFFERS 400
#define LOGSIZE 0x600000
typedef HRESULT  (STDAPICALLTYPE * GET_CLASS_OBJECT)(REFCLSID clsid,
													 REFIID riid,
													 void ** ppv);

// defined in hdr.cpp
#define	LOGREC_TYPE_CONSOLIDATION   6
typedef struct _ConsolidationRecord{
    ULONG  m_ulInSeqVersion;
    ULONG  m_ulXactVersion;
} ConsolidationRecord;

class CLogFile
{
public:
	CLogFile();
	~CLogFile();

	bool GetNextRecord(LRP& lrp, int &type, unsigned long& size, void *& buf);
	bool isCheckPoint(LRP lrp) { return !memcmp(&m_lrpCheckpt1,&lrp,sizeof(LRP)) || !memcmp(&m_lrpCheckpt2,&lrp,sizeof(LRP)); }
	
	bool GetLogManager();
	bool InitLog(LPSTR LogFile);
	bool InitLogRead();
	bool CheckPoint();
		
	IClassFactory *m_pCF;
	ILogInit *m_pILogInit;
	ILogStorage *m_pILogStorage;
	ILogRead *m_pILogRead;
	LRP m_lrpCurrent,m_lrpCheckpt1, m_lrpCheckpt2;

	bool m_bFirstRec;
};

bool CLogFile::GetLogManager()
{
	HINSTANCE hIns = LoadLibrary (L"MqLogMgr.dll");
	if(hIns==NULL)
	{
		Failed(L"Cannot load MqLogMgr.dll");
		return FALSE;
	}

	GET_CLASS_OBJECT getClassObject=(GET_CLASS_OBJECT)GetProcAddress(hIns, "DllGetClassObject");
	if(getClassObject==NULL)
	{
		Failed(L"Library does not contain DllGetClassObject()");
		return FALSE;
	}

	HRESULT hr=getClassObject(CLSID_CLogMgr, IID_IClassFactory, (void**)&m_pCF);
	if(FAILED(hr))
	{
		Failed(L"Cannot create an instance of CLogMgr");
		return FALSE;
	}

	return TRUE;
}

bool CLogFile::InitLog(LPSTR LogFile)
{
	HRESULT hr = m_pCF->CreateInstance(
					NULL, 
 					IID_ILogInit, 
 					(void **)&m_pILogInit);

	if(FAILED(hr))
	{
		Failed(L"Cannot create an instance of ILogInit");
		return FALSE;
	}

	ULONG ulFileSize, ulAvailableSpace;
	hr = m_pILogInit->Init(
				&ulFileSize,		// pulStorageCapacity
				&ulAvailableSpace,	// Available space
 				const_cast<char*>(LogFile),	// ptstrFullFileSpec
 				0,					// ulInitSig
 				TRUE,				// fFixedSize
 				0,					// uiTimerInterval  
 				0,					// uiFlushInterval  
				0,					// uiChkPtInterval  
				LOGBUFFERS);		// logbuffers

	if (FAILED(hr))
	{
		Failed(L"Cannot intialize log");
		return FALSE;
	}

 	hr = m_pILogInit->QueryInterface(
 							IID_ILogStorage, 
 							(void **)&m_pILogStorage);
	if (FAILED(hr))
	{
		Failed(L"Cannot create an instance of ILogStorage");
		return FALSE;
	}

	return TRUE;
}

bool CLogFile::InitLogRead()
{
	HRESULT hr = m_pILogStorage->OpenLogStream(
					"Streamname", 
					STRMMODEREAD, 
					(void **)&m_pILogRead);
	
	if(FAILED(hr))
	{
		Failed(L"Cannot open ILogRead");
		return FALSE;
	}

 	hr = m_pILogRead->ReadInit();
	
	if(FAILED(hr))
	{
		Failed(L"Cannot initialize ILogRead");
		return FALSE;
	}

	return TRUE;
}

bool CLogFile::CheckPoint()
{
	HRESULT  hr = m_pILogRead->GetCheckpoint(2, &m_lrpCheckpt2);
	if(FAILED(hr))
	{
		Failed(L"Cannot get checkpoint 2");
		return FALSE;
	}

	m_lrpCurrent=m_lrpCheckpt2;

	hr = m_pILogRead->GetCheckpoint(1, &m_lrpCheckpt1);
	if(FAILED(hr))
	{
		Failed(L"Cannot get checkpoint 1");
		return FALSE;
	}

	return TRUE;
}

CLogFile::CLogFile() : m_bFirstRec(true)
{
	m_pILogRead    = NULL;
	m_pILogStorage = NULL;
	m_pILogInit    = NULL;
	m_pCF          = NULL;
}

CLogFile::~CLogFile()
{
	if (m_pILogRead)  
		m_pILogRead->Release();
	if (m_pILogStorage)
		m_pILogStorage->Release();
	if (m_pILogInit)
		m_pILogInit->Release();
	if (m_pCF)
		m_pCF->Release();
}
 

bool CLogFile::GetNextRecord(LRP& lrp, int& type, unsigned long &size, void *&pvbuf)
{
	ULONG   ulSize;
	USHORT  usType;

	if(m_bFirstRec)
	{
		HRESULT hr = m_pILogRead->ReadLRP(
									m_lrpCurrent,
									&ulSize,
									&usType);
		if(FAILED(hr))
			return false;

		m_bFirstRec=false;
		lrp=m_lrpCurrent;
	}
	else
	{
		LRP newLRP;
		memset((void*)&newLRP, 0, sizeof(newLRP));

		HRESULT hr=m_pILogRead->ReadNext(&newLRP, &ulSize, &usType);

		if(FAILED(hr))
			return false;
		lrp=newLRP;
	}

	char *chbuf=new char[ulSize];
	HRESULT hr = m_pILogRead->GetCurrentLogRecord(chbuf);

	if(FAILED(hr))
	{
		delete [] chbuf;
		return false;
	}
	
	pvbuf=(void*)chbuf;
	type=usType;
	size=ulSize;
	
	return true;
}

BOOL VerifyQMLogFileContents(LPWSTR wszPath)
{
	BOOL fSuccess = TRUE, b;
	ULONG ulChkPts = 0;

	int type;
	unsigned long size;
	void *buf;
	LRP lrp;

	char szLogName[MAX_PATH+1];
	wcstombs(szLogName, wszPath, MAX_PATH);

	CLogFile log;
	
	b = log.GetLogManager();
	if (!b)
	{
		Failed(L"Get log manager ");
		return FALSE;
	}

	b = log.InitLog(szLogName);	
	if (!b)
	{
		Failed(L"initialize  log manager ");
		return FALSE;
	}

	b = log.InitLogRead();	
	if (!b)
	{
		Failed(L"initialize log manager for read");
		return FALSE;
	}
	
	b = log.CheckPoint();	
	if (!b)
	{
		Failed(L"Get log check points table ");
		return FALSE;
	}
	
	for(int i=1;log.GetNextRecord(lrp, type, size, buf);i++)
	{
		if(log.isCheckPoint(lrp))
		{
			ConsolidationRecord *pConsolidationRecord=(ConsolidationRecord*)buf;

			Succeeded(L"Log file - Checkpoint: m_ulInSeqVersion=%d, m_ulXactVersion=%d", 
				   pConsolidationRecord->m_ulInSeqVersion, 
				   pConsolidationRecord->m_ulXactVersion);

			if (ulChkPts<2)
			{
				LogXactVersions[ulChkPts]  = pConsolidationRecord->m_ulXactVersion;
				LogInseqVersions[ulChkPts] = pConsolidationRecord->m_ulInSeqVersion;
			}
			else
			{
				Warning(L"More than 2 checkpoints in the log");
			}
			ulChkPts++;
		}
		delete [] buf; // free memory allocated by GetNextRecord
	}
	
	if (ulChkPts != 2)
	{
		fSuccess = FALSE;
		Failed(L"see 2 checkpoints in the log file: see %d", ulChkPts);
	}

	if (fSuccess)
	{
		Inform(L"Log file is healthy");
	}

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstore\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mqstore.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstore\lqs.cpp ===
// Validating LQS files
// Borrows from qm\lqs.cpp
//
// AlexDad, February 2000
// 

#include "stdafx.h"
#include "_mqini.h"

#include "msgfiles.h"
#include "lqs.h"

// from qm\lqs.cpp

#define LQS_SUBDIRECTORY                TEXT("\\LQS\\")

#define LQS_TYPE_PROPERTY_NAME          TEXT("Type")
#define LQS_INSTANCE_PROPERTY_NAME      TEXT("Instance")
#define LQS_BASEPRIO_PROPERTY_NAME      TEXT("BasePriority")
#define LQS_JOURNAL_PROPERTY_NAME       TEXT("Journal")
#define LQS_QUOTA_PROPERTY_NAME         TEXT("Quota")
#define LQS_JQUOTA_PROPERTY_NAME        TEXT("JournalQuota")
#define LQS_TCREATE_PROPERTY_NAME       TEXT("CreateTime")
#define LQS_TMODIFY_PROPERTY_NAME       TEXT("ModifyTime")
#define LQS_SECURITY_PROPERTY_NAME      TEXT("Security")
#define LQS_TSTAMP_PROPERTY_NAME        TEXT("TimeStamp")
#define LQS_PATHNAME_PROPERTY_NAME      TEXT("PathName")
#define LQS_QUEUENAME_PROPERTY_NAME     TEXT("QueueName")
#define LQS_LABEL_PROPERTY_NAME         TEXT("Label")
#define LQS_AUTH_PROPERTY_NAME          TEXT("Authenticate")
#define LQS_PRIVLEVEL_PROPERTY_NAME     TEXT("PrivLevel")
#define LQS_TRANSACTION_PROPERTY_NAME   TEXT("Transaction")
#define LQS_SYSQ_PROPERTY_NAME          TEXT("SystemQueue")
#define LQS_PROP_SECTION_NAME           TEXT("Properties")

#define LQS_SIGNATURE_NAME              TEXT("Signature")
#define LQS_SIGNATURE_VALUE             TEXT("DoronJ")
#define LQS_SIGNATURE_NULL_VALUE        TEXT("EpspoK")


ULONG ulPrivates = 0,			// counter of private queues
	  ulPublics  = 0;			// counter of public  queues


BOOL VerifyLqsContents(char * /* pData */, ULONG /* ulLen */, ULONG /* ulParam */)
{
	// TBD
	// We may add here any verification for the LQS contents
	//
	return TRUE;
}

BOOL VerifyLQSFile(LPWSTR wszFile)
{
	BOOL fSuccess = TRUE;

	// Verify general readability
	
	BOOL b = VerifyReadability(NULL, wszFile, 0, VerifyLqsContents, 0);
	if (!b)
	{
		fSuccess = FALSE;
		Failed(L"validate LQS file %s", wszFile);
	}

	// Verify signature
	
    WCHAR awcShortBuff[1000];
    WCHAR *pValBuff = awcShortBuff;
    DWORD dwBuffLen = sizeof(awcShortBuff)/sizeof(WCHAR);
    DWORD dwReqBuffLen;
    awcShortBuff[0] = '\0'; //for win95, when the entry is empty

    dwReqBuffLen = GetPrivateProfileString(LQS_PROP_SECTION_NAME,
                                           LQS_SIGNATURE_NAME,
                                           TEXT(""),
                                           pValBuff,
                                           dwBuffLen,
                                           wszFile);

	if (dwReqBuffLen != wcslen(LQS_SIGNATURE_VALUE))
	{
		fSuccess = FALSE;
		Failed(L"No valid signature in LQS file %s", wszFile);
	}
	else if (wcscmp(awcShortBuff, LQS_SIGNATURE_NULL_VALUE) == 0)
	{
		Warning(L"Null signature in the LQS file %s", wszFile);
	}
	else if (wcscmp(awcShortBuff, LQS_SIGNATURE_VALUE) != 0)
	{
		fSuccess = FALSE;
		Failed(L"validate signature in LQS file %s", wszFile);
	}

	// verify name form

	LPCWSTR lpszPoint  = wcsrchr(wszFile, L'.');
	LPCWSTR lpszBSlash = wcsrchr(wszFile, L'\\');

	if ((lpszPoint - lpszBSlash - 1) == 8)    // In case of a private queue.
	{
		ulPrivates++;
	}
	else if ((lpszPoint - lpszBSlash - 1) == 32)
	{
		ulPublics++;
	}
	else 
	{
		fSuccess = FALSE;
		Failed(L"Wrong name format: %s", wszFile);
	}

	// Verify security descriptor
    dwBuffLen = sizeof(awcShortBuff)/sizeof(WCHAR);
 
	dwReqBuffLen = GetPrivateProfileString(LQS_PROP_SECTION_NAME,
                                           LQS_SECURITY_PROPERTY_NAME,
                                           TEXT(""),
                                           pValBuff,
                                           dwBuffLen,
                                           wszFile);
	
	if (!IsValidSecurityDescriptor((PBYTE)pValBuff))
	{
		//BUGBUG:  it fails always - usage is obviously wrong
		//Failed(L"Wrong security descriptor for lqs %s, err=0x%x", wszFile, GetLastError());
	}


	return fSuccess;
}

BOOL CheckLQS()
{
	BOOL fSuccess = TRUE;

	WCHAR wszDir[MAX_PATH];
	WCHAR wszAll[MAX_PATH];

	wcscpy(wszDir, g_tszPathPersistent);
	wcscat(wszDir, LQS_SUBDIRECTORY);

	wcscpy(wszAll, wszDir);
	wcscat(wszAll, L"*.*");

    WIN32_FIND_DATA FindData;
    HANDLE hFindFile = FindFirstFile(wszAll, &FindData);
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
		Failed(L"find any queues in LQS, err=0x%x", GetLastError());
        return FALSE;
    }

    //
    // Loop while we did not found the appropriate queue, i.e., public
    // or private
    //
    for (;;)
    {
        // Skip over directories and queue of wrong type (private/public).
        BOOL bFound = !(FindData.dwFileAttributes &
                        (FILE_ATTRIBUTE_DIRECTORY |
                         FILE_ATTRIBUTE_READONLY |      // Setup for some reasone creates a read-only
                         FILE_ATTRIBUTE_HIDDEN |        // hidden file named CREATE.DIR.
                         FILE_ATTRIBUTE_TEMPORARY));    // Left-over temporary files   

		
        if (bFound)
        {
            // Verify name form

	        LPCWSTR lpszPoint = wcschr(FindData.cFileName, L'.');
			if ( ((lpszPoint - FindData.cFileName) == 8) ||   // In case of a private queue.
			     ((lpszPoint - FindData.cFileName) == 32))    // In case of a public queue.
			{
				WCHAR wszFile[MAX_PATH];

				wcscpy(wszFile, wszDir);
				wcscat(wszFile, FindData.cFileName);

				BOOL bCorrect = VerifyLQSFile(wszFile);
				if (!bCorrect)
				{
					fSuccess = FALSE;
					Failed(L"Verify LQS file %s", wszFile);
				}
				else
				{
					Succeeded(L"Verify LQS file %s", wszFile);
				}
			}
			else
			{
				Failed(L"recognize lqs file name: %s", FindData.cFileName);
				fSuccess = FALSE;
			}
    
        }

		if (!FindNextFile(hFindFile, &FindData))
        {
            FindClose(hFindFile);
            break;
        }
    }

	Inform(L"LQS statistics:  %d private queues, %d cached public queues", ulPrivates, ulPublics);

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstore\msgfiles.h ===
#ifndef __MSGF_DIAG_H
#define __MSGF_DIAG_H

typedef BOOL (*LPFNVERIFY)(char *, ULONG ulLen, ULONG ulParam);  // Contents verification functionBOOL GatherLocationsFromRegistry();
BOOL LoadPersistentPackets();
BOOL LoadXactStateFiles();
BOOL CheckForExtraFiles();
BOOL VerifyReadability(WIN32_FIND_DATAW *pDataParam, PWSTR pEPath, ULONG ulLen, LPFNVERIFY fn, ULONG ulParam);
BOOL GatherLocationsFromRegistry();
BOOL SummarizeDiskUsage();

extern TCHAR g_tszPathPersistent[];
extern TCHAR g_tszPathJournal[];
extern TCHAR g_tszPathReliable[];
extern TCHAR g_tszPathBitmap[];
extern TCHAR g_tszPathXactLog[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstore\registry.cpp ===
// Validating LQS files
// Borrowed from qm\register.c
//
// AlexDad, February 2000
// 

//
// NOTE: registry routines in mqutil do not provide
// thread or other synchronization. If you change
// implementation here, carefully verify that
// registry routines in mqutil's clients are not
// broken, especially the wrapper routines in
// mqclus.dll  (ShaiK, 19-Apr-1999)
//


#include "stdafx.h"
#include <winreg.h>
#include <uniansi.h>

#include "_mqreg.h"
#include "_mqini.h"

TCHAR  g_tRegKeyName[ 256 ] = {0} ;
HKEY   g_hKeyFalcon = NULL ;

#include "..\registry.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstore\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
#define AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <tchar.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>

//#include <afxtempl.h>

#include "mqstore.h"
#include "..\\base\\base.h" 


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstore\msgfiles.cpp ===
// Validating message files
//
// AlexDad, February 2000
// 

#include "stdafx.h"
#include "_mqini.h"

#include "msgfiles.h"
#include "xact.h"

#include "..\array.h"

// memory reporting stuff

// Use to change the divisor from Kb to Mb.
#define DIV 1024
char *divisor = "K";
#define WIDTH 7



// List of all known files
//
CArr mapfiles;

// Storage locations
//
TCHAR g_tszPathPersistent[MAX_PATH];
TCHAR g_tszPathJournal[MAX_PATH];
TCHAR g_tszPathReliable[MAX_PATH];
TCHAR g_tszPathBitmap[MAX_PATH];
TCHAR g_tszPathXactLog[MAX_PATH];

// FROM inc\Acdef.h
//
//  Number of pools used for storage
//  Reliable, Persistant, Journal, Deadletter
//
enum ACPoolType {
    ptReliable,
    ptPersistent,
    ptJournal,
    ptLastPool
};

//
//  Path count is pool count plus one for the log path
//
#define AC_PATH_COUNT (ptLastPool + 1)

BOOL VerifyMsgsContents(char * /* pData */, ULONG /* ulLen */, ULONG /* ulParam */)
{
	// TBD
	// we could add here any verification for the message file contents
	//
	return TRUE;
}

BOOL VerifBitmapContents(char * /* pData */, ULONG /* ulLen */, ULONG /* ulParam */)
{
	// TBD
	// we could add here any verification for the bitmap file contents
	//
	return TRUE;
}

BOOL GatherLocationsFromRegistry()
{
	BOOL fSuccess = TRUE;
    HRESULT rc;
    DWORD dwType = REG_SZ, dwSize;

    // Get the path for persistent messages
    dwSize = sizeof(g_tszPathPersistent);
    rc = GetFalconKeyValue(MSMQ_STORE_PERSISTENT_PATH_REGNAME,&dwType,g_tszPathPersistent,&dwSize);
    if(rc != ERROR_SUCCESS)
	{
		fSuccess = FALSE;
		Failed(L"get from registry persistent storage location, rc=0x%x", rc);
	}
	else
	{
		Succeeded(L"Storage location - persistent data : %s (set by %s)", 
			   g_tszPathPersistent, MSMQ_STORE_PERSISTENT_PATH_REGNAME);
	}

    // Get the path for journal messages.
    dwSize = sizeof(g_tszPathJournal);
    rc = GetFalconKeyValue(MSMQ_STORE_JOURNAL_PATH_REGNAME,&dwType,g_tszPathJournal,&dwSize);
    if(rc != ERROR_SUCCESS)
	{
		fSuccess = FALSE;
		Failed(L"get from registry journal storage location, rc=0x%x", rc);
	}
	else
	{
		Succeeded(L"Storage location - journal data    : %s (set by %s)", 
			   g_tszPathJournal, MSMQ_STORE_JOURNAL_PATH_REGNAME);
	}

    // Get the path for  reliable messages.
    dwSize = sizeof(g_tszPathReliable);
    rc = GetFalconKeyValue(MSMQ_STORE_RELIABLE_PATH_REGNAME,&dwType,g_tszPathReliable,&dwSize);
    if(rc != ERROR_SUCCESS)
	{
		fSuccess = FALSE;
		Failed(L"get from registry express storage location, rc=0x%x", rc);
	}
	else
	{
		Succeeded(L"Storage location - express data    : %s (set by %s)", 
			   g_tszPathReliable, MSMQ_STORE_RELIABLE_PATH_REGNAME);
	}

    // Get the path for bitmap files.
    dwSize = sizeof(g_tszPathBitmap);
    rc = GetFalconKeyValue(MSMQ_STORE_LOG_PATH_REGNAME,&dwType,g_tszPathBitmap,&dwSize);
    if(rc != ERROR_SUCCESS)
	{
		fSuccess = FALSE;
		Failed(L"get from registry bitmal storage location, rc=0x%x", rc);
	}
	else
	{
		Succeeded(L"Storage location - bitmaps data    : %s (set by %s)", 
			   g_tszPathBitmap, MSMQ_STORE_LOG_PATH_REGNAME);
	}

    // Get the path for transaction files.
    dwSize = sizeof(g_tszPathXactLog);
    rc = GetFalconKeyValue(FALCON_XACTFILE_PATH_REGNAME,&dwType,g_tszPathXactLog,&dwSize);
    if(rc != ERROR_SUCCESS)
	{
		fSuccess = FALSE;
		Failed(L"get from registry transactional storage location, rc=0x%x", rc);
	}
	else
	{
		Succeeded(L"Storage location - xact log data   : %s (set by %s)", 
			   g_tszPathXactLog, FALCON_XACTFILE_PATH_REGNAME);
	}

	return fSuccess;
}


BOOL LookForExtraFiles(LPWSTR pwsPath)
{
	BOOL fSuccess = TRUE;
	WCHAR wszPattern[MAX_PATH+3];

	wcscpy(wszPattern, pwsPath); 
	wcscat(wszPattern, L"\\*.*"); 

	WCHAR *pN = wcsrchr( wszPattern, L'\\');

    HANDLE hEnum;
    WIN32_FIND_DATA FileData;
    hEnum = FindFirstFile(
                wszPattern,
                &FileData
                );

    if(hEnum == INVALID_HANDLE_VALUE)
	{
		// no extras
        return fSuccess;
	}

    do
    {
		if (wcscmp(L".",   FileData.cFileName)==0  || 
			wcscmp(L"..",  FileData.cFileName)==0  ||
			wcscmp(L"LQS", FileData.cFileName)==0    )
		{
			continue;
		}

        wcscpy(pN+1, FileData.cFileName);

		WIN32_FIND_DATA KnownFileData;
		if(mapfiles.Lookup( wszPattern, &KnownFileData )) 
		{
			// This file is known, no problem
		}
		else
		{
			fSuccess = FALSE;
			Warning(L"Extra file found: %s", wszPattern);
		}



    } while(FindNextFile(hEnum, &FileData));

    FindClose(hEnum);
	return fSuccess;
}



BOOL CheckForExtraFiles()
{
	BOOL fSuccess = TRUE, b;

	// Persistent location
	b = LookForExtraFiles(g_tszPathPersistent);
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"make sure that there are no extra files in Persistent location");
	}
	else
	{
		Succeeded(L"No extra files in the Persistent location");
	}

	// Journal location
	if (wcscmp(g_tszPathJournal, g_tszPathPersistent)!=0)
	{
		b = LookForExtraFiles(g_tszPathJournal);
		if(!b)
		{
			fSuccess = FALSE;
			Failed(L"make sure that there are no extra files in journal location");
		}
		else
		{
			Succeeded(L"No extra files in the journal location");
		}
	}


	// Reliable location
	if (wcscmp(g_tszPathReliable, g_tszPathPersistent)!=0 &&
		wcscmp(g_tszPathReliable, g_tszPathJournal)!=0)
	{
		b = LookForExtraFiles(g_tszPathReliable);
		if(!b)
		{
			fSuccess = FALSE;
			Failed(L"make sure that there are no extra files in reliable location");
		}
		else
		{
			Succeeded(L"No extra files in the reliable location");
		}
	}

	// Bitmap location
	if (wcscmp(g_tszPathBitmap, g_tszPathPersistent)!=0 &&
		wcscmp(g_tszPathBitmap, g_tszPathJournal)!=0    &&
		wcscmp(g_tszPathBitmap, g_tszPathReliable)!=0)
	{
		b = LookForExtraFiles(g_tszPathBitmap);
		if(!b)
		{
			fSuccess = FALSE;
			Failed(L"make sure that there are no extra files in bitmap location");
		}
		else
		{
			Succeeded(L"No extra files in the bitmap location");
		}
	}

	// Xact location
	if (wcscmp(g_tszPathXactLog, g_tszPathPersistent)!=0 &&
		wcscmp(g_tszPathXactLog, g_tszPathJournal)!=0    &&
		wcscmp(g_tszPathXactLog, g_tszPathBitmap)!=0    &&
		wcscmp(g_tszPathXactLog, g_tszPathReliable)!=0)
	{
		b = LookForExtraFiles(g_tszPathXactLog);
		if(!b)
		{
			fSuccess = FALSE;
			Failed(L"make sure that there are no extra files in transactional location");
		}
		else
		{
			Succeeded(L"No extra files in the transactional location");
		}
	}

	return fSuccess;
}

BOOL VerifyReadability(WIN32_FIND_DATAW *pDataParam, PWSTR pEPath, ULONG ulLen, LPFNVERIFY fnContentsVerify, ULONG ulParam)
{
	BOOL fSuccess = TRUE;
	WCHAR wszPath[MAX_PATH+1];
	WIN32_FIND_DATAW Data;
	WIN32_FIND_DATAW *pData = &Data;

	if (pDataParam)
	{
		pData = pDataParam;
	}
	else
	{
		
		HANDLE hLogEnum = FindFirstFile(pEPath, pData);

		if(hLogEnum == INVALID_HANDLE_VALUE)
		{
			Failed(L"get data about the file %s, err=0x%x", pEPath, GetLastError());
			return FALSE;
		}
		FindClose(hLogEnum);
	}

	wcscpy(wszPath, pEPath);
    
	WCHAR *pN = wcsrchr( wszPath, L'\\');
	if (pN)
	{
		wcscpy(pN+1, pData->cFileName);
	}
	else
	{
		Failed(L"form file name");
	}

	if (ulLen == 0)
	{
		ulLen = pData->nFileSizeLow;  // using actual length
	}

	if (pData->nFileSizeLow != ulLen)
	{
		fSuccess = FALSE;
		Failed(L" verify the file %s : it has a wrong length 0x%x  0x%x", 
			   pData->cFileName, pData->nFileSizeHigh, pData->nFileSizeLow);
	}

	char *p = new char[ulLen];

	HANDLE f =  CreateFile(wszPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if (f == INVALID_HANDLE_VALUE)
	{
		fSuccess = FALSE;
		Failed(L"Open file %s , error 0x%x", wszPath, GetLastError());
	}
	else
	{
		DWORD dwRead;

		BOOL b = ReadFile(f, p, ulLen, &dwRead, NULL);
		if (!b)
		{
			fSuccess = FALSE;
			Failed(L"Read file %s , error 0x%x", wszPath, GetLastError());
		}

		if (dwRead != ulLen)
		{
			fSuccess = FALSE;
			Failed(L"Read file %s with the length 0x%x: only 0x%x has been read", wszPath, ulLen, dwRead);
		}

		if (fnContentsVerify)
		{
			b = (*fnContentsVerify)(p, dwRead, ulParam);
			if (!b)
			{
				fSuccess = FALSE;
				Failed(L"pass contents verification: %s", wszPath);
			}
		}

		dwRead = 0;
		b = ReadFile(f, p, 1, &dwRead, NULL);
		if (b && dwRead==1)
		{
			fSuccess = FALSE;
			Failed(L"verify the length of the file %s : it is longer than 0x%x", wszPath, ulLen);
		}

		CloseHandle(f);
	}

	delete p;

	mapfiles.Keep(wszPath, pData);

	SYSTEMTIME stCreation, stAccess, stWrite;
	FileTimeToSystemTime(&pData->ftCreationTime,   &stCreation);
	FileTimeToSystemTime(&pData->ftLastAccessTime, &stAccess);
	FileTimeToSystemTime(&pData->ftLastWriteTime,  &stWrite);

    Succeeded(L"read %s:  Created at %d:%d:%d %d/%d/%d, Last written at %d:%d:%d %d/%d/%d,  Last accessed at  %d:%d:%d %d/%d/%d",
	     pData->cFileName, 
		 stCreation.wHour,	stCreation.wMinute, stCreation.wSecond, stCreation.wDay,stCreation.wMonth,	stCreation.wYear,      
	     stWrite.wHour,		stWrite.wMinute,	stWrite.wSecond,	stWrite.wDay,	stWrite.wMonth,		stWrite.wYear,      
	     stAccess.wHour,	stAccess.wMinute,	stAccess.wSecond,	stAccess.wDay,	stAccess.wMonth,	stAccess.wYear);    

	return fSuccess;
}

// from qm\recovery.cpp

inline PWSTR PathSuffix(PWSTR pPath)
{
    return wcsrchr(pPath, L'\\') + 2;
}

DWORD CheckFileName(PWSTR pPath, PWSTR pSuffix)
{
    wcscpy(PathSuffix(pPath), pSuffix);
    return GetFileAttributes(pPath);
}

DWORD GetFileID(PCWSTR pName)
{
    DWORD id = 0;
    _stscanf(pName, TEXT("%x"), &id);
    return id;
}


BOOL
LoadPacketsFile(
    PWSTR pLPath,
    PWSTR pPPath,
    PWSTR pJPath
    )
{
	BOOL b;

	PWSTR pName = PathSuffix(pLPath);

    DWORD dwResult;
    ACPoolType pt;
    if((dwResult = CheckFileName(pPPath, pName)) != 0xffffffff)
    {
        pName = pPPath;
        pt = ptPersistent;
		Succeeded(L"find persistent file %s", pName);
    }
    else if((dwResult = CheckFileName(pJPath, pName)) != 0xffffffff)
    {
        pName = pJPath;
        pt = ptJournal;
		Succeeded(L"find journal file %s", pName);
    }
    else
    {
        //
        //  Error condition we got a log file with no packet file
        //
        //DeleteFile(pLPath);
		Failed(L"find persistent or journal data file for the bitmap %s - bitmap will be deleted at recovery",  pLPath);
        return FALSE;
    }

    // rc = ACRestorePackets(g_hAc, pLPath, pName, dwFileID, pt);

	b = VerifyReadability(NULL, pName, 0x400000, VerifyMsgsContents, 0);
	if (!b)
	{
		Failed(L"verify file %s", pName);
	}

	return b;
}

/*======================================================
Function:        GetRegistryStoragePath
Description:     Get storage path for Falcon data
========================================================*/
BOOL GetRegistryStoragePath(PCWSTR pKey, PWSTR pPath, PCWSTR pSuffix)
{
	GoingTo(L"GetRegistryStoragePath for %s (suffix %s)", pKey, pSuffix);

    DWORD dwValueType = REG_SZ ;
    DWORD dwValueSize = MAX_PATH;

    LONG rc;
    rc = GetFalconKeyValue(
            pKey,
            &dwValueType,
            pPath,
            &dwValueSize
            );

    if(rc != ERROR_SUCCESS)
    {
		Failed(L"GetFalconKeyValue for %s", pKey);
        return FALSE;
    }

    if(dwValueSize < (3 * sizeof(WCHAR)))
    {
		Failed(L"Too short vaue for %s: len=%d, val=%s", pKey, dwValueSize, pPath);
        return FALSE;
    }

    //
    //  Check for absolute path, drive or UNC
    //
    if(!(
        (isalpha(pPath[0]) && (pPath[1] == L':')) ||
        ((pPath[0] == L'\\') && (pPath[1] == L'\\'))
        ))
    {
		Failed(L"Invalid syntax for %s: val=%s", pKey, pPath);
        return FALSE;
    }

    wcscat(pPath, pSuffix);
	Succeeded(L"GetRegistryStoragePath: value is %s", pPath);
    return TRUE;
}

/*======================================================
Function:        GetStoragePath
Description:     Get storage path for mmf
========================================================*/
BOOL GetStoragePath(PWSTR PathPointers[AC_PATH_COUNT])
{
	GoingTo(L"Get Storage Path - in the same wway as QM will do at recovery");

    return (
        //
        //  This first one is a hack to verify that the registry key exists
        //
        GetRegistryStoragePath(FALCON_XACTFILE_PATH_REGNAME,        PathPointers[0], L"") &&

        GetRegistryStoragePath(MSMQ_STORE_RELIABLE_PATH_REGNAME,    PathPointers[0], L"\\r%07x.mq") &&
        GetRegistryStoragePath(MSMQ_STORE_PERSISTENT_PATH_REGNAME,  PathPointers[1], L"\\p%07x.mq") &&
        GetRegistryStoragePath(MSMQ_STORE_JOURNAL_PATH_REGNAME,     PathPointers[2], L"\\j%07x.mq") &&
        GetRegistryStoragePath(MSMQ_STORE_LOG_PATH_REGNAME,         PathPointers[3], L"\\l%07x.mq")
        );
}


BOOL DeleteExpressFiles(PWSTR pEPath)
{
	BOOL fSuccess = TRUE;

	GoingTo(L"Verify all files with express messages - they will be deleted by recovery");

    PWSTR pEName = PathSuffix(pEPath);
    wcscpy(pEName, L"*.mq");
    --pEName;

    HANDLE hEnum;
    WIN32_FIND_DATA ExpressFileData;
    hEnum = FindFirstFile(
                pEPath,
                &ExpressFileData
                );

    if(hEnum == INVALID_HANDLE_VALUE)
	{
		Succeeded(L"see - no express files");
        return TRUE;
	}

    do
    {
        wcscpy(pEName, ExpressFileData.cFileName);
		Inform(L"express file %s will be deleted by the next QM recovery", pEName);

		// Add the file to the map
		//LPWSTR p = new WCHAR(wcslen(pEName)+1);
		//wcscpy(p, pEName);

		WIN32_FIND_DATAW *pData = new WIN32_FIND_DATAW;
		*pData = ExpressFileData;

		BOOL b = VerifyReadability(pData, pEPath, 0x400000, VerifyMsgsContents, 0);
		if (!b)
		{
			fSuccess = b;
			Failed(L"Read the file %s of the length 0x%x", pEPath, ExpressFileData.nFileSizeLow);
		}
		else
		{
			Succeeded(L"Read the file %s of the length 0x%x", pEPath, ExpressFileData.nFileSizeLow);
		}

        //if(!DeleteFile(pEPath))
        //    break;

    } while(FindNextFile(hEnum, &ExpressFileData));

    FindClose(hEnum);

	Succeeded(L"No more express files");

	return fSuccess;
}



BOOL LoadPersistentPackets()
{
	BOOL fSuccess = TRUE;
	GoingTo(L"Pass over all message files");
	

    WCHAR StoragePath[AC_PATH_COUNT][MAX_PATH];
    PWSTR StoragePathPointers[AC_PATH_COUNT];
    for(int i = 0; i < AC_PATH_COUNT; i++)
    {
        StoragePathPointers[i] = StoragePath[i];
    }

    BOOL b = GetStoragePath(StoragePathPointers);
	if (b)
	{
		Succeeded(L"GetStoragePath");
	}
	else
	{
		fSuccess = b;
		Failed(L"GetStoragePath");
	}

	// Find and verify all wxpress message files
	// Be quite: it will not delete actually here
    b = DeleteExpressFiles(StoragePath[0]);
	if (!b) 
	{
		fSuccess = b;
	}
	else
	{
		Inform(L"Express files are healthy");
	}




    PWSTR pPPath = StoragePath[1];
    PWSTR pJPath = StoragePath[2];
    PWSTR pLPath = StoragePath[3];

    PWSTR pLogName = PathSuffix(pLPath);
    wcscpy(pLogName, L"*.mq");
    --pLogName;

    //
    //  Ok now we are ready with the log path template
    //
    HANDLE hLogEnum;
    WIN32_FIND_DATA LogFileData;
    hLogEnum = FindFirstFile(
                pLPath,
                &LogFileData
                );

    if(hLogEnum == INVALID_HANDLE_VALUE)
    {
        //
        //  need to do something, check what happen if no file in directory
        //
		Failed(L"to find any bitmap files - it seems strange");
        return fSuccess;
    }

    do
    {
		b = VerifyReadability(&LogFileData, pLPath, 8192, VerifBitmapContents, 0);
		if (!b)
		{
			Failed(L"verify file %s", pLPath);
		}
   
        wcscpy(pLogName, LogFileData.cFileName);
		GoingTo(L"Verify bitmap file %s", pLogName);

		BOOL b = LoadPacketsFile(pLPath, pPPath, pJPath);
        if (!b)
        {
			fSuccess = FALSE;
            break;
        }

    } while(FindNextFile(hLogEnum, &LogFileData));

    FindClose(hLogEnum);
    return fSuccess;
}

BOOL ReportDiskFreeSpace(LPWSTR wszLoc, LPWSTR wszDone) 
{
	WCHAR wszDisk[5];

	wsprintf(wszDisk, L"%c:\\", wszLoc[0]);

	if (wcsstr(wszDone, wszDisk))
	{
		return TRUE;
	}

	wcscat(wszDone, wszDisk);

	ULARGE_INTEGER	FreeBytesAvailable, TotalNumberOfBytes, TotalNumberOfFreeBytes;

	BOOL b = GetDiskFreeSpaceEx(
		wszDisk,					// directory name
		&FreeBytesAvailable,		// bytes available to caller
		&TotalNumberOfBytes,		// bytes on disk
		&TotalNumberOfFreeBytes);	// free bytes on disk
		
	if (b)
	{
		LONGLONG llkb  = TotalNumberOfFreeBytes.QuadPart / 1024;
		LONGLONG llkbu = FreeBytesAvailable.QuadPart     / 1024;
		LONGLONG llmb  = llkb  / 1024;
		LONGLONG llmbu = llkbu / 1024;

		if (llmb > 0)
		{
			Inform(L"\tDisk %s has over %I64d MB free", wszDisk, llmb);
		}
		else
		{
			Inform(L"\tDisk %s has over %I64d KB", wszDisk, llkb);
		}

		if (llkb != llkbu)
		{
			if (llmb > 0)
			{
				Inform(L"\t     but only over %I64d MB are available to the current user", llmbu);
			}
			else
			{
				Inform(L"\t     but only over %I64d KB are available to the current user", llkbu);
			}
		}
	}
	else
	{
		Failed(L"get disk %s usage data from the OS", wszDisk);
	}

	return b;
}


BOOL SummarizeDiskUsage()
{
	BOOL fSuccess = TRUE;

	//-	total size of message store 
	//-	separately - recoverable, express, journal
	//-	Enough free space on the disk?
	//-	Enough RAM? Compare Msgs/bytes number to kernel memory limits

	// Calculate memory usage per types
	ULONG ulPersistent     = 0,		// all P files
		  ulExpress        = 0,		// all R files		
		  ulJournal        = 0,		// all J files
		  ulBitmap         = 0,		// all L files
		  ulXact           = 0,		// qmlog and snapshot files
		  ulLQS            = 0,		// LQS files
		  ulTotal          = 0;		// all valid files in storage directories
		  //ulDiskTotal      = 0,	//    --- total of the above
		  //ulDiskFree       = 0,	// 
		  //ulPhysicalMemory = 0,	// physical RAM
		  //ulKernelMemory   = 0;	// paged pool


    LPWSTR             pwszName;
    WIN32_FIND_DATAW   *pFind_data;
    mapfiles.StartEnumeration();
    for (pwszName = mapfiles.Next(&pFind_data); pwszName != NULL; pwszName = mapfiles.Next(&pFind_data))
    {
		if (pFind_data->nFileSizeHigh != 0)
		{
			Failed(L"File %s has high size: %d", pwszName, pFind_data->nFileSizeHigh);
			fSuccess = FALSE;
		}
		
		ulTotal += pFind_data->nFileSizeLow;
		switch(towlower(pFind_data->cFileName[0]))
		{
		case L'p':
			ulPersistent += pFind_data->nFileSizeLow;
			break;
		case L'r':
			ulExpress += pFind_data->nFileSizeLow;
			break;
		case L'j':
			ulJournal += pFind_data->nFileSizeLow;
			break;
		case L'l':
			ulBitmap += pFind_data->nFileSizeLow;
			break;
		case L'm':
		case L'q':
			ulXact += pFind_data->nFileSizeLow;
			break;
		case L'0':
		case L'1':
		case L'2':
		case L'3':
		case L'4':
		case L'5':
		case L'6':
		case L'7':
		case L'8':
		case L'9':
		case L'a':
		case L'b':
		case L'c':
		case L'd':
		case L'e':
		case L'f':
			ulLQS += pFind_data->nFileSizeLow;
			break;
		default:
			fSuccess = FALSE;
			Failed(L"Unclear file in summary: %s", pFind_data->cFileName);
		}


    }

	Inform(L" Storage size summary: total    = %d bytes", ulTotal); 
	Inform(L"                       persistent = %d bytes", ulPersistent); 
	Inform(L"                       journal    = %d bytes", ulJournal); 
	Inform(L"                       express    = %d bytes", ulExpress); 
	Inform(L"                       bitmaps    = %d bytes", ulBitmap); 
	Inform(L"                       xact logs  = %d bytes", ulXact); 
	Inform(L"                       LQS data   = %d bytes", ulLQS); 


	// For all different storage locations, get disk data
	WCHAR wszDone[50]=L"";
	
	Inform(L"Disk usage summary: ");

	// Find the disk data for all locations
	ReportDiskFreeSpace(g_tszPathPersistent, wszDone);
	ReportDiskFreeSpace(g_tszPathJournal, wszDone);
	ReportDiskFreeSpace(g_tszPathReliable, wszDone);
	ReportDiskFreeSpace(g_tszPathBitmap, wszDone);
	ReportDiskFreeSpace(g_tszPathXactLog, wszDone);

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstore\mqstore.h ===
#ifndef _MQSTORE_H_
#define _MQSTORE_H_

extern LPTSTR  g_szMachineName;
extern TCHAR   g_tszService[];

extern bool fVerbose ;
extern bool fDebug ;
extern FILE *g_fileLog;
TCHAR g_tszPathPersistent[];
TCHAR g_tszPathJournal[];
TCHAR g_tszPathReliable[];
TCHAR g_tszPathBitmap[];
TCHAR g_tszPathXactLog[];

void OpenLogFile();

BOOL GetComputerNameInternal( 
    WCHAR * pwcsMachineName,
    DWORD * pcbSize);

LONG GetFalconKeyValue(  
					LPCWSTR  pszValueName,
                    PDWORD   pdwType,
                    PVOID    pData,
                    PDWORD   pdwSize,
                    LPCWSTR  pszDefValue = NULL ) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstore\xact.h ===
#ifndef __XACT_DIAG_H
#define __XACT_DIAG_H

BOOL VerifyOneMqTransFileContents(char *pData, ULONG ulLen);
BOOL VerifyOneMqInSeqFileContents(char *pData, ULONG ulLen);
BOOL VerifyXactFilesConsistency();
void XactInit();
BOOL LoadXactStateFiles();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstore\xact.cpp ===
// MQStore tool helps to diagnose problems with MSMQ storage
// This file keeps verification of the transactional checkpoints (MQTrans, MqInseq vs QMlog)
// Borrows heavily from MSMQ itself (qm\xact*.cpp) and old MSMQ1 toolbox - dmpxact\dmpxact, dmpinseq
//
// AlexDad, February 2000
// 
#include <stdafx.h>
#include "xact.h"
#include "msgfiles.h"
#include "log.h"
#include "..\binpatch.h"

extern bool fFix;

#define readvar(type)   *(type *)p; p += sizeof(type)       
#define skipvar(len)    p += len       

// from xactrm.cpp
#define XACTS_SIGNATURE         0x5678

// from xactin.cpp
#define INSEQS_SIGNATURE         0x1234


// from qmfrmt.h
struct  QUEUE_FORMAT
{
	UCHAR m_qft;
	UCHAR m_qst;
	USHORT m_reserved;
	union 
	{
		GUID m_gPublicID;
		OBJECTID m_oPrivateID;
		LPWSTR m_pDirectID;
		GUID m_gMachineID;
		GUID m_gConnectorID;
	};
};
enum QUEUE_FORMAT_TYPE {
    QUEUE_FORMAT_TYPE_UNKNOWN = 0,
    QUEUE_FORMAT_TYPE_PUBLIC,
    QUEUE_FORMAT_TYPE_PRIVATE,
    QUEUE_FORMAT_TYPE_DIRECT,
    QUEUE_FORMAT_TYPE_MACHINE,
    QUEUE_FORMAT_TYPE_CONNECTOR,
};

typedef struct _mqinseq {
	ULONG  PingNo;
	ULONG  Signature;
	ULONG  Seqs;
	ULONG  Directs;
	time_t Latest;
	BOOL   bRead;
	ULONG  PingOffset;
	ULONG  SignOffset;
} _mqinseq;

_mqinseq IncSequences[2];

void ReadInSequence(char * &p, ULONG ulParam)
{
	/* LONGLONG liIDReg		= */ readvar(LONGLONG);
	/* ULONG ulNReg			= */ readvar(ULONG);
	time_t tLastActive		= readvar(time_t);
	/* BOOL fDirect			= */ readvar(BOOL);
	GUID gDestQmOrTaSrcQm	= readvar(GUID);

	UNREFERENCED_PARAMETER(gDestQmOrTaSrcQm) ;

	if (IncSequences[ulParam].Latest < tLastActive) 
		IncSequences[ulParam].Latest = tLastActive;
}

void ReadKeyInSeq(char * &p, ULONG ulParam)
{
	GUID guid = readvar(GUID);
	QUEUE_FORMAT format = readvar(QUEUE_FORMAT);

	UNREFERENCED_PARAMETER(guid) ;

	switch(format.m_qft)
	{
		case QUEUE_FORMAT_TYPE_UNKNOWN:	
		case QUEUE_FORMAT_TYPE_PUBLIC:	
		case QUEUE_FORMAT_TYPE_PRIVATE:	
		case QUEUE_FORMAT_TYPE_MACHINE:	
		case QUEUE_FORMAT_TYPE_CONNECTOR:
			break; 

		case QUEUE_FORMAT_TYPE_DIRECT:	
			{
				ULONG ul = readvar(ULONG);
				skipvar(ul);
			}

			IncSequences[ulParam].Directs++;
			break;
	}
}

void ReadInSeqHash(char * &p, ULONG ulParam, char *pData)
{
	ULONG nFields = readvar(ULONG);
	for(ULONG i=0;i<nFields;i++)
	{
		ReadKeyInSeq(p, ulParam);
		ReadInSequence(p, ulParam);
	}

	IncSequences[ulParam].PingOffset= (PCHAR)p - pData;;
	IncSequences[ulParam].PingNo    = readvar(ULONG);

	IncSequences[ulParam].SignOffset= (PCHAR)p - pData;;
	IncSequences[ulParam].Signature = readvar(ULONG);
	
	IncSequences[ulParam].Seqs      = nFields;
	IncSequences[ulParam].bRead		= TRUE;
}

// from inc\xact.h
typedef struct XACTION_ENTRY {
    ULONG   m_ulIndex;                      //Xact discriminative index 
    ULONG   m_ulFlags;                      //Flags
    ULONG   m_ulSeqNum;                     //Seq Number of the prepared transaction
    GUID	m_uow;			                //Transaction ID  (16b.) (actually was XACTUOW)
    USHORT  m_cbPrepareInfo;                //PrepareInfo length 
    UCHAR  *m_pbPrepareInfo;                //PrepareInfo address
            // This pointer must be last!
} XACTION_ENTRY;


typedef struct  _mqtrans{
	ULONG PingNo;
	ULONG Signature;
	ULONG Xacts;
	BOOL  bRead;
	GUID  guidRM;
	LONGLONG LastSeq;
	ULONG  PingOffset;
	ULONG  SignOffset;
} _mqtrans;

_mqtrans XactCheckpoints[2];


void ReadTransaction(char * &p, ULONG /* ulParam */)
{
	XACTION_ENTRY xaEntry = readvar(XACTION_ENTRY);
	p -= sizeof(UCHAR *);   // so it was saved...

	skipvar(xaEntry.m_cbPrepareInfo);
}


void ReadCheckPoint(char * &p, ULONG ulParam, char *pData)
{
	XactCheckpoints[ulParam].guidRM  = readvar(GUID);
	XactCheckpoints[ulParam].LastSeq = readvar(LONGLONG);
	ULONG nXactions                  = readvar(ULONG); 
	XactCheckpoints[ulParam].Xacts   = nXactions;

	for(ULONG i=0; i<nXactions ; i++)
		ReadTransaction(p, ulParam);

	XactCheckpoints[ulParam].PingOffset = (PCHAR)p - pData;
	XactCheckpoints[ulParam].PingNo     = readvar(ULONG);

	XactCheckpoints[ulParam].SignOffset = (PCHAR)p - pData;
	XactCheckpoints[ulParam].Signature  = readvar(ULONG);

	XactCheckpoints[ulParam].bRead      = TRUE;
}



BOOL VerifyOneMqTransFileContents(char *pData, ULONG ulLen, ULONG ulParam)
{
	char *p = pData;

	ReadCheckPoint(p, ulParam, pData);

	if (p != pData + ulLen)
	{
		//Warning(L"MQTrans file - wrong length: %d", p - pData);
	}

	return TRUE;
}

BOOL VerifyOneMqInSeqFileContents(char *pData, ULONG ulLen, ULONG ulParam)
{
	char *p = pData;

	ReadInSeqHash(p, ulParam, pData);

	if (p != pData + ulLen)
	{
		//Warning(L"MQInseq file - wrong length: %d", p - pData);
	}
	
	return TRUE;
}

BOOL VerifyXactFilesConsistency(BOOL *pfNeedToRewriteInSeqsPingNo, BOOL *pfNeedToRewriteTransPingNo)
{
	BOOL fSuccess = TRUE;
	if (!XactCheckpoints[0].bRead || !XactCheckpoints[1].bRead)
	{
		Failed(L"Read MQTrans files - xact checkpoints");
		return FALSE;
	}

	// Compare ping numbers for xacts
	ULONG latest;
		
	if (XactCheckpoints[1].PingNo > XactCheckpoints[0].PingNo)
	{
		latest = 1;
		if (XactCheckpoints[1].PingNo - XactCheckpoints[0].PingNo != 1)
		{
			fSuccess = FALSE;
			Failed(L"see two consequitive xact checkpoints: %d %d", XactCheckpoints[0].PingNo, XactCheckpoints[1].PingNo);
		}
	}
	else
	{
		latest = 0;
		if (XactCheckpoints[0].PingNo - XactCheckpoints[1].PingNo != 1)
		{
			fSuccess = FALSE;
			Failed(L"see two consequitive xact checkpoints: %d %d", XactCheckpoints[1].PingNo, XactCheckpoints[0].PingNo);
		}
	}


	// Verify signatures for xacts
	if (XactCheckpoints[0].Signature != XACTS_SIGNATURE)
	{
		fSuccess = FALSE;
		Failed(L"Wrong signature in the mqtrans.lg1");
	}

	if (XactCheckpoints[1].Signature != XACTS_SIGNATURE)
	{
		fSuccess = FALSE;
		Failed(L"Wrong signature in the mqtrans.lg2");
	}


	// Print summary for xacts
	Succeeded(L"Latest Xact data  : ping=%d, current transactions counter=%d, last used outgoing SeqID=%I64x",
			 XactCheckpoints[latest].PingNo, XactCheckpoints[latest].Xacts, XactCheckpoints[latest].LastSeq);

	Succeeded(L"Previous Xact data: ping=%d, current transactions counter=%d, last used outgoing SeqID=%I64x",
			 XactCheckpoints[1-latest].PingNo, XactCheckpoints[1-latest].Xacts, XactCheckpoints[1-latest].LastSeq);


	if (!IncSequences[0].bRead || !IncSequences[1].bRead)
	{
		Failed(L"Read MQInSeqs files - sequencing database snapshot");
		return FALSE;
	}

	// Compare ping numbers for inseqs
	if (IncSequences[1].PingNo > IncSequences[0].PingNo)
	{
		latest = 1;
		if (IncSequences[1].PingNo - IncSequences[0].PingNo != 1)
		{
			fSuccess = FALSE;
			Failed(L"see two consequitive sequencing checkpoints: %d %d", IncSequences[0].PingNo, IncSequences[1].PingNo);
		}
	}
	else
	{
		latest = 0;
		if (IncSequences[0].PingNo - IncSequences[1].PingNo != 1)
		{
			fSuccess = FALSE;
			Failed(L"see two consequitive sequencing checkpoints: %d %d", IncSequences[1].PingNo, IncSequences[0].PingNo);
		}
	}

	// Verify signatures for inseqs
	if (IncSequences[0].Signature != INSEQS_SIGNATURE)
	{
		fSuccess = FALSE;
		Failed(L"Wrong signature in the mqinseqs.lg1");
	}
	if (IncSequences[1].Signature != INSEQS_SIGNATURE)
	{
		fSuccess = FALSE;
		Failed(L"Wrong signature in the mqinseqs.lg2");
	}

	// Print summary for inseqs
	Succeeded(L"Latest Sequencing data  : ping=%d, counter=%d, last change at %s",
			 IncSequences[latest].PingNo, IncSequences[latest].Seqs, _wctime(&IncSequences[latest].Latest));

	Succeeded(L"Previous Sequencing data: ping=%d, counter=%d, last change at %s",
			 IncSequences[1-latest].PingNo, IncSequences[1-latest].Seqs, _wctime(&IncSequences[1-latest].Latest));


	// Print summary for the log file
	Succeeded(L"Log file - last checkpoint    : Xact ping = %d, Sequencing ping = %d",
			 LogXactVersions[1], LogInseqVersions[1]);

	Succeeded(L"Log file - previous checkpoint: Xact ping = %d, Sequencing ping = %d",
			 LogXactVersions[0], LogInseqVersions[0]);

	// Compare log file data to checkpoints

	// First and best, latest log checkpoint against latest MQTRANS snapshot
	if (LogXactVersions[1] != XactCheckpoints[latest].PingNo)
	{
		Warning(L"Latest checkpoint in the log file does not match latest MQTRANS snapshot file");
		
		// Second, try previous log checkpoint against previous MQTRANS snapshot

		if (LogXactVersions[0] != XactCheckpoints[1-latest].PingNo)
		{
			Warning(L"One-before-latest checkpoint in the log file does not match one-before-latest MQTRANS snapshot file");
			
			Failed(L"Log file is inconsistent with MQTRANS shapshot files");
			fSuccess = FALSE;
			*pfNeedToRewriteTransPingNo = TRUE;
		}
	}

	// verify that mqtrans.lg1 contains even ping number and mqtrans.lg2 - odd
	if ( (XactCheckpoints[0].PingNo % 2) != 0 || 
		 (XactCheckpoints[1].PingNo % 2) != 1    )
	{
		Warning(L"Parity of the MQTRANS ping numbers contradicts their LG# (even should be in lg1, odd in lg2)");
		
		Failed(L"MQTRANS shapshot files has inconsistent ping versions");
		fSuccess = FALSE;
		*pfNeedToRewriteTransPingNo = TRUE;
	}


	// First and best, latest log checkpoint against latest MQINSEQS snapshot
	if (LogInseqVersions[1] != IncSequences[latest].PingNo)
	{
		Warning(L"Latest checkpoint in the log file does not match latest MQINSEQS snapshot file");
		
		// Second, try previous log checkpoint against previous MQINSEQS snapshot

		if (LogInseqVersions[0] != IncSequences[1-latest].PingNo)
		{
			Warning(L"One-before-latest checkpoint in the log file does not match one-before-latest MQINSEQS snapshot file");
			
			Failed(L"Log file is inconsistent with MQINSEQS shapshot file");
			fSuccess = FALSE;
			*pfNeedToRewriteInSeqsPingNo = TRUE;
		}
	}

	// verify that mqinseq.lg1 contains even ping number and mqinseq.lg2 - odd
	if ( (IncSequences[0].PingNo % 2) != 0 || 
		 (IncSequences[1].PingNo % 2) != 1    )
	{
		Warning(L"Parity of the MQINSEQ ping numbers contradicts their LG# (even should be in lg1, odd in lg2)");
		
		Failed(L"MQINSEQ shapshot files has inconsistent ping versions");
		fSuccess = FALSE;
		*pfNeedToRewriteInSeqsPingNo = TRUE;
	}

	return fSuccess;
}

void XactInit()
{
	for (int i=0; i<2; i++)
	{
		XactCheckpoints[i].bRead = FALSE;

		IncSequences[i].bRead  = FALSE;
		IncSequences[i].Latest = 0;
		IncSequences[i].Directs= 0;
	}
}


BOOL LoadXactStateFiles()
{
	BOOL fSuccess = TRUE, b;
	GoingTo(L"Pass over all xact state files");
	
	// Initialize what's needed
	XactInit();

	WCHAR wszPath[MAX_PATH], 	wszPath2[MAX_PATH];

	wcscpy(wszPath, g_tszPathXactLog);
	wcscat(wszPath, L"\\");
	wcscat(wszPath, L"MQTrans.lg1");
	b = VerifyReadability(NULL, wszPath, 0, VerifyOneMqTransFileContents, 0);
	if (!b)
	{
		fSuccess = b;
		Failed(L"verify file %s", wszPath);
	}

	wcscpy(wszPath2, g_tszPathXactLog);
	wcscat(wszPath2, L"\\");
	wcscat(wszPath2, L"MQTrans.lg2");
	b = VerifyReadability(NULL, wszPath2, 0, VerifyOneMqTransFileContents, 1);
	if (!b)
	{
		fSuccess = b;
		Failed(L"verify file %s", wszPath2);
	}

	wcscpy(wszPath, g_tszPathXactLog);
	wcscat(wszPath, L"\\");
	wcscat(wszPath, L"MQInSeqs.lg1");
	b = VerifyReadability(NULL, wszPath, 0, VerifyOneMqInSeqFileContents, 0);
	if (!b)
	{
		fSuccess = b;
		Failed(L"verify file %s", wszPath);
	}

	wcscpy(wszPath2, g_tszPathXactLog);
	wcscat(wszPath2, L"\\");
	wcscat(wszPath2, L"MQInSeqs.lg2");
	b = VerifyReadability(NULL, wszPath2, 0, VerifyOneMqInSeqFileContents, 1);
	if (!b)
	{
		fSuccess = b;
		Failed(L"verify file %s", wszPath2);
	}

	wcscpy(wszPath, g_tszPathXactLog);
	wcscat(wszPath, L"\\");
	wcscat(wszPath, L"QMLog");
	b = VerifyReadability(NULL, wszPath, 0x600000, NULL, 0);
	if (!b)
	{
		fSuccess = b;
		Failed(L"verify file %s", wszPath);
	}

	b = VerifyQMLogFileContents(wszPath);
	if (!b)
	{
		fSuccess = b;
		Failed(L"verify log file %s", wszPath);
	}

	BOOL fNeedToRewriteInSeqsPingNo = FALSE,
		 fNeedToRewriteTransPingNo  = FALSE;

	b = VerifyXactFilesConsistency(&fNeedToRewriteInSeqsPingNo, &fNeedToRewriteTransPingNo);
	if (!b)
	{
		fSuccess = b;
		Failed(L"verify xact files consistency");
	}

	// If needed and requested, fix version in MQInseqs files
	if (fNeedToRewriteInSeqsPingNo)
	{
		Warning(L"");
		Warning(L"Versions of the MQInseqs.lg checkpoint files contradict to the QMLOG numbers. It will cause problems for MSMQ.");

		if (!fFix)
	  	{
		  	Inform(L"\nYou can use the same tool with -f key to fix the MQInseqs.lg files\n");
		}
		else
		{
			Warning(L"Do you want to fix it?");
			Warning(L"If you agree, the tool will WRITE into both MQInseqs.lg files \n");

			int c = ' ';
			while (c!='Y' && c!='N')
			{
				printf("Do you want that the Store tool will write version numbers from QMLog into MQInSeqs.lg files?\n");
				printf("Answer Y or N  : ");

				c = toupper(getchar());
			}

			if (c == 'Y')
			{
				wcscpy(wszPath, g_tszPathXactLog);
				wcscat(wszPath, L"\\");
				wcscat(wszPath, L"MQInSeqs.lg1");

				int iVer = (LogInseqVersions[0] % 2 == 0 ? LogInseqVersions[0] : LogInseqVersions[1]);

				b = BinPatch(wszPath, 
							 IncSequences[0].PingOffset, iVer, 
							 IncSequences[0].SignOffset, INSEQS_SIGNATURE);
			   	if(!b)
				{
					Failed(L"patch %s with the number %d at offset 0x%x", 
					         wszPath, iVer, IncSequences[0].PingOffset);
					fSuccess = FALSE;
				}
				else
				{
					Warning(L"Successfully patched %s with the number %d at offset 0x%x", 
					         wszPath, iVer, IncSequences[0].PingOffset);
					Warning(L"You must restart msmq now\n");
				}

				wcscpy(wszPath, g_tszPathXactLog);
				wcscat(wszPath, L"\\");
				wcscat(wszPath, L"MQInSeqs.lg2");

				iVer = (LogInseqVersions[0] % 2 == 0 ? LogInseqVersions[1] : LogInseqVersions[0]);
				
				b = BinPatch(wszPath, 
							 IncSequences[1].PingOffset, iVer, 
							 IncSequences[1].SignOffset, INSEQS_SIGNATURE);
			   	if(!b)
				{
					Failed(L"patch %s with the number %d at offset 0x%x", 
					         wszPath, iVer, IncSequences[0].PingOffset);
					fSuccess = FALSE;
				}
				else
				{
					Warning(L"Successfully patched %s with the number %d at offset 0x%x", 
					         wszPath, iVer, IncSequences[0].PingOffset);
					Warning(L"You must restart msmq now\n");
				}
			}
		}
	}	


	// If needed and requested, fix version in MQTrans files
	if (fNeedToRewriteTransPingNo)
	{
		Warning(L"");
		Warning(L"Versions of the MQTrans.lg checkpoint files contradict to the QMLOG numbers. It will cause problems for MSMQ.");

		if (!fFix)
	  	{
		  	Inform(L"\nYou can use the same tool with -f key to fix the MQTrans.lg files\n");
		}
		else
		{
			Warning(L"Do you want to fix it?");
			Warning(L"If you agree, the tool will WRITE into both MQTrans.lg files \n");

			int c = ' ';
			while (c!='Y' && c!='N')
			{
				printf("Do you want that the Store tool will write version numbers from QMLog into MQTrans.lg files?\n");
				printf("Answer Y or N  : ");

				c = toupper(getchar());
			}

			if (c == 'Y')
			{
				wcscpy(wszPath, g_tszPathXactLog);
				wcscat(wszPath, L"\\");
				wcscat(wszPath, L"MQTrans.lg1");

				int iVer = (LogXactVersions[0] % 2 == 0 ? LogXactVersions[0] : LogXactVersions[1]);

				b = BinPatch(wszPath, 
				             XactCheckpoints[0].PingOffset, iVer,
							 XactCheckpoints[0].SignOffset, XACTS_SIGNATURE);
			   	if(!b)
				{
					Failed(L"patch %s with the number %d at offset 0x%x", 
					         wszPath, iVer, XactCheckpoints[0].PingOffset);
					fSuccess = FALSE;
				}
				else
				{
					Warning(L"Successfully patched %s with the number %d at offset 0x%x", 
					         wszPath, iVer, XactCheckpoints[0].PingOffset);
					Warning(L"You must restart msmq now\n");
				}

				wcscpy(wszPath, g_tszPathXactLog);
				wcscat(wszPath, L"\\");
				wcscat(wszPath, L"MQTrans.lg2");

				iVer = (LogXactVersions[0] % 2 == 0 ? LogXactVersions[1] : LogXactVersions[0]);

				b = BinPatch(wszPath, 
				             XactCheckpoints[1].PingOffset, iVer,
							 XactCheckpoints[1].SignOffset, XACTS_SIGNATURE);
			   	if(!b)
				{
					Failed(L"patch %s with the number %d at offset 0x%x", 
					         wszPath, iVer, XactCheckpoints[0].PingOffset);
					fSuccess = FALSE;
				}
				else
				{
					Warning(L"Successfully patched %s with the number %d at offset 0x%x", 
					         wszPath, iVer, XactCheckpoints[0].PingOffset);
					Warning(L"You must restart msmq now\n");
				}
			}
		}
	}	

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqtry\dtcdefs.h ===
// Because we are compiling in UNICODE, here is a problem with DTC...
//#include	<xolehlp.h>
const DWORD		OLE_TM_FLAG_QUERY_SERVICE_LOCKSTATUS = 0x80000000;
extern HRESULT DtcGetTransactionManager(
									LPSTR  pszHost,
									LPSTR	pszTmName,
									REFIID rid,
								    DWORD	dwReserved1,
								    WORD	wcbReserved2,
								    void FAR * pvReserved2,
									void** ppvObject )	;

#define MSDTC_PROXY_DLL_NAME   TEXT("xolehlp.dll")    // Name of the DTC helper proxy DLL

//This API should be used to obtain an IUnknown or a ITransactionDispenser
//interface from the Microsoft Distributed Transaction Coordinator's proxy.
//Typically, a NULL is passed for the host name and the TM Name. In which
//case the MS DTC on the same host is contacted and the interface provided
//for it.
typedef HRESULT (STDAPIVCALLTYPE * LPFNDtcGetTransactionManager) (
                                             LPSTR  pszHost,
                                             LPSTR  pszTmName,
                                    /* in */ REFIID rid,
                                    /* in */ DWORD  i_grfOptions,
                                    /* in */ void FAR * i_pvConfigParams,
                                    /*out */ void** ppvObject ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqtry\async.cpp ===
// Asynchronous event sync implementation
#include "stdafx.h"

#include <transact.h>
#include <olectl.h>

static LONG g_lCommited    = 0;
static LONG g_lAborted     = 0;
static LONG g_lHeuristic   = 0;
static LONG g_lInDoubt     = 0;

static LONG   g_lTotal       = 0;
static HANDLE g_hFinishEvent = NULL;

void SetAnticipatedOutcomes(LONG ul)
{
    g_lTotal = ul;
    g_hFinishEvent =  CreateEvent(NULL, TRUE, FALSE, NULL);
}

void WaitForAllOutcomes(void)
{
    if (g_lTotal && g_hFinishEvent)
    {
        WaitForSingleObject(g_hFinishEvent, INFINITE);
    }
}

void PrintAsyncResults(void)
{
    Inform(L"Async results: %d committed, %d aborted, %d heuristic, %d indoubt",
            g_lCommited, g_lAborted, g_lHeuristic, g_lInDoubt );
}

//---------------------------------------------------------------------
// COutcome::COutcome
//---------------------------------------------------------------------

COutcome::COutcome(void)
{
	m_cRefs = 0;
    m_pCpoint = NULL;
}


//---------------------------------------------------------------------
// COutcome::~COutcome
//---------------------------------------------------------------------
COutcome::~COutcome(void)
{
}



//---------------------------------------------------------------------
// COutcome::QueryInterface
//---------------------------------------------------------------------
STDMETHODIMP COutcome::QueryInterface(REFIID i_iid, LPVOID *ppv)
{
	*ppv = 0;						// Initialize interface pointer.

    if (IID_IUnknown == i_iid || IID_ITransactionOutcomeEvents == i_iid)
	{								// IID supported return interface.
		*ppv = this;
	}

	
	if (0 == *ppv)					// Check for null interface pointer.
	{										
		return ResultFromScode (E_NOINTERFACE);
									// Neither IUnknown nor IResourceManagerSink supported--
									// so return no interface.
	}

	((LPUNKNOWN) *ppv)->AddRef();	// Interface is supported. Increment its usage count.
	
	return S_OK;
}


//---------------------------------------------------------------------
// COutcome::AddRef
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) COutcome::AddRef(void)
{
    return ++m_cRefs;				// Increment interface usage count.
}


//---------------------------------------------------------------------
// COutcome::Release
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) COutcome::Release(void)
{

	--m_cRefs;						// Decrement usage reference count.

	if (0 != m_cRefs)				// Is anyone using the interface?
	{								// The interface is in use.
		return m_cRefs;				// Return the number of references.
	}

	delete this;					// Interface not in use -- delete!

	return 0;						// Zero references returned.
}


//---------------------------------------------------------------------
// COutcome::Committed
//---------------------------------------------------------------------
STDMETHODIMP COutcome::Committed( 
            /* [in] */ BOOL /* fRetaining */,
            /* [in] */ XACTUOW __RPC_FAR * /* pNewUOW */,
            /* [in] */ HRESULT /* hr */)
{
    InterlockedIncrement(&g_lCommited);
    CheckFinish();
    Release();
    return S_OK;
}
        
//---------------------------------------------------------------------
// COutcome::Aborted
//---------------------------------------------------------------------
STDMETHODIMP COutcome::Aborted( 
            /* [in] */ BOID __RPC_FAR * /* pboidReason */,
            /* [in] */ BOOL /* fRetaining */,
            /* [in] */ XACTUOW __RPC_FAR * /* pNewUOW */,
            /* [in] */ HRESULT /* hr */)
{
    InterlockedIncrement(&g_lAborted);
    CheckFinish();
    Release();
    return S_OK;
}
        
//---------------------------------------------------------------------
// COutcome::HeuristicDecision
//---------------------------------------------------------------------
STDMETHODIMP COutcome::HeuristicDecision( 
            /* [in] */ DWORD /* dwDecision */,
            /* [in] */ BOID __RPC_FAR * /* pboidReason */,
            /* [in] */ HRESULT /* hr */)
{
    InterlockedIncrement(&g_lHeuristic);
    CheckFinish();
    Release();
    return S_OK;
}

//---------------------------------------------------------------------
// COutcome::Indoubt
//---------------------------------------------------------------------
STDMETHODIMP COutcome::Indoubt( void)
{
    InterlockedIncrement(&g_lInDoubt);
    CheckFinish();
    Release();
    return S_OK;
}

//---------------------------------------------------------------------
// COutcome::SetCookie
//---------------------------------------------------------------------
STDMETHODIMP COutcome::SetCookie(DWORD dwCookie)
{
    m_dwCookie = dwCookie;
    return S_OK;
}


//---------------------------------------------------------------------
// COutcome::SetConnectionPoint
//---------------------------------------------------------------------
STDMETHODIMP COutcome::SetConnectionPoint(IConnectionPoint *pCpoint)
{
    m_pCpoint = pCpoint;
    return S_OK;
}

//---------------------------------------------------------------------
// COutcome::CheckFinish
//---------------------------------------------------------------------
void COutcome::CheckFinish(void)
{
    if (m_pCpoint)
    {
        m_pCpoint->Unadvise(m_dwCookie);
        m_pCpoint->Release();
    }
    if (g_lTotal <= g_lCommited + g_lAborted + g_lHeuristic + g_lInDoubt)
    {
         SetEvent(g_hFinishEvent);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqtry\modes.h ===
extern ULONG 
		   seed, 
           ulPrevious, 
           nTries, 
           nBurst,
           nThreads,
           nMaxSleep, 
           nMaxTimeQueue,
           nMaxTimeLive, 
           nAbortChances,  
           nAcking, 
           nEncrypt, 
		   nSync,
           nSize,
           nSize2,
           nListing;
extern LPSTR
           pszQueue, 
           pszAdminQueue, 
           pszTable,
           pszMode,
           pszServer;
extern BOOL
		   fTransactions,  
		   fSend, 
		   fReceive, 
		   fEnlist, 
		   fUpdate,  
		   fGlobalCommit, 
		   fDeadLetter, 
		   fJournal,
           fUncoordinated, 
           fStub, 
           fExpress, 
           fInternal, 
           fViper, 
           fXA, 
           fImmediate, 
		   fPeek,
           fDirect,
           fAuthenticate, 
           fBoundaries;

extern void PrintMode(BOOL fTransactions, 
               BOOL fSend, 
               BOOL fReceive, 
               BOOL fEnlist, 
               BOOL fUpdate, 
               BOOL fGlobalCommit, 
               BOOL fUncoordinated,
               BOOL fStub,
               BOOL fExpress,
               BOOL fInternal,
               BOOL fViper,
               BOOL fXA,
			   BOOL fDirect,
               ULONG iTTRQ,
               ULONG iTTBR,
               ULONG iSize,
               ULONG iSize2,
               BOOL  fImmediate,
			   BOOL  fPeek,
               BOOL  fDeadLetter,
               BOOL  fJournal,
               BOOL  fAuthenticate,
               BOOL  fBoundaries);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqstore\mqstore.cpp ===
// This tool helps to diagnose problems with MSMQ storage
//
// AlexDad, February 2000
// 

#include "stdafx.h"
#include "_mqini.h"
#include "msgfiles.h"
#include "lqs.h"
#include "xact.h"
#include <winsvc.h>

extern BOOL DoTheJob();

//
// Log control. The get functions below are called from tmqbase.lib
//
bool fVerbose = false;
bool fDebug   = false;
bool fFix     = false;
FILE *g_fileLog = NULL;
TCHAR g_tszService[100] = L"MSMQ";

FILE *ToolLog()			{	return g_fileLog;	}
BOOL ToolVerbose()		{ 	return fVerbose;	}
BOOL ToolVerboseDebug() { 	return fDebug;		}
BOOL ToolThreadReport() { 	return FALSE;		}

void OpenLogFile()
{
    g_fileLog = fopen( "tmqstore.log", "w" );

    if (g_fileLog)
    {
        time_t  lTime ;
        time( &lTime ) ;
        fprintf(g_fileLog, "tmqstore run at: %ws", _wctime( &lTime ) );
    }
}

void CloseLogFile()
{
    fflush(g_fileLog);
    fclose(g_fileLog);
}

// 
// Main logic of the tool
//
BOOL DoTheJob()
{
	BOOL fSuccess = TRUE, b;

	//--------------------------------------------------------------------------------
	GoingTo(L"Gather from registry the storage locations - per data types"); 
	//--------------------------------------------------------------------------------

	b = GatherLocationsFromRegistry();
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"Gather from registry the storage locations");
	}
	else
	{
		Succeeded(L"Gather data from registry the storage locations");
	}


	//-------------------------------------------------------------------------------
	GoingTo(L"Review the storage directory in the same way as recovery will do it.\n   Please note: mqstore does not parse individual messages, works only on file level\n                use mq2dump if you suspect corrupted messages");
	//-------------------------------------------------------------------------------
	// detect and read all relevant files

	b = LoadPersistentPackets();
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"review the storage");
	}
	else
	{
		Inform(L"Persistent files are healthy");
	}


	//-------------------------------------------------------------------------------
	GoingTo(L"review transactional state files health");
	//-------------------------------------------------------------------------------
	b = LoadXactStateFiles();
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"review the xact state files");
	}
	else
	{
		Inform(L"Transactional state files are healthy");
	}

	//-------------------------------------------------------------------------------
	GoingTo(L"Check for extra files in the storage locations");
	//-------------------------------------------------------------------------------
	b = CheckForExtraFiles();
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"make sure that there are no extra files");
	}
	else
	{
		Inform(L"No extra files");
	}


	//-------------------------------------------------------------------------------
	GoingTo(L"Check the LQS");
	//-------------------------------------------------------------------------------
	b = CheckLQS();
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"make sure that LQS is healthy");
	}
	else
	{
		Inform(L"LQS is healthy");
	}
	
	//-------------------------------------------------------------------------------
	GoingTo(L"Calculate and assess storage sizes");
	//-------------------------------------------------------------------------------
	b = SummarizeDiskUsage();
    if(!b)
	{
		fSuccess = FALSE;
		Failed(L"positevely review disk usage");
	}
	else
	{
		Inform(L"Disk memory usage is healthy");
	}

	return fSuccess;
}

//
//  help
//
void Usage()
{
	printf("usage: store [-v]  [-d] [-s:<service_name>] \n");
	printf("The tool analyzes the MSMQ storage and reports any problems.\n"); 
	printf("It finds and reads all MSMQ data files and parses part of the data.\n"); 
	printf("It will detect any problems with transactional logs or checkpoints.\n");
	printf("Though it won't parse individual messages, so not all corruptions will be noticed.\n"); 
	printf("The tool cannot run together with MSMQ.\n");
	printf("The tool does not write, change or touch anything, so poses no risk.\n");
	printf("-v provide more information; -d gives the highest verbosity\n");
	printf("-s specifies the MSMQ service name, is needed only on the cluster\n");
}

//
//  Main entry point - called from the tmq.exe 
//
int _stdcall run( int argc, char *argv[ ])
{
    //
    // Parse parameters
    //

	for (int i=2; i<argc; i++)
	{
		if (*argv[i] != '-' && *argv[i] != '/')
		{
			printf("Invalid parameter '%S'.\n\n", argv[i]);
            Usage();
		}

		switch (tolower(*(++argv[i])))
		{
		    case 'v':
			    fVerbose = true;
			    break;

		    case 'd':
			    fDebug = true;
			    fVerbose = true;
			    break;

		    case 'f':
			    fFix = true;
			    break;

            case 's':
				if (strlen(argv[i]) > 3)
				{
					mbstowcs(g_tszService, argv[i] + 2, sizeof(g_tszService));
				}
				else if (i+1 < argc)
				{
					mbstowcs(g_tszService, argv[++i], sizeof(g_tszService));
				}
				else
				{
					Usage();
					exit(0);
				}
			    break;

		    default:
			    printf("Unknown switch '%s'.\n\n", argv[i]);
                Usage();
			    exit(0);
		}
	}

    //
    //  we don't want to run in parallel with MSMQ service 
    //
    if (IsMsmqRunning(g_tszService))
    {
        Failed(L"run the test - please stop the msmq service and try once more");
	    exit(0);
    }

	//Inform(L"Starting Thread is t%3x", GetCurrentThreadId());

    //
    // Create mqstore.log - log file in current directory
    //
    OpenLogFile();

    Inform(L"TMQ Store reviews %s storage", g_tszService);

	// Log down time , date, machine, OS
	LogRunCase();

	
	// actual work
    BOOL b = DoTheJob();

	if (b)
	{
		Inform(L"\n\n+++++++ MSMQ Storage is healthy ++++++++\n");
	}
	else
	{
		Inform(L"\n\n-------- TMQ Store has found problems with the Storage ---------\n");
	}

	CloseLogFile();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqtry\async.h ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    Async.h

Abstract:
    This module defines COutcome object

Author:
    Alexander Dadiomov (AlexDad)

--*/

extern void SetAnticipatedOutcomes(LONG ul);
extern void WaitForAllOutcomes(void);
extern void PrintAsyncResults(void);

//---------------------------------------------------------------------
// COutcome:
//---------------------------------------------------------------------

class COutcome: public ITransactionOutcomeEvents
{
public:
	
	COutcome(void);
	~COutcome(void);

    STDMETHODIMP			QueryInterface(REFIID i_iid, LPVOID FAR* ppv);
	STDMETHODIMP_ (ULONG)	AddRef(void);
	STDMETHODIMP_ (ULONG)	Release(void);

    STDMETHODIMP Committed( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
    STDMETHODIMP Aborted( 
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
    STDMETHODIMP HeuristicDecision( 
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr);
        
    STDMETHODIMP Indoubt( void);

    STDMETHODIMP SetCookie(DWORD dwCookie);

    STDMETHODIMP SetConnectionPoint(IConnectionPoint *pCpoint);
	
private:
	ULONG	m_cRefs;
    DWORD   m_dwCookie;
    IConnectionPoint *m_pCpoint;
    
    void CheckFinish(void);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqtry\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mqstore.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqtry\common.h ===
#define ENTER(t)  t -= GetTickCount()
#define LEAVE(t)  t += GetTickCount()
#define PRINT(n,t) printf("%10s %10d %3d\n", n, t,  t*100/ulTimeTotal)

BOOL getDBLIBfunctions();
BOOL getMQRTfunctions();
int msg_handler(DBPROCESS *dbproc, DBINT msgno, int msgstate, int severity, char *msgtext);
int err_handler(DBPROCESS *dbproc, int severity, int dberr, int oserr, char *dberrstr, char *oserrstr);
HRESULT BeginTransaction(ITransaction **ppTrans, ULONG nSync);
HRESULT Send(HANDLE hQueue, ITransaction *pTrans, MQMSGPROPS *pMsgProps);
HRESULT Receive(HANDLE hQueue, ITransaction *pTrans, MQMSGPROPS *pMsgProps, BOOL fImmediate, HANDLE hCursor);
HRESULT Commit(ITransaction *pTrans, BOOL fAsync);
HRESULT Abort(ITransaction *pTrans, BOOL fAsync);
ULONG Release(ITransaction *pTrans);
void DbLogin(ULONG ulLogin, LPSTR pszUser, LPSTR pszPassword);
void DbUse(ULONG ulDbproc, ULONG ulLogin, LPSTR pszDatabase, LPSTR pszServer);
BOOL DbEnlist(ULONG ulDbproc, ITransaction *pTrans);
BOOL DbSql(ULONG ulDbproc, LPSTR pszCommand);
void DbClose();
BOOL StubEnlist(ITransaction *pTrans);
void Sleeping(ULONG nSilent, ULONG nMaxSleep);

#define RECOVERY_TIME 3000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqtry\common.cpp ===
// General sequential test for Falcon/SQL Transactions
#include "stdafx.h"
#include "dtcdefs.h"
#include "sqldefs.h" 
#include "msmqdefs.h" 
#include "modes.h"
#include "common.h"

ITransactionDispenser	*g_pITxDispenser;  // Database connection entities

DBPROCESS	    *g_dbproc[]   = {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
LOGINREC		*g_login[]    = {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
LPCSTR	        g_pszDbLibVer;
RETCODE	        g_rc;
DBINT           g_counter;

ULONG           g_cEnlistFailures 	= 0;
ULONG           g_cBeginFailures 	= 0;
ULONG           g_cDbEnlistFailures = 0;

LPFDBMSGHANDLE_ROUTINE 		*pf_dbmsghandle 	= NULL;
LPFDBERRHANDLE_ROUTINE 		*pf_dberrhandle 	= NULL;
LPFDBINIT_ROUTINE 			*pf_dbinit 			= NULL;
LPFDBLOGIN_ROUTINE 			*pf_dblogin 		= NULL;
LPFDBSETLNAME_ROUTINE 		*pf_dbsetlname 		= NULL;
LPFDBOPEN_ROUTINE 			*pf_dbopen 			= NULL;
LPFDBUSE_ROUTINE 			*pf_dbuse 			= NULL;
LPFDBENLISTTRANS_ROUTINE 	*pf_dbenlisttrans 	= NULL;
LPFDBCMD_ROUTINE 			*pf_dbcmd 			= NULL;
LPFDBSQLEXEC_ROUTINE 		*pf_dbsqlexec		= NULL;
LPFDBRESULTS_ROUTINE 		*pf_dbresults 		= NULL;
LPFDBEXIT_ROUTINE 			*pf_dbexit 			= NULL;
LPFDBDEAD_ROUTINE  			*pf_dbdead  		= NULL;

MQBeginTransaction_ROUTINE     *pf_MQBeginTransaction		= NULL;
MQPathNameToFormatName_ROUTINE *pf_MQPathNameToFormatName	= NULL;
MQOpenQueue_ROUTINE            *pf_MQOpenQueue				= NULL;
MQCloseQueue_ROUTINE           *pf_MQCloseQueue				= NULL;
MQSendMessage_ROUTINE          *pf_MQSendMessage  			= NULL;
MQReceiveMessage_ROUTINE       *pf_MQReceiveMessage			= NULL;


// In order to use InProc RT Stub RM one must add RT_XACT_STUB to preprocessor definitions

HINSTANCE g_DBLib   = NULL;
HINSTANCE g_MQRTLib = NULL;

BOOL getDBLIBfunctions()
{
	// handle of the SQL's DBLIB
    g_DBLib = LoadLibrary(DBLIB_NAME);
    if (g_DBLib == NULL)
    {
     	return FALSE;
    }

    // Get DBLIB functions pointers
    pf_dbmsghandle = (LPFDBMSGHANDLE_ROUTINE *)GetProcAddress(g_DBLib, "dbmsghandle");
    if (!pf_dbmsghandle) 
    	return FALSE;

    pf_dberrhandle = (LPFDBERRHANDLE_ROUTINE *)GetProcAddress(g_DBLib, "dberrhandle");
    if (!pf_dberrhandle) 
   		return FALSE;

    pf_dbinit = (LPFDBINIT_ROUTINE *)GetProcAddress(g_DBLib, "dbinit");
    if (!pf_dbinit) 
       	return FALSE;

    pf_dblogin = (LPFDBLOGIN_ROUTINE *)GetProcAddress(g_DBLib, "dblogin");
    if (!pf_dblogin) 
       	return FALSE;

    pf_dbsetlname = (LPFDBSETLNAME_ROUTINE *)GetProcAddress(g_DBLib, "dbsetlname");
    if (!pf_dbsetlname) 
       	return FALSE;

    pf_dbopen = (LPFDBOPEN_ROUTINE *)GetProcAddress(g_DBLib, "dbopen");
    if (!pf_dbopen) 
       	return FALSE;

    pf_dbuse = (LPFDBUSE_ROUTINE *)GetProcAddress(g_DBLib, "dbuse");
    if (!pf_dbuse) 
       	return FALSE;

    pf_dbenlisttrans = (LPFDBENLISTTRANS_ROUTINE *)GetProcAddress(g_DBLib, "dbenlisttrans");
    if (!pf_dbenlisttrans) 
       	return FALSE;

    pf_dbcmd = (LPFDBCMD_ROUTINE *)GetProcAddress(g_DBLib, "dbcmd");
    if (!pf_dbcmd) 
       	return FALSE;

    pf_dbsqlexec = (LPFDBSQLEXEC_ROUTINE *)GetProcAddress(g_DBLib, "dbsqlexec");
    if (!pf_dbsqlexec) 
       	return FALSE;

    pf_dbresults = (LPFDBRESULTS_ROUTINE *)GetProcAddress(g_DBLib, "dbresults");
    if (!pf_dbresults) 
       	return FALSE;

    pf_dbexit = (LPFDBEXIT_ROUTINE *)GetProcAddress(g_DBLib, "dbexit");
    if (!pf_dbexit) 
       	return FALSE;

	return TRUE;
}

BOOL getMQRTfunctions()
{
	// handle of the SQL's DBLIB
    g_MQRTLib = LoadLibrary(TMQRTLIB_NAME);
    if (g_MQRTLib == NULL)
    {
	    g_MQRTLib = LoadLibrary(MQRTLIB_NAME);
    	if (g_MQRTLib == NULL)
    	{
     		return FALSE;
     	}
    }

    // Get MQRT functions pointers
    pf_MQBeginTransaction = (MQBeginTransaction_ROUTINE *)GetProcAddress(g_MQRTLib, "MQBeginTransaction");
    if (!pf_MQBeginTransaction) 
    	return FALSE;

    pf_MQPathNameToFormatName = (MQPathNameToFormatName_ROUTINE *)GetProcAddress(g_MQRTLib, "MQPathNameToFormatName");
    if (!pf_MQPathNameToFormatName) 
   		return FALSE;

    pf_MQOpenQueue = (MQOpenQueue_ROUTINE *)GetProcAddress(g_MQRTLib, "MQOpenQueue");
    if (!pf_MQOpenQueue) 
       	return FALSE;

    pf_MQCloseQueue = (MQCloseQueue_ROUTINE *)GetProcAddress(g_MQRTLib, "MQCloseQueue");
    if (!pf_MQCloseQueue) 
       	return FALSE;

    pf_MQSendMessage = (MQSendMessage_ROUTINE *)GetProcAddress(g_MQRTLib, "MQSendMessage");
    if (!pf_MQSendMessage) 
       	return FALSE;

    pf_MQReceiveMessage = (MQReceiveMessage_ROUTINE *)GetProcAddress(g_MQRTLib, "MQReceiveMessage");
    if (!pf_MQReceiveMessage) 
       	return FALSE;

	return TRUE;
}

/* Message and error handling functions. */
int msg_handler(DBPROCESS * /* dbproc */, DBINT msgno, int /* msgstate */, int severity, char *msgtext)
{
	/*	Msg 5701 is just a USE DATABASE message, so skip it.	*/
	if (msgno == 5701)
		return (0);

	/*	Print any severity 0 message as is, without extra stuff.	*/
	if (severity == 0)
	{
		Inform(L"%s",msgtext);
		return (0);
	}

	Inform(L"SQL Server message %ld, severity %d:\n\t%s",
		msgno, severity, msgtext);

	if (severity >>= 16)
	{
		Failed(L"Program Terminated! Fatal SQL Server error.");
		exit(ERREXIT);
	}
	return (0);
}


int err_handler(DBPROCESS *dbproc, int /* severity */, int /* dberr */, int oserr, char *dberrstr, char *oserrstr)
{
	if ((dbproc == NULL) || (dyn_DBDEAD(dbproc)))
		return (INT_EXIT);
	else
	{
		printf ("DB-LIBRARY error: \n\t%s", dberrstr);

		if (oserr != DBNOERR)
			printf ("Operating system error:\n\t%s", oserrstr);
	}
	return (INT_CANCEL);
}

HRESULT BeginTransaction(ITransaction **ppTrans, ULONG nSync)
{
	HRESULT hr = XACT_E_CONNECTION_DOWN;

    for (;;)
    {
        hr = g_pITxDispenser->BeginTransaction (
			NULL,						// IUnknown __RPC_FAR *punkOuter,
			ISOLATIONLEVEL_ISOLATED,	// ISOLEVEL isoLevel,
			ISOFLAG_RETAIN_DONTCARE,	// ULONG isoFlags,
			NULL,						// ITransactionOptions *pOptions
			// 0, ISOLATIONLEVEL_UNSPECIFIED, 0,0,
			ppTrans);
        
        if (hr != XACT_E_CONNECTION_DOWN)
            break;

        g_cBeginFailures++;
        Inform(L"BeginTrans failed: Sleeping");
		Sleep(RECOVERY_TIME);
    }

    if (nSync==0)
    {
        COutcome *pOutcome = new COutcome();

        ITransaction *pTrans = *ppTrans;
        IConnectionPointContainer *pCont;

        HRESULT hr = pTrans->QueryInterface (IID_IConnectionPointContainer,(void **)(&pCont));
        if (SUCCEEDED(hr) && pCont)
        {
            IConnectionPoint *pCpoint;

            hr = pCont->FindConnectionPoint(IID_ITransactionOutcomeEvents, &pCpoint);
            if (SUCCEEDED(hr) && pCpoint)
            {
                pOutcome->SetConnectionPoint(pCpoint);

                DWORD dwCookie;
                hr = pCpoint->Advise(pOutcome, &dwCookie);
                if (SUCCEEDED(hr))
                {
                    pOutcome->SetCookie(dwCookie);
                }
                else
                {
                    Inform(L"Advise : hr=%x", hr);
                }
            }
            else
            {
                Inform(L"QueryInterface ICon.P.Cnt.: hr=%x", hr);
            }
            pCont->Release();
        }
    }

    return hr;
}

HRESULT Send(HANDLE hQueue, ITransaction *pTrans, MQMSGPROPS *pMsgProps)
{
    HRESULT hr = MQ_ERROR_TRANSACTION_ENLIST;

    for (;;)
    {
        hr = MQSendMessage_FUNCTION (
                hQueue,
                pMsgProps,
                pTrans);
        if (hr != MQ_ERROR_TRANSACTION_ENLIST)
        {
            break;
        }
   		Inform(L"Enlist Failed, Sleeping");
        g_cEnlistFailures++;
        Sleep(RECOVERY_TIME);
    }

    return hr;
}

HRESULT Receive(HANDLE hQueue, ITransaction *pTrans, MQMSGPROPS *pMsgProps, BOOL fImmediate, HANDLE hCursor)
{
    HRESULT hr = MQ_ERROR_TRANSACTION_ENLIST;
	static  DWORD s_peek_action = MQ_ACTION_PEEK_CURRENT;

    for (;;)
    {
		hr = MQReceiveMessage_FUNCTION (
			hQueue, 
            (fImmediate ? 0 : INFINITE),
			(hCursor == NULL ? MQ_ACTION_RECEIVE : s_peek_action),
			pMsgProps,
			NULL,
			NULL,
			hCursor,
			pTrans);
		
		if (hCursor)
		{
			s_peek_action = MQ_ACTION_PEEK_NEXT;
		}

        if (hr != MQ_ERROR_TRANSACTION_ENLIST)
        {
            break;
        }
   		Inform(L"Enlist Failed, Sleeping");
        g_cEnlistFailures++;
        Sleep(RECOVERY_TIME);
    }

    return hr;
}

HRESULT Commit(ITransaction *pTrans, BOOL fAsync)
{
    HRESULT hr = pTrans->Commit(FALSE, 
                                (fAsync ? XACTTC_ASYNC : 0), 
                                0);
    return (hr == XACT_S_ASYNC ? S_OK : hr);
}

HRESULT Abort(ITransaction *pTrans, BOOL fAsync)
{
	HRESULT hr = pTrans->Abort(NULL, FALSE, fAsync);
    return (hr == XACT_S_ASYNC ? S_OK : hr);
}

ULONG Release(ITransaction *pTrans)
{
	return pTrans->Release();
}

void DbLogin(ULONG ulLogin, LPSTR pszUser, LPSTR pszPassword)
{
    // set error/msg handlers for this program
	(*pf_dbmsghandle)((DBMSGHANDLE_PROC)msg_handler);
	(*pf_dberrhandle)((DBERRHANDLE_PROC)err_handler);

    // Initialize DB-Library.
	g_pszDbLibVer = (*pf_dbinit)();
    if (!g_pszDbLibVer)
    {
        Failed(L"dbinit : %x", g_pszDbLibVer);
        exit(1);
    }

    // Get a LOGINREC.
    g_login[ulLogin] = (*pf_dblogin) ();
    if (!g_login[ulLogin])
    {
        Failed(L"dblogin : %x", g_login[ulLogin]);
        exit(1);
    }

    dyn_DBSETLUSER (g_login[ulLogin], pszUser);   // username, "user1"
    dyn_DBSETLPWD  (g_login[ulLogin], pszPassword);   // password, "user1"
    dyn_DBSETLAPP  (g_login[ulLogin], "SeqTest");    // application

    Inform(L"Login OK, version=%s",  g_pszDbLibVer);
}

void DbUse(ULONG ulDbproc, ULONG ulLogin, LPSTR pszDatabase, LPSTR pszServer)
{
    // Get a DBPROCESS structure for communication with SQL Server.
    g_dbproc[ulDbproc] = (*pf_dbopen) (g_login[ulLogin], pszServer);
    if (g_dbproc[ulDbproc])
    {
        Failed(L"dbopen : %x", g_dbproc[ulDbproc]);
        exit(1);
    }

    // Set current database
	RETCODE	 rc = (*pf_dbuse)(g_dbproc[ulDbproc], pszDatabase);   // database, "test"
    if (rc != SUCCEED)
    {
        Inform(L"dbuse failed: %x", rc); 
        exit(1);
    }
	
	Inform(L"DbUse OK");
}

BOOL DbEnlist(ULONG ulDbproc, ITransaction *pTrans)
{
    for (;;)
    {
        RETCODE rc = (*pf_dbenlisttrans) (g_dbproc[ulDbproc], pTrans);
        if (rc == SUCCEED)
        {
            return TRUE;
        }
   		Inform(L"DbEnlist Failed, Sleeping");
        g_cDbEnlistFailures++;
        Sleep(RECOVERY_TIME);
    }
}

BOOL DbSql(ULONG ulDbproc, LPSTR pszCommand)
{
    // Put the command into the command buffer.
    (*pf_dbcmd) (g_dbproc[ulDbproc], pszCommand);

    // Send the command to SQL Server and start execution.
    RETCODE rc = (*pf_dbsqlexec) (g_dbproc[ulDbproc]);
    if (rc != SUCCEED)
    {
	    Inform(L"dbsqlexec failed: rc=%x", rc);
    }
    else
    {
        rc = (*pf_dbresults)(g_dbproc[ulDbproc]);
        if (rc != SUCCEED)
        {
	        Inform(L"Dbresults: rc=%x", rc);
        }
    }
    return TRUE;
}

void DbClose()
{
    (*pf_dbexit)();
}

#ifdef RT_XACT_STUB
extern HRESULT MQStubRM(ITransaction *pTrans);
#endif

BOOL StubEnlist(ITransaction * /* pTrans */)
{
    HRESULT hr = MQ_OK;
    #ifdef RT_XACT_STUB
    hr = MQStubRM(pTrans);  // to uncomment for stub checks
    #endif
    return (SUCCEEDED(hr));
}

void Sleeping(ULONG nSilent, ULONG nMaxSleep)
{
    int is = rand() * nMaxSleep / RAND_MAX;
	if (nSilent)
		Inform(L"Sleep %d", is);
	Sleep(is);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\template\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mqstore.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\template\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
#define AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <tchar.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>
//#define _WIN32_WINNT 0x0500

#include "..\\base\\base.h" 


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqtry\sqldefs.h ===
#define DBLIB_NAME TEXT("ntwdblib.dll")

//dbmsghandle
typedef DBMSGHANDLE_PROC (SQLAPI *LPFDBMSGHANDLE_ROUTINE)(DBMSGHANDLE_PROC); 
//dberrhandle
typedef DBERRHANDLE_PROC (SQLAPI *LPFDBERRHANDLE_ROUTINE)(DBERRHANDLE_PROC); 
//dbinit
typedef LPCSTR       (SQLAPI *LPFDBINIT_ROUTINE) (void);  						
//dblogin
typedef PLOGINREC    (SQLAPI *LPFDBLOGIN_ROUTINE) (void); 						
//dbsetlname
typedef RETCODE      (SQLAPI *LPFDBSETLNAME_ROUTINE) (PLOGINREC, LPCSTR, INT); 
//dbopen
typedef PDBPROCESS   (SQLAPI *LPFDBOPEN_ROUTINE) (PLOGINREC, LPCSTR);  		
//dbuse
typedef RETCODE      (SQLAPI *LPFDBUSE_ROUTINE) (PDBPROCESS, LPCSTR);  		
//dbenlisttrans
typedef RETCODE 	   (SQLAPI *LPFDBENLISTTRANS_ROUTINE)(PDBPROCESS, LPVOID);  	
//dbcmd
typedef RETCODE      (SQLAPI *LPFDBCMD_ROUTINE) (PDBPROCESS, LPCSTR);  		
//dbsqlexec
typedef RETCODE      (SQLAPI *LPFDBSQLEXEC_ROUTINE) (PDBPROCESS);      		
//dbresults
typedef RETCODE      (SQLAPI *LPFDBRESULTS_ROUTINE) (PDBPROCESS);      		
//dbexit
typedef void         (SQLAPI *LPFDBEXIT_ROUTINE) (void);               		
//dbdead
typedef BOOL   (SQLAPI *LPFDBDEAD_ROUTINE) (PDBPROCESS);

#define dyn_DBSETLUSER(a,b)    (*pf_dbsetlname)   ((a), (b), DBSETUSER)
#define dyn_DBSETLPWD(a,b)     (*pf_dbsetlname)   ((a), (b), DBSETPWD)
#define dyn_DBSETLAPP(a,b)     (*pf_dbsetlname)   ((a), (b), DBSETAPP)
#define dyn_DBDEAD(a)          (*pf_dbdead)       (a)

extern LPFDBMSGHANDLE_ROUTINE *pf_dbmsghandle;
extern LPFDBERRHANDLE_ROUTINE *pf_dberrhandle;
extern LPFDBINIT_ROUTINE *pf_dbinit;
extern LPFDBLOGIN_ROUTINE *pf_dblogin;
extern LPFDBSETLNAME_ROUTINE *pf_dbsetlname;
extern LPFDBOPEN_ROUTINE *pf_dbopen;
extern LPFDBUSE_ROUTINE *pf_dbuse;
extern LPFDBENLISTTRANS_ROUTINE *pf_dbenlisttrans;
extern LPFDBCMD_ROUTINE *pf_dbcmd;
extern LPFDBSQLEXEC_ROUTINE *pf_dbsqlexec;
extern LPFDBRESULTS_ROUTINE *pf_dbresults;
extern LPFDBEXIT_ROUTINE *pf_dbexit;
extern LPFDBDEAD_ROUTINE  *pf_dbdead;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqtry\mqtry.cpp ===
// This tool makes possible to try all types of MSMQ Send/Receive operations
//     previously known as xtest
// AlexDad, March 2000  -- tbd: dyn load mqrt
// 

#include "stdafx.h"
#include "_mqini.h"
#include <winsvc.h>

extern BOOL DoTheJob();

//
// Log control. The get functions below are called from tmqbase.lib
//
bool fVerbose = false;
bool fDebug   = false;
FILE *g_fileLog = NULL;
TCHAR g_tszService[100] = L"MSMQ";

FILE *ToolLog()			{	return g_fileLog;	}
BOOL ToolVerbose()		{ 	return fVerbose;	}
BOOL ToolVerboseDebug() { 	return fDebug;		}
BOOL ToolThreadReport() { 	return FALSE;		}

// modes from parameter line
ULONG      seed = 0, 
           ulPrevious = 0, 
           nTries = 1, 
           nBurst = 1,
           nThreads = 1,
           nMaxSleep = 0, 
           nMaxTimeQueue = 0,
           nMaxTimeLive = 0, 
           nAbortChances = 0,  
           nAcking = 0, 
           nEncrypt = 0, 
           nSync = 1, 
           nSize  = 100,
		   nSize2 = 0,
           nListing = 0;
LPSTR      pszQueue = "", 
           pszAdminQueue = "", 
           pszTable = "",
           pszMode = "ts",
           pszServer = "";
BOOL       fTransactions,  fSend, fReceive, fEnlist, fUpdate,  fGlobalCommit, fDeadLetter, fJournal,
           fUncoordinated, fStub, fExpress, fInternal, fViper, fXA, fImmediate, fPeek,     fDirect,
           fAuthenticate,  fBoundaries;


//-----------------------------------------
// Auxiliary routine: prints mode
//-----------------------------------------
void PrintMode(BOOL fTransactions, 
               BOOL fSend, 
               BOOL fReceive, 
               BOOL fEnlist, 
               BOOL fUpdate, 
               BOOL fGlobalCommit, 
               BOOL fUncoordinated,
               BOOL fStub,
               BOOL fExpress,
               BOOL fInternal,
               BOOL fViper,
               BOOL fXA,
			   BOOL fDirect,
               ULONG iTTRQ,
               ULONG iTTBR,
               ULONG iSize,
               ULONG iSize2,
               BOOL  fImmediate,
			   BOOL  fPeek,
               BOOL  fDeadLetter,
               BOOL  fJournal,
               BOOL  fAuthenticate,
               BOOL  fBoundaries)
{
    Inform(L"\nMode: ");
    if (fTransactions)
        Inform(L"Transactions ");
    if (fSend)
        Inform(L"Send ");
    if (fReceive)
        Inform(L"Receive ");
    if (fEnlist)
        Inform(L"Enlist ");
    if (fUpdate)
        Inform(L"Update ");
    if (fStub)
        Inform(L"Stub ");
    if (fGlobalCommit)
        Inform(L"GlobalCommit ");
    if (fUncoordinated)
        Inform(L"Uncoordinated ");
    if (fExpress)
        Inform(L"Express ");
    if (fDeadLetter)
        Inform(L"DeadLetter ");
    if (fJournal)
        Inform(L"Journal ");
    if (fAuthenticate)
        Inform(L"Authenticated ");
    if (fBoundaries)
        Inform(L"Boundaries ");
    if (fViper)
        Inform(L"Viper ");
    if (fImmediate)
        Inform(L"No wait ");
    if (fPeek)
        Inform(L"Peek ");
    if (fXA)
        Inform(L"XA ");
	if (fDirect)
		Inform(L"Direct ");
    if (fInternal)
        Inform(L"Internal ");
    if (iTTRQ)
        Inform(L"TimeToReachQueue=%d, ",iTTRQ);
    if (iTTBR)
        Inform(L"TimeToBeReceived=%d, ", iTTBR);
    if (iSize)
        Inform(L"BodySize=%d, ",iSize);
    if (iSize2)
        Inform(L"BodySizeMax=%d, ",iSize2);

    if (nEncrypt != 0) {
        Inform(L"Encryption: %d, ", nEncrypt);
    }
    Inform(L"");
}


void OpenLogFile()
{
    g_fileLog = fopen( "tmqtry.log", "w" );

    if (g_fileLog)
    {
        time_t  lTime ;
        time( &lTime ) ;
        fprintf(g_fileLog, "tmqtry run at: %ws", _wctime( &lTime ) );
    }
}

void CloseLogFile()
{
    fflush(g_fileLog);
    fclose(g_fileLog);
}

//
//  help
//
void Usage()
{
        Inform(L"Usage: tmq try mode <parameters>");
        Inform(L"Mode:  tsrmeubgyxvmailhd"); 
        Inform(L"       Transact, Send,   Receive, Peek,  xA,  Enlist,   Update,     autHenticated, bOundaries, Global ");
        Inform(L"       Yncoord.,eXpress, Viper,  iMmediate,   Internal, deadLetter, Journal,       Direct ");
        Inform(L"Parameters:"); 
        Inform(L"    /n #  /b # /t # /Seed  # /sleep # /ttrq # /ttbr # /abort #");
        Inform(L"    /ack # /sync # /q # /a # /table # /srv 3 /lst # /size # ");
        Inform(L" ");
        Inform(L"    /n - number of bursts       \t /q    - target path/formatname");  
        Inform(L"    /t - number of threads      \t /a    - admin queue path/formatname");
        Inform(L"    /b - messages in burst      \t /ack  - ack level"); 
        Inform(L"    /sleep - max between bursts \t /ttrq - TimeToReachQueue");
        Inform(L"    /seed  - seed of random     \t /ttbr - TimeToBeReceived");
        Inform(L"    /table - SQL table name     \t /srv  - SQL server name");
        Inform(L"    /encr  - encryption         \t /?    - full synopsys \n");
        Inform(L"    /abort - PercentOfAborts    \t /lst  - 1/0=verbose/silent ");
        Inform(L"    /size  - body size          \t /sync - 1/0=synch/async commit");
        Inform(L"    /size2 - random add 0..size2 bytes to the body size    ");
}

void Instructions()
{
	printf("MQTRY is intended for diagnostic trial or performance measurements of MSMQ send or receive operations\n");
	printf("	burst = group of messages to be sent/received together\n");
	printf("	values in brackets show default \n");
	printf("/n (1)    - number of bursts \n");
	printf("/b (1)    - number of messages in each burst\n");
	printf("/t (1)	  - number of concurrent threads (each sends/receives /n bursts)\n");
	printf("/q   	  - pathname or formatname of the target queue\n");
	printf("/a   	  - pathname or formatname of the admin  queue \n");
	printf("/size(100)- body size\n");
	printf("/seed (0) - seed number for the random generator\n");
	printf("/sleep(0) - time to wait between bursts (0=no wait)\n");
	printf("/ttrg (0) - value for PROPID_M_TIME_TO_REACH_QUEUE (sec.; 0=infinite)\n");
	printf("/ttbr (0) - value for PROPID_M_TIME_TO_BE_RECEIVED (sec; 0=infinite)\n");
	printf("/abort(0) - percent of the transactions to be randomly aborted \n");
	printf("/ack  (0) - value for the PROPID_M_ACKNOWLEDGE  (0=no ack,15=full ack,...)\n");
	printf("/sync (1) - commit mode: 1=synchronous, 0=asynchronous\n");
	printf("/lst  (0) - listing of operations (1/0)\n");
	printf("/table 	  - name of the SQL Database table to use\n");
	printf("/server	  - name of the server holding SQL database\n");
    printf("/encr (0) - encryption level (1=body base, 3=body enhanced, 0=none\n");
	printf("            ... Press any key to continue . . .\n");
	getchar();
	printf("Mode: some combination of letters:\n");
	printf("   	s - Send\n");
	printf("	r - Receive\n");
	printf("	p - Peek (use with r)\n");
	printf("	d - Direct format queue names\n");
	printf("	x - eXpress messages \n");
	printf("	j - Journal    - PROPID_M_JOURNAL |= MQMSG_JOURNAL    at send\n");
	printf("	l - deadLetter - PROPID_M_JOURNAL |= MQMSG_DEADLETTER at send\n");
	printf("	m - iMmediate  - on receive, timeout=0 (otherwise timeout=INFINITY)\n");
	printf("	h - autHentication: PROPID_M_AUTHENTICATED=1 \n");
    printf("	h - eNcryption: MQMSG_PRIV_LEVEL_BODY=1 \n");
	printf("	t - Transacted (if absent, not transacted)\n");
	printf("	i - Internal MSMQ transactions (no DTC)\n");
	printf("	y - single message transactions (MQ_SINGLE_MESSAGE) \n");
	printf("	a - xA transaction\n");
	printf("	v - MTS (Viper) current transaction\n");
	printf("	g - Global (all operations in one transaction)\n");
	printf("	o - transaction bOundaries - (PROPID_M_FIRST_IN_XACT, *LAST*, *XACTID*)\n");
	printf("	e - Enlist SQL Server into the transaction\n");
	printf("	u - Update SQL inside transaction  \n");
	printf("\n");
	printf("To try performance of 2RM MSMQ & SQL transactions, use SQL manager to create: \n");
	printf("	create user login name = user1 , password=user1 \n");
	printf("	create database TEST with the table named as requested by /table\n");
	printf("	grant to the user1 full rights for database TEST\n");
	printf("	Table contains 2 columns, Counter, Indexing, both numeric, default=0\n");
	printf("	Table should be populated with at least one row, Indexing=1, Counter=0\n");
	printf("	MQTRY will execute  the following SQL operator: \n");
	printf("            'UPDATE <table> SET Counter=Counter + 1 WHERE Indexing=1' \n");
	printf("Call with no parameters to get short synopsys \n");
}

//
//  Main entry point - called from the tmq.exe 
//
int _stdcall run( int argc, char *argv[ ])
{
    //
    // Parse parameters
    //

	//--------------------
	// Get parameters
	//--------------------
	if (argc <= 2)
	{
		Usage();
		return FALSE;
	}

	if (argc==3 && (!strcmp(argv[2], "/?") || !strcmp(argv[2], "-?")))
	{
		Instructions();
		return FALSE;
	}

    // Find out the mode
	pszMode = argv[2];

    fTransactions   = (strchr(pszMode, 't') != NULL);  // use transactions
    fSend           = (strchr(pszMode, 's') != NULL);  // send
    fReceive        = (strchr(pszMode, 'r') != NULL);  // receive
    fEnlist         = (strchr(pszMode, 'e') != NULL);  // enlist SQL
    fUpdate         = (strchr(pszMode, 'u') != NULL);  // update SQL
    fStub           = (strchr(pszMode, 'b') != NULL);  // stub
    fGlobalCommit   = (strchr(pszMode, 'g') != NULL);  // Global Commit/Abort on all actions
    fUncoordinated  = (strchr(pszMode, 'y') != NULL);  // Uncoordinated transaction
    fExpress        = (strchr(pszMode, 'x') != NULL);  // Express messages
    fDeadLetter     = (strchr(pszMode, 'l') != NULL);  // Deadletter
    fJournal        = (strchr(pszMode, 'j') != NULL);  // Journal
    fAuthenticate   = (strchr(pszMode, 'h') != NULL);  // Authentication
    fViper          = (strchr(pszMode, 'v') != NULL);  // Viper implicit
    fImmediate      = (strchr(pszMode, 'm') != NULL);  // No wait
	fPeek			= (strchr(pszMode, 'p') != NULL);  // Peek
    fXA             = (strchr(pszMode, 'a') != NULL);  // XA implicit
    fDirect			= (strchr(pszMode, 'd') != NULL);  // Direct names
    fInternal       = (strchr(pszMode, 'i') != NULL);  // Internal transactions
    fBoundaries     = (strchr(pszMode, 'o') != NULL);  // Transaction bOundaries

    if (!fTransactions && (fEnlist || fGlobalCommit))
    {
        Inform(L"Wrong mode");
		return FALSE;
    }

    srand(seed);

	for (int i=3; i<argc; i++)
	{
		if (*argv[i] != '-' && *argv[i] != '/')
		{
			Inform(L"Invalid parameter '%S'.\n", argv[i]);
            Usage();
            return FALSE;
		}

		if (_stricmp(argv[i]+1, "n") == NULL || _stricmp(argv[i]+1, "nTries") == NULL)
		{
			nTries = atoi(argv[++i]);  
		}
		else if (_stricmp(argv[i]+1, "b") == NULL || _stricmp(argv[i]+1, "burst") == NULL)
		{
			nBurst = atoi(argv[++i]);  
		}
		else if (_stricmp(argv[i]+1, "t") == NULL || _stricmp(argv[i]+1, "threads") == NULL)
		{
			nThreads = atoi(argv[++i]);
		}
		else  if (_stricmp(argv[i]+1, "seeds") == NULL)
		{
			seed = atoi(argv[++i]); 
		}
		else  if (_stricmp(argv[i]+1, "sleep") == NULL)
		{
			nMaxSleep = atoi(argv[++i]); 
		}
		else   if (_stricmp(argv[i]+1, "encr") == NULL)
		{
			nEncrypt = atoi(argv[++i]); 
		}
		else   if (_stricmp(argv[i]+1, "ttrq") == NULL)
		{
			nMaxTimeQueue = atoi(argv[++i]); 
		}
		else   if (_stricmp(argv[i]+1, "ttbr")== NULL || _stricmp(argv[i]+1, "ttl") == NULL)
		{
			nMaxTimeLive = atoi(argv[++i]); 
		}
		else   if (_stricmp(argv[i]+1, "abort") == NULL)
		{
			nAbortChances = atoi(argv[++i]); 
		}
		else   if (_stricmp(argv[i]+1, "ack") == NULL)
		{
			nAcking = atoi(argv[++i]); 
		}
		else   if (_stricmp(argv[i]+1, "sync") == NULL)
		{
			nSync = atoi(argv[++i]); 
		}
		else   if (_stricmp(argv[i]+1, "q") == NULL)
		{
			pszQueue        = argv[++i];   
		}
		else   if (_stricmp(argv[i]+1, "a") == NULL)
		{
			pszAdminQueue        = argv[++i];   
		}
		else   if (_stricmp(argv[i]+1, "table") == NULL)
		{
			pszTable        = argv[++i];   
		}
		else   if (_stricmp(argv[i]+1, "server") == NULL)
		{
			pszServer        = argv[++i];   
		}
		else   if (_stricmp(argv[i]+1, "q") == NULL)
		{
			pszQueue        = argv[++i];   
		}
		else   if (_stricmp(argv[i]+1, "lst") == NULL)
		{
			nListing = atoi(argv[++i]); 
		}
		else   if (_stricmp(argv[i]+1, "size") == NULL)
		{
			nSize = atoi(argv[++i]); 
		}
		else   if (_stricmp(argv[i]+1, "size2") == NULL)
		{
			nSize2 = atoi(argv[++i]); 
		}
		else
		{	
			Failed(L"understand patrameter %S", argv[i]);
		}
	}

    if (seed == 0)
	{
		seed = (ULONG)time(NULL);           //seed
	}

    PrintMode(fTransactions, fSend, fReceive, fEnlist, fUpdate, fGlobalCommit, 
              fUncoordinated, fStub, fExpress, fInternal, fViper, fXA, fDirect,
              nMaxTimeQueue,  nMaxTimeLive, nSize, nSize2, fImmediate, fPeek, fDeadLetter, fJournal, fAuthenticate, fBoundaries);

	Inform(L"Seed number=%d", seed);

    //
    //  we don't want to run in parallel with MSMQ service 
    //
    if (!IsMsmqRunning(g_tszService))
    {
        Warning(L"Msmq service is not running");
    }

	//Inform(L"Starting Thread is t%3x", GetCurrentThreadId());

    //
    // Create mqstore.log - log file in current directory
    //
    OpenLogFile();

    Inform(L"TMQ Try makes diagnostic trial or measures performance of MSMQ send, receive operations", g_tszService);

	// Log down time , date, machine, OS
	LogRunCase();

	
	// actual work
    DoTheJob();


	CloseLogFile();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqtry\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
#define AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <tchar.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>
//#define _WIN32_WINNT 0x0500

#include "..\\base\\base.h" 
#define DBNTWIN32

#define INITGUID
#include <txdtc.h>
//#include <xolehlp.h>
#include "initguid.h"
#include <olectl.h>

#include <sqlfront.h>
#include <sqldb.h>

#include <mq.h>
#include "async.h"



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\tmq\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	tmq.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqtry\msmqdefs.h ===
#define TMQRTLIB_NAME TEXT("tmqrt.dll")
#define  MQRTLIB_NAME TEXT("mqrt.dll")

// when we want dynamic, comment this out
#define MQRT_STATIC

//MQBeginTransaction
typedef HRESULT (APIENTRY *MQBeginTransaction_ROUTINE)(
        	 OUT ITransaction **ppTransaction
       	); 

//MQPathNameToFormatName
typedef HRESULT (APIENTRY *MQPathNameToFormatName_ROUTINE)(
    		IN LPCWSTR lpwcsPathName,
		    OUT LPWSTR lpwcsFormatName,
		    IN OUT LPDWORD lpdwFormatNameLength
    	);
//MQOpenQueue
typedef HRESULT (APIENTRY *MQOpenQueue_ROUTINE)(
    IN LPCWSTR lpwcsFormatName,
    IN DWORD dwAccess,
    IN DWORD dwShareMode,
    OUT QUEUEHANDLE* phQueue
    );

//MQSendMessage 
typedef HRESULT (APIENTRY *  MQSendMessage_ROUTINE)(
    IN QUEUEHANDLE hDestinationQueue,
    IN MQMSGPROPS* pMessageProps,
    IN ITransaction *pTransaction
    );

//MQReceiveMessage_ROUTINE 
typedef HRESULT (APIENTRY *  MQReceiveMessage_ROUTINE)(
    IN QUEUEHANDLE hSource,
    IN DWORD dwTimeout,
    IN DWORD dwAction,
    IN OUT MQMSGPROPS* pMessageProps,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN HANDLE hCursor,
    IN ITransaction* pTransaction
    );

//MQCloseQueue 
typedef HRESULT (APIENTRY *  MQCloseQueue_ROUTINE)(
    IN HANDLE hQueue
    );

// 
//typedef HRESULT (APIENTRY *  _ROUTINE)(

extern MQBeginTransaction_ROUTINE     *pf_MQBeginTransaction;
extern MQPathNameToFormatName_ROUTINE *pf_MQPathNameToFormatName;
extern MQOpenQueue_ROUTINE            *pf_MQOpenQueue;
extern MQCloseQueue_ROUTINE           *pf_MQCloseQueue;
extern MQSendMessage_ROUTINE          *pf_MQSendMessage;
extern MQReceiveMessage_ROUTINE       *pf_MQReceiveMessage;
//extern _ROUTINE            *pf_;

#ifndef MQRT_STATIC
// dynamic load mqrt
#define MQBeginTransaction_FUNCTION  	(*pf_MQBeginTransaction)
#define MQPathNameToFormatName_FUNCTION (*pf_MQPathNameToFormatName)
#define MQOpenQueue_FUNCTION  			(*pf_MQOpenQueue)
#define MQCloseQueue_FUNCTION  			(*pf_MQCloseQueue)
#define MQSendMessage_FUNCTION  		(*pf_MQSendMessage)
#define MQReceiveMessage_FUNCTION  		(*pf_MQReceiveMessage)
//#define _FUNCTION  (*pf_)

#else
// static link to mqrt
#define MQBeginTransaction_FUNCTION      MQBeginTransaction
#define MQPathNameToFormatName_FUNCTION  MQPathNameToFormatName
#define MQOpenQueue_FUNCTION  			 MQOpenQueue
#define MQCloseQueue_FUNCTION  			 MQCloseQueue
#define MQSendMessage_FUNCTION  		 MQSendMessage
#define MQReceiveMessage_FUNCTION  		 MQReceiveMessage
//#define _FUNCTION  

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\tmq\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__3E77B054_48F0_4E83_8FF4_4D54A4B32B0C__INCLUDED_)
#define AFX_STDAFX_H__3E77B054_48F0_4E83_8FF4_4D54A4B32B0C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3E77B054_48F0_4E83_8FF4_4D54A4B32B0C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\template\mqstate.cpp ===
// This tool helps to diagnose problems with MSMQ storage
//
// AlexDad, February 2000
// 

#include "stdafx.h"
#include "_mqini.h"
#include <winsvc.h>

extern BOOL DoTheJob();

//
// Log control. The get functions below are called from tmqbase.lib
//
bool fVerbose = false;
bool fDebug   = false;
FILE *g_fileLog = NULL;
TCHAR g_tszService[100] = L"MSMQ";

FILE *ToolLog()			{	return g_fileLog;	}
BOOL ToolVerbose()		{ 	return fVerbose;	}
BOOL ToolVerboseDebug() { 	return fDebug;		}
BOOL ToolThreadReport() { 	return FALSE;		} 

void OpenLogFile()
{
    g_fileLog = fopen( "tmqstate.log", "w" );

    if (g_fileLog)
    {
        time_t  lTime ;
        time( &lTime ) ;
        fprintf(g_fileLog, "tmqstate run at: %ws", _wctime( &lTime ) );
    }
}

void CloseLogFile()
{
    fflush(g_fileLog);
    fclose(g_fileLog);
}

// 
// Main logic of the tool
//
BOOL DoTheJob()
{
	BOOL fSuccess = TRUE, b;

	//--------------------------------------------------------------------------------
	GoingTo(L"..."); 
	//--------------------------------------------------------------------------------

	b = TRUE;
	if(!b)
	{
		fSuccess = FALSE;
		Failed(L"...");
	}
	else
	{
		Succeeded(L"...");
	}



	return fSuccess;
}

//
//  help
//
void Usage()
{
	printf("usage: state [-v]  [-d] [-s:<service_name>] \n");
}

//
//  Main entry point - called from the tmq.exe 
//
int _stdcall run( int argc, char *argv[ ])
{
    //
    // Parse parameters
    //

	for (int i=2; i<argc; i++)
	{
		if (*argv[i] != '-' && *argv[i] != '/')
		{
			printf("Invalid parameter '%S'.\n\n", argv[i]);
            Usage();
		}

		switch (tolower(*(++argv[i])))
		{
		    case 'v':
			    fVerbose = true;
			    break;

		    case 'd':
			    fDebug = true;
			    fVerbose = true;
			    break;

            case 's':
				if (strlen(argv[i]) > 3)
				{
					mbstowcs(g_tszService, argv[i] + 2, sizeof(g_tszService));
				}
				else if (i+1 < argc)
				{
					mbstowcs(g_tszService, argv[++i], sizeof(g_tszService));
				}
				else
				{
					Usage();
					exit(0);
				}
			    break;

		    default:
			    printf("Unknown switch '%s'.\n\n", argv[i]);
                Usage();
			    exit(0);
		}
	}

    //
    //  we don't want to run in parallel with MSMQ service 
    //
    if (IsMsmqRunning(g_tszService))
    {
        Failed(L"run the test - please stop the msmq service and try once more");
    }

	//Inform(L"Starting Thread is t%3x", GetCurrentThreadId());

    //
    // Create mqstore.log - log file in current directory
    //
    OpenLogFile();

    Inform(L"TMQ State reviews %s state", g_tszService);

	// Log down time , date, machine, OS
	LogRunCase();

	
	// actual work
    BOOL b = DoTheJob();

	if (b)
	{
		Inform(L"\n\n+++++++ MSMQ State is healthy ++++++++\n");
	}
	else
	{
		Inform(L"\n\n-------- TMQ State has found problems with the Storage ---------\n");
	}

	CloseLogFile();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\tmq\tmq.cpp ===
// tmq.cpp : Defines the entry point for the console application.
//
#include <stdio.h>
#include <tchar.h>
#include <windows.h>
#include <winver.h>


typedef int (*Tool_ROUTINE)(int argc, char* argv[]);

void ShowOneTool(LPTSTR lptstrFilename)
{
	DWORD h;
	DWORD dwVerSize = GetFileVersionInfoSize(lptstrFilename, &h);

	if (dwVerSize == 0)
	{
		printf("Cannot get version of %s\n", lptstrFilename);
		return; 
	}

	PCHAR pVerInfo = new char[dwVerSize];

	BOOL b = GetFileVersionInfo(
  				lptstrFilename,         // file name
				h,         				// ignored
  				dwVerSize,            	// size of buffer
  				pVerInfo);           	// version information buffer

	if (b == 0)
	{
		printf("Cannot get version of %s\n", lptstrFilename);
		delete [] pVerInfo; 
		return; 
	}


	// Structure used to store enumerated languages and code pages.

	struct LANGANDCODEPAGE {
	  WORD wLanguage;
	  WORD wCodePage;
	} *lpTranslate;

	TCHAR  wszSubBlock[100];	
	LPTSTR pwszDescription;	
	UINT   dwDescriptionLength, cbTranslate;

	// Read the list of languages and code pages.

	VerQueryValue(pVerInfo, 
              TEXT("\\VarFileInfo\\Translation"),
              (LPVOID*)&lpTranslate,
              &cbTranslate);

	// Read the file description for the first language and code page.
	if ( cbTranslate>0 )
	{
		  wsprintf( wszSubBlock, 
        	    TEXT("\\StringFileInfo\\%04x%04x\\FileDescription"),
            	lpTranslate[0].wLanguage,
	            lpTranslate[0].wCodePage);

		// Retrieve file description for language and code page "i". 
		b = VerQueryValue(
		  		pVerInfo, 					// buffer for version resource
			  	wszSubBlock,   				// value to retrieve
  				(void **)&pwszDescription,  // buffer for version value pointer
  				&dwDescriptionLength);  	// version length
  				
		if (b && pwszDescription && wcsstr(pwszDescription, L"tool"))
		{
			WCHAR wszToolName[50];
			wcscpy(wszToolName, lptstrFilename + 3);
			WCHAR *p = wcschr(wszToolName, L'.');
			if (p)
			{
				*p=L'\0';	
			}


			wprintf(L"%-10s %15s : %s\n", wszToolName, lptstrFilename, pwszDescription);
		}
	}

	delete [] pVerInfo; 

}

void ShowAllTools()
{
	WCHAR wszPattern[MAX_PATH+3] = _T("tmq*.dll");
    HANDLE hEnum;
    WIN32_FIND_DATA FileData;
    
    hEnum = FindFirstFile(
                wszPattern,
                &FileData
                );

    if(hEnum == INVALID_HANDLE_VALUE)
	{
		return;  // no tools
	}

    do
    {
		ShowOneTool(FileData.cFileName);

    } while(FindNextFile(hEnum, &FileData));

    FindClose(hEnum);
	return;
}

void Usage()
{
	printf("Usage: tmq <tool name> <tool parameters>\n");
	printf("For the details about specific tool: tmq <tool name> /?\n");
	printf("Additional tools available at Web site ... \n");
	printf("Available tools: \n\n");
	ShowAllTools();
	return;
}


int __cdecl main(int argc, char* argv[])
{
	if (argc <  2 || 
	    argc == 2 && (strcmp(argv[1], "/?")==0 || strcmp(argv[1], "-?")==0))
	{
		Usage();
		return 0;
	}

	WCHAR wszTool[50];
	wsprintf(wszTool, _T("Tmq%S.dll"), argv[1]);

    HMODULE hModule = LoadLibrary(wszTool);

	if (hModule == 0)
	{
		printf("The tool %ws is unavailable. Please refer to Web site ... or call PSS\n", wszTool);
		Usage();
		return 0;
	}

	Tool_ROUTINE pfnRun = (Tool_ROUTINE)GetProcAddress(hModule, "run");

    if(pfnRun == NULL)
	{
		printf("The tool %ws is unavailable. Please refer to Web site ... \n", wszTool);
		Usage();
		return 0;
	}

    pfnRun(argc, argv);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqdiag\mqtry\xtest.cpp ===
// General sequential test for Falcon/SQL Transactions
#include "stdafx.h"
#include "dtcdefs.h"
#include "sqldefs.h" 
#include "msmqdefs.h" 
#include "modes.h"
#include "common.h"


// Transaction Dispenser DTC's interface
extern ITransactionDispenser	*g_pITxDispenser;

//-------------------------------------
// Global data - read only from threads
//-------------------------------------

HANDLE     hQueueR = NULL, 
           hQueueS = NULL, 
		   hCursor = NULL;

DWORD      dwFormatNameLength = 100;
WCHAR      wszPathName[100];
WCHAR      wszFmtName[100];

ULONG	         nActiveThreads = 0; // counter of live ones
CRITICAL_SECTION crCounter;          // protects nActiveThreads

ULONG      g_cOrderViols = 0;

//------------------------------------
// Cycle of xactions
//------------------------------------
void XactFlow(void *pv)
{
    union {
       ULONG Int;
       char bInt[sizeof(ULONG)];
    } ui;

    memcpy(ui.bInt, pv, sizeof(ULONG));

    ULONG indThread = ui.Int;
    ITransaction *pTrans;
    HRESULT       hr;

    MQMSGPROPS MsgProps;
    MSGPROPID PropId[20];
    MQPROPVARIANT PropVar[20];
    HRESULT Result[20];


    // Time counters for separate steps
    ULONG  ulTimeBegin = 0,
           ulTimeSend = 0,
           ulTimeReceive = 0,
           ulTimeEnlist = 0,
           ulTimeUpdate = 0,
           ulTimeStub = 0,
           ulTimeCommit = 0,
           ulTimeRelease = 0,
           ulTimeSleep = 0,
           ulTimeTotal;

    if (fUpdate)
    {
        DbSql(0, "SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED");
    }
    

	//--------------------
	// start global transaction
	//--------------------
    if (fTransactions && fGlobalCommit && !fUncoordinated)
    {
		if (fInternal)
        {
            hr = MQBeginTransaction_FUNCTION(&pTrans);
        }
        else
        {
            hr = BeginTransaction(&pTrans, nSync);
        }
		if (FAILED(hr))
		{
			Failed(L" (%d) BeginTransaction : %x", indThread,hr);
			return;
		}
		
		if (nListing)
			Inform(L" (%d) Xact Begin\n ", indThread);

        //--------------------
		// Enlist SQL
		//--------------------
        if (fEnlist)
        {
            if (!DbEnlist(0, pTrans))
            {
                Inform(L" (%d) Enlist failed", indThread);
            }
		    else if (nListing)
			    Inform(L" (%d) Enlisted\n ", indThread);
            }

    }
    else
        pTrans = NULL;



	// Cycle
    ULONG  nStep = (nTries > 10 ? nTries / 10 : 1);
    

	for (ULONG i=0; i<nTries; i++)
	{
        if (indThread == 0 && i % nStep == 0)
            Inform(L"Step %d",i);

        if (!fGlobalCommit)
            pTrans = NULL;
        
        //--------------------
		// start transaction
		//--------------------
        ENTER(ulTimeBegin);

        if (fTransactions && !fGlobalCommit || fUncoordinated)
        {
            if (fUncoordinated)
            {
                pTrans = MQ_SINGLE_MESSAGE;
            }
            else if (fViper)
            {
                pTrans = MQ_MTS_TRANSACTION;
            }
            else if (fXA)
            {
                pTrans = MQ_XA_TRANSACTION;
            }
            else
            {
		        if (fInternal)
                {
                    hr = MQBeginTransaction_FUNCTION(&pTrans);
                }
                else
                {
                    hr = BeginTransaction(&pTrans, nSync);
                }
		        if (FAILED(hr))
		        {
			        Inform(L" (%d) BeginTransaction Failed: %x", indThread, hr);
			        Sleep(RECOVERY_TIME);
			        continue;
		        }
		        
		        if (nListing)
			        Inform(L" (%d) Xact %d : ",  indThread, i+1);
            }
        }

        LEAVE(ulTimeBegin);
        //--------------------
		// Send
		//--------------------
        ENTER(ulTimeSend);

        if (fSend)
        {
            for (ULONG iBurst = 0; iBurst < nBurst; iBurst++)
            {
                //--------------------
	    	    // set message properties 
		        //--------------------
		        MsgProps.aPropID = PropId;
		        MsgProps.aPropVar= PropVar;
		        MsgProps.aStatus = Result;

		        int c = 0;

	            // Init values for msg props
		        WCHAR  wszLabel[100];
		        wsprintf(wszLabel, L"Label%d", i+1);

		        //  0:Body
		        WCHAR  wszBody[20000];
		        wsprintf(wszBody, L"Body %d", i+1);

				ULONG ulSize = nSize;
				if (nSize2)
				{
					ulSize += (rand()*nSize2/RAND_MAX);
				}

                PropId[c]             = PROPID_M_BODY; 
		        PropVar[c].vt         = VT_VECTOR | VT_UI1;
                PropVar[c].caub.cElems = ulSize;
    	        PropVar[c].caub.pElems = (unsigned char *)wszBody;
    	        c++;

	            // 1: PROPID_M_LABEL
                PropId[c]     = PROPID_M_LABEL;
		        PropVar[c].vt = VT_LPWSTR;
		        PropVar[c].pwszVal = wszLabel;
    	        c++;

		        // 2: PROPID_M_PRIORITY,
                PropId[c]       = PROPID_M_PRIORITY;
		        PropVar[c].vt   = VT_UI1;
		        PropVar[c].ulVal= 0;
    	        c++;

		        // 3: PROPID_M_TIMETOREACHQUEUE,
                ULONG ulTimeQ= (nMaxTimeQueue == 0 ? LONG_LIVED : nMaxTimeQueue);
                PropId[c]       = PROPID_M_TIME_TO_REACH_QUEUE;
		        PropVar[c].vt   = VT_UI4;
		        PropVar[c].ulVal= ulTimeQ;
    	        c++;

		        // 4: PROPID_M_TIMETOLIVE
                ULONG ulTimeL= (nMaxTimeLive == 0 ? INFINITE : nMaxTimeLive);
                PropId[c]       = PROPID_M_TIME_TO_BE_RECEIVED;
		        PropVar[c].vt   = VT_UI4;
                PropVar[c].ulVal= ulTimeL;
    	        c++;

		        // 5: PROPID_M_ACKNOWLEDGE,
                PropId[c]       = PROPID_M_ACKNOWLEDGE;
		        PropVar[c].vt   = VT_UI1;
		        PropVar[c].bVal = (UCHAR)nAcking;
    	        c++;

	            // 6: PROPID_M_ADMIN_QUEUE
	            if (strlen(pszAdminQueue) > 1)
	            {
	                PropId[c]     = PROPID_M_ADMIN_QUEUE;
			        PropVar[c].vt = VT_LPWSTR;
			        PropVar[c].pwszVal = wszFmtName;
		        } 
    	        c++;

		        // 7: PROPID_M_DELIVERY
                PropId[c]       = PROPID_M_DELIVERY;
		        PropVar[c].vt   = VT_UI1;
                PropVar[c].bVal = (UCHAR)(fExpress ?  MQMSG_DELIVERY_EXPRESS : MQMSG_DELIVERY_RECOVERABLE);
    	        c++;

		        // 8: PROPID_M_APPSPECIFIC
                PropId[c]        = PROPID_M_APPSPECIFIC;
		        PropVar[c].vt    = VT_UI4;
		        PropVar[c].ulVal = i+1;
    	        c++;

		        // 9: PROPID_M_JOURNAL     
                PropId[c]       = PROPID_M_JOURNAL;
		        PropVar[c].vt   = VT_UI1;
                PropVar[c].bVal = (UCHAR)(fDeadLetter ? MQMSG_DEADLETTER : MQMSG_JOURNAL_NONE);

                if (fJournal) 
                {
                    PropVar[c].bVal |= MQMSG_JOURNAL;
                }
    	        c++;

		        // 10: PROPID_M_AUTHENTICATED
                PropId[c]       = PROPID_M_AUTHENTICATED;
		        PropVar[c].vt   = VT_UI1;
                PropVar[c].bVal = (UCHAR)(fAuthenticate ? 1 : 0);
    	        c++;

		        // 11: PROPID_M_PRIV_LEVEL
                PropId[c]       = PROPID_M_PRIV_LEVEL;
		        PropVar[c].vt   = VT_UI4;
                PropVar[c].ulVal= nEncrypt;
    	        c++;

                MsgProps.cProp   = c;

		        hr = Send(hQueueS, pTrans, &MsgProps);
		        if (FAILED(hr))
		        {
			        Inform(L" (%d) MQSendMessage Failed: %x",  indThread,hr);
			        Sleep(RECOVERY_TIME);
			    } 
                else if (nListing)
			        Inform(L" (%d) Sent  ", indThread);
            }
        }

        LEAVE(ulTimeSend);
        //--------------------
		// Receive
		//--------------------
        ENTER(ulTimeReceive);
        OBJECTID  xid;
        memset(&xid, 0, sizeof(xid));
        
        if (fReceive)
        {
            for (ULONG iBurst = 0; iBurst < nBurst; iBurst++)
            {
		        //--------------------
		        // set message properties
		        //--------------------
		        MsgProps.aPropID = PropId;
		        MsgProps.aPropVar= PropVar;
		        MsgProps.aStatus = Result;

		        int c= 0;

	            // Init values for msg props
		        WCHAR  wszLabel[100];

	            // 0: PROPID_M_LABEL
                PropId[c]     = PROPID_M_LABEL;
		        PropVar[c].vt = VT_LPWSTR;
		        PropVar[c].pwszVal = wszLabel;
                c++;

	            // 1: PROPID_M_LABEL_LEN
                PropId[c]     = PROPID_M_LABEL_LEN;
		        PropVar[c].vt = VT_UI4;
		        PropVar[c].ulVal = sizeof(wszLabel) / sizeof(WCHAR);
                c++;

                // 2: PROPID_M_APPSPECIFIC
                PropId[c]     = PROPID_M_APPSPECIFIC;
		        PropVar[c].vt = VT_UI4;
                c++;

                if (fBoundaries)
                {
                      // 3 : PROPID_M_FIRST_IN_XACT
                      PropId[c] = PROPID_M_FIRST_IN_XACT;       // Property ID
                      PropVar[c].vt = VT_UI1;               // Type indicator
                      c++;

                      // 4: PROPID_M_LAST_IN_XACT
                      PropId[c] = PROPID_M_LAST_IN_XACT;       // Property ID
                      PropVar[c].vt = VT_UI1;               // Type indicator
                      c++;

                      // 5: PROPID_M_XACTID
                      PropId[c] = PROPID_M_XACTID;                 // Property ID
                      PropVar[c].vt = VT_UI1 | VT_VECTOR;          // Type indicator
                      PropVar[c].caub.cElems = sizeof(OBJECTID);
                      PropVar[c].caub.pElems = (PUCHAR)&xid;
                      c++;
                }
                MsgProps.cProp = c;

                hr = Receive(hQueueR, pTrans, &MsgProps, fImmediate, hCursor);
		        if (FAILED(hr))
		        {
			        Inform(L"\n (%d) MQReceiveMessage Failed: %x", indThread, hr);
			        Sleep(RECOVERY_TIME);
		        }
                else if (nListing)
                {
    	            Inform(L"\n (%d) Received: %d  ",  indThread,i);
                    if (fBoundaries)
                        printf (" First=%d Last=%d Index=%d ",  
                                 PropVar[3].bVal, PropVar[4].bVal, xid.Uniquifier);
                }

                // Check ordering
                if (nThreads == 1)
                {
	                if (ulPrevious != 0 && PropVar[2].ulVal != ulPrevious+1)
    	            {
        	            if (g_cOrderViols++ < 10)
            	        {
                	        Inform(L"Order violation: %d before %d", ulPrevious, PropVar[2].ulVal);         
                    	}
                	}
                }
                ulPrevious = PropVar[2].ulVal; 
            }
        }

        LEAVE(ulTimeReceive);
        //--------------------
		// Enlist SQL
		//--------------------
        ENTER(ulTimeEnlist);

        if (fEnlist && !fGlobalCommit)
        {
            if (!DbEnlist(0, pTrans))
            {
                Inform(L" (%d) Enlist failed", indThread);
            }
		    else if (nListing)
			    Inform(L" (%d) Enlisted ", indThread);
            }

        LEAVE(ulTimeEnlist);
        //-------------------- 
		// Update sql
		//--------------------
        ENTER(ulTimeUpdate);

        if (fUpdate)
        {
            CHAR  string[256];
            sprintf(string, "UPDATE %s SET Counter=Counter + 1 WHERE Indexing=%d", 
                            pszTable, 1 /*rand() * 999 / RAND_MAX*/);

            DbSql(0, string);
            if (nListing)
			    Inform(L" (%d) Updated ", indThread);        
        }

        LEAVE(ulTimeUpdate);
        //--------------------
		// Stub
		//--------------------
        ENTER(ulTimeStub);

        if (fStub)
        {
            if (!StubEnlist(pTrans))
                Inform(L"Stub fail");
        }

        LEAVE(ulTimeStub);
        //--------------------
		// Commit / Abort
		//--------------------
        ENTER(ulTimeCommit);

        if (fTransactions && !fGlobalCommit && !fUncoordinated)
        {
            if ((ULONG)rand() * 100 / RAND_MAX < nAbortChances)
		    {
       		    hr = Abort(pTrans, nSync==0);
			    if (nListing)
				    Inform(L" (%d)Abort  ", indThread);
                if (hr)
                {
                    Inform(L"   (%d) hr=%x", indThread, hr);
                }
		    }
		    else
		    {
       		    hr = Commit(pTrans, nSync==0);
			    if (nListing)
   				    Inform(L" (%d)Commit  ", indThread);
                if (hr)
                {
                    Inform(L"  (%d) hr=%x", indThread, hr);
                }
		    }
        }

        LEAVE(ulTimeCommit);
		//--------------------
		// Release
		//--------------------
        ENTER(ulTimeRelease);

        if (fTransactions && !fGlobalCommit && !fUncoordinated)
        {
            Release(pTrans);
        }

        LEAVE(ulTimeRelease);
		//--------------------
		// sleep
		//--------------------
        ENTER(ulTimeSleep);

        if (nMaxSleep)
        {
            Sleeping(nListing, nMaxSleep);
        }

        LEAVE(ulTimeSleep);
	}

    //--------------------
	// Global Commit / Abort
	//--------------------
    if (fGlobalCommit && !fUncoordinated)
    {
        if ((ULONG)rand() * 100 / RAND_MAX < nAbortChances)
		{
       		hr = Abort(pTrans, nSync==0);
			if (nListing)
				Inform(L" (%d)Abort  ", indThread);
            if (hr)
            {
                Inform(L"   (%d) hr=%x", indThread, hr);
            }
		}
		else
		{
       		hr = Commit(pTrans, nSync==0);
			if (nListing)
   				Inform(L" (%d)Commit  ", indThread);
            if (hr)
            {
                Inform(L"  (%d) hr=%x", indThread, hr);
            }
		}
        Release(pTrans);
    }

    if (nTries*nBurst > 100)
    {
        ulTimeTotal = ulTimeBegin   + ulTimeSend   + ulTimeReceive +
                      ulTimeEnlist  + ulTimeUpdate + ulTimeCommit  +
                      ulTimeStub    + ulTimeRelease + ulTimeSleep;

        Inform(L"Time distribution (total time=%d): \n     Stage       Time   Percent", ulTimeTotal);
        PRINT("Begin",   ulTimeBegin);
        PRINT("Send",    ulTimeSend);
        PRINT("Receive", ulTimeReceive);
        PRINT("Enlist",  ulTimeEnlist);
        PRINT("Update",  ulTimeUpdate);
        PRINT("Stub",    ulTimeStub);
        PRINT("Commit",  ulTimeCommit);
        PRINT("Release", ulTimeRelease);
        PRINT("Sleep",   ulTimeSleep);

        //getchar();
    }
    EnterCriticalSection(&crCounter); // protects nActiveThreads
    nActiveThreads--;
    LeaveCriticalSection(&crCounter); // protects nActiveThreads
}

//--------------------------------------
// main routine: parses, starts threads
//-------------------------------------
BOOL DoTheJob()
{
	HRESULT    hr = 0;

#ifndef MQRT_STATIC
	// Get MQRT 
	if (!getMQRTfunctions())
	{
		Failed(L" get MQRT library");
		return FALSE;
	};
#endif

    if (nSync==0)
    {
        SetAnticipatedOutcomes(nTries*nThreads*nBurst);
    }

    //--------------------
	// DTC init
	//---------------------
	//CoInitialize(0) ;
    if (fTransactions && !fUncoordinated && !fInternal)
    {
	    // Connect to DTC

    	CoInitialize(0) ;

        // handle of the loaded DTC proxy library (defined in mqutil.cpp)
        HINSTANCE g_DtcHlib = LoadLibrary(MSDTC_PROXY_DLL_NAME);

        // Get DTC API pointer
        LPFNDtcGetTransactionManager pfDtcGetTransactionManager =
              (LPFNDtcGetTransactionManager) GetProcAddress(g_DtcHlib, "DtcGetTransactionManagerExA");

        if (!pfDtcGetTransactionManager) 
        {
            pfDtcGetTransactionManager =
              (LPFNDtcGetTransactionManager) GetProcAddress(g_DtcHlib, "DtcGetTransactionManagerEx");
        }

        if (!pfDtcGetTransactionManager)
        {
            Inform(L"Cannot  GetProcAddress DtcGetTransactionManagerEx");
			return FALSE;
        }

        // Get DTC IUnknown pointer
        hr = (*pfDtcGetTransactionManager)(
                                 NULL,
                                 NULL,
                                 IID_ITransactionDispenser,
                                 OLE_TM_FLAG_QUERY_SERVICE_LOCKSTATUS,
                                 0,
                                 (void**) &g_pITxDispenser);

        if (FAILED(hr))
        {
            Inform(L"DtcGetTransactionManager returned %x", hr);
    		return FALSE;
        }
    }

    //--------------------
	// Open Queue
	//---------------------
    if (fSend || fReceive)
    {
        mbstowcs( wszPathName, pszQueue, 100);
		if (!fDirect)
		{
			hr = MQPathNameToFormatName_FUNCTION (
			                            &wszPathName[0],
										&wszFmtName[0],
										&dwFormatNameLength);
		}
		if (fDirect || FAILED(hr))
	    {
            wcscpy(&wszFmtName[0], &wszPathName[0]);
	    }

        if (fSend)
        {
	        hr = MQOpenQueue_FUNCTION (
                               &wszFmtName[0],
                               MQ_SEND_ACCESS,
                               0,
                               &hQueueS);

	        if (FAILED(hr))
	        {
		        Inform(L"MQOpenQueue Failed: %x", hr);
	 			return FALSE;
	        }
        }

        if (fReceive)
        {
	        hr = MQOpenQueue_FUNCTION (
                               &wszFmtName[0],
                               MQ_RECEIVE_ACCESS,
                               0,
                               &hQueueR);

	        if (FAILED(hr))
	        {
		        Inform(L"MQOpenQueue Failed: %x", hr);
		        return FALSE;
	        }

			if (fPeek)
			{
				hr = MQCreateCursor(hQueueR, &hCursor);
		        if (FAILED(hr))
		        {
			        Inform(L"MQCreateCursor Failed: %x", hr);
				    return FALSE;
				}
  			}

        }

	    //--------------------
	    // Admin Queue
	    //---------------------
		if (strlen(pszAdminQueue)>1)
		{
		    dwFormatNameLength = 100;

    	    mbstowcs( wszPathName, pszAdminQueue, 100);
			if (!fDirect)
			{
				hr = MQPathNameToFormatName_FUNCTION (
				                            &wszPathName[0],
											&wszFmtName[0],
											&dwFormatNameLength);
			}
			if (fDirect || FAILED(hr))
	    	{
            	wcscpy(&wszFmtName[0], &wszPathName[0]);
		    }
		 }
    }

	//--------------------
	// Connect to database
	//--------------------
    if (fEnlist || fUpdate)
    {
		// Get DBLIB 
		if (!getDBLIBfunctions())
		{
			Inform(L"Cannot get DBLIB library %s - so db operations are unavailable", DBLIB_NAME);
			return FALSE;
		};
	
        DbLogin(0, "user1", "user1");
        DbUse(0, 0, "test", pszServer) ;
    }

    nActiveThreads = nThreads;
    InitializeCriticalSection(&crCounter); // protects nActiveThreads

    //------------------------
    // Start threads
    //------------------------
    for (ULONG iThrd=0; iThrd<nThreads; iThrd++) {
        DWORD dwThreadId ;

	union {
       	   ULONG Int;
           char bInt[sizeof(ULONG)];
        } ui;
	ui.Int = iThrd;

        CreateThread(   NULL,
                        0,
                        (LPTHREAD_START_ROUTINE)XactFlow,
                        (void *)ui.bInt,
                        0,
                        &dwThreadId);
    }

    // Starting measurement
    //time_t  t1 = time(NULL);  
    ULONG t1 = GetTickCount();

    //-------------------------
    // Waiting Cycle
    //-------------------------
    while (nActiveThreads > 0) {
        Sleep(1000);
    }

    if (nTries * nThreads * nBurst >= 100)
    {

        // Measuring time
   	    //time_t t2 = time(NULL);
        ULONG t2 = GetTickCount();
	    ULONG delta = t2 - t1;
	    
        PrintMode(fTransactions, fSend, fReceive, fEnlist, fUpdate, fGlobalCommit, 
                  fUncoordinated, fStub, fExpress, fInternal, fViper, fXA, fDirect,
                  nMaxTimeQueue, nMaxTimeLive, nSize, nSize2, fImmediate, fPeek, fDeadLetter, fJournal, fAuthenticate, fBoundaries);
        Inform(L"\n Time: %d seconds; %d msec per message;    %d messages per second ", 
		    delta/1000,  
            delta/nTries/nThreads/nBurst,  
            (delta==0? 0 : (1000*nTries*nThreads*nBurst /*+delta/2-1*/)/delta));

    extern ULONG           g_cEnlistFailures;
    extern ULONG           g_cBeginFailures;
    extern ULONG           g_cDbEnlistFailures;

        if (g_cEnlistFailures)
            Inform(L"%d Enlist failures", g_cEnlistFailures);
        if (g_cDbEnlistFailures)
            Inform(L"%d DbEnlist failures", g_cDbEnlistFailures);
        if (g_cBeginFailures)
            Inform(L"%d Begin failures", g_cBeginFailures);

        if (nSync==0)
        {
            WaitForAllOutcomes();

            // Measuring time
            ULONG t3 = GetTickCount();
	        delta = t3 - t1;

            PrintAsyncResults();

            Inform(L"\n Async completion: %d sec; %d msec per message;    %d messages per second ", 
		        delta/1000,  
                delta/nTries/nThreads/nBurst,  
                (delta==0? 0 : ((1000*nTries*nThreads*nBurst /*+delta/2-1*/)/delta)));
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqforgn\mqfrgnky.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mqfrgnky.h

Abstract:

    header file for the mqfrgnky.dll.
    Used to insert public keys into msmqConfiguration objects of foreign
    computers.

Author:

    Doron Juster  (DoronJ)   21-June-1999  Created

--*/

#ifndef __MQFRGNKY_H_
#define __MQFRGNKY_H_

HRESULT APIENTRY
MQFrgn_StorePubKeysInDS( IN LPWSTR pwszMachineName,
                         IN LPWSTR pwszKeyName,
                         IN BOOL   fRegenerate ) ;

typedef HRESULT
(APIENTRY *MQFrgn_StorePubKeysInDS_ROUTINE) ( IN LPWSTR pwszMachineName,
                                              IN LPWSTR pwszKeyName,
                                              IN BOOL   fRegenerate ) ;

#endif //  __MQFRGNKY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqforgn\mqforgn.cpp ===
/*++

Copyright (c) 1995-99 Microsoft Corporation. All rights reserved

Module Name:
    mqforgn.cpp

Abstract:
    Command line utility to create a foreign computer and foreign CN (Site)

Author:
    RaphiR

Environment:
	Platform-independent.

--*/

#define  FORGN_EXPIRATION_MONTH  10

#pragma warning(disable: 4201)
#pragma warning(disable: 4514)
#include "_stdafx.h"

//#define INITGUID

#include <string.h>
#include <stdio.h>
#include <windows.h>
#include <assert.h>

#include "cmnquery.h"
#include "dsquery.h"

#include "mqsymbls.h"
#include "mqprops.h"
#include "mqtypes.h"
#include "mqcrypt.h"
#include "mqsec.h"
#include "_propvar.h"
#include "_rstrct.h"
#include "ds.h"
#include "_mqdef.h"
#include "rt.h"
#include "_guid.h"
#include "admcomnd.h"
#include "mqfrgnky.h"
#include "..\..\inc\version.h"

HRESULT  CreateEveryoneSD( PSECURITY_DESCRIPTOR  *ppSD ) ;

/*=================================================

              T I M E     B O M B

 ==================================================*/

#include <time.h>
void TimeBomb()
{

     //
     // Get Current time
     //
     time_t utcTime = time( NULL );

     struct tm BetaRTM =      { 0, 0, 0, 15,  2 -1, 99 };  // Feb. 15, 1999
     struct tm BetaExp =      { 0, 0, 0, 15,  FORGN_EXPIRATION_MONTH -1, 99 };  // oct 15, 1999
     struct tm Warning =      { 0, 0, 0,  1,  FORGN_EXPIRATION_MONTH -1, 99 };  // Oct  1, 1999


     time_t utcBetaRTM =   mktime(&BetaRTM);
     time_t utcBetaExp =   mktime(&BetaExp);
     time_t utcWarning =   mktime(&Warning);


     if(utcTime > utcBetaExp)
     {
		 printf("This demo program has expired\n");
		 exit(0);
     }

     else if(utcTime > utcWarning)
     {
         printf("*** Warning - This demo program will expire on Oct 15, 1999 ***\n\n");
     }

}


//-------------------------------
//
//CheckNT4Enterprise()
//
//	Check that we run in an NT4 enterprise.
//  Exit if fail.
//
//-------------------------------
void CheckNT4Enterprise()
{
    HANDLE hQuery;
    HRESULT rc;
    PROPVARIANT result[2];
    DWORD dwPropCount = 2;

    CColumns AttributeColumns;

    AttributeColumns.Add(PROPID_E_NAME);
	AttributeColumns.Add(PROPID_E_VERSION);

    rc = DSLookupBegin(0, NULL, AttributeColumns.CastToStruct(), 0, &hQuery);

    if (SUCCEEDED(rc))
    {
        rc = DSLookupNext( hQuery, &dwPropCount, result);

        if (SUCCEEDED(rc))
        {
			DWORD version = result[1].uiVal;

			if(version != 3)
			{
				printf("Error - this utility can be run only in a Windows NT4 MSMQ environment.\n");
				exit(0);
			}
        }

        DSLookupEnd(hQuery);
    }

}

//-------------------------------
//
//Usage()
//
//-------------------------------

void Usage()
{
	printf(
    "Usage:\n  mqforgn [ -crcn | -opce | -rmcn | -addcn | -crcomp | -rmcomp | -pbkey ]\n\n");
	
    printf("Arguments:\n");
	
	printf("-crcn <CN Name>\tCreate a foreign CN (connected netword)\n");
	printf("-opce <CN Name>\n\tGrant everyone the permission to open the connector queue.\n");
	printf("-rmcn <CN Name>\tRemove a foreign CN \n");
	printf("-addcn  <CompName> <CN Name>\n") ;
    printf("\tAdd a foreign CN to a computer (Routing Server or foreign computer)\n");
	printf("-delcn  <CompName> <CN Name> \tRemove the foreign CN from the computer\n");
	printf("-crcomp <CompName> <SiteName> <CN Name>\tAdd a foreign computer\n");
	printf("-rmcomp <CompName>\tRemove the foreign computer\n");
	printf("-pbkey  <Machine Name> <Key Name>\n") ;
    printf("\tInsert public key in msmqConfiguration object of a foreign machine.\n");

	printf("-? \tprint this help\n\n");

	printf("e.g., mqforgn -crcomp MyComp ThisSite ForCN\n");
	printf("Creates a foreign computer named \"MyComp\" in the site \"ThisSite\", and connected to the foreign CN \"ForCN\"\n");
	printf("...or: mqforgn -crcomp MyComp {Site-Guid} {CN-Guid}\n");
	exit(-1);
}

//-------------------------------
//
//CheckArgNo()
//	
//	Exits if wrong number of arguments
//
//-------------------------------
void CheckArgNo(DWORD argno, DWORD dwRequiredArg)
{
	if(argno != dwRequiredArg + 2)
	{
		printf("*** Error: Wrong number of arguments\n\n");
		exit(-1);
	}

}

//-------------------------------
//
//ErrorExit()
//	
//	Display a user-readable error and exit
//
//-------------------------------
void ErrorExit(char *pszErrorMsg, HRESULT hr)
{

  HINSTANCE hLib = LoadLibrary(L"MQUTIL.DLL");
    if(hLib == NULL)
    {
        exit(-1);
    }

    WCHAR * pText;
    DWORD rc;
    rc = FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE    |
                FORMAT_MESSAGE_FROM_SYSTEM     |
                FORMAT_MESSAGE_IGNORE_INSERTS  |
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_MAX_WIDTH_MASK,
                hLib,
                hr,
                0,
                reinterpret_cast<WCHAR *>(&pText),
                0,
                NULL
                );
    if(rc == 0)
    {
        printf ("Error (0x%x)\n", hr) ;
        exit(-1);
    }

    printf ("Error (0x%x): %S\n", hr, pText);
	exit(hr);
}





//-------------------------------
//
//GetSiteGuid()
//	
// Retrieve a Site Guid based on its name
//
//-------------------------------
HRESULT GetSiteGuid(LPWSTR pwszSiteName, GUID * * ppGuid)
{
	
    PROPID aProp[] = {PROPID_S_PATHNAME,
					  PROPID_S_SITEID};
					
    PROPVARIANT apVar[sizeof(aProp) / sizeof(aProp[0])];

    UINT uiPropIndex = 0;

    //
    // PROPID_S_PATHNAME
    //
    ASSERT(aProp[uiPropIndex] == PROPID_S_PATHNAME);
    apVar[uiPropIndex].vt = VT_NULL;

    uiPropIndex++;


    //
    // PROPID_S_SITEID
    //
    ASSERT(aProp[uiPropIndex] == PROPID_S_SITEID);
    apVar[uiPropIndex].vt = VT_NULL;

    uiPropIndex++;

	
	HRESULT hr = DSGetObjectProperties(MQDS_SITE, pwszSiteName, uiPropIndex,aProp,apVar);

	if(FAILED(hr))
		return(hr);



    ASSERT(aProp[1] == PROPID_S_SITEID);
	*ppGuid = apVar[1].puuid;

	return hr;


}

//-------------------------------
//
//GetCNGuid()
//	
// Retrieve a CN Foreign Guid based on its NAME
//
//-------------------------------
HRESULT GetCNGuid(LPWSTR pwszCNName, GUID * * ppGuid)
{
    PROPID aProp[] = { PROPID_CN_NAME,
					   PROPID_CN_GUID,
                       PROPID_CN_PROTOCOLID } ;

    PROPVARIANT apVar[sizeof(aProp) / sizeof(aProp[0])];

    UINT uiPropIndex = 0;

    //
    // PROPID_CN_NAME
    //
    ASSERT(aProp[uiPropIndex] == PROPID_CN_NAME);
    apVar[uiPropIndex].vt = VT_NULL;

    uiPropIndex++;

	
    //
    // PROPID_CN_GUID
    //
    ASSERT(aProp[uiPropIndex] == PROPID_CN_GUID);
    apVar[uiPropIndex].vt = VT_NULL;
    UINT uiGuidIndex = uiPropIndex ;

    uiPropIndex++;

    //
    // PROPID_CN_PROTOCOLID
    //
    ASSERT(aProp[uiPropIndex] == PROPID_CN_PROTOCOLID);
    apVar[uiPropIndex].vt = VT_NULL;
    UINT uiProtocolIdIndex = uiPropIndex ;

    uiPropIndex++;

	HRESULT hr = DSGetObjectProperties(MQDS_CN,pwszCNName, uiPropIndex,aProp,apVar);

	if (FAILED(hr))
    {
		return(hr);
    }

	//
	// Check if foreign GUID
	//
    ASSERT(aProp[ uiProtocolIdIndex ] == PROPID_CN_PROTOCOLID);
	if (apVar[ uiProtocolIdIndex ].bVal != FOREIGN_ADDRESS_TYPE)
    {
		return(MQ_ERROR_ILLEGAL_OPERATION);
    }

    ASSERT( aProp[uiGuidIndex ] == PROPID_CN_GUID);
	*ppGuid = apVar[ uiGuidIndex ].puuid;

	return hr;
}

//-------------------------------
//
//  OpenConnectorToEveryone()
//	
//-------------------------------

HRESULT OpenConnectorToEveryone( IN LPWSTR  pwszForeignCN )
{
   PSECURITY_DESCRIPTOR pSD = NULL ;

   HRESULT hr = CreateEveryoneSD( &pSD ) ;

   if (FAILED(hr))
   {
       return hr ;
   }

   hr = DSSetObjectSecurity( MQDS_CN,
                             pwszForeignCN,
                             DACL_SECURITY_INFORMATION,
                             pSD ) ;
   return hr ;
}

//-------------------------------
//
//CreateForeignCN()
//	
//-------------------------------

HRESULT CreateForeignCN( IN LPWSTR  pwszForeignCN )
{
    PROPID  aProp[] = {PROPID_CN_GUID, PROPID_CN_NAME, PROPID_CN_PROTOCOLID};

    PROPVARIANT apVar[sizeof(aProp) / sizeof(aProp[0])];

    HRESULT hr = MQ_OK;
    UINT    uiCurVar = 0;

    //
    // PROPID_CN_GUID
    //
    GUID guidInstance;
    apVar[uiCurVar].vt = VT_CLSID;
    UuidCreate(&guidInstance);
    apVar[uiCurVar++].puuid = &guidInstance;

    //
    // PROPID_CN_NAME
    //
    apVar[uiCurVar].vt = VT_LPWSTR;
    apVar[uiCurVar++].pwszVal = pwszForeignCN;

    //
    // PROPID_CN_PROTOCOLID
    //
    apVar[uiCurVar].vt = VT_UI1;
    apVar[uiCurVar++].uiVal = FOREIGN_ADDRESS_TYPE;

    hr = DSCreateObject( MQDS_CN,
                         pwszForeignCN,
                         NULL,
                         sizeof(aProp) / sizeof(aProp[0]),
                         aProp,
                         apVar,
                         NULL ) ;
    return hr;
}

//-------------------------------
//
//AddForeignCN()
//	
//-------------------------------

HRESULT AddForeignCN(LPWSTR pwszCompName, LPWSTR pwszCNName)
{
    PROPID  aProp[] = {PROPID_QM_PATHNAME, PROPID_QM_MACHINE_ID,
					   PROPID_QM_SERVICE, PROPID_QM_CNS, PROPID_QM_ADDRESS,
                       PROPID_QM_FOREIGN, PROPID_QM_OS};

    PROPVARIANT apVar[sizeof(aProp) / sizeof(aProp[0])];
	UINT uiPropIndex = 0;

    HRESULT hr = MQ_OK;

	GUID *pguidCN;

	hr = GetCNGuid(pwszCNName, &pguidCN);
	if(FAILED(hr))
		return(hr);

    //
    // PROPID_QM_PATHNAME
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_MACHINE_ID
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;


    //
    // PROPID_QM_SERVICE
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_CNS
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_ADDRESS
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_FOREIGN
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_OS
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;


	hr = DSGetObjectProperties(MQDS_MACHINE,pwszCompName, uiPropIndex,aProp,apVar);

	//
	// Check foreign machine of FRS
	//
    ASSERT(aProp[5] == PROPID_QM_FOREIGN);
	ASSERT(aProp[2] == PROPID_QM_SERVICE);
	if(apVar[5].bVal != 1 && apVar[2].ulVal < SERVICE_SRV)
		return(MQ_ERROR_ILLEGAL_OPERATION);

	//
	// Add the CN to list of existing CN
	//
    ASSERT(aProp[4] == PROPID_QM_ADDRESS);
	ASSERT(aProp[3] == PROPID_QM_CNS);

	DWORD dwCnCount = apVar[3].cauuid.cElems + 1;
	GUID  * aguidCns = new GUID[dwCnCount];

	for(DWORD i = 0; i < dwCnCount - 1; i++)
	{
		aguidCns[i] = apVar[3].cauuid.pElems[i];
	}
	aguidCns[i] = *pguidCN;

	//
	// Add address to list of existing addresses
	//
	DWORD dwAddressSize = apVar[4].blob.cbSize + (TA_ADDRESS_SIZE + FOREIGN_ADDRESS_LEN);
	BYTE * blobAddress = new BYTE[dwAddressSize];

	memcpy(blobAddress, apVar[4].blob.pBlobData, apVar[4].blob.cbSize);
	BYTE * pAddress = blobAddress + apVar[4].blob.cbSize;
    ((TA_ADDRESS *)pAddress)->AddressLength = FOREIGN_ADDRESS_LEN;
    ((TA_ADDRESS *)pAddress)->AddressType = FOREIGN_ADDRESS_TYPE;
    *(GUID *)&((TA_ADDRESS *)pAddress)->Address = *pguidCN;


	//
	// Set the new CN/Address properties
	//
    PROPID  aPropSet[] = {PROPID_QM_CNS, PROPID_QM_ADDRESS};

    PROPVARIANT apVarSet[sizeof(aPropSet) / sizeof(aPropSet[0])];
	
	uiPropIndex = 0;

    //
    // PROPID_QM_CNS
    //
    apVarSet[uiPropIndex].vt = VT_CLSID|VT_VECTOR;
    apVarSet[uiPropIndex].cauuid.cElems = dwCnCount;
    apVarSet[uiPropIndex].cauuid.pElems = aguidCns;

    uiPropIndex++;

    //
    // PROPID_QM_ADDRESS - Updated only in case of foreign,
    // and then contains the foreign CN guids.
    //
    apVarSet[uiPropIndex].vt = VT_BLOB;
    apVarSet[uiPropIndex].blob.cbSize = dwAddressSize;
    apVarSet[uiPropIndex].blob.pBlobData = blobAddress;

    uiPropIndex++;


	hr = DSSetObjectProperties(MQDS_MACHINE, pwszCompName, uiPropIndex, aPropSet,apVarSet);

    return hr;
}


//-------------------------------
//
//DelForeignCN()
//	
//-------------------------------
HRESULT DelForeignCN(LPWSTR pwszCompName, LPWSTR pwszCNName)
{
    PROPID  aProp[] = {PROPID_QM_PATHNAME, PROPID_QM_MACHINE_ID,
					   PROPID_QM_SERVICE, PROPID_QM_CNS, PROPID_QM_ADDRESS,
                       PROPID_QM_FOREIGN, PROPID_QM_OS};

    PROPVARIANT apVar[sizeof(aProp) / sizeof(aProp[0])];
	UINT uiPropIndex = 0;

    HRESULT hr = MQ_OK;

	GUID *pguidCN;

	hr = GetCNGuid(pwszCNName, &pguidCN);
	if(FAILED(hr))
		return(hr);

    //
    // PROPID_QM_PATHNAME
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_MACHINE_ID
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_SERVICE
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_CNS
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_ADDRESS
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_FOREIGN
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;

    //
    // PROPID_QM_OS
    //
    apVar[uiPropIndex].vt = VT_NULL;
    uiPropIndex++;


	hr = DSGetObjectProperties(MQDS_MACHINE,pwszCompName, uiPropIndex,aProp,apVar);

	//
	// Check foreign machine or FRS
	//
    ASSERT(aProp[5] == PROPID_QM_FOREIGN);
	ASSERT(aProp[2] == PROPID_QM_SERVICE);
	if(apVar[5].bVal != 1 && apVar[2].ulVal < SERVICE_SRV)
		return(MQ_ERROR_ILLEGAL_OPERATION);

	//
	// If last CN refuse the operation
	//
	ASSERT(aProp[3] == PROPID_QM_CNS);
	if(apVar[3].cauuid.cElems <= 1)
		return(MQ_ERROR);


	//
	// Delete the CN to list of existing CN and addresses
	//
    ASSERT(aProp[4] == PROPID_QM_ADDRESS);
	ASSERT(aProp[3] == PROPID_QM_CNS);

	GUID  * aguidCns = new GUID[apVar[3].cauuid.cElems];

	BYTE * blobAddress = new BYTE[apVar[4].blob.cbSize];
	BYTE * pSrcAddress = apVar[4].blob.pBlobData;
	BYTE * pDstAddress = blobAddress;

	for(DWORD i = 0, j = 0; i < apVar[3].cauuid.cElems; i++)
	{
		DWORD dwAddrSize = TA_ADDRESS_SIZE + ((TA_ADDRESS *)pSrcAddress)->AddressLength;

		if(apVar[3].cauuid.pElems[i] == *pguidCN)
		{
			pSrcAddress += dwAddrSize;
			continue;
		}

		aguidCns[j] = apVar[3].cauuid.pElems[i];
		j++;
	
		memcpy(pDstAddress, pSrcAddress, dwAddrSize);
		pDstAddress += dwAddrSize;
		pSrcAddress += dwAddrSize;

	}

	if(i == j)
	{
		//
		// The CN is not in the list
		//
		return(MQ_ERROR_ILLEGAL_OPERATION);
	}

	DWORD dwCnCount = j;
	DWORD dwAddressSize = pDstAddress - blobAddress;

	//
	// Set the new CN/Address properties
	//
    PROPID  aPropSet[] = {PROPID_QM_CNS, PROPID_QM_ADDRESS};

    PROPVARIANT apVarSet[sizeof(aPropSet) / sizeof(aPropSet[0])];
	
	uiPropIndex = 0;

    //
    // PROPID_QM_CNS
    //
    apVarSet[uiPropIndex].vt = VT_CLSID|VT_VECTOR;
    apVarSet[uiPropIndex].cauuid.cElems = dwCnCount;
    apVarSet[uiPropIndex].cauuid.pElems = aguidCns;

    uiPropIndex++;

    //
    // PROPID_QM_ADDRESS - Updated only in case of foreign,
    // and then contains the foreign CN guids.
    //
    apVarSet[uiPropIndex].vt = VT_BLOB;
    apVarSet[uiPropIndex].blob.cbSize = dwAddressSize;
    apVarSet[uiPropIndex].blob.pBlobData = blobAddress;

    uiPropIndex++;


	hr = DSSetObjectProperties(MQDS_MACHINE, pwszCompName, uiPropIndex, aPropSet,apVarSet);

    return hr;
}


//-------------------------------
//
//CreateForeignComputer()
//	
//-------------------------------
HRESULT CreateForeignComputer( LPWSTR pwszCompName,
                               LPWSTR pwszSiteName,
                               LPWSTR pwszCNName )
{
    PROPID  aProp[] = { PROPID_QM_PATHNAME,
                        PROPID_QM_MACHINE_ID,
                        PROPID_QM_SITE_ID,
                        PROPID_QM_SERVICE,
                        PROPID_QM_CNS,
                        PROPID_QM_ADDRESS,
                        PROPID_QM_INFRS,
                        PROPID_QM_OUTFRS,
                        PROPID_QM_FOREIGN,
                        PROPID_QM_OS };

    PROPVARIANT apVar[sizeof(aProp) / sizeof(aProp[0])];
	UINT uiPropIndex = 0;

    HRESULT hr = MQ_OK;

    WCHAR  wszGuid[ 128 ] ;
    GUID SiteGuid ;
	GUID *pguidSite;
    GUID CNGuid ;
	GUID *pguidCN;

	BYTE  Address[TA_ADDRESS_SIZE + FOREIGN_ADDRESS_LEN];

    if ((pwszSiteName[0] == L'{') && (wcslen(pwszSiteName) < 100))
    {
        wcscpy( wszGuid, &pwszSiteName[1] ) ;
        ULONG ul = wcslen(wszGuid) ;
        wszGuid[ ul-1 ] = 0 ;

        RPC_STATUS status = UuidFromString( wszGuid, &SiteGuid ) ;
        if (status != RPC_S_OK)
        {
            return HRESULT_FROM_WIN32(status) ;
        }

        pguidSite = &SiteGuid ;
    }
    else
    {
    	hr = GetSiteGuid(pwszSiteName, &pguidSite);
	    if(FAILED(hr))
		    return(hr);
    }

    if ((pwszCNName[0] == L'{') && (wcslen(pwszCNName) < 100))
    {
        wcscpy( wszGuid, &pwszCNName[1] ) ;
        ULONG ul = wcslen(wszGuid) ;
        wszGuid[ ul-1 ] = 0 ;

        RPC_STATUS status = UuidFromString( wszGuid, &CNGuid ) ;
        if (status != RPC_S_OK)
        {
            return HRESULT_FROM_WIN32(status) ;
        }

        pguidCN = &CNGuid ;
    }
    else
    {
    	hr = GetCNGuid(pwszCNName, &pguidCN);
	    if(FAILED(hr))
		    return(hr);
    }

    ((TA_ADDRESS *)Address)->AddressLength = FOREIGN_ADDRESS_LEN;
    ((TA_ADDRESS *)Address)->AddressType = FOREIGN_ADDRESS_TYPE;
    *(GUID *)&((TA_ADDRESS *)Address)->Address = *pguidCN;

    //
    // PROPID_QM_PATHNAME
    //
    apVar[uiPropIndex].vt = VT_LPWSTR;
    apVar[uiPropIndex].pwszVal = pwszCompName;

    uiPropIndex++;

    //
    // PROPID_QM_MACHINE_ID
    //
    GUID guidInstance;
    apVar[uiPropIndex].vt = VT_CLSID;
    UuidCreate(&guidInstance);
    apVar[uiPropIndex].puuid = &guidInstance;

    uiPropIndex++;

    //
    // PROPID_QM_SITE_ID
    //
    apVar[uiPropIndex].vt = VT_CLSID;
    apVar[uiPropIndex].puuid = pguidSite;

    uiPropIndex++;

    //
    // PROPID_QM_SERVICE
    //
    apVar[uiPropIndex].vt = VT_UI4;
    apVar[uiPropIndex].ulVal = SERVICE_NONE;

    uiPropIndex++;

    //
    // PROPID_QM_CNS - has value only for foreign machine
    //
    apVar[uiPropIndex].vt = VT_CLSID|VT_VECTOR;
    apVar[uiPropIndex].cauuid.cElems = 1;
    apVar[uiPropIndex].cauuid.pElems = pguidCN;

    uiPropIndex++;

    //
    // PROPID_QM_ADDRESS - Updated only in case of foreign,
    // and then contains the foreign CN guids. Update of "real" machine
    // is done only by changing the machine's properties.
    //
    apVar[uiPropIndex].vt = VT_BLOB;
    apVar[uiPropIndex].blob.cbSize = sizeof(Address);
    apVar[uiPropIndex].blob.pBlobData = &Address[0];

    uiPropIndex++;

    //
    // PROPID_QM_INFRS
    //
    apVar[uiPropIndex].vt = VT_CLSID | VT_VECTOR;
    apVar[uiPropIndex].cauuid.cElems = 0;
    apVar[uiPropIndex].cauuid.pElems = NULL;

    uiPropIndex++;

    //
    // PROPID_QM_OUTFRS
    //
    apVar[uiPropIndex].vt = VT_CLSID | VT_VECTOR;
    apVar[uiPropIndex].cauuid.cElems = 0;
    apVar[uiPropIndex].cauuid.pElems = NULL;

    uiPropIndex++;

    //
    // PROPID_QM_FOREIGN
    //
    apVar[uiPropIndex].vt = VT_UI1;
    apVar[uiPropIndex].bVal = TRUE;

    uiPropIndex++;

    //
    // PROPID_QM_OS
    //
    apVar[uiPropIndex].vt = VT_UI4;
    apVar[uiPropIndex].ulVal = MSMQ_OS_FOREIGN;

    uiPropIndex++;

    hr = DSCreateObject( MQDS_MACHINE,
                         pwszCompName,
                         0,
                         sizeof(aProp) / sizeof(aProp[0]),
                         aProp,
                         apVar,
                         NULL );

    return hr;
}

//-------------------------------
//
//DeleteForeignCN()
//	
//-------------------------------
HRESULT DeleteForeignCN(LPWSTR pwszCNName)
{
	HRESULT hr;

	hr = DSDeleteObject(MQDS_CN,pwszCNName);

	return(hr);

}


//-------------------------------
//
//DeleteForeignComputer()
//	
//-------------------------------
HRESULT DeleteForeignComputer(LPWSTR pwszSiteName)
{
	HRESULT hr;

	hr = DSDeleteObject(MQDS_MACHINE, pwszSiteName);

	return(hr);
}

//+-----------------------------------------------------
//
//  HRESULT  StorePbkeyOnForeignMachine()
//
//+-----------------------------------------------------

HRESULT  StorePbkeyOnForeignMachine( WCHAR *pwszMachineName,
                                     WCHAR *pwszKeyName )
{
    HINSTANCE hLib = LoadLibrary(TEXT("mqfrgnky.dll")) ;
    if (!hLib)
    {
        DWORD dwErr = GetLastError() ;
        return HRESULT_FROM_WIN32(dwErr) ;
    }

    MQFrgn_StorePubKeysInDS_ROUTINE pfnStore =
         (MQFrgn_StorePubKeysInDS_ROUTINE)
                        GetProcAddress(hLib, "MQFrgn_StorePubKeysInDS") ;
    if (!pfnStore)
    {
        FreeLibrary(hLib) ;
        DWORD dwErr = GetLastError() ;
        return HRESULT_FROM_WIN32(dwErr) ;
    }

    HRESULT hr = (*pfnStore) ( pwszMachineName,
                               pwszKeyName,
                               TRUE ) ;
    FreeLibrary(hLib) ;
    return hr ;
}

#define CREATE_CN	              1
#define REMOVE_CN	              2
#define	ADD_CN		              3
#define DEL_CN		              4
#define CREATE_COMP	              5
#define REMOVE_COMP	              6
#define STORE_FORGN_PBKEY         7
#define OPEN_CONNECOTR_EVERYONE   8

//-------------------------------
//
//main()
//	
//-------------------------------

void main(int argc, char * * argv)
{
    DWORD   gAction = 0;
    WCHAR   szCNName[100], szMachineName[100], szSiteName[100];
    WCHAR   wszKeyName[ 100 ] ;
    HRESULT hr = 0;
    BOOL    fCheckNt4Ver = TRUE ;

    //
    // Print Title
    //
    printf("MSMQ Foreign objects utility. Release Version, 1.0.%u\n\n", rup);

    //
    // Check Time Bomb
    //
    // TimeBomb();


   //
   // Parse parameters
   //
   for(int i=1; i < argc; i++)
   {

      if(_stricmp(argv[i], "-crcn") == 0)
      {
		 CheckArgNo(argc, 1);
         gAction = CREATE_CN;
		 i++;
	     swprintf(szCNName, L"%S", argv[i]);

         fCheckNt4Ver = FALSE ;
         continue;
      }

      if(_stricmp(argv[i], "-opce") == 0)
      {
		 CheckArgNo(argc, 1);
         gAction = OPEN_CONNECOTR_EVERYONE ;
		 i++;
	     swprintf(szCNName, L"%S", argv[i]);

         fCheckNt4Ver = FALSE ;
         continue;
      }

      if(_stricmp(argv[i], "-rmcn") == 0)
      {
		 CheckArgNo(argc, 1);
         gAction = REMOVE_CN;
		 i++;
	     swprintf(szCNName, L"%S", argv[i]);

         continue;
      }

      if(_stricmp(argv[i], "-addcn") == 0)
      {
		 CheckArgNo(argc, 2);
		 gAction = ADD_CN;
         i++;
	     swprintf(szMachineName, L"%S", argv[i]);

		 i++;
	     swprintf(szCNName, L"%S", argv[i]);

         continue;
      }

	  if(_stricmp(argv[i], "-delcn") == 0)
      {
		 CheckArgNo(argc, 2);
    	 gAction = DEL_CN;
         i++;
	     swprintf(szMachineName, L"%S", argv[i]);

		 i++;
	     swprintf(szCNName, L"%S", argv[i]);

         continue;
      }

      if(_stricmp(argv[i], "-rmcomp") == 0)
      {
		 CheckArgNo(argc, 1);
		 gAction = REMOVE_COMP;
		 i++;
	     swprintf(szMachineName, L"%S", argv[i]);
         continue;
      }

      if(_stricmp(argv[i], "-crcomp") == 0)
      {
		 CheckArgNo(argc, 3);
		 gAction = CREATE_COMP;
         i++;
	     swprintf(szMachineName, L"%S", argv[i]);

		 i++;
	     swprintf(szSiteName, L"%S", argv[i]);

		 i++;
	     swprintf(szCNName, L"%S", argv[i]);

         fCheckNt4Ver = FALSE ;
         continue;
      }

	  if(_stricmp(argv[i], "-pbkey") == 0)
      {
		 CheckArgNo(argc, 2);
    	 gAction = STORE_FORGN_PBKEY ;
         i++;
	     swprintf(szMachineName, L"%S", argv[i]);

		 i++;
	     swprintf(wszKeyName, L"%S", argv[i]);

         fCheckNt4Ver = FALSE ;
         continue;
      }

      if(_stricmp(argv[i], "-?") == 0)
      {
         Usage();
         continue;
      }

	  if(_stricmp(argv[i], "/?") == 0)
      {
         Usage();
         continue;
      }

      printf("\n*** Error - Unknown switch: %s\n\n", argv[i]);
 	  exit(-1);

   }

   if(gAction == 0)
   {
	  printf("\n*** Error - no action specified\n\n");
	  exit(-1);
   }

   //
   // Run this utility on NT4 enterprise only
   //
   if (fCheckNt4Ver)
   {
       CheckNT4Enterprise();
   }

   //
   // Perform the action according to params
   //
   switch(gAction)
   {
   case CREATE_CN:
   	   printf("Creating foreign CN %S...\n", szCNName);
	   hr = CreateForeignCN(szCNName) ;
	   break;

   case OPEN_CONNECOTR_EVERYONE:
   	   printf("Opening connector queue %S to everyone...\n", szCNName);
       hr = OpenConnectorToEveryone( szCNName ) ;
       break ;

   case REMOVE_CN:
   	   printf("Removing foreign CN %S...\n", szCNName);
	   hr = DeleteForeignCN(szCNName);
	   break;

   case ADD_CN:
	   printf("Adding foreign CN %S to computer %S....\n", szCNName, szMachineName);
	   hr = AddForeignCN(szMachineName, szCNName);
	   break;

   case DEL_CN:
	   printf("Deleting foreign CN %S from computer %S....\n", szCNName, szMachineName);
	   hr = DelForeignCN(szMachineName, szCNName);
	   break;

   case CREATE_COMP:
   	   printf("Creating foreign computer %S - Site: %S - CN: %S...\n",szMachineName,szSiteName,szCNName);
	   hr = CreateForeignComputer(szMachineName, szSiteName, szCNName);
	   break;

   case REMOVE_COMP:
   	   printf("Removing foreign computer %S...\n", szMachineName);
	   hr = DeleteForeignComputer(szMachineName);
	   break;

    case STORE_FORGN_PBKEY:
   	    printf("Storing Public Key for computer %S...\n", szMachineName) ;
        hr = StorePbkeyOnForeignMachine( szMachineName, wszKeyName ) ;
        break ;

    default:
	    Usage();
	    break;
   }


   if(FAILED(hr))
	   ErrorExit("",hr);


   printf("Done.\n");
   exit(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqfix\mqfix.cpp ===
//
// This utility eliminates packets listed in the fixes file (usually corrupted ones)
// Works with MSMQ2 only (please use mq1fix for MSMQ1)
//
// Each line of the fixes file contains 4 hexadecimal numbers: 
//      ulPacket = sequential packet slot number
//		ulByte   = # of the relevant byte on the bitmap logfile 
//		ixPacket = relevant bit # in the above byte 
//		ulOffset = actual packet location in the data file
// 
// Mq2dump produces fixes file based on failures during restore
//
// AlexDad, February 2000
//
//
 
#include <stdio.h>
#include <windows.h>
#include <process.h> 
#include <string.h> 

unsigned char Msgs[0x4000000];
unsigned char LogMaps[0x2000];

enum 
{
	SignatureCoherent = 'zerE',
	SignatureNotCoherent = 'roM',
	SignatureInvalid = 0
};

void _cdecl main(int argc, char **argv)
{
	char  szDataFile[200],			// input: P000002B.MQ		(original msg data file)
		  szLogFile[200],			// input: l000002B.MQ		(original msg log file)
		  szFixFile[200],			// input: P000002B.MQ.fix	(done by mq2dump)
		  szBadPagesFile[200];		// output:P000002B.MQ.bad	(eliminated pages) 

	//
	// Check usage and get file names
	//
	if (argc != 2)
	{
		printf("Usage: mqfix message-file-pathname\n");
		printf("Be carefull - this utility actually eliminates messages from the storage files!\n");
		exit(1);
	}
	else
	{
		strcpy(szDataFile, argv[1]);

		strcpy(szLogFile, szDataFile);
		unsigned long ul = (unsigned long)strlen(szDataFile);
		*(szLogFile + ul - 11) = 'l';

		strcpy(szBadPagesFile, szDataFile);
		strcat(szBadPagesFile, ".bad");

		strcpy(szFixFile, szDataFile);
		strcat(szFixFile, ".fix");
	}


	//
	// Open fix file for stream read
	//
	FILE *fFixes = fopen(szFixFile, "r");
	if (fFixes == NULL)
	{
		printf("Cannot open fix file %s\n", szFixFile);
		exit(1);
	}

	//
	// Open, read and close the log file
	//
	FILE *fLog = fopen(szLogFile, "rb");
	if(fLog == NULL)
	{
		printf("Cannot open log file %s\n", szLogFile);
		exit(1);
	}

	if (fread( LogMaps, 1, 0x2000, fLog ) != 0x2000)
	{
		printf("Wrong size of the log file %s\n", szLogFile);
		exit(1);
	}

	fclose(fLog);

	//
	// Make first map uncoherent
	//
	DWORD *pdw = (DWORD *)LogMaps;
	if (*pdw == SignatureCoherent)
	{
		printf("First map has been coherent, changing it to be NotCoherent\n");
		*pdw = SignatureNotCoherent;
	}
	else if (*pdw == SignatureNotCoherent)
	{
		printf("First map has been not coherent\n");
	}
	else
	{
		printf("First map contains bad coherence signature: 0x%x\n", *pdw);
		exit(1);
	}

	// Make second map uncoherent
	pdw = (DWORD *)(LogMaps+0x1000);
	if (*pdw == SignatureCoherent)
	{
		printf("Second map has been coherent, changing it to be NotCoherent\n");
		*pdw = SignatureNotCoherent;
	}
	else if (*pdw == SignatureNotCoherent)
	{
		printf("Second map has been not coherent\n");
	}
	else
	{
		printf("Second map contains bad coherence signature: 0x%x\n", *pdw);
		exit(1);
	}

	//
    // Open, read and close data file
	//
	FILE *fData = fopen(szDataFile, "rb");
	if(fData == NULL)
	{
		printf("Cannot open data file %s\n", szDataFile);
		exit(1);
	}

	if (fread( Msgs, 1, 0x400000, fData ) != 0x400000)
	{
		printf("Wrong size of the log data %s\n", szDataFile);
		exit(1);
	}

	fclose(fData);

	//
	// Open bad pages file for w
	//
	FILE *fBadPages = fopen(szBadPagesFile, "wb");
	if(fBadPages == NULL)
	{
		printf("Cannot create bad pages file %s\n", fBadPages);
		exit(1);
	}

	//
	// Apply fixes and count eliminated pages
	//
	unsigned long ulEliminatedPages = 0;
	unsigned long ulPacket, ulByte, ulBit, ulOffset;

	while(fscanf(fFixes, "%x %x %x %x", &ulPacket, &ulByte, &ulBit, &ulOffset) == 4)
	{
		// Cancel this block: clear away CBaseHeader::m_bOnDiskSignature
		// It resides at the byte # 0x25 from the packet start
		// Very unprobable that we will move it, because of backward compatibility 
		//
		// Normally kept packet has 7c there. 
		// Recovery skips all packets with other values
		//

		printf("The previous m_bOnDiskSignature signature of packet 0x%x was %x. Clearing it out.\n", 
			    ulOffset, Msgs[ulOffset+0x25]);

		Msgs[ulOffset+0x25] = 0;

		// Find the length
		pdw = (DWORD *)(Msgs + ulOffset);
		DWORD dwLen = *pdw;

		// restrict it 
		if (dwLen > 0x10000) 
		{
			dwLen=0x10000;
			printf("Packet %d had overly big length %d - truncating to 0x10000\n",  ulPacket, dwLen);
		}

		// Copy this page to the bad pages file
		if (fwrite(Msgs + ulOffset , 1, dwLen, fBadPages ) != dwLen)
		{
			printf("Cannot write bad page to %s\n", szBadPagesFile);
			exit(1);
		}

		//Count it
		ulEliminatedPages++;
	}

	// Close fix file
	fclose(fFixes);


    // Open, write back and close data file
	fData = fopen(szDataFile, "wb");
	if(fData == NULL)
	{
		printf("Cannot open data file %s\n", szDataFile);
		exit(1);
	}

	if (fwrite( Msgs, 1, 0x400000, fData ) != 0x400000)
	{
		printf("Wrong size of the log data %s\n", szDataFile);
		exit(1);
	}

	fclose(fData);


	//
	// Open, write back and close log file
	//
	fLog = fopen(szLogFile, "wb");
	if(fLog == NULL)
	{
		printf("Cannot open log file %s\n", szLogFile);
		exit(1);
	}

	if (fwrite( LogMaps, 1, 0x2000, fLog ) != 0x2000)
	{
		printf("Cannot write new fixed log file %s\n", szLogFile);
		exit(1);
	}

	fclose(fLog);

	printf("Log file is successfully fixed: %s\n",szLogFile);


	printf("Eliminated %d pages\n", ulEliminatedPages);
	fclose (fBadPages);
	printf("Eliminated packets are kept in  %s\n",szBadPagesFile);

	exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqforgn\forgnkey.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation. All rights reserved

Module Name:
    forgnkey.cpp

Abstract:
    dll that set public key in forign machine object.

Author:
    DoronJ

Environment:
	Win2k only.

--*/

#pragma warning(disable: 4201)
#pragma warning(disable: 4514)

#include "_stdafx.h"

#include <string.h>
#include <stdio.h>
#include <assert.h>

#include "cmnquery.h"
#include "dsquery.h"

#include "mqsymbls.h"
#include "mqprops.h"
#include "mqtypes.h"
#include "mqcrypt.h"
#include "mqsec.h"
#include "_propvar.h"
#include "_rstrct.h"
#include "ds.h"
#include "_mqdef.h"
#include <_mqreg.h>
#include <_mqini.h>

//+---------------------------
//
//  MySetFalconKeyValue()
//
//+---------------------------

LONG
MySetFalconKeyValue(
    LPCTSTR pszValueName,
    PDWORD  pdwType,
    const VOID * pData,
    PDWORD  pdwSize
    )
{
    ASSERT(pData != NULL);
    ASSERT(pdwSize != NULL);

    DWORD dwType = *pdwType;
    DWORD cbData = *pdwSize;
    HKEY hKey = NULL ;

    TCHAR *pszRegKey = FALCON_REG_KEY_ROOT
                       MSMQ_DEFAULT_REGISTRY
                       FALCON_REG_KEY_PARAM
                       TEXT("\\Security") ;

    LONG rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            pszRegKey,
                            0,
                            KEY_ALL_ACCESS,
                            &hKey ) ;
    if ( rc != ERROR_SUCCESS)
    {
        return rc;
    }

    rc =  RegSetValueEx( hKey,
                         pszValueName,
                         0,
                         dwType,
                         reinterpret_cast<const BYTE*>(pData),
                         cbData);
    RegCloseKey(hKey) ;
    return(rc);
}

//-------------------------------
//
// StorePbkeyOnForeignMachine()
//	
//-------------------------------

HRESULT APIENTRY
MQFrgn_StorePubKeysInDS( IN LPWSTR pwszMachineName,
                         IN LPWSTR pwszKeyName,
                         IN BOOL   fRegenerate )
{
    //
    // verify that key name is not msmq.
    // this would overwrite the key used by msmq itself.
    //
    if (wcsicmp(pwszKeyName, L"MSMQ") == 0)
    {
        return  MQ_ERROR_ILLEGAL_PROPERTY_VALUE ;
    }

    //
    // First verify that computer is indeed foreign.
    //
    PROPID      aProp[] = { PROPID_QM_FOREIGN } ;
    PROPVARIANT apVar[sizeof(aProp) / sizeof(aProp[0])] ;
	UINT uiPropIndex = 0;

    apVar[uiPropIndex].vt = VT_NULL;
    UINT  uiForeignIndex = uiPropIndex ;
    uiPropIndex++;

    HRESULT hr = DSGetObjectProperties( MQDS_MACHINE,
                                        pwszMachineName,
                                        uiPropIndex,
                                        aProp,
                                        apVar );

	if (FAILED(hr))
    {
        return hr ;
    }
    else if (apVar[ uiForeignIndex ].bVal != FOREIGN_MACHINE)
    {
		return MQ_ERROR_ILLEGAL_OPERATION ;
    }

    if (pwszKeyName[0] == 0)
    {
        printf("Using default key names %S, %S...\n",
                                     MSMQ_FORGN_BASE_DEFAULT_CONTAINER,
                                     MSMQ_FORGN_ENH_DEFAULT_CONTAINER) ;
    }
    else
    {
        DWORD dwType = REG_SZ ;
        DWORD dwKeyNameLen = 1 + wcslen(pwszKeyName) ;
        DWORD dwSize = dwKeyNameLen * sizeof(WCHAR) ;

        LONG rc = MySetFalconKeyValue( MSMQ_FORGN_BASE_VALUE_REGNAME,
                                      &dwType,
                                       pwszKeyName,
                                      &dwSize) ;
        if (rc != ERROR_SUCCESS)
        {
            return HRESULT_FROM_WIN32(rc) ;
        }

        P<WCHAR> pszEnhKeyName = new WCHAR[ dwKeyNameLen + 4 ] ;
        wcscpy(pszEnhKeyName, pwszKeyName) ;
        wcscat(pszEnhKeyName, L"_ENH") ;

        dwSize = (dwKeyNameLen + 4) * sizeof(WCHAR) ;
        rc = MySetFalconKeyValue( MSMQ_FORGN_ENH_VALUE_REGNAME,
                                 &dwType,
                                  pszEnhKeyName,
                                 &dwSize) ;
        if (rc != ERROR_SUCCESS)
        {
            return HRESULT_FROM_WIN32(rc) ;
        }

        printf("Using key names %S, %S...\n", pwszKeyName, pszEnhKeyName) ;
    }

    HINSTANCE hSecLib = LoadLibrary(TEXT("mqsec.dll")) ;
    if (!hSecLib)
    {
        DWORD dwErr = GetLastError() ;
        return (HRESULT_FROM_WIN32(dwErr)) ;
    }

    MQSec_StorePubKeysInDS_ROUTINE pfnStore =
         (MQSec_StorePubKeysInDS_ROUTINE)
                    GetProcAddress( hSecLib, "MQSec_StorePubKeysInDS") ;
    if (!pfnStore)
    {
        DWORD dwErr = GetLastError() ;
        return (HRESULT_FROM_WIN32(dwErr)) ;
    }

    hr = (*pfnStore) ( fRegenerate,
                       pwszMachineName,
                       MQDS_FOREIGN_MACHINE) ;

    FreeLibrary(hSecLib) ;

    return hr ;
}

/*====================================================

BOOL WINAPI DllMain (HMODULE hMod, DWORD dwReason, LPVOID lpvReserved)

 Initialization and cleanup when DLL is loaded, attached and detached.

=====================================================*/

BOOL WINAPI DllMain (HMODULE hMod, DWORD dwReason, LPVOID lpvReserved)
{
    switch(dwReason)
    {

    case DLL_PROCESS_ATTACH :
        break;

    case DLL_PROCESS_DETACH :
        break;

    default:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\mqforgn\forgnsec.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation. All rights reserved

Module Name:
    forgnsec.cpp

Abstract:
    Security code, for foreign objects.

Author:
    DoronJ

Environment:
	Platform-independent.

--*/

#pragma warning(disable: 4201)
#pragma warning(disable: 4514)

#include "_stdafx.h"

#include <string.h>
#include <stdio.h>
#include <assert.h>

#include "mqsymbls.h"
#include "autorel.h"

#include <wincrypt.h>
#include "mqsec.h"

//+----------------------------------------------------------------------
//
//  BOOL  CreateEveryoneSD()
//
//  Create a security descriptor that grant everyone the permisison to
//  open the connector queue.
//
//+----------------------------------------------------------------------

HRESULT  CreateEveryoneSD( PSECURITY_DESCRIPTOR  *ppSD )
{
    CAutoCloseHandle hToken;

    if (!OpenProcessToken( GetCurrentProcess(),
                           TOKEN_READ,
                           &hToken ))
    {
        return HRESULT_FROM_WIN32(GetLastError()) ;
    }

    BYTE rgbBuf[128];
    DWORD dwSize = 0;
    P<BYTE> pBuf;
    TOKEN_USER * pTokenUser = NULL;

    if (GetTokenInformation( hToken,
                             TokenUser,
                             rgbBuf,
                             sizeof(rgbBuf),
                             &dwSize))
    {
        pTokenUser = (TOKEN_USER *) rgbBuf;
    }
    else if (dwSize > sizeof(rgbBuf))
    {
        pBuf = new BYTE [dwSize];
        if (GetTokenInformation( hToken,
                                 TokenUser,
                                 (BYTE *)pBuf,
                                 dwSize,
                                 &dwSize))
        {
            pTokenUser = (TOKEN_USER *)((BYTE *)pBuf);
        }
        else
        {
            return HRESULT_FROM_WIN32(GetLastError()) ;
        }
    }
    else
    {
        return HRESULT_FROM_WIN32(GetLastError()) ;
    }

    SID *pSid = (SID*) pTokenUser->User.Sid ;
    ASSERT(IsValidSid(pSid));

    SECURITY_DESCRIPTOR  sd ;
    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);

    //
    // Initialize World (everyone) SID
    //
    PSID   pWorldSid = NULL ;
    SID_IDENTIFIER_AUTHORITY WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
    BOOL bRet = AllocateAndInitializeSid( &WorldAuth,
                                          1,
                                          SECURITY_WORLD_RID,
                                          0,
                                          0,
                                          0,
                                          0,
                                          0,
                                          0,
                                          0,
                                         &pWorldSid );
    ASSERT(bRet) ;

    DWORD dwAclRevision = ACL_REVISION ;

    DWORD dwWorldAccess = (MQSEC_CN_GENERIC_READ | MQSEC_CN_OPEN_CONNECTOR) ;
    DWORD dwOwnerAccess = MQSEC_CN_GENERIC_ALL ;

    DWORD dwAclSize = sizeof(ACL)                                +
              (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD))) +
              GetLengthSid(pWorldSid)                            +
              GetLengthSid(pSid) ;

    AP<char> DACL_buff;
    DACL_buff = new char[ dwAclSize ];
    PACL pDacl = (PACL)(char*)DACL_buff;

    InitializeAcl(pDacl, dwAclSize, dwAclRevision);

    bRet = AddAccessAllowedAce( pDacl,
                                dwAclRevision,
                                dwWorldAccess,
                                pWorldSid );
    ASSERT(bRet) ;

    bRet = AddAccessAllowedAce( pDacl,
                                dwAclRevision,
                                dwOwnerAccess,
                                pSid);
    ASSERT(bRet) ;

    //
	// dacl should not be defaulted !
    // Otherwise, calling IDirectoryObject->CreateDSObject() will ignore
    // the dacl we provide and will insert some default.
    //
    bRet = SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE);
    ASSERT(bRet);

    //
    // Convert the descriptor to a self relative format.
    //
    DWORD dwLen = 0;
    bRet = MakeSelfRelativeSD( &sd,
                                NULL,
                               &dwLen) ;

    DWORD dwErr = GetLastError() ;
    if (dwErr == ERROR_INSUFFICIENT_BUFFER)
    {
        *ppSD = (PSECURITY_DESCRIPTOR) new char[ dwLen ];
        bRet = MakeSelfRelativeSD( &sd, *ppSD, &dwLen);

        ASSERT(bRet);
        dwErr = 0 ;
        if (!bRet)
        {
            dwErr = GetLastError() ;
        }
    }

    return HRESULT_FROM_WIN32(dwErr) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\msmqadmin\msmqadmin.cpp ===
#ifndef UNICODE
#define UNICODE
#define _UNICODE
#endif

#include <mqenv.h>
#include <stdio.h>
#include <mq.h>
#include <time.h>

const char  x_purge_token[] = "purge";
const DWORD x_purge_token_len = strlen(x_purge_token);
const char  x_remote_token[] = "remote";
const DWORD x_remote_token_len = strlen(x_remote_token);
const char  x_local_token[] = "local";
const DWORD x_local_token_len = strlen(x_local_token);
const char  x_machine_token[] = "machine";
const DWORD x_machine_token_len = strlen(x_machine_token);
const char  x_queue_token[] = "queue";
const DWORD x_queue_token_len = strlen(x_queue_token);

//
//  Skip white space characters, return next non ws char
//
//  N.B. if no white space is needed uncomment next line
//
inline LPCSTR skip_ws(LPCSTR p)
{
    while(isspace(*p))
    {
        ++p;
    }

    return p;
}


void
PrintUsage(
    void
    )
{
    printf("USAGE: msmqAdmin [ %s = QueueFormatName ] or\n", x_purge_token) ;
    printf(
       "       msmqAdmin [ %s = ComputerName ] | [ %s ] | [ quit ] or\n",
                                           x_remote_token, x_local_token) ;
    printf("       msmqAdmin [ Object_Type ]\n") ;
    printf("\t <Object Type> - %s\n", x_machine_token) ;
    printf("\t               - Queue = <Queue Format Name>\n\n");
}

void
DispalyConnectionStatus(
    PROPVARIANT& propVar
    )
{
    ASSERT(propVar.vt == VT_LPWSTR);

    printf("local Machine - DS Connection status: %S\n", propVar.pwszVal);

    MQFreeMemory(propVar.pwszVal);
}

void
DispalyDSServer(
    PROPVARIANT& propVar
    )
{
    ASSERT((propVar.vt == VT_LPWSTR) || (propVar.vt == VT_NULL));

    printf("local Machine - DS Server:");
    printf("%S\n", (propVar.pwszVal ? propVar.pwszVal : L"DS Offline"));
    printf("\n");

    MQFreeMemory(propVar.pwszVal);
}

void
DisplayMsmqType(
    PROPVARIANT& propVar
    )
{
    ASSERT(propVar.vt == VT_LPWSTR);

    printf("MSMQ Type: %S\n", propVar.pwszVal);

    MQFreeMemory(propVar.pwszVal);
}


void
DisplayMachineOpenQueue(
    PROPVARIANT& propVar
    )
{
    ASSERT(propVar.vt == (VT_LPWSTR | VT_VECTOR));

    printf("local Machine - Open Queues:\n");
    printf("=================================\n");

    for (DWORD i = 0; i < propVar.calpwstr.cElems; i++)
    {
        printf("\t%S\n", propVar.calpwstr.pElems[i]);
        MQFreeMemory(propVar.calpwstr.pElems[i]);
    }
    printf("\n");
}


void
DisplayPrivateQueue(
    PROPVARIANT& propVar
    )
{
    ASSERT(propVar.vt == (VT_LPWSTR | VT_VECTOR));

    printf("Local Machine - Private Queues:\n");
    printf("====================================\n");

    for (DWORD i = 0; i < propVar.calpwstr.cElems; i++)
    {
        printf("\t%S\n", propVar.calpwstr.pElems[i]);
        MQFreeMemory(propVar.calpwstr.pElems[i]);
    }
    printf("\n");
}


void
DisplayMachineInfo(
    MQMGMTPROPS* pmqProps
    )
{
    for (DWORD i = 0; i < pmqProps->cProp; ++i)
    {
        switch (pmqProps->aPropID[i])
        {
            case PROPID_MGMT_MSMQ_ACTIVEQUEUES:
                DisplayMachineOpenQueue(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_MSMQ_DSSERVER:
                DispalyDSServer(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_MSMQ_CONNECTED:
                DispalyConnectionStatus(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_MSMQ_PRIVATEQ:
                DisplayPrivateQueue(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_MSMQ_TYPE:
                DisplayMsmqType(pmqProps->aPropVar[i]);
                break;


            default:
                ASSERT(0);
        }
    }
}

void
MachineGetInfo(
    LPCWSTR MachineName
    )
{
    QUEUEPROPID propId[10];
    MQPROPVARIANT propVar[10];
    DWORD cprop = 0;

    propId[cprop] = PROPID_MGMT_MSMQ_TYPE;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_MSMQ_ACTIVEQUEUES;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_MSMQ_DSSERVER;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_MSMQ_CONNECTED;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_MSMQ_PRIVATEQ;
    propVar[cprop].vt = VT_NULL;
    ++cprop;


    MQMGMTPROPS mqProps;

    mqProps.cProp = cprop;
    mqProps.aPropID = propId;
    mqProps.aPropVar = propVar;

    HRESULT hr;
    hr = MQMgmtGetInfo(MachineName, L"MACHINE", &mqProps);
    if (FAILED(hr))
    {
        printf("Get Machine management was failed. Error %x\n", hr);
        return;
    }

    DisplayMachineInfo(&mqProps);
}

inline
void
DisplayQueueDisplayName(
    PROPVARIANT& propVar
    )
{
    if (propVar.vt != VT_NULL)
    {
        ASSERT(propVar.vt == VT_LPWSTR);
        printf("Display Name: %S\n", propVar.pwszVal);
        MQFreeMemory(propVar.pwszVal);
    }
    else
    {
        printf ("Display Name: can't be retreived\n");
    }
}

inline
void
DisplayQueueFormatName(
    PROPVARIANT& propVar
    )
{
    if (propVar.vt != VT_NULL)
    {
        ASSERT(propVar.vt == VT_LPWSTR);
        printf("Format Name: %S\n", propVar.pwszVal);
        MQFreeMemory(propVar.pwszVal);
    }
    else
    {
        printf ("Display Name: can't be retreived\n");
    }
}

inline
void
DisplayQueueConnectionStatus(
    PROPVARIANT& propVar
    )
{
    if (propVar.vt != VT_NULL)
    {
        ASSERT(propVar.vt == VT_LPWSTR);
        printf("Connection Status: %S\n", propVar.pwszVal);
        MQFreeMemory(propVar.pwszVal);
    }
}

inline
void
DisplayQueueNextHop(
    PROPVARIANT& propVar
    )
{
    if ((propVar.vt == VT_NULL) ||
        (propVar.calpwstr.cElems == 0))
    {
        printf("There aren't any \"Next Possibles Hops\"\n");
        return ;
    }

    ASSERT(propVar.vt == (VT_LPWSTR|VT_VECTOR));
    ASSERT(propVar.calpwstr.cElems != 0);

    if (propVar.calpwstr.cElems >1)
    {
        printf("The Queue is in Wating mode. Next Possibles Hops:\n");
        for (DWORD i = 0; i < propVar.calpwstr.cElems; i++)
        {
            printf("\t%S\n", propVar.calpwstr.pElems[i]);
            MQFreeMemory(propVar.calpwstr.pElems[i]);
        }
    }
    else
    {
        printf("The Next Hope is: %S\n", propVar.calpwstr.pElems[0]);
        MQFreeMemory(propVar.calpwstr.pElems[0]);
    }

    MQFreeMemory(propVar.calpwstr.pElems);
}

inline
void
DisplayQueueType(
    PROPVARIANT& propVar
    )
{
    ASSERT(propVar.vt == VT_LPWSTR);

    printf("Queue Type: %S\n", propVar.pwszVal);
    MQFreeMemory(propVar.pwszVal);
}

inline
void
DisplayQueueLocation(
    PROPVARIANT& propVar
    )
{
    ASSERT(propVar.vt == VT_LPWSTR);

    printf("Queue Location: %S\n", propVar.pwszVal);
    MQFreeMemory(propVar.pwszVal);
}


inline
void
DisplayReadCount(
    PROPVARIANT& propVar
    )
{
    if (propVar.vt == VT_NULL)
        return;

    ASSERT(propVar.vt == VT_UI4);
    printf("Exectly One Delivery, Number of messages that already acked but don't read : %d\n", propVar.ulVal);
}

inline
void
DisplayNoAckedCount(
    PROPVARIANT& propVar
    )
{
    if ( propVar.vt == VT_NULL)
        return;

    ASSERT(propVar.vt == VT_UI4);
    printf("Exectly One Delivery, Number of messages that sent but don't acked : %d\n", propVar.ulVal);
}

inline
void
DisplayQueueMessageCount(
    PROPVARIANT& propVar
    )
{
    ASSERT(propVar.vt != VT_NULL);
    ASSERT(propVar.vt == VT_UI4);

    printf("Queue Message Count: %d\n", propVar.ulVal);
}

inline
void
DisplayQueueUsedQuota(
    PROPVARIANT& propVar
    )
{
    ASSERT(propVar.vt != VT_NULL);
    ASSERT(propVar.vt == VT_UI4);

    ASSERT(propVar.vt == VT_UI4);
    printf("Queue Used Quota: %d\n", propVar.ulVal);
}

inline
void
DisplayJournalQueueMessageCount(
    PROPVARIANT& propVar
    )
{
    ASSERT(propVar.vt != VT_NULL);
    ASSERT(propVar.vt == VT_UI4);

    printf("Journal Queue Message Count: %d\n", propVar.ulVal);
}

inline
void
DisplayJournalQueueUsedQuota(
    PROPVARIANT& propVar
    )
{
    ASSERT(propVar.vt != VT_NULL);
    ASSERT(propVar.vt == VT_UI4);

    ASSERT(propVar.vt == VT_UI4);
    printf("Journal Queue Used Quota: %d\n", propVar.ulVal);
}

inline
void
DisplayQueueXact(
    PROPVARIANT& propVar
    )
{
    if ( propVar.vt == VT_NULL)
        return;

    ASSERT(propVar.vt == VT_LPWSTR);

    printf("XACT Queue: %S\n", propVar.pwszVal);
    MQFreeMemory(propVar.pwszVal);
}

inline
void
DisplayQueueForeign(
    PROPVARIANT& propVar
    )
{
    ASSERT(propVar.vt == VT_LPWSTR);

    printf("Foreign Queue: %S\n", propVar.pwszVal);
    MQFreeMemory(propVar.pwszVal);
}

void
DisplaySequence(
    PROPVARIANT& propVar,
    LPCSTR Title
    )
{
    if (propVar.vt == VT_NULL)
    {
        return;
    }

    ASSERT(propVar.blob.cbSize == sizeof(SEQUENCE_INFO));
    SEQUENCE_INFO* SeqInfo;
    SeqInfo = reinterpret_cast<SEQUENCE_INFO*>(propVar.blob.pBlobData);

    printf("%s:\n\tSequence ID = %I64d\n\tSequence Number %d\n\tPrevious Sequence Number %d\n",
                Title, SeqInfo->SeqID, SeqInfo->SeqNo, SeqInfo->PrevNo
           );

    MQFreeMemory(propVar.blob.pBlobData);
}

void
DisplayLastAckedTime(
    PROPVARIANT& propVar
    )
{
    if ( propVar.vt == VT_NULL)
        return;

    ASSERT(propVar.vt == VT_I4);

    time_t AckTime = propVar.lVal;
    printf("Exectly One Delivery: Last Acknowledge time - %s\n", ctime(&AckTime));
}

void
DisplayResendInterval(
    PROPVARIANT& propVar
    )
{
    if ( propVar.vt == VT_NULL)
        return;

    ASSERT(propVar.vt == VT_UI4);
    printf("Exectly One Delivery: Resend Interval - %d\n", propVar.ulVal);
}


void
DisplayResendIndex(
    PROPVARIANT& propVar
    )
{
    if ( propVar.vt == VT_NULL)
        return;

    ASSERT(propVar.vt == VT_UI4);
    printf("Exectly One Delivery: Resend Index - %d\n", propVar.ulVal);
}


void
DisplayEDOSourceInfo(
    PROPVARIANT& propVar
    )
{
    if (propVar.vt == VT_NULL)
        return;

    ASSERT(propVar.vt == (VT_VECTOR | VT_VARIANT));
    ASSERT(propVar.capropvar.cElems == 6);

    DWORD size = propVar.capropvar.pElems[0].calpwstr.cElems;
    LPWSTR* pSendQueueFormatName = propVar.capropvar.pElems[0].calpwstr.pElems;

    ASSERT(propVar.capropvar.pElems[1].cauuid.cElems == size);
    GUID* pSenderId = propVar.capropvar.pElems[1].cauuid.pElems;

    ASSERT(propVar.capropvar.pElems[2].cauh.cElems == size);
    ULARGE_INTEGER* pSeqId = propVar.capropvar.pElems[2].cauh.pElems;

    ASSERT(propVar.capropvar.pElems[3].caul.cElems == size);
    DWORD* pSeqN = propVar.capropvar.pElems[3].caul.pElems;

    ASSERT(propVar.capropvar.pElems[4].cal.cElems == size);
    time_t* pLastActiveTime = propVar.capropvar.pElems[4].cal.pElems;

    ASSERT(propVar.capropvar.pElems[5].cal.cElems == size);
    DWORD* pRejectCount = propVar.capropvar.pElems[5].caul.pElems;

    printf("Exectly One Delivery - Source Queue Information\n");
    printf("================================================\n");

    for (DWORD i = 0; i < size; ++i)
    {
        LPWSTR GuidString;
        UuidToString(&pSenderId[i], &GuidString);
        printf("Sender QM ID: %S\n", GuidString);
        RpcStringFree(&GuidString);

        printf("Sender Sequence: Sequence Id = %I64d, Sequence Number = %d\n",
                   pSeqId[i].QuadPart, pSeqN[i]);

        printf("Last Access Time: %s", ctime(&pLastActiveTime[i]));
        printf("Reject Count: %d\n", pRejectCount[i]);
        printf("Sending Queue Format Name: %S\n\n", pSendQueueFormatName[i]);

        MQFreeMemory(pSendQueueFormatName[i]);
    }

    MQFreeMemory(pSendQueueFormatName);
    MQFreeMemory(pSenderId);
    MQFreeMemory(pSeqId);
    MQFreeMemory(pSeqN);
    MQFreeMemory(pLastActiveTime);
    MQFreeMemory(pRejectCount);
    MQFreeMemory(propVar.capropvar.pElems);
}

void
DisplayNextResendTime(
    PROPVARIANT& propVar
    )
{
    if (propVar.vt == VT_NULL)
        return;

    ASSERT(propVar.vt == VT_I4);
    time_t ResendTime = propVar.lVal;

    printf("Exectly One Delivery: Next resend time - ");
    if (ResendTime == 0)
    {
        printf("Resend wasn't schedule\n");
        return;
    }

    printf("%s\n", ctime(&ResendTime));
}

void
DisplayQueueInfo(
    MQMGMTPROPS* pmqProps
    )
{
    for (DWORD i = 0; i < pmqProps->cProp; ++i)
    {
        switch (pmqProps->aPropID[i])
        {
            case PROPID_MGMT_QUEUE_PATHNAME:
                DisplayQueueDisplayName(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_FORMATNAME:
                DisplayQueueFormatName(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_TYPE:
                DisplayQueueType(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_LOCATION:
                DisplayQueueLocation(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_XACT:
                DisplayQueueXact(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_FOREIGN:
                DisplayQueueForeign(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_STATE:
                DisplayQueueConnectionStatus(pmqProps->aPropVar[i]);
                break;


            case PROPID_MGMT_QUEUE_NEXTHOPS:
                DisplayQueueNextHop(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_MESSAGE_COUNT:
                DisplayQueueMessageCount(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_USED_QUOTA:
                DisplayQueueUsedQuota(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT:
                DisplayJournalQueueMessageCount(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA:
                DisplayJournalQueueUsedQuota(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_EOD_NEXT_SEQ:
                DisplaySequence(
                    pmqProps->aPropVar[i],
                    "Exectly One Delivery, Next Squence"
                    );
                break;

            case PROPID_MGMT_QUEUE_EOD_LAST_ACK:
                DisplaySequence(
                    pmqProps->aPropVar[i],
                    "Exectly One Delivery, Last Acked Squence"
                    );
                break;

            case PROPID_MGMT_QUEUE_EOD_FIRST_NON_ACK:
                DisplaySequence(
                    pmqProps->aPropVar[i],
                    "Exectly One Delivery, First non acknowledged"
                    );
                break;

            case PROPID_MGMT_QUEUE_EOD_LAST_NON_ACK:
                DisplaySequence(
                    pmqProps->aPropVar[i],
                    "Exectly One Delivery, Last non acknowledged"
                    );
                break;

            case PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT:
                DisplayReadCount(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT:
                DisplayNoAckedCount(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_EOD_LAST_ACK_TIME:
                 DisplayLastAckedTime(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_EOD_RESEND_TIME:
                 DisplayNextResendTime(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_EOD_RESEND_INTERVAL:
                 DisplayResendInterval(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_EOD_RESEND_COUNT:
                 DisplayResendIndex(pmqProps->aPropVar[i]);
                break;

            case PROPID_MGMT_QUEUE_EOD_SOURCE_INFO:
                  DisplayEDOSourceInfo(pmqProps->aPropVar[i]);
                  break;

            default:
                ASSERT(0);
        }
    }
}

void
QueueGetInfo(
    LPCWSTR MachineName,
    LPCWSTR ObjectType
    )
{
    QUEUEPROPID propId[30];
    MQPROPVARIANT propVar[30];
    HRESULT propStatus[30];
    DWORD cprop = 0;

    propId[cprop] = PROPID_MGMT_QUEUE_PATHNAME;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_FORMATNAME;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_TYPE;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_LOCATION;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_XACT;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_FOREIGN;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_STATE;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_NEXTHOPS;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_MESSAGE_COUNT;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_USED_QUOTA;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_EOD_LAST_ACK;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_EOD_FIRST_NON_ACK;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_EOD_LAST_NON_ACK;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_EOD_NEXT_SEQ;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_EOD_LAST_ACK_TIME;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_EOD_RESEND_TIME;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_EOD_RESEND_INTERVAL;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_EOD_RESEND_COUNT;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    propId[cprop] = PROPID_MGMT_QUEUE_EOD_SOURCE_INFO;
    propVar[cprop].vt = VT_NULL;
    ++cprop;

    MQMGMTPROPS mqProps;

    mqProps.cProp = cprop;
    mqProps.aPropID = propId;
    mqProps.aPropVar = propVar;
    mqProps.aStatus = propStatus;

    HRESULT hr = MQMgmtGetInfo(MachineName, ObjectType, &mqProps);

    if (FAILED(hr))
    {
        printf("ERROR: can't find Internal Queue Information. Maybe the queue already closed (%lxh)\n", hr);
        printf("ObjectType: %S\n", ObjectType) ;
        return;
    }

    DisplayQueueInfo(&mqProps);
}

LPWSTR  g_pwszRemoteMachine = NULL;
WCHAR   g_wszMachineName[256] = {0};

void
ParseCmdLine(
    PCHAR cmdLine
    )
{
    LPCSTR tempBuffer;
    tempBuffer = skip_ws(cmdLine);

    for(;;)
    {
        if (strnicmp(tempBuffer, x_machine_token, x_machine_token_len) == 0)
        {
            tempBuffer = skip_ws(tempBuffer + x_machine_token_len);
            MachineGetInfo(g_pwszRemoteMachine);
            return;
        }

        if (strnicmp(tempBuffer, x_queue_token, x_queue_token_len) == 0)
        {
            tempBuffer = skip_ws(tempBuffer + x_queue_token_len);
            if (*tempBuffer != '=')
            {
                PrintUsage();
                return;
            }
            tempBuffer = skip_ws(tempBuffer + 1);

            WCHAR ObjectType[256];
            swprintf(ObjectType, L"QUEUE=%S", tempBuffer);

            QueueGetInfo(g_pwszRemoteMachine, ObjectType);
            return;
        }

        if (strnicmp(tempBuffer, x_purge_token, x_purge_token_len) == 0)
        {
            tempBuffer = skip_ws(tempBuffer + x_purge_token_len);
            if (*tempBuffer != '=')
            {
                PrintUsage();
                return;
            }
            tempBuffer = skip_ws(tempBuffer + 1);

            WCHAR wszQueueName[256];
            swprintf(wszQueueName, L"%S", tempBuffer);

            HANDLE  hQueue = NULL ;
            DWORD dwAccess ;
            if (g_pwszRemoteMachine == NULL)
            {
                //
                // Local case. Purge local queues, including outgoing ones.
                //
                dwAccess =  MQ_RECEIVE_ACCESS | MQ_ADMIN_ACCESS ;
            }
            else
            {
                dwAccess =  MQ_RECEIVE_ACCESS;
            }

            HRESULT rc =  MQOpenQueue( wszQueueName,
                                       dwAccess,
                                       0,
                                      &hQueue );
            if (FAILED(rc))
            {
                printf("Error- Can't open queue %S for purge, hr- %lxh\n",
                                             wszQueueName, rc) ;
                return ;
            }

            rc = MQPurgeQueue(hQueue);
            if (FAILED(rc))
            {
                printf("Error- Failed to purge, hr- %lxh\n", rc) ;
            }
            else
            {
                printf("Queue %S purged successfully\n", wszQueueName) ;
            }
            MQCloseQueue(hQueue) ;

            return;
        }

        if (strnicmp(tempBuffer, x_remote_token, x_remote_token_len) == 0)
        {
            tempBuffer = skip_ws(tempBuffer + x_remote_token_len);
            if (*tempBuffer != '=')
            {
                PrintUsage();
                return;
            }
            tempBuffer = skip_ws(tempBuffer + 1);

            swprintf(g_wszMachineName, L"%S", tempBuffer);
            g_pwszRemoteMachine = g_wszMachineName;

            return ;
        }

        if (strnicmp(tempBuffer, x_local_token, x_local_token_len) == 0)
        {
            tempBuffer = skip_ws(tempBuffer + x_machine_token_len);
            g_pwszRemoteMachine = NULL ;
            return;
        }

        break ;
    }

    PrintUsage();
}


void _cdecl  main(int argv, char* argc[])
{
    char cmdLine[256];

    if (argv == 2)
    {
        printf("command- %s\n", argc[1]) ;
        ParseCmdLine(argc[1]);
        return;
    }

    for (;;)
    {
        if (g_pwszRemoteMachine)
        {
            printf("MSMQ Admin (on %S) >>", g_pwszRemoteMachine) ;
        }
        else
        {
            printf("MSMQ Admin (local) >>");
        }
        gets(cmdLine);

        if (strnicmp(cmdLine, "quit", strlen("quit")) == 0)
        {
            break;
        }

        ParseCmdLine(cmdLine);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\nmparser\attachfalcon.h ===
#ifndef _ATTACHFALCON_
	#define _ATTACHFALCON_
#endif

BOOL WINAPIV AttachBaseHeader(CFrame *pf, CMessage *pm);
BOOL WINAPIV AttachInternalHeader(CFrame *pf, CMessage *pm);
BOOL WINAPIV AttachUserHeader(CFrame *pf, CMessage *pm);
BOOL WINAPIV AttachSecurityHeader(CFrame *pf, CMessage *pm);
BOOL WINAPIV AttachPropertyHeader(CFrame *pf, CMessage *pm);
BOOL WINAPIV AttachXactHeader(CFrame *pf, CMessage *pm);
BOOL WINAPIV AttachSessionHeader(CFrame *pf, CMessage *pm);
BOOL WINAPIV AttachDebugHeader(CFrame *pf, CMessage *pm);
BOOL WINAPIV AttachCPSection(CFrame *pf, CMessage *pm);
BOOL WINAPIV AttachECSection(CFrame *pf, CMessage *pm);
BOOL WINAPIV AttachServerDiscovery(CFrame *pf, CMessage *pm);
VOID WINAPIV AttachServerPing(HFRAME hFrame, LPBYTE packet_pos,	DWORD BytesLeft, bool IsRequest);
VOID WINAPIV format_server_discovery(LPPROPERTYINST lpPropertyInst);
VOID WINAPIV format_falcon_summary(LPPROPERTYINST lpPropertyInst);
VOID WINAPIV format_falcon_summary_mult(LPPROPERTYINST lpPropertyInst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\nmparser\attachfalcon.cpp ===
#include "stdafx.h"
#include "nmmsmq.h"
#include "falconDB.h"

#ifndef _UTILITIES_
	#include "utilities.h"
#endif

/* Falcon headers */
#define private public
	#include <ph.h>
	#include <phintr.h>
	#include <mqformat.h>
#undef private
	//#include <topolpkt.h> bugbug - Error compiling qmutil.h(49) : error C2504: 'CList' : base class undefined - using private struct for now


#ifndef _TRACKER_
	#include "tracker.h"
#endif

#define ALIGNUP4(x) ((((ULONG)(x))+3) & ~3)

//
// bugbug - Workaround - these definitions were taken from xactout.h.
//			try to include the file, but compile errors resulted.
//
//#include <xactout.h>
#define ORDER_ACK_TITLE       (L"QM Ordering Ack")

#pragma pack(push, 1)
typedef struct {
    LARGE_INTEGER  m_liSeqID;
    ULONG     m_ulSeqN;
    ULONG     m_ulPrevSeqN;
    OBJECTID  MessageID;
} MyOrderAckData;
#pragma pack(pop)

extern USHORT g_uMasterIndentLevel;
/*
 * This fucntions is a duplicate of CUserHeader::QueueSize.
 * It is here Becase CUserHeader::QueueSize is private.
 * bugbug - remove this and link to internal library
 */
int QueueSize(ULONG qt, const UCHAR* pQueue)
{
    if(qt < qtSourceQM)
    {
        return 0;
    }

    if(qt < qtGUID)
    {
        return sizeof(ULONG);
    }

    if(qt == qtGUID)
    {
        return sizeof(GUID);
    }

    if (qt == qtPrivate)
    {
        return (sizeof(GUID) + sizeof(ULONG));
    }

    if (qt == qtDirect)
    {
        return ALIGNUP4(*(PUSHORT)pQueue + sizeof(USHORT));
    }

    return 0;
}


BOOL 
WINAPIV 
AttachBaseHeader(CFrame *pf, CMessage *pm) 
{
/************************************************************

  Routine Description:
	Parses the fields of the MSMQ Base header.
	This header precedes all MSMQ internal and user packets

  Arguments:
	pf, pm - point to objects which contains info
	about the state of the parse for the current frame and 
	current message, respectively.

  Return Value:
	Return TRUE if the last property in the header was parsed 
	successfully. Otherwise, return FALSE.

  Notes:
	Assumption: It is assumed this header is not fragmented.

************************************************************/

	#ifdef DEBUG 
		OutputDebugString(L"   AttachBaseHeader ... ");
	#endif
	CBaseHeader UNALIGNED *bh = (CBaseHeader*) pf->packet_pos;
	//
	// Test for Base Header
	//
	if ((bh->GetVersion() == FALCON_PACKET_VERSION) && (bh->SignatureIsValid())) 
	{
		//
		// Generate and attach the header summary property
		//
		char szSummary[MAX_SUMMARY_LENGTH];
		char szTemp[MAX_SUMMARY_LENGTH];
		int iSummaryLength;

		if (bh->GetType() == FALCON_USER_PACKET)
		{
			sprintf(szSummary, "User, ");
		}
		else
		{
			sprintf(szSummary, "Internal, ");
		}

		sprintf(szTemp, "%lu bytes, ", bh->GetPacketSize());
		strcat(szSummary, szTemp);
		
		sprintf(szTemp, "Priority %hu", bh->GetPriority());
		strcat(szSummary, szTemp);
		
		if (bh->GetTraced())
		{
			sprintf(szTemp, ", Traced");
			strcat(szSummary, szTemp);
		}
		strcat(szSummary, "\0"); //pad an extra null

		iSummaryLength = strlen(szSummary);
		DWORD dwHighlightBytes = sizeof(CBaseHeader);
		AttachSummary(pf->hFrame, pf->packet_pos, db_bh_root, szSummary, dwHighlightBytes);

		//
		// Attach the fields of the header
		//
		AttachPropertySequence(pf->hFrame, pf->packet_pos, db_bh_desc, db_bh_abs_ttq);

		//
		// Clean up
		//
		pf->Accrue(sizeof(CBaseHeader));		
		pm->Accrue(sizeof(CBaseHeader));		
		pm->SetCurrentEnum(uIncrementEnum(db_bh_abs_ttq));
		pm->pbh = bh;
	}
	else 
	{
		AttachAsUnparsable(pf->hFrame, pf->packet_pos, pf->dwBytesLeft);
		pf->dwBytesLeft=0;
	}
	#ifdef DEBUG 
		OutputDebugString(L"   Exiting AttachBaseHeader. \n");
	#endif

	return(pm->uGetCurrentEnum() > db_bh_abs_ttq); 
}//AttachBaseHeader

BOOL 
WINAPIV 
AttachInternalHeader(CFrame *pf, CMessage *pm) 
{
/************************************************************

  Routine Description:
	Parses the fields of the MSMQ Internal header.
	This header precedes all MSMQ internal packets

  Arguments:
	pf, pm - point to objects which contains info
	about the state of the parse for the current frame and 
	current message, respectively.

  Return Value:
	Return TRUE if the last property in the header was parsed 
	successfully. Otherwise, return FALSE.

  Notes:
	Assumption: It is assumed this header is not fragmented.

************************************************************/

	#ifdef DEBUG 
		OutputDebugString(L"   AttachInternalHeader ... ");
	#endif

	CInternalSection *pis = (CInternalSection *)pf->packet_pos;
	char szSummary[MAX_SUMMARY_LENGTH];
	char szTemp[MAX_SUMMARY_LENGTH];
	int iSummaryLength;

	//
	// Generate and attach the header summary property
	//
	switch(pis->GetPacketType()) 
	{
		case 1: 
			sprintf(szSummary, "Session Packet");
			break;
		case 2:
			sprintf(szSummary, "Establish Connection Packet");
			break;
		case 3:
			sprintf(szSummary, "Connection Parameters Packet");
			break;
		default:
			sprintf(szSummary, "Unknown");
	};

	sprintf(szTemp, "%s", pis->GetRefuseConnectionFlag() ? ", Connection refused" : "\0");
	strcat(szSummary, szTemp);
	strcat(szSummary, "\0"); //pad an extra null to make NetMon happy
	iSummaryLength = strlen(szSummary);
	DWORD dwHighlightBytes = sizeof(CInternalSection);
	AttachSummary(pf->hFrame, pf->packet_pos, db_ih_root, szSummary, dwHighlightBytes);

	//
	// Attach the fields of the header
	//
	AttachPropertySequence( pf->hFrame, pf->packet_pos, db_ih_desc, db_ih_flags_connection);

	//
	// Clean up
	//
	pf->Accrue(sizeof(CInternalSection));		
	pm->Accrue(sizeof(CInternalSection));		

	pm->SetCurrentEnum(uIncrementEnum(db_ih_flags_connection));

	#ifdef DEBUG 
		OutputDebugString(L"   Exiting AttachInternalHeader. \n");
	#endif
	
	return(TRUE); 
} //AttachInternalHeader

BOOL 
WINAPIV 
AttachECSection(CFrame *pf, CMessage *pm) 
{
/************************************************************

  Routine Description:
	Parses the fields of the MSMQ Establish Connection header
	of the internal session establishment packet.

  Arguments:
	pf, pm - point to objects which contains info
	about the state of the parse for the current frame and 
	current message, respectively.

  Return Value:
	Return TRUE if the last property in the header was parsed 
	successfully. Otherwise, return FALSE.

  Notes:
	Assumption: It is assumed this header is not fragmented.

************************************************************/

	#ifdef DEBUG 
		OutputDebugString(L"   AttachECSection ... ");
	#endif

	CECSection *pec = (CECSection *)pf->packet_pos;
	char szSummary[MAX_SUMMARY_LENGTH];
	char szTemp[MAX_SUMMARY_LENGTH];
	int iSummaryLength;
	DWORD dwVer;

	//
	// Generate and attach the header summary property
	//
	if(pec->IsOtherSideServer())
		sprintf(szSummary, "As MSMQ Server");
	else
		sprintf(szSummary, "As Independent Client");

	dwVer = pec->GetVersion();
	switch(dwVer) 
	{
	case 16:
		sprintf(szTemp, " v1.0");
		break;
	default:
		sprintf(szTemp, " v???");
	}
	strcat(szSummary, szTemp);
	strcat(szSummary, "\0"); //pad an extra null to make Netmon happy
	iSummaryLength = strlen(szSummary);
	DWORD dwHighlightBytes = sizeof(CECSection);
	AttachSummary(pf->hFrame, pf->packet_pos, db_ce_root, szSummary, dwHighlightBytes);

	//
	// Attach the fields of the header
	//
	AttachPropertySequence( pf->hFrame, pf->packet_pos, db_ce_desc, db_ce_body);

	//
	// Clean up
	//
	pf->Accrue(sizeof(CECSection));		
	pm->Accrue(sizeof(CECSection));		

	pm->SetCurrentEnum(uIncrementEnum(db_ce_body));
	#ifdef DEBUG 
		OutputDebugString(L"   Exiting AttachECSection. \n");
	#endif
	
	return(TRUE); 
} //AttachECSection

BOOL 
WINAPIV 
AttachCPSection(CFrame *pf, CMessage *pm) 
{
/************************************************************

  Routine Description:
	Parses the fields of the MSMQ Connection Parameters header
	of the internal session establishment packet.

  Arguments:
	pf, pm - point to objects which contains info
	about the state of the parse for the current frame and 
	current message, respectively.

  Return Value:
	Return TRUE if the last property in the header was parsed 
	successfully. Otherwise, return FALSE.

  Notes:
	Assumption: It is assumed this header is not fragmented.

************************************************************/

	#ifdef DEBUG 
		OutputDebugString(L"   AttachCPSection ... ");
	#endif

	CCPSection *pcp = (CCPSection *)pf->packet_pos;
	char szSummary[MAX_SUMMARY_LENGTH];
	char szTemp[20];
	int iSummaryLength;

	//
	// Generate and attach the header summary property
	//
	sprintf(szSummary, "Ack T/O = %ld, ", pcp->GetAckTimeout());
	sprintf(szTemp, "P-Ack T/O = %ld, ", pcp->GetRecoverAckTimeout());
	strcat(szSummary, szTemp);
	sprintf(szTemp, "Window = %hd", pcp->GetWindowSize());
	strcat(szSummary, szTemp);
	strcat(szSummary, "\0"); //pad an extra null to make Netmon happy
	iSummaryLength = strlen(szSummary);
	DWORD dwHighlightBytes=sizeof(CCPSection);
	AttachSummary(pf->hFrame, pf->packet_pos, db_cp_root, szSummary, dwHighlightBytes);

	//
	// Attach the fields of the header
	//
	AttachPropertySequence( pf->hFrame, pf->packet_pos, db_cp_desc, db_cp_window_size);

	//
	// Clean up
	//
	pf->Accrue(sizeof(CCPSection));		
	pm->Accrue(sizeof(CCPSection));		
	pm->SetCurrentEnum(uIncrementEnum(db_cp_window_size));  //set enum cursor manually since there was only one increment, but a sequence accrued.

	#ifdef DEBUG 
		OutputDebugString(L"   Exiting AttachCPSection. \n");
	#endif
	
	return(TRUE); 
} //AttachCPSection

BOOL 
WINAPIV 
AttachUserHeader(CFrame *pf, CMessage *pm) 
{
/************************************************************

  Routine Description:
	Parses the fields of the MSMQ User header
	of an MSMQ user message packet.

  Arguments:
	pf, pm - point to objects which contains info
	about the state of the parse for the current frame and 
	current message, respectively.

  Return Value:
	Return TRUE if the last property in the header was parsed 
	successfully. Otherwise, return FALSE.

  Notes:

************************************************************/

	#ifdef DEBUG 
		OutputDebugString(L"   AttachUserHeader ... ");
	#endif

	// 
	// The while test assures there are enough bytes left 
	// for the next statically sized field to be parsed
	// Some fields are not statically sized. These fields enter the 
	// loop as size zero and are sized as special cases in the switch
	//
	enum eMQPacketField uThisEnum = pm->uGetCurrentEnum();
	UINT uEnumSize = uGetFieldSize(uThisEnum);
	char szSummary[MAX_SUMMARY_LENGTH];
	DWORD dwHighlightBytes = 0;
	while (uThisEnum <= db_uh_rqt_desc && pf->dwBytesLeft >= uEnumSize) 
	{ 
		switch (uThisEnum) 
		{
		case db_uh_summary: 
			{
				//
				// Generate and attach the header summary property
				// Abort parsing if the header is fragmented
				//
				if (pf->dwBytesLeft >= sizeof(CUserHeader))
				{
					dwHighlightBytes = pm->puh->GetNextSection() - (PCHAR)(pm->puh);
					char szTemp[MAX_SUMMARY_LENGTH];
					UCHAR ucDelivery = pm->puh->GetDelivery();
					switch (ucDelivery)
					{
					case MQMSG_DELIVERY_EXPRESS:
						sprintf(szSummary, "Express");
						break;
					case MQMSG_DELIVERY_RECOVERABLE:
						sprintf(szSummary, "Recoverable");
						break;
					default:
						sprintf(szSummary, " Delivery Unparsable");
						break;
					}
					QUEUE_FORMAT qf;
					pm->puh->GetDestinationQueue(&qf);
					wchar_t wcs_formatname[MAX_SUMMARY_LENGTH];
					ULONG ulFormatNameLength = sizeof(wcs_formatname);
					MQpQueueFormatToFormatName(&qf, wcs_formatname, ulFormatNameLength, &ulFormatNameLength, true);//bugbug adding true for new parm - don't know what it does
					sprintf(szTemp, ", Dest Format Name: %S", wcs_formatname);
					strcat(szSummary, szTemp);
					AttachSummary(pf->hFrame, pf->packet_pos, db_uh_summary, szSummary, dwHighlightBytes);
				}
				else
				{
					dwHighlightBytes = pf->dwBytesLeft;
					AttachAsUnparsable(pf->hFrame, pf->packet_pos, pf->dwBytesLeft);
				}
			}
		 	break;
		case db_uh_destination_qm:
			{
				AttachField(pf->hFrame, pf->packet_pos, uThisEnum);  
				break;
			}
		case db_uh_desc:
			{
				sprintf(szSummary, "--- User Header ---");
				AttachSummary(pf->hFrame, pf->packet_pos, db_uh_desc, szSummary, dwHighlightBytes);
				break;
			}
		case db_uh_dqt_desc: 
			{
				uEnumSize = QueueSize(((CUserHeader *)pm->puh)->m_bfDQT, (const UCHAR*)pf->packet_pos);
				QUEUE_FORMAT qf;
				pm->puh->GetDestinationQueue(&qf);	
				if (qf.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN) 
				{
					AttachPropertyInstanceEx(pf->hFrame,
						falcon_database[db_uh_dqt_desc].hProperty,
						uEnumSize,
						(void*)pf->packet_pos,
						sizeof(qf),
						(void*)&qf,
						0, INDENT_LEVEL_2 + g_uMasterIndentLevel, 0);
				}
			}
			break;
		case db_uh_aqt_desc: 
			{
				uEnumSize = QueueSize(((CUserHeader *)pm->puh)->m_bfAQT, (const UCHAR*)pf->packet_pos);
				QUEUE_FORMAT qf;
				pm->puh->GetAdminQueue(&qf);	
				if (qf.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN) 
				{
					AttachPropertyInstanceEx(pf->hFrame,
						falcon_database[db_uh_aqt_desc].hProperty,
						uEnumSize,
						(void*)pf->packet_pos,
						sizeof(qf),
						(void*)&qf,
						0, INDENT_LEVEL_2 + g_uMasterIndentLevel, 0);
				}
			}
			break;
		case db_uh_rqt_desc: 
			{
				uEnumSize = QueueSize(((CUserHeader *)pm->puh)->m_bfRQT, (const UCHAR*)pf->packet_pos);
				QUEUE_FORMAT qf;
				pm->puh->GetResponseQueue(&qf);	
				if (qf.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN) 
				{
					AttachPropertyInstanceEx(pf->hFrame,
						falcon_database[db_uh_rqt_desc].hProperty,
						uEnumSize,
						(void*)pf->packet_pos,
						sizeof(qf),
						(void*)&qf,
						0, INDENT_LEVEL_2 + g_uMasterIndentLevel, 0);
				}
			}
			break;
		default:
			{
				//
				// attach and accrue all statically sized fields
				//
				if (uThisEnum >= db_uh_desc && uThisEnum <= db_uh_security) 
				{ 
					AttachField(pf->hFrame, pf->packet_pos, uThisEnum);
				}
				else 
					//
					// something went wrong. break the parse.
					// bugbug - style - should assert here?
					//
					pf->dwBytesLeft = 0;
				break;
			}
		}// switch

		//
		// Advance the cursor and get the next field
		//
		pf->Accrue(uEnumSize, uThisEnum);
		pm->Accrue(uEnumSize);
		uThisEnum = pm->uGetCurrentEnum();
		uEnumSize = uGetFieldSize(uThisEnum);
	}// while


	#ifdef DEBUG
	{
		WCHAR szDebugString[MAX_DEBUG_STRING_SIZE];
		wsprintf(szDebugString, L"   MSMQ Msg %d ", ((CUserHeader *)pm->puh)->m_ulMessageID);
		OutputDebugString(szDebugString);
	}
	#endif

	#ifdef DEBUG 
		OutputDebugString(L"   Exiting AttachUserHeader. \n");
	#endif

	return(pm->uGetCurrentEnum() > db_uh_rqt_desc);
}//AttachUserHeader()

BOOL 
WINAPIV 
AttachSecurityHeader(CFrame *pf, CMessage *pm) 
{
/************************************************************

  Routine Description:
	Parses the fields of the MSMQ Security header
	of an MSMQ user message packet.

  Arguments:
	pf, pm - point to objects which contains info
	about the state of the parse for the current frame and 
	current message, respectively.

  Return Value:
	Return TRUE if the last property in the header was parsed 
	successfully. Otherwise, return FALSE.

  Notes:

************************************************************/
#ifdef DEBUG 
	OutputDebugString(L"   AttachSecurityHeader ... ");
#endif

	// 
	// The while test assures there are enough bytes left 
	// for the next statically sized field to be parsed
	// Some fields are not statically sized. These fields enter the 
	// loop as size zero and are sized as special cases in the switch
	//
	enum eMQPacketField uThisEnum = pm->uGetCurrentEnum();
	UINT uEnumSize = uGetFieldSize(uThisEnum);
	char szSummary[MAX_SUMMARY_LENGTH];
	DWORD dwHighlightBytes = 0;
    bool bIsEnhancedSecurityPresent=false;
	while (uThisEnum <= db_sh_certificate && pf->dwBytesLeft >= uEnumSize) 
	{ 
		switch (uThisEnum) 
		{
		case db_sh_summary: 
			{
				//
				// Generate and attach the header summary property
				// Abort parsing if the header is fragmented
				//
				if (pf->dwBytesLeft >= sizeof(CSecurityHeader))
				{
					dwHighlightBytes = pm->psh->GetNextSection() - (PCHAR)(pm->psh);
					sprintf(szSummary, "");
					if(pm->psh->IsEncrypted())
					{
                        sprintf(szSummary, "Encrypted");
                        USHORT SymmetricKeySize=0;
                        const UCHAR *pTemp=pm->psh->GetEncryptedSymmetricKey(&SymmetricKeySize);
    					if (SymmetricKeySize==72) 
                        {
                            strcat(szSummary, ", (Basic encryption)");
                        }
                        else
                        {
                            bIsEnhancedSecurityPresent=true;
                            strcat(szSummary, ", (Enhanced encryption)");
                        }
                    }
					else
					{
						sprintf(szSummary, "Plain text");
					}
					if(pm->psh->IsAuthenticated())
					{
						strcat(szSummary, ", Authenticated");
					}
                    AttachSummary(pf->hFrame, pf->packet_pos, db_sh_summary, szSummary, dwHighlightBytes);
				}
				else
				{
					dwHighlightBytes = pf->dwBytesLeft;
					AttachAsUnparsable(pf->hFrame, pf->packet_pos, pf->dwBytesLeft);
				}
			}//case
			break;
		case db_sh_desc:
			{
				sprintf(szSummary, "--- Security Header ---");
				AttachSummary(pf->hFrame, pf->packet_pos, db_sh_desc, szSummary, dwHighlightBytes);
				break;
			}
		case db_sh_sender_id: 
			//#define ALIGNUP4(x) ((((ULONG)(x))+3) & ~3)
 			uEnumSize = ALIGNUP4(((CSecurityHeader *)pm->psh)->m_wSenderIDSize); 
			{
	        SENDER_ID_INFO sender_id = {pf->packet_pos, uEnumSize, pm->psh->GetSenderIDType()};
			//
			// todo - add tunable parameter to MSMQ.INI to attach resolved SID if desired
			//
			/*AttachPropertyInstanceEx( pf->hFrame,
			                          falcon_database[db_sh_sender_id].hProperty,
				                      uEnumSize,
					                  pf->packet_pos,
						              sizeof(sender_id),
							          &sender_id,
								      NO_HELP_ID, INDENT_LEVEL_2 + g_uMasterIndentLevel, 0); */
		    AttachPropertyInstance( pf->hFrame,
			                          falcon_database[db_sh_sender_id].hProperty,
				                      uEnumSize,
					                  pf->packet_pos,
								      NO_HELP_ID, INDENT_LEVEL_2 + g_uMasterIndentLevel, 0); 
			}
			break;
		case db_sh_encrypted_key:
			uEnumSize = ALIGNUP4(((CSecurityHeader *)pm->psh)->m_wEncryptedKeySize);
			if (uEnumSize) 
				AttachPropertyInstance( pf->hFrame,
                                falcon_database[db_sh_encrypted_key].hProperty,
                                uEnumSize,
                                pf->packet_pos,
                                NO_HELP_ID, INDENT_LEVEL_2 + g_uMasterIndentLevel, 0);
			break;
		case db_sh_signature:
			uEnumSize = ALIGNUP4(((CSecurityHeader *)pm->psh)->m_wSignatureSize);  
			if (uEnumSize) 
				AttachPropertyInstance( pf->hFrame,
                                falcon_database[db_sh_signature].hProperty,
                                uEnumSize,
                                pf->packet_pos,
                                NO_HELP_ID, INDENT_LEVEL_2 + g_uMasterIndentLevel, 0);
			break;
		case db_sh_certificate:
			uEnumSize = ALIGNUP4(((CSecurityHeader *)pm->psh)->m_ulSenderCertSize);
			if (uEnumSize) 
				AttachPropertyInstance( pf->hFrame,
                                falcon_database[db_sh_certificate].hProperty,
                                uEnumSize,
                                pf->packet_pos,
                                NO_HELP_ID, INDENT_LEVEL_2 + g_uMasterIndentLevel, 0);
			break;
		default:
			//
			// attach and accrue all statically sized fields
			//
			if (uThisEnum >= db_sh_desc && uThisEnum <= db_sh_provider_info_size) 
			{ 
				//
				// bugbug - change db_uh_rqt_desc to db_uh_security after queue descriptors are handled.
				//
				AttachField(pf->hFrame, pf->packet_pos, uThisEnum);
			}
			else 
				//
				// something went wrong. break the parse.
				// style - should assert here?
				//
				pf->dwBytesLeft = 0;
			break;
		} // switch
		pf->Accrue(uEnumSize, uThisEnum);
		pm->Accrue(uEnumSize);

	uThisEnum = pm->uGetCurrentEnum();
	uEnumSize = uGetFieldSize(uThisEnum);
	} // while

	#ifdef DEBUG 
		OutputDebugString(L"   Exiting AttachSecurityHeader. \n");
	#endif

	return(pm->uGetCurrentEnum() > db_sh_certificate);
}// AttachSecurityHeader

BOOL 
WINAPIV 
AttachPropertyHeader(CFrame *pf, CMessage *pm) 
{
/************************************************************

  Routine Description:
	Parses the fields of the MSMQ Property header
	of an MSMQ user message packet.

  Arguments:
	pf, pm - point to objects which contains info
	about the state of the parse for the current frame and 
	current message, respectively.

  Return Value:
	Return TRUE if the last property in the header was parsed 
	successfully. Otherwise, return FALSE.

  Notes:
	This is the most interesting of the headers to parse.
	The body property is likely to be fragmented, and a couple of 
	the fields have alignment issues that need to be accounted for 
	in the packet. I.e. the true size of the field is smaller 
	than the packet buffer in which it is stored.

************************************************************/
#ifdef DEBUG 
	OutputDebugString(L"   AttachPropertyHeader ... ");
#endif

	enum eMQPacketField uThisEnum = pm->uGetCurrentEnum();
	UINT uEnumSize = uGetFieldSize(uThisEnum);
	UINT uAccrueBytes = 0;

	// 
	// The while test assures there are enough bytes left 
	// for the next statically sized field to be parsed
	// Some fields are not statically sized. These fields enter the 
	// loop as size zero and are sized as special cases in the switch
	//
	while (uThisEnum <= db_prop_body && pf->dwBytesLeft >= uEnumSize && pf->dwBytesLeft) 
	{ 
		switch (uThisEnum) 
		{
		case db_prop_summary: 
			{
				//
				// Generate and attach the header summary property
				// Abort parsing if the header is fragmented
				//
				DWORD dwHighlightBytes = 0;
				char szSummary[MAX_SUMMARY_LENGTH];
				sprintf(szSummary, "");
				int iSummaryLength = 0;
				if (pf->dwBytesLeft >= sizeof(CPropertyHeader))
				{
					dwHighlightBytes = pm->pph->GetNextSection() - (PCHAR)pm->pph;

					ULONG ulBodySize=pm->pph->GetBodySize();
					sprintf(szSummary, "Body: %lu bytes", ulBodySize);
					UCHAR ucAck = pm->pph->GetAckType();
					strcat(szSummary, " Ack level: ");
					switch (ucAck)
					{
					case MQMSG_ACKNOWLEDGMENT_NONE: //0
						strcat(szSummary, "MQMSG_ACKNOWLEDGMENT_NONE");
						break;
					case MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL: //1
						strcat(szSummary, "MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL");
						break;
					case MQMSG_ACKNOWLEDGMENT_POS_RECEIVE: //2
						strcat(szSummary, "MQMSG_ACKNOWLEDGMENT_POS_RECEIVE");
						break;
					case MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL: //4
						strcat(szSummary, "MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL");
						break;
					case MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE: //5 =MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL | MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL
						strcat(szSummary, "MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE");
						break;
					case MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE: //8
						strcat(szSummary, "MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE");
						break;
					case MQMSG_ACKNOWLEDGMENT_NACK_RECEIVE: //12 =  MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL | MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE
						strcat(szSummary, "MQMSG_ACKNOWLEDGMENT_NACK_RECEIVE");
						break;
					case MQMSG_ACKNOWLEDGMENT_FULL_RECEIVE: //14 = MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL | MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE | MQMSG_ACKNOWLEDGMENT_POS_RECEIVE
						strcat(szSummary, "MQMSG_ACKNOWLEDGMENT_FULL_RECEIVE");
						break;
					default:
						strcat(szSummary, "Unparsable");
						break;
					}
					iSummaryLength = strlen(szSummary);
					AttachSummary(pf->hFrame, pf->packet_pos, db_prop_summary, szSummary, dwHighlightBytes);
				}
				else
				{
					dwHighlightBytes = pf->dwBytesLeft;
					AttachAsUnparsable(pf->hFrame, pf->packet_pos, pf->dwBytesLeft);
				}
			}
			break;
		case db_prop_label: 
			{ 
				ULONG ulSize = pm->pph->GetTitleLength();
				uEnumSize = ulSize * sizeof(WCHAR);  
				if (uEnumSize) 
				AttachPropertyInstanceEx( pf->hFrame,
									  falcon_database[db_prop_label].hProperty,
									  uEnumSize,
									  pf->packet_pos,
									  sizeof(ulSize),
									  (void*)&ulSize,
									  0, INDENT_LEVEL_2 + g_uMasterIndentLevel, 0);
			}
			uAccrueBytes = uEnumSize; //bugbug - ALIGNUP4 here?

			//
			// abbreviate label if needed
			//
			// todo - make length of label abstract tunable in MSMQ.INI
			//
			{
				WCHAR wszTemp[LABEL_ABSTRACT_SIZE +6];
				wcsncpy(wszTemp, (WCHAR *)pf->packet_pos, LABEL_ABSTRACT_SIZE);
				if(wcslen((WCHAR *)pf->packet_pos) >= LABEL_ABSTRACT_SIZE)
					swprintf((wszTemp + LABEL_ABSTRACT_SIZE), L"...");
					
				sprintf( pm->szMessageSummary, "'%S'", wszTemp);
			}
			break;
		case db_prop_extension:
			{
				uEnumSize = pm->pph->GetMsgExtensionSize();
				if (uEnumSize)
					AttachPropertyInstance( pf->hFrame,
									  falcon_database[db_prop_extension].hProperty,
									  uEnumSize,
									  pf->packet_pos,
									  0, INDENT_LEVEL_2 + g_uMasterIndentLevel, 0);
				uAccrueBytes = uEnumSize;
			}
			break;
		case db_prop_body:
			{
				uEnumSize = ALIGNUP4(pm->pph->GetBodySize()); 
				if (uEnumSize <= pf->dwBytesLeft) 
				{
					//
					// the body is contained completely in this frame
					//
					AttachPropertyInstance( pf->hFrame,
									  falcon_database[db_prop_body].hProperty,
									  uEnumSize,
									  pf->packet_pos,
									  0, INDENT_LEVEL_2 + g_uMasterIndentLevel, 0);
					uAccrueBytes = uEnumSize;
				}
				else 
				{ 
					//
					// This is first bytes of a fragmented body
					//
					AttachPropertyInstance( pf->hFrame,
									  falcon_database[db_prop_body].hProperty,
									  pf->dwBytesLeft, //attach remaining bytes in frame
									  pf->packet_pos,
									  0, INDENT_LEVEL_2 + g_uMasterIndentLevel, 0);
					uAccrueBytes = pf->dwBytesLeft;
//					pm->uEnumBytesLeft = (uEnumSize - uAccrueBytes); //bugbug
				}
			}
			break;
		default:
			{
				//
				// attach and accrue all statically sized fields
				//
				if (uThisEnum >= db_prop_desc && uThisEnum <= db_prop_extension_size) 
				{ 
					AttachField(pf->hFrame, pf->packet_pos, uThisEnum);
					uAccrueBytes = uEnumSize;
				}
				else
					//
					// something went wrong. break the parse.
					// style - should assert here?
					//
					pf->dwBytesLeft = 0;
			}
			break;
		}// switch
	pf->Accrue(uEnumSize, uThisEnum);
	pm->Accrue(uEnumSize);
	uThisEnum = pm->uGetCurrentEnum();
	uEnumSize = uGetFieldSize(uThisEnum);
	}// while

	#ifdef DEBUG 
		OutputDebugString(L"   Exiting AttachPropertyHeader. \n");
	#endif

	return(pm->uGetCurrentEnum() > db_prop_body);
}// AttachPropertyHeader

BOOL 
WINAPIV 
AttachXactHeader(CFrame *pf, CMessage *pm) 
{
/************************************************************

  Routine Description:
	Parses the fields of the MSMQ Transaction header
	of an MSMQ user message packet.

  Arguments:
	pf, pm - point to objects which contains info
	about the state of the parse for the current frame and 
	current message, respectively.

  Return Value:
	Return TRUE if the last property in the header was parsed 
	successfully. Otherwise, return FALSE.

  Notes:

************************************************************/

#ifdef DEBUG 
	OutputDebugString(L"   AttachXactHeader ... ");
#endif

	// 
	// The while test assures there are enough bytes left 
	// for the next statically sized field to be parsed
	// Some fields are not statically sized. These fields enter the 
	// loop as size zero and are sized as special cases in the switch
	//
	enum eMQPacketField uThisEnum = pm->uGetCurrentEnum();
	UINT uEnumSize = uGetFieldSize(uThisEnum);
	DWORD dwHighlightBytes = 0;
	char szSummary[MAX_SUMMARY_LENGTH];
	while (uThisEnum <= db_xa_connector_qm && pf->dwBytesLeft >= uEnumSize) 
	{ 
		switch (uThisEnum) 
		{
		case db_xa_summary: 
			{
				//
				// Generate and attach the header summary property
				// Format: "SeqID:  SeqN:   PrevN:"
				//
				// Abort parsing if the header is fragmented
				//
				if (pf->dwBytesLeft >= sizeof(CXactHeader))
				{
					dwHighlightBytes = pm->pxh->GetNextSection() - (PCHAR)(pm->pxh);
					sprintf(szSummary, "SeqID: %I64d, SeqN: %lu, PrevN: %lu",
						pm->pxh->GetSeqID(), pm->pxh->GetSeqN(), pm->pxh->GetPrevSeqN());
					AttachSummary(pf->hFrame, pf->packet_pos, db_xa_summary, szSummary, dwHighlightBytes);
				}
				else
				{
					dwHighlightBytes = pf->dwBytesLeft;
					AttachAsUnparsable(pf->hFrame, pf->packet_pos, pf->dwBytesLeft);
				}
			}
			break;
		case db_xa_desc:
			{
				sprintf(szSummary, "--- Transaction Header ---");
				AttachSummary(pf->hFrame, pf->packet_pos, db_xa_desc, szSummary, dwHighlightBytes);
				break;
			}
		case db_xa_index:
			{
				dwHighlightBytes = sizeof(ULONG);
			    ULONG uXactIndex=pm->pxh->GetXactIndex();
				char szTemp[21]; //xact index is formatted 20 binary digits
				UL2BINSTRING(uXactIndex, szTemp, 20);
				sprintf(szSummary, "........%s....  : Xact Index: %lu", szTemp, uXactIndex);
				AttachSummary(pf->hFrame, pf->packet_pos, db_xa_index, szSummary, dwHighlightBytes);
				break;
			}
		case db_xa_connector_qm: 
			{ 
				if (pm->pxh->ConnectorQMIncluded()) 
				{
					uEnumSize = sizeof(GUID);
					AttachPropertyInstance( pf->hFrame,
									falcon_database[db_xa_connector_qm].hProperty,
									sizeof(GUID),
									pf->packet_pos,
									NO_HELP_ID, INDENT_LEVEL_2 + g_uMasterIndentLevel, 0);
				}
			}
			break;
		default: 
			{
				//
				// attach and accrue all statically sized fields
				//
				if (uThisEnum >= db_xa_desc && uThisEnum <= db_xa_previous_sequence_number) 
				{ 
					AttachField(pf->hFrame, pf->packet_pos, uThisEnum);
				}
				else 
				{
					//
					// something went wrong. break the parse.
					// style - should assert here?
					//
					pf->dwBytesLeft = 0;
					//return(true);
				} //else
				break;
			}
		}//switch
		//
		// Advance the cursor and get the next field
		//
		pf->Accrue(uEnumSize, uThisEnum);
		pm->Accrue(uEnumSize);
		uThisEnum = pm->uGetCurrentEnum();
		uEnumSize = uGetFieldSize(uThisEnum); 
	}// while

	#ifdef DEBUG
		OutputDebugString(L"   Exiting AttachXactHeader\n");
	#endif

	return(pm->uGetCurrentEnum() > db_xa_connector_qm);
}//AttachXactHeader


BOOL 
WINAPIV 
AttachSessionHeader(CFrame *pf, CMessage *pm) 
{
/************************************************************

  Routine Description:
	Parses the fields of the MSMQ Session header
	This header can accompany both MSMQ user message packets
	and internal packets

  Arguments:
	pf, pm - point to objects which contains info
	about the state of the parse for the current frame and 
	current message, respectively.

  Return Value:
	Return TRUE if the last property in the header was parsed 
	successfully. Otherwise, return FALSE.

  Notes:

************************************************************/

	#ifdef DEBUG 
		OutputDebugString(L"   AttachSessionHeader ... ");
	#endif

	// 
	// The while test assures there are enough bytes left 
	// for the next statically sized field to be parsed
	// Some fields are not statically sized. These fields enter the 
	// loop as size zero and are sized as special cases in the switch
	//
	enum eMQPacketField uThisEnum = pm->uGetCurrentEnum();
	UINT uEnumSize = uGetFieldSize(uThisEnum);	

	while (uThisEnum <= db_ss_reserved && pf->dwBytesLeft >= uEnumSize) 
	{ 
		switch (uThisEnum) 
		{
		case db_ss_root: 
			{
				//
				// Determine how many bytes are safe to highlight,
				// since the header may be fragmented
				//
				CSessionSection UNALIGNED *session_header = (CSessionSection*)(pf->packet_pos);
				DWORD dwHighlightBytes = sizeof(CSessionSection);
				//
				//bugbug: will we get this condition? i.e. assert instead
				//
				if (pf->dwBytesLeft < dwHighlightBytes)
					dwHighlightBytes = pf->dwBytesLeft;
				else
				{
					char szSummary[MAX_SUMMARY_LENGTH];
					char szTemp[MAX_SUMMARY_LENGTH];
					int iSummaryLength;

					sprintf(szSummary, "Ack: %lu", session_header->GetAcknowledgeNo());
					sprintf(szTemp, ", Recoverable Ack: %lu", session_header->GetStorageAckNo());
					strcat(szSummary, szTemp);
					strcat(szSummary, "\0"); //pad an extra null
					iSummaryLength = strlen(szSummary);
					AttachSummary(pf->hFrame, pf->packet_pos, db_ss_root, szSummary, dwHighlightBytes);
				}

			}//case
			break;
		default:
			{
				//
				// attach and accrue all statically sized fields
				//
				if (uThisEnum >= db_ss_desc && uThisEnum <= db_ss_reserved) 
				{ 
					AttachField(pf->hFrame, pf->packet_pos, uThisEnum);
				}
				else 
				{
					//
					// something went wrong. break the parse.
					// style - should assert here?
					//
					pf->dwBytesLeft = 0;
					//return(true);
				}//else
				break;
			}
		}//switch

		//
		// Advance the cursor and get the next field
		//
		pf->Accrue(uEnumSize, uThisEnum);
		pm->Accrue(uEnumSize);
		uThisEnum = pm->uGetCurrentEnum();
		uEnumSize = uGetFieldSize(uThisEnum);
	}//while

	#ifdef DEBUG
		OutputDebugString(L"   Exiting AttachSessionHeader\n");
	#endif

	return(pm->uGetCurrentEnum() > db_ss_reserved);
}//AttachSessionHeader


BOOL 
WINAPIV 
AttachDebugHeader(CFrame *pf, CMessage *pm) 
{
/************************************************************

  Routine Description:
	Parses the fields of the MSMQ Debug header
	This header can accompany both MSMQ user message packets
	and internal packets.

  Arguments:
	pfc - points to a CFrameCursor object which contains info
	about the current frame and state of the parse

  Return Value:
	Return TRUE if the last property in the header was parsed 
	successfully. Otherwise, return FALSE.

  Notes:
	Currently does nothing
	todo - create debug packets and parse

************************************************************/

	//attach the Debug header
	//attach sequene db_debug_desc - response queue. Response queue is dynamically sized?
	return(TRUE);
}

//==============================================================================
//  FUNCTION: falFormatSummary()
//
//
// This will generate the summary line for the packet
//
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//  shaharf				19-jan-97		modified for Falcon beta-2
//  Andrew Smith		07/28/97		modified for Beta 2E
//==============================================================================

//
// BUGBUG internationalization
//

VOID 
WINAPIV 
format_falcon_summary(LPPROPERTYINST lpPropertyInst
					  //CMessage *pm,
					  //CFrame *pf,
					  //char *szSummary	
					 )
{
#ifdef DEBUG
	OutputDebugString(L"  format_falcon_summary - ");
#endif
	//
	// There's not much real estate on the frame summary line
	// So prioritize what is seen. The user can scroll or expand columns
	// to see lower priority data (or drill down into the parsed packet)
	//
	char szMessageSummary[128];			// Buffer for assembling the final summary
	char szVisible[FORMAT_BUFFER_SIZE];					// Pri1 - error or condition requiring visibility
	char szSystemPurpose[FORMAT_BUFFER_SIZE];			// Pri2 - system purpose
	char szSystemPurposeQualifier[FORMAT_BUFFER_SIZE];	// Pri3 - system purpose qualifier
	char szCaseSpecific[FORMAT_BUFFER_SIZE];			// Pri4 - case specific visible data
	// todo - char szHeaders[FORMAT_BUFFER_SIZE];			// Pri? headers included
	sprintf(szVisible, "");
	sprintf(szSystemPurpose, "");
	sprintf(szSystemPurposeQualifier, "");
	sprintf(szCaseSpecific, "");
	sprintf(szMessageSummary, "");

	//
	// Test for Base Header
	//
	PCHAR pSection;
	CBaseHeader *pbh = (CBaseHeader *)lpPropertyInst->lpPropertyInstEx->lpData;
	if ((pbh->GetVersion() == FALCON_PACKET_VERSION) && (pbh->SignatureIsValid())) 
	{
		pSection = (PCHAR)pbh->GetNextSection();
		UINT uBytesLeft=lpPropertyInst->lpPropertyInstEx->Length;
		UINT uPacketSize = pbh->GetPacketSize();
		char szTemp[FORMAT_BUFFER_SIZE];
		bool bPartialMessage = (uBytesLeft < uPacketSize);

		if(uBytesLeft > uPacketSize)
		{
			//
			// Mark frame as containing multiple messages
			//
			sprintf( szVisible, "[+] ");
		}
		//
		// assume base header is not fragmented
		// todo - Assert
		//
		if (pbh->GetType() == FALCON_USER_PACKET)
		{ 
			sprintf( szSystemPurpose, "");
			sprintf( szCaseSpecific, ", %lu bytes", pbh->GetPacketSize());

			if (bPartialMessage)
			{
				sprintf( szVisible, "Partial ");
			}
			else
			{
				//
				// Party on! We have a whole user packet to work with!
				//
				OBJECTID objid;
				CUserHeader *puh = (CUserHeader *)pSection;
				pSection = (PCHAR)puh->GetNextSection();
				puh->GetMessageID(&objid);
				sprintf(szTemp, ", ID:%ld ", objid.Uniquifier);
				strcat(szSystemPurposeQualifier, szTemp);
				if (puh->IsOrdered()) 
				{
					sprintf( szSystemPurpose, "Transactional");
					CXactHeader *pxh = (CXactHeader *)pSection;
					pSection = (PCHAR)pxh->GetNextSection();
				    LONGLONG llSeqID = pxh->GetSeqID();
					LARGE_INTEGER liSeqID;
					memcpy(&liSeqID, &llSeqID, sizeof(LONGLONG));
					ULONG ulHighPart = liSeqID.HighPart;
					ULONG ulLowPart = liSeqID.LowPart;
					sprintf
						(
							szCaseSpecific, "SeqID = %x-%x, SeqN = %x, PrevN = %x", 
							ulHighPart, 
							ulLowPart, 
							pxh->GetSeqN(), 
							pxh->GetPrevSeqN()
						);				
				} 
				else 
				{
					UCHAR uc = puh->GetDelivery();
					if (uc == MQMSG_DELIVERY_EXPRESS)
					{
						sprintf( szSystemPurpose, "Express");
					}
					if (uc == MQMSG_DELIVERY_RECOVERABLE)
					{
						sprintf( szSystemPurpose, "Persistent");
					}
				}
				if (puh->PropertyIsIncluded()) 
				{
					CPropertyHeader *pph = (CPropertyHeader *)pSection;
					pSection = (PCHAR)pph->GetNextSection();

					//
					// If this is ordering ack, overwrite default summary with ack summary
					//
					WCHAR wcLabel[255]; //bugbug - need correct label length
					ULONG ulTitleLength = pph->GetTitleLength();
					bool bIsOrderingAck;
					pph->GetTitle(wcLabel, 255); //bugbug - doesn't retrieve title correctly
					if (wcsncmp(wcLabel, ORDER_ACK_TITLE,14))
					{
						bIsOrderingAck = false;
					}
					else
					{
						bIsOrderingAck = true;
					}

					if (bIsOrderingAck)
					{
						sprintf( szSystemPurpose, "Ordering Ack: ");
						sprintf( szSystemPurposeQualifier, "");
						MyOrderAckData *poad=(MyOrderAckData *)pph->GetBodyPtr();
						MyOrderAckData oad = *poad;
						LARGE_INTEGER liSeqID = oad.m_liSeqID;
						ULONG ulHighPart = liSeqID.HighPart;
						ULONG ulLowPart = liSeqID.LowPart;
						sprintf
							(
							szCaseSpecific, "SeqID = %x-%x, SeqN = %x, PrevN = %x", 
							ulHighPart, 
							ulLowPart, 
							poad->m_ulSeqN, 
							poad->m_ulPrevSeqN
							);
					}

					//
					// todo - Add label abstract? Tunable property displays?
					//
				}
			} // else
		} // if - it's a user packet
		else //FALCON_INTERNAL_PACKET:
		{
			sprintf( szSystemPurpose, "Internal ");
			sprintf( szCaseSpecific, ", %lu bytes", pbh->GetPacketSize());
			if (bPartialMessage)
			{
				sprintf( szVisible, "Partial ");
			}
			else
			{
				//
				// Party on! We have a whole internal packet to work with!
				//
				CInternalSection *pis = (CInternalSection *)pbh->GetNextSection();
				switch(pis->GetPacketType()) 
				{
					case INTERNAL_SESSION_PACKET:	
					{
						WORD wj, wk;
						DWORD dwk, dwl;
						char szTemp[60], szTemp2[60];
						CSessionSection *pss = (CSessionSection *) pis->GetNextSection();
						sprintf( szSystemPurpose, "Session Ack");

						if(wj = pss->GetAcknowledgeNo()) 
						{
							sprintf( szTemp, ", Seq %u", wj);
							sprintf( szCaseSpecific, szTemp);
						}
						if(wj = pss->GetStorageAckNo()) 
						{
							sprintf( szTemp, ", Rcvr %u", wj);
							dwk = pss->GetStorageAckBitField();
							dwl = 1;
							while (dwk) 
							{
								wj++;
								if (dwk & dwl)
								{
									sprintf(szTemp2, "-%u", wj);
									strcat(szTemp, szTemp2);
								}
								dwk ^= dwl;
								dwl = dwl << 1; 
							}
							strcat(szCaseSpecific, szTemp);
						}//if
						pss->GetSyncNo(&wj, &wk); //GetSyncNo(WORD* wSyncAckSequenceNo, WORD* wSyncAckRecoverNo);
						if(wj)
						{
							sprintf( szTemp, ", Sync Seq %u", wj);
							strcat( szCaseSpecific, szTemp);
						}
						if(wk)
						{
							sprintf( szTemp, ", Sync Rcvr %u", wk);
							strcat( szCaseSpecific, szTemp);
						}
						if (wj = pss->GetWindowSize()) 
						{
							sprintf( szTemp, ", Window %u", wj);
							strcat( szCaseSpecific, szTemp);
						}
					}
						break;

					case INTERNAL_ESTABLISH_CONNECTION_PACKET:
						{
							CECSection *pec = (CECSection *) pis->GetNextSection();
							sprintf( szSystemPurpose, "Establish Connection ");
							if(pec->IsOtherSideServer())
							{
								sprintf(szCaseSpecific, "as MSMQ Server");
							}
							else
							{
								sprintf(szCaseSpecific, "as Independent Client");
							}
						}
						break;

					case INTERNAL_CONNECTION_PARAMETER_PACKET:
						{
							CCPSection *pcp = (CCPSection *)pis->GetNextSection();
							sprintf( szSystemPurpose, "Connection Parameters: ");
							sprintf(szTemp, "Ack T/O = %ld, ", pcp->GetAckTimeout());
							sprintf( szCaseSpecific, szTemp);
							sprintf(szTemp, "P-Ack T/O = %ld, ", pcp->GetRecoverAckTimeout());
							strcat( szCaseSpecific, szTemp);
							sprintf(szTemp, "Window = %hd", pcp->GetWindowSize());
							strcat( szCaseSpecific, szTemp);
						}
						break;
					default:
						break;
					}//nested switch

			}

		}//else
		sprintf(szMessageSummary, "%s", szVisible);
		strcat(szMessageSummary, szSystemPurpose);
		strcat(szMessageSummary, szSystemPurposeQualifier);
		strcat(szMessageSummary, szCaseSpecific);
		//wsprintf(lpPropertyInst->szPropertyText, szMessageSummary);
		sprintf(lpPropertyInst->szPropertyText, szMessageSummary);
	}//if it's a falcon message
	else
	{
		//sprintf(szSummary, "unparsable - use protocol coalesce expert");
		//wsprintf(lpPropertyInst->szPropertyText, "Fragment (unparsable) - Suggest using SMS protocol coalesce expert");
		sprintf(lpPropertyInst->szPropertyText, "Fragment (unparsable) - Suggest using SMS protocol coalesce expert");
	}

	#ifdef DEBUG
		{
			WCHAR lpzDebugString[MAX_DEBUG_STRING_SIZE];
			wsprintf(lpzDebugString, L"%s ... Exiting\n", szMessageSummary);
			OutputDebugString(lpzDebugString);
		} 
	#endif
}

BOOL WINAPIV AttachServerDiscovery(CFrame *pf, CMessage *pm) 
{
/************************************************************

  Routine Description:
	Parses the fields of the MSMQ Server Discovery Multicast.

  Arguments:
	pf, pm - point to objects which contains info
	about the state of the parse for the current frame and 
	current message, respectively.

  Return Value:
	Return TRUE if the last property in the header was parsed 
	successfully. Otherwise, return FALSE.

  Notes:
	Assumption: It is assumed this packet is not fragmented.

************************************************************/

	#ifdef DEBUG 
		OutputDebugString(L"   AttachServerDiscovery... ");
	#endif
	struct CTopologyPacketHeader //stripped from topolpkt.h
	{
        unsigned char  m_ucVersion;
        unsigned char  m_ucType;
        unsigned short m_usReserved;
        GUID           m_guidIdentifier;
	};

	CTopologyPacketHeader UNALIGNED *tph = (CTopologyPacketHeader*) pf->packet_pos;

	DWORD dwHighlightBytes = sizeof(CTopologyPacketHeader);
	//
	// Attach the root packet summary property - It will be populated later
	// in the format_falcon_summary routine
	//
	char szSummary[FRAME_SUMMARY_LENGTH];
	sprintf (szSummary, "Stub Message Summary for Debugging");
	AttachPropertyInstanceEx(pf->hFrame,
				   falcon_database[db_tph_summary].hProperty,
				   dwHighlightBytes,
				   pf->packet_pos,
				   FRAME_SUMMARY_LENGTH,
				   szSummary,
				   NO_HELP_ID, 
				   falFieldInfo[db_tph_summary].indent_level,
				   falFieldInfo[db_tph_summary].flags);

	//
	// Attach the fields of the packet
	//
	AttachPropertySequence(pf->hFrame, pf->packet_pos, db_tph_version, db_tph_guid);

	//
	// Clean up
	//
	pf->Accrue(sizeof(CTopologyPacketHeader));		
	pm->Accrue(sizeof(CTopologyPacketHeader));		
	pm->SetCurrentEnum(uIncrementEnum(db_tph_guid));

	#ifdef DEBUG 
		OutputDebugString(L"   Exiting AttachServerDiscovery. \n");
	#endif

	return(pm->uGetCurrentEnum() > db_tph_guid); 
}//AttachServerDiscovery


VOID WINAPIV format_server_discovery(LPPROPERTYINST lpPropertyInst)
{
#ifdef DEBUG
	OutputDebugString(L"  format_server_discovery - ");
#endif
	struct CTopologyPacketHeader //stripped from topolpkt.h
	{
        unsigned char  m_ucVersion;
        unsigned char  m_ucType;
        unsigned short m_usReserved;
        GUID           m_guidIdentifier;
	};

	CTopologyPacketHeader UNALIGNED *tph = (CTopologyPacketHeader*) lpPropertyInst->lpPropertyInstEx->lpData;
	char szSummary[MAX_SUMMARY_LENGTH];
	sprintf(szSummary, "Server Discovery: ");
	/*	
	#define QM_RECOGNIZE_CLIENT_REQUEST    1
	#define QM_RECOGNIZE_SERVER_REPLY      2
	*/

	if (tph->m_ucType == 1)
	{
		strcat(szSummary, "Client request");
	}
	else if (tph->m_ucType == 2)
	{
		strcat(szSummary, "Server reply");
	}
	strcat(szSummary, "\0"); //pad an extra null

	//wsprintf(lpPropertyInst->szPropertyText, szSummary);
	sprintf(lpPropertyInst->szPropertyText, szSummary);

	#ifdef DEBUG
		{
			WCHAR lpzDebugString[MAX_DEBUG_STRING_SIZE];
			wsprintf(lpzDebugString, L"%s ... Exiting\n", szSummary);
			OutputDebugString(lpzDebugString);
		} 
	#endif
}
/* from ping.cpp
    union {
        USHORT m_wFlags;
        struct {
            USHORT m_bfIC : 1;
            USHORT m_bfRefuse : 1;
        };
    };
    USHORT  m_ulSignature;
    DWORD   m_dwCookie;
    GUID    m_myQMGuid ;
*/

VOID WINAPIV AttachServerPing(HFRAME hFrame, LPBYTE packet_pos,	DWORD BytesLeft, bool IsPingRequest) 
{
/************************************************************

  Routine Description:
	Parses the fields of the MSMQ Server Discovery Multicast.

  Arguments:
	pf, pm - point to objects which contains info
	about the state of the parse for the current frame and 
	current message, respectively.

  Return Value:
	Return TRUE if the last property in the header was parsed 
	successfully. Otherwise, return FALSE.

  Notes:
	Assumption: It is assumed this packet is not fragmented.

************************************************************/
	struct CPingPacket // todo - include original structure. Problem: it is defined in ping.cpp instead of ping.h
	{
		union 
		{
			USHORT m_wFlags;
			struct 
			{
				USHORT m_bfIC : 1;
				USHORT m_bfRefuse : 1;
			};
		};
		USHORT  m_ulSignature;
		DWORD   m_dwCookie;
		GUID    m_myQMGuid ;
	};

	#ifdef DEBUG 
		OutputDebugString(L"   AttachServerPing... ");
	#endif

	//
	// Attach the root packet summary property - It will be populated later
	// in the format_falcon_summary routine
	//
	char szSummary[FRAME_SUMMARY_LENGTH];
	sprintf (szSummary, "Ping ");
	CPingPacket UNALIGNED *pp = (CPingPacket*) packet_pos;
	DWORD dwHighlightBytes = sizeof(CPingPacket);

	if (IsPingRequest)
	{
		strcat(szSummary, "Request: ");
	}
	else
	{
		strcat(szSummary, "Reply  : ");
	}
	AttachPropertyInstanceEx(hFrame,
				   falcon_database[db_pp_summary].hProperty,
				   dwHighlightBytes,
				   packet_pos,
				   FRAME_SUMMARY_LENGTH,
				   szSummary,
				   NO_HELP_ID, 
				   falFieldInfo[db_pp_summary].indent_level,
				   falFieldInfo[db_pp_summary].flags);

	//
	// Attach the fields of the packet
	//
	AttachPropertySequence(hFrame, packet_pos, db_pp_flags, db_pp_guid);


	#ifdef DEBUG 
		OutputDebugString(L"   Exiting AttachServerPing. \n");
	#endif

}//AttachServerDiscovery


VOID WINAPIV format_server_ping(LPPROPERTYINST lpPropertyInst)
{
#ifdef DEBUG
	OutputDebugString(L"  format_server_ping - ");
#endif
	struct CPingPacket // todo - include original structure. Problem: it is defined in ping.cpp instead of ping.h
	{
		union 
		{
			USHORT m_wFlags;
			struct 
			{
				USHORT m_bfIC : 1;
				USHORT m_bfRefuse : 1;
			};
		};
		USHORT  m_ulSignature;
		DWORD   m_dwCookie;
		GUID    m_myQMGuid ;
	};

	CPingPacket UNALIGNED *pp = (CPingPacket*) lpPropertyInst->lpPropertyInstEx->lpData;
	char szSummary[MAX_SUMMARY_LENGTH];
	char szTemp[MAX_SUMMARY_LENGTH];

	sprintf(szSummary, (char *)lpPropertyInst->lpPropertyInstEx->Byte);
	sprintf(szTemp,"[%lu]", pp->m_dwCookie); 
	strcat(szSummary, szTemp);

	//
	// Comment on connection for only server reply
	// 
	// Look in the summary for the 'p' in "Reply :"
	//
	if (szSummary[7] == 'p')
	{
		if (pp->m_bfRefuse == 1)
		{
			strcat(szSummary, " Connection not permitted");
		}
		else
		{
			strcat(szSummary, " Connection permitted");
		}
	}

	strcat(szSummary, "\0"); //pad an extra null

	//wsprintf(lpPropertyInst->szPropertyText, szSummary);
	sprintf(lpPropertyInst->szPropertyText, szSummary);


	#ifdef DEBUG
		{
			WCHAR lpzDebugString[MAX_DEBUG_STRING_SIZE];
			wsprintf(lpzDebugString, L"%s ... Exiting\n", szSummary);
			OutputDebugString(lpzDebugString);
		} 
	#endif
}


VOID WINAPIV format_falcon_summary_mult(LPPROPERTYINST lpPropertyInst)
{
#ifdef DEBUG
	OutputDebugString(L"  format_falcon_summary_mult - ");
#endif
	//
	// There's not much real estate on the frame summary line
	// So prioritize what is seen. The user can scroll or expand columns
	// to see lower priority data (or drill down into the parsed packet)
	//
	char szMessageSummary[128];			// Buffer for assembling the final summary
	char szVisible[FORMAT_BUFFER_SIZE];					// Pri1 - error or condition requiring visibility
	char szSystemPurpose[FORMAT_BUFFER_SIZE];			// Pri2 - system purpose
	char szSystemPurposeQualifier[FORMAT_BUFFER_SIZE];	// Pri3 - system purpose qualifier
	char szCaseSpecific[FORMAT_BUFFER_SIZE];			// Pri4 - case specific visible data
	// todo - char szHeaders[FORMAT_BUFFER_SIZE];			// Pri? headers included
	sprintf(szVisible, "");
	sprintf(szSystemPurpose, "");
	sprintf(szSystemPurposeQualifier, "");
	sprintf(szCaseSpecific, "");
	sprintf(szMessageSummary, "");

	//
	//Test for Base Header
	//
	PCHAR pMessage;
	CBaseHeader *pbh = (CBaseHeader *)lpPropertyInst->lpPropertyInstEx->lpData;
	if ((pbh->GetVersion() == FALCON_PACKET_VERSION) && (pbh->SignatureIsValid())) 
	{
		pMessage = (PCHAR)pbh;
		DWORD dwBytesLeft=lpPropertyInst->lpPropertyInstEx->Length;
        DWORD dwUnparsableBytes=0;
		UINT uPacketSize = pbh->GetPacketSize();
		char szTemp[FORMAT_BUFFER_SIZE];
		bool bPartialMessage = (dwBytesLeft < uPacketSize);
		UINT uNumInternalMessages= 0;
		UINT uNumUserMessages = 0;
		UINT uNumUnparsable = 0;

		if(dwBytesLeft < uPacketSize)
		{
			//
			// todo - assert this should be a multiple message frame.
			//
		}

		//
		// Mark frame as containing multiple messages
		//
		sprintf( szVisible, "[+] ");

		//
		// Count the messages
		//
		while (dwBytesLeft > 0)
		{
			if ((pbh->GetVersion() == FALCON_PACKET_VERSION) && (pbh->SignatureIsValid()))
			{
				if (pbh->GetType() == FALCON_USER_PACKET)
				{
					uNumUserMessages++;
				}
				else
				{
					uNumInternalMessages++;
				}
				uPacketSize = pbh->GetPacketSize();
				pMessage += uPacketSize;
				dwBytesLeft -= uPacketSize;
				pbh = (CBaseHeader *)pMessage;
			}
			else
			{
				uNumUnparsable=1;
                dwUnparsableBytes=dwBytesLeft;
				dwBytesLeft = 0; //break the count, preserve the unparsable byte count
			}
		}
		UINT uNumMessages = uNumUserMessages + uNumInternalMessages + uNumUnparsable;
		sprintf(szMessageSummary, "%u Messages", uNumMessages);
		if (uNumUserMessages > 0)
		{
			sprintf(szCaseSpecific, ", %u  User", uNumUserMessages);
			strcat(szMessageSummary, szCaseSpecific);
		}
		if (uNumInternalMessages > 0)
		{
			sprintf(szCaseSpecific, ", %u  Internal", uNumInternalMessages);
			strcat(szMessageSummary, szCaseSpecific);
		}
		if (uNumUnparsable > 0)
		{
			sprintf(szCaseSpecific, ", %u  Unparsable bytes", dwUnparsableBytes);
			strcat(szMessageSummary, szCaseSpecific);
		}
		//wsprintf(lpPropertyInst->szPropertyText, szMessageSummary);
		sprintf(lpPropertyInst->szPropertyText, szMessageSummary);

	}//if it's a falcon message
	else
	{
		//wsprintf(lpPropertyInst->szPropertyText, "Fragment (unparsable) - Suggest using SMS protocol coalesce expert");
		sprintf(lpPropertyInst->szPropertyText, "Fragment (unparsable) - Suggest using SMS protocol coalesce expert");

	}

	#ifdef DEBUG
		{
			WCHAR lpzDebugString[MAX_DEBUG_STRING_SIZE];
			wsprintf(lpzDebugString, L"%s ... Exiting\n", szMessageSummary);
			OutputDebugString(lpzDebugString);
		} 
	#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\nmparser\falcondb.h ===
#ifndef _FALCONDB_
	#define _FALCONDB_
#endif

//=============================================================================
//  
//  MODULE: falconDB.h modified from sample: RemAPI.h
//
//  Description:
//
//  Falcon Property Database for MSMQ Netmon parser
//
//  Modification History
//
//  Shaharf		        07/07/94        Original content in nmmsmq.cxx
//  Andrew Smith		07/28/97		Modified to nmmsmq.h
//=============================================================================

#define INDENT_LEVEL_0 0	//indent levels for NM tree view of properties
#define INDENT_LEVEL_1 1
#define INDENT_LEVEL_2 2
#define INDENT_LEVEL_3 3

#define NO_ATTACH_FLAGS 0
#define NO_HELP_ID 0

#ifdef MAIN

#else

#endif
extern VOID WINAPIV format_falcon_summary_mult(LPPROPERTYINST lpPropertyInst);
extern VOID WINAPIV format_server_discovery(LPPROPERTYINST lpPropertyInst);
extern VOID WINAPIV format_server_ping(LPPROPERTYINST lpPropertyInst);

//  Enumeration for indexing database entries 
//	IMPORTANT: enumeration order must match entry order in falFieldInfo[] and falcon_database[]

enum eMQPacketField{
  // packet root summary
  db_summary_mult,
  db_summary_nonroot,
  db_summary_root,

  // base header
  db_bh_root,
  db_bh_desc,
  db_bh_version,			
  db_bh_reserved,
  db_bh_priority,			
  db_bh_flags, 
  db_bh_signature,
  db_bh_size,
  db_bh_abs_ttq,

  // internal: Header
  db_ih_root,
  db_ih_desc,
  db_ih_reserved,
  db_ih_flags_pkt_type,
  db_ih_flags_connection,

  // internal: Establish connection
  db_ce_root,
  db_ce_desc,
  db_ce_client_qm,
  db_ce_server_qm,
  db_ce_time_stamp,
  db_ce_version,
  db_ce_flags,
  db_ce_reserved,
  db_ce_body,

  // internal: Connection Parameters
  db_cp_root,
  db_cp_desc,
  db_cp_recover_ack_timeout,
  db_cp_ack_timeout,
  db_cp_segment_size,
  db_cp_window_size,

  // Session section
  db_ss_root,
  db_ss_desc,
  db_ss_ack_seq_num,
  db_ss_ack_rcvr_num,
  db_ss_ack_rcvr_bf,
  db_ss_sync_ack_seq_num,
  db_ss_sync_ack_rcvr_num,
  db_ss_window_size,
  db_ss_window_priority,
  db_ss_reserved,

  // User: header
  db_uh_summary,
  db_uh_desc,
  db_uh_source_qm,
  db_uh_destination_qm,
  db_uh_time_to_live_delta,
  db_uh_sent_time,
  db_uh_message_id,

  // User header flags
  db_uh_hopcount,
  db_uh_delivery,
  db_uh_routing,
  db_uh_auditing,
  db_uh_dqt_type,
  db_uh_aqt_type,
  db_uh_rqt_type,
  db_uh_security,
  db_uh_dqt_desc,
  db_uh_aqt_desc,
  db_uh_rqt_desc,

// prop - property section
  db_prop_summary,
  db_prop_desc,
  db_prop_ack_mode,
  db_prop_title_length, //new
  db_prop_class,
  db_prop_correlation_id,
  db_prop_body_type,	//new
  db_prop_application_tag,
  db_prop_body_size,
  db_prop_alloc_body_size,
  db_prop_privacy_level,
  db_prop_hash_algorithm,
  db_prop_encryption_algorithm,
  db_prop_extension_size,
  db_prop_label,
  db_prop_extension,
  db_prop_body,

// Debug section
  db_debug_summary,
  db_debug_desc,
  db_debug_flags,
  db_debug_reserved,
  db_debug_reportq_desc,

// Security section
  db_sh_summary,
  db_sh_desc,
  db_sh_flags,
  db_sh_sender_id_size,
  db_sh_encrypted_key_size,
  db_sh_signature_size,
  db_sh_sender_certificate_size,
  db_sh_provider_info_size,
  db_sh_sender_id,
  db_sh_encrypted_key,
  db_sh_signature,
  db_sh_certificate,

// Transaction section
  db_xa_summary,
  db_xa_desc,
  db_xa_flags,
  db_xa_index,
  db_xa_sequence_id,
  db_xa_sequence_number,
  db_xa_previous_sequence_number,
  db_xa_connector_qm,

// Server discovery packet
  db_tph_summary,
  db_tph_version,
  db_tph_type,
  db_tph_reserved,
  db_tph_guid,

// Ping packet
  db_pp_summary,
  db_pp_flags,
  db_pp_signature,
  db_pp_cookie,
  db_pp_guid,

  // Utility enumerations
  db_last_enum,  // End of enumeration marker
  db_fragmented_field,
  db_unparsable_field
};


typedef enum _enumHeaders {
	no_header,
	base_header,
	internal_header,
	cp_section,
	ec_section,
	user_header,
	security_header,
	property_header,
	xact_header,
	session_header,
    debug_header
} MQHEADER;


//#define UNUSED -1
#define VARIABLE 0

typedef struct {
	int offset;
	int length;	//bugbug - body size can be 4MB
	int indent_level;
	int flags;
	bool isComment;
} _FAL_FIELD_INFO;

#ifdef MAIN
_FAL_FIELD_INFO falFieldInfo[] = {
	//database of values to use when attaching a sequence of properties in AttachPropertySequence()
    //IMPORTANT: falFieldInfo[] order must match entry order in enumeration and falcon_database[]
	//Internal packet properties are offset from the base header since they are assume not to be fragmented
	//User packet propeties are 

	//  todo - add copy bytes filed to the FaalDB.  Bool  TRUE indicates copy bytes.  Access from the Accrue function

//offset length  indent level   attachment flags comment field
//====== ====== ==============  ================ =============

	//Root summary
	{0,		0,	INDENT_LEVEL_0,	NO_ATTACH_FLAGS, true},	//db_summary_mult
	{0,		0,	INDENT_LEVEL_0,	NO_ATTACH_FLAGS, true},	//db_summary_nonroot
	{0,		0,	INDENT_LEVEL_0,	NO_ATTACH_FLAGS, true},	//db_summary_root 

//offset length  indent level   attachment flags comment field
//====== ====== ==============  ================ =============
	//Base header
	{0,		16,	INDENT_LEVEL_1,	NO_ATTACH_FLAGS, true},	//db_bh_root
	{0,		16,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, true},	//db_bh_desc
	{0,		1,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},//db_bh_version
	{1,		1,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_bh_reserved
	{2,		2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_bh_priority
	{2,		2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_bh_flags
	{4,		4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_bh_signature
	{8,		4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_bh_size
	{12,	4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_bh_abs_ttq

//offset length  indent level   attachment flags comment field
//====== ====== ==============  ================ =============
	//Internal header
	{0,		4,	INDENT_LEVEL_1,	NO_ATTACH_FLAGS, true},	//db_ih_root
	{0,		4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, true},	//db_ih_desc
	{0,		2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ih_reserved
	{2,		2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ih_flags_pkt_type
	{2,		2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ih_flags_connection

//offset length  indent level   attachment flags comment field
//====== ====== ==============  ================ =============
	//Internal: Establish Connection
	{0,		548,INDENT_LEVEL_1,	NO_ATTACH_FLAGS, true},	//db_ce_root
	{0,		548,INDENT_LEVEL_2,	NO_ATTACH_FLAGS, true},	//db_ce_desc
	{0,		16,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ce_client_qm
	{16,	16,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ce_server_qm
	{32,	4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ce_time_stamp
	{36,	1,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ce_version
	{36,	2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ce_flags
	{38,	2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ce_reserved
	{40,	512,INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ce_body

//offset length  indent level   attachment flags comment field
//====== ====== ==============  ================ =============
	//Internal: Connection Parameters
	{0,		12,	INDENT_LEVEL_1,	NO_ATTACH_FLAGS, true},	//db_cp_root
	{0,		12,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, true},	//db_cp_desc
	{0,		4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_cp_recover_ack_timeout
	{4,		4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_cp_ack_timeout
	{8,		2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_cp_segment_size
	{10,	2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_cp_window_size

//offset length  indent level   attachment flags comment field
//====== ====== ==============  ================ =============
	//Internal: Session
	{0,		16,	INDENT_LEVEL_1,	NO_ATTACH_FLAGS, true},	//db_ss_root
	{0,		16,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, true},	//db_ss_desc
	{0,		2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ss_ack_seq_num
	{2,		2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ss_ack_rcvr_num
	{4,		4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ss_ack_rcvr_bf
	{8,		2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ss_sync_ack_seq_num
	{10,	2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ss_sync_ack_rcvr_num
	{12,	2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ss_window_size
	{14,	1,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ss_window_priority
	{15,	1,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_ss_reserved

//offset length  indent level   attachment flags comment field
//====== ====== ==============  ================ =============
	{0,				VARIABLE,INDENT_LEVEL_1, NO_ATTACH_FLAGS, true},	//db_uh_summary,
	{0,				VARIABLE,INDENT_LEVEL_2, NO_ATTACH_FLAGS, true},	//db_uh_desc
	{0,				16,		INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_uh_source_qm,
	{16,			16,		INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_uh_destination_qm, bugbug this size ignores the union
	{VARIABLE,		4,		INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_uh_time_to_live_delta,
	{VARIABLE,		4,		INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_uh_sent_time,
	{VARIABLE,		4,		INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_uh_message_id,

//offset length  indent level   attachment flags comment field
//====== ====== ==============  ================ =============
	{VARIABLE,	0,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_uh_hopcount
	{VARIABLE,	0,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_uh_delivery
	{VARIABLE,	0,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_uh_routing
	{VARIABLE,	0,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_uh_auditing
	{VARIABLE,	0,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_uh_dqt_type
	{VARIABLE,	0,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_uh_aqt_type
	{VARIABLE,	0,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_uh_rqt_type
	{VARIABLE,	4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_uh_security
																				// User: Queue descriptors
	{VARIABLE,	VARIABLE,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_uh_dqt_desc
	{VARIABLE,	VARIABLE,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_uh_aqt_desc
	{VARIABLE,	VARIABLE,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_uh_rqt_desc

//offset length  indent level   attachment flags comment field
//====== ====== ==============  ================ =============
	// User: property section
	{	  0,		 0,	INDENT_LEVEL_1,	NO_ATTACH_FLAGS, true},	//db_prop_summary
	{	  0,		56,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, true},	//db_prop_desc
	{	  0,		 1,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_prop_ack_mode
	{	  1,		 1,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_prop_title_length
	{	  2,		 2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_prop_class
	{	  4,		20,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_prop_correlation_id
	{	 24,		 4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_prop_body_type
	{	 28,		 4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_prop_application_tag
	{	 32,		 4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_prop_body_size
	{	 36,		 4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_prop_alloc_body_size
	{	 40,		 4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_prop_privacy_level
	{	 44,		 4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_prop_hash_algorithm
	{	 48,		 4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_prop_encryption_algorithm
	{	 52,		 4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_prop_extension_size
	{	 56,	VARIABLE,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_prop_label
	{VARIABLE,	VARIABLE,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_prop_extension
	{VARIABLE,	VARIABLE,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_prop_body
	
//offset length  indent level   attachment flags comment field
//====== ====== ==============  ================ =============
	// User: Debug section
	{	  0,	VARIABLE,	INDENT_LEVEL_1,	NO_ATTACH_FLAGS, true},	//db_debug_summary
	{	  0,		22,		INDENT_LEVEL_2,	NO_ATTACH_FLAGS, true},	//db_debug_desc
	{	  0,		 2,		INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_debug_flags
	{	  2,		 4,		INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_debug_reserved
	{	  6,	VARIABLE,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_debug_reportq_desc

//offset length  indent level   attachment flags comment field
//====== ====== ==============  ================ =============
	// Security section
	{	  0,		 0,	INDENT_LEVEL_1,	NO_ATTACH_FLAGS, true},	//db_sh_summary
	{	  0,		16,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, true},	//db_sh_desc
	{     0,		 2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_sh_flags
	{     2,		 2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_sh_sender_id_size
	{	  4,		 2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_sh_encrypted_key_size
	{	  6,		 2,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_sh_signature_size
	{	  8,		 4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_sh_sender_certificate_size
	{	 12,		 4,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_sh_provider_info_size
	{	 16,  VARIABLE,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_sh_sender_id
	{VARIABLE,VARIABLE,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_sh_encrypted_key
	{VARIABLE,VARIABLE,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_sh_signature
	{VARIABLE,VARIABLE,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_sh_certificate


//offset length  indent level   attachment flags comment field
//====== ====== ==============  ================ =============
	// Transaction section
	{	  0,	VARIABLE,			INDENT_LEVEL_1,	NO_ATTACH_FLAGS, true},	//db_xa_summary
	{	  0,	VARIABLE,			INDENT_LEVEL_2,	NO_ATTACH_FLAGS, true},	//db_xa_desc
	{	  0,	sizeof(ULONG),		INDENT_LEVEL_2,	NO_ATTACH_FLAGS, true},	//db_xa_flags
	{	  0,	sizeof(ULONG),		INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_xa_index
	{	  4,	sizeof(LONGLONG),	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_xa_sequence_id
	{	 12,	sizeof(ULONG),		INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_xa_sequence_number
	{	 16,	sizeof(ULONG),		INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_xa_previous_sequence_number
	{	 20,	VARIABLE,			INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_xa_connector_qm

//offset length  indent level   attachment flags comment field
//====== ====== ==============  ================ =============
	// Server Discovery
	{	  0,	VARIABLE,			INDENT_LEVEL_0,	NO_ATTACH_FLAGS, true},		//db_tph_summary
	{	  0,	sizeof(UCHAR),		INDENT_LEVEL_1,	NO_ATTACH_FLAGS, false},	//db_tph_version
	{	  1,	sizeof(UCHAR),		INDENT_LEVEL_1,	NO_ATTACH_FLAGS, false},	//db_tph_type
	{	  2,	sizeof(WORD),		INDENT_LEVEL_1,	NO_ATTACH_FLAGS, false},	//db_tph_reserved
	{	  4,	sizeof(GUID),		INDENT_LEVEL_1,	NO_ATTACH_FLAGS, false},	//db_tph_guid

//offset length  indent level   attachment flags comment field
//====== ====== ==============  ================ =============
	// Server Discovery
	{	  0,	VARIABLE,			INDENT_LEVEL_0,	NO_ATTACH_FLAGS, true},		//db_pp_summary
	{	  0,	sizeof(WORD),		INDENT_LEVEL_1,	NO_ATTACH_FLAGS, false},	//db_pp_flags
	{	  2,	sizeof(WORD),		INDENT_LEVEL_1,	NO_ATTACH_FLAGS, false},	//db_pp_signature
	{	  4,	sizeof(DWORD),		INDENT_LEVEL_1,	NO_ATTACH_FLAGS, false},	//db_pp_cookie
	{	  8,	sizeof(GUID),		INDENT_LEVEL_1,	NO_ATTACH_FLAGS, false},	//db_pp_guid

//offset length  indent level   attachment flags comment field
//====== ====== ==============  ================ =============
	// Utility
	{0,	VARIABLE,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_last_enum
	{0,	VARIABLE,	INDENT_LEVEL_2,	NO_ATTACH_FLAGS, false},	//db_fragmented_field
	{0,	VARIABLE,	INDENT_LEVEL_1,	NO_ATTACH_FLAGS, false}	//db_unparsable_field

};
#else
extern _FAL_FIELD_INFO falFieldInfo[];
#endif

#define FORMAT_BUFFER_SIZE 80
#define DB_BH_FLAGS_SIZE FORMAT_BUFFER_SIZE * dwfalBaseFlagsEntries
#define DB_CE_FLAGS_SIZE FORMAT_BUFFER_SIZE * dwfalEstablishConnectionFlagsEntries
#define FORMAT_BUFFER_SIZE_SID 128
#pragma warning(disable: 4244) //obscure conversion from 'unsigned long' to 'unsigned short' warning for calculated Format String Size 

#ifdef MAIN
PROPERTYINFO falcon_database[] = {
	//IMPORTANT: falcon_database[] order must match entry order in enumeration and falFieldInfo[]

    //-------------------------- Root MSMQ Summary -----------------
	//	 enumeration	  hProp	Ver	 Label Text		Status Bar Text	  Data Type			Data Qualifier	Data Structure		Format String Size	Formatting Routine
	//================    ===== === ============    ===============  ============		==============	==============		==================	==================
	{ /* db_summary_mult */	0,	0,	 "Frame Summary","Frame Summary",PROP_TYPE_SUMMARY,	PROP_QUAL_NONE,	0,					255,				format_falcon_summary_mult},
	{ /* db_summary_nonroot */0,0,	 "Message Summary","Message Summary",PROP_TYPE_STRING,	PROP_QUAL_NONE,	0,				255,				format_falcon_summary},
	{ /* db_summary */		0,	0,	 "Frame Summary","Frame Summary",PROP_TYPE_SUMMARY,	PROP_QUAL_NONE,	0,					255,				format_falcon_summary},

    //-------------------------- Base header -----------------------
	//	 enumeration	  hProp	Ver	 Label Text		Status Bar Text	  Data Type			Data Qualifier	Data Structure		Format String Size	Formatting Routine
	//================    ===== === ============    ===============  ============		==============	==============		==================	==================
   { /* db_bh_root */		0,	0,  "BH",			"Base Header",	PROP_TYPE_STRING,	PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
   { /* db_bh_desc*/		0,	0,  "-- Base Header --","Base Header",PROP_TYPE_VOID,	PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
   { /* db_bh_version */	0,	0,  "Protocol Version",	"Protocol Version",	PROP_TYPE_BYTE,	PROP_QUAL_LABELED_SET, &format_falBHVersion,FORMAT_BUFFER_SIZE, FormatPropertyInstance},
   { /* db_bh_reserved */	0,	0,  "BH Reserved ",	"BH Reserved",	PROP_TYPE_BYTE,		PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
   { /* db_bh_priority */	0,	0,	"Priority    ","Priority",		PROP_TYPE_WORD,		PROP_QUAL_LABELED_BITFIELD, &format_pri_types, FORMAT_BUFFER_SIZE, FormatPropertyInstance},
   { /* db_bh_flags */		0,	0,  "BH Flags",		"BH Flags",		PROP_TYPE_WORD,	    PROP_QUAL_FLAGS,&fmt_falBaseFlags,	FORMAT_BUFFER_SIZE*dwfalBaseFlagsEntries /*DB_BH_FLAGS_SIZE*/,	FormatPropertyInstance},
   { /* db_bh_signature */  0,  0,  "Signature   ",	"Signature",	PROP_TYPE_STRING,   PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
   { /* db_bh_size */		0,	0,  "Packet Size ",	"Packet Size",	PROP_TYPE_DWORD,    PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
   { /* db_bh_abs_ttq */	0,	0,	"Absolute TTQ",	"Absolute TTQ", PROP_TYPE_DWORD,	PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, format_milliseconds},

	//-------------------------- Internal header -------------------
	//	 enumeration	  hProp	Ver	 Label Text		Status Bar Text	  Data Type			Data Qualifier	Data Structure		Format String Size	Formatting Routine
	//================    ===== === ============    ===============  ============		==============	==============		==================	==================
	{ /* db_ih_root */		0,	0,  "IH",			"Internal Header",PROP_TYPE_STRING,	PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
    { /* db_ih_desc*/		0,	0,  "- Internal Header -","Internal Header",PROP_TYPE_VOID,	PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_ih_reserved */	0,	0,  "Reserved",		"Reserved",		PROP_TYPE_WORD,		PROP_QUAL_NONE,	0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance}, 
	{ /* db_ih_flags_pkt_type */0,0,"Packet Type",	"Packet Type",	PROP_TYPE_WORD,		PROP_QUAL_LABELED_BITFIELD,&format_falIHPacketType,FORMAT_BUFFER_SIZE * dwfalBaseFlagsEntries, FormatPropertyInstance},
	{ /* db_ih_flags_connection */0,0,"IH Conn Flags","Connection Flags",PROP_TYPE_WORD,	PROP_QUAL_FLAGS,&format_falIHConnection,FORMAT_BUFFER_SIZE * dwfalBaseFlagsEntries, FormatPropertyInstance},

	//-------------------------- Internal: Establish Connection -------------------
	//	 enumeration	  hProp	Ver	 Label Text		Status Bar Text	  Data Type			Data Qualifier	Data Structure		Format String Size	Formatting Routine
	//================    ===== === ============    ===============  ============		==============	==============		==================	==================
	{ /* db_ce_root */		0,	0,  "EC","Establish Connection",	PROP_TYPE_STRING,	PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
    { /* db_ce_desc*/		0,	0,  "- Establish Connection Header -","Establish Connection",PROP_TYPE_VOID,PROP_QUAL_NONE,0,FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_ce_client_qm */	0, 	0,  "Client QM",	"Client QM",	PROP_TYPE_VOID,		PROP_QUAL_NONE,	0,					FORMAT_BUFFER_SIZE, format_uuid}, 
	{ /* db_ce_server_qm */ 0,  0,  "Server QM",	"Server QM",	PROP_TYPE_VOID,		PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, format_uuid},
	{ /* db_ce_time_stamp*/	0,	0,  "Time Stamp",	"Time Stamp",	PROP_TYPE_BYTESWAPPED_DWORD,PROP_QUAL_NONE, 0,			FORMAT_BUFFER_SIZE, format_unix_time},
    { /* db_ce_version */	0,	0,  "EC Version",		"EC Version",		PROP_TYPE_WORD,		PROP_QUAL_LABELED_BITFIELD, &format_falECVersion,		FORMAT_BUFFER_SIZE, FormatPropertyInstance},
    { /* db_ce_flags */		0,	0,  "EC Flags",		"EC Flags",		PROP_TYPE_WORD,		PROP_QUAL_FLAGS,&fmt_falEstConnFlags,DB_BH_FLAGS_SIZE,  FormatPropertyInstance},
    { /* db_ce_reserved */	0,	0,  "EC Reserved",		"EC Reserved",		PROP_TYPE_VOID,		PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_ce_body */		0,	0,  "EC Body",			"EC Body",			PROP_TYPE_VOID,		PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},

	//-------------------------- Internal: Connection Parameters -------------------
	//	 enumeration				hProp Ver  Label Text	  Status Bar Text	Data Type		Data Qualifier	Data Structure		Format String Size	Formatting Routine
	//================				===== === ============    ===============  ============		==============	==============		==================	==================
	{ /* db_cp_root */				0,	0,  "CP","Connection Parameters",	PROP_TYPE_STRING,	PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE*2,FormatPropertyInstance},
    { /* db_cp_desc*/				0,	0,  "- Connection Parameters -","Connection Paramters",PROP_TYPE_VOID,PROP_QUAL_NONE,0,		FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_cp_recover_ack_timeout */0, 0,  "Recover ACK Timeout","Recover ACK Timeout",	PROP_TYPE_DWORD,	PROP_QUAL_NONE,	0,	FORMAT_BUFFER_SIZE, FormatPropertyInstance}, 
	{ /* db_cp_ack_timeout */		0,  0,  "ACK Timeout","ACK Timeout",	PROP_TYPE_DWORD,	PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_cp_segment_size*/		0,	0,  "Segment Size","Segment Size",	PROP_TYPE_WORD,		PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
    { /* db_cp_window_size*/		0,	0,  "Window Size","Window Size",	PROP_TYPE_WORD,		PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},

	//-------------------------- Internal: Session -------------------
	//	 enumeration				hProp Ver  Label Text	  Status Bar Text	Data Type		Data Qualifier	Data Structure		Format String Size	Formatting Routine
	//================				===== === ============    ===============  ============		==============	==============		==================	==================
	{ /* db_ss_root */				0,	0,  "SS",	"Session Section",		PROP_TYPE_STRING,	PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
    { /* db_ss_desc*/				0,	0,  "- Session Section -","Session Section",PROP_TYPE_VOID,PROP_QUAL_NONE,0,				FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_ss_ack_seq_num */		0,	0,  "ack_seq_num","ack_seq_num",	PROP_TYPE_WORD,		PROP_QUAL_NONE,	0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance}, 
	{ /* db_ss_ack_rcvr_num */		0,  0,  "ack_rcvr_num","ack_rcvr_num",	PROP_TYPE_WORD,		PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_ss_ack_rcvr_bf*/		0,	0,  "ack_rcvr_bf","ack_rcvr_bf",	PROP_TYPE_DWORD,	PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
    { /* db_ss_sync_ack_seq_num*/	0,	0,  "sync_ack_seq_num","sync_ack_seq_num",	PROP_TYPE_WORD,		PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_ss_sync_ack_rcvr_num*/	0,	0,  "sync_ack_rcvr_num","sync_ack_rcvr_num",PROP_TYPE_WORD,		PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
    { /* db_ss_window_size*/		0,	0,  "Window Size","Window Size",	PROP_TYPE_WORD,		PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_ss_window_priority*/	0,	0,  "Window Priority","Window Priority",PROP_TYPE_BYTE,		PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
    { /* db_ss_reserved*/			0,	0,  "SS Reserved","SS Reserved",	PROP_TYPE_BYTE,		PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},

	//-------------------------- User: Header -------------------
	//	 enumeration				hProp Ver  Label Text	  Status Bar Text	Data Type		Data Qualifier	Data Structure		Format String Size	Formatting Routine
	//================				===== === ============    ===============  ============		==============	==============		==================	==================
	{ /* db_uh_summary */			0,		0, "UH",			"User Header",	PROP_TYPE_STRING,PROP_QUAL_NONE,  0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
    { /* db_uh_desc*/				0,		0,  "-- User Header --","User Header",PROP_TYPE_VOID,PROP_QUAL_NONE,0,				FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_uh_source_qm */			0,		0, "Source QM ","Source QM ",		PROP_TYPE_VOID, PROP_QUAL_NONE,  0,					FORMAT_BUFFER_SIZE*2, format_uuid},
	{ /* db_uh_destination_qm, */	0,		0, "Dest QM   ","Dest QM   ",		PROP_TYPE_VOID, PROP_QUAL_NONE,  0,					FORMAT_BUFFER_SIZE*2, format_uuid},
	{ /* db_uh_time_to_live_delta */0,		0, "TTL Delta ","TTL Delta ",		PROP_TYPE_DWORD,PROP_QUAL_NONE,  0,					FORMAT_BUFFER_SIZE, format_milliseconds},
	{ /* db_uh_sent_time */			0,		0, "Sent Time ","Sent Time ",		PROP_TYPE_VOID, PROP_QUAL_NONE,  0,					FORMAT_BUFFER_SIZE, format_unix_time},
	{ /* db_uh_message_id */		0,		0, "Message ID","Message ID",		PROP_TYPE_DWORD,PROP_QUAL_NONE,  0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	// flags
	{ /* db_uh_hopcount */			0,		0, "hopcount",		" ",		    PROP_TYPE_DWORD, PROP_QUAL_LABELED_BITFIELD,  &format_uh_hopcount,FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_uh_delivery */			0,		0, "delivery",		"  ",		    PROP_TYPE_DWORD, PROP_QUAL_LABELED_BITFIELD,  &format_uh_delivery, FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_uh_routing */			0,		0, "routing",		"  ",		    PROP_TYPE_DWORD, PROP_QUAL_FLAGS,			  &format_uh_flags1, FORMAT_BUFFER_SIZE*uh_flags_entries1, FormatPropertyInstance},
	{ /* db_uh_auditing */			0,		0, "auditing",		"  ",		    PROP_TYPE_DWORD, PROP_QUAL_LABELED_BITFIELD,  &format_uh_auditing, FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_uh_dqt_type */			0,		0, "dqt_type",		"  ",			PROP_TYPE_DWORD, PROP_QUAL_LABELED_BITFIELD,  &format_uh_dqt,	FORMAT_BUFFER_SIZE*3, FormatPropertyInstance},
	{ /* db_uh_aqt_type */			0,		0, "aqt_type",		"  ",			PROP_TYPE_DWORD, PROP_QUAL_LABELED_BITFIELD,  &format_uh_aqt,	FORMAT_BUFFER_SIZE*3, FormatPropertyInstance},
	{ /* db_uh_rqt_type */			0,		0, "rqt_type",		"  ",			PROP_TYPE_DWORD, PROP_QUAL_LABELED_BITFIELD,  &format_uh_rqt, FORMAT_BUFFER_SIZE*3, FormatPropertyInstance},
	{ /* db_uh_security */			0,		0, "security",		"  ",			PROP_TYPE_DWORD, PROP_QUAL_FLAGS,  &format_uh_flags2,FORMAT_BUFFER_SIZE*uh_sections_entries, FormatPropertyInstance},

	//-------------------------- User: Queue Descriptors -------------------
	{ /* db_uh_dqt_desc */			0,		0, "Dest Queue Format Name     ","DQFN",PROP_TYPE_VOID, PROP_QUAL_NONE,  NULL,				FORMAT_BUFFER_SIZE*2, format_q_format},
	{ /* db_uh_aqt_desc */			0,		0, "Admin Queue Format Name    ","AQFN",PROP_TYPE_VOID, PROP_QUAL_NONE,  NULL,				FORMAT_BUFFER_SIZE*2, format_q_format},
	{ /* db_uh_rqt_desc */			0,		0, "Response Queue Format Name ","RQFN",PROP_TYPE_VOID, PROP_QUAL_NONE,  NULL,			    FORMAT_BUFFER_SIZE*2, format_q_format},

	//-------------------------- User: property section -------------------
	//	 enumeration				hProp Ver  Label Text	  Status Bar Text	 Data Type		Data Qualifier	Data Structure		Format String Size	Formatting Routine
	//================				===== === ============    ===============   ============	==============	==============		==================	==================
	{ /* db_prop_summary */			0,		0,   "PH","Property Header",		PROP_TYPE_STRING, PROP_QUAL_NONE, 0,				    FORMAT_BUFFER_SIZE, FormatPropertyInstance},
    { /* db_prop_desc*/				0,		0,  "-- Property Header --","Property Header",PROP_TYPE_VOID,PROP_QUAL_NONE,0,				FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_prop_ack_mode */		0,		0,   "Ack Mode","Ack Mode",		    PROP_TYPE_BYTE, PROP_QUAL_LABELED_BITFIELD, &format_ack_types, FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_prop_title_length */	0,		0,   "Title Length","Title Length", PROP_TYPE_BYTE, PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_prop_class */			0,		0,   "Class",	"Class",		    PROP_TYPE_WORD, PROP_QUAL_LABELED_SET, &format_class_types, FORMAT_BUFFER_SIZE,    FormatPropertyInstance},
	{ /* db_prop_correlation_id */  0,		0,   "Correlation ID","Correlation ID",PROP_TYPE_BYTE, PROP_QUAL_ARRAY,0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_prop_body_type */		0,		0,   "Body Type","Body Type",	    PROP_TYPE_DWORD,PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_prop_application_tag */ 0,		0,   "Application Tag","Application Tag", PROP_TYPE_DWORD,PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_prop_body_size */		0,		0,   "Body Size","Body Size",		PROP_TYPE_DWORD,PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_prop_alloc_body_size */ 0,		0,   "Alloc Body Size","Alloc Body Size",PROP_TYPE_DWORD,PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_prop_privacy_level */	0,		0,   "Privacy Level","Privacy Level",PROP_TYPE_DWORD,PROP_QUAL_LABELED_SET, &format_privacy_level, FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_prop_hash_algorithm */  0,		0,   "Hash Algorithm","Hash Algorithm",PROP_TYPE_DWORD,PROP_QUAL_LABELED_SET, &format_pps_security_algorithms, FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_prop_encryption_algorithm */0,	0,   "Encryption Alg","Encryption Alg",PROP_TYPE_DWORD,PROP_QUAL_LABELED_SET, &format_pps_security_algorithms, FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_prop_extension_size */  0,		0,   "Extension Size","Extension Size",PROP_TYPE_DWORD,PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_prop_label */			0,		0,   "Label","Label",			    PROP_TYPE_VOID, PROP_QUAL_NONE, 0,					MQ_MAX_MSG_LABEL_LEN, format_wstring},
	{ /* db_prop_extension */		0,		0,   "Extension","Extension",	    PROP_TYPE_BYTE, PROP_QUAL_ARRAY,0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_prop_body */			0,		0,   "Body",		"Body",		    PROP_TYPE_BYTE, PROP_QUAL_ARRAY,0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},


	//-------------------------- User: Debug Section -------------------
	//	 enumeration				hProp Ver  Label Text	  Status Bar Text	Data Type		Data Qualifier	Data Structure		Format String Size	Formatting Routine
	//================				===== === ============    ===============  ============		==============	==============		==================	==================
   { /* db_debug_summary */			0,		0,	"Debug Summary","Debug Summary",PROP_TYPE_VOID, PROP_QUAL_NONE, 0,				    FORMAT_BUFFER_SIZE, FormatPropertyInstance},
   { /* db_debug_desc*/				0,		0,  "-- Debug Header --","Property Header",PROP_TYPE_VOID,PROP_QUAL_NONE,0,				FORMAT_BUFFER_SIZE, FormatPropertyInstance},
   { /* db_debug_flags */			0,		0,	"Report Q Type","Report Q Type",PROP_TYPE_VOID, PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},//bugbug - eventually format as flags.
   { /* db_debug_reserved */		0,		0,  "DB Reserved","DB Reserved",    PROP_TYPE_WORD, PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
   { /* db_debug_reportq_desc */	0,		0,  "Report Q Desc","Report Q Desc",PROP_TYPE_VOID, PROP_QUAL_NONE, &format_db_queue_types,FORMAT_BUFFER_SIZE*2,format_q_format},

   
    //-------------------------- User: Security Section -------------------
	//	 enumeration				hProp Ver  Label Text	  Status Bar Text	Data Type		Data Qualifier	Data Structure		Format String Size	Formatting Routine
	//================				===== === ============    ===============  ============		==============	==============		==================	==================

   { /* db_sh_summary */			0,		0,   "SH","Security Header",	   PROP_TYPE_STRING,  PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
   { /* db_sh_desc*/				0,		0,  "-- Security Header --","Security Header",PROP_TYPE_VOID,PROP_QUAL_NONE,0,				FORMAT_BUFFER_SIZE, FormatPropertyInstance},
   { /* db_sh_flags */				0,		0,   "Flags",		"Flags",	   PROP_TYPE_WORD,  PROP_QUAL_FLAGS,&format_sh_flags,   FORMAT_BUFFER_SIZE*sh_flags_entries, FormatPropertyInstance},
   { /* db_sh_sender_id_size */		0,		0,   "Sender ID Size","Sender ID Size", PROP_TYPE_WORD,  PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
   { /* db_sh_encrypted_key_size */ 0,		0,   "Encrypted Key Size","Encrypted Key Size",PROP_TYPE_WORD,  PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_sh_signature_size */	0,		0,   "Signature Size","Signature Size",PROP_TYPE_WORD,  PROP_QUAL_NONE, 0,				    FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_sh_sender_certificate_size */0, 0,   "Sender Certificate Size","Sender Certificate Size",PROP_TYPE_DWORD,PROP_QUAL_NONE, 0,				    FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_sh_provider_info_size */0,		0,   "Provider Info Size","Provider Info Size",PROP_TYPE_DWORD, PROP_QUAL_NONE, 0,					FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_sh_sender_id */			0,		0,   "Sender ID (SID)","Sender ID (SID)",PROP_TYPE_VOID,	PROP_QUAL_NONE, 0,				    FORMAT_BUFFER_SIZE_SID, FormatPropertyInstance/*format_sender_id*/},
	{ /* db_sh_encrypted_key */		0,		0,   "Encrypted Key","Encrypted Key",PROP_TYPE_BYTE,  PROP_QUAL_ARRAY,0,				    FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_sh_signature */			0,		0,   "Signature","Signature",	   PROP_TYPE_BYTE,  PROP_QUAL_ARRAY,0,				    FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_sh_certificate */		0,		0,   "Certificate","Certificate",  PROP_TYPE_BYTE,  PROP_QUAL_ARRAY,0,				    FORMAT_BUFFER_SIZE, FormatPropertyInstance},


	//-------------------------- User: Transaction Section -------------------
	//	 enumeration				hProp Ver  Label Text	  Status Bar Text	Data Type		Data Qualifier	Data Structure		Format String Size	Formatting Routine
	//================				===== === ============    ===============  ============		==============	==============		==================	==================
	{ /* db_xa_summary */			0,		0, "XH","Transaction Header",	   PROP_TYPE_STRING,PROP_QUAL_NONE,    0,			    FORMAT_BUFFER_SIZE, FormatPropertyInstance},
    { /* db_xa_desc*/				0,		0,  "-- Transaction Header --","Transaction Header",PROP_TYPE_VOID,PROP_QUAL_NONE,0,	FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_xa_flags */				0,		0, "Flags",		"Flags",		   PROP_TYPE_DWORD, PROP_QUAL_FLAGS,&format_xa_flags,	FORMAT_BUFFER_SIZE*10, FormatPropertyInstance},
	{ /* db_xa_index */				0,		0, "Index",		"Index",		   PROP_TYPE_VOID, PROP_QUAL_NONE,	   0,			    FORMAT_BUFFER_SIZE, FormatPropertyInstance}, //bugbug - format_xa_index
	{ /* db_xa_sequence_id */		0,		0, "Sequence ID","Sequence ID",	   PROP_TYPE_WORD,  PROP_QUAL_NONE,    0,			    FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_xa_sequence_number */	0,		0, "Sequence Num","Sequence Num",  PROP_TYPE_DWORD, PROP_QUAL_NONE,	   0,			    FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_xa_previous_sequence_number */0,0, "Prev Seq Num","Prev Seq Num",  PROP_TYPE_DWORD, PROP_QUAL_NONE,	   0,			    FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_xa_connector_qm */		0,		0, "Connector QM","Connector QM",  PROP_TYPE_VOID,  PROP_QUAL_NONE,    0,			    FORMAT_BUFFER_SIZE, format_uuid},

	//-------------------------- Internal: Topology Packet (Server Discovery) -------------------
	//	 enumeration				hProp Ver  Label Text	  Status Bar Text	Data Type		Data Qualifier	Data Structure		Format String Size	Formatting Routine
	//================				===== === ============    ===============  ============		==============	==============		==================	==================
	{ /* db_tph_summary */			0,		0, "Server Discovery","Server Discovery",PROP_TYPE_SUMMARY, PROP_QUAL_NONE,    0,		FORMAT_BUFFER_SIZE, format_server_discovery},
    { /* db_tph_version*/			0,		0, "Version",		"Version",	   PROP_TYPE_BYTE,	PROP_QUAL_NONE,		0,				FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_tph_type */				0,		0, "Type",			"Type",		   PROP_TYPE_BYTE, PROP_QUAL_NONE,		0,				FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_tph_reserved */			0,		0, "Reserved",		"Reserved",	   PROP_TYPE_WORD, PROP_QUAL_NONE,	   0,			    FORMAT_BUFFER_SIZE, FormatPropertyInstance}, 
	{ /* db_tph_guid */				0,		0, "QM GUID",		"QM GUID",	   PROP_TYPE_VOID,  PROP_QUAL_NONE,    0,			    FORMAT_BUFFER_SIZE, FormatPropertyInstance},

	//-------------------------- Internal: Ping Packet -------------------
	//	 enumeration				hProp Ver  Label Text	  Status Bar Text	Data Type		Data Qualifier	Data Structure		Format String Size	Formatting Routine
	//================				===== === ============    ===============  ============		==============	==============		==================	==================
	{ /* db_pp_summary */			0,		0, "Ping",			"Ping",			PROP_TYPE_SUMMARY, PROP_QUAL_NONE,  0,				FORMAT_BUFFER_SIZE, format_server_ping},
    { /* db_pp_flags*/				0,		0, "Flags",			"Flags",	   PROP_TYPE_WORD,	PROP_QUAL_FLAGS, &format_falPingFlags, FORMAT_BUFFER_SIZE*10, FormatPropertyInstance},
	{ /* db_pp_signature */			0,		0, "Signature",		"Signature",   PROP_TYPE_STRING,PROP_QUAL_NONE,		0,				FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_pp_cookie */			0,		0, "Cookie",		"Cookie",	   PROP_TYPE_DWORD, PROP_QUAL_NONE,	    0,			    FORMAT_BUFFER_SIZE, FormatPropertyInstance}, 
	{ /* db_pp_guid */				0,		0, "QM GUID",		"QM GUID",	   PROP_TYPE_VOID,  PROP_QUAL_NONE,		0,			    FORMAT_BUFFER_SIZE, FormatPropertyInstance},

	
	//-------------------------- Utility Enumerations Section -------------------
	{ /* db_last_enum */			0,		0, "Last Enum",	"Last Enum",	   PROP_TYPE_VOID,  PROP_QUAL_NONE,    0,			    FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_fragmented_field */		0,		0, "Fragmented Field","Fragmented Field",PROP_TYPE_VOID,  PROP_QUAL_NONE,    0,				FORMAT_BUFFER_SIZE, FormatPropertyInstance},
	{ /* db_unparsable_field */		0,		0, "Unparsable","Unparsable",	   PROP_TYPE_VOID,  PROP_QUAL_NONE,    0,				FORMAT_BUFFER_SIZE, FormatPropertyInstance}

};  //End Falcon database
#else
extern PROPERTYINFO falcon_database[];
#endif

//falcon database
#ifdef MAIN
DWORD dwfalPropertyCount = ((sizeof falcon_database) / PROPERTYINFO_SIZE);
#else
extern DWORD dwfalPropertyCount;
#endif
#pragma warning(default: 4244) //re-enable warning for calculated Format String Size - conversion from 'unsigned long' to 'unsigned short'
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\nmparser\nmmsmq.cpp ===
//=============================================================================
//  
//  MODULE: nmmsmq.cxx modified from sample: RemAPI.c
//
//  Description:
//
//  Bloodhound Parser DLL for MS Message Queue
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created RemAPi.c
//  Shaharf				28-jan-96		created content based on the smb sample.
//  shaharf				19-jan-97		modified for Falcon beta-2
//  Andrew Smith		07/28/97		Extracted portions and modified for Beta 2E
//=============================================================================
#include "stdafx.h"

#include <wincrypt.h>
#include <mq.h>
//#include <mqcrypt.h>
#define MAIN
#include "nmmsmq.h"
#include "falconDB.h"

/* Falcon headers */
#define private public
	#include <ph.h>
	#include <phintr.h>
	#include <mqformat.h>
#undef private

#include "resource.h"

#ifndef _TRACKER_
	#include "tracker.h"
#endif

#ifndef _UTILITIES_
	#include "utilities.h"
#endif

#ifndef _ATTACHFALCON_
	#include "AttachFalcon.h"
#endif


//
//  Globals
//
HPROTOCOL hfal = NULL;
DWORD Attached = 0;
USHORT g_uMasterIndentLevel=0;

//
//  Protocol entry points.
//
VOID   WINAPI falRegister(HPROTOCOL);
VOID   WINAPI falDeregister(HPROTOCOL);
LPBYTE WINAPI falRecognizeFrame(HFRAME, LPBYTE, LPBYTE, DWORD, DWORD, HPROTOCOL, DWORD, LPDWORD, LPHPROTOCOL, LPDWORD);
LPBYTE WINAPI falAttachProperties(HFRAME, LPBYTE, LPBYTE, DWORD, DWORD, HPROTOCOL, DWORD, DWORD);
DWORD  WINAPI falFormatProperties(HFRAME, LPBYTE, LPBYTE, DWORD, LPPROPERTYINST);
PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo();

ENTRYPOINTS falEntryPoints =
{
    falRegister,
    falDeregister,
    falRecognizeFrame,
    falAttachProperties,
    falFormatProperties,
	//ParserAutoInstallInfo - todo - see the the docs explains not to do this.
};


BOOL 
WINAPI 
DllMain(
	HANDLE hInstance, 
	ULONG Command, 
	LPVOID Reserved
	)
/************************************************************

  Routine Description:
	Entry Point for the Parser. Netmon loads the DLL when 
	a capture is opened

  Arguments:
	
  Return Value:
	Bloodhound parsers ALWAYS return TRUE.

************************************************************/
{
    //
    //  If we are loading!
    //
    if ( Command == DLL_PROCESS_ATTACH )
    {
        if ( Attached++ == 0 )
        {
            hfal = CreateProtocol("MSMQ", &falEntryPoints, ENTRYPOINTS_SIZE);
			#ifdef DEBUG
				OutputDebugString(L"DllMain - Protocol created\n");
			#endif
        }
    }

    //
    //  If we are unloading!
    //
    if ( Command == DLL_PROCESS_DETACH )
    {
        if ( --Attached == 0 )
        {
            DestroyProtocol(hfal);
			#ifdef DEBUG
				OutputDebugString(L"DllMain - Protocol destroyed\n");
			#endif
        }
    }
    return TRUE;                    //... Bloodhound parsers ALWAYS return TRUE.
}


//=============================================================================
//  FUNCTION: falRegister()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//=============================================================================
VOID 
WINAPI 
falRegister(HPROTOCOL hfalProtocol)
{
	//
    //  Create the property database.
    //
    DWORD dwResult = CreatePropertyDatabase(hfalProtocol, dwfalPropertyCount);
    DWORD i = 0;
    for(i = 0; i < dwfalPropertyCount; ++i)
    {
	    AddProperty(hfalProtocol, &falcon_database[i]);
    }
	#ifdef DEBUG
		OutputDebugString(L"falRegister - Property database created\n");
	#endif
}

//=============================================================================
//  FUNCTION: Deregister()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//=============================================================================
VOID WINAPI falDeregister(HPROTOCOL hfalProtocol)
{
    DestroyPropertyDatabase(hfalProtocol);

	#ifdef DEBUG
		OutputDebugString(L"falDeregister - Property database destroyed.\n");
	#endif
}


//=============================================================================
//  FUNCTION: falAttachProperties()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//  Shaharf				28-jan-96		created content based on the smb sample.
//  shaharf				19-jan-97		modified for Falcon beta-2
//  Andrew Smith		07/28/97		Extracted portions and modified for Beta 2E
//=============================================================================
LPBYTE 
WINAPI 
falAttachProperties(
	HFRAME    hFrame,
	LPBYTE    Frame,
	LPBYTE    falFrame,
	DWORD     MacType,
	DWORD     BytesLeft,
	HPROTOCOL hPreviousProtocol,
	DWORD     nPreviousProtocolOffset,
	DWORD     InstData
	)
{

	#ifdef DEBUG
	DWORD dwNetmonFrameNumber = GetFrameNumber(hFrame);
	{
		WCHAR szDebugString[MAX_DEBUG_STRING_SIZE];
		wsprintf(szDebugString, L"falAttachProperties - Frame %d \n", dwNetmonFrameNumber);
		OutputDebugString(szDebugString);
	}
	#endif

	//
	// See if this is MSMQ traffic. Currently this should always be the case since we
	// are in the handoffset only for tcp/ip. However if we become a member of a follwset
	// for another protocol, we may get called with a non-MSMQ frame just to see if we recognize it.
	// bugbug - this should actually happen in falRecognizeFrame. Confirm and delete the exit clause.
	//
	LPPROTOCOLINFO lpPreviousProtocolInfo = GetProtocolInfo(hPreviousProtocol);
	int iResult = strcmp((const char *)lpPreviousProtocolInfo->ProtocolName, "UDP");
	bool bServerDiscoveryPacket = (iResult == 0);

 	USHORT usDestPort = usGetTCPDestPort(Frame, nPreviousProtocolOffset);
	USHORT usThisSourcePort = usGetTCPSourcePort(Frame, nPreviousProtocolOffset);
	USHORT usMQPort = usGetMQPort(usDestPort, usThisSourcePort);
	if ( usMQPort == NULL)
	{
		//
		// This should never execute - non-falcon traffic made it through the
		// Recognize filter.
		// 
		// todo - Assert here
		//
		return NULL;
	}

	g_uMasterIndentLevel=0;
	switch(usMQPort) 
	{
		case 1801:
			{
				//
				// internal and user packets
				//
				MQHEADER mqhHeader; 
				BOOL	 bHeaderCompleted;
				CMessage mn;
				mn.Clear(falFrame);
				CFrame fc;
				fc.CreateFrom(hFrame, falFrame, BytesLeft, usThisSourcePort, &mn);

				if(bServerDiscoveryPacket)
				{
					AttachServerDiscovery(&fc, &mn);
					mqhHeader = no_header;
					break;
				}

				char szSummary[FRAME_SUMMARY_LENGTH];
				if(fc.bMultipleMessages) {
					//
					// Adjust indent levels.
					//
					sprintf (szSummary, "Multiple Messages");
					AttachSummary(hFrame, falFrame, db_summary_mult, szSummary, BytesLeft);
					g_uMasterIndentLevel = 1;
				}
				mqhHeader = mn.mqhGetNextHeader();
				while(fc.dwBytesLeft > 0) 
				{ 
					if(fc.bMultipleMessages)
					{
						//
						// Attach a dummy message summary below the frame summary - It will be populated later
						//
						sprintf (szSummary, "Message Summary in Multiple Message Frame");
						AttachSummary(hFrame, (LPBYTE) mn.pbh, db_summary_nonroot, szSummary, mn.ulGetTotalBytes());
					}
					else
					{
						//
						// Single message frame. Attach a dummy message summary as the frame summary property 
						// It will be populated later
						//
						sprintf (szSummary, "Message Summary in Single Message Frame");
						AttachSummary(hFrame, (LPBYTE) mn.pbh, db_summary_root, szSummary, mn.ulGetTotalBytes());
					}
					while(mqhHeader && fc.dwBytesLeft > 0)
					{	
						switch(mqhHeader) 
						{
						case base_header:
							bHeaderCompleted = AttachBaseHeader(&fc, &mn);
							break;
						case internal_header:
							bHeaderCompleted = AttachInternalHeader(&fc, &mn);
							break;
		
						case cp_section:
							bHeaderCompleted = AttachCPSection(&fc, &mn);
							break;
					
						case ec_section:
							bHeaderCompleted = AttachECSection(&fc, &mn);
							break;
					
						case user_header:
							bHeaderCompleted = AttachUserHeader(&fc, &mn);
							break;
					
						case xact_header:
							bHeaderCompleted = AttachXactHeader(&fc, &mn);
							break;
					
						case security_header:
							bHeaderCompleted = AttachSecurityHeader(&fc, &mn);
							break;
					
						case property_header:
							bHeaderCompleted = AttachPropertyHeader(&fc, &mn);
							break;
					
						case debug_header:
							//todo
							//bHeaderCompleted = AttachDebugHeader(&fc, &mn);
							bHeaderCompleted = TRUE;
							break;
						case session_header:
							bHeaderCompleted = AttachSessionHeader(&fc, &mn);
							break;
						default:
							//
							// unknown header  -- mark as unparsable and fail the rest of the parse for the frame
							// 
							AttachAsUnparsable(fc.hFrame, fc.packet_pos, fc.dwBytesLeft);
							fc.Accrue(fc.dwBytesLeft);
							bHeaderCompleted = FALSE;
						}//switch
						if(bHeaderCompleted) 
						{
							mn.SetHeaderCompleted(mqhHeader);
							mqhHeader = mn.mqhGetNextHeader();
						}
						else
						{
							//
							// bugbug test fix - is this the right place to check?
							// bytes left is less than header size
							// header will fail, but bytes not accrued
							//
							AttachAsUnparsable(fc.hFrame, fc.packet_pos, fc.dwBytesLeft);
							fc.Accrue(fc.dwBytesLeft);
						}
					}//while (mqheader && BytesLeft)
					if (fc.dwBytesLeft > 0)	
					{
						//
						// reset the Message structure - we have multiple MSMQ packets in this frame
						//
						mn.Clear(fc.packet_pos);
						mqhHeader = mn.mqhGetNextHeader();
					}
				}//while (BytesLeft)
			}//case

			break; //end 1801

		case 2101:
			//
			// MQIS traffic (future)
			//
			break;
		case 2103:
		case 2105:
			//
			//Remote Read and DC traffic  (future)
			//
			break;
		case 3527:
			//
			// Ping Packet
			//
			AttachServerPing(hFrame, falFrame, BytesLeft, (usDestPort==3527)); 
			break;
		default:
			break;
	}//switch

	#ifdef DEBUG 
		OutputDebugString(L"   Exiting falAttachProperties. \n");
	#endif

	return (NULL);
}//falAttachProperties


//==============================================================================
//  FUNCTION: falFormatProperties()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//==============================================================================

DWORD 
WINAPI 
falFormatProperties(
	HFRAME         hFrame,
    LPBYTE         MacFrame,
    LPBYTE         FrameData,
    DWORD          nPropertyInsts,
    LPPROPERTYINST p
	)
{
    //=========================================================================
    //  Format each property in the property instance table.
    //
    //  The property-specific instance data was used to store the address of a
    //  property-specific formatting function so all we do here is call each
    //  function via the instance data pointer.
    //=========================================================================
	#ifdef DEBUG
		DWORD dw = nPropertyInsts;
		{
		WCHAR szDebugString[MAX_DEBUG_STRING_SIZE];
		wsprintf(szDebugString, L"falFormatProperties - Frame %d. \n", GetFrameNumber(hFrame));
		OutputDebugString(szDebugString);
		}
	#endif

    while (nPropertyInsts--)
    {
		((FORMAT) p->lpPropertyInfo->InstanceData)(p);
        p++;
    }
	#ifdef DEBUG
		{
		WCHAR szDebugString[MAX_DEBUG_STRING_SIZE];
		wsprintf(szDebugString, L"falFormatProperties - Frame %d: %d properties formatted. Exiting\n",GetFrameNumber(hFrame), dw);
		OutputDebugString(szDebugString);
		}
	#endif

    return NMERR_SUCCESS;
}


PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo() 
{
  //
  // Allocate memory for PF_PARSERDLLINFO structure.
  //
  PPF_PARSERDLLINFO pParserDllInfo; 
  PPF_PARSERINFO    pParserInfo;
  // stevenel - unreferenced - DWORD NumProtocols;
  int NumParsers = 1;
  
  pParserDllInfo = (PPF_PARSERDLLINFO)HeapAlloc( GetProcessHeap(),
                                                 HEAP_ZERO_MEMORY,
                                                 sizeof( PF_PARSERDLLINFO ) +
                                                 NumParsers * sizeof( PF_PARSERINFO) );
  if( pParserDllInfo == NULL)
  {
    return NULL;
  }
  
    
  //
  // Specify the number of parsers in the DLL.
  //
  pParserDllInfo->nParsers = NumParsers;

  // 
  // Specify the name, comment, and Help file for each protocol
  // 
  pParserInfo = &(pParserDllInfo->ParserInfo[0]);
  sprintf( pParserInfo->szProtocolName, "MSMQ" );
  sprintf( pParserInfo->szComment,      "Message Queuing" );
  sprintf( pParserInfo->szHelpFile,     "");
  
  //
  // Specify preceding protocols.
  //
  PPF_HANDOFFSET    pHandoffSet;
  PPF_HANDOFFENTRY  pHandoffEntry;
  
  //
  // Allocate PF_HANDOFFSET structure.
  //
  int NumHandoffs = 3;                   
  pHandoffSet = (PPF_HANDOFFSET)HeapAlloc( GetProcessHeap(),
                                           HEAP_ZERO_MEMORY,
                                           sizeof( PF_HANDOFFSET ) +
                                           NumHandoffs * sizeof( PF_HANDOFFENTRY) );
  if( pHandoffSet == NULL )
  {
     return pParserDllInfo;
  }

  //
  // Fill in handoff set
  //
  pParserInfo->pWhoHandsOffToMe = pHandoffSet;
  pHandoffSet->nEntries = NumHandoffs;

  // TCP PORT 1801 - Message traffic
  pHandoffEntry = &(pHandoffSet->Entry[0]);
  sprintf( pHandoffEntry->szIniFile,    "TCPIP.INI" );
  sprintf( pHandoffEntry->szIniSection, "TCP_HandoffSet" );
  sprintf( pHandoffEntry->szProtocol,   "MSMQ" );
  pHandoffEntry->dwHandOffValue =        1801;
  pHandoffEntry->ValueFormatBase =       HANDOFF_VALUE_FORMAT_BASE_DECIMAL;    

  // UDP PORT 1801 - Server discovery
  pHandoffEntry = &(pHandoffSet->Entry[1]);
  sprintf( pHandoffEntry->szIniFile,    "TCPIP.INI" );
  sprintf( pHandoffEntry->szIniSection, "UDP_HandoffSet" );
  sprintf( pHandoffEntry->szProtocol,   "MSMQ" );
  pHandoffEntry->dwHandOffValue =        1801;
  pHandoffEntry->ValueFormatBase =       HANDOFF_VALUE_FORMAT_BASE_DECIMAL;    

  // UDP PORT 3527 - Ping
  pHandoffEntry = &(pHandoffSet->Entry[2]);
  sprintf( pHandoffEntry->szIniFile,    "TCPIP.INI" );
  sprintf( pHandoffEntry->szIniSection, "UDP_HandoffSet" );
  sprintf( pHandoffEntry->szProtocol,   "MSMQ" );
  pHandoffEntry->dwHandOffValue =        3527;
  pHandoffEntry->ValueFormatBase =       HANDOFF_VALUE_FORMAT_BASE_DECIMAL;    

  //
  // Specify following protocols.
  //
  PPF_FOLLOWSET     pFollowSet;
 
  // Allocate PF_FOLLOWSET structure
  int NumFollows = 0;
  pFollowSet = NULL;
  return pParserDllInfo;

}
 


//=============================================================================
//  FUNCTION: falRecognizeFrame()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//=============================================================================
LPBYTE 
WINAPI 
falRecognizeFrame(
	HFRAME          hFrame,                     //... frame handle.
    LPBYTE          MacFrame,                   //... Frame pointer.
    LPBYTE          falFrame,                   //... Relative pointer.
    DWORD           MacType,                    //... MAC type.
    DWORD           BytesLeft,                  //... Bytes left.
    HPROTOCOL       hPreviousProtocol,          //... Previous protocol or NULL if none.
    DWORD           nPreviousProtocolOffset,    //... Offset of previous protocol.
    LPDWORD         ProtocolStatusCode,         //... Pointer to return status code in.
    LPHPROTOCOL     hNextProtocol,              //... Next protocol to call (optional).
    LPDWORD         InstData					//... Next protocol instance data.
	)
{
	#ifdef DEBUG
		OutputDebugString(L"\nfalRecognizeFrame ... ");
	#endif

	enum MQPortType MQPort = GetMQPort(hFrame, hPreviousProtocol, MacFrame);
	switch (MQPort) 
	{
	case eFalconPort:
		//
		// Test for Base Header
		//
		// bugbug - assuming best-case packet 
		//			commenting out this assumption blocks following protocols
		// todo   - determine if another protocol follows us. 
		//			for now, just claim the whole packet.
		//
		//CBaseHeader UNALIGNED *bh = (CBaseHeader*) pfc->packet_pos;
		//if ((bh->GetVersion() == FALCON_PACKET_VERSION) && (bh->SignatureIsValid())) 
		//{
			//
			// Claim this portion of the frame. Move pointer to end of known portion.
			//
		//	if (BytesLeft > bh->GetPacketSize())
		//	{
		//		*ProtocolStatusCode = PROTOCOL_STATUS_RECOGNIZED;
		//		falFrame += bh->GetPacketSize();
		//	}
		//	else  //end of the frame or partial MSMQ packet -- claim it all
			*ProtocolStatusCode = PROTOCOL_STATUS_CLAIMED;

			#ifdef DEBUG 
			{
				WCHAR szDebugString[MAX_DEBUG_STRING_SIZE];
 				wsprintf(szDebugString, L"   Frame %d recognized as Falcon message.", GetFrameNumber(hFrame));
				OutputDebugString(szDebugString);
			}
			#endif
	//	}
	//	else
	//		*ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
			
		break;

	case eMQISPort:
		//future
		*ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
		break;

	case eRemoteReadPort:
		//future
		*ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
		break;

	case eDependentClientPort:
		//future
		*ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
		break;
	
	case eServerDiscoveryPort:
		//future
		*ProtocolStatusCode = PROTOCOL_STATUS_CLAIMED;
		break;

	case eServerPingPort:
		//future
		*ProtocolStatusCode = PROTOCOL_STATUS_CLAIMED;
		break;

	default:
		*ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
		break;
	} //switch

#ifdef DEBUG 
		OutputDebugString(L"   Exiting falRecognizeFrame. \n"); 
#endif
    return NULL;
}//falRecognizeFrame
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\nmparser\nmmqis.h ===
#ifndef _NMMQIS_
	#define _NMMQIS_
#endif

char *mqis_server_calls[] =
    {
    "CreateObject",
    "DeleteObject",
    "GetProps",
    "SetProps",
    "GetObjectSecurity",
    "SetObjectSecurity",
    "LookupBegin",
    "LookupNext",
    "LookupEnd",
    "Flush",
    "DeleteObjectGuid",
    "GetPropsGuid",
    "SetPropsGuid",
    "GetObjectSecurityGuid",
    "SetObjectSecurityGuid",
    "DemoteStopWrite",
    "DemotePSC",
    "CheckDemotedPSC",
    "GetUserParams",
    "QMSetMachineProperties",
    "CreateServersCache",
    "QMGetObjectSecurity",
    "ValidateServer",
    "CloseServerHandle",
    "MQISStats",
    "DisableWriteOperations",
    "EnableWriteOperations",
    "GetServerPort"
    };

char *mqis_client_calls[3] =
    {
    "QMSetMachinePropertiesSignProc",
    "QMGetObjectSecurityChallengeResponceProc",
    "InitSecCtx"
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\nmparser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nmmsmq.rc
//
#define IDS_PROP 1
#define IDS_PROP_LAST 1
#define IDS_PROP_SUMMARY                1

#define IDS_PROP_BH 10
#define IDS_PROP_BH_LAST 17
#define IDS_PROP_BH_SUMMARY             10
#define IDS_PROP_BH_VERSION             11
#define IDS_PROP_BH_FLAGS               12
#define IDS_PROP_BH_FLAGS2              13
#define IDS_PROP_BH_FLAGS3              14
#define IDS_PROP_BH_PRIORITY            15
#define IDS_PROP_BH_SIZE                16
#define IDS_PROP_BH_TIME_TO_QUEUE       17

#define IDS_PROP_UH 120
#define IDS_PROP_UH_LAST 134
#define IDS_PROP_UH_SUMMARY             120
#define IDS_PROP_UH_SOURCE_QM           121
#define IDS_PROP_UH_DESTINATION_QM      122
#define IDS_PROP_UH_TIME_TO_LIVE_DELTA  123
#define IDS_PROP_UH_SENT_TIME           124
#define IDS_PROP_UH_MESSAGE_ID          125
#define IDS_PROP_UH_HOPCOUNT            126
#define IDS_PROP_UH_DELIVERY            127
#define IDS_PROP_UH_FLAGS               128
#define IDS_PROP_UH_AUDITING            129
#define IDS_PROP_UH_FLAGS2              130
#define IDS_PROP_UH_DESTINATION_QUEUE   131
#define IDS_PROP_UH_ADMIN_QUEUE         132
#define IDS_PROP_UH_RESPONSE_QUEUE      133
#define IDS_PROP_UH_CONNECTOR_TYPE          134

#define IDS_PROP_PS 40
#define IDS_PROP_PS_LAST 53
#define IDS_PROP_PS_SUMMARY 			40
#define IDS_PROP_PS_ACK_MODE 			41
#define IDS_PROP_PS_MESSAGE_CLASS 		42
#define IDS_PROP_PS_CORRELATION_ID 		43
#define IDS_PROP_PS_APPLICATION_TAG 		44
#define IDS_PROP_PS_BODY_SIZE 			45
#define IDS_PROP_PS_ALLOCATED_BODY_SIZE 	46
#define IDS_PROP_PS_PRIVACY_LEVEL 		47
#define IDS_PROP_PS_HASH_ALGORITHM 		48
#define IDS_PROP_PS_ENCRYPTION_ALGORITHM	49
#define IDS_PROP_PS_EXTENSION_SIZE 		50
#define IDS_PROP_PS_LABEL 			51
#define IDS_PROP_PS_EXTENSION 			52
#define IDS_PROP_PS_BODY			53

#define IDS_PROP_DEBUG                  60
#define IDS_PROP_DEBUG_LAST             61
#define IDS_PROP_DEBUG_SUMMARY          60
#define IDS_PROP_DEBUG_REPORT_QUEUE     61

#define IDS_PROP_SS                     80
#define IDS_PROP_SS_LAST                87
#define IDS_PROP_SS_SUMMARY             80
#define IDS_PROP_SS_ACK_SN              81
#define IDS_PROP_SS_ACK_RN              82
#define IDS_PROP_SS_STORAGE_BITS        83
#define IDS_PROP_SS_SYNC_ACK_SN         84
#define IDS_PROP_SS_SYNC_ACK_RN         85
#define IDS_PROP_SS_WINDOW_SIZE         86
#define IDS_PROP_SS_WINDOW_PRIORITY     87

#define IDS_PROP_SECURITY               	100
#define IDS_PROP_SECURITY_LAST        		110
#define IDS_PROP_SECURITY_SUMMARY       	100
#define IDS_PROP_SECURITY_FLAGS		     	101
#define IDS_PROP_SECURITY_SENDER_ID_SIZE     	102
#define IDS_PROP_SECURITY_ENCRYPTED_KEY_SIZE 	103
#define IDS_PROP_SECURITY_SIGNATURE_SIZE     	104
#define IDS_PROP_SECURITY_SENDER_CERTIFICATE_SIZE	105
#define IDS_PROP_SECURITY_PROVIDER_INFO_SIZE	106
#define IDS_PROP_SECURITY_SENDER_ID     	107
#define IDS_PROP_SECURITY_ENCRYPTED_KEY 	108
#define IDS_PROP_SECURITY_SIGNATURE     	109
#define IDS_PROP_SECURITY_CERTIFICATE		110

#define IDS_PROP_XA                          	150
#define IDS_PROP_XA_LAST                     	154
#define IDS_PROP_XA_SUMMARY			150
#define IDS_PROP_XA_SEQUENCE_ID              	151
#define IDS_PROP_XA_SEQUENCE_NUMBER          	152
#define IDS_PROP_XA_PREVIOUS_SEQUENCE_NUMBER 	153
#define IDS_PROP_XA_CONNECTOR_QM             	154

#define IDS_PROP_INT			170
#define IDS_PROP_INT_LAST		171	
#define IDS_PROP_INT_SUMMARY		170
#define IDS_PROP_INT_FLAGS		171	

#define IDS_PROP_CE			180
#define IDS_PROP_CE_LAST		183
#define IDS_PROP_CE_SUMMARY		180
#define IDS_PROP_CE_CLIENT_QM		181
#define IDS_PROP_CE_SERVER_QM		182
#define IDS_PROP_CE_TIME_STAMP		183

#define IDS_PROP_CP			190
#define IDS_PROP_CP_LAST		194
#define IDS_PROP_CP_SUMMARY		190
#define IDS_PROP_CP_RECOVER_ACK_TIMEOUT	191
#define IDS_PROP_CP_ACK_TIMEOUT		192
#define IDS_PROP_CP_SEGMENT_SIZE	193
#define IDS_PROP_CP_WINDOW_SIZE		194

#define IDS_BH_FLAGS1 1000
#define IDS_BH_FLAGS1_PACKET_TYPE_OFF   1000
#define IDS_BH_FLAGS1_PACKET_TYPE_ON    1001
#define IDS_BH_FLAGS1_IS_SESSION_OFF    1002
#define IDS_BH_FLAGS1_IS_SESSION_ON     1003
#define IDS_BH_FLAGS1_IS_DEBUG_OFF      1004
#define IDS_BH_FLAGS1_IS_DEBUG_ON       1005
#define IDS_BH_FLAGS1_IS_IMMEDIATE_ACK_OFF 1006
#define IDS_BH_FLAGS1_IS_IMMEDIATE_ACK_ON 1007
#define IDS_BH_FLAGS1_IS_DUPLICATED_OFF 1008
#define IDS_BH_FLAGS1_IS_DUPLICATED_ON  1009
                    
#define IDS_BH_FLAGS 1100                
#define IDS_BH_FLAGS_TRACE_NONE         1100
#define IDS_BH_FLAGS_TRACE_REPORT       1101
                     
#define IDS_BH_FLAGS2 1110               
#define IDS_BH_FLAGS2_IS_FRAGMENTED_OFF 1110
#define IDS_BH_FLAGS2_IS_FRAGMENTED_ON  1111
                          
#define IDS_UH_FLAGS1 1120
#define IDS_UH_FLAGS1_ONLINE_ROUTING_OFF 1120
#define IDS_UH_FLAGS1_ONLINE_ROUTING_ON  1121
                          
#define IDS_UH_FLAGS2 1200
#define IDS_UH_FLAGS2_IS_SECURITY_OFF    1200
#define IDS_UH_FLAGS2_IS_SECURITY_ON     1201
#define IDS_UH_FLAGS2_IS_TRANSACTION_OFF 1202
#define IDS_UH_FLAGS2_IS_TRANSACTION_ON  1203
#define IDS_UH_FLAGS2_IS_PROPERTY_OFF    1204
#define IDS_UH_FLAGS2_IS_PROPERTY_ON     1205
                     
#define IDS_UH_DELIVERY 1220
#define IDS_UH_DELIVERY_EXPRESS         1220
#define IDS_UH_DELIVERY_RECOVERBLE      1221
                       
#define IDS_UH_AUDIT 1230
#define IDS_UH_AUDIT_NONE               1230
#define IDS_UH_AUDIT_DEADLETTER         1231
#define IDS_UH_AUDIT_JOURNAL            1232
                    
#define IDS_UH_ACK 1260
#define IDS_UH_ACK_NONE                 1260
#define IDS_UH_ACK_NEGATIVE             1261
#define IDS_UH_ACK_FULL                 1262
                                    
#define IDS_UH_CLASS 1270
#define IDS_UH_CLASS_NORMAL             1270
#define IDS_UH_CLASS_ARRIVE             1271
#define IDS_UH_CLASS_READRECEIPT        1272
#define IDS_UH_CLASS_REPORT             1273
#define IDS_UH_CLASS_NACK               1274
#define IDS_UH_CLASS_NACK_BAD_DESTINATION 1275
#define IDS_UH_CLASS_NACK_RECEIVE_TIMEOUT 1276
#define IDS_UH_CLASS_NACK_REACH_QUEUE_TIMEOUT 1277
#define IDS_UH_CLASS_NACK_QUOTA         1278
#define IDS_UH_CLASS_NACK_ACCESS_DENIED 1279
#define IDS_UH_CLASS_NACK_HOP_COUNT     1280
                                    
#define IDS_DEBUG_Q_TYPE 1290
#define IDS_DEBUG_Q_TYPE_NONE           1290
#define IDS_DEBUG_Q_TYPE_GUID           1291
#define IDS_DEBUG_Q_TYPE_PRIVATE        1292
#define IDS_DEBUG_Q_TYPE_DIRECT         1293
                                    
#define IDS_SECFLAGS 1300
#define IDS_SECFLAGS_IS_AUTHENTICATED_OFF 1300
#define IDS_SECFLAGS_IS_AUTHENTICATED_ON  1301
#define IDS_SECFLAGS_IS_ENCRYPTED_OFF   1302
#define IDS_SECFLAGS_IS_ENCRYPTED_ON    1303
#define IDS_SECFLAGS_IS_DEFPROV_ON	1304
#define IDS_SECFLAGS_IS_DEFPROV_OFF	1305

#define IDS_SECALG 1310
#define IDS_SECALG_CALG_MD2		1310
#define IDS_SECALG_CALG_MD4		1311
#define IDS_SECALG_CALG_MD5		1312
#define IDS_SECALG_CALG_SHA		1313
#define IDS_SECALG_CALG_SHA1		1314
#define IDS_SECALG_CALG_MAC		1315
#define IDS_SECALG_CALG_RSA_SIGN	1316
#define IDS_SECALG_CALG_DSS_SIGN	1317
#define IDS_SECALG_CALG_RSA_KEYX	1318
#define IDS_SECALG_CALG_DES		1319
#define IDS_SECALG_CALG_3DES_112	1320
#define IDS_SECALG_CALG_3DES		1321
#define IDS_SECALG_CALG_RC2		1322
#define IDS_SECALG_CALG_RC4		1323
#define IDS_SECALG_CALG_SEAL		1324
#define IDS_SECALG_CALG_DH_SF		1325
#define IDS_SECALG_CALG_DH_EPHEM	1326
#define IDS_SECALG_CALG_AGREEDKEY_ANY	1327
#define IDS_SECALG_CALG_KEA_KEYX	1328
#define IDS_SECALG_CALG_SKIPJACK	1329
#define IDS_SECALG_CALG_TEK		1330

#define IDS_PRIVLEVEL 1400
#define IDS_PRIVLEVEL_NONE 1400
#define IDS_PRIVLEVEL_BODY 1401

#define IDS_INTFLAGS 1450
#define IDS_INTFLAGS_REFUSED_OFF 1450
#define IDS_INTFLAGS_REFUSED_ON 1451

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\nmparser\tracker.cpp ===
///////////////////////////////////////////////////////////////////////////////////
//	Tracker.CPP
//
//	This file implements the state tracking objects.
//
//	Modification history:
//	
//	Created:	Andrew Smith	8/25/97
//
///////////////////////////////////////////////////////////////////////////////////

#ifdef MAIN
#undef MAIN
#endif

#include "stdafx.h"
#include "nmmsmq.h"
#include "falconDB.h"

/* Falcon headers */
#include <ph.h>
#include <phintr.h>
#include <mqformat.h>

#include "resource.h"

#include <iostream.h>
#include "tracker.h"
#include "utilities.h"
//EXTERN enum eMQPacketField uIncrementEnum(enum eMQPacketField uThisEnum);

//
// bugbug - Workaround - these definitions were taken from xactout.h.
//			try to include the file, but compile errors resulted.
//
//#include <xactout.h>
#define ORDER_ACK_TITLE       (L"QM Ordering Ack")

#pragma pack(push, 1)
typedef struct {
    LONGLONG  m_liSeqID;
    ULONG     m_ulSeqN;
    ULONG     m_ulPrevSeqN;
    OBJECTID  MessageID;
} OrderAckData;
#pragma pack(pop)


///////////////////////////////////////////////////////////////////////////////////
//						Message Object Operation
///////////////////////////////////////////////////////////////////////////////////

bool CMessage::IsOrderingAck(CPropertyHeader *pph)
{
	WCHAR wcLabel[255]; //bugbug - need correct label length
	ULONG ulTitleLength = pph->GetTitleLength();
    pph->GetTitle(wcLabel, 255);
	if (wcsncmp(wcLabel, ORDER_ACK_TITLE,14))
	{
		return false;
	}
	else
	{
		return true;
	}
}

void CMessage::GenerateOrderingAckSummary(char *szSummary)
{
	OrderAckData *poad=(OrderAckData *)pph->GetBodyPtr();
	ULONG ulHighPart = ((LARGE_INTEGER*)poad->m_liSeqID)->HighPart;
	ULONG ulLowPart  = ((LARGE_INTEGER*)poad->m_liSeqID)->LowPart;
	//printf(":SeqID=%x / %x",    ((LARGE_INTEGER*)&seqID)->HighPart,  ((LARGE_INTEGER*)&seqID)->LowPart );
	sprintf
		(
		szSummary, "SeqID=%x / %x, SeqN=%x, PrevN=%x MsgId=%ld", 
		ulHighPart, 
		ulLowPart, 
		poad->m_ulSeqN, 
		poad->m_ulPrevSeqN,
		poad->MessageID.Uniquifier
		);
}
void CMessage::Accrue(UINT uByteCount)
{
	//
	// Account for attaching this property of the message
	// 
	//m_ulBytesAccrued += uByteCount;
	m_uEnumCursor = uIncrementEnum(m_uEnumCursor);
}


void CMessage::Clear(LPBYTE pNewMessage) 
{ 
	//
	// clears the fields of the message node.
	// todo - make this a constructor
	//

	//
	// public members
	//
	pbh  = (CBaseHeader *)pNewMessage;	//pointer to base header

	//internal headers
	pis	 = NULL;	//pointer to internal section
	pcp = NULL;		//pointer to connection parameters
	pec = NULL;	//pointer to establish connection section

	//user headers
	puh	= NULL; //pointer to user header
    psh	= NULL;	//pointer to security header
	pph	= NULL; //pointer to property header
	pxh	= NULL;	//pointer to transaction header
	pds	= NULL;	//pointer to debug section
	pss	= NULL;	//pointer to session section

	//
	// protected members
	//
	m_ulMsgId = 0;
    if ((pbh->GetVersion() == FALCON_PACKET_VERSION && pbh->SignatureIsValid()))
    {
        m_ulTotalBytes = pbh->GetPacketSize();
    }
    else
    {
        m_ulTotalBytes = 0;
    }
	//m_ulTotalBytes = 0;
	//m_ulBytesAccrued = 0;
	m_uEnumCursor = db_summary_root;
	bfHeaders = 1; //set expectation for base header
	usNextExpectedHeaders = 1;  //set expectation for base header

}

void CMessage::SetHeaderCompleted(MQHEADER ThisHeader) 
{
	//upon completing a header, extract and store relevant info to parse future headers.
	//BUGBUG - How to track separation of internal, session and debug headers. Half implemented here, but I've put Internal header pointers in the CMessage aaaarrrrrgh!!
//	CInternalSection *pis;
//	CECSection *pec;
//	CCPSection *pcp;

	switch(ThisHeader) 
	{
	case base_header:
		need_base_header = FALSE;
		if (pbh->GetType() == FALCON_USER_PACKET)
		{ 
			//
			// User header will be next. Set the pointer
			//
			need_user_header = TRUE;
			puh = (CUserHeader *) pbh->GetNextSection();	//Set pointer to User header
			SetCurrentEnum(db_uh_summary);					//Set enum cursor to first enumeration of user header //bugbug - this may be a redundant setting
			SetTotalBytes(pbh->GetPacketSize());			//Extract size of MSMQ message. 
			if(pbh->DebugIsIncluded())
			{
				need_debug_section = TRUE;
			}
			if(pbh->SessionIsIncluded())
			{
				need_session_section = TRUE;
			}
		}
		else //FALCON_INTERNAL_PACKET:
		{
			//
			// internal header will be next. Set the pointer
			//
			need_internal_header = TRUE;
			pis = (CInternalSection *) pbh->GetNextSection();
			if(pbh->DebugIsIncluded())
			{
				need_debug_section = TRUE;
			}
		}//else
		break;
	case internal_header:
		need_internal_header = FALSE;
		switch(pis->GetPacketType()) 
		{
		case INTERNAL_SESSION_PACKET:	
			//
			// Session header will be next. Set the pointer
			//
			pss = (CSessionSection *) pis->GetNextSection();
			need_session_section = TRUE;
			break;
		case INTERNAL_ESTABLISH_CONNECTION_PACKET:
			//
			// EC header will be next. Set the pointer
			//
			pec = (CECSection *) pis->GetNextSection();
			need_EC_section = TRUE;
			break;
		case INTERNAL_CONNECTION_PARAMETER_PACKET:
			//
			// CP header will be next. Set the pointer
			//
			pcp = (CCPSection *)pis->GetNextSection();
			need_CP_section = TRUE;
			break;
		default:
			break;
		}//nested switch
		break;
	case ec_section:
		//
		// No header follows. 
		//
		need_EC_section = FALSE;
		break;
	case cp_section:
		//
		// No header follows. 
		//
		need_CP_section = FALSE;
		break;
	case user_header:
		need_user_header = 0;
		if (puh->IsOrdered()) 
		{
			//
			// Xact header will be next. Set the pointer
			//
			pxh = (CXactHeader *)puh->GetNextSection();
			need_xact_header = TRUE;
		} 
		else if(puh->SecurityIsIncluded()) 
		{
			//
			// Security header will be next. Set the pointer
			//
			psh = (CSecurityHeader *)puh->GetNextSection();
			need_security_header = TRUE;
		}
		else if (puh->PropertyIsIncluded()) 
		{
			//
			// Property header will be next. Set the pointer
			//
			pph = (CPropertyHeader *)puh->GetNextSection();
			need_property_header = TRUE;
		}
		else if (pbh->DebugIsIncluded()) 
		{
			//
			// Debug header will be next. Set the pointer
			// bugbug - redundant? already set in bh parse
			//
			pds = (CDebugSection *)puh->GetNextSection();
			need_debug_section = TRUE;
		}
		else if (pbh->SessionIsIncluded()) 
		{
			//
			// Session header will be next. Set the pointer
			// bugbug - redundant? already set in bh parse
			// 
			pss = (CSessionSection *)puh->GetNextSection();
			need_session_section = TRUE;
		}
		break;
	case xact_header:
		need_xact_header = 0;
		if(puh->SecurityIsIncluded()) 
		{
			//
			// Security header will be next. Set the pointer
			//
			psh = (CSecurityHeader *)pxh->GetNextSection();
			need_security_header = TRUE;
		}
		else if (puh->PropertyIsIncluded()) 
		{
			//
			// Property header will be next. Set the pointer
			//
			pph = (CPropertyHeader *)pxh->GetNextSection();
			need_property_header = TRUE;
		}
		else if (pbh->DebugIsIncluded()) 
		{
			//
			// Debug header will be next. Set the pointer
			// bugbug - redundant? already set in bh parse
			//
			pds = (CDebugSection *)pxh->GetNextSection();
			need_debug_section = TRUE;
		}
		else if (pbh->SessionIsIncluded()) 
		{
			//
			// Session header will be next. Set the pointer
			// bugbug - redundant? already set in bh parse
			// 
			pss = (CSessionSection *)pxh->GetNextSection();
			need_session_section = TRUE;
		}
		break;
	case security_header:
		need_security_header = 0;
		if (puh->PropertyIsIncluded()) 
		{
			//
			// Property header will be next. Set the pointer
			//
			pph = (CPropertyHeader *)psh->GetNextSection();
			need_property_header = TRUE;
		}
		else if (pbh->DebugIsIncluded()) 
		{
			//
			// Debug header will be next. Set the pointer
			// bugbug - redundant? already set in bh parse
			//
			pds = (CDebugSection *)psh->GetNextSection();
			need_debug_section = TRUE;
		}
		else if (pbh->SessionIsIncluded()) 
		{
			//
			// Session header will be next. Set the pointer
			// bugbug - redundant? already set in bh parse
			// 
			pss = (CSessionSection *)psh->GetNextSection();
			need_session_section = TRUE;
		}
		break;
	case property_header:
		need_property_header = 0;
		if (pbh->DebugIsIncluded()) 
		{
			//
			// Debug header will be next. Set the pointer
			// bugbug - redundant? already set in bh parse
			//
			pds = (CDebugSection *)pph->GetNextSection();
			need_debug_section = TRUE;
		}
		else if (pbh->SessionIsIncluded()) 
		{
			//
			// Session header will be next. Set the pointer
			// bugbug - redundant? already set in bh parse
			// 
			pss = (CSessionSection *)pph->GetNextSection();
			need_session_section = TRUE;
		}
		break;
    case debug_header:
		need_debug_section = 0;
		if (pbh->SessionIsIncluded()) 
		{
			//
			// Session header will be next. Set the pointer
			// bugbug - redundant? already set in bh parse
			// 
			pss = (CSessionSection *)pph->GetNextSection();
			need_session_section = TRUE;
		}
		break;
	case session_header:
		//
		// No header follows. 
		//
		need_session_section = 0;
		break;
	default:
		break;
	}//switch
	MQHEADER mqhTemp = mqhGetNextHeader();
	m_uEnumCursor = GetFirstEnum(mqhTemp);

}//bSetHeaderCompleted

MQHEADER CMessage::mqhGetNextHeader() 
{
	MQHEADER ThisHeader = no_header;
	if(bfHeaders) 
	{
		//
		// parse out the next header
		// They should occur in this order
		//
		if (need_base_header)
			return (base_header);

		else if (need_internal_header)
			return (internal_header);
		
		else if (need_CP_section)
			return (cp_section);

		else if (need_EC_section)
			return (ec_section);
		
		else if (need_user_header)
			return (user_header);
		
		else if (need_xact_header)
			return (xact_header);

		else if (need_security_header)
			return (security_header);
		
		else if (need_property_header)
			return (property_header);
		
		else if (need_debug_section)
			return (debug_header);
		
		else if (need_session_section)
			return (session_header);
		
		return(no_header);	//no_header = 0 - serves as boolean in calling routine
	}
	 return(ThisHeader);  
}
/*
void CMessage::SetNeedHeader(MQHEADER mqh) 
{
	switch(mqh) 
	{
	case base_header:
		need_base_header = 1;
		break;
	case internal_header:
		need_internal_header = 1;
		break;
	case user_header:
		need_user_header = 1;
		break;
	case security_header:
		need_security_header = 1;
		break;
	case property_header:
		need_property_header = 1;
		break;
	case xact_header:
		need_xact_header = 1;
		break;
	case session_header:
		need_session_section = 1;
		break;
    case debug_header:
		need_debug_section = 1;
		break;
	default:
		break;
	}//switch

}
*/
enum eMQPacketField CMessage::GetFirstEnum(MQHEADER mqh)
{			//Returns the first enum for a header

	switch(mqh) 
	{//maps first enum of each header to the header's enumaration. 
	case no_header:
		return(db_summary_root);
	case base_header:
		return (db_bh_root);
	case internal_header:
		return(db_ih_root);
	case cp_section:
		return(db_cp_root);
	case ec_section:
		return(db_ce_root);
	case user_header:
		return(db_uh_summary);
	case xact_header:
		return(db_xa_summary);
	case security_header:
		return(db_sh_summary);
	case property_header:
		return(db_prop_summary);
	case debug_header:
		return(db_debug_summary);
	case session_header:
		return(db_ss_root);
	default:
		return(db_summary_root);
	}//switch
}

///////////////////////////////////////////////////////////////////////////////////
//						Frame Cursor Operation
///////////////////////////////////////////////////////////////////////////////////

void CFrame::CreateFrom(HFRAME hf, LPBYTE falFrame, DWORD BytesLeft, USHORT usThisSourcePort, CMessage *pMessageNode)
{
	//
	// This routine is called before beginning to attach properties for a new Falcon frame.
	// Parsing of non-Falcon frames will not reach this routine. (However, we cannot assume that
	// the start of the frame is also the start of a message.)
	//
	// The object tracks the progress of the parse, but keeps no state outside of the current frame.
	//
	
	//
	// bugbug -  Assume we're at the start of a new Falcon message. todo - ASSERT?
	// Test for base header of User or Internal packet.
	//
	// todo - read forward in the frame to the beginning of a base header
	//      - attach preceding bytes as unparsable
	//

	//
	// todo - this is init stuff. Put it in a constructor
	//
	hFrame = hf;							//handle to Netmon frame
	dwRawFrameNum=GetFrameNumber(hFrame);	//Ordinal Netmon frame number (ordinal for the capture)
	dwSize			= BytesLeft;			//MSMQ bytes left in this frame
	dwBytesLeft		= BytesLeft;			//unparsed MSMQ bytes left in this frame
	packet_pos		= falFrame;				//position in the frame
	bMultipleMessages = (dwSize > ((CBaseHeader*) packet_pos)->GetPacketSize());
}//CreateFrom

bool CFrame::SeekToBaseHeader()
{
	CBaseHeader UNALIGNED *bh = (CBaseHeader*) packet_pos;
	
	for (bh = (CBaseHeader*)packet_pos; (LPBYTE)bh <= packet_pos + dwBytesLeft - sizeof(CBaseHeader); bh++)
	{
		if ((bh->GetVersion() == FALCON_PACKET_VERSION && bh->SignatureIsValid()))
		{
			packet_pos = (LPBYTE)bh;
			return true;
		}
	}
	return false;
}

void CFrame::Accrue(UINT uByteCount, UINT uEnum)
{
	//
	// If the property is a comment or summary, do not accrue bytes or advance the frame pointer
	// bugbug - Case out internal messages from this exclusion until their summary behavior is corrected
	// (The internal headers and base header accrue all bytes at the same time.)
	//
	if (falFieldInfo[uEnum].isComment && uEnum != -1)
	{
		return;
	}
    //
    // bugbug: assert (uByteCount <= dwBytesLeft) instead of hiding it like this
    //
    if (uByteCount > dwBytesLeft) 
    {
        dwBytesLeft=0;
    }
    else
    {
        dwBytesLeft -= uByteCount;
    }
	packet_pos  += uByteCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\nmparser\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
#define AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here
#define MAX_SUMMARY_LENGTH 128
#define DWORD_PTR DWORD
#define ULONG_PTR DWORD
#include <_stdh.h>

#ifndef _NM_
	#pragma warning(disable: 4200) //obscure zero byte array warnings from bh.h
	extern "C" 
	{
		#include <bh.h>
		#include <parser.h>
	}
	#pragma warning(default: 4200) //obscure zero byte array warnings from bh.h
//#include <parser.h>
#endif
#include <qformat.h>
#include <mqsymbls.h>

enum MQPortType
{
	eNonMSMQPort,
	eFalconPort,
	eMQISPort,
	eRemoteReadPort,
	eDependentClientPort,
	eServerDiscoveryPort,
	eServerPingPort
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4AF0C90F_9333_48AC_ADEB_E2478D6566ED__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\nmparser\nmmsmq.h ===
//=============================================================================
//  
//  MODULE: nmmsmq.h modified from sample: RemAPI.h
//
//  Description:
//
//  Bloodhound Parser DLL for MS Message Queue
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created RemAPi.h
//  Andrew Smith		07/28/97		Modified to nmmsmq.h
//=============================================================================
#ifndef _NMMSMQ_
	#define _NMMSMQ_
#endif

//#define EXPORT extern "C" __declspec( dllexport )  // to simplify delaring exported functions
#ifdef DEBUG
#define MAX_DEBUG_STRING_SIZE 100
#endif
#ifdef MAIN
#define EXTERN
#else
#define EXTERN extern
#endif

#define MAX_SUMMARY_LENGTH 128

//=============================================================================
//  Globals.  Data Types
//=============================================================================

/*
 * Copied from phuser.h becuase this enum and structure are private to the CUserHeader class
 * BUGBUG - change add this to headers.h automaticaly.
 */
EXTERN enum QType 
{
    qtNone      = 0,    //  0 - None                    ( 0 bytes)
    qtAdminQ    = 1,    //  1 - Same as Admin.Q         ( 0 bytes)
    qtSourceQM  = 2,    //  2 - Private at Src...QM     ( 4 bytes)
    qtDestQM    = 3,    //  3 - Private at Dest..QM     ( 4 bytes)
    qtAdminQM   = 4,    //  4 - Private at Admin.QM     ( 4 bytes)
    qtGUID      = 5,    //  5 - Public  Queue           (16 bytes)
    qtPrivate   = 6,    //  6 - Private Queue           (20 bytes)
    qtDirect    = 7     //  7 - Direct  Queue           (var size)
};


typedef struct 
{
  UCHAR* sender_id;
  ULONG size;
  USHORT sender_id_type;
} SENDER_ID_INFO;


//=============================================================================
//  Forward references.
//=============================================================================

EXTERN VOID WINAPIV AttachPropertySequence(HFRAME hFrame, LPBYTE falFrame, //attaches a sequence of properties from the enumeration
									int iFirstProp, int iLastProp);
VOID WINAPIV AttachField(HFRAME hFrame, LPBYTE lpPosition, int iEnum);
VOID WINAPIV AttachSummary(HFRAME hFrame, LPBYTE lpPosition, int iEnum, char *szSummary, DWORD iHighlightBytes); //attaches one field from the enumeration

/* Formatting routines */
EXTERN VOID WINAPIV format_uuid(LPPROPERTYINST lpPropertyInst);
EXTERN VOID WINAPIV format_unix_time(LPPROPERTYINST lpPropertyInst);
EXTERN VOID WINAPIV format_falcon_summary(LPPROPERTYINST lpPropertyInst);	//formats the root packet summary display text
EXTERN VOID WINAPIV format_milliseconds(LPPROPERTYINST lpPropertyInst);
EXTERN VOID WINAPIV format_q_format(LPPROPERTYINST lpPropertyInst);
EXTERN VOID WINAPIV format_wstring(LPPROPERTYINST lpPropertyInst);
EXTERN VOID WINAPIV format_sender_id(LPPROPERTYINST lpPropertyInst);

/* Misc Routines */
EXTERN int QueueSize(ULONG qt, const UCHAR* pQueue);
EXTERN BOOL MyGetTextualSid(PSID pSid, LPSTR TextualSID, LPDWORD dwBufferLen);

EXTERN USHORT usGetTCPSourcePort(LPBYTE MacFrame, DWORD nPreviousProtocolOffset);
EXTERN USHORT usGetTCPDestPort(LPBYTE MacFrame, DWORD nPreviousProtocolOffset);
//EXTERN DWORD dwGetTCPSeqNum(LPBYTE MacFrame, DWORD nPreviousProtocolOffset);


//////////////////////////////////////////
// Strings for Falcon Base Header flags.
//////////////////////////////////////////

#ifdef MAIN
	LABELED_BYTE falBHVersion[] = 
	{
		{0xff,0}, // VER MASK
		{16, "1.0"}
	};
	const DWORD dwfalBHVersionEntries = sizeof(falBHVersion) / sizeof(falBHVersion[0]);
	SET format_falBHVersion = {dwfalBHVersionEntries, falBHVersion};
#else
	extern LABELED_BYTE falBHVersion[];
	extern const DWORD dwfalBHVersionEntries;
	extern SET format_falBHVersion;
#endif

//db_prop_ack_mode
#ifdef MAIN
	LABELED_WORD bh_pri_labels[] = 
	{
		{0x07,0}, // ACK MASK
		{0, "Priority       : 0"},
		{1, "Priority       : 1"},
		{2, "Priority       : 2"},
		{3, "Priority       : 3"},
		{4, "Priority       : 4"},
		{5, "Priority       : 5"},
		{6, "Priority       : 6"},
		{7, "Priority       : 7"}
	};
	const DWORD bh_pri_entries = sizeof(bh_pri_labels) / sizeof(bh_pri_labels[0]);
	SET format_pri_types = {bh_pri_entries, bh_pri_labels};
#else
	extern LABELED_BYTE bh_pri_labels[];
	extern const DWORD bh_pri_entries;
	extern SET format_pri_types;
#endif

#ifdef MAIN
	LABELED_BIT falBaseFlags[] = 
	{
		{3, "Packet Type    : User", "Packet Type    : Internal"},
        {4, "Session section: not included","Session section: included"},
        {5, "Debug section  : not included","Debug section  : included"},
        {6, "ACK            : not immediate", "ACK            : immediate"},
        {7, "Duplicate      : No","Duplicate      : Yes" },
		{8, "Trace Packet   : No","Trace Packet   : Yes"},
		{9, "Fragmented     : No","Fragmented     : Yes"}
	};
	const DWORD dwfalBaseFlagsEntries = sizeof(falBaseFlags) / sizeof(falBaseFlags[0]);
	SET fmt_falBaseFlags = {dwfalBaseFlagsEntries, falBaseFlags};
#else
	extern LABELED_BIT falBaseFlags[];
	extern const DWORD dwfalBaseFlagsEntries;
	extern SET fmt_falBaseFlags;
#endif

/////////////////////////////////////////////
// Strings for Falcon Internal Header flags.
/////////////////////////////////////////////

#ifdef MAIN
	LABELED_WORD falIHPacketType[] = 
	{
		{0x0f,0}, // ACK MASK
		{1, "Packet Type    : Session Packet"},
		{2, "Packet Type    : Establish Connection Packet"},
		{3, "Packet Type    : Connection Parameters Packet"}
	};
	const DWORD dwfalIHPacketTypeEntries = sizeof(falIHPacketType) / sizeof(falIHPacketType[0]);
	SET format_falIHPacketType = {dwfalIHPacketTypeEntries, falIHPacketType};
#else
	extern LABELED_BIT falIHPacketType[];
	extern const DWORD dwfalIHPacketTypeEntries;
	extern SET format_falIHPacketType;
#endif

#ifdef MAIN
	LABELED_BIT falIHConnection[] = 
	{
        {4, "Connection     : not refused","Connection     : not refused"},
	};
	const DWORD dwfalIHConnectionEntries = sizeof(falIHConnection) / sizeof(falIHConnection[0]);
	SET format_falIHConnection = {dwfalIHConnectionEntries, falIHConnection};
#else
	extern LABELED_BIT falIHConnection[];
	extern const DWORD dwfalIHConnectionEntries;
	extern SET format_falIHConnection;
#endif


////////////////////////////////////////////////
// Strings for Falcon Establish Connection flags.
////////////////////////////////////////////////
#ifdef MAIN
	LABELED_BIT falEstablishConnectionFlags[] = 
	{
		{8, "CheckNewSession: False","CheckNewSession: True"},
		{9, "Server         : False","Server         : True"}
	};
	const DWORD dwfalEstablishConnectionFlagsEntries = sizeof(falEstablishConnectionFlags) / sizeof(falEstablishConnectionFlags[0]);
	SET fmt_falEstConnFlags = {dwfalEstablishConnectionFlagsEntries, falEstablishConnectionFlags};
#else
	extern LABELED_BIT falEstablishConnectionFlags[];
	extern const DWORD dwfalEstablishConnectionFlagsEntries;
	extern SET fmt_falEstConnFlags;
#endif

#ifdef MAIN
	LABELED_WORD falECVersion[] = 
	{
		{0xff,0}, // ACK MASK
		{16, "Version        : 1.0"}
	};
	const DWORD dwfalECVersionEntries = sizeof(falECVersion) / sizeof(falECVersion[0]);
	SET format_falECVersion = {dwfalECVersionEntries, falECVersion};
#else
	extern LABELED_WORD falECVersion[];
	extern const DWORD dwfalECVersionEntries;
	extern SET format_falECVersion;
#endif

///////////////////////////////////
// Strings for Falcon User Header.
///////////////////////////////////

// db_uh_hopcount
#ifdef MAIN
	LABELED_DWORD uh_hopcount_labels[] = 
	{
		{0x0000001F, 0}, // Hopcount mask
		{0, "HopCount: 0"},	{1, "HopCount: 1"},	{2, "HopCount: 2"},	{3, "HopCount: 3"},	{4, "HopCount: 4"},
		{5, "HopCount: 5"},	{6, "HopCount: 6"},	{7, "HopCount: 7"},	{8, "HopCount: 8"},	{9, "HopCount: 9"},
		{10, "HopCount: 10"},	{11, "HopCount: 11"},	{12, "HopCount: 12"},	{13, "HopCount: 13"},
		{14, "HopCount: 14"},	{15, "HopCount: 15"},	{16, "HopCount: 16"},	{17, "HopCount: 17"},
		{18, "HopCount: 18"},	{19, "HopCount: 19"},	{20, "HopCount: 20"},	{21, "HopCount: 21"},
		{22, "HopCount: 22"},	{23, "HopCount: 23"},	{24, "HopCount: 24"},	{25, "HopCount: 25"},
		{26, "HopCount: 26"},	{27, "HopCount: 27"},	{28, "HopCount: 28"},	{29, "HopCount: 29"},
		{30, "HopCount: 30"},	{31, "HopCount: 31"}
	};
	const DWORD uh_hopcount_entries = sizeof(uh_hopcount_labels) / sizeof(uh_hopcount_labels[0]);
	SET format_uh_hopcount = {uh_hopcount_entries, uh_hopcount_labels};
#else
	extern LABELED_DWORD uh_hopcount_labels[];
	extern const DWORD uh_hopcount_entries;
	extern SET format_uh_hopcount;
#endif

// db_uh_delivery
#ifdef MAIN
	LABELED_DWORD uh_delivery_labels[] = 
	{
		{0x00000060, 0}, // Delivery mask
		{0x0,  "Delivery: Express"},
		{0x20, "Delivery: Recoverable"},
	};
	const DWORD uh_delivery_entries = sizeof(uh_delivery_labels) / sizeof(uh_delivery_labels[0]);
	SET format_uh_delivery = {uh_delivery_entries, uh_delivery_labels};
#else
	extern LABELED_DWORD uh_delivery_labels[];
	extern const DWORD uh_delivery_entries;
	extern SET format_uh_delivery;
#endif

// db_uh_routing
#ifdef MAIN
	LABELED_BIT uh_flags_labels1[] = 
	{
        {7, "Routing : Online", "Routing : Deferred"},
	};
	const DWORD uh_flags_entries1= sizeof(uh_flags_labels1) / sizeof(uh_flags_labels1[0]);
	SET format_uh_flags1 = {uh_flags_entries1, uh_flags_labels1};
#else
	extern LABELED_BIT uh_flags_labels1[];
	extern const DWORD uh_flags_entries1;
	extern SET format_uh_flags1;
#endif

// db_uh_auditing
#ifdef MAIN
	LABELED_DWORD uh_auditing_labels[] = 
	{
		{0x00000300, 0}, // mask
		{MQMSG_JOURNAL_NONE, "Auditing: None"},
		{MQMSG_DEADLETTER, "Auditing: DeadLetter"},
		{MQMSG_JOURNAL, "Auditing: Journal"},
	};
	const DWORD uh_auditing_entries = sizeof(uh_auditing_labels) / sizeof(uh_auditing_labels[0]);
	SET format_uh_auditing = {uh_auditing_entries, uh_auditing_labels};
#else
	extern LABELED_DWORD uh_auditing_labels[];
	extern const DWORD uh_auditing_entries;
	extern SET format_uh_auditing;
#endif

// db_uh_dqt_type -- destination queue type
#ifdef MAIN
	// 1024 = 10 bit offset into DWORD
	LABELED_DWORD uh_dqt_labels[] = 
	{
		{0x00001c00, 0}, //mask
		{qtNone*1024,	 "Dest Queue Type    : None"},
		{qtAdminQ*1024,	 "Dest Queue Type    : Same as Admin Q"},
		{qtSourceQM*1024,"Dest Queue Type    : Private at Src QM"},
		{qtDestQM*1024,  "Dest Queue Type    : Private at Dest QM"},
		{qtAdminQM*1024, "Dest Queue Type    : Private at Admin QM"},
		{qtGUID*1024,	 "Dest Queue Type    : Public Queue"},
		{qtPrivate*1024, "Dest Queue Type    : Private Queue"},
		{qtDirect*1024,  "Dest Queue Type    : Direct Queue"}
	};
	const DWORD uh_dqt_entries = sizeof(uh_dqt_labels) / sizeof(uh_dqt_labels[0]);
	SET format_uh_dqt = {uh_dqt_entries, uh_dqt_labels};
#else
	extern LABELED_DWORD uh_dqt_labels[];
	extern const DWORD uh_dqt_entries;
	extern SET format_uh_dqt;
#endif

// db_uh_aqt_type -- admin queue type
#ifdef MAIN
	// 8192 = 13 bit offset into DWORD
	LABELED_DWORD uh_aqt_labels[] = 
	{
		{0x0000e000, 0}, //mask
		{qtNone*8192,	 "Admin Queue Type   : None"},
		{qtAdminQ*8192,	 "Admin Queue Type   : Same as Admin Q"},
		{qtSourceQM*8192,"Admin Queue Type   : Private at Src QM"},
		{qtDestQM*8192,  "Admin Queue Type   : Private at Dest QM"},
		{qtAdminQM*8192, "Admin Queue Type   : Private at Admin QM"},
		{qtGUID*8192,	 "Admin Queue Type   : Public Queue"},
		{qtPrivate*8192, "Admin Queue Type   : Private Queue"},
		{qtDirect*8192,  "Admin Queue Type   : Direct Queue"}
	};
	const DWORD uh_aqt_entries = sizeof(uh_aqt_labels) / sizeof(uh_aqt_labels[0]);
	SET format_uh_aqt = {uh_aqt_entries, uh_aqt_labels};
#else
	extern LABELED_DWORD uh_aqt_labels[];
	extern const DWORD uh_aqt_entries;
	extern SET format_uh_aqt;
#endif

// db_uh_rqt_type -- response queue type
#ifdef MAIN
	LABELED_DWORD uh_rqt_labels[] = 
	{
		// 65536 = 16 bit offset into DWORD
		{0x00070000, 0}, //mask
		{qtNone*65536,	  "Response Queue Type: None"},
		{qtAdminQ*65536,  "Response Queue Type: Same as Admin Q"},
		{qtSourceQM*65536,"Response Queue Type: Private at Src QM"},
		{qtDestQM*65536,  "Response Queue Type: Private at Dest QM"},
		{qtAdminQM*65536, "Response Queue Type: Private at Admin QM"},
		{qtGUID*65536,	  "Response Queue Type: Public Queue"},
		{qtPrivate*65536, "Response Queue Type: Private Queue"},
		{qtDirect*65536,  "Response Queue Type: Direct Queue"}
	};
	const DWORD uh_rqt_entries = sizeof(uh_rqt_labels) / sizeof(uh_rqt_labels[0]);
	SET format_uh_rqt = {uh_rqt_entries, uh_rqt_labels};
#else
	extern LABELED_DWORD uh_rqt_labels[];
	extern const DWORD uh_rqt_entries;
	extern SET format_uh_rqt;
#endif

// db_uh_sections
#ifdef MAIN
	LABELED_BIT uh_sections_labels[] = 
	{
		{19, "Security section   : not present","Security section   : present"},
		{20, "Transaction section: not present","Transaction section: present"},
		{21, "Property section   : not present","Property section   : present"},
		{22, "Connector section  : not present","Connector section  : present"}
	};
	const DWORD uh_sections_entries= sizeof(uh_sections_labels) / sizeof(uh_sections_labels[0]);
	SET format_uh_flags2 = {uh_sections_entries, uh_sections_labels};
#else
	extern LABELED_BIT uh_sections_labels[];
	extern const DWORD uh_sections_entries;
	extern SET format_uh_flags2;
#endif

///////////////////////////////////////
// Strings for Falcon User Properties.
///////////////////////////////////////

//db_prop_ack_mode
#ifdef MAIN
	LABELED_BYTE uh_ack_labels[] = 
	{
		{0x07,0}, // ACK MASK
		{0, "No ACK"},
		{1, "Negative ACK"},
		{2, "Full ACK"},
	};
	const DWORD uh_ack_entries = sizeof(uh_ack_labels) / sizeof(uh_ack_labels[0]);
	SET format_ack_types = {uh_ack_entries, uh_ack_labels};
#else
	extern LABELED_BYTE uh_ack_labels[];
	extern const DWORD uh_ack_entries;
	extern SET format_ack_types;
#endif

//db_prop_class
#ifdef MAIN
	LABELED_WORD uh_class_labels[] = 
	{
		{MQMSG_CLASS_NORMAL, "MQMSG_CLASS_NORMAL"},
		{MQMSG_CLASS_ACK_REACH_QUEUE, "MQMSG_CLASS_ACK_REACH_QUEUE"},
		{MQMSG_CLASS_ACK_RECEIVE, "MQMSG_CLASS_ACK_RECEIVE"},
		{MQMSG_CLASS_REPORT, "MQMSG_CLASS_REPORT"},
		{MQMSG_CLASS_NACK_BAD_DST_Q, "MQMSG_CLASS_NACK_BAD_DST_Q: Destination queue handle is invalid."},
		{MQMSG_CLASS_NACK_PURGED, "MQMSG_CLASS_NACK_PURGED: The message was purged"},
		{MQMSG_CLASS_NACK_RECEIVE_TIMEOUT, "MQMSG_CLASS_NACK_RECEIVE_TIMEOUT: Time to receive expired"},
		{MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT, "MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT: Time to arrive expired"},
		{MQMSG_CLASS_NACK_Q_EXCEED_QUOTA, "MQMSG_CLASS_NACK_Q_EXCEED_QUOTA: Queue is full."},
		{MQMSG_CLASS_NACK_ACCESS_DENIED, "MQMSG_CLASS_NACK_ACCESS_DENIED: The sender does not have send access rights on the queue."},
		{MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED, "MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED: Hop count exceeded"},
		{MQMSG_CLASS_NACK_BAD_SIGNATURE, "MQMSG_CLASS_NACK_BAD_SIGNATURE: The message was received with a bad signature."},
		{MQMSG_CLASS_NACK_BAD_ENCRYPTION, "MQMSG_CLASS_NACK_BAD_ENCRYPTION: The message could not be decrypted."},
		{MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT, "MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT: The source QM could not encrypt the message for the destination QM."},
	};
	const DWORD uh_class_entries = sizeof(uh_class_labels) / sizeof(uh_class_labels[0]);
	SET format_class_types = {uh_class_entries, uh_class_labels};
#else
	extern LABELED_WORD uh_class_labels[];
	extern const DWORD uh_class_entries;
	extern SET format_class_types;
#endif

//db_prop_privacy_level
#ifdef MAIN
	LABELED_DWORD privacy_level_labels[] = 
	{
		{MQMSG_PRIV_LEVEL_NONE, "NONE"},
		{MQMSG_PRIV_LEVEL_BODY, "BODY"},
	};
	const DWORD  privacy_level_entries=sizeof(privacy_level_labels) / sizeof(privacy_level_labels[0]);
	SET format_privacy_level = {privacy_level_entries, privacy_level_labels};
#else
	extern LABELED_DWORD privacy_level_labels[];
	extern const DWORD  privacy_level_entries;
	extern SET format_privacy_level;
#endif


//db_prop_hash_algorithm
// --and--
//db_prop_encryption_algorithm
#ifdef MAIN
	LABELED_DWORD pps_security_algorithms_labels[] = 
	{
		{CALG_MD2, "MD2"},
		{CALG_MD4, "MD4"},
		{CALG_MD5, "MD5"},
		{CALG_SHA, "SHA"},
		{CALG_SHA1, "SHA1"},
		{CALG_MAC, "MAC"},
		{CALG_RSA_SIGN, "RSA_SIGN"},
		{CALG_DSS_SIGN, "DSS_SIGN"},
		{CALG_RSA_KEYX, "RSA_KEYX"},
		{CALG_DES, "DES"},
		{CALG_3DES_112, "3DES_112"},
		{CALG_3DES, "3DES"},
		{CALG_RC2, "RC2"},
		{CALG_RC4, "RC4"},
		{CALG_SEAL, "SEAL"},
		{CALG_DH_SF, "DH_SF"},
		{CALG_DH_EPHEM, "DH_EPHEM"},
		{CALG_AGREEDKEY_ANY, "AGREEDKEY_ANY"},
		{CALG_KEA_KEYX, "KEA_KEYX"},
		{CALG_SKIPJACK, "SKIPJACK"},
		{CALG_TEK, "TEK"},
	};
	const DWORD  pps_security_algorithms_entries=sizeof(pps_security_algorithms_labels) / sizeof(pps_security_algorithms_labels[0]);
	SET format_pps_security_algorithms = {pps_security_algorithms_entries, pps_security_algorithms_labels};
#else
	extern LABELED_DWORD pps_security_algorithms_labels[];
	extern const DWORD  pps_security_algorithms_entries;
	extern SET format_pps_security_algorithms;
#endif

/////////////////////////////////////
// Strings for Falcon Debug Section
/////////////////////////////////////

//db_debug_reportq_desc
#ifdef MAIN
	LABELED_BYTE db_queue_types_labels[] = 
	{
		{0, "None"},
		{1, "GUID"},
		{2, "Private"},
		{3, "Direct"},
	};
	const DWORD db_queue_types_entries = sizeof(db_queue_types_labels) / sizeof(db_queue_types_labels[0]);
	SET format_db_queue_types = {db_queue_types_entries, db_queue_types_labels};
#else
	extern LABELED_BYTE db_queue_types_labels[];
	extern const DWORD db_queue_types_entries;
	extern SET format_db_queue_types;
#endif

////////////////////////////////////////////
// Strings for Falcon Establish Connection 
////////////////////////////////////////////

//db_sh_flags
#ifdef MAIN
	LABELED_BIT sh_flags_labels[] = 
	{
        {4, "Authenticated    : No", "Authenticated    : Yes"},
        {5, "Encrypted        : No", "Encrypted        : Yes"},
        {6, "Default Provider : No", "Default Provider : Yes"},
        {7, "Extended security info present         : No", "Extended security info present         : Yes"},
        {8, "Extended authentication info present   : No", "Extended authentication info present   : Yes"}
	};
	const DWORD sh_flags_entries= sizeof(sh_flags_labels) / sizeof(sh_flags_labels[0]);
	struct _SET format_sh_flags = {sh_flags_entries, sh_flags_labels};
#else
	extern LABELED_BIT sh_flags_labels[];
	extern const DWORD sh_flags_entries;
	extern struct _SET format_sh_flags;
#endif

////////////////////////////////////////////
// Strings for Falcon Transaction Section
////////////////////////////////////////////
/*
    union {
        ULONG   m_ulFlags;
        struct {
            ULONG m_bfConnector      : 1;
            ULONG m_bfCancelFollowUp : 1;
            ULONG m_bfFirst          : 1;
            ULONG m_bfLast           : 1;
            ULONG m_bfXactIndex      : 20;
        };
    };
*/
//db_sh_flags
#ifdef MAIN
	LABELED_BIT xa_flags_labels[] = 
	{
        {0, "Connector GUID      : Not included",   "Connector GUID      : Included"},
        {1, "Follow up           : Yes",			"Follow up           : Cancelled"},
        {2, "First in transaction: No",				"First in transaction: Yes"},
        {3, "Last in transaction : No",				"Last in transaction : Yes"}
	};
	const DWORD xa_flags_entries= sizeof(xa_flags_labels) / sizeof(xa_flags_labels[0]);
	struct _SET format_xa_flags = {xa_flags_entries, xa_flags_labels};
#else
	extern LABELED_BIT xa_flags_labels[];
	extern const DWORD xa_flags_entries;
	extern struct _SET format_xa_flags;
#endif

////////////////////////////////////////////
// Strings for Ping packet flags
////////////////////////////////////////////
#ifdef MAIN
	LABELED_BIT falPingFlags[] = 
	{
        {0, "Server OS","Non-server OS"},
        {1, "Connection permitted","Connection not permitted"},
	};
	const DWORD dwPingFlagsEntries = 2;
	SET format_falPingFlags = {dwPingFlagsEntries, falPingFlags};
#else
	extern LABELED_BIT falPingFlags[];
	extern const DWORD dwPingFlagsEntries;
	extern SET format_falPingFlags;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\nmparser\utilities.h ===
#ifndef _UTILITIES_
	#define _UTILITIES_
#endif

extern enum MQPortType;
enum MQPortType GetMQPort(HANDLE hFrame, HANDLE hPreviousProtocol, LPBYTE MacFrame);
USHORT usGetMQPort(USHORT usDestPort, USHORT usSourcePort); 
USHORT usGetTCPSourcePort(LPBYTE MacFrame, DWORD nPreviousProtocolOffset);
USHORT usGetTCPDestPort(LPBYTE MacFrame, DWORD nPreviousProtocolOffset);
//DWORD dwGetTCPSeqNum(LPBYTE MacFrame, DWORD nPreviousProtocolOffset);

VOID WINAPIV AttachPropertySequence();
VOID WINAPIV AttachField();
VOID WINAPIV AttachSummary();
VOID WINAPIV AttachAsUnparsable(HFRAME hFrame, LPBYTE lpPosition, DWORD dwBytesLeft);

VOID WINAPIV format_uuid();
VOID WINAPIV format_unix_time();
VOID WINAPIV format_milliseconds();
VOID WINAPIV format_q_format();
VOID WINAPIV format_wstring();
VOID WINAPIV format_sender_id();
VOID WINAPIV format_xa_index(LPPROPERTYINST lpPropertyInst);
BOOL MyGetTextualSid(); // bugbug - not used. Fix or remove
UINT WINAPIV uGetFieldSize(UINT uThisEnum);
enum eMQPacketField WINAPIV uIncrementEnum(enum eMQPacketField uThisEnum);	
void UL2BINSTRING(ULONG ul, char *outstr, int iPad);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\proptree\proptree.cpp ===
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <tchar.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>

//
//  Keeping raw parameters
//
BOOL fQuick       = FALSE;
BOOL fReadOnly    = FALSE;
BOOL fUseStandard = TRUE;

char szFrom[MAX_PATH],
     szTo  [MAX_PATH];

// 
// Excluded types
//
char *szExcludeType[100];
int   cTypes = 0;

//
// Excluded directories
//
char *szExcludeDir[100];
int   cDirs = 0;

//
// Usage 
//
void Usage()
{
	printf("usage: proptree <source> <destination> [-e <exclude extensionx>] [-i <exclude dirs>] [-o] [-s] [-q] \n");
	printf("       The tool compares trees and generates SD script for propagating changes\n"); 
    printf(" -e: exclude types\n"); 
    printf(" -i: exclude subdirectories \n"); 
	printf(" -q: quick compare - just dates/times. Otherwise compares contents\n"); 
	printf(" -o: treat only read-only files\n"); 
	printf(" -s: don't add default ignore types to specified ones\n"); 
    printf("List of excluded extensions: \n\tcomma-separated types, default: \n\t'-e aps,bak,bin,bsc,cnt,cod,cpl,dbg,dll,exe,exp,i,idb,ilk,log,\n\t\tmac,ncb,obj,opt,pch,plg,sbr,tmh,tlh,tli,tlb,mk \n"); 
    printf("List of excluded directories:\n\tcomma-separated names, default:\n\t' -i obj,objd,Checked,Release,Debug,Hleak,bins'\n"); 
    exit(0);
}

//
// Exclusion housekeeping
//

void AddExcludeType(char *type)
{
    if (cTypes < sizeof(szExcludeType)/sizeof(char *))
    {
        szExcludeType[cTypes] = new char[strlen(type)+1];  
        strcpy(szExcludeType[cTypes], type); 
        cTypes++;
    }
    else
    {
        printf("Error - too many exclude types\n");
    }
}

void AddExcludeDir(char *dir)
{
    if (cDirs < sizeof(szExcludeDir)/sizeof(char *))
    {
        szExcludeDir[cDirs] = new char[strlen(dir)+1];  
        strcpy(szExcludeDir[cDirs], dir); 
        cDirs++;
    }
    else
    {
        printf("Error - too many exclude dirs\n");
    }
}

void AddStandardIgnores()
{
    AddExcludeType("aps");
    AddExcludeType("bak");
    AddExcludeType("bin");
    AddExcludeType("bsc");
    AddExcludeType("cnt");
    AddExcludeType("cod");
    AddExcludeType("cpl");
    AddExcludeType("dbg");
    AddExcludeType("dll");
    AddExcludeType("exe");
    AddExcludeType("exp");
    AddExcludeType("i");
    AddExcludeType("idb");
    AddExcludeType("ilk");
    AddExcludeType("log");
    AddExcludeType("mac");
    AddExcludeType("map");
    AddExcludeType("ncb");
    AddExcludeType("obj");
    AddExcludeType("opt");
    AddExcludeType("pch");
    AddExcludeType("plg");
    AddExcludeType("sbr");
    AddExcludeType("tmh");
    AddExcludeType("mk");
 
	
    AddExcludeDir("obj");
    AddExcludeDir("objd");
    AddExcludeDir("Checked");
    AddExcludeDir("Release");
    AddExcludeDir("Debug");
    AddExcludeDir("Hleak");
    AddExcludeDir("bins");
}

void ParseDirsList(char *szList)
{
   static char separators[] = ",;.\\/";

   char *token = strtok( szList, separators );
   while( token != NULL )
   {
      AddExcludeDir(token);
      token = strtok( NULL, separators );
   }
}

void ParseTypesList(char *szList)
{
   static char separators[] = ",;.\\/";

   char *token = strtok( szList, separators );
   while( token != NULL )
   {
      AddExcludeType(token);
      token = strtok( NULL, separators );
   }
}


BOOL IgnoredDir(char *szName)
{
    for (int i=0; i<cDirs; i++)
    {
        if (_stricmp(szExcludeDir[i], szName)==NULL)
            return TRUE;
    }

    return FALSE;
}

BOOL IgnoredType(char *szName)
{
    char *p = strrchr(szName, '.');
    if (!p)
        p = szName;
    else 
        p++;

    for (int i=0; i<cTypes; i++)
    {
        if (_stricmp(szExcludeType[i], p)==NULL)
            return TRUE;
    }

    return FALSE;
}


BOOL CompareFiles(char *szSubFrom, 
                  char *szSubTo, 
                  WIN32_FIND_DATA *FileData1, 
                  WIN32_FIND_DATA *FileData2)
{
    BOOL fEqualSize = 
        (FileData1->nFileSizeHigh == FileData2->nFileSizeHigh   &&
         FileData1->nFileSizeLow  == FileData2->nFileSizeLow);

    BOOL fEqualDate = (memcmp(&FileData1->ftLastWriteTime, 
                              &FileData2->ftLastWriteTime, sizeof(FILETIME)) == 0);

    if (!fEqualSize)
    {
        return FALSE;   // sizes diff, nothing to check more
    }
    // we are left with equal size only

    if (fEqualDate && fQuick)
    {
        return TRUE;   // when /q, equal sizes and equal dates is enough
    }


    // We don't see immediately that they differ but we are asked to go inside
    BOOL fEqual = TRUE;

    FILE *f1, *f2;
    f1 = fopen(szSubFrom, "rb");
    if (f1 == NULL)
    {
        printf("Error - cannot open file %s, err=0x%x\n", szSubFrom, GetLastError());
        return FALSE;
    }

    f2 = fopen(szSubTo, "rb");
    if (f1 == NULL)
    {
        printf("Error - cannot open file %s, err=0x%x\n", szSubTo, GetLastError());
        fclose(f1);
        return FALSE;
    }

    // Files are of the same length, so enough to be leaded by one of them
    char   data1[1000], data2[1000];
    size_t nCont1=0,      nCont2=0;     
    BOOL   fEof1=FALSE, fEof2=FALSE; 

    for (int i=0; !fEof1 || !fEof2; i++)
    {
        if (!fEof1) 
        {
            nCont1 = fread(data1, 1, sizeof(data1), f1);
            fEof1  = feof(f1);
        }


        if (!fEof2)
        {
            nCont2 = fread(data2, 1, sizeof(data2), f2);
            fEof2  = feof(f2);
        }

        if ((nCont1 != nCont2) || (fEof1 != fEof2))
        {
            fEqual = FALSE;
            break;
        }
        else if ((nCont1==0) && fEof1)
        {
            break;
        }
        else if (memcmp(data1, data2, nCont1)!=0)
        {
            fEqual = FALSE;
            break;
        }
    }
    fclose(f1);
    fclose(f2);
    
    return fEqual;
}

//
// Recursive routine compares 2 pointed directories 
//
void CompareDirs(char *szFrom, char *szTo, BOOL fBackward)
{
	CHAR szPattern[MAX_PATH+3];

	strcpy(szPattern, szFrom); 
	strcat(szPattern, "\\*.*"); 

    HANDLE hEnum;
    WIN32_FIND_DATA FileData;
    hEnum = FindFirstFile(szPattern, &FileData);

    if(hEnum == INVALID_HANDLE_VALUE)
	{
		// no more
        return;
	}

    do
    {
	
   		if (_stricmp(".",   FileData.cFileName)==0  || 
			_stricmp("..",  FileData.cFileName)==0  ||
			_stricmp("slm.ini",  FileData.cFileName)==0)
        {
            continue;
        }

       	CHAR szSubFrom[MAX_PATH];
       	CHAR szSubTo  [MAX_PATH];

       	strcpy(szSubFrom, szFrom); 
        strcat(szSubFrom, "\\"); 
        strcat(szSubFrom,  FileData.cFileName); 

       	strcpy(szSubTo, szTo); 
        strcat(szSubTo, "\\"); 
        strcat(szSubTo,  FileData.cFileName); 

        if (FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            // Comparing directories add/delete/compare

            if (IgnoredDir(FileData.cFileName))
            {
                continue;
            }

            HANDLE hEnum2;
            WIN32_FIND_DATA FileData2;
            hEnum2 = FindFirstFile(szSubTo, &FileData2);
            FindClose(hEnum2);

            if(hEnum2 == INVALID_HANDLE_VALUE)
	        {
		        if (fBackward)
                {
                    // Generate delete: directory has been deleted - 
                    printf("cd /d %s\\%s\n", szFrom, FileData.cFileName);
					printf("sd delete *.*\n");

					CompareDirs(szSubFrom, szSubTo, fBackward);
					printf("cd /d %s\n", szFrom);
					printf("delnode /q %s\n", FileData.cFileName);
                }
                else
                {
                    // Generate add: dir has been added
                    printf("cd /d %s\nmd %s\n", szTo, FileData.cFileName);

                    CompareDirs(szSubFrom, szSubTo, fBackward);            
                }
	        }
            else 
            {   
                CompareDirs(szSubFrom, szSubTo, fBackward);            
            }
        }
        else
        {
            // Treating files add/delete/compare

            if (IgnoredType(FileData.cFileName))
            {
                continue;
            }

            if (fReadOnly && 
                !(FileData.dwFileAttributes & FILE_ATTRIBUTE_READONLY))
            {
                continue;
            }

            HANDLE hEnum2;
            WIN32_FIND_DATA FileData2;
            hEnum2 = FindFirstFile(szSubTo, &FileData2);
            FindClose(hEnum2);

            if(hEnum2 == INVALID_HANDLE_VALUE)
	        {
		        if (fBackward)
                {
                    // Generate delete: file has been deleted
                    printf("cd /d %s\nsd delete %s\n", szFrom, FileData.cFileName);
                }
                else
                {
                    // Generate add: file has been added
                    printf("cd /d %s\ncopy %s\\%s .\nsd add %s\n", 
                            szTo, szFrom, FileData.cFileName, FileData.cFileName);
                }
	        }
            else if (!fBackward)
            {   
                // Detect changes: file might have been changed
                if (!CompareFiles(szSubFrom, szSubTo, &FileData, &FileData2))
                {
                    // Generate in: file has been changed
                    printf("cd /d %s\nsd edit %s\ncopy %s\\%s \n", 
                           szTo, FileData.cFileName, szFrom, FileData.cFileName);
                }
            }
        }


    } while(FindNextFile(hEnum, &FileData));

    FindClose(hEnum);
	return;
}





int _cdecl main( int argc, char *argv[ ])
{
    //
    // Parse parameters
    //

    if (argc < 3)
    {
        Usage();
    }

	strcpy(szFrom, argv[1]);
	strcpy(szTo,   argv[2]);

	for (int i=3; i<argc; i++)
	{
		if (*argv[i] != '-' && *argv[i] != '/')
		{
			printf("Error - Invalid parameter '%s'.\n\n", argv[i]);
            Usage();
		}

		switch (tolower(*(++argv[i])))
		{
		    case 'q':
			    fQuick = TRUE;
			    break;

		    case 'o':
			    fReadOnly = TRUE;
			    break;

		    case 's':
			    fUseStandard = FALSE;
			    break;

            case 'e':
				if (i+1 < argc)
				{
					ParseTypesList(argv[++i]);
				}
				else
				{
					Usage();
				}
			    break;

            case 'i':
				if (i+1 < argc)
				{
					ParseDirsList(argv[++i]);
				}
				else
				{
					Usage();
				}

                break;

		    default:
			    printf("Error - Unknown switch '%s'.\n\n", argv[i]);
                Usage();
		}
	}

    if (fUseStandard)
    {
        AddStandardIgnores();
    }

    // Treat add/change
    CompareDirs(szFrom, szTo, FALSE);

    // Treat delete
    CompareDirs(szTo, szFrom, TRUE);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\nmparser\tracker.h ===
///////////////////////////////////////////////////////////////////////////////////
//	Tracker.H 
//
//	This file defines the queue, and tracking object.
//
//	Modification history:
//	
//	Created:	Andrew Smith	8/25/97
//				Andrew Smith	11/14/97 simplified structure. remove consideration for 
//										 order. Now assume packets are arriving in order.
//										 Queue structure is now overkill, but will leave. 
//										 Too much time to rewrite as list.
//
///////////////////////////////////////////////////////////////////////////////////
#ifndef _TRACKER_
	#define _TRACKER_
#endif

#ifndef _NM_
	#pragma warning(disable: 4200) //obscure zero byte array warnings from bh.h
	#include <parser.h>
#endif

#ifndef _NMMSMQ_
	#include "nmmsmq.h"
#endif


enum eMQPacketField;


	
/////////////////////////////////////////////////////////////////////////////////////
//CMessage stores info about a frame as matched to a known fragmented message and its 
//maintains tracking state and position in the message as information is accrued.
//
// todo - better descriptive comments
//
class CMessage 
{
	public:
		CBaseHeader UNALIGNED *pbh;		//pointer to base header
		CInternalSection UNALIGNED *pis;//pointer to internal section
		CCPSection UNALIGNED *pcp;		//pointer to connection parameters
		CECSection UNALIGNED *pec;		//pointer to establish connection section
		CUserHeader UNALIGNED *puh;		//pointer to user header
		CSecurityHeader UNALIGNED *psh;	//pointer to security header
		CPropertyHeader UNALIGNED *pph; //pointer to property header
		CXactHeader UNALIGNED *pxh;		//pointer to transaction header
		CDebugSection UNALIGNED *pds;	//pointer to debug section
		CSessionSection UNALIGNED *pss;	//pointer to session section

		char szMessageSummary[MAX_SUMMARY_LENGTH]; // high level summary text to attach for the message

		enum eMQPacketField	GetFirstEnum(MQHEADER mqh);	//Returns the first enum for a header
		MQHEADER mqhGetNextHeader();				//Returns header to parse
	//	void	SetNeedHeader(MQHEADER mqh);
		void	SetHeaderCompleted(MQHEADER mqh);	//Sets completion flag for this header

		void	Clear(LPBYTE pNewMessage);			//Resets the fields of the node

		void	Accrue(UINT uByteCount = 0);

		enum	eMQPacketField	uGetCurrentEnum();				//read access to m_uEnumCursor. 
		void	SetCurrentEnum(enum eMQPacketField uThisEnum);	//write access to m_uEnumCursor. // todo bugbug - use enum not UINT for easier debugging

		ULONG	ulGetTotalBytes();					//read access to m_ulTotalBytes. 
		void	SetTotalBytes(ULONG ulNumBytes);	//write access to m_ulTotalBytes. 

		USHORT	usGetNextExpectedHeaders();			//read access to usNextExpectedHeaders. 
		void	SetNextExpectedHeaders(USHORT usHeaderField);	//write access to usNextExpectedHeaders. 

	//	UINT	ulGetEnumBytesLeft();			//read access to m_EnumBytesLeft
	//	void    SetEnumBytesLeft(UINT uBytes);  //write access to m_EnumBytesLeft

		BOOL	bMoreEnums();					//returns TRUE if more enumerations are left to parse through

		void	SetMsgId(ULONG ulMsgId);
		ULONG	GetMsgId();

		bool	IsOrderingAck(CPropertyHeader *pph); 
		void	GenerateOrderingAckSummary(char *szSummary);

	private:
		
		ULONG   m_ulTotalBytes;		//Total byte size of message (accrued from base header)
		//ULONG	m_ulBytesAccrued;	//Bytes accrued so far

		enum eMQPacketField	uStartEnum;	//Enumeration to begin parsing at
		
		enum eMQPacketField	m_uEnumCursor;//next enumeration (field) expected in the Falcon packet.
		
		int		m_iNumFrames;			//number of frames accrued so far
		USHORT	usNextExpectedHeaders;	//the state of expected headers for the next unaccrued frame. 
										//(Interpreted as a bitfield in framerec and framecursor)
		ULONG	m_ulMsgId;			//uniquifier portion of the OBJECTID for this message
		union 
		{
			USHORT bfHeaders;
			struct 
			{
				USHORT need_base_header		:1;
				USHORT need_internal_header	:1;
				USHORT need_CP_section		:1;
				USHORT need_EC_section		:1;
				USHORT need_user_header		:1;
				USHORT need_xact_header		:1;
				USHORT need_security_header	:1;
				USHORT need_property_header	:1;
				USHORT need_debug_section	:1;
				USHORT need_session_section	:1;
				USHORT unused				:6;
			};
		};

};


inline enum eMQPacketField CMessage::uGetCurrentEnum() 
{						
	return(m_uEnumCursor);					
}

inline void CMessage::SetCurrentEnum(enum eMQPacketField uThisEnum) 
{			
	m_uEnumCursor = uThisEnum;
}

inline ULONG CMessage::ulGetTotalBytes() 
{					
	return(m_ulTotalBytes);
}

inline void	CMessage::SetTotalBytes(ULONG ulNumBytes) 
{		
	m_ulTotalBytes = ulNumBytes;
}

inline BOOL CMessage::bMoreEnums() //returns TRUE if more enumerations are left to parse through
{
	return(m_uEnumCursor < db_last_enum);
}

inline USHORT CMessage::usGetNextExpectedHeaders() //read access to usNextExpectedHeaders. 
{			
	return(usNextExpectedHeaders);
}

inline void CMessage::SetNextExpectedHeaders(USHORT usHeaderField) //write access to usNextExpectedHeaders. 
{	
	usNextExpectedHeaders = usHeaderField;
}

inline void CMessage::SetMsgId(ULONG ulMsgId)
{
	m_ulMsgId = ulMsgId;
}

inline ULONG CMessage::GetMsgId() 
{
	return m_ulMsgId;
}


//////////////////////////////////////////////////////////////////////////
//
// The Frame cursor is the object from which the attaching routines 
// actually get their parameter information. It is created fresh from 
// existing frame and message records for each call Netmon makes to 
// falAttach properties.
//
// the object presents a copy of pertinent information from the tracking object  
// including pointers and copies of enumeration fields. The purpose of doing
// this is to insulate the attaching routine from the work of figuring out
// how and if to accrue the info to the tracking object.
//
// the frame cursor will accrue information to the tracking object the firt time through 
// an attach sequence. Then throw away accrual info for subsequent times.
// For the attach routine, it is always the first time through.
//
#define FRAME_SUMMARY_LENGTH	255		//this is the length of the summary string for the frame. 
#define LABEL_ABSTRACT_SIZE		10
class CFrame 
{
	public:
		HFRAME	hFrame;			//handle to Netmon frame
		DWORD   dwRawFrameNum;	//Ordinal Netmon frame number (ordinal for the capture)
		DWORD	dwSize;			//bytes in this frame

		DWORD	dwBytesLeft;	//bytes left in this frame
		LPBYTE  packet_pos;		//position in the frame
		bool	bMultipleMessages; //frame contains multiple messages.
		void	Accrue(UINT uNumBytes, UINT uEnum = -1);	//Accrue some bytes and increment the enum cursor
		void	CreateFrom(HFRAME hf, LPBYTE falFrame, DWORD BytesLeft, USHORT usThisSourcePort, CMessage *pMessageNode);
		void	SetFrameCompleted();				//Sets completion and summary info in frame rec
		void	SetFrameIsBody();					//Marks a frame as completely containing body
		void	SetFrameEndBody(DWORD dwFragSize);
		void	SetLabel();							//Sets pointer to label in buffer.
		bool	SeekToBaseHeader();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\nmparser\utilities.cpp ===
#include "stdafx.h"	
#define private public
	#include <mqformat.h>
#undef private

#include "FalconDB.h"

extern HPROTOCOL hTCP;
extern USHORT g_uMasterIndentLevel;

#define UDP_SOURCE_PORT_OFFSET 0
#define UDP_DEST_PORT_OFFSET 2

#define TCP_SOURCE_PORT_OFFSET 0
#define TCP_DEST_PORT_OFFSET 2
#define TCP_SEQ_NUM_OFFSET 4

enum MQPreviousProtocol
{
	eTCP,
	eUDP,
	eIP,
	eSPX,
	eIPX,
	eRPC,
	eNoProtocol
};

void UL2BINSTRING(ULONG ul, char *outstr, int iPad)
{
	sprintf(outstr, "");
	char szTemp[33];
	sprintf(szTemp, "");
	szTemp[iPad]='\0';
	while(iPad-- || ul)
	{
		if(ul & 1)
		{
			szTemp[iPad]='1';
		}
		else
		{
			szTemp[iPad]='0';
		}
		ul /= 2;
	}
	sprintf(outstr, szTemp);
}

// UDP port offsets are the same as TCP 
USHORT usGetTCPSourcePort(LPBYTE MacFrame, DWORD nPreviousProtocolOffset) 
{
	USHORT usPort;
	usPort = *((USHORT *)(MacFrame + nPreviousProtocolOffset + TCP_SOURCE_PORT_OFFSET));
	SWAPBYTES(usPort);
	return(usPort);
}

USHORT usGetTCPDestPort(LPBYTE MacFrame, DWORD nPreviousProtocolOffset)
{
	USHORT usPort;
	usPort = *((USHORT *)(MacFrame + nPreviousProtocolOffset + TCP_DEST_PORT_OFFSET));
	SWAPBYTES(usPort);
	return(usPort);
}

USHORT usGetSPXSourcePort(LPBYTE MacFrame, DWORD nPreviousProtocolOffset) {
	USHORT usPort, usPort2;

	usPort = *((USHORT *)(MacFrame + nPreviousProtocolOffset + TCP_SOURCE_PORT_OFFSET));
	usPort2 = usPort;
	SWAPBYTES(usPort);

	return(usPort);
}

USHORT usGetSPXDestPort(LPBYTE MacFrame, DWORD nPreviousProtocolOffset)
{
	USHORT usPort, usPort2;

	usPort = *((USHORT *)(MacFrame + nPreviousProtocolOffset + TCP_DEST_PORT_OFFSET));
	usPort2 = usPort;
	SWAPBYTES(usPort);

	return(usPort);
}

DWORD dwGetTCPSeqNum(LPBYTE MacFrame, DWORD nPreviousProtocolOffset)
{
	DWORD uSeq, uSeq2;

	uSeq = *((DWORD *)(MacFrame + nPreviousProtocolOffset + TCP_SEQ_NUM_OFFSET));
	uSeq2 = uSeq;
	SWAPWORDS(uSeq);		

	return(uSeq);
}


USHORT usGetMQPort(USHORT usDestPort, USHORT usSourcePort) 
{
	switch (usDestPort) 
	{
	case 1801:
		return(1801);
	case 2101:
		return(2101);
	case 2103:
		return(2103);
	case 2105:
		return(2105);
	case 3527:
		return(3527);
	default:
		break;
	}//switch

	switch (usSourcePort) 
	{
	case 1801:
		return(1801);
	case 2101:
		return(2101);
	case 2103:
		return(2103);
	case 2105:
		return(2105);
	case 3527:
		return(3527);
	default:
		break;
	}//switch
	return(NULL); //no MQ port found
}

enum MQPreviousProtocol MyGetPreviousProtocol(HANDLE hPreviousProtocol)
{
	LPPROTOCOLINFO lpPreviousProtocolInfo = GetProtocolInfo((struct _PROTOCOL *)hPreviousProtocol);
	int iResult = strcmp((const char *)lpPreviousProtocolInfo->ProtocolName, "UDP");
	if (iResult == 0)
	{
		return eUDP;
	}
	
	iResult = strcmp((const char *)lpPreviousProtocolInfo->ProtocolName, "TCP");
	if (iResult == 0)
	{
		return eTCP;
	}
	return eNoProtocol;
}


enum MQPortType GetMQPort(HANDLE hFrame, HANDLE hPreviousProtocol, LPBYTE MacFrame)
{
	enum MQPortType eThisMQPort = eNonMSMQPort;
	USHORT usThisSourcePort;
	USHORT usThisDestPort;
	USHORT usMQPort;
	//
	// extract both source and destination ports
	//
	
	//
	// todo - add support for SPX, RPC, etc. for now consider only TCP and UDP
	//
	// todo - differentiate Remote Read and Dep Client - they use the same ports
	// todo - differentiate UDP ping from regular falcon traffic - both got to 1801 but with diff protocols
	//
	enum MQPreviousProtocol ePreviousProtocol = MyGetPreviousProtocol(hPreviousProtocol);
	DWORD  dwPreviousProtocolOffset;
	switch(ePreviousProtocol)
	{
	case eTCP:
		//extern DWORD                WINAPI GetProtocolStartOffset(HFRAME hFrame, LPSTR ProtocolName);
		dwPreviousProtocolOffset = GetProtocolStartOffset((HFRAME) hFrame, "TCP");

 		usThisDestPort = usGetTCPDestPort(MacFrame, dwPreviousProtocolOffset);
		usThisSourcePort = usGetTCPSourcePort(MacFrame, dwPreviousProtocolOffset);
		usMQPort = usGetMQPort(usThisDestPort, usThisSourcePort);
		switch(usMQPort)
		{
		case 1801:
			return eFalconPort;
		case 2101:
			return eMQISPort;
		case 2103:
		case 2105:
			return eRemoteReadPort;
		default:
			return eNonMSMQPort;
		}

		break;

	case eUDP:
		dwPreviousProtocolOffset = GetProtocolStartOffset((HFRAME) hFrame, "UDP");
 		usThisDestPort = usGetTCPDestPort(MacFrame, dwPreviousProtocolOffset);
		usThisSourcePort = usGetTCPSourcePort(MacFrame, dwPreviousProtocolOffset);
		usMQPort = usGetMQPort(usThisDestPort, usThisSourcePort);
		switch(usMQPort)
		{
		case 1801:
			return eServerDiscoveryPort;
		case 3527:
			return eServerPingPort;
		default:
			return eNonMSMQPort;
		}
	default:
		return eNonMSMQPort;
	}
}

VOID WINAPIV AttachField(HFRAME hFrame, LPBYTE lpPosition, int iEnum) //attaches one field from the enumeration
{
	AttachPropertyInstance(hFrame,
                           falcon_database[iEnum].hProperty,
                           falFieldInfo[iEnum].length,
                           lpPosition, 
                           NO_HELP_ID, falFieldInfo[iEnum].indent_level + g_uMasterIndentLevel, falFieldInfo[iEnum].flags);
}

VOID 
WINAPIV 
AttachPropertySequence( 
	HFRAME    hFrame,
    LPBYTE    falFrame,
	int iFirstProp,
	int iLastProp
	) 
/*******************************************************************************

  Routine Description:
	This utility will attach a sequence of properties based on a start and end point 
	in the enumeration. (defined in falconDB.h)

  Arguments:
	hFrame - BH generated handle to current network frame
	falFrame - pointer to start of MSMQ data in the frame
	iFirstProp - starting point
	iLastProp - stopping point

  Return Value: None

  Note:	this routine relies on information that has been predefined in falcon_database[]
			and falFieldInfo[] (defined in falconDB.h) It will not correctly attach properties
			for which the formatting info cannot be predetermined (e.g. variable length fields.)

********************************************************************************/
{
	int iEnum;
	for(iEnum=iFirstProp; iEnum<=iLastProp; iEnum++)
		AttachField(hFrame, falFrame + falFieldInfo[iEnum].offset, iEnum);
}

VOID WINAPIV AttachSummary(HFRAME hFrame, LPBYTE lpPosition, int iEnum, char *szSummary, DWORD iHighlightBytes) //attaches one field from the enumeration
{
	int iSummaryLength = strlen(szSummary);
	AttachPropertyInstanceEx(hFrame,
                             falcon_database[iEnum].hProperty,
                             iHighlightBytes, lpPosition,
							 iSummaryLength, (void *) szSummary,
                             NO_HELP_ID, falFieldInfo[iEnum].indent_level + g_uMasterIndentLevel, falFieldInfo[iEnum].flags);
}


VOID WINAPIV AttachAsUnparsable(HFRAME hFrame, LPBYTE lpPosition, DWORD dwBytesLeft) {
	AttachPropertyInstance(hFrame,
                           falcon_database[db_unparsable_field].hProperty,
                           dwBytesLeft,
                           lpPosition, 
                           NO_HELP_ID, falFieldInfo[db_unparsable_field].indent_level + g_uMasterIndentLevel, falFieldInfo[db_unparsable_field].flags);
}

//=============================================================================
//  
//  FUNCTION: format_uuid
//
//  Description: Formats a GUID and it's objects label as display text
//
//  Modification History
//
//=============================================================================
VOID WINAPIV format_uuid(LPPROPERTYINST lpPropertyInst)
{
#ifdef DEBUG
		OutputDebugString(L"   format_uuid ... ");
#endif
 GUID UNALIGNED *uuid = (GUID*)lpPropertyInst->lpData;
  _snprintf(lpPropertyInst->szPropertyText, 
            lpPropertyInst->lpPropertyInfo->FormatStringSize,
            "%s = %08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
            lpPropertyInst->lpPropertyInfo->Label,
            uuid->Data1, uuid->Data2, uuid->Data3,
            uuid->Data4[0],
            uuid->Data4[1],
            uuid->Data4[2],
            uuid->Data4[3],
            uuid->Data4[4],
            uuid->Data4[5],
            uuid->Data4[6],
            uuid->Data4[7]
            );
  // Make sure there's a terminating NULL
  lpPropertyInst->szPropertyText[lpPropertyInst->lpPropertyInfo->FormatStringSize - 1] = '\0';
#ifdef DEBUG
		OutputDebugString(L"   Exiting format_uuid\n");
#endif
}

//=============================================================================
//  
//  FUNCTION: format_unix_time
//
//  Description: Formats a dword representing a time stamp as display text
//
//  Modification History
//
//=============================================================================
VOID WINAPIV format_unix_time(LPPROPERTYINST lpPropertyInst)
{
#ifdef DEBUG
		OutputDebugString(L"   format_unix_time ... ");
#endif
  _snprintf(lpPropertyInst->szPropertyText, 
            lpPropertyInst->lpPropertyInfo->FormatStringSize,
            "%s = %.24s",
            lpPropertyInst->lpPropertyInfo->Label,
            ctime((long*)lpPropertyInst->lpDword));

  /*
   * You must be wondering what is that "%.24s", well, ctime() returns
   * a string that is exactly 26 characters long in the following format:
   * Wed Jan 02 02:03:55 1980\n\0
   * alas, we don't want that "\n"
   */
#ifdef DEBUG
		OutputDebugString(L"   Exiting format_unix_time\n");
#endif

}

VOID WINAPIV format_xa_index(LPPROPERTYINST lpPropertyInst)
{
	ULONG uXactIndex=*(((ULONG *)lpPropertyInst->lpData));
	uXactIndex &= 0xFFFFF0;
	uXactIndex /= 0xF; // shift right 4 bits
	char szTemp[21]; //xact index is formatted 20 binary digits
	UL2BINSTRING(uXactIndex, szTemp, 20);
	sprintf(lpPropertyInst->szPropertyText, "........%s....  : Xact Index: %lu", szTemp, uXactIndex);
}

//
// Routine: format milliseconds as days, hours, minutes, seconds
//
VOID WINAPIV format_milliseconds(LPPROPERTYINST lpPropertyInst)
{
	#ifdef DEBUG
		OutputDebugString(L"   format_milliseconds ... ");
	#endif

#define MS_IN_A_DAY 86400000
#define MS_IN_AN_HOUR 3600000
#define MS_IN_A_MIN 60000
#define MS_IN_A_SEC 1000

	DWORD dwTimeInMS = *((DWORD *)(lpPropertyInst->lpData));
	char szTemp[128];
	char szSummary[MAX_SUMMARY_LENGTH];
	sprintf(szSummary, "");

	DWORD dwTimeInDays = dwTimeInMS/MS_IN_A_DAY;
	if(dwTimeInDays > 0)
	{
		sprintf(szTemp, "%lu days ", dwTimeInDays);
		strcat(szSummary, szTemp);
		dwTimeInMS -= (dwTimeInDays*MS_IN_A_DAY);
	}
	DWORD dwTimeInHrs = dwTimeInMS/MS_IN_AN_HOUR;
	if(dwTimeInHrs > 0) 
	{
		sprintf(szTemp, "%lu hrs ", dwTimeInHrs);
		strcat(szSummary, szTemp);
		dwTimeInMS -= (dwTimeInHrs*MS_IN_AN_HOUR);
	}
	DWORD dwTimeInMin = dwTimeInMS/60000;
	if(dwTimeInMin > 0) 
	{
		sprintf(szTemp, "%lu min ", dwTimeInMin);
		strcat(szSummary, szTemp);
		dwTimeInMS -= (dwTimeInMin*MS_IN_A_MIN);
	}
	DWORD dwTimeInSec = dwTimeInMS/1000;
	if(dwTimeInSec >= 0) 
	{
		dwTimeInMS -= (dwTimeInSec*MS_IN_A_SEC);
		sprintf(szTemp, "%lu.%03lu sec ", dwTimeInSec, dwTimeInMS);
		strcat(szSummary, szTemp);
	}

	int iSummaryLength = strlen(szSummary);

	//wsprintf(lpPropertyInst->szPropertyText,"%s: %s (%lu ms)", lpPropertyInst->lpPropertyInfo->Label,szSummary, *((DWORD *)(lpPropertyInst->lpData)));
	sprintf(lpPropertyInst->szPropertyText,"%s: %s (%lu ms)", lpPropertyInst->lpPropertyInfo->Label,szSummary, *((DWORD *)(lpPropertyInst->lpData)));


	#ifdef DEBUG
		OutputDebugString(L"   Exiting format_milliseconds\n");
	#endif
}


VOID WINAPIV format_q_format(LPPROPERTYINST lpPropertyInst)
{
#ifdef DEBUG
		OutputDebugString(L"   format_q_format ... ");
#endif
  wchar_t wcs_formatname[1000];
  ULONG l = sizeof(wcs_formatname);
  QUEUE_FORMAT *qf = (QUEUE_FORMAT*)(lpPropertyInst->lpPropertyInstEx->Byte);

  MQpQueueFormatToFormatName(qf, wcs_formatname, l, &l, true); //bugbug - adding true for new API parm - don't know what it does.
  _snprintf(lpPropertyInst->szPropertyText, 
            lpPropertyInst->lpPropertyInfo->FormatStringSize,
            "%s = %S",
            lpPropertyInst->lpPropertyInfo->Label,
            wcs_formatname);
  // Make sure there's a terminating NULL
  lpPropertyInst->szPropertyText[lpPropertyInst->lpPropertyInfo->FormatStringSize - 1] = '\0';
#ifdef DEBUG
		OutputDebugString(L"   Exiting format_q_format\n");
#endif
}


VOID WINAPIV format_wstring(LPPROPERTYINST lpPropertyInst)
{
#ifdef DEBUG
		OutputDebugString(L"   format_wstring ... ");
#endif
  ULONG l = (ULONG)lpPropertyInst->lpPropertyInstEx->Dword[0];

  _snprintf(lpPropertyInst->szPropertyText, 
            lpPropertyInst->lpPropertyInfo->FormatStringSize,
            "%s = %.*S",
            lpPropertyInst->lpPropertyInfo->Label,
            l,
            (wchar_t*)lpPropertyInst->lpPropertyInstEx->lpData);
  lpPropertyInst->szPropertyText[lpPropertyInst->lpPropertyInfo->FormatStringSize - 1] = '\0';
#ifdef DEBUG
		OutputDebugString(L"   Exiting format_wstring\n");
#endif
}

/*
VOID WINAPIV format_sender_id(LPPROPERTYINST lpPropertyInst)
{
#ifdef DEBUG
		OutputDebugString(L"   format_sender_id ... ");
#endif
 SENDER_ID_INFO *sender_id = (SENDER_ID_INFO*)(lpPropertyInst->lpPropertyInstEx->Byte);

  switch (sender_id->sender_id_type) 
  {
  case 1: // Oracle number: type is SID
    {
      char accname[60]; // BUGBUG 60?
      DWORD cb_accname = 60;
      char domain[60]; // BUGBUG 60?
      DWORD cb_domain=60;
      SID_NAME_USE sid_type;
      
      if (LookupAccountSid(NULL,
                           sender_id->sender_id,
                           accname,
                           &cb_accname,
                           domain,
                           &cb_domain, 
                           &sid_type)) 
	  {
        //wsprintf(lpPropertyInst->szPropertyText, "%s = %s\\%s", lpPropertyInst->lpPropertyInfo->Label, domain, accname);
        sprintf(lpPropertyInst->szPropertyText, "%s = %s\\%s", lpPropertyInst->lpPropertyInfo->Label, domain, accname);
      } 
	  else 
	  {
        //wsprintf(lpPropertyInst->szPropertyText, "Error converting sid"); // BUGBUG: internatiolization
        sprintf(lpPropertyInst->szPropertyText, "Error converting sid"); // BUGBUG: internatiolization
      }
    }
    break;
  case '2': // Oracle number source QM guid
    {
      GUID UNALIGNED *uuid = (GUID*)sender_id->sender_id;
      _snprintf(lpPropertyInst->szPropertyText,
                lpPropertyInst->lpPropertyInfo->FormatStringSize,
                "%s = %08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                lpPropertyInst->lpPropertyInfo->Label,
                uuid->Data1, uuid->Data2, uuid->Data3,
                uuid->Data4[0],
                uuid->Data4[1],
                uuid->Data4[2],
                uuid->Data4[3],
                uuid->Data4[4],
                uuid->Data4[5],
                uuid->Data4[6],
                uuid->Data4[7]
                );
      // Make sure there's a terminating NULL
      lpPropertyInst->szPropertyText[lpPropertyInst->lpPropertyInfo->FormatStringSize - 1] = '\0';
    }
    break;
  }
#ifdef DEBUG
		OutputDebugString(L"   Exiting format_sender_id\n");
#endif
}
*/

/*
BOOL MyGetTextualSid(
    PSID pSid,          // binary SID
    LPSTR TextualSID,   // buffer for textual representaion of SID
    LPDWORD dwBufferLen // required/provided TextualSid buffersize
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

#ifdef DEBUG
		OutputDebugString(L"   MyGetTextualSid ... ");
#endif

    //
    // test if SID passed in is valid
    //
    if(!IsValidSid(pSid))
		return FALSE;

    // obtain SidIdentifierAuthority
    psia=GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities=*GetSidSubAuthorityCount(pSid);

    //
    // compute buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    dwSidSize = 15 + 12 + (12 * dwSubAuthorities) + 1;

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if (*dwBufferLen < dwSidSize)
    {
        *dwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    //wsprintf(TextualSID, "S-%lu-", dwSidRev );
    sprintf(TextualSID, "S-%lu-", dwSidRev );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
      wsprintf(TextualSID + lstrlen(TextualSID),
           "0x%02hx%02hx%02hx%02hx%02hx%02hx",
           (USHORT)psia->Value[0],
           (USHORT)psia->Value[1],
           (USHORT)psia->Value[2],
           (USHORT)psia->Value[3],
           (USHORT)psia->Value[4],
           (USHORT)psia->Value[5]);
    }
    else
    {
      wsprintf(TextualSID + lstrlen(TextualSID), "%lu",
           (ULONG)(psia->Value[5]      )   +
           (ULONG)(psia->Value[4] <<  8)   +
           (ULONG)(psia->Value[3] << 16)   +
           (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
      wsprintf(TextualSID + lstrlen(TextualSID), "-%lu",
           *GetSidSubAuthority(pSid, dwCounter) );
    }
#ifdef DEBUG
		OutputDebugString(L"   Exiting MyGetTextualSid\n");
#endif

    return TRUE;
}
*/



UINT WINAPIV uGetFieldSize(UINT uThisEnum) 
{
	return((UINT) falFieldInfo[uThisEnum].length);
}

/*EXTERN*/ enum eMQPacketField WINAPIV uIncrementEnum(enum eMQPacketField uThisEnum) 
{

	int i;
	enum eMQPacketField uResultEnum;
	
	i = uThisEnum;
	i++;
	uResultEnum = (enum eMQPacketField)i;

	return (uResultEnum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\secserv\rpccli.cpp ===
//
// file:  srpcli.cpp
//
#ifndef UNICODE
#define  UNICODE
#define _UNICODE
#endif

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>

#include "secrpc.h"
#include "secserv.h"


//+-----------------------------------
//
// RPC_STATUS  CreateRpcBindingW()
//
//+-----------------------------------

RPC_STATUS  CreateRpcBindingW( WCHAR  wszProtocol[],
                               WCHAR  wszEndpoint[],
                               WCHAR  wszOptions[],
                               WCHAR  wszServerName[],
                               ULONG  ulAuthnService,
                               ULONG  ulAuthnLevel,
                               BOOL   fService,
                               handle_t *phBind )
{
    ULONG ulMaxCalls = 1000 ;
    ULONG ulMinCalls = 1 ;
    handle_t hBind = NULL ;
    WCHAR *wszStringBinding = NULL;

    RPC_STATUS status = RpcStringBindingCompose( NULL,  // pszUuid,
                                                 wszProtocol,
                                                 wszServerName,
                                                 wszEndpoint,
                                                 wszOptions,
                                                 &wszStringBinding);
    if (!fService)
    {
        DBG_PRINT_INFO((TEXT("RpcStringBindingCompose() return %s, %lut"),
                                               wszStringBinding, status)) ;
    }
    if (status != RPC_S_OK)
    {
        return status ;
    }

    status = RpcBindingFromStringBinding(wszStringBinding,
                                         &hBind);
    if (!fService)
    {
        DBG_PRINT_INFO((
            TEXT("RpcBindingFromStringBinding() return %lut"), status)) ;
    }
    if (status != RPC_S_OK)
    {
        return status ;
    }

    status = RpcStringFree(&wszStringBinding);
    if (!fService)
    {
        DBG_PRINT_INFO((TEXT("RpcStringFree() return %lut"), status)) ;
    }
    if (status != RPC_S_OK)
    {
        return status ;
    }

    RPC_SECURITY_QOS   SecQOS;

    SecQOS.Version = RPC_C_SECURITY_QOS_VERSION;
    SecQOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    SecQOS.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
    WCHAR * wszPrincipalName;
    BOOL fRpcFree;
    if ((ulAuthnService == RPC_C_AUTHN_GSS_NEGOTIATE) ||
        (ulAuthnService == RPC_C_AUTHN_GSS_KERBEROS))
    {
        SecQOS.ImpersonationType = RPC_C_IMP_LEVEL_DELEGATE;
        // kerberos needs principal name
        status = RpcMgmtInqServerPrincName(hBind, ulAuthnService, &wszPrincipalName);
        if (status != RPC_S_OK)
        {
            if (!fService)
            {
                DBG_PRINT_INFO((TEXT(
                  "RpcMgmtInqServerPrincName(Service- %lut) returned %lut"),
                                           ulAuthnService, status)) ;
            }
//            // hack to test
//            wszPrincipalName = L"RAANANHL$@RAANANHD.MICROSOFT.COM";
            wszPrincipalName = NULL;
            fRpcFree = FALSE;
        }
        else
        {
            fRpcFree = TRUE;
        }
    }
    else //ntlm
    {
        SecQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
        wszPrincipalName = NULL;
    }

    status = RpcBindingSetAuthInfoEx( hBind,
                                      wszPrincipalName,
                                      ulAuthnLevel,
                                      ulAuthnService,
                                      NULL,
                                      RPC_C_AUTHZ_NONE,
                                      &SecQOS );
    if (wszPrincipalName && fRpcFree)
    {
        RpcStringFree(&wszPrincipalName);
    }
    if (!fService)
    {
         DBG_PRINT_INFO((TEXT(
          "RpcBindingSetAuthInfoEx(Service- %lut, Level- %lut) returned %lut"),
                                   ulAuthnService, ulAuthnLevel, status)) ;
    }
    if (status != RPC_S_OK)
    {
        return status ;
    }

    *phBind = hBind ;
    return status ;
}

//+-------------------------------------
//
//  RPC_STATUS  PerformADSITestQueryA()
//
//+-------------------------------------

RPC_STATUS  PerformADSITestQueryA( unsigned char  aszProtocol[],
                              unsigned char  aszEndpoint[],
                              unsigned char  aszOptions[],
                              unsigned char  aszServerName[],
                              ULONG          ulAuthnService,
                              ULONG          ulAuthnLevel,
                              BOOL           fFromGC,
                              BOOL           fWithDC,
                              unsigned char  *pszDCName,
                              unsigned char  *pszSearchValue,
                              unsigned char  *pszSearchRoot,
                              BOOL           fWithCredentials,
                              unsigned char  *pszUserName,
                              unsigned char  *pszUserPwd,
                              BOOL           fWithSecuredAuthentication,
                              BOOL           fImpersonate,
                              char           **ppBuf,
                              BOOL           fService )
{
    WCHAR wszProtocol[ 512 ] ;
    mbstowcs( wszProtocol,
              (char*) (const_cast<unsigned char*> (aszProtocol)),
              sizeof(wszProtocol)/sizeof(WCHAR)) ;

    WCHAR wszEndpoint[ 512 ] ;
    mbstowcs( wszEndpoint,
              (char*) (const_cast<unsigned char*> (aszEndpoint)),
              sizeof(wszEndpoint)/sizeof(WCHAR)) ;

    WCHAR wszServerName[ 512 ] ;
    mbstowcs( wszServerName,
              (char*) (const_cast<unsigned char*> (aszServerName)),
              sizeof(wszServerName)/sizeof(WCHAR)) ;

    WCHAR *pwszOptions = NULL ;
    WCHAR wszOptions[ 512 ] ;
    if (aszOptions)
    {
        mbstowcs( wszOptions,
                  (char*) (const_cast<unsigned char*> (aszOptions)),
                  sizeof(wszOptions)/sizeof(WCHAR)) ;
    }

    handle_t hBind = NULL ;
    RPC_STATUS status =  CreateRpcBindingW( wszProtocol,
                                            wszEndpoint,
                                            wszOptions,
                                            wszServerName,
                                            ulAuthnService,
                                            ulAuthnLevel,
                                            fService,
                                            &hBind ) ;
    if (status != RPC_S_OK)
    {
        return status ;
    }

    ULONG ul = (ULONG) -1 ;
    unsigned char * pbBuf = NULL;

    RpcTryExcept
    {
        ul =  RemoteADSITestQuery( hBind,
                          &pbBuf,
                          fFromGC,
                          fWithDC,
                          pszDCName,
                          pszSearchValue,
                          pszSearchRoot,
                          fWithCredentials,
                          pszUserName,
                          pszUserPwd,
                          fWithSecuredAuthentication,
                          fImpersonate);
    }
    RpcExcept(1)
    {
        ul = RpcExceptionCode();
    }
    RpcEndExcept

    if (pbBuf)
    {
        WCHAR wszOut[ PIPE_BUFFER_LEN ] ;
        mbstowcs( wszOut,
                  (char*) (const_cast<unsigned char*> (pbBuf)),
                  sizeof(wszOut)/sizeof(WCHAR)) ;
        if (!fService)
        {
            DBG_PRINT_INFO((
                    TEXT("RemoteADSITestQuery() used auth-service %lu, returned %lx\n%s"), ulAuthnService, ul, wszOut)) ;
        }

        if (ppBuf)
        {
            *ppBuf = (char*) pbBuf ;
        }
        else
        {
            midl_user_free(pbBuf) ;
        }
    }
    else if (!fService)
    {
        DBG_PRINT_INFO((TEXT("RemoteADSITestQuery() used auth-service %lu, returned %lx"), ulAuthnService, ul)) ;
    }

    status = RpcBindingFree(&hBind);

    if (ul != 0)
    {
        return ul ;
    }
    return status ;
}


//+-------------------------------------
//
//  RPC_STATUS  PerformADSITestCreateA()
//
//+-------------------------------------

RPC_STATUS  PerformADSITestCreateA( unsigned char  aszProtocol[],
                              unsigned char  aszEndpoint[],
                              unsigned char  aszOptions[],
                              unsigned char  aszServerName[],
                              ULONG          ulAuthnService,
                              ULONG          ulAuthnLevel,
                              BOOL           fWithDC,
                              unsigned char  *pszDCName,
                              unsigned char  *pszObjectName,
                              unsigned char  *pszDomain,
                              BOOL           fWithCredentials,
                              unsigned char  *pszUserName,
                              unsigned char  *pszUserPwd,
                              BOOL           fWithSecuredAuthentication,
                              BOOL           fImpersonate,
                              char           **ppBuf,
                              BOOL           fService )
{
    WCHAR wszProtocol[ 512 ] ;
    mbstowcs( wszProtocol,
              (char*) (const_cast<unsigned char*> (aszProtocol)),
              sizeof(wszProtocol)/sizeof(WCHAR)) ;

    WCHAR wszEndpoint[ 512 ] ;
    mbstowcs( wszEndpoint,
              (char*) (const_cast<unsigned char*> (aszEndpoint)),
              sizeof(wszEndpoint)/sizeof(WCHAR)) ;

    WCHAR wszServerName[ 512 ] ;
    mbstowcs( wszServerName,
              (char*) (const_cast<unsigned char*> (aszServerName)),
              sizeof(wszServerName)/sizeof(WCHAR)) ;

    WCHAR *pwszOptions = NULL ;
    WCHAR wszOptions[ 512 ] ;
    if (aszOptions)
    {
        mbstowcs( wszOptions,
                  (char*) (const_cast<unsigned char*> (aszOptions)),
                  sizeof(wszOptions)/sizeof(WCHAR)) ;
    }

    handle_t hBind = NULL ;
    RPC_STATUS status =  CreateRpcBindingW( wszProtocol,
                                            wszEndpoint,
                                            wszOptions,
                                            wszServerName,
                                            ulAuthnService,
                                            ulAuthnLevel,
                                            fService,
                                            &hBind ) ;
    if (status != RPC_S_OK)
    {
        return status ;
    }

    ULONG ul = (ULONG) -1 ;
    unsigned char * pbBuf = NULL;

    RpcTryExcept
    {
        ul =  RemoteADSITestCreate( hBind,
                          &pbBuf,
                          fWithDC,
                          pszDCName,
                          pszObjectName,
                          pszDomain,
                          fWithCredentials,
                          pszUserName,
                          pszUserPwd,
                          fWithSecuredAuthentication,
                          fImpersonate);
    }
    RpcExcept(1)
    {
        ul = RpcExceptionCode();
    }
    RpcEndExcept

    if (pbBuf)
    {
        WCHAR wszOut[ PIPE_BUFFER_LEN ] ;
        mbstowcs( wszOut,
                  (char*) (const_cast<unsigned char*> (pbBuf)),
                  sizeof(wszOut)/sizeof(WCHAR)) ;
        if (!fService)
        {
            DBG_PRINT_INFO((
                    TEXT("RemoteADSITestCreate() used auth-service %lu, returned %lx\n%s"), ulAuthnService, ul, wszOut)) ;
        }

        if (ppBuf)
        {
            *ppBuf = (char*) pbBuf ;
        }
        else
        {
            midl_user_free(pbBuf) ;
        }
    }
    else if (!fService)
    {
        DBG_PRINT_INFO((TEXT("RemoteADSITestCreate() used auth-service %lu, returned %lx"), ulAuthnService, ul)) ;
    }

    status = RpcBindingFree(&hBind);

    if (ul != 0)
    {
        return ul ;
    }
    return status ;
}

/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\secserv\seccli.h ===
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: seccli.h
//
//  AUTHOR: Craig Link
//          Doron Juster
//
//
//  Comments:  The use of this header file and the accompanying service.c
//  file simplifies the process of writting a service.  You as a developer
//  simply need to follow the TODO's outlined in this header file, and
//  implement the ServiceStart() and ServiceStop() functions.
//
//  There is no need to modify the code in service.c.  Just add service.c
//  to your project and link with the following libraries...
//
//  libcmt.lib kernel32.lib advapi.lib shell32.lib
//
//  This code also supports unicode.  Be sure to compile both service.c and
//  and code #include "service.h" with the same Unicode setting.
//
//  Upon completion, your code will have the following command line interface
//
//  <service exe> -?                to display this list
//  <service exe> -install          to install the service
//  <service exe> -remove           to remove the service
//  <service exe> -debug <params>   to run as a console app for debugging
//
//  Note: This code also implements Ctrl+C and Ctrl+Break handlers
//        when using the debug option.  These console events cause
//        your ServiceStop routine to be called
//
//        Also, this code only handles the OWN_SERVICE service type
//        running in the LOCAL_SYSTEM security context.
//
//        To control your service ( start, stop, etc ) you may use the
//        Services control panel applet or the NET.EXE program.
//
//        To aid in writing/debugging service, the
//        SDK contains a utility (MSTOOLS\BIN\SC.EXE) that
//        can be used to control, configure, or obtain service status.
//        SC displays complete status for any service/driver
//        in the service database, and allows any of the configuration
//        parameters to be easily changed at the command line.
//        For more information on SC.EXE, type SC at the command line.
//

#ifndef _SERVICE_H
#define _SERVICE_H

#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif


//////////////////////////////////////////////////////////////////////////////
//// todo: change to desired strings
////
// name of the executable
#define SZAPPNAME            "SecServC"

// internal name of the service.
// this name is used in the "net start" and "net stop" commands.
#define SZCLISERVICENAME        "AdsCliService"

// displayed name of the service
#define SZCLISERVICEDISPLAYNAME  TEXT("MSMQ ADSI Security Client Service")

// list of service dependencies - "dep1\0dep2\0\0"
#define SZDEPENDENCIES       ""

//
// Name of Pipe to be used.
//
#define PIPE_CLI_NAME  TEXT("\\\\.\\pipe\\SecCliService")

//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// todo: ServiceStart()must be defined by in your code.
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
VOID ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
VOID ServiceStop();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);


//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
VOID AddToMessageLog(LPTSTR lpszMsg, WORD wType = EVENTLOG_ERROR_TYPE) ;
//////////////////////////////////////////////////////////////////////////////


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\secserv\secrpc.h ===
//
// file: secrpc.h
//
//  Common definitions for the rpc part of this test.
//
#include "secsif.h"

typedef unsigned char * LPUSTR ;

#define PROTOSEQ_TCP_A  ((LPUSTR) "ncacn_ip_tcp")
#define PROTOSEQ_TCP_W  (L"ncacn_ip_tcp")
#define ENDPOINT_TCP_A  ((LPUSTR) "4010")
#define ENDPOINT_TCP_W  (L"4010")
#define OPTIONS_TCP_A   ((LPUSTR) "")
#define OPTIONS_TCP_W   (L"")


RPC_STATUS  PerformADSITestQueryA( unsigned char  aszProtocol[],
                              unsigned char  aszEndpoint[],
                              unsigned char  aszOptions[],
                              unsigned char  aszServerName[],
                              ULONG          ulAuthnService,
                              ULONG          ulAuthnLevel,
                              BOOL           fFromGC,
                              BOOL           fWithDC,
                              unsigned char  *pszDCName,
                              unsigned char  *pszSearchValue,
                              unsigned char  *pszSearchRoot,
                              BOOL           fWithCredentials,
                              unsigned char  *pszUserName,
                              unsigned char  *pszUserPwd,
                              BOOL           fWithSecuredAuthentication,
                              BOOL           fImpersonate,
                              char           **ppBuf,
                              BOOL           fService = FALSE );

RPC_STATUS  PerformADSITestCreateA( unsigned char  aszProtocol[],
                              unsigned char  aszEndpoint[],
                              unsigned char  aszOptions[],
                              unsigned char  aszServerName[],
                              ULONG          ulAuthnService,
                              ULONG          ulAuthnLevel,
                              BOOL           fWithDC,
                              unsigned char  *pszDCName,
                              unsigned char  *pszObjectName,
                              unsigned char  *pszDomain,
                              BOOL           fWithCredentials,
                              unsigned char  *pszUserName,
                              unsigned char  *pszUserPwd,
                              BOOL           fWithSecuredAuthentication,
                              BOOL           fImpersonate,
                              char           **ppBuf,
                              BOOL           fService = FALSE );


#ifdef UNICODE
#define PROTOSEQ_TCP    PROTOSEQ_TCP_W
#define ENDPOINT_TCP    ENDPOINT_TCP_W
#define OPTIONS_TCP     OPTIONS_TCP_W
#else
#define PerformADSITestQuery  PerformADSITestQueryA
#define PerformADSITestCreate PerformADSITestCreateA
#define PROTOSEQ_TCP     PROTOSEQ_TCP_A
#define ENDPOINT_TCP     ENDPOINT_TCP_A
#define OPTIONS_TCP      OPTIONS_TCP_A
#endif

//---------------------------------
//
//  Definitions for debugging
//
//---------------------------------

#ifdef _DEBUG
#define DBG_PRINT_ERROR(x)  _tprintf x ; printf("\n") ;
#define DBG_PRINT_WARN(x)   _tprintf x ; printf("\n") ;
#define DBG_PRINT_TRACE(x)  _tprintf x ; printf("\n") ;
#define DBG_PRINT_INFO(x)   _tprintf x ; printf("\n") ;
#else
#define DBG_PRINT_ERROR(x)
#define DBG_PRINT_WARN(x)
#define DBG_PRINT_TRACE(x)
#define DBG_PRINT_INFO(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\secserv\secserv.h ===
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: secserv.h
//
//  AUTHOR: Craig Link
//          Doron Juster
//
//
//  Comments:  The use of this header file and the accompanying service.c
//  file simplifies the process of writting a service.  You as a developer
//  simply need to follow the TODO's outlined in this header file, and
//  implement the ServiceStart() and ServiceStop() functions.
//
//  There is no need to modify the code in service.c.  Just add service.c
//  to your project and link with the following libraries...
//
//  libcmt.lib kernel32.lib advapi.lib shell32.lib
//
//  This code also supports unicode.  Be sure to compile both service.c and
//  and code #include "service.h" with the same Unicode setting.
//
//  Upon completion, your code will have the following command line interface
//
//  <service exe> -?                to display this list
//  <service exe> -install          to install the service
//  <service exe> -remove           to remove the service
//  <service exe> -debug <params>   to run as a console app for debugging
//
//  Note: This code also implements Ctrl+C and Ctrl+Break handlers
//        when using the debug option.  These console events cause
//        your ServiceStop routine to be called
//
//        Also, this code only handles the OWN_SERVICE service type
//        running in the LOCAL_SYSTEM security context.
//
//        To control your service ( start, stop, etc ) you may use the
//        Services control panel applet or the NET.EXE program.
//
//        To aid in writing/debugging service, the
//        SDK contains a utility (MSTOOLS\BIN\SC.EXE) that
//        can be used to control, configure, or obtain service status.
//        SC displays complete status for any service/driver
//        in the service database, and allows any of the configuration
//        parameters to be easily changed at the command line.
//        For more information on SC.EXE, type SC at the command line.
//

#ifndef _SERVICE_H
#define _SERVICE_H

#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif


//////////////////////////////////////////////////////////////////////////////
//// todo: change to desired strings
////
// name of the executable
#define SZAPPNAME            "SecServS"

// internal name of the service.
// this name is used in the "net start" and "net stop" commands.
#define SZSERVICENAME        "AdsSecService"

// displayed name of the service
#define SZSERVICEDISPLAYNAME  TEXT("MSMQ ADSI Security Test Service")

// list of service dependencies - "dep1\0dep2\0\0"
#define SZDEPENDENCIES       ""

//
// Name of Pipe to be used.
//
#define PIPE_NAME  TEXT("\\\\.\\pipe\\SecService")

//////////////////////////////////////////////////////////////////////////////

/////////////////////
//
//  Commands
//
/////////////////////

#define CMD_LAST  (TEXT("last"))
#define CMD_CRED  (TEXT("cred"))
#define CMD_RPCS  (TEXT("rpcs"))
#define CMD_QUIT  (TEXT("quit"))

//////////////////////////////////////////////////////////////////////////////
//// todo: ServiceStart()must be defined by in your code.
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
VOID ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
VOID ServiceStop();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);


//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
VOID AddToMessageLog(LPTSTR lpszMsg, WORD wType = EVENTLOG_ERROR_TYPE) ;
//////////////////////////////////////////////////////////////////////////////

//
// Size definitions
//
#define PIPE_BUFFER_LEN  5000

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\secserv\cliserv\cliserv.h ===
//
// file: clieserv.h
//


//
// command for cliserv
//

#define CMD_LAST  (TEXT("last"))
#define CMD_ADSQ  (TEXT("adsq"))
#define CMD_ADSC  (TEXT("adsc"))
#define CMD_NAME  (TEXT("name"))
#define CMD_DOMN  (TEXT("domn"))
#define CMD_DCNM  (TEXT("dcnm"))
#define CMD_PSWD  (TEXT("pswd"))
#define CMD_NIMP  (TEXT("nimp"))
#define CMD_AUTG  (TEXT("autg"))
#define CMD_AUTK  (TEXT("autk"))
#define CMD_AUTN  (TEXT("autn"))
#define CMD_YKER  (TEXT("yker"))
#define CMD_NKER  (TEXT("nker"))
#define CMD_YSGC  (TEXT("ysgc"))
#define CMD_NOGC  (TEXT("nogc"))
#define CMD_USER  (TEXT("user"))
#define CMD_NUSR  (TEXT("nusr"))
#define CMD_NODC  (TEXT("nodc"))
#define CMD_YIMP  (TEXT("yimp"))
#define CMD_QUIT  (TEXT("quit"))
#define CMD_SRCH  (TEXT("srch"))
#define CMD_ROOT  (TEXT("root"))

#define  PIPE_BUFFER_LEN  5000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\secserv\secclic\secclic.cpp ===
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   secclic.cpp
//
//  PURPOSE:  This program is a command line oriented
//            demonstration of the Simple service sample.
//
//  FUNCTIONS:
//    main(int argc, char **argv);
//
//  COMMENTS:
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "seccli.h"
#include "..\cliserv\cliserv.h"


VOID main(int argc, char *argv[])
{
    char    inbuf[ PIPE_BUFFER_LEN ];
    char    outbuf[ PIPE_BUFFER_LEN ];
    DWORD   bytesRead;
    BOOL    ret;
    LPSTR   lpszPipeName = PIPE_CLI_NAME ;
    int     ndx;

    // allow user to define pipe name
    for ( ndx = 1; ndx <= argc-1; ndx++ )
    {
        BOOL fPrintHelp = FALSE ;

        if ( (*argv[ndx] == '-') || (*argv[ndx] == '/') )
        {
            LPTSTR lpszArg = argv[ndx]+ 1 ;

            if (( _tcsicmp( CMD_LAST, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_YIMP, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_NIMP, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_AUTG, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_AUTK, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_AUTN, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_NUSR, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_YKER, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_NKER, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_NODC, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_YSGC, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_NOGC, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_QUIT, lpszArg ) == 0 ))
            {
                _tcscpy(outbuf, lpszArg) ;
            }
            else if (( _tcsicmp( CMD_USER, lpszArg ) == 0 ) ||
                     ( _tcsicmp( CMD_PSWD, lpszArg ) == 0 ) ||
                     ( _tcsicmp( CMD_NAME, lpszArg ) == 0 ) ||
                     ( _tcsicmp( CMD_DOMN, lpszArg ) == 0 ) ||
                     ( _tcsicmp( CMD_DCNM, lpszArg ) == 0 ) ||
                     ( _tcsicmp( CMD_ADSQ, lpszArg ) == 0 ) ||
                     ( _tcsicmp( CMD_ADSC, lpszArg ) == 0 ) ||
                     ( _tcsicmp( CMD_SRCH, lpszArg ) == 0 ) ||
                     ( _tcsicmp( CMD_ROOT, lpszArg ) == 0 ))
            {
                _tcscpy(outbuf, lpszArg) ;
                ndx++ ;
                if ((ndx >= argc)        ||
                    (*argv[ndx] == '-')  ||
                    (*argv[ndx] == '/'))
                {
                    printf("\n ERROR: missing input\n\n") ;
                    return ;
                }
                _tcscat(outbuf, argv[ndx]) ;
            }
            else if ( _tcsicmp( TEXT("s"), lpszArg ) == 0 )
            {
                _tcscpy(outbuf, TEXT("string: ")) ;
                _tcscat(outbuf, argv[++ndx]) ;
            }
            else
            {
                fPrintHelp = TRUE ;
            }
        }
        else
        {
            fPrintHelp = TRUE ;
        }

        if (fPrintHelp)
        {
            printf("usage: %s -s    <test string>\n", argv[0]);
            printf("\t        -quit (service will stop)\n") ;
            printf("\t        -yimp (use impersonation on server)\n") ;
            printf("\t        -nimp (no impersonation on server)\n") ;
            printf("\t        -user <user name>\n") ;
            printf("\t         \t..user name to use as credentials in ADSI bind\n") ;
            printf("\t        -pswd <password>\n") ;
            printf("\t         \t..user password to use as credentials in ADSI bind\n") ;
            printf("\t        -nusr (don't use credentials in ADSI bind)\n") ;
            printf("\t        -yker (use secured auth (kerberos) with the credentials in ADSI bind)\n") ;
            printf("\t        -nker (don't use secured auth (kerberos) with the credentials in ADSI bind)\n") ;
            printf("\t        -ysgc (use GC: in ADSI query)\n") ;
            printf("\t        -nogc (use LDAP: in ADSI query)\n") ;
            printf("\t        -srch <search-value>\n") ;
            printf("\t         \t..Value to search in description for ADSI query test\n") ;
            printf("\t        -root <root-search DN>\n") ;
            printf("\t         \t..DN of root for ADSI query test\n") ;
            printf("\t        -name <object's name>\n") ;
            printf("\t         \t..name of object to create in ADSI create test\n") ;
            printf("\t        -domn <domain's DN>\n") ;
            printf("\t         \t..DN of domain for ADSI create test\n") ;
            printf("\t        -dcmn <DC name>\n");
            printf("\t         \t..name of a DC to specify in ADSI bind\n") ;
            printf("\t        -nodc (dont specify a DC in ADSI bind)\n") ;
            printf("\t        -adsc <server name>\n") ;
            printf("\t         \t..ADSI create test (rpc). fill domn & name before\n") ;
            printf("\t        -adsq <server name>\n") ;
            printf("\t         \t..ADSI query test (rpc). fill root before\n") ;
            printf("\t        -last (get last RPC string)\n") ;
            exit(1);
        }
    }

    ret = CallNamedPipeA( lpszPipeName,
                          outbuf,
                          sizeof(outbuf),
                          inbuf,
                          sizeof(inbuf),
                          &bytesRead,
                          NMPWAIT_WAIT_FOREVER);

    if (!ret)
    {
        printf("client: CallNamedPipe failed, GetLastError = %d\n",
                                                     GetLastError()) ;
        exit(1);
    }

    printf("%s received:\n%s\n", argv[0], inbuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\secserv\cliserv\client.cpp ===
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   client.cpp
//
//  PURPOSE:  Implements the body of the service.
//            The default behavior is to open a
//            named pipe, \\.\pipe\SecService, and read
//            from it.  It the modifies the data and
//            writes it back to the pipe.
//
//  FUNCTIONS:
//            ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
//            ServiceStop( );
//
//  COMMENTS: The functions implemented in simple.c are
//            prototyped in service.h
//
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//          Doron Juster
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>

#include "seccli.h"
#include "secrpc.h"
#include "cliserv.h"

#define ARRAY_SIZE(rg) (sizeof(rg)/sizeof(rg[0]))

// this event is signalled when the
// service should end
//
HANDLE  hServerStopEvent = NULL;

TCHAR  g_tszLastRpcString[ PIPE_BUFFER_LEN ] ;

TCHAR  g_tszUserName[ 128 ] = {0};
BOOL   g_fImpersonate = TRUE ;
BOOL g_fFromGC = TRUE;
BOOL g_fWithDC = FALSE;
TCHAR g_tszDCName[ 128 ] = {0};
TCHAR g_tszObjectName[ 128 ] = {0};
TCHAR g_tszDomain[ 1024 ] = {0};
TCHAR g_tszSearchRoot[ 1024 ] = {0};
TCHAR g_tszSearchValue[ 128 ] = {0};
TCHAR g_tszUserPwd[ 128 ] = {0};
BOOL g_fWithCredentials = FALSE;
BOOL g_fWithSecuredAuthentication = FALSE;
ULONG g_ulAuthnService = RPC_C_AUTHN_WINNT;

//
//  FUNCTION: ServiceStart
//
//  PURPOSE: Actual code of the service
//           that does the work.
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    The default behavior is to open a
//    named pipe, \\.\pipe\simple, and read
//    from it.  It the modifies the data and
//    writes it back to the pipe.  The service
//    stops when hServerStopEvent is signalled
//

VOID ServiceStart (DWORD dwArgc, LPTSTR *lpszArgv)
{
    HANDLE                  hPipe = INVALID_HANDLE_VALUE;
    HANDLE                  hEvents[2] = {NULL, NULL};
    OVERLAPPED              os;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_ATTRIBUTES     sa;
    TCHAR                   szOut[ PIPE_BUFFER_LEN ];
    LPTSTR                  lpszPipeName = PIPE_CLI_NAME ;
    BOOL                    bRet;
    DWORD                   cbRead;
    DWORD                   cbWritten;
    DWORD                   dwWait;
    UINT                    ndx;
    BOOL                    fContinue = TRUE ;

    ///////////////////////////////////////////////////
    //
    // Service initialization
    //

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
                SERVICE_START_PENDING, // service state
                NO_ERROR,              // exit code
                3000))                 // wait hint
        goto cleanup;

    // create the event object. The control handler function signals
    // this event when it receives the "stop" control code.
    //
    hServerStopEvent = CreateEvent(
            NULL,    // no security attributes
            TRUE,    // manual reset event
            FALSE,   // not-signalled
            NULL);   // no name

    if ( hServerStopEvent == NULL)
        goto cleanup;

    hEvents[0] = hServerStopEvent;

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
            SERVICE_START_PENDING, // service state
            NO_ERROR,              // exit code
            3000))                 // wait hint
        goto cleanup;

    // create the event object object use in overlapped i/o
    //
    hEvents[1] = CreateEvent(
            NULL,    // no security attributes
            TRUE,    // manual reset event
            FALSE,   // not-signalled
            NULL);   // no name

    if ( hEvents[1] == NULL)
        goto cleanup;

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
            SERVICE_START_PENDING, // service state
            NO_ERROR,              // exit code
            3000))                 // wait hint
        goto cleanup;

    // create a security descriptor that allows anyone to write to
    //  the pipe...
    //
    pSD = (PSECURITY_DESCRIPTOR) malloc( SECURITY_DESCRIPTOR_MIN_LENGTH );

    if (pSD == NULL)
        goto cleanup;

    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
        goto cleanup;

    // add a NULL disc. ACL to the security descriptor.
    //
    if (!SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE))
        goto cleanup;

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = TRUE;
    //
    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
            SERVICE_START_PENDING, // service state
            NO_ERROR,              // exit code
            3000))                 // wait hint
        goto cleanup;

    //
    // allow user tp define pipe name
    //
    for ( ndx = 1; ndx < dwArgc-1; ndx++ )
    {
        if ( ( (*(lpszArgv[ndx]) == TEXT('-')) ||
               (*(lpszArgv[ndx]) == TEXT('/')) ) &&
             _tcsicmp( TEXT("pipe"), lpszArgv[ndx]+1 ) == 0 )
        {
            lpszPipeName = lpszArgv[++ndx];
        }
    }
    //
    // open our named pipe...
    //
    hPipe = CreateNamedPipe(
                    lpszPipeName         ,  // name of pipe
                    FILE_FLAG_OVERLAPPED |
                    PIPE_ACCESS_DUPLEX,     // pipe open mode
                    PIPE_TYPE_MESSAGE |
                    PIPE_READMODE_MESSAGE |
                    PIPE_WAIT,              // pipe IO type
                    1,                      // number of instances
                    0,                      // size of outbuf (0 == allocate as necessary)
                    0,                      // size of inbuf
                    1000,                   // default time-out value
                    &sa);                   // security attributes

    if (hPipe == INVALID_HANDLE_VALUE)
    {
        AddToMessageLog(TEXT("Unable to create named pipe"));
        goto cleanup;
    }
    //
    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
            SERVICE_RUNNING,       // service state
            NO_ERROR,              // exit code
            0))                    // wait hint
        goto cleanup;

    AddToMessageLog(TEXT("Ready to accept commands"),
                    EVENTLOG_INFORMATION_TYPE) ;

    ////////////////////////////////////////////////////////////
    //
    // End of initialization
    //
    //
    // Service is now running, perform work until shutdown
    //
    ////////////////////////////////////////////////////////////

    do
    {
        // init the overlapped structure
        //
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );

        // wait for a connection...
        //
        ConnectNamedPipe(hPipe, &os);

        if ( GetLastError() == ERROR_IO_PENDING )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred,
                break;                           // or server stop signaled
        }

        // init the overlapped structure
        //
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );

        // grab whatever's coming through the pipe...
        //
        TCHAR  szIn[ PIPE_BUFFER_LEN ];

        bRet = ReadFile(
                    hPipe,          // file to read from
                    szIn,           // address of input buffer
                    sizeof(szIn),   // number of bytes to read
                    &cbRead,        // number of bytes read
                    &os);           // overlapped stuff, not needed

		DWORD dlastErr0 = GetLastError();
        if ( !bRet && (  dlastErr0 == ERROR_IO_PENDING ) )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
			printf("wait = %lx\n",dwWait);
			if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred,
                break;                           // or server stop signaled
        }
		DWORD dlastErr1 = GetLastError();
		printf("lasterr0 = %lx lasterr1 = %lx hr = %lx in = %s bytes = %d\n",dlastErr0,dlastErr1,bRet,szIn,cbRead);

        //
        // Parse the command
        //
        TCHAR  szCommand[ 5 ] ;
        memcpy(szCommand, szIn, 4 * sizeof(TCHAR)) ;
        szCommand[4] = TEXT('\0') ;
        LPTSTR lpszParam = &szIn[4] ;

        if (_tcsicmp( szCommand, TEXT("quit")) == 0)
        {
            fContinue = FALSE ;
            _stprintf(szOut, TEXT("%s Quitting !!!"), SZCLISERVICEDISPLAYNAME);
        }
        else if (_tcsicmp( szCommand, CMD_NIMP ) == 0)
        {
            _tcscpy(szOut, TEXT("Impersonation disabled")) ;
            g_fImpersonate = FALSE ;
        }
        else if (_tcsicmp( szCommand, CMD_YIMP ) == 0)
        {
            _tcscpy(szOut, TEXT("Impersonation enabled")) ;
            g_fImpersonate = TRUE ;
        }
        else if (_tcsicmp( szCommand, CMD_AUTG ) == 0)
        {
            _tcscpy(szOut, TEXT("RPC to server uses negotiation")) ;
            g_ulAuthnService = RPC_C_AUTHN_GSS_NEGOTIATE ;
        }
        else if (_tcsicmp( szCommand, CMD_AUTK ) == 0)
        {
            _tcscpy(szOut, TEXT("RPC to server uses kerberos")) ;
            g_ulAuthnService = RPC_C_AUTHN_GSS_KERBEROS ;
        }
        else if (_tcsicmp( szCommand, CMD_AUTN ) == 0)
        {
            _tcscpy(szOut, TEXT("RPC to server uses ntlm")) ;
            g_ulAuthnService = RPC_C_AUTHN_WINNT ;
        }
        else if (_tcsicmp( szCommand, CMD_USER ) == 0)
        {
            _tcscpy(g_tszUserName, lpszParam) ;
            g_fWithCredentials = TRUE;
            sprintf(szOut, "enabled credentials in ADSI binding, user=%hs, pswd=%hs, ", g_tszUserName, g_tszUserPwd);
        }
        else if (_tcsicmp( szCommand, CMD_PSWD ) == 0)
        {
            _tcscpy(g_tszUserPwd, lpszParam) ;
            _tcscpy(szOut, g_tszUserPwd) ;
        }
        else if (_tcsicmp( szCommand, CMD_NUSR ) == 0)
        {
            g_fWithCredentials = FALSE;
            _tcscpy(szOut, TEXT("disabled credentials in ADSI binding\n"));
        }
        else if (_tcsicmp( szCommand, CMD_YKER ) == 0)
        {
            g_fWithSecuredAuthentication = TRUE;
            _tcscpy(szOut, "enabled secured authentication(kerberos) in ADSI binding\n");
        }
        else if (_tcsicmp( szCommand, CMD_NKER ) == 0)
        {
            g_fWithSecuredAuthentication = FALSE;
            _tcscpy(szOut, "disabled secured authentication(kerberos) in ADSI binding\n");
        }
        else if (_tcsicmp( szCommand, CMD_DCNM ) == 0)
        {
            _tcscpy(g_tszDCName, lpszParam) ;
            g_fWithDC = TRUE;
            sprintf(szOut, "talk to a specific dc, dc=%hs\n", g_tszDCName);
        }
        else if (_tcsicmp( szCommand, CMD_NODC ) == 0)
        {
            g_fWithDC = FALSE;
            _tcscpy(szOut, TEXT("talk to any dc\n"));
        }
        else if (_tcsicmp( szCommand, CMD_NAME ) == 0)
        {
            _tcscpy(g_tszObjectName, lpszParam) ;
            sprintf(szOut, "name of object to create - %hs\n", g_tszObjectName);
        }
        else if (_tcsicmp( szCommand, CMD_DOMN ) == 0)
        {
            _tcscpy(g_tszDomain, lpszParam) ;
            sprintf(szOut, "distinguished name of domain where testing create - %hs\n", g_tszDomain);
        }
        else if (_tcsicmp( szCommand, CMD_SRCH ) == 0)
        {
            _tcscpy(g_tszSearchValue, lpszParam) ;
            sprintf(szOut, "search for computers with description=%hs\n", g_tszSearchValue);
        }
        else if (_tcsicmp( szCommand, CMD_ROOT ) == 0)
        {
            _tcscpy(g_tszSearchRoot, lpszParam) ;
            sprintf(szOut, "distinguished name of root-search where testing query - %hs\n", g_tszSearchRoot);
        }
        else if (_tcsicmp( szCommand, CMD_YSGC ) == 0)
        {
            g_fFromGC = TRUE;
            _tcscpy(szOut, "use GC:// when testing query\n");
        }
        else if (_tcsicmp( szCommand, CMD_NOGC ) == 0)
        {
            g_fFromGC = FALSE;
            _tcscpy(szOut, "use LDAP:// when testing query\n");
        }
        else if (_tcsicmp( szCommand, CMD_ADSC) == 0)
        {
             g_tszLastRpcString[0] = TEXT('\0') ;
            //
            // Call server side via rpc.
            //
            ULONG ulAuthnLevel  = RPC_C_AUTHN_LEVEL_CONNECT ;
#ifndef UNICODE
            LPUSTR lpszServer = (LPUSTR) lpszParam ;
#endif
            RPC_STATUS status ;
            char *pBuf = NULL ;
            status = PerformADSITestCreate( PROTOSEQ_TCP,
                                      ENDPOINT_TCP,
                                      OPTIONS_TCP,
                                      lpszServer,
                                      g_ulAuthnService,
                                      ulAuthnLevel,
                                      g_fWithDC,
                                      (unsigned char *)g_tszDCName,
                                      (unsigned char *)g_tszObjectName,
                                      (unsigned char *)g_tszDomain,
                                      g_fWithCredentials,
                                      (unsigned char *)g_tszUserName,
                                      (unsigned char *)g_tszUserPwd,
                                      g_fWithSecuredAuthentication,
                                      g_fImpersonate,
                                      &pBuf,
                                      TRUE ) ;
            _stprintf(szOut, TEXT("PerformADSITestCreate on %hs returned %lx\n%s\n"), lpszServer, status, pBuf) ;
            _tcscpy(g_tszLastRpcString, szOut) ;
            if (pBuf)
            {
                midl_user_free(pBuf) ;
            }
        }
        else if (_tcsicmp( szCommand, CMD_ADSQ) == 0)
        {
             g_tszLastRpcString[0] = TEXT('\0') ;
            //
            // Call server side via rpc.
            //
//            ULONG rgulAuthnService[] = {RPC_C_AUTHN_GSS_KERBEROS, RPC_C_AUTHN_WINNT} ;
            ULONG ulAuthnLevel  = RPC_C_AUTHN_LEVEL_CONNECT ;
#ifndef UNICODE
            LPUSTR lpszServer = (LPUSTR) lpszParam ;
#endif
            RPC_STATUS status ;
            char *pBuf = NULL ;
            status = PerformADSITestQuery( PROTOSEQ_TCP,
                                      ENDPOINT_TCP,
                                      OPTIONS_TCP,
                                      lpszServer,
                                      g_ulAuthnService,
                                      ulAuthnLevel,
                                      g_fFromGC,
                                      g_fWithDC,
                                      (unsigned char *)g_tszDCName,
                                      (unsigned char *)g_tszSearchValue,
                                      (unsigned char *)g_tszSearchRoot,
                                      g_fWithCredentials,
                                      (unsigned char *)g_tszUserName,
                                      (unsigned char *)g_tszUserPwd,
                                      g_fWithSecuredAuthentication,
                                      g_fImpersonate,
                                      &pBuf,
                                      TRUE ) ;
            _stprintf(szOut, TEXT("PerformADSITestQuery on %ls returned %lx\n%s\n"), lpszServer, status, pBuf) ;
            _tcscpy(g_tszLastRpcString, szOut) ;
            if (pBuf)
            {
                midl_user_free(pBuf) ;
            }
        }
        else if (_tcsicmp( szCommand, CMD_LAST) == 0)
        {
             _tcscpy(szOut, g_tszLastRpcString) ;
             g_tszLastRpcString[0] = TEXT('\0') ;
        }
        else
        {
            //
            // return the string to client.
            //
            _stprintf(szOut, TEXT("Hello! [%s]"), szIn);
        }

        // init the overlapped structure
        //
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );
        //
        // send it back out...
        //
		printf("szout = %s\n",szOut);
        bRet = WriteFile(
                    hPipe,          // file to write to
                    szOut,          // address of output buffer
                    sizeof(szOut),  // number of bytes to write
                    &cbWritten,     // number of bytes written
                    &os);           // overlapped stuff, not needed

        if ( !bRet && ( GetLastError() == ERROR_IO_PENDING ) )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred,
                break;                           // or server stop signaled
        }
        //
        // drop the connection...
        //
        DisconnectNamedPipe(hPipe);
    }
    while (fContinue) ;

cleanup:

    if (hPipe != INVALID_HANDLE_VALUE )
        CloseHandle(hPipe);

    if (hServerStopEvent)
        CloseHandle(hServerStopEvent);

    if (hEvents[1]) // overlapped i/o event
        CloseHandle(hEvents[1]);

    if ( pSD )
        free( pSD );

}

//
//  FUNCTION: ServiceStop
//
//  PURPOSE: Stops the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    If a ServiceStop procedure is going to
//    take longer than 3 seconds to execute,
//    it should spawn a thread to execute the
//    stop code, and return.  Otherwise, the
//    ServiceControlManager will believe that
//    the service has stopped responding.
//
VOID ServiceStop()
{
    if ( hServerStopEvent )
        SetEvent(hServerStopEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\secserv\secservs\secadsi.h ===
int ADSITestQuery(BOOL fFromGC,
                  BOOL fWithDC,
                  char * pszDCName,
                  char * pszSearchValue,
                  char * pszSearchRoot,
                  BOOL fWithCredentials,
                  char * pszUserName,
                  char * pszUserPwd,
                  BOOL fWithSecuredAuthentication);

int ADSITestCreate(BOOL fWithDC,
                   char * pszDCName,
                   char * pszObjectName,
                   char * pszDomain,
                   BOOL fWithCredentials,
                   char * pszUserName,
                   char * pszUserPwd,
                   BOOL fWithSecuredAuthentication);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\secserv\secservc\secservc.cpp ===
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   client.c
//
//  PURPOSE:  This program is a command line oriented
//            demonstration of the Simple service sample.
//
//  FUNCTIONS:
//    main(int argc, char **argv);
//
//  COMMENTS:
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "secserv.h"


VOID main(int argc, char *argv[])
{
    char    inbuf[ PIPE_BUFFER_LEN ];
    char    outbuf[ PIPE_BUFFER_LEN ];
    DWORD   bytesRead;
    BOOL    ret;
    LPSTR   lpszPipeName = PIPE_NAME ;
    int     ndx;

    // allow user to define pipe name
    for ( ndx = 1; ndx <= argc-1; ndx++ )
    {
        BOOL fPrintHelp = FALSE ;

        if ( (*argv[ndx] == '-') || (*argv[ndx] == '/') )
        {
            LPTSTR lpszArg = argv[ndx]+ 1 ;

            if (( _tcsicmp( CMD_LAST, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_CRED, lpszArg ) == 0 ) ||
                ( _tcsicmp( CMD_QUIT, lpszArg ) == 0 ))
            {
                _tcscpy(outbuf, lpszArg) ;
            }
            else if ( _tcsicmp( CMD_RPCS, lpszArg ) == 0 )
            {
                _tcscpy(outbuf, lpszArg) ;
                _tcscpy(outbuf + _tcslen(outbuf) + 1, argv[++ndx]) ;
            }
            else if ( _tcsicmp( "s", lpszArg ) == 0 )
            {
                _tcscpy(outbuf, TEXT("string: ")) ;
                _tcscat(outbuf, argv[++ndx]) ;
            }
            else
            {
                fPrintHelp = TRUE ;
            }
        }
        else
        {
            fPrintHelp = TRUE ;
        }

        if (fPrintHelp)
        {
            printf("usage: %s -s    <test string>\n", argv[0]);
            printf("\t        -quit (service will stop)\n") ;
            printf("\t        -cred (show service credentials)\n") ;
            printf("\t        -rpcs [ntlm, kerb, nego, ntlmkerb, ntlmnego, kerbnego, all] (register service as RPC server)\n") ;
            printf("\t        -last (get last RPC string)\n") ;
            exit(1);
        }
    }

    ret = CallNamedPipeA( lpszPipeName,
                          outbuf,
                          sizeof(outbuf),
                          inbuf,
                          sizeof(inbuf),
                          &bytesRead,
                          NMPWAIT_WAIT_FOREVER);

    if (!ret)
    {
        printf("client: CallNamedPipe failed, GetLastError = %d\n",
                                                     GetLastError()) ;
        exit(1);
    }

    printf("%s received:\n%s\n", argv[0], inbuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\secserv\cliserv\cliserv.cpp ===
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   cliserv.cpp
//
//  PURPOSE:  Implements functions required by all services
//            windows.
//
//  FUNCTIONS:
//    main(int argc, char **argv);
//    service_ctrl(DWORD dwCtrlCode);
//    service_main(DWORD dwArgc, LPTSTR *lpszArgv);
//    CmdInstallService(LPTSTR lpszLogonName, LPTSTR lpszLogonPwd);
//    CmdRemoveService();
//    CmdDebugService(int argc, char **argv);
//    ControlHandler ( DWORD dwCtrlType );
//    GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );
//
//  COMMENTS:
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//          Doron Juster
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>

#include "seccli.h"


// internal variables
SERVICE_STATUS          ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle;
DWORD                   dwErr = 0;
BOOL                    bDebug = FALSE;
TCHAR                   szErr[256];

// internal function prototypes
VOID WINAPI service_ctrl(DWORD dwCtrlCode);
VOID WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv);
VOID CmdInstallService(LPTSTR lpszLogonName, LPTSTR lpszLogonPwd);
VOID CmdRemoveService();
VOID CmdDebugService(int argc, char **argv);
BOOL WINAPI ControlHandler ( DWORD dwCtrlType );
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );

//
//  FUNCTION: main
//
//  PURPOSE: entrypoint for service
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    main() either performs the command line task, or
//    call StartServiceCtrlDispatcher to register the
//    main service thread.  When the this call returns,
//    the service has stopped, so exit.
//
void main(int argc, char **argv)
{
    SERVICE_TABLE_ENTRY dispatchTable[] =
    {
        { TEXT(SZCLISERVICENAME), (LPSERVICE_MAIN_FUNCTION)service_main },
        { NULL, NULL }
    };

    if ( (argc > 1) &&
         ((*argv[1] == '-') || (*argv[1] == '/')) )
    {
        if ( _stricmp( "install", argv[1]+1 ) == 0 )
        {
            LPTSTR lpszLogonName = NULL;
            LPTSTR lpszLogonPwd = NULL;
            if (argc > 2)
            {
                lpszLogonName = argv[2];
                //lpszLogonPwd = TEXT("");
            }
            if (argc > 3)
            {
                lpszLogonPwd = argv[3];
            }
            CmdInstallService(lpszLogonName, lpszLogonPwd);
        }
        else if ( _stricmp( "remove", argv[1]+1 ) == 0 )
        {
            CmdRemoveService();
        }
        else if ( _stricmp( "debug", argv[1]+1 ) == 0 )
        {
            bDebug = TRUE;
            CmdDebugService(argc, argv);
        }
        else if (( _tcsicmp( TEXT("?"), argv[1]+1 ) == 0 ) ||
                 ( _tcsicmp( TEXT("h"), argv[1]+1 ) == 0 ))
        {
            printf( "%s -install          to install the service\n", SZAPPNAME );
            printf( "%s -remove           to remove the service\n", SZAPPNAME );
            printf( "%s -debug <params>   to run as a console app for debugging\n", SZAPPNAME );
            printf( "\n To start the service: net start %s\n", SZCLISERVICENAME) ;
        }
        else
        {
            goto dispatch;
        }
        exit(0);
    }

    // if it doesn't match any of the above parameters
    // the service control manager may be starting the service
    // so we must call StartServiceCtrlDispatcher
dispatch:
        // this is just to be friendly
        printf( "\nStartServiceCtrlDispatcher being called.\n" );
        printf( "This may take several seconds.  Please wait.\n" );

        if (!StartServiceCtrlDispatcher(dispatchTable))
            AddToMessageLog(TEXT("StartServiceCtrlDispatcher failed."));
}


//
//  FUNCTION: service_main
//
//  PURPOSE: To perform actual initialization of the service
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This routine performs the service initialization and then calls
//    the user defined ServiceStart() routine to perform majority
//    of the work.
//
void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv)
{

    // register our service control handler:
    //
    sshStatusHandle = RegisterServiceCtrlHandler( SZCLISERVICENAME,
                                                  service_ctrl ) ;

    if (!sshStatusHandle)
        goto cleanup;

    // SERVICE_STATUS members that don't change in example
    //
    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;


    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        goto cleanup;


    ServiceStart( dwArgc, lpszArgv );

cleanup:

    // try to report the stopped status to the service control manager.
    //
    if (sshStatusHandle)
        (VOID)ReportStatusToSCMgr(
                            SERVICE_STOPPED,
                            dwErr,
                            0);

    return;
}



//
//  FUNCTION: service_ctrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode - type of control requested
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID WINAPI service_ctrl(DWORD dwCtrlCode)
{
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop the service.
        //
        case SERVICE_CONTROL_STOP:
            ssStatus.dwCurrentState = SERVICE_STOP_PENDING;
            ServiceStop();
            break;

        // Update the service status.
        //
        case SERVICE_CONTROL_INTERROGATE:
            break;

        // invalid control code
        //
        default:
            break;

    }

    ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);

}



//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;


    if ( !bDebug ) // when debugging we don't report to the SCM
    {
        if (dwCurrentState == SERVICE_START_PENDING)
            ssStatus.dwControlsAccepted = 0;
        else
            ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

        ssStatus.dwCurrentState = dwCurrentState;
        ssStatus.dwWin32ExitCode = dwWin32ExitCode;
        ssStatus.dwWaitHint = dwWaitHint;

        if ( ( dwCurrentState == SERVICE_RUNNING ) ||
             ( dwCurrentState == SERVICE_STOPPED ) )
            ssStatus.dwCheckPoint = 0;
        else
            ssStatus.dwCheckPoint = dwCheckPoint++;


        // Report the status of the service to the service control manager.
        //
        if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus))) {
            AddToMessageLog(TEXT("SetServiceStatus"));
        }
    }
    return fResult;
}


//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//

VOID AddToMessageLog(LPTSTR lpszMsg, WORD wType)
{
    TCHAR   szMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[2];


//    if ( !bDebug )
    {
        if (wType == EVENTLOG_ERROR_TYPE)
        {
            DWORD dwErr = GetLastError();
            _stprintf( szMsg,
                       TEXT("%s error: %d"),
                       SZCLISERVICENAME,
                       dwErr ) ;
        }
        else if (wType == EVENTLOG_INFORMATION_TYPE)
        {
            _stprintf( szMsg,
                       TEXT("%s information "),
                       SZCLISERVICENAME ) ;
        }
        else
        {
            _stprintf( szMsg,
                       TEXT("%s unknown "),
                       SZCLISERVICENAME ) ;
        }

        // Use event logging to log the error.
        //
        hEventSource = RegisterEventSource(NULL, TEXT(SZCLISERVICENAME));

        lpszStrings[0] = szMsg;
        lpszStrings[1] = lpszMsg;

        if (hEventSource != NULL)
        {
            ReportEvent(hEventSource,         // handle of event source
                        wType,                // event type
                        0,                    // event category
                        0,                    // event ID
                        NULL,                 // current user's SID
                        2,                    // strings in lpszStrings
                        0,                    // no bytes of raw data
                        (LPCTSTR *) lpszStrings,          // array of error strings
                        NULL);                // no raw data

            (VOID) DeregisterEventSource(hEventSource);
        }
    }
}

///////////////////////////////////////////////////////////////////
//
//  The following code handles service installation and removal
//


//
//  FUNCTION: CmdInstallService(LPTSTR lpszLogonName, LPTSTR lpszLogonPwd)
//
//  PURPOSE: Installs the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdInstallService(LPTSTR lpszLogonName, LPTSTR lpszLogonPwd)
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    TCHAR szPath[512];

    if ( GetModuleFileName( NULL, szPath, 512 ) == 0 )
    {
        _tprintf( TEXT("Unable to install %s - %s\n"),
                  SZCLISERVICEDISPLAYNAME,
                  GetLastErrorText(szErr, 256));
        return;
    }

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = CreateService(
            schSCManager,               // SCManager database
            TEXT(SZCLISERVICENAME),        // name of service
            TEXT(SZCLISERVICEDISPLAYNAME), // name to display
            SERVICE_ALL_ACCESS,         // desired access
            SERVICE_WIN32_OWN_PROCESS,  // service type
            SERVICE_DEMAND_START,       // start type
            SERVICE_ERROR_NORMAL,       // error control type
            szPath,                     // service's binary
            NULL,                       // no load ordering group
            NULL,                       // no tag identifier
            TEXT(SZDEPENDENCIES),       // dependencies
            lpszLogonName,              // NULL means LocalSystem account
            lpszLogonPwd);              // NULL means no password

        if ( schService )
        {
            _tprintf(TEXT("%s installed.\n"), TEXT(SZCLISERVICEDISPLAYNAME) );
            _tprintf(TEXT("to start: net start %s\n"), SZCLISERVICENAME) ;
            CloseServiceHandle(schService);
        }
        else
        {
            _tprintf(TEXT("CreateService failed - %s\n"), GetLastErrorText(szErr, 256));
        }

        CloseServiceHandle(schSCManager);
    }
    else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}



//
//  FUNCTION: CmdRemoveService()
//
//  PURPOSE: Stops and removes the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdRemoveService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        _tprintf(TEXT("Successfully opened the ServiceManager\n")) ;

        schService = OpenService( schSCManager,
                                  SZCLISERVICENAME,
                                  SERVICE_ALL_ACCESS ) ;

        if (schService)
        {
            _tprintf(TEXT("Successfully opened the Service\n")) ;
            //
            // try to stop the service
            //
            if ( ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
            {
                _tprintf(TEXT("Stopping %s."), TEXT(SZCLISERVICEDISPLAYNAME));
                Sleep( 1000 );

                while( QueryServiceStatus( schService, &ssStatus ) )
                {
                    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
                    {
                        _tprintf(TEXT("."));
                        Sleep( 1000 );
                    }
                    else
                        break;
                }

                if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
                    _tprintf( TEXT("\n%s stopped.\n"),
                              SZCLISERVICEDISPLAYNAME );
                else
                    _tprintf( TEXT("\n%s failed to stop.\n"),
                              SZCLISERVICEDISPLAYNAME );

            }

            // now remove the service
            if( DeleteService(schService) )
                _tprintf(TEXT("%s removed.\n"), SZCLISERVICEDISPLAYNAME );
            else
                _tprintf(TEXT("DeleteService failed - %s\n"), GetLastErrorText(szErr,256));


            CloseServiceHandle(schService);
        }
        else
            _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));

        CloseServiceHandle(schSCManager);
    }
    else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}




///////////////////////////////////////////////////////////////////
//
//  The following code is for running the service as a console app
//


//
//  FUNCTION: CmdDebugService(int argc, char ** argv)
//
//  PURPOSE: Runs the service as a console application
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdDebugService(int argc, char ** argv)
{
    DWORD dwArgc;
    LPTSTR *lpszArgv;

#ifdef UNICODE
    lpszArgv = CommandLineToArgvW(GetCommandLineW(), &(dwArgc) );
#else
    dwArgc   = (DWORD) argc;
    lpszArgv = argv;
#endif

    _tprintf(TEXT("Debugging %s.\n"), TEXT(SZCLISERVICEDISPLAYNAME));

    SetConsoleCtrlHandler( ControlHandler, TRUE );

    ServiceStart( dwArgc, lpszArgv );
}


//
//  FUNCTION: ControlHandler ( DWORD dwCtrlType )
//
//  PURPOSE: Handled console control events
//
//  PARAMETERS:
//    dwCtrlType - type of control event
//
//  RETURN VALUE:
//    True - handled
//    False - unhandled
//
//  COMMENTS:
//
BOOL WINAPI ControlHandler ( DWORD dwCtrlType )
{
    switch( dwCtrlType )
    {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
            _tprintf(TEXT("Stopping %s.\n"), TEXT(SZCLISERVICEDISPLAYNAME));
            ServiceStop();
            return TRUE;
            break;

    }
    return FALSE;
}

//
//  FUNCTION: GetLastErrorText
//
//  PURPOSE: copies error message text to string
//
//  PARAMETERS:
//    lpszBuf - destination buffer
//    dwSize - size of buffer
//
//  RETURN VALUE:
//    destination buffer
//
//  COMMENTS:
//
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize )
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           NULL,
                           GetLastError(),
                           LANG_NEUTRAL,
                           (LPTSTR)&lpszTemp,
                           0,
                           NULL );

    // supplied buffer is not long enough
    if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )
        lpszBuf[0] = TEXT('\0');
    else
    {
        lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\0');  //remove cr and newline character
        _stprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, GetLastError() );
    }

    if ( lpszTemp )
        LocalFree((HLOCAL) lpszTemp );

    return lpszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\secserv\secservs\secldap.cpp ===
//
// file:  secldap.cpp
//
//#include "ds_stdh.h"
#include "activeds.h"
//#include "mqads.h"
//#include "dsutils.h"
#include "secservs.h"
#include <winldap.h>

#define ACTRL_SD_PROP_NAME  TEXT("nTSecurityDescriptor")
#define ACTRL_DN_PROP_NAME  TEXT("distinguishedName")

#define DBG_PRINT_EX(x)
extern TCHAR  g_tszLastRpcString[] ;

WCHAR pwcsComputerName[300] = L"d1s1dep2";
HRESULT test(TCHAR ComputerName[])
{
	printf("hello-");
	swprintf(pwcsComputerName,L"%S",ComputerName);
	int last = 0;
    HRESULT hr;
    IADs * pADs;
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
		_stprintf( g_tszLastRpcString,"CoInitialize=%lx\n", hr);
        return 1;
    }

    //
    // Bind to the RootDSE to obtain information about the schema container
    //
    hr = ADsGetObject(L"LDAP://RootDSE", IID_IADs, (void **)&pADs);
    if (FAILED(hr))
    {
		_stprintf( g_tszLastRpcString,"** FAIL GetRootDsName(LDAP://RootDSE)=%lx\n", hr);
        return 1;
    }

    //
    // Setting value to BSTR Root domain
    //
    BSTR bstrRootDomainNamingContext( L"rootDomainNamingContext");

    //
    // Reading the root domain name property
    //
    VARIANT    varRootDomainNamingContext;

    hr = pADs->Get(bstrRootDomainNamingContext, &varRootDomainNamingContext);
    if (FAILED(hr))
    {
        _stprintf( g_tszLastRpcString+last,"** FAIL CADSI::GetRootDsName(RootNamingContext)=%lx\n", hr);
        return(2);
    }
    //_stprintf( g_tszLastRpcString+last,"** Root Domain Naming Context -%S\n", (&varRootDomainNamingContext)->bstrVal);
	//last = _tcslen(g_tszLastRpcString);
    //
    //  calculate length, allocate and copy the string
    //
    DWORD len = wcslen( ((VARIANT &)varRootDomainNamingContext).bstrVal);
    if ( len == 0)
    {
        return(3);
    }

    //
    // Setting value to BSTR default naming context
    //
    BSTR bstrDefaultNamingContext( L"DefaultNamingContext");

    //
    // Reading the default name property
    //
    VARIANT    varDefaultNamingContext;

    hr = pADs->Get(bstrDefaultNamingContext, &varDefaultNamingContext);
    if (FAILED(hr))
    {
        _stprintf( g_tszLastRpcString+last,"** FAIL CADSI::GetRootDsName(DefaultNamingContext)=%lx\n", hr);
        return(4);
    }
	//_stprintf( g_tszLastRpcString+last,"** Default Naming Context -%S\n", (&varDefaultNamingContext)->bstrVal);
	//last = _tcslen(g_tszLastRpcString);
    //
    //  calculate length, allocate and copy the string
    //
    len = wcslen( ((VARIANT &)varDefaultNamingContext).bstrVal);
    if ( len == 0)
    {
        return(5);
    }

    //
    //  Try to find the computer the GC under root domain naming context
    //
    //_stprintf( g_tszLastRpcString+last,"\n Trying to find computer %S under %S\n\n",pwcsComputerName,((VARIANT &)varRootDomainNamingContext).bstrVal);
	//last = _tcslen(g_tszLastRpcString);
    WCHAR * pwdsADsPath = new WCHAR [ 5 + wcslen( ((VARIANT &)varRootDomainNamingContext).bstrVal)];
    wcscpy(pwdsADsPath, L"GC://");

    wcscat(pwdsADsPath,((VARIANT &)varRootDomainNamingContext).bstrVal);
    IDirectorySearch * pDSSearch = NULL;

    hr = ADsGetObject(
            pwdsADsPath,
            IID_IDirectorySearch,
            (void**)&pDSSearch);
    if FAILED((hr))
    {
        _stprintf( g_tszLastRpcString+last," ** Failed to bind to GC root %lx\n",hr);
        return 6;
    }
    //
    //  Prepare filter - the specific computer
    //

    WCHAR filter[1000]={0};  
    wcscat(filter, L"(&(objectClass=computer)(cn=");
    wcscat(filter, pwcsComputerName);
    wcscat(filter, L"))");
    WCHAR AttributeName[] = L"distinguishedName";
    WCHAR * pAttributeName = AttributeName;
    ADS_SEARCH_HANDLE   hSearch;
    hr = pDSSearch->ExecuteSearch(
        filter,
        &pAttributeName,
        1,
        &hSearch);
    if FAILED((hr))
    {
        _stprintf( g_tszLastRpcString+last," ** Failed to execute search %lx\n",hr);
        return 7;
    }

    while ( SUCCEEDED(  hr = pDSSearch->GetNextRow( hSearch)))
    {
            ADS_SEARCH_COLUMN Column;

            // Ask for the column itself
            hr = pDSSearch->GetColumn(
                         hSearch,
                         AttributeName,
                         &Column);
            if (hr == S_ADS_NOMORE_ROWS)
            {
				_stprintf( g_tszLastRpcString+last," ** no more rows\n",hr);
				return 9;
                break;
            }

            if (FAILED(hr))
            {
				_stprintf( g_tszLastRpcString+last," ** Failed to get column %lx\n",hr);
				return 11;
                break;
            }

           _stprintf( g_tszLastRpcString+last," ** computer : %S\n", Column.pADsValues->CaseIgnoreString);
		   last = _tcslen(g_tszLastRpcString);
		   printf("hello\n %s\n",g_tszLastRpcString);

    }

    //
    //  Try to find the computer n in the default container:
    //
    /*_stprintf( g_tszLastRpcString+last,"\n Trying to find computer %S under %S\n\n",pwcsComputerName,((VARIANT &)varRootDomainNamingContext).bstrVal);
	last = _tcslen(g_tszLastRpcString);
    pwdsADsPath = new WCHAR [ 5 + wcslen( ((VARIANT &)varDefaultNamingContext).bstrVal)];
    wcscpy(pwdsADsPath, L"GC://");

    wcscat(pwdsADsPath,((VARIANT &)varDefaultNamingContext).bstrVal);
    pDSSearch = NULL;

    hr = ADsGetObject(
            pwdsADsPath,
            IID_IDirectorySearch,
            (void**)&pDSSearch);
    if FAILED((hr))
    {
        _stprintf( g_tszLastRpcString+last,"** Failed to bind to default container root %lx\n",hr);
        return 8;
    }
    hr = pDSSearch->ExecuteSearch(
        filter,
        &pAttributeName,
        1,
        &hSearch);
    if FAILED((hr))
    {
        _stprintf( g_tszLastRpcString+last,"** Failed to execute search %lx\n",hr);
        return 9;
    }

    while ( SUCCEEDED(  hr = pDSSearch->GetNextRow( hSearch)))
    {
            ADS_SEARCH_COLUMN Column;

            // Ask for the column itself
            hr = pDSSearch->GetColumn(
                         hSearch,
                         AttributeName,
                         &Column);
            if (hr == S_ADS_NOMORE_ROWS)
            {
                break;
            }

            if (FAILED(hr))
            {
                break;
            }

           _stprintf( g_tszLastRpcString+last,"** computer : %S\n", Column.pADsValues->CaseIgnoreString);
		   last = _tcslen(g_tszLastRpcString);

    }*/



    return 0;
}


//+-----------------------------------------------------------
//
//  BOOL ProcessAnLDAPMessage(LDAPMessage *pEntry)
//
//+-----------------------------------------------------------

BOOL ProcessAnLDAPMessage( LDAPMessage *pEntry,
                           PLDAP       pLdap )
{
    LONG static s_iCount = 1 ;
    TCHAR *pAttr = ACTRL_DN_PROP_NAME;
    TCHAR **ppDN = ldap_get_values( pLdap,
                                    pEntry,
                                    pAttr ) ;
    if (ppDN && *ppDN)
    {
        DBG_PRINT_EX((TEXT("\n...processing entry no. %ldt, %s\n"),
                                                   s_iCount, *ppDN)) ;
        ldap_value_free(ppDN) ;
    }
    else
    {
        DBG_PRINT_EX((
            TEXT("\n...processing entry no. %ldt, no DN\n"), s_iCount)) ;
    }
    s_iCount++ ;

    pAttr = ACTRL_SD_PROP_NAME;
    TCHAR **ppValue = ldap_get_values( pLdap,
                                       pEntry,
                                       pAttr ) ;
    if (ppValue)
    {
        berval **ppVal = ldap_get_values_len( pLdap,
                                              pEntry,
                                              pAttr ) ;
        if (ppVal)
        {
            ULONG ulLen = (*ppVal)->bv_len ;
            DBG_PRINT_EX((
                TEXT("attribute- %s found, length- %lut\n"), pAttr, ulLen)) ;

            SECURITY_DESCRIPTOR *pSD =
                             (SECURITY_DESCRIPTOR *) (*ppVal)->bv_val ;

            SECURITY_DESCRIPTOR_CONTROL SDControl ;
            DWORD                       dwRevision ;

            BOOL f = GetSecurityDescriptorControl( pSD,
                                                   &SDControl,
                                                   &dwRevision ) ;
            if (f)
            {
                if (SDControl & SE_SELF_RELATIVE)
                {
                    DBG_PRINT_EX((
                           TEXT("SecurityDescriptor is self-relative\n"))) ;
                }
                else
                {
                    DBG_PRINT_EX((
                             TEXT("SecurityDescriptor is absolute\n"))) ;
                }
            }
            else
            {
                DBG_PRINT_EX((
                  TEXT("ERROR, GetSecurityDescriptorControl failed\n"))) ;
            }

//////////////// HRESULT hr =  ShowNT5SecurityDescriptor(pSD) ;

            int i = ldap_value_free_len( ppVal ) ;
            if (i != LDAP_SUCCESS)
            {
                DBG_PRINT_EX((TEXT("free failed, i- %lxh\n"), (DWORD) i)) ;
            }
        }
        else
        {
            DWORD dwErr = LdapMapErrorToWin32( pLdap->ld_errno );
            DBG_PRINT_EX((
              TEXT("Attribute %s not found (_len), err- %lut, %lxh\n"),
                                                   pAttr, dwErr, dwErr)) ;
        }
        ldap_value_free(ppValue) ;
    }
    else
    {
        DWORD dwErr = LdapMapErrorToWin32( pLdap->ld_errno );
        DBG_PRINT_EX((TEXT("Attribute %s not found, err- %lut, %lxh\n"),
                                                 pAttr, dwErr, dwErr)) ;
    }

    return TRUE ;
}

//===============
//
// test_main
//
//===============

int QueryLdap(TCHAR wszBaseDN[], TCHAR wszHost[])
{

	return test(wszBaseDN);    
	/*
	PLDAP pLdap = ldap_init(wszHost, LDAP_PORT) ;

    if (!pLdap)
    {
        DBG_PRINT_EX((TEXT("ERROR: failed to open ldap connection\n"))) ;
        return 0 ;
    }

    //
    // Verify its V3
    //
    int iLdapVersion ;
    int iret = ldap_get_option( pLdap,
                                LDAP_OPT_PROTOCOL_VERSION,
                                (void*) &iLdapVersion ) ;
    if (iLdapVersion != LDAP_VERSION3)
    {
        iLdapVersion = LDAP_VERSION3 ;
        iret = ldap_set_option( pLdap,
                                LDAP_OPT_PROTOCOL_VERSION,
                                (void*) &iLdapVersion ) ;
    }
    DBG_PRINT_EX((TEXT("ldap_init(Host- %s) succeeded, version- %ldt\n"),
                                             wszHost, pLdap->ld_version)) ;

    ULONG ulRes ;
    ulRes = ldap_bind_s(pLdap, TEXT(""), NULL, LDAP_AUTH_NTLM) ;
    DBG_PRINT_EX((TEXT("ldap_bind_s() return %lxh\n"), ulRes)) ;

    //
    // The following is copied from
    //      kernel\razzle3\src\security\ntmarta\dsobject.cxx
    //
    SECURITY_INFORMATION   SeInfo = OWNER_SECURITY_INFORMATION |
                                    GROUP_SECURITY_INFORMATION |
                                    DACL_SECURITY_INFORMATION  ;
//                                    SACL_SECURITY_INFORMATION ;
    BYTE      berValue[8];

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)SeInfo & 0xF);

    LDAPControl     SeInfoControl =
                    {
                        TEXT("1.2.840.113556.1.4.801"),
                        {
                            5, (PCHAR)berValue
                        },
                        TRUE
                    };
    LDAPControl *ppldapcSD[2] = {&SeInfoControl, NULL} ;

    LPTSTR   rgAttribs[3] = {NULL, NULL, NULL} ;
    rgAttribs[0] = ACTRL_SD_PROP_NAME;
    rgAttribs[1] = ACTRL_DN_PROP_NAME;

    LDAPMessage *pRes = NULL ;

    ulRes = ldap_search_ext_s( pLdap,
                               wszBaseDN,
                               LDAP_SCOPE_BASE,
                               TEXT("(objectclass=*)"),
                               rgAttribs,
                               0,
                               ppldapcSD,      // PLDAPControlW   *ServerControls,
                               NULL,           // PLDAPControlW   *ClientControls,
                               NULL,           // struct l_timeval  *timeout,
                               0,              // ULONG             SizeLimit,
                               &pRes ) ;
    DBG_PRINT_EX((TEXT("ldap_search_ext_s(%s) return %lxh\n"),
                                                 wszBaseDN, ulRes)) ;
    if (ulRes == LDAP_SUCCESS)
    {
        int iCount = ldap_count_entries(pLdap, pRes) ;
        DBG_PRINT_EX((TEXT("ldap_count_entries() return %ldt\n"), iCount)) ;

        _stprintf(g_tszLastRpcString,
                     TEXT("ldap_search(%s) return %lut entries"),
                                                    wszBaseDN, iCount) ;

        if (iCount == 0)
        {
            BOOL f = ProcessAnLDAPMessage( pRes,
                                           pLdap ) ;
        }
        else
        {
            LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
            while(pEntry)
            {
                BOOL f = ProcessAnLDAPMessage( pEntry,
                                               pLdap ) ;

                LDAPMessage *pPrevEntry = pEntry ;
                pEntry = ldap_next_entry(pLdap, pPrevEntry) ;
            }
        }
    }

    if (pRes)
    {
        ldap_msgfree(pRes);
    }

    ulRes = ldap_unbind_s(pLdap) ;
    DBG_PRINT_EX((TEXT("ldap_unbind_s() return %lxh\n"), ulRes)) ;

    return 0 ;
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\secserv\secservs\secadsi.cpp ===
//
// file:  secadsi.cpp
//
#include "ds_stdh.h"
//#include "mqads.h"
#include "dsutils.h"
#include "activeds.h"
//#include "secservs.h"

extern char g_tszLastRpcString[] ;


static HRESULT GetObjectOwnerFromAttr(IUnknown * punkVal, LPWSTR * ppwszOwner)
{
    HRESULT hr;

    R<IADsSecurityDescriptor> pIADsSec;    
    hr = punkVal->QueryInterface(IID_IADsSecurityDescriptor, (void **)&pIADsSec);
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "QueryInterface(IID_IADsSecurityDescriptor) failed %lx\n", hr);
        return hr;
    }

    BSTR bstrTmpOwner;
    hr = pIADsSec->get_Owner(&bstrTmpOwner);
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "pIADsSec->get_Owner failed %lx\n", hr);
        return hr;
    }

    *ppwszOwner = new WCHAR[1+wcslen(bstrTmpOwner)];
    wcscpy(*ppwszOwner, bstrTmpOwner);
    SysFreeString(bstrTmpOwner);
    return S_OK;
}


static HRESULT GetObjectOwner(IADs * pIADs, LPWSTR * ppwszOwner)
{
    BS bsTmp = L"nTSecurityDescriptor";
    CAutoVariant varTmp;
    VARIANT * pvarTmp = &varTmp;
    HRESULT hr = pIADs->Get(bsTmp, pvarTmp);
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "pIADs->Get(ntsec) failed %lx\n", hr);
        return hr;
    }

    return GetObjectOwnerFromAttr(pvarTmp->punkVal, ppwszOwner);
}


static inline void ToWideStr(char *psz, LPWSTR *ppwsz)
{
    *ppwsz = new WCHAR [1+strlen(psz)];
    swprintf(*ppwsz, L"%hs", psz);
}


static HRESULT BindToObject(
                    LPWSTR lpszPathName,
                    REFIID riid,
                    BOOL fWithCredentials,
                    LPWSTR lpszUserName,
                    LPWSTR lpszPassword,
                    BOOL fWithSecuredAuthentication,
                    void ** ppObject)
{
    if (fWithCredentials)
    {
        DWORD dwReserved = 0;
        if (fWithSecuredAuthentication)
        {
            dwReserved = ADS_SECURE_AUTHENTICATION;
        }
        return ADsOpenObject(lpszPathName,
                             lpszUserName,
                             lpszPassword,
                             dwReserved,
                             riid,
                             ppObject);
    }
    else
    {
        if (fWithSecuredAuthentication)
        {
            return ADsOpenObject(lpszPathName,
                                 NULL,
                                 NULL,
                                 ADS_SECURE_AUTHENTICATION,
                                 riid,
                                 ppObject);
        }
        else
        {
            return ADsGetObject(lpszPathName,
                                riid,
                                ppObject);
        }
    }
}

#if 0
static BOOL fGetUniqueString(LPWSTR * ppwszCN)
{
    GUID guidCN;
    RPC_STATUS rpcstat = UuidCreate(&guidCN);
    if (rpcstat != RPC_S_OK)
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "UuidCreate failed %lx\n", (DWORD)rpcstat);
        return FALSE;
    }
    LPWSTR pwszCN;
    rpcstat = UuidToString(&guidCN, &pwszCN);
    if (rpcstat != RPC_S_OK)
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "UuidToString failed %lx\n", (DWORD)rpcstat);
        return FALSE;
    }
    *ppwszCN = new WCHAR[1+wcslen(pwszCN)];
    wcscpy(*ppwszCN, pwszCN);
    RpcStringFree(&pwszCN);
    _wcsrev(*ppwszCN); // to get unique first chars of computer name
    return TRUE;
}
#endif //0


static void PutDescDC(BOOL fWithDC,
                      LPWSTR pwszDCName)
{
    if (fWithDC)
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "DC=%ls\n", pwszDCName);
    }
    else
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "DC not specified\n");
    }
}


static void PutDescCredentials(BOOL fWithCredentials,
                               LPWSTR pwszUserName,
                               LPWSTR pwszUserPwd,
                               BOOL fWithSecuredAuthentication)
{
    if (fWithCredentials)
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "using UserName=%ls\nUserPwd=%ls\n", pwszUserName, pwszUserPwd);
    }
    else
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "using default user\n");
    }

    if (fWithSecuredAuthentication)
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "with secured authentication(kerberos)\n");
    }
    else
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "without secured authentication(kerberos)\n");
    }
}


static void FillBindPath(BOOL fFromGC,
                         BOOL fWithDC,
                         LPWSTR pwszDCName,
                         LPWSTR pwszBindDN,
                         LPWSTR pwszBindPath)
{
    LPWSTR pwszProv;
    if (fFromGC)
    {
        pwszProv = L"GC://";
    }
    else
    {
        pwszProv = L"LDAP://";
    }

    WCHAR wszDC[200];    
    if (fWithDC)
    {
        swprintf(wszDC, L"%ls/", pwszDCName);
    }
    else
    {
        wcscpy(wszDC, L"");
    }

    swprintf(pwszBindPath, L"%ls%ls%ls", pwszProv, wszDC, pwszBindDN);
}

WCHAR g_wsz_attr_cn[256]    = L"cn";
WCHAR g_wsz_attr_dn[256]    = L"distinguishedName";
WCHAR g_wsz_attr_ntsec[256] = L"nTSecurityDescriptor";

static HRESULT ADSITestQueryComputers(BOOL fFromGC,
                                      BOOL fWithDC,
                                      LPWSTR pwszDCName,
                                      LPWSTR pwszSearchValue,
                                      LPWSTR pwszSearchRoot,
                                      BOOL fWithCredentials,
                                      LPWSTR pwszUserName,
                                      LPWSTR pwszUserPwd,
                                      BOOL fWithSecuredAuthentication)
{
    CCoInit cCoInit;
    HRESULT hr;

    sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "ADSITestQueryComputers\n");
    if (fFromGC)
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "from GC://\n");
    }
    else
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "from LDAP://\n");
    }    
    PutDescDC(fWithDC, pwszDCName);
    sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "search for computers with description=%ls\n", pwszSearchValue);
    sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "search root=%ls\n", pwszSearchRoot);
    PutDescCredentials(fWithCredentials, pwszUserName, pwszUserPwd, fWithSecuredAuthentication);

    hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "CoInitialize() failed %lx\n", hr);
        return hr;
    }

    WCHAR wszPath[1000];
    FillBindPath(fFromGC, fWithDC, pwszDCName, pwszSearchRoot, wszPath);

    R<IDirectorySearch> pDirSearch;
    hr = BindToObject(wszPath,
                      IID_IDirectorySearch,
                      fWithCredentials,
                      pwszUserName,
                      pwszUserPwd,
                      fWithSecuredAuthentication,
                      (void **) &pDirSearch);
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "BindToObject(%ls) failed %lx\n", (LPWSTR)wszPath, hr);
        return hr;
    }

    ADS_SEARCHPREF_INFO         sSearchPrefs[2];
    sSearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
    sSearchPrefs[0].vValue.dwType = ADSTYPE_BOOLEAN;
    sSearchPrefs[0].vValue.Boolean = FALSE;
    sSearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    sSearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    sSearchPrefs[1].vValue.Integer = ADS_SCOPE_SUBTREE;
    hr = pDirSearch->SetSearchPreference(sSearchPrefs, ARRAY_SIZE(sSearchPrefs));

//    LPWSTR sSearchAttrs[] = {L"cn", L"distinguishedName", L"nTSecurityDescriptor"};
    LPWSTR sSearchAttrs[] = {g_wsz_attr_cn, g_wsz_attr_dn, g_wsz_attr_ntsec};
    DWORD dwSearchAttrs = ARRAY_SIZE(sSearchAttrs);
    ADS_SEARCH_HANDLE hSearch;
    WCHAR wszSearchFilter[1024];
    swprintf(wszSearchFilter, L"(&(objectClass=computer)(description=%ls))", pwszSearchValue);
    hr = pDirSearch->ExecuteSearch(
                        wszSearchFilter,
                        sSearchAttrs,
                        dwSearchAttrs,
                        &hSearch);
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "pDirSearch->ExecuteSearch failed %lx\n", hr);
        return hr;
    }
    CAutoCloseSearchHandle cCloseSearchHandle(pDirSearch, hSearch);

    hr = pDirSearch->GetFirstRow(hSearch);
    while (SUCCEEDED(hr) && (hr != S_ADS_NOMORE_ROWS))
    {
        ADS_SEARCH_COLUMN columnDN;
        hr = pDirSearch->GetColumn(hSearch, g_wsz_attr_dn, &columnDN);
        if (FAILED(hr))
        {
            sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "pDirSearch->GetColumn(dn) failed %lx\n", hr);
            return hr;
        }
        CAutoReleaseColumn cAutoReleaseColumnDN(pDirSearch, &columnDN);

        ADS_SEARCH_COLUMN columnCN;
        hr = pDirSearch->GetColumn(hSearch, g_wsz_attr_cn, &columnCN);
        if (FAILED(hr))
        {
            sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "pDirSearch->GetColumn(cn) failed for %ls %lx\n", columnDN.pADsValues->DNString, hr);
            return hr;
        }
        CAutoReleaseColumn cAutoReleaseColumnCN(pDirSearch, &columnCN);

        ADS_SEARCH_COLUMN columnNTSec;
        P<CAutoReleaseColumn> pAutoReleaseColumnNTSec;
        BOOL fNTSecFound;
        hr = pDirSearch->GetColumn(hSearch, g_wsz_attr_ntsec, &columnNTSec);
        if (FAILED(hr))
        {
            sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "pDirSearch->GetColumn(ntsec) failed for %ls %lx, ignored\n", columnDN.pADsValues->DNString, hr);
            fNTSecFound = FALSE;
        }
        else
        {
            pAutoReleaseColumnNTSec = new CAutoReleaseColumn(pDirSearch, &columnNTSec);
            fNTSecFound = TRUE;
        }

/*
        if (fNTSecFound)
        {
            hr = GetObjectOwnerFromAttr(IUnknown * punkVal, LPWSTR * ppwszOwner)
        }
*/

        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "cn:%ls, dn:%ls\n", columnCN.pADsValues->CaseIgnoreString, columnDN.pADsValues->DNString);
        
        hr = pDirSearch->GetNextRow(hSearch);
    }
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "pDirSearch->GetFirst/NextRow failed %lx\n", hr);
        return hr;
    }

    sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "done query computers\n");
    return S_OK;
}


static HRESULT ADSITestCreateComputer(BOOL fWithDC,
                                      LPWSTR pwszDCName,
                                      LPWSTR pwszObjectName,
                                      LPWSTR pwszDomain,
                                      BOOL fWithCredentials,
                                      LPWSTR pwszUserName,
                                      LPWSTR pwszUserPwd,
                                      BOOL fWithSecuredAuthentication)
{
    CCoInit cCoInit;
    HRESULT hr;

    sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "ADSITestCreateComputer\n");
    PutDescDC(fWithDC, pwszDCName);
    sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "object name=%ls\n", pwszObjectName);
    sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "domain=%ls\n", pwszDomain);
    PutDescCredentials(fWithCredentials, pwszUserName, pwszUserPwd, fWithSecuredAuthentication);

    hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "CoInitialize() failed %lx\n", hr);
        return hr;
    }

    WCHAR wszComputersContainer[1000];
    swprintf(wszComputersContainer, L"CN=Computers,%ls", pwszDomain);
    WCHAR wszPath[1000];
    FillBindPath(FALSE /*fFromGC*/, fWithDC, pwszDCName, wszComputersContainer, wszPath);

    R<IADsContainer> pContainer;
    hr = BindToObject(wszPath,
                      IID_IADsContainer,
                      fWithCredentials,
                      pwszUserName,
                      pwszUserPwd,
                      fWithSecuredAuthentication,
                      (void **) &pContainer);
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "BindToObject(%ls) failed %lx\n", (LPWSTR)wszPath, hr);
        return hr;
    }

    WCHAR wszCN[200];
    swprintf(wszCN, L"cn=%ls", pwszObjectName);
    BS bstrCN(wszCN);

    BS bsClass(L"computer");
    R<IDispatch> pDisp;
    hr = pContainer->Create(bsClass, bstrCN, &pDisp);
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "pContainer->Create(%ls, %ls) failed %lx\n", (LPWSTR)bsClass, (LPWSTR)bstrCN, hr);
        return hr;
    }

    R<IADs> pChild;
    hr = pDisp->QueryInterface(IID_IADs,(LPVOID *) &pChild);
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "pDisp->QueryInterface(IID_IADs) failed %lx\n", hr);
        return hr;
    }

    VARIANT varPropVal;

    BS bstrPropCNName(L"cn");
    BS bstrPropCNVal(pwszObjectName);
    varPropVal.vt = VT_BSTR;
    varPropVal.bstrVal = bstrPropCNVal;
    hr = pChild->Put(bstrPropCNName, varPropVal);
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "pChild->Put(%ls, %ls) failed %lx\n", (LPWSTR)bstrPropCNName, (LPWSTR)(varPropVal.bstrVal), hr);
        return hr;
    }

    BS bstrPropSamAccName(L"sAMAccountName");
    BS bstrPropSamAccVal(pwszObjectName);
    varPropVal.vt = VT_BSTR;
    varPropVal.bstrVal = bstrPropSamAccVal;
    hr = pChild->Put(bstrPropSamAccName, varPropVal);
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "pChild->Put(%ls, %ls) failed %lx\n", (LPWSTR)bstrPropSamAccName, (LPWSTR)(varPropVal.bstrVal), hr);
        return hr;
    }

    hr = pChild->SetInfo();
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "pChild->SetInfo failed %lx\n", hr);
        return hr;
    }

    AP<WCHAR> pwszOwner;
    hr = GetObjectOwner(pChild, &pwszOwner);
    if (FAILED(hr))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "failed to get computer's owner, ignored %lx\n", hr);
    }

    sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "done create computer %ls, owner %ls\n", (LPWSTR)pwszObjectName, (LPWSTR)pwszOwner);
    return S_OK;
}


int ADSITestQuery(BOOL fFromGC,
                  BOOL fWithDC,
                  char * pszDCName,
                  char * pszSearchValue,
                  char * pszSearchRoot,
                  BOOL fWithCredentials,
                  char * pszUserName,
                  char * pszUserPwd,
                  BOOL fWithSecuredAuthentication)
{
    AP<WCHAR> pwszDCName, pwszSearchValue, pwszSearchRoot, pwszUserName, pwszUserPwd;
    if (fWithDC)
    {
        ToWideStr(pszDCName, &pwszDCName);
    }
    ToWideStr(pszSearchValue, &pwszSearchValue);
    ToWideStr(pszSearchRoot, &pwszSearchRoot);
    if (fWithCredentials)
    {
        ToWideStr(pszUserName, &pwszUserName);
        ToWideStr(pszUserPwd, &pwszUserPwd);
    }
    ADSITestQueryComputers(fFromGC,
                           fWithDC,
                           pwszDCName,
                           pwszSearchValue,
                           pwszSearchRoot,
                           fWithCredentials,
                           pwszUserName,
                           pwszUserPwd,
                           fWithSecuredAuthentication);
    return 0;
}


int ADSITestCreate(BOOL fWithDC,
                   char * pszDCName,
                   char * pszObjectName,
                   char * pszDomain,
                   BOOL fWithCredentials,
                   char * pszUserName,
                   char * pszUserPwd,
                   BOOL fWithSecuredAuthentication)
{
    AP<WCHAR> pwszDCName, pwszObjectName, pwszDomain, pwszUserName, pwszUserPwd;
    if (fWithDC)
    {
        ToWideStr(pszDCName, &pwszDCName);
    }
    ToWideStr(pszObjectName, &pwszObjectName);
    ToWideStr(pszDomain, &pwszDomain);
    if (fWithCredentials)
    {
        ToWideStr(pszUserName, &pwszUserName);
        ToWideStr(pszUserPwd, &pwszUserPwd);
    }    
    ADSITestCreateComputer(fWithDC,
                           pwszDCName,
                           pwszObjectName,
                           pwszDomain,
                           fWithCredentials,
                           pwszUserName,
                           pwszUserPwd,
                           fWithSecuredAuthentication);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\secserv\secservs\secrpcs.cpp ===
//
// file: secrpcs.cpp
//
#include "secservs.h"
#include "secrpc.h"

#include "secadsi.h"

#define ARRAY_SIZE(rg) (sizeof(rg)/sizeof(rg[0])) 

int QueryLdap(TCHAR wszBaseDN[], TCHAR wszHost[]) ;

void  ShowTokenCredential( HANDLE hToken,
                           TCHAR tszBuf[] ) ;
void  ShowImpersonatedThreadCredential(TCHAR tszBuf[], BOOL fImpersonated);
void  ShowProcessCredential(TCHAR tszBuf[]);

TCHAR  g_tszLastRpcString[ PIPE_BUFFER_LEN ] = {TEXT("")} ;

//+----------------------------------
//
//  ULONG  RemoteOpenProcess()
//
//+----------------------------------

ULONG  RemoteOpenProcess(  handle_t       hBind,
                           unsigned long  dwProcessId,
                           unsigned long  fImpersonate )
{
    RPC_STATUS status = RPC_S_OK ;
    if (fImpersonate)
    {
        status = RpcImpersonateClient(NULL) ;
    }

    SetLastError(0) ;

    HANDLE hCallingProcess = OpenProcess( PROCESS_DUP_HANDLE,
                                          FALSE,
                                          dwProcessId );

    if (fImpersonate)
    {
        status = RpcRevertToSelf() ;
    }

    _stprintf( g_tszLastRpcString,
       "OpenProcess(%lut) return %lxh, LastErr- %lut, fImpersonate- %lut",
              dwProcessId, hCallingProcess, GetLastError(), fImpersonate) ;

    return (ULONG) hCallingProcess ;
}

//+----------------------------------
//
//  ULONG RemoteImpersonate()
//
//+----------------------------------

ULONG RemoteImpersonate( handle_t       hBind,
                         unsigned char  ** achBuf,
                         unsigned long  fImpersonate )
{
    ULONG status = 0 ;
    if (fImpersonate)
    {
        RPC_STATUS status = RpcImpersonateClient(NULL) ;
        if (status != RPC_S_OK)
        {
            _tcscpy(g_tszLastRpcString, TEXT("RpcImpersonateClient failed")) ;
            return status ;
        }
    }

    g_tszLastRpcString[0] = TEXT('\0') ;

    HANDLE hToken = NULL ;
    if (OpenThreadToken( GetCurrentThread(),
                         TOKEN_ALL_ACCESS,
                         FALSE,
                         &hToken))
    {
        ShowTokenCredential( hToken,
                             g_tszLastRpcString ) ;
        *achBuf = (unsigned char *) midl_user_allocate(500) ;
        _tcscpy((char*) *achBuf, g_tszLastRpcString) ;
    }
    else
    {
        _tcscpy(g_tszLastRpcString, TEXT("OpenThreadToken failed")) ;
        status = GetLastError() ;
    }

    if (fImpersonate)
    {
        RPC_STATUS status = RpcRevertToSelf() ;
        if (status != RPC_S_OK)
        {
            _tcscpy(g_tszLastRpcString, TEXT("RpcRevertToSelf failed")) ;
            return status ;
        }
    }

    return status  ;
}

//+-----------------------------
//
//  ULONG  _ImpersonateGuest()
//
//+-----------------------------

static ULONG  _ImpersonateGuest(TCHAR tszUserNameIn[])
{
    HANDLE hToken = NULL ;
    TCHAR *tszUserName = (TCHAR*) tszUserNameIn ;
    if (!tszUserName)
    {
        tszUserName = TEXT("Guest") ;
    }
    BOOL fLogon = LogonUser( tszUserName,
                             TEXT("dj41-Domain"),
                             NULL, //pszPassword,
                             LOGON32_LOGON_INTERACTIVE,
                             LOGON32_PROVIDER_DEFAULT,
                             &hToken ) ;
    if (!fLogon)
    {
        ULONG uErr = GetLastError() ;
        _stprintf(g_tszLastRpcString,
             TEXT("... ERROR: Failed to LogonUser, err- %lut"), uErr) ;
         return uErr ;
    }
    else
    {
       fLogon = ImpersonateLoggedOnUser( hToken ) ;
       if (fLogon)
       {
          _tcscpy(g_tszLastRpcString,
                           TEXT("successfully impersonating Guest")) ;
       }
       else
       {
          ULONG uErr = GetLastError() ;
          _stprintf(g_tszLastRpcString, TEXT(
             "Failed to ImpersonateLoggedOnUser, Guest, err- %lut"), uErr) ;
          return uErr ;
       }
    }

    return 0 ;
}

//+---------------------------
//
//  ULONG RemoteGuest()
//
//+---------------------------

ULONG RemoteGuest( handle_t       hBind,
                   unsigned char  ** achBuf,
                   unsigned long  fGuest,
                   unsigned char  *pszUserName )
{
    g_tszLastRpcString[0] = TEXT('\0') ;

    ULONG status = 0 ;
    if (fGuest)
    {
        status =  _ImpersonateGuest((TCHAR*)pszUserName) ;
        if (status != 0)
        {
            return status ;
        }
    }

    HANDLE hToken = NULL ;
    if (OpenThreadToken( GetCurrentThread(),
                         TOKEN_QUERY,
                         FALSE,
                         &hToken))
    {
        ShowTokenCredential( hToken,
                             g_tszLastRpcString ) ;
        *achBuf = (unsigned char *) midl_user_allocate(500) ;
        _tcscpy((char*) *achBuf, g_tszLastRpcString) ;
    }
    else
    {
        status = GetLastError() ;
        _stprintf(g_tszLastRpcString,
                       TEXT("OpenThreadToken failed, err- %lut"), status) ;
    }

    if (fGuest)
    {
        BOOL f = RevertToSelf() ;
        if (!f)
        {
            status = GetLastError() ;
            _stprintf(g_tszLastRpcString,
                         TEXT("RevertToSelf failed, err- %lut"), status) ;
        }
    }

    return status  ;
}

//+---------------------------
//
//  ULONG  RemoteLdap()
//
//+---------------------------

ULONG  RemoteLdap( handle_t         hBind,
                   unsigned char  **achBuf,
                   unsigned char   *pszHost,
                   unsigned char   *pszBaseDN,
                   unsigned long    fImpersonate,
                   unsigned long    fGuest,
                   unsigned char   *pszUserName )
{
    g_tszLastRpcString[0] = TEXT('\0') ;

    ULONG status = 0 ;
    if (fImpersonate)
    {
        status = RpcImpersonateClient(NULL) ;
        if (status != RPC_S_OK)
        {
            _tcscpy(g_tszLastRpcString, TEXT("RpcImpersonateClient failed")) ;
            return status ;
        }
    }
    else if (fGuest)
    {
        status =  _ImpersonateGuest((TCHAR*)pszUserName) ;
        if (status != 0)
        {
            return status ;
        }
    }

    QueryLdap((TCHAR*) pszBaseDN, (TCHAR*) pszHost) ;

    if (fImpersonate)
    {
        status = RpcRevertToSelf() ;
        if (status != RPC_S_OK)
        {
            //_tcscat(g_tszLastRpcString, TEXT("RpcRevertToSelf failed")) ;
        }
        else
        {
            //_tcscat(g_tszLastRpcString, TEXT(", as Impersonated")) ;
        }
    }
    else if (fGuest)
    {
        BOOL f = RevertToSelf() ;
        if (!f)
        {
            status = GetLastError() ;
            //_stprintf(g_tszLastRpcString,
            //             TEXT("RevertToSelf failed, err- %lut"), status) ;
        }
        else
        {
            if (pszUserName)
            {
               // _tcscat(g_tszLastRpcString, TEXT(", as ")) ;
                //_tcscat(g_tszLastRpcString, (TCHAR*) pszUserName) ;
            }
            else
            {
                //_tcscat(g_tszLastRpcString, TEXT(", as Guest")) ;
            }
        }
    }

    *achBuf = (unsigned char *)
                   midl_user_allocate(PIPE_BUFFER_LEN * sizeof(TCHAR)) ;
    _tcscpy((char*) *achBuf, g_tszLastRpcString) ;

    return status ;
}

void ShowBindingAuthentication(handle_t         hBind)
{
    ULONG status;
    ULONG ulAuthnLevel, ulAuthnSvc;
    status = RpcBindingInqAuthClient(hBind,
                                     NULL,
                                     NULL,
                                     &ulAuthnLevel,
                                     &ulAuthnSvc,
                                     NULL);
    if ((status != RPC_S_OK))
    {
        sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "RpcBindingInqAuthClient failed %lx\n", (DWORD)status) ;
        return;
    }

    char szAuthnSvc[100];
    switch(ulAuthnSvc)
    {
    case RPC_C_AUTHN_GSS_KERBEROS:
        strcpy(szAuthnSvc, "kerberos");
        break;
    case RPC_C_AUTHN_WINNT:
        strcpy(szAuthnSvc, "ntlm");
        break;
    default:
        sprintf(szAuthnSvc, "%lu", ulAuthnSvc);
        break;
    }

    sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "Binding Authentication is %hs\n", szAuthnSvc) ;
}

//+---------------------------
//
//  ULONG  RemoteADSITestCreate()
//
//+---------------------------

ULONG  RemoteADSITestCreate( handle_t         hBind,
                   unsigned char  **achBuf,
                   unsigned long  fWithDC,
                   unsigned char  *pszDCName,
                   unsigned char  *pszObjectName,
                   unsigned char  *pszDomain,
                   unsigned long  fWithCredentials,
                   unsigned char  *pszUserName,
                   unsigned char  *pszUserPwd,
                   unsigned long  fWithSecuredAuthentication,
                   unsigned long  fImpersonate)
{
    ULONG status;
    _tcscpy(g_tszLastRpcString, TEXT("RemoteADSITestCreate\n"));
    _tcscat(g_tszLastRpcString, "thread credentials: ");
    ShowProcessCredential(g_tszLastRpcString + strlen(g_tszLastRpcString));
    ShowBindingAuthentication(hBind);
    if (fImpersonate)
    {
        _tcscat(g_tszLastRpcString, TEXT("with impersonation\n"));
//         status = RpcImpersonateClient(hBind) ;
         status = RpcImpersonateClient(NULL) ;
        if (status != RPC_S_OK)
        {
            sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "RpcImpersonateClient failed %lx\n", (DWORD)status) ;
            return status ;
        }
        _tcscat(g_tszLastRpcString, "impersonated thread credentials: ");
        ShowImpersonatedThreadCredential(g_tszLastRpcString + strlen(g_tszLastRpcString), TRUE);
    }
    else
    {
        _tcscat(g_tszLastRpcString, "without impersonation\n");
    }

    status = ADSITestCreate(fWithDC,
                   (char *)pszDCName,
                   (char *)pszObjectName,
                   (char *)pszDomain,
                   fWithCredentials,
                   (char *)pszUserName,
                   (char *)pszUserPwd,
                   fWithSecuredAuthentication);

    if (fImpersonate)
    {
//        status = RpcRevertToSelfEx(hBind) ;
        status = RpcRevertToSelf() ;
        if (status != RPC_S_OK)
        {
            sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "RpcRevertToSelf failed %lx\n", (DWORD)status) ;
            return status ;
        }
    }

    _tcscat(g_tszLastRpcString, "\n");

    *achBuf = (unsigned char *)
                   midl_user_allocate(PIPE_BUFFER_LEN * sizeof(TCHAR)) ;
    _tcscpy((char*) *achBuf, g_tszLastRpcString) ;

    return status ;
}

//+---------------------------
//
//  ULONG  RemoteADSITestQuery()
//
//+---------------------------

ULONG  RemoteADSITestQuery( handle_t         hBind,
                   unsigned char  **achBuf,
                   unsigned long  fFromGC,
                   unsigned long  fWithDC,
                   unsigned char  *pszDCName,
                   unsigned char  *pszSearchValue,
                   unsigned char  *pszSearchRoot,
                   unsigned long  fWithCredentials,
                   unsigned char  *pszUserName,
                   unsigned char  *pszUserPwd,
                   unsigned long  fWithSecuredAuthentication,
                   unsigned long  fImpersonate)
{
    ULONG status;
    _tcscpy(g_tszLastRpcString, TEXT("RemoteADSITestQuery\n"));
    _tcscat(g_tszLastRpcString, "thread credentials: ");
    ShowProcessCredential(g_tszLastRpcString + strlen(g_tszLastRpcString));
    ShowBindingAuthentication(hBind);
    if (fImpersonate)
    {
        _tcscat(g_tszLastRpcString, TEXT("with impersonation\n"));
//        status = RpcImpersonateClient(hBind) ;
        status = RpcImpersonateClient(NULL) ;
        if (status != RPC_S_OK)
        {
            sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "RpcImpersonateClient failed %lx\n", (DWORD)status) ;
            return status ;
        }
        _tcscat(g_tszLastRpcString, "impersonated thread credentials: ");
        ShowImpersonatedThreadCredential(g_tszLastRpcString + strlen(g_tszLastRpcString), TRUE);
    }
    else
    {
        _tcscat(g_tszLastRpcString, "without impersonation\n");
    }

    status = ADSITestQuery(fFromGC,
                  fWithDC,
                  (char *)pszDCName,
                  (char *)pszSearchValue,
                  (char *)pszSearchRoot,
                  fWithCredentials,
                  (char *)pszUserName,
                  (char *)pszUserPwd,
                  fWithSecuredAuthentication);

    if (fImpersonate)
    {
//        status = RpcRevertToSelfEx(hBind) ;
        status = RpcRevertToSelf() ;
        if (status != RPC_S_OK)
        {
            sprintf(g_tszLastRpcString + strlen(g_tszLastRpcString), "RpcRevertToSelf failed %lx\n", (DWORD)status) ;
            return status ;
        }
    }

    _tcscat(g_tszLastRpcString, "\n");

    *achBuf = (unsigned char *)
                   midl_user_allocate(PIPE_BUFFER_LEN * sizeof(TCHAR)) ;
    _tcscpy((char*) *achBuf, g_tszLastRpcString) ;

    return status ;
}

void Shutdown(void)
{
}

//+--------------------------------------------
//
//  RPC_STATUS RegisterServiceAsRpcServer()
//
//+--------------------------------------------

RPC_STATUS RegisterServiceAsRpcServer(LPTSTR pszAuthSvc)
{
    static BOOL s_fAlreadyInit = FALSE ;
    if (s_fAlreadyInit)
    {
        return RPC_S_OK ;
    }

    TCHAR  tszError[ 128 ] ;
    ULONG ulMaxCalls = 1000 ;
    ULONG ulMinCalls = 1 ;
    BOOL  fRegister = TRUE ;
    LPUSTR pszProtocol =  PROTOSEQ_TCP ;
    LPUSTR pszEndpoint =  ENDPOINT_TCP ;

    RPC_STATUS status = RpcServerUseProtseqEp( pszProtocol,
                                               ulMaxCalls,
                                               pszEndpoint,
                                               NULL ) ;  // Security descriptor
    if (status != RPC_S_OK)
    {
        _stprintf( tszError,
                  TEXT("RpcServerUseProtoseqEp failed, err- %lut"),
                  status) ;
        AddToMessageLog(tszError) ;
        return status ;
    }

    status = RpcServerRegisterIf( SecServ_i_v1_0_s_ifspec,
                                  NULL,    // MgrTypeUuid
                                  NULL );  // MgrEpv; null means use default
    if (status != RPC_S_OK)
    {
        _stprintf( tszError,
                  TEXT("RpcServerRegisterIf failed, err- %lut"),
                  status) ;
        AddToMessageLog(tszError) ;
        return status ;
    }

    if (fRegister)
    {
        // negotiate kerberos
        if ((_tcsicmp(pszAuthSvc, TEXT("nego")) == 0)     ||
            (_tcsicmp(pszAuthSvc, TEXT("ntlmnego")) == 0) ||
            (_tcsicmp(pszAuthSvc, TEXT("kerbnego")) == 0) ||
            (_tcsicmp(pszAuthSvc, TEXT("all")) == 0))
        {
            // kerberos needs principal name
            unsigned char * szPrincipalName;
            status = RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_NEGOTIATE,
                                                  &szPrincipalName);
            if (status != RPC_S_OK)
            {
                _stprintf( tszError,
                          TEXT("RpcServerInqDefaultPrincName(negotiate) failed, err- %lut"),
                          status) ;
                AddToMessageLog(tszError) ;
            }
            else
            {
                status = RpcServerRegisterAuthInfo( szPrincipalName,
                                                    RPC_C_AUTHN_GSS_NEGOTIATE,
                                                    NULL,
                                                    NULL );
                _stprintf( tszError,
                           TEXT("RpcServerRegisterAuthInfo(%hs, negotiate) returned %lut"),
                           szPrincipalName, status) ;
                AddToMessageLog(tszError) ;

                RpcStringFree(&szPrincipalName);
            }
        }

        // ntlm
        if ((_tcsicmp(pszAuthSvc, TEXT("ntlm")) == 0)     ||
            (_tcsicmp(pszAuthSvc, TEXT("ntlmkerb")) == 0) ||
            (_tcsicmp(pszAuthSvc, TEXT("ntlmnego")) == 0) ||
            (_tcsicmp(pszAuthSvc, TEXT("all")) == 0))
        {
            status = RpcServerRegisterAuthInfo( NULL,
                                                RPC_C_AUTHN_WINNT,
                                                NULL,
                                                NULL );
            _stprintf( tszError,
                       TEXT("RpcServerRegisterAuthInfo(ntlm) returned %lut"),
                       status) ;
            AddToMessageLog(tszError) ;
        }
    
        // TRUE kerberos
        if ((_tcsicmp(pszAuthSvc, TEXT("kerb")) == 0)     ||
            (_tcsicmp(pszAuthSvc, TEXT("ntlmkerb")) == 0) ||
            (_tcsicmp(pszAuthSvc, TEXT("kerbnego")) == 0) ||
            (_tcsicmp(pszAuthSvc, TEXT("all")) == 0))
        {
            // kerberos needs principal name
            unsigned char * szPrincipalName;
            status = RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_KERBEROS,
                                                  &szPrincipalName);
            if (status != RPC_S_OK)
            {
                _stprintf( tszError,
                          TEXT("RpcServerInqDefaultPrincName failed, err- %lut"),
                          status) ;
                AddToMessageLog(tszError) ;
            }
            else
            {
                status = RpcServerRegisterAuthInfo( szPrincipalName,
                                                    RPC_C_AUTHN_GSS_KERBEROS,
                                                    NULL,
                                                    NULL );
                _stprintf( tszError,
                           TEXT("RpcServerRegisterAuthInfo(%hs, kerberos) returned %lut"),
                           szPrincipalName, status) ;
                AddToMessageLog(tszError) ;

                RpcStringFree(&szPrincipalName);
            }
        }
    }

    s_fAlreadyInit = TRUE ;
    char szMsg[1024];
    _stprintf(szMsg, "RPC server registered successfully");
    AddToMessageLog( szMsg,
                     EVENTLOG_INFORMATION_TYPE ) ;

    status = RpcServerListen(ulMinCalls,
                             ulMaxCalls,
                             FALSE) ;
    if (status != RPC_S_OK)
    {
        s_fAlreadyInit = FALSE ;
        _stprintf( tszError,
                  TEXT("RpcServerListen failed, err- %lut"),
                  status) ;
        AddToMessageLog(tszError) ;
        return status ;
    }

    return status ;

} // end main()


DWORD __stdcall  ServerThread( void *dwP )
{
    RPC_STATUS status = RegisterServiceAsRpcServer((TCHAR *)dwP) ;
    return status ;
}

/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\secserv\secservs\secservs.cpp ===
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   secservs.cpp
//
//  PURPOSE:  Implements the body of the service.
//            The default behavior is to open a
//            named pipe, \\.\pipe\SecService, and read
//            from it.  It the modifies the data and
//            writes it back to the pipe.
//
//  FUNCTIONS:
//            ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
//            ServiceStop( );
//
//  COMMENTS: The functions implemented in simple.c are
//            prototyped in service.h
//
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//          Doron Juster
//


#include "secservs.h"
#include <process.h>

// this event is signalled when the
// service should end
//
HANDLE  hServerStopEvent = NULL;

void  ShowProcessCredential(TCHAR tszBuf[]) ;
DWORD __stdcall  ServerThread( void *dwP ) ;

extern TCHAR  g_tszLastRpcString[] ;

//
//  FUNCTION: ServiceStart
//
//  PURPOSE: Actual code of the service
//           that does the work.
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    The default behavior is to open a
//    named pipe, \\.\pipe\simple, and read
//    from it.  It the modifies the data and
//    writes it back to the pipe.  The service
//    stops when hServerStopEvent is signalled
//

VOID ServiceStart (DWORD dwArgc, LPTSTR *lpszArgv)
{
    HANDLE                  hPipe = INVALID_HANDLE_VALUE;
    HANDLE                  hEvents[2] = {NULL, NULL};
    OVERLAPPED              os;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_ATTRIBUTES     sa;
    TCHAR                   szOut[ PIPE_BUFFER_LEN ];
    LPTSTR                  lpszPipeName = PIPE_NAME ;
    BOOL                    bRet;
    DWORD                   cbRead;
    DWORD                   cbWritten;
    DWORD                   dwWait;
    UINT                    ndx;
    BOOL                    fContinue = TRUE ;

    ///////////////////////////////////////////////////
    //
    // Service initialization
    //

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
                SERVICE_START_PENDING, // service state
                NO_ERROR,              // exit code
                3000))                 // wait hint
        goto cleanup;

    // create the event object. The control handler function signals
    // this event when it receives the "stop" control code.
    //
    hServerStopEvent = CreateEvent(
            NULL,    // no security attributes
            TRUE,    // manual reset event
            FALSE,   // not-signalled
            NULL);   // no name

    if ( hServerStopEvent == NULL)
        goto cleanup;

    hEvents[0] = hServerStopEvent;

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
            SERVICE_START_PENDING, // service state
            NO_ERROR,              // exit code
            3000))                 // wait hint
        goto cleanup;

    // create the event object object use in overlapped i/o
    //
    hEvents[1] = CreateEvent(
            NULL,    // no security attributes
            TRUE,    // manual reset event
            FALSE,   // not-signalled
            NULL);   // no name

    if ( hEvents[1] == NULL)
        goto cleanup;

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
            SERVICE_START_PENDING, // service state
            NO_ERROR,              // exit code
            3000))                 // wait hint
        goto cleanup;

    // create a security descriptor that allows anyone to write to
    //  the pipe...
    //
    pSD = (PSECURITY_DESCRIPTOR) malloc( SECURITY_DESCRIPTOR_MIN_LENGTH );

    if (pSD == NULL)
        goto cleanup;

    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
        goto cleanup;

    // add a NULL disc. ACL to the security descriptor.
    //
    if (!SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE))
        goto cleanup;

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = TRUE;
    //
    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
            SERVICE_START_PENDING, // service state
            NO_ERROR,              // exit code
            3000))                 // wait hint
        goto cleanup;

    //
    // allow user tp define pipe name
    //
    for ( ndx = 1; ndx < dwArgc-1; ndx++ )
    {
        if ( ( (*(lpszArgv[ndx]) == TEXT('-')) ||
               (*(lpszArgv[ndx]) == TEXT('/')) ) &&
             _tcsicmp( TEXT("pipe"), lpszArgv[ndx]+1 ) == 0 )
        {
            lpszPipeName = lpszArgv[++ndx];
        }
    }
    //
    // open our named pipe...
    //
    hPipe = CreateNamedPipe(
                    lpszPipeName         ,  // name of pipe
                    FILE_FLAG_OVERLAPPED |
                    PIPE_ACCESS_DUPLEX,     // pipe open mode
                    PIPE_TYPE_MESSAGE |
                    PIPE_READMODE_MESSAGE |
                    PIPE_WAIT,              // pipe IO type
                    1,                      // number of instances
                    0,                      // size of outbuf (0 == allocate as necessary)
                    0,                      // size of inbuf
                    1000,                   // default time-out value
                    &sa);                   // security attributes

    if (hPipe == INVALID_HANDLE_VALUE)
    {
        AddToMessageLog(TEXT("Unable to create named pipe"));
        goto cleanup;
    }
    //
    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
            SERVICE_RUNNING,       // service state
            NO_ERROR,              // exit code
            0))                    // wait hint
        goto cleanup;

    AddToMessageLog(TEXT("Ready to accept commands"),
                    EVENTLOG_INFORMATION_TYPE) ;

    ////////////////////////////////////////////////////////////
    //
    // End of initialization
    //
    //
    // Service is now running, perform work until shutdown
    //
    ////////////////////////////////////////////////////////////

    do
    {
        // init the overlapped structure
        //
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );

        // wait for a connection...
        //
        ConnectNamedPipe(hPipe, &os);

        if ( GetLastError() == ERROR_IO_PENDING )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred,
                break;                           // or server stop signaled
        }

        // init the overlapped structure
        //
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );

        // grab whatever's coming through the pipe...
        //
        TCHAR  szIn[ PIPE_BUFFER_LEN ];

        bRet = ReadFile(
                    hPipe,          // file to read from
                    szIn,           // address of input buffer
                    sizeof(szIn),   // number of bytes to read
                    &cbRead,        // number of bytes read
                    &os);           // overlapped stuff, not needed

        if ( !bRet && ( GetLastError() == ERROR_IO_PENDING ) )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred,
                break;                           // or server stop signaled
        }

        //
        // Parse the command
        //
        if (_tcsicmp( szIn, TEXT("quit")) == 0)
        {
            fContinue = FALSE ;
            _stprintf(szOut, TEXT("%s Quitting !!!"), SZSERVICEDISPLAYNAME);
        }
        else if (_tcsicmp( szIn, TEXT("cred")) == 0)
        {
            //
            // show credentials.
            //
            ShowProcessCredential(szOut) ;
        }
        else if (_tcsicmp( szIn, TEXT("last")) == 0)
        {
             _tcscpy(szOut, g_tszLastRpcString) ;
             g_tszLastRpcString[0] = TEXT('\0') ;
        }
        else if (_tcsicmp( szIn, TEXT("rpcs")) == 0)
        {
            //
            // register as rpc server.
            //
            DWORD dwID ;
            HANDLE hT = CreateThread( NULL,
                                      0,       // stack size
                                      ServerThread,
                                      szIn + _tcslen(szIn) + 1,
                                      0,       // creation flag
                                      &dwID ) ;
            if (hT)
            {
                _tcscpy(szOut, TEXT("Rpc Server thread created OK")) ;
            }
            else
            {
                _tcscpy(szOut, TEXT("Failed to create Rpc Server thread")) ;
            }
        }
        else
        {
            //
            // return the string to client.
            //
            _stprintf(szOut, TEXT("Hello! [%s]"), szIn);
        }

        // init the overlapped structure
        //
        memset( &os, 0, sizeof(OVERLAPPED) );
        os.hEvent = hEvents[1];
        ResetEvent( hEvents[1] );
        //
        // send it back out...
        //
        bRet = WriteFile(
                    hPipe,          // file to write to
                    szOut,          // address of output buffer
                    sizeof(szOut),  // number of bytes to write
                    &cbWritten,     // number of bytes written
                    &os);           // overlapped stuff, not needed

        if ( !bRet && ( GetLastError() == ERROR_IO_PENDING ) )
        {
            dwWait = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE );
            if ( dwWait != WAIT_OBJECT_0+1 )     // not overlapped i/o event - error occurred,
                break;                           // or server stop signaled
        }
        //
        // drop the connection...
        //
        DisconnectNamedPipe(hPipe);
    }
    while (fContinue) ;

cleanup:

    if (hPipe != INVALID_HANDLE_VALUE )
        CloseHandle(hPipe);

    if (hServerStopEvent)
        CloseHandle(hServerStopEvent);

    if (hEvents[1]) // overlapped i/o event
        CloseHandle(hEvents[1]);

    if ( pSD )
        free( pSD );

}

//
//  FUNCTION: ServiceStop
//
//  PURPOSE: Stops the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    If a ServiceStop procedure is going to
//    take longer than 3 seconds to execute,
//    it should spawn a thread to execute the
//    stop code, and return.  Otherwise, the
//    ServiceControlManager will believe that
//    the service has stopped responding.
//
VOID ServiceStop()
{
    if ( hServerStopEvent )
        SetEvent(hServerStopEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\secserv\secservs\secservs.h ===
//
// File: secservs.h
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "secserv.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\copyregistry\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	CopyRegistry.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\secserv\secservs\showcred.cpp ===
//
// file: showcred.cpp
//
#include "ds_stdh.h"
//#include <windows.h>
//#include <stdio.h>
//#include <stdlib.h>
//#include <process.h>

#include "secserv.h"

static HRESULT GetLocalSystemAccountSid(OUT PSID *ppsid)
{
    PSID psid;
    SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;
    if (!AllocateAndInitializeSid(&sidAuth,
                                  1,
                                  SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &psid))
    {
        return GetLastError();
    }
    *ppsid = psid;
    return S_OK;
}

//+---------------------------
//
//  void  GetSIDNames()
//
//+---------------------------

void GetSIDNames( PSID  pSid,
                  char wszSid[] )
{
    DWORD dwASize = 1024 ;
    DWORD dwDSize = 1024 ;
    char szAccount[ 1024 ] ;
    char szDomain[ 1024 ] ;
    SID_NAME_USE su ;

    if (LookupAccountSidA( NULL,
                          pSid,
                          szAccount,
                          &dwASize,
                          szDomain,
                          &dwDSize,
                          &su ))
    {
        strcpy(wszSid, "Account: ") ;
        strcat(wszSid, szAccount) ;
        strcat(wszSid, " Domain: ") ;
        strcat(wszSid, szDomain) ;
    }
    else
    {
        strcpy(wszSid, "LookupAccountSid failed") ;
    }

    PSID psidLocalSystemAccount;
    HRESULT hr = GetLocalSystemAccountSid(&psidLocalSystemAccount);
    if (SUCCEEDED(hr))
    {
        if (EqualSid(pSid, psidLocalSystemAccount))
        {
            strcat(wszSid, ". Using local system account\n") ;
        }
        else
        {
            strcat(wszSid, ". Not using local system account\n") ;
        }
        FreeSid(psidLocalSystemAccount);
    }
    else
    {
        strcat(wszSid, ". GetLocalSystemAccountSid failed\n") ;
    }
}

//+--------------------------------
//
//  void  ShowTokenCredential()
//
//+--------------------------------

void  ShowTokenCredential( HANDLE hToken,
                           char tszBuf[] )
{
    BYTE rgbBuf[128];
    DWORD dwSize = 0;
    AP<BYTE> pBuf;
    TOKEN_USER * pTokenUser = NULL;    
    if (GetTokenInformation( hToken,
                             TokenUser,
                             rgbBuf,
                             sizeof(rgbBuf),
                             &dwSize))
    {
        pTokenUser = (TOKEN_USER *) rgbBuf;
    }
    else if (dwSize > sizeof(rgbBuf))
    {
        pBuf = new BYTE [dwSize];
        if (GetTokenInformation( hToken,
                                 TokenUser,
                                 (BYTE *)pBuf,
                                 dwSize,
                                 &dwSize))
        {
            pTokenUser = (TOKEN_USER *)((BYTE *)pBuf);
        }
        else
        {
            strcpy(tszBuf, "GetTokenInformation(2) failed") ;
        }
    }
    else
    {
        strcpy(tszBuf, "GetTokenInformation(1) failed") ;
    }

    if (pTokenUser)
    {
        SID *pSid = (SID*) pTokenUser->User.Sid ;
        GetSIDNames( pSid,
                     tszBuf ) ;
    }  
/*    
   
    TCHAR tuBuf[128] ;
    TOKEN_USER *ptu = (TOKEN_USER*) tuBuf ;
    DWORD  dwSize ;

    if (GetTokenInformation( hToken,
                             TokenUser,
                             ptu,
                             sizeof(tuBuf),
                             &dwSize ))
    {
        SID *pSid = (SID*) ptu->User.Sid ;
        GetSIDNames( pSid,
                     tszBuf ) ;
    }
    else
    {
        _tcscpy(tszBuf, TEXT("GetTokenInformation failed")) ;
    }
*/
}


//+--------------------------------
//
//  void  ShowProcessCredential()
//
//+--------------------------------

void  ShowProcessCredential(char tszBuf[])
{
    HANDLE hToken = NULL ;
    if (OpenProcessToken( GetCurrentProcess(),
                          TOKEN_READ,
                          &hToken))
    {
        ShowTokenCredential( hToken,
                             tszBuf ) ;
    }
    else
    {
        sprintf(tszBuf, "OpenProcessToken failed %lx\n", GetLastError());
    }
}

//+--------------------------------
//
//  void  ShowImpersonatedThreadCredential()
//
//+--------------------------------

void  ShowImpersonatedThreadCredential(char tszBuf[], BOOL fImpersonated)
{
    HANDLE hToken = NULL ;
    if (OpenThreadToken( GetCurrentThread(),
                          TOKEN_READ,
                          !fImpersonated /* OpenAsSelf */,
                          &hToken))
    {
        ShowTokenCredential( hToken,
                             tszBuf ) ;
    }
    else
    {
        sprintf(tszBuf, "OpenThreadToken failed %lx\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\copyregistry\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__09CCD3BA_443F_47F3_91CF_FE19390C287A__INCLUDED_)
#define AFX_STDAFX_H__09CCD3BA_443F_47F3_91CF_FE19390C287A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__09CCD3BA_443F_47F3_91CF_FE19390C287A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\copyregistry\copyregistry.cpp ===
// CopyRegistry.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "windows.h"

BOOL	CopyRegValue(HKEY hSrc, HKEY hDest, DWORD dwValueCount, DWORD dwMaxValueLength, DWORD dwMaxDataLength)
{
DWORD	dwNameLength;
DWORD	dwDataLength;
DWORD	dwType;
BOOL	bReturn = FALSE;
DWORD	dwIndex = 0;
char	*lpszName;
char    *lpszData;


	lpszName = (char *)LocalAlloc(LPTR, dwMaxValueLength);	
	lpszData = (char *)LocalAlloc(LPTR, dwMaxDataLength);
	dwNameLength = dwMaxValueLength;
	dwDataLength = dwMaxDataLength;

	if(lpszName && lpszData)
	{
		while( RegEnumValue(hSrc, dwIndex++, lpszName, &dwNameLength, NULL, &dwType, (unsigned char *)lpszData, &dwDataLength) != ERROR_NO_MORE_ITEMS)
		{
			// Duplicate the value to the destination
			RegSetValueEx(hDest, lpszName, 0, dwType, (const unsigned char *)lpszData, dwDataLength);

			// Reset the length
			dwNameLength = dwMaxValueLength;
			dwDataLength = dwMaxDataLength;
	  	}

		bReturn = TRUE;
	}
	else
	{
		bReturn = FALSE;
	}

	if(lpszName)
	{
		LocalFree(lpszName);
	}

	if(lpszData)
	{
		LocalFree(lpszData);
	}

	return bReturn;
}



//--------------------------------------------------------------------------------------------------------
//   DWORD 	SnaRegRemoveRegKey(HKEY hRegistryRoot, LPSTR szRegistryKey)
//
//   Description: Removing a Key tree in HKCU with the specified szRegistryKey path
//
//	 Input:  dwRegistryRoot -  has to be HKEY_CURRENT_USER
//           szRegistryKey  -  pointer to the registry path
//
//   return: ERROR_SUCCESS  -  successfully removed the registry keyTRUE:  Yes - replication needed
//		     non-zero       -  error code as defined in WINERROR.H
//
//
//--------------------------------------------------------------------------------------------------------
DWORD	SnaRegRemoveRegKey(HKEY hRegistryRoot, LPSTR szRegistryKey)
{
DWORD	dwReturn=ERROR_INVALID_PARAMETER;


	if(szRegistryKey && lstrlen(szRegistryKey) > 0)
	{
	HKEY	hKey=NULL;
	DWORD	dwIndex = 0;
	DWORD	dwSize = MAX_PATH;
	LONG	lStatus;
	char	szEnumeratedKey[MAX_PATH] = "";
	char	szKeyName[MAX_PATH] = "";
	LPSTR	pszKey = NULL;
	LPSTR   szClassName[MAX_PATH];
	DWORD	dwClassNameSize=sizeof(szClassName);
	DWORD	dwMaxSubKeyLength;
	DWORD	dwTotalValuesNumber;
	DWORD   dwMaxValueNameLength;
	DWORD   dwMaxValueDataLength;
	DWORD	dwSecurityDescriptorLength;
	DWORD	dwMaxClassLength;
	FILETIME ftLastWriteTime;
		
		dwReturn = RegOpenKeyEx(hRegistryRoot,
								szRegistryKey,
								0,
								KEY_ALL_ACCESS,
								&hKey);

		if(dwReturn == ERROR_SUCCESS)
		{
			dwReturn = RegQueryInfoKey(hKey,
									 (LPTSTR)szClassName,
									 &dwClassNameSize,
									 NULL,
									 &dwIndex,
									 &dwMaxSubKeyLength,				// longest subkey name
									 &dwMaxClassLength,					// longest class string
									 &dwTotalValuesNumber,				// number of value entries
									 &dwMaxValueNameLength,				// longest value name
									 &dwMaxValueDataLength,				// longest value data
									 &dwSecurityDescriptorLength,		// descriptor length
									 &ftLastWriteTime);					// last write time
		
			
			if(dwReturn == ERROR_SUCCESS && dwIndex > 0)
			{
				// decrement one to adjust for 0 indexing
				dwIndex--;

				while((dwReturn = RegEnumKey(hKey, dwIndex, szKeyName, dwSize))== ERROR_SUCCESS)
				{
				
					strcpy(szEnumeratedKey, szRegistryKey);
					strcat(szEnumeratedKey, "\\");
					strcat(szEnumeratedKey, szKeyName);
				
					// Clip the subkey tree
					dwReturn = SnaRegRemoveRegKey(hRegistryRoot, szEnumeratedKey);

					if(dwReturn != ERROR_SUCCESS || dwIndex == 0)break;

					dwSize = sizeof(szKeyName);
					dwIndex--;
				}

				if(dwReturn == ERROR_NO_MORE_ITEMS)dwReturn = ERROR_SUCCESS;
			}

			RegCloseKey(hKey);

			// ERROR_NO_MORE_ITEM indicates that we have removed all the subkeys successfully
			// we can remove the root key now
			if(dwReturn == ERROR_SUCCESS)
			{
				dwReturn = RegDeleteKey(hRegistryRoot, szRegistryKey);
			}
		}
	}

	return dwReturn;
}


BOOL	CopyRegistryHives(HKEY hSrcRoot, HKEY hDestRoot, LPSTR lpSrcTreeName, LPSTR lpDestTreeName, BOOL bMustCopy)
{
BOOL	bReturn=FALSE;
HKEY	hSrcKey=NULL;
HKEY	hDestKey=NULL;
DWORD	dwIndex=0;
DWORD	dwExist;
char	*lpszName=NULL;

DWORD	dwMaxSubKeyLength=0;
DWORD	dwSubKeyCount=0;
DWORD	dwMaxValueLength=0;
DWORD   dwMaxDataLength=0;
DWORD	dwValueCount=0;


	__try
	{

		if(RegOpenKeyEx(  hSrcRoot, lpSrcTreeName, 0, KEY_READ, &hSrcKey) != ERROR_SUCCESS || !hSrcKey)
		{
			__leave;
		}

		
		if(RegCreateKeyEx( hSrcRoot, lpDestTreeName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hDestKey, &dwExist) != ERROR_SUCCESS ||
			!hDestKey)
		{
			__leave;
		}

		// If bMustCopy is FALSE, check to see if the registry already exists in HKCU
		if(!bMustCopy && dwExist == REG_OPENED_EXISTING_KEY)
		{
#ifdef DEBUG
			DebugTrace((LONG)NULL, "Registry Root = %x, Registry Key = %s already exists, no replication needed", hDestRoot, lpTreeName);	
#endif
			__leave;
		}


		if( RegQueryInfoKey(  hSrcKey,
							  NULL,
							  NULL,
							  NULL,
							  &dwSubKeyCount,
							  &dwMaxSubKeyLength,
							  NULL,
							  &dwValueCount,
							  &dwMaxValueLength,
							  &dwMaxDataLength,
							  NULL,
							  NULL) != ERROR_SUCCESS)
		{
			__leave;
		}

		//inclement the data to include NULL termination character
		dwMaxSubKeyLength++;
		dwMaxValueLength++;
		dwMaxDataLength++;
		
		// Copy the value for the main key first
		if(dwValueCount)
		{
			CopyRegValue(hSrcKey, hDestKey, dwValueCount, dwMaxValueLength, dwMaxDataLength);
		}


		lpszName = (char *)LocalAlloc(LPTR, dwMaxSubKeyLength);	

		if(!lpszName)
		{
			__leave;
		}


		// Copy sub keys
		while( RegEnumKey(  hSrcKey, dwIndex++, lpszName, dwMaxSubKeyLength ) != ERROR_NO_MORE_ITEMS)
		{
			CopyRegistryHives(hSrcKey, hDestKey, lpszName, lpszName, bMustCopy);
		}


		

		if(lpszName)
		{
			LocalFree(lpszName);
		}

		bReturn = TRUE;


	}

	__finally
	{
		if(hSrcKey)
			RegCloseKey(hSrcKey);

		if(hDestKey)
			RegCloseKey(hDestKey);

		
	}

	return bReturn;
	
}






int main(int argc, char* argv[])
{
BOOL    bCopyRegistry=FALSE;
	printf("Hello World!\n");
    bCopyRegistry = CopyRegistryHives(HKEY_LOCAL_MACHINE, 
                                      HKEY_LOCAL_MACHINE, 
                                      "System\\CurrentControlSet\\Services\\EventLog\\Application\\MSMQ Triggers",
                                      "System\\CurrentControlSet\\Services\\EventLog\\Application\\MSMQTriggers",
                                      TRUE);


    if(bCopyRegistry)
    {
    DWORD dwResult;
    
        dwResult = SnaRegRemoveRegKey(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\Eventlog\\Application\\MSMQ Triggers");
        printf("SnaRegRemoveRegKey return = %x", dwResult);
    }
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\secserv\secservs\service.cpp ===
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   service.c
//
//  PURPOSE:  Implements functions required by all services
//            windows.
//
//  FUNCTIONS:
//    main(int argc, char **argv);
//    service_ctrl(DWORD dwCtrlCode);
//    service_main(DWORD dwArgc, LPTSTR *lpszArgv);
//    CmdInstallService(LPTSTR lpszLogonName, LPTSTR lpszLogonPwd);
//    CmdRemoveService();
//    CmdDebugService(int argc, char **argv);
//    ControlHandler ( DWORD dwCtrlType );
//    GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );
//
//  COMMENTS:
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>

#include "secserv.h"


// internal variables
SERVICE_STATUS          ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle;
DWORD                   dwErr = 0;
BOOL                    bDebug = FALSE;
TCHAR                   szErr[256];

// internal function prototypes
VOID WINAPI service_ctrl(DWORD dwCtrlCode);
VOID WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv);
VOID CmdInstallService(LPTSTR lpszLogonName, LPTSTR lpszLogonPwd);
VOID CmdRemoveService();
VOID CmdDebugService(int argc, char **argv);
BOOL WINAPI ControlHandler ( DWORD dwCtrlType );
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );

//
//  FUNCTION: main
//
//  PURPOSE: entrypoint for service
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    main() either performs the command line task, or
//    call StartServiceCtrlDispatcher to register the
//    main service thread.  When the this call returns,
//    the service has stopped, so exit.
//
void main(int argc, char **argv)
{
    SERVICE_TABLE_ENTRY dispatchTable[] =
    {
        { TEXT(SZSERVICENAME), (LPSERVICE_MAIN_FUNCTION)service_main },
        { NULL, NULL }
    };

    if ( (argc > 1) &&
         ((*argv[1] == '-') || (*argv[1] == '/')) )
    {
        if ( _stricmp( "install", argv[1]+1 ) == 0 )
        {
            LPTSTR lpszLogonName = NULL;
            LPTSTR lpszLogonPwd = NULL;
            if (argc > 2)
            {
                lpszLogonName = argv[2];
                //lpszLogonPwd = TEXT("");
            }
            if (argc > 3)
            {
                lpszLogonPwd = argv[3];
            }
            CmdInstallService(lpszLogonName, lpszLogonPwd);
        }
        else if ( _stricmp( "remove", argv[1]+1 ) == 0 )
        {
            CmdRemoveService();
        }
        else if ( _stricmp( "debug", argv[1]+1 ) == 0 )
        {
            bDebug = TRUE;
            CmdDebugService(argc, argv);
        }
        else if (( _tcsicmp( TEXT("?"), argv[1]+1 ) == 0 ) ||
                 ( _tcsicmp( TEXT("h"), argv[1]+1 ) == 0 ))
        {
            printf( "%s -install          to install the service\n", SZAPPNAME );
            printf( "%s -remove           to remove the service\n", SZAPPNAME );
            printf( "%s -debug <params>   to run as a console app for debugging\n", SZAPPNAME );
            printf( "\n To start the service: net start %s\n", SZSERVICENAME) ;
        }
        else
        {
            goto dispatch;
        }
        exit(0);
    }

    // if it doesn't match any of the above parameters
    // the service control manager may be starting the service
    // so we must call StartServiceCtrlDispatcher
dispatch:
        // this is just to be friendly
        printf( "\nStartServiceCtrlDispatcher being called.\n" );
        printf( "This may take several seconds.  Please wait.\n" );

        if (!StartServiceCtrlDispatcher(dispatchTable))
            AddToMessageLog(TEXT("StartServiceCtrlDispatcher failed."));
}


//
//  FUNCTION: service_main
//
//  PURPOSE: To perform actual initialization of the service
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This routine performs the service initialization and then calls
//    the user defined ServiceStart() routine to perform majority
//    of the work.
//
void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv)
{

    // register our service control handler:
    //
    sshStatusHandle = RegisterServiceCtrlHandler( TEXT(SZSERVICENAME), service_ctrl);

    if (!sshStatusHandle)
        goto cleanup;

    // SERVICE_STATUS members that don't change in example
    //
    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;


    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        goto cleanup;


    ServiceStart( dwArgc, lpszArgv );

cleanup:

    // try to report the stopped status to the service control manager.
    //
    if (sshStatusHandle)
        (VOID)ReportStatusToSCMgr(
                            SERVICE_STOPPED,
                            dwErr,
                            0);

    return;
}



//
//  FUNCTION: service_ctrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode - type of control requested
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID WINAPI service_ctrl(DWORD dwCtrlCode)
{
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop the service.
        //
        case SERVICE_CONTROL_STOP:
            ssStatus.dwCurrentState = SERVICE_STOP_PENDING;
            ServiceStop();
            break;

        // Update the service status.
        //
        case SERVICE_CONTROL_INTERROGATE:
            break;

        // invalid control code
        //
        default:
            break;

    }

    ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);

}



//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;


    if ( !bDebug ) // when debugging we don't report to the SCM
    {
        if (dwCurrentState == SERVICE_START_PENDING)
            ssStatus.dwControlsAccepted = 0;
        else
            ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

        ssStatus.dwCurrentState = dwCurrentState;
        ssStatus.dwWin32ExitCode = dwWin32ExitCode;
        ssStatus.dwWaitHint = dwWaitHint;

        if ( ( dwCurrentState == SERVICE_RUNNING ) ||
             ( dwCurrentState == SERVICE_STOPPED ) )
            ssStatus.dwCheckPoint = 0;
        else
            ssStatus.dwCheckPoint = dwCheckPoint++;


        // Report the status of the service to the service control manager.
        //
        if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus))) {
            AddToMessageLog(TEXT("SetServiceStatus"));
        }
    }
    return fResult;
}


//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//

VOID AddToMessageLog(LPTSTR lpszMsg, WORD wType)
{
    TCHAR   szMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[2];


//    if ( !bDebug )
    {
        if (wType == EVENTLOG_ERROR_TYPE)
        {
            DWORD dwErr = GetLastError();
            _stprintf( szMsg,
                       TEXT("%s error: %d"),
                       SZSERVICENAME,
                       dwErr ) ;
        }
        else if (wType == EVENTLOG_INFORMATION_TYPE)
        {
            _stprintf( szMsg,
                       TEXT("%s information "),
                       SZSERVICENAME ) ;
        }
        else
        {
            _stprintf( szMsg,
                       TEXT("%s unknown "),
                       SZSERVICENAME ) ;
        }

        // Use event logging to log the error.
        //
        hEventSource = RegisterEventSource(NULL, TEXT(SZSERVICENAME));

        lpszStrings[0] = szMsg;
        lpszStrings[1] = lpszMsg;

        if (hEventSource != NULL)
        {
            ReportEvent(hEventSource,         // handle of event source
                        wType,                // event type
                        0,                    // event category
                        0,                    // event ID
                        NULL,                 // current user's SID
                        2,                    // strings in lpszStrings
                        0,                    // no bytes of raw data
                        (LPCTSTR *) lpszStrings,          // array of error strings
                        NULL);                // no raw data

            (VOID) DeregisterEventSource(hEventSource);
        }
    }
}

///////////////////////////////////////////////////////////////////
//
//  The following code handles service installation and removal
//


//
//  FUNCTION: CmdInstallService(LPTSTR lpszLogonName, LPTSTR lpszLogonPwd)
//
//  PURPOSE: Installs the service
//
//  PARAMETERS:
//    szLogonName - logon account name (NULL for local system account)
//    szLogonPwd  - logon account password (NULL for local system account)
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdInstallService(LPTSTR lpszLogonName, LPTSTR lpszLogonPwd)
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    TCHAR szPath[512];

    if ( GetModuleFileName( NULL, szPath, 512 ) == 0 )
    {
        _tprintf(TEXT("Unable to install %s - %s\n"), TEXT(SZSERVICEDISPLAYNAME), GetLastErrorText(szErr, 256));
        return;
    }

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = CreateService(
            schSCManager,               // SCManager database
            TEXT(SZSERVICENAME),        // name of service
            TEXT(SZSERVICEDISPLAYNAME), // name to display
            SERVICE_ALL_ACCESS,         // desired access
            SERVICE_WIN32_OWN_PROCESS,  // service type
            SERVICE_DEMAND_START,       // start type
            SERVICE_ERROR_NORMAL,       // error control type
            szPath,                     // service's binary
            NULL,                       // no load ordering group
            NULL,                       // no tag identifier
            TEXT(SZDEPENDENCIES),       // dependencies
            lpszLogonName,              // NULL means LocalSystem account
            lpszLogonPwd);              // NULL means no password

        if ( schService )
        {
            _tprintf(TEXT("%s installed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
            _tprintf(TEXT("to start: net start %s\n"), SZSERVICENAME) ;
            CloseServiceHandle(schService);
        }
        else
        {
            _tprintf(TEXT("CreateService failed - %s\n"), GetLastErrorText(szErr, 256));
        }

        CloseServiceHandle(schSCManager);
    }
    else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}



//
//  FUNCTION: CmdRemoveService()
//
//  PURPOSE: Stops and removes the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdRemoveService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, TEXT(SZSERVICENAME), SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if ( ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
            {
                _tprintf(TEXT("Stopping %s."), TEXT(SZSERVICEDISPLAYNAME));
                Sleep( 1000 );

                while( QueryServiceStatus( schService, &ssStatus ) )
                {
                    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
                    {
                        _tprintf(TEXT("."));
                        Sleep( 1000 );
                    }
                    else
                        break;
                }

                if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
                    _tprintf(TEXT("\n%s stopped.\n"), TEXT(SZSERVICEDISPLAYNAME) );
                else
                    _tprintf(TEXT("\n%s failed to stop.\n"), TEXT(SZSERVICEDISPLAYNAME) );

            }

            // now remove the service
            if( DeleteService(schService) )
                _tprintf(TEXT("%s removed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
            else
                _tprintf(TEXT("DeleteService failed - %s\n"), GetLastErrorText(szErr,256));


            CloseServiceHandle(schService);
        }
        else
            _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));

        CloseServiceHandle(schSCManager);
    }
    else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}




///////////////////////////////////////////////////////////////////
//
//  The following code is for running the service as a console app
//


//
//  FUNCTION: CmdDebugService(int argc, char ** argv)
//
//  PURPOSE: Runs the service as a console application
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdDebugService(int argc, char ** argv)
{
    DWORD dwArgc;
    LPTSTR *lpszArgv;

#ifdef UNICODE
    lpszArgv = CommandLineToArgvW(GetCommandLineW(), &(dwArgc) );
#else
    dwArgc   = (DWORD) argc;
    lpszArgv = argv;
#endif

    _tprintf(TEXT("Debugging %s.\n"), TEXT(SZSERVICEDISPLAYNAME));

    SetConsoleCtrlHandler( ControlHandler, TRUE );

    ServiceStart( dwArgc, lpszArgv );
}


//
//  FUNCTION: ControlHandler ( DWORD dwCtrlType )
//
//  PURPOSE: Handled console control events
//
//  PARAMETERS:
//    dwCtrlType - type of control event
//
//  RETURN VALUE:
//    True - handled
//    False - unhandled
//
//  COMMENTS:
//
BOOL WINAPI ControlHandler ( DWORD dwCtrlType )
{
    switch( dwCtrlType )
    {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
            _tprintf(TEXT("Stopping %s.\n"), TEXT(SZSERVICEDISPLAYNAME));
            ServiceStop();
            return TRUE;
            break;

    }
    return FALSE;
}

//
//  FUNCTION: GetLastErrorText
//
//  PURPOSE: copies error message text to string
//
//  PARAMETERS:
//    lpszBuf - destination buffer
//    dwSize - size of buffer
//
//  RETURN VALUE:
//    destination buffer
//
//  COMMENTS:
//
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize )
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           NULL,
                           GetLastError(),
                           LANG_NEUTRAL,
                           (LPTSTR)&lpszTemp,
                           0,
                           NULL );

    // supplied buffer is not long enough
    if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )
        lpszBuf[0] = TEXT('\0');
    else
    {
        lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\0');  //remove cr and newline character
        _stprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, GetLastError() );
    }

    if ( lpszTemp )
        LocalFree((HLOCAL) lpszTemp );

    return lpszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\mngcontainer\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MngContainer.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_MNGCONTAINER_DIALOG         102
#define IDR_MAINFRAME                   128
#define IDC_KEY_CONTAINERS_LIST         1000
#define IDC_REMOVE_CONTAINER            1001
#define IDC_REMOVE_MQB_CONTAINER        1002
#define IDC_GET_PUBLIC_KEY              1003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\mngcontainer\mngcontainer.cpp ===
// MngContainer.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "MngContainer.h"
#include "MngContainerDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMngContainerApp

BEGIN_MESSAGE_MAP(CMngContainerApp, CWinApp)
	//{{AFX_MSG_MAP(CMngContainerApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMngContainerApp construction

CMngContainerApp::CMngContainerApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMngContainerApp object

CMngContainerApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMngContainerApp initialization

BOOL CMngContainerApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CMngContainerDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\mngcontainer\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	MngContainer.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include "afxpriv.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\mngcontainer\mngcontainerdlg.cpp ===
// MngContainerDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MngContainer.h"
#include "MngContainerDlg.h"
#include "wincrypt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LPWSTR AllocateUnicodeString(LPSTR  pAnsiString);
void FreeUnicodeString(LPWSTR  pUnicodeString);
int AnsiToUnicodeString(LPSTR pAnsi,  LPWSTR pUnicode, DWORD StringLength);

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMngContainerDlg dialog

CMngContainerDlg::CMngContainerDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CMngContainerDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMngContainerDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CMngContainerDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMngContainerDlg)
	DDX_Control(pDX, IDC_KEY_CONTAINERS_LIST, m_wndContainerList);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMngContainerDlg, CDialog)
	//{{AFX_MSG_MAP(CMngContainerDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_REMOVE_CONTAINER, OnRemoveContainer)
	ON_BN_CLICKED(IDC_REMOVE_MQB_CONTAINER, OnRemoveMQBContainer)
	ON_BN_CLICKED(IDC_GET_PUBLIC_KEY, OnGetPublicKey)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMngContainerDlg message handlers

BOOL CMngContainerDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	EnumCryptoContainer();
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CMngContainerDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CMngContainerDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CMngContainerDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CMngContainerDlg::OnRemoveContainer() 
{
int	i=LB_ERR;
DWORD	dwError = ERROR_SUCCESS;

	UpdateData(TRUE);

	i = m_wndContainerList.GetCurSel();

	if(i != LB_ERR)
	{
	char szBuffer[1024];
	int	 nSize=LB_ERR;

		nSize = m_wndContainerList.GetText(i, (LPTSTR)szBuffer);

		if(nSize != LB_ERR &&
		   RemoveKeyContainer((LPWSTR)szBuffer) == ERROR_SUCCESS)
		{
			m_wndContainerList.DeleteString(i);
		}

	}
	
}

void CMngContainerDlg::OnRemoveMQBContainer() 
{
WCHAR wszBuffer[1024];
int	 i=LB_ERR;
int  count=0;

	UpdateData(TRUE);

	count = m_wndContainerList.GetCount();

	if(count > 0)
	{

		wcscpy(wszBuffer, MQBRIDGE_CONTAINER_NAME);
		wcscat(wszBuffer, MQBRIDGE_ENH_SUFFIX);
		if( (i = m_wndContainerList.FindStringExact(0, wszBuffer) )!= LB_ERR)
		{
			if(RemoveKeyContainer(wszBuffer) == ERROR_SUCCESS)
			{
				m_wndContainerList.DeleteString(i);
			}
		}
	

		wcscpy(wszBuffer, MQBRIDGE_CONTAINER_NAME);
		if( (i = m_wndContainerList.FindStringExact(0, wszBuffer)) != LB_ERR)
		{
			if(RemoveKeyContainer(wszBuffer) == ERROR_SUCCESS)
			{
				m_wndContainerList.DeleteString(i);
			}
		}
	}
}


DWORD CMngContainerDlg::EnumCryptoContainer() 
{
HCRYPTPROV	hProv   = 0;
DWORD		dwError=ERROR_SUCCESS;
char		szBuffer[512];
DWORD		nBufferSize=sizeof(szBuffer);
BOOL		bReturn=FALSE;
DWORD		dwFlags=CRYPT_FIRST;
int			i=0;


	if(!CryptAcquireContext(&hProv, NULL , NULL, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET)) 
	{
		dwError = GetLastError();
    
		if((dwError = GetLastError()) == NTE_BAD_KEYSET)
		{
			if( !CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET | CRYPT_NEWKEYSET))
			{
				dwError = GetLastError();
				return dwError;
			}
		}
		else
			return dwError;
	
    }

	

	do
	{
		
	    bReturn = CryptGetProvParam(hProv, PP_ENUMCONTAINERS, (unsigned char *)szBuffer, &nBufferSize, dwFlags);
		

		if(bReturn)
		{
		LPWSTR lpMessage=NULL;

			lpMessage = AllocateUnicodeString((char *)szBuffer);

			if(lpMessage)
			{
				m_wndContainerList.AddString(lpMessage);
				FreeUnicodeString(lpMessage);
			}

			dwFlags = CRYPT_NEXT;
		}
		else
		{
			if(GetLastError() == ERROR_NO_MORE_ITEMS)break;
		}
	}while(bReturn);

	if(hProv)
	{
		CryptReleaseContext(hProv, 0);
		hProv = NULL;
	}

	return dwError;
}


DWORD	CMngContainerDlg::RemoveKeyContainer(LPWSTR lpwszContainerName)
{
HCRYPTPROV	hProv   = 0;
DWORD		dwLastError = ERROR_SUCCESS;
		
	if(!CryptAcquireContext(&hProv, (LPWSTR)lpwszContainerName, NULL, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET|CRYPT_DELETEKEYSET)) 
	{
	CString	csMsg;

		dwLastError = GetLastError();
		csMsg.Format(L"Unable to delete key container %s, error code = %x(H)",lpwszContainerName, dwLastError);
		MessageBox(csMsg);
	}
	else
	{
	CString csMsg;
			
		csMsg.Format(L"Successfully deleted key container %s",lpwszContainerName);
		MessageBox(csMsg);

				
	}

	return dwLastError;
}


LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
    )
{
    LPWSTR  pUnicodeString = NULL;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR)LocalAlloc(
                        LPTR,
                        strlen(pAnsiString)*sizeof(WCHAR) + sizeof(WCHAR)
                        );

    if (pUnicodeString) {

        AnsiToUnicodeString(
            pAnsiString,
            pUnicodeString,
            0
            );
    }

    return pUnicodeString;
}


void
FreeUnicodeString(
    LPWSTR  pUnicodeString
    )
{

    LocalFree(pUnicodeString);

    return;
}


int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
{
    int iReturn;

    if( StringLength == 0 )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}






void CMngContainerDlg::OnGetPublicKey() 
{
int	i=LB_ERR;
DWORD	dwError = ERROR_SUCCESS;


	UpdateData(TRUE);

	i = m_wndContainerList.GetCurSel();

	if(i != LB_ERR)
	{
	char szBuffer[1024];
	int	 nSize=LB_ERR;

		nSize = m_wndContainerList.GetText(i, (LPTSTR)szBuffer);

		if(nSize != LB_ERR)
		{
			DisplayKeyContainerPublicKey((LPWSTR)szBuffer);
		}

	}
	
}



DWORD	CMngContainerDlg::DisplayKeyContainerPublicKey(LPWSTR lpwszContainerName)
{
HCRYPTPROV	hProv   = 0;
DWORD		dwLastError = ERROR_SUCCESS;
HCRYPTKEY hKey     = 0;
HCRYPTKEY hXchgKey = 0;
DWORD	  dwError;
		
	if(!CryptAcquireContext(&hProv, (LPWSTR)lpwszContainerName, NULL, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET)) 
	{
	CString	csMsg;

		csMsg.Format(L"Unable to use key container %s",lpwszContainerName);
		MessageBox(csMsg);

	}
	else
	{



		if(!CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hXchgKey)) 
		{
		CString csFormat=L"Error %x during CryptGetUserKey!";
		CString csMsg;
	
			dwError = GetLastError();
			csMsg.Format(csFormat, dwError);
			MessageBox(csMsg, L"CryptGetUserKey", MB_OK);
			return 0;
		}
		else
		{
		PBYTE pbKeyBlob = NULL;
		DWORD dwKeyBlobLen;

			// Determine size of the key blob and allocate memory.
			if(!CryptExportKey(hXchgKey, hKey, PUBLICKEYBLOB, 0, NULL, &dwKeyBlobLen)) 
			{
			CString csFormat=L"Error %x computing blob length!";
			CString csMsg;

				dwError = GetLastError();
				csMsg.Format(csFormat, dwError);
				MessageBox(csMsg, L"CryptExportKey", MB_OK);
			
		    
			}
			else
			{
			CString csFormat=L"Allocated %d buffer size to store the public key blob";
			CString csMsg;
		

				csMsg.Format(csFormat, dwKeyBlobLen);
				MessageBox(csMsg, L"Allocated Memory", MB_OK);
				dwError = ERROR_SUCCESS;

			
				if((pbKeyBlob = (unsigned char *)LocalAlloc(LPTR, dwKeyBlobLen)) == NULL) 
				{
					CString csMsg=L"Out of memory!";
			
					MessageBox(csMsg, L"Allocated Memory", MB_OK);
					dwError = ERROR_NOT_ENOUGH_MEMORY;
				}
				// Export session key into a simple key blob.
				else if	(!CryptExportKey(hXchgKey, hKey, PUBLICKEYBLOB, 0, pbKeyBlob, &dwKeyBlobLen)) 
				{
				CString csFormat=L"Error %x during CryptExportKey!";
				CString csMsg;

					dwError = GetLastError();
					csMsg.Format(csFormat, dwError);
					MessageBox(csMsg, L"CryptExportKey", MB_OK);
				}

				if(dwError == ERROR_SUCCESS)
				{
				CString csFormat=L"Public Key Blob(%d) = %s";
				CString csMsg;
				WCHAR szPublicKey[200];
				int		i;
				int		j;

					for(i=0;i<dwKeyBlobLen;i++)
					{
					int	nValue;
					
						nValue = *(pbKeyBlob+i);
						j = i*2;
						_itoa((nValue & 0xf0) >> 4, (char *)&szPublicKey[j],16);			
						_itoa((nValue & 0x0f), (char *)&szPublicKey[j+1],16);
					}

					szPublicKey[j+2]=0;
					csMsg.Format(csFormat, dwKeyBlobLen, szPublicKey);
					MessageBox(csMsg, L"Public Key Blob", MB_OK);

				}
			}

			if(pbKeyBlob)LocalFree(pbKeyBlob);


		}
	}

	if(hProv)
	{
		CryptReleaseContext(hProv, 0);
		hProv = NULL;
	}

	if(hXchgKey)
		CryptDestroyKey(hXchgKey);

	if(hKey)
		CryptDestroyKey(hKey);


	return dwLastError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\mngcontainer\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__794A74D9_299B_11D3_8D72_00C04FC307FA__INCLUDED_)
#define AFX_STDAFX_H__794A74D9_299B_11D3_8D72_00C04FC307FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__794A74D9_299B_11D3_8D72_00C04FC307FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\mngcontainer\mngcontainer.h ===
// MngContainer.h : main header file for the MNGCONTAINER application
//

#if !defined(AFX_MNGCONTAINER_H__794A74D5_299B_11D3_8D72_00C04FC307FA__INCLUDED_)
#define AFX_MNGCONTAINER_H__794A74D5_299B_11D3_8D72_00C04FC307FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CMngContainerApp:
// See MngContainer.cpp for the implementation of this class
//

class CMngContainerApp : public CWinApp
{
public:
	CMngContainerApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMngContainerApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMngContainerApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MNGCONTAINER_H__794A74D5_299B_11D3_8D72_00C04FC307FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\crypto\main.c ===
//--------------------------------------------------------------------
//  Example code using CryptEnumProviderTypes, CryptEnumProviders, 
//  CryptGetDefaultProvider, and CryptGetProvParam.
//  Most of these functions are available only with Windows 2000 
//  and later.     
//--------------------------------------------------------------------
//   In this and all other sample and example code, 
//   use the #define and #include statements listed 
//   under #includes and #defines.

#include <stdio.h>
#include <windows.h>
#include <wincrypt.h>
void HandleError(char *s);
void Wait(char *s);

LPWSTR AllocateUnicodeString(LPSTR  pAnsiString);
void FreeUnicodeString(LPWSTR  pUnicodeString);
int AnsiToUnicodeString(LPSTR pAnsi,  LPWSTR pUnicode, DWORD StringLength);

void _cdecl main()
{

//--------------------------------------------------------------------
//  Declare and initialize variables.

HCRYPTPROV hProv;         // Handle to a CSP
LPTSTR      pszName;
DWORD       dwType;
DWORD       cbName;
DWORD       dwIndex=0;
BYTE        *ptr;
ALG_ID      aiAlgid;
DWORD       dwBits;
DWORD       dwNameLen;
CHAR        szName[100]; // Often allocated dynamically
BYTE        pbData[1024];// Often allocated dynamically
DWORD       cbData=1024;
DWORD       dwIncrement = sizeof(DWORD);
DWORD       dwFlags=CRYPT_FIRST;
//DWORD       dwParam = PP_CLIENT_HWND;
CHAR        *pszAlgType = NULL;
BOOL        fMore=TRUE;
LPTSTR      pbProvName;
DWORD       cbProvName;
BOOL	    bReturn = TRUE;
char		szBuffer[512];
DWORD		nBufferSize=sizeof(szBuffer);
DWORD       dwError;



//--------------------------------------------------------------
//   Print header lines for provider types.

printf("\n          Listing Available Provider Types.\n");
printf("Provider type      Provider Type Name\n");
printf("_____________    _____________________________________\n");  

// Loop through enumerating provider types.
dwIndex = 0;
while(CryptEnumProviderTypes(
       dwIndex,     // in -- dwIndex
       NULL,        // in -- pdwReserved- set to NULL
       0,           // in -- dwFlags -- set to zero
       &dwType,     // out -- pdwProvType
       NULL,        // out -- pszProvName -- NULL on the first call
       &cbName      // in, out -- pcbProvName
       ))
{

//--------------------------------------------------------------------
//  cbName is the length of the name of the next provider type.
//  Allocate memory in a buffer to retrieve that name.
pszName = (LPTSTR)LocalAlloc(LMEM_ZEROINIT, cbName);
if (!pszName)
{
   HandleError("ERROR - LocalAlloc failed!");
}
//--------------------------------------------------------------------
//  Get the provider type name.

if (CryptEnumProviderTypes(
       dwIndex++,
       (DWORD *)NULL,
       (DWORD)NULL,
       (DWORD *)&dwType,   
       pszName,
       (DWORD *)&cbName))     
{
    printf ("     %4.0d        %s\n",dwType, pszName);
}
else
{
    HandleError("ERROR - CryptEnumProviders");
}
LocalFree(pszName);
}




//--------------------------------------------------------------
//   Print header lines for providers.

printf("\n\n          Listing Available Providers.\n");
printf("Provider type      Provider Name\n");
printf("_____________    _____________________________________\n");   
//---------------------------------------------------------------- 
// Loop through enumerating providers.
dwIndex = 0;
while(CryptEnumProviders(
       dwIndex,     // in -- dwIndex
       NULL,        // in -- pdwReserved- set to NULL
       0,           // in -- dwFlags -- set to zero
       &dwType,     // out -- pdwProvType
       NULL,        // out -- pszProvName -- NULL on the first call
       &cbName      // in, out -- pcbProvName
       ))
{

//--------------------------------------------------------------------
//  cbName is the length of the name of the next provider.
//  Allocate memory in a buffer to retrieve that name.
pszName = (LPTSTR)LocalAlloc(LMEM_ZEROINIT, cbName);
if (!pszName)
{
   HandleError("ERROR - LocalAlloc failed!");
}
//--------------------------------------------------------------------
//  Get the provider name.

if (CryptEnumProviders(
       dwIndex++,
       NULL,
       0,
       &dwType,
       pszName,
       &cbName     // pcbProvName -- size of pszName
       ))
{
    printf ("     %4.0d        %s\n",dwType, pszName);
}
else
{
    HandleError("ERROR - CryptEnumProviders");
}
LocalFree(pszName);

} // End of while loop



// -------------------
//   Display containers
//
	printf("\n ---------------------------------------\n");
	printf(" Cryto Container Name list \n");
	
	if(!CryptAcquireContext(&hProv, NULL , NULL, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET)) 
	{
		dwError = GetLastError();
    
		if((dwError = GetLastError()) == NTE_BAD_KEYSET)
		{
			if( !CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET | CRYPT_NEWKEYSET))
			{
				dwError = GetLastError();
				return ;
			}
		}
		else
			return;
	
    }


	do
	{
		bReturn = CryptGetProvParam(hProv, PP_ENUMCONTAINERS, (unsigned char *)szBuffer, &nBufferSize, dwFlags);
		

		if(bReturn)
		{
			printf(szBuffer);
			printf("\n");
			dwFlags = CRYPT_NEXT;
		}
		else
		{
			if(GetLastError() == ERROR_NO_MORE_ITEMS)break;
		}
	}
	while(bReturn);

printf("\n\nProvider types, provider names, machine crypto containers have been listed.\n\n");
Wait("Press any key to continue.");


//-----------------------------------------------------------------
// Get the name of the default CSP specified for the PROV_RSA_FULL
// type for the computer.
//

//---------------------------------------------------------------
// Get the length of the RSA_FULL default provider name.

if (!(CryptGetDefaultProvider(
     PROV_RSA_FULL, 
     NULL, 
     CRYPT_MACHINE_DEFAULT,
     NULL, 
     &cbProvName))) 
{ 
   HandleError("Error getting the length of the default provider name.");
}

//---------------------------------------------------------------
// Allocate local memory for the name of the default provider.
pbProvName = (LPTSTR)LocalAlloc(LMEM_ZEROINIT, cbProvName);
if (!pbProvName)
{
    HandleError("Error during memory allocation for provider name.");
}

//---------------------------------------------------------------
// Get the default provider name.

if (CryptGetDefaultProvider(
    PROV_RSA_FULL, 
    (DWORD *)NULL, 
    (DWORD)CRYPT_MACHINE_DEFAULT,
    pbProvName,
    (DWORD *)&cbProvName)) 
{
    printf("The default provider name is %s\n\n",pbProvName);
}
else
{
    HandleError("Getting the name of the provider failed.");
}

//-----------------------------------------------------
//  Acquire a cryptographic context.

if(!CryptAcquireContext(
   &hProv, 
   "OUR Container",
   (DWORD)NULL,
   (DWORD)PROV_RSA_FULL, 
   (DWORD)NULL            // Use CRYPT_NEWKEYSET if the Key Container
                   // is new.
   ))  
{
    HandleError("Error during CryptAcquireContext!");
}



//------------------------------------------------------
// Enumerate the supported algorithms.

//------------------------------------------------------
// Print header for algorithm infomation table
printf("\n               Enumerating the supported algorithms\n\n");
printf("     Algid      Bits      Type        Name         Algorithm\n");
printf("                                     Length          Name\n");
printf("    ________________________________________________________\n");
while(fMore)
{
//------------------------------------------------------
// Retrieve information about an algorithm.

    if(CryptGetProvParam(hProv, PP_ENUMALGS, pbData, &cbData, dwFlags))
    {       
    //-----------------------------------------------------------
    // Extract algorithm information from the 'pbData' buffer.
    
       dwFlags=0;
       ptr = pbData;
       aiAlgid = *(ALG_ID *)ptr;
       ptr += sizeof(ALG_ID);
       dwBits = *(DWORD *)ptr;
       ptr += dwIncrement;
       dwNameLen = *(DWORD *)ptr;
       ptr += dwIncrement;
       strncpy(szName,(char *) ptr, dwNameLen);
       
     //--------------------------------------------------------
     // Determine the algorithm type.

   switch(GET_ALG_CLASS(aiAlgid)) {
        case ALG_CLASS_DATA_ENCRYPT: pszAlgType = "Encrypt  ";
                                     break;
        case ALG_CLASS_HASH:         pszAlgType = "Hash     ";
                                     break;
        case ALG_CLASS_KEY_EXCHANGE: pszAlgType = "Exchange ";
                                     break;
        case ALG_CLASS_SIGNATURE:    pszAlgType = "Signature";
                                     break;
        default:                     pszAlgType = "Unknown  ";
    }

    //------------------------------------------------------------
    // Print information about the algorithm.

     printf("    %8.8xh    %-4d    %s     %-2d          %s\n",
        aiAlgid, dwBits, pszAlgType, dwNameLen, szName
    );
}
else
   fMore=FALSE;
}

if(GetLastError() == ERROR_NO_MORE_ITEMS)
{ 
   printf("\nThe program completed without error.\n");
}
else
{ 
   HandleError("Error reading algorithm!");
}




} // End of main 

//--------------------------------------------------------------------
//  This example uses the function HandleError, a simple error
//  handling function, to print an error message and exit 
//  the program. 
//  For most applications, replace this function with one 
//  that does more extensive error reporting.

void HandleError(char *s)
{
    printf("An error occurred in running the program.\n");
    printf("%s\n",s);
    printf("Error number %x\n.",GetLastError());
    printf("Program terminating.\n");
    exit(1);
}

void Wait(char *s)
{
char x;
printf("%s",s);
scanf("%c",&x);
printf("\n\n\n\n\n\n\n\n\n");
}


LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
    )
{
    LPWSTR  pUnicodeString = NULL;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR)LocalAlloc(
                        LPTR,
                        strlen(pAnsiString)*sizeof(WCHAR) + sizeof(WCHAR)
                        );

    if (pUnicodeString) {

        AnsiToUnicodeString(
            pAnsiString,
            pUnicodeString,
            0
            );
    }

    return pUnicodeString;
}


void
FreeUnicodeString(
    LPWSTR  pUnicodeString
    )
{

    LocalFree(pUnicodeString);

    return;
}


int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
{
    int iReturn;

    if( StringLength == 0 )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\mngcontainer\mngcontainerdlg.h ===
// MngContainerDlg.h : header file
//

#if !defined(AFX_MNGCONTAINERDLG_H__794A74D7_299B_11D3_8D72_00C04FC307FA__INCLUDED_)
#define AFX_MNGCONTAINERDLG_H__794A74D7_299B_11D3_8D72_00C04FC307FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#define MQBRIDGE_CONTAINER_NAME			L"MQBRIDGE"
#define MQBRIDGE_ENH_SUFFIX				L"_ENH"

/////////////////////////////////////////////////////////////////////////////
// CMngContainerDlg dialog

class CMngContainerDlg : public CDialog
{
// Construction
public:
	CMngContainerDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CMngContainerDlg)
	enum { IDD = IDD_MNGCONTAINER_DIALOG };
	CListBox	m_wndContainerList;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMngContainerDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CMngContainerDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnRemoveContainer();
	afx_msg void OnRemoveMQBContainer();
	afx_msg void OnGetPublicKey();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	DWORD EnumCryptoContainer();
	DWORD RemoveKeyContainer(LPWSTR lpwszContainerName);
	DWORD DisplayKeyContainerPublicKey(LPWSTR lpwszContainerName);

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MNGCONTAINERDLG_H__794A74D7_299B_11D3_8D72_00C04FC307FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\socktest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__EEB5AF55_BB55_42AB_9207_AB13E7DA962F__INCLUDED_)
#define AFX_STDAFX_H__EEB5AF55_BB55_42AB_9207_AB13E7DA962F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__EEB5AF55_BB55_42AB_9207_AB13E7DA962F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\socktest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	socktest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\sspi\srv.cpp ===
#include <windows.h>

#define SECURITY_WIN32
#define SECURITY_NTLM
#include <sspi.h>
#include <issperr.h>

#include <winsock.h>

#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

#include "secdef.h"
HMODULE hSecLib;

extern "C" int __cdecl main( int argc, PCHAR *argv )
{
	DWORD dwRet;
	CSecObject SecObjIn;
	WSADATA  wsData = {0};
	int iPort = 4000;

	if( argc > 1 )
	{
		while( --argc )
		{
			if(!_strnicmp(argv[argc], "/help", 5) ||
			   !_strnicmp(argv[argc], "/?", 2))
			{
				printf("usage: sspisrv [/port=<listen port>]\n");
				printf("requires ""Act as Part of the Operating System Privilege""\n");
				return(0);
			}
			else if( !_strnicmp( argv[argc], "/port=", 6 ) )
			{
				iPort = atoi( argv[argc] + 6 );
			}
		}
	}

	printf("Listening on port %u\n",iPort);

	WSAStartup(MAKEWORD(1,1), &wsData);
	if(SecObjIn.Listen(iPort) != ERROR_SUCCESS)
	{
		WSACleanup();
		return(-1);
	}

	do
	{
		hSecLib = (HMODULE)LoadLibrary( "SECURITY.DLL" );
		if(hSecLib )
		{
			dwRet = SecObjIn.InitializeNtLmSecurity(SECPKG_CRED_INBOUND);
			if(dwRet == STATUS_SEVERITY_SUCCESS)
			{
				do
				{
					dwRet = SecObjIn.ReceiveContext();
					if(dwRet == SEC_I_CONTINUE_NEEDED)
					{
						dwRet = SecObjIn.AcceptNtLmSecurityContext(
									SecObjIn.GetInBuffer()
									);

						SecObjIn.ReleaseInBuffer();

						if(dwRet == SEC_I_CONTINUE_NEEDED ||
						   dwRet == SEC_E_OK)
						{
							DWORD lRet;
							lRet = SecObjIn.SendContext(
										SecObjIn.GetOutBuffer()
										);
							if(lRet != ERROR_SUCCESS)
							{
								dwRet = lRet;
							}
						}
					}

				} while(dwRet == SEC_I_CONTINUE_NEEDED);

				if(dwRet == SEC_E_OK)
				{
					printf("Logon OK\n");
				}
				else if(dwRet == ERROR_HANDLE_EOF)
				{
					printf("Client Disconnected\n");
				}

                SecObjIn.CleanupNtLmSecurityContext();
				SecObjIn.CleanupNtLmSecurity();
			}

			FreeLibrary( hSecLib );
			hSecLib = NULL;
		}
		else
		{
			dwRet = GetLastError();
		}

		if(_kbhit())
			break;

	} while(dwRet == STATUS_SEVERITY_SUCCESS);

	SecObjIn.Disconnect();
	WSACleanup();
	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\sspi\secdef.h ===
typedef struct sockaddr_in SOCKADDR_IP;

class CSecObject
{
public:
	CSecObject();
	~CSecObject();

	DWORD InitializeNtLmSecurity(ULONG);
	DWORD CleanupNtLmSecurity(VOID);

	DWORD InitializeNtLmSecurityContext(LPSTR lpwszDomain,PSecBufferDesc InBuffer);
	DWORD AcceptNtLmSecurityContext(PSecBufferDesc InBuffer);
	DWORD CleanupNtLmSecurityContext();

    PSecBufferDesc GetOutBuffer();
    PSecBufferDesc GetInBuffer();
	void ReleaseInBuffer();
	ULONG GetOutTokenLength();

	DWORD Connect(LPSTR lpstrDest,int iDestPort);
	void Disconnect();
	DWORD Listen(int iPort);
	DWORD SendContext(PSecBufferDesc InBuffer);
	DWORD ReceiveContext();

private:
	CredHandle hCredential;				// Credential handle
	CtxtHandle hContext;				// Context Handle
	TimeStamp tsLifeTime;

	PSecurityFunctionTable pFuncTable;	// pointer to security provider function
										// dispatch table
	DWORD dwMaxToken;

	SecBufferDesc OutBuffer;		    // Output buffer descriptor
	SecBufferDesc InBuffer;				// Input buffer descriptor

	SecBuffer OutToken[10];
	SecBuffer InToken[10];

	SOCKET s;
	SOCKET listens;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\socktest\socktest.cpp ===
// socktest.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "winsock.h"
#include "tchar.h"
#include "stdlib.h"

bool	fVerbose = TRUE;
bool	fDebug   = false;
char	*g_tszMachineName = NULL;
short	g_dwIPPort = 0 ;
SOCKET	g_sockListen;
#define SERVPORT	12396	//Default listening port
int		g_nServerPort = SERVPORT;
char	*g_pServerName = NULL;
char	*g_pServerPort = NULL;

SOCKET	g_CliSocket;
SOCKADDR_IN g_accept_sin;
int			accept_sin_length = sizeof(g_accept_sin);


HRESULT		CreateNetConnections();
HRESULT		ClientConnect(char *pszServerName, int nPort);
HRESULT		GetComputerNameInternal(char* pwcsMachineName,DWORD * pcbSize);
    



void		Usage();
void		Failed(char * Format, ...);
void		Succeeded(char * Format, ...);





int main(int argc, char* argv[])
{
WSADATA		WsaData;
char		szName[256];
DWORD		szNameLength=sizeof(szName);
HOSTENT		*pLocalInfo=NULL;
	//
    // Parse parameters
    //

	for (int i=1; i<argc; i++)
	{
		if (*argv[i] != '-' && *argv[i] != '/')
		{
			printf("Invalid parameter '%S'.\n\n", argv[i]);
            Usage();
		}

		switch (tolower(*(++argv[i])))
		{
		    case 'v':		// Verbose switch
			    fVerbose = true;

			    break;

		    

            case 'r':
				if (strlen(argv[i]) > 3)
				{
					g_pServerName = argv[i] + 2;
				}
				else if (i+1 < argc)
				{
					g_pServerName = argv[++i];
				}
				else
				{
					Usage();
					exit(0);
				}
			    break;

			case 'p':
				if (strlen(argv[i]) > 3)
				{
					g_pServerPort = argv[i] + 2;
				}
				else if (i+1 < argc)
				{
					g_pServerPort = argv[++i];
				}
				else
				{
					Succeeded("Default to use server port %d",g_nServerPort); 
				}

				if( g_pServerPort && lstrlen(g_pServerPort) )
				{
					g_nServerPort = atoi(g_pServerPort);
					if(!g_nServerPort)
					{
						Failed("invalid server port specified %s", g_pServerPort);
						Usage();
						exit(0);
					}
				}
				else
				{
					Usage();
					exit(0);
				}
				break;
			case '?':
				Usage();
				exit(0);
				break;

		    default:
			    printf("Unknown switch '%s'.\n\n", argv[i]);
                Usage();
			    exit(0);
		}
	}

	szName[0] = '\0';
	if( S_OK == GetComputerNameInternal(szName, &szNameLength) )
	{
		printf("Local Computer Info: Computer Name = %s\n", szName);
    }

	




	
	if ( SOCKET_ERROR == WSAStartup (MAKEWORD(1,1), &WsaData))
	{
		Failed("WSAStartup Failed - Error Code = %d", WSAGetLastError());
		exit(-1);
	}

	pLocalInfo = gethostbyname(szName);
		
	if(!pLocalInfo)
	{
		Failed("Failed to resolve local computer IP Address thru gethostbyname() - Error = %d", WSAGetLastError());
	}
	else
	{
	SOCKADDR_IN *pLocalAddr=NULL;
	unsigned char *pIPAddr=NULL;
	int		i = 0;
	int		nLength=0;
		pIPAddr = 	(unsigned char  *)pLocalInfo->h_addr_list[0];
		nLength = pLocalInfo->h_length;
		while(nLength >= 4)
		{
			printf("Local Computer Info: IPAddress %d = %d.%d.%d.%d\n", i+1, *pIPAddr, *(pIPAddr+1), *(pIPAddr+2), *(pIPAddr+3));
			nLength -= sizeof(IN_ADDR);
			pIPAddr += sizeof(IN_ADDR);
			i++;
		}
		
	}

	// Check for Client 
	if(g_pServerName)
	{
		// Display remote computer information
		pLocalInfo = NULL;
		pLocalInfo = gethostbyname(g_pServerName);
		
		if(!pLocalInfo)
		{
			Failed("Failed to resolve remote computer <%s> IP Address thru gethostbyname() - Error = %d", 
					g_pServerName, WSAGetLastError());
		}
		else
		{
		SOCKADDR_IN *pLocalAddr=NULL;
		unsigned char *pIPAddr=NULL;
		int		i = 0;
		int		nLength=0;
		
			pIPAddr = 	(unsigned char  *)pLocalInfo->h_addr_list[0];
			nLength = pLocalInfo->h_length;
			while(nLength >= 4)
			{
				printf("Remote computer <%s> Info: IPAddress %d = %d.%d.%d.%d\n", g_pServerName, i+1, *pIPAddr, *(pIPAddr+1), *(pIPAddr+2), *(pIPAddr+3));
				nLength -= sizeof(IN_ADDR);
				pIPAddr += sizeof(IN_ADDR);
				i++;
			}
		
		}

		ClientConnect(g_pServerName, g_nServerPort);
	}
	else
	{
		CreateNetConnections();
	}


	WSACleanup();

	return 0;
}



void Usage()
{
	printf("usage: sockapp [-p:port_number] [-r:remote_machine_name] [-v] [-?]\n\n");
	printf("The tool helps troubleshoot network conenction between 2 machines. \n");
	printf("It should be started on 2 machines, pointing one to another. \n");
	printf("The tool will report any problems it meets.\n\n");
	printf("where \n\n");
	printf("\t -v verbose mode to provide more information\n");
	printf("\t -p server: port number to use, client: port number to connect\n");
	printf("\t -r remote server name or ip address\n\n");
	printf("command examples:\n\n");
	printf("at server : sockapp -p:1234 -v\n\n");
	printf("at client : sockapp -r:test_server -p:1234 -v\n\n");
	
}


HRESULT		CreateNetConnections (void)
{
SOCKET		listener;
INT			err;
SOCKADDR_IN localAddr;

	
	//
	// Open a socket to listen for incoming connections.
	//
	listener = socket (AF_INET, SOCK_STREAM, 0);
	if (listener == INVALID_SOCKET)
	{
		Failed("Socket Create Failed:invalid socket");
        return S_FALSE;
	}

    //
    // Bind our server to the agreed upon port number.  See
    // commdef.h for the actual port number.
    //
    ZeroMemory (&localAddr, sizeof (localAddr));
    localAddr.sin_port = htons (g_nServerPort);
    localAddr.sin_family = AF_INET;

    err = bind (listener, (PSOCKADDR) & localAddr, sizeof (localAddr));
    if (err == SOCKET_ERROR)
	{
	int	nError;

		nError = WSAGetLastError();
		Failed("Socket Bind Failed, error = %d",nError);
        if (nError == WSAEADDRINUSE)
            Failed("The port number may already be in use");
        return S_FALSE;
    }

	Succeeded("Bind to socket successfully\n");
	Succeeded("Using port # %d\n", g_nServerPort);

   
   
	//
	// Prepare to accept client connections.  Allow up to 5 pending
	// connections.
	//
	err = listen (listener, 5);
	if (err == SOCKET_ERROR)
	{
		Failed("Socket Listen Failed %d",WSAGetLastError());
		return S_FALSE;
	}

	printf("Waiting for incoming client connection\n");


	while(1)
	{

		g_CliSocket = accept(listener, (struct sockaddr FAR *)&g_accept_sin,
							  (int FAR *) &accept_sin_length);

		if (g_CliSocket == INVALID_SOCKET)
		{
		
			Failed("Accept Failed - error = %d",WSAGetLastError());
			return S_FALSE;
		}

		unsigned char *lpIPAddr = (unsigned char *)&g_accept_sin.sin_addr.S_un.S_un_b;
		
		Succeeded("Client Connection Accepted - Client IP Address = %d.%d.%d.%d",
				  *lpIPAddr,*(lpIPAddr+1),*(lpIPAddr+2),*(lpIPAddr+3) );

		closesocket(g_CliSocket);
		
	}
    
	return S_OK;
}










HRESULT  GetComputerNameInternal( 
    char * pcsMachineName,
    DWORD * pcbSize
    )
{
    
    if (GetComputerName(pcsMachineName, pcbSize))
    {
        Succeeded("GetComputerName: %s", pcsMachineName);
        return S_OK;
    }
    else
    {
        Failed("Failed GetComputerName, GetLastError=0x%x", GetLastError());
    }

    return S_FALSE;

}



void Succeeded(char * Format, ...)
{
    va_list Args;
	char buf[500];
    char szBuf[500];

    va_start(Args,Format);
    _vsntprintf(buf, 500, Format, Args);

    if (fVerbose)
    {
        sprintf( szBuf, "+++ Succeeded: %s \n", buf);
        printf(szBuf);
    }
}


void Failed(char * Format, ...)
{
    va_list Args;
	char buf[500];
    char szBuf[500];

    va_start(Args,Format);
    _vsntprintf(buf, 500, Format, Args);

    sprintf( szBuf, "!!! Failed to %s\n", buf);
    printf(szBuf);

//  exit(0);
}




HRESULT	ClientConnect(char *pszServerName, int nPort)
{
SOCKET      CliSocket = INVALID_SOCKET;
unsigned long ServerIPAddress=INADDR_NONE;
HOSTENT		*pRemote=NULL;
SOCKADDR_IN RemoteAddr;
SOCKADDR_IN LocalAddr;

	if(!pszServerName && lstrlen(pszServerName))
	{
		return ERROR_INVALID_PARAMETER;
	}

	// Check to see if the host name is the IP address
	ServerIPAddress = inet_addr( pszServerName );

    if( ServerIPAddress == INADDR_NONE )
	{
		//
        //  Assume the user gave us an actual host name.
        //

        pRemote = gethostbyname(pszServerName );
		
		if(!pRemote)
		{
			Failed("Failed to resolve host address thru gethostbyname() - Error = %d", WSAGetLastError());
			return S_FALSE;
		}

		memcpy((void *)&RemoteAddr.sin_addr, (void *)pRemote->h_addr_list[0], sizeof(IN_ADDR) );
	}
	else
	{
		memcpy((void *)&RemoteAddr.sin_addr, (void *)&ServerIPAddress, sizeof(IN_ADDR) );
	}
    
	
	//
	// Open a socket to listen for incoming connections.
	//
	CliSocket = socket (AF_INET, SOCK_STREAM, 0);
	if (CliSocket == INVALID_SOCKET)
	{
		Failed("Socket Create Failed:invalid socket");
        return S_FALSE;
	}

    //
    // Bind our server to the agreed upon port number.  See
    // commdef.h for the actual port number.
    //
	LocalAddr.sin_addr.s_addr = htonl( INADDR_ANY );
    LocalAddr.sin_port = 0;
    LocalAddr.sin_family = AF_INET;

    

    RemoteAddr.sin_family = PF_INET;
    RemoteAddr.sin_port   = htons( nPort );

    if( connect( CliSocket, (SOCKADDR *)&RemoteAddr, sizeof(RemoteAddr) ) != 0 )
    {
        Failed("Connect to server %s Failed - Error Code = %d", pszServerName, WSAGetLastError());
    }
	else
	{
		Succeeded("Connect to server %s succeeded", pszServerName);
	}
    

    
    closesocket( CliSocket );
    

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\xacttest\xtest\async.h ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    Async.h

Abstract:
    This module defines COutcome object

Author:
    Alexander Dadiomov (AlexDad)

--*/

extern void SetAnticipatedOutcomes(LONG ul);
extern void WaitForAllOutcomes(void);
extern void PrintAsyncResults(void);

//---------------------------------------------------------------------
// COutcome:
//---------------------------------------------------------------------

class COutcome: public ITransactionOutcomeEvents
{
public:
	
	COutcome(void);
	~COutcome(void);

    STDMETHODIMP			QueryInterface(REFIID i_iid, LPVOID FAR* ppv);
	STDMETHODIMP_ (ULONG)	AddRef(void);
	STDMETHODIMP_ (ULONG)	Release(void);

    STDMETHODIMP Committed( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
    STDMETHODIMP Aborted( 
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
    STDMETHODIMP HeuristicDecision( 
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr);
        
    STDMETHODIMP Indoubt( void);

    STDMETHODIMP SetCookie(DWORD dwCookie);

    STDMETHODIMP SetConnectionPoint(IConnectionPoint *pCpoint);
	
private:
	ULONG	m_cRefs;
    DWORD   m_dwCookie;
    IConnectionPoint *m_pCpoint;
    
    void CheckFinish(void);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\sspi\cli.cpp ===
#include <windows.h>

#define SECURITY_WIN32
#define SECURITY_NTLM
#include <sspi.h>
#include <issperr.h>

#include <winsock.h>

#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

#define		STATUS_SEVERITY_SUCCESS  0

#include "secdef.h"
HMODULE hSecLib;

extern "C" int __cdecl main( int argc, PCHAR *argv )
{
	DWORD dwRet;
	LPSTR pszTarget = "sspicli";
	CSecObject SecObjOut;
	WSADATA  wsData = {0};
	int iDestPort = 4000;
	CHAR *lpstrDest = "127.0.0.1";

	if( argc > 1 )
	{
		while( --argc )
		{
			if(!_strnicmp(argv[argc], "/help", 5) ||
			   !_strnicmp(argv[argc], "/?", 2))
			{
				printf("usage: sspicli [/dest=<server ip address>] [/port=<server listen port>]\n");
				return(0);
			}
			else if( !_strnicmp( argv[argc], "/port=", 6 ) )
			{
				iDestPort = atoi( argv[argc] + 6 );
			}
			else if(!_strnicmp(argv[argc], "/dest=",6))
			{
				lpstrDest = argv[argc] + 6;
			}
			else if(!_strnicmp(argv[argc], "/target=",8))
			{
				pszTarget = argv[argc] + 8;
			}
		}
	}

	printf("NTLM SSPI Logon test, target: %s\n",pszTarget);

	WSAStartup(MAKEWORD(1,1), &wsData);
/*
	if(SecObjOut.Connect(lpstrDest,iDestPort) != ERROR_SUCCESS)
	{
		WSACleanup();
		return(-1);
	}
*/
    do
	{
		hSecLib = (HMODULE)LoadLibrary( "SECURITY.DLL" );
		if(hSecLib )
		{
			//
			// Get outbound credentials handle.
			//
			dwRet = SecObjOut.InitializeNtLmSecurity(SECPKG_CRED_OUTBOUND);
			if(dwRet == STATUS_SEVERITY_SUCCESS)
			{
				do
				{
					//
					// Generate new client context and release old buffer.
					//
					dwRet = SecObjOut.InitializeNtLmSecurityContext(
									pszTarget,
									SecObjOut.GetInBuffer()
									);
					SecObjOut.ReleaseInBuffer();

					//
					// Send the new token to server.
					//
					if(dwRet == SEC_I_CONTINUE_NEEDED ||
					   (dwRet == SEC_E_OK && SecObjOut.GetOutTokenLength() != 0))
					{
						dwRet = SecObjOut.SendContext(
									SecObjOut.GetOutBuffer()
									);

						//
						// Wait for server response.
						//
						if(dwRet == ERROR_SUCCESS)
						{
							dwRet = SecObjOut.ReceiveContext();
						}
					}
				} while(dwRet == SEC_I_CONTINUE_NEEDED);

				if(dwRet == SEC_E_OK)
				{
					printf("Logon OK\n");
				}

				//
				// Cleanup context and credentials handle.
				//
                SecObjOut.CleanupNtLmSecurityContext();
				SecObjOut.CleanupNtLmSecurity();
			}

			FreeLibrary( hSecLib );
			hSecLib = NULL;
		}
		else
		{
			dwRet = GetLastError();
		}

		if(_kbhit())
			break;

	} while(dwRet == STATUS_SEVERITY_SUCCESS);

	SecObjOut.Disconnect();
	WSACleanup();
	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\systools\sspi\sspi.cpp ===
#include <windows.h>

#define SECURITY_WIN32
#define SECURITY_NTLM
#include <sspi.h>
#include <issperr.h>

#include <winsock.h>

#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

#include "secdef.h"

#define		STATUS_SEVERITY_SUCCESS  0

extern HMODULE hSecLib;

CSecObject::CSecObject()
{
    hCredential.dwUpper = NULL;
    hCredential.dwLower = NULL;
	hContext.dwUpper = NULL;
	hContext.dwLower = NULL;

	OutBuffer.ulVersion = SECBUFFER_VERSION;
	OutBuffer.cBuffers = 0;
	OutBuffer.pBuffers = NULL;
	ZeroMemory(OutToken,sizeof(OutToken));

	InBuffer.ulVersion = SECBUFFER_VERSION;
	InBuffer.cBuffers = 0;
	InBuffer.pBuffers = NULL;
	ZeroMemory(InToken,sizeof(InToken));

	s = INVALID_SOCKET;
	listens = INVALID_SOCKET;
}

CSecObject::~CSecObject()
{
}


PSecBufferDesc CSecObject::GetOutBuffer()
{
	if(OutBuffer.cBuffers != 0)
	{
		return(&OutBuffer);
	}
	else
	{
		return(NULL);
	}
}

PSecBufferDesc CSecObject::GetInBuffer()
{
	if(InBuffer.cBuffers != 0)
	{
		return(&InBuffer);
	}
	else
	{
		return(NULL);
	}
}

ULONG CSecObject::GetOutTokenLength()
{
	ULONG lSize = 0;
	ULONG l;
	if(OutBuffer.cBuffers != 0)
	{
		for(l = 0; l < OutBuffer.cBuffers; l++)
		{
			lSize += OutToken[l].cbBuffer;
		}
		return(lSize);
	}
	else
	{
		return(0);
	}
}


void CSecObject::ReleaseInBuffer()
{
	//
	// Release InBuffer if we have one.
	//
	while(InBuffer.cBuffers != 0)
	{
        InBuffer.cBuffers--;
		if(InToken[InBuffer.cBuffers].pvBuffer)
		{
			HeapFree(GetProcessHeap(),0,InToken[InBuffer.cBuffers].pvBuffer);
            InToken[InBuffer.cBuffers].pvBuffer = NULL;
		}
	}
	InBuffer.cBuffers = 0;
    InBuffer.pBuffers = NULL;
}


DWORD CSecObject::InitializeNtLmSecurity(
	ULONG fCredentialUse
	)
{
	INIT_SECURITY_INTERFACE pfnInitSecurity;
	TimeStamp tsLifeTime;
	DWORD dwRet, dwPackages;
	PSecPkgInfo pspiPackageInfo = NULL;

	pfnInitSecurity = (INIT_SECURITY_INTERFACE)GetProcAddress( hSecLib,
															   "InitSecurityInterfaceA" );
	if( pfnInitSecurity != NULL )
	{
		//
		// Get the pointer to the function dispatch table
		//
		pFuncTable = (*pfnInitSecurity)();
		if( pFuncTable != NULL )
		{
			//
			// Enumerate available security packages
			//
			dwRet = (*pFuncTable->EnumerateSecurityPackages)( &dwPackages,
															  &pspiPackageInfo );
			if( dwRet == STATUS_SEVERITY_SUCCESS )
			{
				DWORD dwI=0, dwTmpI;

				//
				// Search the NTLM security provider.
				//
				for( dwTmpI = 0; dwTmpI < dwPackages; dwTmpI++ )
				{
					printf("security package %d name = %s\n", dwTmpI, pspiPackageInfo[dwTmpI].Name);
					printf("\t comment: %s\n", pspiPackageInfo[dwTmpI].Comment);
					if( !_stricmp( pspiPackageInfo[dwTmpI].Name, "NTLM" ) )
					{
						dwI = dwTmpI;
					}

				}

				//
				// If NTLM found get credentials handle
				//
				if( dwI < dwPackages )
				{
					dwMaxToken = pspiPackageInfo[dwI].cbMaxToken;
					
					dwRet = (*pFuncTable->AcquireCredentialsHandle)(NULL,
																	"NTLM",
																	fCredentialUse,
																	NULL,
																	NULL,
																	NULL,
																	NULL,
																	&hCredential,
																	&tsLifeTime);
					if( dwRet != STATUS_SEVERITY_SUCCESS )
					{
						printf("AcquireCredentialsHandle() error %Xh\n",dwRet);
					}
				}
				else
				{
					dwRet = ERROR_NOT_SUPPORTED;
					printf("NTLM security package not found.\n");
				}
				// Free Buffer in the security context
				(*pFuncTable->FreeContextBuffer)( pspiPackageInfo );
				pspiPackageInfo = NULL;
			}
		}
		else
		{
			dwRet = ERROR_PROC_NOT_FOUND;
		}
	}
	else
	{
		dwRet = GetLastError();
	}
	return( dwRet );
}

DWORD CSecObject::CleanupNtLmSecurity()
{
	DWORD dwRet = STATUS_SEVERITY_SUCCESS;

	if( pFuncTable != NULL )
	{
		if(hCredential.dwUpper != NULL ||
		   hCredential.dwLower != NULL)
		{
			dwRet = (*pFuncTable->FreeCredentialHandle)( &hCredential );
		}

        hCredential.dwUpper = NULL;
        hCredential.dwLower = NULL;
	}
		
	pFuncTable = 0;
	return(dwRet);
}

// Called by the client side

DWORD CSecObject::InitializeNtLmSecurityContext(
	LPSTR lpszTarget,
    PSecBufferDesc InBuffer
	)
{
	DWORD dwRet = STATUS_SEVERITY_SUCCESS;
	DWORD fContextReq = ISC_REQ_CONNECTION | ISC_REQ_MUTUAL_AUTH | ISC_REQ_CONFIDENTIALITY |
						ISC_REQ_INTEGRITY | ISC_REQ_REPLAY_DETECT | ISC_REQ_SEQUENCE_DETECT;
	DWORD ContextAttr = 0;
    CtxtHandle hNewContext;

	//
	// If this is the first call, allocate a buffer big enough to hold
	// the max output token.
	//
	if(OutBuffer.cBuffers == 0)
	{
		OutBuffer.cBuffers = 1;
		OutBuffer.pBuffers = (PSecBuffer)&OutToken;
		OutToken[0].BufferType = SECBUFFER_TOKEN;
		OutToken[0].pvBuffer = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,dwMaxToken+512);
		OutToken[0].cbBuffer = dwMaxToken+512;
	}
	else
	{
		OutToken[0].cbBuffer = dwMaxToken+512; // Restore initial buffer size
	}

	//
	// Call sec DLL passing it the InBuffer and the current context (if we have one).
	// The OutBuffer is sent to the server if return code is SEC_I_CONTINUE_NEEDED or
	// SEC_E_OK and the buffer length is non-zero.
	//
	dwRet = pFuncTable->InitializeSecurityContext(&hCredential,
												  (InBuffer ? &hContext : NULL),
												  lpszTarget,
												  fContextReq,
												  0,
												  SECURITY_NATIVE_DREP,
												  InBuffer,
												  0,
												  &hNewContext,
												  &OutBuffer,
												  &ContextAttr,
												  &tsLifeTime);
	if(dwRet == SEC_E_OK ||
       dwRet == SEC_I_CONTINUE_NEEDED ||
       dwRet == SEC_I_COMPLETE_NEEDED ||
       dwRet == SEC_I_COMPLETE_AND_CONTINUE)
	{
		//
		// Update context handle
		//
		hContext = hNewContext;
	}
	else
	{
		printf("InitializeSecurityContext() error %Xh\n",dwRet);
	}
   	return(dwRet);
}

// Called by the server side

DWORD CSecObject::AcceptNtLmSecurityContext(
    PSecBufferDesc InBuffer
	)
{
	DWORD dwRet = STATUS_SEVERITY_SUCCESS;
	DWORD fContextReq = ASC_REQ_CONNECTION | ASC_REQ_MUTUAL_AUTH | ASC_REQ_CONFIDENTIALITY |
						ASC_REQ_INTEGRITY | ASC_REQ_REPLAY_DETECT | ASC_REQ_SEQUENCE_DETECT;
	DWORD ContextAttr = 0;
    CtxtHandle hNewContext;

	//
	// If this is the first call allocate a buffer big enough to hold
	// the max token.
	//
	if(OutBuffer.cBuffers == 0)
	{
		OutBuffer.cBuffers = 1;
		OutBuffer.pBuffers = (PSecBuffer)OutToken;
		OutToken[0].BufferType = SECBUFFER_TOKEN;
		OutToken[0].pvBuffer = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,dwMaxToken+512);
		OutToken[0].cbBuffer = dwMaxToken+512;
	}
	else
	{
		OutToken[0].cbBuffer = dwMaxToken+512; // Restore initial buffer size
	}

	//
	// Call sec DLL passing it the InBuffer and the current context (if we have one).
	// The OutBuffer is sent back to client if return code is SEC_I_CONTINUE_NEEDED.
	//
	dwRet = pFuncTable->AcceptSecurityContext(&hCredential,
												  (InBuffer ? &hContext : NULL),
												  InBuffer,
												  fContextReq,
												  SECURITY_NATIVE_DREP,
												  &hNewContext,
												  &OutBuffer,
												  &ContextAttr,
												  &tsLifeTime);
	if(dwRet == SEC_E_OK ||
       dwRet == SEC_I_CONTINUE_NEEDED ||
       dwRet == SEC_I_COMPLETE_NEEDED ||
       dwRet == SEC_I_COMPLETE_AND_CONTINUE)
	{
		//
		// Update context handle
		//
		hContext = hNewContext;
	}
	else
	{
		printf("AcceptSecurityContext() error %Xh\n",dwRet);
	}
   	return(dwRet);
}

DWORD CSecObject::CleanupNtLmSecurityContext()
{
	DWORD dwRet = STATUS_SEVERITY_SUCCESS;

	// Close security context
	if(hContext.dwUpper != NULL ||
       hContext.dwLower != NULL)
	{
		dwRet = pFuncTable->DeleteSecurityContext(&hContext);
		hContext.dwUpper = NULL;
		hContext.dwLower = NULL;
	}

	// Release out buffer
	while(OutBuffer.cBuffers != 0)
	{
        OutBuffer.cBuffers--;
		if(OutToken[OutBuffer.cBuffers].pvBuffer)
		{
			HeapFree(GetProcessHeap(),0,OutToken[OutBuffer.cBuffers].pvBuffer);
            OutToken[OutBuffer.cBuffers].pvBuffer = NULL;
		}
	}
	OutBuffer.cBuffers = 0;
    OutBuffer.pBuffers = NULL;
	return(dwRet);
}



DWORD CSecObject::SendContext(
    PSecBufferDesc InBuffer
	)
{
	LPBYTE TrxBuffer = NULL;
	LPBYTE Dest;
	ULONG lSize, dwRet, l;
//	PSecBuffer SecData;

	//
	// Send the InBuffer contents to server/client in the following packet:
	//
	//   ULONG packet_length;
	//   SecBufferDesc buffer_desc;
	//	 SecBuffer buffer_hdr1;
	//   BYTE data1[];
	//	 SecBuffer buffer_hdr2;
	//   BYTE data2[];
	//	 ....

	// A message with packet_length == 0 indicates logon complete.
	//
	if(GetOutTokenLength() == 0)
	{
		lSize = 0;
        send(s,(const char *)&lSize,sizeof(lSize),0);
		return(SEC_E_OK);
	}

	dwRet = ERROR_SUCCESS;
	lSize = sizeof(SecBufferDesc) + sizeof(ULONG);
	for( l = 0; l < InBuffer->cBuffers; l++)
	{
		lSize += InBuffer->pBuffers[l].cbBuffer + sizeof(SecBuffer);
	}

	TrxBuffer = (LPBYTE)HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,lSize);
	Dest = TrxBuffer;

	CopyMemory(Dest,&lSize,sizeof(ULONG));
	Dest += sizeof(ULONG);

	CopyMemory(Dest,InBuffer,sizeof(SecBufferDesc));
	Dest += sizeof(SecBufferDesc);

	for( l = 0; l < InBuffer->cBuffers; l++)
	{
		CopyMemory(Dest,&InBuffer->pBuffers[l],sizeof(SecBuffer));
		Dest += sizeof(SecBuffer);
		CopyMemory(Dest,InBuffer->pBuffers[l].pvBuffer,InBuffer->pBuffers[l].cbBuffer);
		Dest += InBuffer->pBuffers[l].cbBuffer;
	}

	if(!send(s,(const char *)TrxBuffer,lSize,0))
	{
		dwRet = WSAGetLastError();
	}
	HeapFree(GetProcessHeap(),0,TrxBuffer);
	return(dwRet);
}

DWORD CSecObject::ReceiveContext(
	)
{
	LPBYTE RxBuffer = NULL;
	LPBYTE Dest;
	ULONG lSize, dwRet, l;
	int iLen;
	PSecBufferDesc SecDesc;
	PSecBuffer SecData;

	dwRet = ERROR_SUCCESS;
	lSize = 0;

	//
	// Read the packet_length.
	// A message with packet_length == 0 indicates logon complete.
	//
	iLen = recv(s,(char *)&lSize,sizeof(lSize),0);
	if(iLen > 0 && lSize > 0)
	{
		lSize -= sizeof(lSize);
		RxBuffer = (LPBYTE)HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,lSize);

		//
		// Read the actual security packet.
		//
		Dest = RxBuffer;
		while(lSize && iLen > 0)
		{
			iLen = recv(s,(char *)Dest,lSize,0);
			if(iLen > 0)
			{
				lSize -= iLen;
				Dest += iLen;
			}
		}

		SecDesc = (PSecBufferDesc)RxBuffer;
		SecData = (PSecBuffer)(SecDesc+1);

		//
		// Copy the data from the receive buffer to Security strucs (InBuffer and InToken).
		//
		CopyMemory(&InBuffer,SecDesc,sizeof(SecBufferDesc));
		InBuffer.pBuffers = (PSecBuffer)&InToken;

		for(l = 0; l < InBuffer.cBuffers && l < sizeof(InToken)/sizeof(InToken[0]); l++)
		{
			InToken[l].pvBuffer = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,SecData->cbBuffer);
			InToken[l].cbBuffer = SecData->cbBuffer;
			InToken[l].BufferType = SecData->BufferType;
			CopyMemory(InToken[l].pvBuffer,(PBYTE)(SecData+1),SecData->cbBuffer);
			SecData = (PSecBuffer)((PBYTE)(SecData+1)+SecData->cbBuffer);
		}
		HeapFree(GetProcessHeap(),0,RxBuffer);
		dwRet = SEC_I_CONTINUE_NEEDED;
	}
	else if(iLen < 0)
	{
		dwRet = WSAGetLastError();
	}
	else if(iLen == 0)
	{
		dwRet = ERROR_HANDLE_EOF; // Done
	}
	return(dwRet);
}


DWORD CSecObject::Connect(
	LPSTR lpstrDest,
	int iDestPort
	)
{
	SOCKADDR_IP raddr;
	DWORD dwRet = ERROR_SUCCESS;

	s = socket( PF_INET, SOCK_STREAM, 0 );
	if(s != INVALID_SOCKET)
	{
		ZeroMemory(&raddr, sizeof(SOCKADDR_IP));
		raddr.sin_family = PF_INET;
		raddr.sin_port = htons((USHORT)iDestPort);
		raddr.sin_addr.S_un.S_addr = inet_addr(lpstrDest);

		if(connect(s, (SOCKADDR *)&raddr, sizeof(SOCKADDR_IP)))
		{
			dwRet = WSAGetLastError();
			closesocket(s);
			s = INVALID_SOCKET;
		}
	}
	else
	{
		dwRet = WSAGetLastError();
	}
	return(dwRet);
}

void CSecObject::Disconnect()
{
	if(s != INVALID_SOCKET)
	{
		shutdown(s,2);
		closesocket( s );
		s = INVALID_SOCKET;
	}

	if(listens != INVALID_SOCKET)
	{
		closesocket( listens );
		listens = INVALID_SOCKET;
	}
}

DWORD CSecObject::Listen(
	int iPort
	)
{
	SOCKADDR_IP MyAddress, RemoteAddress;
	DWORD dwRet = ERROR_SUCCESS;
	int iAddrLen;

	listens = socket( PF_INET, SOCK_STREAM, 0 );
	if(listens != INVALID_SOCKET)
	{
		ZeroMemory( &MyAddress, sizeof(SOCKADDR_IP) );
		MyAddress.sin_family = PF_INET;
		MyAddress.sin_port = htons((USHORT)iPort);

		if(!bind(listens, (SOCKADDR *)&MyAddress, sizeof(SOCKADDR_IP)))
		{
			if( !listen(listens, 5) )
			{
				s = accept(listens, (SOCKADDR *)&RemoteAddress, &iAddrLen);
			}
			else
			{
				dwRet = WSAGetLastError();
				closesocket(listens);
				listens = INVALID_SOCKET;
			}
		}
		else
		{
			dwRet = WSAGetLastError();
			closesocket(listens);
			listens = INVALID_SOCKET;
		}
	}
	else
	{
		dwRet = WSAGetLastError();
	}
	return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\xacttest\xtest\async.cpp ===
// Asynchronous event sync implementation
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <transact.h>
#include <olectl.h>
#include "async.h"

static LONG g_lCommited    = 0;
static LONG g_lAborted     = 0;
static LONG g_lHeuristic   = 0;
static LONG g_lInDoubt     = 0;

static LONG   g_lTotal       = 0;
static HANDLE g_hFinishEvent = NULL;

void SetAnticipatedOutcomes(LONG ul)
{
    g_lTotal = ul;
    g_hFinishEvent =  CreateEvent(NULL, TRUE, FALSE, NULL);
}

void WaitForAllOutcomes(void)
{
    if (g_lTotal && g_hFinishEvent)
    {
        WaitForSingleObject(g_hFinishEvent, INFINITE);
    }
}

void PrintAsyncResults(void)
{
    printf("\nAsync results: %d committed, %d aborted, %d heuristic, %d indoubt\n",
            g_lCommited, g_lAborted, g_lHeuristic, g_lInDoubt );
}

//---------------------------------------------------------------------
// COutcome::COutcome
//---------------------------------------------------------------------

COutcome::COutcome(void)
{
	m_cRefs = 0;
    m_pCpoint = NULL;
}


//---------------------------------------------------------------------
// COutcome::~COutcome
//---------------------------------------------------------------------
COutcome::~COutcome(void)
{
}



//---------------------------------------------------------------------
// COutcome::QueryInterface
//---------------------------------------------------------------------
STDMETHODIMP COutcome::QueryInterface(REFIID i_iid, LPVOID *ppv)
{
	*ppv = 0;						// Initialize interface pointer.

    if (IID_IUnknown == i_iid || IID_ITransactionOutcomeEvents == i_iid)
	{								// IID supported return interface.
		*ppv = this;
	}

	
	if (0 == *ppv)					// Check for null interface pointer.
	{										
		return ResultFromScode (E_NOINTERFACE);
									// Neither IUnknown nor IResourceManagerSink supported--
									// so return no interface.
	}

	((LPUNKNOWN) *ppv)->AddRef();	// Interface is supported. Increment its usage count.
	
	return S_OK;
}


//---------------------------------------------------------------------
// COutcome::AddRef
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) COutcome::AddRef(void)
{
    return ++m_cRefs;				// Increment interface usage count.
}


//---------------------------------------------------------------------
// COutcome::Release
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) COutcome::Release(void)
{

	--m_cRefs;						// Decrement usage reference count.

	if (0 != m_cRefs)				// Is anyone using the interface?
	{								// The interface is in use.
		return m_cRefs;				// Return the number of references.
	}

	delete this;					// Interface not in use -- delete!

	return 0;						// Zero references returned.
}


//---------------------------------------------------------------------
// COutcome::Committed
//---------------------------------------------------------------------
STDMETHODIMP COutcome::Committed( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr)
{
    InterlockedIncrement(&g_lCommited);
    CheckFinish();
    Release();
    return S_OK;
}
        
//---------------------------------------------------------------------
// COutcome::Aborted
//---------------------------------------------------------------------
STDMETHODIMP COutcome::Aborted( 
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr)
{
    InterlockedIncrement(&g_lAborted);
    CheckFinish();
    Release();
    return S_OK;
}
        
//---------------------------------------------------------------------
// COutcome::HeuristicDecision
//---------------------------------------------------------------------
STDMETHODIMP COutcome::HeuristicDecision( 
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr)
{
    InterlockedIncrement(&g_lHeuristic);
    CheckFinish();
    Release();
    return S_OK;
}

//---------------------------------------------------------------------
// COutcome::Indoubt
//---------------------------------------------------------------------
STDMETHODIMP COutcome::Indoubt( void)
{
    InterlockedIncrement(&g_lInDoubt);
    CheckFinish();
    Release();
    return S_OK;
}

//---------------------------------------------------------------------
// COutcome::SetCookie
//---------------------------------------------------------------------
STDMETHODIMP COutcome::SetCookie(DWORD dwCookie)
{
    m_dwCookie = dwCookie;
    return S_OK;
}


//---------------------------------------------------------------------
// COutcome::SetConnectionPoint
//---------------------------------------------------------------------
STDMETHODIMP COutcome::SetConnectionPoint(IConnectionPoint *pCpoint)
{
    m_pCpoint = pCpoint;
    return S_OK;
}

//---------------------------------------------------------------------
// COutcome::CheckFinish
//---------------------------------------------------------------------
void COutcome::CheckFinish(void)
{
    if (m_pCpoint)
    {
        m_pCpoint->Unadvise(m_dwCookie);
        m_pCpoint->Release();
    }
    if (g_lTotal <= g_lCommited + g_lAborted + g_lHeuristic + g_lInDoubt)
    {
         SetEvent(g_hFinishEvent);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\xacttest\common.cpp ===
// Because we are compiling in UNICODE, here is a problem with DTC...
//#include	<xolehlp.h>
extern HRESULT DtcGetTransactionManager(
									LPSTR  pszHost,
									LPSTR	pszTmName,
									REFIID rid,
								    DWORD	dwReserved1,
								    WORD	wcbReserved2,
								    void FAR * pvReserved2,
									void** ppvObject )	;


// Transaction Dispenser DTC's interface
ITransactionDispenser	*g_pITxDispenser;

// Database connection entities
DBPROCESS	    *g_dbproc[]   = {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
LOGINREC		*g_login[]   = {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
LPCSTR	        g_pszDbLibVer;
RETCODE	        g_rc;
DBINT           g_counter;

ULONG           g_cEnlistFailures = 0;
ULONG           g_cBeginFailures = 0;
ULONG           g_cDbEnlistFailures = 0;

/* Message and error handling functions. */
int msg_handler(DBPROCESS *dbproc, DBINT msgno, int msgstate, int severity, char *msgtext)
{
	/*	Msg 5701 is just a USE DATABASE message, so skip it.	*/
	if (msgno == 5701)
		return (0);

	/*	Print any severity 0 message as is, without extra stuff.	*/
	if (severity == 0)
	{
		printf ("%s\n",msgtext);
		return (0);
	}

	printf("SQL Server message %ld, severity %d:\n\t%s\n",
		msgno, severity, msgtext);

	if (severity >>= 16)
	{
		printf("Program Terminated! Fatal SQL Server error.\n");
		exit(ERREXIT);
	}
	return (0);
}


int err_handler(DBPROCESS *dbproc, int severity, int dberr, int oserr, char *dberrstr, char *oserrstr)
{
	if ((dbproc == NULL) || (DBDEAD(dbproc)))
		return (INT_EXIT);
	else
	{
		printf ("DB-LIBRARY error: \n\t%s\n", dberrstr);

		if (oserr != DBNOERR)
			printf ("Operating system error:\n\t%s\n", oserrstr);
	}
	return (INT_CANCEL);
}

HRESULT BeginTransaction(ITransaction **ppTrans, ULONG nSync)
{
	HRESULT hr = XACT_E_CONNECTION_DOWN;

    while (1)
    {
        hr = g_pITxDispenser->BeginTransaction (
			NULL,						// IUnknown __RPC_FAR *punkOuter,
			ISOLATIONLEVEL_ISOLATED,	// ISOLEVEL isoLevel,
			ISOFLAG_RETAIN_DONTCARE,	// ULONG isoFlags,
			NULL,						// ITransactionOptions *pOptions
			// 0, ISOLATIONLEVEL_UNSPECIFIED, 0,0,
			ppTrans);
        
        if (hr != XACT_E_CONNECTION_DOWN)
            break;

        g_cBeginFailures++;
        printf("BeginTrans failed: Sleeping\n");
		Sleep(RECOVERY_TIME);
    }

    if (nSync==0)
    {
        COutcome *pOutcome = new COutcome();

        ITransaction *pTrans = *ppTrans;
        IConnectionPointContainer *pCont;

        HRESULT hr = pTrans->QueryInterface (IID_IConnectionPointContainer,(void **)(&pCont));
        if (SUCCEEDED(hr) && pCont)
        {
            IConnectionPoint *pCpoint;

            hr = pCont->FindConnectionPoint(IID_ITransactionOutcomeEvents, &pCpoint);
            if (SUCCEEDED(hr) && pCpoint)
            {
                pOutcome->SetConnectionPoint(pCpoint);

                DWORD dwCookie;
                hr = pCpoint->Advise(pOutcome, &dwCookie);
                if (SUCCEEDED(hr))
                {
                    pOutcome->SetCookie(dwCookie);
                }
                else
                {
                    printf("Advise : hr=%x\n", hr);
                }
            }
            else
            {
                printf("QueryInterface ICon.P.Cnt.: hr=%x\n", hr);
            }
            pCont->Release();
        }
    }

    return hr;
}

HRESULT Send(HANDLE hQueue, ITransaction *pTrans, MQMSGPROPS *pMsgProps)
{
    HRESULT hr = MQ_ERROR_TRANSACTION_ENLIST;

    while (1)
    {
        hr = MQSendMessage(
                hQueue,
                pMsgProps,
                pTrans);
        if (hr != MQ_ERROR_TRANSACTION_ENLIST)
        {
            break;
        }
   		printf("Enlist Failed, Sleeping\n");
        g_cEnlistFailures++;
        Sleep(RECOVERY_TIME);
    }

    return hr;
}

HRESULT Receive(HANDLE hQueue, ITransaction *pTrans, MQMSGPROPS *pMsgProps, BOOL fImmediate)
{
    HRESULT hr = MQ_ERROR_TRANSACTION_ENLIST;

    while (1)
    {
		hr = MQReceiveMessage(
			hQueue, 
            (fImmediate ? 0 : INFINITE),
			MQ_ACTION_RECEIVE,
			pMsgProps,
			NULL,
			NULL,
			NULL,
			pTrans);
        if (hr != MQ_ERROR_TRANSACTION_ENLIST)
        {
            break;
        }
   		printf("Enlist Failed, Sleeping\n");
        g_cEnlistFailures++;
        Sleep(RECOVERY_TIME);
    }

    return hr;
}

HRESULT Commit(ITransaction *pTrans, BOOL fAsync)
{
    HRESULT hr = pTrans->Commit(FALSE, 
                                (fAsync ? XACTTC_ASYNC : 0), 
                                0);
    return (hr == XACT_S_ASYNC ? S_OK : hr);
}

HRESULT Abort(ITransaction *pTrans, BOOL fAsync)
{
	HRESULT hr = pTrans->Abort(NULL, FALSE, fAsync);
    return (hr == XACT_S_ASYNC ? S_OK : hr);
}

ULONG Release(ITransaction *pTrans)
{
	return pTrans->Release();
}

void DbLogin(ULONG ulLogin, LPSTR pszUser, LPSTR pszPassword)
{
    // set error/msg handlers for this program
	dbmsghandle((DBMSGHANDLE_PROC)msg_handler);
	dberrhandle((DBERRHANDLE_PROC)err_handler);

    // Initialize DB-Library.
	g_pszDbLibVer = dbinit();
    if (!g_pszDbLibVer)
    {
        printf("dbinit failed: %x\n", g_pszDbLibVer);
        exit(1);
    }

    // Get a LOGINREC.
    g_login[ulLogin] = dblogin ();
    if (!g_login[ulLogin])
    {
        printf("dblogin fauled: %x\n", g_login[ulLogin]);
        exit(1);
    }

    DBSETLUSER (g_login[ulLogin], pszUser);   // username, "user1"
    DBSETLPWD  (g_login[ulLogin], pszPassword);   // password, "user1"
    DBSETLAPP  (g_login[ulLogin], "SeqTest");    // application

    printf("Login OK, version=%s\n",  g_pszDbLibVer);
}

void DbUse(ULONG ulDbproc, ULONG ulLogin, LPSTR pszDatabase, LPSTR pszServer)
{
    // Get a DBPROCESS structure for communication with SQL Server.
    g_dbproc[ulDbproc] = dbopen (g_login[ulLogin], pszServer);
    if (!g_dbproc[ulDbproc])
    {
        printf("dbopen failed: %x\n", g_dbproc[ulDbproc]);
        exit(1);
    }

    // Set current database
	RETCODE	 rc = dbuse(g_dbproc[ulDbproc], pszDatabase);   // database, "test"
    if (rc != SUCCEED)
    {
        printf("dbuse failed: %x\n", rc); 
        exit(1);
    }
	
	printf("DbUse OK\n");
}

BOOL DbEnlist(ULONG ulDbproc, ITransaction *pTrans)
{
    while (1)
    {
        RETCODE rc = dbenlisttrans (g_dbproc[ulDbproc], pTrans);
        if (rc == SUCCEED)
        {
            return TRUE;
        }
   		printf("DbEnlist Failed, Sleeping\n");
        g_cDbEnlistFailures++;
        Sleep(RECOVERY_TIME);
    }

    return TRUE;
}

BOOL DbSql(ULONG ulDbproc, LPSTR pszCommand)
{
    // Put the command into the command buffer.
    dbcmd (g_dbproc[ulDbproc], pszCommand);

    // Send the command to SQL Server and start execution.
    RETCODE rc = dbsqlexec (g_dbproc[ulDbproc]);
    if (rc != SUCCEED)
    {
	    printf("dbsqlexec failed: rc=%x\n", rc);
    }
    else
    {
        rc = dbresults(g_dbproc[ulDbproc]);
        if (rc != SUCCEED)
        {
	        printf("Dbresults: rc=%x\n", rc);
        }
    }
    return TRUE;
}

void DbClose()
{
    dbexit();
}

#ifdef RT_XACT_STUB
extern HRESULT MQStubRM(ITransaction *pTrans);
#endif

BOOL StubEnlist(ITransaction *pTrans)
{
    HRESULT hr = MQ_OK;
    #ifdef RT_XACT_STUB
    hr = MQStubRM(pTrans);  // to uncomment for stub checks
    #endif
    return (SUCCEEDED(hr));
}

void Sleeping(ULONG nSilent, ULONG nMaxSleep)
{
    int is = rand() * nMaxSleep / RAND_MAX;
	if (nSilent)
		printf("Sleep %d\n", is);
	Sleep(is);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\cluster\apps\start\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by start.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\cluster\mqclus\mqclusp.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    mqclusp.cpp

Abstract:

    Implementation for my internal routines

Author:

    Shai Kariv (shaik) Jan 12, 1999

Revision History:

--*/

#include "stdh.h"
#include "clusres.h"
#include <_mqini.h>
#include <autorel.h>
#include <autorel2.h>
#include <autorel3.h>
#include <uniansi.h>
#include "mqclusp.h"
#include <mqtypes.h>
#include <_mqdef.h>
#include <mqprops.h>
#include <mqsymbls.h>
#include <xolehlp.h>
#include <ad.h>
#include <mqsec.h>
#include <mqutil.h>
#include <mqupgrd.h>
#include <mqnames.h>

//
// Synchronize processwide changes to Falcon registry section
// pointed by mqutil.dll (calls to SetFalconServiceName).
//
CCriticalSection s_csReg;


//
// Handle to Win32 event logging source
//
CEventSource     s_hEventSource;


//
// Handles to MSMQ common DLLs
//
CAutoFreeLibrary s_hMqsec;
CAutoFreeLibrary s_hMqutil;


//
// Pointers to MSMQ DLLs common routines
//
MQSec_GetDefaultSecDescriptor_ROUTINE pfMQSec_GetDefaultSecDescriptor = NULL;
MQSec_StorePubKeysInDS_ROUTINE        pfMQSec_StorePubKeysInDS        = NULL;
MQsspi_UPDATECACONFIG_FN              pfMQsspi_UpdateCaConfig         = NULL;
MSMQGetQMTypeString_ROUTINE           pfMSMQGetQMTypeString           = NULL;
MSMQGetOperatingSystem_ROUTINE        pfMSMQGetOperatingSystem        = NULL;
SetFalconServiceName_ROUTINE          pfSetFalconServiceName          = NULL;
SetFalconKeyValue_ROUTINE             pfSetFalconKeyValue             = NULL;
GetFalconKeyValue_ROUTINE             pfGetFalconKeyValue             = NULL;


bool
MqcluspLoadMsmqDlls(
    VOID
    )

/*++

Routine Description:

    Load msmq DLLs that are needed by this DLL, and initialize
    pointers to their exported routines.

    This DLL is installed as part of the cluster product and
    should load w/o depending on msmq DLLs. Load of msmq DLLs
    is done on request to open a resource.

Arguments:

    None.

Return Value:

    true - Operation was successfull.

    false - Operation failed.

--*/

{
    {
        CAutoFreeLibrary hMqrt = LoadLibrary(MQRT_DLL_NAME);
        if (hMqrt == NULL)
        {
            return false;
        }
    }

    s_hMqsec = LoadLibrary(MQSEC_DLL_NAME);
    if (s_hMqsec == NULL)
    {
        return false;
    }

    s_hMqutil = LoadLibrary(MQUTIL_DLL_NAME);
    if (s_hMqutil == NULL)
    {
        return false;
    }

    pfMQSec_GetDefaultSecDescriptor = (MQSec_GetDefaultSecDescriptor_ROUTINE)GetProcAddress(s_hMqsec, "MQSec_GetDefaultSecDescriptor");
    ASSERT(pfMQSec_GetDefaultSecDescriptor != NULL);

    pfMQSec_StorePubKeysInDS = (MQSec_StorePubKeysInDS_ROUTINE)GetProcAddress(s_hMqsec, "MQSec_StorePubKeysInDS");
    ASSERT(pfMQSec_StorePubKeysInDS != NULL);

    pfMQsspi_UpdateCaConfig = (MQsspi_UPDATECACONFIG_FN)GetProcAddress(s_hMqsec, "MQsspi_UpdateCaConfig");
    ASSERT(pfMQsspi_UpdateCaConfig != NULL);

    pfMSMQGetQMTypeString = (MSMQGetQMTypeString_ROUTINE)GetProcAddress(s_hMqutil, "MSMQGetQMTypeString");
    ASSERT(pfMSMQGetQMTypeString != NULL);

    pfMSMQGetOperatingSystem = (MSMQGetOperatingSystem_ROUTINE)GetProcAddress(s_hMqutil, "MSMQGetOperatingSystem");
    ASSERT(pfMSMQGetOperatingSystem != NULL);

    pfSetFalconServiceName = (SetFalconServiceName_ROUTINE)GetProcAddress(s_hMqutil, "SetFalconServiceName");
    ASSERT(pfSetFalconServiceName != NULL);

    pfSetFalconKeyValue = (SetFalconKeyValue_ROUTINE)GetProcAddress(s_hMqutil, "SetFalconKeyValue");
    ASSERT(pfSetFalconKeyValue != NULL);

    pfGetFalconKeyValue = (GetFalconKeyValue_ROUTINE)GetProcAddress(s_hMqutil, "GetFalconKeyValue");
    ASSERT(pfGetFalconKeyValue != NULL);

    return true;

} //MqcluspLoadMsmqDlls


static
bool
MqcluspCreateEventSourceRegistry(
    LPCWSTR pFileName,
    LPCWSTR pSourceName
    )

/*++

Routine Description:

    Create the registry values to support event source registration.

Arguments:

    pFileName   - Name of event source module.

    pSourceName - Descriptive name of the event source.

Return Value:

    true - The operation was successful.
    false - The operation failed.

--*/

{
    WCHAR buffer[255] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\";
    wcscat(buffer, pSourceName);

    CAutoCloseRegHandle hKey;
    if (ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, buffer, &hKey))
    {
        return false;
    }

    if (ERROR_SUCCESS != RegSetValueEx(
                             hKey,
                             L"EventMessageFile",
                             0,
                             REG_EXPAND_SZ,
                             reinterpret_cast<const BYTE*>(pFileName),
                             (wcslen(pFileName) + 1) * sizeof(WCHAR)
                             ))
    {
        return false;
    }

    DWORD dwTypes = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
    if (RegSetValueEx(hKey, L"TypesSupported", 0, REG_DWORD, reinterpret_cast<BYTE*>(&dwTypes), sizeof(DWORD)))
    {
        return false;
    }

    return true;

} //MqcluspCreateEventSourceRegistry

 
VOID
MqcluspRegisterEventSource(
    VOID
    )

/*++

Routine Description:

    Register event source so that this DLL can log events
    in the Windows Event Log.

    We do not use the routines in mqutil.dll to do that,
    since this DLL is installed as part of the cluster
    product and should not assume that MSMQ is installed.

Arguments:

    None

Return Value:

    None.

--*/

{
    if (s_hEventSource != NULL)
    {
        //
        // Already registered
        //
        return;
    }

    WCHAR wzFilename[MAX_PATH] = L"";
    if (0 == GetModuleFileName(g_hResourceMod, wzFilename, TABLE_SIZE(wzFilename)))
    {
        return;
    }

    LPCWSTR x_EVENT_SOURCE = L"MSMQ Cluster Resource DLL";
    if (!MqcluspCreateEventSourceRegistry(wzFilename, x_EVENT_SOURCE))
    {
        return;
    }

    s_hEventSource = RegisterEventSource(NULL, x_EVENT_SOURCE);

} //MqcluspRegisterEventSource


VOID
MqcluspReportEvent(
    WORD      wType,
    DWORD     dwEventId,
    WORD      wNumStrings,
    ...
    )

/*++

Routine Description:

    Wrapper for ReportEvent Win32 API.

Arguments:

    wType - Event type to log.

    dwEventId - Event identifier.

    wNumStrings - Number of strings to merge with message.

    ... - Array of strings to merge with message.

Return Value:

    None.

--*/

{
    if (s_hEventSource == NULL)
    {
        return;
    }

    const DWORD x_MAX_STRINGS = 20;
    ASSERT(wNumStrings < x_MAX_STRINGS);
    va_list Args;
    LPWSTR ppStrings[x_MAX_STRINGS] = {NULL};
    LPWSTR pStrVal = NULL;

    va_start(Args, wNumStrings);
    pStrVal = va_arg(Args, LPWSTR);

    for (UINT i=0; i < wNumStrings; ++i)
    {
        ppStrings[i]=pStrVal;
        pStrVal = va_arg(Args, LPWSTR);
    }

    ::ReportEvent(s_hEventSource, wType, 0, dwEventId, NULL, wNumStrings, 0, (LPCWSTR*)&ppStrings[0], NULL);

} //MqcluspReportEvent


static
bool
MqcluspFirstTimeCreation(
    HKEY hResourceKey
    )

/*++

Routine Description:

    Check if the resource is being created or opened.
    On create, a flag is written to the cluster database key of the resource.
    On open, the flag is already in the cluster database key of the resource.
    On delete, cluster removes the database key of the resource.

    This routine solves the "registry leftovers" scenario where resource deletion
    on node 1 does not remove the msmq registry from node 2. The cluster database
    is managed by the cluster service and its view is coherent amongst all nodes.

Arguments:

    hResourceKey - Supplies handle to the resource's cluster configuration 
        database key.

Return Value:

    true - The resource is opened first time, i.e. this is actually Create.
    false - The resource was already created, i.e. this is actually Open.

--*/

{
    HKEY hParametersKey;
    DWORD disposition;
    LONG rc;
    rc = ClusterRegCreateKey(
             hResourceKey,
             L"Parameters",
             0,
             KEY_ALL_ACCESS,
             NULL,
             &hParametersKey,
             &disposition 
             );
    ASSERT(rc == ERROR_SUCCESS);

    LPCWSTR xValueName = L"Created";

    DWORD Type = REG_DWORD;
    DWORD Value = 0;
    DWORD Size = sizeof(Value);
    rc = ClusterRegQueryValue(
             hParametersKey,
             xValueName,
             &Type,
             reinterpret_cast<BYTE*>(&Value),
             &Size
             );
    if (rc == ERROR_SUCCESS)
    {
        ClusterRegCloseKey(hParametersKey);
        return false;
    }

    Value = 1;
    rc = ClusterRegSetValue(hParametersKey, xValueName, REG_DWORD, reinterpret_cast<BYTE*>(&Value), sizeof(Value));
    ASSERT(rc == ERROR_SUCCESS);

    ClusterRegCloseKey(hParametersKey);

    return true;

} //MqcluspFirstTimeCreation


CQmResource::CQmResourceRegistry::CQmResourceRegistry(LPCWSTR pwzService):m_lock(s_csReg)
{
    pfSetFalconServiceName(pwzService);

} //CQmResource::CQmResourceRegistry::CQmResourceRegistry


CQmResource::CQmResourceRegistry::~CQmResourceRegistry()
{
    pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

} //CQmResource::CQmResourceRegistry::CQmResourceRegistry


CQmResource::CQmResource(
    LPCWSTR pwzResourceName,
    HKEY hResourceKey,
    RESOURCE_HANDLE hReportHandle
    ):
#pragma warning(disable: 4355) // 'this' : used in base member initializer list
    m_ResId(this),
#pragma warning(default: 4355) // 'this' : used in base member initializer list
    m_hReport(hReportHandle),
    m_guidQm(GUID_NULL),
    m_pSd(NULL),
    m_cbSdSize(0),
    m_wDiskDrive(0),
    m_pwzResourceName(NULL),
    m_pwzNetworkName(NULL),
    m_fServerIsMsmq1(false),
    m_dwWorkgroup(0),
    m_nSites(0),
    m_dwMqsRouting(0),
    m_dwMqsDepClients(1),
    m_hScm(OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS)),
    m_hCluster(OpenCluster(NULL)),
    m_hResource(OpenClusterResource(m_hCluster, pwzResourceName))

/*++

Routine Description:

    Constructor.
    Called by Open entry point function.

    All operations must be idempotent !!

Arguments:

    pwzResourceName - Supplies the name of the resource to open.

    hResourceKey - Supplies handle to the resource's cluster configuration 
        database key.

    hReportHandle - A handle that is passed back to the resource monitor
        when the SetResourceStatus or LogClusterEvent method is called. See the
        description of the SetResourceStatus and LogClusterEvent methods on the
        MqclusStatup routine. This handle should never be closed or used
        for any purpose other than passing it as an argument back to the
        Resource Monitor in the SetResourceStatus or LogClusterEvent callback.

Return Value:

    None.
    Throws CMqclusException, bad_alloc.

--*/

{
    DWORD error = GetLastError();

    if (!MqcluspLoadMsmqDlls())
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, MSMQ_NOT_INSTALLED_ERR, 0);
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"MSMQ is not installed on this node.\n");
        throw CMqclusException();
    }

    SetLastError(error);

    if (m_hScm == NULL)
    {
        ReportLastError(OPEN_SCM_ERR, L"Failed to OpenSCManager.", NULL);
        throw CMqclusException();
    }
    if (m_hCluster == NULL)
    {
        ReportLastError(OPEN_CLUSTER_ERR, L"Failed to OpenCluster.", NULL);
        throw CMqclusException();
    }
    if (m_hResource == NULL)
    {
        ReportLastError(OPEN_RESOURCE_ERR, L"Failed to OpenClusterResource to '%1'.", m_pwzResourceName);
        throw CMqclusException();
    }


    ResUtilInitializeResourceStatus(&m_ResourceStatus);
    SetState(ClusterResourceOffline);

    WCHAR wzRemoteQm[MAX_PATH] = L"";
    DWORD dwType = REG_SZ;
    DWORD dwSize = sizeof(wzRemoteQm);
    {
        CS lock(s_csReg);
        pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

        if (ERROR_SUCCESS == pfGetFalconKeyValue(RPC_REMOTE_QM_REGNAME, &dwType, wzRemoteQm, &dwSize))
        {
            MqcluspReportEvent(EVENTLOG_ERROR_TYPE, DEP_CLIENT_INSTALLED_ERR, 0);
            (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"No MSMQ cluster resources for Dependent Client.\n");
            throw CMqclusException();
        }
    }


    //
    // Dont assume any limit to the resource name.
    // It is defined by client and could be very long.
    // The good thing with resource names is that Cluster
    // guarantees their uniqueness.
    //
    m_pwzResourceName = new WCHAR[wcslen(pwzResourceName) + 1];
    wcscpy(m_pwzResourceName, pwzResourceName);

    //
    // Service name is based on the resource name.
    // Long resource name is truncated.
    //
    LPCWSTR x_SERVICE_PREFIX = L"MSMQ$";
    wcscpy(m_wzServiceName, x_SERVICE_PREFIX);
    wcsncat(m_wzServiceName, m_pwzResourceName, STRLEN(m_wzServiceName) - wcslen(x_SERVICE_PREFIX));

    //
    // Driver name is based on the resource name.
    // Long resource name is truncated.
    //
    LPCWSTR x_DRIVER_PREFIX = L"MQAC$";
    wcscpy(m_wzDriverName, x_DRIVER_PREFIX);
    wcsncat(m_wzDriverName, m_pwzResourceName, STRLEN(m_wzDriverName) - wcslen(x_DRIVER_PREFIX));

    GetSystemDirectory(m_wzDriverPath, TABLE_SIZE(m_wzDriverPath));
    wcscat(m_wzDriverPath, L"\\drivers\\");
    wcscat(m_wzDriverPath, m_wzDriverName);
    wcscat(m_wzDriverPath, L".sys");


    //
    // Names for Crypto keys are based on the resource name
    // Long resource name is truncated.
    //

    LPCWSTR x_40 = L"_40";
    LPCWSTR x_Provider40 = L"1\\Microsoft Base Cryptographic Provider v1.0\\";

    wcscpy(m_wzCrypto40Container, L"");
    wcsncat(m_wzCrypto40Container, m_wzServiceName,
            STRLEN(m_wzCrypto40Container) - wcslen(x_40) - wcslen(x_Provider40));
    wcscat(m_wzCrypto40Container, x_40);

    wcscpy(m_wzCrypto40FullKey, x_Provider40);
    ASSERT(("copying to non allocated memory!",
            wcslen(m_wzCrypto40FullKey) + wcslen(m_wzCrypto40Container) < TABLE_SIZE(m_wzCrypto40FullKey)));
    wcscat(m_wzCrypto40FullKey, m_wzCrypto40Container);


    LPCWSTR x_128 = L"_128";
    LPCWSTR x_Provider128 = L"1\\Microsoft Enhanced Cryptographic Provider v1.0\\";

    wcscpy(m_wzCrypto128Container, L"");
    wcsncat(m_wzCrypto128Container, m_wzServiceName,
            STRLEN(m_wzCrypto128Container) - wcslen(x_128) - wcslen(x_Provider128));
    wcscat(m_wzCrypto128Container, x_128);

    wcscpy(m_wzCrypto128FullKey, x_Provider128);
    ASSERT(("copying to non allocated memory!",
             wcslen(m_wzCrypto128FullKey) + wcslen(m_wzCrypto128Container) < TABLE_SIZE(m_wzCrypto128FullKey)));
    wcscat(m_wzCrypto128FullKey, m_wzCrypto128Container);

    //
    // Initialize registry section - idempotent
    //
    // The registry section name of this QM resource MUST be
    // identical to the service name. The registry routines
    // in mqutil.dll are based on that.
    //

    ASSERT(("copying to non allocated memory!",
            TABLE_SIZE(m_wzFalconRegSection) > wcslen(FALCON_CLUSTERED_QMS_REG_KEY) +
                                               wcslen(m_wzServiceName)              +
                                               wcslen(FALCON_REG_KEY_PARAM)));
    C_ASSERT(TABLE_SIZE(m_wzFalconRegSection)> TABLE_SIZE(FALCON_CLUSTERED_QMS_REG_KEY) +
                                               TABLE_SIZE(m_wzServiceName)              +
                                               TABLE_SIZE(FALCON_REG_KEY_PARAM));

    wcscpy(m_wzFalconRegSection, FALCON_CLUSTERED_QMS_REG_KEY);
    wcscat(m_wzFalconRegSection, m_wzServiceName);
    wcscat(m_wzFalconRegSection, FALCON_REG_KEY_PARAM);

    if (MqcluspFirstTimeCreation(hResourceKey))
    {
        RegDeleteTree(FALCON_REG_POS, m_wzFalconRegSection);
        ASSERT(!MqcluspFirstTimeCreation(hResourceKey));
    }

    CAutoCloseRegHandle hKey;
    DWORD dwDisposition = 0;
    LONG rc = RegCreateKeyEx(
                  FALCON_REG_POS,
                  m_wzFalconRegSection,
                  0,
                  NULL,
                  REG_OPTION_NON_VOLATILE,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hKey,
                  &dwDisposition
                  );
    if (ERROR_SUCCESS != rc)
    {
        ASSERT(("Failed to create registry section!", 0));

        SetLastError(rc);
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"Failed to create MSMQ registy. Error 0x%1!x!\n", rc);

        throw CMqclusException();
    }

    SetFalconKeyValue(FALCON_RM_CLIENT_NAME_REGNAME, REG_SZ, m_wzServiceName,
                      (wcslen(m_wzServiceName) + 1) * sizeof(WCHAR));

    SetFalconKeyValue(MSMQ_DRIVER_REGNAME, REG_SZ, m_wzDriverName,
                      (wcslen(m_wzDriverName) + 1) * sizeof(WCHAR));

    const DWORD xDwSize = sizeof(DWORD);
    const DWORD xGuidSize = sizeof(GUID);

    //
    // In the case of migrated QM (QM that was upgraded from the old
    // msmq resource type), setup status is "upgraded from NT4" or
    // "upgraded from win2k beta3".
    //
    DWORD dwSetupStatus = MSMQ_SETUP_FRESH_INSTALL;
    dwSize = sizeof(DWORD);
    if (!GetFalconKeyValue(MSMQ_SETUP_STATUS_REGNAME, &dwSetupStatus, &dwSize))
    {
        SetFalconKeyValue(MSMQ_SETUP_STATUS_REGNAME, REG_DWORD, &dwSetupStatus, xDwSize);
    }

    DWORD dwOldMqs = 0;
    SetFalconKeyValue(MSMQ_MQS_REGNAME, REG_DWORD, &dwOldMqs, xDwSize);

    DWORD dwMqsDsServer = 0;
    SetFalconKeyValue(MSMQ_MQS_DSSERVER_REGNAME, REG_DWORD, &dwMqsDsServer, xDwSize);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    {
        CS lock(s_csReg);
        pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

        pfGetFalconKeyValue(MSMQ_MQS_ROUTING_REGNAME, &dwType, &m_dwMqsRouting, &dwSize);
    }
    SetFalconKeyValue(MSMQ_MQS_ROUTING_REGNAME, REG_DWORD, &m_dwMqsRouting, xDwSize);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    {
        CS lock(s_csReg);
        pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

        pfGetFalconKeyValue(MSMQ_MQS_DEPCLINTS_REGNAME, &dwType, &m_dwMqsDepClients, &dwSize);
    }
    SetFalconKeyValue(MSMQ_MQS_DEPCLINTS_REGNAME, REG_DWORD, &m_dwMqsDepClients, xDwSize);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    DWORD dwCommunication = MSMQ_DEFAULT_SECURE_DS_COMMUNICATION;
    {
        CS lock(s_csReg);
        pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);
        
        pfGetFalconKeyValue(MSMQ_SECURE_DS_COMMUNICATION_REGNAME, &dwType, &dwCommunication, &dwSize);
    }
    SetFalconKeyValue(MSMQ_SECURE_DS_COMMUNICATION_REGNAME, REG_DWORD, &dwCommunication, xDwSize);
    
    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    {
        CS lock(s_csReg);
        pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

        pfGetFalconKeyValue(MSMQ_WORKGROUP_REGNAME, &dwType, &m_dwWorkgroup, &dwSize);
    }

    if (m_dwWorkgroup != 0)
    {
        SetFalconKeyValue(MSMQ_WORKGROUP_REGNAME, REG_DWORD, &m_dwWorkgroup, xDwSize);
    }
    else
    {
        dwType = REG_BINARY;
        dwSize = sizeof(GUID);
        GUID guidEnterprise = GUID_NULL;
        {
            CS lock(s_csReg);
            pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

            if (ERROR_SUCCESS != pfGetFalconKeyValue(MSMQ_ENTERPRISEID_REGNAME, &dwType, &guidEnterprise, &dwSize))
            {
                ReportLastError(READ_REGISTRY_ERR, L"Failed to read Enterprise ID from MSMQ registry", NULL);
                throw CMqclusException();
            }
        }
        SetFalconKeyValue(MSMQ_ENTERPRISEID_REGNAME, REG_BINARY, &guidEnterprise,xGuidSize);

        dwType = REG_BINARY;
        dwSize = sizeof(GUID);
        GUID guidSite = GUID_NULL;
        {
            CS lock(s_csReg);
            pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

            if (ERROR_SUCCESS != pfGetFalconKeyValue(MSMQ_SITEID_REGNAME, &dwType, &guidSite, &dwSize))
            {
                ReportLastError(READ_REGISTRY_ERR, L"Failed to read Site ID from MSMQ registry", NULL);
                throw CMqclusException();
            }
        }
        SetFalconKeyValue(MSMQ_SITEID_REGNAME, REG_BINARY, &guidSite, xGuidSize);

/*
        dwType = REG_SZ;
        WCHAR wzServer[MAX_REG_DSSERVER_LEN] = L"";
        dwSize = sizeof(wzServer);
        {
            CS lock(s_csReg);
            pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);
            if (ERROR_SUCCESS != pfGetFalconKeyValue(MSMQ_DS_SERVER_REGNAME, &dwType, wzServer, &dwSize))
            {
                ReportLastError(READ_REGISTRY_ERR, L"Failed to read server list from MSMQ registry", NULL);
                throw CMqclusException();
            }
        }
        SetFalconKeyValue(MSMQ_DS_SERVER_REGNAME, REG_SZ, wzServer, (wcslen(wzServer) + 1) * sizeof(WCHAR));

        dwType = REG_SZ;
        dwSize = sizeof(m_wzCurrentDsServer);
        {
            CS lock(s_csReg);
            pfSetFalconServiceName(QM_DEFAULT_SERVICE_NAME);

            if (ERROR_SUCCESS != pfGetFalconKeyValue(MSMQ_DS_CURRENT_SERVER_REGNAME, &dwType, m_wzCurrentDsServer, &dwSize))
            {
                ReportLastError(READ_REGISTRY_ERR, L"Failed to read current server from MSMQ registry", NULL);
                throw CMqclusException();
            }
        }
        if (wcslen(m_wzCurrentDsServer) < 1)
        {
            //
            // Current MQIS server is blank. Take the first server from the server list.
            //
            ASSERT(("must have server list in registry", wcslen(wzServer) > 0));
            WCHAR wzBuffer[MAX_REG_DSSERVER_LEN] = L"";
            wcscpy(wzBuffer, wzServer);
            WCHAR * pwz = wcschr(wzBuffer, L',');
            if (pwz != NULL)
            {
                (*pwz) = L'\0';
            }
            wcscpy(m_wzCurrentDsServer, wzBuffer);
        }
        SetFalconKeyValue(MSMQ_DS_CURRENT_SERVER_REGNAME, REG_SZ, m_wzCurrentDsServer, (wcslen(m_wzCurrentDsServer) + 1) * sizeof(WCHAR));
*/

        SetFalconKeyValue(MSMQ_CRYPTO40_CONTAINER_REG_NAME, REG_SZ, m_wzCrypto40Container,
                          (wcslen(m_wzCrypto40Container) + 1) * sizeof(WCHAR));

        SetFalconKeyValue(MSMQ_CRYPTO128_CONTAINER_REG_NAME, REG_SZ, m_wzCrypto128Container,
                          (wcslen(m_wzCrypto128Container) + 1) * sizeof(WCHAR));
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"resource constructed OK.\n");

} //CQmResource::CQmResource


DWORD
CQmResource::ReportLastError(
    DWORD ErrId,
    LPCWSTR pwzDebugLogMsg,
    LPCWSTR pwzArg
    ) const

/*++

Routine Description:

    Report error messages based on last error.
    Most error messages are reported using this routine.
    The report goes to MSMQ debug output and to cluster
    log file.

Arguments:

    ErrId - ID of the error string in mqsymbls.mc

    pwzDebugLogMsg - Non localized string for MSMQ debug output.

    pwzArg - Additional string argument.

Return Value:

    Last error.

--*/

{
    DWORD err = GetLastError();
    ASSERT(err != ERROR_SUCCESS);

    WCHAR wzErr[10];
    _ultow(err, wzErr, 16);

    WCHAR DebugMsg[255] = L"";
    wcscpy(DebugMsg, pwzDebugLogMsg);

    if (pwzArg == NULL)
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, ErrId, 1, wzErr);

        wcscat(DebugMsg, L" Error 0x%1!x!.\n");
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, DebugMsg, err);
    }
    else
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, ErrId, 2, pwzArg, wzErr);

        wcscat(DebugMsg, L" Error 0x%2!x!.\n");
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, DebugMsg, pwzArg, err);
    }

    return err;

} //CQmResource::ReportLastError


inline
VOID
CQmResource::ReportState(
    VOID
    ) const

/*++

Routine Description:

    Report status of the resource to resource monitor.
    This routine is called to report progress when the
    resource is online pending, and to report final status
    when the resource is online or offline.

Arguments:

    None

Return Value:

    None

--*/

{
    ++m_ResourceStatus.CheckPoint;
    g_pfSetResourceStatus(m_hReport, &m_ResourceStatus);

} //CQmResource::ReportState


VOID
CQmResource::RegDeleteTree(
    HKEY hRootKey,
    LPCWSTR pwzKey
    ) const

/*++

Routine Description:

    Recursively delete registry key and all its subkeys - idempotent.

Arguments:

    hRootKey - Handle to the root key of the key to be deleted

    pwzKey   - Key to be deleted

Return Value:

    None

--*/

{
    HKEY hKey = 0;
    if (ERROR_SUCCESS != RegOpenKeyEx(hRootKey, pwzKey, 0, KEY_ENUMERATE_SUB_KEYS | KEY_WRITE, &hKey))
    {
        return;
    }

    for (;;)
    {
        WCHAR wzSubkey[255] = {0};
        DWORD cbSubkey = 0;

        cbSubkey = TABLE_SIZE(wzSubkey);
        if (ERROR_SUCCESS != RegEnumKeyEx(hKey, 0, wzSubkey, &cbSubkey, NULL, NULL, NULL, NULL))
        {
            break;
        }

        RegDeleteTree(hKey, wzSubkey);
    }

    RegCloseKey(hKey);

    RegDeleteKey(hRootKey, pwzKey);

} //CQmResource::RegDeleteTree


VOID
CQmResource::DeleteFalconRegSection(
    VOID
    )
{
    //
    // Idempotent deletion
    //

    if (wcslen(m_wzFalconRegSection) < 1)
    {
        return;
    }

    WCHAR wzFalconRegistry[TABLE_SIZE(m_wzFalconRegSection)] = L"";
    wcscpy(wzFalconRegistry, FALCON_CLUSTERED_QMS_REG_KEY);
    wcsncat(wzFalconRegistry, m_wzServiceName,
            STRLEN(wzFalconRegistry) - wcslen(FALCON_CLUSTERED_QMS_REG_KEY) - wcslen(FALCON_REG_KEY_PARAM));

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Deleting registry section '%1'.\n", wzFalconRegistry);

    RegDeleteTree(FALCON_REG_POS, wzFalconRegistry);

    wcscpy(m_wzFalconRegSection, L"");

} //CQmResource::DeleteFalconRegSection


bool
CQmResource::GetFalconKeyValue(
    LPCWSTR pwzValueName,
    VOID  * pData,
    DWORD * pcbSize
    ) const

/*++

Routine Description:

    Read a registry value from this clustered QM registry section

Arguments:

    pwzValueName - Name of the value to read.

    pData - Points to buffer to receive the value.

    pcbSize - Points to size of value data, in bytes.

Return Value:

    true - Value was read and placed in buffer.

    false - Failed to read the value.

--*/

{
    CQmResourceRegistry lock(m_wzServiceName);

    //
    // Don't log errors. Let caller implement failure policy.
    //
    return (ERROR_SUCCESS == pfGetFalconKeyValue(pwzValueName, NULL, pData, pcbSize));

} //CQmResource::GetFalconKeyValue


bool
CQmResource::SetFalconKeyValue(
    LPCWSTR pwzValueName,
    DWORD   dwType,
    const VOID * pData,
    DWORD   cbSize
    ) const

/*++

Routine Description:

    Set a registry value in this clustered QM registry section

Arguments:

    pwzValueName - Name of the value to set.

    dwType - Type of value to be set

    pData - Points to buffer with the value to be set

    cbSize - Size of value data, in bytes.

Return Value:

    true - Value was set successfully.

    false - Failed to set the value.

--*/

{
    CQmResourceRegistry lock(m_wzServiceName);

    LONG rc = pfSetFalconKeyValue(pwzValueName, &dwType, pData, &cbSize);

    if (ERROR_SUCCESS != rc)
    {
        SetLastError(rc);
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"Failed to set registry value '%1'. Error 0x%2!x!.\n",
                              pwzValueName, rc);

        return false;
    }

    switch (dwType)
    {
        case REG_DWORD:
        {
            DWORD dwValueData = *(static_cast<const DWORD*>(pData));
            (g_pfLogClusterEvent)(
                m_hReport,
                LOG_INFORMATION,
                L"Successfully set registry DWORD value '%1'. Value data: '0x%2!x!'.\n",
                pwzValueName,
                dwValueData
                );
            break;
        }
        case REG_SZ:
        {
            (g_pfLogClusterEvent)(
                m_hReport,
                LOG_INFORMATION,
                L"Successfully set registry STRING value '%1'. Value data: '%2'.\n",
                pwzValueName,
                pData
                );
            break;
        }
        default:
        {
            (g_pfLogClusterEvent)(
                m_hReport,
                LOG_INFORMATION,
                L"Successfully set registry value '%1'.\n",
                pwzValueName
                );
            break;
        }
    }

    return true;

} //CQmResource::SetFalconKeyValue


bool
CQmResource::IsFirstOnline(
    DWORD * pdwSetupStatus
    ) const

/*++

Routine Description:

    Checks in registry if this QM was ever running.
    If the case of migrated QM (QM that was upgraded
    from the old msmq resource type), this routine
    will return true iff this is first online of
    the QM as the new resource type.

Arguments:

    pdwSetupStatus - On output points to this QM setup status.

Return Value:

    true - This QM has never been up and running (or in
      the case of migrated QM: never been up as the new
      resource type).

    false - This QM was up and running.

--*/

{
    //
    // This reg value is deleted by QM on first successful startup
    //
    // In the case of migrated QM (QM that was upgraded from the old
    // msmq resource type), setup status is "upgraded from NT4" or
    // "upgraded from win2k beta3".
    // In the normal case, setup status is "fresh install".
    //

    (*pdwSetupStatus) = MSMQ_SETUP_DONE;
    DWORD dwSize = sizeof(DWORD);
    return (GetFalconKeyValue(MSMQ_SETUP_STATUS_REGNAME, pdwSetupStatus, &dwSize) &&
            MSMQ_SETUP_DONE != *pdwSetupStatus);

} //CQmResource::IsFirstOnline


DWORD
CQmResource::ClusterResourceControl(
    LPCWSTR pwzResourceName,
    DWORD dwControlCode,
    LPBYTE * ppBuffer,
    DWORD * pcbSize
    ) const

/*++

Routine Description:

    Wrapper for ClusterResourceControl.
    We want to control resources such as network name and disk.

    Note that most of the control code functions should not be called
    by resource DLLs, unless from within the online/offline threads.

Arguments:

    pwzResourceName - Name of resource to control.

    dwControlCode - Operation to perform on the resource.

    ppBuffer - Pointer to pointer to output buffer to be allocated.

    pcbSize - Pointer to allocated size of buffer, in bytes.

Return Value:

    Win32 error code.

--*/

{
    ASSERT(("must have a valid handle to cluster", m_hCluster != NULL));

    CClusterResource hResource(OpenClusterResource(
                                   m_hCluster,
                                   pwzResourceName
                                   ));
    if (hResource == NULL)
    {
        return ReportLastError(OPEN_RESOURCE_ERR, L"OpenClusterResource for '%1' failed.", pwzResourceName);
    }

    DWORD dwReturnSize = 0;
    DWORD dwStatus = ::ClusterResourceControl(
                           hResource,
                           0,
                           dwControlCode,
                           0,
                           0,
                           0,
                           0,
                           &dwReturnSize
                           );
    if (dwStatus != ERROR_SUCCESS)
    {
        return dwStatus;
    }
    ASSERT(("failed to get buffer size for a resource", 0 != dwReturnSize));

    *ppBuffer = new BYTE[dwReturnSize];

    dwStatus = ::ClusterResourceControl(
                     hResource,
                     0,
                     dwControlCode,
                     0,
                     0,
                     *ppBuffer,
                     dwReturnSize,
                     &dwReturnSize
                     );

    if (pcbSize != NULL)
    {
        *pcbSize = dwReturnSize;
    }

    return dwStatus;

} //CQmResource::ClusterResourceControl


bool
CQmResource::IsResourceNetworkName(
    LPCWSTR pwzResourceName
    )

/*++

Routine Description:

    Check if a resource is of type Network Name.

Arguments:

    pwzResourceName - Name of resource to check upon.

Return Value:

    true - Resource is of type Network Name

    false - Resource is not of type Network Name

--*/

{
    LPCWSTR x_NETWORK_NAME_TYPE = L"Network Name";
    AP<BYTE> pType = 0;
    DWORD status = ClusterResourceControl(
                       pwzResourceName,
                       CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                       &pType,
                       NULL
                       );
    if (status != ERROR_SUCCESS ||
        0 != CompareStringsNoCase(reinterpret_cast<LPWSTR>(pType.get()), x_NETWORK_NAME_TYPE))
    {
        return false;
    }

    AP<BYTE> pBuffer = 0;
    DWORD dwStatus = ClusterResourceControl(
                         pwzResourceName,
                         CLUSCTL_RESOURCE_GET_NETWORK_NAME,
                         &pBuffer,
                         NULL
                         );


    ReportState();


    if (dwStatus != ERROR_SUCCESS)
    {
        ASSERT(("ClusterResourceControl failed for network name resource!", 0));

        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,
                              L"Failed to control resource. Control Code 0x%1!x!. Error 0x%2!x!.\n",
                              CLUSCTL_RESOURCE_GET_NETWORK_NAME, dwStatus);

        return false;
    }

    LPCWSTR x_pwzNetworkName = reinterpret_cast<LPCWSTR>(pBuffer.get());

    delete [] m_pwzNetworkName.detach();
    m_pwzNetworkName = new WCHAR[wcslen(x_pwzNetworkName) + 1];
    wcscpy(m_pwzNetworkName, x_pwzNetworkName);

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Network name is '%1'.\n", m_pwzNetworkName);

    return true;

}//CQmResource::IsResourceNetworkName


bool
CQmResource::IsResourceDiskDrive(
    LPCWSTR pwzResourceName
    )

/*++

Routine Description:

    Check if a resource is a disk drive.

Arguments:

    pwzResourceName - Name of resource to check upon.

Return Value:

    true - Resource is a disk drive.

    false - Resource is not a disk drive.

--*/

{
    CClusterResource hResource(OpenClusterResource(m_hCluster, pwzResourceName));
    if (hResource == NULL)
    {
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, 
            L"OpenClusterResource for '%1' failed. Error 0x%2!x!.\n", pwzResourceName, GetLastError());
        return false;
    }

    ReportState();

    CLUS_RESOURCE_CLASS_INFO  crciClassInfo;
	crciClassInfo.rc = CLUS_RESCLASS_UNKNOWN;

    DWORD dwSize = 0;
    DWORD status = ::ClusterResourceControl(
					    hResource, 							// Resource to send control to
					    NULL,								// hNode -> NULL == any node
					    CLUSCTL_RESOURCE_GET_CLASS_INFO,	// Want res type
					    NULL,								// Ptr to In buffer
					    0,									// Size of In buffer
					    (LPVOID) &crciClassInfo,			// Ptr to Out buffer
					    (DWORD)  sizeof(crciClassInfo),		// Size of Out buffer
					    &dwSize
                        );

    ReportState();

    ASSERT(dwSize == (DWORD)sizeof(crciClassInfo));

    if (status != ERROR_SUCCESS ||
        CLUS_RESCLASS_STORAGE != crciClassInfo.rc || 
 	    CLUS_RESSUBCLASS_SHARED != crciClassInfo.SubClass
       )
    {
        //
        // Not a storage type resource. Return
        //
        return false;
    }

    AP<BYTE> pBuffer = 0;
    dwSize = 0;
    DWORD dwStatus = ClusterResourceControl(
                         pwzResourceName,
                         CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                         &pBuffer,
                         &dwSize
                         );

    ReportState();

    if (dwStatus != ERROR_SUCCESS)
    {
        ASSERT(("ClusterResourceControl failed for disk resource!", 0));

        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,
                              L"Failed to control resource. Control Code 0x%1!x!. Error 0x%2!x!.\n",
                              CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO, dwStatus);
        return false;
    }

    //
    // Look for the drive letter
    //
    CLUSPROP_VALUE *pheader;

    DWORD dwCurrentLocation = 0;
    while(dwCurrentLocation < dwSize)
    {
        pheader = (CLUSPROP_VALUE *)(pBuffer + dwCurrentLocation);
        if (CLUSPROP_TYPE_ENDMARK == pheader->Syntax.wType)
        {
            break;
        }
        if (CLUSPROP_TYPE_PARTITION_INFO == pheader->Syntax.wType)
        {
            PCLUSPROP_PARTITION_INFO pPartitionInfo =
                (PCLUSPROP_PARTITION_INFO) pheader;

            m_wDiskDrive = pPartitionInfo->szDeviceName[0];

            (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"disk drive is '%1!c!'.\n", m_wDiskDrive);

            return true;
        }
        dwCurrentLocation += ALIGN_CLUSPROP(pheader->cbLength) + sizeof(*pheader);
    }


    ASSERT(("failed to find disk drive letter for a disk resource", 0));
    (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"drive letter not found.\n");

    return false;

} //CQmResource::IsResourceDiskDrive


DWORD
CQmResource::QueryResourceDependencies(
    VOID
    )

/*++

Routine Description:

    Get and store the first disk and network name resources
    we're depended on.
    Keep this routine idempotent.

Arguments:

    None

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    DWORD dwResourceType = CLUSTER_RESOURCE_ENUM_DEPENDS;
    CResourceEnum hResEnum(ClusterResourceOpenEnum(
                               m_hResource,
                               dwResourceType
                               ));
    if (hResEnum == NULL)
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, REQUIRED_DEPENDENCIES_ERR, 0);

        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,L"Failed to enum dependencies. Error 0x%1!x!.\n",
                              GetLastError());

        return GetLastError();
    }

    DWORD dwIndex = 0;
    WCHAR wzResourceName[260] = {0};
    DWORD status = ERROR_SUCCESS;

    for (;;)
    {
        if (m_wDiskDrive != 0            &&
            m_pwzNetworkName != NULL     &&
            wcslen(m_pwzNetworkName) != 0)
        {
            return ERROR_SUCCESS;
        }

        DWORD cchResourceName = STRLEN(wzResourceName);
        status = ClusterResourceEnum(
                     hResEnum,
                     dwIndex++,
                     &dwResourceType,
                     wzResourceName,
                     &cchResourceName
                     );

        if (ERROR_SUCCESS != status)
        {
            break;
        }


        ReportState();


        if (IsResourceNetworkName(wzResourceName) ||
            IsResourceDiskDrive(wzResourceName))
        {
            continue;
        }
    }

    MqcluspReportEvent(EVENTLOG_ERROR_TYPE, REQUIRED_DEPENDENCIES_ERR, 0);

    return status;

} //CQmResource::QueryResourceDependencies


DWORD
CQmResource::CreateCaConfiguration(
    VOID
    ) const

/*++

Routine Description:

    Update/create MSMQ CA configuration.
    Keep this routine idempotent.

Arguments:

    None

Return Value:

    ERROR_SUCCESS - if the operation fails then server authentication
                    will fail.
--*/

{
    if (m_dwWorkgroup != 0)
    {
        return ERROR_SUCCESS;
    }

    {
        CQmResourceRegistry lock(m_wzServiceName);

        (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Updating CA Configuration...\n");

        HRESULT hr = pfMQsspi_UpdateCaConfig(FALSE);
        if (FAILED(hr))
        {
            ASSERT(("Failed to update list of CAs", 0));

            (g_pfLogClusterEvent)(m_hReport, LOG_WARNING, L"Failed to update list of CAs. Error 0x%1!x!.\n", hr);
        }
    }

    ReportState();

    return ERROR_SUCCESS;

} //CQmResource::CreateCaConfiguration


BOOL
NoServerAuthenticationCallback(
    VOID
    )

/*++

Routine Description:

    This callback is called by our DS library
    to notify that server was not authenticated.

Arguments:

    None.

Return Value:

    TRUE - ADS access is allowed.

    FALSE - ADS access is not allowed.

--*/

{
    return TRUE;
} //NoServerAuthenticationCallback


DWORD
CQmResource::AdsInit(
    VOID
    )

/*++

Routine Description:

    Initialize calls from this DLL to ADS.
    Query the MSMQ server and decide if it's MSMQ 1.0 or 2.0.
    Get main QM's ADS sites.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    if (m_dwWorkgroup != 0)
    {
        return ERROR_SUCCESS;
    }

    //
    // No need to reinitialize
    //
    if (0 < m_nSites)
    {
        return ERROR_SUCCESS;
    }

    //
    // Don't remove the no-server-authentication callback.
    // The fact that there's a callback turns on secure
    // server communications
    //
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Initializing access to Active Directory...\n");
    HRESULT hr = ADInit(
        NULL,
        NULL,
        false,
        true,
        false,
        false,
        NoServerAuthenticationCallback,
        NULL,
        true    //fDisableDownlevelNotifications
        );

    ReportState();

    if (FAILED(hr))
    {
        SetLastError(hr);
        return ReportLastError(ADS_INIT_ERR, L"DSInit failed.", NULL);
    }
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Access to Active Directory is initialized!\n");

/*
    //
    // This is the first time we access the server.
    // At this point we do not know if server is MSMQ 1.0
    // or MSMQ 2.0, so we use MSMQ 1.0 RPC interface which
    // is always supported.
    //

    PROPID propIdSiteGuid = PROPID_QM_SITE_ID;
    PROPVARIANT propVarSiteGuid;
    propVarSiteGuid.vt = VT_NULL;

    WCHAR wzServer[MAX_REG_DSSERVER_LEN] = {L""};
    WCHAR wzBuffer[MAX_REG_DSSERVER_LEN] = {L""};
    wcscpy(wzBuffer, m_wzCurrentDsServer);
    ASSERT(wcslen(wzBuffer) > 2);
    wcscpy(wzServer, &wzBuffer[2]);

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Querying Message Queuing Server '%1'...\n", wzServer);
    hr = ADGetObjectProperties(
				eMACHINE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				wzServer,
				1,
				&propIdSiteGuid,
				&propVarSiteGuid
				);

    ReportState();

    if (FAILED(hr))
    {
        SetLastError(hr);
        return ReportLastError(ADS_QUERY_SERVER_ERR, L"Failed to query the MSMQ server '%1'.", wzServer);
    }
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Message Queuing Server '%1' replied!\n", wzServer);

    //
    // Query again using MSMQ 2.0 RPC interface.
    // If we get MQ_ERROR_NO_DS it means server does
    // not recognize MSMQ 2.0 RPC interface (i.e. server
    // is MSMQ 1.0).
    //

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Querying Message Queuing Server '%1'...\n", wzServer);
    PROPID propIdSignPks = PROPID_QM_SIGN_PKS;
    PROPVARIANT propVarSignPks;
    propVarSignPks.vt = VT_NULL;

    hr = ADGetObjectProperties(
				eMACHINE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				wzServer,
				1,
				&propIdSignPks,
				&propVarSignPks
				);

    ReportState();

    if (SUCCEEDED(hr))
    {
        delete propVarSignPks.blob.pBlobData;
    }
    else
    {
        if (hr != MQ_ERROR_NO_DS)
        {
            SetLastError(hr);
            return ReportLastError(ADS_QUERY_SERVER_ERR, L"Failed to query the MSMQ server '%1'.", wzServer);
        }

        m_fServerIsMsmq1 = true;
        (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Server is MSMQ 1.0.\n");

        m_pguidSites = propVarSiteGuid.puuid;
        m_nSites = 1;

        MqcluspReportEvent(EVENTLOG_INFORMATION_TYPE, CONNECT_SERVER_OK, 1, wzServer);
        return ERROR_SUCCESS;
    }


    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Server is MSMQ 2.0.\n");
*/
    WCHAR wzNodeName[MAX_COMPUTERNAME_LENGTH + 1] = {0};
    DWORD dwLen = TABLE_SIZE(wzNodeName);
    GetComputerName(wzNodeName, &dwLen);

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Getting Sites of '%1'...\n", wzNodeName);
    hr = ADGetComputerSites(wzNodeName, &m_nSites, &m_pguidSites);

    ReportState();

    if (FAILED(hr))
    {
        SetLastError(hr);
        return ReportLastError(ADS_QUERY_SERVER_ERR, L"Querying MSMQ server '%1' for Sites failed", L"");
    }
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Successfully got sites of '%1'!\n", wzNodeName);

    MqcluspReportEvent(EVENTLOG_INFORMATION_TYPE, CONNECT_SERVER_OK, 1, L"");
    return ERROR_SUCCESS;

} //CQmResource::AdsInit


DWORD
CQmResource::AdsDeleteQmObject(
    VOID
    ) const

/*++

Routine Description:

    Delete the MSMQ objects from Active Directory
    (or from MQIS in the case of MSMQ 1.0 enterprise).

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    if (m_dwWorkgroup != 0)
    {
        return ERROR_SUCCESS;
    }

    //
    // Idempotent deletion.
    // There are scenarios inwhich the QM ADS object was not created,
    // e.g. when resource is created and deleted w/o attempt to bring
    // it online.
    //

    GUID guidQm = m_guidQm;
    if (guidQm == GUID_NULL)
    {
        DWORD dwSize = sizeof(GUID);
        if (!GetFalconKeyValue(MSMQ_QMID_REGNAME, &guidQm, &dwSize))
        {
            (g_pfLogClusterEvent)(m_hReport, LOG_WARNING, L"Can not delete QM ADS object (fail to obtain GUID).\n");
            return ERROR_SUCCESS;
        }
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Deleting Active Directory objects...\n");
    HRESULT hr = ADDeleteObjectGuid(
						eMACHINE,
						NULL,       // pwcsDomainController
						false,	    // fServerName
						&guidQm
						);

    if (FAILED(hr) &&
        MQDS_OBJECT_NOT_FOUND != hr)
    {
        (g_pfLogClusterEvent)(m_hReport, LOG_WARNING, L"Failed to delete MSMQ ADS object. Error 0x%1!x!.\n", hr);

        return hr;
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Successfully deleted Active Directory objects!\n");
    return ERROR_SUCCESS;

} //CQmResource::AdsDeleteQmObject


DWORD
CQmResource::AdsCreateComputerObject(
    VOID
    ) const

/*++

Routine Description:

    Create a computer object in Active Directory for
    the cluster virtual server. The computer object
    will be a container for MSMQ objects of this QM.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    if (m_dwWorkgroup != 0   ||
        m_fServerIsMsmq1)
    {
        return ERROR_SUCCESS;
    }

    ASSERT(("no network name", m_pwzNetworkName != NULL && wcslen(m_pwzNetworkName) > 0));

    LPCWSTR x_DOLLAR = L"$";

    //
    // The PROPID_COM_SAM_ACCOUNT contains the first MAX_COM_SAM_ACCOUNT_LENGTH (19)
    // characters of the computer name, as unique ID. (6295 - ilanh - 03-Jan-2001)
    //
	DWORD len = __min(wcslen(m_pwzNetworkName), MAX_COM_SAM_ACCOUNT_LENGTH);
	AP<WCHAR> pwzComputerNameWithDollar = new WCHAR[len + wcslen(x_DOLLAR) + 1];
	wcsncpy(pwzComputerNameWithDollar, m_pwzNetworkName, len);
    wcscat(pwzComputerNameWithDollar, x_DOLLAR);

    PROPID propId = PROPID_COM_SAM_ACCOUNT;
    PROPVARIANT propVar;
    propVar.vt = VT_LPWSTR;
    propVar.pwszVal = pwzComputerNameWithDollar;

    //
    // Idempotent creation
    //
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Creating Computer Object '%1' in Active Directory...\n",
                          m_pwzNetworkName);
    HRESULT hr = ADCreateObject(
						eCOMPUTER,
						NULL,       // pwcsDomainController
						false,	    // fServerName
						m_pwzNetworkName,
						NULL,
						1,
						&propId,
						&propVar,
						NULL
						);

    if (FAILED(hr))
    {
        if (hr == MQDS_E_COMPUTER_OBJECT_EXISTS)
        {
            g_pfLogClusterEvent(m_hReport, LOG_INFORMATION, L"Computer Object Already Exists !\n");

            ReportState();
            return ERROR_SUCCESS;
        }

        SetLastError(hr);
        return ReportLastError(ADS_CREATE_COMPUTER_ERR, L"Failed to create Computer Object '%1'.",
                               m_pwzNetworkName);
    }

    MqcluspReportEvent(EVENTLOG_INFORMATION_TYPE, ADS_CREATE_COMPUTER_OK, 1, m_pwzNetworkName);
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Successfully created Computer Object '%1'!\n",
                          m_pwzNetworkName);


    ReportState();


    return ERROR_SUCCESS;

} //CQmResource::AdsCreateComputerObject


DWORD
CQmResource::AdsCreateQmObject(
    VOID
    ) const

/*++

Routine Description:

    Create the MSMQ objects in Active Directory for this QM.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    if (m_dwWorkgroup != 0)
    {
        return ERROR_SUCCESS;
    }

    ASSERT(("no network name", m_pwzNetworkName != NULL && wcslen(m_pwzNetworkName) > 0));

    const DWORD x_MAX_PROPS = 16;
    PROPID propIds[x_MAX_PROPS];
    PROPVARIANT propVars[x_MAX_PROPS];
    DWORD ixProp = 0;

    propIds[ixProp] = PROPID_QM_MACHINE_TYPE;
    propVars[ixProp].vt = VT_LPWSTR;
    propVars[ixProp].pwszVal = pfMSMQGetQMTypeString();
    ++ixProp;

    propIds[ixProp] = PROPID_QM_OS;
    propVars[ixProp].vt = VT_UI4;
    propVars[ixProp].ulVal = pfMSMQGetOperatingSystem();
    ++ixProp;

    DWORD ixPropidMsmqGroupInCluster = 0;
    if (!m_fServerIsMsmq1)
    {
        propIds[ixProp] = PROPID_QM_SERVICE_DSSERVER;
        propVars[ixProp].vt = VT_UI1;
        propVars[ixProp].bVal = static_cast<UCHAR>(0);
        ++ixProp;

        propIds[ixProp] = PROPID_QM_SERVICE_ROUTING;
        propVars[ixProp].vt = VT_UI1;
        propVars[ixProp].bVal = static_cast<UCHAR>(m_dwMqsRouting);
        ++ixProp;

        propIds[ixProp] = PROPID_QM_SERVICE_DEPCLIENTS;
        propVars[ixProp].vt = VT_UI1;
        propVars[ixProp].bVal = static_cast<UCHAR>(m_dwMqsDepClients);
        ++ixProp;

        propIds[ixProp] = PROPID_QM_SITE_IDS;
        propVars[ixProp].vt = VT_CLSID|VT_VECTOR;
        propVars[ixProp].cauuid.pElems = m_pguidSites;
        propVars[ixProp].cauuid.cElems = m_nSites;
        ++ixProp;

        //
        // This PROPID is not supported by win2k beta3 servers.
        // Make sure it is the last one.
        //
        propIds[ixProp] = PROPID_QM_GROUP_IN_CLUSTER;
        propVars[ixProp].vt = VT_UI1;
        propVars[ixProp].bVal = MSMQ_GROUP_IN_CLUSTER;
        ixPropidMsmqGroupInCluster = ixProp;
        ++ixProp;
    }
    else
    {
        propIds[ixProp] = PROPID_QM_SERVICE;
        propVars[ixProp].vt = VT_UI4;
        propVars[ixProp].ulVal = SERVICE_NONE;
        if (0 != m_dwMqsRouting)
        {
            propVars[ixProp].ulVal = SERVICE_SRV;
        }
        ++ixProp;

        propIds[ixProp] = PROPID_QM_SITE_ID;
        propVars[ixProp].vt = VT_CLSID;
        propVars[ixProp].puuid = m_pguidSites;
        ++ixProp;

        propIds[ixProp] = PROPID_QM_PATHNAME;
        propVars[ixProp].vt = VT_LPWSTR;
        propVars[ixProp].pwszVal = m_pwzNetworkName;
        ixProp++;

        propIds[ixProp] = PROPID_QM_MACHINE_ID;
        propVars[ixProp].vt = VT_CLSID;
        GUID guidQm = GUID_NULL;
        RPC_STATUS rc = UuidCreate(&guidQm);
        DBG_USED(rc);;
        ASSERT(("Failed to generate a guid for QM", rc == RPC_S_OK));
        propVars[ixProp].puuid = &guidQm;
        ixProp++;

        propIds[ixProp] = PROPID_QM_CNS;
        propVars[ixProp].vt = VT_CLSID|VT_VECTOR;
        propVars[ixProp].cauuid.cElems = 1;
        GUID guidCns = MQ_SETUP_CN;
        propVars[ixProp].cauuid.pElems = &guidCns;
        ixProp++;

        BYTE Address[TA_ADDRESS_SIZE + IP_ADDRESS_LEN];
        TA_ADDRESS * pBuffer = reinterpret_cast<TA_ADDRESS *>(Address);
        pBuffer->AddressType = IP_ADDRESS_TYPE;
        pBuffer->AddressLength = IP_ADDRESS_LEN;
        ZeroMemory(pBuffer->Address, IP_ADDRESS_LEN);

        propIds[ixProp] = PROPID_QM_ADDRESS;
        propVars[ixProp].vt = VT_BLOB;
        propVars[ixProp].blob.cbSize = sizeof(Address);
        propVars[ixProp].blob.pBlobData = reinterpret_cast<BYTE*>(pBuffer);
        ixProp++;
    }

    if (!m_fServerIsMsmq1)
    {
        //
        // PROPID_QM_GROUP_IN_CLUSTER is not supported by win2k beta3 servers.
        // Make sure it is the last one.
        //
        ASSERT(("PROPID_QM_GROUP_IN_CLUSTER must be last one!", ixPropidMsmqGroupInCluster == (ixProp - 1)));
    }

    //
    // Idempotent creation
    //
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Creating MSMQ Object '%1' in Active Directory...\n",
                          m_pwzNetworkName);
    HRESULT hr = ADCreateObject(
						eMACHINE,
						NULL,       // pwcsDomainController
						false,	    // fServerName
						m_pwzNetworkName,
						NULL,
						ixProp,
						propIds,
						propVars,
						NULL
						);

    ReportState();

    if (hr == MQ_ERROR)
    {
        //
        // Try again w/o PROPID_QM_GROUP_IN_CLUSTER (which is not supported by win2k beta3 servers)
        //
        (g_pfLogClusterEvent)(m_hReport, LOG_WARNING, L"First chance fail to create MSMQ ADS object.\n");

        hr = ADCreateObject(
				eMACHINE, 
				NULL,       // pwcsDomainController
				false,	    // fServerName
				m_pwzNetworkName, 
				NULL, 
				--ixProp, 
				propIds, 
				propVars, 
				NULL
				);

        ReportState();
    }

    if (FAILED(hr))
    {
        if (hr == MQ_ERROR_MACHINE_EXISTS)
        {
            (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"MSMQ ADS Object Already Exists !\n");
            return ERROR_SUCCESS;
        }

        SetLastError(hr);
        return ReportLastError(ADS_CREATE_MSMQ_ERR, L"Failed to create MSMQ ADS object.", NULL);
    }

    MqcluspReportEvent(EVENTLOG_INFORMATION_TYPE, ADS_CREATE_MSMQ_OK, 1, m_pwzNetworkName);
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Successfully created MSMQ ADS object.\n");

    ReportState();

    return ERROR_SUCCESS;

} //CQmResource::AdsCreateQmObject


DWORD
CQmResource::AdsCreateQmPublicKeys(
    VOID
    ) const

/*++

Routine Description:

    Create the public keys of this QM in Active Directory.
Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    //
    // Keep this routine idempotent
    //

    if (m_dwWorkgroup != 0)
    {
        return ERROR_SUCCESS;
    }

    {
        CQmResourceRegistry lock(m_wzServiceName);

        (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Storing Public Keys in Active Directory...\n");
        HRESULT hr = pfMQSec_StorePubKeysInDS(FALSE, m_pwzNetworkName, MQDS_MACHINE);
        if (FAILED(hr))
        {
            SetLastError(hr);
            ReportLastError(ADS_STORE_KEYS_ERR, L"Failed to store public keys.", NULL);
            //
            // Ignore the failure and continue.
            // Encryption will be broken.
            //
        }
    }


    ReportState();

    return ERROR_SUCCESS;

} //CQmResource::AdsCreateQmPublicKeys


DWORD
CQmResource::AdsReadQmSecurityDescriptor(
    VOID
    )

/*++

Routine Description:

    Read the security descriptor of this QM from Active Directory.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    //
    // Keep this routine idempotent
    //

    SECURITY_INFORMATION RequestedInformation =
        OWNER_SECURITY_INFORMATION |
        GROUP_SECURITY_INFORMATION |
        DACL_SECURITY_INFORMATION;

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Reading Security from Active Directory...\n");
    
    MQPROPVARIANT propVar;
    propVar.vt = VT_NULL;

    HRESULT hr;
    hr = ADGetObjectSecurityGuid(
				eMACHINE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				&m_guidQm,
				RequestedInformation,
				PROPID_QM_SECURITY,
				&propVar
				);
    
    
    ReportState();
    
    
    if (FAILED(hr))
    {
        SetLastError(hr);
        return ReportLastError(ADS_READ_ERR, L"Failed to read security descriptor.", NULL);
    }
    
    ASSERT(propVar.vt == VT_BLOB);

    m_pSd = propVar.blob.pBlobData;
    m_cbSdSize = propVar.blob.cbSize;

    return ERROR_SUCCESS;

} //CQmResource::AdsReadQmSecurityDescriptor


DWORD
CQmResource::AdsReadQmProperties(
    VOID
    )

/*++

Routine Description:

    Read properties of this QM from Active Directory.
    The properties we read in this routine are computed
    when the MSMQ objects of this QM are created in AD.
    Thus we must create the objects in AD and then read
    these properties.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    //
    // Keep this routine idempotent
    //

    if (m_dwWorkgroup != 0)
    {
        return ERROR_SUCCESS;
    }

    const DWORD x_MAX_PROPS = 16;
    PROPID propIds[x_MAX_PROPS];
    PROPVARIANT propVars[x_MAX_PROPS];
    DWORD ixProp = 0;

    propIds[ixProp] = PROPID_QM_MACHINE_ID;
    propVars[ixProp].vt = VT_CLSID;
    propVars[ixProp].puuid = &m_guidQm;
    ++ixProp;

    ASSERT(("too many properties", ixProp <= x_MAX_PROPS));
    ASSERT(("no network name", (m_pwzNetworkName != NULL) && wcslen(m_pwzNetworkName) > 0));

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Reading '%1' Properties from Active Directory...\n",
                          m_pwzNetworkName);
    HRESULT hr = ADGetObjectProperties(
						eMACHINE,
						NULL,       // pwcsDomainController
						false,	    // fServerName
						m_pwzNetworkName,
						ixProp,
						propIds,
						propVars
						);
    if (FAILED(hr))
    {
        SetLastError(hr);
        return ReportLastError(ADS_READ_ERR, L"Failed to read QM ADS properties.", NULL);
    }
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Successfully read properties from Active Directory!\n");


    ReportState();

    return AdsReadQmSecurityDescriptor();

} //CQmResource::AdsReadQmProperties


bool
CQmResource::AddRemoveRegistryCheckpoint(
    DWORD dwControlCode
    ) const

/*++

Routine Description:

    Add or remove registry checkpoint for this QM.
    Convenient wrapper for ClusterResourceControl,
    which does the real work.

Arguments:

    dwControlCode - specifies ADD or REMOVE

Return Value:

    true - The operation was successfull.

    false - The operation failed.

--*/

{
    ASSERT(("must have a valid resource handle", m_hResource != NULL));

    DWORD dwBytesReturned = 0;
    DWORD status = ::ClusterResourceControl(
                         m_hResource,
                         NULL,
                         dwControlCode,
                         const_cast<LPWSTR>(m_wzFalconRegSection),
                         (wcslen(m_wzFalconRegSection) + 1)* sizeof(WCHAR),
                         NULL,
                         0,
                         &dwBytesReturned
                         );

    ReportState();


    if (ERROR_SUCCESS == status)
    {
        return true;
    }
    if (CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT == dwControlCode &&
        ERROR_ALREADY_EXISTS == status)
    {
        return true;
    }

    if (CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT == dwControlCode &&
        ERROR_FILE_NOT_FOUND == status)
    {
        return true;
    }

    SetLastError(status);
    ReportLastError(REGISTRY_CP_ERR, L"Failed to add/remove registry CP", NULL);
    return false;

} //CQmResource::AddRemoveRegistryCheckpoint


bool
CQmResource::AddRemoveCryptoCheckpointsInternal(
    DWORD dwControlCode,
    bool  f128bit
    ) const

/*++

Routine Description:

    Add or remove Crypto checkpoints for this QM.
    We have 2 checkpoints - 40 bit and 128 bit.

Arguments:

    dwControlCode - specifies ADD or REMOVE.

    f128bit - specifies true for 128 bit, false for 40 bit.

Return Value:

    true - The operation was successfull.

    false - The operation failed.

--*/

{
    ASSERT(("must have a valid resource handle", m_hResource != NULL));

    DWORD dwBytesReturned = 0;
    LPCWSTR pwzFullKey = f128bit ? m_wzCrypto128FullKey : m_wzCrypto40FullKey;

    DWORD status = ::ClusterResourceControl(
                         m_hResource,
                         NULL,
                         dwControlCode,
                         const_cast<LPWSTR>(pwzFullKey),
                         (wcslen(pwzFullKey) + 1) * sizeof(WCHAR),
                         NULL,
                         0,
                         &dwBytesReturned
                         );


    ReportState();


    if (status == ERROR_SUCCESS)
    {
        return true;
    }

    if (f128bit)
    {
        if(status == NTE_KEYSET_NOT_DEF || status == NTE_BAD_KEYSET)
        {
            return true;
        }
    }

    if (CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT == dwControlCode &&
        ERROR_ALREADY_EXISTS == status)
    {
        return true;
    }

    if (CLUSCTL_RESOURCE_DELETE_CRYPTO_CHECKPOINT == dwControlCode &&
        ERROR_FILE_NOT_FOUND == status)
    {
        return true;
    }

    SetLastError(status);
    ReportLastError(CRYPTO_CP_ERR, L"Failed to add/remove Crypto CP.", NULL);
    return false;

} //CQmResource::AddRemoveCryptoCheckpointsInternal


bool
CQmResource::AddRemoveCryptoCheckpoints(
    DWORD dwControlCode
    ) const

/*++

Routine Description:

    Add or remove Crypto checkpoints for this QM.
    We have 2 checkpoints - 40 bit and 128 bit.

Arguments:

    dwControlCode - specifies ADD or REMOVE.

Return Value:

    true - The operation was successfull.

    false - The operation failed.

--*/

{
    if (m_dwWorkgroup != 0)
    {
        return true;
    }

    if (!AddRemoveCryptoCheckpointsInternal(dwControlCode, /* f128bit = */false))
    {
        return false;
    }

    return AddRemoveCryptoCheckpointsInternal(dwControlCode, /* f128bit = */true);

} //CQmResource::AddRemoveCryptoCheckpoints


DWORD
CQmResource::BringOnlineFirstTime(
    VOID
    )

/*++

Routine Description:

    Handle operations to perform only on first online
    of this QM resource:
    * create the MSMQ objects in Active Directory
    * query what is the disk drive we depend upon
    * add registry checkpoint

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Bringing online first time.\n");

    //
    // Keep this routine idempotent!
    // Anything could fail and this routine can be called
    // again later. E.g. QM could fail to start.
    //

    DWORD status = ERROR_SUCCESS;

    if (ERROR_SUCCESS != (status = QueryResourceDependencies())  ||

        ERROR_SUCCESS != (status = AdsInit())                    ||

        ERROR_SUCCESS != (status = CreateCaConfiguration())      ||

        ERROR_SUCCESS != (status = AdsCreateComputerObject())    ||

        ERROR_SUCCESS != (status = AdsCreateQmObject())          ||

        ERROR_SUCCESS != (status = AdsCreateQmPublicKeys())      ||

        ERROR_SUCCESS != (status = AdsReadQmProperties()) )
    {
        return status;
    }

    if (!AddRemoveRegistryCheckpoint(CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT))
    {
        return GetLastError();
    }

    //
    // In the case of migrated QM (QM that was upgraded from the old
    // msmq resource type), msmq root path is not necessarily under
    // the root. The correct path should be already in registry.
    //
    WCHAR wzMsmqDir[MAX_PATH] = L"";
    DWORD cbSize = TABLE_SIZE(wzMsmqDir);
    if (!GetFalconKeyValue(MSMQ_ROOT_PATH, wzMsmqDir, &cbSize))
    {
        ZeroMemory(wzMsmqDir, TABLE_SIZE(wzMsmqDir));
        wzMsmqDir[0] = m_wDiskDrive;
        wcscat(wzMsmqDir, L":\\msmq");

        SetFalconKeyValue(MSMQ_ROOT_PATH, REG_SZ, wzMsmqDir,
                          (wcslen(wzMsmqDir) + 1) * sizeof(WCHAR));
    }

    if (m_dwWorkgroup != 0)
    {
        if (m_guidQm == GUID_NULL)
        {
            RPC_STATUS rc = UuidCreate(&m_guidQm);
            DBG_USED(rc);
            ASSERT(("Failed to generate a guid for QM", rc == RPC_S_OK));
        }

        AP<VOID> pDescriptor = 0;
        //
        // Caution:
        // If you change implementatation of MQSec_GetDefaultSecDescriptor
        // to use mqutil's registry routines, you need to lock registry
        // here using CQmResourceRegistry .
        //
        status = pfMQSec_GetDefaultSecDescriptor(
                     MQDS_MACHINE,
                     &pDescriptor,
                     FALSE,  //fImpersonate
                     NULL,
                     0,   // seinfoToRemove
                     e_GrantFullControlToEveryone
                     ) ;
        ASSERT(MQSec_OK == status);

        SetFalconKeyValue(MSMQ_DS_SECURITY_CACHE_REGNAME, REG_BINARY, pDescriptor, GetSecurityDescriptorLength(pDescriptor));
    }
    else
    {
        SetFalconKeyValue(MSMQ_DS_SECURITY_CACHE_REGNAME, REG_BINARY, m_pSd, m_cbSdSize);
    }


    SetFalconKeyValue(MSMQ_QMID_REGNAME, REG_BINARY, &m_guidQm, sizeof(GUID));


    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"All first-online operations completed.\n");

    return ERROR_SUCCESS;

} //CQmResource::BringOnlineFirstTime


VOID
CQmResource::DeleteDirectoryFiles(
    LPCWSTR pwzDir
    ) const

/*++

Routine Description:

    Delete files from a given directory.
    Ignore errors (such as directory not exist,
    read only files, no security to delete).
    Will not delete subdirectories.

Arguments:

    pwzDir - Directory path to delete files from.

Return Value:

    None.

--*/

{
    WCHAR wzFileName[MAX_PATH] = {0};
    wcscpy(wzFileName, pwzDir);
    wcscat(wzFileName, L"*");

    WIN32_FIND_DATA FindData;
    CFindHandle hEnum(FindFirstFile(
                          wzFileName,
                          &FindData
                          ));

    if(INVALID_HANDLE_VALUE == hEnum.operator HANDLE())
    {
        return;
    }

    do
    {
        if (0 == CompareStringsNoCase(FindData.cFileName, L".") ||
            0 == CompareStringsNoCase(FindData.cFileName, L".."))
        {
            continue;
        }

        wcscpy(wzFileName, pwzDir);
        wcscat(wzFileName, FindData.cFileName);

        BOOL success = DeleteFile(wzFileName);

        if (success)
        {
            (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"successfully deleted file '%1'.\n", wzFileName);
        }
        else
        {
            DWORD err = GetLastError();
            (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"failed to delete file '%1', error 0x%2!x!.\n",
                                  wzFileName, err);
        }

    } while(FindNextFile(hEnum, &FindData));

} //CQmResource::DeleteDirectoryFiles


VOID
CQmResource::DeleteMsmqDir(
    VOID
    ) const

/*++

Routine Description:

    Delete LQS and Storage directories.
    Ignore errors. It could be that these
    directories do not exist (QM was never up)
    or user has no security to delete, etc.
    It is not that important, so don't report failure.

Arguments:

    None

Return Value:

    None

--*/

{
    //
    // There are scenarios where it's expected to not find in
    // registry the MSMQ_ROOT_PATH value, e.g. when QM resource
    // is created and then deleted w/o attempt to bring it online
    // (this value is written to registry when bringing the resource
    // online, because only then we query dependencies and find the disk).
    //

    WCHAR wzMsmqDir[MAX_PATH] = {L""};
    WCHAR wzDir[MAX_PATH] = {L""};
    DWORD cbSize = TABLE_SIZE(wzMsmqDir);
    if (GetFalconKeyValue(MSMQ_ROOT_PATH, wzMsmqDir, &cbSize))
    {
        wcscpy(wzDir, wzMsmqDir);
        wcscat(wzDir, L"\\STORAGE\\LQS\\");
        (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Deleting folder '%1'...\n", wzDir);
        DeleteDirectoryFiles(wzDir);
        RemoveDirectory(wzDir);
    }

    cbSize = TABLE_SIZE(wzDir);
    if (GetFalconKeyValue(MSMQ_STORE_RELIABLE_PATH_REGNAME, wzDir, &cbSize))
    {
        wcscat(wzDir, L"\\");
        DeleteDirectoryFiles(wzDir);
        RemoveDirectory(wzDir);
    }

    cbSize = TABLE_SIZE(wzDir);
    if (GetFalconKeyValue(MSMQ_STORE_PERSISTENT_PATH_REGNAME, wzDir, &cbSize))
    {
        wcscat(wzDir, L"\\");
        DeleteDirectoryFiles(wzDir);
        RemoveDirectory(wzDir);
    }

    cbSize = TABLE_SIZE(wzDir);
    if (GetFalconKeyValue(MSMQ_STORE_JOURNAL_PATH_REGNAME, wzDir, &cbSize))
    {
        wcscat(wzDir, L"\\");
        DeleteDirectoryFiles(wzDir);
        RemoveDirectory(wzDir);
    }

    cbSize = TABLE_SIZE(wzDir);
    if (GetFalconKeyValue(MSMQ_STORE_LOG_PATH_REGNAME, wzDir, &cbSize))
    {
        wcscat(wzDir, L"\\");
        DeleteDirectoryFiles(wzDir);
        RemoveDirectory(wzDir);
    }

    if (wcslen(wzMsmqDir) > 0)
    {
        wcscpy(wzDir, wzMsmqDir);
        wcscat(wzDir, L"\\STORAGE\\");
        (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Deleting folder '%1'...\n", wzDir);
        DeleteDirectoryFiles(wzDir);
        RemoveDirectory(wzDir);

        wcscpy(wzDir, wzMsmqDir);
        wcscat(wzDir, L"\\");
        (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Deleting folder '%1'...\n", wzDir);
        RemoveDirectory(wzDir);
    }

} //CQmResource::DeleteMsmqDir


VOID
CQmResource::DeleteMqacFile(
    VOID
    ) const

/*++

Routine Description:

    Delete the binary for this QM's device driver.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (wcslen(m_wzDriverPath) < 1)
    {
        return;
    }

    //
    // Idempotent deletion.
    // There are scenarios inwhich it's expected to fail here, e.g.when
    // resource is created and deleted w/o attempt to bring it online.
    //
    DeleteFile(m_wzDriverPath);

} //CQmResource::DeleteMqacFile


DWORD
CQmResource::CloneMqacFile(
    VOID
    ) const

/*++

Routine Description:

    Create the binary for this QM's device driver.
    We copy mqac.sys (of main QM) to a dedicated file, since
    mqac.sys can not host more than one device driver.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    WCHAR wzMainDriverPath[MAX_PATH] = {0};
    GetSystemDirectory(wzMainDriverPath, TABLE_SIZE(wzMainDriverPath));
    wcscat(wzMainDriverPath, L"\\drivers\\mqac.sys");

    //
    // Idempotent copy
    //
    if (!CopyFile(wzMainDriverPath, m_wzDriverPath, /*bFailIfExists*/FALSE))
    {
        ASSERT(("copy file failed!", 0));

        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"Failed to copy '%1' to '%2'. Error 0x%3!x!.\n",
                              wzMainDriverPath, m_wzDriverPath, GetLastError());

        return GetLastError();
    }

    //
    // Set the file to be read/write.
    // Necessary for later delete/idempotent copy.
    //
    if (!SetFileAttributes(m_wzDriverPath, FILE_ATTRIBUTE_NORMAL))
    {
        ASSERT(("set file attribute failed!", 0));

        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, 
            L"Failed to set attributes of file '%1'. Error 0x%2!x!.\n", m_wzDriverPath, GetLastError());

        return GetLastError();
    }

    ReportState();


    return ERROR_SUCCESS;

} //CQmResource::CloneMqacFile


DWORD
CQmResource::RegisterDriver(
    VOID
    ) const

/*++

Routine Description:

    Create the device driver for this QM.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    //
    // Keep this routine idempotent
    //

    ASSERT(("must have valid handle to SCM", m_hScm != NULL));

    WCHAR buffer[256] = L"";
    LoadString(g_hResourceMod, IDS_DRIVER_DISPLAY_NAME, buffer, TABLE_SIZE(buffer));

    WCHAR wzDisplayName[256] = L"";
    wcscpy(wzDisplayName, buffer);
    wcscat(wzDisplayName, L" (");
    wcsncat(wzDisplayName, m_pwzResourceName, STRLEN(wzDisplayName) - wcslen(buffer) - 5);
    wcscat(wzDisplayName, L")");

    CServiceHandle hDriver(CreateService(
                               m_hScm,
                               m_wzDriverName,
                               wzDisplayName,
                               SERVICE_ALL_ACCESS,
                               SERVICE_KERNEL_DRIVER,
                               SERVICE_DEMAND_START,
                               SERVICE_ERROR_NORMAL,
                               m_wzDriverPath,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL
                               ));
    if (hDriver == NULL &&
        ERROR_SERVICE_EXISTS != GetLastError())
    {
        return ReportLastError(CREATE_SERVICE_ERR, L"Failed to register driver '%1'.", m_wzDriverName);
    }


    ReportState();


    return ERROR_SUCCESS;

} //CQmResource::RegisterDriver


DWORD
CQmResource::RegisterService(
    VOID
    ) const

/*++

Routine Description:

    Create the msmq service for this QM.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    //
    // Register service (idempotent)
    //

    WCHAR buffer[256] = L"";
    LoadString(g_hResourceMod, IDS_SERVICE_DISPLAY_NAME, buffer, TABLE_SIZE(buffer));

    WCHAR wzDisplayName[256] = L"";
    wcscpy(wzDisplayName, buffer);
    wcscat(wzDisplayName, L" (");
    wcsncat(wzDisplayName, m_pwzResourceName, STRLEN(wzDisplayName) - wcslen(buffer) - 5);
    wcscat(wzDisplayName, L")");

    WCHAR wzPath[MAX_PATH] = {0};
    GetSystemDirectory(wzPath, TABLE_SIZE(wzPath));
    wcscat(wzPath, L"\\MQSVC.EXE");

    LPCWSTR x_LANMAN_SERVER_SERVICE            = L"LanmanServer";
    LPCWSTR x_LANMAN_SECURITY_SUPPORT_PROVIDER = L"NtLmSsp";
    LPCWSTR x_RPC_SERVICE                      = L"RPCSS";
    LPCWSTR x_SECURITY_ACCOUNTS_MANAGER        = L"SamSs";

    WCHAR wzDependencies[1024] = {0};
    LPWSTR pDependencies = &wzDependencies[0];

    wcscpy(pDependencies, m_wzDriverName);
    pDependencies += wcslen(m_wzDriverName) + 1;

    wcscpy(pDependencies, x_LANMAN_SERVER_SERVICE);
    pDependencies += wcslen(x_LANMAN_SERVER_SERVICE) + 1;

    wcscpy(pDependencies, x_LANMAN_SECURITY_SUPPORT_PROVIDER);
    pDependencies += wcslen(x_LANMAN_SECURITY_SUPPORT_PROVIDER) + 1;

    wcscpy(pDependencies, x_RPC_SERVICE);
    pDependencies += wcslen(x_RPC_SERVICE) + 1;

    wcscpy(pDependencies, x_SECURITY_ACCOUNTS_MANAGER);
    pDependencies += wcslen(x_SECURITY_ACCOUNTS_MANAGER) + 1;

    wcscpy(pDependencies, L"");

    DWORD dwType = SERVICE_WIN32_OWN_PROCESS;
#ifdef _DEBUG
    dwType |= SERVICE_INTERACTIVE_PROCESS;
#endif

    ASSERT(("must have a valid handle to SCM", m_hScm != NULL));

    CServiceHandle hService(CreateService(
                                m_hScm,
                                m_wzServiceName,
                                wzDisplayName,
                                SERVICE_ALL_ACCESS,
                                dwType,
                                SERVICE_DEMAND_START,
                                SERVICE_ERROR_NORMAL,
                                wzPath,
                                NULL,
                                NULL,
                                wzDependencies,
                                NULL,
                                NULL
                                ));
    if (hService == NULL &&
        ERROR_SERVICE_EXISTS != GetLastError())
    {
        return ReportLastError(CREATE_SERVICE_ERR, L"Failed to register service '%1'.", m_wzServiceName);
    }


    ReportState();


    LoadString(g_hResourceMod, IDS_SERVICE_DESCRIPTION, buffer, TABLE_SIZE(buffer));
    SERVICE_DESCRIPTION sd;
    sd.lpDescription = buffer;
    ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, &sd);

    return ERROR_SUCCESS;

} //CQmResource::RegisterService


DWORD
CQmResource::CreateEventSourceRegistry(
    VOID
    ) const

/*++

Routine Description:

    Create the registry values to support event logging by this QM.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
	WCHAR Filename[MAX_PATH];
	GetSystemDirectory(Filename, TABLE_SIZE(Filename));
	wcscat(Filename, TEXT("\\"));
	wcscat(Filename, MQUTIL_DLL_NAME);

	if (!MqcluspCreateEventSourceRegistry(Filename, m_wzServiceName))
    {
        return GetLastError();
    }

    return ERROR_SUCCESS;

} //CQmResource::CreateEventSourceRegistry


VOID
CQmResource::DeleteEventSourceRegistry(
    VOID
    ) const

/*++

Routine Description:

    Delete the registry values to support event logging by this QM.

Arguments:

    None.

Return Value:

    None.

--*/

{
    WCHAR buffer[255] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\";
    wcscat(buffer, m_wzServiceName);

    RegDeleteKey(HKEY_LOCAL_MACHINE, buffer);

} //CQmResource::DeleteEventSourceRegistry


DWORD
CQmResource::StopService(
    LPCWSTR pwzServiceName
    ) const

/*++

Routine Description:

    Stop a service and block until it's stopped (or timeout).

Arguments:

    pwzServiceName - The service to stop.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    ASSERT(("must have a valid handle to SCM", m_hScm != NULL));

    CServiceHandle hService(OpenService(
                                m_hScm,
                                pwzServiceName,
                                SERVICE_ALL_ACCESS
                                ));
    if (hService == NULL)
    {
        if (ERROR_SERVICE_DOES_NOT_EXIST == GetLastError())
        {
            return ERROR_SUCCESS;
        }

        return ReportLastError(STOP_SERVICE_ERR, L"Failed to open service '%1'.", pwzServiceName);
    }

    SERVICE_STATUS ServiceStatus;
    if (!ControlService(hService, SERVICE_CONTROL_STOP, &ServiceStatus) &&
        ERROR_SERVICE_NOT_ACTIVE != GetLastError() &&
        ERROR_SERVICE_CANNOT_ACCEPT_CTRL != GetLastError() &&
        ERROR_BROKEN_PIPE != GetLastError())
    {
        return ReportLastError(STOP_SERVICE_ERR, L"Failed to stop service '%1'.", pwzServiceName);
    }

    //
    // Wait until service is down (or timeout 5 seconds)
    //
    const DWORD x_TIMEOUT = 1000 * 5;

    DWORD dwWaitTime = 0;
    while (dwWaitTime < x_TIMEOUT)
    {
        if (!QueryServiceStatus(hService, &ServiceStatus))
        {
            return ReportLastError(STOP_SERVICE_ERR, L"Failed to query service '%1'.", pwzServiceName);
        }

        if (ServiceStatus.dwCurrentState == SERVICE_START_PENDING)
        {
            //
            // Service is still start pending from a previous call
            // to start it. So it cannot be stopped. We can do
            // nothing about it. Trying to terminate the process
            // of the service will fail with access denied.
            //
            (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,
                              L"Service '%1' can not be stopped because it is start pending.\n", pwzServiceName);

            return SERVICE_START_PENDING;
        }

        if (ServiceStatus.dwCurrentState != SERVICE_STOP_PENDING)
        {
            break;
        }

        const DWORD x_INTERVAL = 50;
        Sleep(x_INTERVAL);
        dwWaitTime += x_INTERVAL;
    }

    if (SERVICE_STOPPED != ServiceStatus.dwCurrentState)
    {
        //
        // Service failed to stop.
        //
        SetLastError(ServiceStatus.dwCurrentState);
        ReportLastError(STOP_SERVICE_ERR, L"TIMEOUT: Failed to stop service '%1'.", pwzServiceName);
        return ServiceStatus.dwCurrentState;
    }

    return ERROR_SUCCESS;

} //CQmResource::StopService


DWORD
CQmResource::RemoveService(
    LPCWSTR pwzServiceName
    ) const

/*++

Routine Description:

    Stop and delete a service.

Arguments:

    pwzServiceName - The service to stop and delete.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    ASSERT(("must have a valid handle to SCM", m_hScm != NULL));

    //
    // First check if service exists
    //
    CServiceHandle hService(OpenService(
                                m_hScm,
                                pwzServiceName,
                                SERVICE_ALL_ACCESS
                                ));
    if (hService == NULL)
    {
        if (ERROR_SERVICE_DOES_NOT_EXIST == GetLastError())
        {
            return ERROR_SUCCESS;
        }

        return ReportLastError(DELETE_SERVICE_ERR, L"Failed to open service '%1'", pwzServiceName);
    }

    //
    // Service exists. Make sure it is not running.
    //
    DWORD status = StopService(pwzServiceName);
    if (ERROR_SUCCESS != status)
    {
        return status;
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Deleting service '%1'.\n", pwzServiceName);

    if (!DeleteService(hService) &&
        ERROR_SERVICE_MARKED_FOR_DELETE != GetLastError())
    {
        return ReportLastError(DELETE_SERVICE_ERR, L"Failed to delete service '%1'", pwzServiceName);
    }

    return ERROR_SUCCESS;

} //CQmResource::RemoveService


DWORD
CQmResource::SetServiceEnvironment(
    VOID
    ) const

/*++

Routine Description:

    Configure the environment for the msmq service of this QM,
    such that code inside the QM that calls GetComputerName will
    get the name of the cluster virtual server (the network name).

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Setting service environment.\n");

    CEnvironment Environment(ResUtilGetEnvironmentWithNetName(m_hResource));
    if (Environment.operator PBYTE() == NULL)
    {
        return ReportLastError(START_SERVICE_ERR, L"Failed to set environment for service '%1'.",
                               m_wzServiceName);
    }


    //
    // Write the environment block in the service registry
    //

    LPCWSTR x_SERVICES_KEY = L"System\\CurrentControlSet\\Services";

    CAutoCloseRegHandle hServicesKey;
    DWORD status = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                       x_SERVICES_KEY,
                       0,
                       KEY_READ,
                       &hServicesKey
                       );
    if (ERROR_SUCCESS != status)
    {
        WCHAR wzFullKey[255] = {0};
        wcscpy(wzFullKey, L"HKEY_LOCAL_MACHINE\\");
        wcscat(wzFullKey, x_SERVICES_KEY);

        SetLastError(status);
        return ReportLastError(START_SERVICE_ERR, L"Failed to open registry key '%1'.", m_wzServiceName);
    }

    CAutoCloseRegHandle hMyServiceKey;
    status = RegOpenKeyEx(
                 hServicesKey,
                 m_wzServiceName,
                 0,
                 KEY_READ | KEY_WRITE,
                 &hMyServiceKey
                 );
    if (ERROR_SUCCESS != status)
    {
        WCHAR wzFullKey[255] = {0};
        wcscpy(wzFullKey, L"HKEY_LOCAL_MACHINE\\");
        wcscat(wzFullKey, x_SERVICES_KEY);
        wcscat(wzFullKey, L"\\");
        wcscat(wzFullKey, m_wzServiceName);

        SetLastError(status);
        return ReportLastError(START_SERVICE_ERR, L"Failed to open registry key '%1'.", m_wzServiceName);
    }

    //
    // Compute the size of the environment. We are looking for
    // the double NULL terminator that ends the environment block.
    //
    PWCHAR p = Environment;
    while (*p)
    {
        while (*p++) {}
    }
    DWORD size = DWORD_PTR_TO_DWORD(reinterpret_cast<PUCHAR>(p) - Environment.operator PUCHAR()) +
                 sizeof(WCHAR);

    LPCWSTR x_ENVIRONMENT = L"Environment";
    status = RegSetValueEx(
                 hMyServiceKey,
                 x_ENVIRONMENT,
                 0,
                 REG_MULTI_SZ,
                 Environment.operator PBYTE(),
                 size
                 );
    if (ERROR_SUCCESS != status)
    {
        WCHAR wzFullKey[255] = {0};
        wcscpy(wzFullKey, L"HKEY_LOCAL_MACHINE\\");
        wcscat(wzFullKey, x_SERVICES_KEY);
        wcscat(wzFullKey, L"\\");
        wcscat(wzFullKey, m_wzServiceName);
        wcscat(wzFullKey, L"\\");
        wcscat(wzFullKey, x_ENVIRONMENT);

        SetLastError(status);
        return ReportLastError(START_SERVICE_ERR, L"Failed to set registry value '%1'.", m_wzServiceName);
    }

    return ERROR_SUCCESS;

} //CQmResource::SetServiceEnvironment


DWORD
CQmResource::StartService(
    VOID
    ) const

/*++

Routine Description:

    Configure environment for the msmq service of this QM,
    start the service and block until it's up and running.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    ASSERT(("must have a valid handle to SCM", m_hScm != NULL));

    CServiceHandle hService(OpenService(
                                m_hScm,
                                m_wzServiceName,
                                SERVICE_ALL_ACCESS
                                ));
    if (hService == NULL)
    {
        return ReportLastError(START_SERVICE_ERR, L"Failed to open service '%1'.", m_wzServiceName);
    }

    DWORD status = SetServiceEnvironment();
    if (ERROR_SUCCESS != status)
    {
        return status;
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Starting the '%1' service.\n", m_wzServiceName);
    BOOL rc = ::StartService(hService, 0, NULL);


    ReportState();


    //
    // Could take a long time for QM to start.
    // This routine can be called more than once.
    //
    if (!rc &&
        ERROR_SERVICE_ALREADY_RUNNING != GetLastError() &&
        ERROR_SERVICE_CANNOT_ACCEPT_CTRL != GetLastError())
    {
        return ReportLastError(START_SERVICE_ERR, L"Failed to start service '%1'.", m_wzServiceName);
    }

    //
    // Wait until service is up
    //
    MqcluspReportEvent(EVENTLOG_INFORMATION_TYPE, START_SERVICE_OK, 1, m_wzServiceName);
    SERVICE_STATUS ServiceStatus;
    for (;;)
    {
        if (!QueryServiceStatus(hService, &ServiceStatus))
        {
            return ReportLastError(START_SERVICE_ERR, L"Failed to query service '%1'.", m_wzServiceName);
        }


        ReportState();


        if (ServiceStatus.dwCurrentState == SERVICE_START_PENDING)
        {
            Sleep(100);
            continue;
        }

        break;
    }

    if (SERVICE_RUNNING != ServiceStatus.dwCurrentState)
    {
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"Service '%1' failed to start.\n", m_wzServiceName);

        return ERROR_SERVICE_SPECIFIC_ERROR;
    }

    return ERROR_SUCCESS;

} //CQmResource::StartService


DWORD
CQmResource::WaitForDtc(
    VOID
    ) const

/*++

Routine Description:

    Bring online the MSDTC resource and block until it's up.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    IUnknown * punkDtc = 0;

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Waiting on DTC...\n");
    HRESULT hr = DtcGetTransactionManagerEx(
                     NULL,
                     NULL,
                     IID_IUnknown,
                     0,
                     0,
                     reinterpret_cast<LPVOID*>(&punkDtc)
                     );

    ReportState();

    if (FAILED(hr))
    {
        SetLastError(hr);
        return ReportLastError(GET_DTC_ERR, L"DTC fails to run.", NULL);
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"DTC is online!\n");
    return ERROR_SUCCESS;

} //CQmResource::WaitForDtc


DWORD
CQmResource::BringOnline(
    VOID
    )

/*++

Routine Description:

    Handle operations for bringing this QM resource online:
    * create the binary for the device driver for this QM
    * create device driver and msmq service
    * bring MSDTC resource online
    * start the msmq service for this QM and verify it's up

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Bringing online.\n");

    //
    // Keep this routine idempotent!
    // Anything could fail and this routine can be called
    // again later. E.g. QM could fail to start.
    //

    DWORD status = ERROR_SUCCESS;

    if (ERROR_SUCCESS != (status = CloneMqacFile())   ||

        ERROR_SUCCESS != (status = RegisterDriver())  ||

        ERROR_SUCCESS != (status = RegisterService()) ||

        ERROR_SUCCESS != (status = CreateEventSourceRegistry()) ||

        ERROR_SUCCESS != (status = WaitForDtc())      ||

        ERROR_SUCCESS != (status = StartService()) )
    {
        (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Failed to bring online. Error 0x%1!x!.\n",
                              status);

        return status;
    }

    //
    // Adding Crypto checkpoints can be done only after QM is up and
    // running, because the QM creates its Crypto keys.
    //
    if (!AddRemoveCryptoCheckpoints(CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT))
    {
        return GetLastError();
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"resource is online!.\n");

    return ERROR_SUCCESS;

} //CQmResource::BringOnline


BOOL
CQmResource::CheckIsAlive(
    VOID
    ) const

/*++

Routine Description:

    Checks is the QM is up and running.

Arguments:

    None.

Return Value:

    TRUE - The QM is up and running.

    FALSE - The QM is not up and running.

--*/

{

    ASSERT(("must have a valid handle to SCM", m_hScm != NULL));

    CServiceHandle hService(OpenService(
                                m_hScm,
                                m_wzServiceName,
                                SERVICE_ALL_ACCESS
                                ));

    SERVICE_STATUS ServiceStatus;
    BOOL fIsAlive = QueryServiceStatus(hService, &ServiceStatus) &&
                    SERVICE_RUNNING == ServiceStatus.dwCurrentState;

    return fIsAlive;

} //CQmResource::CheckIsAlive


VOID
CQmResource::DeleteNt4Files(
    VOID
    ) const

/*++

Routine Description:

    Delete MSMQ 1.0 (NT4) files from shared disk.
    This routine is called for QM that was upgraded from NT4.

    Ignore errors.

Arguments:

    None

Return Value:

    None.
--*/

{
    CAutoFreeLibrary hLib(LoadLibrary(MQUPGRD_DLL_NAME));
    if (hLib == NULL)
    {
        return;
    }

    CleanupOnCluster_ROUTINE pfCleanupOnCluster = 
        (CleanupOnCluster_ROUTINE)GetProcAddress(hLib, "CleanupOnCluster");

    if (pfCleanupOnCluster == NULL)
    {
        return;
    }

    WCHAR wzMsmqDir[MAX_PATH] = {L""};
    DWORD cbSize = TABLE_SIZE(wzMsmqDir);
    if (GetFalconKeyValue(MSMQ_ROOT_PATH, wzMsmqDir, &cbSize))
    {
        pfCleanupOnCluster(wzMsmqDir);
    }

} //CQmResource::DeleteNt4Files


static
bool
MqcluspIsMainMsmqConfigured(
    VOID
    )

/*++

Routine Description:

    Query if main msmq service running on the node is configured
    for clustering, i.e. is demand start.

Arguments:

    None

Return Value:

    true - Main msmq service is configured for clustering.

    false - Main msmq service is not configured, or a failure accured.

--*/

{
    CServiceHandle hScm(OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS));
    if (hScm == NULL)
    {
        return false;
    }

    CServiceHandle hService(OpenService(hScm, QM_DEFAULT_SERVICE_NAME, SERVICE_ALL_ACCESS));
    if (hService == NULL)
    {
        return false;
    }

    P<QUERY_SERVICE_CONFIG> pqsc = new QUERY_SERVICE_CONFIG;
    DWORD cbSize = sizeof(QUERY_SERVICE_CONFIG);
    DWORD dwBytesNeeded = 0;
    memset(pqsc, 0, cbSize);

    BOOL success = QueryServiceConfig(hService, pqsc, cbSize, &dwBytesNeeded);

    if (!success && ERROR_INSUFFICIENT_BUFFER == GetLastError())
    {
        delete pqsc.detach();

        cbSize = dwBytesNeeded + 1;
        pqsc = reinterpret_cast<LPQUERY_SERVICE_CONFIG>(new BYTE[cbSize]);
        memset(pqsc, 0, cbSize);

        success = QueryServiceConfig(hService, pqsc, cbSize, &dwBytesNeeded);
    }

    if (!success)
    {
        return false;
    }
        
    if (pqsc->dwStartType != SERVICE_DEMAND_START)
    {
        return false;
    }

    return true;

} //MqcluspIsMainMsmqConfigured


static
VOID
MqcluspConfigureMainMsmq(
    VOID
    )

/*++

Routine Description:

    If cluster software was installed on this machine after installation
    of msmq, then the main msmq service needs to be reconfigured to:

    * not depend on msdtc service
    * manual start

    Since this routine deals only with the main msmq service on the
    node, failure is not critical.

Arguments:

    None

Return Value:

    None.
--*/

{
    if (MqcluspIsMainMsmqConfigured())
    {
        //
        // Dont configure more than once.
        //
        return;
    }

    LPCWSTR x_LANMAN_SERVER_SERVICE            = L"LanmanServer";
    LPCWSTR x_LANMAN_SECURITY_SUPPORT_PROVIDER = L"NtLmSsp";
    LPCWSTR x_RPC_SERVICE                      = L"RPCSS";
    LPCWSTR x_SECURITY_ACCOUNTS_MANAGER        = L"SamSs";

    WCHAR wzDependencies[1024] = {0};
    LPWSTR pDependencies = &wzDependencies[0];

    wcscpy(pDependencies, MSMQ_DEFAULT_DRIVER);
    pDependencies += wcslen(MSMQ_DEFAULT_DRIVER) + 1;

    wcscpy(pDependencies, x_LANMAN_SERVER_SERVICE);
    pDependencies += wcslen(x_LANMAN_SERVER_SERVICE) + 1;

    wcscpy(pDependencies, x_LANMAN_SECURITY_SUPPORT_PROVIDER);
    pDependencies += wcslen(x_LANMAN_SECURITY_SUPPORT_PROVIDER) + 1;

    wcscpy(pDependencies, x_RPC_SERVICE);
    pDependencies += wcslen(x_RPC_SERVICE) + 1;

    wcscpy(pDependencies, x_SECURITY_ACCOUNTS_MANAGER);
    pDependencies += wcslen(x_SECURITY_ACCOUNTS_MANAGER) + 1;

    wcscpy(pDependencies, L"");

    CServiceHandle hScm(OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS));
    if (hScm == NULL)
    {
        return;
    }

    CServiceHandle hService(OpenService(hScm, QM_DEFAULT_SERVICE_NAME, SERVICE_ALL_ACCESS));
    if (hService == NULL)
    {
        return;
    }

    ChangeServiceConfig(
        hService,
        SERVICE_NO_CHANGE,
        SERVICE_DEMAND_START,
        SERVICE_NO_CHANGE,
        NULL,
        NULL,
        NULL,
        wzDependencies,
        NULL,
        NULL,
        NULL
        );
} //MqcluspConfigureMainMsmq


DWORD
MqcluspStartup(
    VOID
    )

/*++

Routine Description:

    This routine is called when DLL is registered or loaded.
    Could be called by many threads.
    Do not put complex stuff here (eg calling ADS).
    Do not assume that MSMQ is installed on the node here.

Arguments:

    None

Return Value:

    ERROR_SUCCESS - The operation was successful

    Win32 error code - The operation failed.

--*/

{
    try
    {
        MqcluspConfigureMainMsmq();

        MqcluspRegisterEventSource();
    }
    catch (const CMqclusException&)
    {
        return ERROR_NOT_READY;
    }
    catch (const bad_alloc&)
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);
        return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;

} //MqcluspStartup


RESID
MqcluspOpen(
    LPCWSTR pwzResourceName,
    HKEY hResourceKey,
    RESOURCE_HANDLE hResourceHandle
    )

/*++

Routine Description:

    Create an object to represent a new QM resource and
    return a handle to that object.

Arguments:

    pwzResourceName - Name of this QM resource.

    hResourceKey - Supplies handle to the resource's cluster configuration 
        database key.

    hResourceHandle - report handle for this QM resource.

Return Value:

    NULL - The operation failed.

    Some valid address - the memory offset of this QM object.

--*/

{
    (g_pfLogClusterEvent)(hResourceHandle, LOG_INFORMATION, L"opening resource.\n");

    CQmResource * pqm = NULL;
    try
    {
        pqm = new CQmResource(pwzResourceName, hResourceKey, hResourceHandle);
    }
    catch(const bad_alloc&)
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);

        (g_pfLogClusterEvent)(hResourceHandle, LOG_ERROR, L"No memory (CQmResource construction).\n");
        SetLastError(ERROR_NOT_READY);
        return NULL;
    }
    catch (const CMqclusException&)
    {
        SetLastError(ERROR_NOT_READY);
        return NULL;
    }

    (g_pfLogClusterEvent)(hResourceHandle, LOG_INFORMATION, L"resource was opened successfully.\n");

    return static_cast<RESID>(pqm);

} //MqcluspOpen


DWORD
MqcluspOffline(
    CQmResource * pqm
    )

/*++

Routine Description:

    Brings down this QM resource:
    * stop and remove device driver and msmq service
    * delete the binary for the device driver

    We not only stop the QM, but also undo most of the
    operations done in BringOnline. This way we clean
    the local node before failover to remote node, and
    Delete on the remote node will not leave "garbage"
    on this node.

Arguments:

    pqm - pointer to the CQmResource object

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    try
    {
        pqm->RemoveService(pqm->GetServiceName());

        pqm->RemoveService(pqm->GetDriverName());

        pqm->DeleteMqacFile();

        pqm->DeleteEventSourceRegistry();
    }
    catch (const bad_alloc&)
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);

        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, L"No memory (Offline).\n");

        return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;

} //MqcluspOffline


VOID
MqcluspClose(
    CQmResource * pqm
    )

/*++

Routine Description:

    Delete the QM object. Undo MqcluspOpen.

Arguments:

    pqm - pointer to the CQmResource object

Return Value:

    None.

--*/

{
    (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_INFORMATION, L"Closing resource.\n");

    delete pqm;

} //MqcluspClose


DWORD
MqcluspOnlineThread(
    CQmResource * pqm
    )

/*++

Routine Description:

    This is the thread where stuff happens: bringing
    the resource online.

Arguments:

    pqm - pointer to the CQmResource object

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_INFORMATION, L"Starting online thread.\n");

    try
    {
        pqm->SetState(ClusterResourceOnlinePending);
        pqm->ReportState();

        DWORD status = ERROR_SUCCESS;
        DWORD dwSetupStatus = MSMQ_SETUP_DONE;
        if (pqm->IsFirstOnline(&dwSetupStatus))
        {
            status = pqm->BringOnlineFirstTime();
            if (ERROR_SUCCESS != status)
            {
                pqm->SetState(ClusterResourceFailed);
                pqm->ReportState();

                (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_INFORMATION,
                                      L"Failed to bring online first time. Error 0x%1!x!.\n", status);

                return status;
            }

            if (dwSetupStatus == MSMQ_SETUP_UPGRADE_FROM_NT)
            {
                pqm->DeleteNt4Files();
            }
        }

        status = pqm->BringOnline();
        if (ERROR_SUCCESS != status)
        {
            //
            // We report the resource as failed, so make sure
            // the service and driver are indeed down.
            //
            pqm->StopService(pqm->GetServiceName());
            pqm->StopService(pqm->GetDriverName());

            pqm->SetState(ClusterResourceFailed);
            pqm->ReportState();

            (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_INFORMATION,
                                  L"Failed to bring online. Error 0x%1!x!.\n", status);

            return status;
        }


        pqm->SetState(ClusterResourceOnline);
        pqm->ReportState();
    }
    catch (const bad_alloc&)
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);

        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, L"No memory (online thread).\n");

        return ERROR_OUTOFMEMORY;
    }

    return(ERROR_SUCCESS);

} //MqcluspOnlineThread


BOOL
MqcluspCheckIsAlive(
    CQmResource * pqm
    )

/*++

Routine Description:

    Verify that the msmq service of this QM is up and running.

Arguments:

    pqm - pointer to the CQmResource object

Return Value:

    TRUE - The msmq service for this QM is up and running.

    FALSE - The msmq service for this QM is not up and running.

--*/

{
    try
    {
        return pqm->CheckIsAlive();
    }
    catch (const bad_alloc&)
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, L"No memory (check is alive).\n");
    }

    return false;

} //MqcluspCheckIsAlive


DWORD
MqcluspClusctlResourceGetRequiredDependencies(
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    )
{
    //
    // MSMQ resource depends on a disk and network name.
    // This is common to many resources and the code is
    // taken from cluster tree.
    //

typedef struct _COMMON_DEPEND_DATA {
    CLUSPROP_RESOURCE_CLASS storageEntry;
    CLUSPROP_SZ_DECLARE( networkEntry, sizeof(L"Network Name") / sizeof(WCHAR) );
    CLUSPROP_SYNTAX endmark;
} COMMON_DEPEND_DATA, *PCOMMON_DEPEND_DATA;

typedef struct _COMMON_DEPEND_SETUP {
    DWORD               Offset;
    CLUSPROP_SYNTAX     Syntax;
    DWORD               Length;
    PVOID               Value;
} COMMON_DEPEND_SETUP, * PCOMMON_DEPEND_SETUP;

static COMMON_DEPEND_SETUP CommonDependSetup[] = {
    { FIELD_OFFSET(COMMON_DEPEND_DATA, storageEntry), CLUSPROP_SYNTAX_RESCLASS, sizeof(CLUSTER_RESOURCE_CLASS), (PVOID)CLUS_RESCLASS_STORAGE },
    { FIELD_OFFSET(COMMON_DEPEND_DATA, networkEntry), CLUSPROP_SYNTAX_NAME, sizeof(L"Network Name"), L"Network Name" },
    { 0, 0 }
};

    try
    {
        PCOMMON_DEPEND_SETUP pdepsetup = CommonDependSetup;
        PCOMMON_DEPEND_DATA pdepdata = (PCOMMON_DEPEND_DATA)OutBuffer;
        CLUSPROP_BUFFER_HELPER value;

        *BytesReturned = sizeof(COMMON_DEPEND_DATA);
        if ( OutBufferSize < sizeof(COMMON_DEPEND_DATA) )
        {
            if ( OutBuffer == NULL )
            {
                return ERROR_SUCCESS;
            }

            return ERROR_MORE_DATA;
        }
        ZeroMemory( OutBuffer, sizeof(COMMON_DEPEND_DATA) );

        while ( pdepsetup->Syntax.dw != 0 )
        {
            value.pb = (PUCHAR)OutBuffer + pdepsetup->Offset;
            value.pValue->Syntax.dw = pdepsetup->Syntax.dw;
            value.pValue->cbLength = pdepsetup->Length;

            switch ( pdepsetup->Syntax.wFormat )
            {
            case CLUSPROP_FORMAT_DWORD:
                value.pDwordValue->dw = (DWORD) DWORD_PTR_TO_DWORD(pdepsetup->Value); //safe cast, the value is known to be a DWORD constant
                break;

            case CLUSPROP_FORMAT_SZ:
                memcpy( value.pBinaryValue->rgb, pdepsetup->Value, pdepsetup->Length );
                break;

            default:
                break;
            }
            pdepsetup++;
        }
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;
    }
    catch (const bad_alloc&)
    {
        return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;

} //MqcluspClusctlResourceGetRequiredDependencies


DWORD
MqcluspClusctlResourceSetName(
    VOID
    )
{
    //
    // Refuse to rename the resource
    //
    return ERROR_CALL_NOT_IMPLEMENTED;

} //MqcluspClusctlResourceSetName


DWORD
MqcluspClusctlResourceDelete(
    CQmResource * pqm
    )
{
    (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_INFORMATION, L"Deleting resource.\n");

    try
    {
        pqm->RemoveService(pqm->GetServiceName());

        pqm->RemoveService(pqm->GetDriverName());

        pqm->DeleteMqacFile();

        pqm->DeleteMsmqDir();

        pqm->AdsDeleteQmObject();

        pqm->AddRemoveRegistryCheckpoint(CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT);

        pqm->AddRemoveCryptoCheckpoints(CLUSCTL_RESOURCE_DELETE_CRYPTO_CHECKPOINT);

        pqm->DeleteFalconRegSection();
    }
    catch (const bad_alloc&)
    {
        MqcluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, L"No memory (resource delete).\n");

        return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;

} //MqcluspClusctlResourceDelete


DWORD
MqcluspClusctlResourceTypeGetRequiredDependencies(
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    )
{
    return MqcluspClusctlResourceGetRequiredDependencies(OutBuffer, OutBufferSize, BytesReturned);

} // MqcluspClusctlResourceTypeGetRequiredDependencies


DWORD
MqcluspClusctlResourceTypeStartingPhase2(
    VOID
    )
{
    //
    // Delete old msmq resource type. Ignore failures. 
    // This call will fail if there is a resource of this type, this is handled elsewhere.
    //
    DeleteClusterResourceType(OpenCluster(NULL), L"Microsoft Message Queue Server");

    return ERROR_SUCCESS;

} // MqcluspClusctlResourceTypeStartingPhase2


void LogMsgHR(HRESULT, LPWSTR, USHORT)
{
    //
    // Temporary. Null implementation for this callback so that we can link
    // with ad.lib. (ShaiK, 15-Jun-2000)
    //
    NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\cluster\mqclus\mqclus.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    mqclus.cpp

Abstract:

    Resource DLL for MSMQ

Author:

    Shai Kariv (shaik) Jan 12, 1999

Revision History:

--*/


#include "stdh.h"
#include <uniansi.h>

#include "clusres.h"
#include "mqclusp.h"
#include "_mqres.h"

//
// Get the handle to the resource only DLL first, i.e. mqutil.dll
//
HMODULE	g_hResourceMod = MQGetResourceHandle();


// Cluster Event Logging routine.

PLOG_EVENT_ROUTINE g_pfLogClusterEvent = NULL;

// Resource Status routine for pending Online and Offline calls.

PSET_RESOURCE_STATUS_ROUTINE g_pfSetResourceStatus = NULL;






//
// MSMQ resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
MqclusResourcePrivateProperties[] = 
{
    { 0 }
};


BOOLEAN
WINAPI
DllMain(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       /*Reserved*/
    )

/*++

Routine Description:

    Main DLL entry point.

Arguments:

    DllHandle - DLL instance handle.

    Reason - Reason for being called.

    Reserved - Reserved argument.

Return Value:

    TRUE - Success.

    FALSE - Failure.

--*/

{
    switch( Reason ) 
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls( DllHandle );
            break;
            
        case DLL_PROCESS_DETACH:
            break;
    }

	return TRUE;


} // DllMain


DWORD
WINAPI
Startup(
    IN LPCWSTR pwzResourceType,
    IN DWORD dwMinVersionSupported,
    IN DWORD dwMaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE pfSetResourceStatus,
    IN PLOG_EVENT_ROUTINE pfLogClusterEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup the resource DLL. This routine verifies that at least one
    currently supported version of the resource DLL is between
    MinVersionSupported and MaxVersionSupported. If not, then the resource
    DLL should return ERROR_REVISION_MISMATCH.

    If more than one version of the resource DLL interface is supported by
    the resource DLL, then the highest version (up to MaxVersionSupported)
    should be returned as the resource DLL's interface. If the returned
    version is not within range, then startup fails.

    The ResourceType is passed in so that if the resource DLL supports more
    than one ResourceType, it can pass back the correct function table
    associated with the ResourceType.

Arguments:

    pwzResourceType - The type of resource requesting a function table.

    dwMinVersionSupported - The minimum resource DLL interface version 
        supported by the cluster software.

    dwMaxVersionSupported - The maximum resource DLL interface version
        supported by the cluster software.

    pfSetResourceStatus - Pointer to a routine that the resource DLL should 
        call to update the state of a resource after the Online or Offline 
        routine returns a status of ERROR_IO_PENDING.

    pfLogClusterEvent - Pointer to a routine that handles the reporting of events 
        from the resource DLL. 

    FunctionTable - Returns a pointer to the function table defined for the
        version of the resource DLL interface returned by the resource DLL.

Return Value:

    ERROR_SUCCESS - The operation was successful.

    ERROR_MOD_NOT_FOUND - The resource type is unknown by this DLL.

    ERROR_REVISION_MISMATCH - The version of the cluster service doesn't
        match the versrion of the DLL.

    Win32 error code - The operation failed.

--*/

{
    if ( (dwMinVersionSupported > CLRES_VERSION_V1_00) ||
         (dwMaxVersionSupported < CLRES_VERSION_V1_00) ) 
    {
        return(ERROR_REVISION_MISMATCH);
    }

    if ( 0 != CompareStringsNoCase( pwzResourceType, L"MSMQ" ) ) 
    {
        return(ERROR_MOD_NOT_FOUND);
    }

    if ( g_pfLogClusterEvent == NULL) 
    {
        g_pfLogClusterEvent = pfLogClusterEvent;
        g_pfSetResourceStatus = pfSetResourceStatus;
    }

    *FunctionTable = &g_MqclusFunctionTable;

    return MqcluspStartup();

} // Startup


RESID
WINAPI
MqclusOpen(
    IN LPCWSTR pwzResourceName,
    IN HKEY hResourceKey,
    IN RESOURCE_HANDLE hResourceHandle
    )

/*++

Routine Description:

    Open routine for MSMQ resources.

    Open the specified resource (create an instance of the resource). 
    Allocate all structures necessary to bring the specified resource 
    online.

Arguments:

    pwzResourceName - Supplies the name of the resource to open.

    hResourceKey - Supplies handle to the resource's cluster configuration 
        database key.

    hResourceHandle - A handle that is passed back to the resource monitor 
        when the SetResourceStatus or LogClusterEvent method is called. See the 
        description of the SetResourceStatus and LogClusterEvent methods on the
        MqclusStatup routine. This handle should never be closed or used
        for any purpose other than passing it as an argument back to the
        Resource Monitor in the SetResourceStatus or LogClusterEvent callback.

Return Value:

    RESID of created resource.

    NULL on failure.

--*/

{
    return MqcluspOpen(pwzResourceName, hResourceKey, hResourceHandle);

} // MqclusOpen



VOID
WINAPI
MqclusClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for MSMQ resources.

    Close the specified resource and deallocate all structures, etc.,
    allocated in the Open call. If the resource is not in the offline state,
    then the resource should be taken offline (by calling Terminate) before
    the close operation is performed.

Arguments:

    ResourceId - Supplies the RESID of the resource to close.

Return Value:

    None.

--*/

{
    CQmResource * pqm = static_cast<CQmResource*>(ResourceId);

    if ( pqm == NULL ) 
    {
        return;
    }

    if ( ResourceId != pqm->GetResId() )
    {
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, 
                              L"Close sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return;
    }

    //
    // Deallocate resource entry
    //
    MqcluspClose(pqm);

} // MqclusClose



DWORD
WINAPI
MqclusOnlineThread(
    PCLUS_WORKER /*WorkerPtr*/,
    IN CQmResource * pqm
    )

/*++

Routine Description:

    Worker function which brings a resource from the resource table online.
    This function is executed in a separate thread.

Arguments:

    WorkerPtr - Supplies the worker structure

    pqm - A pointer to the MQCLUS_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS - The operation completed successfully.
    
    Win32 error code - The operation failed.

--*/

{
    return MqcluspOnlineThread(pqm);

} // MqclusOnlineThread



DWORD
WINAPI
MqclusOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE /*phEventHandle*/
    )

/*++

Routine Description:

    Online routine for MSMQ resources.

    Bring the specified resource online (available for use). The resource
    DLL should attempt to arbitrate for the resource if it is present on a
    shared medium, like a shared SCSI bus.

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        online (available for use).

    phEventHandle - Returns a signalable handle that is signaled when the 
        resource DLL detects a failure on the resource. This argument is 
        NULL on input, and the resource DLL returns NULL if asynchronous 
        notification of failures is not supported, otherwise this must be 
        the address of a handle that is signaled on resource failures.

Return Value:

    ERROR_SUCCESS - The operation was successful, and the resource is now 
        online.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_RESOURCE_NOT_AVAILABLE - If the resource was arbitrated with some 
        other systems and one of the other systems won the arbitration.

    ERROR_IO_PENDING - The request is pending, a thread has been activated 
        to process the online request. The thread that is processing the 
        online request will periodically report status by calling the 
        SetResourceStatus callback method, until the resource is placed into 
        the ClusterResourceOnline state (or the resource monitor decides to 
        timeout the online request and Terminate the resource. This pending 
        timeout value is settable and has a default value of 3 minutes.).

    Win32 error code - The operation failed.

--*/

{
    CQmResource * pqm = static_cast<CQmResource*>(ResourceId);

    if ( pqm == NULL ) 
    {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( ResourceId != pqm->GetResId()) 
    {
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, 
                              L"Online sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    pqm->SetState(ClusterResourceFailed);
    ClusWorkerTerminate( &pqm->m_OnlineThread );
    DWORD status = ClusWorkerCreate( 
                       &pqm->m_OnlineThread,
                       reinterpret_cast<PWORKER_START_ROUTINE>(MqclusOnlineThread),
                       pqm
                       );
    if ( status != ERROR_SUCCESS ) 
    {
        pqm->SetState(ClusterResourceFailed);
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, 
                              L"Failed to create the online thread. Error 0x%1!x!.\n", status);
    } 
    else 
    {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // MqclusOnline



VOID
WINAPI
MqclusTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for MSMQ resources.

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        offline.

Return Value:

    None.

--*/

{
    CQmResource * pqm = static_cast<CQmResource*>(ResourceId);

    if ( pqm == NULL ) 
    {
        return;
    }

    if ( ResourceId != pqm->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, 
                              L"Terminate sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return;
    }

    //
    // Terminate the resource.
    //
    // Kill off any pending threads.
    //
    ClusWorkerTerminate( &pqm->m_OnlineThread );

    //
    // SCM does not provide any way to kill a service immediately.
    // Even trying to query the service for its process ID and then 
    // terminating the process will fail with access denied.
    // So we will stop the service gracefully by calling Offline.
    //
    MqcluspOffline(pqm);
    pqm->SetState(ClusterResourceOffline);

} // MqclusTerminate



DWORD
WINAPI
MqclusOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for MSMQ resources.

    Take the specified resource offline gracefully (unavailable for use).  
    Wait for any cleanup operations to complete before returning.

Arguments:

    ResourceId - Supplies the resource id for the resource to be shutdown 
        gracefully.

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is 
        offline.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_IO_PENDING - The request is still pending, a thread has been 
        activated to process the offline request. The thread that is 
        processing the offline will periodically report status by calling 
        the SetResourceStatus callback method, until the resource is placed 
        into the ClusterResourceOffline state (or the resource monitor decides 
        to timeout the offline request and Terminate the resource).
    
    Win32 error code - Will cause the resource monitor to log an event and 
        call the Terminate routine.

--*/

{
    CQmResource * pqm = static_cast<CQmResource*>(ResourceId);

    if ( pqm == NULL ) 
    {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( ResourceId != pqm->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, 
                              L"Offline sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    return MqcluspOffline(pqm);

} // MqclusOffline



BOOL
MqclusCheckIsAlive(
    IN CQmResource * pqm
    )

/*++

Routine Description:

    Check to see if the resource is alive for MSMQ resources.

Arguments:

    pqm - Supplies the resource entry for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    //
    // Check to see if the resource is alive.
    //
    // TODO: Add code to determine if your resource is alive.
    //
    return MqcluspCheckIsAlive(pqm);

} // MqclusCheckIsAlive



BOOL
WINAPI
MqclusIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for MSMQ resources.

    Perform a thorough check to determine if the specified resource is online
    (available for use). This call should not block for more than 400 ms,
    preferably less than 100 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    CQmResource * pqm = static_cast<CQmResource*>(ResourceId);

    if ( pqm == NULL ) 
    {
        return(FALSE);
    }

    if ( ResourceId != pqm->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, 
                              L"IsAlive sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(FALSE);
    }

    return(MqclusCheckIsAlive( pqm ));

} // MqclusIsAlive



BOOL
WINAPI
MqclusLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for MSMQ resources.

    Perform a quick check to determine if the specified resource is probably
    online (available for use).  This call should not block for more than
    300 ms, preferably less than 50 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is probably online and available for use.

    FALSE - The specified resource is not functioning normally.

--*/

{
    CQmResource * pqm = static_cast<CQmResource*>(ResourceId);

    if ( pqm == NULL ) 
    {
        return(FALSE);
    }

    if ( ResourceId != pqm->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, 
                              L"LooksAlive sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(FALSE);
    }

    // TODO: LooksAlive code

    // NOTE: LooksAlive should be a quick check to see if the resource is
    // available or not, whereas IsAlive should be a thorough check.  If
    // there are no differences between a quick check and a thorough check,
    // IsAlive can be called for LooksAlive, as it is below.  However, if there
    // are differences, replace the call to IsAlive below with your quick
    // check code.

    return MqclusCheckIsAlive(pqm);

} // MqclusLooksAlive



DWORD
WINAPI
MqclusResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID /*InBuffer*/,
    IN DWORD /*InBufferSize*/,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for MSMQ resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    CQmResource * pqm = static_cast<CQmResource*>(ResourceId);

    if ( pqm == NULL ) 
    {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( ResourceId != pqm->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pqm->GetReportHandle(), LOG_ERROR, 
                              L"ResourceControl sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    DWORD status = ERROR_SUCCESS;
    *BytesReturned = 0;
    ZeroMemory(OutBuffer, OutBufferSize);
    switch ( ControlCode ) 
    {

        case CLUSCTL_RESOURCE_UNKNOWN:
        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            status = MqcluspClusctlResourceGetRequiredDependencies(OutBuffer, OutBufferSize, 
                                                                   BytesReturned);
            break;

        case CLUSCTL_RESOURCE_SET_NAME:
            status = MqcluspClusctlResourceSetName();
            break;

        case CLUSCTL_RESOURCE_DELETE:
            status = MqcluspClusctlResourceDelete(pqm);
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // MqclusResourceControl


DWORD
WINAPI
MqclusResourceTypeControl(
    IN LPCWSTR  pResourceTypeName,
    IN DWORD    ControlCode,
    IN PVOID    /*InBuffer*/,
    IN DWORD    /*InBufferSize*/,
    OUT PVOID   OutBuffer,
    IN DWORD    OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for MSMQ resources.

    Perform the control request specified by ControlCode on the specified
    resource type.

Arguments:

    pResourceTypeName - Supplies the type name of the specific resource type.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_TYPE_NOT_FOUND - pResourceTypeName is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    if (0 != CompareStringsNoCase(pResourceTypeName, L"MSMQ")) 
    {
        return ERROR_RESOURCE_TYPE_NOT_FOUND;
    }

    DWORD status = ERROR_SUCCESS;
    *BytesReturned = 0;
    ZeroMemory(OutBuffer, OutBufferSize);
    switch ( ControlCode ) 
    {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_TYPE_VALIDATE_PRIVATE_PROPERTIES:
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            status = MqcluspClusctlResourceTypeGetRequiredDependencies(OutBuffer, OutBufferSize, 
                                                                   BytesReturned);
            break;

        case CLUSCTL_RESOURCE_TYPE_STARTING_PHASE2:
            status = MqcluspClusctlResourceTypeStartingPhase2();
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // MqclusResourceTypeControl


//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( g_MqclusFunctionTable,     // Name
                         CLRES_VERSION_V1_00,         // Version
                         Mqclus,                    // Prefix
                         NULL,                        // Arbitrate
                         NULL,                        // Release
                         MqclusResourceControl,     // ResControl
                         MqclusResourceTypeControl);// ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\cluster\apps\start\start.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    start.cpp

Abstract:

    Implementation of mqstart.exe utility.

    This utility starts the main msmq service running
    on a cluster node, after waiting for DTC resource
    to come online.

    Usage: configure the generic NT service SrvAny
    (from NT resource kit) to run mqstart:
    * install srvany as a service (MyService)
    * configure MyService to autostart as LocalSystem
    * configure MyService to run mqstart.exe
    * configure Recovery for MyService (same as ClusSvc)

    Note: Since this app is invoked by a service, do not
    add code that interacts with desktop.
    
Author:

    Shai Kariv (shaik)   Aug 29, 1999.

Revision History:

--*/


#include <_stdh.h>
#include <stdio.h>
#include <_mqini.h>
#include <mqtempl.h>
#include <autorel2.h>
#include <xolehlp.h>


void __cdecl main(int /*argc*/, char ** /*argv*/)
{
    R<IUnknown> punkDtc = 0;
    HRESULT hr = DtcGetTransactionManagerEx(
                     NULL,
                     NULL,
                     IID_IUnknown,
                     0,
                     0,
                     reinterpret_cast<LPVOID*>(&punkDtc)
                     );
    if (FAILED(hr))
    {
        exit(1);
    }

    CServiceHandle hScm(OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS));
    if (hScm == NULL)
    {
        exit(1);
    }

    CServiceHandle hService(OpenService(hScm, QM_DEFAULT_SERVICE_NAME, SERVICE_ALL_ACCESS));
    if (hService == NULL)
    {
        exit(1);
    }

    BOOL success = StartService(hService, 0, NULL);
    if (!success && 
        ERROR_SERVICE_ALREADY_RUNNING != GetLastError())
    {
        exit(1);
    }
} // main
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\cluster\mqclus\stdh.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    stdh.cpp

Abstract:

    Creates the PCH

Author:

    Shai Kariv (shaik) Jan 12, 1999

Revision History:

--*/

#include "stdh.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\cluster\mqclus\stdh.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    Main header file

Author:

    Shai Kariv (shaik) Jan 12, 1999

Revision History:

--*/

#ifndef _MQCLUS_STDH_H_
#define _MQCLUS_STDH_H_

#include <_stdh.h>
#include <mqtempl.h>

#include <clusapi.h>
#include <resapi.h>
#include <stdio.h>

#endif //_MQCLUS_STDH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\apps\xacttest\xtest\xtest.cpp ===
// General sequential test for Falcon/SQL Transactions

#define DBNTWIN32
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <time.h>

#define INITGUID
#include <txdtc.h>
#include <xolehlp.h>
#include "initguid.h"
//#include <OLECTLID.H>
#include <olectl.h>

#include <sqlfront.h>
#include <sqldb.h>

#include <mq.h>
#include "async.h"

#define RECOVERY_TIME 3000

#include "..\common.cpp"

#define ENTER(t)  t -= GetTickCount()
#define LEAVE(t)  t += GetTickCount()
#define PRINT(n,t) printf("%10s %10d %3d\n", n, t,  t*100/ulTimeTotal)

#define MSDTC_PROXY_DLL_NAME   TEXT("xolehlp.dll")    // Name of the DTC helper proxy DLL

//This API should be used to obtain an IUnknown or a ITransactionDispenser
//interface from the Microsoft Distributed Transaction Coordinator's proxy.
//Typically, a NULL is passed for the host name and the TM Name. In which
//case the MS DTC on the same host is contacted and the interface provided
//for it.
typedef HRESULT (STDAPIVCALLTYPE * LPFNDtcGetTransactionManager) (
                                             LPSTR  pszHost,
                                             LPSTR  pszTmName,
                                    /* in */ REFIID rid,
                                    /* in */ DWORD  i_grfOptions,
                                    /* in */ void FAR * i_pvConfigParams,
                                    /*out */ void** ppvObject ) ;

// In order to use InProc RT Stub RM one must add RT_XACT_STUB to preprocessor definitions

//-------------------------------------
// Global data - read only from threads
//-------------------------------------

ULONG      seed = 0, 
           ulPrevious = 0, 
           nTries = 1000, 
           nBurst = 1,
           nThreads = 1,
           nMaxSleep = 20, 
           nMaxTimeQueue = 0,
           nMaxTimeLive = 0, 
           nAbortChances = 50,  
           nAcking = 0, 
           nSync = 1, 
           nSize = 100,
           nListing = 0;
LPSTR      pszQueue = "alexdad3\\q1", 
           pszAdminQueue = "alexdad3\\q1admin", 
           pszTable = "table6",
           pszMode = "ts",
           pszServer = "";
BOOL       fTransactions,  fSend, fReceive, fEnlist, fUpdate,  fGlobalCommit, fDeadLetter, fJournal,
           fUncoordinated, fStub, fExpress, fInternal, fViper, fXA, fImmediate, fDirect,
           fAuthenticate, fBoundaries;
HANDLE     hQueueR, hQueueS;

DWORD      dwFormatNameLength = 100;
WCHAR      wszPathName[100];
WCHAR      wszFmtName[100];

ULONG	         nActiveThreads = 0; // counter of live ones
CRITICAL_SECTION crCounter;          // protects nActiveThreads

ULONG      g_cOrderViols = 0;

//-----------------------------------------
// Auxiliary routine: prints mode
//-----------------------------------------
void PrintMode(BOOL fTransactions, 
               BOOL fSend, 
               BOOL fReceive, 
               BOOL fEnlist, 
               BOOL fUpdate, 
               BOOL fGlobalCommit, 
               BOOL fUncoordinated,
               BOOL fStub,
               BOOL fExpress,
               BOOL fInternal,
               BOOL fViper,
               BOOL fXA,
			   BOOL fDirect,
               ULONG iTTRQ,
               ULONG iTTBR,
               ULONG iSize,
               BOOL  fImmediate,
               BOOL  fDeadLetter,
               BOOL  fJournal,
               BOOL  fAuthenticate,
               BOOL  fBoundaries)
{
    printf("\nMode: ");
    if (fTransactions)
        printf("Transactions ");
    if (fSend)
        printf("Send ");
    if (fReceive)
        printf("Receive ");
    if (fEnlist)
        printf("Enlist ");
    if (fUpdate)
        printf("Update ");
    if (fStub)
        printf("Stub ");
    if (fGlobalCommit)
        printf("GlobalCommit ");
    if (fUncoordinated)
        printf("Uncoordinated ");
    if (fExpress)
        printf("Express ");
    if (fDeadLetter)
        printf("DeadLetter ");
    if (fJournal)
        printf("Journal ");
    if (fAuthenticate)
        printf("Authenticated ");
    if (fBoundaries)
        printf("Boundaries ");
    if (fViper)
        printf("Viper ");
    if (fImmediate)
        printf("No wait ");
    if (fXA)
        printf("XA ");
	if (fDirect)
		printf("Direct ");
    if (fInternal)
        printf("Internal ");
    if (iTTRQ)
        printf("TimeToReachQueue=%d, ",iTTRQ);
    if (iTTBR)
        printf("TimeToBeReceived=%d, ", iTTBR);
    if (iSize)
        printf("BodySize=%d, ",iSize);
    printf("\n");
}

//------------------------------------
// Cycle of xactions
//------------------------------------
void XactFlow(void *pv)
{
    int indThread = (int)pv;
	ITransaction *pTrans;
    HRESULT       hr;

    MQMSGPROPS MsgProps;
    MSGPROPID PropId[20];
    MQPROPVARIANT PropVar[20];
    HRESULT Result[20];


    // Time counters for separate steps
    ULONG  ulTimeBegin = 0,
           ulTimeSend = 0,
           ulTimeReceive = 0,
           ulTimeEnlist = 0,
           ulTimeUpdate = 0,
           ulTimeStub = 0,
           ulTimeCommit = 0,
           ulTimeRelease = 0,
           ulTimeSleep = 0,
           ulTimeTotal;

    if (fUpdate)
    {
        DbSql(0, "SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED");
    }
    

	//--------------------
	// start global transaction
	//--------------------
    if (fTransactions && fGlobalCommit && !fUncoordinated)
    {
		if (fInternal)
        {
            hr = MQBeginTransaction(&pTrans);
        }
        else
        {
            hr = BeginTransaction(&pTrans, nSync);
        }
		if (FAILED(hr))
		{
			printf(" (%d) BeginTransaction Failed: %x\n", indThread,hr);
			exit(1);
		}
		
		if (nListing)
			printf(" (%d) Xact Begin\n ", indThread);

        //--------------------
		// Enlist SQL
		//--------------------
        if (fEnlist)
        {
            if (!DbEnlist(0, pTrans))
            {
                printf(" (%d) Enlist failed\n", indThread);
            }
		    else if (nListing)
			    printf(" (%d) Enlisted\n ", indThread);
            }

    }
    else
        pTrans = NULL;



	// Cycle
    ULONG  nStep = (nTries > 10 ? nTries / 10 : 1);
    

	for (ULONG i=0; i<nTries; i++)
	{
        if (indThread == 0 && i % nStep == 0)
            printf("Step %d\n",i);

        if (!fGlobalCommit)
            pTrans = NULL;
        
        //--------------------
		// start transaction
		//--------------------
        ENTER(ulTimeBegin);

        if (fTransactions && !fGlobalCommit || fUncoordinated)
        {
            if (fUncoordinated)
            {
                pTrans = MQ_SINGLE_MESSAGE;
            }
            else if (fViper)
            {
                pTrans = MQ_MTS_TRANSACTION;
            }
            else if (fXA)
            {
                pTrans = MQ_XA_TRANSACTION;
            }
            else
            {
		        if (fInternal)
                {
                    hr = MQBeginTransaction(&pTrans);
                }
                else
                {
                    hr = BeginTransaction(&pTrans, nSync);
                }
		        if (FAILED(hr))
		        {
			        printf(" (%d) BeginTransaction Failed: %x\n", indThread, hr);
			        Sleep(RECOVERY_TIME);
			        continue;
		        }
		        
		        if (nListing)
			        printf(" (%d) Xact %d : ",  indThread, i+1);
            }
        }

        LEAVE(ulTimeBegin);
        //--------------------
		// Send
		//--------------------
        ENTER(ulTimeSend);

        if (fSend)
        {
            for (ULONG iBurst = 0; iBurst < nBurst; iBurst++)
            {
                //--------------------
	    	    // set message properties 
		        //--------------------
		        MsgProps.aPropID = PropId;
		        MsgProps.aPropVar= PropVar;
		        MsgProps.aStatus = Result;

		        MsgProps.cProp   = 11;

	            // Init values for msg props
		        WCHAR  wszLabel[100];
		        wsprintf(wszLabel, L"Label%d", i+1);

		        //  0:Body
		        WCHAR  wszBody[20000];
		        wsprintf(wszBody, L"Body %d", i+1);
                PropId[0]             = PROPID_M_BODY; 
		        PropVar[0].vt         = VT_VECTOR | VT_UI1;
                PropVar[0].caub.cElems = nSize;
    	        PropVar[0].caub.pElems = (unsigned char *)wszBody;

	            // 1: PROPID_M_LABEL
                PropId[1]     = PROPID_M_LABEL;
		        PropVar[1].vt = VT_LPWSTR;
		        PropVar[1].pwszVal = wszLabel;

		        // 2: PROPID_M_PRIORITY,
                PropId[2]       = PROPID_M_PRIORITY;
		        PropVar[2].vt   = VT_UI1;
		        PropVar[2].ulVal= 0;

		        // 3: PROPID_M_TIMETOREACHQUEUE,
                ULONG ulTimeQ= (nMaxTimeQueue == 0 ? LONG_LIVED : nMaxTimeQueue);
                PropId[3]       = PROPID_M_TIME_TO_REACH_QUEUE;
		        PropVar[3].vt   = VT_UI4;
		        PropVar[3].ulVal= ulTimeQ;

		        // 4: PROPID_M_TIMETOLIVE
                ULONG ulTimeL= (nMaxTimeLive == 0 ? INFINITE : nMaxTimeLive);
                PropId[4]       = PROPID_M_TIME_TO_BE_RECEIVED;
		        PropVar[4].vt   = VT_UI4;
                PropVar[4].ulVal= ulTimeL;

		        // 5: PROPID_M_ACKNOWLEDGE,
                PropId[5]       = PROPID_M_ACKNOWLEDGE;
		        PropVar[5].vt   = VT_UI1;
		        PropVar[5].bVal = (UCHAR)nAcking;

	            // 6: PROPID_M_ADMIN_QUEUE
                PropId[6]     = PROPID_M_ADMIN_QUEUE;
		        PropVar[6].vt = VT_LPWSTR;
		        PropVar[6].pwszVal = wszFmtName;

		        // 7: PROPID_M_DELIVERY
                PropId[7]       = PROPID_M_DELIVERY;
		        PropVar[7].vt   = VT_UI1;
                PropVar[7].bVal = (fExpress ?  MQMSG_DELIVERY_EXPRESS : MQMSG_DELIVERY_RECOVERABLE);

		        // 8: PROPID_M_APPSPECIFIC
                PropId[8]        = PROPID_M_APPSPECIFIC;
		        PropVar[8].vt    = VT_UI4;
		        PropVar[8].ulVal = i+1;

		        // 9: PROPID_M_JOURNAL     
                PropId[9]       = PROPID_M_JOURNAL;
		        PropVar[9].vt   = VT_UI1;
                PropVar[9].bVal = (fDeadLetter ? MQMSG_DEADLETTER : MQMSG_JOURNAL_NONE);

                if (fJournal) 
                {
                    PropVar[9].bVal |= MQMSG_JOURNAL;
                }

		        // 10: PROPID_M_AUTHENTICATED
                PropId[10]       = PROPID_M_AUTHENTICATED;
		        PropVar[10].vt   = VT_UI1;
                PropVar[10].bVal = (fAuthenticate ? 1 : 0);



		        hr = Send(hQueueS, pTrans, &MsgProps);
		        if (FAILED(hr))
		        {
			        printf(" (%d) MQSendMessage Failed: %x\n",  indThread,hr);
			        Sleep(RECOVERY_TIME);
			    } 
                else if (nListing)
			        printf(" (%d) Sent  ", indThread);
            }
        }

        LEAVE(ulTimeSend);
        //--------------------
		// Receive
		//--------------------
        ENTER(ulTimeReceive);
        OBJECTID  xid;
        
        if (fReceive)
        {
            for (ULONG iBurst = 0; iBurst < nBurst; iBurst++)
            {
		        //--------------------
		        // set message properties
		        //--------------------
		        MsgProps.aPropID = PropId;
		        MsgProps.aPropVar= PropVar;
		        MsgProps.aStatus = Result;

		        int c= 0;

	            // Init values for msg props
		        WCHAR  wszLabel[100];

	            // 0: PROPID_M_LABEL
                PropId[c]     = PROPID_M_LABEL;
		        PropVar[c].vt = VT_LPWSTR;
		        PropVar[c].pwszVal = wszLabel;
                c++;

	            // 1: PROPID_M_LABEL_LEN
                PropId[c]     = PROPID_M_LABEL_LEN;
		        PropVar[c].vt = VT_UI4;
		        PropVar[c].ulVal = sizeof(wszLabel) / sizeof(WCHAR);
                c++;

                // 2: PROPID_M_APPSPECIFIC
                PropId[c]     = PROPID_M_APPSPECIFIC;
		        PropVar[c].vt = VT_UI4;
                c++;

                if (fBoundaries)
                {
                      // 3 : PROPID_M_FIRST_IN_XACT
                      PropId[c] = PROPID_M_FIRST_IN_XACT;       // Property ID
                      PropVar[c].vt = VT_UI1;               // Type indicator
                      c++;

                      // 4: PROPID_M_LAST_IN_XACT
                      PropId[c] = PROPID_M_LAST_IN_XACT;       // Property ID
                      PropVar[c].vt = VT_UI1;               // Type indicator
                      c++;

                      // 5: PROPID_M_XACTID
                      PropId[c] = PROPID_M_XACTID;                 // Property ID
                      PropVar[c].vt = VT_UI1 | VT_VECTOR;          // Type indicator
                      PropVar[c].caub.cElems = sizeof(OBJECTID);
                      PropVar[c].caub.pElems = (PUCHAR)&xid;
                      c++;
                }
                MsgProps.cProp = c;

                hr = Receive(hQueueR, pTrans, &MsgProps, fImmediate);
		        if (FAILED(hr))
		        {
			        printf("\n (%d) MQReceiveMessage Failed: %x\n", indThread, hr);
			        Sleep(RECOVERY_TIME);
		        }
                else if (nListing)
                {
    	            printf("\n (%d) Received: %d  ",  indThread,i);
                    if (fBoundaries)
                        printf (" First=%d Last=%d Index=%d ",  
                                 PropVar[3].bVal, PropVar[4].bVal, xid.Uniquifier);
                }

                // Check ordering
                if (ulPrevious != 0 && PropVar[2].ulVal != ulPrevious+1)
                {
                    if (g_cOrderViols++ < 10)
                    {
                        printf("Order violation: %d before %d\n", ulPrevious, PropVar[2].ulVal);         
                    }
                }
                ulPrevious = PropVar[2].ulVal; 
            }
        }

        LEAVE(ulTimeReceive);
        //--------------------
		// Enlist SQL
		//--------------------
        ENTER(ulTimeEnlist);

        if (fEnlist && !fGlobalCommit)
        {
            if (!DbEnlist(0, pTrans))
            {
                printf(" (%d) Enlist failed\n", indThread);
            }
		    else if (nListing)
			    printf(" (%d) Enlisted ", indThread);
            }

        LEAVE(ulTimeEnlist);
        //-------------------- 
		// Update sql
		//--------------------
        ENTER(ulTimeUpdate);

        if (fUpdate)
        {
            CHAR  string[256];
            sprintf(string, "UPDATE %s SET Counter=Counter + 1 WHERE Indexing=%d", 
                            pszTable, 1 /*rand() * 999 / RAND_MAX*/);

            DbSql(0, string);
            if (nListing)
			    printf(" (%d) Updated ", indThread);        
        }

        LEAVE(ulTimeUpdate);
        //--------------------
		// Stub
		//--------------------
        ENTER(ulTimeStub);

        if (fStub)
        {
            if (!StubEnlist(pTrans))
                printf("Stub fail\n");
        }

        LEAVE(ulTimeStub);
        //--------------------
		// Commit / Abort
		//--------------------
        ENTER(ulTimeCommit);

        if (fTransactions && !fGlobalCommit && !fUncoordinated)
        {
            if ((ULONG)rand() * 100 / RAND_MAX < nAbortChances)
		    {
       		    hr = Abort(pTrans, nSync==0);
			    if (nListing)
				    printf(" (%d)Abort  ", indThread);
                if (hr)
                {
                    printf("   (%d) hr=%x\n", indThread, hr);
                }
		    }
		    else
		    {
       		    hr = Commit(pTrans, nSync==0);
			    if (nListing)
   				    printf(" (%d)Commit  ", indThread);
                if (hr)
                {
                    printf("  (%d) hr=%x\n", indThread, hr);
                }
		    }
        }

        LEAVE(ulTimeCommit);
		//--------------------
		// Release
		//--------------------
        ENTER(ulTimeRelease);

        if (fTransactions && !fGlobalCommit && !fUncoordinated)
        {
            Release(pTrans);
        }

        LEAVE(ulTimeRelease);
		//--------------------
		// sleep
		//--------------------
        ENTER(ulTimeSleep);

        if (nMaxSleep)
        {
            Sleeping(nListing, nMaxSleep);
        }

        LEAVE(ulTimeSleep);
	}

    //--------------------
	// Global Commit / Abort
	//--------------------
    if (fGlobalCommit && !fUncoordinated)
    {
        if ((ULONG)rand() * 100 / RAND_MAX < nAbortChances)
		{
       		hr = Abort(pTrans, nSync==0);
			if (nListing)
				printf(" (%d)Abort  ", indThread);
            if (hr)
            {
                printf("   (%d) hr=%x\n", indThread, hr);
            }
		}
		else
		{
       		hr = Commit(pTrans, nSync==0);
			if (nListing)
   				printf(" (%d)Commit  ", indThread);
            if (hr)
            {
                printf("  (%d) hr=%x\n", indThread, hr);
            }
		}
        Release(pTrans);
    }

    if (nTries*nBurst > 100)
    {
        ulTimeTotal = ulTimeBegin   + ulTimeSend   + ulTimeReceive +
                      ulTimeEnlist  + ulTimeUpdate + ulTimeCommit  +
                      ulTimeStub    + ulTimeRelease + ulTimeSleep;

        printf("Time distribution (total time=%d): \n     Stage       Time   Percent\n", ulTimeTotal);
        PRINT("Begin",   ulTimeBegin);
        PRINT("Send",    ulTimeSend);
        PRINT("Receive", ulTimeReceive);
        PRINT("Enlist",  ulTimeEnlist);
        PRINT("Update",  ulTimeUpdate);
        PRINT("Stub",    ulTimeStub);
        PRINT("Commit",  ulTimeCommit);
        PRINT("Release", ulTimeRelease);
        PRINT("Sleep",   ulTimeSleep);

        //getchar();
    }
    EnterCriticalSection(&crCounter); // protects nActiveThreads
    nActiveThreads--;
    LeaveCriticalSection(&crCounter); // protects nActiveThreads
}

//--------------------------------------
// main routine: parses, starts threads
//-------------------------------------
void main (int argc, char **argv)
{
	HRESULT    hr;

	//--------------------
	// Get parameters
	//--------------------
	if (argc != 18)
	{
        printf("Usage: xtest Tries Burst Threads Seed MaxSleep TTRQ TTBR AbortChances\n");
        printf("       Acking nSync Queue Admin_queue Table Server Listing BodySize tsrmeubgyxvmailh\n");
        printf("Flags: \n");
        printf("       Transact, Send, Receive, Enlist, xA, Update, Global, autHenticated, bOundaries\n");
        printf("       Yncoord.,eXpress, Viper,  iMmediate,   Internal, stuB, DeadLetter, Journal \n");
		exit(0);
	}

    int iarg = 1;

	nTries          = atoi(argv[iarg++]);
    nBurst          = atoi(argv[iarg++]);
    nThreads        = atoi(argv[iarg++]);
	seed            = atoi(argv[iarg++]);

    if (seed == 0)
	{
		seed = (ULONG)time(NULL);
	}
    srand(seed);
	printf("Seed number=%d\n", seed);

	nMaxSleep       = atoi(argv[iarg++]);
	nMaxTimeQueue   = atoi(argv[iarg++]);
	nMaxTimeLive    = atoi(argv[iarg++]);
	nAbortChances   = atoi(argv[iarg++]);
	nAcking         = atoi(argv[iarg++]);
	nSync           = atoi(argv[iarg++]);
	pszQueue        = argv[iarg++];
	pszAdminQueue   = argv[iarg++];
    pszTable        = argv[iarg++];
    pszServer       = argv[iarg++];
	nListing        = atoi(argv[iarg++]);
	nSize           = atoi(argv[iarg++]);
	pszMode         = argv[iarg++];

    // Find out the mode
    fTransactions   = (strchr(pszMode, 't') != NULL);  // use transactions
    fSend           = (strchr(pszMode, 's') != NULL);  // send
    fReceive        = (strchr(pszMode, 'r') != NULL);  // receive
    fEnlist         = (strchr(pszMode, 'e') != NULL);  // enlist SQL
    fUpdate         = (strchr(pszMode, 'u') != NULL);  // update SQL
    fStub           = (strchr(pszMode, 'b') != NULL);  // stub
    fGlobalCommit   = (strchr(pszMode, 'g') != NULL);  // Global Commit/Abort on all actions
    fUncoordinated  = (strchr(pszMode, 'y') != NULL);  // Uncoordinated transaction
    fExpress        = (strchr(pszMode, 'x') != NULL);  // Express messages
    fDeadLetter     = (strchr(pszMode, 'l') != NULL);  // Deadletter
    fJournal        = (strchr(pszMode, 'j') != NULL);  // Journal
    fAuthenticate   = (strchr(pszMode, 'h') != NULL);  // Authentication
    fViper          = (strchr(pszMode, 'v') != NULL);  // Viper implicit
    fImmediate      = (strchr(pszMode, 'm') != NULL);  // No wait
    fXA             = (strchr(pszMode, 'a') != NULL);  // XA implicit
    fDirect			= (strchr(pszMode, 'd') != NULL);  // Direct names
    fInternal       = (strchr(pszMode, 'i') != NULL);  // Internal transactions
    fBoundaries     = (strchr(pszMode, 'o') != NULL);  // Transaction bOundaries

    PrintMode(fTransactions, fSend, fReceive, fEnlist, fUpdate, fGlobalCommit, 
              fUncoordinated, fStub, fExpress, fInternal, fViper, fXA, fDirect,
              nMaxTimeQueue,  nMaxTimeLive, nSize, fImmediate, fDeadLetter, fJournal, fAuthenticate, fBoundaries);

    if (!fTransactions && (fEnlist || fGlobalCommit))
    {
        printf("Wrong mode\n");
        exit(1);
    }

    if (nSync==0)
    {
        SetAnticipatedOutcomes(nTries*nThreads*nBurst);
    }

    //--------------------
	// DTC init
	//---------------------
	//CoInitialize(0) ;
    if (fTransactions && !fUncoordinated && !fInternal)
    {
	    // Connect to DTC

    	CoInitialize(0) ;

        // handle of the loaded DTC proxy library (defined in mqutil.cpp)
        HINSTANCE g_DtcHlib = LoadLibrary(MSDTC_PROXY_DLL_NAME);

        // Get DTC API pointer
        LPFNDtcGetTransactionManager pfDtcGetTransactionManager =
              (LPFNDtcGetTransactionManager) GetProcAddress(g_DtcHlib, "DtcGetTransactionManagerExA");

        if (!pfDtcGetTransactionManager) 
        {
            pfDtcGetTransactionManager =
              (LPFNDtcGetTransactionManager) GetProcAddress(g_DtcHlib, "DtcGetTransactionManagerEx");
        }

        if (!pfDtcGetTransactionManager)
        {
            printf("Cannot  GetProcAddress DtcGetTransactionManagerEx\n");
            return;
        }

        // Get DTC IUnknown pointer
        hr = (*pfDtcGetTransactionManager)(
                                 NULL,
                                 NULL,
                                 IID_ITransactionDispenser,
                                 OLE_TM_FLAG_QUERY_SERVICE_LOCKSTATUS,
                                 0,
                                 (void**) &g_pITxDispenser);

        if (FAILED(hr))
        {
            printf("DtcGetTransactionManager returned %x\n", hr);
            return;
        }
    }

    //--------------------
	// Open Queue
	//---------------------
    if (fSend || fReceive)
    {
        mbstowcs( wszPathName, pszQueue, 100);
		if (!fDirect)
		{
			hr = MQPathNameToFormatName(&wszPathName[0],
										&wszFmtName[0],
										&dwFormatNameLength);
		}
		if (fDirect || FAILED(hr))
	    {
            wcscpy(&wszFmtName[0], &wszPathName[0]);
	    }

        if (fSend)
        {
	        hr = MQOpenQueue(
                               &wszFmtName[0],
                               MQ_SEND_ACCESS,
                               0,
                               &hQueueS);

	        if (FAILED(hr))
	        {
		        printf("MQOpenQueue Failed: %x\n", hr);
		        return;
	        }
        }

        if (fReceive)
        {
	        hr = MQOpenQueue(
                               &wszFmtName[0],
                               MQ_RECEIVE_ACCESS,
                               0,
                               &hQueueR);

	        if (FAILED(hr))
	        {
		        printf("MQOpenQueue Failed: %x\n", hr);
		        return;
	        }
        }

	    //--------------------
	    // Open Queue
	    //---------------------
	    dwFormatNameLength = 100;

        mbstowcs( wszPathName, pszAdminQueue, 100);
		if (!fDirect)
		{
			hr = MQPathNameToFormatName(&wszPathName[0],
										&wszFmtName[0],
										&dwFormatNameLength);
		}
		if (fDirect || FAILED(hr))
	    {
            wcscpy(&wszFmtName[0], &wszPathName[0]);
	    }
    }

	//--------------------
	// Connect to database
	//--------------------
    if (fEnlist || fUpdate)
    {
        DbLogin(0, "user1", "user1");
        DbUse(0, 0, "test", pszServer) ;
    }

    nActiveThreads = nThreads;
    InitializeCriticalSection(&crCounter); // protects nActiveThreads

    //------------------------
    // Start threads
    //------------------------
    for (ULONG iThrd=0; iThrd<nThreads; iThrd++) {
        DWORD dwThreadId ;
        CreateThread(   NULL,
                        0,
                        (LPTHREAD_START_ROUTINE)XactFlow,
                        (void *)iThrd,
                        0,
                        &dwThreadId);
    }

    // Starting measurement
    //time_t  t1 = time(NULL);  
    ULONG t1 = GetTickCount();

    //-------------------------
    // Waiting Cycle
    //-------------------------
    while (nActiveThreads > 0) {
        Sleep(1000);
    }

    if (nTries * nThreads * nBurst >= 100)
    {

        // Measuring time
   	    //time_t t2 = time(NULL);
        ULONG t2 = GetTickCount();
	    ULONG delta = t2 - t1;
	    
        PrintMode(fTransactions, fSend, fReceive, fEnlist, fUpdate, fGlobalCommit, 
                  fUncoordinated, fStub, fExpress, fInternal, fViper, fXA, fDirect,
                  nMaxTimeQueue, nMaxTimeLive, nSize, fImmediate, fDeadLetter, fJournal, fAuthenticate, fBoundaries);
        printf("\n Time: %d seconds; %d msec per xact;    %d xacts per second \n", 
		    delta/1000,  
            delta/nTries/nThreads/nBurst,  
            (delta==0? 0 : (1000*nTries*nThreads*nBurst /*+delta/2-1*/)/delta));

    extern ULONG           g_cEnlistFailures;
    extern ULONG           g_cBeginFailures;
    extern ULONG           g_cDbEnlistFailures;

        if (g_cEnlistFailures)
            printf("%d Enlist failures\n", g_cEnlistFailures);
        if (g_cDbEnlistFailures)
            printf("%d DbEnlist failures\n", g_cDbEnlistFailures);
        if (g_cBeginFailures)
            printf("%d Begin failures\n", g_cBeginFailures);

        if (nSync==0)
        {
            WaitForAllOutcomes();

            // Measuring time
            ULONG t3 = GetTickCount();
	        delta = t3 - t1;

            PrintAsyncResults();

            printf("\n Async completion: %d sec; %d msec per xact;    %d xacts per second \n", 
		        delta/1000,  
                delta/nTries/nThreads/nBurst,  
                (delta==0? 0 : ((1000*nTries*nThreads*nBurst /*+delta/2-1*/)/delta)));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\cluster\mqclus\mqclusp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    mqclusp.h

Abstract:

    Header for my internal routines

Author:

    Shai Kariv (shaik) Jan 12, 1999

Revision History:

--*/

#ifndef _MQCLUSP_H_
#define _MQCLUSP_H_

#include "stdh.h"
#include <cs.h>
#include <_mqini.h>
#include <autorel2.h>
#include <autorel3.h>

extern HMODULE	g_hResourceMod;
extern PLOG_EVENT_ROUTINE           g_pfLogClusterEvent;
extern PSET_RESOURCE_STATUS_ROUTINE g_pfSetResourceStatus;
extern CLRES_FUNCTION_TABLE         g_MqclusFunctionTable;
    

class CMqclusException
{
};


class CQmResource
{
    //
    // CQmResource - holds information of a QM resource.
    //

public:                   
    CQmResource(LPCWSTR, HKEY, RESOURCE_HANDLE);
    ~CQmResource() {};

    RESID GetResId(VOID) const { return m_ResId; };
    RESOURCE_HANDLE GetReportHandle(VOID) const { return m_hReport; };
    LPCWSTR GetResourceName(VOID) const { return m_pwzResourceName; };
    LPCWSTR GetServiceName(VOID) const { return m_wzServiceName; }; 
    LPCWSTR GetDriverName(VOID) const  { return m_wzDriverName; };
    LPCWSTR GetFalconRegSection(VOID) const { return m_wzFalconRegSection; };
    LPCWSTR GetCrypto40FullKey(VOID) const  { return m_wzCrypto40FullKey; };
    LPCWSTR GetCrypto128FullKey(VOID) const { return m_wzCrypto128FullKey; };

    BOOL CheckIsAlive(VOID) const;
    VOID DeleteFalconRegSection(VOID);
    VOID DeleteMsmqDir(VOID) const;
    VOID DeleteMqacFile(VOID) const;

    bool SetFalconKeyValue(LPCWSTR, DWORD, const VOID*, DWORD) const;
    bool GetFalconKeyValue(LPCWSTR, VOID*, DWORD*) const;
                            
    bool  IsFirstOnline(DWORD*) const;
    DWORD BringOnlineFirstTime();
    DWORD BringOnline();

    VOID    SetState(CLUSTER_RESOURCE_STATE s) { m_ResourceStatus.ResourceState = s; };
    inline VOID    ReportState(VOID) const;

    DWORD   ClusterResourceControl(LPCWSTR, DWORD, LPBYTE*, DWORD*) const;

    bool    AddRemoveRegistryCheckpoint(DWORD) const;
    bool    AddRemoveCryptoCheckpoints(DWORD) const;

    DWORD   AdsDeleteQmObject(VOID) const;

    DWORD   CreateEventSourceRegistry(VOID) const;
    VOID    DeleteEventSourceRegistry(VOID) const;

    DWORD   StopService(LPCWSTR) const;
    DWORD   RemoveService(LPCWSTR) const;

    VOID   DeleteNt4Files(VOID) const;

    CLUS_WORKER m_OnlineThread;
                            
private:                  

    class CQmResourceRegistry
    {
    public:
        explicit CQmResourceRegistry(LPCWSTR pwzService);
        ~CQmResourceRegistry();

    private:
        CS m_lock;
    }; 

    VOID   RegDeleteTree(HKEY, LPCWSTR) const;
    VOID   DeleteDirectoryFiles(LPCWSTR) const;

    DWORD  WaitForDtc(VOID) const;
    bool   IsResourceNetworkName(LPCWSTR);
    bool   IsResourceDiskDrive(LPCWSTR);
    DWORD  QueryResourceDependencies(VOID);

    DWORD  CreateCaConfiguration(VOID) const;

    DWORD  AdsInit(VOID);
    DWORD  AdsCreateComputerObject(VOID) const;
    DWORD  AdsCreateQmObject(VOID) const;
    DWORD  AdsCreateQmPublicKeys(VOID) const;
    DWORD  AdsReadQmProperties(VOID);
    DWORD  AdsReadQmSecurityDescriptor(VOID);

    DWORD  CloneMqacFile(VOID) const;
    bool   AddRemoveCryptoCheckpointsInternal(DWORD, bool) const;

    DWORD  RegisterDriver(VOID) const;
    DWORD  RegisterService(VOID) const;
    DWORD  StartService(VOID) const;
    DWORD  SetServiceEnvironment(VOID) const;

    DWORD  ReportLastError(DWORD, LPCWSTR, LPCWSTR) const;

private:
    RESID                     m_ResId;
    RESOURCE_HANDLE           m_hReport;
    AP<WCHAR>                 m_pwzResourceName; 
    mutable RESOURCE_STATUS   m_ResourceStatus;

    GUID                      m_guidQm;
    CSecDescPointer           m_pSd;
    DWORD                     m_cbSdSize;
    WCHAR                     m_wDiskDrive;
    CServiceHandle            m_hScm;
    CAutoCluster              m_hCluster;
    CClusterResource          m_hResource;
    bool                      m_fServerIsMsmq1;

    DWORD                     m_dwWorkgroup;
    DWORD                     m_nSites;
    AP<GUID>                  m_pguidSites;
    DWORD                     m_dwMqsRouting;
    DWORD                     m_dwMqsDepClients;
    WCHAR                     m_wzCurrentDsServer[MAX_REG_DSSERVER_LEN];

    AP<WCHAR>                 m_pwzNetworkName; 
    WCHAR                     m_wzFalconRegSection[200 + 100];
    WCHAR                     m_wzServiceName[200];
    WCHAR                     m_wzDriverName[200];
    WCHAR                     m_wzDriverPath[MAX_PATH];
    WCHAR                     m_wzCrypto40Container[200];
    WCHAR                     m_wzCrypto40FullKey[200];
    WCHAR                     m_wzCrypto128Container[200];
    WCHAR                     m_wzCrypto128FullKey[200];

}; //class CQmResource


DWORD
MqcluspStartup(
    VOID
    );

RESID
MqcluspOpen(
    LPCWSTR pwzResourceName,
    HKEY hResourceKey,
    RESOURCE_HANDLE hResourceHandle
    );

VOID
MqcluspClose(
    CQmResource * pqm
    );

DWORD 
MqcluspOnlineThread(
    CQmResource * pqm
    );

DWORD
MqcluspOffline(
    CQmResource * pqm
    );

BOOL
MqcluspCheckIsAlive(
    CQmResource * pqm
    );

DWORD
MqcluspClusctlResourceGetRegistryCheckpoints(
    CQmResource * pqm,
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    );

DWORD
MqcluspClusctlResourceGetCryptoCheckpoints(
    CQmResource * pqm,
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    );

DWORD
MqcluspClusctlResourceGetRequiredDependencies(
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    );

DWORD
MqcluspClusctlResourceSetName(
    VOID
    );

DWORD
MqcluspClusctlResourceDelete(
    CQmResource * pqm
    );

DWORD
MqcluspClusctlResourceTypeGetRequiredDependencies(
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    );

DWORD
MqcluspClusctlResourceTypeStartingPhase2(
    VOID
    );

#endif //_MQCLUSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\common\certres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mqcertui.rc
//

//
// changed from 2 to 8002
//

#define IDS_CANT_GET_CERT               8003
#define IDS_CERT_TIME_FORMAT            8005
#define IDS_CERT_VALID                  8006
#define IDS_ERROR                       8008
// #define IDS_SHOWCERTINSTR               14  - already defined in snapres.h
#define IDS_REMOVECERTINSTR             8015
#define IDS_REMOVE                      8016
#define IDS_SAVECERTINSTR               8017
#define IDS_SAVE                        8018
#define IDS_VERIFY_DELETE_CERT          8020
#define IDS_VERIFY_CAPTION              8021
#define IDS_VERIFY_SYSCERTS             8022
#define IDD_TESTAPP2_DIALOG             8102
#define IDR_MAINFRAME                   8128
#define IDD_CERTSEL_DIALOG              8136
#define IDD_CA_CONFIG                   8137
#define IDB_CA_LIST_IMAGE               8139

// changed from 1000 to 8200
#define IDC_CERTSLIST                   8200
#define IDC_CERTSINSTR                  8201
#define IDC_SHOWCERT                    8202
#define IDC_ITEMS                       8203
#define IDC_ITEMVALUE                   8204
#define IDC_VALIDSTATE                  8205
#define IDC_CERT_PROPS_ICON             8206
#define IDC_CERTIFICATE_LIST            8207
#define IDC_VIEW_CERT                   8208
#define IDC_DELETE_CERT                 8209
#define IDC_SYSTEM_CERTS                8210
#define IDC_CERTSEL_ICON                8211

//
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        8212
#define _APS_NEXT_COMMAND_VALUE         40300
#define _APS_NEXT_CONTROL_VALUE         8212
#define _APS_NEXT_SYMED_VALUE           8212
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\common\clusres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mqclus.rc
//
#define IDS_DRIVER_DISPLAY_NAME         6101
#define IDS_SERVICE_DISPLAY_NAME        6102
#define IDS_SERVICE_DESCRIPTION         6103

//
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        6104
#define _APS_NEXT_COMMAND_VALUE         40400
#define _APS_NEXT_CONTROL_VALUE         6104
#define _APS_NEXT_SYMED_VALUE           6104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\common\midluser.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    midluser.cpp

Abstract:

Author:

    Lior Moshaiov (LiorM)   ??-???-??
    Erez Haba (erezh)       11-Jan-96

--*/


#include "stdh.h"
#undef new

extern "C" void __RPC_FAR * __RPC_USER midl_user_allocate(size_t cBytes)
{
    return new_nothrow char[cBytes];
}


extern "C" void  __RPC_USER midl_user_free (void __RPC_FAR * pBuffer)
{
    delete[] pBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\common\bkupres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mqbkup.rc
//

// Change from 1 to 1001

#define IDS_STRING1                     1001
#define IDS_VERIFY_BK_PRIV              1001
#define IDS_CHECK_BK_DIR                1002
#define IDS_READ_FILE_LOCATION          1003
#define IDS_BKRESTORE_STOP_SERVICE      1004
#define IDS_CHECK_AVAIL_DISK_SPACE      1005
#define IDS_BACKUP_REGISTRY             1006
#define IDS_BACKUP_MSG_FILES            1007
#define IDS_START_SERVICE               1008
#define IDS_DONE                        1009
#define IDS_CANT_LOOKUP_PRIV_VALUE      1011
#define IDS_CANT_ENABLE_PRIV            1012
#define IDS_CANT_OPEN_PROCESS_TOKEN     1013
#define IDS_DIR_NOT_EMPTY               1014
#define IDS_CANT_CREATE_FILE            1015
#define IDS_CANT_WRITE_FILE             1016
#define IDS_CANT_QUERY_REGISTRY_VALUE   1017
#define IDS_CANT_SET_REGISTRY_VALUE     1018
#define IDS_CANT_OPEN_MSMQ_REGISTRY_READ 1019
#define IDS_CANT_OPEN_SCM               1020
#define IDS_CANT_OPEN_SERVICE           1021
#define IDS_CANT_STOP_SERVICE           1022
#define IDS_CANT_OPEN_DRIVER            1023
#define IDS_CANT_RELEASE_MSG_FILES      1024
#define IDS_CANT_START_SERVICE          1025
#define IDS_CANT_ACCESS_DIR             1026
#define IDS_CANT_GET_FREE_SPACE         1027
#define IDS_CANT_OPEN_MSMQ_REG          1028
#define IDS_CANT_SAVE_MSMQ_REGISTRY     1029
#define IDS_CANT_RESTORE_MSMQ_REGISTRY  1030
#define IDS_CANT_OPEN_REG_KEY_READ_WRITE 1031
#define IDS_CANT_COPY                   1032
#define IDS_CANT_CREATE_DIR             1033
#define IDS_NOT_VALID_BK                1034
#define IDS_USAGE                       1035
#define IDS_CANT_ENUM_SERVICE_DEPENDENCIES 1036
#define IDS_NO_MEMORY                   1037
#define IDS_VERIFY_RESTORE_PRIV         1038
#define IDS_VERIFY_BK                   1039
#define IDS_RESTORE_REGISTRY            1040
#define IDS_REMEMBER_SEQID_RESTORE      1041
#define IDS_VERIFY_STORAGE_DIRS         1042
#define IDS_RESTORE_MSG_FILES           1043
#define IDS_NOT_ENOUGH_DISK_SPACE_BK    1044
#define IDS_CANT_DEL_FILE               1045
#define IDS_WARN_BEFORE_DELETION        1046
#define IDS_Y                           1047
#define IDS_ABORT                       1048
#define IDS_N                           1049
#define IDS_CANT_GET_FULL_PATH          1051
#define IDS_PATH_TOO_LONG_ERROR         1052
#define IDS_CANT_QUERY_SERVICE          1053
#define IDS_DELETING_FILES				1054
#define IDS_SEARCHING_AFFECTED_PROCESSES 1055
#define IDS_VERIFY_CONTINUE             1056
#define IDS_CANT_LOAD_FUNCTION          1057
#define IDS_CANT_CREATE_SNAPSHOT        1058
#define IDS_CANT_SHOW_PROCESSES_LIB_PROBLEM 1059

//
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        1060
#define _APS_NEXT_COMMAND_VALUE         40200
#define _APS_NEXT_CONTROL_VALUE         1060
#define _APS_NEXT_SYMED_VALUE           1060
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\common\makefile.inc ===
MSMQ_HSPLIT=$(FROOT)\tools\hsplit\$(PROCESSOR_ARCHITECTURE)\hsplit.exe

MQ_H=$(MSMQ_BINS_PATH)\mq.h


DEP_MQ_H=\
    $(MSMQ_INC_PATH)\_mqbegin.h \
    $(MSMQ_BINS_PATH)\mqtypes.h \
    $(MSMQ_INC_PATH)\_mqdef.h \
    $(MSMQ_INC_PATH)\mqprops.h \
    $(MSMQ_BINS_PATH)\mqsymbls.h \
    $(MSMQ_INC_PATH)\mqsec.h \
    $(MSMQ_INC_PATH)\rt.h \
    $(MSMQ_INC_PATH)\_mqend.h \


all: $(MQ_H)

$(MQ_H): $(DEP_MQ_H)
    @echo HSPLIT: Creating public header $(MQ_H)
    $(MSMQ_HSPLIT) -o nul $(MQ_H) -c // -bt2 begin_mq_h end_mq_h $(DEP_MQ_H)

clean: delsrc all

delsrc:
    if exist $(MQ_H)  del $(MQ_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\common\tclusres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by restype.rc
//
#define IDS_ClusCfgMQTrigResType_DESC			6201
#define IDR_ClusCfgMQTrigResType			6202
#define IDS_CONFIGURING_RESOURCE_TYPE			6202
#define IDS_DISPLAY_NAME				6203
#define IDS_TRIGGER_CLUSTER_SERVICE_DESCRIPTION         6204

//
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        6205
#define _APS_NEXT_COMMAND_VALUE         6205
#define _APS_NEXT_CONTROL_VALUE         6205
#define _APS_NEXT_SYMED_VALUE           6205
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\common\mqoares.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mqoa.rc
//
// Changed from 1 to 2001
//
#define IDS_RELOPS                      2001
#define IDS_MQTRANSACTION               2002
#define IDS_MQMSGCURSOR                 2003
#define IDS_MQMSGCLASS                  2004
#define IDS_MQMSGDELIVERY               2005
#define IDS_MQMSGACKNOWLEDGEMENT        2006
#define IDS_MQMSGJOURNAL                2007
#define IDS_MQMSGTRACE                  2008
#define IDS_MQMSGSENDERIDTYPE           2009
#define IDS_MQMSGPRIVLEVEL              2010
#define IDS_MQMSGAUTHLEVEL              2011
#define IDS_MQMSGIDSIZE                 2012
#define IDS_MQMSGMAX                    2013
#define IDS_MQSHARE                     2014
#define IDS_MQACCESS                    2015
#define IDS_MQJOURNAL                   2016
#define IDS_MQTRANSACTIONAL             2017
#define IDS_MQAUTHENTICATE              2018
#define IDS_MQPRIVLEVEL                 2019
#define IDS_MQPRIORITY                  2020
#define IDS_MQMAX                       2021
#define IDS_MQDEFAULT                   2022
#define IDS_MQERROR                     2023
#define IDS_MQWARNING                   2024
#define IDS_IMSMQQUERY                  2025
#define IDS_MSMQQUERY                   2026
#define IDS_IMSMQMESSAGE                2027
#define IDS_MSMQMESSAGE                 2028
#define IDS_IMSMQQUEUE                  2029
#define IDS_IMSMQEVENT                  2030
#define IDS_DMSMQEVENTEVENTS            2031
#define IDS_MSMQQUEUE                   2032
#define IDS_MSMQEVENT                   2033
#define IDS_IMSMQQUEUEINFO              2034
#define IDS_MSMQQUEUEINFO               2035
#define IDS_IMSMQQUEUEINFOS             2036
#define IDS_MSMQQUEUEINFOS              2037
#define IDS_IMSMQTRANSACTION            2038
#define IDS_MSMQTRANSACTION             2039
#define IDS_IMSMQCOORDINATEDTRANSACTIONDISPENSER 2040
#define IDS_MSMQCOORDINATEDTRANSACTIONDISPENSER 2041
#define IDS_IMSMQTRANSACTIONDISPENSER   2042
#define IDS_MSMQTRANSACTIONDISPENSER    2043
#define IDS_IMSMQAPPLICATION            2044
#define IDS_MSMQAPPLICATION             2045
#define IDS_LookupQueue                 2046
#define IDS_lClass                      2047
#define IDS_lPrivLevel                  2048
#define IDS_lAuthLevel                  2049
#define IDS_isAuthenticated             2050
#define IDS_lDelivery                   2051
#define IDS_lTrace                      2052
#define IDS_lPriority                   2053
#define IDS_lJournal                    2054
#define IDS_queueinfoResponse           2055
#define IDS_lAppSpecific                2056
#define IDS_guidSrcMachine              2057
#define IDS_lenBody                     2058
#define IDS_body                        2059
#define IDS_queueinfoAdmin              2060
#define IDS_id                          2061
#define IDS_idCorrelation               2062
#define IDS_lAck                        2063
#define IDS_strLabel                    2064
#define IDS_lMaxTimeToReachQueue        2065
#define IDS_lMaxTimeToReceive           2066
#define IDS_lHashAlg                    2067
#define IDS_lEncryptAlg                 2068
#define IDS_dateSentTime                2069
#define IDS_dateArrivedTime             2070
#define IDS_queueinfoDest               2071
#define IDS_binSenderCert               2072
#define IDS_binSenderId                 2073
#define IDS_lSenderIdType               2074
#define IDS_Send                        2075
#define IDS_AttachCurrentSecurityContext 2076
#define IDS_lAccess                     2077
#define IDS_lShareMode                  2078
#define IDS_queueinfo                   2079
#define IDS_lHandle                     2080
#define IDS_isOpen                      2081
#define IDS_Close                       2082
#define IDS_Receive                     2083
#define IDS_Peek                        2084
#define IDS_EnableNotification          2085
#define IDS_Reset                       2086
#define IDS_ReceiveCurrent              2087
#define IDS_PeekNext                    2088
#define IDS_PeekCurrent                 2089
#define IDS_guidQueue                   2090
#define IDS_guidServiceType             2091
#define IDS_MSMQQueueInfo_strLabel      2092
#define IDS_strPathName                 2093
#define IDS_strFormatName               2094
#define IDS_isTransactional             2095
#define IDS_MSMQQueueInfo_lPrivLevel    2096
#define IDS_MSMQQueueInfo_lJournal      2097
#define IDS_lQuota                      2098
#define IDS_lBasePriority               2099
#define IDS_dateCreateTime              2100
#define IDS_dateModifyTime              2101
#define IDS_lAuthenticate               2102
#define IDS_lJournalQuota               2103
#define IDS_Create                      2104
#define IDS_Delete                      2105
#define IDS_Open                        2106
#define IDS_Refresh                     2107
#define IDS_Update                      2108
#define IDS_MSMQQueueInfos_Reset        2109
#define IDS_MSMQQueueInfos_Next         2110
#define IDS_lTransaction                2111
#define IDS_Commit                      2112
#define IDS_Abort                       2113
#define IDS_BeginTransaction            2114
#define IDS_StrMachineIdOfMachineName   2115
#define IDS_Arrived                     2116
#define IDS_ArrivedError                2117
#define IDS_IsWorldReadable             2118
#define IDS_MQCALG                      2119
#define IDS_IMSMQTRANSACTION2           2120
#define IDS_InitNew                     2121
#define IDS_IMSMQAPPLICATION2           2122
#define IDS_RegisterCertificate         2123
#define IDS_MQCERT_REGISTER             2124
#define IDS_MQCERT_REGISTER_ALWAYS      2125
#define IDS_MQCERT_REGISTER_IF_NOT_EXIST 2126
#define IDS_IMSMQQUEUEINFO2             2127
#define IDS_strPathNameDNS              2128
#define IDR_MSMQQUEUEINFO               2129
#define IDR_MSMQMESSAGE                 2130
#define IDR_MSMQQUERY                   2131
#define IDR_MSMQQUEUE                   2132
#define IDR_MSMQEVENT                   2133
#define IDR_MSMQQUEUEINFOS              2134
#define IDR_MSMQTRANSACTION             2135
#define IDR_MSMQCOORDINATEDTRANSACTIONDISPENSER 2136
#define IDR_MSMQTRANSACTIONDISPENSER    2137
#define IDR_MSMQAPPLICATION             2138
#define IDS_IMSMQMESSAGE2               2139
#define IDS_lSenderVersion              2140
#define IDS_binExtension                2141
#define IDS_guidConnectorType           2142
#define IDS_queueinfoXactStatus         2143
#define IDS_binDestSymmKey              2144
#define IDS_binSignature                2145
#define IDS_lAuthProvType               2146
#define IDS_strAuthProvName             2147
#define IDS_lMsgClass                   2148
#define IDS_IMSMQQUEUE2                 2149
#define IDS_Receive_2                   2150
#define IDS_Peek_2                      2151
#define IDS_ReceiveCurrent_2            2152
#define IDS_PeekNext_2                  2153
#define IDS_PeekCurrent_2               2154

#define IDS_idXact                      2155
#define IDS_isFirstInXact               2156
#define IDS_isLastInXact                2157

#define IDS_IMSMQQUERY2                 2158
#define IDS_IMSMQQUEUEINFOS2            2159
#define IDS_IMSMQCOORDINATEDTRANSACTIONDISPENSER2 2160
#define IDS_IMSMQTRANSACTIONDISPENSER2  2161
#define IDS_StrMachineNameOfMachineId   2162
#define IDS_sMSMQVersionMajor           2163
#define IDS_sMSMQVersionMinor           2164
#define IDS_sMSMQVersionBuild           2165
#define IDS_fIsDsEnabled                2166
#define IDS_IMSMQEVENT2                 2167

#define IDS_sReceivedAuthenticationLevel          2168
#define IDS_MQMSGAUTHENTICATION         2169

#define IDS_IMSMQTRANSACTION3           2170
#define IDS_varITransaction             2171
#define IDS_IMSMQCOORDINATEDTRANSACTIONDISPENSER3 2172
#define IDS_IMSMQTRANSACTIONDISPENSER3  2173

#define IDR_MSMQDESTINATION             2174
#define IDS_IMSMQDESTINATION            2175
#define IDS_DestOpen                    2176
#define IDS_fDestIsOpen                 2177
#define IDS_strADsPath                  2178
#define IDS_strDestFormatName           2179
#define IDS_MSMQDESTINATION             2180
#define IDS_destResponse                2181
#define IDS_destDestination             2183
#define IDS_strObjADsPath               2184
#define IDS_varHandle2                  2185
#define IDS_IMSMQQUERY3                 2186
#define IDS_IMSMQMESSAGE3               2187
#define IDS_IMSMQQUEUE3                 2188
#define IDS_IMSMQEVENT3                 2189
#define IDS_IMSMQQUEUEINFO3             2190
#define IDS_IMSMQQUEUEINFOS3            2191
#define IDS_IMSMQAPPLICATION3           2192
#define IDS_Send_3                      2193
#define IDS_DestClose                   2194
#define IDS_strDestPathName             2195
#define IDS_varLookupId                 2196
#define IDS_ReceiveByLookupId           2197
#define IDS_ReceiveNextByLookupId       2198
#define IDS_ReceivePreviousByLookupId   2199
#define IDS_ReceiveFirstByLookupId      2200
#define IDS_ReceiveLastByLookupId       2201
#define IDS_PeekByLookupId              2202
#define IDS_PeekNextByLookupId          2203
#define IDS_PeekPreviousByLookupId      2204
#define IDS_PeekFirstByLookupId         2205
#define IDS_PeekLastByLookupId          2206
#define IDS_isAuthenticated2            2207
#define IDS_isFirstInXact2              2208
#define IDS_isLastInXact2               2209
#define IDS_isOpen2                     2210
#define IDS_isTransactional2            2211
#define IDS_IsWorldReadable2            2212
#define IDS_strMulticastAddress         2213
#define IDS_AttachCurrentSecurityContext2         2214
#define IDS_LookupQueue_3               2215
#define IDS_binSoapEnvelope             2216
#define IDS_binCompoundMessage          2217
#define IDS_binSoapHeader               2218
#define IDS_binSoapBody                 2219
#define IDS_Purge                       2220
#define IDS_EodResend                   2221
#define IDS_Pause                       2222
#define IDS_Resume                      2223
#define IDS_QueueType                   2224
#define IDS_IsLocal                     2225
#define IDS_ForeignStatus               2226
#define IDS_UsedQuota	                2227
#define IDS_QueueState                  2228
#define IDS_QUEUE_TYPE                  2229
#define IDS_FOREIGN_STATUS              2230
#define IDS_QUEUE_STATE                 2231
#define IDS_NextHops                    2232
#define IDS_ActiveQueues                2233
#define IDS_PrivateQueues               2234
#define IDS_DirectoryServiceServer      2235
#define IDS_IsConnected                 2236
#define IDS_Connect                     2237
#define IDS_Disconnect                  2238
#define IDS_Tidy                        2239
#define IDS_IMSMQMANAGEMENT             2240
#define IDS_ManagementInit              2241
#define IDS_IMSMQOUTGOINGQUEUEMANAGEMENT 2242
#define IDS_IMSMQQUEUEMANAGEMENT        2243
#define IDR_MSMQMANAGEMENT              2244
#define IDS_Machine                     2245
#define IDS_MessageCount                2246
#define IDS_State                       2247
#define IDS_EodGetSendInfo              2251
#define IDS_EodGetReceiveInfo           2252
#define IDS_TransactionalStatus         2253
#define IDS_JournalMessageCount         2255


//#define IDC_STATIC                      -1

//
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        2257
#define _APS_NEXT_COMMAND_VALUE         40100
#define _APS_NEXT_CONTROL_VALUE         2257
#define _APS_NEXT_SYMED_VALUE           2257
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\common\qmres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by qmres.rc
//
#define IDS_SENT1                       6001
#define IDS_RECEIVE                     6002
#define IDS_SENT2                       6003
#define IDS_REPORT_TITLE                6004
#define IDS_TEST_TITLE                  6005
#define IDS_MACHINE_QUEUES_INSTANCE     6006
#define IDS_INCOMING_PGM_INSTANCE_NAME  6007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        6011
#define _APS_NEXT_COMMAND_VALUE         6011
#define _APS_NEXT_CONTROL_VALUE         6011
#define _APS_NEXT_SYMED_VALUE           6011
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\common\upgrdres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mqupgrd.rc
//

//
// changed for 1 to 7001
//
#define IDS_OPEN_REG_KEY_ERROR          7001
#define IDS_QUERY_REG_KEY_ERROR         7002
#define IDS_OPEN_INF_ERROR              7003
#define IDS_SET_DIR_ID_ERROR            7004
#define IDS_OPEN_FILE_Q_ERROR           7005
#define IDS_INSTALL_FROM_INF_ERROR      7006
#define IDS_INIT_Q_CALLBACK_ERROR       7007
#define IDS_COMMIT_Q_ERROR              7008

//
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        7009
#define _APS_NEXT_COMMAND_VALUE         7009
#define _APS_NEXT_CONTROL_VALUE         7009
#define _APS_NEXT_SYMED_VALUE           7009
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\common\snapres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mqsnap.rc
//

// ID 10000 - 12000
// CONTROL  32767 - 57424

//
// changed from 100 to 10000
//
#define IDS_PROJNAME                    10000
#define IDD_FINDQUEUE                   10001
#define IDR_SNAPIN_MENU                 10004
#define IDR_MsmqQueueExt                10004
#define IDS_SNAPIN_DESC                 10005
#define IDS_SNAPIN_PROVIDER             10006
#define IDS_SNAPIN_VERSION              10007
#define IDR_SNAPIN                      10008
#define IDS_READMESSAGE                 10008
#define IDS_REPORT_MESSAGEPRIORITY      10009
#define IDS_REPORT_MESSAGETITLE         10010
#define IDS_REPORT_MESSAGETIMETOLIVE    10011
#define IDS_REPORT_MESSAGE_SEQNO        10012
#define IDS_REPORT_MESSAGE_RCPT_QUEUE_LEN 10013
#define IDS_REPORT_MESSAGE_ADMIN_QUEUE_LEN 10014
#define IDS_REPORT_MESSAGE_RESP_QUEUE_LEN 10015
#define IDS_REPORT_MESSAGE_PRIV_LEVEL   10016
#define IDS_REPORT_MESSAGEID            10017
#define IDS_REPORT_MESSAGELEN           10018
#define IDS_REPORT_MESSAGE_BODYSIZE     10019
#define IDS_REPORT_MESSAGE_BODY         10020
#define IDS_REPORT_MESSAGE_CLASS        10021
#define IDS_REPORT_MESSAGE_AUTHENTICATED 10022
#define IDS_REPORT_MESSAGE_HASH_ALG     10023
#define IDS_REPORT_MESSAGE_ENCRYPT_ALG  10024
#define IDS_REPORT_MESSAGE_SRC_MACHINE_ID 10025
#define IDS_REPORT_MESSAGE_SENTTIME     10026
#define IDS_REPORT_MESSAGE_ARRIVEDTIME  10027
#define IDS_REPORT_MESSAGE_RESP_QUEUE   10028
#define IDS_REPORT_MESSAGE_ADMIN_QUEUE  10029
#define IDS_REPORT_MESSAGE_RCPT_QUEUE   10030
#define IDS_REPORT_MESSAGE_TRACE        10031
#define IDS_REPORT_MESSAGE_SENDERID     10032
#define IDS_REPORT_MESSAGE_SENDERID_LEN 10033
#define IDS_REPORT_MESSAGE_SENDERID_TYPE 10034
#define IDS_REPORT_MESSAGETITLE_LEN     10035
#define IDS_REPORT_MESSAGE_CORRELATIONID 10036
#define IDS_REPORT_MESSAGEDELIVERY      10037
#define IDS_READJOURNALMESSAGE          10038
#define IDS_MQMSG_CLASS_NORMAL          10039
#define IDS_MQMSG_CLASS_REPORT          10040
#define IDS_MQMSG_CLASS_NACK_Q_DELETED  10041
#define IDS_MQMSG_CLASS_NACK_BAD_DST_Q  10042
#define IDS_MQMSG_CLASS_NACK_RECEIVE_TIMEOUT 10043
#define IDS_MQMSG_CLASS_NACK_Q_EXCEED_QUOTA 10044
#define IDD_COMPUTER_MSMQ_GENERAL       10044
#define IDS_MQMSG_CLASS_NACK_ACCESS_DENIED 10045
#define IDS_MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED 10046
#define IDD_COMPUTER_MSMQ_ROUTING       10046
#define IDS_MQMSG_CLASS_ACK_REACH_QUEUE 10047
#define IDS_MQMSG_CLASS_ACK_RECEIVE     10048
#define IDS_MQMSG_CLASS_NACK_PURGED     10049
#define IDS_MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT 10050
#define IDS_MQMSG_CLASS_NACK_BAD_SIGNATURE 10051
#define IDD_SITE_LINK_GENERAL           10051
#define IDS_MQMSG_CLASS_NACK_Q_PURGED   10052
#define IDS_MQMSG_CLASS_NACK_BAD_ENCRYPTION 10053
#define IDD_QUEUE_GENERAL               10053
#define IDS_MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT 10054
#define IDS_MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q 10055
#define IDS_MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_MSG 10056
#define IDS_MQMSG_DELIVERY_EXPRESS      10057
#define IDS_MQMSG_DELIVERY_RECOVERABLE  10058
#define IDS_CALG_MD2                    10059
#define IDD_QUEUENAME                   10059
#define IDS_CALG_MD4                    10060
#define IDS_CALG_MD5                    10061
#define IDS_CALG_SHA                    10062
#define IDS_CALG_MAC                    10063
#define IDS_CALG_RSA_SIGN               10064
#define IDS_CALG_DSS_SIGN               10065
#define IDS_CALG_RSA_KEYX               10066
#define IDS_CALG_DES                    10067
#define IDS_CALG_RC2                    10068
#define IDS_CALG_RC4                    10069
#define IDS_CALG_SEAL                   10070
#define IDS_CALG_DH_SF                  10071
#define IDS_CALG_DH_EPHEM               10072
#define IDS_MQ_PRIV_LEVEL_NONE          10073
#define IDS_MQ_PRIV_LEVEL_OPTIONAL      10074
#define IDS_MQ_PRIV_LEVEL_BODY          10075
#define IDS_NO                          10076
#define IDS_YES                         10077
#define IDS_UNKNOWN                     10078
#define IDS_MSMQ_OS_NONE                10079
#define IDS_MSMQ_OS_FOREIGN             10080
#define IDR_MsmqCompExt                 10081
#define IDS_LOCALOUTGOING_FOLDER        10081
#define IDS_MSMQ_OS_95                  10082
#define IDD_ENTERPRISE_GENERAL          10083
#define IDS_MGMT_QUEUE_TYPE_PUBLIC      10083
#define IDS_MSMQ_OS_NTW                 10084
#define IDS_MSMQ_OS_NTS                 10085
#define IDS_MSMQ_OS_NTE                 10086
#define IDE_INVALIDGUID                 10087
#define IDS_MGMT_QUEUE_TYPE_PRIVATE     10088
#define IDS_MQSRV_SERVER                10089
#define IDS_MGMT_QUEUE_TYPE_MACHINE     10090
#define IDS_MSMQ_TRIGGERS               10091
#define IDS_MGMT_QUEUE_TYPE_CONNECTOR   10092
#define IDS_MQSRV_FOREIGN_WORKSTATION   10093
#define IDS_MGMT_QUEUE_STATE_LOCAL      10094
#define IDS_MQSRV_INDEPENDENT_CLIENT    10095
#define IDE_NO_DS_SNAPIN                10096
#define IDS_MGMT_QUEUE_STATE_NONACTIVE  10097
#define IDR_ENTERPRISEDATAOBJECT        10098
#define IDS_MGMT_QUEUE_STATE_WAITING    10098
#define IDR_LINKDATAOBJECT              10099
#define IDS_MGMT_QUEUE_STATE_NEED_VALIDATE 10099
#define IDR_USERCERTIFICATE             10100
#define IDS_MGMT_QUEUE_STATE_ONHOLD     10100
#define IDB_MESSAGE_16                  10101
#define IDS_MGMT_QUEUE_STATE_CONNECTED  10101
#define IDB_MESSAGE_32                  10102
#define IDS_MGMT_QUEUE_STATE_DISCONNECTING 10102
#define IDD_SNAPIN                      10103
#define IDS_MGMT_QUEUE_STATE_DISCONNECTED 10103
#define IDS_NAME                        10104
#define IDD_MESSAGE_GENERAL             10104
#define IDS_TYPE                        10105
#define IDD_MESSAGE_SENDER              10105
#define IDS_DESCRIPTION                 10106
#define IDD_MESSAGE_QUEUE               10106
#define IDS_MGMT_QUEUE_LOCAL_LOCATION   10107
#define IDS_COMBO_SELECTION_NONE        10108
#define IDR_RDMSG_MENU                  10108
#define IDS_OUTOFMEMORY                 10109
#define IDC_MSGLABEL                    10109
#define IDS_DS_ERROR                    10110
#define IDR_MMCICONS_16x16              10110
#define IDS_UNKNOWN_ERROR_FORMAT        10111
#define IDC_MSGID                       10111
#define IDS_OP_GET_PROPERTIES_OF        10112
#define IDR_MMCICONS_32x32              10112
#define IDS_OP_SET_PROPERTIES_OF        10114
#define IDC_MSGTRACK                    10114
#define IDS_FRS_ALREADY_EXIST           10115
#define IDC_MSGPRIORITY                 10115
#define IDS_NEW_QUEUE                   10116
#define IDC_MSGCLASS                    10116
#define IDS_LOOKUP_BEGIN                10117
#define IDC_MSGSENT                     10117
#define IDS_OP_CREATE                   10118
#define IDC_MSGARRIVED                  10118
#define IDS_DELETE                      10119
#define IDC_MSGGUID                     10119
#define IDS_DELETE_QUESTION             10120
#define IDC_MSGPATHNAME                 10120
#define IDS_OP_DELETE                   10121
#define IDC_MSGUSER                     10121
#define IDC_MSGSID                      10122
#define IDS_DISPLAY_ERROR_FORMAT        10122
#define IDC_MSGAUTHENTICATED            10123
#define IDS_MACHINEQ_TYPE_DEADXACT      10123
#define IDC_MSGHASHALG                  10124
#define IDS_MACHINEQ_TYPE_JOURNAL       10124
#define IDC_MSGENCRYPT                  10125
#define IDS_MACHINEQ_TYPE_DEADLETTER    10125
#define IDC_MSGENCRYPTALG               10126
#define IDS_PRIVATE_FOLDER              10126
#define IDS_DAYS                        10127
#define IDC_MSG_DST_FN                  10127
#define IDS_SECONDS                     10128
#define IDC_MSG_RSP_FN                  10128
#define IDS_MINUTES                     10129
#define IDC_MSG_ADMIN_FN                10129
#define IDS_NEW_LINK                    10130
#define IDC_MSG_DST_PN                  10130
#define IDC_MSG_RSP_PN                  10131
#define IDS_MISSING_SITE_NAME           10131
#define IDS_HOURS                       10132
#define IDC_MSG_ADMIN_PN                10132
#define IDS_QUEUE_ENCRYPT_NONE          10133
#define IDS_QUEUE_ENCRYPT_OPTIONAL      10134
#define IDS_QUEUE_ENCRYPT_BODY          10135
#define IDS_SYSTEM_QUEUES               10136
#define IDS_COLUMN_NAME                 10137
#define IDS_OP_REQUESTPRIVATEQUEUE      10138
#define IDS_OP_PURGE                    10139
#define IDS_CONFIRM_PURGE               10140
#define IDS_MSMQADMIN                   10141
#define IDS_OP_READMESSAGE              10142
#define IDS_BODY_SIZE_PARTIAL_MESSAGE   10143
#define IDC_FIRST_SITE_COMBO            10144
#define IDS_BODY_SIZE_NORMAL_MESSAGE    10144
#define IDC_SECOND_SITE_COMBO           10145
#define IDS_BOTH_SITES_ARE_SAME         10145
#define IDS_CLIENTS_HEADING             10146
#define IDD_NEW_MSMQ_LINK               10147
#define IDS_SITE_LINK_LABEL             10147
#define IDS_SITE                        10148
#define IDS_SITE_LINK                   10149
#define IDC_MBODY_SIZE_MESSAGE          10150
#define IDD_MESSAGE_BODY                10150
#define IDS_LINK_DESCRIPTION            10150
#define IDS_DELETE_USER_CERT_ERROR      10151





/////////////////////////////////////////////////////////////////////////////
//
// Icon defined in Active Directory schema
// Location and value as listed below
//  1. Two new optional attributes in the USER object.
//  mSMQSignCertificatesMig - single-valued, ADSTYPE_OCTET_STRING, not in GC, not indexed
//  mSMQDigestsMig             - multi-valued,   ADSTYPE_OCTET_STRING, not in GC, not indexed    
//  
//  2. Add iconPath to existing display specifiers:
//  CN=mSMQQueue-Display,CN=409,CN=DisplaySpecifiers,CN=Configuration,DC=...
//  iconPath=0,mqsnap.dll,-251
//  
//  CN=mSMQConfiguration-Display,CN=409,CN=DisplaySpecifiers,CN=Configuration,DC=...
//  iconPath=0,mqsnap.dll,-252
//  
//  CN=mSMQEnterpriseSettings-Display,CN=409,CN=DisplaySpecifiers,CN=Configuration,DC=...
//  iconPath=0,mqsnap.dll,-253
//  
//  CN=mSMQSiteLink-Display,CN=409,CN=DisplaySpecifiers,CN=Configuration,DC=...
//  iconPath=0,mqsnap.dll,-254
//  
//  CN=mSMQSettings-Display,CN=409,CN=DisplaySpecifiers,CN=Configuration,DC=...
//  iconPath=0,mqsnap.dll,-255
//
#define IDI_QUEUE                         251
#define IDI_COMPUTER_MSMQ				  252
#define IDI_ENTERPRISE                    253
#define IDI_SITE_LINK                     254
#define IDI_SERVER_SETTINGS               255

#define IDD_SITE_LINK_GATES             10152

#define IDS_SHOWCERTINSTR               10152
#define IDD_USER_CERTIFICATE            10153

#define IDS_MISSING_FOREIGN_SITE_NAME   10153
#define IDS_PING_FAILED                 10154

#define IDS_PING_SUCCEEDED              10155

#define IDS_TESTQ_LABEL                 10156
#define IDS_TEST_TITLE_FORMAT           10157
#define IDI_PING                        10157
#define IDS_OP_SEND_TEST_MESSAGE        10158
#define IDI_SEND_TEST                   10158
#define IDS_LB_NONE                     10159
#define IDI_TRACKING                    10159
#define IDS_OP_SET_REPORTQUEUE          10160
#define IDS_OP_SET_PROPAGATION_FLAG     10161
#define IDS_REPORTQ_LABEL               10162
#define IDS_CANNOT_OPEN_PING_RESPONSE_QUEUE 10163
#define IDS_NEW_FOREIGN_SITE            10164
#define IDS_CREATE_SITE_FAILED          10165
#define IDS_FOREIGN_SITE                10166
#define IDR_FOREIGNSITEDATA             10167
#define IDS_CANNOT_GET_REPORT_QUEUE     10167
#define IDS_CANNOT_GET_TRACKING_FLAG    10168
#define IDS_NEW_FOREIGN_COMPUTER        10169
#define IDS_PLEASE_SELECT_A_SITE        10170
#define IDS_OP_CREATE_COMPUTER          10171
#define IDS_OP_CREATE_MSMQ_OBJECT       10172
#define IDS_FOREIGN_SITE_CREATED        10173
#define IDS_FOREIGN_COMPUTER_CREATED    10174
#define IDS_PLEASE_ENTER_A_COMPUTER_NAME 10175
#define IDS_FIND_QUEUE_TITLE            10176
#define IDS_FIND_QUEUE_DIALOG_TITLE     10177
#define IDS_MGMT_QUEUE_REMOTE_LOCATION  10178
#define IDS_STRING279                   10179
#define IDS_LABEL                       10180
#define IDS_FULL_PATH                   10182
#define IDS_REPORT_MESSAGE_APPSPECIFIC  10183
#define IDS_CREATED_WAIT_FOR_REPLICATION 10184
#define IDS_CREATED_CLICK_REFRESH       10185
#define IDS_REPLICATION_PROBLEMS        10186
#define IDS_PRIVATE_QUEUE_NOT_SUPPORTED 10187
#define IDS_NOCONNECTION_TO_SRVICE      10188
#define IDS_LOCAL_MACHINE_ADM           10189
#define IDS_LQ_PATHNAME                 10190
#define IDS_LQ_TYPE                     10191
#define IDS_LQ_LOCATION                 10192
#define IDS_LQ_XACT                     10193
#define IDS_LQ_FOREIGN                  10194
#define IDS_LQ_MSGCOUNT                 10195
#define IDS_LQ_USEDQUOTA                10196
#define IDS_LQ_STATE                    10197
#define IDS_LQ_NEXTHOP                  10198
#define IDS_LQ_JMSGCOUNT                10199
#define IDS_LQ_JUSEDQUOTA               10200
#define IDS_CONNECT_QUESTION            10201
#define IDS_DISCONNECT_QUESTION         10202
#define IDS_PAUSE_QUESTION              10203
#define IDS_RESUME_QUESTION             10204
#define IDS_MGMT_QUEUE_CORRECT_TYPE     10205
#define IDS_MGMT_QUEUE_INCORRECT_TYPE   10206
#define IDS_MGMT_QUEUE_UNKNOWN_TYPE     10207
#define IDS_OPERATION_FAILED            10208
#define IDS_LQ_READCOUNT                10209
#define IDS_LQ_ACKCOUNT                 10210
#define IDS_LQ_FORMATNM                 10211
#define IDS_Q_PATHNAME                  10212
#define IDS_Q_LABEL                     10213
#define IDS_Q_QUOTA                     10214
#define IDS_Q_TRANSACTION               10215
#define IDS_Q_TYPE                      10216
#define IDS_Q_AUTHENTICATE              10217
#define IDS_Q_JOURNAL                   10218
#define IDS_Q_JOURNAL_QUOTA             10219
#define IDS_Q_PRIV_LEVEL                10220
#define IDS_Q_BASEPRIORITY              10221
#define IDS_SEC_TAKE_OWNERSHIP          10222
#define IDS_SEC_SET_PERMISSIONS         10223
#define IDS_SEC_GET_PERMISSIONS         10224
#define IDS_SEC_SET_PROPERTIES          10225
#define IDS_SEC_GET_PROPERTIES          10226
#define IDS_SEC_DELETE                  10227
#define IDS_SEC_PEEK_MESSAGE            10228
#define IDS_SEC_SEND_MESSAGE            10229
#define IDS_SEC_RECEIVE_JOURNAL_MESSAGE 10230
#define IDS_SEC_RECEIVE_MESSAGE         10231
#define IDS_SEC_DELETE_MESSAGE          10232
#define IDS_SEC_WRITE_MESSAGE           10233
#define IDS_SEC_DELETE_JOURNAL_MESSAGE  10234
#define IDS_SEC_ACCESS_ALL              10235
#define IDS_OP_GET_SECURITY_DESCRIPTOR  10236
#define IDS_OP_SET_SECURITY_DESCRIPTOR  10237
#define IDS_OP_PATHNAMETOFORMAT         10238
#define IDS_REMOTE_PRIVATE_QUEUE_OPERATION 10239
#define IDS_OP_GETFORMATNAME            10240
#define IDS_OP_RETRIEVE_DEP_CLIENTS     10241
#define IDS_UNKNOWN_OR_DELETED_SITE     10242
#define IDS_INFINITE_QUOTA              10243
#define IDS_PRODUCT_DESCRIPTION         10244
#define IDS_COMPANY                     10245
#define IDS_VERSION_FORMAT              10246
#define IDS_HELPPATH                    10247
#define IDS_HELPTOPIC_GENERAL           10248
#define IDS_HTMLHELP_NAME               10249
#define IDS_LOCALPUBLIC_FOLDER          10250
#define IDS_MQMSG_CLASS_NACK_RECEIVE_TIMEOUT_AT_SENDER 10251
#define IDS_MQMSG_CLASS_NACK_UNSUPPORTED_CRYPTO_PROVIDER 10252
#define IDS_HELPTOPIC_QUEUES            10253
#define IDS_HELPTOPIC_MESSAGES          10254
#define IDS_HELPTOPIC_TRIGGERS          10255
#define IDS_THIS_COMPUTER               10256
#define IDS_OP_DISPLAY_SECURITY_PAGE    10257
#define IDS_YOU_MUST_SPECIFY_SITE       10258
#define IDS_RULE_NAME_REQUIRED          10259
#define IDS_QUEUES_BELONG_TO_NT4        10260
#define IDS_WRITE_REQUEST_FAILED        10261
#define IDS_SERVER_SITES_WARNING        10262
#define IDS_WARNING_DS_PUBLIC_QUEUES_NOT_AVAILABLE 10263
#define IDS_MULTI_DELETE_QUESTION       10264
#define IDS_DELETE_ONE_QUEUE_ERROR      10265
#define IDS_MULTI_DELETE_ERROR          10266
#define IDS_QUEUES_DELETED_HIT_REFRESH  10267
#define IDS_MQPING                      10268
#define IDS_BOTH_SITES_ARE_FOREIGN      10269
#define IDD_COMPUTER_MSMQ_DEPENDENT_CLIENTS 10270
#define IDS_WARN_ABOUT_FOREIGN_SITES    10270
#define IDS_SEC_CREATE_QUEUE            10271
#define IDS_SEC_RECEIVE_DEAD_LETTER_MESSAGE 10272
#define IDS_SEC_PEEK_DEAD_LETTER_MESSAGE 10273
#define IDS_SEC_PEEK_COMPUTER_JOURNAL   10274
#define IDS_SEC_DELETE_DEAD_LETTER_MESSAGE 10275
#define IDS_SEC_RECEIVE_MACHINE_JOURNAL 10276
#define IDS_SEC_DELETE_MACHINE_JOURNAL  10277
#define IDS_MACHINE_BELONG_TO_NT4       10278
#define IDS_MAX_MUST_BE_LESS_THEN       10279
#define IDR_ALIASQOBJECT                10280
#define IDS_ILLEGAL_DEAFULT_MSG_BODY_SIZE 10280
#define IDS_INIT_THREAD_MUST_BE_LESS_THEN_MAX 10281
#define IDS_RULE_DEFINITION             10282
#define IDS_TRIGGER_DEFINITION          10283
#define IDS_RULE_NAME                   10284
#define IDS_RULE_DESCRIPTION            10285
#define IDS_RULE_SHOW_WINDOW            10286
#define IDS_TRIGGER_NAME                10287
#define IDS_TRIGGER_QUEUE               10288
#define IDS_NUM_OF_RULES                10289
#define IDS_TRIGGER_ENABLED             10290
#define IDS_TRIGGER_SERIALIZED          10291
#define IDS_COND_LABEL_CONTAIN          10292
#define IDS_COND_LABEL_NOT_CONTAIN      10293
#define IDS_COND_BODY_CONTAIN           10294
#define IDS_COND_BODY_NOT_CONTAIN       10295
#define IDS_COND_PRIORITY_EQUAL         10296
#define IDS_COND_PRIORITY_NOT_EQUAL     10297
#define IDS_COND_PRIORITY_GRATER        10298
#define IDS_COND_PRIORITY_LESS          10299
#define IDD_TESTMESSAGE                 10300
#define IDS_COND_APP_EQUAL              10300
#define IDD_MACHINE_TRACKING            10301
#define IDS_COND_APP_NOT_EQUAL          10301
#define IDS_COND_APP_GREATER            10302
#define IDD_COMPUTER_MSMQ_DIAGNOSTICS   10303
#define IDS_COND_APP_LESS               10303
#define IDS_COND_SRCID_EQUAL            10304
#define IDD_NEWTYPED_QUEUE              10305
#define IDS_COND_SRCID_NOT_EQUAL        10305
#define IDD_COMPUTER_MSMQ_SITES         10306
#define IDS_ACT_MSGID                   10306
#define IDD_CREATE_FOREIGN_SITE         10307
#define IDS_ACT_MSG_LABEL               10307
#define IDS_ACT_MSG_BODY_VARIANT        10308
#define IDD_FOREIGN_SITE                10309
#define IDS_ACT_MSG_BODY                10309
#define IDD_CREATE_FOREIGN_COMPUTER     10310
#define IDS_ACT_MSG_PRIORITY            10310
#define IDI_MSGICON                     10311
#define IDD_GENERALERROR                10311
#define IDS_ACT_MSG_CORRELATION         10311
#define IDD_STORAGE                     10312
#define IDS_ACT_QUEUE_PATH              10312
#define IDD_INFO_DLG                    10313
#define IDS_ACT_QUEUE_FORMATNAME        10313
#define IDD_RESTART                     10314
#define IDS_ACT_RESPONSE_FORMATNAME     10314
#define IDD_LOCAL_USERCERT              10315
#define IDS_ACT_ADMIN_FORMATNAME        10315
#define IDD_MOBILE                      10316
#define IDS_ACT_APP_SPECIFIC            10316
#define IDD_CLIENT                      10317
#define IDS_ACT_TRIGGER_NAME            10317
#define IDD_SERVICE_SECURITY            10318
#define IDS_ACT_TRIGGER_ID              10318
#define IDS_ACT_SRC_ID                  10319
#define IDS_COND_ITEAM                  10320
#define IDI_JOURNAL_MSG                 10321
#define IDS_LAST_COND_ITEAM             10321
#define IDI_REPORT_MSG                  10322
#define IDS_RULE_TITLE                  10322
#define IDI_ACK_MSG                     10323
#define IDS_ILLEAGL_CONDITION           10323
#define IDI_NACK_MSG                    10324
#define IDS_MSG_ID_PARAM                10324
#define IDI_TEST_MSG                    10325
#define IDS_MSG_LABEL_PARAM             10325
#define IDI_DEADLTR_MSG                 10326
#define IDS_MSG_BODY_PARAM              10326
#define IDI_PRIVATE_QUEUE               10327
#define IDS_MSG_BODY_STR_PARAM          10327
#define IDR_LOCALACTIVE_MENU            10328
#define IDS_MSG_PREIORITY_PARAM         10328
#define IDR_LOCALADM_MENU               10329
#define IDS_MSG_CORRELATION_PARAM       10329
#define IDR_LOCALOUTGOINGQUEUE_MENU     10330
#define IDS_MSG_QUEUE_PN_PARAM          10330
#define IDR_LOCALPRIVATE_MENU           10331
#define IDR_MsmqPrivQExt                10331
#define IDS_MSG_QUEUE_FN_PARAM          10331
#define IDR_LOCALPUBLIC_MENU            10332
#define IDS_MSG_RESP_QUEUE_PARAM        10332
#define IDR_REMOTEPRIVATE_MENU          10333
#define IDR_MIGRATEDUSERCERTIFICATE     10333
#define IDS_MSG_ADMIN_QUEUE_PARAM       10333
#define IDR_IPPUBLIC_MENU               10334
#define IDS_MSG_APP_PARAM               10334
#define IDD_ALIAS_GENERAL               10335
#define IDR_TRIGGER_MENU                10335
#define IDS_MSG_SRC_MACHINE_PARAM       10335
#define IDD_NEW_ALIAS                   10336
#define IDR_RULE_DEF_MENU               10336
#define IDS_MSG_ARRIVED_TIME_PARAM      10336
#define IDI_ALIAS                       10337
#define IDR_TRIGGER_DEF_MENU            10337
#define IDS_MSG_SENT_TIME_PARAM         10337
#define IDD_TRIGGER_CONFIG              10337
#define IDD_TRIGGER_RULE_GENEARL        10338
#define IDS_BAD_RULE_ACTION             10338
#define IDR_TRIGADM_MENUE               10338
#define IDD_TRIGGER_RULE_COND           10339
#define IDS_COND_LEGTH_EXCEEDED         10339
#define IDR_ATTACHED_RULE_MENU          10339
#define IDI_TRIGGER_GENEARL             10340
#define IDD_TRIGGER_RULE_ACTION         10340
#define IDS_COND_TYPE_NOT_SELECTED      10340
#define IDD_RULE_ACTION_PARAM           10341
#define IDS_TRIGGER_NAME_PARAM          10341
#define IDS_TRIGGER_ID_PARAM            10342
#define IDD_TRIGGER_GEN                 10342
#define IDS_NUM_PARAM                   10343
#define IDD_ATTACH_RULE                 10343
#define IDS_STRING_PARAM                10344
#define IDD_ADD_ATTACH_RULE             10344
#define IDS_LITERAL_VALUE_REQUIRES      10345
#define IDS_ILLEGAL_NUMERIC_VALUE       10346
#define IDS_NEW_RULE_CAPTION            10347
#define IDS_ILLEGAL_INVOCE              10348
#define IDS_NEW_RULE_FAILED             10349
#define IDS_ILLEAGL_PRIORITY_VALUE      10350
#define IDS_ILLEAGL_NUMERIC_VALUE       10351
#define IDS_ILLEAGL_SRC_MACHINE_VALUE   10352
#define IDS_PARAM_NO_EXEEDED            10354
#define IDS_MISSING_QUEUE_PATHNAME      10355
#define IDS_MISSING_TRIGGER_NAME        10356
#define IDS_ILLEGAL_QUEUE_PATH          10357
#define IDS_QUEUE_NOT_REGISTER          10358
#define IDS_QUEUE_NOT_VALIDATE          10359
#define IDS_OPEN_QUEUE_FAILED           10360
#define IDS_NEW_TRIGGER_CAPTION         10361
#define IDS_RULE_ID                     10362
#define IDS_TRIGGER_ID                  10363
#define IDS_MSG_LOOKUP_ID               10364
#define IDS_PROC_TYPE                   10365
#define IDD_QUEUE_MULTICAST             10365
#define IDS_XACT_NO_RETRIEVE            10366
#define IDS_QUEUE_NOT_XACT              10367
#define IDS_NEW_TRIGGER_FAILED          10368
#define IDS_DISPLAY_PEEK                10369
#define IDS_DISPLAY_RECEIVE             10370
#define IDS_DISPLAY_RECEIVE_XACT        10371
#define IDS_ILLEGAL_STRING_VALUE        10372
#define IDS_STOP_SERVICE_ERR            10373
#define IDS_DEP_SERVICES_LIST           10374
#define IDS_OK                          10375
#define IDI_FOREIGN_SITE_ICON           10377
#define IDS_SITES                       10377
#define IDI_FOREIGN_COMPUTER_ICON       10378
#define IDS_COMPUTERS                   10378
#define IDS_NEW_PRIVATE_QUEUE           10379
#define IDS_MSMQ_MAY_BE_DOWN            10380
#define IDS_INVALID_DN_SYNTAX           10381
#define IDS_MAYBE_INVALID_DN_SYNTAX     10382
#define IDI_TRIGGER_GENERAL             10382
#define IDS_ERROR_DW_FORMAT             10383
#define IDI_TRIGDEF                     10383
#define IDS_NO_DS_ERROR                 10384
#define IDI_RULE                        10384
#define IDD_NEW_TRIGGER_GEN             10385
#define IDS_TRANSACTIONAL_Q             10385
#define IDD_NEW_ATTACH_RULE             10386
#define IDS_NONTRANSACTIONAL_Q          10386
#define IDD_NEW_TRIGGER_RULE_GENEARL    10387
#define IDD_NEW_TRIGGER_RULE_COND       10388
#define IDD_NEW_TRIGGER_RULE_ACTION     10389
#define IDS_CREATED_BUT_RETRIEVE_FAILED 10390



// changed from 1000 to 10400

#define IDC_FIND_EDITTYPE               10400							
#define IDC_LINK_COST                   10401
#define IDC_COMPUTER_MSMQ_NAME          10402
#define IDC_QGENERAL_ID                 10403
#define IDC_QGENERAL_NAME               10404
#define IDC_QGENERAL_QLABEL             10405
#define IDC_QGENERAL_TRANSACTIONAL      10406
#define IDC_QGENERAL_TYPEID             10407
#define IDC_QGENERAL_TRANSACTIONAL_LABEL 10408
#define IDC_QMULTICAST_QADDRESS         10409
#define IDC_QMESSAGES_JOURNAL           10414
#define IDC_QMESSAGES_QUOTA             10415
#define IDC_QMESSAGES_JOURNAL_QUOTA     10416
#define IDC_INROUTCOMBO_0               10417
#define IDC_INROUTCOMBO_1               10418
#define IDC_INROUTCOMBO_2               10419
#define IDC_INROUT_LABEL                10420
#define IDC_OUTROUT_LABEL               10421
#define IDC_OUTROUTCOMBO_0              10423
#define IDC_OUTROUTCOMBO_1              10424
#define IDC_OUTROUTCOMBO_2              10425
#define IDC_QUEUENAME                   10426
#define IDC_REPORTQUEUE_NEW             10508
#define IDC_REPORTQUEUE_NAME            10509
#define IDC_TESTMESSAGE_DESTQ           10510
#define IDC_TESTMESSAGE_NEW             10511
#define IDC_NEWQTYPE_QUEUENAME          10515
#define IDC_TRACK_ALL                   10519
#define IDC_TRACK_TEST                  10520
#define IDC_TESTMESSAGE_SEND            10521
#define IDC_TESTMESSAGE_CLOSE           10522
#define IDC_TESTMESSAGE_NO_SENT         10523
#define IDC_TRANSACTIONAL               10528
#define IDC_BASEPRIORITY_SPIN           10530
#define IDC_COMPUTER_MSMQ_QUOTA         10546
#define IDC_COMPUTER_MSMQ_JOURNAL_QUOTA 10547
#define IDC_COMPUTER_MSMQ_SERVICE_LABEL 10558
#define IDC_QUEUE_MQUOTA_CHECK          10564
#define IDC_QUEUE_JQUOTA_CHECK          10565
#define IDC_QUEUE_ENCRIPTION_LABEL      10566
#define IDC_QUEUE_BASEPRIORITY_LABEL    10567
#define IDC_COMPUTER_MSMQ_MQUOTA_CHECK  10569
#define IDC_COMPUTER_MSMQ_JQUOTA_CHECK  10570
#define IDC_MQUEUE_MULTIDEST_FRAME      10571
#define IDC_MQUEUE_MULTIDEST_FORMAT_LABEL 10572
#define IDC_MSG_MULTIDST_FN             10573
#define IDC_MESSAGE_TRACKING_EXPLANATION 10588
#define IDC_REPORTQUEUE_NAME_LABEL      10589
#define IDC_QUEUENAME_LABEL             10590
#define IDC_MSGGNRL_TITLE_LABEL         10593
#define IDC_MSGGNRL_ID_LABEL            10594
#define IDC_MSGGNRL_PRIORITY_LABEL      10595
#define IDC_MSGGNRL_TRACKED_LABEL       10596
#define IDC_MSGGNRL_CLASS_LABEL         10597
#define IDC_MSGGNRL_SENT_TIME_LABEL     10598
#define IDC_MSGGNRL_ARRIVED_TIME_LABEL  10599
#define IDC_MQUEUE_DEST_FRAME           10600
#define IDC_MQUEUE_DEST_FORMAT_LABEL    10601
#define IDC_MQUEUE_DEST_PATH_LABEL      10602
#define IDC_MQUEUE_RESP_FRAME           10603
#define IDC_MQUEUE_RESPONSE_FORMAT_LABEL 10604
#define IDC_MQUEUE_RESPONSE_PATH_LABEL  10605
#define IDC_MQUEUE_ADMIN_FRAME          10606
#define IDC_MQUEUE_ADMIN_FORMAT_LABEL   10607
#define IDC_MQUEUE_ADMIN_PATH_LABEL     10608
#define IDC_MSENDER_SOURCE_FRAME        10609
#define IDC_MSENDER_SOURCE_GUID_LABEL   10610
#define IDC_MSENDER_SOURCE_PATH_LABEL   10611
#define IDC_MSENDER_SENDER_FRAME        10612
#define IDC_MSENDER_SECURITY_FRAME      10613
#define IDC_MSENDER_UID_LABEL           10614
#define IDC_MSENDER_SID_LABEL           10615
#define IDC_MSENDER_AUTHENTICATED_LABEL 10616
#define IDC_MSENDER_HASH_ALG_LABEL      10617
#define IDC_MSENDER_ENCRYPTED_LABEL     10618
#define IDC_MSENDER_ENCRYPT_ALG_LABEL   10619
#define IDC_NEWQTYPE_QUEUENAME_LABEL    10620
#define IDC_QGENERAL_QLABEL_LABEL       10625
#define IDC_QGENERAL_TYPEID_LABEL       10626
#define IDC_QMULTICAST_QADDRESS_LABEL   10627
#define IDC_TESTMESSAGE_DESTQ_LABEL     10638
#define IDC_TESTMESSAGE_NO_SENT_LABEL   10639
#define IDC_COMPUTER_MSMQ_SERVICE       10640
#define IDC_QMESSAGES_AUTHENTICATED     10645
#define IDC_FOREIGN_COMPUTER_NAME       10651
#define IDC_ENT_GEN_LONGLIVE_EDIT       10652
#define IDC_ENT_GEN_LONGLIVE_UNITS_COMBO 10656
#define IDC_ENT_GEN_LONGLIVE_EDIT_LABEL 10657
#define IDC_EGENERAL_DEFINITIONS_FRAME  10658
#define IDC_DEPENDENT_CLIENTS_REFRESH   10666
#define IDC_DEPENDENT_CLIENTS           10669
#define IDC_MESSAGE_BODY_EDIT           10700
#define IDC_SITE_FRS_LIST               10701
#define IDB_SITE_GATE_ADD               10702
#define IDB_SITE_GATE_REMOVE            10703
#define IDC_SITE_GATES_LIST             10704
#define IDC_SITE_GATE_LABEL             10705
#define IDC_SITE_FRS_LABEL              10706
#define IDC_LINK_LABEL                  10709
#define IDC_CERT_LIST                   10710
#define IDC_CERT_VIEW                   10711
#define IDC_CERT_REMOVE                 10712
#define IDC_CERTLABEL                   10713
#define IDC_ALLSITES_LABEL              10715
#define IDC_CURRENTSITES_LABEL          10716
#define IDC_ALLSITES_LIST               10717
#define IDC_CURRENTSITES_LIST           10718
#define IDC_SITES_ADD                   10719
#define IDC_SITES_REMOVE                10720
#define IDC_DIAG_SEND_TEST              10727
#define IDC_DIAG_TRACKING               10729
#define IDC_DIAG_PING                   10731
#define IDC_FOREIGN_SITE_NAME           10732
#define IDC_FOREIGN_SITE_LABEL          10733
#define IDC_FOREIGN_LABEL               10734
#define IDC_DEPCLIENTS_LABEL            10736
#define IDC_DIAG_PING_LABEL             10737
#define IDC_DIAG_PING_ICON              10740
#define IDC_DIAG_SENDTEST_ICON          10741
#define IDC_DIAG_TRACKING_ICON          10742
#define IDC_LINK_COST_LABEL             10747
#define IDC_FCOMPNAME_LABEL             10748
#define IDC_FOREIGN_COMPUTER_SITE       10749
#define IDC_FCOMPSITE_LABEL             10750
#define IDC_FIND_EDITLABEL              10753
#define IDC_FIND_LABEL_LABEL            10754
#define IDC_LINK_COST_EDIT              10755
#define IDC_COMPUTER_MSMQ_ID            10756
#define IDC_QMESSAGES_PRIVLEVEL         10757
#define IDC_QUEUE_BASEPRIORITY          10758
#define IDC_MESSAGE_ICON                10760
#define IDC_COMPUTER_MSMQ_ID_LABEL      10761
#define IDC_FIRST_SITE_LABEL            10762
#define IDC_SECOND_SITE_LABEL           10763
#define IDC_QGENERAL_ID_LABEL           10764
#define IDC_DIAG_SENDTEST_LABEL         10765
#define IDC_DIAG_TRACKING_LABEL         10766
#define IDC_COMPUTER_MSMQ_ICON          10767
#define IDC_QGENERAL_ICON               10768
#define IDC_QNAME_PRIVATE_TITLE         10769
#define IDC_COMPUTER_SITES_TITLE        10770
#define IDC_ENT_GEN_TITLE               10771
#define IDC_ENTERPRISE_GENERAL          10772
#define IDC_ROUTING_LINK_ICON           10773
#define IDC_ERROR_LABEL                 10774
#define IDC_Storage_Explanation_LABEL1  10775
#define IDC_Storage_Explanation_LABEL2  10776
#define ID_MessageLogger_LABEL          10778
#define ID_TransactionLogger_LABEL      10779
#define ID_MessageLogger                10780
#define ID_TransactionLogger            10781
#define ID_MessageFiles                 10782
#define IDC_Moving_Files_LABEL          10783
#define IDC_RESTART_WARNING             10784
#define IDC_Security_Cert_FRAME         10785
#define IDC_Security_InternalCert_LABEL 10786
#define ID_Register_LABEL               10787
#define ID_Register                     10788
#define ID_View_LABEL                   10789
#define ID_View                         10790
#define ID_Remove                       10791
#define ID_Remove_LABEL                 10792
#define IDC_SERVER_COMM_FRAME           10793
#define IDC_CRYPTO_KEYS_FRAME           10794
#define ID_RenewCryp                    10795
#define ID_RenewCert                    10796
#define IDC_USE_SECURED_SEVER_COMM      10797
#define IDC_CAS                         10798
#define IDC_MOBILE_FRAME                10799
#define IDC_Mobile_Explanation_LABEL    10800
#define ID_CurrentSite                  10801
#define ID_CurrentSite_LABEL            10802
#define ID_SiteList_LABEL               10803
#define ID_SiteList                     10804
#define IDC_ServerName                  10805
#define IDC_ServerName_LABEL            10806
#define IDC_SERVER_AUTHENTICATION       10807
#define IDC_SERVER_AUTHENTICATION_LABEL 10808
#define IDC_SERVER_AUTHENTICATION_FRAME 10809
#define ID_MessageFiles_LABEL           10810
#define IDC_ALIAS_LABEL                 10811
#define IDC_ALIAS_FORMATNAME_LABEL      10812
#define IDC_ALIAS_FORMATNAME            10813
#define IDC_ALIAS_DESCRIPTION_LABEL     10814
#define IDC_ALIAS_DESCRIPTION           10815
#define IDC_NEWALIAS_PATHNAME_LABEL     10818
#define IDC_NEWALIAS_PATHNAME           10819
#define IDC_NEWALIAS_FORMATNAME_LABEL   10820
#define IDC_NEWALIAS_FORMATNAME         10821
#define IDC_CRYPTO_KEYS_LABEL           10822
#define IDC_ALIAS_ICON                  10823
#define IDC_TRIGGER_GENERAL_HEADER      10824
#define IDC_InitThreadsCount_LABEL      10825
#define IDC_MaxThreadCount_LABEL        10826
#define IDC_DefaultMsgBodySize_LABEL    10827
#define IDC_InitThreadsCount            10828
#define IDC_MaxThreadCount              10829
#define IDC_DefaultMsgBodySize          10830
#define IDC_ConditionValue              10831
#define IDC_RULE_DESCRIPTION            10832
#define IDC_RULE_COND_TYPES             10834
#define IDC_RULECOND_LIST				10835
#define IDS_PROPERTIES					10836
#define IDC_AddRuleCondition_BTM        10837
#define IDC_RULE_LIST                   10838
#define IDC_RemoveCondition             10839
#define IDC_RULE_NAME                   10840
#define IDC_RuleName_LABEL              10841
#define IDC_RuleDescription_LABEL       10842
#define IDC_INVOKE_COM                  10846
#define IDC_INVOKE_EXE                  10847
#define IDC_SHOW_WINDOW                 10848
#define IDC_PROID_LABEL                 10849
#define IDC_EXEPATH_LABEL               10850
#define IDC_METHOD_LABEL                10851
#define IDC_COMPONENT_PROGID            10852
#define IDC_COMMETHOD_NAME              10853
#define IDC_EXE_PATH                    10854
#define IDC_TRIGGER_ICON                10862
#define IDC_RULE_ICON                   10863
#define IDC_RULE_GENERAL_TITLE          10864
#define IDC_EXE_INVOKE                  10865
#define IDC_COM_INVOKE                  10866
#define IDC_FIND_EXE_BTM                10869
#define IDC_PARAM_BTM                   10870
#define IDC_RULE_PARM_LABEL             10871
#define IDC_PARAM_BTM3                  10872
#define IDC_INVOKE_PARAM_LABEL          10873
#define IDB_PARAM_ORDER_UP              10878
#define IDB_PARM_REMOVE                 10879
#define IDB_PARAM_ADD                   10880
#define IDB_PARM_ORDER_DOWN             10881
#define IDC_PARAM_COMBO                 10882
#define IDC_LITERAL_PARAM               10883
#define IDC_LITERAL_VALUE               10884
#define IDC_INVOKE_PARMETER_LIST        10885
#define IDC_TriggerName_LABEL           10886
#define IDC_QueuePathname_LABEL         10887
#define IDC_TriggerName_EDIT            10888
#define IDC_QueuePathName               10889
#define IDC_SysyetmQueue_GROUP          10890
#define IDC_QueueMessages_RDB           10891
#define IDC_JournalMessages_RDB         10892
#define IDC_DeadlLetter_RDB             10893
#define IDC_TransactionalDeadLetter_RDB 10894
#define IDC_Enabled_CHK                 10896
#define IDC_Serialized_CHK              10897
#define IDC_ATTACHED_RULE_LIST          10899
#define IDC_RuleList_LABEL              10900
#define IDC_AttachedRule                10901
#define IDC_RemoveRule_BTM              10903
#define IDC_UpRule_BTM                  10904
#define IDC_Down_BTM                    10905
#define IDC_ATTACH_RULES_BTM            10906
#define IDC_ADD_RULE                    10907
#define IDC_PeekMessage_RDB             10908
#define IDC_ReceiveMessage_RDB          10909
#define IDC_ReceiveMessageXact_RDB      10910
#define IDC_MsgProcessingType_Group     10911
#define IDC_QMULTICAST_QADDRESS_DESCRIPTION 10912
#define ID_Renew_LABEL                  10913
#define IDC_CREATE_IN                   10914
#define IDC_ALIAS_CONTAINER             10915
#define IDC_FIND_TYPE_LABEL             10916
#define IDC_ROUTING_LINK_CONTAINER      10919
#define IDC_SITE_LINK_ICON              10920
#define IDC_FOREIGN_SITE_ICON           10922
#define IDC_FOREIGN_SITE_CONTAINER      10923
#define IDC_PUBLIC_QUEUE_ICON           10924
#define IDC_QUEUE_CONTAINER             10925
#define IDC_PRIVATE_QUEUE_ICON          10926
#define IDC_FOREIGN_COMPUTER_ICON       10927
#define IDC_FOREIGN_COMPUTER_CONTAINER  10928
#define IDC_LINK_DESCR_LABEL            10929
#define IDC_LINK_DESCR                  10930
#define IDS_PRIVATE_Q_NOT_FOUND			10931
#define IDC_Monitored_Label				10932
#define IDC_Monitored_Queue				10933
#define	IDS_COMPUTER_JOURNAL			10934
#define IDS_COMPUTER_DEADLETTER			10935
#define IDS_COMPUTER_XACT_DEADLETTER	10936
#define IDC_TRIGGER_CREATE_HEADER		10937
#define IDC_RULE_CREATE_TITLE			10938
#define IDC_FORMATNAME_EXAMPLE			10939
#define IDC_ExistingRule				10940
#define IDS_MULTIPLE_PROP_NOT_ALLOWED   10941
#define IDC_PROPERTIES_LABEL			10942
#define IDC_EXISTING_RULE_PROPS			10943
#define IDC_ATTACHED_RULE_PROPS			10944
#define IDS_SHORT_COND_BODY_CONTAIN		10945
#define IDS_SHORT_COND_BODY_NOT_CONTAIN 10946
#define IDS_SHORT_COND_APP_EQUAL		10947
#define IDS_SHORT_COND_APP_NOT_EQUAL	10948
#define IDS_SHORT_COND_APP_GREATER		10949
#define IDS_SHORT_COND_APP_LESS			10950
#define IDS_SHORT_COND_SRCID_EQUAL		10951
#define IDS_SHORT_COND_SRCID_NOT_EQUAL	10952
#define IDS_ERROR_NOT_A_DIR				10953
#define IDS_FOLDERNAME_TOO_LONG			10954
#define IDS_MISSING_MSGFILES_FOLDER		10955
#define IDS_MISSING_LOGGER_FOLDER		10956
#define IDS_MISSING_TX_LOGGER_FOLDER	10957
#define IDC_TRIGGER_ACCESS_NOTE			10958
#define IDS_SEC_ALL_EXTENDED_RIGHTS     10959
#define IDS_SEC_CREATE_ALL_CHILD_OBJECTS 10960
#define IDS_SEC_DELETE_ALL_CHILD_OBJECTS 10961
#define IDS_PUBLIC_PATHNAME_IN_WORKGROUP 10962

#define ID_MENUITEM_RDMSG_PURGE         32769
#define ID_BUTTON32771                  32771
#define ID_BUTTON32772                  32772
#define ID_BUTTON32773                  32773
#define ID_BUTTON32775                  32775
#define ID_BUTTON32776                  32776
#define ID_BUTTON32777                  32777
#define ID_BUTTON32779                  32779
#define ID_BUTTON32780                  32780
#define ID_BUTTON32781                  32781
#define ID_BUTTON32782                  32782
#define ID_BUTTON32783                  32783
#define ID_BUTTON32784                  32784
#define ID_BUTTON32793                  32786
#define ID_BUTTON32794                  32787
#define ID_BUTTON32796                  32789
#define ID_BUTTON32798                  32791
#define ID_BUTTON32799                  32792
#define ID_BUTTON32800                  32793
#define ID_BM_SMALL                     32793
#define ID_BUTTON32801                  32794
#define ID_BUTTON32802                  32795
#define ID_BUTTON32804                  32798
#define ID_BUTTON32805                  32799
#define ID_BUTTON32806                  32800
#define ID_BUTTON32807                  32801
#define ID_BUTTON32808                  32802
#define ID_BUTTON32809                  32803
#define ID_MENUITEM_LOCALADM_CONNECT    32807
#define ID_MENUITEM_LOCALADM_DISCONNECT 32808
#define ID_BUTTON32810                  32810
#define ID_BUTTON32811                  32811
#define ID_BUTTON32812                  32812
#define ID_BUTTON32813                  32813
#define ID_BUTTON32814                  32814
#define ID_BUTTON32816                  32816
#define ID_BUTTON32817                  32817
#define ID_BUTTON32818                  32818
#define ID_BUTTON32819                  32819
#define ID_MENUITEM_LOCALOUTGOINGQUEUE_PAUSE 32822
#define ID_MENUITEM_LOCALOUTGOINGQUEUE_RESUME 32823
#define ID_BUTTON32825                  32825
#define ID_MENUITEM_NEW_PRIVATE_QUEUE   32828
#define ID_MENUITEM_NEW_PUBLIC_QUEUE    32829
#define ID_NEW_NEWRULE                  32830
#define ID_NEW_TRIGGER                  32831
#define ID_TASK_ENABLE                  32834
#define ID_TASK_DISABLE                 32835
#define ID_BUTTON32841                  32841
#define ID_BUTTON32842                  32842
#define ID_BUTTON32843                  32843
#define ID_BUTTON32844                  32844
#define ID_BUTTON32845                  32845
#define ID_BUTTON32846                  32846
#define IDS_NOT_A_DIR                   57345
#define IDS_LOCAL_DRIVE                 57346
#define IDS_ASK_CREATE_DIR              57347
#define IDS_SET_DIR_SECURITY_ERROR      57348
#define IDS_DIR_SECURITY_WARNING        57349
#define IDS_CREATE_DIR_ERROR            57350
#define IDS_FAT_WARNING                 57351
#define IDS_ERROR_CODE                  57352
#define IDS_REGISTRY_ERROR              57353
#define IDS_OP_DISPLAY_STORAGE_PAGE     57354
#define IDS_MOVE_FILE_ERROR             57355
#define IDS_MOVE_FILES_RECOVERY_ERROR   57356
#define IDS_SERVICE_MANAGER_PRIVILEGE_ERROR 57357
#define IDS_SERVICE_PRIVILEGE_ERROR     57358
#define IDS_GET_SYSTEM_DIRECTORY_ERROR  57359
#define IDS_QUERY_SERVICE_ERROR         57360
#define IDS_NO_DRIVER                   57361
#define IDS_STOP_SERVICE_ERROR          57362
#define IDS_COULD_NOT_RELEASE_MSG_FILES 57363
#define IDS_Q_STOP_SRVICE               57364
#define IDS_STOP_SERVICE                57365
#define IDS_MOVING_FILES                57366
#define IDS_FAILED_TO_CREATE_LQS_DIR    57367
#define IDS_RESTART_WINDOWS_ERROR       57368
#define IDS_OP_DISPLAY_MSMQSECURITY_PAGE 57369
#define IDS_CERT_EXIST1                 57370
#define IDS_REGISTER_ERROR1             57371
#define IDS_GET_USER_CERTS_ERROR1       57372
#define IDS_DELETE_USER_CERT_ERROR1     57373
#define IDS_NEW_CRYPT_KEYS_CAPTION      57374
#define IDS_NEW_CRYPT_KEYS_WARNING      57375
#define IDS_RENEW_CRYP_ERROR            57376
#define IDS_CERT_WARNING                57377
#define IDS_CREATE_INTERNAL_CERT_ERROR1 57378
#define IDS_UNREGISTER_ERROR            57379
#define IDS_DELETE_ERROR                57380
#define IDS_INTERNAL_CERT_RENEWED       57381
#define IDS_FAILED_TO_UPDATE_CAS        57382
#define IDS_FAILED_TO_RETRIEVE_CAS      57383
#define IDS_NO_CAS                      57384
#define IDS_FAILED_TO_GET_CA_CERT       57385
#define IDS_OP_DISPLAY_PAGES            57386
#define IDS_OP_DISPLAY_MOBILE_PAGE      57387
#define IDS_OP_DISPLAY_CLIENT_PAGE      57388
#define IDS_OP_DISPLAY_SRVAUTH_PAGE     57389
#define IDS_FAIL_CRYPTUI                57390
#define IDS_FAIL_OPEN_MY                57391
#define IDS_SELECT_SRV_CERT             57392
#define IDS_FAIL_CERT_OBJ               57393
#define IDS_MISSING_ALIAS_NAME          57394
#define IDS_RULE_GENERAL_FAILED         57395
#define IDS_ALIAS                       57396
#define IDS_MISSING_ALIAS_FORMATNAME    57397
#define IDS_RULE_COND_FAILE             57398
#define IDS_RULE_ACTION_FAILED          57399
#define IDS_REPORT_MESSAGE_DEST_FN      57402
#define IDS_REPORT_MESSAGE_DEST_FN_LEN  57403
#define IDS_OP_DISPLAY_TRIGGER_CONFIG_PAGE 57404
#define IDS_RULE_CONDITION_REQUIRED     57405
#define IDS_RULE_UPDATE_FAILED          57406
#define IDS_CONDITION_NOT_SELECTED      57407
#define IDS_PARAM_NOT_SELECTED          57408
#define IDS_REPORT_MESSAGE_RESP_FN      57409
#define IDS_REPORT_MESSAGE_RESP_FN_LEN  57410
#define IDS_TRIGGER_GENERAL_FAILED      57411
#define IDS_TRIGGER_ATTACHED_RULE_FAILED 57412
#define IDS_ATTACHED_RULE               57413
#define IDS_OP_SET_MULTICAST_PROPERTY   57416
#define IDS_TRIGGER_UPDATE_FAILED       57417
#define IDS_MULTIPLERECEIVE_TRIGGER     57418
#define IDS_MQMSG_PRIV_LEVEL_BODY_BASE  57419
#define IDS_MQMSG_PRIV_LEVEL_BODY_ENHANCED 57420
#define IDS_MQSRV_ROUTING_SERVER        57421
#define IDS_OP_SET_FORMATNAME_PROPERTY  57422
#define IDS_TRIGGER_ALREADY_DELETED     57423
#define IDS_RULE_ALREADY_DELETED        57424
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\common\ocmres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msmqocm.rc
//
//  changed from 1 to 3001
//


#define IDS_STR_SRV_ERROR_TITLE         3001
#define IDS_OBJECTCREATE_ERROR          3002
#define IDS_STR_CLI_ERROR_TITLE         3004
#define IDS_RT_IN_USE_ERROR             3011
#define IDS_SETUP_ERROR                 3012
#define IDS_STR_SERVER_SETUP_TITLE      3021
#define IDS_STR_CLIENT_SETUP_TITLE      3022
#define IDS_STR_CLIONSRV_ERROR          3029
#define IDS_STR_INSTALL_FAIL            3058
#define IDS_SRVRTYPE_SRV                3080
#define IDS_SRVRTYPE_CLIENT             3081
#define IDS_SRVRTYPE_DEP_CLIENT         3090
#define IDS_DEP_SERVER                  3092
#define IDS_IND_CLIENT                  3093
#define IDS_RS_SERVER                   3094
#define IDS_RS_TITLE_SERVER             3095
#define IDS_IND_TITLE_SERVER            3096
#define IDS_DEP_TITLE_SERVER            3097
#define IDS_STR_EXCHN_EXIST             3100
#define IDS_SRVFRAME_IND                3104
#define IDS_SRVFRAME_DEP                3105
#define IDS_CLIENTTYPE_IND              3108
#define IDB_MSMQ                        3118
#define IDB_HTTP                        3119
#define IDB_ROUTING                     3120
#define IDB_ADINTEGR                    3121
#define IDB_MQDS                        3122
#define IDB_STORAGE                     3123
#define IDB_TRIGGERS                    3124
#define IDB_COMMON                      3125
#define IDB_CORE                        3126
#define IDS_INIKEYNOTFOUND              3132
#define IDS_WARNING_TITLE               3144
#define IDS_CANCEL_INSTRUCTION          3148
#define IDS_CONTINUE_QUESTION           3149
#define IDS_LINKCREATEPRIVILEGE_ERROR   3173
#define IDS_DLLLOAD_ERROR               3195
#define IDS_DLLGETADDRESS_ERROR         3196
#define IDS_ACTIVEXREGISTER_ERROR       3197
#define IDS_SNAPINREGISTER_ERROR        3198
#define IDS_SERVICEPRIVILEGE_ERROR      3207
#define IDS_SERVICECREATE_ERROR         3208
#define IDS_SERVICEDELETE_ERROR         3209
#define IDS_SERVICEOPEN_ERROR           3210
#define IDS_SERVICEGETSTATUS_ERROR      3211
#define IDS_SERVICESTART_ERROR          3214
#define IDS_SERVICESTOP_ERROR           3215
#define IDS_QMPROCESSCREATE_ERROR       3216
#define IDS_DRIVERCREATE_ERROR          3217
#define IDS_DRIVERDELETE_ERROR          3218
#define IDS_DRIVERCREATE_MUST_REBOOT_ERROR 3219
#define IDS_DSSERVERINITIALIZE_ERROR    3221
#define IDS_DSCLIENTINITIALIZE_ERROR    3222
#define IDS_COUNTERSLOAD_ERROR          3223
#define IDS_PROCESSCREATE_ERROR         3224
#define IDS_PROCESSCOMPLETE_ERROR       3225
#define IDS_PROCESSEXITCODE_ERROR       3226
#define IDS_NOSITELINKS_ERROR           3227
#define IDS_NO_SERVER_AUTH_TITLE        3258
#define IDS_REGISTRYOPEN_ERROR          3275
#define IDS_REGISTRYSET_ERROR           3276
#define IDS_REGISTRYGET_ERROR           3277
#define IDS_PEC_LABEL                   3279
#define IDS_PSC_LABEL                   3280
#define IDS_BSC_LABEL                   3281
#define IDS_RS_LABEL                    3282
#define IDS_WORKSTATION_LABEL           3283
#define IDS_MSMQSERVICEGETID_ERROR      3285
#define IDS_SITESLOOKUP_ERROR           3291
#define IDS_COMPUTERCREATE_ERROR        3292
#define IDS_LINKCREATE_ERROR            3293
#define IDS_MACHINEDELETE_NOTEMPTY_ERROR 3294
#define IDS_MACHINECREATE_ERROR         3295
#define IDS_MACHINEDELETE_ERROR         3296
#define IDS_MACHINELOCALGETID_ERROR     3297
#define IDS_MACHINEGETPROPS_ERROR       3298
#define IDS_MACHINEREMOTEGETID_ERROR    3299
#define IDS_MACHINESETPROPERTIES_ERROR  3301
#define IDS_PRIVATEQUEUECREATE_ERROR    3311
#define IDS_POSSIBLECOMPROMISE_ERROR    3312
#define IDS_PUBLICKEYSSTORE_WARNING     3313
#define IDS_REMOTEQM_NA                 3384
#define IDS_REMOTEQM_NOT_SERVER         3385
#define IDS_WAIT_FOR_STOP_TIMEOUT_EXPIRED 3437
#define IDS_COULD_NOT_SET_DIR_SECURITY  3454
#define IDS_COULD_NOT_CREATE_DIRECTORY  3466
#define IDS_NO_SERVER_AUTHN_OCM         3480
#define IDS_SITELINKLOOKUP_ERROR        3482
#define IDS_SITEGETID_ERROR             3483
#define IDS_MSMQ1SERVER_SITE_GUID_ERROR 3484
#define IDS_GETIP_ERROR                 3485
#define IDS_QMSETUPLOG_ERROR            3487
#define IDS_QMPROCESSSEARCH_ERROR       3488
#define IDS_BADINIVALUE_ERROR           3499
#define IDS_STR_REMOTEQM_NA             3501
#define IDS_SERVER_NOT_AVAILABLE        3502
#define IDS_STR_MUST_GIVE_SERVER        3503
#define IDD_WAIT                        3512
#define IDD_ServerName                  3513
#define IDD_Sites                       3515
#define IDD_Welcome                     3516
#define IDD_Final                       3517
#define IDD_Security                    3519
#define IDS_MSMQROOTNOTFOUND_ERROR      3531
#define IDS_BADMSMQ1STFPATH_ERROR       3534
#define IDS_MSMQTYPEUNKNOWN_ERROR       3535
#define IDS_MSMQSERVERUNKNOWN_ERROR     3536
#define IDS_STR_DIR_NOTVALID_ERROR      3537
#define IDS_MSMQ1TYPEUNKNOWN_ERROR      3562
#define IDS_MSMQ1SERVERUNKNOWN_ERROR    3563
#define IDS_MSMQ_TITLE                  3565
#define IDS_SERVICE_NOT_EXIST_ON_UPGRADE_ERROR 3569
#define IDS_SERVICE_CHANGE_CONFIG_ERROR 3570
#define IDS_MSMQ_SRV_DESCRIPTION        3571
#define IDS_IND_DESCRIPTION             3573
#define IDS_DEP_DESCRIPTION             3574
#define IDS_SITE_NOT_RESOLVED_WARNING   3579
#define IDS_TYPE_PAGE_TITLE             3581
#define IDS_TYPE_PAGE_SUBTITLE          3582
#define IDS_ServerName_PAGE_TITLE       3583
#define IDS_ServerName_PAGE_SUBTITLE    3584
#define IDS_WELCOME_TITLE_CLUSTER_UPGRADE 3585
#define IDS_SITE_NOT_RESOLVED_TITLE     3587
#define IDS_WELCOME_TITLE_DATA          3588
#define IDS_SetupFindFirstLine_ERROR    3589
#define IDS_SetupGetStringField_ERROR   3590
#define IDS_SetupInstallFilesFromInfSection_ERROR 3591
#define IDS_STOP_QM_ERROR               3592
#define IDS_SetupAddInstallSectionToDiskSpaceList_ERROR 3593
#define IDS_SetupRemoveInstallSectionFromDiskSpaceList_ERROR 3595
#define IDS_MSMQINFO_NOT_FOUND_ERROR    3596
#define IDS_MSMQINFO_TYPE_KEY_ERROR     3597
#define IDS_WIN95_UPGRADE_MSG           3598
#define IDS_MIGRATION_WELCOME_TITLE_DATA 3599
#define IDS_CACHE_SECURITY_ERROR        3600
#define IDS_MACHINECREATE_OBJECTNOTFOUND_ERROR 3602
#define IDS_MACHINECREATE_CLIENT_ACCESSDENIED_ERROR 3603
#define IDS_MACHINEGETPROPS_MSMQ1_ERROR 3604
#define IDS_MACHINECREATE_SERVER_ACCESSDENIED_ERROR 3605
#define IDS_MACHINECREATE_MSMQ1_ERROR   3606
#define IDS_MACHINESETPROPERTIES_MSMQ1_ERROR 3607
#define IDS_QMSETUPINITPRIVATEQ_ERROR   3608
#define IDS_ERRORCODE_MSG               3610
#define IDS_ERRORDESC_MSG               3611
#define IDS_DEFAULT_MSG                 3612
#define IDS_DEFAULT_YES_MSG             3613
#define IDS_DEFAULT_NO_MSG              3614
#define IDS_SETUP_START_LOG             3615
#define IDS_UNATTEND_SERVER_NOT_FOUND_ERROR 3616
#define IDS_UNINSTALL_LOG               3617
#define IDS_SETUP_FAIL_LOG              3618
#define IDS_SETUP_SUCCESS_LOG           3619
#define IDS_UNINSTALL_AREYOUSURE_TITLE  3620
#define IDS_UNINSTALL_AREYOUSURE_MSG    3621
#define IDS_MACHINECREATE_INVALID_DIR_ERROR 3622
#define IDS_DEP_UNINSTALL_AREYOUSURE_MSG 3624
#define IDS_GET_DEFAULT_SEC_DESC_ERROR  3625
#define IDS_TIME_LOG                    3626
#define IDS_TYPE_MISMATCH_MACHINE_DELETE_ERROR 3627
#define IDS_TYPE_MISMATCH_MACHINE_DELETE_NOTEMPTY_ERROR 3628
#define IDS_FRS_IN_MSMQ1_ENTERPRISE_ERROR 3631
#define IDS_WELCOME_PAGE_TITLE          3632
#define IDS_WELCOME_PAGE_SUBTITLE       3633
#define IDS_FINAL_PAGE_TITLE            3634
#define IDS_FINAL_PAGE_SUBTITLE         3635
#define IDS_SERVER_MACHINEDELETE_ERROR  3637
#define IDS_SERVER_MACHINEDELETE_NOTEMPTY_ERROR 3638
#define IDS_PROGRESS_INSTALL            3639
#define IDS_PROGRESS_UPGRADE            3640
#define IDS_PROGRESS_CONFIG             3641
#define IDS_PROGRESS_REMOVE             3642
#define IDS_IND_CLNT_ON_DC_LABEL        3643
#define IDS_SERVER_NOT_AUTO_FOUND       3645
#define IDS_UNATTEND_SITE_NOT_FOUND_ERROR 3647
#define IDS_MSMQ_SERVICE_DESCRIPTION    3648
#define IDS_DTC_RESOURCE                3650
#define IDS_MSMQ_RESOURCE               3651
#define IDS_IND_SRVR                    3652
#define IDS_Security_PAGE_TITLE         3653
#define IDS_Security_PAGE_SUBTITLE      3654
#define IDS_MSMQINFO_HEADER_ERROR       3657
#define IDS_MSMQINFO_DIRECTORY_KEY_ERROR 3658
#define IDS_MSMQ_FAIL_SETUP_NO_OBJECT    3659
#define IDS_MSMQ_FAIL_SETUP_NO_SERVICE  3660
#define IDS_ACCESS_MSMQ_SERVER_ERR      3661
#define IDS_UpgradeMsmqClusterResource_PROGRESS 3700
#define IDS_SearchOldResource_PROGRESS  3702
#define IDS_ClusterTypeName             3704
#define IDS_ClusterUpgradeFixRegistry_PROGRESS 3705
#define IDS_CreateNewResource_PROGRESS  3706
#define IDS_ClusterUpgradeMsgTitle      3710
#define IDS_ClusterUpgrade_ResourceNameSuffix 3711
#define IDS_NewResourceCreateOk         3712
#define IDS_NewResourceOnlineOk         3713
#define IDS_ClusterResourceOldTypeName  3714
#define IDS_ConfigureNewResource_PROGRESS 3715
#define IDS_OpenCluster_ERR             3800
#define IDS_OpenClusterGroup_ERR        3801
#define IDS_Enumerate_ERR               3802
#define IDS_OpenClusterResource_ERR     3803
#define IDS_QUERY_RESOURCE_TYPE_ERR     3804
#define IDS_UpgradeCluster_NoMemory_ERR 3805
#define IDS_UpgradeClusterFail_ERR      3806
#define IDS_EnumerateGroup_ERR          3807
#define IDS_DelRegistryCp_ERR           3809
#define IDS_CreateResource_ERR          3811
#define IDS_ClusterUpgradeDeleteResource_ERR 3812
#define IDS_DeleteResourceType_ERR      3813
#define IDS_OnlineResource_ERR          3814
#define IDS_EnumerateResource_ERR       3815
#define IDS_AddClusterResourceDependency_ERR 3816
#define IDS_RemoveClusterResourceDependency_ERR 3817
#define IDS_CREATE_UUID_ERR             3818
#define IDS_REPLICATION_DELAYS_WARNING  3819
#define IDS_STRONG_CRYPTO_ERROR         3820


// Changed 1003- 1145 to 3821 - 3895
#define IDC_SpecifyServer               3821			   	// 1003
#define IDC_RADIO_NON_ROUTING           3822			   	// 1006
#define IDC_RADIO_DEP_CLIENT            3823			   	// 1007
#define IDC_STATIC_SERVER_NAME          3823			   	// 1007
#define IDC_Description                 3824				// 1008
#define IDC_List                        3825				// 1009
#define IDC_EDIT_ServerName             3826				// 1010
#define ID_OK                           3827				// 1010
#define IDC_Routing                     3828				// 1013
#define IDC_MQDSService                 3829				// 1014
#define IDC_MQTRIGService               3830				// 1015
#define IDC_DEP_DESCRIPTION             3831				// 1017
#define IDC_RADIO_STRONG                3832				// 1018
#define IDC_RADIO_WEAK                  3833				// 1019
#define IDC_SuccessStatus               3834				// 1020
#define IDC_SpecifyServerDescription    3835				// 1023
#define IDC_NoServerDescription         3836				// 1024
#define IDC_PageTitle                   3837				// 1026
#define IDC_DomainController            3838				// 1027
#define IDC_STATIC_MESSAGE              3839				// 1029
#define IDC_PROGRESS                    3840				// 1052
#define IDC_CHECK_SEC_COMM              3841				// 1055
#define IDC_TITLE                       3842				// 1057
#define IDS_INIT_FOREXTEN_ERROR         3843				// 1058
#define IDS_EXTEN_APPCREATE_ERROR       3844				// 1059
#define IDS_CREATE_IISEXTEN_ERROR       3845				// 1060
#define IDS_TITLE_FONTNAME              3846				// 1064
#define IDS_TITLE_FONTSIZE              3847				// 1065

#define IDS_MQDS_SERVICE_DESCRIPTION    3849				// 1069
#define IDS_STOP_QMDS_ERROR             3850				// 1070
#define IDS_WWW_SERVICE_ERROR           3851				// 1071
#define IDC_SECURITY_PAGE_DESCRIPTION   3852				// 1080
#define IDS_TRIGREGISTER_ERROR          3853				// 1100

#define IDS_TRIG_SERVICE_DESCRIPTION    3855				// 1102
#define IDS_STOP_TRIG_ERROR             3856				// 1103
#define IDS_CHANGEROUTING_STATE_ERROR   3857				// 1104
#define IDS_UNINSTALL_HTTPSUPPORT       3858				// 1105
#define IDS_PROGRESS_INSTALL_TRIGGERS   3859				// 1106
#define IDS_PROGRESS_REMOVE_TRIGGERS    3860				// 1107
#define IDS_PROGRESS_INSTALL_MQDS       3861				// 1108
#define IDS_PROGRESS_REMOVE_MQDS        3862				// 1109
#define IDS_CHANGE_LOCAL_STORAGE_STATE  3863				// 1110
#define IDS_PROGRESS_REMOVE_HTTP        3864				// 1111
#define IDS_ADD_SUBCOMP_ON_DEPCL_ERROR  3865				// 1112
#define IDS_PROGRESS_CONFIGURE_TRIGGERS 3866				// 1113
#define IDS_COMPLUS_UNREGISTER_ERROR    3870				// 1117
#define IDS_MSMQ1SERVER_CN_GUID_ERROR   3872				// 1119
#define IDS_PGM_DRIVER_LABEL            3873				// 1120
#define IDS_WINSOCK_CONFIG_ERROR        3874				// 1121
#define IDS_STR_GENERAL_INSTALL_FAIL    3879				// 1123
#define IDS_REMOVE_AD_INTEGRATED        3880				// 1125
#define IDS_ADINTEGRATED_INSTALL_WARN   3881				// 1126
#define IDS_ACCESS_AD_ERROR             3882				// 1127
#define IDS_IND_PAGE_TITLE_SERVER       3883				// 1128
#define IDS_DEP_PAGE_TITLE_SERVER       3884				// 1129
#define IDS_ROUTING_ON_WORKGROUP_ERROR  3885				// 1131
#define IDS_MQDS_ON_WORKGROUP_ERROR     3886				// 1132
#define IDS_DEP_ON_WORKGROUP_WARN       3887				// 1133
#define IDS_WRONG_CONFIG_ERROR          3888				// 1134
#define IDS_CREATE_MAPPING_FILE_ERROR   3889				// 1139
#define IDS_EXTEN_EXISTS_ERROR          3890				// 1140
#define IDS_DELETE_EXT_ERROR            3891				// 1141
#define IDS_WELCOME_WRONG_CONFIG_ERROR  3892				// 1142
#define IDS_SUCCESS_INSTALL             3893				// 1143
#define IDS_EVENTLOG_REGISTRY_ERROR     3894				// 1144
#define IDS_SECURITY_PAGE_DESCRIPTION   3895				// 1145
#define IDS_WWW_SERVICE_LABEL           3896				// 1146
#define IDS_UNATTEN_NO_SUPPORTING_SERVER 3897
#define IDS_ENUM_SERVICE_DEPENDENCIES   3898

//
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        3897
#define _APS_NEXT_COMMAND_VALUE         40500
#define _APS_NEXT_CONTROL_VALUE         3897
#define _APS_NEXT_SYMED_VALUE           3897
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\adalloc.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    alloc.cpp

Abstract:

	Overridable allocation function

Author:

    Nela Karpel(nelak)

--*/
#include "ds_stdh.h"


PVOID
ADAllocateMemory(
	IN DWORD size
	)
{
	PVOID ptr = new BYTE[size];
	return ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\adalloc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    alloc.cpp

Abstract:

	Overridable allocation function

Author:

    Nela Karpel(nelak)

--*/

#include "adprov.h"

extern P<CBaseADProvider> g_pAD;


//
// Allocation function implementation
//
PVOID
ADAllocateMemory(
	IN DWORD size
	);


//---------------------------------------------------------
//
//  template class SP
//
//---------------------------------------------------------
template<class T>
class CAutoADFree {
private:
    T* m_p;

public:
    CAutoADFree(T* p = 0) : m_p(p)    {}
   ~CAutoADFree()                     { g_pAD->FreeMemory(m_p); }

    operator T*() const     { return m_p; }
    T* operator->() const   { return m_p; }
    T* get() const          { return m_p; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
    void free()             { g_pAD->FreeMemory(detach()); }


    T** operator&()
    {
        ASSERT(("Auto pointer in use, can't take it's address", m_p == 0));
        return &m_p;
    }


    CAutoADFree& operator=(T* p)
    {
        ASSERT(("Auto pointer in use, can't assign it", m_p == 0));
        m_p = p;
        return *this;
    }

private:
    CAutoADFree(const CAutoADFree&);
	CAutoADFree<T>& operator=(const CAutoADFree<T>&);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\adglbobj.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    adglbobj.cpp

Abstract:

    Declaration of Global Instances of AD library.
    They are put in one place to ensure the order their constructors take place.

Author:

    ronit hartmann (ronith)

--*/
#include "ds_stdh.h"
#include "baseprov.h"
#include "detect.h"
//
// single global object providing Active Directory access
//
P<CBaseADProvider> g_pAD;
//
//  Single global object for detecting environment
//
CDetectEnvironment g_detectEnv;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\adglbobj.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    adglbobj.h

Abstract:

    Definition of Global Instances of the AD Library.
    They are put in one place to ensure the order their constructors take place.

Author:

    ronit hartmann (ronith)

--*/
#include "ds_stdh.h"
#include "baseprov.h"
#include "detect.h"
//
// single global object providing Active Directory access
//
extern P<CBaseADProvider> g_pAD;
//
//  Single global object for detecting environment
//
extern CDetectEnvironment g_detectEnv;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\adprov.h ===
/*++

Copyright (c) 1995  Microsoft Corporation 

Module Name:
	adprov.h

Abstract:
	Active Directory provider class.

Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __ADPROV_H__
#define __ADPROV_H__

#include "baseprov.h"
#include "mqad.h"
#include "autorel.h"
#include "cliprov.h"

//-----------------------------------------------------------------------------------
//
//      CActiveDirectoryProvider
//
//  Virtual class, encapsulates ActiveDirectory operations 
//
//-----------------------------------------------------------------------------------
class CActiveDirectoryProvider : public  CBaseADProvider
{
public:
    CActiveDirectoryProvider();

    ~CActiveDirectoryProvider();

    virtual HRESULT CreateObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[],
                OUT GUID*                   pObjGuid
                );

    virtual HRESULT DeleteObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName
                );

    virtual HRESULT DeleteObjectGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject
                );

    virtual HRESULT GetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT PROPVARIANT          apVar[]
                );

    virtual HRESULT GetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  OUT PROPVARIANT         apVar[]
                );

    virtual HRESULT QMGetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded,
                IN  DSQMChallengeResponce_ROUTINE
                                            pfChallengeResponceProc,
                IN  DWORD_PTR               dwContext
                );

    virtual HRESULT GetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                );

    virtual HRESULT GetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                );

    virtual HRESULT SetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                );

    virtual HRESULT SetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                );

    virtual HRESULT QMSetMachineProperties(
                IN  LPCWSTR             pwcsObjectName,
                IN  const DWORD         cp,
                IN  const PROPID        aProp[],
                IN  const PROPVARIANT   apVar[],
                IN  DSQMChallengeResponce_ROUTINE pfSignProc,
                IN  DWORD_PTR           dwContext
                );

    virtual HRESULT SetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                );

    virtual HRESULT SetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                );

    virtual HRESULT Init( 
                IN QMLookForOnlineDS_ROUTINE    pLookDS,
                IN MQGetMQISServer_ROUTINE      pGetServers,
                IN bool                         fSetupMode,
                IN bool                         fQMDll,
                IN NoServerAuth_ROUTINE         pNoServerAuth,
                IN LPCWSTR                      szServerName,
                IN bool                         fDisableDownlevelNotifications
                );

    virtual HRESULT SetupInit(
                IN    unsigned char   ucRoll,
                IN    LPWSTR          pwcsPathName,
                IN    const GUID *    pguidMasterId
                );

    virtual HRESULT CreateServersCache();

    virtual HRESULT GetComputerSites(
                IN  LPCWSTR     pwcsComputerName,
                OUT DWORD  *    pdwNumSites,
                OUT GUID **     ppguidSites
                );

    virtual HRESULT BeginDeleteNotification(
                IN  AD_OBJECT               eObject,
                IN LPCWSTR                  pwcsDomainController,
                IN  bool					fServerName,
                IN LPCWSTR					pwcsObjectName,
                IN OUT HANDLE   *           phEnum
                );

    virtual HRESULT NotifyDelete(
                IN  HANDLE                  hEnum
                );

    virtual HRESULT EndDeleteNotification(
                IN  HANDLE                  hEnum
                );

    virtual HRESULT QueryMachineQueues(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID *            pguidMachine,
                IN  const MQCOLUMNSET*      pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QuerySiteServers(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN AD_SERVER_TYPE           serverType,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

	virtual HRESULT QueryNT4MQISServers(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
	            IN  DWORD                   dwServerType,
	            IN  DWORD                   dwNT4,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryUserCert(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const BLOB *             pblobUserSid,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryConnectors(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryForeignSites(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryLinks(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN eLinkNeighbor            eNeighbor,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryAllLinks(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryAllSites(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryQueues(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const MQRESTRICTION*    pRestriction,
                IN  const MQCOLUMNSET*      pColumns,
                IN  const MQSORTSET*        pSort,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryResults(
                IN      HANDLE          hEnum,
                IN OUT  DWORD*          pcProps,
                OUT     PROPVARIANT     aPropVar[]
                );

    virtual HRESULT EndQuery(
                IN  HANDLE                  hEnum
                );

    virtual void Terminate();

    virtual HRESULT ADGetADsPathInfo(
                IN  LPCWSTR                 pwcsADsPath,
                OUT PROPVARIANT *           pVar,
                OUT eAdsClass *             pAdsClass
                );

	virtual void FreeMemory(
				IN PVOID					pMemory
				);

    private:

    HRESULT LoadDll();

    bool IsDownlevelClient(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const GUID*             pguidObject
                );

    DWORD GetMsmqDisableDownlevelKeyValue();

    HRESULT InitDownlevelNotifcationSupport(
                IN MQGetMQISServer_ROUTINE      pGetServers,
                IN bool                         fSetupMode,
                IN bool                         fQMDll,
                IN bool                         fDisableDownlevelNotifications,
                IN NoServerAuth_ROUTINE         pNoServerAuth
                );

    HRESULT LoadAndInitMQDSCli();

    bool IsThereDsServerListInRegistry();

    private:

    MQADCreateObject_ROUTINE                m_pfMQADCreateObject;
    MQADDeleteObject_ROUTINE                m_pfMQADDeleteObject;
    MQADDeleteObjectGuid_ROUTINE            m_pfMQADDeleteObjectGuid;
    MQADGetObjectProperties_ROUTINE         m_pfMQADGetObjectProperties;
    MQADGetObjectPropertiesGuid_ROUTINE     m_pfMQADGetObjectPropertiesGuid;
    MQADQMGetObjectSecurity_ROUTINE         m_pfMQADQMGetObjectSecurity;
    MQADSetObjectProperties_ROUTINE         m_pfMQADSetObjectProperties;
    MQADSetObjectPropertiesGuid_ROUTINE     m_pfMQADSetObjectPropertiesGuid;
    MQADQMSetMachineProperties_ROUTINE      m_pfMQADQMSetMachineProperties;
    MQADInit_ROUTINE                        m_pfMQADInit;
    MQADSetupInit_ROUTINE                   m_pfMQADSetupInit;
    MQADGetComputerSites_ROUTINE            m_pfMQADGetComputerSites;
    MQADBeginDeleteNotification_ROUTINE     m_pfMQADBeginDeleteNotification;
    MQADNotifyDelete_ROUTINE                m_pfMQADNotifyDelete;
    MQADEndDeleteNotification_ROUTINE       m_pfMQADEndDeleteNotification;
    MQADQueryMachineQueues_ROUTINE          m_pfMQADQueryMachineQueues;
    MQADQuerySiteServers_ROUTINE            m_pfMQADQuerySiteServers;
    MQADQueryNT4MQISServers_ROUTINE         m_pfMQADQueryNT4MQISServers;
    MQADQueryUserCert_ROUTINE               m_pfMQADQueryUserCert;
    MQADQueryConnectors_ROUTINE             m_pfMQADQueryConnectors;
    MQADQueryForeignSites_ROUTINE           m_pfMQADQueryForeignSites;
    MQADQueryLinks_ROUTINE                  m_pfMQADQueryLinks;
    MQADQueryAllLinks_ROUTINE               m_pfMQADQueryAllLinks;
    MQADQueryAllSites_ROUTINE               m_pfMQADQueryAllSites;
    MQADQueryQueues_ROUTINE                 m_pfMQADQueryQueues;
    MQADQueryResults_ROUTINE                m_pfMQADQueryResults;
    MQADEndQuery_ROUTINE                    m_pfMQADEndQuery;
    MQADGetObjectSecurity_ROUTINE           m_pfMQADGetObjectSecurity;
    MQADGetObjectSecurityGuid_ROUTINE       m_pfMQADGetObjectSecurityGuid;
    MQADSetObjectSecurity_ROUTINE           m_pfMQADSetObjectSecurity;
    MQADSetObjectSecurityGuid_ROUTINE       m_pfMQADSetObjectSecurityGuid;
    MQADGetADsPathInfo_ROUTINE              m_pfMQADGetADsPathInfo;
	MQADFreeMemory_ROUTINE					m_pfMQADFreeMemory;
    CAutoFreeLibrary                        m_hLib;

    //
    //  Downlevel clients support
    //
    CCriticalSection                        m_csInitialization;
    bool                                    m_fSupportDownlevelNotifications;
    P<CDSClientProvider>                    m_pDownLevelProvider; 
    MQADGetComputerVersion_ROUTINE          m_pfMQADGetComputerVersion;
    MQGetMQISServer_ROUTINE                 m_pGetServers;
    bool                                    m_fSetupMode;
    bool                                    m_fQMDll;
    NoServerAuth_ROUTINE                    m_pNoServerAuth;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\adprov.cpp ===
/*++


Copyright (c) 1998  Microsoft Corporation 

Module Name:

    adprov.cpp

Abstract:

	Active Directory provider class.

Author:

    ronith

--*/
#include "ds_stdh.h"
#include "adprov.h"
#include "adglbobj.h"
#include "mqlog.h"
#include "_mqreg.h"
#include "_mqini.h"
#include "_rstrct.h"
#include "adalloc.h"

#include "adprov.tmh"

static WCHAR *s_FN=L"ad/adprov";

CActiveDirectoryProvider::CActiveDirectoryProvider():
        m_pfMQADCreateObject(NULL),
        m_pfMQADDeleteObject(NULL),
        m_pfMQADDeleteObjectGuid(NULL),
        m_pfMQADGetObjectProperties(NULL),
        m_pfMQADGetObjectPropertiesGuid(NULL),
        m_pfMQADQMGetObjectSecurity(NULL),
        m_pfMQADSetObjectProperties(NULL),
        m_pfMQADSetObjectPropertiesGuid(NULL),
        m_pfMQADQMSetMachineProperties(NULL),
        m_pfMQADInit(NULL),
        m_pfMQADSetupInit(NULL),
        m_pfMQADGetComputerSites(NULL),
        m_pfMQADBeginDeleteNotification(NULL),
        m_pfMQADNotifyDelete(NULL),
        m_pfMQADEndDeleteNotification(NULL),
        m_pfMQADQueryMachineQueues(NULL),
        m_pfMQADQuerySiteServers(NULL),
        m_pfMQADQueryNT4MQISServers(NULL),
        m_pfMQADQueryUserCert(NULL),
        m_pfMQADQueryConnectors(NULL),
        m_pfMQADQueryForeignSites(NULL),
        m_pfMQADQueryLinks(NULL),
        m_pfMQADQueryAllLinks(NULL),
        m_pfMQADQueryAllSites(NULL),
        m_pfMQADQueryQueues(NULL),
        m_pfMQADQueryResults(NULL),
        m_pfMQADEndQuery(NULL),
        m_pfMQADGetObjectSecurity(NULL),
        m_pfMQADGetObjectSecurityGuid(NULL),
        m_pfMQADSetObjectSecurity(NULL),
        m_pfMQADSetObjectSecurityGuid(NULL),
        m_pfMQADGetADsPathInfo(NULL),
		m_pfMQADFreeMemory(NULL)
/*++
    Abstract:
	Constructor- init pointers

    Parameters:
    none

    Returns:
	none
--*/
{
}
                                                   

CActiveDirectoryProvider::~CActiveDirectoryProvider()
/*++
    Abstract:
    destructor

    Parameters:
    none

    Returns:
	none
--*/
{
    //
    //  nothing to do, everthing is auto-pointers
    //
}


HRESULT CActiveDirectoryProvider::CreateObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[],
                OUT GUID*                   pObjGuid
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
	PSECURITY_DESCRIPTOR    pSecurityDescriptor - object SD
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values
	GUID*                   pObjGuid - the created object unique id

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADCreateObject != NULL);
    
    //
    //  Supporting downlevel clients notifications,
    //  don't access AD directly but through MQDSCli
    //
    if (m_fSupportDownlevelNotifications &&
         (eObject == eQUEUE))       // notifications are sent only when creating queues
    {
        //
        //  Is it a downlevel computer?
        //
        bool fDownlevelComputer = IsDownlevelClient(
                        eObject,
                        pwcsDomainController,
						fServerName,
                        pwcsObjectName,
                        NULL
                        );
        //
        //  If for some reason we cannot use MQDSCLI, access AD directly
        //  ( this is a best effort to send notifications)
        //
        if (fDownlevelComputer &&
            SUCCEEDED(LoadAndInitMQDSCli()))
        {
            return m_pDownLevelProvider->CreateObject( 
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                pSecurityDescriptor,
                cp,
                aProp,
                apVar,
                pObjGuid
                );

        }
    }

         
    return m_pfMQADCreateObject( 
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                pSecurityDescriptor,
                cp,
                aProp,
                apVar,
                pObjGuid
                );
}


HRESULT CActiveDirectoryProvider::DeleteObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADDeleteObject != NULL);

    //
    //  Supporting downlevel clients notifications,
    //  don't access AD directly but through MQDSCli
    //
    if (m_fSupportDownlevelNotifications &&
         (eObject == eQUEUE))       // notifications are sent only when creating queues
    {
        //
        //  Is it a downlevel computer?
        //
        bool fDownlevelComputer = IsDownlevelClient(
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                NULL
                );

        //
        //  If for some reason we cannot use MQDSCLI, access AD directly
        //  ( this is a best effort to send notifications)
        //
        if (fDownlevelComputer &&
            SUCCEEDED(LoadAndInitMQDSCli()))
        {
            return m_pDownLevelProvider->DeleteObject( 
                    eObject,
                    pwcsDomainController,
					fServerName,
                    pwcsObjectName
                    );

        }
    }

    return m_pfMQADDeleteObject(
                    eObject,
                    pwcsDomainController,
					fServerName,
                    pwcsObjectName
                    );
}


HRESULT CActiveDirectoryProvider::DeleteObjectGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	GUID*                   pguidObject - the unique id of the object

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADDeleteObjectGuid != NULL);
    return m_pfMQADDeleteObjectGuid(
                    eObject,
                    pwcsDomainController,
					fServerName,
                    pguidObject
                    );
}


HRESULT CActiveDirectoryProvider::GetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT PROPVARIANT          apVar[]
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADGetObjectProperties != NULL);
    return m_pfMQADGetObjectProperties(
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                cp,
                aProp,
                apVar
                );
}


HRESULT CActiveDirectoryProvider::GetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  OUT PROPVARIANT         apVar[]
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	GUID *                  pguidObject -  object unique id
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADGetObjectPropertiesGuid != NULL);
    return m_pfMQADGetObjectPropertiesGuid(
                eObject,
                pwcsDomainController,
				fServerName,
                pguidObject,
                cp,
                aProp,
                apVar
                );
}


HRESULT CActiveDirectoryProvider::QMGetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded,
                IN  DSQMChallengeResponce_ROUTINE
                                            pfChallengeResponceProc,
                IN  DWORD_PTR               dwContext
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
    AD_OBJECT               object - object type
    const GUID*             pguidObject - unique id of the object
    SECURITY_INFORMATION    RequestedInformation - what security info is requested
    PSECURITY_DESCRIPTOR    pSecurityDescriptor - SD response buffer
    DWORD                   nLength - length of SD buffer
    LPDWORD                 lpnLengthNeeded
    DSQMChallengeResponce_ROUTINE
                                pfChallengeResponceProc,
    DWORD_PTR               dwContext

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADQMGetObjectSecurity != NULL);
    return m_pfMQADQMGetObjectSecurity(
                eObject,
                pguidObject,
                RequestedInformation,
                pSecurityDescriptor,
                nLength,
                lpnLengthNeeded,
                pfChallengeResponceProc,
                dwContext
                );
}


HRESULT CActiveDirectoryProvider::SetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADSetObjectProperties != NULL);

    //
    //  Supporting downlevel clients notifications,
    //  don't access AD directly but through MQDSCli
    //
    if (m_fSupportDownlevelNotifications &&
         ((eObject == eQUEUE) || (eObject == eMACHINE)))       // notifications are sent only when modifing queues or machines
    {
        //
        //  Is it a downlevel computer?
        //
        bool fDownlevelComputer = IsDownlevelClient(
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                NULL
                );

        //
        //  If for some reason we cannot use MQDSCLI, access AD directly
        //  ( this is a best effort to send notifications)
        //
        if (fDownlevelComputer &&
            SUCCEEDED(LoadAndInitMQDSCli()))
        {
            return m_pDownLevelProvider->SetObjectProperties( 
                        eObject,
                        pwcsDomainController,
						fServerName,
                        pwcsObjectName,
                        cp,
                        aProp,
                        apVar
                        );
        }
    }
    return m_pfMQADSetObjectProperties(
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                cp,
                aProp,
                apVar
                );
}


HRESULT CActiveDirectoryProvider::SetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	GUID *                  pguidObject - the object unique id
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADSetObjectPropertiesGuid != NULL);
    //
    //  Supporting downlevel clients notifications,
    //  don't access AD directly but through MQDSCli
    //
    if (m_fSupportDownlevelNotifications &&
         ((eObject == eQUEUE) || (eObject == eMACHINE)))       // notifications are sent only when modifing queues or machines
    {
        //
        //  Is it a downlevel computer?
        //
        bool fDownlevelComputer = IsDownlevelClient(
                eObject,
                pwcsDomainController,
				fServerName,
                NULL,
                pguidObject
                );

        //
        //  If for some reason we cannot use MQDSCLI, access AD directly
        //  ( this is a best effort to send notifications)
        //
        if (fDownlevelComputer &&
            SUCCEEDED(LoadAndInitMQDSCli()))
        {
            return m_pDownLevelProvider->SetObjectPropertiesGuid( 
                        eObject,
                        pwcsDomainController,
						fServerName,
                        pguidObject,
                        cp,
                        aProp,
                        apVar
                        );
        }
    }
    return m_pfMQADSetObjectPropertiesGuid(
                        eObject,
                        pwcsDomainController,
						fServerName,
                        pguidObject,
                        cp,
                        aProp,
                        apVar
                        );
}


HRESULT CActiveDirectoryProvider::QMSetMachineProperties(
                IN  LPCWSTR             pwcsObjectName,
                IN  const DWORD         cp,
                IN  const PROPID        aProp[],
                IN  const PROPVARIANT   apVar[],
                IN  DSQMChallengeResponce_ROUTINE pfSignProc,
                IN  DWORD_PTR           dwContext
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
    LPCWSTR             pwcsObjectName - object msmq-name
    const DWORD         cp - number of properties to set
    const PROPID        aProp - properties
    const PROPVARIANT   apVar  property values
    DSQMChallengeResponce_ROUTINE pfSignProc - sign routine
    DWORD_PTR           dwContext

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADQMSetMachineProperties != NULL);
    return m_pfMQADQMSetMachineProperties(
                        pwcsObjectName,
                        cp,
                        aProp,
                        apVar,
                        pfSignProc,
                        dwContext
                        );
}


HRESULT CActiveDirectoryProvider::Init( 
                IN QMLookForOnlineDS_ROUTINE    pLookDS,
                IN MQGetMQISServer_ROUTINE      pGetServers,
                IN bool                         fSetupMode,
                IN bool                         fQMDll,
                IN NoServerAuth_ROUTINE         pNoServerAuth,
                IN LPCWSTR                      szServerName,
                IN bool                         fDisableDownlevelNotifications
                )
/*++
    Abstract:
    Loads mqad dll and then forwards the call to mqad dll

    Parameters:
    QMLookForOnlineDS_ROUTINE pLookDS -
    MQGetMQISServer_ROUTINE pGetServers -
    bool  fDSServerFunctionality - should provide DS server functionality
    bool  fSetupMode -  called during setup
    bool  fQMDll - called by QM
    NoServerAuth_ROUTINE pNoServerAuth -
    LPCWSTR szServerName -

    Returns:
	HRESULT
--*/
{
    HRESULT hr = LoadDll();
    if (FAILED(hr))
    {
        return hr;
    }

    ASSERT(m_pfMQADInit != NULL);
    hr = m_pfMQADInit(
                    pLookDS,
                    fQMDll,
                    szServerName
                    );
    if (FAILED(hr))
    {
        return hr;
    }

    return InitDownlevelNotifcationSupport(
                        pGetServers,
                        fSetupMode,
                        fQMDll,
                        fDisableDownlevelNotifications,
                        pNoServerAuth
                        );
}


HRESULT CActiveDirectoryProvider::SetupInit(
                IN    unsigned char   /* ucRoll */,
                IN    LPWSTR          /* pwcsPathName*/,
                IN    const GUID *    /* pguidMasterId */
                )
/*++
    Abstract:
    Loads mqad dll and then forwards the call to mqad dll

    Parameters:
        unsigned char   ucRoll -
        LPWSTR          pwcsPathName -
        const GUID *    pguidMasterId -

    Returns:
	HRESULT
--*/
{
    return Init( 
                NULL,   //  pLookDS
                NULL,   //  pGetServers
                true,   //  fSetupMode
                false,  //  fQMDll
                NULL,   //  pNoServerAuth
                NULL,   //  szServerName
                true    //  fDisableDownlevelNotifications
                );

}


HRESULT CActiveDirectoryProvider::CreateServersCache()
/*++
    Abstract:
    Just returns ok

    Parameters:
    none

    Returns:
	MQ_OK
--*/
{
    //
    //  Has no meaning when client access directly the Active Directory
    //  ( there is no use in keeping list of DCs, since ADSI finds one automatically)
    //
    return MQ_OK;
}


HRESULT CActiveDirectoryProvider::GetComputerSites(
                IN  LPCWSTR     pwcsComputerName,
                OUT DWORD  *    pdwNumSites,
                OUT GUID **     ppguidSites
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
    LPCWSTR     pwcsComputerName - computer name
    DWORD  *    pdwNumSites - number of sites retrieved
    GUID **     ppguidSites - the retrieved sites ids

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADGetComputerSites != NULL);
    return m_pfMQADGetComputerSites(
                        pwcsComputerName,
                        pdwNumSites,
                        ppguidSites
                        );
}


HRESULT CActiveDirectoryProvider::BeginDeleteNotification(
                IN  AD_OBJECT               eObject,
                IN LPCWSTR                  pwcsDomainController,
                IN  bool					fServerName,
                IN LPCWSTR					pwcsObjectName,
                IN OUT HANDLE   *           phEnum
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
    AD_OBJECT         eObject - object type
    LPCWSTR           pwcsDomainController - DC against which the operation should be performed
    bool			  fServerName - flag that indicate if the pwcsDomainController string is a server name
    LPCWSTR			  pwcsObjectName - msmq-name of the object
    HANDLE   *        phEnum - notification handle

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADBeginDeleteNotification != NULL);
    return m_pfMQADBeginDeleteNotification(
                eObject, 
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                phEnum
                );
}


HRESULT CActiveDirectoryProvider::NotifyDelete(
                IN  HANDLE                  hEnum
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
    HANDLE            hEnum - notification handle

    Returns:
	HRESULT

--*/
{
    ASSERT(m_pfMQADNotifyDelete != NULL);
    return m_pfMQADNotifyDelete(
                hEnum
                );
}


HRESULT CActiveDirectoryProvider::EndDeleteNotification(
                IN  HANDLE                  hEnum
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
    HANDLE            hEnum - notification handle

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADEndDeleteNotification != NULL);
    return m_pfMQADEndDeleteNotification(
                        hEnum
                        );
}


HRESULT CActiveDirectoryProvider::QueryMachineQueues(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID *            pguidMachine,
                IN  const MQCOLUMNSET*      pColumns,
                OUT PHANDLE                 phEnume
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID *            pguidMachine - the unqiue id of the computer
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADQueryMachineQueues != NULL);
    return m_pfMQADQueryMachineQueues(
                    pwcsDomainController,
					fServerName,
                    pguidMachine,
                    pColumns,
                    phEnume
                    );
}


HRESULT CActiveDirectoryProvider::QuerySiteServers(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN AD_SERVER_TYPE           serverType,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID *            pguidSite - the site id
    AD_SERVER_TYPE          eServerType- which type of server
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADQuerySiteServers != NULL);
    return m_pfMQADQuerySiteServers(
                    pwcsDomainController,
					fServerName,
                    pguidSite,
                    serverType,
                    pColumns,
                    phEnume
                    );
}


HRESULT CActiveDirectoryProvider::QueryNT4MQISServers(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
	            IN  DWORD                   dwServerType,
	            IN  DWORD                   dwNT4,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    DWORD		            dwServerType- which type of server
    DWORD		            dwNT4- NT4 flag
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADQueryNT4MQISServers != NULL);
    return m_pfMQADQueryNT4MQISServers(
                    pwcsDomainController,
					fServerName,
                    dwServerType,
                    dwNT4,
                    pColumns,
                    phEnume
                    );
}

HRESULT CActiveDirectoryProvider::QueryUserCert(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const BLOB *             pblobUserSid,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const BLOB *            pblobUserSid - the user sid
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADQueryUserCert != NULL);
    return m_pfMQADQueryUserCert(
                    pwcsDomainController,
					fServerName,
                    pblobUserSid,
                    pColumns,
                    phEnume
                    );
}


HRESULT CActiveDirectoryProvider::QueryConnectors(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID *            pguidSite - the site id
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADQueryConnectors != NULL);
    return m_pfMQADQueryConnectors(
                        pwcsDomainController,
						fServerName,
                        pguidSite,
                        pColumns,
                        phEnume
                        );
}


HRESULT CActiveDirectoryProvider::QueryForeignSites(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADQueryForeignSites != NULL);
    return m_pfMQADQueryForeignSites(
                        pwcsDomainController,
						fServerName,
                        pColumns,
                        phEnume
                        );
}


HRESULT CActiveDirectoryProvider::QueryLinks(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN eLinkNeighbor            eNeighbor,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID *            pguidSite - the site id
    eLinkNeighbor           eNeighbor - which neighbour
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

    Returns:
	HRESULT
--*/
{   
    ASSERT(m_pfMQADQueryLinks != NULL);
    return m_pfMQADQueryLinks(
                        pwcsDomainController,
						fServerName,
                        pguidSite,
                        eNeighbor,
                        pColumns,
                        phEnume
                        );
}


HRESULT CActiveDirectoryProvider::QueryAllLinks(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the
							results

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADQueryAllLinks != NULL);
    return m_pfMQADQueryAllLinks(
                pwcsDomainController,
				fServerName,
                pColumns,
                phEnume
                );
}


HRESULT CActiveDirectoryProvider::QueryAllSites(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the
							results

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADQueryAllSites != NULL);
    return m_pfMQADQueryAllSites(
                pwcsDomainController,
				fServerName,
                pColumns,
                phEnume
                );
}


HRESULT CActiveDirectoryProvider::QueryQueues(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const MQRESTRICTION*    pRestriction,
                IN  const MQCOLUMNSET*      pColumns,
                IN  const MQSORTSET*        pSort,
                OUT PHANDLE                 phEnume
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	const MQRESTRICTION*    pRestriction - query restriction
	const MQCOLUMNSET*      pColumns - result columns
	const MQSORTSET*        pSort - how to sort the results
	PHANDLE                 phEnume - query handle for retriving the
							results

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADQueryQueues != NULL);
    return m_pfMQADQueryQueues(
                pwcsDomainController,
				fServerName,
                pRestriction,
                pColumns,
                pSort,
                phEnume
                );
}


HRESULT CActiveDirectoryProvider::QueryResults(
                IN      HANDLE          hEnum,
                IN OUT  DWORD*          pcProps,
                OUT     PROPVARIANT     aPropVar[]
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	HANDLE          hEnum - query handle
	DWORD*          pcProps - number of results to return
	PROPVARIANT     aPropVar - result values

    Returns:
	HRESULT
--*/
{
    ASSERT(m_pfMQADQueryResults != NULL);
    return m_pfMQADQueryResults(
                hEnum,
                pcProps,
                aPropVar
                );
}


HRESULT CActiveDirectoryProvider::EndQuery(
                IN  HANDLE                  hEnum
                )
/*++
    Abstract:
    Forwards the call to mqad dll

    Parameters:
	HANDLE    hEnum - the query handle

    Returns:
	none
--*/
{
    ASSERT(m_pfMQADEndQuery != NULL);
    return m_pfMQADEndQuery(
                hEnum
                );
}

HRESULT CActiveDirectoryProvider::GetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                )
/*++

Routine Description:
    Forward the request to mqad dll

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	PROPVARIANT             pVar - property values

Return Value
	HRESULT

--*/
{
    ASSERT(m_pfMQADGetObjectSecurity != NULL);
    return m_pfMQADGetObjectSecurity(
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                RequestedInformation,
                prop,
                pVar
                );

}

HRESULT CActiveDirectoryProvider::GetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                )
/*++

Routine Description:
    Forward the request to mqad dll

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID*             pguidObject - unique id of the object
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	PROPVARIANT             pVar - property values

Return Value
	HRESULT

--*/
{
    ASSERT( m_pfMQADGetObjectSecurityGuid != NULL);
    return m_pfMQADGetObjectSecurityGuid(
                eObject,
                pwcsDomainController,
				fServerName,
                pguidObject,
                RequestedInformation,
                prop,
                pVar
                );
}

HRESULT CActiveDirectoryProvider::SetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                )
/*++

Routine Description:
    Forward the request to mqad dll

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values

Return Value
	HRESULT

--*/
{
    ASSERT(m_pfMQADSetObjectSecurity != NULL);
    //
    //  Supporting downlevel clients notifications,
    //  don't access AD directly but through MQDSCli
    //
    if (m_fSupportDownlevelNotifications &&
         ((eObject == eQUEUE) || (eObject == eMACHINE)))       // notifications are sent only when modifing queues or machines
    {
        //
        //  Is it a downlevel computer?
        //
        bool fDownlevelComputer =  IsDownlevelClient(
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                NULL
                );

        //
        //  If for some reason we cannot use MQDSCLI, access AD directly
        //  ( this is a best effort to send notifications)
        //
        if (fDownlevelComputer &&
            SUCCEEDED(LoadAndInitMQDSCli()))
        {
            return m_pDownLevelProvider->SetObjectSecurity( 
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                RequestedInformation,
                prop,
                pVar
                );
        }
    }
    return m_pfMQADSetObjectSecurity(
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                RequestedInformation,
                prop,
                pVar
                );
}


HRESULT CActiveDirectoryProvider::SetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                )
/*++

Routine Description:
    Forward the request to mqad dll

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID*             pguidObject - unique object id
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values

Return Value
	HRESULT

--*/
{
    ASSERT(m_pfMQADSetObjectSecurityGuid != NULL);
    //
    //  Supporting downlevel clients notifications,
    //  don't access AD directly but through MQDSCli
    //
    if (m_fSupportDownlevelNotifications &&
         ((eObject == eQUEUE) || (eObject == eMACHINE)))       // notifications are sent only when modifing queues or machines
    {
        //
        //  Is it a downlevel computer?
        //
        bool fDownlevelComputer =  IsDownlevelClient(
                eObject,
                pwcsDomainController,
				fServerName,
                NULL,
                pguidObject
                );

        //
        //  If for some reason we cannot use MQDSCLI, access AD directly
        //  ( this is a best effort to send notifications)
        //
        if (fDownlevelComputer &&
            SUCCEEDED(LoadAndInitMQDSCli()))
        {
            return m_pDownLevelProvider->SetObjectSecurityGuid( 
                eObject,
                pwcsDomainController,
				fServerName,
                pguidObject,
                RequestedInformation,
                prop,
                pVar
                );
        }
    }
    return m_pfMQADSetObjectSecurityGuid(
                eObject,
                pwcsDomainController,
				fServerName,
                pguidObject,
                RequestedInformation,
                prop,
                pVar
                );
}



HRESULT CActiveDirectoryProvider::LoadDll()
/*++
    Abstract:
    Loads aqad dll and get address of all the interface routines

    Parameters:
    none

    Returns:
	HRESULT
--*/
{
    m_hLib = LoadLibrary(MQAD_DLL_NAME );
    if (m_hLib == NULL)
    {
       return LogHR(MQ_ERROR_CANNOT_LOAD_MQAD, s_FN, 10);
    }

    m_pfMQADCreateObject = (MQADCreateObject_ROUTINE)GetProcAddress(m_hLib,"MQADCreateObject"); 
    if (m_pfMQADCreateObject == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 100);
    }
    m_pfMQADDeleteObject = (MQADDeleteObject_ROUTINE)GetProcAddress(m_hLib,"MQADDeleteObject");
    if (m_pfMQADDeleteObject == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 110);
    }
    m_pfMQADDeleteObjectGuid = (MQADDeleteObjectGuid_ROUTINE)GetProcAddress(m_hLib,"MQADDeleteObjectGuid");
    if (m_pfMQADDeleteObjectGuid == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 120);
    }
    m_pfMQADGetObjectProperties = (MQADGetObjectProperties_ROUTINE)GetProcAddress(m_hLib,"MQADGetObjectProperties");
    if (m_pfMQADGetObjectProperties == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 130);
    }
    m_pfMQADGetObjectPropertiesGuid = (MQADGetObjectPropertiesGuid_ROUTINE)GetProcAddress(m_hLib,"MQADGetObjectPropertiesGuid");
    if (m_pfMQADGetObjectPropertiesGuid == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 140);
    }
    m_pfMQADQMGetObjectSecurity = (MQADQMGetObjectSecurity_ROUTINE)GetProcAddress(m_hLib,"MQADQMGetObjectSecurity");
    if (m_pfMQADQMGetObjectSecurity == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 150);
    }
    m_pfMQADSetObjectProperties = (MQADSetObjectProperties_ROUTINE)GetProcAddress(m_hLib,"MQADSetObjectProperties");
    if (m_pfMQADSetObjectProperties == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 160);
    }
    m_pfMQADSetObjectPropertiesGuid = (MQADSetObjectPropertiesGuid_ROUTINE)GetProcAddress(m_hLib,"MQADSetObjectPropertiesGuid");
    if (m_pfMQADSetObjectPropertiesGuid == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 170);
    }
    m_pfMQADQMSetMachineProperties = (MQADQMSetMachineProperties_ROUTINE)GetProcAddress(m_hLib,"MQADQMSetMachineProperties");
    if (m_pfMQADQMSetMachineProperties == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 180);
    }
    m_pfMQADInit = (MQADInit_ROUTINE)GetProcAddress(m_hLib,"MQADInit");
    if (m_pfMQADInit == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 190);
    }
    m_pfMQADSetupInit = (MQADSetupInit_ROUTINE)GetProcAddress(m_hLib,"MQADSetupInit");
    if (m_pfMQADSetupInit == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 200);
    }
    m_pfMQADGetComputerSites = (MQADGetComputerSites_ROUTINE)GetProcAddress(m_hLib,"MQADGetComputerSites");
    if (m_pfMQADGetComputerSites == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 210);
    }
    m_pfMQADBeginDeleteNotification = (MQADBeginDeleteNotification_ROUTINE)GetProcAddress(m_hLib,"MQADBeginDeleteNotification");
    if (m_pfMQADBeginDeleteNotification == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 220);
    }
    m_pfMQADNotifyDelete = (MQADNotifyDelete_ROUTINE)GetProcAddress(m_hLib,"MQADNotifyDelete");
    if (m_pfMQADNotifyDelete == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 230);
    }
    m_pfMQADEndDeleteNotification = (MQADEndDeleteNotification_ROUTINE)GetProcAddress(m_hLib,"MQADEndDeleteNotification");
    if (m_pfMQADEndDeleteNotification == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 240);
    }
    m_pfMQADQueryMachineQueues = (MQADQueryMachineQueues_ROUTINE)GetProcAddress(m_hLib,"MQADQueryMachineQueues");
    if (m_pfMQADQueryMachineQueues == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 250);
    }
    m_pfMQADQuerySiteServers = (MQADQuerySiteServers_ROUTINE)GetProcAddress(m_hLib,"MQADQuerySiteServers");
    if (m_pfMQADQuerySiteServers == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 260);
    }
    m_pfMQADQueryNT4MQISServers = (MQADQueryNT4MQISServers_ROUTINE)GetProcAddress(m_hLib,"MQADQueryNT4MQISServers");
    if (m_pfMQADQueryNT4MQISServers == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 265);
    }
    m_pfMQADQueryUserCert = (MQADQueryUserCert_ROUTINE)GetProcAddress(m_hLib,"MQADQueryUserCert");
    if (m_pfMQADQueryUserCert == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 270);
    }
    m_pfMQADQueryConnectors = (MQADQueryConnectors_ROUTINE)GetProcAddress(m_hLib,"MQADQueryConnectors");
    if (m_pfMQADQueryConnectors == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 280);
    }
    m_pfMQADQueryForeignSites = (MQADQueryForeignSites_ROUTINE)GetProcAddress(m_hLib,"MQADQueryForeignSites");
    if (m_pfMQADQueryForeignSites == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 290);
    }
    m_pfMQADQueryLinks = (MQADQueryLinks_ROUTINE)GetProcAddress(m_hLib,"MQADQueryLinks");
    if (m_pfMQADQueryLinks == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 300);
    }
    m_pfMQADQueryAllLinks = (MQADQueryAllLinks_ROUTINE)GetProcAddress(m_hLib,"MQADQueryAllLinks");
    if (m_pfMQADQueryAllLinks == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 310);
    }
    m_pfMQADQueryAllSites = (MQADQueryAllSites_ROUTINE)GetProcAddress(m_hLib,"MQADQueryAllSites");
    if (m_pfMQADQueryAllSites == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 320);
    }
    m_pfMQADQueryQueues = (MQADQueryQueues_ROUTINE)GetProcAddress(m_hLib,"MQADQueryQueues");
    if (m_pfMQADQueryQueues == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 330);
    }
    m_pfMQADQueryResults = (MQADQueryResults_ROUTINE)GetProcAddress(m_hLib,"MQADQueryResults");
    if (m_pfMQADQueryResults == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 340);
    }
    m_pfMQADEndQuery = (MQADEndQuery_ROUTINE)GetProcAddress(m_hLib,"MQADEndQuery");
    if (m_pfMQADEndQuery == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 350);
    }
    m_pfMQADGetObjectSecurity = (MQADGetObjectSecurity_ROUTINE)GetProcAddress(m_hLib, "MQADGetObjectSecurity");
    if (m_pfMQADGetObjectSecurity == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 360);
    }
    m_pfMQADGetObjectSecurityGuid = (MQADGetObjectSecurityGuid_ROUTINE)GetProcAddress(m_hLib, "MQADGetObjectSecurityGuid");
    if (m_pfMQADGetObjectSecurityGuid == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 370);
    }
    m_pfMQADSetObjectSecurity = (MQADSetObjectSecurity_ROUTINE)GetProcAddress(m_hLib, "MQADSetObjectSecurity");
    if (m_pfMQADSetObjectSecurity == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 380);
    }
    m_pfMQADSetObjectSecurityGuid = (MQADSetObjectSecurityGuid_ROUTINE)GetProcAddress(m_hLib, "MQADSetObjectSecurityGuid");
    if (m_pfMQADSetObjectSecurityGuid == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 385);
    }
    m_pfMQADGetADsPathInfo = (MQADGetADsPathInfo_ROUTINE)GetProcAddress(m_hLib, "MQADGetADsPathInfo");
    if (m_pfMQADGetADsPathInfo == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 386);
    }

	m_pfMQADFreeMemory = (MQADFreeMemory_ROUTINE)GetProcAddress(m_hLib, "MQADFreeMemory");
    if (m_pfMQADFreeMemory == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 386);
    }
    return MQ_OK;
}

void CActiveDirectoryProvider::Terminate()
/*++
    Abstract:
    unload aqad dll 

    Parameters:
    none

    Returns:
	none
--*/
{
    //
    //  BUGBUG -The following code is not thread safe.
    //
    m_pfMQADCreateObject = NULL;
    m_pfMQADDeleteObject = NULL;
    m_pfMQADDeleteObjectGuid = NULL;
    m_pfMQADGetObjectProperties = NULL;
    m_pfMQADGetObjectPropertiesGuid = NULL;
    m_pfMQADQMGetObjectSecurity = NULL;
    m_pfMQADSetObjectProperties = NULL;
    m_pfMQADSetObjectPropertiesGuid = NULL;
    m_pfMQADQMSetMachineProperties = NULL;
    m_pfMQADInit = NULL;
    m_pfMQADSetupInit = NULL;
    m_pfMQADGetComputerSites = NULL;
    m_pfMQADBeginDeleteNotification = NULL;
    m_pfMQADNotifyDelete = NULL;
    m_pfMQADEndDeleteNotification = NULL;
    m_pfMQADQueryMachineQueues = NULL;
    m_pfMQADQuerySiteServers = NULL;
	m_pfMQADQueryNT4MQISServers = NULL;
    m_pfMQADQueryUserCert = NULL;
    m_pfMQADQueryConnectors = NULL;
    m_pfMQADQueryForeignSites = NULL;
    m_pfMQADQueryLinks = NULL;
    m_pfMQADQueryAllLinks = NULL;
    m_pfMQADQueryAllSites = NULL;
    m_pfMQADQueryQueues = NULL;
    m_pfMQADQueryResults = NULL;
    m_pfMQADEndQuery = NULL;
    m_pfMQADGetObjectSecurity = NULL;
    m_pfMQADGetObjectSecurityGuid = NULL;
    m_pfMQADSetObjectSecurity = NULL;
    m_pfMQADSetObjectSecurityGuid = NULL;
    m_pfMQADGetADsPathInfo = NULL;
 
    HINSTANCE hLib = m_hLib.detach();
    if (hLib)
    {
        FreeLibrary(hLib); 
    }

    CDSClientProvider * pClient =  m_pDownLevelProvider.detach(); 
    if ( pClient)
    {
        pClient->Terminate();
        delete pClient;
    }
    m_pfMQADGetComputerVersion = NULL;


}

HRESULT CActiveDirectoryProvider::ADGetADsPathInfo(
                IN  LPCWSTR                 pwcsADsPath,
                OUT PROPVARIANT *           pVar,
                OUT eAdsClass *             pAdsClass
                )
/*++

Routine Description:
    Retreives information about the specified object

Arguments:
	LPCWSTR                 pwcsADsPath - object pathname
	const PROPVARIANT       pVar - property values
    eAdsClass *             pAdsClass - indication about the object class
Return Value
	HRESULT

--*/
{
    ASSERT(m_pfMQADGetADsPathInfo != NULL);
    return m_pfMQADGetADsPathInfo(
                pwcsADsPath,
                pVar,
                pAdsClass
                );

}


bool CActiveDirectoryProvider::IsDownlevelClient(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const GUID*             pguidObject
                )
/*++

Routine Description:
    Validates if the specified computer is Whistler or not

Arguments:
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsComputerName - Computer name
Return Value
    bool 	true : the computer is downlevel client

--*/
{
    //
    // This is a best effort to find out if the object belongs to downlevel
    // computer.
    // In any case of failure, will assume that it is not downlevel client
    //
    MQPROPVARIANT var;
    var.vt = VT_NULL;
    
    ASSERT(m_pfMQADGetComputerVersion != NULL);
    HRESULT hr =  m_pfMQADGetComputerVersion(
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                pguidObject,
                &var
                );

    if (FAILED(hr))
    {
       LogHR(hr, s_FN, 823);
       return false;
    }
    
	CAutoADFree<WCHAR> pwcsVersion = var.pwszVal;
    ASSERT(pwcsVersion != NULL);
    //
    // If the property contains L"", then it is Win9x
    // or WinME computer or foreign computer
    //
    if (pwcsVersion[0] == L'')
    {
        return true;
    }
    //
    // For NT4 computers, the version is 4.0
    // For W2K computers, the version string begins with 5.0
    // For Whistler computers, the version string begins with 5.1
    //
    const WCHAR NT4_VERSION[] = L"4.0";
    const WCHAR W2K_VERSION[] = L"5.0";

    if ((0 == wcsncmp(pwcsVersion, NT4_VERSION, STRLEN(NT4_VERSION))) ||
        (0 == wcsncmp(pwcsVersion, W2K_VERSION, STRLEN(W2K_VERSION))))
    {
        return true;
    }
    
    return false;

}

DWORD CActiveDirectoryProvider::GetMsmqDisableDownlevelKeyValue()
/*++

Routine Description:
    Read flacon registry downlevel key.

Arguments:
	None

Return Value:
	DWORD key value (DEFAULT_DOWNLEVEL if the key not exist)
--*/
{

    CAutoCloseRegHandle hKey;
    LONG rc = RegOpenKeyEx(
				 FALCON_REG_POS,
				 FALCON_REG_KEY,
				 0,
				 KEY_READ,
				 &hKey
				 );

    if ( rc != ERROR_SUCCESS)
    {
        ASSERT(("At this point MSMQ Registry must exist", 0));
        return DEFAULT_DOWNLEVEL;
    }

    DWORD value = 0;
    DWORD type = REG_DWORD;
    DWORD size = sizeof(DWORD);
    rc = RegQueryValueEx( 
             hKey,
             MSMQ_DOWNLEVEL_REGNAME,
             0L,
             &type,
             reinterpret_cast<BYTE*>(&value),
             &size 
             );
    
    if ((rc != ERROR_SUCCESS) && (rc != ERROR_FILE_NOT_FOUND))
    {
        ASSERT(("We should get either ERROR_SUCCESS or ERROR_FILE_NOT_FOUND", 0));
        return DEFAULT_DOWNLEVEL;
    }

	TrTRACE(AD, "registry value: %ls = %d", MSMQ_DOWNLEVEL_REGNAME, value);

    return value;
}

HRESULT CActiveDirectoryProvider::InitDownlevelNotifcationSupport(
                IN MQGetMQISServer_ROUTINE      pGetServers,
                IN bool                         fSetupMode,
                IN bool                         fQMDll,
                IN bool                         fDisableDownlevelNotifications,
                IN NoServerAuth_ROUTINE         pNoServerAuth
                )
/*++

Routine Description:
    First stage init of downlevel notification support

Arguments:
    MQGetMQISServer_ROUTINE pGetServers -
    bool  fSetupMode -  called during setup
    bool  fQMDll - called by QM
    bool  fDisableDownlevelNotifications - 
    NoServerAuth_ROUTINE pNoServerAuth -

Return Value:
	HRESULT
--*/
{
    //
    //  Explicit overwrite of default to support downlevel notifications
    //
    if ( fDisableDownlevelNotifications)
    {
        m_fSupportDownlevelNotifications = false;
        return MQ_OK;
    }

    //
    //  Next let's see if there is a local registry key that overrides downlevel
    //  notification support
    //
    if (GetMsmqDisableDownlevelKeyValue() > 0)
    {
        m_fSupportDownlevelNotifications = false;
        return MQ_OK;
    }

    //
    //  Next step, read Enterprise object - to see if downlevel notification is supported
    //
    PROPID prop = PROPID_E_CSP_NAME;
    PROPVARIANT var;
    var.vt = VT_NULL;

    ASSERT(m_pfMQADGetObjectProperties != NULL);
    HRESULT hr = m_pfMQADGetObjectProperties(
						eENTERPRISE,
						NULL,       // pwcsDomainController
						false,	    // fServerName
						L"msmq",
						1,
						&prop,
						&var
						);
    if (FAILED(hr))
    {
	    TrTRACE(AD, "Failed to read PROPID_E_CSP_NAME: hr = 0x%x", hr);
        //
        //  Ignore the failure, incase of failure support downlevel notifications
        //
        m_fSupportDownlevelNotifications = true;
    }
    else
    {
        CAutoADFree<WCHAR> pClean = var.pwszVal;

        m_fSupportDownlevelNotifications = (*var.pwszVal != L'N') ? true: false;
    }

    if ( !m_fSupportDownlevelNotifications)
    {
        return MQ_OK;
    }

    TrTRACE(AD, "Supporting downlevel notification ");

    m_pGetServers = pGetServers;
    m_fSetupMode = fSetupMode;
    m_fQMDll = fQMDll;
    m_pNoServerAuth = pNoServerAuth;

    ASSERT(m_hLib != NULL);

    m_pfMQADGetComputerVersion = (MQADGetComputerVersion_ROUTINE)GetProcAddress(m_hLib,"MQADGetComputerVersion"); 
    if (m_pfMQADGetComputerVersion == NULL)
    {
	    TrTRACE(AD, "Failed to get proc address of MQADGetComputerVersion");
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 199);
    }

    return MQ_OK;
}

HRESULT CActiveDirectoryProvider::LoadAndInitMQDSCli( )
/*++

Routine Description:
    Second stage init of downlevel notification support

Arguments:
    NONE

Return Value:
	HRESULT
--*/
{
    ASSERT(m_fSupportDownlevelNotifications);

    //
    //  Before starting MQDSCLI, lets verify that the MQIS server list in registry
    //  is not empty
    //
    if( !IsThereDsServerListInRegistry())
    {
	    TrTRACE(AD, "No DS server list registry key");
        return MQ_ERROR_NO_DS;
    }
    //
    //  Load MQDSLI and Init only once
    //
    if (m_pDownLevelProvider != NULL)
    {
        return MQ_OK;
    }

    CS lock(m_csInitialization);

    if (m_pDownLevelProvider != NULL)
    {
        return MQ_OK;
    }

    m_pDownLevelProvider = new CDSClientProvider();
    HRESULT hr = m_pDownLevelProvider->Init(
                        NULL,   // relevant only for QM
                        m_pGetServers,    // relevant only for dep client
                        m_fSetupMode,
                        m_fQMDll,
                        m_pNoServerAuth,
                        NULL,            // szServerName - not used
                        false            // fDisableDownlevelNotifications
                        );
    if (FAILED(hr))
    {
	    TrTRACE(AD, "Failed to init MQDSCli: hr = 0x%x", hr);
        return hr;
    }
    return MQ_OK;
}

bool CActiveDirectoryProvider::IsThereDsServerListInRegistry()
/*++

Routine Description:
    Verify that DS SERVER LIST registry exists 

Arguments:
	None

Return Value:
	bool
--*/
{

    CAutoCloseRegHandle hKey;
    LONG rc = RegOpenKeyEx(
				 FALCON_REG_POS,
				 FALCON_MACHINE_CACHE_REG_KEY,
				 0,
				 KEY_READ,
				 &hKey
				 );

    if ( rc != ERROR_SUCCESS)
    {
        ASSERT(("At this point MSMQ Registry must exist", 0));
	    TrTRACE(AD, "Failed to open MSMQ reg key: rc = 0x%x", rc);
        return false;
    }

    WCHAR wszServers[ MAX_REG_DSSERVER_LEN];
    DWORD type = REG_SZ;
    DWORD size = sizeof(wszServers);

    rc = RegQueryValueEx( 
             hKey,
             MSMQ_DS_SERVER_REGVALUE,
             0L,
             &type,
             reinterpret_cast<BYTE*>(wszServers),
             &size 
             );
    
    if ( rc != ERROR_SUCCESS)
    {
	    TrTRACE(AD, "Failed to read value of %ls, rc = 0x%x", MSMQ_DOWNLEVEL_REGNAME, rc);
        return false;
    }

    return true;
}


void
CActiveDirectoryProvider::FreeMemory(
	PVOID pMemory
	)
{
	m_pfMQADFreeMemory(pMemory);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\cliprov.cpp ===
/*++


Copyright (c) 2000  Microsoft Corporation 

Module Name:

    cliprov.cpp

Abstract:

	DS client provider class.

Author:

    Ilan Herbst		(ilanh)		13-Sep-2000

--*/
#include "ds_stdh.h"
#include "ad.h"
#include "cliprov.h"
#include "adglbobj.h"
#include "mqlog.h"
#include "mqmacro.h"
#include "traninfo.h"
#include "queryh.h"
#include "_ta.h"
#include "adalloc.h"

static WCHAR *s_FN=L"ad/cliprov";

//
// translation information of properties
//
CMap<PROPID, PROPID, const PropTranslation*, const PropTranslation*&> g_PropDictionary;

CDSClientProvider::CDSClientProvider():
            m_pfDSCreateObject(NULL),
            m_pfDSGetObjectProperties(NULL),
            m_pfDSSetObjectProperties(NULL),
            m_pfDSLookupBegin(NULL),
            m_pfDSLookupNext(NULL),
            m_pfDSLookupEnd(NULL),
            m_pfDSInit(NULL),
            m_pfDSGetObjectPropertiesGuid(NULL),
            m_pfDSSetObjectPropertiesGuid(NULL),
            m_pfDSQMSetMachineProperties(NULL),
            m_pfDSCreateServersCache(NULL),
            m_pfDSQMGetObjectSecurity(NULL),
            m_pfDSGetComputerSites(NULL),
            m_pfDSGetObjectPropertiesEx(NULL),
            m_pfDSGetObjectPropertiesGuidEx(NULL),
			m_pfDSSetObjectSecurity(NULL),
			m_pfDSGetObjectSecurity(NULL),
			m_pfDSDeleteObject(NULL),
			m_pfDSSetObjectSecurityGuid(NULL),
			m_pfDSGetObjectSecurityGuid(NULL),
			m_pfDSDeleteObjectGuid(NULL),
			m_pfDSBeginDeleteNotification(NULL),
			m_pfDSNotifyDelete(NULL),
			m_pfDSEndDeleteNotification(NULL),
			m_pfDSFreeMemory(NULL)
{
}
                                                   

CDSClientProvider::~CDSClientProvider()
{
    //
    //  nothing to do, everthing is auto-pointers
    //
}


HRESULT 
CDSClientProvider::CreateObject(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN  LPCWSTR                 pwcsObjectName,
    IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    IN  const DWORD             cp,
    IN  const PROPID            aProp[],
    IN  const PROPVARIANT       apVar[],
    OUT GUID*                   pObjGuid
    )
/*++

Routine Description:
	The function check the properties and take the action according to the properties type.
	The following action can be done to the properties:
	1) using the input property set
	2) Convert the input propery set to a new set (eliminate default props, convert props)
	For the Create operation, Forwards the call to mqdscli dll

Arguments:
	eObject - object type
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
	pwcsObjectName - MSMQ object name
	pSecurityDescriptor - object SD
	cp - number of properties
	aProp - properties
	apVar - property values
	pObjGuid - the created object unique id

Return Value
	HRESULT
--*/
{
	//
	// Check if we try to set some properties that are not supported
	// and must have their defalt value
	//
	if(!CheckProperties(cp, aProp, apVar))
		return MQ_ERROR_PROPERTY;
		
	//
	// Find property type and if convert is needed
	//
	bool fNeedConvert;
	PropsType PropertiesType = CheckPropertiesType(eObject, cp, aProp, &fNeedConvert);
	
    ASSERT(m_pfDSCreateObject != NULL);

	if(!fNeedConvert)
	{
		//
		// No convert, use input properties
		// this is either all props are NT4
		// or we have some NT5 props that we can not convert
		//
		return m_pfDSCreateObject( 
					GetMsmq2Object(eObject),
					pwcsObjectName,
					pSecurityDescriptor,
					cp,
					const_cast<PROPID*>(aProp),
					const_cast<PROPVARIANT*>(apVar),
					pObjGuid
					);
	}

	//
	// Prepare the new props
	// we are here in case we should eliminate default props
	// or we should convert the props to NT4 props
	//
	DWORD cpNew;
	AP<PROPID> aPropNew;
	AP<PROPVARIANT> apVarNew;

	ConvertPropsForSet(eObject, PropertiesType, cp, aProp, apVar, &cpNew, &aPropNew, &apVarNew);   

	return m_pfDSCreateObject( 
				GetMsmq2Object(eObject),
				pwcsObjectName,
				pSecurityDescriptor,
				cpNew,
				aPropNew,
				apVarNew,
				pObjGuid
				);
}


HRESULT 
CDSClientProvider::DeleteObject(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN  LPCWSTR                 pwcsObjectName
    )
/*++

Routine Description:
    Forwards the call to mqdscli dll

Arguments:
	eObject - object type
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
	pwcsObjectName - MSMQ object name

Return Value
	HRESULT
--*/
{
    ASSERT(m_pfDSDeleteObject != NULL);
    return m_pfDSDeleteObject( 
                GetMsmq2Object(eObject),
                pwcsObjectName
                );
}


HRESULT 
CDSClientProvider::DeleteObjectGuid(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN  const GUID*             pguidObject
    )
/*++

Routine Description:
    Forwards the call to mqdscli dll

Arguments:
	eObject - object type
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
	pguidObject - the unique id of the object

Return Value
	HRESULT
--*/
{
    ASSERT(m_pfDSDeleteObjectGuid != NULL);
    return m_pfDSDeleteObjectGuid( 
                GetMsmq2Object(eObject),
                pguidObject
                );
}


HRESULT 
CDSClientProvider::GetObjectSecurityKey(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 pwcsObjectName,
    IN  const GUID*             pguidObject,
    IN  const DWORD             cp,
    IN  const PROPID            aProp[],
    IN OUT PROPVARIANT          apVar[]
    )
/*++

Routine Description:
	Get the security key property PROPID_QM_ENCRYPT_PK or PROPID_QM_SIGN_PK

Arguments:
	eObject - object type
	pwcsObjectName - MSMQ object name
	pguidObject - the unique id of the object
	cp - number of properties
	aProp - properties
	apVar - property values

Return Value
	HRESULT
--*/
{
	ASSERT((pwcsObjectName != NULL) ^ (pguidObject != NULL));

	//
	// Get the RequestedInformation
	//
	SECURITY_INFORMATION RequestedInformation = GetKeyRequestedInformation(eObject, cp, aProp);

	ASSERT(RequestedInformation != 0);

	//
	// Get the Key according to pwcsObjectName or pguidObject 
	//

	BYTE abPbKey[1024];
    DWORD dwReqLen;

	HRESULT hr;
	if(pwcsObjectName != NULL)
	{
		ASSERT(m_pfDSGetObjectSecurity != NULL);
		hr = m_pfDSGetObjectSecurity(
					GetMsmq2Object(eObject),
					pwcsObjectName,
					RequestedInformation,
					abPbKey,
					sizeof(abPbKey),
					&dwReqLen
					);
	}
	else
	{
		ASSERT(m_pfDSGetObjectSecurityGuid != NULL);
		hr = m_pfDSGetObjectSecurityGuid(
					GetMsmq2Object(eObject),
					pguidObject,
					RequestedInformation,
					abPbKey,
					sizeof(abPbKey),
					&dwReqLen
					);
	}
	
	if (FAILED(hr))
        return hr;

	ASSERT(dwReqLen <= 1024);

	//
	// Assign the return value to the apVar prop
	// RunTime should convert this value to VT_UI1|VT_VECTOR
	// when using PROPID_QM_ENCRYPT_PK for getting
	// PROPID_QM_ENCRYPTION_PK or PROPID_QM_ENCRYPTION_PK_BASE
	//
    apVar[0].vt = VT_BLOB;
    apVar[0].caub.cElems = dwReqLen;
    apVar[0].caub.pElems = new UCHAR[dwReqLen];
    memcpy(apVar[0].caub.pElems, abPbKey, dwReqLen);
	return hr;
}


HRESULT 
CDSClientProvider::GetObjectPropertiesInternal(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 pwcsObjectName,
    IN  const GUID*             pguidObject,
    IN  const DWORD             cp,
    IN  const PROPID            aProp[],
    IN OUT PROPVARIANT          apVar[]
    )
/*++

Routine Description:
	Get object properties.
	Special case properties:
	1) PROPID_E_ID - lookup
	2) security keys PROPID_QM_ENCRYPT_PK, PROPID_QM_SIGN_PK - m_pfDSGetObjectSecurity
	3) Ex properties - m_pfDSGetObjectPropertiesEx

	If no special properties, 
	check the properties and take the action according to the properties type.
	The following action can be done to the properties:
	1) using the input property set
	2) Convert the input propery set to a new set (eliminate default props, convert props)
	   and reconstruct the original props from the new props values.

Arguments:
	eObject - object type
	pwcsObjectName - MSMQ object name
	pguidObject - the unique id of the object
	cp - number of properties
	aProp - properties
	apVar - property values

Return Value
	HRESULT
--*/
{
	ASSERT((pwcsObjectName != NULL) ^ (pguidObject != NULL));

	if(IsEIDProperty(cp, aProp))
	{
		//
		// PROPID_E_ID
		//
		return GetEnterpriseId(cp, aProp, apVar);
	}
		
	if(IsKeyProperty(cp, aProp))
	{
		//
		// Security keys PROPID_QM_ENCRYPT_PK, PROPID_QM_SIGN_PK 
		//
		return GetObjectSecurityKey(
					eObject,
					pwcsObjectName,
					pguidObject,
					cp,
					const_cast<PROPID*>(aProp),
					apVar
					);
	}

	if(IsExProperty(cp, aProp))
	{
		//
		// Handling Ex property 
		// PROPID_Q_OBJ_SECURITY, PROPID_QM_OBJ_SECURITY
		// PROPID_QM_ENCRYPT_PKS, PROPID_QM_SIGN_PKS
		// use *Ex api.
		//

		ASSERT(("Must be one property for GetObjectProp*Ex", cp == 1));

		if(pwcsObjectName != NULL)
		{
			ASSERT(m_pfDSGetObjectPropertiesEx != NULL);
			return m_pfDSGetObjectPropertiesEx(
						GetMsmq2Object(eObject),
						pwcsObjectName,
						cp,
						const_cast<PROPID*>(aProp),
						apVar
						);
		}
		else
		{
			ASSERT(m_pfDSGetObjectPropertiesGuidEx != NULL);
			return m_pfDSGetObjectPropertiesGuidEx(
						GetMsmq2Object(eObject),
						pguidObject,
						cp,
						const_cast<PROPID*>(aProp),
						apVar
						);
		}
	}

	//
	// Find props type and if convert is needed
	//
	bool fNeedConvert;
	PropsType PropertiesType = CheckPropertiesType(eObject, cp, aProp, &fNeedConvert);
	
	if(!fNeedConvert)
	{
		//
		// No convert, use input properties
		// this is either all props are NT4
		// or we have some NT5 props that we can not convert
		//

		if(pwcsObjectName != NULL)
		{
			ASSERT(m_pfDSGetObjectProperties != NULL);
			return m_pfDSGetObjectProperties(
						GetMsmq2Object(eObject),
						pwcsObjectName,
						cp,
						const_cast<PROPID*>(aProp),
						apVar
						);
		}
		else
		{
		    ASSERT(m_pfDSGetObjectPropertiesGuid != NULL);
			return m_pfDSGetObjectPropertiesGuid(
						GetMsmq2Object(eObject),
						pguidObject,
						cp,
						const_cast<PROPID*>(aProp),
						apVar
						);
		}
	}

	//
	// Prepare the new props and information for reconstruct the 
	// original property set
	// we are here in case we should eliminate default props
	// or we should convert the props to NT4 props
	//
	AP<PropInfo> pPropInfo = new PropInfo[cp];
	DWORD cpNew;
	AP<PROPID> aPropNew;
	AP<PROPVARIANT> apVarNew;

	ConvertPropsForGet(
		eObject, 
		PropertiesType, 
		cp, 
		aProp, 
		apVar, 
		pPropInfo, 
		&cpNew, 
		&aPropNew,  
		&apVarNew
		);

	HRESULT hr;
	if(pwcsObjectName != NULL)
	{
		ASSERT(m_pfDSGetObjectProperties != NULL);
		hr = m_pfDSGetObjectProperties(
					GetMsmq2Object(eObject),
					pwcsObjectName,
					cpNew,
					aPropNew,
					apVarNew
					);
	}
	else
	{
		ASSERT(m_pfDSGetObjectPropertiesGuid != NULL);
		hr = m_pfDSGetObjectPropertiesGuid(
					GetMsmq2Object(eObject),
					pguidObject,
					cpNew,
					aPropNew,
					apVarNew
					);

	}

	if (FAILED(hr))
		return hr;

	//
	// Reconstruct the original properties array
	//
	ReconstructProps(
		pwcsObjectName, 
		pguidObject,
		cpNew, 
		aPropNew, 
		apVarNew, 
		pPropInfo, 
		cp, 
		aProp, 
		apVar
		);   

	return MQ_OK;
	
}


HRESULT 
CDSClientProvider::GetObjectProperties(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN  LPCWSTR                 pwcsObjectName,
    IN  const DWORD             cp,
    IN  const PROPID            aProp[],
    IN OUT PROPVARIANT          apVar[]
    )
/*++

Routine Description:
	Get object properties.

Arguments:
	eObject - object type
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
	pwcsObjectName - MSMQ object name
	cp - number of properties
	aProp - properties
	apVar - property values

Return Value
	HRESULT
--*/
{
	return GetObjectPropertiesInternal(
				eObject,
				pwcsObjectName,
				NULL,	// pguidObject
				cp,
				aProp,
				apVar
				);
}


HRESULT 
CDSClientProvider::GetObjectPropertiesGuid(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN  const GUID*             pguidObject,
    IN  const DWORD             cp,
    IN  const PROPID            aProp[],
    IN  OUT PROPVARIANT         apVar[]
    )
/*++

Routine Description:
	Get object properties.

Arguments:
	eObject - object type
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
	pguidObject -  object unique id
	cp - number of properties
	aProp - properties
	apVar - property values

Return Value
	HRESULT
--*/
{
	return GetObjectPropertiesInternal(
				eObject,
				NULL,  // pwcsObjectName
				pguidObject,
				cp,
				aProp,
				apVar
				);
}


HRESULT 
CDSClientProvider::QMGetObjectSecurity(
    IN  AD_OBJECT               eObject,
    IN  const GUID*             pguidObject,
    IN  SECURITY_INFORMATION    RequestedInformation,
    IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    IN  DWORD                   nLength,
    IN  LPDWORD                 lpnLengthNeeded,
    IN  DSQMChallengeResponce_ROUTINE
                                pfChallengeResponceProc,
    IN  DWORD_PTR               dwContext
    )
/*++

Routine Description:
    Forwards the call to mqdscli dll

Arguments:
    object - object type
    pguidObject - unique id of the object
    RequestedInformation - what security info is requested
    pSecurityDescriptor - SD response buffer
    nLength - length of SD buffer
    lpnLengthNeeded
    pfChallengeResponceProc,
    dwContext

Return Value
	HRESULT
--*/
{
    ASSERT(m_pfDSQMGetObjectSecurity != NULL);
    return m_pfDSQMGetObjectSecurity(
                GetMsmq2Object(eObject),
                pguidObject,
                RequestedInformation,
                pSecurityDescriptor,
                nLength,
                lpnLengthNeeded,
                pfChallengeResponceProc,
                dwContext
                );
}


HRESULT 
CDSClientProvider::SetObjectSecurityKey(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 pwcsObjectName,
    IN  const GUID*             pguidObject,
    IN  const DWORD             cp,
    IN  const PROPID            aProp[],
    IN  const PROPVARIANT       apVar[]
    )
/*++

Routine Description:
	Set the security key property PROPID_QM_ENCRYPT_PK or PROPID_QM_SIGN_PK

Arguments:
	eObject - object type
	pwcsObjectName - MSMQ object name
	pguidObject - the unique id of the object
	cp - number of properties
	aProp - properties
	apVar - property values

Return Value
	HRESULT
--*/
{
	ASSERT((pwcsObjectName != NULL) ^ (pguidObject != NULL));

	//
	// Get the RequestedInformation
	//
	SECURITY_INFORMATION RequestedInformation = GetKeyRequestedInformation(eObject, cp, aProp);

	ASSERT(RequestedInformation != 0);

	ASSERT(apVar[0].vt == VT_BLOB);

	//
	// Create PMQDS_PublicKey structure for the key
	//
	BYTE abPbKey[1024];
	PMQDS_PublicKey pMQDS_PbK = (PMQDS_PublicKey)abPbKey;

	pMQDS_PbK->dwPublikKeyBlobSize = apVar[0].blob.cbSize;

	ASSERT((apVar[0].blob.cbSize + sizeof(DWORD)) <= sizeof(abPbKey));

    memcpy(pMQDS_PbK->abPublicKeyBlob, apVar[0].blob.pBlobData, apVar[0].blob.cbSize);

	if(pwcsObjectName != NULL)
	{
		ASSERT(m_pfDSSetObjectSecurity != NULL);
		return m_pfDSSetObjectSecurity(
					GetMsmq2Object(eObject),
					pwcsObjectName,
					RequestedInformation,
					reinterpret_cast<PSECURITY_DESCRIPTOR>(pMQDS_PbK)
					);
	}
	else
	{
		ASSERT(m_pfDSSetObjectSecurityGuid != NULL);
		return m_pfDSSetObjectSecurityGuid(
					GetMsmq2Object(eObject),
					pguidObject,
					RequestedInformation,
					reinterpret_cast<PSECURITY_DESCRIPTOR>(pMQDS_PbK)
					);
	}

}


HRESULT 
CDSClientProvider::SetObjectPropertiesInternal(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 pwcsObjectName,
    IN  const GUID*             pguidObject,
    IN  const DWORD             cp,
    IN  const PROPID            aProp[],
    IN  const PROPVARIANT       apVar[]
    )
/*++

Routine Description:
	Set object properties.
	Special case properties:
	1) security keys PROPID_QM_ENCRYPT_PK, PROPID_QM_SIGN_PK - m_pfDSGetObjectSecurity

	If no special properties, 
	check the properties and take the action according to the properties type.
	The following action can be done to the properties:
	1) using the input property set
	2) Convert the input propery set to a new set (eliminate default props, convert props)

Arguments:
	eObject - object type
	pwcsObjectName - MSMQ object name
	pguidObject - the unique id of the object
	cp - number of properties
	aProp - properties
	apVar - property values

Return Value
	HRESULT
--*/
{
	ASSERT((pwcsObjectName != NULL) ^ (pguidObject != NULL));

	if(IsKeyProperty(cp, aProp))
	{
		//
		// Security keys PROPID_QM_ENCRYPT_PK, PROPID_QM_SIGN_PK 
		//
		return SetObjectSecurityKey(
					eObject,
					pwcsObjectName,
					pguidObject,
					cp,
					aProp,
					apVar
					);
	}

	//
	// Check if we try to set some properties that are not supported
	// and must have their defalt value
	//
	if(!CheckProperties(cp, aProp, apVar))
		return MQ_ERROR_PROPERTY;

	//
	// Find property type and if convert is needed
	//
	bool fNeedConvert;
	PropsType PropertiesType = CheckPropertiesType(eObject, cp, aProp, &fNeedConvert);

	if(!fNeedConvert)
	{
		//
		// No convert, use input properties
		// this is either all props are NT4
		// or we have some NT5 props that we can not convert
		//

		if(pwcsObjectName != NULL)
		{
		    ASSERT(m_pfDSSetObjectProperties != NULL);
			return m_pfDSSetObjectProperties(
						GetMsmq2Object(eObject),
						pwcsObjectName,
						cp,
						const_cast<PROPID*>(aProp),
						const_cast<PROPVARIANT*>(apVar)
						);
		}
		else
		{
		    ASSERT(m_pfDSSetObjectPropertiesGuid != NULL);
			return m_pfDSSetObjectPropertiesGuid(
						GetMsmq2Object(eObject),
						pguidObject,
						cp,
						const_cast<PROPID*>(aProp),
						const_cast<PROPVARIANT*>(apVar)
						);
		}		
	}

	//
	// Prepare the new props
	// we are here in case we should eliminate default props
	// or we should convert the props to NT4 props
	//
	DWORD cpNew;
	AP<PROPID> aPropNew;
	AP<PROPVARIANT> apVarNew;

	ConvertPropsForSet(
		eObject, 
		PropertiesType, 
		cp, 
		aProp, 
		apVar, 
		&cpNew, 
		&aPropNew, 
		&apVarNew
		);   

	if(pwcsObjectName != NULL)
	{
		ASSERT(m_pfDSSetObjectProperties != NULL);
		return m_pfDSSetObjectProperties(
					GetMsmq2Object(eObject),
					pwcsObjectName,
					cpNew,
					aPropNew,
					apVarNew
					);
	}
	else
	{
		ASSERT(m_pfDSSetObjectPropertiesGuid != NULL);
		return m_pfDSSetObjectPropertiesGuid(
					GetMsmq2Object(eObject),
					pguidObject,
					cpNew,
					aPropNew,
					apVarNew
					);
	}
}


HRESULT 
CDSClientProvider::SetObjectProperties(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN  LPCWSTR                 pwcsObjectName,
    IN  const DWORD             cp,
    IN  const PROPID            aProp[],
    IN  const PROPVARIANT       apVar[]
    )
/*++

Routine Description:
	Set object properties.

Arguments:
	eObject - object type
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
	pwcsObjectName - MSMQ object name
	cp - number of properties
	aProp - properties
	apVar - property values

Return Value
	HRESULT
--*/
{
	return SetObjectPropertiesInternal(
				eObject,
				pwcsObjectName,
				NULL,	// pguidObject
				cp,
				aProp,
				apVar
				);
}


HRESULT 
CDSClientProvider::SetObjectPropertiesGuid(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN  const GUID*             pguidObject,
    IN  const DWORD             cp,
    IN  const PROPID            aProp[],
    IN  const PROPVARIANT       apVar[]
    )
/*++

	Set object properties.

Arguments:
	eObject - object type
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
	pguidObject - the object unique id
	cp - number of properties
	aProp - properties
	apVar - property values

Return Value
	HRESULT
--*/
{
	return SetObjectPropertiesInternal(
				eObject,
				NULL,	// pwcsObjectName
				pguidObject,
				cp,
				aProp,
				apVar
				);
}


HRESULT 
CDSClientProvider::QMSetMachineProperties(
    IN  LPCWSTR             pwcsObjectName,
    IN  const DWORD         cp,
    IN  const PROPID        aProp[],
    IN  const PROPVARIANT   apVar[],
    IN  DSQMChallengeResponce_ROUTINE pfSignProc,
    IN  DWORD_PTR           dwContext
    )
/*++

Routine Description:
	QM set machine properties.
	Assume all props are NT4 props.

Arguments:
    pwcsObjectName - object msmq-name
    cp - number of properties to set
    aProp - properties
    apVar  property values
    pfSignProc - sign routine
    dwContext

Return Value
	HRESULT
--*/
{
	ASSERT(IsNt4Properties(eMACHINE, cp, aProp));

    ASSERT(m_pfDSQMSetMachineProperties != NULL);
	return m_pfDSQMSetMachineProperties(
				pwcsObjectName,
				cp,
				const_cast<PROPID*>(aProp),
				const_cast<PROPVARIANT*>(apVar),
				pfSignProc,
				dwContext
				);
}


HRESULT 
CDSClientProvider::Init( 
    IN QMLookForOnlineDS_ROUTINE    pLookDS,
    IN MQGetMQISServer_ROUTINE      pGetServers,
    IN bool                         fSetupMode,
    IN bool                         fQMDll,
    IN NoServerAuth_ROUTINE         pNoServerAuth,
    IN LPCWSTR                      szServerName,
    IN bool                         /*fDisableDownlevelNotifications*/
    )
/*++

Routine Description:
    Loads mqdscli dll, init property translation info
	and then forwards the call to mqdscli dll

Arguments:
    QMLookForOnlineDS_ROUTINE pLookDS -
    MQGetMQISServer_ROUTINE pGetServers -
    fDSServerFunctionality - should provide DS server functionality
    fSetupMode -  called during setup
    fQMDll - called by QM
    NoServerAuth_ROUTINE pNoServerAuth -
    szServerName -

Return Value
	HRESULT
--*/
{
    HRESULT hr = LoadDll();
    if (FAILED(hr))
    {
        return hr;
    }

	InitPropertyTranslationMap();

    ASSERT(m_pfDSInit != NULL);
    return m_pfDSInit(
                pLookDS,
                pGetServers,
                FALSE,
                (fSetupMode) ? TRUE : FALSE,
                (fQMDll) ? TRUE : FALSE,
                pNoServerAuth,
                szServerName
                );
}


HRESULT 
CDSClientProvider::SetupInit(
    IN    unsigned char   /* ucRoll */,
    IN    LPWSTR          /* pwcsPathName */,
    IN    const GUID *    /* pguidMasterId */
    )
/*++

Routine Description:

Arguments:
    ucRoll -
    pwcsPathName -
    pguidMasterId -

Return Value
	HRESULT
--*/
{
    ASSERT(0);
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 30);
}


HRESULT CDSClientProvider::CreateServersCache()
/*++

Routine Description:
    Forward the call to mqdscli dll

Arguments:
    none

Return Value
	HRESULT
--*/
{
    ASSERT(m_pfDSCreateServersCache != NULL);
    return m_pfDSCreateServersCache();
}


HRESULT 
CDSClientProvider::GetComputerSites(
    IN  LPCWSTR     pwcsComputerName,
    OUT DWORD  *    pdwNumSites,
    OUT GUID **     ppguidSites
    )
/*++

Routine Description:
    Forwards the call to mqdscli dll

Arguments:
    pwcsComputerName - computer name
    pdwNumSites - number of sites retrieved
    ppguidSites - the retrieved sites ids

Return Value
	HRESULT
--*/
{
	if(ADGetEnterprise() == eAD)
	{
		ASSERT(m_pfDSGetComputerSites != NULL);
		return m_pfDSGetComputerSites(
							pwcsComputerName,
							pdwNumSites,
							ppguidSites
							);
	}

	return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 40);
}


HRESULT 
CDSClientProvider::BeginDeleteNotification(
    IN  AD_OBJECT       /* eObject */,
    IN LPCWSTR          /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN LPCWSTR			pwcsObjectName,
    IN OUT HANDLE*		phEnum
    )
/*++

Routine Description:

Arguments:
    eObject - object type
    pwcsDomainController - DC against which the operation should be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
    pwcsObjectName - msmq-name of the object
    phEnum - notification handle

Return Value
	HRESULT
--*/
{
	if(ADGetEnterprise() == eAD)
	{
		ASSERT(m_pfDSBeginDeleteNotification != NULL);
		return m_pfDSBeginDeleteNotification(
					pwcsObjectName,
					phEnum
					);
	}

    ASSERT(("BeginDeleteNotification not supported in mqis env by CDSClientProvider", 0));
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 50);
}


HRESULT 
CDSClientProvider::NotifyDelete(
    IN  HANDLE   hEnum
    )
/*++

Routine Description:

Arguments:
    hEnum - notification handle

Return Value
	HRESULT

--*/
{
	if(ADGetEnterprise() == eAD)
	{
		ASSERT(m_pfDSNotifyDelete != NULL);
		return m_pfDSNotifyDelete(
					hEnum
					);
	}
	
    ASSERT(("NotifyDelete not supported in mqis env by CDSClientProvider", 0));
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 60);

}


HRESULT 
CDSClientProvider::EndDeleteNotification(
    IN  HANDLE                  hEnum
    )
/*++

Routine Description:

Arguments:
    hEnum - notification handle

Return Value
	HRESULT
--*/
{
	if(ADGetEnterprise() == eAD)
	{
		ASSERT(m_pfDSEndDeleteNotification != NULL);
		return m_pfDSEndDeleteNotification(
					hEnum
					);
	}
	
    ASSERT(("EndDeleteNotification not supported in mqis env by CDSClientProvider", 0));
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 70);
}


HRESULT 
CDSClientProvider::QueryQueuesInternal(
    IN  const MQRESTRICTION*    pRestriction,
    IN  const MQCOLUMNSET*      pColumns,
    IN  const MQSORTSET*        pSort,
    OUT PHANDLE                 phEnume
    )
/*++

Routine Description:
	LookupBegin for QueryMachineQueue or QueryQueue
	If there are default props, prepare a new props set
	and keep the information to reconstruct original props set
	from the new set using CQueueQueryHandle.
	If no default props, use input props and simple query CQueryHandle

Arguments:
	pRestriction - query restriction
	pColumns - result columns
	pSort - how to sort the results
	phEnume - query handle for retriving the results

Return Value
	HRESULT
--*/
{ 
    //
    //  Check if one of the columns is PROPID_Q_PATHNAME_DNS.
    //  MQIS does not support PROPID_Q_PATHNAME_DNS, return a specific
    //  error
    //
    if  (IsQueuePathNameDnsProperty(pColumns))
    {
        return MQ_ERROR_Q_DNS_PROPERTY_NOT_SUPPORTED;
    }
    //
    //  Check if one of the columns is PROPID_Q_ADS_PATH.
    //  MQIS does not support PROPID_Q_ADS_PATH, return a specific
    //  error
    //
    if  (IsQueueAdsPathProperty(pColumns))
    {
        return MQ_ERROR_Q_ADS_PROPERTY_NOT_SUPPORTED;
    }
	//
	// Check if we have default props
	//
	bool fDefaultProp;
	if(!CheckDefaultColumns(pColumns, &fDefaultProp))
	{
		ASSERT(("Column must be either NT4 or default prop", 0));
		return MQ_ERROR_ILLEGAL_PROPID;
	}

    ASSERT(m_pfDSLookupBegin != NULL);

	if(!fDefaultProp)
	{
		ASSERT(IsNT4Columns(pColumns));

		//
		// All prop are NT4, no default props
		// use simple CQueryHande
		//
		HANDLE hCursor;
		HRESULT hr = m_pfDSLookupBegin(
						NULL,		//pwcsContext
						const_cast<MQRESTRICTION*>(pRestriction),       
						const_cast<MQCOLUMNSET*>(pColumns),
						const_cast<MQSORTSET*>(pSort),       
						&hCursor
						);

		if (SUCCEEDED(hr))
		{
			//
			// use simple Query - CQueryHande
			//
			CQueryHandle* phQuery = new CQueryHandle( 
											hCursor,
											this
											);
			*phEnume = (HANDLE)phQuery;
		}

		return(hr);
	}

	ASSERT(fDefaultProp);

	//
	// Prepare the new Columns (eliminate default props) 
	// and prepare information for reconstructing original input props 
	//
	AP<PropInfo> pPropInfo = new PropInfo[pColumns->cCol];
	AP<PROPID> pPropNew;
	MQCOLUMNSET ColumnsNew;

	EliminateDefaultProps(pColumns->cCol, pColumns->aCol, pPropInfo, &ColumnsNew.cCol, &pPropNew);
	ColumnsNew.aCol = pPropNew;

	ASSERT(IsNT4Columns(&ColumnsNew));

    HANDLE hCursor;
	HRESULT hr = m_pfDSLookupBegin(
					NULL,		//pwcsContext
					const_cast<MQRESTRICTION*>(pRestriction),       
					&ColumnsNew,
					const_cast<MQSORTSET*>(pSort),       
					&hCursor
					);

    if (SUCCEEDED(hr))
    {
		//
		// QueueQueryHande - this will reconstruct input props
		// by adding the default props with default values 
		// in the correct place on every LocateNext
		//
        CQueueQueryHandle* phQuery = new CQueueQueryHandle(
											pColumns,
											hCursor,
											this,
											pPropInfo.detach(),
											ColumnsNew.cCol
											);
        *phEnume = (HANDLE)phQuery;
    }

    return(hr);

}


HRESULT 
CDSClientProvider::QueryMachineQueues(
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN  const GUID *            pguidMachine,
    IN  const MQCOLUMNSET*      pColumns,
    OUT PHANDLE                 phEnume
    )
/*++

Routine Description:
    Query Machine queues

Arguments:
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
    pguidMachine - the unqiue id of the computer
	pColumns - result columns
	phEnume - query handle for retriving the

Return Value
	HRESULT
--*/
{   
    MQPROPERTYRESTRICTION queuesRestrict;
    queuesRestrict.rel = PREQ;
    queuesRestrict.prop = PROPID_Q_QMID; 
    queuesRestrict.prval.vt = VT_CLSID;
    queuesRestrict.prval.puuid = const_cast<GUID*>(pguidMachine);

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &queuesRestrict;

	return QueryQueuesInternal(
				&restriction,       
				pColumns,
				NULL,
				phEnume
				);
}


HRESULT 
CDSClientProvider::QuerySiteServers(
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN const GUID *             pguidSite,
    IN AD_SERVER_TYPE           serverType,
    IN const MQCOLUMNSET*       pColumns,
    OUT PHANDLE                 phEnume
    )
/*++

Routine Description:
    Query Site Servers.
	If pColumns is only NT4 props use simple query handle
	Otherwise, we assume that pColumns has NT4 props and
	NT5 pros that can be converted to NT4.
	we use CSiteServersQueryHandle that will do the reconstructing
	of the original props on every LocateNext

Arguments:
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
    pguidSite - the site id
    eServerType- which type of server
	pColumns - result columns
	phEnume - query handle for retriving the

Return Value
	HRESULT
--*/
{  
    const x_num = 2;
    MQPROPERTYRESTRICTION serversRestrict[x_num];
    serversRestrict[0].rel = (serverType == eRouter) ? PRGE : PRGT;
    serversRestrict[0].prop = PROPID_QM_SERVICE; 
    serversRestrict[0].prval.vt = VT_UI4;
    serversRestrict[0].prval.ulVal = SERVICE_SRV;

    serversRestrict[1].rel = PREQ;
    serversRestrict[1].prop = PROPID_QM_SITE_ID; 
    serversRestrict[1].prval.vt = VT_CLSID;
    serversRestrict[1].prval.puuid = const_cast<GUID*>(pguidSite);

    MQRESTRICTION restriction;
    restriction.cRes = x_num;
    restriction.paPropRes = serversRestrict;

	//
	// Find property type and if convert is needed
	//
	bool fNeedConvert;
	PropsType PropertiesType = CheckPropertiesType(
									eMACHINE, 
									pColumns->cCol, 
									pColumns->aCol, 
									&fNeedConvert
									);

    ASSERT(m_pfDSLookupBegin != NULL);
 	if(!fNeedConvert)
	{
		//
		// No need to convert
		// use simple CQueryHande
		//
	    HANDLE hCursor;
		HRESULT hr = m_pfDSLookupBegin(
						NULL,       //pwcsContext
						&restriction,
						const_cast<MQCOLUMNSET*>(pColumns),
						NULL,       //pSort
						&hCursor
						);

		if (SUCCEEDED(hr))
		{
			//
			// use simple Query - CQueryHande
			//
			CQueryHandle* phQuery = new CQueryHandle( 
											hCursor,
											this
											);
			*phEnume = (HANDLE)phQuery;
		}

		return(hr);
	}

	ASSERT(fNeedConvert);

	//
	// We should not have default props only NT5 props that can be replaced with NT4 
	// This is the way this ADQuerySiteServers is being used currently
	// If this is changed we should update this function
	// and CSiteServersQueryHandle.
	// (PropertiesType != ptNT4Props) && (PropertiesType != ptForceNT5Props)
	//
	ASSERT(PropertiesType == ptMixedProps);
	DBG_USED(PropertiesType);

	//
	// Prepare new Columns and information to
	// reconstruct the original Columns from the new Columns
	// in every LocateNext
	//
	AP<PropInfo> pPropInfo = new PropInfo[pColumns->cCol];
	AP<PROPID> pPropNew;
	MQCOLUMNSET ColumnsNew;

	PrepareReplaceProps(
		eMACHINE, 
		pColumns->cCol, 
		pColumns->aCol, 
		pPropInfo, 
		&ColumnsNew.cCol, 
		&pPropNew
		);

	ColumnsNew.aCol = pPropNew;

	ASSERT(IsNT4Columns(&ColumnsNew));

    HANDLE hCursor;
	HRESULT hr = m_pfDSLookupBegin(
					NULL,       //pwcsContext
					&restriction,
					&ColumnsNew,
					NULL,       //pSort
					&hCursor
					);

    if (SUCCEEDED(hr))
    {
		//
		// CSiteServersQueryHandle - this will reconstruct input props
		// by translating the converted props, and only assign
		// the same props
		//
        CSiteServersQueryHandle* phQuery = new CSiteServersQueryHandle(
													pColumns,
													&ColumnsNew,
													hCursor,
													this,
													pPropInfo.detach()
													);
        *phEnume = (HANDLE)phQuery;
    }

    return(hr);

}


HRESULT 
CDSClientProvider::QueryUserCert(
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN const BLOB *             pblobUserSid,
    IN const MQCOLUMNSET*       pColumns,
    OUT PHANDLE                 phEnume
    )
/*++

Routine Description:
    Query user certificate using simple query handle

Arguments:
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
    pblobUserSid - the user sid
	pColumns - result columns
	phEnume - query handle for retriving the

Return Value
	HRESULT
--*/
{
	ASSERT(IsNT4Columns(pColumns));

    MQPROPERTYRESTRICTION userRestrict;
    userRestrict.rel = PREQ;
    userRestrict.prop = PROPID_U_SID; 
    userRestrict.prval.vt = VT_BLOB;
    userRestrict.prval.blob = *pblobUserSid;

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &userRestrict;

    ASSERT(m_pfDSLookupBegin != NULL);
    HANDLE hCursor;
	HRESULT hr = m_pfDSLookupBegin(
					NULL,       //pwcsContext
					&restriction,
					const_cast<MQCOLUMNSET*>(pColumns),
					NULL,       //pSort
					&hCursor
					);

    if (SUCCEEDED(hr))
    {
		//
		// use simple Query - CQueryHande
		//
        CQueryHandle* phQuery = new CQueryHandle( 
										hCursor,
										this
										);
        *phEnume = (HANDLE)phQuery;
    }

    return(hr);
}


HRESULT 
CDSClientProvider::QueryConnectors(
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN const GUID *             pguidSite,
    IN const MQCOLUMNSET*       pColumns,
    OUT PHANDLE                 phEnume
    )
/*++

Routine Description:
    Query Connectors using simple query handle

Arguments:
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
    pguidSite - the site id
	pColumns - result columns
	phEnume - query handle for retriving the

Return Value
	HRESULT
--*/
{
	ASSERT(IsNT4Columns(pColumns));

    const x_num = 2;
    MQPROPERTYRESTRICTION connectorRestrict[x_num];
    connectorRestrict[0].rel = PRGE;
    connectorRestrict[0].prop = PROPID_QM_SERVICE; 
    connectorRestrict[0].prval.vt = VT_UI1;
    connectorRestrict[0].prval.bVal = SERVICE_SRV;

    connectorRestrict[1].rel = PREQ|PRAny;
    connectorRestrict[1].prop = PROPID_QM_CNS; 
    connectorRestrict[1].prval.vt = VT_ARRAY |VT_CLSID;
    connectorRestrict[1].prval.cauuid.cElems = 1;
    connectorRestrict[1].prval.cauuid.pElems = const_cast<GUID*>(pguidSite);

    MQRESTRICTION restriction;
    restriction.cRes = x_num;
    restriction.paPropRes = connectorRestrict;

    ASSERT(m_pfDSLookupBegin != NULL);
    HANDLE hCursor;
	HRESULT hr = m_pfDSLookupBegin(
					NULL,       //pwcsContext
					&restriction,
					const_cast<MQCOLUMNSET*>(pColumns),
					NULL,       //pSort
					&hCursor
					);

    if (SUCCEEDED(hr))
    {
        CQueryHandle* phQuery = new CQueryHandle( 
										hCursor,
										this
										);
        *phEnume = (HANDLE)phQuery;
    }

    return(hr);
}


HRESULT 
CDSClientProvider::QueryForeignSites(
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN const MQCOLUMNSET*       pColumns,
    OUT PHANDLE                 phEnume
    )
/*++

Routine Description:
    Query Foreign Sites using simple query handle
	This Query is used by MMC and only valid in AD environment.

Arguments:
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
	pColumns - result columns
	phEnume - query handle for retriving the

Return Value
	HRESULT
--*/
{
	ASSERT(IsNT4Columns(pColumns));

	//
	// QueryForeignSites is used by mqsnap
	// mmc will not work in NT4 environment only AD environment
	//
	eDsEnvironment DsEnv = ADGetEnterprise();
	ASSERT(DsEnv == eAD);
	if(DsEnv != eAD)
	{
		//
		// Return error in non AD env
		//
		return MQ_ERROR_DS_ERROR;
	}

	//
	// ISSUE - need convertion
	//
    MQPROPERTYRESTRICTION foreignRestrict;
    foreignRestrict.rel = PREQ;
    foreignRestrict.prop = PROPID_S_FOREIGN; 
    foreignRestrict.prval.vt = VT_UI1;
    foreignRestrict.prval.bVal = 1;

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &foreignRestrict;

    ASSERT(m_pfDSLookupBegin != NULL);
    HANDLE hCursor;
	HRESULT hr = m_pfDSLookupBegin(
					NULL,       //pwcsContext
					&restriction,
					const_cast<MQCOLUMNSET*>(pColumns),
					NULL,       //pSort
					&hCursor
					);

    if (SUCCEEDED(hr))
    {
		//
		// use simple Query - CQueryHande
		//
        CQueryHandle* phQuery = new CQueryHandle( 
										hCursor,
										this
										);
        *phEnume = (HANDLE)phQuery;
    }

    return(hr);
}


HRESULT 
CDSClientProvider::QueryLinks(
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN const GUID *             pguidSite,
    IN eLinkNeighbor            eNeighbor,
    IN const MQCOLUMNSET*       pColumns,
    OUT PHANDLE                 phEnume
    )
/*++

Routine Description:
    Forwards the call to mqdscli dll

Arguments:
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
    pguidSite - the site id
    eNeighbor - which neighbour
	pColumns - result columns
	phEnume - query handle for retriving the

Return Value
	HRESULT
--*/
{ 
	ASSERT(IsNT4Columns(pColumns));

    MQPROPERTYRESTRICTION linkRestrict;
    linkRestrict.rel = PREQ;
    linkRestrict.prop = (eNeighbor == eLinkNeighbor1) ?  PROPID_L_NEIGHBOR1 : PROPID_L_NEIGHBOR2;
    linkRestrict.prval.vt = VT_CLSID;
    linkRestrict.prval.puuid = const_cast<GUID*>(pguidSite);

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &linkRestrict;

    ASSERT(m_pfDSLookupBegin != NULL);
    HANDLE hCursor;
	HRESULT hr = m_pfDSLookupBegin(
					NULL,       //pwcsContext
					&restriction,
					const_cast<MQCOLUMNSET*>(pColumns),
					NULL,       //pSort
					&hCursor
					);
    if (SUCCEEDED(hr))
    {
        CQueryHandle* phQuery = new CQueryHandle( 
										hCursor,
										this
										);
        *phEnume = (HANDLE)phQuery;
    }

    return(hr);
}


HRESULT 
CDSClientProvider::QueryAllLinks(
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN const MQCOLUMNSET*       pColumns,
    OUT PHANDLE                 phEnume
    )
/*++

Routine Description:
    Forwards the call to mqdscli dll

Arguments:
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
	pColumns - result columns
	phEnume - query handle for retriving the results

Return Value
	HRESULT
--*/
{
	AP<PROPID> pPropNew;
	MQCOLUMNSET ColumnsNew;

	//
	// pColumns->cCol is illegal index (end of prop buf) 0 - (cCol - 1) are valid indexes
	//
	DWORD LGatesIndex = pColumns->cCol;		
	DWORD Neg1NewIndex = pColumns->cCol; 
	DWORD Neg2NewIndex = pColumns->cCol;

	if(!PrepareAllLinksProps(
			pColumns, 
			&ColumnsNew.cCol, 
			&pPropNew, 
			&LGatesIndex, 
			&Neg1NewIndex, 
			&Neg2NewIndex
			))
	{
		return MQ_ERROR_ILLEGAL_PROPID;
	}

	//
	// Should only remove PROPID_L_GATES
	//
	ASSERT(ColumnsNew.cCol == (pColumns->cCol - 1));
	ASSERT((LGatesIndex != pColumns->cCol) && 
		   (Neg1NewIndex != pColumns->cCol) && 
		   (Neg2NewIndex != pColumns->cCol));

	ColumnsNew.aCol = pPropNew;

	ASSERT(IsNT4Columns(&ColumnsNew));

    ASSERT(m_pfDSLookupBegin != NULL);

    HANDLE hCursor;
	HRESULT hr = m_pfDSLookupBegin(
					NULL,       //pwcsContext
					NULL,       //pRestriction
					&ColumnsNew,
					NULL,       //pSort
					&hCursor
					);

    if (SUCCEEDED(hr))
    {
        CAllLinksQueryHandle* phQuery = new CAllLinksQueryHandle( 
												hCursor,
												this,
												pColumns->cCol,
												ColumnsNew.cCol,
												LGatesIndex,
												Neg1NewIndex,
												Neg2NewIndex
												);

        *phEnume = (HANDLE)phQuery;
    }

    return(hr);


}


HRESULT 
CDSClientProvider::QueryAllSites(
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN const MQCOLUMNSET*       pColumns,
    OUT PHANDLE                 phEnume
    )
/*++

Routine Description:
    Forwards the call to mqdscli dll

Arguments:
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
	pColumns - result columns
	phEnume - query handle for retriving the results

Return Value
	HRESULT
--*/
{
	ASSERT(IsNT4Columns(pColumns));

    ASSERT(m_pfDSLookupBegin != NULL);
    HANDLE hCursor;
	HRESULT hr = m_pfDSLookupBegin(
					NULL,       //pwcsContext
					NULL,       //pRestriction
					const_cast<MQCOLUMNSET*>(pColumns),
					NULL,       //pSort
					&hCursor
					);

    if (SUCCEEDED(hr))
    {
        CQueryHandle* phQuery = new CQueryHandle( 
										hCursor,
										this
										);
        *phEnume = (HANDLE)phQuery;
    }

    return(hr);

}


HRESULT 
CDSClientProvider::QueryQueues(
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN  const MQRESTRICTION*    pRestriction,
    IN  const MQCOLUMNSET*      pColumns,
    IN  const MQSORTSET*        pSort,
    OUT PHANDLE                 phEnume
    )
/*++

Routine Description:
    Query queues

Arguments:
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
	pRestriction - query restriction
	pColumns - result columns
	pSort - how to sort the results
	phEnume - query handle for retriving the results

Return Value
	HRESULT
--*/
{
	if(!CheckRestriction(pRestriction))
		return MQ_ERROR_ILLEGAL_RESTRICTION_PROPID; 

	if(!CheckSort(pSort))
		return MQ_ERROR_ILLEGAL_SORT_PROPID; 

	return QueryQueuesInternal(
				pRestriction,       
				pColumns,
				pSort,
				phEnume
				);
}


HRESULT 
CDSClientProvider::QueryResults(
    IN      HANDLE          hEnum,
    IN OUT  DWORD*          pcProps,
    OUT     PROPVARIANT     aPropVar[]
    )
/*++

Routine Description:
    Query the results using the query handle that we create after LookupBegin

Arguments:
	hEnum - query handle
	pcProps - number of results to return
	aPropVar - result values

Return Value
	HRESULT
--*/
{
	//
	// phQuery will get the C*QueryHandle that we created after LookupBegin
	//
    CBasicQueryHandle* phQuery = (CBasicQueryHandle *)hEnum;

    return phQuery->LookupNext(
                pcProps,
                aPropVar
                );
}


HRESULT 
CDSClientProvider::EndQuery(
    IN  HANDLE                  hEnum
    )
/*++

Routine Description:
	End query using the query handle that we create after LookupBegin

Arguments:
	hEnum - the query handle

Return Value
	none
--*/
{
	//
	// phQuery will get the C*QueryHandle that we created after LookupBegin
	//
    CBasicQueryHandle* phQuery = (CBasicQueryHandle *)hEnum;

    return phQuery->LookupEnd();
}


HRESULT 
CDSClientProvider::LookupNext(
    IN      HANDLE          hEnum,
    IN OUT  DWORD*          pcProps,
    OUT     PROPVARIANT     aPropVar[]
    )
/*++

Routine Description:
    Forwards the call to mqdscli dll LookupNext
	This will be used by the C*QueryHandle for calling LookupNext

Arguments:
	hEnum - query handle
	pcProps - number of results to return
	aPropVar - result values

Return Value
	HRESULT
--*/
{
    ASSERT(m_pfDSLookupNext != NULL);
    return m_pfDSLookupNext(
                hEnum,
                pcProps,
                aPropVar
                );
}


HRESULT 
CDSClientProvider::LookupEnd(
    IN  HANDLE                  hEnum
    )
/*++

Routine Description:
    Forwards the call to mqdscli dll LookupEnd
	This will be used by the C*QueryHandle for calling LookupNext

Arguments:
	hEnum - the query handle

Return Value
	none
--*/
{
    ASSERT(m_pfDSLookupEnd != NULL);
	return m_pfDSLookupEnd(
                hEnum
                );
}


HRESULT 
CDSClientProvider::GetObjectSecurityInternal(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 pwcsObjectName,
    IN  const GUID*             pguidObject,
    IN  SECURITY_INFORMATION    RequestedInformation,
    IN  const PROPID            prop,
    IN OUT  PROPVARIANT *       pVar
    )
/*++

Routine Description:
    Get the object security descriptor.

Arguments:
	eObject - object type
	pwcsObjectName - MSMQ object name
    pguidObject - unique id of the object
    RequestedInformation - reuqested security info (DACL, SACL..)
	prop - security property
	pVar - property values

Return Value
	HRESULT

--*/
{
	//
	// Check that exactly one of pwcsObjectName, pguidObject was passed to the function
	//
	ASSERT((pwcsObjectName != NULL) ^ (pguidObject != NULL));

	if(IsExProperty(1, &prop))
	{
		//
		// Handling Ex property 
		// PROPID_Q_OBJ_SECURITY, PROPID_QM_OBJ_SECURITY
		// PROPID_QM_ENCRYPT_PKS, PROPID_QM_SIGN_PKS
		// use *Ex api.
		//
		if(pwcsObjectName != NULL)
		{
			ASSERT(m_pfDSGetObjectPropertiesEx != NULL);
			return m_pfDSGetObjectPropertiesEx(
						GetMsmq2Object(eObject),
						pwcsObjectName,
						1,
						const_cast<PROPID*>(&prop),
						pVar
						);
		}
		else
		{
			ASSERT(m_pfDSGetObjectPropertiesGuidEx != NULL);
			return m_pfDSGetObjectPropertiesGuidEx(
						GetMsmq2Object(eObject),
						pguidObject,
						1,
						const_cast<PROPID*>(&prop),
						pVar
						);
		}
	}

	//
	// try m_pfDSGetObjectSecurity, Security Descriptor in NT4 format 
	//

	//
	// Allocate 512 bytes at for first try
	//
    BYTE SD_buff[512];
    PSECURITY_DESCRIPTOR pSecurityDescriptor = reinterpret_cast<PSECURITY_DESCRIPTOR>(SD_buff);
    DWORD nLength = sizeof(SD_buff);
    DWORD nLengthNeeded = 0;
	
	HRESULT hr;
	if(pwcsObjectName != NULL)
	{
		ASSERT(m_pfDSGetObjectSecurity != NULL);
		hr = m_pfDSGetObjectSecurity(
					GetMsmq2Object(eObject),
					pwcsObjectName,
					RequestedInformation,
					pSecurityDescriptor,
					nLength,
					&nLengthNeeded
					);
	}
	else
	{
		ASSERT(m_pfDSGetObjectSecurityGuid != NULL);
		hr = m_pfDSGetObjectSecurityGuid(
						GetMsmq2Object(eObject),
						pguidObject,
						RequestedInformation,
						pSecurityDescriptor,
						nLength,
						&nLengthNeeded
						);

	}

    AP<BYTE> pReleaseSD;
	if(hr == MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL)
	{
		ASSERT(nLengthNeeded > nLength);

		//
		// Allocate larger buffer 
		//
		BYTE* pSD_buff = new BYTE[nLengthNeeded];
        pReleaseSD = pSD_buff;
        pSecurityDescriptor = reinterpret_cast<PSECURITY_DESCRIPTOR>(pSD_buff);
        nLength = nLengthNeeded;

		if(pwcsObjectName != NULL)
		{
			ASSERT(m_pfDSGetObjectSecurity != NULL);
			hr = m_pfDSGetObjectSecurity(
						GetMsmq2Object(eObject),
						pwcsObjectName,
						RequestedInformation,
						pSecurityDescriptor,
						nLength,
						&nLengthNeeded
						);
		}
		else
		{
			ASSERT(m_pfDSGetObjectSecurityGuid != NULL);
			hr = m_pfDSGetObjectSecurityGuid(
							GetMsmq2Object(eObject),
							pguidObject,
							RequestedInformation,
							pSecurityDescriptor,
							nLength,
							&nLengthNeeded
							);
		}
	}

	ASSERT(hr != MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL);

	if(SUCCEEDED(hr))
	{
		pVar->vt = VT_BLOB;
		pVar->blob.pBlobData = reinterpret_cast<PBYTE>(ADAllocateMemory(nLengthNeeded));
        memcpy(pVar->blob.pBlobData, pSecurityDescriptor, nLengthNeeded);
		pVar->blob.cbSize = nLengthNeeded;
	}
    
	return hr;
}


HRESULT 
CDSClientProvider::GetObjectSecurity(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN  LPCWSTR                 pwcsObjectName,
    IN  SECURITY_INFORMATION    RequestedInformation,
    IN  const PROPID            prop,
    IN OUT  PROPVARIANT *       pVar
    )
/*++

Routine Description:
    Get the object security descriptor.

Arguments:
	eObject - object type
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
	pwcsObjectName - MSMQ object name
    RequestedInformation - reuqested security info (DACL, SACL..)
	prop - security property
	pVar - property values

Return Value
	HRESULT

--*/
{
	return GetObjectSecurityInternal(
				eObject,
				pwcsObjectName,
				NULL,
				RequestedInformation,
				prop,
				pVar
				);
}


HRESULT 
CDSClientProvider::GetObjectSecurityGuid(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN  const GUID*             pguidObject,
    IN  SECURITY_INFORMATION    RequestedInformation,
    IN  const PROPID            prop,
    IN OUT  PROPVARIANT *       pVar
    )
/*++

Routine Description:
    Get the object security descriptor.

Arguments:
	eObject - object type
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
    pguidObject - unique id of the object
    RequestedInformation - reuqested security info (DACL, SACL..)
	prop - security property
	pVar - property values

Return Value
	HRESULT

--*/
{
	return GetObjectSecurityInternal(
				eObject,
				NULL,
				pguidObject,
				RequestedInformation,
				prop,
				pVar
				);
}


HRESULT 
CDSClientProvider::SetObjectSecurity(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN  LPCWSTR                 pwcsObjectName,
    IN  SECURITY_INFORMATION    RequestedInformation,
    IN  const PROPID            /* prop */,
    IN  const PROPVARIANT *     pVar
    )
/*++

Routine Description:
    Forward the request to mqdscli dll

Arguments:
	eObject - object type
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
	pwcsObjectName - MSMQ object name
    RequestedInformation - reuqested security info (DACL, SACL..)
	prop - security property
	pVar - property values

Return Value
	HRESULT

--*/
{
	ASSERT(pVar->vt == VT_BLOB);

	ASSERT(m_pfDSSetObjectSecurity != NULL);
    return m_pfDSSetObjectSecurity(
                GetMsmq2Object(eObject),
				pwcsObjectName,
				RequestedInformation,
				reinterpret_cast<PSECURITY_DESCRIPTOR>(pVar->blob.pBlobData)
				);

}


HRESULT 
CDSClientProvider::SetObjectSecurityGuid(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 /* pwcsDomainController */,
    IN  bool					/* fServerName */,
    IN  const GUID*             pguidObject,
    IN  SECURITY_INFORMATION    RequestedInformation,
    IN  const PROPID            /* prop */,
    IN  const PROPVARIANT *     pVar
    )
/*++

Routine Description:
    Forward the request to mqdscli dll

Arguments:
	eObject - object type
	pwcsDomainController - DC against which the operation will be performed
    fServerName - flag that indicate if the pwcsDomainController string is a server name
    pguidObject - unique object id
    RequestedInformation - reuqested security info (DACL, SACL..)
	prop - security property
	pVar - property values

Return Value
	HRESULT

--*/
{
	ASSERT(pVar->vt == VT_BLOB);

	ASSERT(m_pfDSSetObjectSecurityGuid != NULL);
    return m_pfDSSetObjectSecurityGuid(
                GetMsmq2Object(eObject),
				pguidObject,
				RequestedInformation,
				reinterpret_cast<PSECURITY_DESCRIPTOR>(pVar->blob.pBlobData)
				);
}


void CDSClientProvider::Terminate()
/*++

Routine Description:
    unload mqdscli.dll 

Arguments:
    none

Return Value
	none
--*/
{
    //
    //  BUGBUG -The following code is not thread safe.
    //
    m_pfDSCreateObject = NULL;
    m_pfDSGetObjectProperties = NULL;
    m_pfDSSetObjectProperties = NULL;
    m_pfDSLookupBegin = NULL;
    m_pfDSLookupNext = NULL;
    m_pfDSLookupEnd = NULL;
    m_pfDSInit = NULL;
    m_pfDSGetObjectPropertiesGuid = NULL;
    m_pfDSSetObjectPropertiesGuid = NULL;
    m_pfDSQMSetMachineProperties = NULL;
    m_pfDSCreateServersCache = NULL;
    m_pfDSQMGetObjectSecurity = NULL;
    m_pfDSGetComputerSites = NULL;
    m_pfDSGetObjectPropertiesEx = NULL;
    m_pfDSGetObjectPropertiesGuidEx = NULL;
	m_pfDSSetObjectSecurity = NULL;
    m_pfDSGetObjectSecurity = NULL;
    m_pfDSDeleteObject = NULL;
    m_pfDSSetObjectSecurityGuid = NULL;
    m_pfDSGetObjectSecurityGuid = NULL;
    m_pfDSDeleteObjectGuid = NULL;
    m_pfDSBeginDeleteNotification = NULL;
    m_pfDSNotifyDelete = NULL;
    m_pfDSEndDeleteNotification = NULL;

 
    HINSTANCE hLib = m_hLib.detach();
    if (hLib)
    {
        FreeLibrary(hLib); 
    }

}


HRESULT CDSClientProvider::LoadDll()
/*++

Routine Description:
    Loads mqdscli dll and get address of all the interface routines

Arguments:
    none

Return Value
	HRESULT
--*/
{
    m_hLib = LoadLibrary(MQDSCLI_DLL_NAME);
    if (m_hLib == NULL)
    {
       DWORD dw = GetLastError();
/*
       DBGMSG((DBGMOD_ALL, DBGLVL_ERROR,
        _T("CDSClientProvider::Init: LoadLibrary failed. Error: %d"), dw));
*/

	   LogHR(HRESULT_FROM_WIN32(dw), s_FN, 100);
       return MQ_ERROR_CANNOT_LOAD_MQDSXXX;
    }
    m_pfDSCreateObject = (DSCreateObject_ROUTINE)GetProcAddress(m_hLib,"DSCreateObject");
    if (m_pfDSCreateObject == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 110);
    }
    m_pfDSGetObjectProperties = (DSGetObjectProperties_ROUTINE)GetProcAddress(m_hLib,"DSGetObjectProperties");
    if (m_pfDSGetObjectProperties == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 120);
    }
    m_pfDSSetObjectProperties = (DSSetObjectProperties_ROUTINE)GetProcAddress(m_hLib,"DSSetObjectProperties");
    if (m_pfDSSetObjectProperties == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 130);
    }
    m_pfDSLookupBegin = (DSLookupBegin_ROUTINE)GetProcAddress(m_hLib,"DSLookupBegin");
    if (m_pfDSLookupBegin == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 140);
    }
    m_pfDSLookupNext = (DSLookupNext_ROUTINE)GetProcAddress(m_hLib,"DSLookupNext");
    if (m_pfDSLookupNext == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 150);
    }
    m_pfDSLookupEnd = (DSLookupEnd_ROUTINE)GetProcAddress(m_hLib,"DSLookupEnd");
    if (m_pfDSLookupEnd == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 160);
    }
    m_pfDSInit = (DSInit_ROUTINE)GetProcAddress(m_hLib,"DSInit");
    if (m_pfDSInit == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 170);
    }
    m_pfDSGetObjectPropertiesGuid = (DSGetObjectPropertiesGuid_ROUTINE)GetProcAddress(m_hLib,"DSGetObjectPropertiesGuid");
    if (m_pfDSGetObjectPropertiesGuid == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 180);
    }
    m_pfDSSetObjectPropertiesGuid = (DSSetObjectPropertiesGuid_ROUTINE)GetProcAddress(m_hLib,"DSSetObjectPropertiesGuid");
    if (m_pfDSSetObjectPropertiesGuid == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 190);
    }
    m_pfDSQMSetMachineProperties = (DSQMSetMachineProperties_ROUTINE)GetProcAddress(m_hLib,"DSQMSetMachineProperties");
    if (m_pfDSQMSetMachineProperties == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 200);
    }
    m_pfDSCreateServersCache = (DSCreateServersCache_ROUTINE)GetProcAddress(m_hLib,"DSCreateServersCache");
    if (m_pfDSCreateServersCache == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 210);
    }
    m_pfDSQMGetObjectSecurity = (DSQMGetObjectSecurity_ROUTINE)GetProcAddress(m_hLib,"DSQMGetObjectSecurity");
    if (m_pfDSQMGetObjectSecurity == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 220);
    }
    m_pfDSGetComputerSites = (DSGetComputerSites_ROUTINE)GetProcAddress(m_hLib,"DSGetComputerSites");             ;
    if (m_pfDSGetComputerSites == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 230);
    }
    m_pfDSGetObjectPropertiesEx = (DSGetObjectPropertiesEx_ROUTINE)GetProcAddress(m_hLib,"DSGetObjectPropertiesEx");
    if (m_pfDSGetObjectPropertiesEx == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 250);
    }
    m_pfDSGetObjectPropertiesGuidEx = (DSGetObjectPropertiesGuidEx_ROUTINE)GetProcAddress(m_hLib,"DSGetObjectPropertiesGuidEx");
    if (m_pfDSGetObjectPropertiesGuidEx == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 260);
    }
    m_pfDSSetObjectSecurity = (DSSetObjectSecurity_ROUTINE)GetProcAddress(m_hLib,"DSSetObjectSecurity");
    if (m_pfDSSetObjectSecurity == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 270);
    }
    m_pfDSGetObjectSecurity = (DSGetObjectSecurity_ROUTINE)GetProcAddress(m_hLib,"DSGetObjectSecurity");
    if (m_pfDSGetObjectSecurity == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 280);
    }
    m_pfDSDeleteObject = (DSDeleteObject_ROUTINE)GetProcAddress(m_hLib,"DSDeleteObject");
    if (m_pfDSDeleteObject == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 290);
    }
    m_pfDSSetObjectSecurityGuid = (DSSetObjectSecurityGuid_ROUTINE)GetProcAddress(m_hLib,"DSSetObjectSecurityGuid");
    if (m_pfDSSetObjectSecurityGuid == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 300);
    }
    m_pfDSGetObjectSecurityGuid = (DSGetObjectSecurityGuid_ROUTINE)GetProcAddress(m_hLib,"DSGetObjectSecurityGuid");
    if (m_pfDSGetObjectSecurityGuid == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 310);
    }
    m_pfDSDeleteObjectGuid = (DSDeleteObjectGuid_ROUTINE)GetProcAddress(m_hLib,"DSDeleteObjectGuid");
    if (m_pfDSDeleteObjectGuid == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 320);
    }
    m_pfDSBeginDeleteNotification = (DSBeginDeleteNotification_ROUTINE)GetProcAddress(m_hLib,"DSBeginDeleteNotification");
    if (m_pfDSBeginDeleteNotification == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 330);
    }
    m_pfDSNotifyDelete = (DSNotifyDelete_ROUTINE)GetProcAddress(m_hLib,"DSNotifyDelete");
    if (m_pfDSNotifyDelete == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 340);
    }
    m_pfDSEndDeleteNotification = (DSEndDeleteNotification_ROUTINE)GetProcAddress(m_hLib,"DSEndDeleteNotification");
    if (m_pfDSEndDeleteNotification == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 350);
    }

	m_pfDSFreeMemory = (DSFreeMemory_ROUTINE)GetProcAddress(m_hLib,"DSFreeMemory");
    if (m_pfDSFreeMemory == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 360);
    }

    return MQ_OK;
}


HRESULT CDSClientProvider::ADGetADsPathInfo(
                IN  LPCWSTR                 /*pwcsADsPath*/,
                OUT PROPVARIANT *           /*pVar*/,
                OUT eAdsClass *             /*pAdsClass*/
                )
/*++

Routine Description:
    Not supported

Arguments:
	LPCWSTR                 pwcsADsPath - object pathname
	const PROPVARIANT       pVar - property values
    eAdsClass *             pAdsClass - indication about the object class
Return Value
	HRESULT

--*/
{
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 450);
}


void
CDSClientProvider::FreeMemory(
	PVOID pMemory
	)
{
	m_pfDSFreeMemory(pMemory);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\adapi.cpp ===
/*++

Copyright (c) 1995-99  Microsoft Corporation 

Module Name:

    mqadapi.cpp

Abstract:

    Implementation of  MQAD APIs.

    MQAD APIs implements client direct call to Active Directory

Author:

    ronit hartmann ( ronith)

--*/
#include "ds_stdh.h"
#include "ad.h"
#include "dsproto.h"
#include "adglbobj.h"

static WCHAR *s_FN=L"ad/adapi";

static bool s_fInitializeAD = false;

static
HRESULT
DefaultInitialization( void)
/*++

Routine Description:
	This routine performs default initialization ( env detection + call to the
    relevant DS init).

    The purpose is to support AD access without specific call to ADInit ( in the
    case where default values are needed)

Arguments:

Return Value
	HRESULT

--*/
{

    //
    //  Call ADInit with default values
    //

    HRESULT hr =  ADInit(
            NULL,   // pLookDS
            NULL,   // pGetServers
            false,  // fDSServerFunctionality
            false,  // fSetupMode
            false,  // fQMDll
			false,  // fIgnoreWorkGroup
            NULL,   // pNoServerAuth
            NULL,   // szServerName
            false   // fDisableDownlevelNotifications
            );

    return hr;

}

HRESULT
ADCreateObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[],
                OUT GUID*                   pObjGuid
                )
/*++

Routine Description:
    The routine creates an object in AD by forwarding the 
    request to the relevant provider

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
	PSECURITY_DESCRIPTOR    pSecurityDescriptor - object SD
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values
	GUID*                   pObjGuid - the created object unique id

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->CreateObject(
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                pSecurityDescriptor,
                cp,
                aProp,
                apVar,
                pObjGuid
                );
    return hr;
}



HRESULT
ADDeleteObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName
                )
/*++

Routine Description:
    The routine deletes an object from AD by forwarding the 
    request to the relevant provider

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->DeleteObject(
                    eObject,
                    pwcsDomainController,
					fServerName,
                    pwcsObjectName
                    );
    return hr;

}

HRESULT
ADDeleteObjectGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject
                )
/*++

Routine Description:
    The routine deletes an object from AD by forwarding the 
    request to the relevant provider

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	GUID*                   pguidObject - the unique id of the object

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->DeleteObjectGuid(
                    eObject,
                    pwcsDomainController,
					fServerName,
                    pguidObject
                    );
    return hr;

}


HRESULT
ADGetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT PROPVARIANT          apVar[]
                )
/*++

Routine Description:
    The routine retrieves an object from AD by forwarding the 
    request to the relevant provider

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->GetObjectProperties(
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                cp,
                aProp,
                apVar
                );
    return hr;
}

HRESULT
ADGetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  OUT PROPVARIANT         apVar[]
                )
/*++

Routine Description:
    The routine retrieves an object from AD by forwarding the 
    request to the relevant provider

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	GUID *                  pguidObject -  object unique id
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->GetObjectPropertiesGuid(
                eObject,
                pwcsDomainController,
				fServerName,
                pguidObject,
                cp,
                aProp,
                apVar
                );
    return hr;

}


HRESULT
ADQMGetObjectSecurity(
    IN  AD_OBJECT               eObject,
    IN  const GUID*             pguidObject,
    IN  SECURITY_INFORMATION    RequestedInformation,
    IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    IN  DWORD                   nLength,
    IN  LPDWORD                 lpnLengthNeeded,
    IN  DSQMChallengeResponce_ROUTINE
                                pfChallengeResponceProc,
    IN  DWORD_PTR               dwContext
    )
/*++

Routine Description:
    The routine retrieves an object from AD by forwarding the 
    request to the relevant provider

Arguments:
    AD_OBJECT               object - object type
    const GUID*             pguidObject - unique id of the object
    SECURITY_INFORMATION    RequestedInformation - what security info is requested
    PSECURITY_DESCRIPTOR    pSecurityDescriptor - SD response buffer
    DWORD                   nLength - length of SD buffer
    LPDWORD                 lpnLengthNeeded
    DSQMChallengeResponce_ROUTINE
                                pfChallengeResponceProc,
    DWORD_PTR               dwContext

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->QMGetObjectSecurity(
                eObject,
                pguidObject,
                RequestedInformation,
                pSecurityDescriptor,
                nLength,
                lpnLengthNeeded,
                pfChallengeResponceProc,
                dwContext
                );
    return hr;
}



HRESULT
ADSetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                )
/*++

Routine Description:
    The routine sets object properties in AD by forwarding the 
    request to the relevant provider

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->SetObjectProperties(
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                cp,
                aProp,
                apVar
                );
    return hr;

}

HRESULT
ADSetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                )
/*++

Routine Description:
    The routine sets object properties in AD by forwarding the 
    request to the relevant provider

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	GUID *                  pguidObject - the object unique id
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->SetObjectPropertiesGuid(
                eObject,
                pwcsDomainController,
				fServerName,
                pguidObject,
                cp,
                aProp,
                apVar
                );
    return hr;

}




HRESULT
ADQMSetMachineProperties(
    IN  LPCWSTR             pwcsObjectName,
    IN  const DWORD         cp,
    IN  const PROPID        aProp[],
    IN  const PROPVARIANT   apVar[],
    IN  DSQMChallengeResponce_ROUTINE pfSignProc,
    IN  DWORD_PTR           dwContext
    )
/*++

Routine Description:
    The routine sets object properties in AD by forwarding the 
    request to the relevant provider

Arguments:
    LPCWSTR             pwcsObjectName - object msmq-name
    const DWORD         cp - number of properties to set
    const PROPID        aProp - properties
    const PROPVARIANT   apVar  property values
    DSQMChallengeResponce_ROUTINE pfSignProc - sign routine
    DWORD_PTR           dwContext

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->QMSetMachineProperties(
                    pwcsObjectName,
                    cp,
                    aProp,
                    apVar,
                    pfSignProc,
                    dwContext
                    );
    return hr;

}

CCriticalSection s_csInitialization;

HRESULT
ADInit( 
       IN  QMLookForOnlineDS_ROUTINE pLookDS,
       IN  MQGetMQISServer_ROUTINE pGetServers,
       IN  bool  /* fDSServerFunctionality */,
       IN  bool  fSetupMode,
       IN  bool  fQMDll,
       IN  bool  fIgnoreWorkGroup,
       IN  NoServerAuth_ROUTINE pNoServerAuth,
       IN  LPCWSTR szServerName,
       IN  bool  fDisableDownlevelNotifications
        )
/*++

Routine Description:
    The routine detects the environment and then initialize the
    relevant provider

Arguments:
       QMLookForOnlineDS_ROUTINE pLookDS -
       MQGetMQISServer_ROUTINE pGetServers -
       bool  fDSServerFunctionality - should provide DS server functionality
       bool  fSetupMode -  called during setup
       bool  fQMDll - called by QM
       bool  fIgnoreWorkGroup - Ignore WorkGroup registry
       NoServerAuth_ROUTINE pNoServerAuth -
       LPCWSTR szServerName -
       bool fDiesableDownlevelNotifications

Return Value
	HRESULT

--*/
{
    if (s_fInitializeAD)
    {
        return MQ_OK;
    }

    CS lock(s_csInitialization);

    if (s_fInitializeAD)
    {
        return MQ_OK;
    }

    //
    //  Detect in which environment we are running and accordingly load
    //  the AD/DS dll that provide DS/AD access.
    //
    //  This is done only once at start up, there is no detection of environment
    //  change while running
    //
	bool fCheckAlwaysDsCli = true;
	if(fQMDll || fSetupMode)
	{
	    fCheckAlwaysDsCli = false;
	}

    HRESULT hr = g_detectEnv.Detect(fIgnoreWorkGroup, fCheckAlwaysDsCli, pGetServers);
    if (FAILED(hr))
    {
        return hr;
    }


    ASSERT(g_pAD != NULL);

    hr = g_pAD->Init( 
            pLookDS,
            pGetServers,
            fSetupMode,
            fQMDll,
            pNoServerAuth,
            szServerName,
            fDisableDownlevelNotifications
            );
    if (SUCCEEDED(hr))
    {
        s_fInitializeAD = true;
    }
    return hr;
}


HRESULT
ADSetupInit( 
            IN    unsigned char   ucRoll,
            IN    LPWSTR          pwcsPathName,
            IN    const GUID *    pguidMasterId,
            IN    bool  /* fDSServerFunctionality */
            )
/*++

Routine Description:
    The routine detects the environment and then initialize the
    relevant provider

Arguments:
        unsigned char   ucRoll -
        LPWSTR          pwcsPathName -
        const GUID *    pguidMasterId -
        bool  fDSServerFunctionality - should provide DS server functionality

Return Value
	HRESULT

--*/
{
    if (s_fInitializeAD)
    {
        return MQ_OK;
    }

    CS lock(s_csInitialization);

    if (s_fInitializeAD)
    {
        return MQ_OK;
    }
    //
    //  Detect in which environment we are running and accordingly load
    //  the AD/DS dll that provide DS/AD access.
    //
    //  This is done only once at start up, there is no detection of environment
    //  change while running
    //
    HRESULT hr;
    hr = g_detectEnv.Detect(false, false, NULL);
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->SetupInit(
                    ucRoll,
                    pwcsPathName,
                    pguidMasterId
                    );
    if (SUCCEEDED(hr))
    {
        s_fInitializeAD = true;
    }
    return hr;

}

HRESULT
ADCreateServersCache()
/*++

Routine Description:
    The routine creates server cache by forwarding the 
    request to the relevant provider

Arguments:
    none

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->CreateServersCache();

    return hr;
}



HRESULT
ADGetComputerSites(
            IN  LPCWSTR     pwcsComputerName,
            OUT DWORD  *    pdwNumSites,
            OUT GUID **     ppguidSites
            )
/*++

Routine Description:
    The routine retrieves a computer sites by forwarding the 
    request to the relevant provider

Arguments:
    LPCWSTR     pwcsComputerName - computer name
    DWORD  *    pdwNumSites - number of sites retrieved
    GUID **     ppguidSites - the retrieved sites ids

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->GetComputerSites(
                    pwcsComputerName,
                    pdwNumSites,
                    ppguidSites
                    );
    return hr;
}


HRESULT
ADBeginDeleteNotification(
				IN AD_OBJECT                eObject,
				IN LPCWSTR                  pwcsDomainController,
				IN  bool					fServerName,
				IN LPCWSTR					 pwcsObjectName,
				IN OUT HANDLE   *           phEnum
	            )
/*++

Routine Description:
    The routine begins delete notification by forwarding the 
    request to the relevant provider

Arguments:
    AD_OBJECT         eObject - object type
    LPCWSTR           pwcsDomainController - DC against which the operation should be performed
    bool			  fServerName - flag that indicate if the pwcsDomainController string is a server name
    LPCWSTR			  pwcsObjectName - msmq-name of the object
    HANDLE   *        phEnum - notification handle

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->BeginDeleteNotification(
					eObject,
					pwcsDomainController,
					fServerName,
					pwcsObjectName,
					phEnum
					);
    return hr;

}

HRESULT
ADNotifyDelete(
        IN  HANDLE                  hEnum
	    )
/*++

Routine Description:
    The routine performs notify delete  by forwarding the 
    request to the relevant provider

Arguments:
    HANDLE            hEnum - notification handle

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->NotifyDelete(
                    hEnum
	                );
    return hr;

}

HRESULT
ADEndDeleteNotification(
        IN  HANDLE                  hEnum
        )
/*++

Routine Description:
    The routine completes notify delete  by forwarding the 
    request to the relevant provider

Arguments:
    HANDLE            hEnum - notification handle

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->EndDeleteNotification(
                        hEnum
                        );
    return hr;

}



HRESULT
ADQueryMachineQueues(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID *            pguidMachine,
                IN  const MQCOLUMNSET*      pColumns,
                OUT PHANDLE                 phEnume
                )
/*++

Routine Description:
    Begin query of all queues that belongs to a specific computer

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID *            pguidMachine - the unqiue id of the computer
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->QueryMachineQueues(
                pwcsDomainController,
				fServerName,
                pguidMachine,
                pColumns,
                phEnume
                );
    return hr;

}


HRESULT
ADQuerySiteServers(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN AD_SERVER_TYPE           serverType,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                )
/*++

Routine Description:
    Begins query of all servers of a specific type in a specific site

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID *            pguidSite - the site id
    AD_SERVER_TYPE          eServerType- which type of server
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->QuerySiteServers(
                pwcsDomainController,
				fServerName,
                pguidSite,
                serverType,
                pColumns,
                phEnume
                );
    return hr;

}


HRESULT
ADQueryUserCert(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const BLOB *             pblobUserSid,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                )
/*++

Routine Description:
    Begins query of all certificates that belong to a specific user

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const BLOB *            pblobUserSid - the user sid
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->QueryUserCert(
                pwcsDomainController,
				fServerName,
                pblobUserSid,
                pColumns,
                phEnume
                );
    return hr;

}

HRESULT
ADQueryConnectors(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                )
/*++

Routine Description:
    Begins query of all connectors of a specific site

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID *            pguidSite - the site id
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->QueryConnectors(
                    pwcsDomainController,
					fServerName,
                    pguidSite,
                    pColumns,
                    phEnume
                    );
    return hr;

}

HRESULT
ADQueryForeignSites(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                )
/*++

Routine Description:
    Begins query of all foreign sites

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->QueryForeignSites(
                    pwcsDomainController,
					fServerName,
                    pColumns,
                    phEnume
                    );
    return hr;

}

HRESULT
ADQueryLinks(
            IN  LPCWSTR                 pwcsDomainController,
            IN  bool					fServerName,
            IN const GUID *             pguidSite,
            IN eLinkNeighbor            eNeighbor,
            IN const MQCOLUMNSET*       pColumns,
            OUT PHANDLE                 phEnume
            )
/*++

Routine Description:
    Begins query of all routing links to a specific site

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID *            pguidSite - the site id
    eLinkNeighbor           eNeighbor - which neighbour
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the
							results

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->QueryLinks(
                pwcsDomainController,
				fServerName,
                pguidSite,
                eNeighbor,
                pColumns,
                phEnume
                );
    return hr;

}

HRESULT
ADQueryAllLinks(
            IN  LPCWSTR                 pwcsDomainController,
            IN  bool					fServerName,
            IN const MQCOLUMNSET*       pColumns,
            OUT PHANDLE                 phEnume
            )
/*++

Routine Description:
    Begins query of all routing links

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the
							results

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->QueryAllLinks(
                    pwcsDomainController,
					fServerName,
                    pColumns,
                    phEnume
                    );
    return hr;

}

HRESULT
ADQueryAllSites(
            IN  LPCWSTR                 pwcsDomainController,
            IN  bool					fServerName,
            IN const MQCOLUMNSET*       pColumns,
            OUT PHANDLE                 phEnume
            )
/*++

Routine Description:
    Begins query of all sites

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the
							results

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->QueryAllSites(
                pwcsDomainController,
				fServerName,
                pColumns,
                phEnume
                );
    return hr;

}


HRESULT
ADQueryQueues(
                IN  LPCWSTR                 pwcsDomainController,
				IN  bool					fServerName,
                IN  const MQRESTRICTION*    pRestriction,
                IN  const MQCOLUMNSET*      pColumns,
                IN  const MQSORTSET*        pSort,
                OUT PHANDLE                 phEnume
                )
/*++

Routine Description:
	Begin query of queues according to specified restriction
	and sort order

Arguments:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	const MQRESTRICTION*    pRestriction - query restriction
	const MQCOLUMNSET*      pColumns - result columns
	const MQSORTSET*        pSort - how to sort the results
	PHANDLE                 phEnume - query handle for retriving the
							results

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->QueryQueues(
                    pwcsDomainController,
					fServerName,
                    pRestriction,
                    pColumns,
                    pSort,
                    phEnume
                    );

    return hr;
}

HRESULT
ADQueryResults(
                IN      HANDLE          hEnum,
                IN OUT  DWORD*          pcProps,
                OUT     PROPVARIANT     aPropVar[]
                )
/*++

Routine Description:
	retrieves another set of query results

Arguments:
	HANDLE          hEnum - query handle
	DWORD*          pcProps - number of results to return
	PROPVARIANT     aPropVar - result values

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->QueryResults(
                    hEnum,
                    pcProps,
                    aPropVar
                    );
    return hr;

}

HRESULT
ADEndQuery(
            IN  HANDLE                  hEnum
            )
/*++

Routine Description:
	Cleanup after a query

Arguments:
	HANDLE    hEnum - the query handle

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->EndQuery(
                hEnum
                );
    return hr;

}

eDsEnvironment
ADGetEnterprise( void)
/*++

Routine Description:
	returns the detected enviornment

Arguments:
    none

Return Value
	eDsEnterprise

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return eUnknown;
    }
    return g_detectEnv.GetEnvironment();
}


eDsProvider
ADProviderType( void)
/*++

Routine Description:
	returns the provider that is being used mqad.dll, mqdscli.dll.

Arguments:
    none

Return Value
	eDsProvider

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return eUnknownProvider;
    }
    return g_detectEnv.GetProviderType();
}


DWORD
ADRawDetection(void)
/*++

Routine Description:
	perform raw detection of DS environment

Arguments:
    none

Return Value
	MSMQ_DS_ENVIRONMENT_PURE_AD for AD environment, otherwise MSMQ_DS_ENVIRONMENT_MQIS

--*/
{
	CDetectEnvironment DetectEnv;
	return DetectEnv.RawDetection();
}


HRESULT
ADGetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
				IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                )
/*++

Routine Description:
    The routine retrieves an objectsecurity from AD by forwarding the 
    request to the relevant provider

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	PROPVARIANT             pVar - property values

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->GetObjectSecurity(
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                RequestedInformation,
                prop,
                pVar
                );
    return hr;
}

HRESULT
ADGetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
				IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                )
/*++

Routine Description:
    The routine retrieves an objectsecurity from AD by forwarding the 
    request to the relevant provider

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID*             pguidObject - unique id of the object
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	PROPVARIANT             pVar - property values

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->GetObjectSecurityGuid(
                eObject,
                pwcsDomainController,
				fServerName,
                pguidObject,
                RequestedInformation,
                prop,
                pVar
                );
    return hr;
}

HRESULT
ADSetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
				IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                )
/*++

Routine Description:
    The routine sets object security in AD by forwarding the 
    request to the relevant provider

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->SetObjectSecurity(
                eObject,
                pwcsDomainController,
				fServerName,
                pwcsObjectName,
                RequestedInformation,
                prop,
                pVar
                );
    return hr;
}


HRESULT
ADSetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
				IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                )
/*++

Routine Description:
    The routine sets object security in AD by forwarding the 
    request to the relevant provider

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID*             pguidObject - unique object id
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->SetObjectSecurityGuid(
                eObject,
                pwcsDomainController,
				fServerName,
                pguidObject,
                RequestedInformation,
                prop,
                pVar
                );
    return hr;
}

void
ADTerminate()
/*++

Routine Description:
    The routine unloads the AD access dll

Arguments:
    none

Return Value
	none

--*/
{
    if (g_pAD == NULL)
    {
        return;
    }
    g_pAD->Terminate();
	s_fInitializeAD = false;
}


HRESULT
ADGetADsPathInfo(
                IN  LPCWSTR                 pwcsADsPath,
                OUT PROPVARIANT *           pVar,
                OUT eAdsClass *             pAdsClass
                )
/*++

Routine Description:

Arguments:

Return Value
	HRESULT

--*/
{
    HRESULT hr;
    hr = DefaultInitialization();
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(g_pAD != NULL);
    hr = g_pAD->ADGetADsPathInfo(
                pwcsADsPath,
                pVar,
                pAdsClass
                );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\baseprov.h ===
/*++

Copyright (c) 1995  Microsoft Corporation 

Module Name:
	baseprov.h

Abstract:
	Base Active Directory provider class.

Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __BASEPROV_H__
#define __BASEPROV_H__
#include "mqaddef.h"
#include "dsproto.h"


//-----------------------------------------------------------------------------------
//
//      CBaseADProvider
//
//  Virtual class, encapsulates ActiveDirectory operations 
//
//-----------------------------------------------------------------------------------
class CBaseADProvider 
{
public:
    CBaseADProvider() {};

    virtual ~CBaseADProvider() {};

    virtual HRESULT CreateObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[],
                OUT GUID*                   pObjGuid
                ) = 0;

    virtual HRESULT DeleteObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName
                ) = 0;

    virtual HRESULT DeleteObjectGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject
                ) = 0;

    virtual HRESULT GetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT PROPVARIANT          apVar[]
                ) = 0;

    virtual HRESULT GetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  OUT PROPVARIANT         apVar[]
                ) = 0;

    virtual HRESULT QMGetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded,
                IN  DSQMChallengeResponce_ROUTINE
                                            pfChallengeResponceProc,
                IN  DWORD_PTR               dwContext
                ) = 0;

    virtual HRESULT GetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                ) = 0;

    virtual HRESULT GetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                ) = 0;

    virtual HRESULT SetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                ) = 0;

    virtual HRESULT SetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                ) = 0;

    virtual HRESULT QMSetMachineProperties(
                IN  LPCWSTR             pwcsObjectName,
                IN  const DWORD         cp,
                IN  const PROPID        aProp[],
                IN  const PROPVARIANT   apVar[],
                IN  DSQMChallengeResponce_ROUTINE pfSignProc,
                IN  DWORD_PTR           dwContext
                ) = 0;

    virtual HRESULT SetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                ) = 0;


    virtual HRESULT SetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                ) = 0;

    virtual HRESULT Init( 
                IN QMLookForOnlineDS_ROUTINE    pLookDS,
                IN MQGetMQISServer_ROUTINE      pGetServers,
                IN bool                         fSetupMode,        
                IN bool                         fQMDll,
                IN NoServerAuth_ROUTINE         pNoServerAuth,
                IN LPCWSTR                      szServerName,
                IN bool                         fDisableDownlevelNotifications
                ) = 0;

    virtual HRESULT SetupInit(
                IN    unsigned char   ucRoll,
                IN    LPWSTR          pwcsPathName,
                IN    const GUID *    pguidMasterId
                ) = 0;

    virtual HRESULT CreateServersCache() = 0;

    virtual HRESULT GetComputerSites(
                IN  LPCWSTR     pwcsComputerName,
                OUT DWORD  *    pdwNumSites,
                OUT GUID **     ppguidSites
                ) = 0;

    virtual HRESULT BeginDeleteNotification(
                IN  AD_OBJECT               eObject,
                IN LPCWSTR                  pwcsDomainController,
                IN  bool					fServerName,
                IN LPCWSTR					pwcsObjectName,
                IN OUT HANDLE   *           phEnum
                ) = 0;

    virtual HRESULT NotifyDelete(
                IN  HANDLE                  hEnum
                ) = 0;

    virtual HRESULT EndDeleteNotification(
                IN  HANDLE                  hEnum
                ) = 0;

    virtual HRESULT QueryMachineQueues(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID *            pguidMachine,
                IN  const MQCOLUMNSET*      pColumns,
                OUT PHANDLE                 phEnume
                ) = 0;

    virtual HRESULT QuerySiteServers(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN AD_SERVER_TYPE           serverType,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                ) = 0;

	virtual HRESULT QueryNT4MQISServers(
                IN  LPCWSTR                 /* pwcsDomainController */,
                IN  bool					/* fServerName */,
	            IN  DWORD                   /* dwServerType */,
	            IN  DWORD                   /* dwNT4 */,
                IN const MQCOLUMNSET*       /* pColumns */,
                OUT PHANDLE                 /* phEnume */
                )
	{
		ASSERT(("QueryNT4MQISServers expect to be used by adprov only", 0));
		return MQ_ERROR_UNSUPPORTED_OPERATION;
	}

    virtual HRESULT QueryUserCert(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const BLOB *             pblobUserSid,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                ) = 0;

    virtual HRESULT QueryConnectors(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                ) = 0;

    virtual HRESULT QueryForeignSites(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                ) = 0;

    virtual HRESULT QueryLinks(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN eLinkNeighbor            eNeighbor,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                ) = 0;

    virtual HRESULT QueryAllLinks(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                ) = 0;

    virtual HRESULT QueryAllSites(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                ) = 0;

    virtual HRESULT QueryQueues(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const MQRESTRICTION*    pRestriction,
                IN  const MQCOLUMNSET*      pColumns,
                IN  const MQSORTSET*        pSort,
                OUT PHANDLE                 phEnume
                ) = 0;

    virtual HRESULT QueryResults(
                IN      HANDLE          hEnum,
                IN OUT  DWORD*          pcProps,
                OUT     PROPVARIANT     aPropVar[]
                ) = 0;

    virtual HRESULT EndQuery(
                IN  HANDLE                  hEnum
                ) = 0;

    virtual void Terminate() = 0;

    virtual HRESULT ADGetADsPathInfo(
                IN  LPCWSTR                 pwcsADsPath,
                OUT PROPVARIANT *           pVar,
                OUT eAdsClass *             pAdsClass
                ) = 0;

	virtual void FreeMemory(
				IN PVOID					pMemory
				) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\ds_stdh.h ===
#include "..\h\ds_stdh.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\detect.h ===
/*++

Copyright (c) 1995  Microsoft Corporation 

Module Name:
	detect.h

Abstract:
	Detect Environment class.

Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __DETECT_H__
#define __DETECT_H__
#include "mqaddef.h"
#include "baseprov.h"
extern P<CBaseADProvider> g_pAD;

//
// map of NT4 Site entries by site id
//
typedef CMap<GUID, const GUID&, DWORD, DWORD> NT4Sites_CMAP;

//-----------------------------------------------------------------------------------
//
//      CDetectEnvironment
//
//
//-----------------------------------------------------------------------------------
class CDetectEnvironment 
{
public:
    CDetectEnvironment();

    ~CDetectEnvironment();

	DWORD RawDetection();

    HRESULT 
	Detect(
		bool fIgnoreWorkGroup,
		bool fCheckAlwaysDsCli,
        MQGetMQISServer_ROUTINE pGetServers
		);

    eDsEnvironment GetEnvironment() const;

	eDsProvider GetProviderType() const;

private:

	eDsEnvironment FindDsEnvironment();

	bool IsADEnvironment();

	void CheckWorkgroup();

	DWORD GetMsmqDWORDKeyValue(LPCWSTR RegName);

    DWORD GetMsmqWorkgroupKeyValue();

	DWORD GetMsmqDsEnvironmentKeyValue();

	DWORD GetMsmqEnableLocalUserKeyValue();

	LONG SetDsEnvironmentRegistry(DWORD value);

	bool ServerRespond(LPCWSTR pwszServerName);

	void GetQmGuid(GUID* pGuid);

	bool MachineOwnedByNT4Site();

	bool MasterIdIsNT4();

	HRESULT GetQMMasterId(GUID** ppQmMasterId);

	bool IsNT4Site(const GUID* pSiteGuid);

	void FindSiteInAd(const GUID* pSiteGuid);

	bool SiteWasFoundInNT4SiteMap(const GUID* pSiteGuid);

	void CreateNT4SitesMap(NT4Sites_CMAP ** ppmapNT4Sites);

	bool IsDepClient();

private:
	bool m_fInitialized;
	eDsEnvironment m_DsEnvironment;
	eDsProvider m_DsProvider;
	MQGetMQISServer_ROUTINE m_pfnGetServers;
};


//-------------------------------------------------------
//
// auto release for ADQuery handles
//
//-------------------------------------------------------
class CAutoADQueryHandle
{
public:
    CAutoADQueryHandle()
    {
        m_hLookup = NULL;
    }

    CAutoADQueryHandle(HANDLE hLookup)
    {
        m_hLookup = hLookup;
    }

    ~CAutoADQueryHandle()
    {
        if (m_hLookup)
        {
            g_pAD->EndQuery(m_hLookup);
        }
    }

    HANDLE detach()
    {
        HANDLE hTmp = m_hLookup;
        m_hLookup = NULL;
        return hTmp;
    }

    operator HANDLE() const
    {
        return m_hLookup;
    }

    HANDLE* operator &()
    {
        return &m_hLookup;
    }

    CAutoADQueryHandle& operator=(HANDLE hLookup)
    {
        if (m_hLookup)
        {
            g_pAD->EndQuery(m_hLookup);
        }
        m_hLookup = hLookup;
        return *this;
    }

private:
    HANDLE m_hLookup;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\detect.cpp ===
/*++


Copyright (c) 1998  Microsoft Corporation 

Module Name:

    detect.cpp

Abstract:

	Detect Environment class.

Author:

    Ronit Hartmann	(ronith)
    Ilan Herbst		(ilanh)		08-Sep-2000

--*/
#include "ds_stdh.h"
#include "detect.h"
#include "adglbobj.h"
#include "cliprov.h"
#include "adprov.h"
#include "wrkgprov.h"
#include "_mqini.h"
#include "_registr.h"
#include "_mqreg.h"
#include "autorel.h"
#include "autoreln.h"
#include "dsutils.h"
#include "Dsgetdc.h"
#include <lm.h>
#include <lmapibuf.h>
#include "uniansi.h"
#include "Winldap.h"
#define SECURITY_WIN32
#include <security.h>
#include "adserr.h"
#include <mqexception.h>
#include <tr.h>
#include "adalloc.h"

const TraceIdEntry AdDetect = L"AD DETECT";

#include "detect.tmh"


CDetectEnvironment::CDetectEnvironment():
            m_fInitialized(false),
			m_DsEnvironment(eUnknown),
			m_DsProvider(eUnknownProvider),
			m_pfnGetServers(NULL)
{
}

CDetectEnvironment::~CDetectEnvironment()
{
}


DWORD CDetectEnvironment::RawDetection()
{
	bool fAd = IsADEnvironment();
	return fAd ? MSMQ_DS_ENVIRONMENT_PURE_AD : MSMQ_DS_ENVIRONMENT_MQIS;
}


HRESULT 
CDetectEnvironment::Detect(
	bool  fIgnoreWorkGroup,
	bool  fCheckAlwaysDsCli,
    MQGetMQISServer_ROUTINE pGetServers
	)
/*++

Routine Description:
	Detects in which environment we are, and activate the correct DS provider

Arguments:
    fIgnoreWorkGroup - flag that indicate if we will Ignore WorkGroup registry
	fCheckAlwaysDsCli - flag that indicate we should check registry in order to force DsCli provider
	pGetServers - GetServers routine for dependent client

Return Value:
	HRESULT
--*/
{
    //
    //  Leaving the asserts, to catch initialization problems
    //
    ASSERT(g_pAD == NULL);
    ASSERT(!m_fInitialized);

    if (m_fInitialized)
    {
        return MQ_OK;
    }

    //
    // Read from registery if the machine is WorkGroup Installed machine
    //
	DWORD dwWorkGroup = 0;
	if(!fIgnoreWorkGroup)
	{
		dwWorkGroup = GetMsmqWorkgroupKeyValue();
	}

    if (dwWorkGroup > 0)
    {
        //
        //  Chose a provider that doesn't try to access AD,
        //  and for all AD APIs returns error
        //
        g_pAD = new CWorkGroupProvider();
		m_DsProvider = eWorkgroup;
		m_fInitialized = true;
		return MQ_OK;
    }

	m_pfnGetServers = pGetServers;
	m_DsEnvironment = FindDsEnvironment();

	switch(m_DsEnvironment)
	{
		case eAD:

			//
			// First Check if we want to force DsClient provider
			//
			if(fCheckAlwaysDsCli)
			{
				//
				// This is the workaround to enable local user.
				// If We have the registry is set
				// We force to load DsClient provider
				// And we should work with weaken security
				//
				DWORD AlwaysUseDSCli = GetMsmqEnableLocalUserKeyValue();
				if(AlwaysUseDSCli)
				{
					g_pAD = new CDSClientProvider;
					m_DsProvider = eMqdscli;
                    m_fInitialized = true;
					break;
				}
			}

			//
			// We have w2k DC server in our site, load mqad.dll
			//
			g_pAD = new CActiveDirectoryProvider();
			m_DsProvider = eMqad;
            m_fInitialized = true;
			break;
	
		case eMqis:

			//
			// mqis load mqdscli
			//
			g_pAD = new CDSClientProvider();
			m_DsProvider = eMqdscli;
            m_fInitialized = true;
			break;

		case eUnknown:

			ASSERT(("At this point we dont suppose to get Unknown environment", 0));
			break;

		default:
			ASSERT(("should not get here", 0));
			break;
	}

    return MQ_OK;
}


eDsEnvironment CDetectEnvironment::FindDsEnvironment()
/*++

Routine Description:
	Find DsEnvironment. we will determinate the Environment according to the registry.
	If the registry value is not PURE_AD then we will check what is our environment.
	If we will find out that we will have access to w2k AD server in our site, we will update
	our environment.
	otherwise we will stay in mqis environment.

Arguments:
	None

Return Value:
	detected DsEnvironment 
--*/
{
	//
	// Get DsEnvironment registry value
	//
	DWORD DsEnvironmentRegVal = GetMsmqDsEnvironmentKeyValue();

	TrTRACE(AdDetect, "DsEnvironmentRegVal = %d", DsEnvironmentRegVal);

#ifdef _DEBUG
	CheckWorkgroup();
#endif

	if(DsEnvironmentRegVal == MSMQ_DS_ENVIRONMENT_PURE_AD)
	{
		//
		// In pure w2k no need to check
		//
		TrTRACE(AdDetect, "MSMQ_DS_ENVIRONMENT_PURE_AD");
		return eAD;
	}

	//
	// We must have previous reg value when calling this function 
	//
	if(DsEnvironmentRegVal == MSMQ_DS_ENVIRONMENT_UNKNOWN)
	{
		//
		// Setup should always initialize this registry
		//
		ASSERT(("Setup did not initialize DsEnvironment registry", DsEnvironmentRegVal != MSMQ_DS_ENVIRONMENT_UNKNOWN));
		return eAD;
	}

	//
	// Must have this value in registry when trying to update environment
	//
	ASSERT(DsEnvironmentRegVal == MSMQ_DS_ENVIRONMENT_MQIS);

	if(!IsADEnvironment())
	{
		TrTRACE(AdDetect, "Remain in Mqis environment");
		return eMqis;
	}

	//
	// We have w2k dc server
	// Check if the machine belong to NT4 site
	// if it belong to NT4 site we should remain in MQIS environment
	//
	if(MachineOwnedByNT4Site())
	{
		return eMqis;
	}

	//
	// Our machine is not owned by NT4 site
	//

	TrTRACE(AdDetect, "Found w2k DC server in our computer site, and our site is not nt4, upgrade to PURE_AD environment");

	SetDsEnvironmentRegistry(MSMQ_DS_ENVIRONMENT_PURE_AD);
	return eAD;
}


void CDetectEnvironment::CheckWorkgroup()
/*++

Routine Description:
	Find if we can access Active Directory

Arguments:
	None

Return Value:
	true if we can access AD, false if not
--*/
{
	DWORD dwWorkGroup = GetMsmqWorkgroupKeyValue();
	if(dwWorkGroup != 0)
	{
		DWORD DsEnvironmentRegVal = GetMsmqDsEnvironmentKeyValue();
		DBG_USED(DsEnvironmentRegVal);

		//
		// This is join domain scenario, only in that case workgroup
		// registry is on.
		// Join domain is supported only in AD environment
		//
		ASSERT(DsEnvironmentRegVal == MSMQ_DS_ENVIRONMENT_PURE_AD);
		ASSERT(IsADEnvironment());
	}
}


bool CDetectEnvironment::IsADEnvironment()
/*++

Routine Description:
	Find if we can access Active Directory

Arguments:
	None

Return Value:
	true if we can access AD, false if not
--*/
{
	//
	// Try to find w2k AD server
	// for online we should check with DS_FORCE_REDISCOVERY if the server is not responding
	//
    PNETBUF<DOMAIN_CONTROLLER_INFO> pDcInfo;
	DWORD dw = DsGetDcName(
					NULL, 
					NULL, 
					NULL, 
					NULL, 
					DS_DIRECTORY_SERVICE_REQUIRED, 
					&pDcInfo
					);

	if(dw != NO_ERROR) 
	{
		//
		// We failed to find w2k dc server, stay in mqis environment
		//
		TrTRACE(AdDetect, "Did not find AD server, DsGetDcName() failed, err = %d", dw);
		return false;
	}

#ifdef _DEBUG
	//
	// We have w2k AD server, check he is responding
	//
	LPWSTR pwcsServerName = pDcInfo->DomainControllerName + 2;
	ServerRespond(pwcsServerName);
#endif

	TrTRACE(AdDetect, "DsGetDcName() Found w2k AD");
	TrTRACE(AdDetect, "DCName = %ls", pDcInfo->DomainControllerName);
	TrTRACE(AdDetect, "ClientSiteName = %ls", pDcInfo->ClientSiteName);
	TrTRACE(AdDetect, "DcSiteName = %ls", pDcInfo->DcSiteName);

	return true;
}


eDsEnvironment CDetectEnvironment::GetEnvironment() const
{
	return m_DsEnvironment;
}

eDsProvider CDetectEnvironment::GetProviderType() const
{
	return m_DsProvider;
}

DWORD CDetectEnvironment::GetMsmqDWORDKeyValue(LPCWSTR RegName)
/*++

Routine Description:
    Read flacon DWORD registry key.
    BUGBUG - this routine is temporary. AD.lib cannot use mqutil.dll (due
    to dll availability during setup)

Arguments:
	RegName - Registry name (under HKLM\msmq\parameters)

Return Value:
	DWORD key value (0 if the key not exist)
--*/
{
    CAutoCloseRegHandle hKey;
    LONG rc = RegOpenKeyEx(
				 FALCON_REG_POS,
				 FALCON_REG_KEY,
				 0,
				 KEY_READ,
				 &hKey
				 );

    if ( rc != ERROR_SUCCESS)
    {
        ASSERT(("At this point MSMQ Registry must exist", 0));
        return 0;
    }

    DWORD value = 0;
    DWORD type = REG_DWORD;
    DWORD size = sizeof(DWORD);
    rc = RegQueryValueEx( 
             hKey,
             RegName,
             0L,
             &type,
             reinterpret_cast<BYTE*>(&value),
             &size 
             );
    
    if ((rc != ERROR_SUCCESS) && (rc != ERROR_FILE_NOT_FOUND))
    {
        ASSERT(("We should get either ERROR_SUCCESS or ERROR_FILE_NOT_FOUND", 0));
        return 0;
    }

    return value;
}


DWORD CDetectEnvironment::GetMsmqWorkgroupKeyValue()
/*++

Routine Description:
    Read flacon registry workgroup key.

Arguments:
	None

Return Value:
	DWORD key value (0 if the key not exist)
--*/
{
    DWORD value = GetMsmqDWORDKeyValue(MSMQ_WORKGROUP_REGNAME);

	TrTRACE(AdDetect, "registry value: %ls = %d", MSMQ_WORKGROUP_REGNAME, value);

    return value;
}


DWORD CDetectEnvironment::GetMsmqDsEnvironmentKeyValue()
/*++

Routine Description:
    Read flacon registry DsEnvironment key.

Arguments:
	None

Return Value:
	DWORD key value (0 if the key not exist)
--*/
{
    DWORD value = GetMsmqDWORDKeyValue(MSMQ_DS_ENVIRONMENT_REGNAME);

	TrTRACE(AdDetect, "registry value: %ls = %d", MSMQ_DS_ENVIRONMENT_REGNAME, value);

    return value;
}


DWORD CDetectEnvironment::GetMsmqEnableLocalUserKeyValue()
/*++

Routine Description:
    Read flacon registry EnableLocalUser key.

Arguments:
	None

Return Value:
	DWORD key value (0 if the key not exist)
--*/
{
    DWORD value = GetMsmqDWORDKeyValue(MSMQ_ENABLE_LOCAL_USER_REGNAME);
    
	TrTRACE(AdDetect, "registry value: %ls = %d", MSMQ_ENABLE_LOCAL_USER_REGNAME, value);

    return value;
}


LONG CDetectEnvironment::SetDsEnvironmentRegistry(DWORD value)
/*++

Routine Description:
    Set flacon registry DsEnvironment key.
    BUGBUG - this routine is temporary. AD.lib cannot use mqutil.dll (due
    to dll availability during setup)

Arguments:
	value - new registry value.

Return Value:
	ERROR_SUCCESS if ok, else error code
--*/
{
    CAutoCloseRegHandle hKey;
    LONG rc = RegOpenKeyEx(
				 FALCON_REG_POS,
				 FALCON_REG_KEY,
				 0,
				 KEY_WRITE,
				 &hKey
				 );

    if (rc != ERROR_SUCCESS)
    {
		TrERROR(AdDetect, "RegOpenKeyEx failed to open MSMQ Registry, error = 0x%x", rc);
        ASSERT(("At this point MSMQ Registry must exist", 0));
        return rc;
    }

    rc =  RegSetValueEx( 
				hKey,
				MSMQ_DS_ENVIRONMENT_REGNAME,
				0,
				REG_DWORD,
				reinterpret_cast<const BYTE*>(&value),
				sizeof(DWORD)
				);

    ASSERT(("Failed to Set MSMQ_DS_ENVIRONMENT_REGNAME", rc == ERROR_SUCCESS));

	TrTRACE(AdDetect, "Set registry value: %ls = %d", MSMQ_DS_ENVIRONMENT_REGNAME, value);

    return rc;
}


bool CDetectEnvironment::IsDepClient()
/*++

Routine Description:
    Check if this is dependent client

Arguments:
	None

Return Value:
	true for dependent client, false otherwise.
--*/
{
    CAutoCloseRegHandle hKey;
    LONG rc = RegOpenKeyEx(
				 FALCON_REG_POS,
				 FALCON_REG_KEY,
				 0,
				 KEY_READ,
				 &hKey
				 );

    if (rc != ERROR_SUCCESS)
    {
		TrERROR(AdDetect, "RegOpenKeyEx failed to open MSMQ Registry, error = 0x%x", rc);
        ASSERT(("At this point MSMQ Registry must exist", 0));
        return false;
    }

	//
	// Read name of remote QM (if exist).
	//
	WCHAR wszRemoteQMName[MAX_PATH] = {0};
    DWORD type = REG_SZ;
    DWORD size = sizeof(wszRemoteQMName);
    rc = RegQueryValueEx( 
             hKey,
             RPC_REMOTE_QM_REGNAME,
             0L,
             &type,
             reinterpret_cast<BYTE*>(&wszRemoteQMName),
             &size 
             );

	TrTRACE(AdDetect, "IsDependentClient = %d", (rc == ERROR_SUCCESS));

    return (rc == ERROR_SUCCESS);
}


bool CDetectEnvironment::ServerRespond(LPCWSTR pwszServerName)
/*++

Routine Description:
	Check that the server is responding

Arguments:
	pwszServerName - Server Name

Return Value:
	true if server respond, false otherwise 
--*/
{
	LDAP* pLdap = ldap_init(
						const_cast<LPWSTR>(pwszServerName), 
						LDAP_PORT
						);

	if(pLdap == NULL)
	{
		TrERROR(AdDetect, "ServerRespond(), ldap_init failed, server = %ls, error = 0x%x", pwszServerName, LdapGetLastError());
		return false;
	}

    ULONG LdapError = ldap_set_option( 
							pLdap,
							LDAP_OPT_AREC_EXCLUSIVE,
							LDAP_OPT_ON  
							);

	if (LdapError != LDAP_SUCCESS)
    {
		TrERROR(AdDetect, "ServerRespond(), ldap_set_option failed, LdapError = 0x%x", LdapError);
		return false;
    }

	LdapError = ldap_connect(pLdap, 0);
	if (LdapError != LDAP_SUCCESS)
    {
		TrERROR(AdDetect, "ServerRespond(), ldap_connect failed, LdapError = 0x%x", LdapError);
		return false;
    }

    LdapError = ldap_unbind(pLdap);
	if (LdapError != LDAP_SUCCESS)
    {
		TrERROR(AdDetect, "ServerRespond(), ldap_unbind failed, LdapError = 0x%x", LdapError);
    }

	TrTRACE(AdDetect, "Server %ls Respond", pwszServerName);
	return true;
}

void CDetectEnvironment::GetQmGuid(GUID* pGuid)
/*++

Routine Description:
	Read qm guid from the registry.
	can throw bad_win32_error

Arguments:
	pGuid - pointer to qm guid

Return Value:
	None.
--*/
{
	CAutoCloseRegHandle hKey;
    DWORD rc = RegOpenKeyEx(
				 FALCON_REG_POS,
				 FALCON_MACHINE_CACHE_REG_KEY,
				 0,
				 KEY_READ,
				 &hKey
				 );

    if (rc != ERROR_SUCCESS)
    {
        ASSERT(("At this point MSMQ MachineCache Registry must exist", 0));
		TrERROR(AdDetect, "RegOpenKeyEx Failed to open registry %ls, rc = %d", FALCON_MACHINE_CACHE_REG_KEY, rc);
		throw bad_win32_error(rc);
    }

	DWORD type = REG_BINARY;
    DWORD size = sizeof(GUID);
	if(IsDepClient())
	{    
		//
		// Call GetServers function that also write the SUPPORT_SERVER_QMID value in the registry
		//
		ASSERT(m_pfnGetServers != NULL);
		BOOL fDepClient = FALSE;
		(*m_pfnGetServers)(&fDepClient);
		ASSERT(fDepClient);

		//
		// For dependent client read the supporting server QmGuid
		//
		rc = RegQueryValueEx( 
				 hKey,
				 MSMQ_SUPPORT_SERVER_QMID_REGVALUE,
				 0L,
				 &type,
				 reinterpret_cast<BYTE*>(pGuid),
				 &size 
				 );
	}
	else
	{
		rc = RegQueryValueEx( 
				 hKey,
				 MSMQ_QMID_REGVALUE,
				 0L,
				 &type,
				 reinterpret_cast<BYTE*>(pGuid),
				 &size 
				 );
	}    

    if (rc != ERROR_SUCCESS)
    {
		//
		// This is legal scenario in setup, when we still did not create QMID registry
		// The code handle it correctly, throw exception and does not upgrade to the DsEnvironment
		//
		TrERROR(AdDetect, "RegQueryValueEx Failed to query registry %ls, rc = %d", MSMQ_QMID_REGNAME, rc);
		throw bad_win32_error(rc);
    }

	TrTRACE(AdDetect, "Registry value: %ls = %!guid!", MSMQ_QMID_REGNAME, pGuid);
}


bool CDetectEnvironment::MachineOwnedByNT4Site()
/*++

Routine Description:
	Check if the machine is owned by NT4 site.

	We are using the following logic:
	
	1) We get QM guid from the registry.
	2) find PROPID_QM_OWNERID (the site id that owned the machine)
			if the property is not found (E_ADS_PROPERTY_NOT_FOUND) --> the machine is not owned by NT4
			every other error --> stay as NT4
	3) check if OWNERID site exist in AD
			error --> stay as NT4
	4) check if OWNERID site is NT4
		a) create NT4 site map
				error --> stay as NT4
		b) check if OWNERID site is in NT4 map
				yes --> stay as NT4
				no ---> the machine is not owned by NT4

	Please note that on every exception we will stay as NT4.

Arguments:
	None

Return Value:
	true if the machine is owned by NT4, false if not.
	 
--*/
{

	//
	// We have w2k DC server in our site, load AD provider
	// for checking AD information
	//
	g_pAD = new CActiveDirectoryProvider();
	HRESULT hr = g_pAD->Init(            
					NULL,   // pLookDS
					NULL,   // pGetServers
					false,  // fSetupMode
					false,  // fQMDll
					NULL,   // pNoServerAuth
					NULL,   // szServerName
                    true    // fDisableDownlevelNotifications

					);
	if(FAILED(hr))
	{
		TrERROR(AdDetect, "MasterIdIsNT4: g_pAD->Init failed, hr = 0x%x", hr);
		return true;
	}

	bool fIsMachineNT4 = true;
	try
	{
		fIsMachineNT4 = MasterIdIsNT4();
	}
	catch(bad_api&)
	{
		//
		// Every exception, we will remain owned by NT4 site 
		// fIsMachineNT4 was initialized to true
		//
		TrTRACE(AdDetect, "MasterIdIsNT4: got bad_api exception");
	}

	//
	// unload AD provider
	//
	g_pAD->Terminate();
	g_pAD.free();

	return fIsMachineNT4;
}


bool CDetectEnvironment::MasterIdIsNT4()
/*++

Routine Description:
	Check if the machine master id is NT4 site.
	can throw bad_hresult, bad_win32_error.

Arguments:
	None

Return Value:
	true if the machine master id is NT4 site, false if not.
	 
--*/
{
	//
	// Get Machine master id
	//
	CAutoADFree<GUID> pQmMasterGuid;
	HRESULT hr = GetQMMasterId(&pQmMasterGuid);

    if (hr == E_ADS_PROPERTY_NOT_FOUND)
	{
		//
		// QM_MASTER_ID property was not found, this means we are not owned by NT4 site
		// This will be the case on upgrade from w2k
		//

		TrTRACE(AdDetect, "MasterIdIsNT4: PROPID_QM_MASTERID was not found, we are not NT4 site");
		return false;
	}

    if (FAILED(hr))
    {
		TrERROR(AdDetect, "MasterIdIsNT4: GetQMMasterId failed, error = 0x%x", hr);
		throw bad_hresult(hr);
    }

	//
	// Check if master id is NT4 site
	//
	return IsNT4Site(pQmMasterGuid);
}


HRESULT CDetectEnvironment::GetQMMasterId(GUID** ppQmMasterId)
/*++

Routine Description:
	Get machine master id
	can throw bad_win32_error.

Arguments:
	ppQmMasterId - pointer to machine master id.

Return Value:
	HRESULT
	 
--*/
{
	*ppQmMasterId = NULL;

	//
	// Get qm guid
	//
	GUID QMGuid;
	GetQmGuid(&QMGuid);
    
    PROPID propId = PROPID_QM_MASTERID;
    PROPVARIANT var;
    var.vt = VT_NULL;

    HRESULT hr = g_pAD->GetObjectPropertiesGuid(
					eMACHINE,
					NULL,       // pwcsDomainController
					false,	    // fServerName
					&QMGuid,
					1,
					&propId,
					&var
					);

	if(FAILED(hr))
	{
		return hr;
	}

    ASSERT((var.vt == VT_CLSID) && (var.puuid != NULL));
	*ppQmMasterId = var.puuid;
	return hr;
}


bool CDetectEnvironment::IsNT4Site(const GUID* pSiteGuid)
/*++

Routine Description:
	Check if site is NT4 site
	can throw bad_hresult.

Arguments:
	pSiteGuid - pointer to site guid.

Return Value:
	true if site is NT4 site, false if not
	 
--*/
{
	FindSiteInAd(pSiteGuid);

	//
	// We found the site in AD, Check if the site is NT4 site
	//

	return SiteWasFoundInNT4SiteMap(pSiteGuid);
}


void CDetectEnvironment::FindSiteInAd(const GUID* pSiteGuid)
/*++

Routine Description:
	Find site in AD. normal termination if site is found in AD.
	otherwise throw bad_hresult.

Arguments:
	pSiteGuid - pointer to site guid.

Return Value:
	None
	 
--*/
{
    PROPID propSite = PROPID_S_PATHNAME;
    PROPVARIANT varSite;
    varSite.vt = VT_NULL;

    HRESULT hr = g_pAD->GetObjectPropertiesGuid(
					eSITE,
					NULL,       // pwcsDomainController
					false,	    // fServerName
					pSiteGuid,
					1,
					&propSite,
					&varSite
					);

    CAutoADFree<WCHAR> pCleanSite = varSite.pwszVal;

	if(FAILED(hr))
	{
		if (hr == MQDS_OBJECT_NOT_FOUND)
		{
			//
			// The site object was not found, it must be NT4 site and migration did not started yet
			// This will be handle as any other error (stay as NT4 site)
			//
			TrTRACE(AdDetect, "FindSiteInAd: Site object was not found, this means we are NT4 site");
		}
		else
		{
			TrERROR(AdDetect, "FindSiteInAd: ADGetObjectPropertiesGuid failed, error = 0x%x", hr);
		}
		throw bad_hresult(hr);
	}

    ASSERT(varSite.vt == VT_LPWSTR);
	TrTRACE(AdDetect, "FindSiteInAd: Site cn = %ls", varSite.pwszVal);
}


bool
CDetectEnvironment::SiteWasFoundInNT4SiteMap(
	 const GUID* pSiteGuid
	 )
/*++

Routine Description:
	Check if site is in NT4 site map.
	can throw bad_hresult.

Arguments:
	pSiteGuid - pointer to site guid.

Return Value:
	None
	 
--*/
{
	//
	// Create NT4 site map
	//
	P<NT4Sites_CMAP> pmapNT4Sites;
	CreateNT4SitesMap(&pmapNT4Sites);

    //
	// Check if the site is in the NT4 site map.
	//
	DWORD dwNotApplicable;
    BOOL fNT4Site = pmapNT4Sites->Lookup(*pSiteGuid, dwNotApplicable);
	TrTRACE(AdDetect, "SiteWasFoundInNT4SiteMap: pmapNT4Sites->Lookup = %d", fNT4Site);
    return(fNT4Site ? true: false);
}


void 
CDetectEnvironment::CreateNT4SitesMap(
     NT4Sites_CMAP ** ppmapNT4Sites
     )
/*++

Routine Description:
    Creates new maps for NT4 site PSC's
	can throw bad_hresult.

Arguments:
    ppmapNT4Sites   - returned new NT4Sites map

Return Value:
    none.

--*/
{
    //
    // find all msmq servers that have an NT4 flags > 0 AND services == PSC
    //
    // NT4 flags > 0 (equal to NT4 flags >= 1 for easier LDAP query)
    //
    // start search
    //

    CAutoADQueryHandle hLookup;
	const PROPID xNT4SitesPropIDs[] = {PROPID_SET_MASTERID};
	const xNT4SitesProp_MASTERID = 0;
	const MQCOLUMNSET xColumnsetNT4Sites = {ARRAY_SIZE(xNT4SitesPropIDs), const_cast<PROPID *>(xNT4SitesPropIDs)};

	//
    // This search request will be recognized and specially simulated by DS
	//
    HRESULT hr = g_pAD->QueryNT4MQISServers(
							NULL,       // pwcsDomainController
							false,	    // fServerName
							SERVICE_PSC,
							1,
							const_cast<MQCOLUMNSET*>(&xColumnsetNT4Sites),
							&hLookup
							);

    if (FAILED(hr))
    {
		TrERROR(AdDetect, "CreateNT4SitesMap:DSCoreLookupBegin(), hr = 0x%x", hr);
		throw bad_hresult(hr);
    }

	ASSERT(hLookup != NULL);

    //
    // create maps for NT4 PSC data
    //
    P<NT4Sites_CMAP> pmapNT4Sites = new NT4Sites_CMAP;

    //
    // allocate propvars array for NT4 PSC
    //
    CAutoCleanPropvarArray cCleanProps;
    PROPVARIANT * rgPropVars = cCleanProps.allocClean(ARRAY_SIZE(xNT4SitesPropIDs));

    //
    // loop on the NT4 PSC's
    //
    bool fContinue = true;
    while (fContinue)
    {
        //
        // get next server
        //
        DWORD cProps = ARRAY_SIZE(xNT4SitesPropIDs);

        hr = g_pAD->QueryResults(hLookup, &cProps, rgPropVars);
        if (FAILED(hr))
        {
			TrERROR(AdDetect, "CreateNT4SitesMap:DSCoreLookupNext(), hr = 0x%x", hr);
			throw bad_hresult(hr);
        }

        //
        // remember to clean the propvars in the array for the next loop
        // (only propvars, not the array itself, this is why we call attachStatic)
        //
        CAutoCleanPropvarArray cCleanPropsLoop;
        cCleanPropsLoop.attachStatic(cProps, rgPropVars);

        //
        // check if finished
        //
        if (cProps < ARRAY_SIZE(xNT4SitesPropIDs))
        {
            //
            // finished, exit loop
            //
            fContinue = false;
        }
        else
        {
            ASSERT(rgPropVars[xNT4SitesProp_MASTERID].vt == VT_CLSID);
            GUID guidSiteId = *(rgPropVars[xNT4SitesProp_MASTERID].puuid);

            //
            // add entry to the NT4Sites map
            //
            pmapNT4Sites->SetAt(guidSiteId, 1);
        }
    }

    //
    // return results
    //
    *ppmapNT4Sites = pmapNT4Sites.detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\cliprov.h ===
/*++

Copyright (c) 2000  Microsoft Corporation 

Module Name:
	cliprov.h

Abstract:
	Ds Client provider class.

Author:

    Ilan Herbst (ilanh)	  13-Sep-2000

--*/

#ifndef __CLIPROV_H__
#define __CLIPROV_H__

#include "baseprov.h"
#include "dsproto.h"
#include "autorel.h"

//
// Type of properties
//
enum PropsType
{
    ptNT4Props,				// only NT4 properties
    ptForceNT5Props,		// there is at least 1 property that is NT5+ with no translation
    ptMixedProps			// all properties can be converted to NT4 (or default props)
};


//
// Action for property
//
enum PropAction
{
    paAssign,				// simple assign
    paUseDefault,			// use default value
    paTranslate				// use translation function
};


//
// Information regarding a property
//
struct PropInfo
{
	DWORD						Index;	  // matching index in the new properties set
	PropAction					Action;	  // action for this prop
};


//-----------------------------------------------------------------------------------
//
//      CDSClientProvider
//
//  encapsulates DS client functionality for ActiveDirectory operations 
//
//-----------------------------------------------------------------------------------
class CDSClientProvider : public  CBaseADProvider
{
public:
    CDSClientProvider();

    ~CDSClientProvider();

    virtual 
	HRESULT 
	CreateObject(
		IN  AD_OBJECT               eObject,
		IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
		IN  LPCWSTR                 pwcsObjectName,
		IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
		IN  const DWORD             cp,
		IN  const PROPID            aProp[],
		IN  const PROPVARIANT       apVar[],
		OUT GUID*                   pObjGuid
		);

    virtual 
	HRESULT 
	DeleteObject(
		IN  AD_OBJECT               eObject,
		IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
		IN  LPCWSTR                 pwcsObjectName
		);

    virtual 
	HRESULT 
	DeleteObjectGuid(
        IN  AD_OBJECT               eObject,
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN  const GUID*             pguidObject
        );

    virtual 
	HRESULT 
	GetObjectProperties(
        IN  AD_OBJECT               eObject,
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN  LPCWSTR                 pwcsObjectName,
        IN  const DWORD             cp,
        IN  const PROPID            aProp[],
        IN OUT PROPVARIANT          apVar[]
        );

    virtual 
	HRESULT 
	GetObjectPropertiesGuid(
        IN  AD_OBJECT               eObject,
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN  const GUID*             pguidObject,
        IN  const DWORD             cp,
        IN  const PROPID            aProp[],
        IN  OUT PROPVARIANT         apVar[]
        );

    virtual 
	HRESULT 
	GetObjectSecurity(
        IN  AD_OBJECT               eObject,
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN  LPCWSTR                 pwcsObjectName,
        IN  SECURITY_INFORMATION    RequestedInformation,
        IN  const PROPID            prop,
        IN OUT  PROPVARIANT *       pVar
        );

    virtual 
	HRESULT 
	GetObjectSecurityGuid(
        IN  AD_OBJECT               eObject,
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN  const GUID*             pguidObject,
        IN  SECURITY_INFORMATION    RequestedInformation,
        IN  const PROPID            prop,
        IN OUT  PROPVARIANT *       pVar
        );

    virtual 
	HRESULT 
	SetObjectProperties(
        IN  AD_OBJECT               eObject,
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN  LPCWSTR                 pwcsObjectName,
        IN  const DWORD             cp,
        IN  const PROPID            aProp[],
        IN  const PROPVARIANT       apVar[]
        );

    virtual 
	HRESULT 
	SetObjectPropertiesGuid(
        IN  AD_OBJECT               eObject,
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN  const GUID*             pguidObject,
        IN  const DWORD             cp,
        IN  const PROPID            aProp[],
        IN  const PROPVARIANT       apVar[]
        );
 
	virtual 
	HRESULT 
	QMGetObjectSecurity(
        IN  AD_OBJECT               eObject,
        IN  const GUID*             pguidObject,
        IN  SECURITY_INFORMATION    RequestedInformation,
        IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
        IN  DWORD                   nLength,
        IN  LPDWORD                 lpnLengthNeeded,
        IN  DSQMChallengeResponce_ROUTINE
                                    pfChallengeResponceProc,
        IN  DWORD_PTR               dwContext
        );

    virtual 
	HRESULT 
	QMSetMachineProperties(
        IN  LPCWSTR             pwcsObjectName,
        IN  const DWORD         cp,
        IN  const PROPID        aProp[],
        IN  const PROPVARIANT   apVar[],
        IN  DSQMChallengeResponce_ROUTINE pfSignProc,
        IN  DWORD_PTR           dwContext
        );

    virtual 
	HRESULT 
	SetObjectSecurity(
        IN  AD_OBJECT               eObject,
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN  LPCWSTR                 pwcsObjectName,
        IN  SECURITY_INFORMATION    RequestedInformation,
        IN  const PROPID            prop,
        IN  const PROPVARIANT *     pVar
        );


    virtual 
	HRESULT 
	SetObjectSecurityGuid(
        IN  AD_OBJECT               eObject,
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN  const GUID*             pguidObject,
        IN  SECURITY_INFORMATION    RequestedInformation,
        IN  const PROPID            prop,
        IN  const PROPVARIANT *     pVar
        );


    virtual 
	HRESULT 
	Init( 
        IN QMLookForOnlineDS_ROUTINE    pLookDS,
        IN MQGetMQISServer_ROUTINE      pGetServers,
        IN bool                         fSetupMode,
        IN bool                         fQMDll,
        IN NoServerAuth_ROUTINE         pNoServerAuth,
        IN LPCWSTR                      szServerName,
        IN bool                         fDisableDownlevelNotifications
        );

    virtual 
	HRESULT 
	SetupInit(
        IN    unsigned char   ucRoll,
        IN    LPWSTR          pwcsPathName,
        IN    const GUID *    pguidMasterId
        );

    virtual HRESULT CreateServersCache();

    virtual 
	HRESULT 
	GetComputerSites(
        IN  LPCWSTR     pwcsComputerName,
        OUT DWORD  *    pdwNumSites,
        OUT GUID **     ppguidSites
        );

    virtual 
	HRESULT 
	BeginDeleteNotification(
        IN  AD_OBJECT               eObject,
        IN LPCWSTR                  pwcsDomainController,
        IN  bool					fServerName,
        IN LPCWSTR					pwcsObjectName,
        IN OUT HANDLE   *           phEnum
        );

    virtual 
	HRESULT 
	NotifyDelete(
        IN  HANDLE hEnum
        );

    virtual 
	HRESULT 
	EndDeleteNotification(
        IN  HANDLE hEnum
        );

    virtual 
	HRESULT 
	QueryMachineQueues(
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN  const GUID *            pguidMachine,
        IN  const MQCOLUMNSET*      pColumns,
        OUT PHANDLE                 phEnume
        );

    virtual 
	HRESULT 
	QuerySiteServers(
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN const GUID *             pguidSite,
        IN AD_SERVER_TYPE           serverType,
        IN const MQCOLUMNSET*       pColumns,
        OUT PHANDLE                 phEnume
        );

    virtual 
	HRESULT 
	QueryUserCert(
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN const BLOB *             pblobUserSid,
        IN const MQCOLUMNSET*       pColumns,
        OUT PHANDLE                 phEnume
        );

    virtual 
	HRESULT 
	QueryConnectors(
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN const GUID *             pguidSite,
        IN const MQCOLUMNSET*       pColumns,
        OUT PHANDLE                 phEnume
        );

    virtual 
	HRESULT 
	QueryForeignSites(
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN const MQCOLUMNSET*       pColumns,
        OUT PHANDLE                 phEnume
        );

    virtual 
	HRESULT 
	QueryLinks(
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN const GUID *             pguidSite,
        IN eLinkNeighbor            eNeighbor,
        IN const MQCOLUMNSET*       pColumns,
        OUT PHANDLE                 phEnume
        );

    virtual 
	HRESULT 
	QueryAllLinks(
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN const MQCOLUMNSET*       pColumns,
        OUT PHANDLE                 phEnume
        );

    virtual 
	HRESULT 
	QueryAllSites(
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN const MQCOLUMNSET*       pColumns,
        OUT PHANDLE                 phEnume
        );

    virtual 
	HRESULT 
	QueryQueues(
        IN  LPCWSTR                 pwcsDomainController,
        IN  bool					fServerName,
        IN  const MQRESTRICTION*    pRestriction,
        IN  const MQCOLUMNSET*      pColumns,
        IN  const MQSORTSET*        pSort,
        OUT PHANDLE                 phEnume
        );

	virtual 
	HRESULT 
	QueryResults(
        IN      HANDLE          hEnum,
        IN OUT  DWORD*          pcProps,
        OUT     PROPVARIANT     aPropVar[]
        );

    virtual 
	HRESULT 
	EndQuery(
        IN  HANDLE hEnum
        );

    virtual void Terminate();

    virtual HRESULT ADGetADsPathInfo(
                IN  LPCWSTR                 pwcsADsPath,
                OUT PROPVARIANT *           pVar,
                OUT eAdsClass *             pAdsClass
                );

	virtual void FreeMemory(
				IN PVOID					pMemory
				);

	//
	// Additional functions for the querys to call directly LookupNext, LookupEnd
	//
	HRESULT 
	LookupNext(
        IN      HANDLE          hEnum,
        IN OUT  DWORD*          pcProps,
        OUT     PROPVARIANT     aPropVar[]
        );

    HRESULT LookupEnd(IN  HANDLE hEnum);



private:

    HRESULT LoadDll();

	HRESULT 
	GetObjectSecurityKey(
		IN  AD_OBJECT               eObject,
		IN  LPCWSTR                 pwcsObjectName,
		IN  const GUID*             pguidObject,
		IN  const DWORD             cp,
		IN  const PROPID            aProp[],
		IN OUT PROPVARIANT          apVar[]
		);

	HRESULT 
	GetObjectPropertiesInternal(
		IN  AD_OBJECT               eObject,
		IN  LPCWSTR                 pwcsObjectName,
		IN  const GUID*             pguidObject,
		IN  const DWORD             cp,
		IN  const PROPID            aProp[],
		IN OUT PROPVARIANT          apVar[]
		);

	HRESULT 
	SetObjectSecurityKey(
		IN  AD_OBJECT               eObject,
		IN  LPCWSTR                 pwcsObjectName,
		IN  const GUID*             pguidObject,
		IN  const DWORD             cp,
		IN  const PROPID            aProp[],
		IN  const PROPVARIANT       apVar[]
		);

	HRESULT 
	SetObjectPropertiesInternal(
		IN  AD_OBJECT               eObject,
		IN  LPCWSTR                 pwcsObjectName,
		IN  const GUID*             pguidObject,
		IN  const DWORD             cp,
		IN  const PROPID            aProp[],
		IN  const PROPVARIANT       apVar[]
		);

	HRESULT 
	GetObjectSecurityInternal(
		IN  AD_OBJECT               eObject,
		IN  LPCWSTR                 pwcsObjectName,
		IN  const GUID*             pguidObject,
		IN  SECURITY_INFORMATION    RequestedInformation,
		IN  const PROPID            prop,
		IN OUT  PROPVARIANT *       pVar
		);

	HRESULT 
	QueryQueuesInternal(
		IN  const MQRESTRICTION*    pRestriction,
		IN  const MQCOLUMNSET*      pColumns,
		IN  const MQSORTSET*        pSort,
		OUT PHANDLE                 phEnume
		);


	HRESULT 
	GetEnterpriseId(
		IN  const DWORD             cp,
		IN  const PROPID            aProp[],
		OUT PROPVARIANT apVar[]
		);

	void 
	GetSiteForeignProperty(
		IN  LPCWSTR                 pwcsObjectName,
		IN  const GUID*             pguidObject,
		IN  const PROPID            pid,
		IN OUT PROPVARIANT*         pVar
		);

	SECURITY_INFORMATION 
	GetKeyRequestedInformation(
		IN AD_OBJECT eObject, 
		IN  const DWORD   cp,
		IN  const PROPID  aProp[]
		);

    DWORD GetMsmq2Object(IN  AD_OBJECT  eObject); 

	PropsType 
	CheckPropertiesType(
		IN  AD_OBJECT     eObject,
		IN  const DWORD   cp,
		IN  const PROPID  aProp[],
		OUT bool*		  pfNeedConvert
		);

	bool 
	CheckProperties(
		IN  const DWORD   cp,
		IN  const PROPID  aProp[],
		IN  const PROPVARIANT apVar[]
		);

	bool 
	IsNt4Properties(
		IN AD_OBJECT eObject, 
		IN  const DWORD   cp,
		IN  const PROPID  aProp[]
		);

	bool 
	IsNt4Property(
		IN AD_OBJECT eObject, 
		IN PROPID pid
		);

	bool 
	IsNt4Property(
		IN PROPID pid
		);

	bool 
	IsNt5ProperyOnly(
		IN AD_OBJECT eObject, 
		IN PROPID pid
		);

	bool 
	IsDefaultProperties(
		IN  const DWORD   cp,
		IN  const PROPID  aProp[]
		);

	bool 
	IsDefaultProperty(
		IN  const PROPID  Prop
		);


	bool 
	IsKeyProperty(
		IN  const DWORD   cp,
		IN  const PROPID  aProp[]
		);

	bool 
	IsEIDProperty(
		IN  const DWORD   cp,
		IN  const PROPID  aProp[]
		);

	bool 
	IsExProperty(
		IN  const DWORD   cp,
		IN  const PROPID  aProp[]
		);

	bool 
	FoundSiteIdsConvertedProps(
		IN  const DWORD   cp,
		IN  const PROPID  aProp[]
		);

	bool 
	IsPropBufferAllocated(
		IN  const PROPVARIANT&    PropVar
		);

	bool 
	CheckRestriction(
		IN  const MQRESTRICTION*    pRestriction
		);

	bool 
	CheckSort(
		IN  const MQSORTSET*        pSort
		);

	bool 
	CheckDefaultColumns(
		IN  const MQCOLUMNSET*      pColumns,
		OUT bool* pfDefaultProp
		);

	bool 
	IsNT4Columns(
		IN  const MQCOLUMNSET*      pColumns
		);


	void InitPropertyTranslationMap();


	void 
	ConvertPropsForGet(
		IN  AD_OBJECT     eObject,
		IN 	PropsType	  PropertiesType,
		IN  const DWORD   cp,
		IN  const PROPID  aProp[],
		IN  const PROPVARIANT apVar[],
		OUT PropInfo    pPropInfo[],
		OUT DWORD*		pcpNew,
		OUT PROPID**	paPropNew,
		OUT PROPVARIANT** papVarNew
		);


	void 
	ConvertPropsForSet(
		IN  AD_OBJECT     eObject,
		IN 	PropsType	  PropertiesType,
		IN  const DWORD   cp,
		IN  const PROPID  aProp[],
		IN  const PROPVARIANT apVar[],
		OUT DWORD*		pcpNew,
		OUT PROPID**	paPropNew,
		OUT PROPVARIANT** papVarNew
		);


	void 
	PrepareNewProps(
		IN  AD_OBJECT     eObject,
		IN  const DWORD   cp,
		IN  const PROPID  aProp[],
		IN  const PROPVARIANT apVar[],
		OUT PropInfo    pPropInfo[],
		OUT DWORD*		pcpNew,
		OUT PROPID**	paPropNew,
		OUT PROPVARIANT** papVarNew
		);

	void 
	PrepareReplaceProps(
		IN  AD_OBJECT     eObject,
		IN  const DWORD   cp,
		IN  const PROPID  aProp[],
		OUT PropInfo    pPropInfo[],
		OUT DWORD*		pcpNew,
		OUT PROPID**	paPropNew
		);

	bool 
	PrepareAllLinksProps(
		IN  const MQCOLUMNSET* pColumns,
		OUT DWORD*		pcpNew,
		OUT PROPID**	paPropNew,
		OUT DWORD*		pLGatesIndex,
		OUT DWORD*		pNeg1Index,
		OUT DWORD*		pNeg2Index
		);

	void 
	EliminateDefaultProps(
		IN  const DWORD   cp,
		IN  const PROPID  aProp[],
		IN  const PROPVARIANT apVar[],
		OUT PropInfo    pPropInfo[],
		OUT DWORD*		pcpNew,
		OUT PROPID**	paPropNew,
		OUT PROPVARIANT** papVarNew
		);

	void 
	EliminateDefaultProps(
		IN  const DWORD   cp,
		IN  const PROPID  aProp[],
		OUT PropInfo    pPropInfo[],
		OUT DWORD*		pcpNew,
		OUT PROPID**	paPropNew
		);

	void 
	ReconstructProps(
		IN  LPCWSTR       pwcsObjectName,
		IN  const GUID*   pguidObject,
		IN  const DWORD   cpTran,
		IN  const PROPID  aPropTran[],
		IN  const PROPVARIANT   apVarTran[],
		IN  const PropInfo pPropInfo[],
		IN  const DWORD   cp,
		IN  const PROPID  aProp[],
		IN OUT PROPVARIANT   apVar[]
		);

	void 
	ConvertToNT4Props(
		IN  AD_OBJECT     eObject,
		IN  const DWORD   cp,
		IN  const PROPID  aProp[],
		IN  const PROPVARIANT apVar[],
		OUT DWORD*		pcpNew,
		OUT PROPID**	paPropNew,
		OUT PROPVARIANT** papVarNew
		);


	void 
	EliminateDefaultPropsForSet(
		IN  const DWORD   cp,
		IN  const PROPID  aProp[],
		IN  const PROPVARIANT apVar[],
		OUT DWORD*		pcpNew,
		OUT PROPID**	paPropNew,
		OUT PROPVARIANT** papVarNew
		);


	bool 
	CompareVarValue(
           IN const MQPROPVARIANT * pvarUser,
           IN const MQPROPVARIANT * pvarValue
           );

    bool 
	IsQueuePathNameDnsProperty(
		IN  const MQCOLUMNSET*      pColumns
        );

    bool 
	IsQueueAdsPathProperty(
		IN  const MQCOLUMNSET*      pColumns
        );

private:

    DSCreateObject_ROUTINE                  m_pfDSCreateObject;
    DSGetObjectProperties_ROUTINE           m_pfDSGetObjectProperties;
    DSSetObjectProperties_ROUTINE           m_pfDSSetObjectProperties;
    DSLookupBegin_ROUTINE                   m_pfDSLookupBegin;
    DSLookupNext_ROUTINE                    m_pfDSLookupNext;
    DSLookupEnd_ROUTINE                     m_pfDSLookupEnd;
    DSInit_ROUTINE                          m_pfDSInit;
    DSGetObjectPropertiesGuid_ROUTINE       m_pfDSGetObjectPropertiesGuid;
    DSSetObjectPropertiesGuid_ROUTINE       m_pfDSSetObjectPropertiesGuid;
    DSQMSetMachineProperties_ROUTINE        m_pfDSQMSetMachineProperties;
    DSGetObjectPropertiesEx_ROUTINE         m_pfDSGetObjectPropertiesEx;
    DSGetObjectPropertiesGuidEx_ROUTINE     m_pfDSGetObjectPropertiesGuidEx;
    DSCreateServersCache_ROUTINE            m_pfDSCreateServersCache;
    DSQMGetObjectSecurity_ROUTINE           m_pfDSQMGetObjectSecurity;
    DSGetComputerSites_ROUTINE              m_pfDSGetComputerSites;
    DSSetObjectSecurity_ROUTINE				m_pfDSSetObjectSecurity;
    DSGetObjectSecurity_ROUTINE				m_pfDSGetObjectSecurity;
    DSDeleteObject_ROUTINE					m_pfDSDeleteObject;
    DSSetObjectSecurityGuid_ROUTINE			m_pfDSSetObjectSecurityGuid;
    DSGetObjectSecurityGuid_ROUTINE			m_pfDSGetObjectSecurityGuid;
    DSDeleteObjectGuid_ROUTINE				m_pfDSDeleteObjectGuid;
	DSBeginDeleteNotification_ROUTINE		m_pfDSBeginDeleteNotification;
	DSNotifyDelete_ROUTINE					m_pfDSNotifyDelete;
	DSEndDeleteNotification_ROUTINE			m_pfDSEndDeleteNotification;
	DSFreeMemory_ROUTINE					m_pfDSFreeMemory;

	CAutoFreeLibrary                        m_hLib;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\queryh.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
	hquery.cpp

Abstract:
	Implementation of different query handles
	
Author:

    Ilan Herbst		(ilanh)		12-Oct-2000

--*/
#include "ds_stdh.h"
#include "queryh.h"
#include "traninfo.h"
#include "ad.h"
#include "adalloc.h"

static WCHAR *s_FN=L"ad/queryh";

extern CMap<PROPID, PROPID, const PropTranslation*, const PropTranslation*&> g_PropDictionary;


HRESULT 
CQueryHandle::LookupNext(
    IN OUT DWORD*             pdwSize,
    OUT    PROPVARIANT*       pbBuffer
	)
/*++

Routine Description:
	Performs Locate next on the DS directly.
	Simple LookupNext, only forward the call to mqdscli

Arguments:
	pdwSize - IN number of PROPVARIANT in pbBuffer, OUT number of PROPVARIANT filled in
	pbBuffer - a caller allocated buffer

Return Value
	HRESULT
--*/
{
    return m_pClientProvider->LookupNext(
				m_hCursor,
				pdwSize,
				pbBuffer
				);
}


HRESULT 
CBasicLookupQueryHandle::LookupNext(
    IN OUT  DWORD*            pdwSize,
    OUT     PROPVARIANT*      pbBuffer
	)
/*++

Routine Description:
	Performs Locate next when we need to fill the original propvar buffer (pbBuffer)
	by retreiving another set of propvars and convert them to the original props
	This LookupNext is used by all advance query handles

Arguments:
	pdwSize - IN number of PROPVARIANT in pbBuffer, OUT number of PROPVARIANT filled in
	pbBuffer - a caller allocated buffer

Return Value
	HRESULT
--*/
{
    //
    // Calculate the number of records ( == results) to be read
    //
    DWORD NoOfRecords = *pdwSize / m_cCol;

    if (NoOfRecords == 0)
    {
        //
        //  Number of properties is not big enough to hold one result
        //
        *pdwSize = 0;
        return LogHR(MQ_ERROR_RESULT_BUFFER_TOO_SMALL, s_FN, 40);
    }

    //
    // compute the complete set
	// according to the new props count
    //
    DWORD cp = NoOfRecords * m_cColNew;
    AP<MQPROPVARIANT> pPropVar = new MQPROPVARIANT[cp];

    HRESULT hr = m_pClientProvider->LookupNext(
						m_hCursor,
						&cp,
						pPropVar
						);

    if (FAILED(hr))
    {
        //
        // BUGBUG - are there other indication to failure of Locate next?
		//
        return LogHR(hr, s_FN, 50);
    }

    //
    //  For each of the results, retreive the properties
    //  the user asked for in locate begin
    //
    MQPROPVARIANT* pvar = pbBuffer;
    for (DWORD j = 0; j < *pdwSize; j++, pvar++)
    {
        pvar->vt = VT_NULL;
    }

	//
	// Calc number of records read by LookupNext
	//
	DWORD NoResultRead = cp / m_cColNew;

    for (DWORD i = 0; i < NoResultRead; i++)
    {
		FillInOneResponse(
			&pPropVar[i * m_cColNew], 
			&pbBuffer[i * m_cCol]
			);
	}

    *pdwSize = NoResultRead * m_cCol;
    return(MQ_OK);
}


void 
CQueueQueryHandle::FillInOneResponse(
    IN const PROPVARIANT*      pPropVar,
    OUT      PROPVARIANT*      pOriginalPropVar
	)
/*++

Routine Description:
	Fill one record for queues query.
	This fill only assign propvars or copy default values

Arguments:
	pPropVar - pointer to the filled props var
	pOriginalPropVar - pointer to original props var to be filled

Return Value
	None
--*/
{
	for (DWORD i = 0; i < m_cCol; ++i)
	{
		//
		// For each original prop
		//
		switch (m_pPropInfo[i].Action)
		{
			case paAssign:
				pOriginalPropVar[i] = pPropVar[m_pPropInfo[i].Index];
				break;

			case paUseDefault:
				{
					//
					// find original prop default value in the translation map
					//
					const PropTranslation *pTranslate;
					if(!g_PropDictionary.Lookup(m_aCol[i], pTranslate))
					{
						ASSERT(("Must find the property in the translation table", 0));
					}

					ASSERT(pTranslate->pvarDefaultValue);

					HRESULT hr = CopyDefaultValue(
									   pTranslate->pvarDefaultValue,
									   &pOriginalPropVar[i]
									   );

					if(FAILED(hr))
					{
						ASSERT(("Failed to copy default value", 0));
					}
				}
				break;

			default:
				ASSERT(0);
				break;
		}	
	}
}


void 
CSiteServersQueryHandle::FillInOneResponse(
    IN const PROPVARIANT*      pPropVar,
    OUT      PROPVARIANT*      pOriginalPropVar
	)
/*++

Routine Description:
	Fill one record for Site servers query.
	This fill only assign propvars or translate NT4 propvars to NT5 propvars

Arguments:
	pPropVar - pointer to the filled props var
	pOriginalPropVar - pointer to original props var to be filled

Return Value
	None
--*/
{
	for (DWORD i = 0; i < m_cCol; ++i)
	{
		//
		// For each original prop
		//
		switch (m_pPropInfo[i].Action)
		{
			case paAssign:
				pOriginalPropVar[i] = pPropVar[m_pPropInfo[i].Index];
				break;

			case paTranslate:
				{
					//
					// find original prop translation
					//
					const PropTranslation *pTranslate;
					if(!g_PropDictionary.Lookup(m_aCol[i], pTranslate))
					{
						ASSERT(("Must find the property in the translation table", 0));
					}

					ASSERT(pTranslate->SetPropertyHandleNT5);

					HRESULT hr = pTranslate->SetPropertyHandleNT5(
										m_cColNew,
										m_aColNew,
										pPropVar,
										m_pPropInfo[i].Index,
										&pOriginalPropVar[i]
										);
					if (FAILED(hr))
					{
						ASSERT(("Failed to set NT5 property value", 0));
					}
				}
				break;

			default:
				ASSERT(0);
				break;
		}	
	}

}

/*====================================================

CAllLinksQueryHandle::FillInOneResponse

Arguments:
      pPropVar - pointer to the filled props var
      pOriginalPropVar - pointer to original props var to be filled


=====================================================*/
void
CAllLinksQueryHandle::FillInOneResponse(
    IN const PROPVARIANT*      pPropVar,
    OUT      PROPVARIANT*      pOriginalPropVar
	)
/*++

Routine Description:
	Fill one record for All Links query.
	This fill only assign propvars 
	and retreive the PROPID_L_GATES

Arguments:
	pPropVar - pointer to the filled props var
	pOriginalPropVar - pointer to original props var to be filled

Return Value
	None
--*/
{
	//
	// Keep the count in the new props array
	//
	DWORD PropIndex = 0;

	for (DWORD i = 0; i < m_cCol; ++i)
	{
		if(m_LGatesIndex == i)
		{
			//
			// Need to fill PROPID_L_GATES
			//
			HRESULT hr = GetLGates( 
							pPropVar[m_Neg1NewIndex].puuid,
							pPropVar[m_Neg2NewIndex].puuid,
							&pOriginalPropVar[i]
							);

			ASSERT(SUCCEEDED(hr));
			DBG_USED(hr);
			continue;
		}

		//
		// Simple assign for all others PROPID
		//
		pOriginalPropVar[i] = pPropVar[PropIndex];
		PropIndex++;
	}
}


HRESULT
CAllLinksQueryHandle::GetLGates(
    IN const GUID*            pNeighbor1Id,
    IN const GUID*            pNeighbor2Id,
    OUT     PROPVARIANT*      pProvVar
	)
/*++

Routine Description:
	Calc PROPID_L_GATES

Arguments:
	pNeighbor1Id - pointer to Neighbor1 guid
	pNeighbor2Id - pointer to Neighbor2 guid
	pProvVar - PROPID_L_GATES propvar to be filled

Return Value
	HRESULT
--*/
{
    //
    // read the SiteGates of the Neighbor1
    //

    PROPVARIANT Var1;
    PROPID Prop1 = PROPID_S_GATES;
    Var1.vt = VT_NULL;

    HRESULT hr = ADGetObjectPropertiesGuid(
						eSITE,
						NULL,       // pwcsDomainController
						false,	    // fServerName
						pNeighbor1Id,
						1,
						&Prop1,
						&Var1
						);


    if ( FAILED(hr))
    {
        return LogHR(hr, s_FN, 100);
    }

	CAutoADFree<GUID> pCleanAGuid1 = Var1.cauuid.pElems;

    ASSERT(Var1.vt == (VT_CLSID|VT_VECTOR));

    //
    // read the SiteGates of the Neighbor2
    //

    PROPVARIANT Var2;
    PROPID      Prop2 = PROPID_S_GATES;
    Var2.vt = VT_NULL;

    hr = ADGetObjectPropertiesGuid(
			eSITE,
			NULL,       // pwcsDomainController
			false,	    // fServerName
			pNeighbor2Id,
			1,
			&Prop2,
			&Var2
			);


    if ( FAILED(hr))
    {
        return LogHR(hr, s_FN, 105);
    }

	CAutoADFree<GUID> pCleanAGuid2 = Var2.cauuid.pElems;

    ASSERT(Var2.vt == (VT_CLSID|VT_VECTOR));

	//
	// Prepare PROPID_L_GATES propvar
	// concatanate of PROPID_S_GATES of both neighbor
	//
	pProvVar->vt = VT_CLSID|VT_VECTOR;
	DWORD cSGates = Var1.cauuid.cElems + Var2.cauuid.cElems;

	if (cSGates != 0)
    {
        pProvVar->cauuid.pElems = new GUID[cSGates];

		//
		// Copy neighbor1 S_GATES
		//
		if(Var1.cauuid.cElems > 0)
		{
			memcpy(
				pProvVar->cauuid.pElems, 
				Var1.cauuid.pElems, 
				Var1.cauuid.cElems * sizeof(GUID)
				);
		}

		//
		// concatanate neighbor2 S_GATES
		//
		if(Var2.cauuid.cElems > 0)
		{
			memcpy(
				&(pProvVar->cauuid.pElems[Var1.cauuid.cElems]), 
				Var2.cauuid.pElems, 
				Var2.cauuid.cElems * sizeof(GUID)
				);
		}
	}
    else
    {
        pProvVar->cauuid.pElems = NULL;
    }

	pProvVar->cauuid.cElems	= cSGates;
    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\cliutil.cpp ===
/*++


Copyright (c) 2000  Microsoft Corporation 

Module Name:

    cliutil.cpp

Abstract:

	DS client provider class utils.

Author:

    Ilan Herbst		(ilanh)		13-Sep-2000

--*/

#include "ds_stdh.h"
#include "ad.h"
#include "cliprov.h"
#include "mqmacro.h"
#include "traninfo.h"
#include "_ta.h"

static WCHAR *s_FN=L"ad/cliputil";

//
// translation information of properties
//
extern CMap<PROPID, PROPID, const PropTranslation*, const PropTranslation*&> g_PropDictionary;


HRESULT 
CDSClientProvider::GetEnterpriseId(
    IN  const DWORD             cp,
    IN  const PROPID            aProp[],
    OUT PROPVARIANT         apVar[]
    )
/*++

Routine Description:
	Get PROPID_E_ID
	This is a special translate for GetObjectProp* that
	need to retrieve PROPID_E_ID

Arguments:
    cp - number of properties to set
    aProp - properties
    apVar  property values


Return Value
	HRESULT
--*/
{
	DBG_USED(cp);
	DBG_USED(aProp);

	ASSERT(cp == 1);
	ASSERT(aProp[0] == PROPID_E_ID);

    //
    // Prepare the properties
    //
    PROPID columnsetPropertyIDs[] = {PROPID_E_ID};
    MQCOLUMNSET columnsetMSMQService;
    columnsetMSMQService.cCol = 1;
    columnsetMSMQService.aCol = columnsetPropertyIDs;

    HANDLE hQuery;

    ASSERT(m_pfDSLookupBegin != NULL);
    HRESULT hr = m_pfDSLookupBegin(
					NULL,       //pwcsContext
					NULL,       //pRestriction
					const_cast<MQCOLUMNSET*>(&columnsetMSMQService),
					NULL,       //pSort
					&hQuery
					);

	if(FAILED(hr))
		return hr;

    ASSERT(m_pfDSLookupNext != NULL);

    DWORD dwCount = 1;
    hr = m_pfDSLookupNext(
                hQuery,
                &dwCount,
                &apVar[0]
                );


    ASSERT(m_pfDSLookupEnd != NULL);
    m_pfDSLookupEnd(hQuery);

    return hr;
}


void 
CDSClientProvider::GetSiteForeignProperty(
    IN  LPCWSTR                 pwcsObjectName,
    IN  const GUID*             pguidObject,
    IN  const PROPID            pid,
    IN OUT PROPVARIANT*         pVar
    )
/*++

Routine Description:
	Handle PROPID_S_FOREIGN.
	Only if we found CN with the object name / guid
	and its PROPID_CN_PROTOCOLID == FOREIGN_ADDRESS_TYPE
	then we set PROPID_S_FOREIGN.

Arguments:
	pwcsObjectName - MSMQ object name
	pguidObject - the unique id of the object
	pid - prop id
	pVar - property values

Return Value
	None
--*/
{
	DBG_USED(pid);

	ASSERT((pwcsObjectName != NULL) ^ (pguidObject != NULL));

	ASSERT(pid == PROPID_S_FOREIGN);

	//
	// Assign the default - not foreign
	//
	pVar->bVal = 0;

	//
	// We need to get PROPID_CN_PROTOCOLID
	// but this is only supported when retreiving a specific set of props for CN
	// this is one of the possible supported sets for getting PROPID_CN_PROTOCOLID
	//
    PROPID aProp[] = {PROPID_CN_PROTOCOLID, PROPID_CN_NAME};
    MQPROPVARIANT apVar[TABLE_SIZE(aProp)] = {{VT_UI1, 0, 0, 0, 0}, {VT_NULL, 0, 0, 0, 0}};

	HRESULT hr;
	if(pwcsObjectName != NULL)
	{
		ASSERT(m_pfDSGetObjectProperties != NULL);
		hr = m_pfDSGetObjectProperties(
					MQDS_CN,
					pwcsObjectName,
					TABLE_SIZE(aProp),
					aProp,
					apVar
					);
	}
	else
	{
		ASSERT(m_pfDSGetObjectPropertiesGuid != NULL);
		hr = m_pfDSGetObjectPropertiesGuid(
					MQDS_CN,
					pguidObject,
					TABLE_SIZE(aProp),
					aProp,
					apVar
					);
	}

	m_pfDSFreeMemory(apVar[1].pwszVal);

	if (FAILED(hr))
	{
		//
		// If we dont find CN we assume site. and site can not be foreign in msmq1.0
		//
        return;
	}
	
	if(apVar[0].bVal == FOREIGN_ADDRESS_TYPE)
	{
		//
		// We found the object 
		// and its PROPID_CN_PROTOCOLID == FOREIGN_ADDRESS_TYPE
		// only in that case we set PROPID_S_FOREIGN
		//
		pVar->bVal = 1;
	}
}


SECURITY_INFORMATION 
CDSClientProvider::GetKeyRequestedInformation(
	IN AD_OBJECT eObject, 
    IN  const DWORD   cp,
    IN  const PROPID  aProp[]
    )
/*++

Routine Description:
	Get the SECURITY_INFORMATION for 
	the security key property PROPID_QM_ENCRYPT_PK or PROPID_QM_SIGN_PK

Arguments:
	eObject - object type
	cp - number of properties
	aProp - properties

Return Value
	key SECURITY_INFORMATION or 0 
--*/
{

	ASSERT(("Must be one property for PROPID_QM_ENCRYPT_PK or PROPID_QM_SIGN_PK", cp == 1));
	DBG_USED(cp);
	DBG_USED(eObject);

	if(aProp[0] == PROPID_QM_ENCRYPT_PK)
	{
		ASSERT(eObject == eMACHINE);
		return MQDS_KEYX_PUBLIC_KEY;
	}

	if(aProp[0] == PROPID_QM_SIGN_PK)
	{
		//
		// ISSUE - is site sign key is in use ??
		//
		ASSERT((eObject == eMACHINE) || (eObject == eSITE));
		return MQDS_SIGN_PUBLIC_KEY;
	}

	ASSERT(("dont suppose to get here", 0));
	return 0;
}


DWORD 
CDSClientProvider::GetMsmq2Object(
    IN  AD_OBJECT  eObject
    )
/*++

Routine Description:
	Convert AD_OBJECT to Msmq2Object

Arguments:
	eObject - object type

Return Value
	Msmq2Object (DWORD)
--*/
{
    switch(eObject)
    {
        case eQUEUE:
            return MQDS_QUEUE;
            break;
        case eMACHINE:
            return MQDS_MACHINE;
            break;
        case eSITE:
            return MQDS_SITE;
            break;
        case eENTERPRISE:
            return MQDS_ENTERPRISE;
            break;
        case eUSER:
            return MQDS_USER;
            break;
        case eROUTINGLINK:
            return MQDS_SITELINK;
            break;
        case eCOMPUTER:
            return MQDS_COMPUTER;
            break;
        default:
            ASSERT(0);
            return 0;
    }
}

//
// CheckProps functions
//

PropsType 
CDSClientProvider::CheckPropertiesType(
    IN  AD_OBJECT     eObject,
    IN  const DWORD   cp,
    IN  const PROPID  aProp[],
	OUT bool*		  pfNeedConvert
    )
/*++

Routine Description:
	Check the properties type 
	and check if we need to convert the properties

Arguments:
	eObject - object type
	cp - number of properties
	aProp - properties
	pfNeedConvert - flag, indicate if we need to convert the props

Return Value
	PropsType (enum)
	ptNT4Props - all props are NT4 props
	ptForceNT5Props - at least 1 prop is NT5 prop with no convertion
	ptMixedProps - all NT5 props can be converted to NT4 props
--*/
{
	*pfNeedConvert = false;
	bool fNT4PropType = true;
	bool fNT5OnlyProp = false;

    for (DWORD i = 0; i < cp; ++i)
	{
		if(!IsNt4Property(eObject, aProp[i]))
		{
			//
			// Not NT4 property
			//
			fNT4PropType = false;

			if(IsNt5ProperyOnly(eObject, aProp[i]))
			{
				//
				// We need NT5 server for this prop
				// can not convert to NT4 prop
				//
				fNT5OnlyProp = true;
				continue;
			}

			if(IsDefaultProperty(aProp[i]))
			{
				//
				// We have a default property
				// We always eliminate default properties
				// so we need to convert
				//
				*pfNeedConvert = true;
			}
		}
	}

	if(fNT4PropType)
	{
		//
		// All props are NT4
		//

		ASSERT(*pfNeedConvert == false);
		return ptNT4Props;
	}

	if(fNT5OnlyProp)
	{
		//
		// *pfNeedConvert is true if there are default props otherwise false
		// 
		return ptForceNT5Props;
	}

	//
	// In mixed mode we always need to convert to NT4 props
	//
	*pfNeedConvert = true;
    return ptMixedProps;
}


bool 
CDSClientProvider::CheckProperties(
    IN  const DWORD   cp,
    IN  const PROPID  aProp[],
    IN  const PROPVARIANT apVar[]
    )
/*++

Routine Description:
	Check that all properties are ok.
	property is not ok if: 
		it is a default prop and her value is different from the default value

Arguments:
	cp - number of properties
	aProp - properties
    apVar  property values

Return Value
	true if properties ok, false if not
--*/
{
    for (DWORD i = 0; i < cp; ++i)
	{
		const PropTranslation *pTranslate;

		if((g_PropDictionary.Lookup(aProp[i], pTranslate)) &&	  // found prop translation info
		   (pTranslate->Action == taUseDefault) &&				  // prop action is taUseDefault
		   (!CompareVarValue(&apVar[i], pTranslate->pvarDefaultValue)))	  // prop value is different from the default value
		{
			//
			// The prop is not NT4 prop
			// We found the prop translation info
			// the prop action is taUseDefault
			// But the prop var is different from the default value
			//
			return false;
		}
	}
    return true;
}


bool 
CDSClientProvider::IsNt4Properties(
	IN AD_OBJECT eObject, 
    IN  const DWORD   cp,
    IN  const PROPID  aProp[]
    )
/*++

Routine Description:
	Check if all props are NT4

Arguments:
	cp - number of properties
	aProp - properties

Return Value
	true if all props are NT4, false if not
--*/
{
    for (DWORD i = 0; i < cp; ++i)
	{
		if(!IsNt4Property(eObject, aProp[i]))
		{
			//
			// We found Non NT4 prop
			//
			return false;
		}
	}

    return true;
}


bool 
CDSClientProvider::IsNt4Property(
	IN AD_OBJECT eObject, 
	IN PROPID pid
	)
/*++

Routine Description:
	Check if the property is NT4 prop 

Arguments:
	eObject - object type
	pid - prop id

Return Value
	true if prop is NT4 prop, false if not
--*/
{
    switch (eObject)
    {
        case eQUEUE:
            return (pid < PROPID_Q_NT4ID || 
                    (pid > PPROPID_Q_BASE && pid < PROPID_Q_OBJ_SECURITY));

        case eMACHINE:
            return (pid < PROPID_QM_FULL_PATH || 
                    (pid > PPROPID_QM_BASE && pid <= PROPID_QM_ENCRYPT_PK));

        case eSITE:
            return (pid < PROPID_S_FULL_NAME || 
                    (pid > PPROPID_S_BASE && pid <= PROPID_S_PSC_SIGNPK));

        case eENTERPRISE:
            return (pid < PROPID_E_NT4ID || 
                    (pid > PPROPID_E_BASE && pid <= PROPID_E_SECURITY));

        case eUSER:
            return (pid <= PROPID_U_ID);

        case eROUTINGLINK:
            return (pid < PROPID_L_GATES_DN);

        case eCOMPUTER:
			//
			// ISSUE: ??
			//
            return false;

		default:
            ASSERT(0);
            //
            // Other objects (like CNs) should have the same properties under NT4 or 
            // Win 2K
            //
            return false;
    }
}


bool 
CDSClientProvider::IsNt4Property(
	IN PROPID pid
	)
/*++

Routine Description:
	Check if the property is NT4 prop 

Arguments:
	pid - prop id

Return Value
	true if prop is NT4 prop, false if not
--*/
{
	if(((pid > PROPID_Q_BASE) && (pid < PROPID_Q_NT4ID))			||  /* eQUEUE */
       ((pid > PPROPID_Q_BASE) && (pid < PROPID_Q_OBJ_SECURITY))	||  /* eQUEUE */
       ((pid > PROPID_QM_BASE) && (pid < PROPID_QM_FULL_PATH))		||  /* eMACHINE */
       ((pid > PPROPID_QM_BASE) && (pid <= PROPID_QM_ENCRYPT_PK))	||	/* eMACHINE */
       ((pid > PROPID_S_BASE) && (pid < PROPID_S_FULL_NAME))		||	/* eSITE */
       ((pid > PPROPID_S_BASE) && (pid <= PROPID_S_PSC_SIGNPK))		||	/* eSITE */
       ((pid > PROPID_E_BASE) && (pid < PROPID_E_NT4ID))			||	/* eENTERPRISE */ 
       ((pid > PPROPID_E_BASE) && (pid <= PROPID_E_SECURITY))		||	/* eENTERPRISE */
       ((pid > PROPID_U_BASE) && (pid <= PROPID_U_ID))				||	/* eUSER */
	   ((pid > PROPID_L_BASE) && (pid < PROPID_L_GATES_DN)))			/* eROUTINGLINK */
	{
		return true;
	}

	return false;
}


bool 
CDSClientProvider::IsNt5ProperyOnly(
	IN AD_OBJECT eObject, 
	IN PROPID pid
	)
/*++

Routine Description:
	Check if the property is NT5 only prop 

Arguments:
	eObject - object type
	pid - prop id

Return Value
	true if prop is NT5 only prop, false if not
--*/
{
	//
	// Should call this function after validate this is not NT4 props
	// If we will change this assumption should convert the ASSERT into the function code
	//

	DBG_USED(eObject);
	ASSERT(!IsNt4Property(eObject, pid));

    const PropTranslation *pTranslate;
    if(!g_PropDictionary.Lookup(pid, pTranslate))
    {
		//
		// If it is not found in the dictionary, we have no action for it
		// so we must use NT5 prop.
		//
		return true;
    }
	
	if((pid == PROPID_QM_SITE_IDS) && (ADGetEnterprise() == eAD))
	{
		//
		// Special case for PROPID_QM_SITE_IDS in eAD env
		// we dont want to convert this props.
		// so we return that prop as NT5 property only
		// this will cause that NT5 props will not be converted
		//
		return true;
	}

	//
	// If the action says it is only NT5 then return true
	// else we have an action for this property
	//
	return (pTranslate->Action == taOnlyNT5);
}


bool 
CDSClientProvider::IsDefaultProperties(
    IN  const DWORD   cp,
    IN  const PROPID  aProp[]
    )
/*++

Routine Description:
	Check if there are default properties 

Arguments:
	cp - number of properties
	aProp - properties

Return Value
	true if there is default prop, false if not
--*/
{
    for (DWORD i = 0; i < cp; ++i)
	{
		if(IsDefaultProperty(aProp[i]))
		{
			//
			// We found a default prop
			//
			return true;
		}
	}

    return false;
}


bool 
CDSClientProvider::IsDefaultProperty(
    IN  const PROPID  Prop
    )
/*++

Routine Description:
	Check if the property is default property 

Arguments:
	Prop - prop id

Return Value
	true if the prop is default prop, false if not
--*/
{
	const PropTranslation *pTranslate;

	if((g_PropDictionary.Lookup(Prop, pTranslate)) &&	// found prop translation info
	   (pTranslate->Action == taUseDefault))			// prop action is taUseDefault
	{
		//
		// We found the prop translation info
		// the prop action is taUseDefault
		//
		return true;
	}
    return false;
}


bool 
CDSClientProvider::IsKeyProperty(
    IN  const DWORD   cp,
    IN  const PROPID  aProp[]
    )
/*++

Routine Description:
	Check if we have key property 
	PROPID_QM_ENCRYPT_PK or PROPID_QM_SIGN_PK

Arguments:
	cp - number of properties
	aProp - properties

Return Value
	true if we found key prop, false if not
--*/
{
    for (DWORD i = 0; i < cp; ++i)
	{
		if((aProp[i] == PROPID_QM_ENCRYPT_PK) || (aProp[i] == PROPID_QM_SIGN_PK))
		{
			ASSERT(("Currently Key Property must be only 1 property", cp == 1));
	        return true;
		}
	}

    return false;
}


bool 
CDSClientProvider::IsEIDProperty(
    IN  const DWORD   cp,
    IN  const PROPID  aProp[]
    )
/*++

Routine Description:
	Check if we have PROPID_E_ID 

Arguments:
	cp - number of properties
	aProp - properties

Return Value
	true if we found PROPID_E_ID, false if not
--*/
{
    for (DWORD i = 0; i < cp; ++i)
	{
		if(aProp[i] == PROPID_E_ID)
	        return true;
	}

    return false;
}


bool 
CDSClientProvider::IsExProperty(
    IN  const DWORD   cp,
    IN  const PROPID  aProp[]
    )
/*++

Routine Description:
	Check if we have Ex property
	PROPID_Q_OBJ_SECURITY or PROPID_QM_OBJ_SECURITY or
	PROPID_QM_ENCRYPT_PKS or PROPID_QM_SIGN_PKS

Arguments:
	cp - number of properties
	aProp - properties

Return Value
	true if we found Ex property, false if not
--*/
{
    for (DWORD i = 0; i < cp; ++i)
	{
		if((aProp[i] == PROPID_Q_OBJ_SECURITY) || (aProp[i] == PROPID_QM_OBJ_SECURITY) ||
		   (aProp[i] == PROPID_QM_ENCRYPT_PKS) || (aProp[i] == PROPID_QM_SIGN_PKS))
		{
			ASSERT(("Currently Ex support only 1 property", cp == 1));
	        return true;
		}
	}

    return false;
}


bool 
CDSClientProvider::FoundSiteIdsConvertedProps(
    IN  const DWORD   cp,
    IN  const PROPID  aProp[]
    )
/*++

Routine Description:
	Check if we have already PROPID_QM_SITE_IDS converted props

Arguments:
	cp - number of properties
	aProp - properties

Return Value
	true if we found PROPID_QM_SITE_IDS converted props, false if not
--*/
{
    for (DWORD i = 0; i < cp; ++i)
	{
		if((aProp[i] == PROPID_QM_SITE_ID) ||
		   (aProp[i] == PROPID_QM_ADDRESS) ||
		   (aProp[i] == PROPID_QM_CNS))

		{
			//
			// Found PROPID_QM_SITE_IDS converted props
			//
			return true;
		}
	}

    return false;
}


bool 
CDSClientProvider::IsPropBufferAllocated(
    IN  const PROPVARIANT&    PropVar
	)
/*++

Routine Description:
	Check if prop var was allocated.
	If more VT_* types are being added we need to update the list
	of allocated vt types

Arguments:
	PropVar - PROPVARIANT

Return Value
	true if buffer for PropVar was allocated, false otherwise
--*/
{
    switch (PropVar.vt)
    {
		//
		// All allocated vt types
		//
        case VT_CLSID:
        case VT_CLSID|VT_VECTOR:
        case VT_LPWSTR:
        case VT_LPWSTR|VT_VECTOR:
		case VT_BLOB:
        case VT_UI1|VT_VECTOR:
        case VT_UI4|VT_VECTOR:
			return true;

        default:
            return false;
    }
}


//
// Query related functions
//

bool 
CDSClientProvider::CheckRestriction(
    IN  const MQRESTRICTION* pRestriction
    )
/*++

Routine Description:
    Check restriction.
	Currently all restrictions must be NT4 props.
	We can not have default props as a restriction

Arguments:
	pRestriction - query restriction

Return Value
	true if pRestriction is ok, false otherwise
--*/
{
	if(pRestriction == NULL)
		return true;

	for(DWORD i = 0; i < pRestriction->cRes; ++i)
	{
		if(!IsNt4Property(pRestriction->paPropRes[i].prop))
		{
			//
			// Found non NT4 prop
			//
			return false;
		}
	}
	return true;
}


bool 
CDSClientProvider::CheckSort(
    IN  const MQSORTSET* pSort
    )
/*++

Routine Description:
    Check sort set.
	Currently all sort keys must be NT4 props.
	We can not have default props as a sort key

Arguments:
	pSort - how to sort the results

Return Value
	true if pSort is ok, false otherwise
--*/
{
	if(pSort == NULL)
		return true;

	for(DWORD i = 0; i < pSort->cCol; ++i)
	{
		if(!IsNt4Property(pSort->aCol[i].propColumn))
		{
			//
			// Found non NT4 prop
			//
			return false;
		}
	}
	return true;
}


bool 
CDSClientProvider::CheckDefaultColumns(
    IN  const MQCOLUMNSET* pColumns,
	OUT bool* pfDefaultProp
    )
/*++

Routine Description:
    Check if Columns has default props.
	It also check that all other props are NT4 props

Arguments:
	pColumns - result columns
	pfDefaultProp - flag that indicate if there are default props

Return Value
	true if pColumns has only NT4 props or default props, false otherwise
--*/
{
	*pfDefaultProp = false;
	if(pColumns == NULL)
		return true;

	for(DWORD i = 0; i < pColumns->cCol; ++i)
	{
		if(!IsNt4Property(pColumns->aCol[i]))
		{
			const PropTranslation *pTranslate;
			if((g_PropDictionary.Lookup(pColumns->aCol[i], pTranslate)) &&	// found prop translation info
			   (pTranslate->Action == taUseDefault))	// prop action is taUseDefault
			{
				*pfDefaultProp = true;
				continue;
			}

			//
			// Column is not NT4 and not default
			//
			ASSERT(("Column must be either NT4 or default prop", 0));
			return false;
		}
	}
	return true;
}


bool 
CDSClientProvider::IsNT4Columns(
    IN  const MQCOLUMNSET*      pColumns
    )
/*++

Routine Description:
    Check if Columns has only NT4 props.

Arguments:
	pColumns - result columns

Return Value
	true if pColumns has only NT4 props, false otherwise
--*/
{
	for(DWORD i = 0; i < pColumns->cCol; ++i)
	{
		if(!IsNt4Property(pColumns->aCol[i]))
			return false;
	}
	return true;
}


void CDSClientProvider::InitPropertyTranslationMap()
/*++

Routine Description:
	Initialize Prop translation map (g_PropDictionary)

Arguments:
	None

Return Value
	None
--*/
{
    //
    // Populate  g_PropDictionary
    //
	ASSERT(TABLE_SIZE(PropTranslateInfo) == cPropTranslateInfo);

    const PropTranslation* pProperty = PropTranslateInfo;
    for (DWORD i = 0; i < TABLE_SIZE(PropTranslateInfo); i++, pProperty++)
    {
        g_PropDictionary.SetAt(pProperty->propidNT5, pProperty);
    }
}


//
// Convert and reconstruct functions
//

//
// Max extra prop needed
// currently only for PROPID_QM_SITE_IDS we will need 2 extra props
//
const DWORD xMaxExtraProp = 2;

void 
CDSClientProvider::PrepareNewProps(
    IN  AD_OBJECT     eObject,
    IN  const DWORD   cp,
    IN  const PROPID  aProp[],
    IN  const PROPVARIANT apVar[],
    OUT PropInfo    pPropInfo[],
    OUT DWORD*		pcpNew,
    OUT PROPID**	paPropNew,
    OUT PROPVARIANT** papVarNew
    )
/*++

Routine Description:
	Prepare a new set of properties for get* operations.
    replaces NT5 props with the corresponding NT4 props 
	and eliminate default props.
	This function is call to convert 
	mixed props = all NT5 props has a convertion operation

Arguments:
	eObject - object type
	cp - number of properties
	aProp - properties
	apVar - property values
	pPropInfo - Property info that will be used for reconstruct apVar[] from apVarNew[] 
	pcpNew - pointer to number of new properties
	paPropNew - pointer to new properties
	papVarNew - pointer to new property values

Return Value
	None.

--*/
{
    //
    // Alloc place for the new properties 
    //
    AP<PROPVARIANT> pTempPropVars = new PROPVARIANT[cp + xMaxExtraProp];
    AP<PROPID> pTempPropIDs = new PROPID[cp + xMaxExtraProp];
    DWORD cTempProps = 0;

    for (DWORD i = 0; i < cp; ++i)
    {
		if(IsNt4Property(eObject, aProp[i]))
		{
			//
			// NT4 original property
			// only put it in the NewProp array.
			//
			pPropInfo[i].Action = paAssign;
			pPropInfo[i].Index = cTempProps;
			pTempPropIDs[cTempProps] = aProp[i];
			pTempPropVars[cTempProps] = apVar[i];
			cTempProps++;
			continue;
		}

		const PropTranslation *pTranslate;
		if(!g_PropDictionary.Lookup(aProp[i], pTranslate))	// Prop was not foumd in g_PropDictionary
        {
			//
			// We call this function only when every NT5 props has an action
			// so it must be found in g_PropDictionary 
			//
            ASSERT(("Must find the property in the translation table", 0));
        }

        //
        // Check what we need to do with this property
        //
        switch (pTranslate->Action)
        {
			case taUseDefault:
                ASSERT(pTranslate->pvarDefaultValue);
				pPropInfo[i].Action = paUseDefault;
				pPropInfo[i].Index = cp + xMaxExtraProp;   // ilegall index, end of aProp buff
				break;
				
			case taReplace:
				{
					ASSERT(pTranslate->propidNT4 != 0);

					ASSERT(pTranslate->SetPropertyHandleNT5);

					pPropInfo[i].Action = paTranslate;

					if(aProp[i] == PROPID_QM_SITE_IDS)
					{
						//
						// Handle PROPID_QM_SITE_IDS as special case
						// need PROPID_QM_SITE_ID, PROPID_QM_ADDRESS, PROPID_QM_CNS
						//
						pPropInfo[i].Index = cTempProps;

						ASSERT(pTranslate->propidNT4 == PROPID_QM_SITE_ID);
						pTempPropIDs[cTempProps] = PROPID_QM_SITE_ID;
						pTempPropIDs[cTempProps + 1] = PROPID_QM_ADDRESS;
						pTempPropIDs[cTempProps + 2] = PROPID_QM_CNS;


						ASSERT(apVar[i].vt == VT_NULL);
						pTempPropVars[cTempProps].vt = VT_NULL;
						pTempPropVars[cTempProps + 1].vt = VT_NULL;
						pTempPropVars[cTempProps + 2].vt = VT_NULL;

						cTempProps += 3;
						break;
					}
					//
					// check if the replacing property already exist.
					// this is when several NT5 props map to the same NT4 prop (like in QM_SERVICE)
					//
					bool fFoundReplacingProp = false;
					for (DWORD j = 0; j < cTempProps; j++)
					{
						if (pTempPropIDs[j] == pTranslate->propidNT4)
						{
							//
							// the replacing prop is already in the props, exit loop.
							//
							pPropInfo[i].Index = j;
							fFoundReplacingProp = true;
						}
					}

					if(fFoundReplacingProp)
						break;

					//
					// generate replacing property if not generated yet
					//
					pPropInfo[i].Index = cTempProps;
					pTempPropIDs[cTempProps] = pTranslate->propidNT4;

					//
					// We assume no buffer was allocated, 
					//
					ASSERT(!IsPropBufferAllocated(apVar[i]));
					pTempPropVars[cTempProps].vt = VT_NULL;

					cTempProps++;
				}
				break;

			case taReplaceAssign:
				{
					ASSERT(pTranslate->propidNT4 != 0);

					pPropInfo[i].Action = paAssign;

					//
					// check if the replacing property already exist.
					// this is when several NT5 props map to the same NT4 prop (like in QM_SERVICE)
					//
					bool fFoundReplacingProp = false;
					for (DWORD j = 0; j < cTempProps; j++)
					{
						if (pTempPropIDs[j] == pTranslate->propidNT4)
						{
							//
							// the replacing prop is already in the props, exit loop.
							//
							pPropInfo[i].Index = j;
							fFoundReplacingProp = true;
						}
					}

					if(fFoundReplacingProp)
						break;

					//
					// generate replacing property if not generated yet
					//
					pPropInfo[i].Index = cTempProps;
					pTempPropIDs[cTempProps] = pTranslate->propidNT4;
					pTempPropVars[cTempProps] = apVar[i];
					cTempProps++;
				}
				break;

			case taOnlyNT5:
				ASSERT(("Should not get here in case of property is Only NT5", 0));
				break;

			default:
				ASSERT(0);
				break;
		}

	}

	ASSERT(cTempProps <= (cp + xMaxExtraProp));

    //
    // return values
    //
    *pcpNew = cTempProps;
    *paPropNew = pTempPropIDs.detach();
	*papVarNew = pTempPropVars.detach();
}


void 
CDSClientProvider::PrepareReplaceProps(
    IN  AD_OBJECT     eObject,
    IN  const DWORD   cp,
    IN  const PROPID  aProp[],
    OUT PropInfo    pPropInfo[],
    OUT DWORD*		pcpNew,
    OUT PROPID**	paPropNew
    )
/*++

Routine Description:
	Prepare a new set of properties for lookup operations.
	This function support only in NT4 props or NT5 props
	with translation to NT4 props.

Arguments:
	eObject - object type
	cp - number of properties
	aProp - properties
	pPropInfo - Property info that will be used for reconstruct apVar[] from apVarNew[] 
	pcpNew - pointer to number of new properties
	paPropNew - pointer to new properties

Return Value
	None.

--*/
{
    //
    // Alloc place for the new properties 
    //
    AP<PROPID> pTempPropIDs = new PROPID[cp + xMaxExtraProp];
    DWORD cTempProps = 0;

    for (DWORD i = 0; i < cp; ++i)
    {

		if(IsNt4Property(eObject, aProp[i]))
		{
			//
			// NT4 original property
			// only put it in the NewProp array.
			//
			pPropInfo[i].Action = paAssign;
			pPropInfo[i].Index = cTempProps;
			pTempPropIDs[cTempProps] = aProp[i];
			cTempProps++;
			continue;
		}

		const PropTranslation *pTranslate;
		if((!g_PropDictionary.Lookup(aProp[i], pTranslate)) ||	// Prop was not foumd in g_PropDictionary
		   (pTranslate->Action != taReplace))	// Prop action is not taReplace
        {
			ASSERT(("Should have only taReplace props", 0));
        }

		ASSERT(pTranslate->propidNT4 != 0);

		ASSERT(pTranslate->SetPropertyHandleNT5);

		pPropInfo[i].Action = paTranslate;

		if(aProp[i] == PROPID_QM_SITE_IDS)
		{
			//
			// Handle PROPID_QM_SITE_IDS as special case
			// need PROPID_QM_SITE_ID, PROPID_QM_ADDRESS, PROPID_QM_CNS
			//
			ASSERT(!FoundSiteIdsConvertedProps(cTempProps, pTempPropIDs));

			pPropInfo[i].Index = cTempProps;

			ASSERT(pTranslate->propidNT4 == PROPID_QM_SITE_ID);
			pTempPropIDs[cTempProps] = PROPID_QM_SITE_ID;
			pTempPropIDs[cTempProps + 1] = PROPID_QM_ADDRESS;
			pTempPropIDs[cTempProps + 2] = PROPID_QM_CNS;

			cTempProps += 3;
			continue;
		}

		//
		// check if the replacing property already exist.
		// this is when several NT5 props map to the same NT4 prop (like in QM_SERVICE)
		//
		bool fFoundReplacingProp = false;
		for (DWORD j = 0; j < cTempProps; j++)
		{
			if (pTempPropIDs[j] == pTranslate->propidNT4)
			{
				//
				// the replacing prop is already in the props, exit loop.
				//
				pPropInfo[i].Index = j;
				fFoundReplacingProp = true;
			}
		}

		if(fFoundReplacingProp)
			continue;

		//
		// generate replacing property if not generated yet
		//
		pPropInfo[i].Index = cTempProps;
		pTempPropIDs[cTempProps] = pTranslate->propidNT4;
		cTempProps++;
	}

	ASSERT(cTempProps <= (cp + xMaxExtraProp));

    //
    // return values
    //
    *pcpNew = cTempProps;
    *paPropNew = pTempPropIDs.detach();
}


bool 
CDSClientProvider::PrepareAllLinksProps(
    IN  const MQCOLUMNSET* pColumns,
    OUT DWORD*		pcpNew,
    OUT PROPID**	paPropNew,
    OUT DWORD*		pLGatesIndex,
    OUT DWORD*		pNeg1NewIndex,
    OUT DWORD*		pNeg2NewIndex
	)
/*++

Routine Description:
	Prepare props and some indexs for QueryAllLinks()
    this will remove PROPID_L_GATES from props
	and get PROPID_L_GATES, PROPID_L_NEIGHBOR1, PROPID_L_NEIGHBOR2
	for reconstructing the original props (calculating PROPID_L_GATES)
	see CAllLinksQueryHandle class for details.


Arguments:
	pColumns - result columns
	pcpNew - pointer to number of new properties
	paPropNew - pointer to new properties
	pLGatesIndex - PROPID_L_GATES index in original props array
	pNeg1NewIndex - PROPID_L_NEIGHBOR1 index in new props array
	pNeg1NewIndex - PROPID_L_NEIGHBOR2 index in new props array

Return Value
	true if pColumns is ok for QueryAllLinks, false otherwise
--*/
{
	if(pColumns == NULL)
		return false;

    //
    // Alloc place for the new properties 
    //
    AP<PROPID> pTempPropIDs = new PROPID[pColumns->cCol];
    DWORD cTempProps = 0;

	//
	// Counter for PROPID_L_GATES, PROPID_L_NEIGHBOR1, PROPID_L_NEIGHBOR2
	// that must be found in pColumns
	//
	DWORD cFoundProps = 0;

	for(DWORD i = 0; i < pColumns->cCol; ++i)
	{
		switch (pColumns->aCol[i])
		{
	        case PROPID_L_GATES:
				*pLGatesIndex = i;
				cFoundProps++;
				break;

			case PROPID_L_NEIGHBOR1:
				*pNeg1NewIndex = cTempProps;
				cFoundProps++;
				pTempPropIDs[cTempProps] = pColumns->aCol[i];
				cTempProps++;
				break;

			case PROPID_L_NEIGHBOR2:
				*pNeg2NewIndex = cTempProps;
				cFoundProps++;
				pTempPropIDs[cTempProps] = pColumns->aCol[i];
				cTempProps++;
				break;

			default:
				//
				// All other properties must be NT4 props
				//
				ASSERT(IsNt4Property(eROUTINGLINK, pColumns->aCol[i]));
				pTempPropIDs[cTempProps] = pColumns->aCol[i];
				cTempProps++;
				break;
		}
	}

	ASSERT(cFoundProps == 3);
	ASSERT(cTempProps == (pColumns->cCol - 1));

    //
    // return values
    //
    *pcpNew = cTempProps;
    *paPropNew = pTempPropIDs.detach();
	return true;
}


void 
CDSClientProvider::EliminateDefaultProps(
    IN  const DWORD   cp,
    IN  const PROPID  aProp[],
    IN  const PROPVARIANT apVar[],
    OUT PropInfo    pPropInfo[],
    OUT DWORD*		pcpNew,
    OUT PROPID**	paPropNew,
    OUT PROPVARIANT** papVarNew
    )
/*++

Routine Description:
	Eliminate the default properties from the properties for a get operation
	and create a new set of properties.

Arguments:
	cp - number of properties
	aProp - properties
	apVar - property values
	pPropInfo - Property info that will be used for reconstruct apVar[] from apVarNew[] 
	pcpNew - pointer to number of new properties
	paPropNew - pointer to new properties
	papVarNew - pointer to new property values

Return Value
	None.

--*/
{
    //
    // Alloc place for the new properties 
    //
    AP<PROPVARIANT> pTempPropVars = new PROPVARIANT[cp];
    AP<PROPID> pTempPropIDs = new PROPID[cp];
    DWORD cTempProps = 0;

    for (DWORD i = 0; i < cp; ++i)
    {
		const PropTranslation *pTranslate;
		if((g_PropDictionary.Lookup(aProp[i], pTranslate)) &&	// found prop translation info
		   (pTranslate->Action == taUseDefault))	// prop action is taUseDefault
        {
			//
			// Dont include the UseDefault properties
			//

            ASSERT(pTranslate->pvarDefaultValue);
			pPropInfo[i].Action = paUseDefault;
			pPropInfo[i].Index = cp;   // ilegall index	, end of aProp buff
			continue;
        }

		pPropInfo[i].Action = paAssign;
		pPropInfo[i].Index = cTempProps;
		pTempPropIDs[cTempProps] = aProp[i];
		pTempPropVars[cTempProps] = apVar[i];
		cTempProps++;
	}

	ASSERT(cTempProps <= cp);

    //
    // return values
    //
    *pcpNew = cTempProps;
    *paPropNew = pTempPropIDs.detach();
	*papVarNew = pTempPropVars.detach();
}


void 
CDSClientProvider::EliminateDefaultProps(
    IN  const DWORD   cp,
    IN  const PROPID  aProp[],
    OUT PropInfo    pPropInfo[],
    OUT DWORD*		pcpNew,
    OUT PROPID**	paPropNew
    )
/*++

Routine Description:
	Eliminate the default properties from the properties for a lookup operation
	and create a new set of properties.

Arguments:
	cp - number of properties
	aProp - properties
	pPropInfo - Property info that will be used for reconstruct apVar[] from apVarNew[] 
	pcpNew - pointer to number of new properties
	paPropNew - pointer to new properties

Return Value
	None.

--*/
{
    //
    // Alloc place for the new properties 
    //
    AP<PROPID> pTempPropIDs = new PROPID[cp];
    DWORD cTempProps = 0;

    for (DWORD i = 0; i < cp; ++i)
    {
		const PropTranslation *pTranslate;
		if((g_PropDictionary.Lookup(aProp[i], pTranslate)) &&	// found prop translation info
		   (pTranslate->Action == taUseDefault))	// prop action is taUseDefault
        {
			//
			// Dont include the UseDefault properties
			//

            ASSERT(pTranslate->pvarDefaultValue);
			pPropInfo[i].Action = paUseDefault;
			pPropInfo[i].Index = cp;   // ilegall index, end of aProp buff
			continue;
        }

		pPropInfo[i].Action = paAssign;
		pPropInfo[i].Index = cTempProps;
		pTempPropIDs[cTempProps] = aProp[i];
		cTempProps++;
	}

	ASSERT(cTempProps <= cp);

    //
    // return values
    //
    *pcpNew = cTempProps;
    *paPropNew = pTempPropIDs.detach();
}


void 
CDSClientProvider::ReconstructProps(
    IN  LPCWSTR       pwcsObjectName,
    IN  const GUID*   pguidObject,
    IN  const DWORD   cpNew,
    IN  const PROPID  aPropNew[],
    IN  const PROPVARIANT   apVarNew[],
    IN  const PropInfo pPropInfo[],
    IN  const DWORD   cp,
    IN  const PROPID  aProp[],
    IN OUT PROPVARIANT   apVar[]
    )
/*++

Routine Description:
	Reconstruct the original props from the new props values.
	this function is used by get operation, after getting the new props from AD.

Arguments:
	pwcsObjectName - MSMQ object name
	pguidObject - the unique id of the object
	cpNew - number of new properties
	aPropNew - new properties
	apVarNew - new property values
	pPropInfo - Property info that will be used for reconstruct apVar[] from apVarNew[] 
	cp - number of properties
	aProp - properties
	apVar - property values

Return Value
	None.

--*/
{
    for (DWORD i = 0; i < cp; ++i)
    {
		HRESULT hr;
        switch (pPropInfo[i].Action)
        {
	        case paAssign:
				//
				// Simple assign from the correct index
				//
				apVar[i] = apVarNew[pPropInfo[i].Index];
				break;

	        case paUseDefault:
				{
					if(aProp[i] == PROPID_S_FOREIGN)
					{
						//
						// Special case for PROPID_S_FOREIGN
						// When reconstructing properties
						//
						GetSiteForeignProperty(
							pwcsObjectName,
							pguidObject,
							aProp[i], 
							&apVar[i]
							);

						break;
					}
					
					//
					// Copy default value
					//
					const PropTranslation *pTranslate;
					if(!g_PropDictionary.Lookup(aProp[i], pTranslate))
					{
						ASSERT(("Must find the property in the translation table", 0));
					}

					ASSERT(pTranslate->pvarDefaultValue);

					hr = CopyDefaultValue(
							   pTranslate->pvarDefaultValue,
							   &(apVar[i])
							   );

					if(FAILED(hr))
					{
						ASSERT(("Failed to copy default value", 0));
					}
				}
				break;

	        case paTranslate:
				//
				// Translate the value to NT5 prop
				//
				{
					const PropTranslation *pTranslate;
					if(!g_PropDictionary.Lookup(aProp[i], pTranslate))
					{
						ASSERT(("Must find the property in the translation table", 0));
					}

					ASSERT(pTranslate->propidNT4 == aPropNew[pPropInfo[i].Index]);
					ASSERT(pTranslate->SetPropertyHandleNT5);

					hr = pTranslate->SetPropertyHandleNT5(
										cpNew,
										aPropNew,
										apVarNew,
										pPropInfo[i].Index,
										&apVar[i]
										);
					if (FAILED(hr))
					{
						ASSERT(("Failed to set NT5 property value", 0));
					}
				}
				break;

			default:
				ASSERT(0);
				break;
		}	
	}
}


void 
CDSClientProvider::ConvertToNT4Props(
    IN  AD_OBJECT     eObject,
    IN  const DWORD   cp,
    IN  const PROPID  aProp[],
    IN  const PROPVARIANT apVar[],
    OUT DWORD*		pcpNew,
    OUT PROPID**	paPropNew,
	OUT PROPVARIANT** papVarNew
    )
/*++

Routine Description:
	Prepare a new set of properties for set*\create* operations
    translate NT5 props to the corresponding NT4 props 
	and eliminate default props.
	This function is call to convert 
	mixed props = all NT5 props has a convertion operation

Arguments:
	eObject - object type
	cp - number of properties
	aProp - properties
	apVar - property values
	pcpNew - pointer to number of new properties
	paPropNew - pointer to new properties
	papVarNew - pointer to new property values

Return Value
	None.

--*/
{
    //
    // Alloc place for the new properties 
    //
    AP<PROPVARIANT> pTempPropVars = new PROPVARIANT[cp];
    AP<PROPID> pTempPropIDs = new PROPID[cp];
    DWORD cTempProps = 0;

    for (DWORD i = 0; i < cp; ++i)
    {

		if(IsNt4Property(eObject, aProp[i]))
		{
			//
			// NT4 original property
			// only put it in the NT4 array.
			//
			pTempPropIDs[cTempProps] = aProp[i];
			pTempPropVars[cTempProps] = apVar[i];
			cTempProps++;
			continue;
		}

		const PropTranslation *pTranslate;
		if(!g_PropDictionary.Lookup(aProp[i], pTranslate))	// Prop was not foumd in g_PropDictionary
        {
			//
			// We call this function only when every NT5 props has an action
			// so it must be found in g_PropDictionary 
			//
            ASSERT(("Must find the property in the translation table", 0));
        }

        //
        // Check what we need to do with this property
        //
        switch (pTranslate->Action)
        {
			case taUseDefault:
				//
				// Do nothing - skip this property
				//

				ASSERT(pTranslate->pvarDefaultValue);

				//
				// If UseDefault only checks that the user did not try to set other value
				// This check should done earlier by CheckProperties
				// So only assert here
				//
				ASSERT(CompareVarValue(&apVar[i], pTranslate->pvarDefaultValue));
				break;
				
			case taReplace:
				{
					ASSERT(pTranslate->propidNT4 != 0);
					ASSERT(pTranslate->SetPropertyHandleNT4);

					//
					// check if the replacing property already exist.
					// this is when several NT5 props map to the same NT4 prop (like in QM_SERVICE)
					//
					HRESULT hr;
					bool fFoundReplacingProp = false;
					for (DWORD j = 0; j < cTempProps; j++)
					{
						if (pTempPropIDs[j] == pTranslate->propidNT4)
						{
							//
							// the replacing prop is already in the props, exit loop.
							//
							fFoundReplacingProp = true;

							#ifdef _DEBUG
								//
								// Currently SetPropertyHandleNT4 do not
								// Allocate new buffer so no need to free
								//
								PROPVARIANT TempPropVar;
								hr = pTranslate->SetPropertyHandleNT4(
													cp,
													aProp,
													apVar,
													i,
													&TempPropVar
													);

								if (FAILED(hr))
								{
									ASSERT(("Failed to set NT4 property value", 0));
								}

								ASSERT(CompareVarValue(&TempPropVar, &pTempPropVars[j]));
							#endif
						}
					}

					if(fFoundReplacingProp)
						break;

					//
					// generate replacing property if not generated yet
					//
					hr = pTranslate->SetPropertyHandleNT4(
										cp,
										aProp,
										apVar,
										i,
										&pTempPropVars[cTempProps]
										);
					if (FAILED(hr))
					{
						ASSERT(("Failed to set NT4 property value", 0));
					}

					pTempPropIDs[cTempProps] = pTranslate->propidNT4;
					cTempProps++;
				}
				break;

			case taReplaceAssign:
				{
					ASSERT(pTranslate->propidNT4 != 0);

					//
					// check if the replacing property already exist.
					// this is when several NT5 props map to the same NT4 prop (like in QM_SERVICE)
					//
					bool fFoundReplacingProp = false;
					for (DWORD j = 0; j < cTempProps; j++)
					{
						if (pTempPropIDs[j] == pTranslate->propidNT4)
						{
							//
							// the replacing prop is already in the props, exit loop.
							//
							fFoundReplacingProp = true;
							ASSERT(CompareVarValue(&apVar[i], &pTempPropVars[j]));
						}
					}

					if(fFoundReplacingProp)
						break;

					pTempPropIDs[cTempProps] = pTranslate->propidNT4;
					pTempPropVars[cTempProps] = apVar[i];
					cTempProps++;
				}
				break;

			case taOnlyNT5:
				//
				// In this case we should identify earlier that we must have
				// a supporting w2k server and not try to convert all the propertis to 
				// NT4 properties
				//
				ASSERT(("Should not get here in case of property is Only NT5", 0));
				break;

			default:
				ASSERT(0);
				break;
		}

	}

	ASSERT(cTempProps <= cp);

    //
    // return values
    //
    *pcpNew = cTempProps;
    *paPropNew = pTempPropIDs.detach();
	*papVarNew = pTempPropVars.detach();
}


void 
CDSClientProvider::ConvertPropsForGet(
    IN  AD_OBJECT     eObject,
	IN 	PropsType	  PropertiesType,
    IN  const DWORD   cp,
    IN  const PROPID  aProp[],
    IN  const PROPVARIANT apVar[],
    OUT PropInfo    pPropInfo[],
    OUT DWORD*		pcpNew,
    OUT PROPID**	paPropNew,
	OUT PROPVARIANT** papVarNew
    )
/*++

Routine Description:
	Prepare a new set of properties for get* operations

Arguments:
	eObject - object type
	PropertiesType - Properties type
	cp - number of properties
	aProp - properties
	apVar - property values
	pPropInfo - Property info that will be used for reconstruct apVar[] from apVarNew[] 
	pcpNew - pointer to number of new properties
	paPropNew - pointer to new properties
	papVarNew - pointer to new property values

Return Value
	None.

--*/
{
	ASSERT(PropertiesType != ptNT4Props);

	if(PropertiesType == ptForceNT5Props)
	{
		//
		// For NT5 props only eliminate default props
		//

		ASSERT(IsDefaultProperties(cp, aProp));

		EliminateDefaultProps(cp, aProp, apVar, pPropInfo, pcpNew, paPropNew,  papVarNew);   
	}
	else
	{
		//
		// Convert to NT4 properties and eliminate default props
		//

		ASSERT(PropertiesType == ptMixedProps);

		PrepareNewProps(eObject, cp, aProp, apVar, pPropInfo, pcpNew, paPropNew, papVarNew);   
	}
}


void 
CDSClientProvider::ConvertPropsForSet(
    IN  AD_OBJECT     eObject,
	IN 	PropsType	  PropertiesType,
    IN  const DWORD   cp,
    IN  const PROPID  aProp[],
    IN  const PROPVARIANT apVar[],
    OUT DWORD*		pcpNew,
    OUT PROPID**	paPropNew,
	OUT PROPVARIANT** papVarNew
    )
/*++

Routine Description:
	Prepare a new set of properties for set*\create* operations

Arguments:
	eObject - object type
	PropertiesType - Properties type
	cp - number of properties
	aProp - properties
	apVar - property values
	pcpNew - pointer to number of new properties
	paPropNew - pointer to new properties
	papVarNew - pointer to new property values

Return Value
	None.

--*/
{
	ASSERT(PropertiesType != ptNT4Props);

	if(PropertiesType == ptForceNT5Props)
	{
		//
		// For NT5 props only eliminate default props
		//

		ASSERT(IsDefaultProperties(cp, aProp));

		EliminateDefaultPropsForSet(cp, aProp, apVar, pcpNew, paPropNew, papVarNew);   
	}
	else
	{
		//
		// Convert to NT4 properties and eliminate default props
		//

		ASSERT(PropertiesType == ptMixedProps);

		ConvertToNT4Props(eObject, cp, aProp, apVar, pcpNew, paPropNew, papVarNew);   
	}
}


void 
CDSClientProvider::EliminateDefaultPropsForSet(
    IN  const DWORD   cp,
    IN  const PROPID  aProp[],
    IN  const PROPVARIANT apVar[],
    OUT DWORD*		pcpNew,
    OUT PROPID**	paPropNew,
	OUT PROPVARIANT** papVarNew
    )
/*++

Routine Description:
	Eliminate the default properties from the properties for a set/create operation
	and create a new set of properties.

Arguments:
	cp - number of properties
	aProp - properties
	apVar - property values
	pcpNew - pointer to number of new properties
	paPropNew - pointer to new properties
	papVarNew - pointer to new property values

Return Value
	None.

--*/
{
    //
    // Alloc place for the new properties 
    //
    AP<PROPVARIANT> pTempPropVars = new PROPVARIANT[cp];
    AP<PROPID> pTempPropIDs = new PROPID[cp];
    DWORD cTempProps = 0;

    for (DWORD i = 0; i < cp; ++i)
    {
		const PropTranslation *pTranslate;
		if((g_PropDictionary.Lookup(aProp[i], pTranslate)) &&	// found prop translation info
		   (pTranslate->Action == taUseDefault))	// prop action is taUseDefault
        {
			//
			// Dont include the UseDefault properties
			//

            ASSERT(pTranslate->pvarDefaultValue);

			//
			// If UseDefault only checks that the user did not try to set other value
			// This check should done earlier by CheckProperties
			// So only assert here
			//
			ASSERT(CompareVarValue(&apVar[i], pTranslate->pvarDefaultValue));
			continue;
        }

		//
		// For any non default prop, simply copy it to the TempProp array
		//
		pTempPropIDs[cTempProps] = aProp[i];
		pTempPropVars[cTempProps] = apVar[i];
		cTempProps++;
	}

	ASSERT(cTempProps <= cp);

    //
    // return values
    //
    *pcpNew = cTempProps;
    *paPropNew = pTempPropIDs.detach();
	*papVarNew = pTempPropVars.detach();
}


bool 
CDSClientProvider::CompareVarValue(
       IN const MQPROPVARIANT * pvarUser,
       IN const MQPROPVARIANT * pvarValue
       )
/*++

Routine Description:
	Compare values of 2 properties.
	This function can use to verify that property value is equal to its default value
	or to compare between 2 properties.

Arguments:
	pvarUser - pointer to first propvar
	pvarValue - pointer to second propvar

Return Value
	true - if the properties values are equel, false otherwise
--*/
{
    if ( pvarValue == NULL)
    {
        return(false);
    }
    if ( pvarUser->vt != pvarValue->vt )
    {
        return(false);
    }

    switch ( pvarValue->vt)
    {
        case VT_I2:
            return( pvarValue->iVal == pvarUser->iVal);
            break;

        case VT_I4:
            return( pvarValue->lVal == pvarUser->lVal);
            break;

        case VT_UI1:
            return( pvarValue->bVal == pvarUser->bVal);
            break;

        case VT_UI2:
            return( pvarValue->uiVal == pvarUser->uiVal);
            break;

        case VT_UI4:
            return( pvarValue->ulVal == pvarUser->ulVal);
            break;

        case VT_LPWSTR:
            return ( !wcscmp( pvarValue->pwszVal, pvarUser->pwszVal));
            break;

        case VT_BLOB:
            if ( pvarValue->blob.cbSize != pvarUser->blob.cbSize)
            {
                return(false);
            }
            return( !memcmp( pvarValue->blob.pBlobData,
                             pvarUser->blob.pBlobData,
                             pvarUser->blob.cbSize));
            break;

        case VT_CLSID:
            return( !!(*pvarValue->puuid == *pvarUser->puuid));
            break;

        default:
            ASSERT(0);
            return(false);
            break;

    }
}

bool 
CDSClientProvider::IsQueuePathNameDnsProperty(
    IN  const MQCOLUMNSET* pColumns
    )
/*++

Routine Description:
    Check if Columns one of the columns is PROPID_Q_PATHNAME_DNS.

Arguments:
	pColumns - result columns

Return Value
	true if pColumns contains PROPID_Q_PATHNAME_DNS, false otherwise
--*/
{
	if(pColumns == NULL)
		return false;

	for(DWORD i = 0; i < pColumns->cCol; ++i)
	{
		if(pColumns->aCol[i] == PROPID_Q_PATHNAME_DNS)
		{
			return true;
		}
	}
	return false;
}


bool 
CDSClientProvider::IsQueueAdsPathProperty(
    IN  const MQCOLUMNSET* pColumns
    )
/*++

Routine Description:
    Check if Columns one of the columns is PROPID_Q_ADS_PATH.

Arguments:
	pColumns - result columns

Return Value
	true if pColumns contains PROPID_Q_ADS_PATH, false otherwise
--*/
{
	if(pColumns == NULL)
		return false;

	for(DWORD i = 0; i < pColumns->cCol; ++i)
	{
		if(pColumns->aCol[i] == PROPID_Q_ADS_PATH)
		{
			return true;
		}
	}
	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\queryh.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
	hquery.h

Abstract:
	query handle classes, for locate nect of different queries

Author:

    Ilan Herbst		(ilanh)		12-Oct-2000

--*/

#ifndef __AD_QUERYH_H__
#define __AD_QUERYH_H__

#include "cliprov.h"

//-----------------------------------------------------------------------------------
//
//      CBasicQueryHandle
//
//  Virtual class, all query-handle classes are derived from this class.
//
//-----------------------------------------------------------------------------------
class CBasicQueryHandle
{
public:

    CBasicQueryHandle(
           IN  HANDLE  hCursor,
		   IN CDSClientProvider*	pClientProvider
           );

	virtual ~CBasicQueryHandle() {}

	virtual 
	HRESULT 
	LookupNext(
        IN OUT  DWORD*            pdwSize,
        OUT     PROPVARIANT*      pbBuffer
		) = 0;

    HRESULT LookupEnd();

protected:
    HANDLE				m_hCursor;	        // a cursor returned from Locate Begin operation performed on the DS
	CDSClientProvider*  m_pClientProvider;	// pointer to client provider class that implements "raw" LookupNext, LookupEnd
};


inline 
CBasicQueryHandle::CBasicQueryHandle( 
       IN  HANDLE               hCursor,
	   IN CDSClientProvider*	pClientProvider
       ):
	   m_hCursor(hCursor),	
	   m_pClientProvider(pClientProvider)
{
}


inline HRESULT CBasicQueryHandle::LookupEnd()
{
	HRESULT hr = m_pClientProvider->LookupEnd(m_hCursor);
	delete this;
    return(hr);
}


//-----------------------------------------------------------------------------------
//
//      CQueryHandle
//
//  This class is suitable for all queries, where locate next is referred 
//  directly to the DS (i.e. no additional translation or checking is required).
//
//-----------------------------------------------------------------------------------
class CQueryHandle : public CBasicQueryHandle
{
public:

    CQueryHandle( 
           IN  HANDLE  hCursor,
		   IN CDSClientProvider*	pClientProvider
           );

	~CQueryHandle() {}

	virtual 
	HRESULT 
	LookupNext(
            IN OUT  DWORD*            pdwSize,
            OUT     PROPVARIANT*      pbBuffer
			);
};


inline 
CQueryHandle::CQueryHandle( 
		IN  HANDLE               hCursor,
		IN CDSClientProvider*	pClientProvider
		):
		CBasicQueryHandle(hCursor, pClientProvider)
{
}


//-----------------------------------------------------------------------------------
//
//      CBasicLookupQueryHandle
//
//  Virtual class, all advanced query-handle classes are derived from this class.
//  This class implement LookupNext method and force the derived class to implement 
//	FillInOneResponse method
//
//-----------------------------------------------------------------------------------
class CBasicLookupQueryHandle : public CBasicQueryHandle
{
public:
    CBasicLookupQueryHandle(
		IN  HANDLE  hCursor,
		IN CDSClientProvider*	pClientProvider,
		IN ULONG cCol,
		IN ULONG cColNew
		);

	virtual ~CBasicLookupQueryHandle() {}

	virtual 
	HRESULT 
	LookupNext(
        IN OUT  DWORD* pdwSize,
        OUT     PROPVARIANT* pbBuffer
		);

	virtual
	void 
	FillInOneResponse(
		IN const PROPVARIANT*      pPropVar,
		OUT      PROPVARIANT*      pOriginalPropVar
		) = 0;

protected:
    ULONG               m_cCol;			// original number of props
    ULONG               m_cColNew;		// new props count
};


inline
CBasicLookupQueryHandle::CBasicLookupQueryHandle(
	IN  HANDLE  hCursor,
	IN CDSClientProvider*	pClientProvider,
	IN ULONG cCol,
	IN ULONG cColNew
    ) :
	CBasicQueryHandle(hCursor, pClientProvider),
    m_cCol(cCol),
	m_cColNew(cColNew)
{
}

//-----------------------------------------------------------------------------------
//
//      CQueueQueryHandle
//
//  This class is suitable for Queue queries when some of the props are not supported
//  and should be return their default value (PROPID_Q_MULTICAST_ADDRESS) 
//
//-----------------------------------------------------------------------------------
class CQueueQueryHandle : public CBasicLookupQueryHandle
{
public:
    CQueueQueryHandle(
         IN  const MQCOLUMNSET* pColumns,
         IN  HANDLE hCursor,
 		 IN CDSClientProvider* pClientProvider,
		 IN PropInfo* pPropInfo,
		 IN ULONG cColNew
         );

	~CQueueQueryHandle() {}

	virtual
	void 
	FillInOneResponse(
		IN const PROPVARIANT*      pPropVar,
		OUT      PROPVARIANT*      pOriginalPropVar
		);

private:
    AP<PROPID>			m_aCol;			// original propids
	AP<PropInfo>		m_pPropInfo;	// information how to reconstruct original props from the new props
};


inline
CQueueQueryHandle::CQueueQueryHandle(
	IN  const MQCOLUMNSET* pColumns,
	IN  HANDLE hCursor,
	IN CDSClientProvider* pClientProvider,
	IN PropInfo* pPropInfo,
	IN ULONG cColNew
    ) :
	CBasicLookupQueryHandle(
		hCursor, 
		pClientProvider, 
		pColumns->cCol, 
		cColNew
		),
	m_pPropInfo(pPropInfo)
{
    m_aCol = new PROPID[pColumns->cCol];
    memcpy(m_aCol, pColumns->aCol, pColumns->cCol * sizeof(PROPID));
}


//-----------------------------------------------------------------------------------
//
//      CSiteServersQueryHandle
//
//  This class is suitable for Site Servers queries when some of the props are NT5 props
//  that can be translated to NT4 props. (PROPID_QM_SITE_IDS, PROPID_QM_SERVICE_ROUTING)
//
//-----------------------------------------------------------------------------------
class CSiteServersQueryHandle : public CBasicLookupQueryHandle
{
public:
    CSiteServersQueryHandle(
				IN  const MQCOLUMNSET* pColumns,
				IN  const MQCOLUMNSET* pColumnsNew,
				IN  HANDLE hCursor,
				IN CDSClientProvider* pClientProvider,
				IN PropInfo* pPropInfo
                );

	~CSiteServersQueryHandle() {}

	virtual
	void 
	FillInOneResponse(
		IN const PROPVARIANT*      pPropVar,
		OUT      PROPVARIANT*      pOriginalPropVar
		);

private:
    AP<PROPID>			m_aCol;			// original propids
	AP<PropInfo>		m_pPropInfo;	// information how to reconstruct original props from the new props
    AP<PROPID>			m_aColNew;		// new propids
};


inline
CSiteServersQueryHandle::CSiteServersQueryHandle(
	IN  const MQCOLUMNSET* pColumns,
	IN  const MQCOLUMNSET* pColumnsNew,
	IN  HANDLE hCursor,
	IN CDSClientProvider* pClientProvider,
	IN PropInfo* pPropInfo
    ) :
	CBasicLookupQueryHandle(
		hCursor, 
		pClientProvider, 
		pColumns->cCol, 
		pColumnsNew->cCol
		),
	m_pPropInfo(pPropInfo)
{
	m_aCol = new PROPID[pColumns->cCol];
    memcpy(m_aCol, pColumns->aCol, pColumns->cCol * sizeof(PROPID));

    m_aColNew = new PROPID[pColumnsNew->cCol];
    memcpy(m_aColNew, pColumnsNew->aCol, pColumnsNew->cCol * sizeof(PROPID));
}


//-----------------------------------------------------------------------------------
//
//      CAllLinksQueryHandle
//
//  This class is suitable for ALL Links queries when PROPID_L_GATES
//  should handled separatly
//
//-----------------------------------------------------------------------------------
class CAllLinksQueryHandle : public CBasicLookupQueryHandle
{
public:
    CAllLinksQueryHandle(
                 IN HANDLE hCursor,
 			     IN CDSClientProvider* pClientProvider,
                 IN ULONG cCol,
                 IN ULONG cColNew,
				 IN DWORD LGatesIndex,
				 IN	DWORD Neg1NewIndex,
				 IN	DWORD Neg2NewIndex
                 );

	~CAllLinksQueryHandle() {}

	virtual
	void 
	FillInOneResponse(
		IN const PROPVARIANT*      pPropVar,
		OUT      PROPVARIANT*      pOriginalPropVar
		);

	HRESULT
	GetLGates(
		IN const GUID*            pNeighbor1Id,
		IN const GUID*            pNeighbor2Id,
		OUT     PROPVARIANT*      pProvVar
		);

private:
	DWORD				m_LGatesIndex;	// PROPID_L_GATES index in the original props
	DWORD				m_Neg1NewIndex;	// PROPID_L_NEIGHBOR1 index in the new props
	DWORD				m_Neg2NewIndex;	// PROPID_L_NEIGHBOR2 index in the new props
};


inline
CAllLinksQueryHandle::CAllLinksQueryHandle(
	IN HANDLE hCursor,
	IN CDSClientProvider* pClientProvider,
	IN ULONG cCol,
	IN ULONG cColNew,
	IN DWORD LGatesIndex,
	IN	DWORD Neg1NewIndex,
	IN	DWORD Neg2NewIndex
	) :
	CBasicLookupQueryHandle(
		hCursor, 
		pClientProvider, 
		cCol, 
		cColNew
		),
	m_LGatesIndex(LGatesIndex),
	m_Neg1NewIndex(Neg1NewIndex),
	m_Neg2NewIndex(Neg2NewIndex)
{
	ASSERT(m_cColNew == (m_cCol - 1));
	ASSERT(m_LGatesIndex < m_cCol);
	ASSERT(m_Neg1NewIndex < m_cColNew);
	ASSERT(m_Neg2NewIndex < m_cColNew);
}


#endif //__AD_QUERYH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\srvprov.h ===
/*++

Copyright (c) 1995  Microsoft Corporation 

Module Name:
	adprov.h

Abstract:
	Active Directory provider class.

Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __SRVPROV_H__
#define __SRVPROV_H__

#include "baseprov.h"
#include "dsproto.h"
#include "autorel.h"

//-----------------------------------------------------------------------------------
//
//      CDSServerProvider
//
//  encapsulates DS server functionality for ActiveDirectory operations 
//
//-----------------------------------------------------------------------------------
class CDSServerProvider : public  CBaseADProvider
{
public:
    CDSServerProvider();

    ~CDSServerProvider();

    virtual HRESULT CreateObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  LPCWSTR                 pwcsObjectName,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[],
                OUT GUID*                   pObjGuid
                );

    virtual HRESULT DeleteObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  LPCWSTR                 pwcsObjectName
                );

    virtual HRESULT DeleteObjectGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  const GUID*             pguidObject
                );

    virtual HRESULT GetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT PROPVARIANT          apVar[]
                );

    virtual HRESULT GetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  OUT PROPVARIANT         apVar[]
                );

    virtual HRESULT QMGetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded,
                IN  DSQMChallengeResponce_ROUTINE
                                            pfChallengeResponceProc,
                IN  DWORD_PTR               dwContext
                );

    virtual HRESULT SetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                );

    virtual HRESULT SetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                );

    virtual HRESULT QMSetMachineProperties(
                IN  LPCWSTR             pwcsObjectName,
                IN  const DWORD         cp,
                IN  const PROPID        aProp[],
                IN  const PROPVARIANT   apVar[],
                IN  DSQMChallengeResponce_ROUTINE pfSignProc,
                IN  DWORD_PTR           dwContext
                );

    virtual HRESULT Init( 
                IN QMLookForOnlineDS_ROUTINE    pLookDS,
                IN MQGetMQISServer_ROUTINE      pGetServers,
                IN bool                         fSetupMode,
                IN bool                         fQMDll,
                IN NoServerAuth_ROUTINE         pNoServerAuth,
                IN LPCWSTR                      szServerName
                );

    virtual HRESULT SetupInit(
                IN    unsigned char   ucRoll,
                IN    LPWSTR          pwcsPathName,
                IN    const GUID *    pguidMasterId
                );

    virtual HRESULT CreateServersCache();

    virtual HRESULT GetComputerSites(
                IN  LPCWSTR     pwcsComputerName,
                OUT DWORD  *    pdwNumSites,
                OUT GUID **     ppguidSites
                );

    virtual HRESULT RelaxSecurity(
                IN DWORD dwRelaxFlag
                );

    virtual HRESULT BeginDeleteNotification(
                IN  AD_OBJECT               eObject,
                IN LPCWSTR                  pwcsDomainController,
                IN LPCWSTR					pwcsObjectName,
                IN OUT HANDLE   *           phEnum
                );

    virtual HRESULT NotifyDelete(
                IN  HANDLE                  hEnum
                );

    virtual HRESULT EndDeleteNotification(
                IN  HANDLE                  hEnum
                );

    virtual HRESULT QueryMachineQueues(
                IN  LPCWSTR                 pwcsDomainController,
                IN  const GUID *            pguidMachine,
                IN  const MQCOLUMNSET*      pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QuerySiteServers(
                IN  LPCWSTR                 pwcsDomainController,
                IN const GUID *             pguidSite,
                IN AD_SERVER_TYPE           serverType,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryUserCert(
                IN  LPCWSTR                 pwcsDomainController,
                IN const BLOB *             pblobUserSid,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryConnectors(
                IN  LPCWSTR                 pwcsDomainController,
                IN const GUID *             pguidSite,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryForeignSites(
                IN  LPCWSTR                 pwcsDomainController,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryLinks(
                IN  LPCWSTR                 pwcsDomainController,
                IN const GUID *             pguidSite,
                IN eLinkNeighbor            eNeighbor,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryAllLinks(
                IN  LPCWSTR                 pwcsDomainController,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryAllSites(
                IN  LPCWSTR                 pwcsDomainController,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryQueues(
                IN  LPCWSTR                 pwcsDomainController,
                IN  const MQRESTRICTION*    pRestriction,
                IN  const MQCOLUMNSET*      pColumns,
                IN  const MQSORTSET*        pSort,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryResults(
                IN      HANDLE          hEnum,
                IN OUT  DWORD*          pcProps,
                OUT     PROPVARIANT     aPropVar[]
                );

    virtual HRESULT EndQuery(
                IN  HANDLE                  hEnum
                );
    private:

    HRESULT LoadDll();

    DWORD GetMsmq2Object(
                IN  AD_OBJECT               eObject
                ); 

    bool IsPrivateProperties(
                    IN  const DWORD   cp,
                    IN  const PROPID  aProp[]
                    );
    private:

    DSCreateObject_ROUTINE                  m_pfDSCreateObject;
    DSGetObjectProperties_ROUTINE           m_pfDSGetObjectProperties;
    DSSetObjectProperties_ROUTINE           m_pfDSSetObjectProperties;
    DSLookupBegin_ROUTINE                   m_pfDSLookupBegin;
    DSLookupNext_ROUTINE                    m_pfDSLookupNext;
    DSLookupEnd_ROUTINE                     m_pfDSLookupEnd;
    DSInit_ROUTINE                          m_pfDSInit;
    DSGetObjectPropertiesGuid_ROUTINE       m_pfDSGetObjectPropertiesGuid;
    DSSetObjectPropertiesGuid_ROUTINE       m_pfDSSetObjectPropertiesGuid;
    DSQMSetMachineProperties_ROUTINE        m_pfDSQMSetMachineProperties;
    DSCreateServersCache_ROUTINE            m_pfDSCreateServersCache;
    DSQMGetObjectSecurity_ROUTINE           m_pfDSQMGetObjectSecurity;
    DSGetComputerSites_ROUTINE              m_pfDSGetComputerSites;
    DSRelaxSecurity_ROUTINE                 m_pfDSRelaxSecurity;
    DSGetObjectPropertiesEx_ROUTINE         m_pfDSGetObjectPropertiesEx;
    DSGetObjectPropertiesGuidEx_ROUTINE     m_pfDSGetObjectPropertiesGuidEx;

    CAutoFreeLibrary                        m_hLib;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\traninfo.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
	traninfo.h

Abstract:

Author:

    Ilan Herbst		(ilanh)		02-Oct-2000

--*/


#ifndef __AD_TRANINFO_H__
#define __AD_TRANINFO_H__

HRESULT   
CopyDefaultValue(
	IN const MQPROPVARIANT *   pvarDefaultValue,
	OUT MQPROPVARIANT *        pvar
	);


//-----------------------------------------
// Routine to set a property value 
//-----------------------------------------
typedef HRESULT (WINAPI*  SetPropertyValue_HANDLER)(
							 IN ULONG             cProps,
							 IN const PROPID      *rgPropIDs,
							 IN const PROPVARIANT *rgPropVars,
							 IN ULONG             idxProp,
							 OUT PROPVARIANT      *pNewPropVar
							 );

enum TranslateAction
{
    taUseDefault,		// Properties that are not supported, Get will return Default value, Set will check if the prop value equal to the default value
    taReplace,			// There is a replacement NT4 property, need to call a convert function
    taReplaceAssign,	// Special replacement NT4 property, the convertion function is simple assign 
	taOnlyNT5			// property that supported only by NT5 servers
};

//----------------------------------------------------------------
//  PropTranslation
//
//  A structure describing the translation for NT5+ property 
//----------------------------------------------------------------
struct PropTranslation
{
    PROPID						propidNT5;		// PropId entry
    PROPID						propidNT4;		// Replacing NT4 PropId
    VARTYPE						vtMQ;			// the vartype of this property in MQ
    TranslateAction				Action;			// what the translation action for this prop
    SetPropertyValue_HANDLER    SetPropertyHandleNT4;	// The set function for NT4 prop (Set*)
    SetPropertyValue_HANDLER    SetPropertyHandleNT5;	// The set function for NT5 prop (Get*)
    const MQPROPVARIANT*		pvarDefaultValue;   // attribute's default value
};

const DWORD cPropTranslateInfo = 13;
extern PropTranslation   PropTranslateInfo[cPropTranslateInfo];

#endif	 // __AD_TRANINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\wrkgprov.cpp ===
/*++


Copyright (c) 1998  Microsoft Corporation 

Module Name:

    wrkgprov.cpp

Abstract:

	Workgroup mode provider class.

Author:

    ronith

--*/
#include "ds_stdh.h"
#include "wrkgprov.h"
#include "adglbobj.h"
#include "mqlog.h"

static WCHAR *s_FN=L"ad/wrkgprov";

CWorkGroupProvider::CWorkGroupProvider()
/*++
    Abstract:
	Constructor- init pointers

    Parameters:
    none

    Returns:
	none
--*/
{
}
                                                   

CWorkGroupProvider::~CWorkGroupProvider()
/*++
    Abstract:
    destructor

    Parameters:
    none

    Returns:
	none
--*/
{
    //
    //  nothing to do, everthing is auto-pointers
    //
}


HRESULT CWorkGroupProvider::CreateObject(
                IN  AD_OBJECT               /* eObject */,
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN  LPCWSTR                 /* pwcsObjectName */,
                IN  PSECURITY_DESCRIPTOR    /* pSecurityDescriptor */,
                IN  const DWORD             /* cp */,
                IN  const PROPID            /* aProp */[],
                IN  const PROPVARIANT       /* apVar */[],
                OUT GUID*                   /* pObjGuid */
                )
/*++
    Abstract:
    Not supported

    Parameters:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
	PSECURITY_DESCRIPTOR    pSecurityDescriptor - object SD
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values
	GUID*                   pObjGuid - the created object unique id

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::DeleteObject(
                IN  AD_OBJECT               /* eObject */,
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN  LPCWSTR                 /* pwcsObjectName */
                )
/*++
    Abstract:
    Not supported

    Parameters:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::DeleteObjectGuid(
                IN  AD_OBJECT               /* eObject */,
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN  const GUID*             /* pguidObject */
                )
/*++
    Abstract:
    Not supported

    Parameters:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	GUID*                   pguidObject - the unique id of the object

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::GetObjectProperties(
                IN  AD_OBJECT               /* eObject */,
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN  LPCWSTR                 /* pwcsObjectName */,
                IN  const DWORD             /* cp */,
                IN  const PROPID            /* aProp */[],
                IN OUT PROPVARIANT          /* apVar */[]
                )
/*++
    Abstract:
    NotSupported

    Parameters:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::GetObjectPropertiesGuid(
                IN  AD_OBJECT               /* eObject */,
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN  const GUID*             /* pguidObject */,
                IN  const DWORD             /* cp */,
                IN  const PROPID            /* aProp */[],
                IN  OUT PROPVARIANT         /* apVar */[]
                )
/*++
    Abstract:
    Not supported

    Parameters:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	GUID *                  pguidObject -  object unique id
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::QMGetObjectSecurity(
                IN  AD_OBJECT               /* eObject */,
                IN  const GUID*             /* pguidObject */,
                IN  SECURITY_INFORMATION    /* RequestedInformation */,
                IN  PSECURITY_DESCRIPTOR    /* pSecurityDescriptor */,
                IN  DWORD                   /* nLength */,
                IN  LPDWORD                 /* lpnLengthNeeded */,
                IN  DSQMChallengeResponce_ROUTINE
                                            /* pfChallengeResponceProc */,
                IN  DWORD_PTR               /* dwContext */
                )
/*++
    Abstract:
    Not Supported

    Parameters:
    AD_OBJECT               object - object type
    const GUID*             pguidObject - unique id of the object
    SECURITY_INFORMATION    RequestedInformation - what security info is requested
    PSECURITY_DESCRIPTOR    pSecurityDescriptor - SD response buffer
    DWORD                   nLength - length of SD buffer
    LPDWORD                 lpnLengthNeeded
    DSQMChallengeResponce_ROUTINE
                                pfChallengeResponceProc,
    DWORD_PTR               dwContext

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::SetObjectProperties(
                IN  AD_OBJECT               /* eObject */,
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN  LPCWSTR                 /* pwcsObjectName */,
                IN  const DWORD             /* cp */,
                IN  const PROPID            /* aProp */[],
                IN  const PROPVARIANT       /* apVar */[]
                )
/*++
    Abstract:
    Not supported

    Parameters:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::SetObjectPropertiesGuid(
                IN  AD_OBJECT               /* eObject */,
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN  const GUID*             /* pguidObject */,
                IN  const DWORD             /* cp */,
                IN  const PROPID            /* aProp */[],
                IN  const PROPVARIANT       /* apVar */[]
                )
/*++
    Abstract:
    Not supported

    Parameters:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	GUID *                  pguidObject - the object unique id
	const DWORD             cp - number of properties
	const PROPID            aProp - properties
	const PROPVARIANT       apVar - property values

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::QMSetMachineProperties(
                IN  LPCWSTR             /* pwcsObjectName */,
                IN  const DWORD         /* cp */,
                IN  const PROPID        /* aProp */[],
                IN  const PROPVARIANT   /* apVar */[],
                IN  DSQMChallengeResponce_ROUTINE /* pfSignProc */,
                IN  DWORD_PTR           /* dwContext */
                )
/*++
    Abstract:
    Not supported

    Parameters:
    LPCWSTR             pwcsObjectName - object msmq-name
    const DWORD         cp - number of properties to set
    const PROPID        aProp - properties
    const PROPVARIANT   apVar  property values
    DSQMChallengeResponce_ROUTINE pfSignProc - sign routine
    DWORD_PTR           dwContext

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::Init( 
                IN QMLookForOnlineDS_ROUTINE    /* pLookDS */,
                IN MQGetMQISServer_ROUTINE      /* pGetServers */,
                IN bool                         /* fSetupMode */,
                IN bool                         /* fQMDll */,
                IN NoServerAuth_ROUTINE         /* pNoServerAuth */,
                IN LPCWSTR                      /* szServerName */,
                IN bool                         /* fDisableDownlevelNotifications*/
                )
/*++
    Abstract:
    Not supported

    Parameters:
    QMLookForOnlineDS_ROUTINE pLookDS -
    MQGetMQISServer_ROUTINE pGetServers -
    bool  fDSServerFunctionality - should provide DS server functionality
    bool  fSetupMode -  called during setup
    bool  fQMDll - called by QM
    NoServerAuth_ROUTINE pNoServerAuth -
    LPCWSTR szServerName -

    Returns:
	HRESULT
--*/
{
    return MQ_OK;
}


HRESULT CWorkGroupProvider::SetupInit(
                IN    unsigned char   /* ucRoll */,
                IN    LPWSTR          /* pwcsPathName */,
                IN    const GUID *    /* pguidMasterId */
                )
/*++
    Abstract:
    Not Supported

    Parameters:
        unsigned char   ucRoll -
        LPWSTR          pwcsPathName -
        const GUID *    pguidMasterId -

    Returns:
	HRESULT
--*/
{
    return MQ_OK;
}


HRESULT CWorkGroupProvider::CreateServersCache()
/*++
    Abstract:
    Not Supported

    Parameters:
    none

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::GetComputerSites(
                IN  LPCWSTR     /* pwcsComputerName */,
                OUT DWORD  *    /* pdwNumSites */,
                OUT GUID **     /* ppguidSites */
                )
/*++
    Abstract:
    Not Supported

    Parameters:
    LPCWSTR     pwcsComputerName - computer name
    DWORD  *    pdwNumSites - number of sites retrieved
    GUID **     ppguidSites - the retrieved sites ids

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::BeginDeleteNotification(
                IN  AD_OBJECT               /* eObject */,
                IN LPCWSTR                  /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN LPCWSTR					/* pwcsObjectName */,
                IN OUT HANDLE   *           /* phEnum */
                )
/*++
    Abstract:
    Not Supported

    Parameters:
    AD_OBJECT         eObject - object type
    LPCWSTR           pwcsDomainController - DC against which the operation should be performed
    bool			  fServerName - flag that indicate if the pwcsDomainController string is a server name
    LPCWSTR			  pwcsObjectName - msmq-name of the object
    HANDLE   *        phEnum - notification handle

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::NotifyDelete(
                IN  HANDLE                  /* hEnum */
                )
/*++
    Abstract:
    Not Supported

    Parameters:
    HANDLE            hEnum - notification handle

    Returns:
	HRESULT

--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::EndDeleteNotification(
                IN  HANDLE                  /* hEnum */
                )
/*++
    Abstract:
    Not Supported

    Parameters:
    HANDLE            hEnum - notification handle

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::QueryMachineQueues(
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN  const GUID *            /* pguidMachine */,
                IN  const MQCOLUMNSET*      /* pColumns */,
                OUT PHANDLE                 /* phEnume */
                )
/*++
    Abstract:
    Not Supported

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID *            pguidMachine - the unqiue id of the computer
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::QuerySiteServers(
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN const GUID *             /* pguidSite */,
                IN AD_SERVER_TYPE           /* serverType */,
                IN const MQCOLUMNSET*       /* pColumns */,
                OUT PHANDLE                 /* phEnume */
                )
/*++
    Abstract:
    Not supported

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID *            pguidSite - the site id
    AD_SERVER_TYPE          eServerType- which type of server
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::QueryUserCert(
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN const BLOB *             /* pblobUserSid */,
                IN const MQCOLUMNSET*       /* pColumns */,
                OUT PHANDLE                 /* phEnume */
                )
/*++
    Abstract:
    Not supported

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const BLOB *            pblobUserSid - the user sid
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::QueryConnectors(
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN const GUID *             /* pguidSite */,
                IN const MQCOLUMNSET*       /* pColumns */,
                OUT PHANDLE                 /* phEnume */
                )
/*++
    Abstract:
    Not Supported

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID *            pguidSite - the site id
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::QueryForeignSites(
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN const MQCOLUMNSET*       /* pColumns */,
                OUT PHANDLE                 /* phEnume */
                )
/*++
    Abstract:
    Not supported

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::QueryLinks(
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN const GUID *             /* pguidSite */,
                IN eLinkNeighbor            /* eNeighbor */,
                IN const MQCOLUMNSET*       /* pColumns */,
                OUT PHANDLE                 /* phEnume */
                )
/*++
    Abstract:
    Not supported

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID *            pguidSite - the site id
    eLinkNeighbor           eNeighbor - which neighbour
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the

    Returns:
	HRESULT
--*/
{   
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::QueryAllLinks(
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN const MQCOLUMNSET*       /* pColumns */,
                OUT PHANDLE                 /* phEnume */
                )
/*++
    Abstract:
    Not supported

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the
							results

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::QueryAllSites(
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN const MQCOLUMNSET*       /* pColumns */,
                OUT PHANDLE                 /* phEnume */
                )
/*++
    Abstract:
    Not supported

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	const MQCOLUMNSET*      pColumns - result columns
	PHANDLE                 phEnume - query handle for retriving the
							results

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::QueryQueues(
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN  const MQRESTRICTION*    /* pRestriction */,
                IN  const MQCOLUMNSET*      /* pColumns */,
                IN  const MQSORTSET*        /* pSort */,
                OUT PHANDLE                 /* phEnume */
                )
/*++
    Abstract:
    Not supported

    Parameters:
	LPCWSTR                 pwcsDomainController - DC against which
									the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	const MQRESTRICTION*    pRestriction - query restriction
	const MQCOLUMNSET*      pColumns - result columns
	const MQSORTSET*        pSort - how to sort the results
	PHANDLE                 phEnume - query handle for retriving the
							results

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::QueryResults(
                IN      HANDLE          /* hEnum */,
                IN OUT  DWORD*          /* pcProps */,
                OUT     PROPVARIANT     /* aPropVar */[]
                )
/*++
    Abstract:
    Not supported

    Parameters:
	HANDLE          hEnum - query handle
	DWORD*          pcProps - number of results to return
	PROPVARIANT     aPropVar - result values

    Returns:
	HRESULT
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::EndQuery(
                IN  HANDLE                  /* hEnum */
                )
/*++
    Abstract:
    Not supported

    Parameters:
	HANDLE    hEnum - the query handle

    Returns:
	none
--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::GetObjectSecurity(
                IN  AD_OBJECT               /* eObject */,
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN  LPCWSTR                 /* pwcsObjectName */,
                IN  SECURITY_INFORMATION    /* RequestedInformation */,
                IN  const PROPID            /* prop */,
                IN OUT  PROPVARIANT *       /* pVar */
                )
/*++

Routine Description:
    Not supported

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	PROPVARIANT             pVar - property values

Return Value
	HRESULT

--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}

HRESULT CWorkGroupProvider::GetObjectSecurityGuid(
                IN  AD_OBJECT               /* eObject */,
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN  const GUID*             /* pguidObject */,
                IN  SECURITY_INFORMATION    /* RequestedInformation */,
                IN  const PROPID            /* prop */,
                IN OUT  PROPVARIANT *       /* pVar */
                )
/*++

Routine Description:
    Not supported

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID*             pguidObject - unique id of the object
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	PROPVARIANT             pVar - property values

Return Value
	HRESULT

--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}

HRESULT CWorkGroupProvider::SetObjectSecurity(
                IN  AD_OBJECT               /* eObject */,
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN  LPCWSTR                 /* pwcsObjectName */,
                IN  SECURITY_INFORMATION    /* RequestedInformation */,
                IN  const PROPID            /* prop */,
                IN  const PROPVARIANT *     /* pVar	*/
                )
/*++

Routine Description:
    Not supported

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
	LPCWSTR                 pwcsObjectName - MSMQ object name
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values

Return Value
	HRESULT

--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


HRESULT CWorkGroupProvider::SetObjectSecurityGuid(
                IN  AD_OBJECT               /* eObject */,
                IN  LPCWSTR                 /* pwcsDomainController */,
		        IN  bool					/* fServerName */,
                IN  const GUID*             /* pguidObject */,
                IN  SECURITY_INFORMATION    /* RequestedInformation */,
                IN  const PROPID            /* prop */,
                IN  const PROPVARIANT *     /* pVar */
                )
/*++

Routine Description:
    Not supported

Arguments:
	AD_OBJECT               eObject - object type
	LPCWSTR                 pwcsDomainController - DC against
							which the operation will be performed
    bool					fServerName - flag that indicate if the pwcsDomainController
							string is a server name
    const GUID*             pguidObject - unique object id
    SECURITY_INFORMATION    RequestedInformation - reuqested security info (DACL, SACL..)
	const PROPID            prop - security property
	const PROPVARIANT       pVar - property values

Return Value
	HRESULT

--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}

HRESULT CWorkGroupProvider::ADGetADsPathInfo(
                IN  LPCWSTR                 /*pwcsADsPath*/,
                OUT PROPVARIANT *           /*pVar*/,
                OUT eAdsClass *             /*pAdsClass*/
                )
/*++

Routine Description:
    Not supported

Arguments:
	LPCWSTR                 pwcsADsPath - object pathname
	const PROPVARIANT       pVar - property values
    eAdsClass *             pAdsClass - indication about the object class
Return Value
	HRESULT

--*/
{
    return MQ_ERROR_UNSUPPORTED_OPERATION;
}


void
CWorkGroupProvider::FreeMemory(
	PVOID /* pMemory */
	)
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\traninfo.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    traninfo.cpp

Abstract:

    Translation information of MSMQ 2.0/3.0 properties into MSMQ 1.0 attributes

Author:

    Ilan Herbst		(ilanh)		02-Oct-2000

--*/
#include "ds_stdh.h"
#include "mqprops.h"
#include "xlat.h"
#include "traninfo.h"

static WCHAR *s_FN=L"ad/traninfo";

//----------------------------------------------------------
//  defaultVARIANT
//
//  This structure is equivalent in size and order of variables 
//  to MQPROPVARIANT.
//
//  MQPROPVARIANT contains a union, and the size first member of
//  the union is smaller than other members of the union.
//  Therefore MQPROVARIANT cannot be initialized at compile time
//  with union members other than the smallest one.
//
//----------------------------------------------------------
struct defaultVARIANT {
    VARTYPE vt;
    WORD wReserved1;
    WORD wReserved2;
    WORD wReserved3;
    ULONG_PTR l1;
    ULONG_PTR l2;
};

C_ASSERT(sizeof(defaultVARIANT) == sizeof(MQPROPVARIANT));
C_ASSERT(FIELD_OFFSET(defaultVARIANT, l1) == FIELD_OFFSET(MQPROPVARIANT, caub.cElems));
C_ASSERT(FIELD_OFFSET(defaultVARIANT, l2) == FIELD_OFFSET(MQPROPVARIANT, caub.pElems));

const defaultVARIANT varDefaultEmpty = { VT_EMPTY, 0, 0, 0, 0, 0};
const defaultVARIANT varDefaultNull = { VT_NULL, 0, 0, 0, 0, 0};

//
//      Default values for queue properties
//
const defaultVARIANT varDefaultDoNothing = { VT_NULL, 0, 0, 0, 0, 0};
const defaultVARIANT varDefaultQMulticastAddress = { VT_EMPTY, 0, 0, 0, 0, 0};

//
//      Default values for machine properties
//

const defaultVARIANT varDefaultQMService = { VT_UI4, 0,0,0, DEFAULT_N_SERVICE, 0};
const defaultVARIANT varDefaultQMServiceRout = { VT_UI1, 0,0,0, DEFAULT_N_SERVICE, 0};
const defaultVARIANT varDefaultQMServiceDs   = { VT_UI1, 0,0,0, DEFAULT_N_SERVICE, 0};
const defaultVARIANT varDefaultQMServiceDep  = { VT_UI1, 0,0,0, DEFAULT_N_SERVICE, 0};
const defaultVARIANT varDefaultQMSiteIDs = { VT_CLSID|VT_VECTOR, 0,0,0, 0, 0};
const defaultVARIANT varDefaultSForeign = { VT_UI1, 0,0,0, 0, 0};


PropTranslation   PropTranslateInfo[] = {
// PROPID NT5				| PROPID NT4				| vartype		| Action		| SetNT4 routine				| SetNT5 routine				| default value 								|
//--------------------------|---------------------------|---------------|---------------|-------------------------------|-------------------------------|-----------------------------------------------|
{PROPID_Q_DONOTHING			,0                          ,VT_UI1			,taUseDefault   ,NULL                           ,NULL                           ,(MQPROPVARIANT*)&varDefaultDoNothing			},
{PROPID_Q_PATHNAME_DNS		,0                          ,VT_LPWSTR		,taOnlyNT5		,NULL                           ,NULL							,NULL											},
{PROPID_Q_MULTICAST_ADDRESS	,0                          ,VT_LPWSTR		,taUseDefault   ,NULL                           ,NULL							,(MQPROPVARIANT*)&varDefaultQMulticastAddress	},
{PROPID_Q_ADS_PATH   		,0                          ,VT_LPWSTR		,taOnlyNT5		,NULL                           ,NULL							,NULL											},
{PROPID_QM_OLDSERVICE		,PROPID_QM_SERVICE			,VT_UI4         ,taReplaceAssign,NULL							,NULL							,(MQPROPVARIANT*)&varDefaultQMService			},
{PROPID_QM_SERVICE_DSSERVER ,PROPID_QM_SERVICE			,VT_UI1			,taReplace		,ADpSetMachineService			,ADpSetMachineServiceDs         ,(MQPROPVARIANT*)&varDefaultQMServiceDs			},
{PROPID_QM_SERVICE_ROUTING	,PROPID_QM_SERVICE			,VT_UI1			,taReplace		,ADpSetMachineService			,ADpSetMachineServiceRout       ,(MQPROPVARIANT*)&varDefaultQMServiceRout		},
{PROPID_QM_SERVICE_DEPCLIENTS ,PROPID_QM_SERVICE		,VT_UI1			,taReplace		,ADpSetMachineService			,ADpSetMachineServiceRout       ,(MQPROPVARIANT*)&varDefaultQMServiceDep		},
{PROPID_QM_SITE_IDS			,PROPID_QM_SITE_ID			,VT_CLSID|VT_VECTOR ,taReplace	,ADpSetMachineSite				,ADpSetMachineSiteIds	        ,(MQPROPVARIANT*)&varDefaultQMSiteIDs			},
{PROPID_QM_DONOTHING		,0                          ,VT_UI1			,taUseDefault   ,NULL                           ,NULL                           ,(MQPROPVARIANT*)&varDefaultDoNothing			},
{PROPID_QM_PATHNAME_DNS		,0                          ,VT_LPWSTR      ,taOnlyNT5		,NULL							,NULL							,NULL											},
{PROPID_S_DONOTHING			,0                          ,VT_UI1			,taUseDefault   ,NULL                           ,NULL                           ,(MQPROPVARIANT*)&varDefaultDoNothing			},
{PROPID_S_FOREIGN			,0					        ,VT_UI1			,taUseDefault   ,NULL				            ,NULL			                ,(MQPROPVARIANT*)&varDefaultSForeign			}
};


HRESULT   
CopyDefaultValue(
	IN const MQPROPVARIANT*   pvarDefaultValue,
	OUT MQPROPVARIANT*        pvar
	)
/*++

Routine Description:
	Copy property's default value into user's mqpropvariant

Arguments:
	pvarDefaultValue - default value
	pvar - the prop var that need to be filled with the default value

Return Value
	HRESULT

--*/
{
    if ( pvarDefaultValue == NULL)
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1870);
    }
    switch ( pvarDefaultValue->vt)
    {
        case VT_I2:
        case VT_I4:
        case VT_I1:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_EMPTY:
        case VT_NULL:
            //
            //  copy as is
            //
            *pvar = *pvarDefaultValue;
            break;

        case VT_LPWSTR:
            {
                DWORD len = wcslen( pvarDefaultValue->pwszVal);
                pvar->pwszVal = new WCHAR[ len + 1];
                wcscpy( pvar->pwszVal, pvarDefaultValue->pwszVal);
                pvar->vt = VT_LPWSTR;
            }
            break;
        case VT_BLOB:
            {
                DWORD len = pvarDefaultValue->blob.cbSize;
                if ( len > 0)
                {
                    pvar->blob.pBlobData = new unsigned char[ len];
                    memcpy(  pvar->blob.pBlobData,
                             pvarDefaultValue->blob.pBlobData,
                             len);
                }
                else
                {
                    pvar->blob.pBlobData = NULL;
                }
                pvar->blob.cbSize = len;
                pvar->vt = VT_BLOB;
            }
            break;

        case VT_CLSID:
            //
            //  This is a special case where we do not necessarily allocate the memory for the guid
            //  in puuid. The caller may already have puuid set to a guid, and this is indicated by the
            //  vt member on the given propvar. It could be VT_CLSID if guid already allocated, otherwise
            //  we allocate it (and vt should be VT_NULL (or VT_EMPTY))
            //
            if ( pvar->vt != VT_CLSID)
            {
                ASSERT(((pvar->vt == VT_NULL) || (pvar->vt == VT_EMPTY)));
                pvar->puuid = new GUID;
                pvar->vt = VT_CLSID;
            }
            else if ( pvar->puuid == NULL)
            {
                return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 1880);
            }
            *pvar->puuid = *pvarDefaultValue->puuid;
            break;

        case VT_VECTOR|VT_CLSID:
            {
                DWORD len = pvarDefaultValue->cauuid.cElems;
                if ( len > 0)
                {
                    pvar->cauuid.pElems = new GUID[ len];
                    memcpy( pvar->cauuid.pElems,
                           pvarDefaultValue->cauuid.pElems,
                           len*sizeof(GUID));
                }
                else
                {
                    pvar->cauuid.pElems = NULL;
                }
                pvar->cauuid.cElems = len;
                pvar->vt = VT_VECTOR|VT_CLSID;
            }
            break;

        case VT_VECTOR|VT_LPWSTR:
            {
                DWORD len = pvarDefaultValue->calpwstr.cElems;
                if ( len > 0)
                {
                    pvar->calpwstr.pElems = new LPWSTR[ len];
					for (DWORD i = 0; i < len; i++)
					{
						DWORD strlen = wcslen(pvarDefaultValue->calpwstr.pElems[i]) + 1;
						pvar->calpwstr.pElems[i] = new WCHAR[ strlen];
						wcscpy( pvar->calpwstr.pElems[i], pvarDefaultValue->calpwstr.pElems[i]);
					}
                }
                else
                {
                    pvar->calpwstr.pElems = NULL;
                }
                pvar->calpwstr.cElems = len;
                pvar->vt = VT_VECTOR|VT_LPWSTR;
            }
            break;


        default:
            ASSERT(0);
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1890);

    }
    return(MQ_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\xlat.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xlat.cpp

Abstract:

    Implementation of routines to translate NT5 properties To NT4 properties
    and vice versa

Author:

    Ilan Herbst		(ilanh)		02-Oct-2000

--*/

#include "ds_stdh.h"
#include "mqmacro.h"
#include "_ta.h"
#include "adalloc.h"

static WCHAR *s_FN=L"ad/xlat";

HRESULT 
WINAPI 
ADpSetMachineSiteIds(
     IN DWORD               cp,
     IN const PROPID*       aProp,
     IN const PROPVARIANT*  apVar,
     IN DWORD               idxProp,
     OUT PROPVARIANT*		pNewPropVar
	 )
/*++

Routine Description:
	Translate NT4 props (PROPID_QM_SITE_ID, PROPID_QM_ADDRESS, PROPID_QM_CNS)
	to PROPID_QM_SITE_IDS.
	PROPID_QM_SITE_IDS will be a concatanation of PROPID_QM_SITE_ID and all foreign CNS
	in PROPID_QM_CNS.
	This function is used to retreive PROPID_QM_SITE_IDS (NT5 prop) from NT4 props

Arguments:
	cp - number of properties
	aProp - properties
	apVar - property values
	idxProp - index of the translated props in aProp, apVar	arrays
	pNewPropVar - the new prop var to construct

Return Value
	HRESULT
--*/
{
	DBG_USED(cp);
	DBG_USED(aProp);

	ASSERT(idxProp + 2 < cp);
	ASSERT(aProp[idxProp] == PROPID_QM_SITE_ID);
	ASSERT(aProp[idxProp + 1] == PROPID_QM_ADDRESS);
	ASSERT(aProp[idxProp + 2] == PROPID_QM_CNS);

	//
	// PROPID_QM_SITE_ID
	//
    ASSERT((apVar[idxProp].vt == VT_CLSID) &&
		   (apVar[idxProp].puuid != NULL));

	//
	// PROPID_QM_ADDRESS
	//
    ASSERT((apVar[idxProp + 1].vt == VT_BLOB) &&
	       (apVar[idxProp + 1].blob.cbSize > 0) &&
		   (apVar[idxProp + 1].blob.pBlobData != NULL));

	//
	// PROPID_QM_CNS
	//
	ASSERT((apVar[idxProp + 2].vt == (VT_CLSID|VT_VECTOR)) &&
	       (apVar[idxProp + 2].cauuid.cElems > 0) &&
		   (apVar[idxProp + 2].cauuid.pElems != NULL));

	//
	// Auto Clean props
	//
	P<GUID> pCleanGuid = apVar[idxProp].puuid;
	AP<BYTE> pCleanBlob = apVar[idxProp + 1].blob.pBlobData;
	AP<GUID> pCleanAGuid = apVar[idxProp + 2].cauuid.pElems;

	//
	// PROPID_QM_SITE_ID (1) + PROPID_QM_CNS count
	//
	DWORD cMaxSites = 1 + apVar[idxProp + 2].cauuid.cElems;
	AP<GUID> pGuid = new GUID[cMaxSites];
	DWORD cSites = 0;

	//
	// First Site is from PROPID_QM_SITE_ID
	//
	pGuid[cSites] = *apVar[idxProp].puuid;
	++cSites;
	
	//
	// Process the results - look for all forgien cns
	//
	BYTE* pAddress = apVar[idxProp + 1].blob.pBlobData;
	for(DWORD i = 0; i < apVar[idxProp + 2].cauuid.cElems; ++i)
	{
        TA_ADDRESS* pBuffer = reinterpret_cast<TA_ADDRESS *>(pAddress);

		ASSERT((pAddress + TA_ADDRESS_SIZE + pBuffer->AddressLength) <= 
			   (apVar[idxProp + 1].blob.pBlobData + apVar[idxProp + 1].blob.cbSize)); 

        if(pBuffer->AddressType == FOREIGN_ADDRESS_TYPE)
		{
			//
			// Found FOREIGN_ADDRESS_TYPE cn
			//
			pGuid[cSites] = apVar[idxProp + 2].cauuid.pElems[i];
			++cSites;
		}

		//
		// Advance pointer to the next address
		//
		pAddress += TA_ADDRESS_SIZE + pBuffer->AddressLength;
	}

    pNewPropVar->vt = VT_CLSID|VT_VECTOR;
    pNewPropVar->cauuid.cElems = cSites;
	pNewPropVar->cauuid.pElems = reinterpret_cast<GUID*>(ADAllocateMemory(sizeof(GUID)*cSites));
    memcpy(pNewPropVar->cauuid.pElems, pGuid, cSites * sizeof(GUID));
    return MQ_OK;
}


HRESULT 
WINAPI 
ADpSetMachineSite(
     IN DWORD               /* cp */,
     IN const PROPID*       aProp,
     IN const PROPVARIANT*  apVar,
     IN DWORD               idxProp,
     OUT PROPVARIANT*		pNewPropVar
	 )
/*++

Routine Description:
	Translate NT5 props PROPID_QM_SITE_IDS to PROPID_QM_SITE_ID.
	PROPID_QM_SITE_ID is the first site in PROPID_QM_SITE_IDS
	This function is used to convert PROPID_QM_SITE_IDS (NT5 prop) to PROPID_QM_SITE_ID (NT4 prop)

Arguments:
	cp - number of properties
	aProp - properties
	apVar - property values
	idxProp - index of the translated props in aProp, apVar	arrays
	pNewPropVar - the new prop var to construct

Return Value
	HRESULT
--*/
{
	DBG_USED(aProp);
	ASSERT(aProp[idxProp] == PROPID_QM_SITE_IDS);

    const PROPVARIANT *pPropVar = &apVar[idxProp];

	//
	// Check PROPID_QM_SITE_IDS
	//
    if ((pPropVar->vt != (VT_CLSID|VT_VECTOR)) ||
        (pPropVar->cauuid.cElems == 0) ||
        (pPropVar->cauuid.pElems == NULL))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 10);
    }

    //
    // return the first site-id from the list
    //
    pNewPropVar->vt = VT_CLSID;
    pNewPropVar->puuid = pPropVar->cauuid.pElems;

    return MQ_OK;
}


HRESULT 
WINAPI 
ADpSetMachineServiceDs(
     IN DWORD               /* cp */,
     IN const PROPID*       aProp,
     IN const PROPVARIANT*  apVar,
     IN DWORD               idxProp,
     OUT PROPVARIANT*		pNewPropVar
	 )
/*++

Routine Description:
	Translate NT4 prop PROPID_QM_SERVICE to PROPID_QM_SERVICE_DSSERVER.

Arguments:
	cp - number of properties
	aProp - properties
	apVar - property values
	idxProp - index of the translated props in aProp, apVar	arrays
	pNewPropVar - the new prop var to construct

Return Value
	HRESULT
--*/
{

	DBG_USED(aProp);
	ASSERT(aProp[idxProp] == PROPID_QM_SERVICE);

    pNewPropVar->vt = VT_UI1;
    pNewPropVar->bVal = (apVar[idxProp].ulVal >= SERVICE_BSC);

	return MQ_OK;
}


HRESULT 
WINAPI 
ADpSetMachineServiceRout(
     IN DWORD               /* cp */,
     IN const PROPID*       aProp,
     IN const PROPVARIANT*  apVar,
     IN DWORD               idxProp,
     OUT PROPVARIANT*		pNewPropVar
	 )
/*++

Routine Description:
	Translate NT4 prop PROPID_QM_SERVICE to PROPID_QM_SERVICE_ROUTING or PROPID_QM_SERVICE_DEPCLIENTS.

Arguments:
	cp - number of properties
	aProp - properties
	apVar - property values
	idxProp - index of the translated props in aProp, apVar	arrays
	pNewPropVar - the new prop var to construct

Return Value
	HRESULT
--*/
{

	DBG_USED(aProp);
	ASSERT(aProp[idxProp] == PROPID_QM_SERVICE);

    pNewPropVar->vt = VT_UI1;
    pNewPropVar->bVal = (apVar[idxProp].ulVal >= SERVICE_SRV);

	return MQ_OK;
}


HRESULT 
WINAPI 
ADpSetMachineService(
     IN DWORD               cp,
     IN const PROPID*       aProp,
     IN const PROPVARIANT*  apVar,
     IN DWORD              /*idxProp*/,
     OUT PROPVARIANT*		pNewPropVar
	 )
/*++

Routine Description:
	Translate NT5 props PROPID_QM_SERVICE_DSSERVER, PROPID_QM_SERVICE_ROUTING, PROPID_QM_SERVICE_DEPCLIENTS
	to NT5 prop PROPID_QM_SERVICE.

Arguments:
	cp - number of properties
	aProp - properties
	apVar - property values
	idxProp - index of the translated props in aProp, apVar	arrays
	pNewPropVar - the new prop var to construct

Return Value
	HRESULT
--*/
{
    bool fRouter = false;
    bool fDSServer = false;
    bool fFoundRout = false;
    bool fFoundDs = false;
    bool fFoundDepCl = false;

    for (DWORD i = 0; i< cp ; i++)
    {
        switch (aProp[i])
        {
			case PROPID_QM_SERVICE_ROUTING:
				fRouter = (apVar[i].bVal != 0);
				fFoundRout = true;
				break;

			case PROPID_QM_SERVICE_DSSERVER:
				fDSServer  = (apVar[i].bVal != 0);
				fFoundDs = true;
				break;

			case PROPID_QM_SERVICE_DEPCLIENTS:
				fFoundDepCl = true;
				break;

			default:
				break;

        }
    }

	//
	// If anybody sets one of 3 proprties (rout, ds, depcl), he must do it for all 3 of them
	//
	ASSERT(fFoundRout && fFoundDs && fFoundDepCl);

    pNewPropVar->vt = VT_UI4;

	if(fDSServer)
	{
		ASSERT(("Should not set Ds Server property", 0));
		pNewPropVar->ulVal = SERVICE_PSC;
	}
	else if(fRouter)
	{
		ASSERT(("Should not set Router property", 0));
		pNewPropVar->ulVal = SERVICE_SRV;
	}
	else
	{
		pNewPropVar->ulVal = SERVICE_NONE;
	}

	return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\dsutils\loadqm.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    loadqm.cpp

Abstract:

    Load the MQQM dll.

Author:

    Doron Juster  (DoronJ)


--*/

#include "stdh.h"
#include <mqnames.h>

#include "loadqm.tmh"

HINSTANCE LoadMQQMDll()
{
    //
    // Load the MQQM dll to call its rpc initialization code.
    //
    WCHAR wszMQQMFileName[ MAX_PATH ] ;
    DWORD dwLen = GetModuleFileName( NULL,
                                     wszMQQMFileName,
                                     MAX_PATH ) ;
    if (dwLen == 0)
    {
        return NULL ;
    }
    WCHAR *pW = wcsrchr(wszMQQMFileName, L'\\') ;
    if (!pW)
    {
        return NULL ;
    }
    pW++ ;
    wcscpy(pW, MQQM_DLL_NAME) ;

    DBGMSG((DBGMOD_DS, DBGLVL_TRACE,
            TEXT("dsutils, loading %ls"), wszMQQMFileName)) ;

    HINSTANCE hMQQM = LoadLibrary(wszMQQMFileName) ;
    return hMQQM  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\test\test.cpp ===
#include "..\..\h\ds_stdh.h"
#include "ad.h"
#include "cm.h"
#include "tr.h"

#include "test.tmh"

const TraceIdEntry AdTest = L"AD TEST";


extern "C" 
int 
__cdecl 
_tmain(
    int /* argc */,
    LPCTSTR* /* argv */
    )
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	CmInitialize(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MSMQ\\Parameters");
	TrInitialize();

	//
	// Test Setup raw detection
	//
    DWORD dwDsEnv = ADRawDetection();
	TrTRACE(AdTest, "DsEnv = %d", dwDsEnv);

	//
	// Test ADInit
	//
	ADInit(NULL, NULL, false,false, false, false, NULL,NULL,true);

    //
    //  Retrieve local computer name
    //
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    AP<WCHAR> pwcsComputerName = new WCHAR[dwSize];

    if (GetComputerName(pwcsComputerName, &dwSize))
    {
        CharLower(pwcsComputerName);
    }
    else
    {
        printf("failed to retreive local computer name \n");
    }

    //
    //  Get local computer sites
    //
    GUID* pguidSites;
    DWORD numSites;
    HRESULT hr;

    hr = ADGetComputerSites(
                        pwcsComputerName,
                        &numSites,
                        &pguidSites
                        );
    if (FAILED(hr))
    {
        printf("FAILURE: to getComputerSites, computer = %S, hr =%lx\n", pwcsComputerName, hr);
    }
    if (numSites != 1)
    {
        printf("FAILURE: wrong number of sites \n");
    }

	ADTerminate();
    WPP_CLEANUP();

    return(0);
} 


void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogDS,
                     LOG_DS_ERRORS,
                     L"MQADS Error: %s/%d. HR: %x", 
                     wszFileName,
                     usPoint,
                     hr)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\wrkgprov.h ===
/*++

Copyright (c) 1995  Microsoft Corporation 

Module Name:
	wrkgprov.h

Abstract:
	Workgroup mode provider class.

Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __WRKGPROV_H__
#define __WRKGPROV_H__

#include "baseprov.h"

//-----------------------------------------------------------------------------------
//
//      CWorkGroupProvider
//
//  encapsulates Workgroup mode operations 
//
//-----------------------------------------------------------------------------------
class CWorkGroupProvider : public  CBaseADProvider
{
public:
    CWorkGroupProvider();

    ~CWorkGroupProvider();

    virtual HRESULT CreateObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[],
                OUT GUID*                   pObjGuid
                );

    virtual HRESULT DeleteObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName
                );

    virtual HRESULT DeleteObjectGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN  const GUID*             pguidObject
                );

    virtual HRESULT GetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT PROPVARIANT          apVar[]
                );

    virtual HRESULT GetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  OUT PROPVARIANT         apVar[]
                );

    virtual HRESULT QMGetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded,
                IN  DSQMChallengeResponce_ROUTINE
                                            pfChallengeResponceProc,
                IN  DWORD_PTR               dwContext
                );

    virtual HRESULT GetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                );

    virtual HRESULT GetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                );

    virtual HRESULT SetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                );

    virtual HRESULT SetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                );

    virtual HRESULT QMSetMachineProperties(
                IN  LPCWSTR             pwcsObjectName,
                IN  const DWORD         cp,
                IN  const PROPID        aProp[],
                IN  const PROPVARIANT   apVar[],
                IN  DSQMChallengeResponce_ROUTINE pfSignProc,
                IN  DWORD_PTR           dwContext
                );

    virtual HRESULT SetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                );

    virtual HRESULT SetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                );

    virtual HRESULT Init( 
                IN QMLookForOnlineDS_ROUTINE    pLookDS,
                IN MQGetMQISServer_ROUTINE      pGetServers,
                IN bool                         fSetupMode,
                IN bool                         fQMDll,
                IN NoServerAuth_ROUTINE         pNoServerAuth,
                IN LPCWSTR                      szServerName,
                IN bool                         fDisableDownlevelNotifications
                );

    virtual HRESULT SetupInit(
                IN    unsigned char   ucRoll,
                IN    LPWSTR          pwcsPathName,
                IN    const GUID *    pguidMasterId
                );

    virtual HRESULT CreateServersCache();

    virtual HRESULT GetComputerSites(
                IN  LPCWSTR     pwcsComputerName,
                OUT DWORD  *    pdwNumSites,
                OUT GUID **     ppguidSites
                );

    virtual HRESULT BeginDeleteNotification(
                IN  AD_OBJECT               eObject,
                IN LPCWSTR                  pwcsDomainController,
		        IN  bool					fServerName,
                IN LPCWSTR					pwcsObjectName,
                IN OUT HANDLE   *           phEnum
                );

    virtual HRESULT NotifyDelete(
                IN  HANDLE                  hEnum
                );

    virtual HRESULT EndDeleteNotification(
                IN  HANDLE                  hEnum
                );

    virtual HRESULT QueryMachineQueues(
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN  const GUID *            pguidMachine,
                IN  const MQCOLUMNSET*      pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QuerySiteServers(
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN AD_SERVER_TYPE           serverType,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryUserCert(
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN const BLOB *             pblobUserSid,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryConnectors(
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryForeignSites(
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryLinks(
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN eLinkNeighbor            eNeighbor,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryAllLinks(
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryAllSites(
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryQueues(
                IN  LPCWSTR                 pwcsDomainController,
		        IN  bool					fServerName,
                IN  const MQRESTRICTION*    pRestriction,
                IN  const MQCOLUMNSET*      pColumns,
                IN  const MQSORTSET*        pSort,
                OUT PHANDLE                 phEnume
                );

    virtual HRESULT QueryResults(
                IN      HANDLE          hEnum,
                IN OUT  DWORD*          pcProps,
                OUT     PROPVARIANT     aPropVar[]
                );

    virtual HRESULT EndQuery(
                IN  HANDLE                  hEnum
                );

    virtual void Terminate() {};

    virtual HRESULT ADGetADsPathInfo(
                IN  LPCWSTR                 pwcsADsPath,
                OUT PROPVARIANT *           pVar,
                OUT eAdsClass *             pAdsClass
                );

	virtual void FreeMemory(
				IN PVOID					pMemory
				);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\dsutils\stdh.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    precompiled header file

Author:

    Rannanh


--*/

#ifndef __STDH_H
#define __STDH_H

#include "_stdh.h"
#include "mqtypes.h"

#include "dsutils.h"

#endif // __STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\ad\xlat.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xlat.h

Abstract:

    Definition of routines to translate NT5 properties To NT4 properties
    and vice versa

Author:

    Ilan Herbst		(ilanh)		02-Oct-2000

--*/

#ifndef __AD_XLAT_H__
#define __AD_XLAT_H__


HRESULT 
WINAPI 
ADpSetMachineSiteIds(
     IN DWORD               cp,
     IN const PROPID*       aProp,
     IN const PROPVARIANT*  apVar,
     IN DWORD               idxProp,
     OUT PROPVARIANT*		pNewPropVar
	 );


HRESULT 
WINAPI 
ADpSetMachineSite(
     IN DWORD               /* cp */,
     IN const PROPID*       aProp,
     IN const PROPVARIANT*  apVar,
     IN DWORD               idxProp,
     OUT PROPVARIANT*		pNewPropVar
	 );


HRESULT 
WINAPI 
ADpSetMachineServiceDs(
     IN DWORD               /* cp */,
     IN const PROPID*       aProp,
     IN const PROPVARIANT*  apVar,
     IN DWORD               idxProp,
     OUT PROPVARIANT*		pNewPropVar
	 );


HRESULT 
WINAPI 
ADpSetMachineServiceRout(
     IN DWORD               /* cp */,
     IN const PROPID*       aProp,
     IN const PROPVARIANT*  apVar,
     IN DWORD               idxProp,
     OUT PROPVARIANT*		pNewPropVar
	 );


HRESULT 
WINAPI 
ADpSetMachineService(
     IN DWORD               cp,
     IN const PROPID*       aProp,
     IN const PROPVARIANT*  apVar,
     IN DWORD              /*idxProp*/,
     OUT PROPVARIANT*		pNewPropVar
	 );


#endif // __AD_XLAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\dsutils\pvalloc.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pvalloc.cpp

Abstract:

    Implementation of chained memory allocation routines

Author:

    Raanan Harari (raananh)


--*/

#include "stdh.h"

#include "pvalloc.tmh"

//
// on debug new is redefined as new(__FILE__, __LINE__)
// but here we want to add our own file & line parameters
//
#undef new

//
// on debug we redefined PvAlloc in the headers for the outside world
// to use the PvAllocDbg, but we don't want it in here...
//
#undef PvAlloc
#undef PvAllocMore

//
// Should be unique as much as possible
//
const DWORD PVALLOC_SIGNATURE = 0xE1D2C3B4;

//
// Memory allocation node
//
struct PVINFO;
struct PVINFO
{
    PVINFO * pNext;
    DWORD  dwSignature;
};
typedef struct PVINFO * PPVINFO;

//-------------------------------------------------------------------------
//
//  Purpose:
//      start a memory chain from the block
//
//  Parameters:
//      ppvinfo       - new first (master) block
//
//  Returns:
//      void
//
inline STATIC void StartChainFromBlock(IN PPVINFO ppvinfo)
{
    //
    // Set signature
    //
    ppvinfo->dwSignature = PVALLOC_SIGNATURE;

    //
    // This is the first block in the chain
    //
    ppvinfo->pNext = NULL;
}

//-------------------------------------------------------------------------
//
//  Purpose:
//      Allocates a chunk of memory, and starts a memory allocation chain.
//
//  Parameters:
//      cbSize          - Count of bytes requested.
//
//  Returns:
//      LPVOID          - Pointer to the allocated memory
//
LPVOID PvAlloc(IN ULONG cbSize)
{
    PPVINFO ppvinfo;

    //
    // Allocate the block and a header just before the requested block
    //
    ppvinfo = (PPVINFO) new BYTE[cbSize + sizeof(PVINFO)];
    if (!ppvinfo)
        return(NULL);

    //
    // start a memory chain from the block
    //
    StartChainFromBlock(ppvinfo);

    //
    // Return pointer to the actual block just after the header
    //
    return(((LPBYTE)ppvinfo) + sizeof(PVINFO));
}

//-------------------------------------------------------------------------
//
//  Purpose:
//      Same as PvAlloc, just with dbg info on caller
//
//  Parameters:
//      cbSize          - Count of bytes requested.
//      pszFile         - File name of caller
//      ulLine          - Line number of caller
//
//  Returns:
//      LPVOID          - Pointer to the allocated memory
//
LPVOID PvAllocDbg(IN ULONG cbSize,
                  IN LPCSTR pszFile,
                  IN ULONG ulLine)
{
    PPVINFO ppvinfo;

    //
    // Allocate the block and a header just before the requested block
    //
    ppvinfo = (PPVINFO) new(pszFile, ulLine) BYTE[cbSize + sizeof(PVINFO)];
    if (!ppvinfo)
        return(NULL);

    //
    // start a memory chain from the block
    //
    StartChainFromBlock(ppvinfo);

    //
    // Return pointer to the actual block just after the header
    //
    return(((LPBYTE)ppvinfo) + sizeof(PVINFO));
}

//-------------------------------------------------------------------------
//
//  Purpose:
//      Checks if a pvinfo pointer is valid or not
//
//  Parameters:
//      ppvinfo  - Pointer to PVINFO header
//
//  Returns:
//      True if invalid, False if valid
//
inline STATIC BOOL FIsBadPVINFO(IN PPVINFO ppvinfo)
{
    //
    // Check we are allowed to write
    //
    if (IsBadWritePtr(ppvinfo, sizeof(PVINFO)))
        return(TRUE);

    //
    // Check it is our signature in the block
    //
    if (ppvinfo->dwSignature != PVALLOC_SIGNATURE)
        return(TRUE);

    //
    // most likely it is a valid pvinfo header
    //
    return(FALSE);
}

//-------------------------------------------------------------------------
//
//  Purpose:
//      Gets the header for AllocMore parent
//
//  Parameters:
//      lpvParent       - Pointer to a memory block returned by a previous
//                        pvAlloc call
//  Returns:
//      pvinfo header just above lpvParent
//
inline STATIC PPVINFO GetHeaderOfAllocMoreParent(IN LPVOID lpvParent)
{
    PPVINFO ppvinfoParent;

    //
    // Sanity check 
    //
    if (!lpvParent)
    {
        ASSERT(0);
        throw bad_alloc();
    }

    //
    // Get pointer to the header just before the pointed block
    //
    ppvinfoParent = (PPVINFO)(((LPBYTE)lpvParent) - sizeof(PVINFO));

    //
    // Check it is a valid pvinfo header and not garbage
    //
    if (FIsBadPVINFO(ppvinfoParent))
    {
        ASSERT(0);
        throw bad_alloc();
    }

    return(ppvinfoParent);
}

//-------------------------------------------------------------------------
//
//  Purpose:
//      insert the new block in the chain immediately after the first (master) block.
//
//  Parameters:
//      ppvinfo       - new block to add
//      ppvinfoParent - Pointer to the first (master) block
//
//  Returns:
//      void
//
inline STATIC void InsertNewBlockToChain(IN PPVINFO ppvinfo,
                                         IN PPVINFO ppvinfoParent)
{
    PPVINFO ppvinfoParentNext;

    //
    // Set signature
    //
    ppvinfo->dwSignature = PVALLOC_SIGNATURE;

    //
    // We insert the new block in the chain immediately after the first (master) block.
    //
    ppvinfoParentNext = ppvinfoParent->pNext;
    ppvinfoParent->pNext = ppvinfo;
    ppvinfo->pNext = ppvinfoParentNext;
}

//-------------------------------------------------------------------------
//
//  Purpose:
//      Allocates a chunk of memory and chains it to a parent block.
//  Parameters:
//      cbSize          - Count of bytes requested.
//      lpvParent       - Pointer to a memory block returned by a previous
//                        pvAlloc call
//  Returns:
//      LPVOID          - Pointer to the allocated memory
//
LPVOID PvAllocMore(IN ULONG cbSize,
                   IN LPVOID lpvParent)
{
    PPVINFO ppvinfo, ppvinfoParent;

    //
    // Get the header for AllocMore parent
    //
    ppvinfoParent = GetHeaderOfAllocMoreParent(lpvParent);

    //
    // Allocate the block and a header just before the requested block
    //
    ppvinfo = (PPVINFO) new BYTE[cbSize + sizeof(PVINFO)];
    if (!ppvinfo)
    {
        ASSERT(0);
        throw bad_alloc();
    }

    //
    // insert the new block in the chain immediately after the first (master) block
    //
    InsertNewBlockToChain(ppvinfo, ppvinfoParent);

    //
    // Return pointer to the actual block just after the header
    //
    return(((LPBYTE)ppvinfo) + sizeof(PVINFO));
}

//-------------------------------------------------------------------------
//
//  Purpose:
//      Same as PvAllocMore, just with dbg info on caller
//  Parameters:
//      cbSize          - Count of bytes requested.
//      lpvParent       - Pointer to a memory block returned by a previous
//                        pvAlloc call
//      pszFile         - File name of caller
//      ulLine          - Line number of caller
//  Returns:
//      LPVOID          - Pointer to the allocated memory
//
LPVOID PvAllocMoreDbg(IN ULONG cbSize,
                      IN LPVOID lpvParent,
                      IN LPCSTR pszFile,
                      IN ULONG ulLine)
{
    PPVINFO ppvinfo, ppvinfoParent;

    //
    // Get the header for AllocMore parent
    //
    ppvinfoParent = GetHeaderOfAllocMoreParent(lpvParent);

    //
    // Allocate the block and a header just before the requested block
    //
    ppvinfo = (PPVINFO) new(pszFile, ulLine) BYTE[cbSize + sizeof(PVINFO)];
    if (!ppvinfo)
    {
        ASSERT(0);
        throw bad_alloc();
    }

    //
    // insert the new block in the chain immediately after the first (master) block
    //
    InsertNewBlockToChain(ppvinfo, ppvinfoParent);

    //
    // Return pointer to the actual block just after the header
    //
    return(((LPBYTE)ppvinfo) + sizeof(PVINFO));
}

//-------------------------------------------------------------------------
//
//  Purpose:
//      This function frees allocations on a memory chain. This memory chain
//      starts with the master block that was returned from a previous pvAlloc
//      call, and is followed by blocks allocated later with pvAllocMore calls
//      that used the given master block as the parent.
//
//  Parameters:
//      lpvParent       - Pointer to a memory block returned by a previous
//                        pvAlloc call
//  Returns:
//      void
//
void PvFree(IN LPVOID lpvParent)
{
    PPVINFO ppvinfo;

    //
    // Sanity check 
    //
    if(!lpvParent)
        return;

    //
    // Get pointer to the header just before the pointed block
    //
    ppvinfo = (PPVINFO)(((LPBYTE)lpvParent) - sizeof(PVINFO));

    //
    // loop over the chain and delete the blocks allocated
    //
    while (ppvinfo)
    {
        PPVINFO ppvinfoNext;

        //
        // Check it is a valid pvinfo header and not garbage
        //
        if (FIsBadPVINFO(ppvinfo))
        {
            ASSERT(0);
            return;
        }

        //
        // Save pointer to next block in the chain
        //
        ppvinfoNext = ppvinfo->pNext;

        //
        // Delete existing block
        //
        delete [] ((LPBYTE)ppvinfo);

        //
        // move to next block in the chain
        //
        ppvinfo = ppvinfoNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\getmqds\dsreg.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:
    dsreg.cpp

Abstract:
    code to handle registry. copied from setup.

Author:
    Doron Juster (DoronJ)

--*/

#include "stdh.h"
#include <_mqreg.h>

//+-------------------------------------------------------------------------
//
//  Function:  _GenerateSubkeyValue
//
//  Synopsis:  Creates a subkey in registry
//
//+-------------------------------------------------------------------------

LONG
_DsGenerateSubkeyValue(
    IN     const TCHAR  * szEntryName,
    IN OUT       TCHAR  * szValueName,
    IN OUT       HKEY    &hRegKey )
{
    //
    // Store the full subkey path and value name
    //
    TCHAR szKeyName[256] = {_T("")};
    _stprintf(szKeyName, TEXT("%s\\%s"), FALCON_REG_KEY, szEntryName);

    TCHAR *pLastBackslash = _tcsrchr(szKeyName, TEXT('\\'));
    if (szValueName)
    {
        lstrcpy(szValueName, _tcsinc(pLastBackslash));
        lstrcpy(pLastBackslash, TEXT(""));
    }

    //
    // Create the subkey, if necessary
    //
    DWORD dwDisposition;
    LONG rc = RegCreateKeyEx( FALCON_REG_POS,
                              szKeyName,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                             &hRegKey,
                             &dwDisposition );

    return rc ;

} // _DsGenerateSubkeyValue

//+-------------------------------------------------------------------------
//
//  Function:  MqReadRegistryValue
//
//  Synopsis:  Gets a MSMQ value from registry (under MSMQ key)
//
//+-------------------------------------------------------------------------

LONG
DsReadRegistryValue(
    IN     const TCHAR   *szEntryName,
    IN OUT       DWORD   *pdwNumBytes,
    IN OUT       PVOID    pValueData )
{
    TCHAR szValueName[256] = {_T("")};
    HKEY hRegKey = NULL ;

    LONG rc = _DsGenerateSubkeyValue( 
                  szEntryName,
                  szValueName,
                  hRegKey 
                  );
    if (rc != ERROR_SUCCESS)
    {
        return rc ;
    }

    //
    // Get the requested registry value
    //
    rc = RegQueryValueEx( hRegKey,
                          szValueName,
                          0,
                          NULL,
                          (BYTE *)pValueData,
                          pdwNumBytes ) ;

    RegCloseKey(hRegKey);

    return rc ;

} // DsReadRegistryValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\getmqds\dsliblog.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:
    dsliblog.cpp

Abstract:
    code to handle logging. In this static library (which is also used from
    setup), we can't assume that mqutil.dll is already loaded.

Author:
    Doron Juster (DoronJ)

--*/

#include "stdh.h"
#include <mqnames.h>

//+---------------------------------
//
//  void DsLibWriteMsmqLog()
//
//+---------------------------------

void _cdecl DsLibWriteMsmqLog( DWORD dwLevel,
                               enum enumLogComponents eLogComponent,
                               DWORD dwSubComponent,
                               WCHAR * Format, ...)
{
    static BOOL s_fInited = FALSE ;
    static WriteToMsmqLog_ROUTINE  s_pfnLog = NULL ;

    if (!s_fInited)
    {
        HINSTANCE hMod =  GetModuleHandle(MQUTIL_DLL_NAME) ;
        if (hMod)
        {
            s_pfnLog = (WriteToMsmqLog_ROUTINE)
                                GetProcAddress(hMod, "WriteToMsmqLog") ;
            ASSERT(s_pfnLog) ;
        }
        s_fInited = TRUE ;
    }

    if (s_pfnLog == NULL)
    {
        //
        // can not log.
        //
        return ;
    }

    #define LOG_BUF_LEN 512
    WCHAR wszBuf[ LOG_BUF_LEN ] ;

    va_list Args;
    va_start(Args,Format);
    _vsntprintf(wszBuf, LOG_BUF_LEN, Format, Args);

    (*s_pfnLog) ( dwLevel,
                  eLogComponent,
                  dwSubComponent,
                  wszBuf ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\getmqds\getrelax.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: getrelax.cpp

Abstract:
    Read nt4 relaxation flag from ADS.

Author:
    Doron Juster (DoronJ)

--*/

#include "stdh.h"
#include "mqprops.h"
#include "autorel.h"

#include <activeds.h>
#include "mqattrib.h"
#include "mqdsname.h"
#include "dsutils.h"
#include "getmqds.h"

//+-------------------------------------------------------
//
//  HRESULT  GetNt4RelaxationStatus(ULONG *pulRelax)
//
//+-------------------------------------------------------

HRESULT APIENTRY  GetNt4RelaxationStatus(ULONG *pulRelax)
{
    CCoInit cCoInit;
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        if (hr == RPC_E_CHANGED_MODE)
        {
            //
            // COM is already initialized on this thread with another threading model. Since we
            // don't care which threading model is used - as long as COM is initialized - we ignore
            // this specific error
            //
            hr = S_OK;
        }
        else
        {
            //
            // failed to initialize COM, return the error
            //
            return hr;
        }
    }

    //
    // load ADsOpenObject
    //
    HINSTANCE hInstAds = LoadLibrary(TEXT("activeds.dll"));
    if (!hInstAds)
    {
        return FALSE;
    }
    CAutoFreeLibrary cFreeLibAds(hInstAds);
    ADsOpenObject_ROUTINE pfnADsOpenObject = (ADsOpenObject_ROUTINE)
                               GetProcAddress(hInstAds, "ADsOpenObject");
    if (!pfnADsOpenObject)
    {
        return E_FAIL ;
    }

    //
    // Bind to RootDSE to get configuration DN
    //
    R<IADs> pRootDSE;
    hr = (*pfnADsOpenObject) ( 
				const_cast<LPWSTR>(x_LdapRootDSE),
				NULL,
				NULL,
				ADS_SECURE_AUTHENTICATION, 
				IID_IADs,
				(void **)&pRootDSE
				);

    if (FAILED(hr))
    {
        return hr ;
    }

    //
    // Get configuration DN
    //
    CAutoVariant varRootDN;
    BS bstrTmp = L"rootDomainNamingContext" ;
    hr = pRootDSE->Get(bstrTmp, &varRootDN);
    if (FAILED(hr))
    {
        return hr;
    }

    VARIANT * pvarRootDN = &varRootDN;
    ASSERT(pvarRootDN->vt == VT_BSTR);
    ASSERT(pvarRootDN->bstrVal);

    DWORD len = wcslen( pvarRootDN->bstrVal );
    if ( len == 0)
    {
        return(MQ_ERROR);
    }
    len +=  x_MsmqServiceContainerPrefixLen +  x_providerPrefixLength + 2 ;

    P<WCHAR> pwszMsmqServices = new WCHAR[ len ] ;
    wcscpy(pwszMsmqServices, x_LdapProvider) ;
    wcscat(pwszMsmqServices, x_MsmqServiceContainerPrefix) ;
    wcscat(pwszMsmqServices, L",") ;
    wcscat(pwszMsmqServices, pvarRootDN->bstrVal) ;

    R<IDirectoryObject> pDirObj ;
    hr = (*pfnADsOpenObject) ( 
				pwszMsmqServices,
				NULL,
				NULL,
				ADS_SECURE_AUTHENTICATION, 
				IID_IDirectoryObject,
				(void **)&pDirObj
				);

    if (FAILED(hr))
    {
        return hr ;
    }

    LPWSTR  ppAttrNames[] = {const_cast<LPWSTR> (MQ_E_NAMESTYLE_ATTRIBUTE)} ;
    DWORD   dwAttrCount = 0 ;
    ADS_ATTR_INFO *padsAttr ;

    hr = pDirObj->GetObjectAttributes( ppAttrNames,
                             (sizeof(ppAttrNames) / sizeof(ppAttrNames[0])),
                                       &padsAttr,
                                       &dwAttrCount ) ;
    if (dwAttrCount != 0)
    {
        ASSERT(dwAttrCount == 1) ;

        ADS_ATTR_INFO adsInfo = padsAttr[0] ;
        if (adsInfo.dwADsType == ADSTYPE_BOOLEAN)
        {
            ADSVALUE *pAdsVal = adsInfo.pADsValues ;
            *pulRelax = (ULONG) pAdsVal->Boolean ;
        }
        else
        {
            ASSERT(0) ;
            *pulRelax = MQ_E_RELAXATION_DEFAULT ;
        }
    }
    else
    {
        *pulRelax = MQ_E_RELAXATION_DEFAULT ;
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\getmqds\stdh.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
	stdh.cpp

Abstract:
	Used only to create precompiled header

Author:	
	RaphiR

--*/
#include "stdh.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\getmqds\stdh.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    precompiled header file

Author:

    Rannanh


--*/

#ifndef __STDH_H
#define __STDH_H

#include "_stdh.h"
#include "mqtypes.h"
#include "mqsymbls.h"


void _cdecl DsLibWriteMsmqLog( DWORD dwLevel,
                               enum enumLogComponents eLogComponent,
                               DWORD dwSubComponent,
                               WCHAR * Format, ...) ;

#endif // __STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\getmqds\getmqds.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    getmqds.cpp

Abstract:
    Find MQDS servers in my site through ADS

Author:
    Raanan Harari (RaananH)

--*/

#include "stdh.h"
#include <mqmacro.h>
#include <activeds.h>
#include "mqdsname.h"
#include "mqattrib.h"
#include "mqprops.h"
#include "autorel.h"
#include "dsutils.h"
#include "cs.h"
#include "getmqds.h"
#include <_mqini.h>

const WCHAR x_wszServerNamePrefix[] = L"\\\\";
const ULONG x_cchServerNamePrefix = STRLEN(x_wszServerNamePrefix);

LONG
DsReadRegistryValue(
    IN     const TCHAR  *szEntryName,
    IN OUT       DWORD  *pdwNumBytes,
    IN OUT       PVOID   pValueData ) ;

STATIC inline void SwitchMqDsServersInAds(MqDsServerInAds * rgServers, ULONG idx1, ULONG idx2)
/*++

Routine Description:
    Switches two MqDsServerInAds entries.
    Uses memcpy to avoid unnecessary constructors/destructors

Arguments:
    rgServers  - array of MqDsServerInAds entries
    idx1, idx2 - indexes to switch

Return Value:
    None

--*/
{
    BYTE rgbServer [sizeof(MqDsServerInAds)];
    memcpy(rgbServer,        &rgServers[idx1], sizeof(MqDsServerInAds));
    memcpy(&rgServers[idx1], &rgServers[idx2], sizeof(MqDsServerInAds));
    memcpy(&rgServers[idx2], rgbServer,        sizeof(MqDsServerInAds));
}


BOOLEAN CGetMqDS::GetServerDNS(IN LPCWSTR pwszSettingsDN,
                                           OUT LPWSTR * ppwszServerName)
/*++

Routine Description:
    Gets server DNS name from the server object in the configuration site servers

Arguments:
    pwszSettingsDN   - MSMQ Settings DN
    ppwszServerName  - Server name returned

Return Value:
    BOOLEAN

--*/
{
    //
    // skip CN=MSMQ Settings,
    //
    LPWSTR pwszTmp = wcschr(pwszSettingsDN, L',');
    if (pwszTmp)
    {
        pwszTmp++;
    }
    if (!pwszTmp)
    {
        return FALSE;
    }

	//
	//	bind to the server object
	//
    R<IADs> pIADs;
	HRESULT hr;
	DWORD len = wcslen(pwszTmp);

    const WCHAR x_wszLDAP[] = L"LDAP://";
	AP<WCHAR> pwcsServerDN = new WCHAR[ ARRAY_SIZE(x_wszLDAP) +	 len +
                                        wcslen(m_pwszOptionalDcForBinding) + 1];

	swprintf(
		pwcsServerDN,
		L"%s%s%s",
		x_wszLDAP,
		m_pwszOptionalDcForBinding,
		pwszTmp
        );

	DWORD Flags = ADS_SECURE_AUTHENTICATION;
    if (wcslen(m_pwszOptionalDcForBinding) != 0)
	{
		Flags |= ADS_SERVER_BIND;
	}
    hr = (*m_pfnADsOpenObject) ( 
				pwcsServerDN,
				NULL,
				NULL,
				Flags,
				IID_IADs,
				(void**)&pIADs 
				);

    if (FAILED(hr))
    {
        return FALSE;
    }
	//
	//	Get the dNSHostName value
	//
    CAutoVariant varResult;
    BS bsProp = L"dNSHostName";
    hr = pIADs->Get(bsProp, &varResult);
    if (FAILED(hr) || ((V_BSTR(&varResult)) == NULL))
    {
        return FALSE;
    }

    //
    // copy server name
    //
    AP<WCHAR> pwszServerName = new WCHAR [wcslen((V_BSTR(&varResult))) + 1];
    wcscpy(pwszServerName, (V_BSTR(&varResult)));

    //
    // return results
    //
    *ppwszServerName = pwszServerName.detach();
    return TRUE;
}


STATIC BOOL LoadAdsRoutines(OUT DsGetSiteName_ROUTINE * ppfnDsGetSiteName,
                            OUT DsGetDcName_ROUTINE * ppfnDsGetDcName,
                            OUT NetApiBufferFree_ROUTINE * ppfnNetApiBufferFree,
                            OUT ADsOpenObject_ROUTINE * ppfnADsOpenObject,
                            OUT HINSTANCE * phInstNet,
                            OUT HINSTANCE * phInstAds)
/*++

Routine Description:
    Dynamically load several ADS functions

Arguments:
    ppfnDsGetSiteName - returned DsGetSiteName()
    ppfnDsGetDcName   - returned DsGetDcName()
    ppfnNetApiBufferFree - returned NetApiBufferFree()
    ppfnADsOpenObject - returned ADsOpenObject()
    phInstNet         - returned handle to netapi32.dll
    phInstAds         - returned handle to activeds.dll

Return Value:
    TRUE if load succeeded, FALSE otherwise

--*/
{
    //
    // load DsGetSiteName, DsGetDcName, NetApiBufferFree
    //
    HINSTANCE hInstNet = LoadLibrary(TEXT("netapi32.dll"));
    if (!hInstNet)
    {
        return FALSE;
    }
    CAutoFreeLibrary cFreeLibNet(hInstNet);
    DsGetSiteName_ROUTINE pfnDsGetSiteName = (DsGetSiteName_ROUTINE) GetProcAddress(hInstNet, "DsGetSiteNameW");
    DsGetDcName_ROUTINE pfnDsGetDcName = (DsGetDcName_ROUTINE) GetProcAddress(hInstNet, "DsGetDcNameW");
    NetApiBufferFree_ROUTINE pfnNetApiBufferFree = (NetApiBufferFree_ROUTINE) GetProcAddress(hInstNet, "NetApiBufferFree");
    if ((pfnDsGetSiteName == NULL) ||
        (pfnDsGetDcName == NULL) ||
        (pfnNetApiBufferFree == NULL))
    {
        return FALSE;
    }

    //
    // load ADsOpenObject
    //
    HINSTANCE hInstAds = LoadLibrary(TEXT("activeds.dll"));
    if (!hInstAds)
    {
        return FALSE;
    }
    CAutoFreeLibrary cFreeLibAds(hInstAds);
    ADsOpenObject_ROUTINE pfnADsOpenObject = (ADsOpenObject_ROUTINE) GetProcAddress(hInstAds, "ADsOpenObject");
    if (!pfnADsOpenObject)
    {
        return FALSE;
    }

    //
    // return values
    //
    *ppfnDsGetSiteName = pfnDsGetSiteName;
    *ppfnDsGetDcName = pfnDsGetDcName;
    *ppfnNetApiBufferFree = pfnNetApiBufferFree;
    *ppfnADsOpenObject = pfnADsOpenObject;
    *phInstNet = cFreeLibNet.detach();
    *phInstAds = cFreeLibAds.detach();
    return TRUE;
}

//
// class CGetMqDS
//

CGetMqDS::CGetMqDS()
{
    m_pfnDsGetSiteName = NULL;
    m_pfnDsGetDcName = NULL;
    m_pfnNetApiBufferFree = NULL;
    m_pfnADsOpenObject = NULL;
    m_fInited = FALSE;
    m_fAdsExists = FALSE;
    m_fInitedAds = FALSE;
    m_pwszSiteName = NULL;
    //
    // point to an empty string so that by default we don't specify a DC in bindings
    //
    m_pwszOptionalDcForBinding = L"";
}


CGetMqDS::~CGetMqDS()
{
    if (m_pwszSiteName)
    {
        ASSERT(m_fInitedAds);
        ASSERT(m_pfnNetApiBufferFree);
        (*m_pfnNetApiBufferFree)(m_pwszSiteName);
    }
    //
    // other members are auto release
    //
}


void CGetMqDS::Init()
/*++

Routine Description:
    Load ADS functions, and try to initialize ADS.
    Can be called multiple times with no effect

Arguments:
    None

Return Value:
    None

--*/
{
    //
    // enter critical section (check/update m_fInited)
    //
    CS cs(m_cs);

    //
    // init can be called several times
    // if we're inited already, return immediately
    //
    if (m_fInited)
    {
        return;
    }

    //
    // load the Ads funcs
    //
    if (!LoadAdsRoutines(&m_pfnDsGetSiteName,
                         &m_pfnDsGetDcName,
                         &m_pfnNetApiBufferFree,
                         &m_pfnADsOpenObject,
                         &m_hLibNetapi32,
                         &m_hLibActiveds))
    {
        m_fAdsExists = FALSE;
    }
    else
    {
        //
        // can connect to Ads
        //
        m_fAdsExists = TRUE;
    }
    m_fInited = TRUE;

    //
    // while we're here, try to get data from Ads, but don't fail init
    // if not succeeded, it might be a temporary problem
    //
    if (m_fAdsExists)
    {
        InitAds();
    }
}


HRESULT CGetMqDS::InitAds()
/*++

Routine Description:
    Prepares Ads data that is common to subsequent calls to FindMqDsServersInAds
    It is here because of performance reasons, and because there are
    memory leaks in ADSI when doing these actions repeatedly

Arguments:
    None

Return Value:
    MQ_OK                   - Success
    MQ_ERROR_NO_DS          - No Active DS support on client
    other HRESULT errors    - real errors

--*/
{
    ASSERT(m_fInited); //just to catch bad execution flow

    //
    // check that we have Ads funcs
    //
    if (!m_fAdsExists)
    {
        return MQ_ERROR_NO_DS;
    }

    //
    // enter critical section (check/update m_fInitedAds)
    //
    CS cs(m_cs);

    //
    // if we're inited already, return immediately
    //
    if (m_fInitedAds)
    {
        return MQ_OK;
    }

    //
    // Get my site name, remeber to free it with NetApiBufferFree
    //
    // BUGBUG we might want to change this call to DsGetDcName POST_BETA3 - will get us the same
    // info, plus will save us another DsGetDcName call to find a DC for the computer domain to bind
    // to incase ADSI can't bind to the user domain (see binding to rootdse below). RaananH
    //
    LPWSTR pwszSiteName;
    DWORD dwRet = (*m_pfnDsGetSiteName)(NULL, &pwszSiteName);
    if (dwRet != NO_ERROR)
    {
        DsLibWriteMsmqLog( MSMQ_LOG_WARNING,
                           e_LogDS,
                           LOG_DS_FIND_SITE,
                         L"getmqds: DcGetSiteName() failed, hr- %lxh, %lut",
                           dwRet, dwRet ) ;

        return HRESULT_FROM_WIN32(dwRet);
    }
    CAutoFreeFn cFreeSiteName(pwszSiteName, m_pfnNetApiBufferFree);

    //
    // init COM with auto release (for getting configuration DN)
    //
    CCoInit cCoInit;
    HRESULT hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        if (hr == RPC_E_CHANGED_MODE)
        {
            //
            // COM is already initialized on this thread with another threading model. Since we
            // don't care which threading model is used - as long as COM is initialized - we ignore
            // this specific error
            //
            hr = S_OK;
        }
        else
        {
            //
            // failed to initialize COM, return the error
            //
            return hr;
        }
    }

    //
    // Bind to RootDSE to get configuration DN
    //
    R<IADs> pRootDSE;

    hr = (*m_pfnADsOpenObject) ( 
				const_cast<LPWSTR>(x_LdapRootDSE),
				NULL,
				NULL,
				ADS_SECURE_AUTHENTICATION,
				IID_IADs,
				(void**)&pRootDSE 
				);

    if (FAILED(hr))
    {
        if (hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN))
        {
            return hr;
        }
        //
        // We got ERROR_NO_SUCH_DOMAIN
        // By default ADSI tries to use the user domain for binding, and it might be that it is
        // an NT4 domain without ADS. We need to use a DC for the computer instead.
        // Get DC for the computer domain. Remember to free the buffer with NetApiBufferFree
        //
        DOMAIN_CONTROLLER_INFO * pDcInfo;
        DWORD dwRet = (*m_pfnDsGetDcName)(NULL, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED, &pDcInfo);
        if (dwRet != NO_ERROR)
        {
            return HRESULT_FROM_WIN32(dwRet);
        }
        CAutoFreeFn cFreeDcInfo(pDcInfo, m_pfnNetApiBufferFree);
        //
        // Save DC name, skip \\ prefix
        //
        ASSERT(pDcInfo->DomainControllerName);
        LPCWSTR pwszDcName = pDcInfo->DomainControllerName;
        if (wcsncmp(pwszDcName, x_wszServerNamePrefix, x_cchServerNamePrefix) == 0)
        {
            pwszDcName += x_cchServerNamePrefix;
        }
        ULONG cchDcName = wcslen(pwszDcName);
        m_pwszBufferForOptionalDcForBinding = new WCHAR [2 + cchDcName]; // need to append a slash
        wcscpy(m_pwszBufferForOptionalDcForBinding, pwszDcName);
        //
        // remove trailing dot if any
        //
        if (cchDcName > 0)
        {
            if (m_pwszBufferForOptionalDcForBinding[cchDcName-1] == L'.')
            {
                cchDcName--;
            }
        }
        //
        // append a slash to its end
        //
        m_pwszBufferForOptionalDcForBinding[cchDcName] = L'/';
        m_pwszBufferForOptionalDcForBinding[cchDcName+1] = L'\0';
        //
        // point to it so we use it instead of the empty string for future bindings
        //
        m_pwszOptionalDcForBinding = m_pwszBufferForOptionalDcForBinding;
        //
        // compute LDAP path to rootdse on the specified DC
        //
        const WCHAR x_wszFmtRootDSE[] = L"LDAP://%lsRootDSE";
        AP<WCHAR> pwszRootDSE = new WCHAR [ARRAY_SIZE(x_wszFmtRootDSE) +
                                           wcslen(m_pwszOptionalDcForBinding) + 1];
        swprintf(pwszRootDSE, x_wszFmtRootDSE, m_pwszOptionalDcForBinding);
        //
        // try the binding to rootdse again, this time return an error if it fails
        //
		hr = (*m_pfnADsOpenObject) ( 
					pwszRootDSE,
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**)&pRootDSE 
					);

        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    // Get configuration DN
    //
    CAutoVariant varConfigDN;
    BS bstrTmp = x_ConfigurationNamingContext;
    hr = pRootDSE->Get(bstrTmp, &varConfigDN);
    if (FAILED(hr))
    {
        return hr;
    }
    VARIANT * pvarConfigDN = &varConfigDN;
    ASSERT(pvarConfigDN->vt == VT_BSTR);
    ASSERT(pvarConfigDN->bstrVal);

    //
    // Build LDAP pathname of this site servers container in ADS
    //
    const WCHAR x_wszFmtConfigurationSiteServers[] = L"LDAP://%lsCN=Servers,CN=%ls,CN=Sites,%ls";
    AP<WCHAR> pwszConfigurationSiteServers = new WCHAR [ARRAY_SIZE(x_wszFmtConfigurationSiteServers) +
                                                        wcslen(m_pwszOptionalDcForBinding) +
                                                        wcslen(pwszSiteName) +
                                                        wcslen(pvarConfigDN->bstrVal) + 1];
    swprintf(pwszConfigurationSiteServers,
             x_wszFmtConfigurationSiteServers,
             m_pwszOptionalDcForBinding,
             (LPWSTR)pwszSiteName,
             pvarConfigDN->bstrVal);

    //
    // Build search preference
    //
    m_sSearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
    m_sSearchPrefs[0].vValue.dwType = ADSTYPE_BOOLEAN;
    m_sSearchPrefs[0].vValue.Boolean = FALSE;
    m_sSearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    m_sSearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    m_sSearchPrefs[1].vValue.Integer = ADS_SCOPE_SUBTREE;

    //
    // Build search filter (objectClass = mSMQSettings) AND (mSMQServices >= SERVICE_BSC)
    //
    const WCHAR x_wszFmtSearchFilter[] = L"(&(objectClass=%ls)(%ls=TRUE))";     // [adsrv] what is the syntax?
    ULONG ulLen = ARRAY_SIZE(x_wszFmtSearchFilter) +
                  ARRAY_SIZE(MSMQ_SETTING_CLASS_NAME) +
                  ARRAY_SIZE(MQ_SET_SERVICE_DSSERVER_ATTRIBUTE) +
                  20; //arbitrary, max characters for short decimal
    AP<WCHAR> pwszSearchFilter = new WCHAR [ulLen + 1];
    swprintf(pwszSearchFilter,
             x_wszFmtSearchFilter,
             MSMQ_SETTING_CLASS_NAME,
             MQ_SET_SERVICE_DSSERVER_ATTRIBUTE);  // [adsrv]   SERVICE_BSC);

    //
    // Build search attributes requested
    // [adsrv]
    //
    m_sSearchAttrs[0] = x_AttrDistinguishedName;
    m_sSearchAttrs[1] = MQ_SET_SERVICE_DSSERVER_ATTRIBUTE;     // [adsrv] MQ_SET_SERVICE_ATTRIBUTE;
    m_sSearchAttrs[2] = MQ_SET_NT4_ATTRIBUTE;

    //
    // remember values & mark Ads inited
    //
    m_pwszConfigurationSiteServers = pwszConfigurationSiteServers.detach();
    m_pwszSearchFilter = pwszSearchFilter.detach();
    m_pwszSiteName = (LPWSTR) cFreeSiteName.detach();
    m_fInitedAds = TRUE;
    return MQ_OK;
}


HRESULT CGetMqDS::_FindMqDsServersInAds(
                           OUT ULONG * pcServers,
                           OUT MqDsServerInAds ** prgServers)
/*++

Routine Description:
    Find MSMQ DS servers in NT5 ADS. The servers are returned in a random
    order for load balancing.

Arguments:
    pcServers   - number of servers returned
    prgServers  - array of servers returned

Return Value:
    MQ_OK                   - returned results (could be 0 servers)
    MQ_ERROR_NO_DS          - No Active DS support on client
    other HRESULT errors    - real errors

--*/
{
    ASSERT(pcServers);
    ASSERT(prgServers);
    *pcServers = 0;
    *prgServers = NULL;

    //
    // initialize the class
    // this immediately returns if the class is already initialized
    //
    Init();

    //
    // check that Ads is inited
    //
    HRESULT hr = InitAds();
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // init COM
    //
    CCoInit cCoInit;
    hr = cCoInit.CoInitialize();
    if (FAILED(hr))
    {
        if (hr == RPC_E_CHANGED_MODE)
        {
            //
            // COM is already initialized on this thread with another threading model. Since we
            // don't care which threading model is used - as long as COM is initialized - we ignore
            // this specific error
            //
            hr = S_OK;
        }
        else
        {
            //
            // failed to initialize COM, return the error
            //
            return hr;
        }
    }

    //
    // Bind to servers of this site in ADS
    //
    R<IDirectorySearch> pDirSearch;
	hr = (*m_pfnADsOpenObject) ( 
				m_pwszConfigurationSiteServers,
				NULL,
				NULL,
				ADS_SECURE_AUTHENTICATION,
				IID_IDirectorySearch,
				(void**)&pDirSearch 
				);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Set search preference
    //
    hr = pDirSearch->SetSearchPreference(m_sSearchPrefs, ARRAY_SIZE(m_sSearchPrefs));
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Execute search
    //
    ADS_SEARCH_HANDLE hSearch;
    hr = pDirSearch->ExecuteSearch(
                m_pwszSearchFilter,
                const_cast<LPWSTR *>(m_sSearchAttrs),
                ARRAY_SIZE(m_sSearchAttrs),
                &hSearch);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Make sure search handle is eventually closed
    //
    CAutoCloseSearchHandle cCloseSearchHandle(pDirSearch.get(), hSearch);

    //
    // Count number of rows
    //
    ULONG cRows = 0;
    hr = pDirSearch->GetFirstRow(hSearch);
    while (SUCCEEDED(hr) && (hr != S_ADS_NOMORE_ROWS))
    {
        cRows++;
        hr = pDirSearch->GetNextRow(hSearch);
    }
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // exit if no servers
    //
    if (cRows == 0)
    {
        *pcServers = 0;
        *prgServers = NULL;
        return MQ_OK;
    }

    //
    // Allocate place for returned servers
    //
    AP<MqDsServerInAds> rgServers = new MqDsServerInAds[cRows];
    ULONG cServers = 0;

    //
    // Get servers (make sure we don't overrun somehow the allocated buffer)
    //
    hr = pDirSearch->GetFirstRow(hSearch);
    while (SUCCEEDED(hr) && (hr != S_ADS_NOMORE_ROWS) && (cServers < cRows))
    {
        MqDsServerInAds * pServer = &rgServers[cServers];

        //
        // Get DN, Make sure the column is freed eventually
        //
        ADS_SEARCH_COLUMN columnDN;
        hr = pDirSearch->GetColumn(hSearch, const_cast<LPWSTR>(x_AttrDistinguishedName), &columnDN);
        if (FAILED(hr))
        {
            //
            // DN must be there
            //
            return hr;
        }
        CAutoReleaseColumn cAutoReleaseColumnDN(pDirSearch.get(), &columnDN);
        //
        // Find Server DNS name
        //
        if (!columnDN.pADsValues->DNString)
        {
            ASSERT(0);
            return MQ_ERROR;
        }
        if (!GetServerDNS(columnDN.pADsValues->DNString, &pServer->pwszName))
        {
            return MQ_ERROR;
        }


        //
        // get NT4 flags (optional prop) (check if server is ADS)
        //
        ADS_SEARCH_COLUMN columnNT4;
        hr = pDirSearch->GetColumn(hSearch, const_cast<LPWSTR>(MQ_SET_NT4_ATTRIBUTE), &columnNT4);
        if (SUCCEEDED(hr))
        {
            //
            // Make sure the column is freed eventually (end of this block)
            //
            CAutoReleaseColumn cAutoReleaseColumnNT4(pDirSearch.get(), &columnNT4);
            //
            // if the property contains 0, it is NT5, otherwise NT4
            //
            if (columnNT4.pADsValues->Integer == 0)
            {
                pServer->fIsADS = TRUE;
            }
            else
            {
                pServer->fIsADS = FALSE;
            }
        }
        else if (hr == E_ADS_COLUMN_NOT_SET)
        {
            //
            // property is not there, it is nt5 ADS
            //
            pServer->fIsADS = TRUE;
        }
        else // not SUCCEEDED and not E_ADS_COLUMN_NOT_SET
        {
            //
            // real error
            //
            return hr;
        }

        //
        // Continue to next server
        //
        cServers++;
        hr = pDirSearch->GetNextRow(hSearch);
    }
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // rearrange the servers in random order for load balancing
    //
    srand(GetTickCount());
    for (DWORD cTmp = cServers; cTmp > 1; cTmp--)
    {
        //
        // find index to switch with last entry (0 to cTmp - 1)
        //
        DWORD idxSwitch = rand() % cTmp;
        //
        // if the index is not the last entry, switch the last entry with it
        //
        if (idxSwitch != cTmp - 1)
        {
            //
            // switch the entries
            //
            SwitchMqDsServersInAds(rgServers, cTmp - 1, idxSwitch);
        }
    }

    //
    // Try to rearrange the list such that the first server in the list a DC of this
    // computer's domain (#3820). Ignore errors.
    //
    if (cServers > 0)
    {
        MakeComputerDcFirst(cServers, rgServers);
        //
        // Some errors are expected when trying to rearrange the list (#4236).
        // BUGBUG - for post-beta3 we might want to research them and assert on unexpected
        // errors only, or change the called function to swallow them (RaananH)
        //
    }

    //
    // return results
    //
    *pcServers = cServers;
    *prgServers = rgServers.detach();
    return MQ_OK;
}

HRESULT CGetMqDS::FindMqDsServersInAds(
                           OUT ULONG * pcServers,
                           OUT MqDsServerInAds ** prgServers)
/*++

Routine Description:
    Find MSMQ DS servers in NT5 ADS. The servers are returned in a random
    order for load balancing.

Arguments:
    pcServers   - number of servers returned
    prgServers  - array of servers returned

Return Value:
    MQ_OK                   - returned results (could be 0 servers)
    MQ_ERROR_NO_DS          - No Active DS support on client
    other HRESULT errors    - real errors

--*/
{
    HRESULT hr = _FindMqDsServersInAds( pcServers,
                                        prgServers ) ;
    if (SUCCEEDED(hr) && (*pcServers > 0))
    {
        return hr ;
    }

    //
    // Server not found. Try to read from registry.
    //
    DWORD  dwSize = 0 ;

    LONG res = DsReadRegistryValue( MSMQ_FORCED_DS_SERVER_REGNAME,
                                   &dwSize,
                                    NULL ) ;
    if (dwSize > 0)
    {
        P<WCHAR> pwszValue = new WCHAR[ dwSize ] ;

        res = DsReadRegistryValue( MSMQ_FORCED_DS_SERVER_REGNAME,
                                  &dwSize,
                                   pwszValue ) ;

        if (res == ERROR_SUCCESS)
        {
            *prgServers = new MqDsServerInAds[1] ;
            (*prgServers)->pwszName =  new WCHAR[ dwSize ] ;
            wcscpy((*prgServers)->pwszName, pwszValue) ;
            pwszValue.detach();

            (*prgServers)->fIsADS = TRUE ;
            *pcServers = 1 ;

            hr = MQ_OK ;
        }
    }

    return hr ;
}


HRESULT CGetMqDS::MakeComputerDcFirst(
                           IN ULONG cServers,
                           IN OUT MqDsServerInAds * rgServers)
/*++

Routine Description:
    Rearrange the list of servers such that the first one is a DC of this computer's
    domain. The reason is that most of the DS calls are made against queues that are part of
    the computer object, so they are better performed against a DC of the machine's domain. This
    might also save replication delays of updates.

Arguments:
    cServers   - number of servers
    rgServers  - array of servers

Return Value:
    MQ_OK                   - returned results (could be 0 servers)
    other HRESULT errors    - real errors

--*/
{
    BOOL fComputerDcIsFirst;
    return MakeComputerDcFirstByUsingDsGetDcName(cServers, rgServers, &fComputerDcIsFirst);
}


STATIC void GetFlatNameOfDcName(LPCWSTR pwszDcName, LPWSTR * ppwszFlatDcName)
/*++

Routine Description:
    Gets the flat name of a DC

Arguments:
    pwszDcName      - DC name can be \\name or \\name.dom1.dom2....
    ppwszFlatDcName - returned flat DC name

Return Value:
    None

--*/
{
    //
    // find beginning of flat name, advance past \\ before the name (if any)
    //
    LPCWSTR pwszStart;
    if (wcsncmp(pwszDcName, x_wszServerNamePrefix, x_cchServerNamePrefix) == 0)
    {
        pwszStart = pwszDcName + x_cchServerNamePrefix;
    }
    else
    {
        pwszStart = pwszDcName;
    }
    //
    // find end of flat name
    //
    LPCWSTR pwszEnd = wcschr(pwszDcName, L'.');
    if (pwszEnd == NULL)
    {
        pwszEnd = pwszDcName + wcslen(pwszDcName);
    }
    //
    // get the flat name of the DC
    //
    ULONG_PTR cchFlatDcName = pwszEnd - pwszStart;
    AP<WCHAR> pwszFlatDcName = new WCHAR[1 + cchFlatDcName];
    memcpy(pwszFlatDcName, pwszStart, cchFlatDcName*sizeof(WCHAR));
    pwszFlatDcName[cchFlatDcName] = L'\0';
    //
    // return results
    //
    *ppwszFlatDcName = pwszFlatDcName.detach();
}


HRESULT CGetMqDS::MakeComputerDcFirstByUsingDsGetDcName(
                           IN ULONG cServers,
                           IN OUT MqDsServerInAds * rgServers,
                           OUT BOOL *pfComputerDcIsFirst)
/*++

Routine Description:
    Rearrange the list of servers such that the first one is a DC of this computer's
    domain. This routine calls DsGetDcName to get a DC for the computer's domain, and see if it is in the
    list of the servers. If so, we move it to be the first. If not, it might be that the Dc doesn't
    have MSMQ installed on it, so we return an indication that we didn't rearrange the list

Arguments:
    cServers            - number of servers
    rgServers           - array of servers
    pfComputerDcIsFirst - on success, whether the first server is known to be a DC for this computer

Return Value:
    MQ_OK                   - returned results (could be we didn't rearrange the list)
    other HRESULT errors    - real errors

--*/
{
    //
    // we want an NT5 DC (so that it might have MQDS server on it from the list)
    //
    ULONG ulFlags = DS_DIRECTORY_SERVICE_REQUIRED;
    //
    // get a DC for this computer's domain, from this site, and remember to free the buffer later
    //
    DOMAIN_CONTROLLER_INFO * pDcInfo;
    DWORD dwRes = (*m_pfnDsGetDcName)(NULL, NULL, NULL, m_pwszSiteName, ulFlags, &pDcInfo);
    if (dwRes != NO_ERROR)
    {
        return HRESULT_FROM_WIN32(dwRes);
    }
    CAutoFreeFn cFreeDcInfo(pDcInfo, m_pfnNetApiBufferFree);
    //
    // check whether the returned DC is in our site
    //
    BOOL fWrongSite;
    if (pDcInfo->DcSiteName == NULL)
    {
        fWrongSite = TRUE;
    }
    else if (_wcsicmp(pDcInfo->DcSiteName, m_pwszSiteName) != 0)
    {
        fWrongSite = TRUE;
    }
    else
    {
        fWrongSite = FALSE;
    }
    if (fWrongSite)
    {
        //
        // the returned DC is not in our site, we cant use it.
        //
        *pfComputerDcIsFirst = FALSE;
        return MQ_OK;
    }
    //
    // get the flat name of the DC. We munge it, so we need a buffer for it.
    //
    AP<WCHAR> pwszFlatDcName;
    ASSERT(pDcInfo->DomainControllerName);
    GetFlatNameOfDcName(pDcInfo->DomainControllerName, &pwszFlatDcName);
    //
    // lookup this DC in the list of servers. If found, move it to be the first
    //
    ULONG idxFoundServer = 0;
    MqDsServerInAds * pServer = rgServers;
    BOOL fServerNotFound = TRUE;
    for (ULONG ulServer = 0; (ulServer < cServers) && fServerNotFound; ulServer++, pServer++)
    {
        if (_wcsicmp(pServer->pwszName, pwszFlatDcName) == 0)
        {
            fServerNotFound = FALSE;
            idxFoundServer = ulServer;
        }
    }
    //
    // if DC not found in the list it might be that MSMQ is not installed on it.
    // mark that we couldn't rearrange the server's list, and return.
    //
    if (fServerNotFound)
    {
        *pfComputerDcIsFirst = FALSE;
        return MQ_OK;
    }
    //
    // move this server to be the first (if it is not the first already)
    //
    if (idxFoundServer != 0)
    {
        SwitchMqDsServersInAds(rgServers, 0, idxFoundServer);
    }
    //
    // mark that the first server is indeed of the computer's domain, and return
    //
    *pfComputerDcIsFirst = TRUE;
    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\h\dsinc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dsinc.h

Abstract:

    Include file of internal DS structures

Author:

    Ronit Hartmann (ronith)

--*/
#ifndef __DSINC_H__
#define __DSINC_H__

//
//	Defines
//
//

typedef struct _PROP_INFO

{
	PROPID	prop;
	int		iPropSetNum;
	LPSTR	pszName;
} PROP_INFO;


#define EXECUTE_EXCEPTION(type)				\
		(GetExceptionCode() == type) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH	\

/*----------------------
	Table Open mode
-----------------------*/
#define	CREATE_TABLE	1
#define OPEN_TABLE		2


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\h\dsreqinf.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    dsreqinf.h

Abstract:
    DS request information and stat


Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __DSREQINF_H__
#define __DSREQINF_H__

//--------------------------
//
//  enum eImpersonate
//
//--------------------------

enum enumImpersonate
{
    e_DoNotImpersonate = 0,
    e_DoImpersonate = 1
} ;

enum enumRequesterProtocol
{
    e_IP_PROTOCOL,
    e_RESERVED_PROTOCOL,
    e_ALL_PROTOCOLS
};

//-----------------------------------------
// Definition of a class that DS request parameters.
// This class is created per each DS request
//
// ***********************************************
//  NOTE:
//  =====
//  When adding members to the class, make sure
//  that the usage of the class is correct ( i.e
//  that the same object is not use in multiple
//  DS calls)
// ***********************************************
//-----------------------------------------
class CDSRequestContext
{
public:
	CDSRequestContext(
				BOOL				    fImpersonate,
				enumRequesterProtocol	eProtocol
				);
    CDSRequestContext(
			enumImpersonate         eImpersonate,
			enumRequesterProtocol	eProtocol
			);

	~CDSRequestContext();

    BOOL NeedToImpersonate();
    void SetDoNotImpersonate();
    void SetDoNotImpersonate2();

    enumRequesterProtocol GetRequesterProtocol() const;
    void SetAllProtocols();

    void AccessVerified(BOOL fAccessVerified) ;
    BOOL IsAccessVerified() const ;

    void SetKerberos(BOOL fKerberos) ;
    BOOL IsKerberos() const ;

private:
    enumImpersonate         m_eImpersonate;
    enumRequesterProtocol   m_eProtocol;
    BOOL                    m_fAccessVerified ;
    BOOL                    m_fKerberos ;
};

inline CDSRequestContext::CDSRequestContext(
				BOOL				    fImpersonate,
				enumRequesterProtocol	eProtocol
                ) :
                m_fAccessVerified(FALSE),
                m_fKerberos(TRUE),
                m_eProtocol( eProtocol)
{
    m_eImpersonate =  fImpersonate ? e_DoImpersonate : e_DoNotImpersonate;
}

inline CDSRequestContext::CDSRequestContext(
			enumImpersonate         eImpersonate,
			enumRequesterProtocol	eProtocol
            ):
            m_fAccessVerified(FALSE),
            m_fKerberos(TRUE),
            m_eImpersonate( eImpersonate),
            m_eProtocol( eProtocol)
{
}

inline  CDSRequestContext::~CDSRequestContext( )
{
}

inline BOOL CDSRequestContext::NeedToImpersonate()
{
    return( m_eImpersonate == e_DoImpersonate);
}

inline void CDSRequestContext::SetDoNotImpersonate()
{
    ASSERT(m_eImpersonate == e_DoImpersonate);
    m_eImpersonate = e_DoNotImpersonate;
}

inline void CDSRequestContext::SetDoNotImpersonate2()
{
    //
    // do not assert, as this may be used from migration tool and replication
    // service.
    //
    m_eImpersonate = e_DoNotImpersonate;
}

inline enumRequesterProtocol CDSRequestContext::GetRequesterProtocol() const
{
    return(m_eProtocol);
}


inline void CDSRequestContext::SetAllProtocols()
{
    m_eProtocol =  e_ALL_PROTOCOLS;
}

inline void CDSRequestContext::AccessVerified(BOOL fAccessVerified)
{
    m_fAccessVerified = fAccessVerified ;
}

inline BOOL CDSRequestContext::IsAccessVerified() const
{
    return m_fAccessVerified ;
}

inline void CDSRequestContext::SetKerberos(BOOL fKerberos)
{
    m_fKerberos = fKerberos ;
}

inline BOOL CDSRequestContext::IsKerberos() const
{
    return m_fKerberos ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\h\ds_stdh.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ds_stdh.h

Abstract:

    precompiled header file for MQNT5 provider

Author:

    Ronith

--*/

#ifndef __DS_STDH_H
#define __DS_STDH_H

#include <_stdh.h>

#include "mqtypes.h"
#include <_guid.h>
#include <wincrypt.h>

#include "mqsymbls.h"
#include "mqprops.h"
#include "mqnames.h"
#include "cs.h"
#include "mqlog.h"

#endif // __DS_STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\h\dscore.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    dscore.h

Abstract:
    ds core api

Author:
    ronit hartmann (ronith)

Revision History:
--*/

#ifndef _DSCORE_H
#define _DSCORE_H

#include "mqads.h"
#include "dsreqinf.h"


HRESULT
DSCoreCreateObject( IN DWORD            dwObjectType,
                    IN LPCWSTR          pwcsPathName,
                    IN DWORD            cp,
                    IN PROPID           aProp[  ],
                    IN PROPVARIANT      apVar[  ],
                    IN DWORD            cpEx,
                    IN PROPID           aPropEx[  ],
                    IN PROPVARIANT      apVarEx[  ],
                    IN CDSRequestContext *         pRequestContext,
                    IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,    // optional request for object info
                    IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest); // optional request for parent info

HRESULT
DSCoreCreateMigratedObject(
                IN DWORD                  dwObjectType,
                IN LPCWSTR                pwcsPathName,
                IN DWORD                  cp,
                IN PROPID                 aProp[  ],
                IN PROPVARIANT            apVar[  ],
                IN DWORD                  cpEx,
                IN PROPID                 aPropEx[  ],
                IN PROPVARIANT            apVarEx[  ],
                IN CDSRequestContext         * pRequestContext,
                IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest,    // optional request for object info
                IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest, // optional request for parent info
                //
                // if fReturnProperties
                // we have to return full path name and provider
                // if fUseProperties we have to use these values
                //
                IN BOOL                    fUseProperties,
                IN BOOL                    fReturnProperties,
                IN OUT LPWSTR              *ppwszFullPathName,
                IN OUT ULONG               *pulProvider ) ;


HRESULT
DSCoreDeleteObject( IN  DWORD           dwObjectType,
                    IN  LPCWSTR         pwcsPathName,
                    IN  CONST GUID    * pguidIdentifier,
                    IN CDSRequestContext * pRequestContext,
                    IN OUT MQDS_OBJ_INFO_REQUEST * pParentInfoRequest );

HRESULT
DSCoreGetProps(
             IN  DWORD              dwObjectType,
             IN  LPCWSTR            pwcsPathName,
             IN  CONST GUID *       pguidIdentifier,
             IN  DWORD              cp,
             IN  PROPID             aProp[  ],
             IN  CDSRequestContext *pRequestContext,
             OUT PROPVARIANT        apVar[  ]);

HRESULT
DSCoreInit(
        IN BOOL                  fSetupMode,
        IN BOOL                  fReplicaionMode = FALSE
        );

HRESULT
DSCoreLookupBegin(
                IN  LPWSTR          pwcsContext,
                IN  MQRESTRICTION   *pRestriction,
                IN  MQCOLUMNSET     *pColumns,
                IN  MQSORTSET       *pSort,
                IN  CDSRequestContext * pRequestContext,
                IN  HANDLE          *pHandle
                );


HRESULT
DSCoreLookupNext(
                    HANDLE              handle,
                    DWORD  *            pdwSize,
                    PROPVARIANT  *      pbBuffer);

HRESULT
DSCoreLookupEnd(
                IN HANDLE handle
                );

void
DSCoreTerminate();

HRESULT
DSCoreGetComputerSites(
            IN  LPCWSTR     pwcsComputerName,
            OUT DWORD  *    pdwNumSites,
            OUT GUID **     ppguidSites
            );

HRESULT
DSCoreSetObjectProperties(
                IN const  DWORD         dwObjectType,
                IN LPCWSTR              pwcsPathName,
                IN const GUID *         pguidIdentifier,
                IN const DWORD          cp,
                IN const PROPID         aProp[],
                IN const PROPVARIANT    apVar[],
                IN CDSRequestContext *  pRequestContext,
                IN OUT MQDS_OBJ_INFO_REQUEST * pObjInfoRequest
                );

HRESULT DSCoreGetNT4PscName( IN  const GUID *pguidSiteId,
                             IN  LPCWSTR     pwszSiteName,
                             OUT WCHAR     **pwszServerName ) ;

BOOL    DSCoreIsServerGC() ;

enum enumNtlmOp
{
    e_Create,
    e_Delete,
    e_GetProps,
    e_Locate
} ;

HRESULT  DSCoreCheckIfGoodNtlmServer(
                                 IN DWORD             dwObjectType,
                                 IN LPCWSTR           pwcsPathName,
                                 IN const GUID       *pObjectGuid,
                                 IN DWORD             cProps,
                                 IN const PROPID     *pPropIDs,
                                 IN enum enumNtlmOp   eNtlmOp = e_Create) ;

HRESULT DSCoreSetOwnerPermission( WCHAR *pwszPath,
                                  DWORD  dwPermissions ) ;

HRESULT
DSCoreGetGCListInDomain(
	IN  LPCWSTR              pwszComputerName,
	IN  LPCWSTR              pwszDomainName,
	OUT LPWSTR              *lplpwszGCList 
	);

HRESULT
DSCoreUpdateSettingDacl( IN GUID  *pQmGuid,
                         IN PSID   pSid ) ;

HRESULT
DSCoreGetFullComputerPathName(
	IN  LPCWSTR                    pwcsComputerCn,
	IN  enum  enumComputerObjType  eCopmuterObjType,
	OUT LPWSTR *                   ppwcsFullPathName 
	);

//-------------------------------------------------------
//
// auto release for DSCoreLookup handles
//
class CAutoDSCoreLookupHandle
{
public:
    CAutoDSCoreLookupHandle()
    {
        m_hLookup = NULL;
    }

    CAutoDSCoreLookupHandle(HANDLE hLookup)
    {
        m_hLookup = hLookup;
    }

    ~CAutoDSCoreLookupHandle()
    {
        if (m_hLookup)
        {
            DSCoreLookupEnd(m_hLookup);
        }
    }

    HANDLE detach()
    {
        HANDLE hTmp = m_hLookup;
        m_hLookup = NULL;
        return hTmp;
    }

    operator HANDLE() const
    {
        return m_hLookup;
    }

    HANDLE* operator &()
    {
        return &m_hLookup;
    }

    CAutoDSCoreLookupHandle& operator=(HANDLE hLookup)
    {
        if (m_hLookup)
        {
            DSCoreLookupEnd(m_hLookup);
        }
        m_hLookup = hLookup;
        return *this;
    }

private:
    HANDLE m_hLookup;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\h\guids.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    guids.h

Abstract:

    Defines GUIDs

Author:
	Ronit Hartmann (ronith)

--*/
#ifndef __GUIDS_H__
#define __GUIDS_H__

#ifdef _MQDS_
extern __declspec(dllexport) GUID IID_MQProps;
#else
extern __declspec(dllimport) GUID IID_MQProps;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\h\dsstg.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dsstg.h

Abstract:

    Implementation of DS object as an OFS storage

Author:


--*/

#ifndef __DSSTG_H__
#define __DSSTG_H__

enum AccessModes {
    ReadOnly = 0,
    TransactedReadWrite = 1
};

//
// In the future, Falcon releated properties may belong to more than one property
// set. Such as machine address.
//
#define NUM_PROPSETS 1

extern GUID const *PropSetGuids[NUM_PROPSETS];

//
//	CDSObject : implements DS objects as OFS storage, with property sets
//
//
class CDSObject {
private:
    IStorage *	m_pIstorage;
    IPropertyStorage * m_pPropStgs[NUM_PROPSETS];
    int  m_EnumSet;
    IEnumSTATPROPSTG * m_pEnum;
    CLSID    *m_clsid;
    DWORD     m_StorageProps;

public:
    CDSObject();
    ~CDSObject();

    inline SCODE Create(LPWSTR FileName, const LPGUID lpgClassId); 
    SCODE Create(LPWSTR FileName,  DWORD dwStgFmt, const LPGUID lpgClassId);
    SCODE Open(LPWSTR FileName, DWORD dwAccessMode);

    void  Close();
    SCODE Commit();
    void  Revert();

    SCODE Read(DSPROPSPEC *pSpec, PROPVARIANT **ppV);

    SCODE Read(DSPROPSPEC *pSpec, PROPVARIANT *pV);

    inline SCODE Read(DSPROPSPEC &pSpec, PROPVARIANT *pV);
    SCODE Write(DSPROPSPEC *pSpec, PROPVARIANT *pV);
    inline SCODE Write(DSPROPSPEC &pSpec, PROPVARIANT &pV);
    SCODE Write(int SetNum, PROPID propid, PROPVARIANT *pV);
    inline SCODE Write(DSPROPSPEC &pSpec, LPWSTR pwszVal); 
    SCODE Delete(DSPROPSPEC *pSpec);

    SCODE Reset();
    SCODE Next(DSPROPSPEC *pSpec, int *eof);

    void  FreeVariant(PROPVARIANT *vp);
    inline void  FreeVariant(PROPVARIANT &v);

    inline CLSID   *GetClass();
};

/*====================================================

CDSObject::Create

Arguments:
		FileName - the object name
		lpgClassId	??

Return Value:


=====================================================*/
inline SCODE CDSObject::Create(LPWSTR FileName, const LPGUID lpgClassId)
{
        return(Create(FileName, STGFMT_DIRECTORY, lpgClassId));
}

/*====================================================

CDSObject::Read

Arguments:
		pSpec 	- the property specification
		pV		- the property's variant		

Return Value:


=====================================================*/
inline SCODE CDSObject::Read(DSPROPSPEC &pSpec, PROPVARIANT *pV)
{
	return(Read(&pSpec, pV));
}

/*====================================================

CDSObject::Write

Arguments:
		pSpec 	- the property specification
		pV		- the property's variant		

Return Value:


=====================================================*/
inline SCODE CDSObject::Write(DSPROPSPEC &pSpec, PROPVARIANT &pV)
{
	return(Write(&pSpec, &pV));
}

/*====================================================

CDSObject::Write

Arguments:
		pSpec 	- the property specification
		pwszVal	- the string to be written		

Return Value:


=====================================================*/
inline SCODE CDSObject::Write(DSPROPSPEC &pSpec, LPWSTR pwszVal)
{
	PROPVARIANT v;

	v.vt = VT_LPWSTR;
	v.pwszVal = pwszVal;
	return(Write(&pSpec, &v));
}

/*====================================================

CDSObject::FreeVariant

Arguments:
		v		- the variant to be freed		

Return Value:


=====================================================*/
inline void  CDSObject::FreeVariant(PROPVARIANT &v)
{
	FreeVariant(&v);
}

inline CLSID* CDSObject::GetClass()
{
	return(m_clsid);
}


#define PROP_E_NOT_FOUND 0x7676


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\h\dsutils.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
	dsutils.h

Abstract:
	General declarations and utilities for msads project

Author:
    AlexDad

--*/

#ifndef __DSUTILS_H__
#define __DSUTILS_H__

#include <adsiutil.h>
#include "_propvar.h"

//
// Helper class to auto-release search columns
//
class CAutoReleaseColumn
{
public:
    CAutoReleaseColumn( IDirectorySearch  *pSearch, ADS_SEARCH_COLUMN * pColumn)
    {
        m_pSearch = pSearch;
        m_pColumn = pColumn;
    }
    ~CAutoReleaseColumn()
    {
        m_pSearch->FreeColumn(m_pColumn);
    };
private:
    ADS_SEARCH_COLUMN * m_pColumn;
    IDirectorySearch  * m_pSearch;
};
//-----------------------------
// wrapper for SysAllocString that throws exception for out of memory
//-----------------------------
inline BSTR BS_SysAllocString(const OLECHAR *pwcs)
{
    BSTR bstr = SysAllocString(pwcs);
    //
    // If call failed, throw memory exception.
    // SysAllocString can also return NULL if passed NULL, so this is not
    // considered as bad alloc in order not to break depending apps if any
    //
    if ((bstr == NULL) && (pwcs != NULL))
    {
        ASSERT(0);
        throw bad_alloc();
    }
    return bstr;
}
//-----------------------------
// BSTRING auto-free wrapper class
//-----------------------------
class BS
{
public:
    BS()
    {
        m_bstr = NULL;
    };

    BS(LPCWSTR pwszStr)
    {
        m_bstr = BS_SysAllocString(pwszStr);
    };

    BS(LPWSTR pwszStr)
    {
        m_bstr = BS_SysAllocString(pwszStr);
    };

    BSTR detach()
    {
        BSTR p = m_bstr;
        m_bstr = 0;
        return p;
    };

    ~BS()
    {
        if (m_bstr)
        {
            SysFreeString(m_bstr);
        }
    };

public:
    BS & operator =(LPCWSTR pwszStr)
    {
        if (m_bstr) 
        { 
            SysFreeString(m_bstr); 
            m_bstr = NULL;
        }
        m_bstr = BS_SysAllocString(pwszStr);
        return *this;
    };

    BS & operator =(LPWSTR pwszStr)
    {
        if (m_bstr) { SysFreeString(m_bstr); };
        m_bstr = BS_SysAllocString(pwszStr);
        return *this;
    };

    BS & operator =(BS bs)
    {
        if (m_bstr) { SysFreeString(m_bstr); };
        m_bstr = BS_SysAllocString(LPWSTR(bs));
        return *this;
    };

    operator LPWSTR()
    {
        return m_bstr;
    };

private:
    BSTR  m_bstr;
};

//-----------------------------
//  Auto PV-free pointer
//-----------------------------
template<class T>
class PVP {
public:
    PVP() : m_p(0)          {}
    PVP(T* p) : m_p(p)      {}
   ~PVP()                   { PvFree(m_p); }

    operator T*() const     { return m_p; }
    T** operator&()         { return &m_p;}
    T* operator->() const   { return m_p; }
    PVP<T>& operator=(T* p) { m_p = p; return *this; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }

private:
    T* m_p;
};

//
// Helper class to auto-release variants
//
class CAutoVariant
{
public:
    CAutoVariant()                          { VariantInit(&m_vt); }
    ~CAutoVariant()                         { VariantClear(&m_vt); }
    operator VARIANT&()                     { return m_vt; }
    VARIANT* operator &()                   { return &m_vt; }
    VARIANT detach()                        { VARIANT vt = m_vt; VariantInit(&m_vt); return vt; }
private:
    VARIANT m_vt;
};


//
// Helper class to auto-release safe arrays
//
class CAutoSafeArray
{
public:
    CAutoSafeArray()                        { m_p = NULL; }
    ~CAutoSafeArray()                       { if (m_p) SafeArrayDestroy(m_p); }
    operator SAFEARRAY*() const             { return m_p; }
    SAFEARRAY** operator &()                { return &m_p; }
    SAFEARRAY* detach()                     { SAFEARRAY* p = m_p; m_p = NULL; return p; }
    CAutoSafeArray& operator=(SAFEARRAY* p) { if (m_p) SafeArrayDestroy(m_p); m_p = p; return *this; }
    BOOL Empty()                            { return (m_p == NULL); }
private:
    SAFEARRAY* m_p;
};

//-------------------------------------------------------
//
// Definitions of chained memory allocator
//
LPVOID PvAlloc(IN ULONG cbSize);
LPVOID PvAllocDbg(IN ULONG cbSize,
                  IN LPCSTR pszFile,
                  IN ULONG ulLine);
LPVOID PvAllocMore(IN ULONG cbSize,
                   IN LPVOID lpvParent);
LPVOID PvAllocMoreDbg(IN ULONG cbSize,
                      IN LPVOID lpvParent,
                      IN LPCSTR pszFile,
                      IN ULONG ulLine);
void PvFree(IN LPVOID lpvParent);

#ifdef _DEBUG
#define PvAlloc(cbSize) PvAllocDbg(cbSize, __FILE__, __LINE__)
#define PvAllocMore(cbSize, lpvParent) PvAllocMoreDbg(cbSize, lpvParent, __FILE__, __LINE__)
#endif //_DEBUG

//
// Helper class for auto-free of chained memory allocator
//
class CPvAlloc
{
public:
    CPvAlloc()
    {
        m_lpMore = NULL;
    };

    ~CPvAlloc()
    {
        if (m_lpMore)
            PvFree(m_lpMore);
    };

    LPVOID AllocMore(ULONG cbSize)
    {
        if (m_lpMore)
        {
            return (PvAllocMore(cbSize, m_lpMore));
        }
        else
        {
            m_lpMore = PvAlloc(cbSize);
            return (m_lpMore);
        }
    };

    LPVOID AllocMoreDbg(ULONG cbSize, LPCSTR pszFile, ULONG ulLine)
    {
        if (m_lpMore)
        {
            return (PvAllocMoreDbg(cbSize, m_lpMore, pszFile, ulLine));
        }
        else
        {
            m_lpMore = PvAllocDbg(cbSize, pszFile, ulLine);
            return (m_lpMore);
        }
    };

private:
    LPVOID m_lpMore;
};
typedef CPvAlloc * PCPvAlloc;

#ifdef _DEBUG
#define PCPV_ALLOC(pcpv, cbSize) (pcpv)->AllocMoreDbg(cbSize, __FILE__, __LINE__)
#else
#define PCPV_ALLOC(pcpv, cbSize) (pcpv)->AllocMore(cbSize)
#endif //_DEBUG
//
//-------------------------------------------------------
// class to auto clean propvar array
//
class CAutoCleanPropvarArray
{
public:

    CAutoCleanPropvarArray()
    {
        m_rgPropVars = NULL;
    }

    ~CAutoCleanPropvarArray()
    {
        if (m_rgPropVars)
        {
            if (m_fFreePropvarArray)
            {
                //
                // we need to free the propvars and the array itself
                // free the propvars and the array by assigning it to an auto free propvar
                // of type VT_VECTOR | VT_VARIANT
                //
                CMQVariant mqvar;
                PROPVARIANT * pPropVar = mqvar.CastToStruct();
                pPropVar->capropvar.pElems = m_rgPropVars;
                pPropVar->capropvar.cElems = m_cProps;
                pPropVar->vt = VT_VECTOR | VT_VARIANT;
            }
            else
            {
                //
                // we must not free the array itself, just the contained propvars
                // free the propvars only by by assigning each one to an auto free propvar
                //
                PROPVARIANT * pPropVar = m_rgPropVars;
                for (ULONG ulProp = 0; ulProp < m_cProps; ulProp++, pPropVar++)
                {
                    CMQVariant mqvar;
                    *(mqvar.CastToStruct()) = *pPropVar;
                    pPropVar->vt = VT_EMPTY;
                }
            }
        }
    }

    PROPVARIANT * allocClean(ULONG cProps)
    {
        PROPVARIANT * rgPropVars = new PROPVARIANT[cProps];
        attachClean(cProps, rgPropVars);
        return rgPropVars;
    }

    void attachClean(ULONG cProps, PROPVARIANT * rgPropVars)
    {
        attachInternal(cProps, rgPropVars, TRUE /*fClean*/,  TRUE /*fFreePropvarArray*/);
    }

    void attach(ULONG cProps, PROPVARIANT * rgPropVars)
    {
        attachInternal(cProps, rgPropVars, FALSE /*fClean*/, TRUE /*fFreePropvarArray*/);
    }

    void attachStaticClean(ULONG cProps, PROPVARIANT * rgPropVars)
    {
        attachInternal(cProps, rgPropVars, TRUE /*fClean*/,  FALSE /*fFreePropvarArray*/);
    }

    void attachStatic(ULONG cProps, PROPVARIANT * rgPropVars)
    {
        attachInternal(cProps, rgPropVars, FALSE /*fClean*/, FALSE /*fFreePropvarArray*/);
    }

    void detach()
    {
        m_rgPropVars = NULL;
    }

private:
    PROPVARIANT * m_rgPropVars;
    ULONG m_cProps;
    BOOL m_fFreePropvarArray;

    void attachInternal(ULONG cProps,
                        PROPVARIANT * rgPropVars,
                        BOOL fClean,
                        BOOL fFreePropvarArray)
    {
        ASSERT(m_rgPropVars == NULL);
        if (fClean)
        {
            PROPVARIANT * pPropVar = rgPropVars;
            for (ULONG ulTmp = 0; ulTmp < cProps; ulTmp++, pPropVar++)
            {
                pPropVar->vt = VT_EMPTY;
            }
        }
        m_rgPropVars = rgPropVars;
        m_cProps = cProps;
        m_fFreePropvarArray = fFreePropvarArray;
    }
};
//-------------------------------------------------------
//
// auto free pointer that uses a custom free function
//
typedef unsigned long (__stdcall *CAutoFreeFn_FreeRoutine)(void * p);
class CAutoFreeFn
{
public:
    CAutoFreeFn()
    {
        m_p = NULL;
        m_fn = NULL;
    }

    CAutoFreeFn(void * p, CAutoFreeFn_FreeRoutine fn)
    {
        m_p = p;
        m_fn = fn;
    }

    ~CAutoFreeFn()
    {
        if (m_p && m_fn)
        {
            (*m_fn)(m_p);
        }
    }

    void * detach()
    {
        void * p = m_p;
        m_p = NULL;
        m_fn = NULL;
        return p;
    }

private:
    void * m_p;
    CAutoFreeFn_FreeRoutine m_fn;
};
//-------------------------------------------------------
//
// auto release for search handles
//
class CAutoCloseSearchHandle
{
public:
    CAutoCloseSearchHandle()
    {
        m_pDirSearch = NULL;
    }

    CAutoCloseSearchHandle(IDirectorySearch * pDirSearch,
                           ADS_SEARCH_HANDLE hSearch)
    {
        pDirSearch->AddRef();
        m_pDirSearch = pDirSearch;
        m_hSearch = hSearch;
    }

    ~CAutoCloseSearchHandle()
    {
        if (m_pDirSearch)
        {
            m_pDirSearch->CloseSearchHandle(m_hSearch);
            m_pDirSearch->Release();
        }
    }

    void detach()
    {
        if (m_pDirSearch)
        {
            m_pDirSearch->Release();
            m_pDirSearch = NULL;
        }
    }

private:
    IDirectorySearch * m_pDirSearch;
    ADS_SEARCH_HANDLE m_hSearch;
};

//-------------------------------------------------------

#define ARRAY_SIZE(array)   (sizeof(array)/sizeof(array[0]))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\h\mqad.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mqad.h

Abstract:

    Internal Message queuing interface for active directory operations

    Messgae queuing components are using the interface defined in inc\ad.h

--*/

#ifndef __MQAD_H__
#define __MQAD_H__


#ifdef _MQDS_
//
// Exports that are defined in a def file should not be using __declspec(dllexport)
//  otherwise the linker issues a warning
//
#define MQAD_EXPORT
#else
#define MQAD_EXPORT  DLL_IMPORT
#endif

#include <mqaddef.h>
#include <dsproto.h>

#ifdef __cplusplus
extern "C"
{
#endif


//********************************************************************
//                           A P I
//********************************************************************

//
//  Creating objects
//
HRESULT
MQAD_EXPORT
APIENTRY
MQADCreateObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[],
                OUT GUID*                   pObjGuid
                );

typedef HRESULT
(APIENTRY *MQADCreateObject_ROUTINE)(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[],
                OUT GUID*                   pObjGuid
                );
//
//  Deleting objects
//
HRESULT
MQAD_EXPORT
APIENTRY
MQADDeleteObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName
                );

typedef HRESULT
(APIENTRY *MQADDeleteObject_ROUTINE)(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName
                );

HRESULT
MQAD_EXPORT
APIENTRY
MQADDeleteObjectGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject
                );
typedef HRESULT
(APIENTRY *MQADDeleteObjectGuid_ROUTINE)(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject
                );
//
//  Retreive object properties
//
HRESULT
MQAD_EXPORT
APIENTRY
MQADGetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT  PROPVARIANT         apVar[]
                );
typedef HRESULT
(APIENTRY * MQADGetObjectProperties_ROUTINE)(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT  PROPVARIANT         apVar[]
                );

HRESULT
MQAD_EXPORT
APIENTRY
MQADGetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT PROPVARIANT          apVar[]
                );
typedef HRESULT
(APIENTRY *MQADGetObjectPropertiesGuid_ROUTINE)(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT PROPVARIANT          apVar[]
                );

HRESULT
MQAD_EXPORT
APIENTRY
MQADGetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                );
typedef HRESULT
(APIENTRY *MQADGetObjectSecurity_ROUTINE)( 
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                );

HRESULT
MQAD_EXPORT
APIENTRY
MQADGetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                );
typedef HRESULT
(APIENTRY *MQADGetObjectSecurityGuid_ROUTINE)(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                );



typedef HRESULT
(*DSQMChallengeResponce_ROUTINE)(
     IN     BYTE    *pbChallenge,
     IN     DWORD   dwChallengeSize,
     IN     DWORD_PTR dwContext,
     OUT    BYTE    *pbSignature,
     OUT    DWORD   *pdwSignatureSize,
     IN     DWORD   dwSignatureMaxSize);



HRESULT
MQAD_EXPORT
APIENTRY
MQADQMGetObjectSecurity(
    IN  AD_OBJECT               eObject,
    IN  const GUID*             pguidObject,
    IN  SECURITY_INFORMATION    RequestedInformation,
    IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    IN  DWORD                   nLength,
    IN  LPDWORD                 lpnLengthNeeded,
    IN  DSQMChallengeResponce_ROUTINE
                                pfChallengeResponceProc,
    IN  DWORD_PTR               dwContext
    );

typedef HRESULT
(APIENTRY *MQADQMGetObjectSecurity_ROUTINE)(
    IN  AD_OBJECT               eObject,
    IN  const GUID*             pguidObject,
    IN  SECURITY_INFORMATION    RequestedInformation,
    IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    IN  DWORD                   nLength,
    IN  LPDWORD                 lpnLengthNeeded,
    IN  DSQMChallengeResponce_ROUTINE
                                pfChallengeResponceProc,
    IN  DWORD_PTR               dwContext
    );


//
// Setting object properties
//
HRESULT
MQAD_EXPORT
APIENTRY
MQADSetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                );
typedef HRESULT
(APIENTRY *MQADSetObjectProperties_ROUTINE)(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                );

HRESULT
MQAD_EXPORT
APIENTRY
MQADSetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                );

typedef HRESULT
(APIENTRY *MQADSetObjectPropertiesGuid_ROUTINE)(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                );


HRESULT
MQAD_EXPORT
APIENTRY
MQADSetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                );
typedef HRESULT
(APIENTRY *MQADSetObjectSecurity_ROUTINE)( 
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                );

HRESULT
MQAD_EXPORT
APIENTRY
MQADSetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                );
typedef HRESULT
(APIENTRY *MQADSetObjectSecurityGuid_ROUTINE)(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                );


HRESULT
MQAD_EXPORT
APIENTRY
MQADQMSetMachineProperties(
    IN  LPCWSTR             pwcsObjectName,
    IN  const DWORD			cp,
    IN  const PROPID		aProp[],
    IN  const PROPVARIANT	apVar[],
    IN  DSQMChallengeResponce_ROUTINE pfSignProc,
    IN  DWORD_PTR           dwContext
    );

typedef HRESULT
(APIENTRY  *MQADQMSetMachineProperties_ROUTINE)(
    IN  LPCWSTR             pwcsObjectName,
    IN  const DWORD			cp,
    IN  const PROPID		aProp[],
    IN  const PROPVARIANT	apVar[],
    IN  DSQMChallengeResponce_ROUTINE pfSignProc,
    IN  DWORD_PTR           dwContext
    );


//
//  Initailzation
//

HRESULT
MQAD_EXPORT
APIENTRY
MQADInit( 
        IN QMLookForOnlineDS_ROUTINE pLookDS = NULL,
        IN bool  fQMDll         = false,
        IN LPCWSTR szServerName = NULL
        );

typedef HRESULT
(APIENTRY *MQADInit_ROUTINE)(
        IN QMLookForOnlineDS_ROUTINE pLookDS,
        IN bool  fQMDll,
        IN LPCWSTR szServerName
        );

HRESULT
MQAD_EXPORT
APIENTRY
MQADSetupInit( 
             IN    LPWSTR          pwcsPathName
             );

typedef HRESULT
(APIENTRY *MQADSetupInit_ROUTINE)( 
             IN    LPWSTR          pwcsPathName
             );


HRESULT
MQAD_EXPORT
APIENTRY
MQADGetComputerSites(
            IN  LPCWSTR     pwcsComputerName,
            OUT DWORD  *    pdwNumSites,
            OUT GUID **     ppguidSites
            );
typedef HRESULT
(APIENTRY *MQADGetComputerSites_ROUTINE)(
            IN  LPCWSTR     pwcsComputerName,
            OUT DWORD  *    pdwNumSites,
            OUT GUID **     ppguidSites
            );


HRESULT
MQAD_EXPORT
APIENTRY
MQADBeginDeleteNotification(
				IN  AD_OBJECT               eObject,
				IN  LPCWSTR                 pwcsDomainController,
				IN  bool					 fServerName,
				IN  LPCWSTR			     pwcsObjectName,
				OUT HANDLE *                phEum
				);
typedef HRESULT
(APIENTRY *MQADBeginDeleteNotification_ROUTINE)(
				IN  AD_OBJECT               eObject,
				IN  LPCWSTR                 pwcsDomainController,
				IN  bool					fServerName,
				IN  LPCWSTR			     pwcsObjectName,
				OUT HANDLE *                phEnum
				);

HRESULT
MQAD_EXPORT
APIENTRY
MQADNotifyDelete(
        IN  HANDLE                  hEnum
	    );
typedef HRESULT
(APIENTRY *MQADNotifyDelete_ROUTINE)(
        IN  HANDLE                  hEnum
	    );

HRESULT
MQAD_EXPORT
APIENTRY
MQADEndDeleteNotification(
        IN  HANDLE                  hEnum
        );

typedef HRESULT
(APIENTRY  * MQADEndDeleteNotification_ROUTINE)(
        IN  HANDLE                  hEnum
        );



//
// Locating objects
//


HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryMachineQueues(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID *            pguidMachine,
                IN  const MQCOLUMNSET*      pColumns,
                OUT PHANDLE                 phEnume
                );
typedef HRESULT
(APIENTRY *MQADQueryMachineQueues_ROUTINE)(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID *            pguidMachine,
                IN  const MQCOLUMNSET*      pColumns,
                OUT PHANDLE                 phEnume
                );


HRESULT
MQAD_EXPORT
APIENTRY
MQADQuerySiteServers(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN AD_SERVER_TYPE           serverType,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );
typedef HRESULT
(APIENTRY *MQADQuerySiteServers_ROUTINE)(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN AD_SERVER_TYPE           serverType,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryUserCert(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const BLOB *             pblobUserSid,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );
typedef HRESULT
(APIENTRY * MQADQueryUserCert_ROUTINE)(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const BLOB *             pblobUserSid,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryConnectors(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );
typedef HRESULT
(APIENTRY * MQADQueryConnectors_ROUTINE)(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryForeignSites(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );
typedef HRESULT
(APIENTRY *MQADQueryForeignSites_ROUTINE)(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryLinks(
            IN  LPCWSTR                 pwcsDomainController,
            IN  bool					fServerName,
            IN const GUID *             pguidSite,
            IN eLinkNeighbor            eNeighbor,
            IN const MQCOLUMNSET*       pColumns,
            OUT PHANDLE                 phEnume
            );
typedef HRESULT
(APIENTRY * MQADQueryLinks_ROUTINE)(
            IN  LPCWSTR                 pwcsDomainController,
            IN  bool					fServerName,
            IN const GUID *             pguidSite,
            IN eLinkNeighbor            eNeighbor,
            IN const MQCOLUMNSET*       pColumns,
            OUT PHANDLE                 phEnume
            );

HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryAllLinks(
            IN  LPCWSTR                 pwcsDomainController,
            IN  bool					fServerName,
            IN const MQCOLUMNSET*       pColumns,
            OUT PHANDLE                 phEnume
            );
typedef HRESULT
(APIENTRY * MQADQueryAllLinks_ROUTINE)(
            IN  LPCWSTR                 pwcsDomainController,
            IN  bool					fServerName,
            IN const MQCOLUMNSET*       pColumns,
            OUT PHANDLE                 phEnume
            );

HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryAllSites(
            IN  LPCWSTR                 pwcsDomainController,
            IN  bool					fServerName,
            IN const MQCOLUMNSET*       pColumns,
            OUT PHANDLE                 phEnume
            );
typedef HRESULT
(APIENTRY * MQADQueryAllSites_ROUTINE)(
            IN  LPCWSTR                 pwcsDomainController,
            IN  bool					fServerName,
            IN const MQCOLUMNSET*       pColumns,
            OUT PHANDLE                 phEnume
            );

HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryNT4MQISServers(
            IN  LPCWSTR                 pwcsDomainController,
            IN  bool					fServerName,
            IN  DWORD                   dwServerType,
            IN  DWORD                   dwNT4,
            IN const MQCOLUMNSET*       pColumns,
            OUT PHANDLE                 phEnume
            );
typedef HRESULT
(APIENTRY * MQADQueryNT4MQISServers_ROUTINE)(
            IN  LPCWSTR                 pwcsDomainController,
            IN  bool					fServerName,
            IN  DWORD                   dwServerType,
            IN  DWORD                   dwNT4,
            IN const MQCOLUMNSET*       pColumns,
            OUT PHANDLE                 phEnume
            );


HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryQueues(
                IN  LPCWSTR                 pwcsDomainController,
	            IN  bool					fServerName,
                IN  const MQRESTRICTION*    pRestriction,
                IN  const MQCOLUMNSET*      pColumns,
                IN  const MQSORTSET*        pSort,
                OUT PHANDLE                 phEnume
                );
typedef HRESULT
(APIENTRY *MQADQueryQueues_ROUTINE)(
                IN  LPCWSTR                 pwcsDomainController,
	            IN  bool					fServerName,
                IN  const MQRESTRICTION*    pRestriction,
                IN  const MQCOLUMNSET*      pColumns,
                IN  const MQSORTSET*        pSort,
                OUT PHANDLE                 phEnume
                );

HRESULT
MQAD_EXPORT
APIENTRY
MQADQueryResults(
                IN      HANDLE          hEnum,
                IN OUT  DWORD*          pcProps,
                OUT     PROPVARIANT     aPropVar[]
                );
typedef HRESULT
(APIENTRY * MQADQueryResults_ROUTINE)(
                IN      HANDLE          hEnum,
                IN OUT  DWORD*          pcProps,
                OUT     PROPVARIANT     aPropVar[]
                );

HRESULT
MQAD_EXPORT
APIENTRY
MQADEndQuery(
            IN  HANDLE                  hEnum
            );
typedef HRESULT
(APIENTRY *MQADEndQuery_ROUTINE)(
            IN  HANDLE                  hEnum
            );


HRESULT
MQAD_EXPORT
APIENTRY
MQADGetADsPathInfo(
                IN  LPCWSTR                 pwcsADsPath,
                OUT PROPVARIANT *           pVar,
                OUT eAdsClass *             pAdsClass
                );
typedef HRESULT
(APIENTRY *MQADGetADsPathInfo_ROUTINE)(
                IN  LPCWSTR                 pwcsADsPath,
                OUT PROPVARIANT *           pVar,
                OUT eAdsClass *             pAdsClass
                );

HRESULT
MQAD_EXPORT
APIENTRY
MQADGetComputerVersion(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
	            IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const GUID*             pguidObject,
                OUT PROPVARIANT *           pVar
                );

typedef HRESULT
(APIENTRY *MQADGetComputerVersion_ROUTINE)(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
	            IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const GUID*             pguidObject,
                OUT PROPVARIANT *           pVar
                );

void
MQAD_EXPORT
APIENTRY
MQADFreeMemory(
		IN  PVOID					pMemory
		);

typedef void
(APIENTRY *MQADFreeMemory_ROUTINE)(
                IN  PVOID					pMemory
                );

#ifdef __cplusplus
}
#endif


//-------------------------------------------------------
//
// auto release for MQADQuery handles
//
class CAutoMQADQueryHandle
{
public:
    CAutoMQADQueryHandle()
    {
        m_hLookup = NULL;
    }

    CAutoMQADQueryHandle(HANDLE hLookup)
    {
        m_hLookup = hLookup;
    }

    ~CAutoMQADQueryHandle()
    {
        if (m_hLookup)
        {
            MQADEndQuery(m_hLookup);
        }
    }

    HANDLE detach()
    {
        HANDLE hTmp = m_hLookup;
        m_hLookup = NULL;
        return hTmp;
    }

    operator HANDLE() const
    {
        return m_hLookup;
    }

    HANDLE* operator &()
    {
        return &m_hLookup;
    }

    CAutoMQADQueryHandle& operator=(HANDLE hLookup)
    {
        if (m_hLookup)
        {
            MQADEndQuery(m_hLookup);
        }
        m_hLookup = hLookup;
        return *this;
    }

private:
    HANDLE m_hLookup;
};


#endif // __MQAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\h\mqdsname.h ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:
	mqdsname.h

Abstract:
	Names used for DS objects.
    This file is used by the migration tool too.

    Initial content taken from mqads\mqads.h

Author:

    Doron Juster (DoronJ)

--*/

#ifndef __mqdsname_h__
#define __mqdsname_h__

//-----------------------------------------
//  Pathname of object/containers in NT5 DS
//-----------------------------------------

//
// definition for msmqConfiguration object.
//
const WCHAR x_MsmqComputerConfiguration[] = L"msmq";
const DWORD x_MsmqComputerConfigurationLen =
                     sizeof(x_MsmqComputerConfiguration)/sizeof(WCHAR) -1;

const WCHAR x_LdapMsmqConfiguration[] = L"LDAP://cn=msmq," ;
const DWORD x_LdapMsmqConfigurationLen =
                         sizeof(x_LdapMsmqConfiguration)/sizeof(WCHAR) -1;

const WCHAR x_ConfigurationPrefix[] = L"CN=Configuration";
const DWORD x_ConfigurationPrefixLen = sizeof(x_ConfigurationPrefix)/sizeof(WCHAR);
const WCHAR x_ServicesContainerPrefix[] = L"CN=Services,CN=Configuration";
const DWORD x_ServiceContainerPrefixLen = sizeof(x_ServicesContainerPrefix)/sizeof(WCHAR);
const WCHAR x_MsmqServiceContainerPrefix[] = L"CN=MsmqServices,CN=Services,CN=Configuration";
const DWORD x_MsmqServiceContainerPrefixLen = sizeof(x_MsmqServiceContainerPrefix)/sizeof(WCHAR);
const WCHAR x_MsmqSettingName[] = L"MSMQ Settings";
const DWORD x_MsmqSettingNameLen = sizeof(x_MsmqSettingName)/sizeof(WCHAR) -1;
const WCHAR x_MsmqServicesName[] = L"MsmqServices";
const WCHAR x_SitesContainerPrefix[] = L"CN=Sites,CN=Configuration";
const DWORD x_SitesContainerPrefixLen = sizeof(x_SitesContainerPrefix)/sizeof(WCHAR);
const WCHAR x_LdapProvider[] = L"LDAP://";
const DWORD x_LdapProviderLen = (sizeof(x_LdapProvider)/sizeof(WCHAR)) - 1;
const WCHAR x_GcProvider[] = L"GC://";
const DWORD x_GcProviderLen = (sizeof(x_GcProvider)/sizeof(WCHAR)) - 1;
C_ASSERT( sizeof( x_LdapProvider) > sizeof( x_GcProvider));

const DWORD x_providerPrefixLength = sizeof(x_LdapProvider)/sizeof(WCHAR);
const WCHAR x_ComputersContainerPrefix[] = L"CN=Computers";
const DWORD x_ComputersContainerPrefixLength = (sizeof( x_ComputersContainerPrefix) /sizeof(WCHAR)) -1;
const WCHAR x_GcRoot[] = L"GC:";
const WCHAR x_DcPrefix[] = L"DC=";
const DWORD x_DcPrefixLength = (sizeof( x_DcPrefix)/sizeof(WCHAR)) - 1;
const WCHAR x_RootDSE[] = L"RootDSE";
const DWORD x_RootDSELength = (sizeof( x_RootDSE)/sizeof(WCHAR)) - 1;

const WCHAR x_AttrDistinguishedName[] = L"distinguishedName";
const WCHAR x_AttrObjectGUID[]        = L"objectGUID";
const WCHAR x_AttrCN[]                = L"cn";
const WCHAR x_AttrObjectCategory[]    = L"objectCategory";

const WCHAR x_LdapRootDSE[]                = L"LDAP://RootDSE";
const WCHAR x_ConfigurationNamingContext[] = L"configurationNamingContext";

const DWORD x_PrefixQueueNameLength = 63;
const DWORD x_SplitQNameIdLength = 9;

#endif // __mqdsname_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\h\mqds.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mqds.h

Abstract:

    Message Queuing's Directory Service PROVIDER Header File

--*/

#ifndef __MQDS_H__
#define __MQDS_H__

#ifdef _MQDS_
#define MQDS_EXPORT  DLL_EXPORT
#else
#define MQDS_EXPORT  DLL_IMPORT
#endif

//
// MQDS_EXPORT_IN_DEF_FILE
// Exports that are defined in a def file should not be using __declspec(dllexport)
//  otherwise the linker issues a warning
//
#ifdef _MQDS_
#define MQDS_EXPORT_IN_DEF_FILE
#else
#define MQDS_EXPORT_IN_DEF_FILE  DLL_IMPORT
#endif

#include "mqdsdef.h"
#include "dsreqinf.h"


#ifdef __cplusplus
extern "C"
{
#endif


//********************************************************************
//                           A P I
//********************************************************************


HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSCreateObject(
                   IN  DWORD            dwObjectType,
                   IN  LPCWSTR          pwcsPathName,
                   IN  DWORD            cp,
                   IN  PROPID           aProp[],
                   IN  PROPVARIANT      apVar[],
                   IN  DWORD            cpEx,
                   IN  PROPID           aPropEx[],
                   IN  PROPVARIANT      apVarEx[],
                   IN  CDSRequestContext * pRequestContext,
                   OUT GUID*            pObjGuid);

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSDeleteObject(
                   IN  DWORD            dwObjectType,
                   IN  LPCWSTR          pwcsPathName,
                   IN  CONST GUID *     pguidIdentifier,
                   IN  CDSRequestContext * pRequestContext
                 ) ;

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSGetProps(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  CONST GUID *            pguidIdentifier,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[],
                IN  CDSRequestContext *     pRequestContext
                );

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSSetProps(   IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  CONST GUID *            pguidIdentifier,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[],
                IN  CDSRequestContext *     pRequestContext
             );

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSLookupBegin(
                IN  LPWSTR                  pwcsContext,
                IN  MQRESTRICTION*          pRestriction,
                IN  MQCOLUMNSET*            pColumns,
                IN  MQSORTSET*              pSort,
                OUT HANDLE*                 pHandle,
                IN  CDSRequestContext *     pRequestContext
                );

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSLookupNext(
                IN  HANDLE                  pHandle,
                OUT DWORD*                  dwSize,
                OUT PROPVARIANT *           pbBuffer);

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSLookupEnd(
                IN  HANDLE                  pHandle);

HRESULT
MQDS_EXPORT
APIENTRY
MQDSGetObjectSecurity(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  CONST GUID *            pguidIdentifier,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded,
                IN  CDSRequestContext *     pRequestContext
                );

HRESULT
MQDS_EXPORT
APIENTRY
MQDSSetObjectSecurity(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  CONST GUID *            pguidIdentifier,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  CDSRequestContext *     pRequestContext
                );

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSInit(
    VOID
    );

void
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSTerminate(
    VOID
    );

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSQMSetMachineProperties(
            IN  LPCWSTR     pwcsPathName,
            IN  DWORD       cp,
            IN  PROPID      aProp[],
            IN  PROPVARIANT apVar[],
            IN  BYTE        pbChallenge[],
            IN  DWORD       dwChallengeSize,
            IN  BYTE        pbSignature[],
            IN  DWORD       dwSignatureSize);

HRESULT
MQDS_EXPORT
APIENTRY
MQDSQMGetObjectSecurity(
            IN  DWORD                   dwObjectType,
            IN  CONST GUID *            pguidIdentifier,
            IN  SECURITY_INFORMATION    RequestedInformation,
            IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
            IN  DWORD                   nLength,
            IN  LPDWORD                 lpnLengthNeeded,
            IN  BYTE                    pbChallenge[],
            IN  DWORD                   dwChallengeSize,
            IN  BYTE                    pbChallengeResponce[],
            IN  DWORD                   dwChallengeResponceSize);

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSCreateServersCache() ;

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSGetComputerSites(
            IN  LPCWSTR     pwcsComputerName,
            OUT DWORD  *    pdwNumSites,
            OUT GUID **     ppguidSites
            );

//
//  For retrieving MSMQ 2.0 properties
//
HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSGetPropsEx(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  CONST GUID *            pguidIdentifier,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[],
                IN  CDSRequestContext *     pRequestContext
                );

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSPreDeleteQueueGatherInfo(
        IN LPCWSTR      pwcsQueueName,
        OUT GUID *      pguidQmId,
        OUT BOOL *      pfForeignQm,
        OUT BOOL *      pfOwnedByNT4Site,
        OUT GUID *      pguidOwnerNT4Site
        );

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSPostDeleteQueueActions(
        IN LPCWSTR      pwcsQueueName,
        IN const GUID * pguidQmId,
        IN BOOL *       pfForeignQm,
        IN BOOL *       pfOwnedByNT4Site,
        IN GUID *       pguidOwnerNT4Site
        );

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSPreDeleteMachineGatherInfo(
        IN LPCWSTR      pwcsMachineName,
        OUT BOOL *      pfOwnedByNT4Site,
        OUT GUID *      pguidOwnerNT4Site
        );

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSPostDeleteMachineActions(
        IN LPCWSTR      pwcsMachineName,
        IN BOOL *       pfOwnedByNT4Site,
        IN GUID *       pguidOwnerNT4Site
        );

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSRelaxSecurity( DWORD dwRelaxFlag ) ;

BOOL
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSIsServerGC() ;

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSUpdateMachineDacl(
    VOID
    );

HRESULT
MQDS_EXPORT_IN_DEF_FILE
APIENTRY
MQDSGetGCListInDomain(
	IN  LPCWSTR             pwszComputerName,
	IN  LPCWSTR             pwszDomainName,
	OUT LPWSTR             *lplpwszGCList 
	);

#ifdef __cplusplus
}
#endif

#endif // __MQDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\h\mqads.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    mqads.h

Abstract:
    MQADS defines and structures


Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __MQADS_H__
#define __MQADS_H__

#include "_mqdef.h"
#include "iads.h"
#include "mqdsname.h"
#include "dsreqinf.h"

//----------------------------------------------------------
//
//  Context where to start searching/getting the object
//
//----------------------------------------------------------

enum DS_CONTEXT
{
    e_RootDSE,
    e_ConfigurationContainer,
    e_SitesContainer,
    e_MsmqServiceContainer,
    e_ServicesContainer
};

//-----------------------------------------
//
// Query Handler Routine
//
//-----------------------------------------

typedef HRESULT (WINAPI*  QueryRequest_HANDLER)(
                 IN  LPWSTR         pwcsContext,
                 IN  MQRESTRICTION  *pRestriction,
                 IN  MQCOLUMNSET    *pColumns,
                 IN  MQSORTSET      *pSort,
                 IN  CDSRequestContext *pRequestContext,
                 OUT HANDLE         *pHandle
                );

//-----------------------------------------
//  Query Format
//-----------------------------------------

#define NO_OF_RESTRICITIONS 10
struct RESTRICTION_PARAMS
{
    ULONG   rel;
    PROPID  propId;
};


struct QUERY_FORMAT
{
    DWORD                   dwNoRestrictions;
    QueryRequest_HANDLER    QueryRequestHandler;
    RESTRICTION_PARAMS      restrictions[NO_OF_RESTRICITIONS];
    DS_CONTEXT              queryContext ;
};

//-----------------------------------------
// Definition of a class that holds translation info for an MSMQ object.
// This class (or a derived classe) will be created when translating an instance
// of an object in the DS, and will be passed to the translation routines of
// all its properties. This enables a translation routine of one property to store/cache
// data needed for a translation routine of another property.
//-----------------------------------------
class CMsmqObjXlateInfo
{
public:
    CMsmqObjXlateInfo(LPCWSTR               pwszObjectDN,
                      const GUID*           pguidObjectGuid,
                      CDSRequestContext *   pRequestContext);
    virtual ~CMsmqObjXlateInfo();    // allow destructing derived classes
    LPCWSTR ObjectDN();
    GUID*  ObjectGuid();
    void InitGetDsProps(IN IDirectorySearch * pSearchObj,
                        IN ADS_SEARCH_HANDLE hSearch);
    void InitGetDsProps(IN IADs * pIADs);
    HRESULT GetDsProp(IN LPCWSTR pwszPropName,
                      IN ADSTYPE adstype,
                      IN VARTYPE vartype,
                      IN BOOL fMultiValued,
                      OUT PROPVARIANT * ppropvarResult);

private:
    AP<WCHAR> m_pwszObjectDN  ;      // object's DN
    P<GUID>   m_pguidObjectGuid;     // object's GUID
    R<IADs>             m_pIADs;      // IADs interface to DS props
    R<IDirectorySearch> m_pSearchObj; // IDirectorySearch interface to DS props
    ADS_SEARCH_HANDLE   m_hSearch;    // needed for IDirectorySearch interface to DS props
    CDSRequestContext * m_pRequestContext; // information about the request

};

inline LPCWSTR CMsmqObjXlateInfo::ObjectDN()    {return m_pwszObjectDN;}
inline GUID*  CMsmqObjXlateInfo::ObjectGuid()  {return m_pguidObjectGuid;}

//-----------------------------------------
// Definition of a routine to get a translate object for an MSMQ DS object.
// this object will be passed to translation routines for all properties of
// the DS object.
// This mechanism enables returning derived classes for specific objects
//-----------------------------------------
typedef HRESULT (WINAPI*  FT_GetMsmqObjXlateInfo)(
                 IN  LPCWSTR                pwcsObjectDN,
                 IN  const GUID*            pguidObjectGuid,
                 IN  CDSRequestContext *    pRequestContext,
                 OUT CMsmqObjXlateInfo**    ppcMsmqObjXlateInfo);

//-----------------------------------------
// Routine to retrieve a property value ( for properties that are not kept in DS)
//-----------------------------------------
typedef HRESULT (WINAPI*  RetrievePropertyValue_HANDLER)(
                 IN  CMsmqObjXlateInfo *    pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *          ppropvariant
                );

//-----------------------------------------
// Routine to set a property value ( for properties that are not kept in DS)
//-----------------------------------------
typedef HRESULT (WINAPI*  SetPropertyValue_HANDLER)(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

//-----------------------------------------
// Routine to set a property value during create of an object
// ( for properties that are not kept in DS)
//-----------------------------------------
typedef HRESULT (WINAPI*  CreatePropertyValue_HANDLER)(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);


//-----------------------------------------
// Routine to set a property value ( for properties that are not kept in QM1)
//-----------------------------------------
typedef HRESULT (WINAPI*  QM1SetPropertyValue_HANDLER)(
                 IN ULONG             cProps,
                 IN const PROPID      *rgPropIDs,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar);

//---------------------------------------
//  TranslateInfo
//
//  A structure describing property in MQ and NT5
//---------------------------------------
struct MQTranslateInfo
{
    PROPID                  propid;
    LPCWSTR                 wcsPropid;
    VARTYPE                 vtMQ;         // the vartype of this property in MQ
    ADSTYPE                 vtDS;         // the vartype of this property in NT5 DS
    RetrievePropertyValue_HANDLER  RetrievePropertyHandle;
    BOOL                    fMultiValue;  // whether the attribute is multi value or not
    BOOL                    fPublishInGC; // whether the attribute is published in GC or not
    const MQPROPVARIANT *   pvarDefaultValue;   // attribute's default value, incase it is not in DS
    SetPropertyValue_HANDLER       SetPropertyHandle;
	CreatePropertyValue_HANDLER	   CreatePropertyHandle;
    WORD                    wQM1Action;       // how to notify this property to QM1 (relevant only to Queues and QMs)
    PROPID                  propidReplaceNotifyQM1; // replacing property in a notification to QM 1.0 (if wQM1Action == e_NOTIFY_WRITEREQ_QM1_REPLACE)
    QM1SetPropertyValue_HANDLER    QM1SetPropertyHandle;
};

//
// how to notify and write request a property to QM1
// this has a meaning only for queue & QM properties
//
enum
{
    e_NO_NOTIFY_NO_WRITEREQ_QM1,   // ignore it
    e_NOTIFY_WRITEREQ_QM1_AS_IS,   // notify and write request it as is
    e_NOTIFY_WRITEREQ_QM1_REPLACE, // replace it with another property
    e_NO_NOTIFY_ERROR_WRITEREQ_QM1 // don't notify it. generate an error
                                   // when need to write request it.
};

//---------------------------------------
//  ClassInfo
//
// A structure describing MSMQ class in NT5 DS
//
//---------------------------------------
struct MQClassInfo
{
    LPCWSTR               pwcsClassName;
    const MQTranslateInfo * pProperties;     // class properties
    ULONG                 cProperties;     // number of class properties
    FT_GetMsmqObjXlateInfo  fnGetMsmqObjXlateInfo;  // get translate info obj for the class
    DS_CONTEXT            context;
    DWORD                 dwObjectType ; // good old MSMQ1.0 obj class.
    WCHAR **              ppwcsObjectCategory;
    LPCWSTR               pwcsCategory;
    DWORD                 dwCategoryLen;
};

extern const ULONG g_cMSMQClassInfo;
extern const MQClassInfo g_MSMQClassInfo[];

//-----------------------------------------
// Routine to get a default translation object for MSMQ DS objects
//-----------------------------------------
HRESULT WINAPI GetDefaultMsmqObjXlateInfo(
                 IN  LPCWSTR                pwcsObjectDN,
                 IN  const GUID*            pguidObjectGuid,
                 IN  CDSRequestContext *    pRequestContext,
                 OUT CMsmqObjXlateInfo**    ppcMsmqObjXlateInfo);


//-----------------------------------------
// keep in the same order as the array in traninfo.cpp
//-----------------------------------------
enum
{
    e_MSMQ_COMPUTER_CONFIGURATION_CLASS,
    e_MSMQ_QUEUE_CLASS,
    e_MSMQ_SERVICE_CLASS,
    e_MSMQ_SITELINK_CLASS,
    e_MSMQ_USER_CLASS,
    e_MSMQ_SETTING_CLASS,
    e_MSMQ_SITE_CLASS,
    e_MSMQ_SERVER_CLASS,
    e_MSMQ_COMPUTER_CLASS,
    e_MSMQ_MQUSER_CLASS,
    e_MSMQ_CN_CLASS,
    e_MSMQ_NUMBER_OF_CLASSES
};

const DWORD x_NoPropertyFirstAppearance = 0xffffffff;

//
//  building restriction const strings
//
const WCHAR x_ObjectClassPrefix[] = L"(objectClass=";
const DWORD x_ObjectClassPrefixLen = (sizeof( x_ObjectClassPrefix) / sizeof(WCHAR)) -1;
const WCHAR x_ObjectClassSuffix[] = L")";
const DWORD x_ObjectClassSuffixLen = (sizeof( x_ObjectClassSuffix) / sizeof(WCHAR)) -1;
const WCHAR x_ObjectCategoryPrefix[] = L"(objectCategory=";
const DWORD x_ObjectCategoryPrefixLen = (sizeof( x_ObjectCategoryPrefix) / sizeof(WCHAR)) -1;
const WCHAR x_ObjectCategorySuffix[] = L")";
const DWORD x_ObjectCategorySuffixLen = (sizeof( x_ObjectCategorySuffix) / sizeof(WCHAR)) -1;
const WCHAR x_AttributeNotIncludedPrefix[] = L"(|(!(";
const DWORD x_AttributeNotIncludedPrefixLen = (sizeof(x_AttributeNotIncludedPrefix) / sizeof(WCHAR)) - 1;
const WCHAR x_AttributeNotIncludedSuffix[] = L"=*))";
const DWORD x_AttributeNotIncludedSuffixLen = (sizeof(x_AttributeNotIncludedSuffix) / sizeof(WCHAR)) - 1;
const WCHAR x_PropertyPrefix[] = L"(";
const DWORD x_PropertyPrefixLen = ( sizeof(x_PropertyPrefix) / sizeof(WCHAR)) - 1;
const WCHAR x_PropertySuffix[] = L")";
const DWORD x_PropertySuffixLen = ( sizeof(x_PropertySuffix) / sizeof(WCHAR)) - 1;
const WCHAR x_msmqUsers[] = L"MSMQ Users";
const WCHAR x_msmqUsersOU[] = L"OU=MSMQ Users";
const DWORD x_msmqUsersOULen = ( sizeof(x_msmqUsersOU) / sizeof(WCHAR)) - 1;
//
//  Additional const string for ADSI operations
//
const WCHAR x_CnPrefix[] = L"CN=";
const DWORD x_CnPrefixLen = ( sizeof(x_CnPrefix) / sizeof(WCHAR)) - 1;
const WCHAR x_OuPrefix[] = L"OU=";
const DWORD x_OuPrefixLen = ( sizeof(x_OuPrefix) / sizeof(WCHAR)) - 1;
const WCHAR x_GuidPrefix[] = L"<GUID=";
const DWORD x_GuidPrefixLen = ( sizeof(x_GuidPrefix) / sizeof(WCHAR)) - 1;

//-------------------------------------------------------------
//  request for info on object that is changed/created/deleted
//-------------------------------------------------------------
struct MQDS_OBJ_INFO_REQUEST
{
    DWORD          cProps;    // number of props to get
    const PROPID * pPropIDs;  // prop ids to get
    PROPVARIANT *  pPropVars; // prop values
    HRESULT        hrStatus;  // status of request
};


enum  enumComputerObjType
{
    e_RealComputerObject,
    e_MsmqComputerObject
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\h\mqattrib.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
	mqattrib.h

Abstract:
	MSMQ classes and attributes in NT5
	
Author:

    Ronit Hartmann (ronith)

--*/
#ifndef __mqattrib_h__
#define __mqattrib_h__

//-----------------------------------------------------
//      MSMQ-service
//-----------------------------------------------------
const WCHAR MSMQ_SERVICE_CLASS_NAME[] = L"mSMQEnterpriseSettings";

const WCHAR x_ServiceCategoryName[] = L"CN=MSMQ-Enterprise-Settings";
const DWORD x_ServiceCategoryLength = (sizeof( x_ServiceCategoryName)/sizeof(WCHAR)) - 1;

const WCHAR MQ_E_NAMESTYLE_ATTRIBUTE[] = L"mSMQNameStyle"; // PROPID_E_NAMESTYLE
const WCHAR MQ_E_CSP_NAME_ATTRIBUTE[] = L"mSMQCSPName";    // PROPID_E_CSP_NAME
const WCHAR MQ_E_ID_ATTRIBUTE[] = L"objectGUID";           // PROPID_E_ID
const WCHAR MQ_E_LONG_LIVE_ATTRIBUTE[] = L"mSMQLongLived";  // PROPID_E_LONG_LIVE
const WCHAR MQ_E_VERSION_ATTRIBUTE[] = L"mSMQVersion";     // PROPID_E_VERSION
const WCHAR MQ_E_SECURITY_ATTRIBUTE[] = L"nTSecurityDescriptor"; // PROPID_E_SECURITY
const WCHAR MQ_E_NT4ID_ATTRIBUTE[] = L"objectGUID";        // PROPID_E_NT4ID
const WCHAR MQ_E_INTERVAL1[] = L"mSMQInterval1";           //PROPID_E_S_INTERVAL1
const WCHAR MQ_E_INTERVAL2[] = L"mSMQInterval2";           //PROPID_E_S_INTERVAL2


const ADSTYPE MQ_E_NAMESTYLE_ADSTYPE = ADSTYPE_BOOLEAN;
const ADSTYPE MQ_E_CSP_NAME_ADSTYPE = ADSTYPE_CASE_IGNORE_STRING;
const ADSTYPE MQ_E_ID_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_E_LONG_LIVE_ADSTYPE = ADSTYPE_INTEGER;
const ADSTYPE MQ_E_VERSION_ADSTYPE = ADSTYPE_INTEGER;
const ADSTYPE MQ_E_SECURITY_ADSTYPE = ADSTYPE_NT_SECURITY_DESCRIPTOR;
const ADSTYPE MQ_E_NT4ID_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_E_INTERVAL1_ADSTYPE = ADSTYPE_INTEGER;
const ADSTYPE MQ_E_INTERVAL2_ADSTYPE = ADSTYPE_INTEGER;

//-----------------------------------------------------
//      MSMQ-site-link
//-----------------------------------------------------
const WCHAR MSMQ_SITELINK_CLASS_NAME[] = L"mSMQSiteLink";

const WCHAR x_LinkCategoryName[] = L"CN=MSMQ-Site-Link";
const DWORD x_LinkCategoryLength = (sizeof( x_LinkCategoryName)/sizeof(WCHAR)) - 1;

const WCHAR MQ_L_NEIGHBOR1_ATTRIBUTE[] = L"mSMQSite1";    // PROPID_L_NEIGHBOR1
const WCHAR MQ_L_NEIGHBOR2_ATTRIBUTE[] = L"mSMQSite2";    // PROPID_L_NEIGHBOR2
const WCHAR MQ_L_COST_ATTRIBUTE[] = L"mSMQCost";         // PROPID_L_COST
const WCHAR MQ_L_ID_ATTRIBUTE[] = L"objectGUID";           // PROPID_L_ID
const WCHAR MQ_L_SITEGATES_ATTRIBUTE[] = L"mSMQSiteGates";        // PROPID_S_GATES
const WCHAR MQ_L_DESCRIPTION_ATTRIBUTE[] = L"description";  // PROPID_L_DESCRIPTION
const WCHAR MQ_L_FULL_PATH_ATTRIBUTE[] = L"distinguishedName"; // PROPID_L_FULL_PATH

const ADSTYPE MQ_L_NEIGHBOR1_ADSTYPE = ADSTYPE_DN_STRING;
const ADSTYPE MQ_L_NEIGHBOR2_ADSTYPE = ADSTYPE_DN_STRING;
const ADSTYPE MQ_L_COST_ADSTYPE = ADSTYPE_INTEGER;
const ADSTYPE MQ_L_ID_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_L_SITEGATES_ADSTYPE = ADSTYPE_DN_STRING;
const ADSTYPE MQ_L_DESCRIPTION_ADSTYPE = ADSTYPE_CASE_IGNORE_STRING;
const ADSTYPE MQ_L_FULL_PATH_ADSTYPE = ADSTYPE_DN_STRING;
//-----------------------------------------------------
//      User
//-----------------------------------------------------
const WCHAR MSMQ_USER_CLASS_NAME[] = L"user";

const WCHAR x_UserCategoryName[] = L"CN=Person";
const DWORD x_UserCategoryLength = (sizeof( x_UserCategoryName)/sizeof(WCHAR)) - 1;

const WCHAR MQ_U_SID_ATTRIBUTE[] = L"objectSid";           // PROPID_U_SID
const WCHAR MQ_U_SIGN_CERT_ATTRIBUTE[] = L"mSMQSignCertificates";        // PROPID_U_SIGN_CERT
const WCHAR MQ_U_DIGEST_ATTRIBUTE[] = L"mSMQDigests";      // PROPID_U_DIGEST
const WCHAR MQ_U_ID_ATTRIBUTE[] = L"objectGUID";          // PROPID_U_ID

const ADSTYPE MQ_U_SID_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_U_SIGN_CERT_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_U_DIGEST_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_U_ID_ADSTYPE = ADSTYPE_OCTET_STRING;

//-----------------------------------------------------
//      MQUser
//-----------------------------------------------------
#define MSMQ_OBJECT_SID_ATTRIBUTE   (L"mSMQUserSid")
#define MSMQ_OBJECT_SID_DESCRIPTION (L"MSMQ-User-sid")

const WCHAR MSMQ_MQUSER_CLASS_NAME[] = L"mSMQMigratedUser";

const WCHAR x_MQUserCategoryName[] = L"CN=MSMQ-Migrated-User";
const DWORD x_MQUserCategoryLength = (sizeof( x_MQUserCategoryName)/sizeof(WCHAR)) - 1;


const WCHAR MQ_MQU_SID_ATTRIBUTE[] = MSMQ_OBJECT_SID_ATTRIBUTE;        // PROPID_MQU_SID
const WCHAR MQ_MQU_SIGN_CERT_ATTRIBUTE[] = L"mSMQSignCertificates";    // PROPID_MQU_SIGN_CERT
const WCHAR MQ_MQU_DIGEST_ATTRIBUTE[] = L"mSMQDigests";                // PROPID_MQU_DIGEST
const WCHAR MQ_MQU_ID_ATTRIBUTE[] = L"objectGUID";                     // PROPID_MQU_ID
const WCHAR MQ_MQU_SECURITY_ATTRIBUTE[] = L"nTSecurityDescriptor";     // PROPID_MQU_SECURITY

const ADSTYPE MQ_MQU_SID_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_MQU_SIGN_CERT_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_MQU_DIGEST_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_MQU_ID_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_MQU_SECURITY_ADSTYPE = ADSTYPE_NT_SECURITY_DESCRIPTOR;

//-----------------------------------------------------
//      MSMQ-computer-configuration
//-----------------------------------------------------
const WCHAR MSMQ_COMPUTER_CONFIGURATION_CLASS_NAME[] = L"mSMQConfiguration";

const WCHAR x_ComputerConfigurationCategoryName[] = L"CN=MSMQ-Configuration";
const DWORD x_ComputerConfigurationCategoryLength = (sizeof( x_ComputerConfigurationCategoryName)/sizeof(WCHAR)) - 1;

const WCHAR MQ_QM_ID_ATTRIBUTE[] = L"objectGUID";          // PROPID_QM_MACHINE_ID
const WCHAR MQ_QM_OUTFRS_ATTRIBUTE[] = L"mSMQOutRoutingServers";  // PROPID_QM_OUTFRS_DN
const WCHAR MQ_QM_INFRS_ATTRIBUTE[] = L"mSMQInRoutingServers";   // PROPID_QM_INFRS_DN
const WCHAR MQ_QM_SERVICE_ATTRIBUTE[] = L"mSMQServiceType"; // PROPID_QM_SERVICE  // [adsrv]
const WCHAR MQ_QM_SERVICE_ROUTING_ATTRIBUTE[]   = L"mSMQRoutingServices";         // PROPID_QM_SERVICE_ROUTING
const WCHAR MQ_QM_SERVICE_DSSERVER_ATTRIBUTE[]  = L"mSMQDsServices";              // PROPID_QM_SERVICE_DSSERVER
const WCHAR MQ_QM_SERVICE_DEPCLIENTS_ATTRIBUTE[]= L"mSMQDependentClientServices"; // PROPID_QM_SERVICE_DEPCLIENTS
const WCHAR MQ_QM_QUOTA_ATTRIBUTE[] = L"mSMQQuota";   // PROPID_QM_QUOTA
const WCHAR MQ_QM_JOURNAL_QUOTA_ATTRIBUTE[] = L"mSMQJournalQuota"; // PROPID_QM_JOURNAL_QUOTA
const WCHAR MQ_QM_MACHINE_TYPE_ATTRIBUTE[] = L"mSMQComputerTypeEx"; // PROPID_QM_MACHINE
const WCHAR MQ_QM_FOREIGN_ATTRIBUTE[] = L"mSMQForeign"; // PROPID_QM_FOREIGN
const WCHAR MQ_QM_OS_ATTRIBUTE[] = L"mSMQOSType";      // PROPID_QM_OS
const WCHAR MQ_QM_SECURITY_ATTRIBUTE[] = L"nTSecurityDescriptor"; // PROPID_QM_SECURITY
const WCHAR MQ_QM_SIGN_PK_ATTRIBUTE[] = L"mSMQSignKey";          // PROPID_QM_SIGN_PK
const WCHAR MQ_QM_ENCRYPT_PK_ATTRIBUTE[] = L"mSMQEncryptKey";     // PROPID_QM_ENCRYPT_PK
const WCHAR MQ_QM_CREATE_TIME_ATTRIBUTE[] = L"whenCreated";         // PROPID_QM_CREATE_TIME
const WCHAR MQ_QM_MODIFY_TIME_ATTRIBUTE[] = L"whenChanged";         // PROPID_QM_MODIFY_TIME
const WCHAR MQ_QM_SITES_ATTRIBUTE[] = L"mSMQSites";   // PROPID_QM_SITE_IDS
const WCHAR MQ_QM_PATHNAME_ATTRIBUTE[] = L"cn";                  // PROPID_QM_PATHNAME
const WCHAR MQ_QM_FULL_PATH_ATTRIBUTE[] = L"distinguishedName";   //PROPID_QM_FULL_PATH
const WCHAR MQ_QM_MASTERID_ATTRIBUTE[] = L"mSMQOwnerID";          //PROPID_QM_MASTERID
const WCHAR MQ_QM_NT4ID_ATTRIBUTE[] = L"objectGUID";              //PROPID_QM_NT4ID
const WCHAR MQ_QM_WORKGROUP_ID_ATTRIBUTE[] = L"objectGUID";       //PROPID_QM_WORKGROUP_ID
const WCHAR MQ_QM_DESCRIPTION_ATTRIBUTE[] = L"description";       //PROPID_QM_DESCRIPTION

const ADSTYPE MQ_QM_ID_ADSTYPE  = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_QM_OUTFRS_ADSTYPE = ADSTYPE_DN_STRING;
const ADSTYPE MQ_QM_INFRS_ADSTYPE = ADSTYPE_DN_STRING;
const ADSTYPE MQ_QM_SERVICE_ADSTYPE = ADSTYPE_INTEGER;  // [adsrv]
const ADSTYPE MQ_QM_SERVICE_ROUTING_ADSTYPE = ADSTYPE_BOOLEAN;
const ADSTYPE MQ_QM_SERVICE_DSSERVER_ADSTYPE = ADSTYPE_BOOLEAN;
const ADSTYPE MQ_QM_SERVICE_DEPCLIENTS_ADSTYPE = ADSTYPE_BOOLEAN;
const ADSTYPE MQ_QM_QUOTA_ADSTYPE = ADSTYPE_INTEGER;
const ADSTYPE MQ_QM_JOURNAL_QUOTA_ADSTYPE = ADSTYPE_INTEGER;
const ADSTYPE MQ_QM_MACHINE_TYPE_ADSTYPE = ADSTYPE_CASE_IGNORE_STRING;
const ADSTYPE MQ_QM_FOREIGN_ADSTYPE = ADSTYPE_BOOLEAN;
const ADSTYPE MQ_QM_OS_ADSTYPE = ADSTYPE_INTEGER;
const ADSTYPE MQ_QM_SECURITY_ADSTYPE = ADSTYPE_NT_SECURITY_DESCRIPTOR;
const ADSTYPE MQ_QM_SIGN_PK_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_QM_ENCRYPT_PK_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_QM_CREATE_TIME_ADSTYPE = ADSTYPE_UTC_TIME;
const ADSTYPE MQ_QM_MODIFY_TIME_ADSTYPE = ADSTYPE_UTC_TIME;
const ADSTYPE MQ_QM_SITES_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_QM_FULL_PATH_ADSTYPE = ADSTYPE_DN_STRING;
const ADSTYPE MQ_QM_MASTERID_ADSTYPE  = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_QM_NT4ID_ADSTYPE  = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_QM_WORKGROUP_ID_ADSTYPE  = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_QM_DESCRIPTION_ADSTYPE = ADSTYPE_CASE_IGNORE_STRING; 

//-----------------------------------------------------
//      MSMQ-queue

// TOP,  Superior computer
//-----------------------------------------------------
const WCHAR MSMQ_QUEUE_CLASS_NAME[] = L"mSMQQueue";

const WCHAR x_QueueCategoryName[] = L"CN=MSMQ-Queue";
const DWORD x_QueueCategoryLength = (sizeof( x_QueueCategoryName)/sizeof(WCHAR)) - 1;

const WCHAR MQ_Q_INSTANCE_ATTRIBUTE[] = L"objectGUID";          // PROPIQ_Q_INSTANCE
const WCHAR MQ_Q_TYPE_ATTRIBUTE[] = L"mSMQQueueType";      // PROPID_Q_TYPE
const WCHAR MQ_Q_PATHNAME_ATTRIBUTE[] = L"distinguishedName";     // PROPID_Q_PATHNAME
const WCHAR MQ_Q_JOURNAL_ATTRIBUTE[] = L"mSMQJournal";    // PROPID_Q_JOURNAL
const WCHAR MQ_Q_QUOTA_ATTRIBUTE[] = L"mSMQQueueQuota";     // PROPID_Q_QUOTA
const WCHAR MQ_Q_BASEPRIORITY_ATTRIBUTE[] = L"mSMQBasePriority";  // PROPID_Q_BASEPRIORITY
const WCHAR MQ_Q_JOURNAL_QUOTA_ATTRIBUTE[] = L"mSMQQueueJournalQuota";  // PROPID_Q_JOURNALQUOTA
const WCHAR MQ_Q_LABEL_ATTRIBUTE[] = L"mSMQLabelEx";         // PROPID_Q_LABEL
const WCHAR MQ_Q_CREATE_TIME_ATTRIBUTE[] = L"whenCreated";         // PROPID_Q_CREATE_TIME
const WCHAR MQ_Q_MODIFY_TIME_ATTRIBUTE[] = L"whenChanged";         // PROPID_Q_MODIFY_TIME
const WCHAR MQ_Q_AUTHENTICATE_ATTRIBUTE[] = L"mSMQAuthenticate";  // PROPID_Q_AUTHENTICATE
const WCHAR MQ_Q_PRIV_LEVEL_ATTRIBUTE[] = L"mSMQPrivacyLevel";  // PROPID_Q_PRIV_LEVEL
const WCHAR MQ_Q_TRANSACTION_ATTRIBUTE[] = L"mSMQTransactional";     // PROPID_Q_TRANSACTION
const WCHAR MQ_Q_SECURITY_ATTRIBUTE[] = L"nTSecurityDescriptor";     // PROPID_Q_SECURITY
const WCHAR MQ_Q_MASTERID_ATTRIBUTE[] = L"mSMQOwnerID";     // PROPID_Q_MASTERID
const WCHAR MQ_Q_NT4ID_ATTRIBUTE[] = L"objectGUID";          // PROPIQ_Q_NT4ID
const WCHAR MQ_Q_FULL_PATH_ATTRIBUTE[] = L"distinguishedName"; // PROPID_Q_FULL_PATH
const WCHAR MQ_Q_NAME_EXT[] = L"mSMQQueueNameExt";
const WCHAR MQ_Q_MULTICAST_ADDRESS[] = L"MSMQ-MulticastAddress"; // PROPID_Q_MULTICAST_ADDRESS

const ADSTYPE MQ_Q_INSTANCE_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_Q_TYPE_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_Q_JOURNAL_ADSTYPE = ADSTYPE_BOOLEAN;
const ADSTYPE MQ_Q_QUOTA_ADSTYPE = ADSTYPE_INTEGER;
const ADSTYPE MQ_Q_BASEPRIORITY_ADSTYPE = ADSTYPE_INTEGER;
const ADSTYPE MQ_Q_JOURNAL_QUOTA_ADSTYPE = ADSTYPE_INTEGER;
const ADSTYPE MQ_Q_LABEL_ADSTYPE = ADSTYPE_CASE_IGNORE_STRING;
const ADSTYPE MQ_Q_CREATE_TIME_ADSTYPE = ADSTYPE_UTC_TIME;
const ADSTYPE MQ_Q_MODIFY_TIME_ADSTYPE = ADSTYPE_UTC_TIME;
const ADSTYPE MQ_Q_AUTHENTICATE_ADSTYPE = ADSTYPE_BOOLEAN;
const ADSTYPE MQ_Q_PRIV_LEVEL_ADSTYPE = ADSTYPE_INTEGER;
const ADSTYPE MQ_Q_TRANSACTION_ADSTYPE = ADSTYPE_BOOLEAN;
const ADSTYPE MQ_Q_SECURITY_ADSTYPE = ADSTYPE_NT_SECURITY_DESCRIPTOR;
const ADSTYPE MQ_Q_MASTERID_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_Q_NT4ID_ADSTYPE = ADSTYPE_OCTET_STRING;
const ADSTYPE MQ_Q_FULL_PATH_ADSTYPE = ADSTYPE_DN_STRING;
const ADSTYPE MQ_Q_NAME_EXT_ADSTYPE = ADSTYPE_CASE_EXACT_STRING;
const ADSTYPE MQ_Q_MULTICAST_ADDRESS_ADSTYPE = ADSTYPE_CASE_IGNORE_STRING;


//-----------------------------------------------------
//      Site
//-----------------------------------------------------
const WCHAR MSMQ_SITE_CLASS_NAME[] = L"site";

const WCHAR x_SiteCategoryName[] = L"CN=Site";
const DWORD x_SiteCategoryLength = (sizeof( x_SiteCategoryName)/sizeof(WCHAR)) - 1;

const WCHAR MQ_S_NAME_ATTRIBUTE[] = L"cn";                         //PROPID_S_PATHNAME
const WCHAR MQ_S_ID_ATTRIBUTE[] = L"objectGUID";                   //PROPID_S_SITEID
const WCHAR 