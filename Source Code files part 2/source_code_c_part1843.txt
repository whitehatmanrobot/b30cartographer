
    c = get_byte(s);
    if (c == EOF) s->z_err = Z_DATA_ERROR;
    x += ((uLong)c)<<24;
    return x;
}

/* ===========================================================================
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state.
*/
int ZEXPORT gzclose (file)
    gzFile file;
{
    int err;
    gz_stream *s = (gz_stream*)file;

    if (s == NULL) return Z_STREAM_ERROR;

    if (s->mode == 'w') {
#ifdef NO_DEFLATE
	return Z_STREAM_ERROR;
#else
        err = do_flush (file, Z_FINISH);
        if (err != Z_OK) return destroy((gz_stream*)file);

        putLong (s->file, s->crc);
        putLong (s->file, s->stream.total_in);
#endif
    }
    return destroy((gz_stream*)file);
}

/* ===========================================================================
     Returns the error message for the last error which occured on the
   given compressed file. errnum is set to zlib error number. If an
   error occured in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/
const char*  ZEXPORT gzerror (file, errnum)
    gzFile file;
    int *errnum;
{
    char *m;
    gz_stream *s = (gz_stream*)file;

    if (s == NULL) {
        *errnum = Z_STREAM_ERROR;
        return (const char*)ERR_MSG(Z_STREAM_ERROR);
    }
    *errnum = s->z_err;
    if (*errnum == Z_OK) return (const char*)"";

    m =  (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);

    if (m == NULL || *m == '\0') m = (char*)ERR_MSG(s->z_err);

    TRYFREE(s->msg);
    s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);
    strcpy(s->msg, s->path);
    strcat(s->msg, ": ");
    strcat(s->msg, m);
    return (const char*)s->msg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\infcodes.h ===
/* infcodes.h -- header to use infcodes.c
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

struct inflate_codes_state;
typedef struct inflate_codes_state FAR inflate_codes_statef;

extern inflate_codes_statef *inflate_codes_new OF((
    uInt, uInt,
    inflate_huft *, inflate_huft *,
    z_streamp ));

extern int inflate_codes OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));

extern void inflate_codes_free OF((
    inflate_codes_statef *,
    z_streamp ));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\inffixed.h ===
/* inffixed.h -- table for decoding fixed codes
 * Generated automatically by the maketree.c program
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

local uInt fixed_bl = 9;
local uInt fixed_bd = 5;
local inflate_huft fixed_tl[] = {
    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},192},
    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},160},
    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},224},
    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},144},
    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},208},
    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},176},
    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},240},
    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},200},
    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},168},
    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},232},
    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},152},
    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},216},
    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},184},
    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},248},
    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},196},
    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},164},
    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},228},
    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},148},
    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},212},
    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},180},
    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},244},
    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},204},
    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},172},
    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},236},
    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},156},
    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},220},
    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},188},
    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},252},
    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},194},
    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},162},
    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},226},
    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},146},
    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},210},
    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},178},
    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},242},
    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},202},
    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},170},
    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},234},
    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},154},
    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},218},
    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},186},
    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},250},
    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},198},
    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},166},
    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},230},
    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},150},
    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},214},
    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},182},
    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},246},
    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},206},
    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},174},
    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},238},
    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},158},
    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},222},
    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},190},
    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},254},
    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},193},
    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},161},
    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},225},
    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},145},
    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},209},
    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},177},
    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},241},
    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},201},
    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},169},
    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},233},
    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},153},
    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},217},
    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},185},
    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},249},
    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},197},
    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},165},
    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},229},
    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},149},
    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},213},
    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},181},
    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},245},
    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},205},
    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},173},
    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},237},
    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},157},
    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},221},
    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},189},
    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},253},
    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},195},
    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},163},
    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},227},
    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},147},
    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},211},
    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},179},
    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},243},
    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},203},
    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},171},
    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},235},
    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},155},
    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},219},
    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},187},
    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},251},
    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},199},
    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},167},
    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},231},
    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},151},
    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},215},
    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},183},
    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},247},
    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},207},
    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},175},
    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},239},
    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},159},
    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},223},
    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},191},
    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},255}
  };
local inflate_huft fixed_td[] = {
    {{{80,5}},1}, {{{87,5}},257}, {{{83,5}},17}, {{{91,5}},4097},
    {{{81,5}},5}, {{{89,5}},1025}, {{{85,5}},65}, {{{93,5}},16385},
    {{{80,5}},3}, {{{88,5}},513}, {{{84,5}},33}, {{{92,5}},8193},
    {{{82,5}},9}, {{{90,5}},2049}, {{{86,5}},129}, {{{192,5}},24577},
    {{{80,5}},2}, {{{87,5}},385}, {{{83,5}},25}, {{{91,5}},6145},
    {{{81,5}},7}, {{{89,5}},1537}, {{{85,5}},97}, {{{93,5}},24577},
    {{{80,5}},4}, {{{88,5}},769}, {{{84,5}},49}, {{{92,5}},12289},
    {{{82,5}},13}, {{{90,5}},3073}, {{{86,5}},193}, {{{192,5}},24577}
  };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\inffast.c ===
/* inffast.c -- process literals and length/distance pairs fast
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"
#include "infblock.h"
#include "infcodes.h"
#include "infutil.h"
#include "inffast.h"

struct inflate_codes_state {int dummy;}; /* for buggy compilers */

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits

/* macros for bit input with no checking and for returning unused bytes */
#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
#define UNGRAB {c=z->avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;}

/* Called with number of bytes left to write in window at least 258
   (the maximum string length) and number of input bytes available
   at least ten.  The ten bytes are six bytes for the longest length/
   distance pair plus four bytes for overloading the bit buffer. */

int inflate_fast(uInt bl, uInt bd, inflate_huft *tl, inflate_huft *td, inflate_blocks_statef *s,  z_streamp z)
{
  inflate_huft *t;      /* temporary pointer */
  uInt e;               /* extra bits or operation */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */
  uInt ml;              /* mask for literal/length tree */
  uInt md;              /* mask for distance tree */
  uInt c;               /* bytes to copy */
  uInt d;               /* distance back to copy from */
  Bytef *r;             /* copy source pointer */

  /* load input, output, bit values */
  LOAD

  /* initialize masks */
  ml = inflate_mask[bl];
  md = inflate_mask[bd];

  /* do until not enough input or output space for fast loop */
  do {                          /* assume called with m >= 258 && n >= 10 */
    /* get literal/length code */
    GRABBITS(20)                /* max bits for literal/length code */
    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
    {
      DUMPBITS(t->bits)
      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                "inflate:         * literal '%c'\n" :
                "inflate:         * literal 0x%02x\n", t->base));
      *q++ = (Byte)t->base;
      m--;
      continue;
    }
    do {
      DUMPBITS(t->bits)
      if (e & 16)
      {
        /* get extra bits for length */
        e &= 15;
        c = t->base + ((uInt)b & inflate_mask[e]);
        DUMPBITS(e)
        Tracevv((stderr, "inflate:         * length %u\n", c));

        /* decode distance base of block to copy */
        GRABBITS(15);           /* max bits for distance code */
        e = (t = td + ((uInt)b & md))->exop;
        do {
          DUMPBITS(t->bits)
          if (e & 16)
          {
            /* get extra bits to add to distance base */
            e &= 15;
            GRABBITS(e)         /* get extra bits (up to 13) */
            d = t->base + ((uInt)b & inflate_mask[e]);
            DUMPBITS(e)
            Tracevv((stderr, "inflate:         * distance %u\n", d));

            /* do the copy */
            m -= c;
            r = q - d;
            if (r < s->window)                  /* wrap if needed */
            {
              do {
                r += s->end - s->window;        /* force pointer in window */
              } while (r < s->window);          /* covers invalid distances */
              e = (uInt)(s->end - r);
              if (c > e)
              {
                c -= e;                         /* wrapped copy */
                do {
                    *q++ = *r++;
                } while (--e);
                r = s->window;
                do {
                    *q++ = *r++;
                } while (--c);
              }
              else                              /* normal copy */
              {
                *q++ = *r++;  c--;
                *q++ = *r++;  c--;
                do {
                    *q++ = *r++;
                } while (--c);
              }
            }
            else                                /* normal copy */
            {
              *q++ = *r++;  c--;
              *q++ = *r++;  c--;
              do {
                *q++ = *r++;
              } while (--c);
            }
            break;
          }
          else if ((e & 64) == 0)
          {
            t += t->base;
            e = (t += ((uInt)b & inflate_mask[e]))->exop;
          }
          else
          {
            z->msg = (char*)"invalid distance code";
            UNGRAB
            UPDATE
            return Z_DATA_ERROR;
          }
        } while (1);
        break;
      }
      if ((e & 64) == 0)
      {
        t += t->base;
        if ((e = (t += ((uInt)b & inflate_mask[e]))->exop) == 0)
        {
          DUMPBITS(t->bits)
          Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                    "inflate:         * literal '%c'\n" :
                    "inflate:         * literal 0x%02x\n", t->base));
          *q++ = (Byte)t->base;
          m--;
          break;
        }
      }
      else if (e & 32)
      {
        Tracevv((stderr, "inflate:         * end of block\n"));
        UNGRAB
        UPDATE
        return Z_STREAM_END;
      }
      else
      {
        z->msg = (char*)"invalid literal/length code";
        UNGRAB
        UPDATE
        return Z_DATA_ERROR;
      }
    } while (1);
  } while (m >= 258 && n >= 10);

  /* not enough input or output--restore pointers and return */
  UNGRAB
  UPDATE
  return Z_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\inffast.h ===
/* inffast.h -- header to use inffast.c
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

extern int inflate_fast OF((
    uInt,
    uInt,
    inflate_huft *,
    inflate_huft *,
    inflate_blocks_statef *,
    z_streamp ));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\infblock.h ===
/* infblock.h -- header to use infblock.c
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

struct inflate_blocks_state;
typedef struct inflate_blocks_state FAR inflate_blocks_statef;

extern inflate_blocks_statef * inflate_blocks_new OF((
    z_streamp z,
    check_func c,               /* check function */
    uInt w));                   /* window size */

extern int inflate_blocks OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));                      /* initial return code */

extern void inflate_blocks_reset OF((
    inflate_blocks_statef *,
    z_streamp ,
    uLongf *));                  /* check value on output */

extern int inflate_blocks_free OF((
    inflate_blocks_statef *,
    z_streamp));

extern void inflate_set_dictionary OF((
    inflate_blocks_statef *s,
    const Bytef *d,  /* dictionary */
    uInt  n));       /* dictionary length */

extern int inflate_blocks_sync_point OF((
    inflate_blocks_statef *s));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\infcodes.c ===
/* infcodes.c -- process literals and length/distance pairs
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"
#include "infblock.h"
#include "infcodes.h"
#include "infutil.h"
#include "inffast.h"

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits

typedef enum {        /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
      START,    /* x: set up for LEN */
      LEN,      /* i: get length/literal/eob next */
      LENEXT,   /* i: getting length extra (have base) */
      DIST,     /* i: get distance next */
      DISTEXT,  /* i: getting distance extra */
      COPY,     /* o: copying bytes in window, waiting for space */
      LIT,      /* o: got literal, waiting for output space */
      WASH,     /* o: got eob, possibly still output waiting */
      END,      /* x: got eob and all data flushed */
      BADCODE}  /* x: got error */
inflate_codes_mode;

/* inflate codes private state */
struct inflate_codes_state {

  /* mode */
  inflate_codes_mode mode;      /* current inflate_codes mode */

  /* mode dependent information */
  uInt len;
  union {
    struct {
      inflate_huft *tree;       /* pointer into tree */
      uInt need;                /* bits needed */
    } code;             /* if LEN or DIST, where in tree */
    uInt lit;           /* if LIT, literal */
    struct {
      uInt get;                 /* bits to get for extra */
      uInt dist;                /* distance back to copy from */
    } copy;             /* if EXT or COPY, where and how much */
  } sub;                /* submode */

  /* mode independent information */
  Byte lbits;           /* ltree bits decoded per branch */
  Byte dbits;           /* dtree bits decoder per branch */
  inflate_huft *ltree;          /* literal/length/eob tree */
  inflate_huft *dtree;          /* distance tree */

};


inflate_codes_statef *inflate_codes_new(uInt bl, uInt bd, inflate_huft *tl, inflate_huft *td, z_streamp z)
{
  inflate_codes_statef *c;

  if ((c = (inflate_codes_statef *)
       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
  {
    c->mode = START;
    c->lbits = (Byte)bl;
    c->dbits = (Byte)bd;
    c->ltree = tl;
    c->dtree = td;
    Tracev((stderr, "inflate:       codes new\n"));
  }
  return c;
}


int inflate_codes(inflate_blocks_statef *s, z_streamp z, int r)
{
  uInt j;               /* temporary storage */
  inflate_huft *t;      /* temporary pointer */
  uInt e;               /* extra bits or operation */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */
  Bytef *f;             /* pointer to copy strings from */
  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD

  /* process input and output based on current state */
  while (1) switch (c->mode)
  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
    case START:         /* x: set up for LEN */
#ifndef SLOW
      if (m >= 258 && n >= 10)
      {
        UPDATE
        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
        LOAD
        if (r != Z_OK)
        {
          c->mode = r == Z_STREAM_END ? WASH : BADCODE;
          break;
        }
      }
#endif /* !SLOW */
      c->sub.code.need = c->lbits;
      c->sub.code.tree = c->ltree;
      c->mode = LEN;
    case LEN:           /* i: get length/literal/eob next */
      j = c->sub.code.need;
      NEEDBITS(j)
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
      DUMPBITS(t->bits)
      e = (uInt)(t->exop);
      if (e == 0)               /* literal */
      {
        c->sub.lit = t->base;
        Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                 "inflate:         literal '%c'\n" :
                 "inflate:         literal 0x%02x\n", t->base));
        c->mode = LIT;
        break;
      }
      if (e & 16)               /* length */
      {
        c->sub.copy.get = e & 15;
        c->len = t->base;
        c->mode = LENEXT;
        break;
      }
      if ((e & 64) == 0)        /* next table */
      {
        c->sub.code.need = e;
        c->sub.code.tree = t + t->base;
        break;
      }
      if (e & 32)               /* end of block */
      {
        Tracevv((stderr, "inflate:         end of block\n"));
        c->mode = WASH;
        break;
      }
      c->mode = BADCODE;        /* invalid code */
      z->msg = (char*)"invalid literal/length code";
      r = Z_DATA_ERROR;
      LEAVE
    case LENEXT:        /* i: getting length extra (have base) */
      j = c->sub.copy.get;
      NEEDBITS(j)
      c->len += (uInt)b & inflate_mask[j];
      DUMPBITS(j)
      c->sub.code.need = c->dbits;
      c->sub.code.tree = c->dtree;
      Tracevv((stderr, "inflate:         length %u\n", c->len));
      c->mode = DIST;
    case DIST:          /* i: get distance next */
      j = c->sub.code.need;
      NEEDBITS(j)
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
      DUMPBITS(t->bits)
      e = (uInt)(t->exop);
      if (e & 16)               /* distance */
      {
        c->sub.copy.get = e & 15;
        c->sub.copy.dist = t->base;
        c->mode = DISTEXT;
        break;
      }
      if ((e & 64) == 0)        /* next table */
      {
        c->sub.code.need = e;
        c->sub.code.tree = t + t->base;
        break;
      }
      c->mode = BADCODE;        /* invalid code */
      z->msg = (char*)"invalid distance code";
      r = Z_DATA_ERROR;
      LEAVE
    case DISTEXT:       /* i: getting distance extra */
      j = c->sub.copy.get;
      NEEDBITS(j)
      c->sub.copy.dist += (uInt)b & inflate_mask[j];
      DUMPBITS(j)
      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
      c->mode = COPY;
    case COPY:          /* o: copying bytes in window, waiting for space */
      f = q - c->sub.copy.dist;
      while (f < s->window)             /* modulo window size-"while" instead */
        f += s->end - s->window;        /* of "if" handles invalid distances */
      while (c->len)
      {
        NEEDOUT
        OUTBYTE(*f++)
        if (f == s->end)
          f = s->window;
        c->len--;
      }
      c->mode = START;
      break;
    case LIT:           /* o: got literal, waiting for output space */
      NEEDOUT
      OUTBYTE(c->sub.lit)
      c->mode = START;
      break;
    case WASH:          /* o: got eob, possibly more output */
      if (k > 7)        /* return unused byte, if any */
      {
        Assert(k < 16, "inflate_codes grabbed too many bytes")
        k -= 8;
        n++;
        p--;            /* can always return one */
      }
      FLUSH
      if (s->read != s->write)
        LEAVE
      c->mode = END;
    case END:
      r = Z_STREAM_END;
      LEAVE
    case BADCODE:       /* x: got error */
      r = Z_DATA_ERROR;
      LEAVE
    default:
      r = Z_STREAM_ERROR;
      LEAVE
  }
#ifdef NEED_DUMMY_RETURN
  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
#endif
}


void inflate_codes_free(inflate_codes_statef *c, z_streamp z)
{
  ZFREE(z, c);
  Tracev((stderr, "inflate:       codes free\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\inflate.c ===
/* inflate.c -- zlib interface to inflate modules
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "infblock.h"

struct inflate_blocks_state {int dummy;}; /* for buggy compilers */

typedef enum {
      METHOD,   /* waiting for method byte */
      FLAG,     /* waiting for flag byte */
      DICT4,    /* four dictionary check bytes to go */
      DICT3,    /* three dictionary check bytes to go */
      DICT2,    /* two dictionary check bytes to go */
      DICT1,    /* one dictionary check byte to go */
      DICT0,    /* waiting for inflateSetDictionary */
      BLOCKS,   /* decompressing blocks */
      CHECK4,   /* four check bytes to go */
      CHECK3,   /* three check bytes to go */
      CHECK2,   /* two check bytes to go */
      CHECK1,   /* one check byte to go */
      DONE,     /* finished check, done */
      BAD}      /* got an error--stay here */
inflate_mode;

/* inflate private state */
struct internal_state {

  /* mode */
  inflate_mode  mode;   /* current inflate mode */

  /* mode dependent information */
  union {
    uInt method;        /* if FLAGS, method byte */
    struct {
      uLong was;                /* computed check value */
      uLong need;               /* stream check value */
    } check;            /* if CHECK, check values to compare */
    uInt marker;        /* if BAD, inflateSync's marker bytes count */
  } sub;        /* submode */

  /* mode independent information */
  int  nowrap;          /* flag for no wrapper */
  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */
  inflate_blocks_statef 
    *blocks;            /* current inflate_blocks state */

};


int ZEXPORT inflateReset(z_streamp z)
{
  if (z == Z_NULL || z->state == Z_NULL)
    return Z_STREAM_ERROR;
  z->total_in = z->total_out = 0;
  z->msg = Z_NULL;
  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
  inflate_blocks_reset(z->state->blocks, z, Z_NULL);
  Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}


int ZEXPORT inflateEnd(z_streamp z)
{
  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
    return Z_STREAM_ERROR;
  if (z->state->blocks != Z_NULL)
    inflate_blocks_free(z->state->blocks, z);
  ZFREE(z, z->state);
  z->state = Z_NULL;
  Tracev((stderr, "inflate: end\n"));
  return Z_OK;
}


int ZEXPORT inflateInit2_(z_streamp z, int w, const char *version, int stream_size)
{
  if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
      stream_size != sizeof(z_stream))
      return Z_VERSION_ERROR;

  /* initialize state */
  if (z == Z_NULL)
    return Z_STREAM_ERROR;
  z->msg = Z_NULL;
  if (z->zalloc == Z_NULL)
  {
    z->zalloc = zcalloc;
    z->opaque = (voidpf)0;
  }
  if (z->zfree == Z_NULL) z->zfree = zcfree;
  if ((z->state = (struct internal_state FAR *)
       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
    return Z_MEM_ERROR;
  z->state->blocks = Z_NULL;

  /* handle undocumented nowrap option (no zlib header or check) */
  z->state->nowrap = 0;
  if (w < 0)
  {
    w = - w;
    z->state->nowrap = 1;
  }

  /* set window size */
  if (w < 8 || w > 15)
  {
    inflateEnd(z);
    return Z_STREAM_ERROR;
  }
  z->state->wbits = (uInt)w;

  /* create inflate_blocks state */
  if ((z->state->blocks =
      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))
      == Z_NULL)
  {
    inflateEnd(z);
    return Z_MEM_ERROR;
  }
  Tracev((stderr, "inflate: allocated\n"));

  /* reset state */
  inflateReset(z);
  return Z_OK;
}


int ZEXPORT inflateInit_(z_streamp z, const char *version, int stream_size)
{
  return inflateInit2_(z, DEF_WBITS, version, stream_size);
}


#define NEEDBYTE {if(z->avail_in==0)return r;r=f;}
#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)

int ZEXPORT inflate(z_streamp z, int f)
{
  int r;
  uInt b;

  if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL)
    return Z_STREAM_ERROR;
  f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
  r = Z_BUF_ERROR;
  while (1) switch (z->state->mode)
  {
    case METHOD:
      NEEDBYTE
      if (((z->state->sub.method = NEXTBYTE) & 0xf) != Z_DEFLATED)
      {
        z->state->mode = BAD;
        z->msg = (char*)"unknown compression method";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
      {
        z->state->mode = BAD;
        z->msg = (char*)"invalid window size";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      z->state->mode = FLAG;
    case FLAG:
      NEEDBYTE
      b = NEXTBYTE;
      if (((z->state->sub.method << 8) + b) % 31)
      {
        z->state->mode = BAD;
        z->msg = (char*)"incorrect header check";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      Tracev((stderr, "inflate: zlib header ok\n"));
      if (!(b & PRESET_DICT))
      {
        z->state->mode = BLOCKS;
        break;
      }
      z->state->mode = DICT4;
    case DICT4:
      NEEDBYTE
      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
      z->state->mode = DICT3;
    case DICT3:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
      z->state->mode = DICT2;
    case DICT2:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
      z->state->mode = DICT1;
    case DICT1:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE;
      z->adler = z->state->sub.check.need;
      z->state->mode = DICT0;
      return Z_NEED_DICT;
    case DICT0:
      z->state->mode = BAD;
      z->msg = (char*)"need dictionary";
      z->state->sub.marker = 0;       /* can try inflateSync */
      return Z_STREAM_ERROR;
    case BLOCKS:
      r = inflate_blocks(z->state->blocks, z, r);
      if (r == Z_DATA_ERROR)
      {
        z->state->mode = BAD;
        z->state->sub.marker = 0;       /* can try inflateSync */
        break;
      }
      if (r == Z_OK)
        r = f;
      if (r != Z_STREAM_END)
        return r;
      r = f;
      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
      if (z->state->nowrap)
      {
        z->state->mode = DONE;
        break;
      }
      z->state->mode = CHECK4;
    case CHECK4:
      NEEDBYTE
      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
      z->state->mode = CHECK3;
    case CHECK3:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
      z->state->mode = CHECK2;
    case CHECK2:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
      z->state->mode = CHECK1;
    case CHECK1:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE;

      if (z->state->sub.check.was != z->state->sub.check.need)
      {
        z->state->mode = BAD;
        z->msg = (char*)"incorrect data check";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      Tracev((stderr, "inflate: zlib check ok\n"));
      z->state->mode = DONE;
    case DONE:
      return Z_STREAM_END;
    case BAD:
      return Z_DATA_ERROR;
    default:
      return Z_STREAM_ERROR;
  }
#ifdef NEED_DUMMY_RETURN
  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
#endif
}


int ZEXPORT inflateSetDictionary(z_streamp z, const Bytef *dictionary, uInt dictLength)
{
  uInt length = dictLength;

  if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)
    return Z_STREAM_ERROR;

  if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;
  z->adler = 1L;

  if (length >= ((uInt)1<<z->state->wbits))
  {
    length = (1<<z->state->wbits)-1;
    dictionary += dictLength - length;
  }
  inflate_set_dictionary(z->state->blocks, dictionary, length);
  z->state->mode = BLOCKS;
  return Z_OK;
}


int ZEXPORT inflateSync(z_streamp z)
{
  uInt n;       /* number of bytes to look at */
  Bytef *p;     /* pointer to bytes */
  uInt m;       /* number of marker bytes found in a row */
  uLong r, w;   /* temporaries to save total_in and total_out */

  /* set up */
  if (z == Z_NULL || z->state == Z_NULL)
    return Z_STREAM_ERROR;
  if (z->state->mode != BAD)
  {
    z->state->mode = BAD;
    z->state->sub.marker = 0;
  }
  if ((n = z->avail_in) == 0)
    return Z_BUF_ERROR;
  p = z->next_in;
  m = z->state->sub.marker;

  /* search */
  while (n && m < 4)
  {
    static const Byte mark[4] = {0, 0, 0xff, 0xff};
    if (*p == mark[m])
      m++;
    else if (*p)
      m = 0;
    else
      m = 4 - m;
    p++, n--;
  }

  /* restore */
  /* !!! on IA64, p-z->next_in could technically be bigger than 32bits.
         We need to verify that it's not possible in this code. */
  z->total_in += (uLong) (p - z->next_in);
  z->next_in = p;
  z->avail_in = n;
  z->state->sub.marker = m;

  /* return no joy or set up to restart on a new block */
  if (m != 4)
    return Z_DATA_ERROR;
  r = z->total_in;  w = z->total_out;
  inflateReset(z);
  z->total_in = r;  z->total_out = w;
  z->state->mode = BLOCKS;
  return Z_OK;
}


/* Returns true if inflate is currently at the end of a block generated
 * by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
 * implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH
 * but removes the length bytes of the resulting empty stored block. When
 * decompressing, PPP checks that at the end of input packet, inflate is
 * waiting for these length bytes.
 */
int ZEXPORT inflateSyncPoint(z_streamp z)
{
  if (z == Z_NULL || z->state == Z_NULL || z->state->blocks == Z_NULL)
    return Z_STREAM_ERROR;
  return inflate_blocks_sync_point(z->state->blocks);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\inftrees.h ===
/* inftrees.h -- header to use inftrees.c
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* Huffman code lookup table entry--this entry is four bytes for machines
   that have 16-bit pointers (e.g. PC's in the small or medium model). */

typedef struct inflate_huft_s FAR inflate_huft;

struct inflate_huft_s {
  union {
    struct {
      Byte Exop;        /* number of extra bits or operation */
      Byte Bits;        /* number of bits in this code or subcode */
    } what;
    uInt pad;           /* pad structure to a power of 2 (4 bytes for */
  } word;               /*  16-bit, 8 bytes for 32-bit int's) */
  uInt base;            /* literal, length base, distance base,
                           or table offset */
};

/* Maximum size of dynamic tree.  The maximum found in a long but non-
   exhaustive search was 1004 huft structures (850 for length/literals
   and 154 for distances, the latter actually the result of an
   exhaustive search).  The actual maximum is not known, but the
   value below is more than safe. */
#define MANY 1440

extern int inflate_trees_bits OF((
    uIntf *,                    /* 19 code lengths */
    uIntf *,                    /* bits tree desired/actual depth */
    inflate_huft * FAR *,       /* bits tree result */
    inflate_huft *,             /* space for trees */
    z_streamp));                /* for messages */

extern int inflate_trees_dynamic OF((
    uInt,                       /* number of literal/length codes */
    uInt,                       /* number of distance codes */
    uIntf *,                    /* that many (total) code lengths */
    uIntf *,                    /* literal desired/actual bit depth */
    uIntf *,                    /* distance desired/actual bit depth */
    inflate_huft * FAR *,       /* literal/length tree result */
    inflate_huft * FAR *,       /* distance tree result */
    inflate_huft *,             /* space for trees */
    z_streamp));                /* for messages */

extern int inflate_trees_fixed OF((
    uIntf *,                    /* literal desired/actual bit depth */
    uIntf *,                    /* distance desired/actual bit depth */
    inflate_huft * FAR *,       /* literal/length tree result */
    inflate_huft * FAR *,       /* distance tree result */
    z_streamp));                /* for memory allocation */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\infutil.h ===
/* infutil.h -- types and macros common to blocks and codes
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

#ifndef _INFUTIL_H
#define _INFUTIL_H

typedef enum {
      TYPE,     /* get type bits (3, including end bit) */
      LENS,     /* get lengths for stored */
      STORED,   /* processing stored block */
      TABLE,    /* get table lengths */
      BTREE,    /* get bit lengths tree for a dynamic block */
      DTREE,    /* get length, distance trees for a dynamic block */
      CODES,    /* processing fixed or dynamic block */
      DRY,      /* output remaining window bytes */
      DONE,     /* finished last block, done */
      BAD}      /* got a data error--stuck here */
inflate_block_mode;

/* inflate blocks semi-private state */
struct inflate_blocks_state {

  /* mode */
  inflate_block_mode  mode;     /* current inflate_block mode */

  /* mode dependent information */
  union {
    uInt left;          /* if STORED, bytes left to copy */
    struct {
      uInt table;               /* table lengths (14 bits) */
      uInt index;               /* index into blens (or border) */
      uIntf *blens;             /* bit lengths of codes */
      uInt bb;                  /* bit length tree depth */
      inflate_huft *tb;         /* bit length decoding tree */
    } trees;            /* if DTREE, decoding info for trees */
    struct {
      inflate_codes_statef 
         *codes;
    } decode;           /* if CODES, current state */
  } sub;                /* submode */
  uInt last;            /* true if this block is the last block */

  /* mode independent information */
  uInt bitk;            /* bits in bit buffer */
  uLong bitb;           /* bit buffer */
  inflate_huft *hufts;  /* single malloc for tree space */
  Bytef *window;        /* sliding window */
  Bytef *end;           /* one byte after sliding window */
  Bytef *read;          /* window read pointer */
  Bytef *write;         /* window write pointer */
  check_func checkfn;   /* check function */
  uLong check;          /* check on output */

};


/* defines for inflate input/output */
/*   update pointers and return */
#define UPDBITS {s->bitb=b;s->bitk=k;}
/* !!! on IA64, p-z->next_in could technically be bigger than 32bits.
       We need to verify that it's not possible in this code. */
#define UPDIN {z->avail_in=n;z->total_in+=(uLong)(p-z->next_in);z->next_in=p;}
#define UPDOUT {s->write=q;}
#define UPDATE {UPDBITS UPDIN UPDOUT}
#define LEAVE {UPDATE return inflate_flush(s,z,r);}
/*   get bytes and bits */
#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
#define NEXTBYTE (n--,*p++)
#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
#define DUMPBITS(j) {b>>=(j);k-=(j);}
/*   output bytes */
#define WAVAIL (uInt)(q<s->read?s->read-q-1:s->end-q)
#define LOADOUT {q=s->write;m=(uInt)WAVAIL;}
#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=(uInt)WAVAIL;}}
#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}
#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
/*   load local pointers */
#define LOAD {LOADIN LOADOUT}

/* masks for lower bits (size given to avoid silly warnings with Visual C++) */
extern uInt inflate_mask[17];

/* copy as much as possible from the sliding window to the output area */
extern int inflate_flush OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));

struct internal_state      {int dummy;}; /* for buggy compilers */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\trees.c ===
/* trees.c -- output deflated data using Huffman coding
 * Copyright (C) 1995-1998 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process uses several Huffman trees. The more
 *      common source values are represented by shorter bit sequences.
 *
 *      Each code tree is stored in a compressed form which is itself
 * a Huffman encoding of the lengths of all the code strings (in
 * ascending order by source values).  The actual code strings are
 * reconstructed from the lengths in the inflate process, as described
 * in the deflate specification.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
 *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
 *
 *      Storer, James A.
 *          Data Compression:  Methods and Theory, pp. 49-50.
 *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
 *
 *      Sedgewick, R.
 *          Algorithms, p290.
 *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
 */

/* @(#) $Id$ */

/* #define GEN_TREES_H */

#include "deflate.h"

#ifdef DEBUG
#  include <ctype.h>
#endif

/* ===========================================================================
 * Constants
 */

#define MAX_BL_BITS 7
/* Bit length codes must not exceed MAX_BL_BITS bits */

#define END_BLOCK 256
/* end of block literal code */

#define REP_3_6      16
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

#define REPZ_3_10    17
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

#define REPZ_11_138  18
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};

local const int extra_dbits[D_CODES] /* extra bits for each distance code */
   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};

local const uch bl_order[BL_CODES]
   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

#define Buf_size (8 * 2*sizeof(char))
/* Number of bits used within bi_buf. (bi_buf might be implemented on
 * more than 16 bits on some systems.)
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

#define DIST_CODE_LEN  512 /* see definition of array dist_code below */

#if defined(GEN_TREES_H) || !defined(STDC)
/* non ANSI compilers may not accept trees.h */

local ct_data static_ltree[L_CODES+2];
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

local ct_data static_dtree[D_CODES];
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

uch _dist_code[DIST_CODE_LEN];
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

uch _length_code[MAX_MATCH-MIN_MATCH+1];
/* length code for each normalized match length (0 == MIN_MATCH) */

local int base_length[LENGTH_CODES];
/* First normalized length for each code (0 = MIN_MATCH) */

local int base_dist[D_CODES];
/* First normalized distance for each code (0 = distance of 1) */

#else
#  include "trees.h"
#endif /* GEN_TREES_H */

struct static_tree_desc_s {
    const ct_data *static_tree;  /* static tree or NULL */
    const intf *extra_bits;      /* extra bits for each code or NULL */
    int     extra_base;          /* base index for extra_bits */
    int     elems;               /* max number of elements in the tree */
    int     max_length;          /* max bit length for the codes */
};

local static_tree_desc  static_l_desc =
{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};

local static_tree_desc  static_d_desc =
{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};

local static_tree_desc  static_bl_desc =
{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};

/* ===========================================================================
 * Local (static) routines in this file.
 */

local void tr_static_init OF((void));
local void init_block     OF((deflate_state *s));
local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
local void build_tree     OF((deflate_state *s, tree_desc *desc));
local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local int  build_bl_tree  OF((deflate_state *s));
local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
                              int blcodes));
local void compress_block OF((deflate_state *s, ct_data *ltree,
                              ct_data *dtree));
local void set_data_type  OF((deflate_state *s));
local unsigned bi_reverse OF((unsigned value, int length));
local void bi_windup      OF((deflate_state *s));
local void bi_flush       OF((deflate_state *s));
local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
                              int header));

#ifdef GEN_TREES_H
local void gen_trees_header OF((void));
#endif

#ifndef DEBUG
#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
   /* Send a code of the given tree. c and tree must not have side effects */

#else /* DEBUG */
#  define send_code(s, c, tree) \
     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
       send_bits(s, tree[c].Code, tree[c].Len); }
#endif

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
#define put_short(s, w) { \
    put_byte(s, (uch)((w) & 0xff)); \
    put_byte(s, (uch)((ush)(w) >> 8)); \
}

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
#ifdef DEBUG
local void send_bits      OF((deflate_state *s, int value, int length));

local void send_bits(deflate_state *s, int value, int length)
{
    Tracevv((stderr," l %2d v %4x ", length, value));
    Assert(length > 0 && length <= 15, "invalid length");
    s->bits_sent += (ulg)length;

    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
     * unused bits in value.
     */
    if (s->bi_valid > (int)Buf_size - length) {
        s->bi_buf |= (value << s->bi_valid);
        put_short(s, s->bi_buf);
        s->bi_buf = (ush)(value >> (Buf_size - s->bi_valid));
        s->bi_valid += length - Buf_size;
    } else {
        s->bi_buf |= value << s->bi_valid;
        s->bi_valid += length;
    }
}
#else /* !DEBUG */

#define send_bits(s, value, length) \
{ int len = length;\
  if (s->bi_valid > (int)Buf_size - len) {\
    int val = value;\
    s->bi_buf |= (val << s->bi_valid);\
    put_short(s, s->bi_buf);\
    s->bi_buf = (ush)((ush)val >> (Buf_size - s->bi_valid));\
    s->bi_valid += len - Buf_size;\
  } else {\
    s->bi_buf |= (value) << s->bi_valid;\
    s->bi_valid += len;\
  }\
}
#endif /* DEBUG */


#define MAX(a,b) (a >= b ? a : b)
/* the arguments must not have side effects */

/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
local void tr_static_init()
{
#if defined(GEN_TREES_H) || !defined(STDC)
    static int static_init_done = 0;
    int n;        /* iterates over tree elements */
    int bits;     /* bit counter */
    int length;   /* length value */
    int code;     /* code value */
    int dist;     /* distance index */
    ush bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    if (static_init_done) return;

    /* For some embedded targets, global variables are not initialized: */
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;

    /* Initialize the mapping length (0..255) -> length code (0..28) */
    length = 0;
    for (code = 0; code < LENGTH_CODES-1; code++) {
        base_length[code] = length;
        for (n = 0; n < (1<<extra_lbits[code]); n++) {
            _length_code[length++] = (uch)code;
        }
    }
    Assert (length == 256, "tr_static_init: length != 256");
    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
    _length_code[length-1] = (uch)code;

    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
    dist = 0;
    for (code = 0 ; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < (1<<extra_dbits[code]); n++) {
            _dist_code[dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: dist != 256");
    dist >>= 7; /* from now on, all distances are divided by 128 */
    for ( ; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
            _dist_code[256 + dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: 256+dist != 512");

    /* Construct the codes of the static literal tree */
    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
    n = 0;
    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);

    /* The static distance tree is trivial: */
    for (n = 0; n < D_CODES; n++) {
        static_dtree[n].Len = 5;
        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
    }
    static_init_done = 1;

#  ifdef GEN_TREES_H
    gen_trees_header();
#  endif
#endif /* defined(GEN_TREES_H) || !defined(STDC) */
}

/* ===========================================================================
 * Genererate the file trees.h describing the static trees.
 */
#ifdef GEN_TREES_H
#  ifndef DEBUG
#    include <stdio.h>
#  endif

#  define SEPARATOR(i, last, width) \
      ((i) == (last)? "\n};\n\n" :    \
       ((i) % (width) == (width)-1 ? ",\n" : ", "))

void gen_trees_header()
{
    FILE *header = fopen("trees.h", "w");
    int i;

    Assert (header != NULL, "Can't open trees.h");
    fprintf(header,
	    "/* header created automatically with -DGEN_TREES_H */\n\n");

    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
    for (i = 0; i < L_CODES+2; i++) {
	fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
		static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
    }

    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
	fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
		static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
    }

    fprintf(header, "const uch _dist_code[DIST_CODE_LEN] = {\n");
    for (i = 0; i < DIST_CODE_LEN; i++) {
	fprintf(header, "%2u%s", _dist_code[i],
		SEPARATOR(i, DIST_CODE_LEN-1, 20));
    }

    fprintf(header, "const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
	fprintf(header, "%2u%s", _length_code[i],
		SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
    }

    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
    for (i = 0; i < LENGTH_CODES; i++) {
	fprintf(header, "%1u%s", base_length[i],
		SEPARATOR(i, LENGTH_CODES-1, 20));
    }

    fprintf(header, "local const int base_dist[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
	fprintf(header, "%5u%s", base_dist[i],
		SEPARATOR(i, D_CODES-1, 10));
    }

    fclose(header);
}
#endif /* GEN_TREES_H */

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
void _tr_init(deflate_state *s)
{
    tr_static_init();

    s->l_desc.dyn_tree = s->dyn_ltree;
    s->l_desc.stat_desc = &static_l_desc;

    s->d_desc.dyn_tree = s->dyn_dtree;
    s->d_desc.stat_desc = &static_d_desc;

    s->bl_desc.dyn_tree = s->bl_tree;
    s->bl_desc.stat_desc = &static_bl_desc;

    s->bi_buf = 0;
    s->bi_valid = 0;
    s->last_eob_len = 8; /* enough lookahead for inflate */
#ifdef DEBUG
    s->compressed_len = 0L;
    s->bits_sent = 0L;
#endif

    /* Initialize the first block of the first file: */
    init_block(s);
}

/* ===========================================================================
 * Initialize a new block.
 */
local void init_block(deflate_state *s)
{
    int n; /* iterates over tree elements */

    /* Initialize the trees. */
    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

    s->dyn_ltree[END_BLOCK].Freq = 1;
    s->opt_len = s->static_len = 0L;
    s->last_lit = s->matches = 0;
}

#define SMALLEST 1
/* Index within the heap array of least frequent node in the Huffman tree */


/* ===========================================================================
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates heap and heap_len.
 */
#define pqremove(s, tree, top) \
{\
    top = s->heap[SMALLEST]; \
    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
    pqdownheap(s, tree, SMALLEST); \
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
#define smaller(tree, n, m, depth) \
   (tree[n].Freq < tree[m].Freq || \
   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
local void pqdownheap(deflate_state *s, ct_data *tree, int k)
{
    int v = s->heap[k];
    int j = k << 1;  /* left son of k */
    while (j <= s->heap_len) {
        /* Set j to the smallest of the two sons: */
        if (j < s->heap_len &&
            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
            j++;
        }
        /* Exit if v is smaller than both sons */
        if (smaller(tree, v, s->heap[j], s->depth)) break;

        /* Exchange v with the smallest son */
        s->heap[k] = s->heap[j];  k = j;

        /* And continue down the tree, setting j to the left son of k */
        j <<= 1;
    }
    s->heap[k] = v;
}

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
local void gen_bitlen(deflate_state *s, tree_desc *desc)
{
    ct_data *tree        = desc->dyn_tree;
    int max_code         = desc->max_code;
    const ct_data *stree = desc->stat_desc->static_tree;
    const intf *extra    = desc->stat_desc->extra_bits;
    int base             = desc->stat_desc->extra_base;
    int max_length       = desc->stat_desc->max_length;
    int h;              /* heap index */
    int n, m;           /* iterate over the tree elements */
    int bits;           /* bit length */
    int xbits;          /* extra bits */
    ush f;              /* frequency */
    int overflow = 0;   /* number of elements with bit length too large */

    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
        n = s->heap[h];
        bits = tree[tree[n].Dad].Len + 1;
        if (bits > max_length) bits = max_length, overflow++;
        tree[n].Len = (ush)bits;
        /* We overwrite tree[n].Dad which is no longer needed */

        if (n > max_code) continue; /* not a leaf node */

        s->bl_count[bits]++;
        xbits = 0;
        if (n >= base) xbits = extra[n-base];
        f = tree[n].Freq;
        s->opt_len += (ulg)f * (bits + xbits);
        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
    }
    if (overflow == 0) return;

    Trace((stderr,"\nbit length overflow\n"));
    /* This happens for example on obj2 and pic of the Calgary corpus */

    /* Find the first bit length which could increase: */
    do {
        bits = max_length-1;
        while (s->bl_count[bits] == 0) bits--;
        s->bl_count[bits]--;      /* move one leaf down the tree */
        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
        s->bl_count[max_length]--;
        /* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */
        overflow -= 2;
    } while (overflow > 0);

    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
    for (bits = max_length; bits != 0; bits--) {
        n = s->bl_count[bits];
        while (n != 0) {
            m = s->heap[--h];
            if (m > max_code) continue;
            if (tree[m].Len != (unsigned) bits) {
                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                s->opt_len += ((long)bits - (long)tree[m].Len)
                              *(long)tree[m].Freq;
                tree[m].Len = (ush)bits;
            }
            n--;
        }
    }
}

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
local void gen_codes (ct_data *tree, int max_code, ushf *bl_count)
{
    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
    ush code = 0;              /* running code value */
    int bits;                  /* bit index */
    int n;                     /* code index */

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
    for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = (ush)((code + bl_count[bits-1]) << 1);
    }
    /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
            "inconsistent bit counts");
    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

    for (n = 0;  n <= max_code; n++) {
        int len = tree[n].Len;
        if (len == 0) continue;
        /* Now reverse the bits */
        tree[n].Code = (ush)bi_reverse(next_code[len]++, len);

        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
    }
}

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
local void build_tree(deflate_state *s, tree_desc *desc)
{
    ct_data *tree         = desc->dyn_tree;
    const ct_data *stree  = desc->stat_desc->static_tree;
    int elems             = desc->stat_desc->elems;
    int n, m;          /* iterate over heap elements */
    int max_code = -1; /* largest code with non zero frequency */
    int node;          /* new node being created */

    /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */
    s->heap_len = 0, s->heap_max = HEAP_SIZE;

    for (n = 0; n < elems; n++) {
        if (tree[n].Freq != 0) {
            s->heap[++(s->heap_len)] = max_code = n;
            s->depth[n] = 0;
        } else {
            tree[n].Len = 0;
        }
    }

    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
    while (s->heap_len < 2) {
        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
        tree[node].Freq = 1;
        s->depth[node] = 0;
        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
        /* node is 0 or 1 so it does not have extra bits */
    }
    desc->max_code = max_code;

    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
    node = elems;              /* next internal node of the tree */
    do {
        pqremove(s, tree, n);  /* n = node of least frequency */
        m = s->heap[SMALLEST]; /* m = node of next least frequency */

        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
        s->heap[--(s->heap_max)] = m;

        /* Create a new node father of n and m */
        tree[node].Freq = (ush)(tree[n].Freq + tree[m].Freq);
        s->depth[node] = (uch) (MAX(s->depth[n], s->depth[m]) + 1);
        tree[n].Dad = tree[m].Dad = (ush)node;
#ifdef DUMP_BL_TREE
        if (tree == s->bl_tree) {
            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
        }
#endif
        /* and insert the new node in the heap */
        s->heap[SMALLEST] = node++;
        pqdownheap(s, tree, SMALLEST);

    } while (s->heap_len >= 2);

    s->heap[--(s->heap_max)] = s->heap[SMALLEST];

    /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */
    gen_bitlen(s, (tree_desc *)desc);

    /* The field len is now set, we can generate the bit codes */
    gen_codes ((ct_data *)tree, max_code, s->bl_count);
}

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
local void scan_tree (deflate_state *s, ct_data *tree, int max_code)
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    if (nextlen == 0) max_count = 138, min_count = 3;
    tree[max_code+1].Len = (ush)0xffff; /* guard */

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            s->bl_tree[curlen].Freq = (ush)(s->bl_tree[curlen].Freq + count);
        } else if (curlen != 0) {
            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
            s->bl_tree[REP_3_6].Freq++;
        } else if (count <= 10) {
            s->bl_tree[REPZ_3_10].Freq++;
        } else {
            s->bl_tree[REPZ_11_138].Freq++;
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
local void send_tree (deflate_state *s, ct_data *tree, int max_code)
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    /* tree[max_code+1].Len = -1; */  /* guard already set */
    if (nextlen == 0) max_count = 138, min_count = 3;

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

        } else if (curlen != 0) {
            if (curlen != prevlen) {
                send_code(s, curlen, s->bl_tree); count--;
            }
            Assert(count >= 3 && count <= 6, " 3_6?");
            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

        } else if (count <= 10) {
            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

        } else {
            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
local int build_bl_tree(deflate_state *s)
{
    int max_blindex;  /* index of last bit length code of non zero freq */

    /* Determine the bit length frequencies for literal and distance trees */
    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

    /* Build the bit length tree: */
    build_tree(s, (tree_desc *)(&(s->bl_desc)));
    /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
    }
    /* Update opt_len to include the bit length tree and counts */
    s->opt_len += 3*(max_blindex+1) + 5+5+4;
    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
            s->opt_len, s->static_len));

    return max_blindex;
}

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
local void send_all_trees(deflate_state *s, int lcodes, int dcodes, int blcodes)
{
    int rank;                    /* index in bl_order */

    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
            "too many codes");
    Tracev((stderr, "\nbl counts: "));
    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
    send_bits(s, dcodes-1,   5);
    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
    for (rank = 0; rank < blcodes; rank++) {
        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
    }
    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}

/* ===========================================================================
 * Send a stored block
 */
void _tr_stored_block(deflate_state *s, charf *buf, ulg stored_len, int eof)
{
    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
#ifdef DEBUG
    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
    s->compressed_len += (stored_len + 4) << 3;
#endif
    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
}

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 * The current inflate code requires 9 bits of lookahead. If the
 * last two codes for the previous block (real code plus EOB) were coded
 * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
 * the last real code. In this case we send two empty static blocks instead
 * of one. (There are no problems if the previous block is stored or fixed.)
 * To simplify the code, we assume the worst case of last real code encoded
 * on one bit only.
 */
void _tr_align(deflate_state *s)
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef DEBUG
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
#endif
    bi_flush(s);
    /* Of the 10 bits for the empty block, we have already sent
     * (10 - bi_valid) bits. The lookahead for the last real code (before
     * the EOB of the previous block) was thus at least one plus the length
     * of the EOB plus what we have just sent of the empty static block.
     */
    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
        send_bits(s, STATIC_TREES<<1, 3);
        send_code(s, END_BLOCK, static_ltree);
#ifdef DEBUG
        s->compressed_len += 10L;
#endif
        bi_flush(s);
    }
    s->last_eob_len = 7;
}

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
void _tr_flush_block(deflate_state *s, charf *buf, ulg stored_len, int eof)
{
    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
    int max_blindex = 0;  /* index of last bit length code of non zero freq */

    /* Build the Huffman trees unless a stored block is forced */
    if (s->level > 0) {

	 /* Check if the file is ascii or binary */
	if (s->data_type == Z_UNKNOWN) set_data_type(s);

	/* Construct the literal and distance trees */
	build_tree(s, (tree_desc *)(&(s->l_desc)));
	Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
		s->static_len));

	build_tree(s, (tree_desc *)(&(s->d_desc)));
	Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
		s->static_len));
	/* At this point, opt_len and static_len are the total bit lengths of
	 * the compressed block data, excluding the tree representations.
	 */

	/* Build the bit length tree for the above two trees, and get the index
	 * in bl_order of the last bit length code to send.
	 */
	max_blindex = build_bl_tree(s);

	/* Determine the best encoding. Compute first the block length in bytes*/
	opt_lenb = (s->opt_len+3+7)>>3;
	static_lenb = (s->static_len+3+7)>>3;

	Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
		opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
		s->last_lit));

	if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

    } else {
        Assert(buf != (char*)0, "lost buf");
	opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
    }

#ifdef FORCE_STORED
    if (buf != (char*)0) { /* force stored block */
#else
    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
                       /* 4: two words for the lengths */
#endif
        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
         * transform a block into a stored block.
         */
        _tr_stored_block(s, buf, stored_len, eof);

#ifdef FORCE_STATIC
    } else if (static_lenb >= 0) { /* force static trees */
#else
    } else if (static_lenb == opt_lenb) {
#endif
        send_bits(s, (STATIC_TREES<<1)+eof, 3);
        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
#ifdef DEBUG
        s->compressed_len += 3 + s->static_len;
#endif
    } else {
        send_bits(s, (DYN_TREES<<1)+eof, 3);
        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
                       max_blindex+1);
        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
#ifdef DEBUG
        s->compressed_len += 3 + s->opt_len;
#endif
    }
    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
    /* The above check is made mod 2^32, for files larger than 512 MB
     * and uLong implemented on 32 bits.
     */
    init_block(s);

    if (eof) {
        bi_windup(s);
#ifdef DEBUG
        s->compressed_len += 7;  /* align on byte boundary */
#endif
    }
    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
           s->compressed_len-7*eof));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
int _tr_tally (deflate_state *s, unsigned dist, unsigned lc)
{
    s->d_buf[s->last_lit] = (ush)dist;
    s->l_buf[s->last_lit++] = (uch)lc;
    if (dist == 0) {
        /* lc is the unmatched char */
        s->dyn_ltree[lc].Freq++;
    } else {
        s->matches++;
        /* Here, lc is the match length - MIN_MATCH */
        dist--;             /* dist = match distance - 1 */
        Assert((ush)dist < (ush)MAX_DIST(s) &&
               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
        s->dyn_dtree[d_code(dist)].Freq++;
    }

#ifdef TRUNCATE_BLOCK
    /* Try to guess if it is profitable to stop the current block here */
    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
        /* Compute an upper bound for the compressed length */
        ulg out_length = (ulg)s->last_lit*8L;
        ulg in_length = (ulg)((long)s->strstart - s->block_start);
        int dcode;
        for (dcode = 0; dcode < D_CODES; dcode++) {
            out_length += (ulg)s->dyn_dtree[dcode].Freq *
                (5L+extra_dbits[dcode]);
        }
        out_length >>= 3;
        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
               s->last_lit, in_length, out_length,
               100L - out_length*100L/in_length));
        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
    }
#endif
    return (s->last_lit == s->lit_bufsize-1);
    /* We avoid equality with lit_bufsize because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */
}

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
local void compress_block(deflate_state *s, ct_data *ltree, ct_data *dtree)
{
    unsigned dist;      /* distance of matched string */
    int lc;             /* match length or unmatched char (if dist == 0) */
    unsigned lx = 0;    /* running index in l_buf */
    unsigned code;      /* the code to send */
    int extra;          /* number of extra bits to send */

    if (s->last_lit != 0) do {
        dist = s->d_buf[lx];
        lc = s->l_buf[lx++];
        if (dist == 0) {
            send_code(s, lc, ltree); /* send a literal byte */
            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
        } else {
            /* Here, lc is the match length - MIN_MATCH */
            code = _length_code[lc];
            send_code(s, code+LITERALS+1, ltree); /* send the length code */
            extra = extra_lbits[code];
            if (extra != 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);       /* send the extra length bits */
            }
            dist--; /* dist is now the match distance - 1 */
            code = d_code(dist);
            Assert (code < D_CODES, "bad d_code");

            send_code(s, code, dtree);       /* send the distance code */
            extra = extra_dbits[code];
            if (extra != 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);   /* send the extra distance bits */
            }
        } /* literal or match pair ? */

        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
        Assert(s->pending < s->lit_bufsize + 2*lx, "pendingBuf overflow");

    } while (lx < s->last_lit);

    send_code(s, END_BLOCK, ltree);
    s->last_eob_len = ltree[END_BLOCK].Len;
}

/* ===========================================================================
 * Set the data type to ASCII or BINARY, using a crude approximation:
 * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
 * IN assertion: the fields freq of dyn_ltree are set and the total of all
 * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
 */
local void set_data_type(deflate_state *s)
{
    int n = 0;
    unsigned ascii_freq = 0;
    unsigned bin_freq = 0;
    while (n < 7)        bin_freq += s->dyn_ltree[n++].Freq;
    while (n < 128)    ascii_freq += s->dyn_ltree[n++].Freq;
    while (n < LITERALS) bin_freq += s->dyn_ltree[n++].Freq;
    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
}

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
local unsigned bi_reverse(unsigned code, int len)
{
    register unsigned res = 0;
    do {
        res |= code & 1;
        code >>= 1, res <<= 1;
    } while (--len > 0);
    return res >> 1;
}

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
local void bi_flush(deflate_state *s)
{
    if (s->bi_valid == 16) {
        put_short(s, s->bi_buf);
        s->bi_buf = 0;
        s->bi_valid = 0;
    } else if (s->bi_valid >= 8) {
        put_byte(s, (Byte)s->bi_buf);
        s->bi_buf >>= 8;
        s->bi_valid -= 8;
    }
}

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
local void bi_windup(deflate_state *s)
{
    if (s->bi_valid > 8) {
        put_short(s, s->bi_buf);
    } else if (s->bi_valid > 0) {
        put_byte(s, (Byte)s->bi_buf);
    }
    s->bi_buf = 0;
    s->bi_valid = 0;
#ifdef DEBUG
    s->bits_sent = (s->bits_sent+7) & ~7;
#endif
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
local void copy_block(deflate_state *s, charf *buf, unsigned len, int header)
{
    bi_windup(s);        /* align on byte boundary */
    s->last_eob_len = 8; /* enough lookahead for inflate */

    if (header) {
        put_short(s, (ush)len);   
        put_short(s, (ush)~len);
#ifdef DEBUG
        s->bits_sent += 2*16;
#endif
    }
#ifdef DEBUG
    s->bits_sent += (ulg)len<<3;
#endif
    while (len--) {
        put_byte(s, *buf++);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\inftrees.c ===
/* inftrees.c -- generate Huffman trees for efficient decoding
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"

#if !defined(BUILDFIXED) && !defined(STDC)
#  define BUILDFIXED   /* non ANSI compilers may not accept inffixed.h */
#endif

const char inflate_copyright[] =
   " inflate 1.1.4 Copyright 1995-2002 Mark Adler ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */
struct internal_state  {int dummy;}; /* for buggy compilers */

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits


local int huft_build OF((
    uIntf *,            /* code lengths in bits */
    uInt,               /* number of codes */
    uInt,               /* number of "simple" codes */
    const uIntf *,      /* list of base values for non-simple codes */
    const uIntf *,      /* list of extra bits for non-simple codes */
    inflate_huft * FAR*,/* result: starting table */
    uIntf *,            /* maximum lookup bits (returns actual) */
    inflate_huft *,     /* space for trees */
    uInt *,             /* hufts used in space */
    uIntf * ));         /* space for values */

/* Tables for deflate from PKZIP's appnote.txt. */
local const uInt cplens[31] = { /* Copy lengths for literal codes 257..285 */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
        /* see note #13 above about 258 */
local const uInt cplext[31] = { /* Extra bits for literal codes 257..285 */
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; /* 112==invalid */
local const uInt cpdist[30] = { /* Copy offsets for distance codes 0..29 */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577};
local const uInt cpdext[30] = { /* Extra bits for distance codes */
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
        12, 12, 13, 13};

/*
   Huffman code decoding is performed using a multi-level table lookup.
   The fastest way to decode is to simply build a lookup table whose
   size is determined by the longest code.  However, the time it takes
   to build this table can also be a factor if the data being decoded
   is not very long.  The most common codes are necessarily the
   shortest codes, so those codes dominate the decoding time, and hence
   the speed.  The idea is you can have a shorter table that decodes the
   shorter, more probable codes, and then point to subsidiary tables for
   the longer codes.  The time it costs to decode the longer codes is
   then traded against the time it takes to make longer tables.

   This results of this trade are in the variables lbits and dbits
   below.  lbits is the number of bits the first level table for literal/
   length codes can decode in one step, and dbits is the same thing for
   the distance codes.  Subsequent tables are also less than or equal to
   those sizes.  These values may be adjusted either when all of the
   codes are shorter than that, in which case the longest code length in
   bits is used, or when the shortest code is *longer* than the requested
   table size, in which case the length of the shortest code in bits is
   used.

   There are two different values for the two tables, since they code a
   different number of possibilities each.  The literal/length table
   codes 286 possible values, or in a flat code, a little over eight
   bits.  The distance table codes 30 possible values, or a little less
   than five bits, flat.  The optimum values for speed end up being
   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
   The optimum values may differ though from machine to machine, and
   possibly even between compilers.  Your mileage may vary.
 */


/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
#define BMAX 15         /* maximum bit length of any code */

local int huft_build(
uIntf *b,               /* code lengths in bits (all assumed <= BMAX) */
uInt n,                 /* number of codes (assumed <= 288) */
uInt s,                 /* number of simple-valued codes (0..s-1) */
const uIntf *d,         /* list of base values for non-simple codes */
const uIntf *e,         /* list of extra bits for non-simple codes */
inflate_huft * FAR *t,  /* result: starting table */
uIntf *m,               /* maximum lookup bits, returns actual */
inflate_huft *hp,       /* space for trees */
uInt *hn,               /* hufts used in space */
uIntf *v)               /* working area: values in order of bit length */
/* Given a list of code lengths and a maximum table size, make a set of
   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
   if the given code set is incomplete (the tables are still built in this
   case), or Z_DATA_ERROR if the input is invalid. */
{

  uInt a;                       /* counter for codes of length k */
  uInt c[BMAX+1];               /* bit length count table */
  uInt f;                       /* i repeats in table every f entries */
  int g;                        /* maximum code length */
  int h;                        /* table level */
  register uInt i;              /* counter, current code */
  register uInt j;              /* counter */
  register int k;               /* number of bits in current code */
  int l;                        /* bits per table (returned in m) */
  uInt mask;                    /* (1 << w) - 1, to avoid cc -O bug on HP */
  register uIntf *p;            /* pointer into c[], b[], or v[] */
  inflate_huft *q;              /* points to current table */
  struct inflate_huft_s r;      /* table entry for structure assignment */
  inflate_huft *u[BMAX];        /* table stack */
  register int w;               /* bits before this table == (l * h) */
  uInt x[BMAX+1];               /* bit offsets, then code stack */
  uIntf *xp;                    /* pointer into x */
  int y;                        /* number of dummy codes added */
  uInt z;                       /* number of entries in current table */


  /* Generate counts for each bit length */
  p = c;
#define C0 *p++ = 0;
#define C2 C0 C0 C0 C0
#define C4 C2 C2 C2 C2
  C4                            /* clear c[]--assume BMAX+1 is 16 */
  p = b;  i = n;
  do {
    c[*p++]++;                  /* assume all entries <= BMAX */
  } while (--i);
  if (c[0] == n)                /* null input--all zero length codes */
  {
    *t = (inflate_huft *)Z_NULL;
    *m = 0;
    return Z_OK;
  }


  /* Find minimum and maximum length, bound *m by those */
  l = *m;
  for (j = 1; j <= BMAX; j++)
    if (c[j])
      break;
  k = j;                        /* minimum code length */
  if ((uInt)l < j)
    l = j;
  for (i = BMAX; i; i--)
    if (c[i])
      break;
  g = i;                        /* maximum code length */
  if ((uInt)l > i)
    l = i;
  *m = l;


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
    if ((y -= c[j]) < 0)
      return Z_DATA_ERROR;
  if ((y -= c[i]) < 0)
    return Z_DATA_ERROR;
  c[i] += y;


  /* Generate starting offsets into the value table for each length */
  x[1] = j = 0;
  p = c + 1;  xp = x + 2;
  while (--i) {                 /* note that i == g from above */
    *xp++ = (j += *p++);
  }


  /* Make a table of values in order of bit lengths */
  p = b;  i = 0;
  do {
    if ((j = *p++) != 0)
      v[x[j]++] = i;
  } while (++i < n);
  n = x[g];                     /* set n to length of v */


  /* Generate the Huffman codes and for each, make the table entries */
  x[0] = i = 0;                 /* first Huffman code is zero */
  p = v;                        /* grab values in bit order */
  h = -1;                       /* no tables yet--level -1 */
  w = -l;                       /* bits decoded == (l * h) */
  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
  q = (inflate_huft *)Z_NULL;   /* ditto */
  z = 0;                        /* ditto */

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
  {
    a = c[k];
    while (a--)
    {
      /* here i is the Huffman code of length k bits for value *p */
      /* make tables up to required level */
      while (k > w + l)
      {
        h++;
        w += l;                 /* previous table always l bits */

        /* compute minimum size table less than or equal to l bits */
        z = g - w;
        z = z > (uInt)l ? l : z;        /* table size upper limit */
        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
        {                       /* too few codes for k-w bit table */
          f -= a + 1;           /* deduct codes from patterns left */
          xp = c + k;
          if (j < z)
            while (++j < z)     /* try smaller tables up to z bits */
            {
              if ((f <<= 1) <= *++xp)
                break;          /* enough codes to use up j bits */
              f -= *xp;         /* else deduct codes from patterns */
            }
        }
        z = 1 << j;             /* table entries for j-bit table */

        /* allocate new table */
        if (*hn + z > MANY)     /* (note: doesn't matter for fixed) */
          return Z_DATA_ERROR;  /* overflow of MANY */
        u[h] = q = hp + *hn;
        *hn += z;

        /* connect to last table, if there is one */
        if (h)
        {
          x[h] = i;             /* save pattern for backing up */
          r.bits = (Byte)l;     /* bits to dump before this table */
          r.exop = (Byte)j;     /* bits in this table */
          j = i >> (w - l);
          r.base = (uInt)(q - u[h-1] - j);   /* offset to this table */
          u[h-1][j] = r;        /* connect to last table */
        }
        else
          *t = q;               /* first table is returned result */
      }

      /* set up table entry in r */
      r.bits = (Byte)(k - w);
      if (p >= v + n)
        r.exop = 128 + 64;      /* out of values--invalid code */
      else if (*p < s)
      {
        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
        r.base = *p++;          /* simple code is just the value */
      }
      else
      {
        r.exop = (Byte)(e[*p - s] + 16 + 64);/* non-simple--look up in lists */
        r.base = d[*p++ - s];
      }

      /* fill code-like entries with r */
      f = 1 << (k - w);
      for (j = i >> w; j < z; j += f)
        q[j] = r;

      /* backwards increment the k-bit code i */
      for (j = 1 << (k - 1); i & j; j >>= 1)
        i ^= j;
      i ^= j;

      /* backup over finished tables */
      mask = (1 << w) - 1;      /* needed on HP, cc -O bug */
      while ((i & mask) != x[h])
      {
        h--;                    /* don't need to update q */
        w -= l;
        mask = (1 << w) - 1;
      }
    }
  }


  /* Return Z_BUF_ERROR if we were given an incomplete table */
  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
}


int inflate_trees_bits(
uIntf *c,               /* 19 code lengths */
uIntf *bb,              /* bits tree desired/actual depth */
inflate_huft * FAR *tb, /* bits tree result */
inflate_huft *hp,       /* space for trees */
z_streamp z)
            /* for messages */
{
  int r;
  uInt hn = 0;          /* hufts used in space */
  uIntf *v;             /* work area for huft_build */

  if ((v = (uIntf*)ZALLOC(z, 19, sizeof(uInt))) == Z_NULL)
    return Z_MEM_ERROR;
  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL,
                 tb, bb, hp, &hn, v);
  if (r == Z_DATA_ERROR)
    z->msg = (char*)"oversubscribed dynamic bit lengths tree";
  else if (r == Z_BUF_ERROR || *bb == 0)
  {
    z->msg = (char*)"incomplete dynamic bit lengths tree";
    r = Z_DATA_ERROR;
  }
  ZFREE(z, v);
  return r;
}


int inflate_trees_dynamic(
uInt nl,                /* number of literal/length codes */
uInt nd,                /* number of distance codes */
uIntf *c,               /* that many (total) code lengths */
uIntf *bl,              /* literal desired/actual bit depth */
uIntf *bd,              /* distance desired/actual bit depth */
inflate_huft * FAR *tl, /* literal/length tree result */
inflate_huft * FAR *td, /* distance tree result */
inflate_huft *hp,       /* space for trees */
z_streamp z)            /* for messages */
{
  int r;
  uInt hn = 0;          /* hufts used in space */
  uIntf *v;             /* work area for huft_build */

  /* allocate work area */
  if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
    return Z_MEM_ERROR;

  /* build literal/length tree */
  r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &hn, v);
  if (r != Z_OK || *bl == 0)
  {
    if (r == Z_DATA_ERROR)
      z->msg = (char*)"oversubscribed literal/length tree";
    else if (r != Z_MEM_ERROR)
    {
      z->msg = (char*)"incomplete literal/length tree";
      r = Z_DATA_ERROR;
    }
    ZFREE(z, v);
    return r;
  }

  /* build distance tree */
  r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &hn, v);
  if (r != Z_OK || (*bd == 0 && nl > 257))
  {
    if (r == Z_DATA_ERROR)
      z->msg = (char*)"oversubscribed distance tree";
    else if (r == Z_BUF_ERROR) {
#ifdef PKZIP_BUG_WORKAROUND
      r = Z_OK;
    }
#else
      z->msg = (char*)"incomplete distance tree";
      r = Z_DATA_ERROR;
    }
    else if (r != Z_MEM_ERROR)
    {
      z->msg = (char*)"empty distance tree with lengths";
      r = Z_DATA_ERROR;
    }
    ZFREE(z, v);
    return r;
#endif
  }

  /* done */
  ZFREE(z, v);
  return Z_OK;
}


/* build fixed tables only once--keep them here */
#ifdef BUILDFIXED
local int fixed_built = 0;
#define FIXEDH 544      /* number of hufts used by fixed tables */
local inflate_huft fixed_mem[FIXEDH];
local uInt fixed_bl;
local uInt fixed_bd;
local inflate_huft *fixed_tl;
local inflate_huft *fixed_td;
#else
#include "inffixed.h"
#endif


int inflate_trees_fixed(
uIntf *bl,               /* literal desired/actual bit depth */
uIntf *bd,               /* distance desired/actual bit depth */
inflate_huft * FAR *tl,  /* literal/length tree result */
inflate_huft * FAR *td,  /* distance tree result */
z_streamp z)             /* for memory allocation */
{
#ifdef BUILDFIXED
  /* build fixed tables if not already */
  if (!fixed_built)
  {
    int k;              /* temporary variable */
    uInt f = 0;         /* number of hufts used in fixed_mem */
    uIntf *c;           /* length list for huft_build */
    uIntf *v;           /* work area for huft_build */

    /* allocate memory */
    if ((c = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
      return Z_MEM_ERROR;
    if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
    {
      ZFREE(z, c);
      return Z_MEM_ERROR;
    }

    /* literal table */
    for (k = 0; k < 144; k++)
      c[k] = 8;
    for (; k < 256; k++)
      c[k] = 9;
    for (; k < 280; k++)
      c[k] = 7;
    for (; k < 288; k++)
      c[k] = 8;
    fixed_bl = 9;
    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl,
               fixed_mem, &f, v);

    /* distance table */
    for (k = 0; k < 30; k++)
      c[k] = 5;
    fixed_bd = 5;
    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd,
               fixed_mem, &f, v);

    /* done */
    ZFREE(z, v);
    ZFREE(z, c);
    fixed_built = 1;
  }
#endif
  *bl = fixed_bl;
  *bd = fixed_bd;
  *tl = fixed_tl;
  *td = fixed_td;
  return Z_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\trees.h ===
/* header created automatically with -DGEN_TREES_H */

local const ct_data static_ltree[L_CODES+2] = {
{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
};

local const ct_data static_dtree[D_CODES] = {
{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
};

const uch _dist_code[DIST_CODE_LEN] = {
 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
};

const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {
 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
};

local const int base_length[LENGTH_CODES] = {
0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
64, 80, 96, 112, 128, 160, 192, 224, 0
};

local const int base_dist[D_CODES] = {
    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\infutil.c ===
/* inflate_util.c -- data and routines common to blocks and codes
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "infblock.h"
#include "inftrees.h"
#include "infcodes.h"
#include "infutil.h"

struct inflate_codes_state {int dummy;}; /* for buggy compilers */

/* And'ing with mask[n] masks the lower n bits */
uInt inflate_mask[17] = {
    0x0000,
    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
};


/* copy as much as possible from the sliding window to the output area */
int inflate_flush(inflate_blocks_statef *s, z_streamp z, int r)
{
  uInt n;
  Bytef *p;
  Bytef *q;

  /* local copies of source and destination pointers */
  p = z->next_out;
  q = s->read;

  /* compute number of bytes to copy as far as end of window */
  n = (uInt)((q <= s->write ? s->write : s->end) - q);
  if (n > z->avail_out) n = z->avail_out;
  if (n && r == Z_BUF_ERROR) r = Z_OK;

  /* update counters */
  z->avail_out -= n;
  z->total_out += n;

  /* update check information */
  if (s->checkfn != Z_NULL)
    z->adler = s->check = (*s->checkfn)(s->check, q, n);

  /* copy as far as end of window */
  zmemcpy(p, q, n);
  p += n;
  q += n;

  /* see if more to copy at beginning of window */
  if (q == s->end)
  {
    /* wrap pointers */
    q = s->window;
    if (s->write == s->end)
      s->write = s->window;

    /* compute bytes to copy */
    n = (uInt)(s->write - q);
    if (n > z->avail_out) n = z->avail_out;
    if (n && r == Z_BUF_ERROR) r = Z_OK;

    /* update counters */
    z->avail_out -= n;
    z->total_out += n;

    /* update check information */
    if (s->checkfn != Z_NULL)
      z->adler = s->check = (*s->checkfn)(s->check, q, n);

    /* copy */
    zmemcpy(p, q, n);
    p += n;
    q += n;
  }

  /* update pointers */
  z->next_out = p;
  s->read = q;

  /* done */
  return r;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\uncompr.c ===
/* uncompr.c -- decompress a memory buffer
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

/* ===========================================================================
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/
int ZEXPORT uncompress (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen)
{
    z_stream stream;
    int err;

    stream.next_in = (Bytef*)source;
    stream.avail_in = (uInt)sourceLen;
    /* Check for source > 64K on 16-bit machine: */
    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;

    stream.next_out = dest;
    stream.avail_out = (uInt)*destLen;
    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;

    err = inflateInit(&stream);
    if (err != Z_OK) return err;

    err = inflate(&stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        inflateEnd(&stream);
        return err == Z_OK ? Z_BUF_ERROR : err;
    }
    *destLen = stream.total_out;

    err = inflateEnd(&stream);
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\office.h ===
#ifndef OFFICE_CONFIGURATION
#define OFFICE_CONFIGURATION 1

#include <msowarn.h>

/* WARNING: this just contains hack configuration information to make the
	Zlib source work under Office. */
#define STDC 1 // Switch on arg lists
#ifndef _WINDOWS
	#define ZEXPORTVA __cdecl
#endif
//#include <stdlib.h>

/* The C++ compiler defines _DEBUG and _PROFILE, handle that here but warn
	about it (not expected in an Office build.) */
#if DBG && !defined(DEBUG)
	#define DEBUG 1
#endif
#if defined(_DEBUG) && !defined(DEBUG)
	#define DEBUG 1
	#pragma message("    WARNING: DEBUG switched on")
#endif
#if defined(_PROFILE) && !defined(HYBRID)
	#define HYBRID 1
	#pragma message("    WARNING: HYBRID switched on")
#endif

#if DEBUG
	#define ZEXPORT __cdecl
#else
	#define ZEXPORT __fastcall
#endif

/* Use intrinsic versions of some functions are required because the Office
	environment doesn't include them. */
#include <string.h>
#pragma intrinsic(strcmp, strcpy, strcat, strlen, memcpy, memset, memcmp)
#ifdef _M_IX86
#include <stdlib.h>
#pragma intrinsic(abs)
#endif

/* NOTE: someone added this to allow MSOCONSTFIXUP on the Mac, thereby
	they permitted removal of ctype.h and, at the same time, included the
	whole of the windows world (which makes compilation slow to a crawl
	and brings in all sorts of unknown goop.)  Do not do this - check before
	you add includes.  Someone has to maintain this stuff. */
#if 0
	#include <msostd.h>
#endif

#if ZINTERNAL /* Specific for the build of zlib. */

/* We want "local" functions to be exported when profiling.  We want all
	internal data to be static const. */
#if HYBRID
	#define local
#endif
//1/#define rodata static const

/* Heavyweight Zlib debugging if required is obtained by cranking up the
	value of the verbose setting. */
#ifdef DEBUG
extern int z_verbose;
#endif

/* zlib/example.c defines "main", in the ship version this must be __cdecl,
	but the Office build scripts force stdcall, similarly for minigzip.c and
	pngtest.c */
#if defined(FILE_minigzip)
	#define main __cdecl main
#endif

/* gzio.c uses fdopen, we don't have a POSIX library in otools, so I define
	fdopen to be _fdopen, similarly for the other POSIX functions used in
	minigzip.  fileno causes particular problems because stdio.h defines a
	function fileno after the macro _fileno, so we must force stdio.h in
	first. */
#if defined(FILE_gzio) || defined(DEBUG)
	//1/#define _NTSDK
	//1/#include <stdio.h>

	//1/#define fdopen _fdopen
	//1/#define setmode _setmode
	//1/#undef fileno
	//1/#define fileno(s) _fileno(s)
#endif

/* Tracing used in several files refers to stderr.  We hack this out
	here, but it is used in example.c and minigzip.c */
#if DEBUG
#if !defined(FILE_example) && !defined(FILE_minigzip) && !defined(FILE_gzio)
	#include <stdio.h> // Preempt inclusion in zutil.h
	#undef stderr
	#define stderr (0)
	#define fprintf z_trace
	void z_trace(int idummy, char *sz, ...);
	#undef putc
	#define putc(c,s) (z_trace((s), "%c", (c)))
#endif
#endif

/* Likewise in trees.c, which also needs isgraph in debug and attempts
	to get it from ctype.h */
	#if DEBUG
		/* isgraph - a debug only trace requirement, this code is somewhat
			broken, but that doesn't matter - see the usage in trees.c */
		#define _INC_CTYPE // Prevents include of ctype.h
		#define isgraph(c) (((c) & 0x7f) > 0x20)
	#endif

/* Optimization.  For PNG all the time is in zlib in the longest_match
	API, so optimizing this is most important, the major consumers are
	deflate_slow itself, _tr_tally (most number of calls) and inflate_fast
	(for decompression). */
#if !DEBUG
	/* The following offers no clear advantage (times are too variable to
		see any clear gain) so is not done. */
	#if 1
		/* This is the time specific stuff. */
		#pragma optimize("s", off)
		#pragma optimize("gitwab2", on)
		#pragma message("    optimize (zlib) should only appear in ZLIB files")
	#else
		/* This is space specific optimization. */
		#pragma optimize("t", off)
		#pragma optimize("gisawb2", on)
	#endif
#endif

#endif /* End of ZINTERNAL specific stuff. */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\zconf.h ===
/* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#ifndef _ZCONF_H
#define _ZCONF_H

#include "office.h"

/*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 */
#ifdef Z_PREFIX
#  define deflateInit_	z_deflateInit_
#  define deflate	z_deflate
#  define deflateEnd	z_deflateEnd
#  define inflateInit_ 	z_inflateInit_
#  define inflate	z_inflate
#  define inflateEnd	z_inflateEnd
#  define deflateInit2_	z_deflateInit2_
#  define deflateSetDictionary z_deflateSetDictionary
#  define deflateCopy	z_deflateCopy
#  define deflateReset	z_deflateReset
#  define deflateParams	z_deflateParams
#  define inflateInit2_	z_inflateInit2_
#  define inflateSetDictionary z_inflateSetDictionary
#  define inflateSync	z_inflateSync
#  define inflateSyncPoint z_inflateSyncPoint
#  define inflateReset	z_inflateReset
#  define compress	z_compress
#  define compress2	z_compress2
#  define uncompress	z_uncompress
#  define adler32	z_adler32
#  define crc32		z_crc32
#  define get_crc_table z_get_crc_table

#  define Byte		z_Byte
#  define uInt		z_uInt
#  define uLong		z_uLong
#  define Bytef	        z_Bytef
#  define charf		z_charf
#  define intf		z_intf
#  define uIntf		z_uIntf
#  define uLongf	z_uLongf
#  define voidpf	z_voidpf
#  define voidp		z_voidp
#endif

#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
#  define WIN32
#endif
#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
#  ifndef __32BIT__
#    define __32BIT__
#  endif
#endif
#if defined(__MSDOS__) && !defined(MSDOS)
#  define MSDOS
#endif

/*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 */
#if defined(MSDOS) && !defined(__32BIT__)
#  define MAXSEG_64K
#endif
#ifdef MSDOS
#  define UNALIGNED_OK
#endif

#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
#  define STDC
#endif
#if defined(__STDC__) || defined(__cplusplus) || defined(__OS2__)
#  ifndef STDC
#    define STDC
#  endif
#endif

#ifndef STDC
#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
#    define const
#  endif
#endif

/* Some Mac compilers merge all .h files incorrectly: */
#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
#  define NO_DUMMY_DECL
#endif

/* Old Borland C incorrectly complains about missing returns: */
#if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
#  define NEED_DUMMY_RETURN
#endif


/* Maximum value for memLevel in deflateInit2 */
#ifndef MAX_MEM_LEVEL
#  ifdef MAXSEG_64K
#    define MAX_MEM_LEVEL 8
#  else
#    define MAX_MEM_LEVEL 9
#  endif
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/* The memory requirements for deflate are (in bytes):
            (1 << (windowBits+2)) +  (1 << (memLevel+9))
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus a few kilobytes
 for small objects.
*/

                        /* Type declarations */

#ifndef OF /* function prototypes */
#  ifdef STDC
#    define OF(args)  args
#  else
#    define OF(args)  ()
#  endif
#endif

/* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 */
#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
   /* MSC small or medium model */
#  define SMALL_MEDIUM
#  ifdef _MSC_VER
#    define FAR _far
#  else
#    define FAR far
#  endif
#endif
#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
#  ifndef __32BIT__
#    define SMALL_MEDIUM
#    define FAR _far
#  endif
#endif

/* Compile with -DZLIB_DLL for Windows DLL support */
#if defined(ZLIB_DLL)
#  if defined(_WINDOWS) || defined(WINDOWS)
#    ifdef FAR
#      undef FAR
#    endif
#    include <windows.h>
#    define ZEXPORT  WINAPI
#    ifdef WIN32
#      define ZEXPORTVA  WINAPIV
#    else
#      define ZEXPORTVA  FAR _cdecl _export
#    endif
#  endif
#  if defined (__BORLANDC__)
#    if (__BORLANDC__ >= 0x0500) && defined (WIN32)
#      include <windows.h>
#      define ZEXPORT __declspec(dllexport) WINAPI
#      define ZEXPORTRVA __declspec(dllexport) WINAPIV
#    else
#      if defined (_Windows) && defined (__DLL__)
#        define ZEXPORT _export
#        define ZEXPORTVA _export
#      endif
#    endif
#  endif
#endif

#if defined (__BEOS__)
#  if defined (ZLIB_DLL)
#    define ZEXTERN extern __declspec(dllexport)
#  else
#    define ZEXTERN extern __declspec(dllimport)
#  endif
#endif

#ifndef ZEXPORT
#  define ZEXPORT
#endif
#ifndef ZEXPORTVA
#  define ZEXPORTVA
#endif
#ifndef ZEXTERN
#  define ZEXTERN extern
#endif

#ifndef FAR
#   define FAR
#endif

#if !defined(MACOS) && !defined(TARGET_OS_MAC)
typedef unsigned char  Byte;  /* 8 bits */
#endif
typedef unsigned int   uInt;  /* 16 bits or more */
typedef unsigned long  uLong; /* 32 bits or more */

#ifdef SMALL_MEDIUM
   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
#  define Bytef Byte FAR
#else
   typedef Byte  FAR Bytef;
#endif
typedef char  FAR charf;
typedef int   FAR intf;
typedef uInt  FAR uIntf;
typedef uLong FAR uLongf;

#ifdef STDC
   typedef void FAR *voidpf;
   typedef void     *voidp;
#else
   typedef Byte FAR *voidpf;
   typedef Byte     *voidp;
#endif

#ifdef HAVE_UNISTD_H
#  include <sys/types.h> /* for off_t */
#  include <unistd.h>    /* for SEEK_* and off_t */
#  define z_off_t  off_t
#endif
#ifndef SEEK_SET
#  define SEEK_SET        0       /* Seek from beginning of file.  */
#  define SEEK_CUR        1       /* Seek from current position.  */
#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
#endif
#ifndef z_off_t
#  define  z_off_t long
#endif

/* MVS linker does not support external names larger than 8 bytes */
#if defined(__MVS__)
#   pragma map(deflateInit_,"DEIN")
#   pragma map(deflateInit2_,"DEIN2")
#   pragma map(deflateEnd,"DEEND")
#   pragma map(inflateInit_,"ININ")
#   pragma map(inflateInit2_,"ININ2")
#   pragma map(inflateEnd,"INEND")
#   pragma map(inflateSync,"INSY")
#   pragma map(inflateSetDictionary,"INSEDI")
#   pragma map(inflate_blocks,"INBL")
#   pragma map(inflate_blocks_new,"INBLNE")
#   pragma map(inflate_blocks_free,"INBLFR")
#   pragma map(inflate_blocks_reset,"INBLRE")
#   pragma map(inflate_codes_free,"INCOFR")
#   pragma map(inflate_codes,"INCO")
#   pragma map(inflate_fast,"INFA")
#   pragma map(inflate_flush,"INFLU")
#   pragma map(inflate_mask,"INMA")
#   pragma map(inflate_set_dictionary,"INSEDI2")
#   pragma map(inflate_copyright,"INCOPY")
#   pragma map(inflate_trees_bits,"INTRBI")
#   pragma map(inflate_trees_dynamic,"INTRDY")
#   pragma map(inflate_trees_fixed,"INTRFI")
#   pragma map(inflate_trees_free,"INTRFR")
#endif

#endif /* _ZCONF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\zutil.c ===
/*****************************************************************************
	gelzutil.cpp

	Owner: JohnBo
	Copyright (c) 1997 Microsoft Corporation

	Zlib basic utilities
*****************************************************************************/
#include "zutil.h"

/*****************************************************************************
	blip/zlib/zutil.c

	The only required interfaces are z_errmsg (FCheckZlib debug and deflate.c
	ONLY), zcalloc and zcfree.  The error messages should probably be removed,
	only Z_MEM_ERROR is used (apparently).
******************************************************************* JohnBo **/

//#ifdef DEBUG // Temporarily enabled in ship too.
const char * z_errmsg[10] = {
"need dictionary",     /* Z_NEED_DICT       2  */
"stream end",          /* Z_STREAM_END      1  */
"",                    /* Z_OK              0  */
"file error",          /* Z_ERRNO         (-1) */
"stream error",        /* Z_STREAM_ERROR  (-2) */
"data error",          /* Z_DATA_ERROR    (-3) */
"insufficient memory", /* Z_MEM_ERROR     (-4) */
"buffer error",        /* Z_BUF_ERROR     (-5) */
"incompatible version",/* Z_VERSION_ERROR (-6) */
""};
//#endif

void *zcalloc(void *pvOpaque, unsigned int c, unsigned int cb)
	{
	void *pv = GpMalloc(c * cb);
	if (pv != NULL)
		memset(pv, 0, c * cb);
	return pv;
	}


void zcfree(void *pvOpaque, void *pv)
	{
	GpFree(pv);
	}

#ifdef DEBUG
#include <stdarg.h>

void z_trace(int idummy, char *sz, ...)
	{
#if 0
	static bool vfztrace = 0; // Enable lots of tracing.
	if (vfztrace)
		{
		va_list va;
		va_start(va, sz);
      GelHost::TraceVa(sz, va);
		va_end(va);
		}
#endif
	}


/* The following is only used for blip debug - not even required in normal
	debug. */
void z_error(char *sz)
	{
#if 0
	GELLog(gelinfo, "ZLIB", 0, 1, 0 /*dwTag*/, "%s", sz);
#endif
	}

/* Debugging verbosity control. */
int z_verbose = 0;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\wmf\wmfcodec.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   emfcodec.cpp
*
* Abstract:
*
*   Shared methods for the WMF codec
*
* Revision History:
*
*   6/21/1999 OriG
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "wmfcodec.hpp"


/**************************************************************************\
*
* Function Description:
*
*     Constructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpWMFCodec::GpWMFCodec(
    void
    )
{
    comRefCount   = 1;
    pIstream      = NULL;
    decodeSink    = NULL;
}

/**************************************************************************\
*
* Function Description:
*
*     Destructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpWMFCodec::~GpWMFCodec(
    void
    )
{
    // The destructor should never be called before Terminate is called, but
    // if it does we should release our reference on the stream anyway to avoid
    // a memory leak.

    if(pIstream)
    {
        WARNING(("GpWMFCodec::~GpWMFCodec -- need to call TerminateDecoder first"));
        pIstream->Release();
        pIstream = NULL;
    }
}

/**************************************************************************\
*
* Function Description:
*
*     QueryInterface
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageDecoder)
    {
        *ppv = static_cast<IImageDecoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageDecoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     AddRef
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpWMFCodec::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

/**************************************************************************\
*
* Function Description:
*
*     Release
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpWMFCodec::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\wmf\wmfcodec.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   wmfcodec.hpp
*
* Abstract:
*
*   Header file for the WMF encoder/decoder
*
* Revision History:
*
*   6/21/1999 OriG
*       Created it.
*
\**************************************************************************/

// The metafile file header

#pragma pack(1)

typedef struct tagOLDRECT
{
    short   left;
    short   top;
    short   right;
    short   bottom;
} OLDRECT;

typedef struct {
        DWORD   key;
        WORD    hmf;
        OLDRECT bbox;
        WORD    inch;
        DWORD   reserved;
        WORD    checksum;
}PLACEABLEWMFHEADER;

#pragma pack()

class GpWMFCodec : public IImageDecoder
{
private:

    // =====================================================
    // Decoder privates
    // =====================================================

    IStream *pIstream;
    IImageSink* decodeSink;
    ImageInfo imageInfo;
    PLACEABLEWMFHEADER pwmfh;
    METAHEADER mh;
    BOOL bReadHeader;
    BOOL bReinitializeWMF;
    
protected:
    LONG comRefCount;       // COM object reference count    

public:

    // Constructor and Destructor
    
    GpWMFCodec::GpWMFCodec(void);
    GpWMFCodec::~GpWMFCodec(void);

    // IImageDecoder methods
    
    STDMETHOD(InitDecoder)(IN IStream* stream, IN DecoderInitFlag flags);
    STDMETHOD(TerminateDecoder) ();
    STDMETHOD(BeginDecode)(IN IImageSink* imageSink,
                           IN OPTIONAL IPropertySetStorage* newPropSet);
    STDMETHOD(Decode)();
    STDMETHOD(EndDecode)(IN HRESULT statusCode);

    STDMETHOD(GetFrameDimensionsCount)(OUT UINT* count);
    STDMETHOD(GetFrameDimensionsList)(OUT GUID* dimensionIDs,IN OUT UINT count);
    STDMETHOD(GetFrameCount)(IN const GUID* dimensionID, OUT UINT* count);
    STDMETHOD(SelectActiveFrame)(IN const GUID* dimensionID, 
                                 IN UINT frameIndex);
    STDMETHOD(GetImageInfo)(OUT ImageInfo* imageInfo);
    STDMETHOD(GetThumbnail)(IN OPTIONAL UINT thumbWidth,
                            IN OPTIONAL UINT thumbHeight,
                            OUT IImage** thumbImage);
    STDMETHOD(QueryDecoderParam)(IN GUID Guid);
    STDMETHOD(SetDecoderParam)(IN GUID Guid, IN UINT Length, IN PVOID Value);
    STDMETHOD(GetPropertyCount)(OUT UINT* numOfProperty);
    STDMETHOD(GetPropertyIdList)(IN UINT numOfProperty,IN OUT PROPID* list);
    STDMETHOD(GetPropertyItemSize)(IN PROPID propId, OUT UINT* size);    
    STDMETHOD(GetPropertyItem)(IN PROPID propId, IN UINT propSize,
                               IN OUT PropertyItem* buffer);
    STDMETHOD(GetPropertySize)(OUT UINT* totalBufferSize,
                               OUT UINT* numProperties);
    STDMETHOD(GetAllPropertyItems)(IN UINT totalBufferSize,
                                   IN UINT numProperties,
                                   IN OUT PropertyItem* allItems);
    STDMETHOD(RemovePropertyItem)(IN PROPID propId);
    STDMETHOD(SetPropertyItem)(IN PropertyItem item);
    STDMETHOD(GetRawInfo)(IN OUT void** info)
    {
        return E_NOTIMPL;
    }
    STDMETHOD(ReadWMFHeader());
    
    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\wmf\wmfdecoder.cpp ===
/**************************************************************************\
/**************************************************************************\
/**************************************************************************\
/**************************************************************************\
/**************************************************************************\
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   wmfdecoder.cpp
*
* Abstract:
*
*   Implementation of the WMF decoder
*
* Revision History:
*
*   6/21/1999 OriG
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "wmfcodec.hpp"

/**************************************************************************\
*
* Function Description:
*
*     Initialize the image decoder
*
* Arguments:
*
*     stream -- The stream containing the bitmap data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::InitDecoder(
    IN IStream* stream,
    IN DecoderInitFlag flags
    )
{
    HRESULT hresult;

    // Make sure we haven't been initialized already

    if (pIstream)
    {
        return E_FAIL;
    }

    // Keep a reference on the input stream

    stream->AddRef();
    pIstream = stream;
    bReadHeader = FALSE;
    bReinitializeWMF = FALSE;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image decoder
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::TerminateDecoder()
{
    // Release the input stream

    if(pIstream)
    {
        pIstream->Release();
        pIstream = NULL;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Reads the WMF header
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::ReadWMFHeader()
{
    HRESULT hresult;

    if (!pIstream)
    {
        return E_FAIL;
    }

    if (!bReadHeader)
    {
        ULONG cbRead;

        // Read the PLACEABLEWMFHEADER

        hresult = pIstream->Read((void *) &pwmfh, sizeof(pwmfh), &cbRead);
        if (FAILED(hresult))
        {
            return hresult;
        }
        if (cbRead != sizeof(pwmfh))
        {
            return E_FAIL;
        }

        // Read the METAHEADER

        hresult = pIstream->Read((void *) &mh, sizeof(mh), &cbRead);
        if (FAILED(hresult))
        {
            return hresult;
        }
        if (cbRead != sizeof(mh))
        {
            return E_FAIL;
        }

        bReadHeader = TRUE;

        imageInfo.RawDataFormat = IMGFMT_WMF;
        imageInfo.PixelFormat = PIXFMT_32BPP_RGB;
        imageInfo.Width  = MulDiv( pwmfh.bbox.right - pwmfh.bbox.left,
                                   96, pwmfh.inch );
        imageInfo.Height = MulDiv( pwmfh.bbox.bottom - pwmfh.bbox.top,
                                   96, pwmfh.inch );
        imageInfo.TileWidth  = imageInfo.Width;
        imageInfo.TileHeight = 1; // internal GDI format is bottom-up...

        imageInfo.Xdpi = (double) pwmfh.inch;
        imageInfo.Ydpi = (double) pwmfh.inch;
        imageInfo.Flags = SINKFLAG_TOPDOWN
                        | SINKFLAG_FULLWIDTH
                        | SINKFLAG_SCALABLE
                        | IMGFLAG_COLORSPACE_RGB;
    }

    return S_OK;
}

STDMETHODIMP
GpWMFCodec::QueryDecoderParam(
    IN GUID     Guid
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
GpWMFCodec::SetDecoderParam(
    IN GUID     Guid,
    IN UINT     Length,
    IN PVOID    Value
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP 
GpWMFCodec::GetPropertyCount(
    OUT UINT*   numOfProperty
    )
{
    return E_NOTIMPL;
}// GetPropertyCount()

STDMETHODIMP 
GpWMFCodec::GetPropertyIdList(
    IN UINT numOfProperty,
  	IN OUT PROPID* list
    )
{
    return E_NOTIMPL;
} // GetPropertyIdList()

HRESULT
GpWMFCodec::GetPropertyItemSize(
    IN PROPID propId,
    OUT UINT* size
    )
{
    return E_NOTIMPL;
}// GetPropertyItemSize()

HRESULT
GpWMFCodec::GetPropertyItem(
    IN PROPID               propId,
    IN UINT                 propSize,
    IN OUT PropertyItem*    buffer
    )
{
    return E_NOTIMPL;
}// GetPropertyItem()

HRESULT
GpWMFCodec::GetPropertySize(
    OUT UINT* totalBufferSize,
    OUT UINT* numProperties
    )
{
    return E_NOTIMPL;
}// GetPropertySize()

HRESULT
GpWMFCodec::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    IN OUT PropertyItem* allItems
    )
{
    return E_NOTIMPL;
}// GetAllPropertyItems()

HRESULT
GpWMFCodec::RemovePropertyItem(
    IN PROPID   propId
    )
{
    return E_NOTIMPL;
}// RemovePropertyItem()

HRESULT
GpWMFCodec::SetPropertyItem(
    IN PropertyItem item
    )
{
    return E_NOTIMPL;
}// SetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*     Initiates the decode of the current frame
*
* Arguments:
*
*   decodeSink --  The sink that will support the decode operation
*   newPropSet - New image property sets, if any
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::BeginDecode(
    IN IImageSink* imageSink,
    IN OPTIONAL IPropertySetStorage* newPropSet
    )
{
    if (decodeSink)
    {
        WARNING(("BeginDecode called again before call to EngDecode"));
        return E_FAIL;
    }

    imageSink->AddRef();
    decodeSink = imageSink;

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Ends the decode of the current frame
*
* Arguments:
*
*     statusCode -- status of decode operation

* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::EndDecode(
    IN HRESULT statusCode
    )
{
    HRESULT hresult;

    if (!decodeSink)
    {
        WARNING(("EndDecode called before call to BeginDecode"));
        return E_FAIL;
    }

    hresult = decodeSink->EndSink(statusCode);

    decodeSink->Release();
    decodeSink = NULL;

    bReinitializeWMF = TRUE;

    return hresult;
}


/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     decodeSink --  The sink that will support the decode operation
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::GetImageInfo(OUT ImageInfo* imageInfoArg)
{
    HRESULT hresult;

    hresult = ReadWMFHeader();
    if (FAILED(hresult))
    {
        return hresult;
    }

    *imageInfoArg = imageInfo;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     decodeSink --  The sink that will support the decode operation
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::Decode()
{
    HRESULT hresult = S_OK;
    void *buffer;

    // If this is the second time through this stream, reinitialize pointer.

    if (bReinitializeWMF)
    {
        bReadHeader = FALSE;
        if (!pIstream)
        {
            return E_FAIL;
        }

        LARGE_INTEGER zero = {0,0};
        hresult = pIstream->Seek(zero, STREAM_SEEK_SET, NULL);
        if (!SUCCEEDED(hresult))
        {
            return hresult;
        }
    }

    hresult = ReadWMFHeader();
    if (FAILED(hresult))
    {
        return hresult;
    }

    // Allocate a buffer for the metafile.  There are some metafiles where
    // mh.mtSize is wrong, so let's read all the bits in the stream.

    //UINT mhSize = mh.mtSize * sizeof(WORD);

    STATSTG statStg;
    hresult = pIstream->Stat(&statStg, STATFLAG_NONAME);
    if (FAILED(hresult))
    {
        return hresult;
    }
    UINT mhSize = statStg.cbSize.LowPart - sizeof(pwmfh);

    // According to the document for IStream::Stat::StatStage(), the caller
    // has to free the pwcsName string
    CoTaskMemFree(statStg.pwcsName);

    buffer = GpMalloc(mhSize);
    if (!buffer)
    {
        return E_OUTOFMEMORY;
    }

    // Copy the metafile header to the start of the buffer

    *((METAHEADER *) buffer) = mh;

    // Now read the rest of the metafile into the buffer

    void *restOfBuffer = (void *) (((BYTE *) buffer) + sizeof(mh));
    ULONG cbRead;
    hresult = pIstream->Read(restOfBuffer, mhSize - sizeof(mh), &cbRead);
    if (FAILED(hresult))
    {
        return hresult;
    }
    if (cbRead != (mhSize - sizeof(mh)))
    {
        return E_FAIL;
    }

    // Call BeginSink

    hresult = decodeSink->BeginSink(&imageInfo, NULL);
    if (FAILED(hresult))
    {
        return hresult;
    }

    // Create memory DC and dibsection

    BITMAPINFO bmi;
    bmi.bmiHeader.biSize     = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth    = imageInfo.Width;
    bmi.bmiHeader.biHeight   = imageInfo.Height;
    bmi.bmiHeader.biPlanes   = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biSizeImage = 0;
    bmi.bmiHeader.biXPelsPerMeter = 0;
    bmi.bmiHeader.biYPelsPerMeter = 0;
    bmi.bmiHeader.biClrUsed = 0;
    bmi.bmiHeader.biClrImportant = 0;

    PBYTE pBits;
    HDC hdcScreen = GetDC(NULL);
    if ( hdcScreen == NULL )
    {
        GpFree(buffer);
        return E_OUTOFMEMORY;
    }

    HDC hdcMem = CreateCompatibleDC(hdcScreen);
    if ( hdcMem == NULL )
    {
        ReleaseDC(NULL, hdcScreen);
        GpFree(buffer);
        return E_OUTOFMEMORY;
    }
    HBITMAP hbitmap = CreateDIBSection(hdcScreen,
                                       &bmi,
                                       DIB_RGB_COLORS,
                                        (void **) &pBits,
                                       NULL,
                                       0);
    if (!hbitmap)
    {
        WARNING(("GpWMFCodec::Decode -- failed to create DIBSection"));

        DeleteDC(hdcMem);
        ReleaseDC(NULL, hdcScreen);
        GpFree(buffer);
        return E_OUTOFMEMORY;
    }

    // Initialize background to white

    UINT *p = (UINT *) pBits;
    UINT numPixels = imageInfo.Width * imageInfo.Height;
    UINT i;
    for (i = 0; i < numPixels; i++, p++)
    {
        *p = 0x00ffffff;
    }

    HBITMAP hOldBitmap = reinterpret_cast<HBITMAP>(SelectObject(hdcMem, hbitmap));

    // Create a handle for the metafile backing the bits from the stream

    HMETAFILE hWMF = SetMetaFileBitsEx(mhSize, (BYTE *) buffer);
    if (!hWMF)
    {
        WARNING(("GpWMFCodec::Decode -- cannot create metafile backing stream bits"));

        DeleteDC(hdcMem);
        DeleteObject(SelectObject(hdcMem, hOldBitmap));
        ReleaseDC(NULL, hdcScreen);
        GpFree(buffer);
        return E_FAIL;
    }

    // Now xform the DC so that the bounding rectangle is exactly the same as our dib.

    INT nOldMapMode = GetMapMode(hdcMem);
    SIZE sizeOld;
    SetMapMode(hdcMem, MM_ANISOTROPIC);
    SetViewportExtEx(hdcMem, imageInfo.Width, imageInfo.Height, &sizeOld );

    // Play the metafile onto the memory DC

    PlayMetaFile(hdcMem, hWMF);

    // Restore old settings

    SetViewportExtEx(hdcMem, sizeOld.cx, sizeOld.cy, NULL);
    SetMapMode(hdcMem, nOldMapMode);

    // And finally deliver the bits to the sink

    // ASSERT: The bits are in PIXFMT_32BPP_RGB format (no alpha values)

    BitmapData bitmapData;
    RECT rect;

    bitmapData.Width  = imageInfo.Width;
    bitmapData.Height = 1;
    bitmapData.Stride = bitmapData.Width * 4;
    bitmapData.PixelFormat = PIXFMT_32BPP_ARGB;
    bitmapData.Reserved = 0;

    rect.left  = 0;
    rect.right = imageInfo.Width;

    for (i=0; i < imageInfo.Height; i++)
    {
        rect.top    = i;
        rect.bottom = i + 1;
        bitmapData.Scan0 = pBits + (imageInfo.Height - i - 1) * bitmapData.Stride;

        // need to fill in the alpha values to make the bits be PIXFMT_32BPP_ARGB format,
        // which is a canonical format.
        UINT j;
        BYTE *ptr;
        for (j = 0, ptr = static_cast<BYTE *>(bitmapData.Scan0);
             j < imageInfo.Width;
             j++, ptr += 4)
        {
            // fill in the alpha value with 0xff
            *(ptr + 3) = 0xff;
        }

        hresult = decodeSink->PushPixelData(&rect,
                                            &bitmapData,
                                            PIXFMT_32BPP_ARGB);

        if (FAILED(hresult))
        {
            WARNING(("GpWMFCodec::Decode -- failed call to PushPixelData"));
            break;
        }
    }

    // Release objects

    DeleteMetaFile(hWMF);
    DeleteObject(SelectObject(hdcMem, hOldBitmap));
    DeleteDC(hdcMem);
    ReleaseDC(NULL, hdcScreen);
    GpFree(buffer);

    return hresult;
}

/**************************************************************************\
*
* Function Description:
*
*     Get the total number of dimensions the image supports
*
* Arguments:
*
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::GetFrameDimensionsCount(
    UINT* count
    )
{
    if ( count == NULL )
    {
        WARNING(("GpWmfCodec::GetFrameDimensionsCount--Invalid input parameter"));
        return E_INVALIDARG;
    }
    
    // Tell the caller that WMF is a one dimension image.

    *count = 1;

    return S_OK;
}// GetFrameDimensionsCount()

/**************************************************************************\
*
* Function Description:
*
*     Get an ID list of dimensions the image supports
*
* Arguments:
*
*     dimensionIDs---Memory buffer to hold the result ID list
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::GetFrameDimensionsList(
    GUID*   dimensionIDs,
    UINT    count
    )
{
    if ( (count != 1) || (dimensionIDs == NULL) )
    {
        WARNING(("GpWmfCodec::GetFrameDimensionsList-Invalid input param"));
        return E_INVALIDARG;
    }

    dimensionIDs[0] = FRAMEDIM_PAGE;

    return S_OK;
}// GetFrameDimensionsList()

/**************************************************************************\
*
* Function Description:
*
*     Get number of frames for the specified dimension
*
* Arguments:
*
*     dimensionID --
*     count --
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::GetFrameCount(
    IN const GUID* dimensionID,
    OUT UINT* count
    )
{
    if ( (NULL == count) || (*dimensionID != FRAMEDIM_PAGE) )
    {
        return E_INVALIDARG;
    }

    *count = 1;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Select currently active frame
*
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpWMFCodec::SelectActiveFrame(
    IN const GUID* dimensionID,
    IN UINT frameIndex
    )
{
    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*   Get image thumbnail
*
* Arguments:
*
*   thumbWidth, thumbHeight - Specifies the desired thumbnail size in pixels
*   thumbImage - Returns a pointer to the thumbnail image
*
* Return Value:
*
*   Status code
*
* Note:
*
*   Even if the optional thumbnail width and height parameters are present,
*   the decoder is not required to honor it. The requested size is used
*   as a hint. If both width and height parameters are 0, then the decoder
*   is free to choose an convenient thumbnail size.
*
\**************************************************************************/

HRESULT
GpWMFCodec::GetThumbnail(
    IN OPTIONAL UINT thumbWidth,
    IN OPTIONAL UINT thumbHeight,
    OUT IImage** thumbImage
    )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\zlib.h ===
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.1.4, March 11th, 2002

  Copyright (C) 1995-2002 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*/

#ifndef _ZLIB_H
#define _ZLIB_H

#include "zconf.h"

#ifdef __cplusplus
extern "C" {
#endif

#define ZLIB_VERSION "1.1.4"

/* 
     The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed
  data.  This version of the library supports only one compression method
  (deflation) but other algorithms will be added later and will have the same
  stream interface.

     Compression can be done in a single step if the buffers are large
  enough (for example if an input file is mmap'ed), or can be done by
  repeated calls of the compression function.  In the latter case, the
  application must provide more input and/or consume the output
  (providing more output space) before each call.

     The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio.

     The library does not install any signal handler. The decoder checks
  the consistency of the compressed data, so the library should never
  crash even in case of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    Bytef    *next_in;  /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total nb of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total nb of bytes output so far */

    char     *msg;      /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: ascii or binary */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
   The application must update next_in and avail_in when avail_in has
   dropped to zero. It must update next_out and avail_out when avail_out
   has dropped to zero. The application must initialize zalloc, zfree and
   opaque before calling the init function. All other fields are set by the
   compression library and must not be updated by the application.

   The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree. This can be useful for custom
   memory management. The compression library attaches no meaning to the
   opaque value.

   zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.

   On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this
   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
   pointers returned by zalloc for objects of exactly 65536 bytes *must*
   have their offset normalized to zero. The default allocation function
   provided by this library ensures this (see zutil.c). To reduce memory
   requirements and avoid any allocation of 64K objects, at the expense of
   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).

   The fields total_in and total_out can be used for statistics or
   progress reports. After compression, total_in holds the total size of
   the uncompressed data and may be saved for use in the decompressor
   (particularly if the decompressor wants to decompress everything in
   a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
/* Allowed flush values; see deflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_ASCII    1
#define Z_UNKNOWN  2
/* Possible values of the data_type field */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */

                        /* basic functions */

ZEXTERN const char * ZEXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is
   not compatible with the zlib.h header file used by the application.
   This check is automatically made by deflateInit and inflateInit.
 */

/* 
ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.
   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
   use default allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at
   all (the input data is simply copied a block at a time).
   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
   compression (currently equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).
   msg is set to null if there is no error message.  deflateInit does not
   perform any compression: this will be done by deflate().
*/


ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
/*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may introduce some
  output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows. deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly. This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).
    Some output may be provided even if flush is not set.

  Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating avail_in or avail_out accordingly; avail_out
  should never be zero before the call. The application can consume the
  compressed output when it wants, for example when the output buffer is full
  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
  and with zero avail_out, it must be called again after making room in the
  output buffer because there might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far. (In particular
  avail_in is zero after the call if enough output space has been provided
  before the call.)  Flushing may degrade compression for some compression
  algorithms and so it should be used only when necessary.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
  the compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out).

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there
  was enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error. After
  deflate has returned Z_STREAM_END, the only possible operations on the
  stream are deflateReset or deflateEnd.
  
    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step. In this case, avail_out must be at least
  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
  Z_STREAM_END, then it must be called again as described above.

    deflate() sets strm->adler to the adler32 checksum of all input read
  so far (that is, total_in bytes).

    deflate() may update data_type if it can make a good guess about
  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
  binary. This field is only for information purposes and does not affect
  the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
  (for example avail_in or avail_out was zero).
*/


ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded). In the error case,
   msg may be set but then points to a static string (which must not be
   deallocated).
*/


/* 
ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression. The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
   value depends on the compression method), inflateInit determines the
   compression method from the zlib header and allocates all data structures
   accordingly; otherwise the allocation will be deferred to the first call of
   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
   use default allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller.  msg is set to null if there is no error
   message. inflateInit does not perform any decompression apart from reading
   the zlib header if present: this will be done by inflate().  (So next_in and
   avail_in may be modified, but next_out and avail_out are unchanged.)
*/


ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
/*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may some
  introduce some output latency (reading input without producing any output)
  except when forced to flush.

  The detailed semantics are as follows. inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing
    will resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there
    is no more input data or no more space in the output buffer (see below
    about the flush parameter).

  Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating the next_* and avail_* values accordingly.
  The application can consume the uncompressed output when it wants, for
  example when the output buffer is full (avail_out == 0), or after each
  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
  must be called again after making room in the output buffer because there
  might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
  output as possible to the output buffer. The flushing behavior of inflate is
  not specified for values of the flush parameter other than Z_SYNC_FLUSH
  and Z_FINISH, but the current implementation actually flushes as much output
  as possible anyway.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error. However if all decompression is to be performed in a single step
  (a single call of inflate), the parameter flush should be set to
  Z_FINISH. In this case all pending input is processed and all pending
  output is flushed; avail_out must be large enough to hold all the
  uncompressed data. (The size of the uncompressed data may have been saved
  by the compressor for this purpose.) The next operation on this stream must
  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
  is never required, but can be used to inform inflate that a faster routine
  may be used for the single inflate() call.

     If a preset dictionary is needed at this point (see inflateSetDictionary
  below), inflate sets strm-adler to the adler32 checksum of the
  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise 
  it sets strm->adler to the adler32 checksum of all output produced
  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
  an error code as described below. At the end of the stream, inflate()
  checks that its computed adler32 checksum is equal to that saved by the
  compressor and returns Z_STREAM_END only if the checksum is correct.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect
  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
  case, the application may then call inflateSync to look for a good
  compression block.
*/


ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent. In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/

                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*   
ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                     int  level,
                                     int  method,
                                     int  windowBits,
                                     int  memLevel,
                                     int  strategy));

     This is another version of deflateInit with more compression options. The
   fields next_in, zalloc, zfree and opaque must be initialized before by
   the caller.

     The method parameter is the compression method. It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library. Larger values of this parameter result in better
   compression at the expense of memory usage. The default value is 15 if
   deflateInit is used instead.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state. memLevel=1 uses minimum memory but
   is slow and reduces compression ratio; memLevel=9 uses maximum memory
   for optimal speed. The default value is 8. See zconf.h for total memory
   usage as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm. Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match).  Filtered data consists mostly of small values with a
   somewhat random distribution. In this case, the compression algorithm is
   tuned to compress them better. The effect of Z_FILTERED is to force more
   Huffman coding and less string matching; it is somewhat intermediate
   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
   the compression ratio but not the correctness of the compressed output even
   if it is not set appropriately.

      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
   method). msg is set to null if there is no error message.  deflateInit2 does
   not perform any compression: this will be done by deflate().
*/
                            
ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output. This function must be called
   immediately after deflateInit, deflateInit2 or deflateReset, before any
   call of deflate. The compressor and decompressor must use exactly the same
   dictionary (see inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary. Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size in
   deflate or deflate2. Thus the strings most likely to be useful should be
   put at the end of the dictionary, not at the front.

     Upon return of this function, strm->adler is set to the Adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor. (The Adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.)

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if the compression method is bsort). deflateSetDictionary does not
   perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter. The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and
   can consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being NULL). msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.
   The stream will keep the same compression level and any other attributes
   that may have been set by deflateInit2.

      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/

ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
				      int level,
				      int strategy));
/*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2.  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different
   strategy. If the compression level is changed, the input available so far
   is compressed with the old level (and may be flushed); the new level will
   take effect only at the next call of deflate().

     Before the call of deflateParams, the stream state must be set as for
   a call of deflate(), since the currently available input may have to
   be compressed and flushed. In particular, strm->avail_out must be non-zero.

     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
   if strm->avail_out was zero.
*/

/*   
ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                     int  windowBits));

     This is another version of inflateInit with an extra parameter. The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library. The default value is 15 if inflateInit is used
   instead. If a compressed stream with a larger window size is given as
   input, inflate() will return with the error code Z_DATA_ERROR instead of
   trying to allocate a larger window.

      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
   memLevel). msg is set to null if there is no error message.  inflateInit2
   does not perform any decompression apart from reading the zlib header if
   present: this will be done by inflate(). (So next_in and avail_in may be
   modified, but next_out and avail_out are unchanged.)
*/

ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the decompression dictionary from the given uncompressed byte
   sequence. This function must be called immediately after a call of inflate
   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
   can be determined from the Adler32 value returned by this call of
   inflate. The compressor and decompressor must use exactly the same
   dictionary (see deflateSetDictionary).

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect Adler32 value). inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
/* 
    Skips invalid compressed data until a full flush point (see above the
  description of deflate with Z_FULL_FLUSH) can be found, or until all
  available input is skipped. No output is provided.

    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
  case, the application may save the current current value of total_in which
  indicates where valid compressed data was found. In the error case, the
  application may repeatedly call inflateSync, providing more input each time,
  until success or end of the input data.
*/

ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate all the internal decompression state.
   The stream will keep attributes that may have been set by inflateInit2.

      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/


                        /* utility functions */

/*
     The following utility functions are implemented on top of the
   basic stream-oriented functions. To simplify the interface, some
   default options are assumed (compression level and memory usage,
   standard memory allocation functions). The source code of these
   utility functions can easily be modified if you need special options.
*/

ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
                                 const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be at least 0.1% larger than
   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
   compressed buffer.
     This function can be used to compress a whole file at once if the
   input file is mmap'ed.
     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
                                  const Bytef *source, uLong sourceLen,
                                  int level));
/*
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/

ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/


typedef voidp gzFile;

ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
/*
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb") but can also include a compression level
   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
   Huffman only compression as in "wb1h". (See the description
   of deflateInit2 for more information about the strategy parameter.)

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.

     gzopen returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).  */

ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
/*
     gzdopen() associates a gzFile with the file descriptor fd.  File
   descriptors are obtained from calls like open, dup, creat, pipe or
   fileno (in the file has been previously opened with fopen).
   The mode parameter is as in gzopen.
     The next call of gzclose on the returned gzFile will also close the
   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
     gzdopen returns NULL if there was insufficient memory to allocate
   the (de)compression state.
*/

ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
/*
     Dynamically update the compression level or strategy. See the description
   of deflateInit2 for the meaning of these parameters.
     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
   opened for writing.
*/

ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.
   If the input file was not in gzip format, gzread copies the given number
   of bytes into the buffer.
     gzread returns the number of uncompressed bytes actually read (0 for
   end of file, -1 for error). */

ZEXTERN int ZEXPORT    gzwrite OF((gzFile file, 
				   const voidp buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes actually written
   (0 in case of error).
*/

ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
/*
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).
*/

ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
/*
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/

ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
/*
      Reads bytes from the compressed file until len-1 characters are read, or
   a newline character is read and transferred to buf, or an end-of-file
   condition is encountered.  The string is then terminated with a null
   character.
      gzgets returns buf, or Z_NULL in case of error.
*/

ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
/*
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/

ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
/*
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/

ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function. The return value is the zlib
   error number (see function gzerror below). gzflush returns Z_OK if
   the flush parameter is Z_FINISH and all output could be flushed.
     gzflush should be called only when strictly necessary because it can
   degrade compression.
*/

ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
				      z_off_t offset, int whence));
/* 
      Sets the starting position for the next gzread or gzwrite on the
   given compressed file. The offset represents a number of bytes in the
   uncompressed data stream. The whence parameter is defined as in lseek(2);
   the value SEEK_END is not supported.
     If the file is opened for reading, this function is emulated but can be
   extremely slow. If the file is opened for writing, only forward seeks are
   supported; gzseek then compresses a sequence of zeroes up to the new
   starting position.

      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error, in
   particular if the file is opened for writing and the new starting position
   would be before the current position.
*/

ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
/*
     Rewinds the given file. This function is supported only for reading.

   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
*/

ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
/*
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.

   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
*/

ZEXTERN int ZEXPORT gzeof OF((gzFile file));
/*
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/

ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state. The return value is the zlib
   error number (see function gzerror below).
*/

ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the
   compression library.
*/

ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));

/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum. If buf is NULL, this function returns
   the required initial value for the checksum.
   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster. Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running crc with the bytes buf[0..len-1] and return the updated
   crc. If buf is NULL, this function returns the required initial value
   for the crc. Pre- and post-conditioning (one's complement) is performed
   within this function so it shouldn't be done by the application.
   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                                      int windowBits, int memLevel,
                                      int strategy, const char *version,
                                      int stream_size));
ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                      const char *version, int stream_size));
#define deflateInit(strm, level) \
        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm) \
        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm, windowBits) \
        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))


#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
    struct internal_state {int dummy;}; /* hack for buggy compilers */
#endif

ZEXTERN const char   * ZEXPORT zError           OF((int err));
ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));

#ifdef __cplusplus
}
#endif

#endif /* _ZLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\png\zlib\zutil.h ===
/* zutil.h -- internal interface and configuration of the compression library
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* @(#) $Id$ */

#ifndef _Z_UTIL_H
#define _Z_UTIL_H

#include "zlib.h"

#ifdef STDC
#  include <stddef.h>
#  include <string.h>
#  include <stdlib.h>
#endif
#ifdef NO_ERRNO_H
    extern int errno;
#else
#   include <errno.h>
#endif

#ifndef local
#  define local static
#endif
/* compile with -Dlocal if your debugger can't find static symbols */

typedef unsigned char  uch;
typedef uch FAR uchf;
typedef unsigned short ush;
typedef ush FAR ushf;
typedef unsigned long  ulg;

extern const char *z_errmsg[10]; /* indexed by 2-zlib_error */
/* (size given to avoid silly warnings with Visual C++) */

#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]

#define ERR_RETURN(strm,err) \
  return (strm->msg = (char*)ERR_MSG(err), (err))
/* To be used only when the state is known to be valid */

        /* common constants */

#ifndef DEF_WBITS
#  define DEF_WBITS MAX_WBITS
#endif
/* default windowBits for decompression. MAX_WBITS is for compression only */

#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif
/* default memLevel */

#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2
/* The three kinds of block type */

#define MIN_MATCH  3
#define MAX_MATCH  258
/* The minimum and maximum match lengths */

#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */

        /* target dependencies */

#ifdef MSDOS
#  define OS_CODE  0x00
#  if defined(__TURBOC__) || defined(__BORLANDC__)
#    if(__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
       /* Allow compilation with ANSI keywords only enabled */
       void _Cdecl farfree( void *block );
       void *_Cdecl farmalloc( unsigned long nbytes );
#    else
#     include <alloc.h>
#    endif
#  else /* MSC or DJGPP */
#    include <malloc.h>
#  endif
#endif

#ifdef OS2
#  define OS_CODE  0x06
#endif

#ifdef WIN32 /* Window 95 & Windows NT */
#  define OS_CODE  0x0b
#endif

#if defined(VAXC) || defined(VMS)
#  define OS_CODE  0x02
#  define F_OPEN(name, mode) \
     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
#endif

#ifdef AMIGA
#  define OS_CODE  0x01
#endif

#if defined(ATARI) || defined(atarist)
#  define OS_CODE  0x05
#endif

#if defined(MACOS) || defined(TARGET_OS_MAC)
#  define OS_CODE  0x07
#  if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
#    include <unix.h> /* for fdopen */
#  else
#    ifndef fdopen
#      define fdopen(fd,mode) NULL /* No fdopen() */
#    endif
#  endif
#endif

#ifdef __50SERIES /* Prime/PRIMOS */
#  define OS_CODE  0x0F
#endif

#ifdef TOPS20
#  define OS_CODE  0x0a
#endif

#if defined(_BEOS_) || defined(RISCOS)
#  define fdopen(fd,mode) NULL /* No fdopen() */
#endif

#if (defined(_MSC_VER) && (_MSC_VER > 600))
#  define fdopen(fd,type)  _fdopen(fd,type)
#endif


        /* Common defaults */

#ifndef OS_CODE
#  define OS_CODE  0x03  /* assume Unix */
#endif

#ifndef F_OPEN
#  define F_OPEN(name, mode) fopen((name), (mode))
#endif

         /* functions */

#ifdef HAVE_STRERROR
   extern char *strerror OF((int));
#  define zstrerror(errnum) strerror(errnum)
#else
#  define zstrerror(errnum) ""
#endif

#if defined(pyr)
#  define NO_MEMCPY
#endif
#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
 /* Use our own functions for small and medium model with MSC <= 5.0.
  * You may have to use the same strategy for Borland C (untested).
  * The __SC__ check is for Symantec.
  */
#  define NO_MEMCPY
#endif
#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
#  define HAVE_MEMCPY
#endif
#ifdef HAVE_MEMCPY
#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
#    define zmemcpy _fmemcpy
#    define zmemcmp _fmemcmp
#    define zmemzero(dest, len) _fmemset(dest, 0, len)
#  else
#    define zmemcpy memcpy
#    define zmemcmp memcmp
#    define zmemzero(dest, len) memset(dest, 0, len)
#  endif
#else
   extern void zmemcpy  OF((Bytef* dest, const Bytef* source, uInt len));
   extern int  zmemcmp  OF((const Bytef* s1, const Bytef* s2, uInt len));
   extern void zmemzero OF((Bytef* dest, uInt len));
#endif

/* Diagnostic functions */
#ifdef DEBUG
#  include <stdio.h>
   extern int z_verbose;
   extern void z_error    OF((char *m));
#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
#else
#  define Assert(cond,msg)
#  define Trace(x)
#  define Tracev(x)
#  define Tracevv(x)
#  define Tracec(c,x)
#  define Tracecv(c,x)
#endif


typedef uLong (ZEXPORT *check_func) OF((uLong check, const Bytef *buf,
				       uInt len));
voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
void   zcfree  OF((voidpf opaque, voidpf ptr));

#define ZALLOC(strm, items, size) \
           (*((strm)->zalloc))((strm)->opaque, (items), (size))
#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}

#endif /* _Z_UTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\aaline.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   One-pixel-wide solid anti-aliased lines
*
* Abstract:
*
*   Draws anti-aliased solid-color lines which are one pixel wide.
*   Supports clipping against complex clipping regions. 
*
* History:
*
*   3/31/1999 AMatos
*       Created it.
*   08/17/1999 AGodfrey
*       Separated aliased from antialiased.
*
\**************************************************************************/

#include "precomp.hpp" 

#pragma optimize("a", on) 

// Antialiased lines are usually drawn using aarasterizer.cpp 
// rather than aaline.cpp.  If aaline.cpp is to be used, define
// AAONEPIXELLINE_SUPPORT

#ifdef AAONEPIXELLINE_SUPPORT

//------------------------------------------------------------------------
// Global array that stores all the different options of drawing functions. 
// If the order of the functions change, the offset constants must also 
// change.  
//------------------------------------------------------------------------

#define FUNC_X_MAJOR     0
#define FUNC_Y_MAJOR     1
#define FUNC_CLIP_OFFSET 2


typedef VOID (OnePixelLineDDAAntiAliased::*DDAFunc)(DpScanBuffer*);

DDAFunc gDrawFunctions[] = { 
    OnePixelLineDDAAntiAliased::DrawXMajor, 
    OnePixelLineDDAAntiAliased::DrawYMajor, 
    OnePixelLineDDAAntiAliased::DrawXMajorClip, 
    OnePixelLineDDAAntiAliased::DrawYMajorClip, 
};

//------------------------------------------------------------------------
// Constants used for manipulating fixed point and doing all the bitwise 
// operations on the aliased and antialiased DDA. I know some of these
// are already defined elsewhere, but I do it again here as it might be nice to 
// keep this independent of the rest of gdiplus. 
//------------------------------------------------------------------------

// Fixed point 

#define RealToFix GpRealToFix4 

#define FBITS     4
#define FMASK     0xf
#define FINVMASK  0xfffffff0
#define FSIZE     16
#define FHALF     8
#define FHALFMASK 7

// Antialiasing constants 

#define MAXALPHA   255
#define MAXERROR   0x08000000
#define TESTABOVE  0xf8000000
#define TESTBELOW  0x07ffffff
#define MAXHALF    0x04000000
#define CONVERTALPHA 19


/**************************************************************************\
*
* Function Description:
*
* Does all the DDA setup that is common to aliased and antialiased
* lines. 
*
* Arguments:
*
*   [IN] point1   - end point
*   [IN] point2   - end point
*   [IN] drawLast - FALSE if the line is to be end-exclusive

* Return Value:
*
* Returns TRUE if the drawing should continue, meaning the line
* has non-zero length. 
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

BOOL
OnePixelLineDDAAntiAliased::SetupCommon( 
    GpPointF *point1, 
    GpPointF *point2, 
    BOOL drawLast
    )
{
    // Turn the points into fixed 28.4 

    INT x1 = RealToFix(point1->X); 
    INT x2 = RealToFix(point2->X); 
    
    REAL rDeltaX = point2->X - point1->X; 
    REAL rDeltaY = point2->Y - point1->Y; 

    if( rDeltaX == 0 && rDeltaY == 0 ) 
    {
        return FALSE; 
    }

    INT xDir = 1; 

    if(rDeltaX < 0)
    {
        rDeltaX = -rDeltaX; 
        xDir = -1; 
    }

    INT y1 = RealToFix(point1->Y); 
    INT y2 = RealToFix(point2->Y); 

    INT yDir = 1; 

    if( rDeltaY < 0)
    {
        rDeltaY = -rDeltaY; 
        yDir = -1;
    }
    
    Flipped = FALSE; 

    if( rDeltaY >= rDeltaX ) 
    {
        // y-major 
                
        InvDelta = 1.0F/rDeltaY; 

        // Invert the endpoints if necessary       

        if(yDir == -1)
        {
            INT tmp = y1; 
            y1 = y2; 
            y2 = tmp; 
            tmp = x1;
            x1 = x2; 
            x2 = tmp; 
            xDir = -xDir; 
            Flipped = TRUE; 
        }

        // Determine the Slope 
        
        Slope = xDir*rDeltaX*InvDelta; 

        // Initialize the Start and End points 

        IsXMajor = FALSE; 
        MajorStart = y1; 
        MajorEnd = y2; 
        MinorStart = x1; 
        MinorEnd = x2; 
        MinorDir = xDir;

        // This will help us for the AntiAliased x-major case.

        SwitchFirstLast = 1;

        // Mark that we'll use the y-major functions. 

        DrawFuncIndex = FUNC_Y_MAJOR; 
    }
    else
    {
        // x-major        

        InvDelta = 1.0F/rDeltaX; 

        // Invert the endpoints if necessary        

        if(xDir == -1)
        {
            INT tmp = x1; 
            x1 = x2; 
            x2 = tmp; 
            tmp = y1;
            y1 = y2; 
            y2 = tmp; 
            yDir = -yDir; 
            Flipped = TRUE; 
        }

        Slope = yDir*rDeltaY*InvDelta; 

        // Initialize the rest

        IsXMajor = TRUE; 
        MajorStart = x1; 
        MajorEnd = x2; 
        MinorStart = y1; 
        MinorEnd = y2; 
        MinorDir = yDir; 

        // This will help us for the AntiAliased x-major case.

        SwitchFirstLast = MinorDir;

        // Mark that we'll use the x-major functions. 

        DrawFuncIndex = FUNC_X_MAJOR;
    }

    // Initialize the Deltas. In fixed point. 

    DMajor = MajorEnd - MajorStart; 
    DMinor = (MinorEnd - MinorStart)*MinorDir; 

    // Mark if we're drawing end-exclusive 

    IsEndExclusive = drawLast; 

    return TRUE; 
}

/**************************************************************************\
*
* Function Description:
*
* Does the part of the DDA setup that is specific for anti-aliased lines. 
*
* Arguments:

* Return Value:
*
* Always returns TRUE. It must return a BOOL because it must have the
* same signature as the aliased case. 
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

BOOL
OnePixelLineDDAAntiAliased::SetupAntiAliased()
{   
    const REAL maxError = MAXERROR;

    // Find the integer major positions for the beginning and 
    // the end of the line. 

    INT major, minor; 
    INT majorEnd, minorEnd; 

    major = (MajorStart + FHALF) >> FBITS; 
    majorEnd = (MajorEnd + FHALF) >> FBITS;    

    // Check for the simple case of a one pixel long line
    
    if(majorEnd == major) 
    {
        AlphaFirst = (MAXALPHA*(MajorEnd - MajorStart)*MinorDir) >> FBITS;    
        MajorStart = major;
        MajorEnd   = majorEnd;
        MinorStart = (MinorStart + FHALF) >> FBITS;
        return TRUE; 
    }

    // Store the fraction of the first pixel covered due to 
    // the start point. 

    FracStart = (major << FBITS) - MajorStart; 

    // Advance the minor coordinate to the integer major

    MinorStart += GpFloor(Slope*FracStart); 

    // Calculate the length across the line in the minor direction 

    INT halfWidth = RealToFix(LineLength*InvDelta) >> 1;       

    // Make sure thar startX and endX don't end up being the
    // same pixel, which our code does not handle. Theoretically
    // this cannot happen when the width of the line is 1, but
    // let's make sure it doesn't happen because of some roundoff
    // Error. 

    if( halfWidth < FHALF ) 
    { 
        halfWidth = FHALF; 
    }
    
    INT endMinor = MinorEnd + MinorDir*halfWidth; 

    // Calculate the Error up from the Slope. It needs to be that 
    // way so that the Error up will work when the 0-1 interval 
    // is mapped to the interval 0 to 0x8000000. See comments below. 

    ErrorUp = GpFloor(Slope*maxError); 
    ErrorDown = MinorDir*MAXERROR; 

    // For a given aa one pixel wide line, there can be up to three pixels 
    // baing painted across the line. We call these the first, middle and
    // last lines. So all variable with such prefixes refer to one
    // of these three. firstX and lastX are the positions of these lines. 
    // In the x-major case, unlike the y-major, we might need to switch 
    // who is the first and who is the second line depending on the 
    // direction, so that the order that each line fills the scan 
    // remains the same. That's why we multiply halfWidth by yDir. 

    halfWidth *= SwitchFirstLast; 

    MinorFirst = MinorStart - halfWidth;
    MinorLast  = MinorStart + halfWidth;

    // Calculate the initial Error. The Error is mapped so that 1 is 
    // taken to MAXERROR. So we find how mush we are into the 
    // pixel in X, which is a number between 0 and 16 (n.4). We then
    // multiply this by MAXERROR and shift it from fized point. Finally we add
    // MAXHALF  so that the 0-1 interval is mapped to 0 to MAXERROR 
    // instead of from -MAXHALF  and MAXHALF .     
           
    const INT convError = MAXERROR >> FBITS; 

    ErrorFirst = (MinorFirst - ((MinorFirst + FHALF) & FINVMASK))*
                convError + MAXHALF;
    ErrorLast  = (MinorLast  - ((MinorLast  + FHALF) & FINVMASK))*
                convError + MAXHALF ;
    
    // Now calculate the alpha's for the first pixel. This is 
    // done from the Error. Since the Error is between 
    // 0 and MAXERROR-1, if we shift it back by 19 (CONVERTALPHA)
    // we have a number between 0 and 255. We the multiply by 
    // yFrac which takes into account that the end of the line 
    // also cuts the coverage down. At the end we convert from
    // 28.4. alphaFirst is the alpha of for the first pixel across the
    // aa line, alpha Mid is for the middle if there is one, and 
    // AlphaLast is for the last pixel. 

    FracStart = FracStart + FHALF; 

    // Convert from 28.4 rounding 

    MinorFirst = (MinorFirst + FHALF) >> FBITS; 
    MinorLast  = (MinorLast  + FHALF) >> FBITS; 

    // Store the fraction for the last pixel 

    FracEnd = MajorEnd - (majorEnd << FBITS) + FHALF;

    // Store the initial values in integer coordinates 

    MajorStart = major; 
    MajorEnd = majorEnd; 
    MinorStart = MinorFirst;
    MinorEnd = (endMinor + FHALF) >> FBITS; 

    // Now do some initializations specific for the x-major and 
    // y-major cases. These can't be done in the drawing routine 
    // because those are reused during clipping. 

    if(!IsXMajor)
    {
        // Calculate the coverage values at the initial pixel. 

        AlphaFirst = ((MAXALPHA - (ErrorFirst >> CONVERTALPHA))*
                        FracStart) >> FBITS; 
        AlphaLast  = ((ErrorLast >> CONVERTALPHA)*FracStart) >> FBITS; 
        AlphaMid   = (MAXALPHA*FracStart) >> FBITS; 
    }
    else
    {
        // Depending if we are going up or down, the alpha is calculated 
        // a different way from the coverage. In each case we want to 
        // estimate the coverage as the area from the current position to 
        // the end of the pixel, but which end varies. This is stored 
        // in the following biases. We don't have to do this for the 
        // y-major line because of the switch between first and last line
        // explained above. 

        AlphaBiasLast  = ((1 - MinorDir) >> 1)*TESTBELOW; 
        AlphaBiasFirst = ((1 + MinorDir) >> 1)*TESTBELOW; 

        AlphaFirst = ((AlphaBiasFirst - MinorDir*ErrorFirst)*FracStart) >> FBITS; 
        AlphaLast  = ((AlphaBiasLast  + MinorDir*ErrorLast)*FracStart) >> FBITS; 
        
        // If there is a middle line on the first X value, take xFrac into 
        // account. Otherwise, the middle line's alpha is always MAXALPHA.                
        
        if(MinorDir*(MinorLast - MinorFirst) < 2)
        {
            AlphaMid = MAXALPHA; 
        }
        else
        {
            AlphaMid = MAXALPHA*FracStart >> FBITS; 
        }
        
        // Both the first and last DDAs start with the same 
        // major positions, given by the first pixel. 
        
        MajorFirst = MajorLast = MajorStart; 
    }

    return TRUE; 
}

    
/**************************************************************************\
*
* Function Description:
*
* Draws a y major anti-aliased line. Does not support clipping, it assumes that 
* it is completely inside any clipping area. 
*
* Arguments:
*
*   [IN] DpScanBuffer - The scan buffer for accessing the surface. 

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

VOID
OnePixelLineDDAAntiAliased::DrawYMajor(
    DpScanBuffer *scan
    )
{      
    ARGB *buffer;            

    // Treat the special case where the line is just 
    // one pixel long. 

    if( MajorEnd == MajorStart)
    {
        buffer  = scan->NextBuffer( MinorStart, MajorStart, 1);
        *buffer = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaFirst));
        return; 
    }

    // Get the number of pixels not counting the last one. 
    // Which requires special endpoint treatment. 

    INT  numPixels = MajorEnd - MajorStart;
    BOOL endDone   = FALSE; 

    // There can be two or three pixels across the line

    INT pixelWidth = MinorLast - MinorFirst + 1; 

    while(numPixels) 
    {
        numPixels--; 

last_pixel: 
        
        // Get the scanline buffer buffer

        buffer = scan->NextBuffer(MinorFirst, MajorStart, pixelWidth);       

        // Write the value of the first DDA

        *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaFirst));

        // If there is a middle line, write its value. 

        if(pixelWidth > 2)
        {
            *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaMid));
        }
        
        // Write the value of the last (2nd or 3rd) DDA

        *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaLast)); 

        // Update the errors of both DDAs

        ErrorFirst+= ErrorUp; 
        ErrorLast += ErrorUp; 
        MajorStart++; 

        if(ErrorFirst & TESTABOVE)
        {
            ErrorFirst -= ErrorDown; 
            MinorFirst += MinorDir; 
        }
        if(ErrorLast & TESTABOVE)
        {
            ErrorLast -= ErrorDown; 
            MinorLast += MinorDir; 
        }
        
        // Calculate the new alphas for the next scan, and 
        // the new line width. 

        AlphaFirst = MAXALPHA - (ErrorFirst >> CONVERTALPHA); 
        AlphaLast  = (ErrorLast >> CONVERTALPHA); 
        AlphaMid   = MAXALPHA;             

        pixelWidth = MinorLast - MinorFirst + 1;             
    }

    // The last scan requires special treatment since its coverage
    // must be multiplied my the stored end coverage. So so this 
    // multiplication and go back to the body of the loop above 
    // to draw the last scan. 

    if(!endDone) 
    {
        AlphaFirst = (AlphaFirst*FracEnd) >> FBITS; 
        AlphaLast  = (AlphaLast*FracEnd)  >> FBITS; 
        AlphaMid   = (AlphaMid*FracEnd)   >> FBITS; 
        
        endDone = TRUE; 
        goto last_pixel; 
    }
}


/**************************************************************************\
*
* Function Description:
*
* Draws a x major anti-aliased line. Does not support clipping, it assumes that 
* it is completely inside any clipping area. 
*
* Arguments:
*
*   [IN] DpScanBuffer - The scan buffer for accessing the surface. 

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

VOID
OnePixelLineDDAAntiAliased::DrawXMajor(
    DpScanBuffer *scan
    )
{
    ARGB *buffer;     
    INT maxWidth = scan->GetSurface()->Width;

    // Treat the special case where the line is just 
    // one pixel long. 

    if( MajorEnd == MajorStart)
    {
        buffer  = scan->NextBuffer( MajorStart, MinorStart, 1);
        *buffer = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaFirst));
        return; 
    }

    // For an x-major one-pixel wide line, there can be up to 
    // three different scans being painted for the same x 
    // position. But in our case we can't draw to these all at
    // the same time since some surfaces can only be accessed
    // one scan at a time. So the algorithm used here does all the 
    // drawing to one scan at each time. But on the first scan, only
    // the first line should be drawn, on the second one both the
    // first and middle (if there is a middle) and only then all 
    // the lines. So correct the Error of the last line so that 
    // it'll only be drawn when we are at the second or third scan line. 
    // Also correct the alpha since it'll also be crecremented for
    // each scan line. 
    
    ErrorLast   += MinorDir*(MinorLast - MinorFirst)*ErrorDown; 
    AlphaLast   += (MinorLast - MinorFirst)*ErrorDown; 

    // Get the pointer to the buffer

    buffer = scan->NextBuffer(MajorLast, MinorStart, maxWidth);

    INT width = 0; 
    INT alpha;                   
    INT middleMajor; 

    while(MajorLast <= MajorEnd) 
    {
        // Fill the scan with the portion corresponding to the 
        // last line, which shoudl comes first on the scan. This is 
        // why we use the class member SwitchFirstLast, so we can decide 
        // based on the line direction which DDA will be the first and last
        // so that the last one (paradoxically) always comes first on the 
        // scan. Keep doing it untill the last line chages scan. Check for
        // the end to multiply by the last pixel's coverage. 

        while(!(ErrorLast & TESTABOVE))
        {
            if(MajorLast == MajorEnd)
            {
                AlphaLast  = (AlphaLast*FracEnd) >> FBITS; 

                // Increment the error to correct for the 
                // decrementing below, since we didn't leave the
                // loop because the error became above 0. 

                ErrorLast += ErrorDown; 
            }
            *buffer++ = GpColor::PremultiplyWithCoverage(Color, 
                static_cast<BYTE>(AlphaLast >> CONVERTALPHA));
            ErrorLast += ErrorUp; 
            AlphaLast = AlphaBiasLast + MinorDir*ErrorLast; 
            width++; 
            MajorLast++; 
        }

        // We changed scans on the last DDA, so update the errors

        ErrorLast -= ErrorDown; 
        AlphaLast -= MinorDir*ErrorDown; 
        
        // Fill in the middle part if there is one

        middleMajor = MajorLast; 

        while(middleMajor < MajorFirst)
        {
            if( middleMajor == MajorEnd) 
            {
                AlphaMid = (AlphaMid*FracEnd) >> FBITS; 
            }
            *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaMid));
            AlphaMid = MAXALPHA; 
            width++;
            middleMajor++;
        }
    
        // Fill the scan with the portion corresponding to the 
        // first line, which comes last. Keep doing it untill the 
        // last line chages scan. 

        while(!(ErrorFirst & TESTABOVE))
        {
            if(MajorFirst == MajorEnd) 
            {
                AlphaFirst = (AlphaFirst*FracEnd) >> FBITS;
                
                // Since we can have at most three more scans
                // increment ErrorFirst so that we never go in here again

                ErrorFirst += 4*ErrorDown; 
            }

            *buffer++ = GpColor::PremultiplyWithCoverage(
                Color, 
                static_cast<BYTE>(AlphaFirst >> CONVERTALPHA));
            ErrorFirst += ErrorUp; 
            AlphaFirst = AlphaBiasFirst - MinorDir*ErrorFirst; 
            width++; 
            MajorFirst++; 
        }

        // Update the errors on the first scan

        ErrorFirst -= ErrorDown; 
        AlphaFirst += MinorDir*ErrorDown; 

        // Write the buffer and update the minor variables

        scan->UpdateWidth(width); 
        MinorStart += MinorDir; 
        if (MajorLast <= MajorEnd)
        {
            buffer = scan->NextBuffer(MajorLast, MinorStart, maxWidth); 
        }
        width = 0; 
    }

    scan->UpdateWidth(width);
}


/**************************************************************************\
*
* Function Description:
*
* Draws a y major line taking clipping into account. It uses the member
* variables MajorIn, MajorOut, MinorIn, MinorOut of the class as the 
* clip rectangle. It advances untill the line is in the clip rectangle and 
* draws untill it gets out or the end point is reached. In the first case, 
* it leaves the DDA in a state so that it can be called again with another
* clipping rectangle. 
*
* Arguments:
*
*   [IN] DpScanBuffer - The scan buffer for accessing the surface. 

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/
    
VOID
OnePixelLineDDAAntiAliased::DrawYMajorClip(
    DpScanBuffer *scan
    )
{      
    ARGB *buffer;     
        
    // Treat the special case where the line is just 
    // one pixel long. 

    if( MajorEnd == MajorStart)
    {
        // Check if the point is inside the rectangle 

        if((MajorStart >= MajorIn) && 
           (MajorStart <= MajorOut) && 
           ((MinorStart  - MinorIn)*MinorDir >= 0) && 
           ((MinorOut - MinorStart)*MinorDir >= 0))
        {
            buffer  = scan->NextBuffer( MinorStart, MajorStart, 1);
            *buffer = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaFirst));
        }
        return; 
    }

    // Align the major start coordinate with the edge of the 
    // cliprectangle 

    INT numScans = MajorIn - MajorStart; 

    while(numScans > 0)
    {

        ErrorFirst+= ErrorUp; 
        ErrorLast += ErrorUp; 
        MajorStart++;
        numScans--;

        if(ErrorFirst & MAXERROR)
        {
            ErrorFirst -= ErrorDown; 
            MinorFirst += MinorDir; 
        }
        if(ErrorLast & MAXERROR)
        {
            ErrorLast -= ErrorDown; 
            MinorLast += MinorDir; 
        }
        
        // Calculate the new alphas for the next line, and 
        // the width. 

        AlphaFirst = MAXALPHA - (ErrorFirst >> CONVERTALPHA); 
        AlphaLast  = (ErrorLast >> CONVERTALPHA); 
        AlphaMid   = MAXALPHA;             
    }
    
    // Save the end values 

    INT saveMajor2  = MajorEnd; 
    INT saveFracEnd = FracEnd; 

    // If the end major coordinate is outside of the rectangle, 
    // mark that the DDA should stop at the edge

    if(MajorEnd > MajorOut)
    {
        MajorEnd = MajorOut; 
        FracEnd  = FSIZE; 
    }

    // Number of pixels to draw, not counting the last

    INT  numPixels =  MajorEnd - MajorStart;
    BOOL endDone   = FALSE; 

    // There can be two or three pixels across the line

    INT  pixelWidth = MinorLast - MinorFirst + 1; 

    // Do the DDA loop. Two loops are implemented here. The 
    // first one is used in the case that the x coordinate of
    // the rectangle is close enough to the constant-y edges 
    // of the clip rectangle. In this case, it's a pain, since
    // we have to check each pixel that we are writing if it's
    // not outside. Thus, as soon as we notice that we are 
    // far from the edges we go to the other loop that doesn't 
    // check all that. All it checks is if it got close enough
    // to the other edge, in which case it comes back to this
    // loop, using the label last_part. firstOutDist, firstInDist, 
    // lastOutDist and lastInDist keeps track of the number of 
    // pixels between the first and last DDAs and the In and 
    // Out y-constant edges of the rectangle. 
    
    INT firstOutDist = (MinorOut - MinorFirst)*MinorDir; 

last_part: 

    INT firstInDist  = (MinorFirst - MinorIn)*MinorDir; 
    INT lastInDist   = (MinorLast - MinorIn)*MinorDir; 
    INT lastOutDist  = (MinorOut - MinorLast)*MinorDir; 

    while(numPixels > 0) 
    {
        numPixels--; 

last_pixel: 
        
        // Check if it's ok to write the first pixel 
                
        if(firstInDist >= 0 && firstOutDist >= 0)
        {
            buffer    = scan->NextBuffer(MinorFirst, MajorStart, 1);       
            *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaFirst));
        }
        else
        {
            // If the first DDA is out, and we are going in the 
            // positive direction, then the whole line is out and
            // we are done

            if(firstOutDist < 0 && MinorDir == 1)
            {
                goto end; 
            }
        }

        // If the line has 3 pixels across

        if(pixelWidth > 2)
        {
            // Check if it's ok to write the second pixel

            if(firstInDist >= -MinorDir && firstOutDist >= MinorDir)
            {
                buffer    = scan->NextBuffer(MinorFirst+1, MajorStart, 1);
                *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaMid));
            }
        }
        
        // Now check if it's ok to write the last one 

        if(lastInDist >= 0 && lastOutDist >= 0)
        {
            buffer    = scan->NextBuffer(MinorLast, MajorStart, 1);               
            *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaLast));
        }
        else
        {
            // If the first DDA is out, and we are going in the 
            // negative direction, then the whole line is out and
            // we are done

            if(lastOutDist < 0 && MinorDir == -1)
            {
                goto end; 
            }
        }

        // Update the errors

        ErrorFirst+= ErrorUp; 
        ErrorLast += ErrorUp; 
        MajorStart++; 

        if(ErrorFirst & TESTABOVE)
        {
            ErrorFirst -= ErrorDown; 
            MinorFirst += MinorDir;
            firstInDist++; 
            firstOutDist--; 
        }
        if(ErrorLast & TESTABOVE)
        {
            ErrorLast -= ErrorDown; 
            MinorLast += MinorDir; 
            lastInDist++; 
            lastOutDist--;
        }
        
        // Calculate the new alphas for the next line, and 
        // the width. 

        AlphaFirst = MAXALPHA - (ErrorFirst >> CONVERTALPHA); 
        AlphaLast  = (ErrorLast >> CONVERTALPHA); 
        AlphaMid   = MAXALPHA;             

        pixelWidth = MinorLast - MinorFirst + 1;             

        // Check to see if we can 'upgrade' to the next loop 

        if(firstInDist >= 3 && firstOutDist >= 3)
        {
            break;
        }
    }
    
    while(numPixels > 0) 
    {
        numPixels--; 

        // Get the scanline buffer buffer

        buffer = scan->NextBuffer(MinorFirst, MajorStart, pixelWidth);       

        // Write the value of the first DDA

        *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaFirst));

        // If there is a middle line, write its value. 

        if(pixelWidth > 2)
        {
            *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaMid));
        }
        
        // Write the value of the last (2nd or 3rd) DDA

        *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaLast));

        // Update the DDA 

        ErrorFirst+= ErrorUp; 
        ErrorLast += ErrorUp; 
        MajorStart++; 

        if(ErrorFirst & TESTABOVE)
        {
            ErrorFirst -= ErrorDown; 
            MinorFirst += MinorDir; 
            firstOutDist--; 
        }
        if(ErrorLast & TESTABOVE)
        {
            ErrorLast -= ErrorDown; 
            MinorLast += MinorDir; 
        }
        
        // Calculate the new alphas for the next line, and 
        // the width. 

        AlphaFirst = MAXALPHA - (ErrorFirst >> CONVERTALPHA); 
        AlphaLast  = (ErrorLast >> CONVERTALPHA); 
        AlphaMid   = MAXALPHA;             

        pixelWidth = MinorLast - MinorFirst + 1;             

        // Now check if it's time to go to the other loop
        // because we are too close to the out edge 

        if(firstOutDist < 3)
        {
            goto last_part;
        }
    }

    // Now if we haven't gotten here yet, do the last pixel 
    // and go once more through the loop. 

    if(!endDone) 
    {
        AlphaFirst = (AlphaFirst*FracEnd) >> FBITS; 
        AlphaLast  = (AlphaLast*FracEnd) >> FBITS; 
        AlphaMid   = (AlphaMid*FracEnd) >> FBITS; 
        
        endDone = TRUE; 
        goto last_pixel; 
    }

end:

    MajorEnd = saveMajor2; 
    FracEnd  = saveFracEnd; 
}



/**************************************************************************\
*
* Function Description:
*
* Draws a x major line taking clipping into account. It uses the member
* variables MajorIn, MajorOut, MinorIn, MinorOut of the class as the 
* clip rectangle. It advances untill the line is in the clip rectangle and 
* draws untill it gets out or the end point is reached. In the first case, 
* it leaves the DDA in a state so that it can be called again with another
* clipping rectangle. 
*
* Arguments:
*
*   [IN] DpScanBuffer - The scan buffer for accessing the surface. 

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

VOID
OnePixelLineDDAAntiAliased::DrawXMajorClip(
    DpScanBuffer *scan
    )
{
    ARGB *buffer;     
    INT maxWidth = scan->GetSurface()->Width;
    
    // Treat the special case where the line is just 
    // one pixel long. 

    if( MajorEnd == MajorStart)
    {
        // Check to see if the point is inside the rectangle 

        if((MajorStart >= MajorIn)  && 
           (MajorStart <= MajorOut) && 
           ((MinorStart - MinorIn)*MinorDir >= 0) && 
           ((MinorOut - MinorStart)*MinorDir >= 0))
        {
            buffer  = scan->NextBuffer( MajorStart, MinorStart, 1);
            *buffer = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaFirst));
        }
        return; 
    }

    // Save the real end and its fraction

    INT saveMajor2  = MajorEnd; 
    INT saveFracEnd = FracEnd; 
    
    // If the end major coordinate is out, mark that we must stop 
    // before. Also make the fraction be one, since the last 
    // one drawn now should not have a fraction

    if(MajorOut < MajorEnd)
    {
        MajorEnd = MajorOut; 
        FracEnd  = FSIZE; 
    }
    
    // Advance until the last DDA is in the right scan line and
    // is aligned with the In y-constant edge of the rectnagle

    INT numScans = (MinorIn - MinorLast)*MinorDir; 
    
    while((numScans > 0 && MajorLast <= MajorEnd) || MajorLast < MajorIn)
    {
        ErrorLast += ErrorUp;
        if(ErrorLast & TESTABOVE)
        {
            ErrorLast -= ErrorDown; 
            MinorLast += MinorDir; 
            numScans--; 
        }

        MajorLast++; 

        // Calculate the alpha for the current pixel 
        
        AlphaLast = AlphaBiasLast + MinorDir*ErrorLast;
    }
    
    // Do the same for the first DDA

    numScans = (MinorIn - MinorFirst)*MinorDir; 
    
    while((numScans > 0 && MajorFirst <= MajorEnd) || MajorFirst < MajorIn)
    {        
        ErrorFirst += ErrorUp;
        if(ErrorFirst & TESTABOVE)
        {
            ErrorFirst -= ErrorDown; 
            MinorFirst += MinorDir; 
            numScans--; 
        }

        MajorFirst++; 

        AlphaFirst = AlphaBiasFirst - MinorDir*ErrorFirst; 
    }
        
    // If there is no middle line in the first x-position, 
    // make the middle alpha full, since the start coverage 
    // won't apply

    if((MinorLast - MinorFirst) < 2)
    {
        AlphaMid = MAXALPHA; 
    }

    MinorStart = MinorFirst; 

    // The same way that was done in the non-clipping case, 
    // mock arround with the error so we won't draw the 
    // last DDA until the first DDA is in the same scan line, 
    // or has caught up. We need to adjust the alpha and minor
    // positions for this DDA to, so that when we start 
    // drawing they will have the right value 

    ErrorLast += MinorDir*(MinorLast - MinorFirst)*ErrorDown; 
    AlphaLast += (MinorLast - MinorFirst)*ErrorDown; 
    MinorLast -= (MinorLast - MinorFirst); 

    // Get the pointer to the buffer 
    
    buffer = scan->NextBuffer(MajorLast, MinorStart, maxWidth);
    
    INT width = 0; 
    INT alpha;                   
    INT middleMajor;

    while(MajorLast <= MajorEnd) 
    {
        // Fill the scan with the portion corresponding to the 
        // last line, which should come first. Keep doing it 
        // until the last line changes scan. 

        while(!(ErrorLast & TESTABOVE))
        {
            // Check if we passed or are at the last pixel
            if(MajorLast >= MajorEnd)
            {
                if(MajorLast == MajorEnd) 
                {
                    // If we are at, just update the alpha

                    AlphaLast  = (AlphaLast*FracEnd) >> FBITS; 
                }
                else
                {
                    // If we passed, we don't want to draw anymore. 
                    // Just adjust the error, alpha and minor so they
                    // will be right when they are corrected after this
                    // loop for the next scan

                    ErrorLast += ErrorDown; 
                    AlphaLast -= MinorDir*ErrorDown;             
                    MinorLast -= MinorDir; 
                    break; 
                }
            }
            *buffer++ = GpColor::PremultiplyWithCoverage(Color, 
                static_cast<BYTE>(AlphaLast >> CONVERTALPHA));
            ErrorLast += ErrorUp; 
            AlphaLast = AlphaBiasLast + MinorDir*ErrorLast; 
            width++; 
            MajorLast++; 
        }
        
        // Correct the values for the next scan

        ErrorLast -= ErrorDown; 
        AlphaLast -= MinorDir*ErrorDown;        
        MinorLast += MinorDir;         

        // Fill in the middle part. 

        middleMajor = MajorLast; 

        while(middleMajor < MajorFirst)
        {
            if( middleMajor == MajorEnd) 
            {
                AlphaMid = (AlphaMid*FracEnd) >> FBITS; 
            }
            *buffer++ = GpColor::PremultiplyWithCoverage(Color, static_cast<BYTE>(AlphaMid));
            AlphaMid = MAXALPHA; 
            width++;
            middleMajor++;
        }
    
        // Fill the scan with the portion corresponding to the 
        // first line, which should come first. Keep doing it 
        // until the last line changes scan. 

        while(!(ErrorFirst & TESTABOVE))
        {
            // Check for the end pixel, just like we 
            // did for the last DDA

            if(MajorFirst >= MajorEnd)
            {
                if(MajorFirst == MajorEnd) 
                {
                    AlphaFirst = (AlphaFirst*FracEnd) >> FBITS;
                }
                else
                {
                    ErrorFirst += ErrorDown; 
                    AlphaFirst -= MinorDir*ErrorDown;             
                    MinorFirst -= MinorDir; 
                    break; 
                }
            }
            *buffer++ = GpColor::PremultiplyWithCoverage(
                Color,
                static_cast<BYTE>(AlphaFirst >> CONVERTALPHA));
            ErrorFirst += ErrorUp; 
            AlphaFirst = AlphaBiasFirst - MinorDir*ErrorFirst; 
            width++; 
            MajorFirst++; 
        }
        
        // Correct the values for the next scan 

        ErrorFirst -= ErrorDown; 
        AlphaFirst += MinorDir*ErrorDown;             
        MinorFirst += MinorDir; 
    
        scan->UpdateWidth(width); 
    
        // Check to see if we have come to the end of the rectangle
        // through the minor coordinate crossing the Out edge
        // in the x-constant direction  

        if(MinorStart == MinorOut)
        {
            MinorStart += MinorDir; 
            break; 
        }

        // Update the minor coordinate and get the next buffer
        // if we aren't done yet.

        MinorStart += MinorDir; 
        if (MajorLast <= MajorEnd)
        {
            buffer = scan->NextBuffer(MajorLast, MinorStart, maxWidth); 
        }
        width = 0; 
    }

    scan->UpdateWidth(width);

    // Restore the old values 

    MajorEnd = saveMajor2; 
    FracEnd  = saveFracEnd;
}

//--------------------------------------------------------------------
// Auxiliary functions 
//--------------------------------------------------------------------


/**************************************************************************\
*
* Function Description:
*
* Clips the line against a rectangle. It assumes that the line endpoints 
* are stored in the class in floating point format. This sets an 
* order in which this function can be called. It must be after the 
* SetupCommon function and before the specific setups for antialiasing 
* and aliasing. This is a pain, but it's better than requirering on of
* these to have to know about clipping. The clipping here is done by 
* using the Slope and InvSlope members of the class to advance the 
* endpoints to the rectangle edges. Thus the function also assumes that
* Slope and InvSlope have been calculated.
*
* Arguments:
*
*   [IN] clipRect - The rectangle to clip against

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

BOOL 
OnePixelLineDDAAntiAliased::ClipRectangle(
    const GpRect* clipRect
    )
{

    INT clipBottom, clipTop, clipLeft, clipRight; 

    // Set the major and minor edges ef the clipping
    // region, converting to fixed point 28.4. Note that
    // we don't convert to the pixel center, but to a 
    // that goes all the way up to the pixel edges. This 
    // makes a difference for antialiasing. We don't go all
    // the way to the edge since some rounding rules could 
    // endup lihgting the next pixel outside of the clipping
    // area. That's why we add/subtract 7 instead of 8. 
    // The right and bottom are exclusive. 
    
    INT majorMin = (clipRect->GetLeft() << FBITS) - FHALFMASK;
    INT majorMax = ((clipRect->GetRight() - 1) << FBITS) + FHALFMASK; 
    INT minorMax = ((clipRect->GetBottom() - 1) << FBITS) + FHALFMASK; 
    INT minorMin = (clipRect->GetTop() << FBITS) - FHALFMASK; 

    if(!IsXMajor)
    {
        INT tmp; 
        tmp      = majorMin; 
        majorMin = minorMin; 
        minorMin = tmp; 
        tmp      = majorMax; 
        majorMax = minorMax; 
        minorMax = tmp; 
    }

    // First clip in the major coordinate 

    BOOL minOut, maxOut; 

    minOut = MajorStart < majorMin; 
    maxOut = MajorEnd > majorMax; 

    if( minOut || maxOut )
    {
        if(MajorStart > majorMax || MajorEnd < majorMin)
        {
            return FALSE; 
        }

        if(minOut)
        {
            MinorStart += GpFloor((majorMin - MajorStart)*Slope); 
            MajorStart = majorMin;
        }

        if(maxOut)
        {
            MinorEnd += GpFloor((majorMax - MajorEnd)*Slope); 
            MajorEnd = majorMax; 

            // If we clipped the last point, we don't need to be IsEndExclusive
            // anymore, as the last point now is not the line's last 
            // point but some in the middle. 

            IsEndExclusive = FALSE; 
        }
    }

    // Now clip the minor coordinate 

    INT *pMajor1, *pMinor1, *pMajor2, *pMinor2; 

    if(MinorDir == 1)
    {
        pMajor1 = &MajorStart; 
        pMajor2 = &MajorEnd; 
        pMinor1 = &MinorStart; 
        pMinor2 = &MinorEnd; 
    }
    else
    {
        pMajor1 = &MajorEnd; 
        pMajor2 = &MajorStart; 
        pMinor1 = &MinorEnd; 
        pMinor2 = &MinorStart; 
    }

    minOut = *pMinor1 < minorMin; 
    maxOut = *pMinor2 > minorMax; 

    if(minOut || maxOut)
    {
        if(*pMinor1 > minorMax || *pMinor2 < minorMin)
        {
            return FALSE; 
        }

        if(minOut)
        {
            *pMajor1 += GpFloor((minorMin - *pMinor1)*InvSlope); 
            *pMinor1 = minorMin;
        }

        if(maxOut)
        {
            *pMajor2 += GpFloor((minorMax - *pMinor2)*InvSlope); 
            *pMinor2 = minorMax;

            // If we clipped the last point, we don't need to be endExclusive
            // anymore, as the last point now is not the line's last 
            // point but some in the middle. 

            IsEndExclusive = FALSE; 
        }
    }

    return(TRUE); 
}

/**************************************************************************\
*
* Function Description:
*
* Draws a one-pixe-wide line with a solid color. Calls on the 
* OnePixelLineDDAAntiAliased class to do the actual drawing. 
*
* Arguments:
*
*   [IN] scan         - The DpScanBuffer to access the drawing surface 
*   [IN] clipRect     - A single rectangle that includes all the clipping 
*                       region. If there is no clipping, should be set to NULL.                          
*   [IN] clipRegionIn - A complex clipping region. If the clipping region is 
*                       simple, this should be NULL, and clipRect will be used. 
*   [IN] point1       - line end point 
*   [IN] point2       - line end point 
*   [IN] inColor      - the solid color
*   [IN] drawLast     - FALSE if the line is to be end-exclusive.
*   [IN] antiAliased  - TRUE if the line should be antialiased. 
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

GpStatus
DrawSolidLineOnePixelAntiAliased( 
    DpScanBuffer *scan, 
    const GpRect *clipRect, 
    const DpClipRegion* clipRegionIn, 
    GpPointF *point1, 
    GpPointF *point2,
    ARGB inColor,
    BOOL drawLast
    )
{
    // Take out the const for now because the Enumeration method
    // is not const. 

    DpClipRegion *clipRegion = const_cast<DpClipRegion*>(clipRegionIn); 

    // Setup the common part of the DDA

    OnePixelLineDDAAntiAliased dda; 

    if(!dda.SetupCommon(point1, point2, drawLast))
    {
        return Ok;
    }

    // Calculate the length of the line. Since we only use
    // it to determine the width, it shouldn't matter that
    // we convert the deltas from 28.4 before the multiplication. 

    INT d1 = dda.DMajor >> FBITS; 
    INT d2 = dda.DMinor >> FBITS;

    dda.LineLength = (REAL)sqrt((double)(d1*d1 + d2*d2)); 

    // Store the color, not premultiplied 

    dda.Color = inColor;         

    // Now handle the different clipping cases 

    if(!clipRect)
    {
        // This is easy, there is no clipping so just draw.

        if(!dda.SetupAntiAliased())
        {
            return Ok; 
        }

        (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 

        return Ok;
    }
    else
    {
        // The inverse of the Slope might be needed. 
       
        // Can't use the inverse slope if the slope is zero.
        if(dda.Slope==0.0F) 
        {
          dda.InvSlope=0.0F;
        } 
        else 
        {
          dda.InvSlope =  (1.0F/dda.Slope); 
        }

        // First of all clip against the bounding rectangle 

        if(!dda.ClipRectangle(clipRect))
        {
            return Ok;            
        }

        // Do the specific setup 

        if(!dda.SetupAntiAliased())
        {
            return Ok; 
        }

        // For each clip rectangle we store it's limits in 
        // an array of four elements. We then index this array using 
        // the variables below which depend on the slope and 
        // direction of the line in the following way: majorIn is edge crossed 
        // to go into the rect in the major direction, majorOut is the edge 
        // crossed to go out of the rect in the major direction, and so on.
        // The same for xIn, xOut, yIn, yOut. 

        INT majorIn, majorOut, minorIn, minorOut; 
        INT xIn, xOut, yIn, yOut;
        
        // Direction to enumerate the rectangles which depends on the 
        // line 

        DpClipRegion::Direction enumDirection; 
        
        INT clipBounds[4]; 
               
        // We store all our info in terms of major and minor 
        // direction, but to deal with cliping rectangles we
        // need to know them in terms of x and y, so calculate
        // xDir, yDir, the advance slope. 

        REAL xAdvanceRate; 
        INT  xDir, yDir; 
        INT  yEndLine;        
    
        // If the line crosses a span completely, (xStart, yStart)
        // is the position where it enters the span and (xEnd, yEnd)
        // is the position that it leaves. If it starts inside the 
        // span, then (xStart, yStart) is the start point

        REAL yStart, xStart, xEnd, yEnd; 

        if(dda.IsXMajor)
        {
            // Calculate the in-out indices

            majorIn  = xIn  = 0; 
            majorOut = xOut = 2; 
            if(dda.MinorDir == 1)
            {
                minorIn  = 1;
                minorOut = 3;
                enumDirection = DpClipRegion::TopLeftToBottomRight;
            }
            else
            {
                minorIn  = 3;
                minorOut = 1;
                enumDirection = DpClipRegion::BottomLeftToTopRight; 
            }
            
            yIn = minorIn;
            yOut = minorOut;

            // Make (xStart, yStart) be the initial point

            yStart = (REAL)dda.MinorStart; 
            xStart = (REAL)dda.MajorStart;

            xAdvanceRate = dda.InvSlope; 
            xDir = 1; 
            yDir = dda.MinorDir; 
            yEndLine =  dda.MinorEnd; 
        }
        else
        {
            majorIn = yIn =  1; 
            majorOut = yOut = 3; 
            if(dda.MinorDir == 1)
            {
                minorIn = 0;
                minorOut = 2;
                enumDirection = DpClipRegion::TopLeftToBottomRight;
            }
            else
            {
                minorIn = 2;
                minorOut = 0;
                enumDirection = DpClipRegion::TopRightToBottomLeft;
            }
            
            xIn = minorIn; 
            xOut = minorOut; 

            // Make (xStart, yStart) be the initial point

            yStart = (REAL)dda.MajorStart;
            xStart = (REAL)dda.MinorStart; 

            xAdvanceRate = dda.Slope; 
            xDir = dda.MinorDir; 
            yDir = 1;
            yEndLine = dda.MajorEnd; 
        }

        // Update the drawing function to the correct 
        // slipping version

        dda.DrawFuncIndex += FUNC_CLIP_OFFSET; 
    
        if(!clipRegion)
        {
            // In this case there is only a single rect, so just
            // draw clipped to that 

            // Store the rectangle in an array so we can atribute the 
            // right values to the MajorIn, majorOut, etc... variables. 
            // Remember that bottom and right are exclusive. 

            clipBounds[0] = clipRect->GetLeft(); 
            clipBounds[1] = clipRect->GetTop(); 
            clipBounds[2] = clipRect->GetRight() - 1; 
            clipBounds[3] = clipRect->GetBottom() - 1; 

            dda.MajorIn  = clipBounds[majorIn]; 
            dda.MajorOut = clipBounds[majorOut]; 
            dda.MinorIn  = clipBounds[minorIn]; 
            dda.MinorOut = clipBounds[minorOut]; 

            (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 

            return Ok;
        }
        else
        {
            BOOL agregating = FALSE; 
            INT  agregateBounds[4];

            // We have a complex clipping region. So what we'll do 
            // is clip against each individual rectangle in the 
            // cliping region. 

            clipRegion->StartEnumeration(GpFloor(yStart), enumDirection);            

            GpRect rect; 

            // Get the first rectangle. 

            INT numRects = 1;        

            clipRegion->Enumerate(&rect, numRects); 
            
            clipBounds[0] = rect.GetLeft(); 
            clipBounds[1] = rect.GetTop(); 
            clipBounds[2] = rect.GetRight() - 1; 
            clipBounds[3] = rect.GetBottom() - 1; 
            
            // Store the y position into the span 

            INT currSpanYMin = clipBounds[yIn]; 

            // We need some special treatment for the case where the 
            // line is horizontal, since is this case it's not going 
            // to cross different spans. And it it's not in the current
            // span, it's totally clipped out. 

            if(dda.IsXMajor && dda.ErrorUp == 0)
            {
                if(yStart >= clipBounds[1] && yStart <= clipBounds[3])
                {
                    xStart  = (REAL)dda.MajorStart;
                    xEnd    = (REAL)dda.MajorEnd; 
                }
                else
                {
                    return Ok; 
                }
            }
            else
            {
                if(yStart < clipBounds[1] || yStart > clipBounds[3])
                {
                    xStart  = xStart + (clipBounds[yIn] - yStart)*xAdvanceRate; 
                    yStart  = (REAL)clipBounds[yIn];
                }

                xEnd = xStart + (clipBounds[yOut] - yStart)*xAdvanceRate; 
            }
            
            yEnd = (REAL)clipBounds[yOut]; 

            while(1)
            {
                // Get to the first rectangle on the span that crosses the
                // line 
                
                while((xStart - clipBounds[xOut])*xDir > 0)
                {
                    numRects = 1; 
                    
                    clipRegion->Enumerate(&rect, numRects); 
                    
                    clipBounds[0] = rect.GetLeft(); 
                    clipBounds[1] = rect.GetTop(); 
                    clipBounds[2] = rect.GetRight() - 1; 
                    clipBounds[3] = rect.GetBottom() - 1; 

                    if(numRects != 1) 
                    {
                        goto draw_agregated;
                    }
                    if(clipBounds[yIn] != currSpanYMin)
                    {
                        goto process_next_span; 
                    }
                }

                // Draw on all the rectangles that intersect the 
                // line 

                if((xStart - clipBounds[xIn])*xDir > 0 && 
                   (clipBounds[xOut] - xEnd)*xDir > 0)
                {
                    if(agregating) 
                    {
                        if((clipBounds[xIn] - agregateBounds[xIn])*xDir < 0)
                        {
                            agregateBounds[xIn] = clipBounds[xIn];        
                        }
                        if((clipBounds[xOut] - agregateBounds[xOut])*xDir > 0)
                        {
                            agregateBounds[xOut] = clipBounds[xOut];        
                        }
                        agregateBounds[yOut] = clipBounds[yOut];
                    }
                    else
                    {
                        agregateBounds[0] = clipBounds[0];
                        agregateBounds[1] = clipBounds[1];
                        agregateBounds[2] = clipBounds[2];
                        agregateBounds[3] = clipBounds[3];

                        agregating = TRUE; 
                    }
                }
                else
                {
                    if(agregating)
                    {
                        dda.MajorIn  = agregateBounds[majorIn]; 
                        dda.MajorOut = agregateBounds[majorOut]; 
                        dda.MinorIn  = agregateBounds[minorIn]; 
                        dda.MinorOut = agregateBounds[minorOut]; 
            
                        (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 
                        
                        agregating = FALSE; 
                    }
                    while((xEnd - clipBounds[xIn])*xDir > 0)
                    {
                        dda.MajorIn  = clipBounds[majorIn]; 
                        dda.MajorOut = clipBounds[majorOut]; 
                        dda.MinorIn  = clipBounds[minorIn]; 
                        dda.MinorOut = clipBounds[minorOut]; 
            
                        (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 
                            
                        if(dda.MajorStart > dda.MajorEnd)
                        {
                            return Ok; 
                        }

                        numRects = 1; 
                        
                        clipRegion->Enumerate(&rect, numRects); 
                        
                        clipBounds[0] = rect.GetLeft(); 
                        clipBounds[1] = rect.GetTop(); 
                        clipBounds[2] = rect.GetRight() - 1; 
                        clipBounds[3] = rect.GetBottom() - 1; 
    
                        if(numRects != 1) 
                        {
                            goto draw_agregated;
                        }
                        if(clipBounds[yIn] != currSpanYMin)
                        {
                            goto process_next_span; 
                        }
                    }
                }
                // Get to the next span

                while(clipBounds[yIn] == currSpanYMin)
                {
                    numRects = 1; 
                    
                    clipRegion->Enumerate(&rect, numRects); 
                    
                    clipBounds[0] = rect.GetLeft(); 
                    clipBounds[1] = rect.GetTop(); 
                    clipBounds[2] = rect.GetRight() - 1; 
                    clipBounds[3] = rect.GetBottom() - 1; 

                    if(numRects != 1) 
                    {
                        goto draw_agregated;
                    }
                }

process_next_span:

                if((clipBounds[yIn] - yEndLine)*yDir > 0)
                {
                    // We are done. 
                    goto draw_agregated; 
                }

                if((clipBounds[yIn] - yEnd)*yDir == 1)
                {
                    xStart  = xEnd;
                }
                else
                {
                    if(agregating)
                    {
                        dda.MajorIn  = agregateBounds[majorIn]; 
                        dda.MajorOut = agregateBounds[majorOut]; 
                        dda.MinorIn  = agregateBounds[minorIn]; 
                        dda.MinorOut = agregateBounds[minorOut]; 
                        
                        (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 
                        
                        if(dda.MajorStart > dda.MajorEnd)
                        {
                            return Ok; 
                        }

                        agregating = FALSE; 
                    }

                    xStart  = xStart + (clipBounds[yIn] - yStart)*xAdvanceRate;
                }

                yStart  = (REAL)clipBounds[yIn];                 
                xEnd    = xStart + (clipBounds[yOut] - yStart)*xAdvanceRate; 
                yEnd    = (REAL)clipBounds[yOut];
                currSpanYMin = GpFloor(yStart); 
            }

draw_agregated: 

            if(agregating)
            {
                dda.MajorIn  = agregateBounds[majorIn]; 
                dda.MajorOut = agregateBounds[majorOut]; 
                dda.MinorIn  = agregateBounds[minorIn]; 
                dda.MinorOut = agregateBounds[minorOut]; 
                
                (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan);                 
            }

        }
    }

    return Ok; 
}

#endif // AAONEPIXELLINE_SUPPORT

#pragma optimize("a", off)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\aarasterizer.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   AARasterizer.cpp
*
* Abstract:
*
*   Contains all the code for rasterizing the fill of a path.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

#include "precomp.hpp"

#include <limits.h>

#if DBG
    #define ASSERTACTIVELIST(list, y) AssertActiveList(list, y)
    #define ASSERTACTIVELISTORDER(list) AssertActiveListOrder(list)
    #define ASSERTINACTIVEARRAY(list, count) AssertInactiveArray(list, count)
    #define ASSERTPATH(path) AssertPath(path)
#else
    #define ASSERTACTIVELIST(list, y)
    #define ASSERTACTIVELISTORDER(list)
    #define ASSERTINACTIVEARRAY(list, count)
    #define ASSERTPATH(path)
#endif

// Define our on-stack storage use.  The 'free' versions are nicely tuned
// to avoid allocations in most common scenarios, while at the same time
// not chewing up toooo much stack space.  
//
// We make the debug versions small so that we hit the 'grow' cases more
// frequently, for better testing:

#if DBG
    #define EDGE_STORE_STACK_NUMBER 10
    #define EDGE_STORE_ALLOCATION_NUMBER 11
    #define INACTIVE_LIST_NUMBER 12
    #define ENUMERATE_BUFFER_NUMBER 15
    #define INTERVAL_BUFFER_NUMBER 8        // Must be at least 4
    #define NOMINAL_FILL_POINT_NUMBER 4     // Must be at least 4
#else    
    #define EDGE_STORE_STACK_NUMBER (1600 / sizeof(EpEdge))
    #define EDGE_STORE_ALLOCATION_NUMBER (4032 / sizeof(EpEdge))
    #define INACTIVE_LIST_NUMBER EDGE_STORE_STACK_NUMBER
    #define ENUMERATE_BUFFER_NUMBER 32
    #define INTERVAL_BUFFER_NUMBER 32
    #define NOMINAL_FILL_POINT_NUMBER 32
#endif

class EpEdgeStore;

// 'EpEdge' is our classic data structure for tracking an edge:

struct EpEdge
{
    EpEdge *Next;               // Next active edge (don't check for NULL,
                                //   look for tail sentinel instead)
    INT X;                      // Current X location
    INT Dx;                     // X increment
    INT Error;                  // Current DDA error
    INT ErrorUp;                // Error increment
    INT ErrorDown;              // Error decrement when the error rolls over
    INT StartY;                 // Y-row start
    INT EndY;                   // Y-row end
    INT WindingDirection;       // -1 or 1
};

// We the inactive-array separate from the edge allocations so that
// we can more easily do in-place sorts on it:

struct EpInactiveEdge
{
    EpEdge *Edge;               // Associated edge
    LONGLONG Yx;                // Sorting key, StartY and X packed into an lword
};

// We allocate room for our edge datastructures in batches:

struct EpEdgeAllocation
{
    EpEdgeAllocation *Next;     // Next allocation batch (may be NULL)
    INT Count;
    EpEdge EdgeArray[EDGE_STORE_STACK_NUMBER];
};

// The following is effectively the paramter list for 'InitializeEdges',
// which takes a run of points and sets up the initial edge list:

struct EpInitializeEdgesContext
{
    INT MaxY;                   // Maximum 'y' found, should be INT_MIN on
                                //   first call to 'InitializeEdges'
    RECT* ClipRect;             // Bounding clip rectangle in 28.4 format
    EpEdgeStore *Store;         // Where to stick the edges
    BOOL IsAntialias;           // The edges are going to be rendered
                                //   using antialiasing super-sampling
};

// Interval coverage descriptor for our antialiased filler:

struct EpInterval
{
    INT X;                      // Interval's left edge (Next->X is the 
                                //   right edge)
    INT Depth;                  // Number of layers that this interval has
                                //   been covered
    EpInterval *Next;           // Next interval (look for sentinel, not NULL)
};

// Allocator structure for the antialiased fill interval data:

struct EpIntervalBuffer
{
    EpIntervalBuffer *Next;
    EpInterval Interval[INTERVAL_BUFFER_NUMBER];
};

/**************************************************************************\
*
* Class Description:
*
*  'EpEdgeStore' is used by 'InitializeEdges' as its repository for
*   all the edge data:
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

class EpEdgeStore
{
private:

    INT TotalCount;                 // Total edge count in store
    INT CurrentRemaining;           // How much room remains in current buffer
    EpEdgeAllocation *CurrentBuffer;// Current buffer
    EpEdge *CurrentEdge;            // Current edge in current buffer
    EpEdgeAllocation *Enumerator;   // For enumerating all the edges
    EpEdgeAllocation EdgeHead;      // Our built-in allocation

public:

    EpEdgeStore()
    {
        TotalCount = 0;
        CurrentBuffer = &EdgeHead;
        CurrentEdge = &EdgeHead.EdgeArray[0];
        CurrentRemaining = EDGE_STORE_STACK_NUMBER;

        EdgeHead.Count = EDGE_STORE_STACK_NUMBER;
        EdgeHead.Next = NULL;
    }

    ~EpEdgeStore()
    {
        // Free our allocation list, skipping the head, which is not
        // dynamically allocated:

        EpEdgeAllocation *allocation = EdgeHead.Next;
        while (allocation != NULL)
        {
            EpEdgeAllocation *next = allocation->Next;
            GpFree(allocation);
            allocation = next;
        }
    }

    INT StartEnumeration()
    {
        Enumerator = &EdgeHead;

        // Update the count and make sure nothing more gets added (in
        // part because this Count would have to be re-computed):

        CurrentBuffer->Count -= CurrentRemaining;
        TotalCount += CurrentBuffer->Count;

        // Prevent this from being called again, because bad things would
        // happen:

        CurrentBuffer = NULL;

        return(TotalCount);
    }

    BOOL Enumerate(EpEdge** startEdge, EpEdge** endEdge)
    {
        EpEdgeAllocation *enumerator = Enumerator;
    
        // Might return startEdge == endEdge:
    
        *startEdge = &enumerator->EdgeArray[0];
        *endEdge = &enumerator->EdgeArray[Enumerator->Count];
    
        return((Enumerator = enumerator->Next) != NULL);
    }

    VOID StartAddBuffer(EpEdge **currentEdge, INT *remaining)
    {
        *currentEdge = CurrentEdge;
        *remaining = CurrentRemaining;
    }

    VOID EndAddBuffer(EpEdge *currentEdge, INT remaining)
    {
        CurrentEdge = currentEdge;
        CurrentRemaining = remaining;
    }

    BOOL NextAddBuffer(EpEdge **currentEdge, INT *remaining);
};

/**************************************************************************\
*
* Function Description:
*
*   The edge initializer is out of room in its current 'store' buffer;
*   get it a new one.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

BOOL
EpEdgeStore::NextAddBuffer(
    EpEdge **currentEdge,
    INT *remaining
    )
{
    // The caller has completely filled up this chunk:

    ASSERT(*remaining == 0);

    // We have to grow our data structure by adding a new buffer
    // and adding it to the list:

    EpEdgeAllocation *newBuffer = static_cast<EpEdgeAllocation*>
        (GpMalloc(sizeof(EpEdgeAllocation) +
                  sizeof(EpEdge) * (EDGE_STORE_ALLOCATION_NUMBER
                                  - EDGE_STORE_STACK_NUMBER)));
    if (newBuffer == NULL)
        return(FALSE);

    newBuffer->Next = NULL;
    newBuffer->Count = EDGE_STORE_ALLOCATION_NUMBER;

    TotalCount += CurrentBuffer->Count;

    CurrentBuffer->Next = newBuffer;
    CurrentBuffer = newBuffer;

    *currentEdge = CurrentEdge = &newBuffer->EdgeArray[0];
    *remaining = CurrentRemaining = EDGE_STORE_ALLOCATION_NUMBER;

    return(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Some debug code for verifying the state of the active edge list.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

BOOL
AssertActiveList(
    const EpEdge *list, 
    INT yCurrent
    )
{
    BOOL b = TRUE;
    INT activeCount = 0;

    ASSERT(list->X == INT_MIN);
    b &= (list->X == INT_MIN);

    // Skip the head sentinel:

    list = list->Next;

    while (list->X != INT_MAX)
    {
        ASSERT(list->X != INT_MIN);
        b &= (list->X != INT_MIN);

        ASSERT(list->X <= list->Next->X);
        b &= (list->X <= list->Next->X);

        ASSERT((list->StartY <= yCurrent) && (yCurrent < list->EndY));
        b &= ((list->StartY <= yCurrent) && (yCurrent < list->EndY));

        activeCount++;
        list = list->Next;
    }

    ASSERT(list->X == INT_MAX);
    b &= (list->X == INT_MAX);

    // There should always be a multiple of 2 edges in the active list.
    //
    // NOTE: If you hit this assert, do NOT simply comment it out!
    //       It usually means that all the edges didn't get initialized
    //       properly.  For every scan-line, there has to be a left edge
    //       and a right edge (or a mulitple thereof).  So if you give
    //       even a single bad edge to the edge initializer (or you miss 
    //       one), you'll probably hit this assert.

    ASSERT((activeCount & 1) == 0);
    b &= ((activeCount & 1) == 0);

    return(b);
}

/**************************************************************************\
*
* Function Description:
*
*   Some debug code for verifying the state of the active edge list.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID
AssertActiveListOrder(
    const EpEdge *list
    )
{
    INT activeCount = 0;

    ASSERT(list->X == INT_MIN);

    // Skip the head sentinel:

    list = list->Next;

    while (list->X != INT_MAX)
    {
        ASSERT(list->X != INT_MIN);
        ASSERT(list->X <= list->Next->X);

        activeCount++;
        list = list->Next;
    }

    ASSERT(list->X == INT_MAX);
}

/**************************************************************************\
*
* Class Description:
*
*   Base class for all our fill routines.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

class EpFiller : public DpOutputSpan
{
public:

    virtual BOOL IsValid() const { return(TRUE); }

};

typedef VOID (FASTCALL EpFiller::*EpFillerFunction)(EpEdge *, INT);

/**************************************************************************\
*
* Class Description:
*
*   Antialised filler state.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

class EpAntialiasedFiller : public EpFiller
{
private:

    INT Y;                              // Current scan
    DpOutputSpan *Output;
    DpOutputSpan *Clipper;
    EpInterval *StartInterval;          // Points to list head entry
    EpInterval *NewInterval;
    EpInterval *EndIntervalMinus2;
    EpIntervalBuffer BuiltinBuffer;
    EpIntervalBuffer *CurrentBuffer;

public:

    EpAntialiasedFiller(DpOutputSpan *output)
    {
        Output = output;
        Clipper = this;

        BuiltinBuffer.Interval[0].X = INT_MIN;
        BuiltinBuffer.Interval[0].Depth = 0;
        BuiltinBuffer.Interval[0].Next = &BuiltinBuffer.Interval[1];

        BuiltinBuffer.Interval[1].X = INT_MAX;
        BuiltinBuffer.Interval[1].Depth = 0xdeadbeef;
        BuiltinBuffer.Interval[1].Next = NULL;

        BuiltinBuffer.Next = NULL;
        CurrentBuffer = &BuiltinBuffer;

        StartInterval = &BuiltinBuffer.Interval[0];
        NewInterval = &BuiltinBuffer.Interval[2];
        EndIntervalMinus2 = &BuiltinBuffer.Interval[INTERVAL_BUFFER_NUMBER - 2];
    }

    ~EpAntialiasedFiller()
    {
        GenerateOutputAndClearCoverage(Y);

        // Free the linked-list of allocations (skipping 'BuiltinBuffer',
        // which is built into the class):

        EpIntervalBuffer *buffer = BuiltinBuffer.Next;
        while (buffer != NULL)
        {
            EpIntervalBuffer *nextBuffer = buffer->Next;
            GpFree(buffer);
            buffer = nextBuffer;
        }
    }

    VOID SetClipper(DpOutputSpan *clipper)
    {
        Clipper = clipper;
    }

    VOID FASTCALL FillEdgesAlternate(const EpEdge *active, INT yCurrent);

    VOID FASTCALL FillEdgesWinding(const EpEdge *active, INT yCurrent);

    BOOL Grow(EpInterval **newInterval, EpInterval**endIntervalMinus2);

    VOID GenerateOutputAndClearCoverage(INT yCurrent);

    virtual GpStatus OutputSpan(INT y, INT left, INT right);
};

/**************************************************************************\
*
* Function Description:
*
*   Grow our interval buffer.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

BOOL 
EpAntialiasedFiller::Grow(
    EpInterval **newInterval, 
    EpInterval **endIntervalMinus2
    )
{
    EpIntervalBuffer *newBuffer = CurrentBuffer->Next;
    if (!newBuffer)
    {
        newBuffer = static_cast<EpIntervalBuffer*>
                        (GpMalloc(sizeof(EpIntervalBuffer)));
        if (!newBuffer)
            return(FALSE);

        newBuffer->Next = NULL;
        CurrentBuffer->Next = newBuffer;
    }

    CurrentBuffer = newBuffer;

    NewInterval = &newBuffer->Interval[2];
    EndIntervalMinus2 = &newBuffer->Interval[INTERVAL_BUFFER_NUMBER - 2];

    *newInterval = NewInterval;
    *endIntervalMinus2 = EndIntervalMinus2;

    return(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Given the active edge list for the current scan, do an alternate-mode
*   antialiased fill.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID
FASTCALL
EpAntialiasedFiller::FillEdgesAlternate(
    const EpEdge *activeList,
    INT yCurrent
    )
{
    EpInterval *interval = StartInterval;
    EpInterval *newInterval = NewInterval;
    EpInterval *endIntervalMinus2 = EndIntervalMinus2;
    const EpEdge *startEdge = activeList->Next;
    const EpEdge *endEdge;
    INT left;
    INT right;
    INT nextX;

    ASSERTACTIVELIST(activeList, yCurrent);

    while (startEdge->X != INT_MAX)
    {
        endEdge = startEdge->Next;

        // We skip empty pairs:

        if ((left = startEdge->X) != endEdge->X)
        {
            // We now know we have a non-empty interval.  Skip any
            // empty interior pairs:

            while ((right = endEdge->X) == endEdge->Next->X)
                endEdge = endEdge->Next->Next;

            ASSERT((left < right) && (right < INT_MAX));

            // Make sure we have enough room to add two intervals if
            // necessary:

            if (newInterval >= endIntervalMinus2)
            {
                if (!Grow(&newInterval, &endIntervalMinus2))
                    break;      // ==============>
            }

            // Skip any intervals less than 'left':

            while ((nextX = interval->Next->X) < left)
                interval = interval->Next;

            // Insert a new interval if necessary:

            if (nextX != left)
            {
                newInterval->X = left;
                newInterval->Depth = interval->Depth + 1;
                newInterval->Next = interval->Next;

                interval->Next = newInterval;
                interval = newInterval;
                newInterval++;
            }

            // Increase the coverage for any intervals between 'left'
            // and 'right':

            while ((nextX = interval->Next->X) < right)
            {
                interval = interval->Next;
                interval->Depth++;
            }

            // Insert another new interval if necessary:

            if (nextX != right)
            {
                newInterval->X = right;
                newInterval->Depth = interval->Depth - 1;
                newInterval->Next = interval->Next;

                interval->Next = newInterval;
                interval = newInterval;
                newInterval++;
            }
        }

        // Prepare for the next iteration:

        startEdge = endEdge->Next;
    } 

    NewInterval = newInterval;
    Y = yCurrent;

    // If the next scan is done, output what's there:

    if (((yCurrent + 1) & AA_Y_MASK) == 0)
    {
        GenerateOutputAndClearCoverage(yCurrent);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Given the active edge list for the current scan, do a winding-mode
*   antialiased fill.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID
FASTCALL
EpAntialiasedFiller::FillEdgesWinding(
    const EpEdge *activeList,
    INT yCurrent
    )
{
    EpInterval *interval = StartInterval;
    EpInterval *newInterval = NewInterval;
    EpInterval *endIntervalMinus2 = EndIntervalMinus2;
    const EpEdge *startEdge = activeList->Next;
    const EpEdge *endEdge;
    INT left;
    INT right;
    INT nextX;
    INT windingValue;

    ASSERTACTIVELIST(activeList, yCurrent);

    while (startEdge->X != INT_MAX)
    {
        endEdge = startEdge->Next;

        windingValue = startEdge->WindingDirection;
        while ((windingValue += endEdge->WindingDirection) != 0)
            endEdge = endEdge->Next;

        ASSERT(endEdge->X != INT_MAX);

        // We skip empty pairs:

        if ((left = startEdge->X) != endEdge->X)
        {
            // We now know we have a non-empty interval.  Skip any
            // empty interior pairs:

            while ((right = endEdge->X) == endEdge->Next->X)
            {
                startEdge = endEdge->Next;
                endEdge = startEdge->Next;

                windingValue = startEdge->WindingDirection;
                while ((windingValue += endEdge->WindingDirection) != 0)
                    endEdge = endEdge->Next;
            }

            ASSERT((left < right) && (right < INT_MAX));

            // Make sure we have enough room to add two intervals if
            // necessary:

            if (newInterval >= endIntervalMinus2)
            {
                if (!Grow(&newInterval, &endIntervalMinus2))
                    break;      // ==============>
            }

            // Skip any intervals less than 'left':

            while ((nextX = interval->Next->X) < left)
                interval = interval->Next;

            // Insert a new interval if necessary:

            if (nextX != left)
            {
                newInterval->X = left;
                newInterval->Depth = interval->Depth + 1;
                newInterval->Next = interval->Next;

                interval->Next = newInterval;
                interval = newInterval;
                newInterval++;
            }

            // Increase the coverage for any intervals between 'left'
            // and 'right':

            while ((nextX = interval->Next->X) < right)
            {
                interval = interval->Next;
                interval->Depth++;
            }

            // Insert another new interval if necessary:

            if (nextX != right)
            {
                newInterval->X = right;
                newInterval->Depth = interval->Depth - 1;
                newInterval->Next = interval->Next;

                interval->Next = newInterval;
                interval = newInterval;
                newInterval++;
            }
        }

        // Prepare for the next iteration:

        startEdge = endEdge->Next;
    } 

    NewInterval = newInterval;
    Y = yCurrent;

    // If the next scan is done, output what's there:

    if (((yCurrent + 1) & AA_Y_MASK) == 0)
    {
        GenerateOutputAndClearCoverage(yCurrent);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Now that it's been clipped, produce the pixels and modify their
*   alpha values according to the antialiased coverage.
*
* Created:
*
*   03/17/2000 andrewgo
*
\**************************************************************************/

GpStatus
EpAntialiasedFiller::OutputSpan(
    INT y,          // Non-scaled coordinates
    INT left,
    INT right
    ) 
{
    ASSERT(right > left);

    // First ask the 'producer' to actually generate the pixels for us.
    // Then we need to simply whack the pixel buffer with the coverage
    // values we've generated.

    Output->OutputSpan(y, left, right);

    // Retrieve a pointer to the buffer that the 'producer' just wrote
    // the pixels to:

    UCHAR *buffer = reinterpret_cast<UCHAR*> 
                        (Output->GetScanBuffer()->GetCurrentBuffer());

    EpInterval *coverage = StartInterval;

    // Figure out the end of the last pixel, remembering that 'right'
    // is exclusive:

    INT scaledRight = right << AA_X_SHIFT;

    // Skip any intervals that might have been completely clipped out:

    INT pixelLeftEdge = left << AA_X_SHIFT;
    while (coverage->Next->X < pixelLeftEdge)
        coverage = coverage->Next;

    INT pixelRightEdge = pixelLeftEdge + AA_X_WIDTH;

    while (pixelLeftEdge < scaledRight)
    {
        UINT coverageValue;

        // Compute the coverage coming into the first pixel:

        if (coverage->Next->X > pixelRightEdge)
        {
            // The interval extends out the end of the pixel:

            coverageValue = (pixelRightEdge - max(pixelLeftEdge, coverage->X))
                          * coverage->Depth;
        }
        else
        {
            // The interval ends in our pixel:

            coverageValue = (coverage->Next->X - max(pixelLeftEdge, coverage->X))
                          * coverage->Depth;

            coverage = coverage->Next;
    
            // Add in any coverages for intervals contained entirely within the
            // pixel:
    
            while (coverage->Next->X < pixelRightEdge)
            {
                coverageValue += (coverage->Next->X - coverage->X) * coverage->Depth;
                coverage = coverage->Next;
            }
    
            // Add in the coverage for the interval going out of the pixel:
    
            coverageValue += (pixelRightEdge - max(coverage->X, pixelLeftEdge)) 
                           * coverage->Depth;
        }

        // We've goofed if we get a coverage value more than is theoretically
        // possible, or if it's zero (in the latter case, it should have
        // been filtered already by our caller).

        ASSERT(coverageValue <= (1 << (AA_X_SHIFT + AA_Y_SHIFT)));
        ASSERT(coverageValue != 0);

        // Modify the pixel's alpha channel according to the coverage values:

    #if !defined(NO_PREMULTIPLIED_ALPHA)
        *(buffer+0) = MULTIPLY_COVERAGE(*(buffer+0), coverageValue, AA_X_SHIFT + AA_Y_SHIFT);
        *(buffer+1) = MULTIPLY_COVERAGE(*(buffer+1), coverageValue, AA_X_SHIFT + AA_Y_SHIFT);
        *(buffer+2) = MULTIPLY_COVERAGE(*(buffer+2), coverageValue, AA_X_SHIFT + AA_Y_SHIFT);
    #endif
        *(buffer+3) = MULTIPLY_COVERAGE(*(buffer+3), coverageValue, AA_X_SHIFT + AA_Y_SHIFT);
        buffer += 4; 

        // Now handle the part of the current interval that completely covers 
        // more than one pixel (if it does):

        UINT consecutivePixels = (min(coverage->Next->X, scaledRight) 
                                  - pixelRightEdge) >> AA_X_SHIFT;

        UINT depth = coverage->Depth;

        // By definition, we shouldn't have an interval with zero coverage
        // (it should have been filtered out by our caller).  We won't fall
        // over, but it would be the wrong thing to do for SrcCopy mode.

        ASSERT((consecutivePixels == 0) || (depth != 0));

        if (depth == AA_Y_HEIGHT)
        {
            // All these pixels are completely covered.  Woo hoo, no work to 
            // do!

            buffer += (4 * consecutivePixels);
        }
        else
        {
            // Go through the run and multiply the alpha values by the run's
            // coverage:

            UINT i = consecutivePixels;
            while (i-- != 0)
            {
            #if !defined(NO_PREMULTIPLIED_ALPHA)
                *(buffer+0) = MULTIPLY_COVERAGE(*(buffer+0), depth, AA_Y_SHIFT);
                *(buffer+1) = MULTIPLY_COVERAGE(*(buffer+1), depth, AA_Y_SHIFT);
                *(buffer+2) = MULTIPLY_COVERAGE(*(buffer+2), depth, AA_Y_SHIFT);
            #endif
                *(buffer+3) = MULTIPLY_COVERAGE(*(buffer+3), depth, AA_Y_SHIFT);
                buffer += 4;
            }
        }

        // Prepare for the next iteration through the loop:

        pixelLeftEdge += ((consecutivePixels + 1) << AA_X_SHIFT);
        pixelRightEdge += ((consecutivePixels + 1) << AA_X_SHIFT);
    }

    return(Ok);
}

/**************************************************************************\
*
* Function Description:
*
*   Given complete interval data for a scan, find runs of touched pixels
*   and then call the clipper (or directly to the rendering routine if
*   there's no clipping).
*
* Created:
*
*   03/17/2000 andrewgo
*
\**************************************************************************/

VOID
EpAntialiasedFiller::GenerateOutputAndClearCoverage(
    INT yScaled
    )
{
    EpInterval *spanStart = StartInterval->Next;
    EpInterval *spanEnd;

    while (spanStart->X != INT_MAX)
    {
        ASSERT(spanStart->Depth != 0);

        // Here we determine the length of a continuous run of covered
        // pixels.  For the case where the user has set the mode to 
        // SRCCOPY, it's very important that we don't accidentally pass 
        // off as 'covered' a pixel that we later realize wasn't covered.

        spanEnd = spanStart->Next;
        while ((spanEnd->Depth != 0) ||
               ((spanEnd->Next->X & ~AA_X_MASK) == (spanEnd->X & ~AA_X_MASK)))
        {
            spanEnd = spanEnd->Next;
        }

        // Figure out the actual integer pixel values.  

        INT left = spanStart->X >> AA_X_SHIFT;                   // inclusive
        INT right = (spanEnd->X + AA_X_WIDTH - 1) >> AA_X_SHIFT; // exclusive
        INT y = yScaled >> AA_Y_SHIFT;

        // If there's no clip region, this jumps to EpAntialiasedFiller::
        // OutputSpan:

        Clipper->OutputSpan(y, left, right);

        // Advance to after the gap:

        spanStart = spanEnd->Next;
    }

    // Reset our coverage structure.  Point the head back to the tail,
    // and reset where the next new entry will be placed:

    BuiltinBuffer.Interval[0].Next = &BuiltinBuffer.Interval[1];

    CurrentBuffer = &BuiltinBuffer;
    NewInterval = &BuiltinBuffer.Interval[2];
    EndIntervalMinus2 = &BuiltinBuffer.Interval[INTERVAL_BUFFER_NUMBER - 2];
}

/**************************************************************************\
*
* Class Description:
*
*   Aliased filler state.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

class EpAliasedFiller : public EpFiller
{
private:
    DpOutputSpan *Output;

public:

    EpAliasedFiller(DpOutputSpan *output)
    {
        Output = output;
    }

    VOID SetOutputSpan(DpOutputSpan *output)
    {
        Output = output;
    }

    VOID FASTCALL FillEdgesAlternate(const EpEdge *active, INT yCurrent);

    VOID FASTCALL FillEdgesWinding(const EpEdge *active, INT yCurrent);

    virtual GpStatus OutputSpan(INT y, INT left, INT right) { return Ok; }
};

/**************************************************************************\
*
* Function Description:
*
*   Given the active edge list for the current scan, do an alternate-mode
*   aliased fill.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID 
FASTCALL
EpAliasedFiller::FillEdgesAlternate(
    const EpEdge *activeList,
    INT yCurrent
    )
{
    const EpEdge *startEdge = activeList->Next;
    const EpEdge *endEdge;
    INT left;
    INT right;
    INT nextX;

    ASSERTACTIVELIST(activeList, yCurrent);

    while (startEdge->X != INT_MAX)
    {
        endEdge = startEdge->Next;

        ASSERT(endEdge->X != INT_MAX);

        // We skip empty pairs:

        if ((left = startEdge->X) != endEdge->X)
        {
            // We now know we have a non-empty interval.  Skip any
            // empty interior pairs:

            while ((right = endEdge->X) == endEdge->Next->X)
                endEdge = endEdge->Next->Next;

            ASSERT((left < right) && (right < INT_MAX));

            Output->OutputSpan(yCurrent, left, right);
        }

        // Prepare for the next iteration:

        startEdge = endEdge->Next;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Given the active edge list for the current scan, do a winding-mode
*   aliased fill.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID 
FASTCALL
EpAliasedFiller::FillEdgesWinding(
    const EpEdge *activeList,
    INT yCurrent
    )
{
    const EpEdge *startEdge = activeList->Next;
    const EpEdge *endEdge;
    INT left;
    INT right;
    INT nextX;
    INT windingValue;

    ASSERTACTIVELIST(activeList, yCurrent);

    while (startEdge->X != INT_MAX)
    {
        endEdge = startEdge->Next;

        windingValue = startEdge->WindingDirection;
        while ((windingValue += endEdge->WindingDirection) != 0)
            endEdge = endEdge->Next;

        ASSERT(endEdge->X != INT_MAX);

        // We skip empty pairs:

        if ((left = startEdge->X) != endEdge->X)
        {
            // We now know we have a non-empty interval.  Skip any
            // empty interior pairs:

            while ((right = endEdge->X) == endEdge->Next->X)
            {
                startEdge = endEdge->Next;
                endEdge = startEdge->Next;

                windingValue = startEdge->WindingDirection;
                while ((windingValue += endEdge->WindingDirection) != 0)
                    endEdge = endEdge->Next;
            }

            ASSERT((left < right) && (right < INT_MAX));

            Output->OutputSpan(yCurrent, left, right);
        }

        // Prepare for the next iteration:

        startEdge = endEdge->Next;
    }
}

#ifdef BEZIER_FLATTEN_GDI_COMPATIBLE

// GDI flattens using an error of 2/3

// Flatten to an error of 2/3.  During initial phase, use 18.14 format.

#define TEST_MAGNITUDE_INITIAL    (6 * 0x00002aa0L)

// Error of 2/3.  During normal phase, use 15.17 format.

#define TEST_MAGNITUDE_NORMAL     (TEST_MAGNITUDE_INITIAL << 3)

#else

// Use a higher flattening tolerance. Turns out that 2/3 produces very 
// noticable artifacts on antialiased lines.

// Flatten to an error of 1/4.  During initial phase, use 18.14 format.

#define TEST_MAGNITUDE_INITIAL    (6 * 0x00001000L)

// Error of 1/4.  During normal phase, use 15.17 format.

#define TEST_MAGNITUDE_NORMAL     (TEST_MAGNITUDE_INITIAL << 3)

#endif

/**********************************Class***********************************\
* class HfdBasis32
*
*   Class for HFD vector objects.
*
* Public Interface:
*
*   vInit(p1, p2, p3, p4)       - Re-parameterizes the given control points
*                                 to our initial HFD error basis.
*   vLazyHalveStepSize(cShift)  - Does a lazy shift.  Caller has to remember
*                                 it changes 'cShift' by 2.
*   vSteadyState(cShift)        - Re-parameterizes to our working normal
*                                 error basis.
*
*   vTakeStep()                 - Forward steps to next sub-curve
*   vHalveStepSize()            - Adjusts down (subdivides) the sub-curve
*   vDoubleStepSize()           - Adjusts up the sub-curve
*   lError()                    - Returns error if current sub-curve were
*                                 to be approximated using a straight line
*                                 (value is actually multiplied by 6)
*   fxValue()                   - Returns rounded coordinate of first point in
*                                 current sub-curve.  Must be in steady
*                                 state.
*
* History:
*  10-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

// The code is actually smaller when these methods are forced inline;
// this is one of the rare cases where 'forceinline' is warranted:

#define INLINE __forceinline

class HfdBasis32
{
private:
    LONG  e0;
    LONG  e1;
    LONG  e2;
    LONG  e3;

public:
    INLINE LONG lParentErrorDividedBy4() 
    { 
        return(max(abs(e3), abs(e2 + e2 - e3))); 
    }

    INLINE LONG lError()                 
    { 
        return(max(abs(e2), abs(e3))); 
    }

    INLINE INT fxValue()                
    { 
        return((e0 + (1L << 12)) >> 13); 
    }

    INLINE VOID vInit(INT p1, INT p2, INT p3, INT p4)
    {
    // Change basis and convert from 28.4 to 18.14 format:
    
        e0 = (p1                     ) << 10;
        e1 = (p4 - p1                ) << 10;
        e2 = (3 * (p2 - p3 - p3 + p4)) << 11;
        e3 = (3 * (p1 - p2 - p2 + p3)) << 11;
    }
    
    INLINE VOID vLazyHalveStepSize(LONG cShift)
    {
        e2 = (e2 + e3) >> 1;
        e1 = (e1 - (e2 >> cShift)) >> 1;
    }
    
    INLINE VOID vSteadyState(LONG cShift)
    {
    // We now convert from 18.14 fixed format to 15.17:
    
        e0 <<= 3;
        e1 <<= 3;
    
        register LONG lShift = cShift - 3;
    
        if (lShift < 0)
        {
            lShift = -lShift;
            e2 <<= lShift;
            e3 <<= lShift;
        }
        else
        {
            e2 >>= lShift;
            e3 >>= lShift;
        }
    }
    
    INLINE VOID vHalveStepSize()
    {
        e2 = (e2 + e3) >> 3;
        e1 = (e1 - e2) >> 1;
        e3 >>= 2;
    }
    
    INLINE VOID vDoubleStepSize()
    {
        e1 += e1 + e2;
        e3 <<= 2;
        e2 = (e2 << 3) - e3;
    }
    
    INLINE VOID vTakeStep()
    {
        e0 += e1;
        register LONG lTemp = e2;
        e1 += lTemp;
        e2 += lTemp - e3;
        e3 = lTemp;
    }
};

/**********************************Class***********************************\
* class Bezier32
*
*   Bezier cracker.
*
* A hybrid cubic Bezier curve flattener based on KirkO's error factor.
* Generates line segments fast without using the stack.  Used to flatten
* a path.
*
* For an understanding of the methods used, see:
*
*     Kirk Olynyk, "..."
*     Goossen and Olynyk, "System and Method of Hybrid Forward
*         Differencing to Render Bezier Splines"
*     Lien, Shantz and Vaughan Pratt, "Adaptive Forward Differencing for
*     Rendering Curves and Surfaces", Computer Graphics, July 1987
*     Chang and Shantz, "Rendering Trimmed NURBS with Adaptive Forward
*         Differencing", Computer Graphics, August 1988
*     Foley and Van Dam, "Fundamentals of Interactive Computer Graphics"
*
* Public Interface:
*
*   vInit(pptfx)                - pptfx points to 4 control points of
*                                 Bezier.  Current point is set to the first
*                                 point after the start-point.
*   Bezier32(pptfx)             - Constructor with initialization.
*   vGetCurrent(pptfx)          - Returns current polyline point.
*   bCurrentIsEndPoint()        - TRUE if current point is end-point.
*   vNext()                     - Moves to next polyline point.
*
* History:
*  1-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

class Bezier32
{
private:
    LONG       cSteps;
    HfdBasis32 x;
    HfdBasis32 y;
    RECT       rcfxBound;

public:
    BOOL bInit(const POINT* aptfx, const RECT*);
    INT cFlatten(POINT* pptfx, INT cptfx, BOOL *pbMore);
};

#define FRACTION64 28

class HfdBasis64
{
private:
    LONGLONG e0;
    LONGLONG e1;
    LONGLONG e2;
    LONGLONG e3;

public:
    VOID vInit(INT p1, INT p2, INT p3, INT p4);
    VOID vHalveStepSize();
    VOID vDoubleStepSize();
    VOID vTakeStep();
    VOID vUntransform(LONG* afx);

    VOID vParentError(LONGLONG* peq) const;
    VOID vError(LONGLONG* peq) const;
    INT fxValue() const;
};

class Bezier64
{
private:
    HfdBasis64 xLow;
    HfdBasis64 yLow;
    HfdBasis64 xHigh;
    HfdBasis64 yHigh;

    LONGLONG    eqErrorLow;
    RECT*       prcfxClip;
    RECT        rcfxClip;

    LONG        cStepsHigh;
    LONG        cStepsLow;

public:

    INT cFlatten(POINT* pptfx, INT cptfx, BOOL *pbMore);
    VOID vInit(const POINT* aptfx, const RECT* prcfx, const LONGLONG eq);
};

typedef struct _BEZIERCONTROLS {
    POINT ptfx[4];
} BEZIERCONTROLS;

inline VOID vBoundBox(const POINT* aptfx, RECT* prcfx)
{
    INT i;

    INT left = aptfx[0].x;
    INT right = aptfx[0].x;
    INT top = aptfx[0].y;
    INT bottom = aptfx[0].y;

    for (i = 1; i < 4; i++)
    {
        left = min(left, aptfx[i].x);
        top = min(top, aptfx[i].y);
        right = max(right, aptfx[i].x);
        bottom = max(bottom, aptfx[i].y);
    }

    // We make the bounds one pixel loose for the nominal width 
    // stroke case, which increases the bounds by half a pixel 
    // in every dimension:

    prcfx->left = left - 16;
    prcfx->top = top - 16;
    prcfx->right = right + 16;
    prcfx->bottom = bottom + 16;
}

BOOL bIntersect(
    const RECT *a,
    const RECT *b)
{
    return((a->left < b->right) &&
           (a->top < b->bottom) &&
           (a->right > b->left) &&
           (a->bottom > b->top));
}

BOOL Bezier32::bInit(
const POINT* aptfxBez,      // Pointer to 4 control points
const RECT* prcfxClip)      // Bound box of visible region (optional)
{
    POINT aptfx[4];
    LONG cShift = 0;    // Keeps track of 'lazy' shifts

    cSteps = 1;         // Number of steps to do before reach end of curve

    vBoundBox(aptfxBez, &rcfxBound);

    *((BEZIERCONTROLS*) aptfx) = *((BEZIERCONTROLS*) aptfxBez);

    {
        register INT fxOr;
        register INT fxOffset;

        fxOffset = rcfxBound.left;
        fxOr  = (aptfx[0].x -= fxOffset);
        fxOr |= (aptfx[1].x -= fxOffset);
        fxOr |= (aptfx[2].x -= fxOffset);
        fxOr |= (aptfx[3].x -= fxOffset);

        fxOffset = rcfxBound.top;
        fxOr |= (aptfx[0].y -= fxOffset);
        fxOr |= (aptfx[1].y -= fxOffset);
        fxOr |= (aptfx[2].y -= fxOffset);
        fxOr |= (aptfx[3].y -= fxOffset);

    // This 32 bit cracker can only handle points in a 10 bit space:

        if ((fxOr & 0xffffc000) != 0)
            return(FALSE);
    }

    x.vInit(aptfx[0].x, aptfx[1].x, aptfx[2].x, aptfx[3].x);
    y.vInit(aptfx[0].y, aptfx[1].y, aptfx[2].y, aptfx[3].y);

    if (prcfxClip == (RECT*) NULL || bIntersect(&rcfxBound, prcfxClip))
    {
        while (TRUE)
        {
            register LONG lTestMagnitude = TEST_MAGNITUDE_INITIAL << cShift;

            if (x.lError() <= lTestMagnitude && y.lError() <= lTestMagnitude)
                break;

            cShift += 2;
            x.vLazyHalveStepSize(cShift);
            y.vLazyHalveStepSize(cShift);
            cSteps <<= 1;
        }
    }

    x.vSteadyState(cShift);
    y.vSteadyState(cShift);

// Note that this handles the case where the initial error for
// the Bezier is already less than TEST_MAGNITUDE_NORMAL:

    x.vTakeStep();
    y.vTakeStep();
    cSteps--;

    return(TRUE);
}

INT Bezier32::cFlatten(POINT* pptfx, INT cptfx, BOOL *pbMore)
{
    ASSERT(cptfx > 0);

    INT cptfxOriginal = cptfx;

    do {
    // Return current point:
    
        pptfx->x = x.fxValue() + rcfxBound.left;
        pptfx->y = y.fxValue() + rcfxBound.top;
        pptfx++;
    
    // If cSteps == 0, that was the end point in the curve!
    
        if (cSteps == 0)
        {
            *pbMore = FALSE;

            // '+1' because we haven't decremented 'cptfx' yet:

            return(cptfxOriginal - cptfx + 1);
        }
    
    // Okay, we have to step:
    
        if (max(x.lError(), y.lError()) > TEST_MAGNITUDE_NORMAL)
        {
            x.vHalveStepSize();
            y.vHalveStepSize();
            cSteps <<= 1;
        }
    
        ASSERTMSG(max(x.lError(), y.lError()) <= TEST_MAGNITUDE_NORMAL,
                  ("Please tell AndrewGo he was wrong"));
    
        while (!(cSteps & 1) &&
               x.lParentErrorDividedBy4() <= (TEST_MAGNITUDE_NORMAL >> 2) &&
               y.lParentErrorDividedBy4() <= (TEST_MAGNITUDE_NORMAL >> 2))
        {
            x.vDoubleStepSize();
            y.vDoubleStepSize();
            cSteps >>= 1;
        }
    
        cSteps--;
        x.vTakeStep();
        y.vTakeStep();

    } while (--cptfx != 0);

    *pbMore = TRUE;
    return(cptfxOriginal);
}

///////////////////////////////////////////////////////////////////////////
// Bezier64
//
// All math is done using 64 bit fixed numbers in a 36.28 format.
//
// All drawing is done in a 31 bit space, then a 31 bit window offset
// is applied.  In the initial transform where we change to the HFD
// basis, e2 and e3 require the most bits precision: e2 = 6(p2 - 2p3 + p4).
// This requires an additional 4 bits precision -- hence we require 36 bits
// for the integer part, and the remaining 28 bits is given to the fraction.
//
// In rendering a Bezier, every 'subdivide' requires an extra 3 bits of
// fractional precision.  In order to be reversible, we can allow no
// error to creep in.  Since a INT coordinate is 32 bits, and we
// require an additional 4 bits as mentioned above, that leaves us
// 28 bits fractional precision -- meaning we can do a maximum of
// 9 subdivides.  Now, the maximum absolute error of a Bezier curve in 27
// bit integer space is 2^29 - 1.  But 9 subdivides reduces the error by a
// guaranteed factor of 2^18, meaning we can crack down only to an error
// of 2^11 before we overflow, when in fact we want to crack error to less
// than 1.
//
// So what we do is HFD until we hit an error less than 2^11, reverse our
// basis transform to get the four control points of this smaller curve
// (rounding in the process to 32 bits), then invoke another copy of HFD
// on the reduced Bezier curve.  We again have enough precision, but since
// its starting error is less than 2^11, we can reduce error to 2^-7 before
// overflowing!  We'll start a low HFD after every step of the high HFD.
////////////////////////////////////////////////////////////////////////////

// The following is our 2^11 target error encoded as a 36.28 number
// (don't forget the additional 4 bits of fractional precision!) and
// the 6 times error multiplier:

const LONGLONG geqErrorHigh = (LONGLONG)(6 * (1L << 15) >> (32 - FRACTION64)) << 32;

// The following is the default 2/3 error encoded as a 36.28 number,
// multiplied by 6, and leaving 4 bits for fraction:

const LONGLONG geqErrorLow = (LONGLONG)(4) << 32;

inline INT HfdBasis64::fxValue() const
{
// Convert from 36.28 and round:

    LONGLONG eq = e0;
    eq += (1L << (FRACTION64 - 1));
    eq >>= FRACTION64;
    return((INT) (LONG) eq);
}

#define MAX(a, b) ((a) >= (b) ? (a) : (b))
#define ABS(a) ((a) >= 0 ? (a) : -(a))

inline VOID HfdBasis64::vParentError(LONGLONG* peq) const
{
    *peq = MAX(ABS(e3 << 2), ABS((e2 << 3) - (e3 << 2)));
}

inline VOID HfdBasis64::vError(LONGLONG* peq) const
{
    *peq = MAX(ABS(e2), ABS(e3));
}

VOID HfdBasis64::vInit(INT p1, INT p2, INT p3, INT p4)
{
    LONGLONG eqTmp;
    LONGLONG eqP2 = (LONGLONG) p2;
    LONGLONG eqP3 = (LONGLONG) p3;

// e0 = p1
// e1 = p4 - p1
// e2 = 6(p2 - 2p3 + p4)
// e3 = 6(p1 - 2p2 + p3)

// Change basis:

    e0 = p1;                                        // e0 = p1
    e1 = p4;
    e2 = eqP2; e2 -= eqP3; e2 -= eqP3; e2 += e1;    // e2 = p2 - 2*p3 + p4
    e3 = e0;   e3 -= eqP2; e3 -= eqP2; e3 += eqP3;  // e3 = p1 - 2*p2 + p3
    e1 -= e0;                                       // e1 = p4 - p1

// Convert to 36.28 format and multiply e2 and e3 by six:

    e0 <<= FRACTION64;
    e1 <<= FRACTION64;
    eqTmp = e2; e2 += eqTmp; e2 += eqTmp; e2 <<= (FRACTION64 + 1);
    eqTmp = e3; e3 += eqTmp; e3 += eqTmp; e3 <<= (FRACTION64 + 1);
}

VOID HfdBasis64::vUntransform(LONG* afx)
{
// Declare some temps to hold our operations, since we can't modify e0..e3.

    LONGLONG eqP0;
    LONGLONG eqP1;
    LONGLONG eqP2;
    LONGLONG eqP3;

// p0 = e0
// p1 = e0 + (6e1 - e2 - 2e3)/18
// p2 = e0 + (12e1 - 2e2 - e3)/18
// p3 = e0 + e1

    eqP0 = e0;

// NOTE PERF: Convert this to a multiply by 6: [andrewgo]

    eqP2 = e1;
    eqP2 += e1;
    eqP2 += e1;
    eqP1 = eqP2;
    eqP1 += eqP2;           // 6e1
    eqP1 -= e2;             // 6e1 - e2
    eqP2 = eqP1;
    eqP2 += eqP1;           // 12e1 - 2e2
    eqP2 -= e3;             // 12e1 - 2e2 - e3
    eqP1 -= e3;
    eqP1 -= e3;             // 6e1 - e2 - 2e3

// NOTE: May just want to approximate these divides! [andrewgo]
// Or can do a 64 bit divide by 32 bit to get 32 bits right here.

    eqP1 /= 18;
    eqP2 /= 18;
    eqP1 += e0;
    eqP2 += e0;

    eqP3 = e0;
    eqP3 += e1;

// Convert from 36.28 format with rounding:

    eqP0 += (1L << (FRACTION64 - 1)); eqP0 >>= FRACTION64; afx[0] = (LONG) eqP0;
    eqP1 += (1L << (FRACTION64 - 1)); eqP1 >>= FRACTION64; afx[2] = (LONG) eqP1;
    eqP2 += (1L << (FRACTION64 - 1)); eqP2 >>= FRACTION64; afx[4] = (LONG) eqP2;
    eqP3 += (1L << (FRACTION64 - 1)); eqP3 >>= FRACTION64; afx[6] = (LONG) eqP3;
}

VOID HfdBasis64::vHalveStepSize()
{
// e2 = (e2 + e3) >> 3
// e1 = (e1 - e2) >> 1
// e3 >>= 2

    e2 += e3; e2 >>= 3;
    e1 -= e2; e1 >>= 1;
    e3 >>= 2;
}

VOID HfdBasis64::vDoubleStepSize()
{
// e1 = 2e1 + e2
// e3 = 4e3;
// e2 = 8e2 - e3

    e1 <<= 1; e1 += e2;
    e3 <<= 2;
    e2 <<= 3; e2 -= e3;
}

VOID HfdBasis64::vTakeStep()
{
    e0 += e1;
    LONGLONG eqTmp = e2;
    e1 += e2;
    e2 += eqTmp; e2 -= e3;
    e3 = eqTmp;
}

VOID Bezier64::vInit(
const POINT*    aptfx,        // Pointer to 4 control points
const RECT*     prcfxVis,     // Pointer to bound box of visible area (may be NULL)
LONGLONG        eqError)      // Fractional maximum error (32.32 format)
{
    LONGLONG eqTmp;

    cStepsHigh = 1;
    cStepsLow  = 0;

    xHigh.vInit(aptfx[0].x, aptfx[1].x, aptfx[2].x, aptfx[3].x);
    yHigh.vInit(aptfx[0].y, aptfx[1].y, aptfx[2].y, aptfx[3].y);

// Initialize error:

    eqErrorLow = eqError;

    if (prcfxVis == (RECT*) NULL)
        prcfxClip = (RECT*) NULL;
    else
    {
        rcfxClip = *prcfxVis;
        prcfxClip = &rcfxClip;
    }

    while (((xHigh.vError(&eqTmp), eqTmp) > geqErrorHigh) ||
           ((yHigh.vError(&eqTmp), eqTmp) > geqErrorHigh))
    {
        cStepsHigh <<= 1;
        xHigh.vHalveStepSize();
        yHigh.vHalveStepSize();
    }
}

INT Bezier64::cFlatten(POINT* pptfx, INT cptfx, BOOL *pbMore)
{
    POINT    aptfx[4];
    RECT     rcfxBound;
    LONGLONG eqTmp;
    INT      cptfxOriginal = cptfx;

    ASSERT(cptfx > 0);

    do {
        if (cStepsLow == 0)
        {
        // Optimization that if the bound box of the control points doesn't
        // intersect with the bound box of the visible area, render entire
        // curve as a single line:
    
            xHigh.vUntransform(&aptfx[0].x);
            yHigh.vUntransform(&aptfx[0].y);
    
            xLow.vInit(aptfx[0].x, aptfx[1].x, aptfx[2].x, aptfx[3].x);
            yLow.vInit(aptfx[0].y, aptfx[1].y, aptfx[2].y, aptfx[3].y);
            cStepsLow = 1;
    
            if (prcfxClip != (RECT*) NULL)
                vBoundBox(aptfx, &rcfxBound);
    
            if (prcfxClip == (RECT*) NULL || bIntersect(&rcfxBound, prcfxClip))
            {
                while (((xLow.vError(&eqTmp), eqTmp) > eqErrorLow) ||
                       ((yLow.vError(&eqTmp), eqTmp) > eqErrorLow))
                {
                    cStepsLow <<= 1;
                    xLow.vHalveStepSize();
                    yLow.vHalveStepSize();
                }
            }
    
        // This 'if' handles the case where the initial error for the Bezier
        // is already less than the target error:
    
            if (--cStepsHigh != 0)
            {
                xHigh.vTakeStep();
                yHigh.vTakeStep();
    
                if (((xHigh.vError(&eqTmp), eqTmp) > geqErrorHigh) ||
                    ((yHigh.vError(&eqTmp), eqTmp) > geqErrorHigh))
                {
                    cStepsHigh <<= 1;
                    xHigh.vHalveStepSize();
                    yHigh.vHalveStepSize();
                }
    
                while (!(cStepsHigh & 1) &&
                       ((xHigh.vParentError(&eqTmp), eqTmp) <= geqErrorHigh) &&
                       ((yHigh.vParentError(&eqTmp), eqTmp) <= geqErrorHigh))
                {
                    xHigh.vDoubleStepSize();
                    yHigh.vDoubleStepSize();
                    cStepsHigh >>= 1;
                }
            }
        }
    
        xLow.vTakeStep();
        yLow.vTakeStep();
    
        pptfx->x = xLow.fxValue();
        pptfx->y = yLow.fxValue();
        pptfx++;
    
        cStepsLow--;
        if (cStepsLow == 0 && cStepsHigh == 0)
        {
            *pbMore = FALSE;

            // '+1' because we haven't decremented 'cptfx' yet:

            return(cptfxOriginal - cptfx + 1);
        }
    
        if (((xLow.vError(&eqTmp), eqTmp) > eqErrorLow) ||
            ((yLow.vError(&eqTmp), eqTmp) > eqErrorLow))
        {
            cStepsLow <<= 1;
            xLow.vHalveStepSize();
            yLow.vHalveStepSize();
        }
    
        while (!(cStepsLow & 1) &&
               ((xLow.vParentError(&eqTmp), eqTmp) <= eqErrorLow) &&
               ((yLow.vParentError(&eqTmp), eqTmp) <= eqErrorLow))
        {
            xLow.vDoubleStepSize();
            yLow.vDoubleStepSize();
            cStepsLow >>= 1;
        }

    } while (--cptfx != 0);

    *pbMore = TRUE;
    return(cptfxOriginal);
}

/**********************************Class***********************************\
* class BEZIER
*
* Bezier cracker.  Flattens any Bezier in our 28.4 device space down
* to a smallest 'error' of 2^-7 = 0.0078.  Will use fast 32 bit cracker
* for small curves and slower 64 bit cracker for big curves.
*
* Public Interface:
*
*   vInit(aptfx, prcfxClip, peqError)
*       - pptfx points to 4 control points of Bezier.  The first point
*         retrieved by bNext() is the the first point in the approximation
*         after the start-point.
*
*       - prcfxClip is an optional pointer to the bound box of the visible
*         region.  This is used to optimize clipping of Bezier curves that
*         won't be seen.  Note that this value should account for the pen's
*         width!
*
*       - optional maximum error in 32.32 format, corresponding to Kirko's
*         error factor.
*
*   bNext(pptfx)
*       - pptfx points to where next point in approximation will be
*         returned.  Returns FALSE if the point is the end-point of the
*         curve.
*
* History:
*  1-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

class BEZIER
{
private:

    union
    {
        Bezier64 bez64;
        Bezier32 bez32;
    } bez;

    BOOL bBez32;

public:

// All coordinates must be in 28.4 format:

    BEZIER(const POINT* aptfx, const RECT* prcfxClip)
    {
        bBez32 = bez.bez32.bInit(aptfx, prcfxClip);
        if (!bBez32)
            bez.bez64.vInit(aptfx, prcfxClip, geqErrorLow);
    }

    INT Flatten(POINT* pptfx, INT cptfx, BOOL *pbMore)
    {
        if (bBez32)
        {
            return(bez.bez32.cFlatten(pptfx, cptfx, pbMore));
        }
        else
        {
            return(bez.bez64.cFlatten(pptfx, cptfx, pbMore));
        }
    }
};                                  

/**************************************************************************\
*
* Function Description:
*
*   Clip the edge vertically.
*
*   We've pulled this routine out-of-line from InitializeEdges mainly
*   because it needs to call inline Asm, and when there is in-line
*   Asm in a routine the compiler generally does a much less efficient
*   job optimizing the whole routine.  InitializeEdges is rather 
*   performance critical, so we avoid polluting the whole routine 
*   by having this functionality out-of-line.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID
ClipEdge(
    EpEdge *edgeBuffer,
    INT yClipTopInteger,
    INT dMOriginal
    )
{
    INT xDelta;
    INT error;

    // Cases where bigNumerator will exceed 32-bits in precision
    // will be rare, but could happen, and we can't fall over
    // in those cases.

    INT dN = edgeBuffer->ErrorDown;
    LONGLONG bigNumerator = Int32x32To64(dMOriginal, 
                                         yClipTopInteger - edgeBuffer->StartY)
                          + (edgeBuffer->Error + dN);
    if (bigNumerator >= 0)
    {
        QUOTIENT_REMAINDER_64_32(bigNumerator, dN, xDelta, error);
    }
    else
    {
        bigNumerator = -bigNumerator;
        QUOTIENT_REMAINDER_64_32(bigNumerator, dN, xDelta, error);

        xDelta = -xDelta;
        if (error != 0)
        {
            xDelta--;
            error = dN - error;
        }
    }

    // Update the edge data structure with the results:

    edgeBuffer->StartY  = yClipTopInteger;
    edgeBuffer->X      += xDelta;
    edgeBuffer->Error   = error - dN;      // Renormalize error
}

/**************************************************************************\
*
* Function Description:
*
*   Add edges to the edge list.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

BOOL
InitializeEdges(
    VOID *context,
    POINT *pointArray,    // Points to a 28.4 array of size 'vertexCount'
                          //   Note that we may modify the contents!
    INT vertexCount,
    PathEnumerateTermination lastSubpath      // not used
    )
{
    INT xStart;
    INT yStart;
    INT yStartInteger;
    INT yEndInteger;
    INT dMOriginal;
    INT dM;
    INT dN;
    INT dX;
    INT errorUp;
    INT quotient;
    INT remainder;
    INT error;
    LONGLONG bigNumerator;
    INT littleNumerator;
    INT windingDirection;
    EpEdge *edgeBuffer;
    EpEdge *endEdge;
    INT bufferCount;
    INT yClipTopInteger;
    INT yClipTop;
    INT yClipBottom;
    INT xClipLeft;
    INT xClipRight;

    EpInitializeEdgesContext *edgeContext = static_cast<EpInitializeEdgesContext*>(context);
    INT yMax = edgeContext->MaxY;
    EpEdgeStore *store = edgeContext->Store;
    RECT *clipRect = edgeContext->ClipRect;

    INT edgeCount = vertexCount - 1;
    ASSERT(edgeCount >= 1);

    if (clipRect == NULL)
    {
        yClipBottom = 0;
        yClipTopInteger = INT_MIN >> AA_Y_SHIFT;   
    }
    else
    {
        yClipTopInteger = clipRect->top >> 4;
        yClipTop = clipRect->top;
        yClipBottom = clipRect->bottom;
        xClipLeft = clipRect->left;
        xClipRight = clipRect->right;

        ASSERT(yClipBottom > 0);
        ASSERT(yClipTop <= yClipBottom);
    }

    if (edgeContext->IsAntialias)
    {
        // If antialiasing, apply the supersampling scaling here before we
        // calculate the DDAs.  We do this here and not in the Matrix
        // transform we give to FixedPointPathEnumerate mainly so that the
        // Bezier flattener can continue to operate in its optimal 28.4
        // format.  
        //
        // We also apply a half-pixel offset here so that the antialiasing
        // code can assume that the pixel centers are at half-pixel
        // coordinates, not on the integer coordinates.

        POINT *point = pointArray;
        INT i = vertexCount;

        do {
            point->x = (point->x + 8) << AA_X_SHIFT;
            point->y = (point->y + 8) << AA_Y_SHIFT;

        } while (point++, --i != 0);

        yClipTopInteger <<= AA_Y_SHIFT;
        yClipTop <<= AA_Y_SHIFT;
        yClipBottom <<= AA_Y_SHIFT;
        xClipLeft <<= AA_X_SHIFT;
        xClipRight <<= AA_X_SHIFT;
    }

    // Make 'yClipBottom' inclusive by subtracting off one pixel
    // (keeping in mind that we're in 28.4 device space):

    yClipBottom -= 16;

    // Warm up the store where we keep the edge data:

    store->StartAddBuffer(&edgeBuffer, &bufferCount);

    do {
        // Handle trivial rejection:

        if (yClipBottom >= 0)
        {
            // Throw out any edges that are above or below the clipping.
            // This has to be a precise check, because we assume later
            // on that every edge intersects in the vertical dimension 
            // with the clip rectangle.  That asssumption is made in two 
            // places:
            //
            // 1.  When we sort the edges, we assume either zero edges,
            //     or two or more.
            // 2.  When we start the DDAs, we assume either zero edges,
            //     or that there's at least one scan of DDAs to output.
            //
            // Plus, of course, it's less efficient if we let things
            // through.
            //
            // Note that 'yClipBottom' is inclusive:

            BOOL clipHigh = ((pointArray)->y <= yClipTop) &&
                            ((pointArray + 1)->y <= yClipTop);

            BOOL clipLow = ((pointArray)->y > yClipBottom) &&
                             ((pointArray + 1)->y > yClipBottom);

            #if DBG
            {
                INT yRectTop, yRectBottom, y0, y1, yTop, yBottom;

                // Getting the trivial rejection code right is tricky.  
                // So on checked builds let's verify that we're doing it 
                // correctly, using a different approach:

                BOOL clipped = FALSE;
                if (clipRect != NULL)
                {
                    yRectTop = clipRect->top >> 4;
                    yRectBottom = clipRect->bottom >> 4;
                    if (edgeContext->IsAntialias)
                    {
                        yRectTop <<= AA_Y_SHIFT;
                        yRectBottom <<= AA_Y_SHIFT;
                    }
                    y0 = ((pointArray)->y + 15) >> 4;
                    y1 = ((pointArray + 1)->y + 15) >> 4;
                    yTop = min(y0, y1);
                    yBottom = max(y0, y1);

                    clipped = ((yTop >= yRectBottom) || (yBottom <= yRectTop));
                }

                ASSERT(clipped == (clipHigh || clipLow));
            }
            #endif

            if (clipHigh || clipLow)
                continue;               // ======================>

            if (edgeCount > 1)
            {
                // Here we'll collapse two edges down to one if both are
                // to the left or to the right of the clipping rectangle.
    
                if (((pointArray)->x < xClipLeft) &&
                    ((pointArray + 1)->x < xClipLeft) &&
                    ((pointArray + 2)->x < xClipLeft))
                {
                    // Note this is one reason why 'pointArray' can't be 'const':

                    *(pointArray + 1) = *(pointArray);

                    continue;           // ======================>
                }

                if (((pointArray)->x > xClipRight) &&
                    ((pointArray + 1)->x > xClipRight) &&
                    ((pointArray + 2)->x > xClipRight))
                {
                    // Note this is one reason why 'pointArray' can't be 'const':

                    *(pointArray + 1) = *(pointArray);

                    continue;           // ======================>
                }
            }
        
        }

        dM = (pointArray + 1)->x - (pointArray)->x;
        dN = (pointArray + 1)->y - (pointArray)->y;
    
        if (dN >= 0)
        {
            // The vector points downward:

            xStart = (pointArray)->x;
            yStart = (pointArray)->y;

            yStartInteger = (yStart + 15) >> 4;
            yEndInteger   = ((pointArray + 1)->y + 15) >> 4;

            windingDirection = 1;
        }
        else
        {
            // The vector points upward, so we have to essentially
            // 'swap' the end points:

            dN = -dN;
            dM = -dM;
    
            xStart = (pointArray + 1)->x;
            yStart = (pointArray + 1)->y;

            yStartInteger = (yStart + 15) >> 4;
            yEndInteger   = ((pointArray)->y + 15) >> 4;

            windingDirection = -1;
        }

        // The edgeBuffer must span an integer y-value in order to be 
        // added to the edgeBuffer list.  This serves to get rid of 
        // horizontal edges, which cause trouble for our divides.

        if (yEndInteger > yStartInteger)
        {
            yMax = max(yMax, yEndInteger);

            dMOriginal = dM;
            if (dM < 0)
            {
                dM = -dM;
                if (dM < dN)            // Can't be '<='
                {
                    dX      = -1;
                    errorUp = dN - dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, quotient, remainder);
        
                    dX      = -quotient;
                    errorUp = remainder;
                    if (remainder > 0)
                    {
                        dX      = -quotient - 1;
                        errorUp = dN - remainder;
                    }
                }
            }
            else
            {
                if (dM < dN)
                {
                    dX      = 0;
                    errorUp = dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, quotient, remainder);
        
                    dX      = quotient;
                    errorUp = remainder;
                }
            }
        
            error = -1;     // Error is initially zero (add dN - 1 for       
                            //   the ceiling, but subtract off dN so that    
                            //   we can check the sign instead of comparing  
                            //   to dN)                                      
        
            if ((yStart & 15) != 0)
            {
                // Advance to the next integer y coordinate
        
                for (INT i = 16 - (yStart & 15); i != 0; i--)
                {
                    xStart += dX;
                    error += errorUp;
                    if (error >= 0)
                    {
                        error -= dN;
                        xStart++;
                    }
                }
            }
        
            if ((xStart & 15) != 0)
            {
                error -= dN * (16 - (xStart & 15));
                xStart += 15;       // We'll want the ceiling in just a bit...
            }

            xStart >>= 4;
            error >>= 4;

            if (bufferCount == 0)
            {
                if (!store->NextAddBuffer(&edgeBuffer, &bufferCount))
                    return(FALSE);
            }

            edgeBuffer->X                = xStart;
            edgeBuffer->Dx               = dX;
            edgeBuffer->Error            = error;
            edgeBuffer->ErrorUp          = errorUp;
            edgeBuffer->ErrorDown        = dN;
            edgeBuffer->WindingDirection = windingDirection;
            edgeBuffer->StartY           = yStartInteger;
            edgeBuffer->EndY             = yEndInteger;       // Exclusive of end

            // Here we handle the case where the edge starts above the
            // clipping rectangle, and we need to jump down in the 'y'
            // direction to the first unclipped scan-line.
            //
            // Consequently, we advance the DDA here:

            if (yClipTopInteger > yStartInteger)
            {
                ASSERT(edgeBuffer->EndY > yClipTopInteger);

                ClipEdge(edgeBuffer, yClipTopInteger, dMOriginal);
            }

            // Advance to handle the next edge:

            edgeBuffer++;
            bufferCount--;
        }
    } while (pointArray++, --edgeCount != 0);

    // We're done with this batch.  Let the store know how many edges
    // we ended up with:

    store->EndAddBuffer(edgeBuffer, bufferCount);

    edgeContext->MaxY = yMax;

    return(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Returns TRUE if the line from point[1] to point[2] turns 'left'
*   from the line from point[0] to point[1].  Uses the sign of the
*   cross product.
*
*   Remember that we're in device space, where positive 'y' is down!
*
* Created:
*
*   04/09/2000 andrewgo
*
\**************************************************************************/

inline
BOOL
TurnLeft(
    const POINT *points
    )
{
    LONGLONG ad = Int32x32To64(points[1].x - points[0].x,
                               points[2].y - points[1].y);
    LONGLONG bc = Int32x32To64(points[1].y - points[0].y,
                               points[2].x - points[1].x);

    return(ad < bc);
}

/**************************************************************************\
*
* Function Description:
*
*   Computes the index of the NominalDrawVertex table to be use as the
*   drawing vertex.  The result is numbered such that a traversal using
*   an increasing pointer will go counter-clockwise around the pen.
*
* Created:
*
*   04/09/2000 andrewgo
*
\**************************************************************************/

POINT NominalDrawVertex[] = 
{
    // Don't forget that in device space, positive 'y' is down:

    {0,  -8},
    {-8, 0},
    {0,  8},
    {8,  0}
};

INT OctantToDrawVertexTranslate[] =
{
    0, 2, 0, 2, 3, 3, 1, 1
};

inline
INT
ComputeDrawVertex(
    const POINT* points
    )
{
    INT dx = points[1].x - points[0].x;
    INT dy = points[1].y - points[0].y;
    INT octant = 0;

    if (dx < 0)
    {
        octant |= 1;
        dx = -dx;
    }
    if (dy < 0)
    {
        octant |= 2;
        dy = -dy;
    }
    if (dy > dx)
    {
        octant |= 4;
    }

    return(OctantToDrawVertexTranslate[octant]);
}

/**************************************************************************\
*
* Function Description:
*
*   Routine for nominal-width lines that generates a fast outline to
*   be filled by the fill code.
*
*   The resulting fill must always be done in winding mode.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

BOOL
InitializeNominal(
    VOID *context,
    POINT *pointArray,    // Points to a 28.4 array of size 'vertexCount'
                          //   Note that we may modify the contents!
    INT vertexCount,
    PathEnumerateTermination lastSubpath     
    )
{
    POINT leftBuffer[NOMINAL_FILL_POINT_NUMBER];
    POINT rightBuffer[NOMINAL_FILL_POINT_NUMBER];
    POINT lastPoint;
    INT iDraw;
    INT iNewDraw;
    INT xStart;
    INT yStart;
    INT xEnd;
    INT yEnd;
    INT xPerp;
    INT yPerp;
    BOOL isLeftTurn;
    INT iNext;

    POINT *rightStartPlus3 = rightBuffer + 3;
    POINT *rightEnd = rightBuffer + NOMINAL_FILL_POINT_NUMBER;
    POINT *leftStart = leftBuffer;
    POINT *leftEndMinus3 = leftBuffer + NOMINAL_FILL_POINT_NUMBER - 3;
    POINT *left = leftStart;
    POINT *right = rightEnd;

    INT lineCount = vertexCount - 1;

    iDraw = ComputeDrawVertex(pointArray);

    // Add start cap:

    xStart = (pointArray)->x;
    yStart = (pointArray)->y;
    (left)->x = xStart - NominalDrawVertex[iDraw].x;
    (left)->y = yStart - NominalDrawVertex[iDraw].y;
    (left + 1)->x = xStart + NominalDrawVertex[(iDraw + 1) & 3].x;
    (left + 1)->y = yStart + NominalDrawVertex[(iDraw + 1) & 3].y;
    left += 2;

    while (TRUE)
    {
        if (left >= leftEndMinus3)
        {
            lastPoint = *(left - 1);

            if (!InitializeEdges(context, 
                                 leftBuffer, 
                                 static_cast<INT>(left - leftBuffer),
                                 lastSubpath))
            {
                return(FALSE);
            }

            *(leftStart) = lastPoint;
            left = leftStart + 1;
        }
        if (right < rightStartPlus3)
        {
            lastPoint = *right;

            if (!InitializeEdges(context,
                                 right,
                                 static_cast<INT>(rightEnd - right),
                                 lastSubpath))
            {
                return(FALSE);
            }

            *(rightEnd - 1) = lastPoint;
            right = rightEnd - 1;
        }

        xStart = (pointArray)->x;
        yStart = (pointArray)->y;
        xEnd = (pointArray + 1)->x;
        yEnd = (pointArray + 1)->y;
        xPerp = NominalDrawVertex[iDraw].x;
        yPerp = NominalDrawVertex[iDraw].y;

        (left)->x = xStart + xPerp;
        (left)->y = yStart + yPerp;
        (right - 1)->x = xStart - xPerp;
        (right - 1)->y = yStart - yPerp;
        (left + 1)->x = xEnd + xPerp;
        (left + 1)->y = yEnd + yPerp;
        (right - 2)->x = xEnd - xPerp;
        (right - 2)->y = yEnd - yPerp;

        left += 2;
        right -= 2;

        pointArray++;
        if (--lineCount == 0)
            break;

        // Darn, we have to handle a join:

        iNewDraw = ComputeDrawVertex(pointArray);
        if (iNewDraw != iDraw)
        {
            isLeftTurn = TurnLeft(pointArray - 1);
            if (isLeftTurn)
            {
                iNext = (iDraw + 1) & 3;
                if (iNewDraw != iNext)
                {
                    (right - 1)->x = xEnd - NominalDrawVertex[iNext].x;
                    (right - 1)->y = yEnd - NominalDrawVertex[iNext].y;
                    right--;
                }

                (left)->x = xEnd;
                (left)->y = yEnd;
                left++;
            }
            else // We're turning 'right':
            {
                iNext = (iDraw - 1) & 3;
                if (iNewDraw != iNext)
                {
                    (left)->x = xEnd + NominalDrawVertex[iNext].x;
                    (left)->y = yEnd + NominalDrawVertex[iNext].y;
                    left++;
                }

                (right - 1)->x = xEnd;
                (right - 1)->y = yEnd;
                right--;
            }
        }

        ASSERT(left <= &leftBuffer[NOMINAL_FILL_POINT_NUMBER]);
        ASSERT(right >= &rightBuffer[0]);

        iDraw = iNewDraw;
    }

    // Add end cap:

    if (left >= leftEndMinus3)
    {
        lastPoint = *(left - 1);

        if (!InitializeEdges(context, 
                             leftBuffer, 
                             static_cast<INT>(left - leftBuffer),
                             lastSubpath))
        {
            return(FALSE);
        }

        *(leftStart) = lastPoint;
        left = leftStart + 1;
    }

    xStart = (pointArray)->x;
    yStart = (pointArray)->y;
    (left)->x = xStart + NominalDrawVertex[(iDraw - 1) & 3].x;
    (left)->y = yStart + NominalDrawVertex[(iDraw - 1) & 3].y;
    (left + 1)->x = xStart - NominalDrawVertex[iDraw].x;
    (left + 1)->y = yStart - NominalDrawVertex[iDraw].y;
    left += 2;

    // Flush the left batch.  Since we just added an end cap, we
    // know there's more than one vertex in there:

    if (!InitializeEdges(context, 
                         leftBuffer, 
                         static_cast<INT>(left - leftBuffer),
                         lastSubpath))
    {
        return(FALSE);
    }

    // Don't flush the right buffer if there's only one point in there,
    // because one point doesn't make an edge.  

    INT count = static_cast<INT>(rightEnd - right);
    if (count > 1)
    {
        if (!InitializeEdges(context, right, count, lastSubpath))
        {
            return(FALSE);
        }
    }

    return(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Does complete parameter checking on the 'types' array of a path.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

BOOL
ValidatePathTypes(
    const BYTE *typesArray,
    INT count
    )
{
    BYTE type;
    const BYTE *types = typesArray;

    if (count == 0)
        return(TRUE);

    while (TRUE)
    {
        // The first point in every subpath has to be an unadorned
        // 'start' point:
    
        if ((*types & PathPointTypePathTypeMask) != PathPointTypeStart)
        {
            WARNING(("Bad subpath start"));
            return(FALSE);
        }
    
        // Advance to the first point after the 'start' point:
    
        types++;
        if (--count == 0)
        {
            WARNING(("Path ended after start-path"));
            return(FALSE);
        }
    
        if ((*types & PathPointTypePathTypeMask) == PathPointTypeStart)
        {
            WARNING(("Can't have a start followed by a start!"));
            return(FALSE);
        }
    
        // Swallow up runs of lines and Bezier curves:
    
        do {
            switch(*types & PathPointTypePathTypeMask)
            {
            case PathPointTypeLine:
                types++;
                if (--count == 0)
                    return(TRUE);
    
                break;
    
            case PathPointTypeBezier:
                if(count < 3)
                {
                    WARNING(("Path ended before multiple of 3 Bezier points"));
                    return(FALSE);
                }

                if((*types & PathPointTypePathTypeMask) != PathPointTypeBezier)
                {
                    WARNING(("Can't have a close on the first Bezier vertex"));
                    return(FALSE);
                }
    
                if((*(types + 1) & PathPointTypePathTypeMask) != PathPointTypeBezier)
                {
                    WARNING(("Expected plain Bezier control point for 3rd vertex"));
                    return(FALSE);
                }
    
                if((*(types + 2) & PathPointTypePathTypeMask) != PathPointTypeBezier)
                {
                    WARNING(("Expected Bezier control point for 4th vertex"));
                    return(FALSE);
                }
    
                types += 3;
                if ((count -= 3) == 0)
                    return(TRUE);
    
                break;
    
            default:
                WARNING(("Illegal type"));
                return(FALSE);
            }

            // A close-subpath marker or a start-subpath marker marks the
            // end of a subpath:

        } while (!(*(types - 1) & PathPointTypeCloseSubpath) &&
                  ((*types & PathPointTypePathTypeMask) != PathPointTypeStart));
    }

    return(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Some debug code for verifying the path.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID 
AssertPath(
    const DpPath *path
    )
{
    // Make sure that the 'types' array is well-formed, otherwise we
    // may fall over in the FixedPointPathEnumerate function.
    //
    // NOTE: If you hit this assert, DO NOT SIMPLY COMMENT THIS ASSERT OUT!
    //
    //       Instead, fix the ValidatePathTypes code if it's letting through
    //       valid paths, or (more likely) fix the code that's letting bogus
    //       paths through.  The FixedPointPathEnumerate routine has some 
    //       subtle assumptions that require the path to be perfectly valid!
    //
    //       No internal code should be producing invalid paths, and all
    //       paths created by the application must be parameter checked!

    ASSERT(ValidatePathTypes(path->GetPathTypes(), path->GetPointCount()));
}

/**************************************************************************\
*
* Function Description:
*
*   Enumerate the path.
*
*   NOTE: The 'enumerateFunction' function is allowed to modify the
*         contents of our call-back buffer!  (This is mainly done
*         to allow 'InitializeEdges' to be simpler for some clipping trivial
*         rejection cases.)
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

BOOL 
FixedPointPathEnumerate(
    const DpPath *path,
    const GpMatrix *matrix,
    const RECT *clipRect,       // In scaled 28.4 format
    PathEnumerateType enumType, // Fill, stroke or for flattening.
    FIXEDPOINTPATHENUMERATEFUNCTION enumerateFunction,
    VOID *enumerateContext
    )
{
    POINT bufferStart[ENUMERATE_BUFFER_NUMBER];
    POINT bezierBuffer[4];
    POINT *buffer;
    INT bufferSize;
    POINT startFigure;
    INT iStart;
    INT iEnd;
    INT runSize;
    INT thisCount;
    BOOL isMore;
    RECT scaledClip;
    INT xLast;
    INT yLast;

    ASSERTPATH(path);

    INT pathCount = path->GetPointCount();
    const PointF *pathPoint = path->GetPathPoints();
    const BYTE *pathType = path->GetPathTypes();

    // Every valid subpath has at least two vertices in it, hence the
    // check of 'pathCount - 1':

    iStart = 0;
    while (iStart < pathCount - 1)
    {
        ASSERT((pathType[iStart] & PathPointTypePathTypeMask)
                    == PathPointTypeStart);
        ASSERT((pathType[iStart + 1] & PathPointTypePathTypeMask)
                    != PathPointTypeStart);

        // Add the start point to the beginning of the batch, and
        // remember it for handling the close figure:

        matrix->Transform(&pathPoint[iStart], &startFigure, 1);

        bufferStart[0].x = startFigure.x;
        bufferStart[0].y = startFigure.y;
        buffer = bufferStart + 1;
        bufferSize = ENUMERATE_BUFFER_NUMBER - 1;

        // We need to enter our loop with 'iStart' pointing one past
        // the start figure:

        iStart++;

        do {
            // Try finding a run of lines:
    
            if ((pathType[iStart] & PathPointTypePathTypeMask) 
                                == PathPointTypeLine)
            {
                iEnd = iStart + 1;
    
                while ((iEnd < pathCount) && 
                       ((pathType[iEnd] & PathPointTypePathTypeMask) 
                                == PathPointTypeLine))
                {
                    iEnd++;
                }

                // Okay, we've found a run of lines.  Break it up into our 
                // buffer size:
    
                runSize = (iEnd - iStart);
                do {
                    thisCount = min(bufferSize, runSize);
                    matrix->Transform(&pathPoint[iStart], buffer, thisCount);
    
                    iStart += thisCount;
                    buffer += thisCount;
                    runSize -= thisCount;
                    bufferSize -= thisCount;
    
                    if (bufferSize > 0)
                        break;
    
                    xLast = bufferStart[ENUMERATE_BUFFER_NUMBER - 1].x;
                    yLast = bufferStart[ENUMERATE_BUFFER_NUMBER - 1].y;
                    if (!(enumerateFunction)(
                        enumerateContext, 
                        bufferStart, 
                        ENUMERATE_BUFFER_NUMBER,
                        PathEnumerateContinue
                    ))
                    {
                        return(FALSE);
                    }
    
                    // Continue the last vertex as the first in the new batch:
    
                    bufferStart[0].x = xLast;
                    bufferStart[0].y = yLast;
                    buffer = bufferStart + 1;
                    bufferSize = ENUMERATE_BUFFER_NUMBER - 1;

                } while (runSize != 0);
            }
            else
            {
                ASSERT(iStart + 3 <= pathCount);
                ASSERT((pathType[iStart] & PathPointTypePathTypeMask)
                        == PathPointTypeBezier);
                ASSERT((pathType[iStart + 1] & PathPointTypePathTypeMask)
                        == PathPointTypeBezier);
                ASSERT((pathType[iStart + 2] & PathPointTypePathTypeMask)
                        == PathPointTypeBezier);
    
                matrix->Transform(&pathPoint[iStart - 1], bezierBuffer, 4);
    
                // Prepare for the next iteration:
    
                iStart += 3;

                // Crack that Bezier:
    
                BEZIER bezier(bezierBuffer, clipRect);
                do {
                    thisCount = bezier.Flatten(buffer, bufferSize, &isMore);
    
                    buffer += thisCount;
                    bufferSize -= thisCount;

                    if (bufferSize > 0)
                        break;

                    xLast = bufferStart[ENUMERATE_BUFFER_NUMBER - 1].x;
                    yLast = bufferStart[ENUMERATE_BUFFER_NUMBER - 1].y;
                    if (!(enumerateFunction)(
                        enumerateContext, 
                        bufferStart, 
                        ENUMERATE_BUFFER_NUMBER,
                        PathEnumerateContinue
                    ))
                    {
                        return(FALSE);
                    }

                    // Continue the last vertex as the first in the new batch:

                    bufferStart[0].x = xLast;
                    bufferStart[0].y = yLast;
                    buffer = bufferStart + 1;
                    bufferSize = ENUMERATE_BUFFER_NUMBER - 1;
    
                } while (isMore);
            }

        } while ((iStart < pathCount) &&
                 ((pathType[iStart] & PathPointTypePathTypeMask) 
                    != PathPointTypeStart));

        // Okay, the subpath is done.  But we still have to handle the
        // 'close figure' (which is implicit for a fill):
        bool isClosed = (
            (enumType == PathEnumerateTypeFill) || 
            (pathType[iStart - 1] & PathPointTypeCloseSubpath));

        if (isClosed)
        {
            // Add the close-figure point:

            buffer->x = startFigure.x;
            buffer->y = startFigure.y;
            bufferSize--;
        }

        // We have to flush anything we might have in the batch, unless 
        // there's only one vertex in there!  (The latter case may happen
        // for the stroke case with no close figure if we just flushed a 
        // batch.)
        // If we're flattening, we must call the one additional time to 
        // correctly handle closing the subpath, even if there is only
        // one entry in the batch. The flattening callback handles the
        // one point case and closes the subpath properly without adding
        // extraneous points.

        INT verticesInBatch = ENUMERATE_BUFFER_NUMBER - bufferSize;
        if ((verticesInBatch > 1) || (enumType == PathEnumerateTypeFlatten))
        {
            // because we always exit the above loops if the buffer contains
            // some data, and if it contains nothing, we add a final element,
            // verticesInBatch should always be at least one.
            // If we're flattening, we will sometimes enter here with 
            // verticesInBatch==1, but it should never be zero or less.
           
            ASSERT(verticesInBatch >= 1);
            
            if (!(enumerateFunction)(
                enumerateContext, 
                bufferStart, 
                verticesInBatch,
                isClosed ? PathEnumerateCloseSubpath : PathEnumerateEndSubpath
            ))
            {
                return(FALSE);
            }
        }
    }

    return(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   We want to sort in the inactive list; the primary key is 'y', and
*   the secondary key is 'x'.  This routine creates a single LONGLONG
*   key that represents both.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

inline VOID YX(INT x, INT y, LONGLONG *p)
{
    // Bias 'x' by INT_MAX so that it's effectively unsigned:

    reinterpret_cast<LARGE_INTEGER*>(p)->HighPart = y;
    reinterpret_cast<LARGE_INTEGER*>(p)->LowPart = x + INT_MAX;
}

/**************************************************************************\
*
* Function Description:
*
*   Recursive function to quick-sort our inactive edge list.  Note that
*   for performance, the results are not completely sorted; an insertion 
*   sort has to be run after the quicksort in order to do a lighter-weight
*   sort of the subtables.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

#define QUICKSORT_THRESHOLD 8

VOID
QuickSortEdges(
    EpInactiveEdge *f,
    EpInactiveEdge *l
    )
{
    EpEdge *e;
    LONGLONG y;
    LONGLONG first;
    LONGLONG second;
    LONGLONG last;

    // Find the median of the first, middle, and last elements:

    EpInactiveEdge *m = f + ((l - f) >> 1);

    SWAP(y, (f + 1)->Yx, m->Yx);
    SWAP(e, (f + 1)->Edge, m->Edge);

    if ((second = (f + 1)->Yx) > (last = l->Yx))
    {
        (f + 1)->Yx = last;
        l->Yx = second;

        SWAP(e, (f + 1)->Edge, l->Edge);
    }
    if ((first = f->Yx) > (last = l->Yx))
    {
        f->Yx = last;
        l->Yx = first;

        SWAP(e, f->Edge, l->Edge);
    }
    if ((second = (f + 1)->Yx) > (first = f->Yx))
    {
        (f + 1)->Yx = first;
        f->Yx = second;

        SWAP(e, (f + 1)->Edge, f->Edge);
    }

    // f->Yx is now the desired median, and (f + 1)->Yx <= f->Yx <= l->Yx

    ASSERT(((f + 1)->Yx <= f->Yx) && (f->Yx <= l->Yx));

    LONGLONG median = f->Yx;

    EpInactiveEdge *i = f + 2;
    while (i->Yx < median)
        i++;

    EpInactiveEdge *j = l - 1;
    while (j->Yx > median)
        j--;

    while (i < j)
    {
        SWAP(y, i->Yx, j->Yx);
        SWAP(e, i->Edge, j->Edge);

        do {
            i++;
        } while (i->Yx < median);

        do {
            j--;
        } while (j->Yx > median);
    }

    SWAP(y, f->Yx, j->Yx);
    SWAP(e, f->Edge, j->Edge);

    size_t a = j - f;
    size_t b = l - j;

    // Use less stack space by recursing on the shorter subtable.  Also,
    // have the less-overhead insertion-sort handle small subtables.

    if (a <= b)
    {
        if (a > QUICKSORT_THRESHOLD)
        {
            // 'a' is the smallest, so do it first:

            QuickSortEdges(f, j - 1);
            QuickSortEdges(j + 1, l);
        }
        else if (b > QUICKSORT_THRESHOLD)
        {
            QuickSortEdges(j + 1, l);
        }
    }
    else
    {
        if (b > QUICKSORT_THRESHOLD)
        {
            // 'b' is the smallest, so do it first:

            QuickSortEdges(j + 1, l);
            QuickSortEdges(f, j - 1);
        }
        else if (a > QUICKSORT_THRESHOLD)
        {
            QuickSortEdges(f, j- 1);
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Do a sort of the inactive table using an insertion-sort.  Expects
*   large tables to have already been sorted via quick-sort.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID
FASTCALL
InsertionSortEdges(
    EpInactiveEdge *inactive,
    INT count
    )
{
    EpInactiveEdge *p;
    EpEdge *e;
    LONGLONG y;
    LONGLONG yPrevious;

    ASSERT((inactive - 1)->Yx == _I64_MIN);
    ASSERT(count >= 2);

    inactive++;     // Skip first entry (by definition it's already in order!)
    count--;            

    do {
        p = inactive;

        // Copy the current stuff to temporary variables to make a hole:

        e = inactive->Edge;
        y = inactive->Yx;

        // Shift everything one slot to the right (effectively moving
        // the hole one position to the left):

        while (y < (yPrevious = (p - 1)->Yx))
        {
            p->Yx = yPrevious;
            p->Edge = (p - 1)->Edge;
            p--;
        }

        // Drop the temporary stuff into the final hole:

        p->Yx = y;
        p->Edge = e;

        // The quicksort should have ensured that we don't have to move
        // any entry terribly far:

        ASSERT(inactive - p <= QUICKSORT_THRESHOLD);

    } while (inactive++, --count != 0);
}

/**************************************************************************\
*
* Function Description:
*
*   Assert the state of the inactive array.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID
AssertInactiveArray(
    EpInactiveEdge *inactive,
    INT count
    )
{
    // Verify the head:

    ASSERT((inactive - 1)->Yx == _I64_MIN);
    ASSERT(inactive->Yx != _I64_MIN);

    do {
        LONGLONG yx;
        YX(inactive->Edge->X, inactive->Edge->StartY, &yx);

        ASSERT(inactive->Yx == yx);
        ASSERT(inactive->Yx >= (inactive - 1)->Yx);

    } while (inactive++, --count != 0);

    // Verify that the tail is setup appropriately:

    ASSERT(inactive->Edge->StartY == INT_MAX);
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize and sort the inactive array.
*
* Returns:
*
*   'y' value of topmost edge.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

INT
InitializeInactiveArray(
    EpEdgeStore *edgeStore,
    EpInactiveEdge *inactiveArray,      // 'inactiveArray' must be at least
    INT count,                          //   'count + 2' elements in size!
    EpEdge *tailEdge                    // Tail sentinel for inactive list
    )                
{
    BOOL isMore;
    EpEdge *activeEdge;
    EpEdge *activeEdgeEnd;
    INT i;
    INT j;
    EpEdge *e;
    INT y;

    // First initialize the inactive array.  Skip the first entry, 
    // which we reserve as a head sentinel for the insertion sort:

    EpInactiveEdge *inactiveEdge = inactiveArray + 1;

    do {
        isMore = edgeStore->Enumerate(&activeEdge, &activeEdgeEnd);

        while (activeEdge != activeEdgeEnd)
        {
            inactiveEdge->Edge = activeEdge;
            YX(activeEdge->X, activeEdge->StartY, &inactiveEdge->Yx);
            inactiveEdge++;
            activeEdge++;
        }
    } while (isMore);

    ASSERT(inactiveEdge - inactiveArray == count + 1);

    // Add the tail, which is used when reading back the array.  This 
    // is why we had to allocate the array as 'count + 1':

    inactiveEdge->Edge = tailEdge;

    // Add the head, which is used for the insertion sort.  This is why 
    // we had to allocate the array as 'count + 2':

    inactiveArray->Yx = _I64_MIN;

    // Only invoke the quicksort routine if it's worth the overhead:

    if (count > QUICKSORT_THRESHOLD)
    {
        // Quick-sort this, skipping the first and last elements,
        // which are sentinels.  
        //
        // We do 'inactiveArray + count' to be inclusive of the last
        // element:
    
        QuickSortEdges(inactiveArray + 1, inactiveArray + count);
    }

    // Do a quick sort to handle the mostly sorted result:

    InsertionSortEdges(inactiveArray + 1, count);

    ASSERTINACTIVEARRAY(inactiveArray + 1, count);

    // Return the 'y' value of the topmost edge:

    return(inactiveArray[1].Edge->StartY);
}

/**************************************************************************\
*
* Function Description:
*
*   Insert edges into the active edge list.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID
InsertNewEdges(
    EpEdge *activeList,   
    INT yCurrent,
    EpInactiveEdge **inactiveEdge,  // In/Out
    INT *yNextInactive              // Out, will be INT_MAX when no more
    )
{
    EpInactiveEdge *inactive = *inactiveEdge;

    ASSERT(inactive->Edge->StartY == yCurrent);

    do {
        EpEdge *newActive = inactive->Edge;

        // The activeList edge list sentinel is INT_MAX, so this always 
        // terminates:

        while (activeList->Next->X < newActive->X)
            activeList = activeList->Next;

        newActive->Next = activeList->Next;
        activeList->Next = newActive;

        inactive++;

    } while (inactive->Edge->StartY == yCurrent);

    *yNextInactive = inactive->Edge->StartY;
    *inactiveEdge = inactive;
}

/**************************************************************************\
*
* Function Description:
*
*   Sort the edges so that they're in ascending 'x' order.
*
*   We use a bubble-sort for this stage, because edges maintain good
*   locality and don't often switch ordering positions.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID 
FASTCALL
SortActiveEdges(
    EpEdge *list
    )
{
    BOOL swapOccurred;
    EpEdge *tmp;

    // We should never be called with an empty active edge list:

    ASSERT(list->Next->X != INT_MAX);

    do {
        swapOccurred = FALSE;

        EpEdge *previous = list;
        EpEdge *current = list->Next;
        EpEdge *next = current->Next;
        INT nextX = next->X;
        
        do {
            if (nextX < current->X)
            {
                swapOccurred = TRUE;

                previous->Next = next;
                current->Next = next->Next;
                next->Next = current;

                SWAP(tmp, next, current);
            }

            previous = current;
            current = next;
            next = next->Next;

        } while ((nextX = next->X) != INT_MAX); 

    } while (swapOccurred);
}

/**************************************************************************\
*
* Function Description:
*
* For each scan-line to be filled:
*
*   1.  Remove any stale edges from the active edge list
*   2.  Insert into the active edge list any edges new to this scan-line
*   3.  Advance the DDAs of every active edge
*   4.  If any active edges are out of order, re-sort the active edge list
*   5.  Now that the active edges are ready for this scan, call the filler
*       to traverse the edges and output the spans appropriately
*   6.  Lather, rinse, and repeat
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

VOID
RasterizeEdges(
    EpEdge *activeList,
    EpInactiveEdge *inactiveArray,
    INT yCurrent,
    INT yBottom,
    EpFiller *filler,
    EpFillerFunction fillerFunction
    )
{
    INT yNextInactive;

    InsertNewEdges(activeList, yCurrent, &inactiveArray, &yNextInactive);

    ASSERTACTIVELIST(activeList, yCurrent);

    (filler->*fillerFunction)(activeList, yCurrent);
    
    while (++yCurrent < yBottom)
    {
        EpEdge *previous = activeList;
        EpEdge *current = activeList->Next;
        INT outOfOrderCount = 0;

        while (TRUE)
        {
            if (current->EndY <= yCurrent)
            {
                // If we've hit the sentinel, our work here is done:
    
                if (current->EndY == INT_MIN)
                    break;              // ============>
    
                // This edge is stale, remove it from the list:
    
                current = current->Next;
                previous->Next = current;

                continue;               // ============>
            }
    
            // Advance the DDA:
    
            current->X += current->Dx;
            current->Error += current->ErrorUp;
            if (current->Error >= 0)
            {
                current->Error -= current->ErrorDown;
                current->X++;
            }
    
            // Is this entry out-of-order with respect to the previous one?
    
            outOfOrderCount += (previous->X > current->X);
    
            // Advance:
    
            previous = current;
            current = current->Next;
        }

        // It turns out that having any out-of-order edges at this point
        // is extremely rare in practice, so only call the bubble-sort
        // if it's truly needed.
        //
        // NOTE: If you're looking at this code trying to fix a bug where
        //       the edges are out of order when the filler is called, do 
        //       NOT simply change the code to always do the bubble-sort!  
        //       Instead, figure out what caused our 'outOfOrder' logic 
        //       above to get messed up.

        if (outOfOrderCount)
        {
            SortActiveEdges(activeList);
        }

        ASSERTACTIVELISTORDER(activeList);

        if (yCurrent == yNextInactive)
        {
            InsertNewEdges(activeList, yCurrent, &inactiveArray, &yNextInactive);
        }

        ASSERTACTIVELIST(activeList, yCurrent);

        // Do the appropriate alternate or winding, supersampled or 
        // non-supersampled fill:

        (filler->*fillerFunction)(activeList, yCurrent);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Fill (or sometimes stroke) that path.
*
* Created:
*
*   03/25/2000 andrewgo
*
\**************************************************************************/

GpStatus
RasterizePath(
    const DpPath    *path,
    GpMatrix        *worldTransform,
    GpFillMode       fillMode,
    BOOL             antiAlias,
    BOOL             nominalWideLine,
    DpOutputSpan    *output,
    DpClipRegion    *clipper,
    const GpRect    *drawBounds
    )
{
    EpInactiveEdge inactiveArrayStack[INACTIVE_LIST_NUMBER];
    EpInactiveEdge *inactiveArray;
    EpInactiveEdge *inactiveArrayAllocation;
    EpEdge headEdge;
    EpEdge tailEdge;
    EpEdge *activeList;
    RECT clipBounds;
    GpRect clipRect;
    EpEdgeStore edgeStore;
    EpInitializeEdgesContext edgeContext;
    INT yClipBottom;

    inactiveArrayAllocation = NULL;
    edgeContext.ClipRect = NULL;

    tailEdge.X = INT_MAX;       // Terminator to active list
    tailEdge.StartY = INT_MAX;  // Terminator to inactive list

    tailEdge.EndY = INT_MIN;
    headEdge.X = INT_MIN;       // Beginning of active list
    edgeContext.MaxY = INT_MIN;

    headEdge.Next = &tailEdge;
    activeList = &headEdge;
    edgeContext.Store = &edgeStore;

    edgeContext.IsAntialias = antiAlias;

    //////////////////////////////////////////////////////////////////////////

    DpRegion::Visibility visibility = clipper->GetRectVisibility(
                    drawBounds->X,
                    drawBounds->Y,
                    drawBounds->X + drawBounds->Width,
                    drawBounds->Y + drawBounds->Height);

    if (visibility != DpRegion::TotallyVisible)
    {
        clipper->GetBounds(&clipRect);

        // !!![andrewgo] Don, why do we have to do an 'Invisible' test
        //               here?  Shouldn't GetRectVisibility have already
        //               taken care of that case?  (GetRectVisibility
        //               was checked by our caller.)

        // Early-out if we're invisible, or if the bounds would overflow
        // our DDA calculations (which would cause us to crash).  We
        // leave 4 bits for the 28.4 fixed point, plus enough bits for
        // the antialiasing supersampling.  We also need a bit for doing
        // a signed difference without overflowing.

        if ((visibility == DpRegion::Invisible) ||
            (clipRect.X < (INT_MIN >> (5 + AA_X_SHIFT))) ||
            (clipRect.Y < (INT_MIN >> (5 + AA_Y_SHIFT))) ||
            (clipRect.X > (INT_MAX >> (5 + AA_X_SHIFT))) ||
            (clipRect.Y > (INT_MAX >> (5 + AA_Y_SHIFT))) ||
            (clipRect.Width  > (INT_MAX >> (5 + AA_X_SHIFT))) ||
            (clipRect.Height > (INT_MAX >> (5 + AA_Y_SHIFT))))
        {
            return(Ok);
        }

        // Scale the clip bounds rectangle by 16 to account for our 
        // scaling to 28.4 coordinates:
    
        clipBounds.left = clipRect.GetLeft() * 16;
        clipBounds.top = clipRect.GetTop() * 16;
        clipBounds.right = clipRect.GetRight() * 16;
        clipBounds.bottom = clipRect.GetBottom() * 16;

        yClipBottom = clipRect.GetBottom();

        edgeContext.ClipRect = &clipBounds;
    }

    //////////////////////////////////////////////////////////////////////////

    // Convert all our points to 28.4 fixed point:

    GpMatrix matrix(*worldTransform);
    matrix.AppendScale(TOREAL(16), TOREAL(16));

    // Enumerate the path and construct the edge table:

    FIXEDPOINTPATHENUMERATEFUNCTION pathEnumerationFunction = InitializeEdges;
    
    PathEnumerateType enumType = PathEnumerateTypeFill;
    
    if (nominalWideLine)
    {
        // The nominal-width wideline code always produces edges that
        // require a winding-mode fill:

        pathEnumerationFunction = InitializeNominal;
        fillMode = FillModeWinding;
        enumType = PathEnumerateTypeStroke;   // nominal width is a stroke.
    }

    if (!FixedPointPathEnumerate(
        path, 
        &matrix, 
        edgeContext.ClipRect,
        enumType, 
        pathEnumerationFunction, 
        &edgeContext
        ))
    {
        return(OutOfMemory);
    }

    INT totalCount = edgeStore.StartEnumeration();
    if (totalCount == 0)
        return(Ok);     // We're outta here (empty path or entirely clipped)

    // At this point, there has to be at least two edges.  If there's only
    // one, it means that we didn't do the trivially rejection properly.

    ASSERT(totalCount >= 2);

    inactiveArray = &inactiveArrayStack[0];
    if (totalCount > (INACTIVE_LIST_NUMBER - 2))
    {
        inactiveArrayAllocation = static_cast<EpInactiveEdge*>
            (GpMalloc(sizeof(EpInactiveEdge) * (totalCount + 2)));
        if (inactiveArrayAllocation == NULL)
            return(OutOfMemory);

        inactiveArray = inactiveArrayAllocation;
    }

    // Initialize and sort the inactive array:

    INT yCurrent = InitializeInactiveArray(&edgeStore, inactiveArray, 
                                           totalCount, &tailEdge);
    INT yBottom = edgeContext.MaxY;

    ASSERT(yBottom > 0);

    // Skip the head sentinel on the inactive array:

    inactiveArray++;

    if (antiAlias)
    {
        EpAntialiasedFiller filler(output);

        EpFillerFunction fillerFunction = (fillMode == FillModeAlternate) 
            ? (EpFillerFunction) (EpAntialiasedFiller::FillEdgesAlternate)
            : (EpFillerFunction) (EpAntialiasedFiller::FillEdgesWinding);

        if (edgeContext.ClipRect)
        {
            filler.SetClipper(clipper);

            // The clipper has to call back to EpFillerFunction::OutputSpan
            // to do the output, and then *we* call output->OutputSpan.

            clipper->InitClipping(&filler, drawBounds->Y);

            // 'yClipBottom' is in 28.4 format, and has to be converted
            // to the 30.2 format we use for antialiasing:

            yBottom = min(yBottom, yClipBottom << AA_Y_SHIFT);

            // 'totalCount' should have been zero if all the edges were
            // clipped out (RasterizeEdges assumes there's at least one edge
            // to be drawn):

            ASSERT(yBottom > yCurrent);
        }

        RasterizeEdges(activeList, inactiveArray, yCurrent, yBottom, &filler,
                       fillerFunction);
    }
    else
    {
        EpAliasedFiller filler(output);

        EpFillerFunction fillerFunction = (fillMode == FillModeAlternate) 
            ? (EpFillerFunction) (EpAliasedFiller::FillEdgesAlternate)
            : (EpFillerFunction) (EpAliasedFiller::FillEdgesWinding);

        if (edgeContext.ClipRect)
        {
            // The clipper calls output->OutputSpan directly.  We just have
            // to remember to call clipper->OutputSpan instead of 
            // output->OutputSpan:

            filler.SetOutputSpan(clipper);

            clipper->InitClipping(output, drawBounds->Y);

            yBottom = min(yBottom, yClipBottom);

            // 'totalCount' should have been zero if all the edges were
            // clipped out (RasterizeEdges assumes there's at least one edge
            // to be drawn):

            ASSERT(yBottom > yCurrent);
        }

        RasterizeEdges(activeList, inactiveArray, yCurrent, yBottom, &filler,
                       fillerFunction);
    }

    // Free any objects and get outta here:

    if (inactiveArrayAllocation != NULL)
        GpFree(inactiveArrayAllocation);

    return(Ok);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\alphablender.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Alpha-blender
*
* Abstract:
*
*   A class which alpha-blends a source scanline in either sRGB or
*   sRGB64 format, to a destination of arbitrary format. 
*
*   The operation can be either a SrcOver or a SrcCopy. 
*   A quality hint can be used to make the "SrcOver using sRGB source" case 
*   do a higher-quality blend in the sRGB64 color space.
*
* Created:
*
*   01/03/2000 agodfrey
*       Created it.
*   02/22/2001 agodfrey
*       Expanded it for different scan types (needed for ClearType).
*       Simplified the Initialize() parameters by adding a 
*       DpContext parameter.
*
\**************************************************************************/

#ifndef _ALPHABLENDER_HPP
#define _ALPHABLENDER_HPP

//--------------------------------------------------------------------------
// The different Scan types:
//
// Blend: The typical alpha-blending operation.
//        Context->CompositingMode specifies the blend mode.
//
// Opaque: Opaque can be used in place of Blend, when all the input pixels
//         are opaque. This applies to both SrcCopy and SrcOver blends.
//         (But right now, EpAlphaBlender doesn't distinguish properly
//          between Opaque and SrcCopy. See bug #127412.)
//
// OpaqueSolidFill is a further specialized version of Opaque, in which all
// the input pixels are the same color. Disabled until the back-end supports
// these kinds of scan.
//
// CT and CTSolidFill are the ClearType blends - with an arbitrary brush,
// or a solid (single-color) one, respectively.
//
// Note: We depend on these values starting at 0 and being consecutive -
//       we use them as array indices.
//              
// Max: Counts the number of "real" scan types.
// Unknown: Used where we don't know the type. This allows us to specify
//     the scan type either in Start(), or in NextBuffer(), depending on
//     the situation.
//
//--------------------------------------------------------------------------

enum EpScanType
{
    EpScanTypeBlend,
    EpScanTypeOpaque,
    
    // EpScanTypeOpaqueSolidFill,
    
    EpScanTypeCT,
    EpScanTypeCTSolidFill,
    
    // End of "real" scan types.
    
    EpScanTypeMax,
    EpScanTypeUnknown = EpScanTypeMax
};

#include "ScanOperation.hpp"

// !!! [asecchia] This include needs to be cleaned up when we fix 
// the imaging.h mess.
#include "..\..\privinc\pixelformats.h"

class EpAlphaBlender
{
public:
    EpAlphaBlender() 
    { 
        Initialized = FALSE; 
        ConvertBlendingScan = FALSE;
    }
    
    ~EpAlphaBlender() {}

    // Right now, everyone sets "dither16bpp" to TRUE.
    // I can see it being useful, perhaps renamed to "shouldDither", 
    // to support an API to make us quantize & dither the way GDI does.

    VOID
    Initialize(
        EpScanType scanType,
        PixelFormatID dstFormat,
        PixelFormatID srcFormat,
        const DpContext *context,
        const ColorPalette *dstpal,
        VOID **tempBuffers,
        BOOL dither16bpp,
        BOOL useRMW,
        ARGB solidColor
        );

    VOID Blend(
        VOID *dst, 
        VOID *src, 
        UINT width, 
        INT dither_x, 
        INT dither_y,
        BYTE *ctBuffer
        );

    VOID UpdatePalette(const ColorPalette *dstpal, const EpPaletteMap *paletteMap);
    
    // Returns true if EpAlphaBlender knows how to convert 
    // the specified pixelFormat.    
    
    static BOOL IsSupportedPixelFormat(PixelFormatID pixelFormat)
    {
        return (
           pixelFormat != PixelFormatUndefined &&
           pixelFormat != PixelFormatMulti &&
           pixelFormat != PixelFormat1bppIndexed &&
           pixelFormat != PixelFormat4bppIndexed &&
           pixelFormat != PixelFormat16bppGrayScale &&
           pixelFormat != PixelFormat16bppARGB1555
        );
    }
private:

    // Records whether Initialize() has been called yet
    BOOL Initialized;

    ScanOperation::OtherParams OperationParameters;

    // An internal helper class, used only by Initialize().
    
    class Builder;
    
    // The IA64 compiler seems to need some convincing:
    friend class Builder;
    
    // ConvertBlendingScan:
    //   TRUE:  The pipeline will convert the blending scan to another
    //          format before using it
    //   FALSE: The pipeline will use the original passed-in blending scan
    //          (this is the common case).
    
    BOOL ConvertBlendingScan;
    
    // We represent the pipeline with an array of PipelineItem structures.
    //   Src - the source buffer for the operation. Can also be 
    //         BLENDER_USE_SOURCE or BLENDER_USE_DESTINATION. (q.v.)
    //   Dst - the destination buffer for the operation. For the final
    //         operation of the pipeline, and only then, 
    //         Dst == BLENDER_USE_DESTINATION.
        
    struct PipelineItem
    {
        ScanOperation::ScanOpFunc Op;
        VOID *Src;
        VOID *Dst;
        
        PipelineItem() {} 
        
        PipelineItem(
            ScanOperation::ScanOpFunc op,
            VOID *src,
            VOID *dst
            )
        {
            Op = op;
            Src = src;
            Dst = dst;
        }
    };
    
    enum 
    {
        MAX_ITEMS = 20
    };
    
    // !!! [agodfrey]: MAX_ITEMS was 8. I'm boosting it until we know what the 
    // maximum really should be, so that I can hack in the meantime.

    PipelineItem Pipeline[MAX_ITEMS];   // the scan operation pipeline
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\aarasterizer.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   AARasterizer.hpp
*
* Abstract:
*
*   GpRasterizer class definition (and supporting classes)
*
* Created:
*
*   04/12/99 AMatos
*
\**************************************************************************/

#ifndef _AARASTERIZER_HPP
#define _AARASTERIZER_HPP

// It's possible to have higher 'X' resolution antialiasing than 'Y', with
// only a slight decrease in performance:

#define AA_X_WIDTH  8
#define AA_X_MASK   7
#define AA_X_HALF   4
#define AA_X_SHIFT  3

#define AA_Y_HEIGHT 4
#define AA_Y_MASK   3
#define AA_Y_HALF   2
#define AA_Y_SHIFT  2

// Calculate the new color channel value according to the coverage:
//
//      round((c * multiplier) / 2^(shift))

#define MULTIPLY_COVERAGE(c, multiplier, shift) \
    static_cast<UCHAR>((static_cast<UINT>(c) * (multiplier) \
                        + (1 << ((shift) - 1))) >> (shift))

// SWAP macro:

#define SWAP(temp, a, b) { temp = a; a = b; b = temp; }

enum PathEnumerateTermination {
    PathEnumerateContinue,      // more to come in this subpath
    PathEnumerateEndSubpath,    // end this subpath.
    PathEnumerateCloseSubpath   // end this subpath with a close figure.
};

typedef BOOL (*FIXEDPOINTPATHENUMERATEFUNCTION)(
    VOID *, POINT *, INT, PathEnumerateTermination
);

enum PathEnumerateType {
    PathEnumerateTypeStroke,
    PathEnumerateTypeFill,
    PathEnumerateTypeFlatten
};

BOOL 
FixedPointPathEnumerate(
    const DpPath *path,
    const GpMatrix *matrix,
    const RECT *clipRect,       
    PathEnumerateType enumType,                
    FIXEDPOINTPATHENUMERATEFUNCTION enumerateFunction,
    VOID *enumerateContext
    );

GpStatus
RasterizePath(
    const DpPath    *path,
    GpMatrix        *worldTransform,
    GpFillMode       fillMode,
    BOOL             antiAlias,
    BOOL             nominalWideLine,
    DpOutputSpan    *output,
    DpClipRegion    *clipper,
    const GpRect    *drawBounds
    );

#endif // _AARASTERIZER_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\bicubic.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   bicubic.cpp
*
* Abstract:
*
*   Bicubic Resampling code
*
* Created:
*
*   11/03/1999 ASecchia
\**************************************************************************/

#include "precomp.hpp"

DpOutputBicubicImageSpan::DpOutputBicubicImageSpan(
    DpBitmap* bitmap,
    DpScanBuffer * scan,
    DpContext* context,
    DpImageAttributes imageAttributes,
    INT numPoints,
    const GpPointF *dstPoints,
    const GpRectF *srcRect
    )
{
    Scan     = scan;
    BWrapMode = imageAttributes.wrapMode;
    ClampColor = imageAttributes.clampColor;
    SrcRectClamp = imageAttributes.srcRectClamp;
    dBitmap   = bitmap;

    ASSERT(dBitmap != NULL);
    ASSERT(dBitmap->IsValid());

    // on bad bitmap, we return with Valid = FALSE
    if (dBitmap == NULL ||
        !dBitmap->IsValid() )
    {
        dBitmap = NULL;
        return;
    } else {
        BmpData.Width = dBitmap->Width;
        BmpData.Height = dBitmap->Height;
        BmpData.PixelFormat = PIXFMT_32BPP_PARGB;
        BmpData.Stride = dBitmap->Delta;
        BmpData.Scan0 = dBitmap->Bits;
    }

    WorldToDevice = context->WorldToDevice;
    context->GetDeviceToWorld(&DeviceToWorld);

    if(srcRect)
        SrcRect = *srcRect;
    else
    {
        SrcRect.X = 0;
        SrcRect.Y = 0;
        SrcRect.Width  = (REAL) dBitmap->Width;
        SrcRect.Height = (REAL) dBitmap->Height;
    }

    GpPointF points[4];

    GpMatrix xForm;
    BOOL existsTransform = TRUE;

    switch(numPoints)
    {
    case 0:
        points[0].X = 0;
        points[0].Y = 0;
        points[1].X = (REAL) SrcRect.Width;
        points[1].Y = 0;
        points[2].X = 0;
        points[2].Y = (REAL) SrcRect.Height;
        break;

    case 1:
        points[0] = dstPoints[0];
        points[1].X = (REAL) (points[0].X + SrcRect.Width);
        points[1].Y = points[0].Y;
        points[2].X = points[0].X;
        points[2].Y = (REAL) (points[0].Y + SrcRect.Height);
        break;

    case 3:
    case 4:
        GpMemcpy(&points[0], dstPoints, numPoints*sizeof(GpPointF));
        break;

    default:
        existsTransform = FALSE;
    }

    if(existsTransform)
    {
        xForm.InferAffineMatrix(points, SrcRect);
    }

    WorldToDevice = context->WorldToDevice;
    WorldToDevice.Prepend(xForm);
    if(WorldToDevice.IsInvertible())
    {
        DeviceToWorld = WorldToDevice;
        DeviceToWorld.Invert();
    }
}

namespace DpOutputBicubicImageSpanNS {
const INT KernShift = 6;
const INT Oversample = 1 << KernShift;
const FIX16 kern[2*Oversample+1] =
{
    65536, 65496, 65379, 65186, 64920, 64583, 64177, 63705,
    63168, 62569, 61911, 61195, 60424, 59600, 58725, 57802,
    56832, 55818, 54763, 53668, 52536, 51369, 50169, 48939,
    47680, 46395, 45087, 43757, 42408, 41042, 39661, 38268,
    36864, 35452, 34035, 32614, 31192, 29771, 28353, 26941,
    25536, 24141, 22759, 21391, 20040, 18708, 17397, 16110,
    14848, 13614, 12411, 11240, 10104,  9005,  7945,  6927,
     5952,  5023,  4143,  3313, 2536,  1814,  1149,   544,
        0,  -496,  -961, -1395, -1800, -2176, -2523, -2843,
    -3136, -3403, -3645, -3862, -4056, -4227, -4375, -4502,
    -4608, -4694, -4761, -4809, -4840, -4854, -4851, -4833,
    -4800, -4753, -4693, -4620, -4536, -4441, -4335, -4220,
    -4096, -3964, -3825, -3679, -3528, -3372, -3211, -3047,
    -2880, -2711, -2541, -2370, -2200, -2031, -1863, -1698,
    -1536, -1378, -1225, -1077, -936,  -802,  -675,  -557,
     -448,  -349,  -261,  -184, -120,   -69,   -31,    -8,
        0
};


#ifdef _X86_

const short kern14[2*Oversample+1] =
{
    16384, 16374, 16345, 16297, 16230, 16146, 16044, 15926,
    15792, 15642, 15478, 15299, 15106, 14900, 14681, 14451,
    14208, 13955, 13691, 13417, 13134, 12842, 12542, 12235,
    11920, 11599, 11272, 10939, 10602, 10261,  9915,  9567,
     9216,  8863,  8509,  8154,  7798,  7443,  7088,  6735,
     6384,  6035,  5690,  5348,  5010,  4677,  4349,  4028,
     3712,  3404,  3103,  2810,  2526,  2251,  1986,  1732,
     1488,  1256,  1036,   828,   634,   454,   287,   136,
        0,  -124,  -240,  -349,  -450,  -544,  -631,  -711,
     -784,  -851,  -911,  -966, -1014, -1057, -1094, -1126,
    -1152, -1174, -1190, -1202, -1210, -1214, -1213, -1208,
    -1200, -1188, -1173, -1155, -1134, -1110, -1084, -1055,
    -1024,  -991,  -956,  -920,  -882,  -843,  -803,  -762,
     -720,  -678,  -635,  -593,  -550,  -508,  -466,  -425,
     -384,  -345,  -306,  -269,  -234,  -201,  -169,  -139,
     -112,   -87,   -65,   -46,   -30,   -17,    -8,    -2,
        0
};

#pragma warning(disable : 4799)

ARGB FASTCALL Do1DBicubicMMX(ARGB filter[4], short w[4])
{
    ARGB result;
    
    static ULONGLONG HalfFix3 = 0x0004000400040004;

    // really should do this function without any preamble.
    _asm
    {
        mov        eax, filter     ;
        mov        ebx, w          ;
        pxor       mm0, mm0        ; zero

        movq       mm1, [ebx]      ; w

        movd       mm4, [eax]      ; filter[0]
        movd       mm5, [eax+4]    ; filter[1]
        movd       mm6, [eax+8]    ; filter[2]
        movd       mm7, [eax+0xc]  ; filter[3]

        punpcklbw  mm4, mm0        ; 0a0r0g0b (interleave zeros)
        punpcklbw  mm5, mm0        ;
        punpcklbw  mm6, mm0        ;
        punpcklbw  mm7, mm0        ;

        psllw      mm4, 5          ; 2 to compensate for the kernel resolution +
        psllw      mm5, 5          ; 3 to support some fractional bits for the add.
        psllw      mm6, 5          ;
        psllw      mm7, 5          ;

        movq       mm2, mm1        ;
        punpcklwd  mm2, mm2        ; w1 w1 w0 w0
        movq       mm3, mm2        ;
        punpckldq  mm2, mm2        ; w0
        punpckhdq  mm3, mm3        ; w1

        pmulhw     mm4, mm2        ; filter[0]*w0
        pmulhw     mm5, mm3        ; filter[1]*w1

        punpckhwd  mm1, mm1        ; w3 w3 w2 w2
        movq       mm2, mm1        ;
        punpckldq  mm1, mm1        ; w2
        punpckhdq  mm2, mm2        ; w3

        pmulhw     mm6, mm1        ; filter[2]*w2
        pmulhw     mm7, mm2        ; filter[3]*w3

        paddsw     mm4, mm5        ; add
        paddsw     mm6, mm7        ; add
        paddsw     mm4, mm6        ; add

        movq       mm3, HalfFix3   ; 
        paddsw     mm4, mm3        ; add half
        psraw      mm4, 3          ; round the fractional bits away.
        
        packuswb   mm4, mm4        ; saturate between [0, 0xff]

        ; need to saturate the r, g, b components to range 0..a

        movq       mm0, mm4        ;
        punpcklbw  mm0, mm0        ; aarrggbb
        punpckhwd  mm0, mm0        ; aaaarrrr
        psrlq      mm0, 32         ; 0000aaaa
        mov        eax, 0xffffffff ;
        movd       mm1, eax        ;
        psubb      mm1, mm0        ; 255-a
        paddusb    mm4, mm1        ; saturate against 255
        psubusb    mm4, mm1        ; drop it back to the right range

        movd       result, mm4     ;
        //emms; this instruction is done by the caller.
    }
    return result;
}
#endif

inline ARGB Do1DBicubic(ARGB filter[4], const FIX16 x)
{
    // Lookup the convolution kernel.
    FIX16 w0 = kern[Oversample+x];
    FIX16 w1 = kern[x];
    FIX16 w2 = kern[Oversample-x];
    FIX16 w3 = kern[2*Oversample-x];

    // Cast to LONG so that we preserve the sign when we start
    // shifting values around - the bicubic filter will often
    // have negative intermediate color components.
    ULONG *p = (ULONG *)filter;
    LONG a, r, g, b;

    // Casting of p to ULONG and then having the LONG casts in the expressions
    // below is to work around a compiler sign extension bug.
    // In this particular case, the bug was dropping the '& 0xff' from the
    // green component expression causing it to become negative
    // which gets clamped to zero.
    // When the bug is fixed, p should be reverted to LONG and casted to LONG
    // and the LONG casts should be removed from the expressions below.

    // Alpha component
    a = (w0 * (LONG)((p[0] >> 24) & 0xff) +
         w1 * (LONG)((p[1] >> 24) & 0xff) +
         w2 * (LONG)((p[2] >> 24) & 0xff) +
         w3 * (LONG)((p[3] >> 24) & 0xff)) >> FIX16_SHIFT;
    a = (a < 0) ? 0 : (a > 255) ? 255 : a;

    // We have premultiplied alpha values - clamp R, G, B to alpha
    // Red component
    r = (w0 * (LONG)((p[0] >> 16) & 0xff) +
         w1 * (LONG)((p[1] >> 16) & 0xff) +
         w2 * (LONG)((p[2] >> 16) & 0xff) +
         w3 * (LONG)((p[3] >> 16) & 0xff)) >> FIX16_SHIFT;
    r = (r < 0) ? 0 : (r > a) ? a : r;

    // Green component
    g = (w0 * (LONG)((p[0] >> 8) & 0xff) +
         w1 * (LONG)((p[1] >> 8) & 0xff) +
         w2 * (LONG)((p[2] >> 8) & 0xff) +
         w3 * (LONG)((p[3] >> 8) & 0xff)) >> FIX16_SHIFT;
    g = (g < 0) ? 0 : (g > a) ? a : g;

    // Blue component
    b = (w0 * (LONG)(p[0] & 0xff) +
         w1 * (LONG)(p[1] & 0xff) +
         w2 * (LONG)(p[2] & 0xff) +
         w3 * (LONG)(p[3] & 0xff)) >> FIX16_SHIFT;
    b = (b < 0) ? 0 : (b > a) ? a : b;

    return ((a << 24) | (r << 16) | (g << 8) | b);
}
} // end DpOutputBicubicImageSpanNS


GpStatus
DpOutputBicubicImageSpan::OutputSpan(
  INT y,
  INT xMin,
  INT xMax     // xMax is exclusive
)
{
    // Nothing to do.

    if(xMin==xMax)
    {
        return Ok;
    }

    ASSERT(xMin < xMax);

    GpPointF p1, p2;
    p1.X = (REAL) xMin;
    p1.Y = p2.Y = (REAL) y;
    p2.X = (REAL) xMax;

    DeviceToWorld.Transform(&p1);
    DeviceToWorld.Transform(&p2);

    // Convert to Fixed point notation - 16 bits of fractional precision.
    FIX16 dx, dy, x0, y0;
    x0 = GpRound(p1.X*FIX16_ONE);
    y0 = GpRound(p1.Y*FIX16_ONE);

    ASSERT(xMin < xMax);
    dx = GpRound(((p2.X - p1.X)*FIX16_ONE)/(xMax-xMin));
    dy = GpRound(((p2.Y - p1.Y)*FIX16_ONE)/(xMax-xMin));

    return OutputSpanIncremental(y, xMin, xMax, x0, y0, dx, dy);
}

GpStatus
DpOutputBicubicImageSpan::OutputSpanIncremental(
    INT      y,
    INT      xMin,
    INT      xMax,
    FIX16    x0,
    FIX16    y0,
    FIX16    dx,
    FIX16    dy
    )
{
    using namespace DpOutputBicubicImageSpanNS;
    INT width  = xMax - xMin;
    ARGB *buffer = Scan->NextBuffer(xMin, y, width);
    ARGB *srcPtr0 = static_cast<ARGB*> (BmpData.Scan0);
    INT stride = BmpData.Stride/sizeof(ARGB);

    INT ix;
    INT iy;
    FIX16 fracx;        // hold the fractional increment for ix
    FIX16 fracy;        // hold the fractional increment for iy

    ARGB filter[4][4];  // 4x4 filter array.
    INT xstep, ystep;   // loop variables in x and y
    INT wx[4];
    INT wy[4];          // wrapped coordinates

    // For all pixels in the destination span...
    for(int i=0; i<width; i++)
    {
        // .. compute the position in source space.

        // floor
        ix = x0 >> FIX16_SHIFT;
        iy = y0 >> FIX16_SHIFT;

        // Apply the wrapmode to all possible kernel combinations.
        for(xstep=0;xstep<4;xstep++) {
            wx[xstep] = ix+xstep-1;
            wy[xstep] = iy+xstep-1;
        }


        if(BWrapMode != WrapModeClamp) {
            if( ( (UINT)(ix-1) >= (UINT)( max(((INT)BmpData.Width)-4,0))) ||
                ( (UINT)(iy-1) >= (UINT)( max(((INT)BmpData.Height)-4,0))) )
            {
                for(xstep=0;xstep<4;xstep++) {
                    ApplyWrapMode(BWrapMode, wx[xstep], wy[xstep], BmpData.Width, BmpData.Height);
                }
            }
        }

        // Check to see if we're outside of the valid drawing range specified
        // in the DpBitmap.

        fracx = (x0  & FIX16_MASK) >> (FIX16_SHIFT-KernShift);
        fracy = (y0  & FIX16_MASK) >> (FIX16_SHIFT-KernShift);

        // Build up the filter domain surrounding the current pixel.
        // Technically the loops below should go from -2 to 2 to correctly
        // handle the case of fracx or fracy == 0, but our convolution kernel
        // has zero at that point anyway, so we optimize it away.
        
        for(ystep=0;ystep<4;ystep++) for(xstep=0;xstep<4;xstep++)
        {
            // !!! PERF: check the y step outside
            //       of the x loop and use memset to fill the entire line.
            //       This should reduce the complexity of the inner loop
            //       comparison.

            // Make sure the pixel is within the bounds of the source before
            // accessing it.

            if( ((wx[xstep]) >=0) &&
                ((wy[ystep]) >=0) &&
                ((wx[xstep]) < (INT)(BmpData.Width)) &&
                ((wy[ystep]) < (INT)(BmpData.Height)) )
            {
                filter[xstep][ystep] =
                  *(srcPtr0+stride*(wy[ystep])+(wx[xstep]));
            } else {
                // This means that this source pixel is outside of the valid
                // bits in the source. (edge condition)
                filter[xstep][ystep] = (ARGB) ClampColor;
            }
        }

        #ifdef _X86_
        if(OSInfo::HasMMX)
        {
            // Lookup the convolution kernel.
            short w[4];

            w[0] = kern14[Oversample+fracy];
            w[1] = kern14[fracy];
            w[2] = kern14[Oversample-fracy];
            w[3] = kern14[2*Oversample-fracy];

            // Filter the 4 vertical pixel columns
            // Reuse filter[0] to store the intermediate result
            for(xstep=0;xstep<4;xstep++)
            {
                filter[0][xstep] = Do1DBicubicMMX(filter[xstep], w);
            }

                // Lookup the convolution kernel.

            w[0] = kern14[Oversample+fracx];
            w[1] = kern14[fracx];
            w[2] = kern14[Oversample-fracx];
            w[3] = kern14[2*Oversample-fracx];

            // Filter horizontally.
            *buffer++ = Do1DBicubicMMX(filter[0], w);

            // Update source position
            x0 += dx;
            y0 += dy;
        }
        else
        #endif
        {
            // Filter the 4 vertical pixel columns
            // Reuse filter[0] to store the intermediate result
            for(xstep=0;xstep<4;xstep++)
            {
                filter[0][xstep] = Do1DBicubic(filter[xstep], fracy);
            }

            // Filter horizontally.
            *buffer++ = Do1DBicubic(filter[0], fracx);

            // Update source position
            x0 += dx;
            y0 += dy;
        }
    }

    // Clear the MMX state

    #ifdef _X86_
    if(OSInfo::HasMMX)
    {
        _asm emms;
    }
    #endif

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\bicubic.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   bicubic.hpp
*
* Abstract:
*
*   Bicubic Resampling code
*
* Created:
*
*   11/03/1999 ASecchia
\**************************************************************************/

#pragma once

class DpOutputBicubicImageSpan : public DpOutputSpan
{
public:
    DpBitmap *dBitmap;
    BitmapData BmpData;
    DpScanBuffer *  Scan;
    WrapMode BWrapMode;
    ARGB ClampColor;
    BOOL SrcRectClamp;
    GpRectF SrcRect;
    GpMatrix WorldToDevice;
    GpMatrix DeviceToWorld;

public:
    DpOutputBicubicImageSpan(
        DpBitmap* bitmap,
        DpScanBuffer * scan,
        DpContext* context,
        DpImageAttributes imageAttributes,
        INT numPoints,
        const GpPointF *dstPoints,
        const GpRectF *srcRect
    );

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
    );

    virtual GpStatus OutputSpanIncremental(
        INT      y,
        INT      xMin,
        INT      xMax,
        FIX16    x0,
        FIX16    y0,
        FIX16    dx,
        FIX16    dy
    );

    virtual BOOL IsValid() const { return (dBitmap!=NULL); }
    DpScanBuffer* GetScanBuffer(){ return Scan; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\alphablender.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Alpha-blender
*
* Abstract:
*
*   A class which alpha-blends a source scanline in either sRGB or
*   sRGB64 format, to a destination of arbitrary format. 
*
* Revision History:
*
*   01/03/2000 agodfrey
*       Created it.
*   02/22/2001 agodfrey
*       Expanded it for different scan types (needed for ClearType).
*       Simplified the Initialize() parameters by adding a 
*       DpContext parameter.
*
\**************************************************************************/

#include "precomp.hpp"

#include "scanoperationinternal.hpp"

// !!![agodfrey] Hack:
const ColorPalette*
GetDefaultColorPalette(PixelFormatID pixfmt);

inline UINT
GetPixelFormatIndex(
    PixelFormatID pixfmt
    )
{
    return pixfmt & 0xff;
}
// !!![agodfrey] Endhack

// BLENDER_USE_DESTINATION and BLENDER_USE_SOURCE are used in the Src and 
// Dst fields of PipelineItem:
//    BLENDER_USE_SOURCE: Use the blend's original source  
//      (i.e. the sRGB/sRGB64 scanbuffer)
//    BLENDER_USE_DESTINATION: Use the blend's final destination.
//    BLENDER_INVALID: Used in the debug build for assertions.

#define BLENDER_USE_DESTINATION ((VOID *) 0)
#define BLENDER_USE_SOURCE ((VOID *) 1)
#define BLENDER_INVALID ((VOID *) 2)

using namespace ScanOperation;

/**************************************************************************\
*
* Special-case blend operations which blend directly to a given destination
* format (with the source in 32BPP_PARGB).
*
* Notes:
*
*   The 555/565 cases handle both dithering and non-dithering,
*   selected via OtherParams::DoingDither.
*
*   We leave out PIXFMT_32BPP_ARGB and PIXFMT_64BPP_ARGB, since they're not
*   "ignore destination alpha" formats, so we'd need to AlphaDivide after 
*   the blend.
*
\**************************************************************************/

ScanOpFunc ScanOperation::BlendOpsLowQuality[PIXFMT_MAX] =
{
    NULL,                         // PIXFMT_UNDEFINED
    NULL,                         // PIXFMT_1BPP_INDEXED
    NULL,                         // PIXFMT_4BPP_INDEXED
    NULL,                         // PIXFMT_8BPP_INDEXED
    NULL,                         // PIXFMT_16BPP_GRAYSCALE
    Dither_Blend_sRGB_555,        // PIXFMT_16BPP_RGB555
    Dither_Blend_sRGB_565,        // PIXFMT_16BPP_RGB565
    NULL,                         // PIXFMT_16BPP_ARGB1555
    Blend_sRGB_24,                // PIXFMT_24BPP_RGB
    Blend_sRGB_sRGB,              // PIXFMT_32BPP_RGB
    NULL,                         // PIXFMT_32BPP_ARGB
    Blend_sRGB_sRGB,              // PIXFMT_32BPP_PARGB
    NULL,                         // PIXFMT_48BPP_RGB
    NULL,                         // PIXFMT_64BPP_ARGB
    NULL,                         // PIXFMT_64BPP_PARGB
    Blend_sRGB_24BGR              // PIXFMT_24BPP_BGR
};

/**************************************************************************\
*
* Special-case gamma-corrected blend operations which blend directly to a 
* given destination format (with the source in 32BPP_PARGB).
*
* Notes:
*
*   The 555/565 cases must handle both dithering and non-dithering,
*   selected via OtherParams::DoingDither.
*
*   We leave out PIXFMT_32BPP_ARGB and PIXFMT_64BPP_ARGB, since they're not
*   "ignore destination alpha" formats, so we'd need to AlphaDivide after 
*   the blend.
*
\**************************************************************************/

ScanOpFunc ScanOperation::BlendOpsHighQuality[PIXFMT_MAX] =
{
    NULL,                         // PIXFMT_UNDEFINED
    NULL,                         // PIXFMT_1BPP_INDEXED
    NULL,                         // PIXFMT_4BPP_INDEXED
    NULL,                         // PIXFMT_8BPP_INDEXED
    NULL,                         // PIXFMT_16BPP_GRAYSCALE
    BlendLinear_sRGB_555,         // PIXFMT_16BPP_RGB555
    BlendLinear_sRGB_565,         // PIXFMT_16BPP_RGB565
    NULL,                         // PIXFMT_16BPP_ARGB1555
    NULL,                         // PIXFMT_24BPP_RGB
    BlendLinear_sRGB_32RGB,       // PIXFMT_32BPP_RGB
    NULL,                         // PIXFMT_32BPP_ARGB
    NULL,                         // PIXFMT_32BPP_PARGB
    NULL,                         // PIXFMT_48BPP_RGB
    NULL,                         // PIXFMT_64BPP_ARGB
    Blend_sRGB64_sRGB64,          // PIXFMT_64BPP_PARGB
    NULL                          // PIXFMT_24BPP_BGR
};

/**************************************************************************\
*
* Operations which convert from the closest canonical format - either
* 32BPP_ARGB or 64BPP_ARGB).
*
* This is specific to EpAlphaBlender. EpFormatConverter uses a different
* table; some of the entries are different.
*
* The NULL entries for 32BPP_ARGB and 64_BPP_ARGB are used to indicate that no
* conversion is necessary.
*
* These operations work on all processors.
*
* Notes:
*
*   The 555/565 cases handle both dithering and non-dithering,
*   selected via OtherParams::DoingDither.
*
\**************************************************************************/

ScanOpFunc ScanOperation::ABConvertFromCanonicalOps[PIXFMT_MAX] =
{
    NULL,                         // PIXFMT_UNDEFINED
    NULL,                         // PIXFMT_1BPP_INDEXED
    NULL,                         // PIXFMT_4BPP_INDEXED
    HalftoneToScreen_sRGB_8_16,   // PIXFMT_8BPP_INDEXED
    NULL,                         // PIXFMT_16BPP_GRAYSCALE
    Dither_sRGB_555,              // PIXFMT_16BPP_RGB555
    Dither_sRGB_565,              // PIXFMT_16BPP_RGB565
    Quantize_sRGB_1555,           // PIXFMT_16BPP_ARGB1555
    Quantize_sRGB_24,             // PIXFMT_24BPP_RGB
    Quantize_sRGB_32RGB,          // PIXFMT_32BPP_RGB
    NULL,                         // PIXFMT_32BPP_ARGB
    AlphaMultiply_sRGB,           // PIXFMT_32BPP_PARGB
    Quantize_sRGB64_48,           // PIXFMT_48BPP_RGB
    NULL,                         // PIXFMT_64BPP_ARGB
    AlphaMultiply_sRGB64,         // PIXFMT_64BPP_PARGB
    Quantize_sRGB_24BGR           // PIXFMT_24BPP_BGR
};

// Builder: Holds the intermediate state and logic used to build the
//   blending pipeline.

class EpAlphaBlender::Builder
{
public:
    Builder(
        PipelineItem *pipelinePtr,
        VOID **tempBuffers,
        GpCompositingMode compositingMode
        )
    {
        TempBuffers = tempBuffers;
        PipelinePtr = pipelinePtr;
        
        // At the start, the source and destination data are in external
        // buffers.
        
        CurrentDstBuffer = BLENDER_USE_DESTINATION;
        CurrentSrcBuffer = BLENDER_USE_SOURCE;
        
#if DBG        
        CompositingMode = compositingMode;
        if (compositingMode == CompositingModeSourceCopy)
        {
            // In SourceCopy mode, we never read from the destination -
            // we only write to it.
            
            CurrentDstBuffer = BLENDER_INVALID;
        }
#endif

        // At the start, all 3 buffers are free. We'll use buffer 0 first.
        // The 'current' source and destination buffers are external buffers,
        // but we set CurrentDstIndex and CurrentSrcIndex in such a way that
        // the 'free buffer' logic works.
        
        FreeBufferIndex = 0;
        CurrentDstIndex = 1;
        CurrentSrcIndex = 2;
    }
    
    BOOL IsEmpty(
        EpAlphaBlender &blender
        )
    {
        return PipelinePtr == blender.Pipeline;
    }

    VOID End(
        EpAlphaBlender &blender
        )
    {
        // Check that we have at least one operation
        ASSERT(!IsEmpty(blender));
        
        // Check that we haven't overstepped the end of the pipeline space
        ASSERT(((PipelinePtr - blender.Pipeline) / sizeof(blender.Pipeline[0])) 
               <= MAX_ITEMS);
        
        // Many of these cases will not have set the destination of the final 
        // item in the pipeline correctly (it's hard for them to know that 
        // they're doing the last item in the pipeline). So we explicitly set 
        // it here.
        
        (PipelinePtr-1)->Dst = BLENDER_USE_DESTINATION;
        
        #if DBG
            // Make further member function calls hit an assertion.
            PipelinePtr = NULL;
        #endif
    }
    
    VOID
    AddConvertSource(
        ScanOperation::ScanOpFunc op
        )
    {
        // Check that we're not calling this when we shouldn't
        
        ASSERT(CurrentSrcBuffer != BLENDER_INVALID);
        
        // Choose the next temporary buffer
        
        INT nextIndex = FreeBufferIndex;
        VOID *nextBuffer = TempBuffers[nextIndex];
        
        // Add the operation
        
        AddOperation(op, CurrentSrcBuffer, nextBuffer);
        CurrentSrcBuffer = nextBuffer;
        
        // Swap the 'free' and 'current' indices.
        
        FreeBufferIndex = CurrentSrcIndex;
        CurrentSrcIndex = nextIndex;
    }
    
    VOID
    AddConvertDestination(
        ScanOperation::ScanOpFunc op
        )
    {
        // Check that we're not calling this when we shouldn't
        
        ASSERT(CompositingMode != CompositingModeSourceCopy);
        ASSERT(CurrentDstBuffer != BLENDER_INVALID);

        // Choose the next temporary buffer
        
        INT nextIndex = FreeBufferIndex;
        VOID *nextBuffer = TempBuffers[nextIndex];
        
        // Add the operation
        
        AddOperation(op, CurrentDstBuffer, nextBuffer);
        CurrentDstBuffer = nextBuffer;
        
        // Swap the 'free' and 'current' indices.
        
        FreeBufferIndex = CurrentDstIndex;
        CurrentDstIndex = nextIndex;
    }
    
    VOID
    AddBlend(
        ScanOperation::ScanOpFunc op,
        EpAlphaBlender &blender
        )
    {
        // Check that we're not calling this when we shouldn't

        ASSERT(CompositingMode != CompositingModeSourceCopy);
        ASSERT(CurrentSrcBuffer != BLENDER_INVALID);
        ASSERT(CurrentDstBuffer != BLENDER_INVALID);
        
        ASSERT(CurrentDstBuffer != BLENDER_USE_SOURCE);
        
        // If we're going to have to convert the source blend pixels, initialize
        // 'BlendingScan' to point to the temporary buffer in which the 
        // converted pixels will end up. Otherwise, Blend() will have to 
        // initialize 'BlendingScan'.
        
        if (CurrentSrcBuffer != BLENDER_USE_SOURCE)
        {
            blender.ConvertBlendingScan = TRUE;
            blender.OperationParameters.BlendingScan = CurrentSrcBuffer;
        }
        else
        {
            blender.ConvertBlendingScan = FALSE;
        }

        // The pipeline doesn't necessarily end with a WriteRMW operation
        // (or with one which contains it). So we must avoid blending from
        // one temporary buffer to another - the blend functions aren't 
        // strictly ternary, and so we would end up leaving garbage values
        // in the target temporary buffer (whenever we blend a completely
        // transparent pixel).
        
        AddOperation(op, CurrentDstBuffer, CurrentDstBuffer);

#if DBG
        // After this, we shouldn't call AddConvertSource or AddBlend again.
        CurrentSrcBuffer = BLENDER_INVALID;
        
        // And if this blend wasn't to a temporary buffer, this should be
        // the final operation in the pipeline. In particular, the caller
        // shouldn't try to add a WriteRMW operation after this.
        
        if (CurrentDstBuffer == BLENDER_USE_DESTINATION)
        {
            CurrentDstBuffer = BLENDER_INVALID;
        }
#endif        
    }

protected:    
    // AddOperation: Adds an operation to the pipeline.
    
    VOID 
    AddOperation(
        ScanOperation::ScanOpFunc op, 
        VOID *src,
        VOID *dst
        )
    {
        ASSERT(PipelinePtr != NULL);
        ASSERT(op != NULL);
        ASSERT(src != BLENDER_INVALID);
        ASSERT(dst != BLENDER_INVALID);
        
        *PipelinePtr++ = PipelineItem(op, src, dst);
    }

    PipelineItem *PipelinePtr; // Points to the space for the next item
    
    VOID **TempBuffers;        // The 3 temporary scan-line buffers
    
    INT FreeBufferIndex;       // The index of the next free scan-line buffer
    
    VOID *CurrentDstBuffer;    // The buffer holding the most recently-converted
    VOID *CurrentSrcBuffer;    // dst/src pixels.
    
    INT CurrentDstIndex;       // The index of the scan-line buffer equal
    INT CurrentSrcIndex;       // to CurrentDstBuffer/CurrentSrcBuffer (kinda)

#if DBG
    GpCompositingMode CompositingMode;
#endif
};

/**************************************************************************\
*
* Function Description:
*
*   Initialize the alpha-blender object
*
* Arguments:
*
*   scanType           - The type of scan to output.
*   dstFormat          - The pixel format of the destination. This shouldn't be
*                        lower than 8bpp.
*   srcFormat          - The pixel format of the source. This should be either
*                        PIXFMT_32BPP_PARGB, or PIXFMT_64BPP_PARGB, except in
*                        SourceCopy mode, in which it can be any legal 
*                        destination format.
*   context            - The graphics context.
*   dstpal             - The destination color palette, if the destination is
*                        palettized. (Can be NULL, but we'll need a palette to 
*                        be supplied [via UpdatePalette()] some time before 
*                        Blend() is called.)
*   tempBuffers        - An array of 3 pointers to temporary buffers, which
*                        should be 64-bit aligned (for perf reasons),
*                        and have enough space to hold a scan of 64bpp pixels.
*   dither16bpp        - If TRUE, and the destination format is 16bpp: We should
*                        dither to the destination.
*   useRMW             - Use the RMW optimization.
*   compositingQuality - Specifies whether to do a high-quality 
*                        (gamma-corrected) blend. A gamma-corrected blend will
*                        be used if this flag says so, or if the source or
*                        destination are linear formats like PIXFMT_64BPP_PARGB.
*
* Notes:
*
*   This code speaks of "canonical" formats - it means the two formats
*   PIXFMT_32BPP_ARGB and PIXFMT_64BPP_ARGB.
*
*   !!! [agodfrey]: "canonical" is a confusing word. We should just say
*       "intermediate" format.
*
*   This function may be called multiple times during the lifetime of an
*   EpAlphaBlender object.
*
*   All error cases are flagged as ASSERTs, so there is no return code.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
EpAlphaBlender::Initialize(
    EpScanType scanType,
    PixelFormatID dstFormat,
    PixelFormatID srcFormat,
    const DpContext *context,
    const ColorPalette *dstpal,
    VOID **tempBuffers,
    BOOL dither16bpp,
    BOOL useRMW,
    ARGB solidColor
    )
{
    // Isolate all the references to 'context'. Later, we may want to solve
    // the 'batching across primitives' problem, and depending on how we do
    // it, we may not want the original context passed down to this function.
    
    const EpPaletteMap *paletteMap = context->PaletteMap;
    GpCompositingMode compositingMode = context->CompositingMode;
    GpCompositingQuality compositingQuality = context->CompositingQuality;
    UINT textContrast = context->TextContrast;

    // ClearType doesn't work with SourceCopy
    BOOL isClearType = (scanType == EpScanTypeCT || scanType == EpScanTypeCTSolidFill);
    if (isClearType)
    {
        ASSERT(compositingMode != CompositingModeSourceCopy);
    }

    ////////////////////////////// PRECONDITIONS ///////////////////////////////
    
    // We don't have Quantize/Halftone operations for pixel formats below 8bpp.
    // Calling code will handle <8bpp, if it wants to, by asking us to
    // draw to 8bpp, and using GDI to read/write to the <8bpp format.
    
    ASSERT(GetPixelFormatSize(dstFormat) >= 8);
    
    // The following destination formats are not supported
    
    ASSERT(IsSupportedPixelFormat(dstFormat));
    
    // This function currently only supports these two compositing modes.
    
    ASSERT(compositingMode == CompositingModeSourceCopy ||
           compositingMode == CompositingModeSourceOver);
    
    ////////////////////////////// INITIALIZATION //////////////////////////////
    
    // Lazy initialization for MMX-specific code.
    
    if (!Initialized)
    {
        // We only need to check CPUSpecificOps initialization the first
        // time this EpAlphaBlender is initialized. On subsequent calls,
        // we know that a call to CPUSpecificOps::Initialize() has already
        // completed.
        
        CPUSpecificOps::Initialize();
        Initialized = TRUE;
    }

    OperationParameters.TempBuffers[0]=tempBuffers[0];
    OperationParameters.TempBuffers[1]=tempBuffers[1];
    OperationParameters.TempBuffers[2]=tempBuffers[2];

    // Set SolidColor - only used for SolidFill scan types
    
    OperationParameters.SolidColor = solidColor;
    OperationParameters.TextContrast = textContrast;
    
    // The pipeline builder
    
    Builder builder(
        Pipeline,
        tempBuffers,
        compositingMode
        );
    
    INT dstfmtIndex = GetPixelFormatIndex(dstFormat);
    INT srcfmtIndex = GetPixelFormatIndex(srcFormat);
    
    BOOL dstExtended = IsExtendedPixelFormat(dstFormat);
    BOOL srcExtended = IsExtendedPixelFormat(srcFormat);
    
    OperationParameters.DoingDither = dither16bpp;
    
    // If the destination format doesn't have an alpha channel, we can make
    // a few optimizations. For example, we can avoid AlphaMultiply/AlphaDivide 
    // in some cases.
                                                        
    BOOL ignoreDstAlpha = !IsAlphaPixelFormat(dstFormat);
    
    // If the destination pixel format is an indexed color format,
    // get the color palette and palette map

    if (IsIndexedPixelFormat(dstFormat))
    {
        OperationParameters.Dstpal = OperationParameters.Srcpal = 
            (dstpal ? dstpal : GetDefaultColorPalette(dstFormat));
            
        OperationParameters.PaletteMap = paletteMap;    
    }
    
    // Process the 'compositingQuality' parameter

    BOOL highQuality = FALSE;
    switch (compositingQuality)
    {
    case CompositingQualityDefault:
    case CompositingQualityHighSpeed:
    case CompositingQualityAssumeLinear:
        break;
    
    case CompositingQualityHighQuality:
    case CompositingQualityGammaCorrected:
        highQuality = TRUE;
        break;
    
    default:
        RIP(("Unrecognized compositing quality: %d", compositingQuality));
        break;
    }
    
    // Work out whether our intermediate format (if we're doing SourceOver)
    // needs to be 32bpp or 64bpp.
    
    BOOL blendExtended = dstExtended || srcExtended || highQuality;
    if (isClearType)
        blendExtended = FALSE;
    
    // Decide on the 'convert from canonical' operation. (We do it now since
    // the logic is the same for all branches.)
    
    ScanOpFunc convertFromCanonical = ABConvertFromCanonicalOps[dstfmtIndex];
    
    switch (dstFormat)
    {
    case PIXFMT_8BPP_INDEXED:
        if (paletteMap && !paletteMap->IsVGAOnly())
        {
            convertFromCanonical = HalftoneToScreen_sRGB_8_216;
        }
        
        // If there is no palette map yet, we'll default to the 16-color 
        // halftone function. Later on, in UpdatePalette(), we'll update this 
        // function pointer if necessary. Ugh.
        break;
        
    case PIXFMT_32BPP_RGB:
        // ignoreDstAlpha should have been set to TRUE earlier.

        ASSERT(ignoreDstAlpha);
        
        // We can write garbage to the high byte, so we treat this
        // exactly as if the destination were ARGB. This avoids calling
        // Quantize_sRGB_32RGB and Convert_32RGB_sRGB.

        convertFromCanonical = NULL;
        dstFormat = PIXFMT_32BPP_ARGB;
        break;
        
    case PIXFMT_16BPP_RGB555:
    case PIXFMT_16BPP_RGB565:
        // The Dither_Blend_sRGB_555_MMX and Dither_Blend_sRGB_565_MMX
        // operations, unlike other blends, are not WriteRMW operations.
        // They sometimes write when a blend pixel is completely transparent.
        // So, we must not use a ReadRMW operation (otherwise we'd write garbage
        // to the destination.)
        
        if (OSInfo::HasMMX && !blendExtended && !isClearType)
        {
            useRMW = FALSE;
        }
        break;
    }
        
    /////////////////////////// SOURCECOPY / OPAQUE ////////////////////////////
    
    if (   (scanType == EpScanTypeOpaque)
        || (compositingMode == CompositingModeSourceCopy))
    {
        // (See bug #122441).
        // 
        // We can now tell the difference between opaque input and general
        // SourceCopy. But I can't fix the bug right now. So, for now
        // we treat SourceCopy like the opaque case.
        //
        // This gives the wrong answer if the Graphics has SourceCopy mode set
        // and the user is drawing semitransparent pixels. Note that they need
        // to be doing this to a non-alpha surface to hit this case, 
        // which is pretty dumb anyway.
        
        if (srcFormat == PIXFMT_32BPP_PARGB
            && ignoreDstAlpha
            && !dstExtended)
        {
            // At this point, the destination shouldn't be 32BPP_PARGB, because
            // we want that to be handled with a simple Copy_32 operation.
            // But that's okay - we shouldn't be here if the destination is
            // 32BPP_PARGB, because ignoreDstAlpha shouldn't be TRUE.
            
            ASSERT(dstFormat != PIXFMT_32BPP_PARGB);
            
            srcFormat = PIXFMT_32BPP_ARGB;
        }
        
        // If the formats are identical, just use a copy operation.
        
        if (srcFormat == dstFormat)
        {
            builder.AddConvertSource(CopyOps[dstfmtIndex]);
            goto PipelineDone;
        }
        
        // We don't check for other special case conversion operations for 
        // SourceCopy, because:
        // 1) I'm lazy
        // 2) We don't have any at the moment
        // 3) If the source isn't in one of the canonical formats, we expect 
        //    that the destination will be the same format. Otherwise, it's
        //    not a perf-important scenario, at least not right now.
        
        
        // Convert to the nearest canonical format, if necessary
        
        if (srcFormat != PIXFMT_32BPP_ARGB &&
            srcFormat != PIXFMT_64BPP_ARGB)
        {
            builder.AddConvertSource(ConvertIntoCanonicalOps[srcfmtIndex]);
        }
        
        // Convert to the other canonical format, if necessary
        
        if (srcExtended != dstExtended)
        {
            builder.AddConvertSource(
                srcExtended ? 
                    GammaConvert_sRGB64_sRGB :
                    GammaConvert_sRGB_sRGB64);
        }
        
        // Convert to the destination format, if necessary
                
        if (convertFromCanonical)
        {
            builder.AddConvertSource(convertFromCanonical);
        }
        
        // At least one of these should have added an operation (since
        // the case where the source and destination formats are identical
        // was handled already).
        
        ASSERT(!builder.IsEmpty(*this));
        
        goto PipelineDone;
    }

    ////////////////////////// SOURCEOVER / CLEARTYPE //////////////////////////

    ASSERT(   (scanType == EpScanTypeBlend)
           || isClearType);
    
    // The pseudocode is as follows:
    // * Handle ReadRMW
    // * Check for a special-case blend
    // * Convert source to blend format
    // * Convert destination to blend format
    // * Blend
    // * Convert to destination format
    // * WriteRMW

    // * Handle ReadRMW
    
    // We'll also decide which WriteRMW operation to use at the end.

    ScanOpFunc writeRMWfunc;
    ScanOpFunc readRMWfunc;
        
    writeRMWfunc = NULL;
    readRMWfunc = NULL;
   
    if (useRMW)
    {    
        if (isClearType)
        {
            switch (GetPixelFormatSize(dstFormat))
            {
            case 16:
                if (scanType == EpScanTypeCT)
                {
                    readRMWfunc = ReadRMW_16_CT_CARGB;
                    writeRMWfunc = WriteRMW_16_CT_CARGB;
                }
                else
                {
                    readRMWfunc = ReadRMW_16_CT_Solid;
                    writeRMWfunc = WriteRMW_16_CT_Solid;
                }
                break;
            case 24:
                if (scanType == EpScanTypeCT)
                {
                    readRMWfunc = ReadRMW_24_CT_CARGB;
                    writeRMWfunc = WriteRMW_24_CT_CARGB;
                }
                else
                {
                    readRMWfunc = ReadRMW_24_CT_Solid;
                    writeRMWfunc = WriteRMW_24_CT_Solid;
                }
                break;
            }
        }
        else
        if (blendExtended)
        {
            switch (GetPixelFormatSize(dstFormat))
            {
            case 8:
                readRMWfunc = ReadRMW_8_sRGB64;
                writeRMWfunc = WriteRMW_8_sRGB64;
                break;
            case 16:
                // For special-case high quality blends to 16bpp formats, RMW has no perf
                // gain, and is simply overhead.

                // readRMWfunc = ReadRMW_16_sRGB64;
                // writeRMWfunc = WriteRMW_16_sRGB64;
                break;
            case 24:
                readRMWfunc = ReadRMW_24_sRGB64;
                writeRMWfunc = WriteRMW_24_sRGB64;
                break;
            case 32:
                // For special-case high quality blends to 32bpp formats, RMW has no perf
                // gain, and is simply overhead.

                // readRMWfunc = ReadRMW_32_sRGB64;
                // writeRMWfunc = WriteRMW_32_sRGB64;
                break;
            }
        }
        else
        {
            switch (GetPixelFormatSize(dstFormat))
            {
            case 8:
                readRMWfunc = ReadRMW_8_sRGB;
                writeRMWfunc = WriteRMW_8_sRGB;
                break;
            case 16:
                readRMWfunc = ReadRMW_16_sRGB;
                writeRMWfunc = WriteRMW_16_sRGB;
                break;
            case 24:
                readRMWfunc = ReadRMW_24_sRGB;
                writeRMWfunc = WriteRMW_24_sRGB;
                break;
            case 32:
                // For special-base blends to 32bpp formats, RMW has no perf
                // gain, and is simply overhead.

                // readRMWfunc = ReadRMW_32_sRGB;
                // writeRMWfunc = WriteRMW_32_sRGB;

                break;
            }
        }
        
        // We won't actually add the ReadRMW here. For example, if the source is
        // 32bpp and we want to do an extended blend, we need to convert
        // the source before doing the ReadRMW.
        //
        // However, we needed the logic here so that the special-case blend
        // code doesn't need to duplicate it.
    }
    
    // * Check for a special-case blend
    
    ScanOpFunc specialCaseBlend;
    specialCaseBlend = NULL;
    
    if (scanType == EpScanTypeBlend && !srcExtended)
    {
        if (blendExtended)
        {
            specialCaseBlend = BlendOpsHighQuality[dstfmtIndex];
        }
        else
        {
            specialCaseBlend = BlendOpsLowQuality[dstfmtIndex];
        }
    
        if (specialCaseBlend)
        {
            // If we're supposed to ReadRMW, do it now.
            
            if (readRMWfunc)
            {
                builder.AddConvertDestination(readRMWfunc);
            }
            
            // Dither_Blend_sRGB_555_MMX and Dither_Blend_sRGB_565_MMX
            // don't work with ReadRMW. Earlier code should have handled
            // it, so we'll just assert it here.

            ASSERT(!(   (   (specialCaseBlend == Dither_Blend_sRGB_555_MMX)
                         || (specialCaseBlend == Dither_Blend_sRGB_565_MMX)
                        ) 
                     && (useRMW)));

            builder.AddBlend(specialCaseBlend, *this);
            goto PipelineDone;
        }
    }
    
    // * Convert source to blend format
    
    // We currently only support source data other than 32BPP_PARGB and
    // 64BPP_PARGB for the SourceCopy case.
    
    ASSERT(   (srcFormat == PIXFMT_32BPP_PARGB)
           || (srcFormat == PIXFMT_64BPP_PARGB));
           
    if (blendExtended && !srcExtended)
    {
        // Unfortunately, the source is premultiplied and we need to gamma
        // convert it. We must divide by the alpha first, and remultiply
        // afterwards.
        
        builder.AddConvertSource(AlphaDivide_sRGB);
        builder.AddConvertSource(GammaConvert_sRGB_sRGB64);
        builder.AddConvertSource(AlphaMultiply_sRGB64);
    }    
    
    // * Handle ReadRMW (continued)
    
    if (readRMWfunc)
    {
        builder.AddConvertDestination(readRMWfunc);
    }
            
    // * Convert destination to blend format

    // Skip this if it's already in the blend format
    if (   (blendExtended  && dstFormat != PIXFMT_64BPP_PARGB)
        || (!blendExtended && dstFormat != PIXFMT_32BPP_PARGB))
    {
        
        // Convert to the nearest canonical format, if necessary
        
        if (dstFormat != PIXFMT_32BPP_ARGB &&
            dstFormat != PIXFMT_64BPP_ARGB)
        {
            builder.AddConvertDestination(ConvertIntoCanonicalOps[dstfmtIndex]);
        }
        
        // Convert to sRGB64, if necessary
        
        if (!srcExtended && blendExtended)
        {
            builder.AddConvertDestination(GammaConvert_sRGB_sRGB64);
        }
        
        // Convert to the premultiplied version, if necessary
        
        if (!ignoreDstAlpha)
        {
            builder.AddConvertDestination(
                blendExtended ?
                    AlphaMultiply_sRGB64 :
                    AlphaMultiply_sRGB);
        }
    }
    
    // * Blend

    if (scanType == EpScanTypeCT)
    {
        builder.AddBlend(CTBlendCARGB, *this);
    }
    else if (scanType == EpScanTypeCTSolidFill)
    {
        builder.AddBlend(CTBlendSolid, *this);
    }
    else
    {
        builder.AddBlend(
            blendExtended ? 
            BlendOpsHighQuality[GetPixelFormatIndex(PIXFMT_64BPP_PARGB)]:
            BlendOpsLowQuality[GetPixelFormatIndex(PIXFMT_32BPP_PARGB)],
            *this);
    }

    // * Convert to destination format
    
    // Skip this if it's already in the destination format
    if (   (blendExtended  && dstFormat != PIXFMT_64BPP_PARGB)
        || (!blendExtended && dstFormat != PIXFMT_32BPP_PARGB))
    {
        // Convert to the nearest nonpremultiplied, if necessary
        
        if (!ignoreDstAlpha)
        {
            builder.AddConvertDestination(
                blendExtended ?
                    AlphaDivide_sRGB64 :
                    AlphaDivide_sRGB);
        }
        
        // Convert to the other canonical format, if necessary
        
        if (blendExtended != dstExtended)
        {
            builder.AddConvertDestination(
                blendExtended ? 
                    GammaConvert_sRGB64_sRGB :
                    GammaConvert_sRGB_sRGB64);
        }
        
        // Convert to the destination format, if necessary
                
        if (convertFromCanonical)
        {
            builder.AddConvertDestination(convertFromCanonical);
        }
    }
    
    // * WriteRMW
        
    if (writeRMWfunc)
    {
        builder.AddConvertDestination(writeRMWfunc);
    }

PipelineDone:    
    
    builder.End(*this);
}

/**************************************************************************\
*
* Function Description:
*
*   Blend source pixels to the given destination.
*
* Arguments:
*
*   dst      - The destination buffer
*   src      - The source pixels to blend
*   width    - The number of pixels in the source/destination buffers
*   dither_x - The x and y offsets of the destination scanline into the 
*   dither_y -   halftone or dither matrix (implicit mod the matrix size).
*   ctBuffer - The ClearType coverage buffer, or NULL for non-ClearType
*                scan types.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/
    
VOID 
EpAlphaBlender::Blend(
    VOID *dst, 
    VOID *src, 
    UINT width,
    INT dither_x,
    INT dither_y,
    BYTE *ctBuffer
    )
{
    if (!width) 
    {
        return;
    }
    
    // If ConvertBlendingScan is TRUE, then Initialize() will already
    // have set BlendingScan to point to one of the temporary buffers.
    
    if (!ConvertBlendingScan)
    {
        OperationParameters.BlendingScan = src;
    }
    
    OperationParameters.CTBuffer = ctBuffer;
    OperationParameters.X = dither_x;
    OperationParameters.Y = dither_y;
            
    PipelineItem *pipelinePtr = &Pipeline[0];
    const VOID *currentSrc;
    VOID *currentDst;
    BOOL finished = FALSE;
    
    do
    {
        currentSrc = pipelinePtr->Src;
        currentDst = pipelinePtr->Dst;
        
        // We should never write to the original source, because we don't
        // control that memory.
        
        ASSERT (currentDst != BLENDER_USE_SOURCE);
        
        // Translate BLENDER_USE_SOURCE and BLENDER_USE_DESTINATION
        
        if (currentSrc == BLENDER_USE_SOURCE)
        {
            currentSrc = src;
        }
        
        if (currentSrc == BLENDER_USE_DESTINATION)
        {
            currentSrc = dst;
        }
        
        if (currentDst == BLENDER_USE_DESTINATION)
        {
            currentDst = dst;
            finished = TRUE;
        }
        
        pipelinePtr->Op(currentDst, currentSrc, width, &OperationParameters);
        pipelinePtr++;
    } while (!finished);
}

/**************************************************************************\
*
* Function Description:
*
*   Update the palette/palette map.
*
* Arguments:
*
*   dstpal          - The destination color palette.
*   paletteMap      - The palette map for the destination.
*
* Notes:
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
EpAlphaBlender::UpdatePalette(
    const ColorPalette *dstpal, 
    const EpPaletteMap *paletteMap
    )
{
    ASSERT(dstpal && paletteMap);
    
    BOOL wasVGAOnly = (!OperationParameters.PaletteMap) || 
                      (OperationParameters.PaletteMap->IsVGAOnly());
    
    OperationParameters.Srcpal = OperationParameters.Dstpal = dstpal;
    OperationParameters.PaletteMap = paletteMap;
    
    // Detect whether we need to change the halftone function.
    
    if (wasVGAOnly != paletteMap->IsVGAOnly())
    {
        ScanOpFunc before, after;
        
        if (wasVGAOnly)
        {
            before = HalftoneToScreen_sRGB_8_16;
            after = HalftoneToScreen_sRGB_8_216;
        }
        else
        {
            before = HalftoneToScreen_sRGB_8_216;
            after = HalftoneToScreen_sRGB_8_16;
        }
        
        // Search the pipeline for the 'before' function, and replace it with
        // the 'after' function.
        
        PipelineItem *pipelinePtr = Pipeline;
        
        while (1)
        {
            if (pipelinePtr->Op == before)
            {
                pipelinePtr->Op = after;
            }

            if (pipelinePtr->Dst == BLENDER_USE_DESTINATION)
            {
                break;
            }
            pipelinePtr++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\cpuspecificops.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   CPU-specific scan operations
*
* Abstract:
*
*   Handles scan operations which only work on certain CPU's. 
*   Currently only used by EpAlphaBlender. This works by overwriting the
*   function pointer arrays with ones holding CPU-specific information.
*
* Created:
*
*   05/30/2000 agodfrey
*      Created it.
*
**************************************************************************/

#ifndef _CPUSPECIFICOPS_HPP
#define _CPUSPECIFICOPS_HPP

namespace CPUSpecificOps
{
    VOID Initialize();       // Sets up the function pointer arrays.
                             // Should only be called once (we ASSERT).
    
    extern BOOL Initialized; // Whether Initialize() has been called yet.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\drawcachedbitmap.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Software rasterizer code for drawing a CachedBitmap
*
* Created:
*
*   05/18/2000 asecchia
*      Created it.
*
**************************************************************************/

#include "precomp.hpp"

// Class to output a clipped span for a CachedBitmap

class DpOutputCachedBitmapSpan : public DpOutputSpan
{
    EpScanRecord *InputBuffer;
    DpScanBuffer *Scan;
    INT XOff, YOff;           // coordinates of the top left corner.
    INT PixelSize;
    
    public: 

    DpOutputCachedBitmapSpan(
        DpScanBuffer *scan,
        INT x, 
        INT y
    )
    {
        Scan = scan;
        InputBuffer = NULL;
        XOff = x;
        YOff = y;
    }

    virtual GpStatus OutputSpan(INT y, INT xMin, INT xMax)
    {
        // Can't draw anything if the buffer hasn't been set correctly.

        ASSERT(InputBuffer != NULL);
        ASSERT(YOff + InputBuffer->Y == y);
        ASSERT(xMax-xMin <= InputBuffer->Width);

        // Get an output buffer.

        void *buffer;
        
        buffer = Scan->NextBuffer(
            xMin, y, 
            xMax-xMin, 
            InputBuffer->BlenderNum
        );
        
        // Get a pointer to the start of the scanline.
        
        void *ib = InputBuffer->GetColorBuffer();

        INT pixelSize = PixelSize;

        // InputBuffer->X + XOff is the x starting position on the screen.
        // Make sure we're not trying to draw off to the left of our data.

        ASSERT(xMin >= (InputBuffer->X+XOff));
        ib = (void *) ( (BYTE *)(ib) + 
                        (xMin - (InputBuffer->X+XOff))*pixelSize);
        
        // Copy the input buffer to the output buffer.

        GpMemcpy(buffer, ib, (xMax-xMin)*pixelSize);

        // Cannot fail this routine.

        return Ok;
    }

    // Initialize the class with a new scan record.
    // This is used when we want to start processing a new batch record.

    void SetInputBuffer(
        EpScanRecord *ib,
        INT pixelSize
        ) 
    { 
        InputBuffer = ib; 
        PixelSize = pixelSize;
    }

    // We're always valid.

    virtual int IsValid() const {return TRUE;}
};


/**************************************************************************
*
* Function Description:
*
*   Software Rasterizer code for drawing a DpCachedBitmap
*
* Arguments:
*
*   context - the graphics context.
*   src     - the DpCachedBitmap to draw from
*   dst     - where the output goes
*   x, y    - offset - position to draw the top left corner of the CachedBitmap.
*
* Return Value:
*
*   GpStatus.
*
* Notes:
*   
*   This driver entry point expects the input to be in device coordinates
*   so the caller has to pre compute the world to device transform.
*   This is contrary to how most of our driver entry points work.
*
* Created:
*
*   05/18/2000 asecchia
*      Created it.
*
**************************************************************************/
GpStatus
DpDriver::DrawCachedBitmap(
    DpContext *context,
    DpCachedBitmap *src,
    DpBitmap *dst,
    INT x, INT y               // Device coordinates!
)
{
    ASSERT(context);
    ASSERT(src);
    ASSERT(dst);
    
    // Let's go make sure the Surface pixel format and the CachedBitmap
    // opaque format match.
    // The exception is for 32bppRGB which can draw onto anything.
    // This format is used in the multi-mon case where the individual
    // screen devices can be in multiple formats.
    // When 64bpp formats become first class citizens, we may want to 
    // update this condition.
    
    if((dst->PixelFormat != src->OpaqueFormat) &&
       (src->OpaqueFormat != PixelFormat32bppRGB))
    {
        return WrongState;
    }
    
    // Ignore the world to device transform - this driver entry point is
    // somewhat unique in that it expects device coordinates.

    // Initialize the DpScanBuffer.
    // This hooks us up to the appropriate DpScanXXX class for outputting our
    // data to the destination device.

    DpScanBuffer scanBuffer(
        dst->Scan,
        this,
        context,
        dst,
        FALSE,
        EpScanTypeBlend,
        src->SemiTransparentFormat,
        src->OpaqueFormat
    );
    
    if(!scanBuffer.IsValid())
    {
        return(GenericError);
    }

    // Set up the clipping.

    DpRegion::Visibility visibility = DpRegion::TotallyVisible;
    DpClipRegion *clipRegion = NULL;

    if(context->VisibleClip.GetRectVisibility(
        x, y,
        x+src->Width,
        y+src->Height
        ) != DpRegion::TotallyVisible
       )
    {
        clipRegion = &(context->VisibleClip);
    }
   
    GpRect clippedRect;
    
    if(clipRegion)
    {
        visibility = clipRegion->GetRectVisibility(
            x, y, 
            x+src->Width,
            y+src->Height,
            &clippedRect
        );
    }

    // Decide on our clipping strategy.

    switch (visibility)
    {

        case DpRegion::TotallyVisible:    // no clipping is needed
        {        
            // Copy the scanlines to the destination buffer
        
            // ProcessBatch requests that the DpScan class handle the entire
            // batch as a single block. If it can't it will return FALSE and
            // we fall through into the general purpose code below.
        
            BOOL batchSupported = scanBuffer.ProcessBatch(
                src->RecordStart, 
                src->RecordEnd,
                x, 
                y,
                x+src->Width,
                y+src->Height
            );
            
            if(batchSupported)
            {
                // The scanBuffer supports ProcessBatch; we're done.
                break;
            }
            
            // The scanBuffer doesn't support the ProcessBatch routine.
            // Lets manually enumerate the batch structure into the destination.
            // Fall through into the manual enumeration code:
        }
                
        // !!! PERF [asecchia] We have a perf problem when there is no clipping
        //     except the standard surface bounds. DCI/GDI would be able to clip
        //     this directly, but we aren't sure how to robustly detect this
        //     optimization and ignore the clip rectangle. This does not impact
        //     the fully visible case. Also it's not appropriate to make this
        //     optimization unless we're using DpScanGdiDci as our output device.
    
        case DpRegion::ClippedVisible:   
        case DpRegion::PartiallyVisible:  // some clipping is needed            
        {
            // Create the OutputSpan class for the CachedBitmap.
            // Create this on the stack because it has very little storage
            // and we can avoid a malloc. It gets cleaned up when we go out
            // of scope.

            DpOutputCachedBitmapSpan output(
                &scanBuffer, 
                x, 
                y
            );

            // Initialize the clipper to point to the clip region and
            // create the clpping chain by tacking the output created above
            // on to the end of the list.
          
            DpOutputSpan *clipper;
            if(clipRegion)
            {
                clipper = clipRegion;
                clipRegion->InitClipping(&output, y);
            }
            else
            {
                // no clipping required - possible due to the fallthrough case
                // in the fully visible codepath.
               
                clipper = &output;
            }
            
            // Lets manually enumerate the batch structure into the destination
            // taking into account clipping

            // First set up the running record pointer to the beginning of the
            // batch and a sentinel for the end.

            EpScanRecord *record = src->RecordStart;
            EpScanRecord *batchEnd = src->RecordEnd;

            // For all the batch records, Draw them on the destination.

            while(record < batchEnd) 
            {
                PixelFormatID format;
                if (record->BlenderNum == 0)
                {
                    format = src->SemiTransparentFormat;
                }
                else
                {
                    ASSERT(record->BlenderNum == 1);
                    format = src->OpaqueFormat;
                }
                
                INT pixelSize = GetPixelFormatSize(format) >> 3;
            
                // Set the output span buffer

                output.SetInputBuffer(record, pixelSize);

                // Draw this span

                INT x1 = x+record->X;
                INT x2 = x+record->X+record->Width;
                clipper->OutputSpan(y+record->Y, x1, x2);
                
                // Advance to the next record:

                record = record->NextScanRecord(pixelSize);
            }


        }
        break;
        
        case DpRegion::Invisible:         // nothing on screen - quit
        break;
    }


    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\cpuspecificops.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   CPU-specific scan operations
*
* Abstract:
*
*   Handles scan operations which only work on certain CPU's. 
*   Currently only used by EpAlphaBlender. This works by overwriting the
*   function pointer arrays with ones holding CPU-specific information.
*
* Created:
*
*   05/30/2000 agodfrey
*      Created it.
*
**************************************************************************/

#include "precomp.hpp"

#include "scanoperationinternal.hpp"

using namespace ScanOperation;

// This variable records whether Initialize() has been called yet.

BOOL CPUSpecificOps::Initialized = FALSE;

/**************************************************************************\
*
* Special-case low-quality blend operations which blend directly to a 
* given destination format (with the source in 32BPP_PARGB).
*
* Some of these operations may use MMX instructions.
*
* Notes:
*
*   The 555/565 cases support both dithering and non-dithering, via the flag
*   OtherParams::DoingDither.
*
*   We leave out PIXFMT_32BPP_ARGB and PIXFMT_64BPP_ARGB, since they're not
*   "ignore alpha" formats, so we'd need to AlphaDivide after the blend.
*
\**************************************************************************/

static ScanOpFunc BlendOpsLowQuality_MMX[PIXFMT_MAX] =
{
    NULL,                         // PIXFMT_UNDEFINED
    NULL,                         // PIXFMT_1BPP_INDEXED
    NULL,                         // PIXFMT_4BPP_INDEXED
    NULL,                         // PIXFMT_8BPP_INDEXED
    NULL,                         // PIXFMT_16BPP_GRAYSCALE
    Dither_Blend_sRGB_555_MMX,    // PIXFMT_16BPP_RGB555
    Dither_Blend_sRGB_565_MMX,    // PIXFMT_16BPP_RGB565
    NULL,                         // PIXFMT_16BPP_ARGB1555
    Blend_sRGB_24,                // PIXFMT_24BPP_RGB
    Blend_sRGB_sRGB_MMX,          // PIXFMT_32BPP_RGB
    NULL,                         // PIXFMT_32BPP_ARGB
    Blend_sRGB_sRGB_MMX,          // PIXFMT_32BPP_PARGB
    NULL,                         // PIXFMT_48BPP_RGB
    NULL,                         // PIXFMT_64BPP_ARGB
    NULL,                         // PIXFMT_64BPP_PARGB
    Blend_sRGB_24BGR              // PIXFMT_24BPP_BGR
};

/**************************************************************************\
*
* Special-case gamma-corrected blend operations which blend directly to a 
* given destination format (with the source in 32BPP_PARGB).
*
* Some of these operations may use MMX instructions.
*
* Notes:
*
*   We leave out PIXFMT_32BPP_ARGB and PIXFMT_64BPP_ARGB, since they're not
*   "ignore alpha" formats, so we'd need to AlphaDivide after the blend.
*
\**************************************************************************/

static ScanOpFunc BlendOpsHighQuality_MMX[PIXFMT_MAX] =
{
    NULL,                         // PIXFMT_UNDEFINED
    NULL,                         // PIXFMT_1BPP_INDEXED
    NULL,                         // PIXFMT_4BPP_INDEXED
    NULL,                         // PIXFMT_8BPP_INDEXED
    NULL,                         // PIXFMT_16BPP_GRAYSCALE
    BlendLinear_sRGB_555_MMX,     // PIXFMT_16BPP_RGB555
    BlendLinear_sRGB_565_MMX,     // PIXFMT_16BPP_RGB565
    NULL,                         // PIXFMT_16BPP_ARGB1555
    NULL,                         // PIXFMT_24BPP_RGB
    BlendLinear_sRGB_32RGB_MMX,   // PIXFMT_32BPP_RGB
    NULL,                         // PIXFMT_32BPP_ARGB
    NULL,                         // PIXFMT_32BPP_PARGB
    NULL,                         // PIXFMT_48BPP_RGB
    NULL,                         // PIXFMT_64BPP_ARGB
    Blend_sRGB64_sRGB64_MMX,      // PIXFMT_64BPP_PARGB
    NULL                          // PIXFMT_24BPP_BGR
};

/**************************************************************************\
*
* Operations which convert from the closest canonical format - either
* 32BPP_ARGB or 64BPP_ARGB).
*
* This is specific to EpAlphaBlender. EpFormatConverter uses a different
* table; some of the entries are different.
*
* The NULL entries for 32BPP_ARGB and 64_BPP_ARGB are used to indicate that no
* conversion is necessary.
*
* Some of these operations use MMX instructions.
*
* Notes:
*
*   The 555/565 cases support both dithering and non-dithering, via the flag
*   OtherParams::DoingDither.
*
*   For 8bpp, we use the 16-color halftoning function. Initialize() will
*   need to work out if it can use something better, like the 216-color
*   halftone function. We should really have a 'nearest-color-matching' function
*   here, to support drawing to bitmaps with arbitrary palettes (the "16 VGA
*   colors" assumption is only true for the screen.)
*
\**************************************************************************/

static ScanOpFunc ABConvertFromCanonicalOps_MMX[PIXFMT_MAX] =
{
    NULL,                         // PIXFMT_UNDEFINED
    NULL,                         // PIXFMT_1BPP_INDEXED
    NULL,                         // PIXFMT_4BPP_INDEXED
    HalftoneToScreen_sRGB_8_16,   // PIXFMT_8BPP_INDEXED
    NULL,                         // PIXFMT_16BPP_GRAYSCALE
    Dither_sRGB_555_MMX,          // PIXFMT_16BPP_RGB555
    Dither_sRGB_565_MMX,          // PIXFMT_16BPP_RGB565
    Quantize_sRGB_1555,           // PIXFMT_16BPP_ARGB1555
    Quantize_sRGB_24,             // PIXFMT_24BPP_RGB
    Quantize_sRGB_32RGB,          // PIXFMT_32BPP_RGB
    NULL,                         // PIXFMT_32BPP_ARGB
    AlphaMultiply_sRGB,           // PIXFMT_32BPP_PARGB
    Quantize_sRGB64_48,           // PIXFMT_48BPP_RGB
    NULL,                         // PIXFMT_64BPP_ARGB
    AlphaMultiply_sRGB64,         // PIXFMT_64BPP_PARGB
    Quantize_sRGB_24BGR           // PIXFMT_24BPP_BGR
};

/**************************************************************************
*
* Function Description:
*
*   Initializes the function pointer arrays with processor-specific
*   data. Should only be called once.
* 
* Return Value:
*
*   NONE
*
* Created:
*
*   05/30/2000 agodfrey
*      Created it.
*
**************************************************************************/

VOID 
CPUSpecificOps::Initialize()
{
    // Thread-protect the access to the global "Initialized" and
    // the function pointer arrays. Beware: Users of these tables (currently
    // only EpAlphaBlender::Initialize()) must be careful when they read those
    // arrays. They must either protect the access under this critical section,
    // or simply ensure that they've called this function first.

    LoadLibraryCriticalSection llcs; // Hey, it's an 'initialization' critsec!
    
    // Make sure no-one calls us before OSInfo::HasMMX is initialized
    
    #if DBG
    
    static BOOL noMMX = FALSE;
    ASSERT(!(noMMX && OSInfo::HasMMX));
    if (!OSInfo::HasMMX)
    {
        noMMX = TRUE;
    }
    
    #endif
    
    if (!Initialized)
    {
        INT i;
        
        if (OSInfo::HasMMX)
        {
            for (i=0; i<PIXFMT_MAX; i++)
            {
                BlendOpsLowQuality[i] = BlendOpsLowQuality_MMX[i];
                BlendOpsHighQuality[i] = BlendOpsHighQuality_MMX[i];
                ABConvertFromCanonicalOps[i] = ABConvertFromCanonicalOps_MMX[i];
            }
        }
        
        Initialized = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\formatconverter.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Format converter
*
* Abstract:
*
*   A class which converts scanlines from one pixel format to another.
*
* Notes:
*
*   The sRGB   format is equivalent to PIXFMT_32BPP_ARGB.
*   The sRGB64 format is equivalent to PIXFMT_64BPP_ARGB.
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*   11/23/1999 agodfrey
*       Integrated with scan operations, moved it from 
*       imaging\api\convertfmt.cpp.
*
\**************************************************************************/

#include "precomp.hpp"

#include "scanoperationinternal.hpp"

// !!![agodfrey] Hack:
const ColorPalette*
GetDefaultColorPalette(PixelFormatID pixfmt);

inline UINT
GetPixelFormatIndex(
    PixelFormatID pixfmt
    )
{
    return pixfmt & 0xff;
}
// !!![agodfrey] Endhack

using namespace ScanOperation;

/**************************************************************************\
*
* Special-case conversion operations
*
* For performance reasons, we may want to supply special-case operations
* which convert directly from one format to another. Here is where they
* would be plugged in.
*
\**************************************************************************/

struct 
{
    PixelFormatID Srcfmt;
    PixelFormatID Dstfmt;
    ScanOpFunc Op;
}
const SpecialConvertOps[] =
{
    { PIXFMT_24BPP_RGB, PIXFMT_32BPP_PARGB, Convert_24_sRGB },
    
    // Sentinel

    { PIXFMT_UNDEFINED, PIXFMT_UNDEFINED, NULL }
};

/**************************************************************************\
*
* Operations which convert from the closest canonical format.
*
* This is specific to EpFormatConverter - the 16bpp cases don't dither,
* and there's no 8BPP_INDEXED entry (DCurtis removed it, change #806.)
*
\**************************************************************************/

static ScanOpFunc FCConvertFromCanonicalOps[PIXFMT_MAX] =
{
    NULL,                   // PIXFMT_UNDEFINED
    NULL,                   // PIXFMT_1BPP_INDEXED
    NULL,                   // PIXFMT_4BPP_INDEXED
    NULL,                   // PIXFMT_8BPP_INDEXED
    NULL, // !!! TODO       // PIXFMT_16BPP_GRAYSCALE
    Quantize_sRGB_555,      // PIXFMT_16BPP_RGB555
    Quantize_sRGB_565,      // PIXFMT_16BPP_RGB565
    Quantize_sRGB_1555,     // PIXFMT_16BPP_ARGB1555
    Quantize_sRGB_24,       // PIXFMT_24BPP_RGB
    Quantize_sRGB_32RGB,    // PIXFMT_32BPP_RGB
    Copy_32,                // PIXFMT_32BPP_ARGB
    AlphaMultiply_sRGB,     // PIXFMT_32BPP_PARGB
    Quantize_sRGB64_48,     // PIXFMT_48BPP_RGB
    Copy_64,                // PIXFMT_64BPP_ARGB
    AlphaMultiply_sRGB64,   // PIXFMT_64BPP_PARGB
    Quantize_sRGB_24BGR     // PIXFMT_24BPP_BGR
};

/**************************************************************************\
*
* Function Description:
*
*   Add a scan operation to the pipeline
*
* Arguments:
*
*   [IN/OUT] pipelinePtr - The current position in the Pipeline array,
*                          as it is being built
*   newOperation         - The scan operation to add
*   pixelFormat          - The destination pixel format
*
* Notes:
*
*   This should only be used by Initialize().
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
EpFormatConverter::AddOperation(
    PipelineItem **pipelinePtr,
    const ScanOpFunc newOperation,
    PixelFormatID pixelFormat
    )
{
    if (!newOperation)
    {
        return IMGERR_NOCONVERSION;
    }
    
    (*pipelinePtr)->Op = newOperation;
    (*pipelinePtr)->PixelFormat = pixelFormat;
    (*pipelinePtr)->Dst = NULL;
    
    // If this isn't the first operation in the pipeline,
    // we know that we need to allocate a temporary buffer for the
    // previous operation.
    
    if (*pipelinePtr != Pipeline)
    {
        PipelineItem *prevItem = (*pipelinePtr) - 1;
        
        VOID * buffer;
        buffer = GpMalloc(
            Width * GetPixelFormatSize(prevItem->PixelFormat) >> 3
            );
        if (buffer == NULL)
        {
            WARNING(("Out of memory."));
            return E_OUTOFMEMORY;
        }
        
        prevItem->Dst = buffer;

        // Remember the buffer pointer 
        
        VOID **tempBufPtr = TempBuf;
        
        if (*tempBufPtr) tempBufPtr++;
        ASSERT(!*tempBufPtr);
        
        *tempBufPtr = buffer;
    }
    (*pipelinePtr)++;
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize a scanliner pixel format converter object
*
* Arguments:
*
*   dstbmp - Specifies the destination bitmap data buffer
*   dstpal - Specifies the destination color palette, if any
*   srcbmp - Specifies the source bitmap data buffer
*   srcpal - Specifies the source color palette, if any
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
EpFormatConverter::Initialize(
    const BitmapData* dstbmp,
    const ColorPalette* dstpal,
    const BitmapData* srcbmp,
    const ColorPalette* srcpal
    )
{
    FreeBuffers();
    
    // !!![agodfrey]
    // We need a better error handling scheme. We should import the
    // CHECK_HR macro from somewhere - I like the one in the test\Simpsons
    // directory.
    // At the moment, we could leak memory if there is a memory failure.
    
    HRESULT hr=S_OK;
    
    Width = srcbmp->Width;
    PixelFormatID srcfmt = srcbmp->PixelFormat;
    PixelFormatID dstfmt = dstbmp->PixelFormat;
    
    INT srcfmtIndex = GetPixelFormatIndex(srcfmt);
    INT dstfmtIndex = GetPixelFormatIndex(dstfmt);

/*    ASSERT(IsValidPixelFormat(srcfmt) &&
           IsValidPixelFormat(dstfmt));
!!![agodfrey] Pixel formats need a revamp. Currently, I'd have to include
    most of imaging/api/*.hpp to get IsValidPixelFormat. Pixel format stuff
    needs to be in a common place. Also, information about the pixel format
    shouldn't be encoded in the pixel format DWORD itself.
*/
    
    // If the source and desination formats are the same, we just need
    // a copy operation.
    //
    // !!![agodfrey] This is horrible. We don't even compare the palettes -
    //               we just compare the pointers.

    if (srcfmt == dstfmt 
        && (!IsIndexedPixelFormat(srcfmt) 
            || (srcpal == dstpal)
           )
       )
    {
        Pipeline[0].Op = CopyOps[srcfmtIndex];
        Pipeline[0].PixelFormat = dstfmt;
        Pipeline[0].Dst = NULL;
        return S_OK;
    }

    // If source pixel format is an indexed color format,
    // make sure we have a source color palette.

    if (IsIndexedPixelFormat(srcfmt))
    {
        if (srcpal)
        {
            ASSERT(GetPixelFormatSize(srcfmt) <= 16);
            
            // If there aren't enough colors in the palette (256 or 16 or 2), 
            // clone the palette and fill the rest with opaque black.
        
            UINT maxPaletteSize = (1 << GetPixelFormatSize(srcfmt));
            if (srcpal->Count < maxPaletteSize)
            {
                ClonedSourcePalette = CloneColorPaletteResize(
                    srcpal,
                    maxPaletteSize,
                    0xff000000);
                srcpal = ClonedSourcePalette;
            }
        }
        OperationParameters.Srcpal = srcpal ? srcpal : GetDefaultColorPalette(srcfmt);
    }    

    // If destination pixel format is an indexed color format,
    // make sure we have a destination color palette.

    if (IsIndexedPixelFormat(dstfmt))
    {
        // !!! [agodfrey] We don't have code to convert to an arbitrary
        //     palette. So we can't convert to a palettized format.
        //     In the original code I transmogrified, there was a '!!! TODO'
        //     next to the 8bpp case.
        
        return IMGERR_NOCONVERSION;
        
        /*
        If we did support it, here's what we'd probably do:
        
        OperationParameters.X = 0;
        OperationParameters.Y = 0;
        
        OperationParameters.Dstpal = dstpal ? dstpal :
                       (srcpal ? srcpal : GetDefaultColorPalette(dstfmt));
        */               
    }

    // Search for a special-case operation for this combination of formats

    UINT index = 0;

    while (SpecialConvertOps[index].Op)
    {
        if (srcfmt == SpecialConvertOps[index].Srcfmt &&
            dstfmt == SpecialConvertOps[index].Dstfmt)
        {
            Pipeline[0].Op = SpecialConvertOps[index].Op;
            Pipeline[0].PixelFormat = dstfmt;
            Pipeline[0].Dst = NULL;
            return S_OK;
        }

        index++;
    }

    // We didn't find a special case; instead we use the general case.
    //
    // We assume that there are only 2 canonical formats -
    // PIXFMT_32BPP_ARGB (i.e. sRGB), and
    // PIXFMT_64BPP_ARGB (i.e. sRGB64). 
    //
    // 1) Convert from the source to the nearest canonical format, if necessary.
    // 2) Convert from that canonical format to the other one, if necessary.
    // 3) Convert to the destination format, if necessary.

    PipelineItem *pipelinePtr = Pipeline;
    
    // Convert from the source to the nearest canonical format, if necessary.
    
    if (!IsCanonicalPixelFormat(srcfmt))
    {
        hr = AddOperation(
            &pipelinePtr,
            ConvertIntoCanonicalOps[srcfmtIndex],
            IsExtendedPixelFormat(srcfmt) ? 
                PIXFMT_64BPP_ARGB : PIXFMT_32BPP_ARGB
            );
        if (FAILED(hr)) 
        {
            return hr;
        }
    }
    
    // Convert to the other canonical format, if necessary.
    
    if (IsExtendedPixelFormat(srcfmt) != IsExtendedPixelFormat(dstfmt))
    {
        if (IsExtendedPixelFormat(srcfmt))
        {
            hr = AddOperation(
                &pipelinePtr,
                GammaConvert_sRGB64_sRGB,
                PIXFMT_32BPP_ARGB
                );
        }
        else
        {
            hr = AddOperation(
                &pipelinePtr,
                GammaConvert_sRGB_sRGB64,
                PIXFMT_64BPP_ARGB
                );
        }
        if (FAILED(hr)) 
        {
            return hr;
        }
    }
    
    // Convert to the destination format, if necessary.
    
    if (!IsCanonicalPixelFormat(dstfmt))
    {
        hr = AddOperation(
            &pipelinePtr,
            FCConvertFromCanonicalOps[dstfmtIndex],
            dstfmt
            );
        if (FAILED(hr)) 
        {
            return hr;
        }
    }
    
    // Assert that the number of operations in our pipeline is between
    // 1 and 3.
    
    ASSERT(pipelinePtr != Pipeline);
    ASSERT(((pipelinePtr - Pipeline) / sizeof(Pipeline[0])) <= 3);

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Check if we can do a pixel format converter from srcFmt to dstFmt
*
* Arguments:
*
*   srcFmt - Specifies the source pixel format
*   dstFmt - Specifies the destination pixel format
*
* Return Value:
*
*   Return TRUE if we can do the convertion, otherwise, return FALSE
*
* Note:
*   This function should be put in the hpp file as inline function. But since
*   the hpp file doesn't include scanoperationinternal.hpp (which is needed
*   because we need "FCConvertFromCanonicalOps" and "ConvertIntoCanonicalOps".)
*   So if the caller wants to use this function, he has to include this file 
*   which is not nice.
*
* Revision History:
*
*   04/28/2000 minliu
*       Created it.
*
\**************************************************************************/

BOOL
EpFormatConverter::CanDoConvert(
    const PixelFormatID srcFmt,
    const PixelFormatID dstFmt
    )
{
    if ( srcFmt == dstFmt )
    {
        // If the source and dest are the same format, of course we can convert

        return TRUE;
    }

    INT srcfmtIndex = GetPixelFormatIndex(srcFmt);
    INT dstfmtIndex = GetPixelFormatIndex(dstFmt);

    // If we can convert source to Canonical and then convert to dest, we can
    // do the convertion

    if ( (ConvertIntoCanonicalOps[srcfmtIndex] != NULL)
       &&(FCConvertFromCanonicalOps[dstfmtIndex] != NULL) )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}// CanDoConvert()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\gradientfill.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   GradientFill.cpp
*
* Abstract:
*
*   gradient fill routines.
*
* Revision History:
*
*   01/21/1999 ikkof
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#define CLAMP_COLOR_CHANNEL(a, b)  \
    if(a < 0)                   \
    {                           \
        a = 0;                  \
    }                           \
    if(a > b)                   \
    {                           \
        a = b;                  \
    }     

// 10bit inverse gamma 2.2 look up table.

static const BYTE TenBitInvGamma2_2 [] = {
    0, 11, 15, 18, 21, 23, 25, 26,
    28, 30, 31, 32, 34, 35, 36, 37,
    39, 40, 41, 42, 43, 44, 45, 45,
    46, 47, 48, 49, 50, 50, 51, 52,
    53, 54, 54, 55, 56, 56, 57, 58,
    58, 59, 60, 60, 61, 62, 62, 63,
    63, 64, 65, 65, 66, 66, 67, 68,
    68, 69, 69, 70, 70, 71, 71, 72,
    72, 73, 73, 74, 74, 75, 75, 76,
    76, 77, 77, 78, 78, 79, 79, 80,
    80, 81, 81, 81, 82, 82, 83, 83,
    84, 84, 84, 85, 85, 86, 86, 87,
    87, 87, 88, 88, 89, 89, 89, 90,
    90, 91, 91, 91, 92, 92, 93, 93,
    93, 94, 94, 94, 95, 95, 96, 96,
    96, 97, 97, 97, 98, 98, 98, 99,
    99, 99, 100, 100, 101, 101, 101, 102,
    102, 102, 103, 103, 103, 104, 104, 104,
    105, 105, 105, 106, 106, 106, 107, 107,
    107, 108, 108, 108, 108, 109, 109, 109,
    110, 110, 110, 111, 111, 111, 112, 112,
    112, 112, 113, 113, 113, 114, 114, 114,
    115, 115, 115, 115, 116, 116, 116, 117,
    117, 117, 117, 118, 118, 118, 119, 119,
    119, 119, 120, 120, 120, 121, 121, 121,
    121, 122, 122, 122, 123, 123, 123, 123,
    124, 124, 124, 124, 125, 125, 125, 125,
    126, 126, 126, 127, 127, 127, 127, 128,
    128, 128, 128, 129, 129, 129, 129, 130,
    130, 130, 130, 131, 131, 131, 131, 132,
    132, 132, 132, 133, 133, 133, 133, 134,
    134, 134, 134, 135, 135, 135, 135, 136,
    136, 136, 136, 137, 137, 137, 137, 138,
    138, 138, 138, 138, 139, 139, 139, 139,
    140, 140, 140, 140, 141, 141, 141, 141,
    142, 142, 142, 142, 142, 143, 143, 143,
    143, 144, 144, 144, 144, 144, 145, 145,
    145, 145, 146, 146, 146, 146, 146, 147,
    147, 147, 147, 148, 148, 148, 148, 148,
    149, 149, 149, 149, 149, 150, 150, 150,
    150, 151, 151, 151, 151, 151, 152, 152,
    152, 152, 152, 153, 153, 153, 153, 154,
    154, 154, 154, 154, 155, 155, 155, 155,
    155, 156, 156, 156, 156, 156, 157, 157,
    157, 157, 157, 158, 158, 158, 158, 158,
    159, 159, 159, 159, 159, 160, 160, 160,
    160, 160, 161, 161, 161, 161, 161, 162,
    162, 162, 162, 162, 163, 163, 163, 163,
    163, 164, 164, 164, 164, 164, 165, 165,
    165, 165, 165, 165, 166, 166, 166, 166,
    166, 167, 167, 167, 167, 167, 168, 168,
    168, 168, 168, 168, 169, 169, 169, 169,
    169, 170, 170, 170, 170, 170, 171, 171,
    171, 171, 171, 171, 172, 172, 172, 172,
    172, 173, 173, 173, 173, 173, 173, 174,
    174, 174, 174, 174, 174, 175, 175, 175,
    175, 175, 176, 176, 176, 176, 176, 176,
    177, 177, 177, 177, 177, 177, 178, 178,
    178, 178, 178, 179, 179, 179, 179, 179,
    179, 180, 180, 180, 180, 180, 180, 181,
    181, 181, 181, 181, 181, 182, 182, 182,
    182, 182, 182, 183, 183, 183, 183, 183,
    183, 184, 184, 184, 184, 184, 185, 185,
    185, 185, 185, 185, 186, 186, 186, 186,
    186, 186, 186, 187, 187, 187, 187, 187,
    187, 188, 188, 188, 188, 188, 188, 189,
    189, 189, 189, 189, 189, 190, 190, 190,
    190, 190, 190, 191, 191, 191, 191, 191,
    191, 192, 192, 192, 192, 192, 192, 192,
    193, 193, 193, 193, 193, 193, 194, 194,
    194, 194, 194, 194, 195, 195, 195, 195,
    195, 195, 195, 196, 196, 196, 196, 196,
    196, 197, 197, 197, 197, 197, 197, 197,
    198, 198, 198, 198, 198, 198, 199, 199,
    199, 199, 199, 199, 199, 200, 200, 200,
    200, 200, 200, 201, 201, 201, 201, 201,
    201, 201, 202, 202, 202, 202, 202, 202,
    202, 203, 203, 203, 203, 203, 203, 204,
    204, 204, 204, 204, 204, 204, 205, 205,
    205, 205, 205, 205, 205, 206, 206, 206,
    206, 206, 206, 206, 207, 207, 207, 207,
    207, 207, 207, 208, 208, 208, 208, 208,
    208, 209, 209, 209, 209, 209, 209, 209,
    210, 210, 210, 210, 210, 210, 210, 211,
    211, 211, 211, 211, 211, 211, 212, 212,
    212, 212, 212, 212, 212, 213, 213, 213,
    213, 213, 213, 213, 213, 214, 214, 214,
    214, 214, 214, 214, 215, 215, 215, 215,
    215, 215, 215, 216, 216, 216, 216, 216,
    216, 216, 217, 217, 217, 217, 217, 217,
    217, 218, 218, 218, 218, 218, 218, 218,
    218, 219, 219, 219, 219, 219, 219, 219,
    220, 220, 220, 220, 220, 220, 220, 221,
    221, 221, 221, 221, 221, 221, 221, 222,
    222, 222, 222, 222, 222, 222, 223, 223,
    223, 223, 223, 223, 223, 223, 224, 224,
    224, 224, 224, 224, 224, 225, 225, 225,
    225, 225, 225, 225, 225, 226, 226, 226,
    226, 226, 226, 226, 226, 227, 227, 227,
    227, 227, 227, 227, 228, 228, 228, 228,
    228, 228, 228, 228, 229, 229, 229, 229,
    229, 229, 229, 229, 230, 230, 230, 230,
    230, 230, 230, 230, 231, 231, 231, 231,
    231, 231, 231, 232, 232, 232, 232, 232,
    232, 232, 232, 233, 233, 233, 233, 233,
    233, 233, 233, 234, 234, 234, 234, 234,
    234, 234, 234, 235, 235, 235, 235, 235,
    235, 235, 235, 236, 236, 236, 236, 236,
    236, 236, 236, 237, 237, 237, 237, 237,
    237, 237, 237, 238, 238, 238, 238, 238,
    238, 238, 238, 238, 239, 239, 239, 239,
    239, 239, 239, 239, 240, 240, 240, 240,
    240, 240, 240, 240, 241, 241, 241, 241,
    241, 241, 241, 241, 242, 242, 242, 242,
    242, 242, 242, 242, 243, 243, 243, 243,
    243, 243, 243, 243, 243, 244, 244, 244,
    244, 244, 244, 244, 244, 245, 245, 245,
    245, 245, 245, 245, 245, 245, 246, 246,
    246, 246, 246, 246, 246, 246, 247, 247,
    247, 247, 247, 247, 247, 247, 248, 248,
    248, 248, 248, 248, 248, 248, 248, 249,
    249, 249, 249, 249, 249, 249, 249, 249,
    250, 250, 250, 250, 250, 250, 250, 250,
    251, 251, 251, 251, 251, 251, 251, 251,
    251, 252, 252, 252, 252, 252, 252, 252,
    252, 252, 253, 253, 253, 253, 253, 253,
    253, 253, 254, 254, 254, 254, 254, 254,
    254, 254, 254, 255, 255, 255, 255, 255
};

// 8bit to float gamma 2.2 LUT.

static const REAL Gamma2_2LUT[] = {
    0.000000000f, 0.001294648f, 0.005948641f, 0.014515050f,
    0.027332777f, 0.044656614f, 0.066693657f, 0.093619749f,
    0.125588466f, 0.162736625f, 0.205187917f, 0.253055448f,
    0.306443578f, 0.365449320f, 0.430163406f, 0.500671134f,
    0.577053056f, 0.659385527f, 0.747741173f, 0.842189273f,
    0.942796093f, 1.049625159f, 1.162737505f, 1.282191881f,
    1.408044937f, 1.540351382f, 1.679164133f, 1.824534436f,
    1.976511986f, 2.135145025f, 2.300480434f, 2.472563819f,
    2.651439585f, 2.837151004f, 3.029740281f, 3.229248608f,
    3.435716220f, 3.649182441f, 3.869685731f, 4.097263727f,
    4.331953283f, 4.573790502f, 4.822810773f, 5.079048802f,
    5.342538638f, 5.613313704f, 5.891406820f, 6.176850227f,
    6.469675611f, 6.769914121f, 7.077596394f, 7.392752570f,
    7.715412307f, 8.045604807f, 8.383358822f, 8.728702674f,
    9.081664270f, 9.442271111f, 9.810550312f, 10.18652861f,
    10.57023236f, 10.96168759f, 11.36091997f, 11.76795482f,
    12.18281716f, 12.60553168f, 13.03612276f, 13.47461451f,
    13.92103071f, 14.37539488f, 14.83773026f, 15.30805982f,
    15.78640628f, 16.27279209f, 16.76723947f, 17.26977037f,
    17.78040653f, 18.29916946f, 18.82608041f, 19.36116046f,
    19.90443044f, 20.45591098f, 21.01562250f, 21.58358523f,
    22.15981921f, 22.74434425f, 23.33718001f, 23.93834596f,
    24.54786138f, 25.16574537f, 25.79201687f, 26.42669465f,
    27.06979729f, 27.72134324f, 28.38135078f, 29.04983802f,
    29.72682293f, 30.41232332f, 31.10635686f, 31.80894107f,
    32.52009334f, 33.23983090f, 33.96817086f, 34.70513018f,
    35.45072570f, 36.20497412f, 36.96789203f, 37.73949586f,
    38.51980195f, 39.30882651f, 40.10658561f, 40.91309523f,
    41.72837123f, 42.55242933f, 43.38528517f, 44.22695426f,
    45.07745202f, 45.93679373f, 46.80499461f, 47.68206973f,
    48.56803410f, 49.46290260f, 50.36669002f, 51.27941105f,
    52.20108030f, 53.13171227f, 54.07132136f, 55.01992190f,
    55.97752811f, 56.94415413f, 57.91981400f, 58.90452170f,
    59.89829110f, 60.90113599f, 61.91307008f, 62.93410700f,
    63.96426029f, 65.00354342f, 66.05196978f, 67.10955268f,
    68.17630535f, 69.25224094f, 70.33737253f, 71.43171314f,
    72.53527570f, 73.64807306f, 74.77011803f, 75.90142331f,
    77.04200157f, 78.19186538f, 79.35102726f, 80.51949965f,
    81.69729494f, 82.88442544f, 84.08090341f, 85.28674102f,
    86.50195041f, 87.72654363f, 88.96053269f, 90.20392952f,
    91.45674601f, 92.71899397f, 93.99068516f, 95.27183128f,
    96.56244399f, 97.86253485f, 99.17211542f, 100.4911972f,
    101.8197915f, 103.1579098f, 104.5055633f, 105.8627634f,
    107.2295212f, 108.6058479f, 109.9917545f, 111.3872522f,
    112.7923519f, 114.2070647f, 115.6314012f, 117.0653726f,
    118.5089894f, 119.9622626f, 121.4252027f, 122.8978204f,
    124.3801265f, 125.8721313f, 127.3738455f, 128.8852796f,
    130.4064438f, 131.9373487f, 133.4780046f, 135.0284217f,
    136.5886104f, 138.1585808f, 139.7383431f, 141.3279074f,
    142.9272838f, 144.5364824f, 146.1555131f, 147.7843860f,
    149.4231109f, 151.0716977f, 152.7301563f, 154.3984965f,
    156.0767280f, 157.7648605f, 159.4629038f, 161.1708675f,
    162.8887612f, 164.6165945f, 166.3543769f, 168.1021179f,
    169.8598270f, 171.6275137f, 173.4051873f, 175.1928571f,
    176.9905325f, 178.7982229f, 180.6159374f, 182.4436852f,
    184.2814757f, 186.1293178f, 187.9872208f, 189.8551937f,
    191.7332455f, 193.6213854f, 195.5196223f, 197.4279651f,
    199.3464228f, 201.2750043f, 203.2137184f, 205.1625740f,
    207.1215799f, 209.0907449f, 211.0700776f, 213.0595868f,
    215.0592813f, 217.0691695f, 219.0892603f, 221.1195621f,
    223.1600835f, 225.2108331f, 227.2718194f, 229.3430508f,
    231.4245359f, 233.5162830f, 235.6183005f, 237.7305968f,
    239.8531803f, 241.9860592f, 244.1292419f, 246.2827366f,
    248.4465516f, 250.6206950f, 252.8051751f, 255.0000000f,
};




/**************************************************************************\
*
* Function Description:
*
* Arguments:
*
* Created:
*
*   04/26/1999 ikkof
*
\**************************************************************************/

DpOutputSpan *
DpOutputSpan::Create(
    const DpBrush * dpBrush,
    DpScanBuffer *  scan,
    DpContext *context,
    const GpRect *drawBounds
)
{
    const GpBrush * brush = GpBrush::GetBrush( (DpBrush *)(dpBrush));

    if(brush)
    {
        return ((GpBrush*) brush)->CreateOutputSpan(scan, context, drawBounds);
    }
    else
        return NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   Gradient brush constructor.
*
* Arguments:
*
* Created:
*
*   04/26/1999 ikkof
*
\**************************************************************************/

DpOutputGradientSpan::DpOutputGradientSpan(
    const GpElementaryBrush *brush,
    DpScanBuffer * scan,
    DpContext* context
    )
{
    Scan = scan;

    CompositingMode = context->CompositingMode;

    Brush = brush;
    BrushType = brush->GetBrushType();
    brush->GetRect(BrushRect);
    WrapMode = brush->GetWrapMode();

    // Incorporate the brush's transform into the graphics context's
    // current transform:

    GpMatrix xForm;
    brush->GetTransform(&xForm);

    WorldToDevice = context->WorldToDevice;
    WorldToDevice.Prepend(xForm);

    // !!![andrewgo] garbage is left in DeviceToWorld if not invertible

    if(WorldToDevice.IsInvertible())
    {
        DeviceToWorld = WorldToDevice;
        DeviceToWorld.Invert();
    }

    InitDefaultColorArrays(brush);
}

/**************************************************************************\
*
* Function Description:
*
*   Converts the input value by using the blend factors and
*   blend positions.
*
\**************************************************************************/
    
REAL
slowAdjustValue(
    REAL x, INT count,
    REAL falloff,
    REAL* blendFactors,
    REAL* blendPositions
    )
{
    REAL value = x;
    if(count == 1 && falloff != 1 && falloff > 0)
    {
        if((x >= 0.0f) && (x <= 1.0f))
            value = (REAL) pow(x, falloff);
    }
    else if(count >= 2 && blendFactors && blendPositions)
    {
        // This has to be an 'equality' test, because the 
        // DpOutputLinearGradientSpan fast-path samples only 
        // discretely, and it starts at exactly 0.0 and ends
        // exactly at 1.0.  We don't actually have to incorporate
        // an epsilon in that case because it always gives us
        // exactly 0.0 and 1.0 for the start and end.

        if((x >= 0.0f) && (x <= 1.0f))
        {
            INT index = 1;

            // Look for the interval.

            while( ((x-blendPositions[index]) > REAL_EPSILON) && 
                   (index < count) )
            {
                index++;
            }

            // Interpolate.

            if(index < count)
            {
                REAL d = blendPositions[index] - blendPositions[index - 1];
                if(d > 0)
                {
                    REAL t = (x - blendPositions[index - 1])/d;
                    value = blendFactors[index - 1]
                        + t*(blendFactors[index] - blendFactors[index - 1]);
                }
                else
                    value = (blendFactors[index - 1] + blendFactors[index])/2;
            }
        }
    }

    return value;
}

// We make this routine inline because it's nice and small and very 
// frequently we don't even have to call 'slowAdjustValue'.

inline
REAL
adjustValue(
    REAL x, INT count,
    REAL falloff,
    REAL* blendFactors,
    REAL* blendPositions
    )
{
    REAL value = x;

    if(count != 1 || falloff != 1)
    {
        value = slowAdjustValue(x, count, falloff, blendFactors, blendPositions);
    }
    
    return value;
}


/**************************************************************************\
*
* Function Description:
*
*   GammaLinearizeAndPremultiply
*
*   This function takes non-premultiplied ARGB input and emits a
*   Gamma converted (2.2) output 128bit floating point premultiplied
*   color value
*
* Arguments:
*
*   [IN]  ARGB         - input premultiplied floating point color value
*   [IN]  gammaCorrect - turn on gamma correction logic
*   [OUT] color        - output color value. 128bit float color. premultiplied
*
* 10/31/2000 asecchia
*   Created
*
\**************************************************************************/
VOID GammaLinearizeAndPremultiply( 
    ARGB argb,               // Non-premultiplied input.
    BOOL gammaCorrect,
    GpFColor128 *color       // pre-multiplied output.
)
{
    // Alpha (opacity) shouldn't be gamma corrected.
    
    color->a = (REAL)GpColor::GetAlphaARGB(argb);
    
    // Alpha zero...
    
    if(REALABS((color->a)) < REAL_EPSILON) 
    {
        color->r = 0.0f;
        color->g = 0.0f;
        color->b = 0.0f;
        
        // we're done.
        return;    
    }
    
    if(gammaCorrect)
    {
        
        // use the gamma 2.2 lookup table to convert r, g, b.
        
        color->r = Gamma2_2LUT[GpColor::GetRedARGB(argb)];
        color->g = Gamma2_2LUT[GpColor::GetGreenARGB(argb)];
        color->b = Gamma2_2LUT[GpColor::GetBlueARGB(argb)];
        
    }
    else
    {
        color->r = (REAL)GpColor::GetRedARGB(argb);
        color->g = (REAL)GpColor::GetGreenARGB(argb);
        color->b = (REAL)GpColor::GetBlueARGB(argb);
    }
    
    // Alpha != 255
    
    if(REALABS((color->a)-255.0f) >= REAL_EPSILON) 
    {
        // Do the premultiplication.
        
        color->r *= (color->a)/255.0f;
        color->g *= (color->a)/255.0f;
        color->b *= (color->a)/255.0f;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   GammaUnlinearizePremultiplied128.
*
*   This function takes a 128bit floating point premultiplied color and 
*   performs the inverse gamma correction step.
*
*   First the color value is unpremultiplied - then the r,g,b channels are
*   scaled into the range 0-1023 and rounded so that they match our 10bit
*   gamma lookup table. We pass it through the 1/2.2 gamma LUT and 
*   premultiply the output.
*
* Arguments:
*
*   [IN] color   - input premultiplied floating point color value
*
* Return:
*
*   ARGB         - output premultiplied 32bpp integer color (gamma corrected).
*
* 10/31/2000 asecchia
*   Created
*
\**************************************************************************/

ARGB GammaUnlinearizePremultiplied128(
    const GpFColor128 &color
)
{
    // Do the gamma conversion thing. Ten bits is enough.
    
    INT iA, iR, iG, iB;
    
    // First unpremultiply. Don't do gamma conversion on the alpha channel.
    
    iA = GpRound(color.a);
    
    // make sure we're passed a valid input alpha channel.
    
    ASSERT(iA >= 0);
    ASSERT(iA <= 255);
    
    // full transparency.
    
    if(iA == 0)
    {
        iR = iG = iB = 0;
    }
    else
    {
        // full opacity.
    
        if(iA == 255)
        {
            // Simply scale the color channels to 0-1023
            
            iR = GpRound(color.r*(1023.0f/255.0f));
            iG = GpRound(color.g*(1023.0f/255.0f));
            iB = GpRound(color.b*(1023.0f/255.0f));
        }
        else
        {
            // Alpha Divide. Note that alpha already has a factor of 255 and
            // so do all the color channels. Therefore when we divide the 
            // color channel by color.a, we implicitly cancel out the 255 
            // factor and all that's left is to scale up to 10bit --- hence
            // the scale factor of 1023/a
            
            REAL scale = 1023.0f/color.a;
            iR = GpRound(color.r*scale);
            iG = GpRound(color.g*scale);
            iB = GpRound(color.b*scale);
        }
    }
    
    // must be well formed color value otherwise we will AV accessing our
    // gamma conversion table.
    
    ASSERT(iB >= 0);
    ASSERT(iB <= 1023);
    ASSERT(iG >= 0);
    ASSERT(iG <= 1023);
    ASSERT(iR >= 0);
    ASSERT(iR <= 1023);
    
    // Apply Gamma using our 10bit inverse 2.2 power function table.
    
    GpColorConverter colorConv;
    colorConv.Channel.b = TenBitInvGamma2_2[iB];
    colorConv.Channel.g = TenBitInvGamma2_2[iG];
    colorConv.Channel.r = TenBitInvGamma2_2[iR];
    colorConv.Channel.a = static_cast<BYTE>(iA); // alpha is already linear.
    
    // Premultiply.
    
    return GpColor::ConvertToPremultiplied(colorConv.argb);
}


VOID
interpolatePresetColors(
    GpFColor128 *colorOut,
    REAL x,
    INT count,
    ARGB* presetColors,
    REAL* blendPositions,
    BOOL gammaCorrect
    )
{
    REAL value = x;

    if(count > 1 && presetColors && blendPositions)
    {
        if(x >= 0 && x <= 1)
        {
            INT index = 1;

            // Look for the interval.

            while(blendPositions[index] < x && index < count)
            {
                index++;
            }

            // Interpolate.

            if(index < count)
            {
                GpFColor128 color[2];

                GammaLinearizeAndPremultiply(
                    presetColors[index-1], 
                    gammaCorrect, 
                    &color[0]
                );

                GammaLinearizeAndPremultiply(
                    presetColors[index],
                    gammaCorrect, 
                    &color[1]
                );

                REAL d = blendPositions[index] - blendPositions[index - 1];
                if(d > 0)
                {
                    REAL t = (x - blendPositions[index - 1])/d;
                    colorOut->a = t*(color[1].a - color[0].a) + color[0].a;
                    colorOut->r = t*(color[1].r - color[0].r) + color[0].r;
                    colorOut->g = t*(color[1].g - color[0].g) + color[0].g;
                    colorOut->b = t*(color[1].b - color[0].b) + color[0].b;
                }
                else
                {
                    colorOut->a = (color[0].a + color[1].a)/2.0f;
                    colorOut->r = (color[0].r + color[1].r)/2.0f;
                    colorOut->g = (color[0].g + color[1].g)/2.0f;
                    colorOut->b = (color[0].b + color[1].b)/2.0f;
                }
            }
            else    // index == count
            {
                //!!! This case should not be happening if
                // the blendPositions array is properly set.
                // That means:
                // blendPositions array is monotonically
                // increasing and
                // blendPositions[0] = 0
                // blendPositions[count - 1] = 1.

                GammaLinearizeAndPremultiply(
                    presetColors[count-1], 
                    gammaCorrect,
                    colorOut
                );
            }
        }
        else if(x <= 0)
        {
            GammaLinearizeAndPremultiply(
                presetColors[0], 
                gammaCorrect, 
                colorOut
            );
        }
        else    // x >= 1
        {
            GammaLinearizeAndPremultiply(
                presetColors[count-1], 
                gammaCorrect, 
                colorOut
            );
        }
    }
}

DpTriangleData::DpTriangleData(
    VOID
    )
{
    SetValid(FALSE);
    IsPolygonMode = FALSE;
    GammaCorrect = FALSE;
    Index[0] = 0;
    Index[1] = 1;
    Index[2] = 2;
    GpMemset(&X[0], 0, 3*sizeof(REAL));
    GpMemset(&Y[0], 0, 3*sizeof(REAL));
    GpMemset(Color, 0, 3*sizeof(GpFColor128));
    Xmin = Xmax = 0;
    GpMemset(&M[0], 0, 3*sizeof(REAL));
    GpMemset(&DeltaY[0], 0, 3*sizeof(REAL));

    Falloff0 = 1;
    Falloff1 = 1;
    Falloff2 = 1;
    BlendCount0 = 1;
    BlendCount1 = 1;
    BlendCount2 = 1;
    BlendFactors0 = NULL;
    BlendFactors1 = NULL;
    BlendFactors2 = NULL;
    BlendPositions0 = NULL;
    BlendPositions1 = NULL;
    BlendPositions2 = NULL;

    XSpan[0] = 0.0f;
    XSpan[1] = 0.0f;
}

VOID
DpTriangleData::SetTriangle(
    GpPointF& pt0,
    GpPointF& pt1,
    GpPointF& pt2,
    GpColor& color0,
    GpColor& color1,
    GpColor& color2,
    BOOL isPolygonMode,
    BOOL gammaCorrect
    )
{
    IsPolygonMode = isPolygonMode;
    GammaCorrect = gammaCorrect;

    // !!! [asecchia] Windows db #203480
    // We're filtering the input points here because the rest of the 
    // gradient code is sloppy about handling the comparison between 
    // floating point coordinates. Basically no attempt is made to 
    // handle rounding error and therefore we can get random off-by-one
    // scanline rendering errors based on coordinate differences 
    // on the order of FLT_EPSILON in size.
    // Effectively we're applying a noise filter here by rounding to 
    // 4 bits of fractional precision. This was chosen to match our
    // rasterizer rounding precision because we're in device space
    // already.
    
    X[0] = TOREAL(GpRealToFix4(pt0.X)) / 16.0f;
    Y[0] = TOREAL(GpRealToFix4(pt0.Y)) / 16.0f;
    X[1] = TOREAL(GpRealToFix4(pt1.X)) / 16.0f;
    Y[1] = TOREAL(GpRealToFix4(pt1.Y)) / 16.0f;
    X[2] = TOREAL(GpRealToFix4(pt2.X)) / 16.0f;
    Y[2] = TOREAL(GpRealToFix4(pt2.Y)) / 16.0f;

    GammaLinearizeAndPremultiply(
        color0.GetValue(), 
        GammaCorrect, 
        &Color[0]
    );

    GammaLinearizeAndPremultiply(
        color1.GetValue(), 
        GammaCorrect, 
        &Color[1]
    );

    GammaLinearizeAndPremultiply(
        color2.GetValue(), 
        GammaCorrect, 
        &Color[2]
    );

    Xmin = Xmax = X[0];
    Xmin = min(Xmin, X[1]);
    Xmax = max(Xmax, X[1]);
    Xmin = min(Xmin, X[2]);
    Xmax = max(Xmax, X[2]);

    INT i, j;

    // Sort the points according to the ascending y order. 
    for(i = 0; i < 2; i++)
    {
        for(j = i; j < 3; j++)
        {
            if((Y[j] < Y[i]) ||
                ( (Y[j] == Y[i]) && (X[j] < X[i]) ))
            {
                REAL temp;
                INT tempColor;
                INT tempIndex;

                tempIndex = Index[i];
                Index[i] = Index[j];
                Index[j] = tempIndex;

                temp = X[i];
                X[i] = X[j];
                X[j] = temp;
                temp = Y[i];
                Y[i] = Y[j];
                Y[j] = temp;
            }
        }
    }

    // Calculate the gradients if possible.  

    if(Y[0] != Y[1])
    {
        // P0->P2

        DeltaY[0] = TOREAL(1.0)/(Y[1] - Y[0]);
        M[0] = (X[1] - X[0])*DeltaY[0];
    }
    if(Y[1] != Y[2])
    {
        // P2->P1

        DeltaY[1] = TOREAL(1.0)/(Y[1] - Y[2]);
        M[1] = (X[1] - X[2])*DeltaY[1];
    }
    if(Y[2] != Y[0])
    {
        // P0->P2

        DeltaY[2] = TOREAL(1.0)/(Y[2] - Y[0]);
        M[2] = (X[2] - X[0])*DeltaY[2];
    }

    SetValid(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Get the x span and st array values for this triangle for the scanline 
*   specified by y.
*   NOTE:  This must be called after SetXSpan for a particular value of y.
*
* Return Value:
*
*   TRUE if retrieved successfully
*
* Created: peterost
*
\**************************************************************************/

BOOL
DpTriangleData::GetXSpan(REAL y, REAL xmin, REAL xmax, REAL* x, GpPointF* s)
{
    // If SetXSpan did it's job correctly, we shouldn't need to do all this
    // stuff. In fact we shouldn't even need to pass all these parameters.
    // We simply retrieve the values for the span.
    
    if(!IsValid() || y < Y[0] || y >= Y[2] || xmin > Xmax || 
       xmax < Xmin || XSpan[0] == XSpan[1])
    {
        return FALSE;
    }

    // Retrieve the span coordinates.
    
    x[0] = XSpan[0];
    x[1] = XSpan[1];
    s[0].X = STGradient[0].X;
    s[0].Y = STGradient[0].Y;
    s[1].X = STGradient[1].X;
    s[1].Y = STGradient[1].Y;

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the x span and st array values for this triangle for the scanline 
*   specified by y.
*   NOTE:  This must be called before GetXSpan for a particular value of y.
*
* Return Value:
*
*   TRUE if set successfully
*
* Created: peterost (factored out of GetXSpan created by ikkof)
*
\**************************************************************************/

BOOL
DpTriangleData::SetXSpan(REAL y, REAL xmin, REAL xmax, REAL* x)
{
    if(!IsValid() || y < Y[0] || y >= Y[2] || xmin > Xmax || xmax < Xmin)
        return FALSE;

    REAL xSpan[2], dy;
    REAL s1[2], t1[2];

    if(y < Y[1])    // Y[0] <= y < Y[1]
    {
        dy = y - Y[0];

        // P0->P1
        xSpan[0] = X[0] + M[0]*dy;
        s1[0] = DeltaY[0]*dy;
        t1[0] = 0;

        // P0->P2
        xSpan[1] = X[0] + M[2]*dy;
        s1[1] = 0;
        t1[1] = DeltaY[2]*dy;
    }
    else // Y[1] <= y < Y[2]
    {
        // P2->P1
        dy = y - Y[2];
        xSpan[0] = X[2] + M[1]*dy;
        s1[0] = DeltaY[1]*dy;
        t1[0] = 1 - s1[0];

        // P0->P2
        dy = y - Y[0];
        xSpan[1] = X[0] + M[2]*dy;
        s1[1] = 0;
        t1[1] = DeltaY[2]*dy;;
    }

    if(xSpan[0] == xSpan[1])
    {
        XSpan[0] = xSpan[0];
        XSpan[1] = xSpan[1];
        return FALSE;
    }

    // We must convert to the st values of the original
    // triangle.

    INT sIndex = 1, tIndex = 2;

    for(INT i = 0; i < 3; i++)
    {
        if(Index[i] == 1)
            sIndex = i;
        if(Index[i] == 2)
            tIndex = i;
    }

    REAL s[2], t[2];

    switch(sIndex)
    {
    case 0:
        s[0] = 1 - s1[0] - t1[0];
        s[1] = 1 - s1[1] - t1[1];
        break;
    case 1:
        s[0] = s1[0];
        s[1] = s1[1];
        break;
    case 2:
        s[0] = t1[0];
        s[1] = t1[1];
        break;
    }

    switch(tIndex)
    {
    case 0:
        t[0] = 1 - s1[0] - t1[0];
        t[1] = 1 - s1[1] - t1[1];
        break;
    case 1:
        t[0] = s1[0];
        t[1] = s1[1];
        break;
    case 2:
        t[0] = t1[0];
        t[1] = t1[1];
        break;
    }

    INT k0, k1;

    if(xSpan[0] < xSpan[1])
    {
        k0 = 0;
        k1 = 1;
    }
    else
    {
        k0 = 1;
        k1 = 0;
    }

    XSpan[k0] = xSpan[0];
    XSpan[k1] = xSpan[1];
    STGradient[k0].X = s[0];
    STGradient[k1].X = s[1];
    STGradient[k0].Y = t[0];
    STGradient[k1].Y = t[1];

    x[0] = XSpan[0];
    x[1] = XSpan[1];

    return TRUE;
}

GpStatus
DpTriangleData::OutputSpan(
    ARGB* buffer,
    INT compositingMode,
    INT y,
    INT &xMin,
    INT &xMax    // xMax is exclusive
    )
{
    PointF st[2];
    REAL xSpan[2];

    // First grab the span for this y coordinate. 
    // Note that GetXSpan returns the xSpan coordinates and the (s, t) texture
    // coordinates and that both are unclipped. We have to infer the clipping
    // based on the difference between the xSpan coordinates and the 
    // input xMin and xMax coordinates and explicitly apply clipping to the
    // texture space coordinates (s, t).
    //
    // ( Texture mapping and gradient filling are mathematically similar 
    //   problems so we use 'texture space' and 'texture coordinates' 
    //   to refer to the gradient interpolation. In this way, gradient fills
    //   can be thought of as procedurally-defined textures. )
    
    if(!GetXSpan((REAL) y, (REAL) xMin, (REAL) xMax, xSpan, st))
    {
        return Ok;
    }
    
    // SetXSpan ensures a correct ordering of the xSpan coordinates.
    // We rely on this, so we must ASSERT it.
    
    ASSERT(xSpan[0] <= xSpan[1]);

    // Round using our rasterizer rounding rules.
    // This is not strictly true, though, our rasterizer uses GpFix4Ceiling
    // See RasterizerCeiling
    
    INT xLeft  = GpFix4Round(GpRealToFix4(xSpan[0]));
    INT xRight = GpFix4Round(GpRealToFix4(xSpan[1]));
    
    // Clip the x values.
    
    xLeft  = max(xLeft, xMin);
    xRight = min(xRight, xMax);  // remember, xMax is exclusive.
    
    // We're done. No pixels to emit.
    
    if(xLeft >= xRight)
    {
        return Ok;
    }
    
    // Now compute the per pixel interpolation increments for the 
    // texture (s, t) coordinates.
    
    // Here are our actual interpolation coordinates.
    // Start them off at the left-hand edge of the span.

    REAL s = st[0].X;
    REAL t = st[0].Y;
    
    // Left clipping.
    
    // This is the amount to clip off the left edge of the span to reach
    // the left-most pixel.
    
    REAL clipLength = (REAL)xLeft - xSpan[0];
    
    if(REALABS(clipLength) > REAL_EPSILON)
    {
        ASSERT((xSpan[1]-xSpan[0]) != 0.0f);
        
        // Compute the proportion of the span that we're clipping off.
        // This is in the range [0,1]
        
        REAL u = clipLength/(xSpan[1]-xSpan[0]);
        
        // Apply the proportion to texture space and then add to the left
        // texture coordinate.
        
        s += u*(st[1].X-st[0].X);
        t += u*(st[1].Y-st[0].Y);
    }

    // Temporaries to store the right-hand texture endpoint for the span.
    
    REAL s_right = st[1].X;
    REAL t_right = st[1].Y;
    
    // Right clipping.
    
    // This is the amount to clip off the right edge of the span to reach
    // the right-most pixel.
    
    clipLength = xSpan[1] - xRight;
    
    if(REALABS(clipLength) > REAL_EPSILON)
    {
        ASSERT((xSpan[1]-xSpan[0]) != 0.0f);
        
        // Compute the proportion of the span that we're clipping off.
        // This is in the range [0,1]
        
        REAL u = clipLength/(xSpan[1]-xSpan[0]);
        
        // Apply the proportion to texture space and then subtract from the 
        // right texture coordinate.
        
        s_right -= u*(st[1].X-st[0].X);
        t_right -= u*(st[1].Y-st[0].Y);
    }

    // Divide each texture coordinate interval by the number of pixels we're
    // emitting. Note that xRight != xLeft. Also note that SetXSpan ensures a 
    // correct ordering of the xSpan coordinates. This gives us a set of
    // per pixel delta values for the (s, t) coordinates.  
    // The next pixels texture coordinate is computed according 
    // to the following formula:
    // (s', t') <-- (s, t) + (ds, dt)

    ASSERT(xRight > xLeft);

    REAL ds = (s_right - s)/(xRight - xLeft);
    REAL dt = (t_right - t)/(xRight - xLeft);

    GpFColor128 colorOut;

    buffer += (xLeft - xMin);
    
    for(INT x = xLeft; x < xRight; x++, buffer++)
    {
        if(!(UsesPresetColors && BlendPositions0 && BlendCount0 > 1))
        {
            if(BlendCount0 == 1 && Falloff0 == 1
                && BlendCount1 == 1 && Falloff1 == 1
                && BlendCount2 == 1 && Falloff2 == 1)
            {
                colorOut.a = Color[0].a + s*(Color[1].a - Color[0].a) + t*(Color[2].a - Color[0].a);
                colorOut.r = Color[0].r + s*(Color[1].r - Color[0].r) + t*(Color[2].r - Color[0].r);
                colorOut.g = Color[0].g + s*(Color[1].g - Color[0].g) + t*(Color[2].g - Color[0].g);
                colorOut.b = Color[0].b + s*(Color[1].b - Color[0].b) + t*(Color[2].b - Color[0].b);
            }
            else
            {
                REAL u1, s1, t1;

                u1 = ::adjustValue(1 - s - t, BlendCount0, Falloff0,
                            BlendFactors0, BlendPositions0);
                s1 = ::adjustValue(s, BlendCount1, Falloff1,
                            BlendFactors1, BlendPositions1);
                t1 = ::adjustValue(t, BlendCount2, Falloff2,
                            BlendFactors2, BlendPositions2);

                REAL sum;

                if(!IsPolygonMode)
                {
                    sum = u1 + s1 + t1;
                    u1 = u1/sum;
                    s1 = s1/sum;
                    t1 = t1/sum;
                }
                else
                {
                    // If it is the polygon gradient, treat u1 differently.
                    // This gives the similar behavior as RadialGradient.

                    sum = s1 + t1;
                    if(sum != 0)
                    {
                        sum = (1 - u1)/sum;
                        s1 *= sum;
                        t1 *= sum;
                    }
                }

                colorOut.a = Color[0].a + s1*(Color[1].a - Color[0].a) + t1*(Color[2].a - Color[0].a);
                colorOut.r = Color[0].r + s1*(Color[1].r - Color[0].r) + t1*(Color[2].r - Color[0].r);
                colorOut.g = Color[0].g + s1*(Color[1].g - Color[0].g) + t1*(Color[2].g - Color[0].g);
                colorOut.b = Color[0].b + s1*(Color[1].b - Color[0].b) + t1*(Color[2].b - Color[0].b);
            }
        }
        else
        {
            interpolatePresetColors(
                &colorOut,
                1 - s - t,
                BlendCount0,
                PresetColors,
                BlendPositions0,
                GammaCorrect
            );
        }

        s += ds;
        t += dt;

        if((REALABS(colorOut.a) >= REAL_EPSILON) || 
            compositingMode == CompositingModeSourceCopy)
        {
            GpColorConverter colorConv;

            // Make sure the colorOut is properly premultiplied.
            
            CLAMP_COLOR_CHANNEL(colorOut.a, 255.0f)
            CLAMP_COLOR_CHANNEL(colorOut.r, colorOut.a);
            CLAMP_COLOR_CHANNEL(colorOut.g, colorOut.a);
            CLAMP_COLOR_CHANNEL(colorOut.b, colorOut.a);
            
            if(GammaCorrect)
            {
                colorConv.argb = GammaUnlinearizePremultiplied128(colorOut);
            }
            else
            {
                colorConv.Channel.a = static_cast<BYTE>(GpRound(colorOut.a));
                colorConv.Channel.r = static_cast<BYTE>(GpRound(colorOut.r));
                colorConv.Channel.g = static_cast<BYTE>(GpRound(colorOut.g));
                colorConv.Channel.b = static_cast<BYTE>(GpRound(colorOut.b));
            }
            
            // Clamp to the alpha channel for the premultiplied alpha blender.
            
            *buffer = colorConv.argb;
        }
        else
        {
            *buffer = 0;    // case of CompositingModeSourceOver && alpha = 0
        }
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster with a gradient brush.
*   Is called by the rasterizer.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   01/21/1999 ikkof
*
\**************************************************************************/

GpStatus
DpOutputGradientSpan::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    ARGB    argb;
    INT     width  = xMax - xMin;
    if(width <= 0)
        return Ok;

    ARGB *  buffer = Scan->NextBuffer(xMin, y, width);

    GpPointF pt1, pt2;
    pt1.X = (REAL) xMin;
    pt1.Y = pt2.Y = (REAL) y;
    pt2.X = (REAL)xMax;

    DeviceToWorld.Transform(&pt1);
    DeviceToWorld.Transform(&pt2);

    REAL u1, v1, u2, v2, du, dv;

    u1 = (pt1.X - BrushRect.X)/BrushRect.Width;
    v1 = (pt1.Y - BrushRect.Y)/BrushRect.Height;
    u2 = (pt2.X - BrushRect.X)/BrushRect.Width;
    v2 = (pt2.Y - BrushRect.Y)/BrushRect.Height;
    du = (u2 - u1)/width;
    dv = (v2 - v1)/width;

    INT i;
    REAL u0 = u1, v0 = v1;
    REAL u, v;

    REAL delta = min(BrushRect.Width, BrushRect.Height)/2;
    
    if(REALABS(delta) < REAL_EPSILON)
    {
        delta = 1.0f;
    }
    
    REAL deltaInv = 1.0f/delta;

    for(i = 0; i < width; i++, buffer++)
    {
        u = u0;
        v = v0;
        REAL alpha = 0, red = 0, green = 0, blue = 0;

        // If this is the outside of the rectangle in Clamp mode,
        // don't draw anything.

        if(WrapMode == WrapModeClamp)
        {
            if(u < 0 || u > 1 || v < 0 || v > 1)
            {
                *buffer = 0;

                goto NextUV;
            }
        }
        
        // Remap the v-coordinate in Tile mode.

        if(WrapMode == WrapModeTile || WrapMode == WrapModeTileFlipX)
        {
            // Get the fractional part of v.
            v = GpModF(v, 1);
        }
        else if(WrapMode == WrapModeTileFlipY || WrapMode == WrapModeTileFlipXY)
        {
            INT nV;

            nV = GpFloor(v);
            v = GpModF(v, 1);

            if(nV & 1)
                v = 1 - v;  // flip.
        }

        // Remap the u-coordinate in Tile mode.

        if(WrapMode == WrapModeTile || WrapMode == WrapModeTileFlipY)
        {
            // Get the fractional part of u.
            u = GpModF(u, 1);
        }
        else if(WrapMode == WrapModeTileFlipX || WrapMode == WrapModeTileFlipXY)
        {
            INT nU;

            nU = GpFloor(u);
            u = GpModF(u, 1);

            if(nU & 1)
                u = 1 - u;  // flip.
        }

        if(/*BrushType == BrushRectGrad ||*/ BrushType == BrushTypeLinearGradient)
        {
            const GpRectGradient* rectGrad = static_cast<const GpRectGradient*> (Brush);

            if(!(rectGrad->HasPresetColors() &&
                 rectGrad->DeviceBrush.PresetColors &&
                 rectGrad->DeviceBrush.BlendPositions[0] &&
                 rectGrad->DeviceBrush.BlendCounts[0] > 1))
            {
                u = ::adjustValue(
                    u,
                    rectGrad->DeviceBrush.BlendCounts[0],
                    rectGrad->DeviceBrush.Falloffs[0],
                    rectGrad->DeviceBrush.BlendFactors[0],
                    rectGrad->DeviceBrush.BlendPositions[0]
                    );

                v = ::adjustValue(
                    v,
                    rectGrad->DeviceBrush.BlendCounts[1],
                    rectGrad->DeviceBrush.Falloffs[1],
                    rectGrad->DeviceBrush.BlendFactors[1],
                    rectGrad->DeviceBrush.BlendPositions[1]
                    );

                REAL c[4];

                c[0] = (1 - u)*(1 - v);
                c[1] = u*(1 - v);
                c[2] = (1 - u)*v;
                c[3] = u*v;

                // We must interpolate alpha.
                alpha = c[0]*A[0] + c[1]*A[1]
                    + c[2]*A[2] + c[3]*A[3];
                red = c[0]*R[0] + c[1]*R[1]
                    + c[2]*R[2] + c[3]*R[3];
                green = c[0]*G[0] + c[1]*G[1]
                    + c[2]*G[2] + c[3]*G[3];
                blue = c[0]*B[0] + c[1]*B[1]
                    + c[2]*B[2] + c[3]*B[3];
            }
            else
            {
                GpFColor128 color;
                interpolatePresetColors(
                    &color,
                    u,
                    rectGrad->DeviceBrush.BlendCounts[0],
                    rectGrad->DeviceBrush.PresetColors,
                    rectGrad->DeviceBrush.BlendPositions[0],
                    FALSE
                );
                
                alpha = color.a;
                red = color.r;
                green = color.g;
                blue = color.b;
            }
        }

        if(alpha != 0 || CompositingMode == CompositingModeSourceCopy)
        {
            CLAMP_COLOR_CHANNEL(alpha, 255.0f);
            CLAMP_COLOR_CHANNEL(red, alpha);
            CLAMP_COLOR_CHANNEL(green, alpha);
            CLAMP_COLOR_CHANNEL(blue, alpha);

            *buffer = GpColor::MakeARGB(
                static_cast<BYTE>(GpRound(alpha)),
                static_cast<BYTE>(GpRound(red)),
                static_cast<BYTE>(GpRound(green)), 
                static_cast<BYTE>(GpRound(blue)));
        }
        else
        {
            *buffer = 0;    // case of CompositingModeSourceOver && alpha = 0
        }

NextUV:
        u0 += du;
        v0 += dv;
    }

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Constructor for One Dimentional Gradient.
*
* Arguments:
*
*   [IN] brush - brush
*   [IN] scan  - the scan buffer
*   [IN] context - the context
*   [IN] isHorizontal - TRUE if this is the horizontal gradient.
*                       Also TRUE for more complicated one-D gradient like
*                       Radial Gradient.
*   [IN] isVertical - TRUE if this is the vertical gradient.
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/21/1999 ikkof
*
\**************************************************************************/

DpOutputOneDGradientSpan::DpOutputOneDGradientSpan(
    const GpElementaryBrush *brush,
    DpScanBuffer * scan,
    DpContext* context,
    BOOL isHorizontal,
    BOOL isVertical
    ) : DpOutputGradientSpan(brush, scan, context)
{
    FPUStateSaver::AssertMode();
    
    Initialize();               
    
    GpStatus status = AllocateOneDData(isHorizontal, isVertical);

    if(status == Ok)
    {
        if(BrushType == BrushTypeLinearGradient)
        {
            SetupRectGradientOneDData();
        }
    }

    if(status == Ok)
        SetValid(TRUE);
}

GpStatus
DpOutputOneDGradientSpan::AllocateOneDData(
    BOOL isHorizontal,
    BOOL isVertical
    )
{
    if(!isHorizontal && !isVertical)
        return InvalidParameter;
    
    IsHorizontal = isHorizontal;
    IsVertical = isVertical;

    GpPointF axis[4];

    axis[0].X = 0;
    axis[0].Y = 0;
    axis[1].X = BrushRect.Width;
    axis[1].Y = 0;
    axis[2].X = BrushRect.Width;
    axis[2].Y = BrushRect.Height;
    axis[3].X = 0;
    axis[3].Y = BrushRect.Height;

    WorldToDevice.VectorTransform(&axis[0], 4);

    // Calculate the sum of the diagonals as the largest possible distance
    // of interest and use this to size the OneD array of colors.  This gets us
    // to within 1 bit of the "true" gradient values for each A,R,G,B channel.
    REAL d1 = REALSQRT(distance_squared(axis[0], axis[2]));
    REAL d2 = REALSQRT(distance_squared(axis[1], axis[3]));

    OneDDataMultiplier = max(1, GpCeiling(d1+d2));
    OneDDataCount = OneDDataMultiplier + 2;

    GpStatus status = Ok;

    OneDData = (ARGB*) GpMalloc(OneDDataCount*sizeof(ARGB));

    if(!OneDData)
        status = OutOfMemory;

    return status;
}

DpOutputOneDGradientSpan::~DpOutputOneDGradientSpan()
{
    if(OneDData)
        GpFree(OneDData);
}

VOID
DpOutputOneDGradientSpan::SetupRectGradientOneDData(
    )
{
    REAL u, u0, du;

    u0 = 0;
    du = 1.0f/OneDDataMultiplier;
    ARGB* buffer = OneDData;

    ASSERT(buffer);
    if(!buffer)
        return;

    for(INT i = 0; i < OneDDataCount; i++, buffer++)
    {       
        u = u0;

        const GpRectGradient* rectGrad = static_cast<const GpRectGradient*> (Brush);

        REAL alpha = 0, red = 0, green = 0, blue = 0;

        if(!(rectGrad->HasPresetColors() &&
            rectGrad->DeviceBrush.PresetColors &&
            rectGrad->DeviceBrush.BlendPositions[0] &&
            rectGrad->DeviceBrush.BlendCounts[0] > 1))
        {
            INT index, i0, i1;
            REAL a0, r0, g0, b0, a1, r1, g1, b1;

            if(IsHorizontal)
            {
                index = 0;
                i0 = 0;
                i1 = 1;
            }
            else
            {
                index = 1;
                i0 = 0;
                i1 = 2;
            }

            a0 = A[i0];
            r0 = R[i0];
            g0 = G[i0];
            b0 = B[i0];

            a1 = A[i1];
            r1 = R[i1];
            g1 = G[i1];
            b1 = B[i1];
            
            u = ::adjustValue(
                u0,
                rectGrad->DeviceBrush.BlendCounts[index],
                rectGrad->DeviceBrush.Falloffs[index],
                rectGrad->DeviceBrush.BlendFactors[index],
                rectGrad->DeviceBrush.BlendPositions[index]
                );

            REAL c[2];

            c[0] = (1 - u);
            c[1] = u;

            // We must interpolate alpha.
            alpha = c[0]*a0 + c[1]*a1;
            red = c[0]*r0 + c[1]*r1;
            green = c[0]*g0 + c[1]*g1;
            blue = c[0]*b0 + c[1]*b1;
        }
        else
        {
            GpFColor128 color;
                
            interpolatePresetColors(
                &color, 
                u0,
                rectGrad->DeviceBrush.BlendCounts[0],
                rectGrad->DeviceBrush.PresetColors,
                rectGrad->DeviceBrush.BlendPositions[0],
                FALSE
            );
            alpha = color.a;
            red = color.r;
            green = color.g;
            blue = color.b;
        }

        if(alpha != 0 || CompositingMode == CompositingModeSourceCopy)
        {
            CLAMP_COLOR_CHANNEL(alpha, 255.0f);
            CLAMP_COLOR_CHANNEL(red, alpha);
            CLAMP_COLOR_CHANNEL(green, alpha);
            CLAMP_COLOR_CHANNEL(blue, alpha);

            *buffer = GpColor::MakeARGB(
                static_cast<BYTE>(GpRound(alpha)),
                static_cast<BYTE>(GpRound(red)),
                static_cast<BYTE>(GpRound(green)), 
                static_cast<BYTE>(GpRound(blue)));
        }
        else
        {
            *buffer = 0;    // case of CompositingModeSourceOver && alpha = 0
        }

        u0 += du;
    }
}


VOID
DpOutputOneDGradientSpan::SetupRadialGradientOneDData()
{
    ASSERT(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster with a gradient brush.
*   Is called by the rasterizer.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   01/21/1999 ikkof
*
\**************************************************************************/

GpStatus
DpOutputOneDGradientSpan::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    ARGB    argb;
    INT     width  = xMax - xMin;
    if(width <= 0 || !OneDData)
        return Ok;

    ARGB *  buffer = Scan->NextBuffer(xMin, y, width);

    GpPointF pt1, pt2;
    pt1.X = (REAL) xMin;
    pt1.Y = pt2.Y = (REAL) y;
    pt2.X = (REAL)xMax;

    DeviceToWorld.Transform(&pt1);
    DeviceToWorld.Transform(&pt2);

    REAL u1, v1, u2, v2;

    u1 = (pt1.X - BrushRect.X)/BrushRect.Width;
    v1 = (pt1.Y - BrushRect.Y)/BrushRect.Height;
    u2 = (pt2.X - BrushRect.X)/BrushRect.Width;
    v2 = (pt2.Y - BrushRect.Y)/BrushRect.Height;

    INT u1Major, u2Major, v1Major, v2Major;
    INT u1Minor, u2Minor, v1Minor, v2Minor;

    u1Major = GpFloor(u1); 
    u2Major = GpFloor(u2);
    u1Minor = GpRound(OneDDataMultiplier*(u1 - u1Major));
    u2Minor = GpRound(OneDDataMultiplier*(u2 - u2Major));

    v1Major = GpFloor(v1);
    v2Major = GpFloor(v2);
    v1Minor = GpRound(OneDDataMultiplier*(v1 - v1Major));
    v2Minor = GpRound(OneDDataMultiplier*(v2 - v2Major));

    INT du, dv;

    du = GpRound((u2 - u1)*OneDDataMultiplier/width);
    dv = GpRound((v2 - v1)*OneDDataMultiplier/width);

    INT i;

    INT uMajor, uMinor, vMajor, vMinor;

    uMajor = u1Major;
    uMinor = u1Minor;
    vMajor = v1Major;
    vMinor = v1Minor;

    if(BrushType == BrushTypeLinearGradient)
    {
        for(i = 0; i < width; i++, buffer++)
        {
            if(IsHorizontal)
            {
                if((WrapMode == WrapModeTileFlipX || WrapMode == WrapModeTileFlipXY)
                    && (uMajor & 0x01) != 0)
                    *buffer = OneDData[OneDDataMultiplier - uMinor];
                else
                    *buffer = OneDData[uMinor];
            }
            else if(IsVertical)
            {
                if((WrapMode == WrapModeTileFlipY || WrapMode == WrapModeTileFlipXY)
                    && (vMajor & 0x01) != 0)
                    *buffer = OneDData[OneDDataMultiplier - vMinor];
                else
                    *buffer = OneDData[vMinor];
            }

            if(WrapMode == WrapModeClamp)
            {
                if(uMajor != 0 || vMajor != 0)
                    *buffer = 0;
            }

            uMinor += du;

            while(uMinor >= OneDDataMultiplier)
            {
                uMajor++;
                uMinor -= OneDDataMultiplier;
            }

            while(uMinor < 0)
            {
                uMajor--;
                uMinor += OneDDataMultiplier;
            }

            vMinor += dv;

            while(vMinor >= OneDDataMultiplier)
            {
                vMajor++;
                vMinor -= OneDDataMultiplier;
            }

            while(vMinor < 0)
            {
                vMajor--;
                vMinor += OneDDataMultiplier;
            }
        }
    } 

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor for linear gradient.
*
* Arguments:
*
*   [IN] brush - brush
*   [IN] scan  - the scan buffer
*   [IN] context - the context
*
* Return Value:
*
*   NONE
*
* Created:
*
*   1/13/2000 andrewgo
*
\**************************************************************************/

DpOutputLinearGradientSpan::DpOutputLinearGradientSpan(
    const GpElementaryBrush *brush,
    DpScanBuffer * scan,
    DpContext* context
    ) : DpOutputGradientSpan(brush, scan, context)
{
    SetValid(FALSE);

    const GpRectGradient* gradient = static_cast<const GpRectGradient*>(brush);

    // Copy some brush attributes to locals for speed:

    GpRectF brushRect;
    gradient->GetRect(brushRect);

    BOOL doPresetColor = (gradient->HasPresetColors());
    BOOL doAdjustValue = (gradient->DeviceBrush.BlendCounts[0] != 1) ||
                         (gradient->DeviceBrush.Falloffs[0] != 1);

    // For now we just assume 32 pixels in the texture.  In the future,
    // we can change this to be inherited from the API.

    UINT numberOfIntervalBits = 5;
    UINT numberOfTexels = 32;
    
    // If we're doing a fancy blend with multiple color points.

    if(doPresetColor || doAdjustValue)
    {
        // Office specifies simple blends with 2-3 blend factors. If it's a 
        // simple blend, 32 texels is enough, but if it's complicated lets
        // use more texels.  Use in the range of the width + height, with a
        // cap of 512.  Using too many texels can result in overflow errors
        // when calculating M11, M21 and Dx, and is wasted memory and 
        // processing power.

        if(gradient->DeviceBrush.BlendCounts[0] > 3)
        {
            REAL widthHeight = brushRect.Width + brushRect.Height;
            if (widthHeight > 512)
            {
                numberOfTexels = 512;
               numberOfIntervalBits = 9;
            }
            else if (widthHeight > 128)
            {
                numberOfTexels = 128;
                numberOfIntervalBits = 7;
            }
        } 
    }
 
    const UINT halfNumberOfTexels = numberOfTexels / 2;

    // The number of texels has to be a power of two:

    ASSERT((numberOfTexels & (numberOfTexels - 1)) == 0);

    // Remember the size:

    IntervalMask = numberOfTexels - 1;
    NumberOfIntervalBits = numberOfIntervalBits;

    // We want to create a transform that takes us from any point in the
    // device-space brush parallelogram to normalized texture coordinates.
    // We're a bit tricky here and do the divide by 2 to handle TileFlipX:

    REAL normalizedSize = (REAL)(numberOfTexels * (1 << ONEDNUMFRACTIONALBITS));

    GpRectF normalizedRect(
        0.0f, 0.0f, 
        normalizedSize / 2, 
        normalizedSize / 2
    );

    GpMatrix normalizeBrushRect;
    if (normalizeBrushRect.InferAffineMatrix(brushRect, normalizedRect) == Ok)
    {
        DeviceToNormalized = WorldToDevice;
        DeviceToNormalized.Prepend(normalizeBrushRect);
        if (DeviceToNormalized.Invert() == Ok)
        {
            // Convert the transform to fixed point units:

            M11 = GpRound(DeviceToNormalized.GetM11());
            M21 = GpRound(DeviceToNormalized.GetM21());
            Dx  = GpRoundSat(DeviceToNormalized.GetDx());

            // For every pixel that we step one to the right in device space,
            // we need to know the corresponding x-increment in texture (err,
            // I mean gradient) space.  Take a (1, 0) device vector, pop-it
            // through the device-to-normalized transform, and you get this
            // as the xIncrement result:

            XIncrement = M11;

            ULONG i;
            GpFColor128 color;
            REAL w;

            // should we perform gamma correction to gamma 2.2 
            
            BOOL doGammaConversion = brush->GetGammaCorrection();
            
            // Store our real converted color channels.
            
            GpFColor128 A, B;
            
            // Convert the end colors to premultiplied form,
            // Convert the end color components to REALs,
            // ... and pre-gamma convert to 2.2 if necessary.
            
            GammaLinearizeAndPremultiply(
                gradient->DeviceBrush.Colors[0].GetValue(),
                doGammaConversion, 
                &A
            );

            GammaLinearizeAndPremultiply(
                gradient->DeviceBrush.Colors[1].GetValue(),
                doGammaConversion, 
                &B
            );

            // Okay, now we simply have to load the texture:

            ULONGLONG *startTexelArgb = &StartTexelArgb[0];
            ULONGLONG *endTexelArgb = &EndTexelArgb[0];

            AGRB64TEXEL *startTexelAgrb = &StartTexelAgrb[0];
            AGRB64TEXEL *endTexelAgrb = &EndTexelAgrb[0];

            REAL wIncrement = 1.0f / halfNumberOfTexels;

            // Note that we're looping through ONEDREALTEXTUREWIDTH + 1
            // elements!

            for (w = 0, i = 0;
                 i <= halfNumberOfTexels;
                 w += wIncrement, i++)
            {
                // We sample the specified interpolators at our fixed
                // frequency:

                if (doPresetColor)
                {
                    interpolatePresetColors(
                        &color, w, 
                        gradient->DeviceBrush.BlendCounts[0],
                        gradient->DeviceBrush.PresetColors,
                        gradient->DeviceBrush.BlendPositions[0],
                        doGammaConversion
                    );
                }
                else
                {
                    REAL multB = w;
                    if (doAdjustValue)
                    {
                        multB = slowAdjustValue(w, 
                            gradient->DeviceBrush.BlendCounts[0],
                            gradient->DeviceBrush.Falloffs[0],
                            gradient->DeviceBrush.BlendFactors[0],
                            gradient->DeviceBrush.BlendPositions[0]);

                        // !!![andrewgo] This can produce out-of-range numbers
                    }

                    REAL multA = 1.0f - multB;

                    color.a = (A.a * multA) + (B.a * multB);
                    color.r = (A.r * multA) + (B.r * multB);
                    color.g = (A.g * multA) + (B.g * multB);
                    color.b = (A.b * multA) + (B.b * multB);
                }

                // Note that we're actually touching ONEDREALTEXTUREWIDTH + 1
                // elements in the array here!

                if(doGammaConversion)
                {
                    GpColorConverter colorConv;
                    colorConv.argb = GammaUnlinearizePremultiplied128(color);
                    
                    startTexelAgrb[i].A00aa00gg = 
                        (colorConv.Channel.a << 16) | colorConv.Channel.g;
                    startTexelAgrb[i].A00rr00bb = 
                        (colorConv.Channel.r << 16) | colorConv.Channel.b;
                }
                else
                {
                    startTexelAgrb[i].A00aa00gg = 
                        (GpRound(color.a) << 16) | GpRound(color.g);
                    startTexelAgrb[i].A00rr00bb = 
                        (GpRound(color.r) << 16) | GpRound(color.b);
                }

                ASSERT((startTexelAgrb[i].A00aa00gg & 0xff00ff00) == 0);
                ASSERT((startTexelAgrb[i].A00rr00bb & 0xff00ff00) == 0);
            }

            // Replicate the interval start colors to the end colors (note
            // again that we actually reference ONEDREALTEXTUREWIDTH + 1
            // elements):

            for (i = 0; i < halfNumberOfTexels; i++)
            {
                endTexelArgb[i] = startTexelArgb[i + 1];
            }

            // Here's why we've only filled up half the texture so far.
            // If FlipX is set, we make the second half an inverted
            // copy of the first; if not, we make it a straight copy:

            if ((gradient->GetWrapMode() != WrapModeTileFlipX) &&
                (gradient->GetWrapMode() != WrapModeTileFlipXY))
            {
                memcpy(&startTexelArgb[halfNumberOfTexels],
                       &startTexelArgb[0],
                       halfNumberOfTexels * sizeof(startTexelArgb[0]));
                memcpy(&endTexelArgb[halfNumberOfTexels],
                       &endTexelArgb[0],
                       halfNumberOfTexels * sizeof(endTexelArgb[0]));
            }
            else
            {
                for (i = 0; i < halfNumberOfTexels; i++)
                {
                    startTexelArgb[halfNumberOfTexels + i] 
                        = endTexelArgb[halfNumberOfTexels - i - 1];

                    endTexelArgb[halfNumberOfTexels + i]
                        = startTexelArgb[halfNumberOfTexels - i - 1];
                }
            }

            // We're done!  We're set!

            SetValid(TRUE);
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor for MMX linear gradient.
*
* Arguments:
*
*   [IN] brush - brush
*   [IN] scan  - the scan buffer
*   [IN] context - the context
*
* Return Value:
*
*   NONE
*
* Created:
*
*   1/13/2000 andrewgo
*
\**************************************************************************/

DpOutputLinearGradientSpan_MMX::DpOutputLinearGradientSpan_MMX(
    const GpElementaryBrush *brush,
    DpScanBuffer * scan,
    DpContext* context
    ) : DpOutputLinearGradientSpan(brush, scan, context)
{
    ASSERT(OSInfo::HasMMX);

    // Here we do some additional stuff for our MMX routine, beyond
    // what the base constructor did.

#if defined(_X86_)

    UINT32 numberOfTexels = IntervalMask + 1;
    ULONGLONG *startTexelArgb = &StartTexelArgb[0];
    ULONGLONG *endTexelArgb = &EndTexelArgb[0];
    static ULONGLONG OneHalf8dot8 = 0x0080008000800080;

    // The C constructor creates the colors in AGRB order, but we
    // want them in ARGB order, so swap R and G for every pixel:

    USHORT *p = reinterpret_cast<USHORT*>(startTexelArgb);
    for (UINT i = 0; i < numberOfTexels; i++, p += 4)
    {
        USHORT tmp = *(p + 1);
        *(p + 1) = *(p + 2);
        *(p + 2) = tmp;
    }

    p = reinterpret_cast<USHORT*>(endTexelArgb);
    for (UINT i = 0; i < numberOfTexels; i++, p += 4)
    {
        USHORT tmp = *(p + 1);
        *(p + 1) = *(p + 2);
        *(p + 2) = tmp;
    }

    // Make some more adjustments for our MMX routine:
    //
    //     EndTexelArgb[i] -= StartTexelArgb[i]
    //     StartTexelArgb[i] = 256 * StartTexelArgb[i] + OneHalf

    _asm
    {
        mov     ecx, numberOfTexels
        mov     esi, startTexelArgb
        mov     edi, endTexelArgb

    MoreTexels:
        movq    mm0, [esi]
        movq    mm1, [edi]
        psubw   mm1, mm0
        psllw   mm0, 8
        paddw   mm0, OneHalf8dot8
        movq    [esi], mm0
        movq    [edi], mm1
        add     esi, 8
        add     edi, 8
        dec     ecx
        jnz     MoreTexels

        emms
    }

#endif
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster with a gradient brush.
*   Uses linear interpolation from a small one dimensional texture
*   that effectively creates a piecewise-linear approximation to
*   the blend curve.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   1/13/2000 andrewgo
*
\**************************************************************************/

GpStatus
DpOutputLinearGradientSpan::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    ASSERT((BrushType == BrushTypeLinearGradient) /*|| (BrushType == BrushRectGrad)*/);
    ASSERT(xMax > xMin);

    // Copy some class stuff to local variables for faster access in
    // our inner loop:

    INT32 xIncrement = XIncrement;
    AGRB64TEXEL *startTexels = &StartTexelAgrb[0];
    AGRB64TEXEL *endTexels = &EndTexelAgrb[0];
    UINT32 count = xMax - xMin;
    ARGB *buffer = Scan->NextBuffer(xMin, y, count);
    UINT32 intervalMask = IntervalMask;

    // Given our start point in device space, figure out the corresponding 
    // texture pixel.  Note that this is expressed as a fixed-point number 
    // with FRACTIONBITS bits of fractional precision:

    INT32 xTexture = (xMin * M11) + (y * M21) + Dx;

    do {
        // We want to linearly interpolate between two pixels,
        // A and B (where A is the floor pixel, B the ceiling pixel).
        // 'multA' is the fraction of pixel A that we want, and
        // 'multB' is the fraction of pixel B that we want:

        UINT32 multB = ONEDGETFRACTIONAL8BITS(xTexture);   
        UINT32 multA = 256 - multB;

        // We could actually do a big lookup table right off of 'xTexture'
        // for however many bits of precision we wanted to do.  But that
        // would be too much work in the setup.

        UINT32 iTexture = ONEDGETINTEGERBITS(xTexture) & intervalMask;

        AGRB64TEXEL *startTexel = &startTexels[iTexture];
        AGRB64TEXEL *endTexel = &endTexels[iTexture];

        // Note that we can gamma correct the texels so that we don't
        // have to do gamma correction here.  The addition of constants
        // here are to accomplish rounding:

        UINT32 rrrrbbbb = (startTexel->A00rr00bb * multA) 
                        + (endTexel->A00rr00bb * multB)
                        + 0x00800080;

        UINT32 aaaagggg = (startTexel->A00aa00gg * multA)
                        + (endTexel->A00aa00gg * multB)
                        + 0x00800080;

        *buffer = (aaaagggg & 0xff00ff00) + ((rrrrbbbb & 0xff00ff00) >> 8);

        buffer++;
        xTexture += xIncrement;

    } while (--count != 0);

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster with a gradient brush.
*
* Created:
*
*   03/16/2000 andrewgo
*
\**************************************************************************/

GpStatus
DpOutputLinearGradientSpan_MMX::OutputSpan(
    INT y,
    INT xMin,
    INT xMax   // xMax is exclusive
    )
{
    ASSERT((BrushType == BrushTypeLinearGradient) /*|| (BrushType == BrushRectGrad)*/);

#if defined(_X86_)

    ASSERT(xMax > xMin);

    // Copy some class stuff to local variables for faster access in
    // our inner loop:

    INT32 xIncrement = XIncrement;
    AGRB64TEXEL *startTexels = &StartTexelAgrb[0];
    AGRB64TEXEL *endTexels = &EndTexelAgrb[0];
    UINT32 count = xMax - xMin;
    ARGB *buffer = Scan->NextBuffer(xMin, y, count);

    // Given our start point in device space, figure out the corresponding 
    // texture pixel.  Note that this is expressed as a fixed-point number 
    // with FRACTIONBITS bits of fractional precision:

    INT32 xTexture = (xMin * M11) + (y * M21) + Dx;

    // Scale up the interval count to the MSB so that we don't have to do
    // a mask in the inner loop, which assumes 16.16 for the fixed point
    // representation.

    UINT32 downshiftAmount = 32 - NumberOfIntervalBits;
    UINT32 upshiftAmount = 16 - NumberOfIntervalBits;
    UINT32 intervalCounter = xTexture << upshiftAmount;
    UINT32 intervalIncrement = xIncrement << upshiftAmount;

    // Prepare for the three stages:
    // stage1: QWORD align the destination
    // stage2: process 2 pixels at a time
    // stage3: process the last pixel if present

    UINT32 stage1_count = 0, stage2_count = 0, stage3_count = 0;
    if (count > 0)
    {
        // If destination is not QWORD aligned, process the first pixel
        // in stage 1.

        if (((UINT_PTR) buffer) & 0x4)
        {
            stage1_count = 1;
            count--;
        }

        stage2_count = count >> 1;
        stage3_count = count - 2 * stage2_count;

        _asm 
        {
            // eax = pointer to interval-start array
            // ebx = pointer to interval-end array
            // ecx = shift count
            // edx = scratch
            // esi = count
            // edi = destination
            // mm0 = interval counter
            // mm1 = interval incrementer
            // mm2 = fractional counter
            // mm3 = fractional incrementer
            // mm4 = temp
            // mm5 = temp

            dec         stage1_count

            mov         eax, startTexels
            mov         ebx, endTexels
            mov         ecx, downshiftAmount             
            mov         esi, stage2_count
            mov         edi, buffer
            movd        mm0, intervalCounter
            movd        mm1, intervalIncrement

            movd        mm2, xTexture           // 0 | 0 | 0 | 0 || x | x | mult | lo
            movd        mm3, xIncrement
            punpcklwd   mm2, mm2                // 0 | x | 0 | x || mult | lo | mult | lo
            punpcklwd   mm3, mm3
            punpckldq   mm2, mm2                // mult | lo | mult | lo || mult | lo | mult | lo
            punpckldq   mm3, mm3

            // This preparation normally happens inside the loop:

            movq        mm4, mm2                // mult | x | mult | x || mult | x | mult | x
            movd        edx, mm0

            jnz         pre_stage2_loop         // the flags for this are set in the "dec stage1_count" above

// stage1_loop:
  
            psrlw       mm4, 8                  // 0 | mult | 0 | mult || 0 | mult | 0 | mult
            shr         edx, cl

            pmullw      mm4, [ebx + edx*8]
            paddd       mm0, mm1                // interval counter += interval increment

            add         edi, 4                  // buffer++

            paddw       mm4, [eax + edx*8]
            movd        edx, mm0                // Prepare for next iteration

            paddw       mm2, mm3                // fractional counter += fractional increment

            psrlw       mm4, 8                  // 0 | a | 0 | r || 0 | g | 0 | b        

            packuswb    mm4, mm4                // a | r | g | b || a | r | g | b

            movd        [edi - 4], mm4        
            movq        mm4, mm2                // Prepare for next iteration

pre_stage2_loop:

            cmp         esi, 0
            jz          stage3_loop             // Do we need to execute the stage2_loop?

stage2_loop:

            psrlw       mm4, 8                  // 0 | mult | 0 | mult || 0 | mult | 0 | mult
            shr         edx, cl

            paddd       mm0, mm1                // interval counter += interval increment
            pmullw      mm4, [ebx + edx*8]

            add         edi, 8                  // buffer++

            paddw       mm2, mm3                // fractional counter += fractional increment

            paddw       mm4, [eax + edx*8]
            movd        edx, mm0                // Prepare for next iteration

            shr         edx, cl

            movq        mm5, mm2                // Prepare for next iteration


            psrlw       mm5, 8                  // 0 | mult | 0 | mult || 0 | mult | 0 | mult

            psrlw       mm4, 8                  // 0 | a | 0 | r || 0 | g | 0 | b        
            paddd       mm0, mm1                // interval counter += interval increment
            pmullw      mm5, [ebx + edx*8]
            dec         esi                     // count--

            paddw       mm5, [eax + edx*8]
            movd        edx, mm0                // Prepare for next iteration

            paddw       mm2, mm3                // fractional counter += fractional increment

            psrlw       mm5, 8                  // 0 | a | 0 | r || 0 | g | 0 | b        
  
            packuswb    mm4, mm5
            
            movq        [edi - 8], mm4        
            movq        mm4, mm2                // Prepare for next iteration
            jnz         stage2_loop

 stage3_loop:

            dec         stage3_count
            jnz         skip_stage3_loop

            psrlw       mm4, 8                  // 0 | mult | 0 | mult || 0 | mult | 0 | mult
            shr         edx, cl

            pmullw      mm4, [ebx + edx*8]
            paddd       mm0, mm1                // interval counter += interval increment

            paddw       mm4, [eax + edx*8]
            movd        edx, mm0                // Prepare for next iteration

            paddw       mm2, mm3                // fractional counter += fractional increment

            psrlw       mm4, 8                  // 0 | a | 0 | r || 0 | g | 0 | b        

            packuswb    mm4, mm4                // a | r | g | b || a | r | g | b
  
            movd        [edi], mm4        

skip_stage3_loop:

            emms
        }
    }

#endif

    return(Ok);
}

DpOutputPathGradientSpan::DpOutputPathGradientSpan(
    const GpElementaryBrush *brush,
    DpScanBuffer * scan,
    DpContext* context
    ) : DpOutputGradientSpan(brush, scan, context)
{
    SetValid(FALSE);
    const GpPathGradient* pathBrush
        = static_cast<const GpPathGradient*> (brush);

    if(pathBrush->DeviceBrush.Path)
        pathBrush->Flatten(&WorldToDevice);

    Count = pathBrush->GetNumberOfPoints();
    PointF pt0, pt1, pt2;
    pathBrush->GetCenterPoint(&pt0);
    WorldToDevice.Transform(&pt0);

    GpColor c0, c1, c2;
    pathBrush->GetCenterColor(&c0);

    Triangles = (DpTriangleData**) GpMalloc(Count*sizeof(DpTriangleData*));

    BOOL isPolygonMode = TRUE;

    if(Triangles)
    {
        GpMemset(Triangles, 0, Count*sizeof(DpTriangleData*));

        INT j;
        for(INT i = 0; i < Count; i++)
        {
            if(i < Count - 1)
                j = i + 1;
            else
                j = 0;

            pathBrush->GetPoint(&pt1, i);
            pathBrush->GetPoint(&pt2, j);

            if(pt1.X != pt2.X || pt1.Y != pt2.Y)
            {
                DpTriangleData* tri = new DpTriangleData();
                pathBrush->GetSurroundColor(&c1, i);
                pathBrush->GetSurroundColor(&c2, j);

                // Transform points if they have not been flattened,
                // since OutputSpan gets span data as Device units and 
                // the BLTransform must be in the same coordinate space.
                
                if (pathBrush->FlattenPoints.GetCount() == 0)
                {
                    WorldToDevice.Transform(&pt1);
                    WorldToDevice.Transform(&pt2);
                }

                tri->SetTriangle(
                    pt0, pt1, pt2, 
                    c0, c1, c2, 
                    isPolygonMode,
                    brush->GetGammaCorrection()
                );

                // Set the blend factors.
                tri->Falloff0 = pathBrush->DeviceBrush.Falloffs[0];
                tri->Falloff1 = 1;
                tri->Falloff2 = 1;
                tri->BlendCount0 = pathBrush->DeviceBrush.BlendCounts[0];
                tri->BlendCount1 = 1;
                tri->BlendCount2 = 1;
                tri->BlendFactors0 = pathBrush->DeviceBrush.BlendFactors[0];
                tri->BlendFactors1 = NULL;
                tri->BlendFactors2 = NULL;
                tri->BlendPositions0 = pathBrush->DeviceBrush.BlendPositions[0];
                tri->BlendPositions1 = NULL;
                tri->BlendPositions2 = NULL;
                tri->PresetColors = pathBrush->DeviceBrush.PresetColors;
                tri->UsesPresetColors = pathBrush->DeviceBrush.UsesPresetColors;

                Triangles[i] = tri;
            }
            else
                Triangles[i] = NULL;
        }
        SetValid(TRUE);
    }
    else
        SetValid(FALSE);
}

DpOutputPathGradientSpan::~DpOutputPathGradientSpan(
    VOID
    )
{
    FreeData();
}

VOID
DpOutputPathGradientSpan::FreeData()
{
    if(Triangles) {
        for(INT i = 0; i < Count; i++)
        {
            DpTriangleData* tri = Triangles[i];
            delete tri;
            Triangles[i] = NULL;
        }

        GpFree(Triangles);
        Triangles = NULL;
    }

    SetValid(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster with a polygon gradient brush.
*   Is called by the rasterizer.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   03/24/1999 ikkof
*
\**************************************************************************/

GpStatus
DpOutputPathGradientSpan::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    if(!IsValid())
        return Ok;

    INT     xxMin = xMax, xxMax = xMin;
    INT     iFirst = 0x7FFFFFFF, iLast = 0;

    for(INT i = 0; i < Count; i++)
    {
        DpTriangleData* triangle = Triangles[i];
        REAL   xx[2];
        
        if(triangle &&
           triangle->SetXSpan((REAL) y, (REAL) xMin, (REAL) xMax, xx))
        {
            xxMin = min(xxMin, GpFloor(xx[0]));
            xxMax = max(xxMax, GpRound(xx[1]));
            iFirst = min(iFirst, i);
            iLast = i;
        }
    }

    // Don't attempt to fill outside the specified x bounds
    xxMin = max(xxMin, xMin);
    xxMax = min(xxMax, xMax);

    INT  width = xxMax - xxMin;  // Right exclusive when filling
    
    // No triangles intersect this scan line, so exit
    if (width <= 0)
        return Ok;

    ARGB *  buffer = Scan->NextBuffer(xxMin, y, width);
    GpMemset(buffer, 0, width*sizeof(ARGB));

    for(INT i = iFirst; i <= iLast; i++)
    {
        DpTriangleData* triangle = Triangles[i];
        if(triangle)
            triangle->OutputSpan(buffer, CompositingMode,
                y, xxMin, xxMax);
    }

    return Ok;
}

DpOutputOneDPathGradientSpan::DpOutputOneDPathGradientSpan(
    const GpElementaryBrush *brush,
    DpScanBuffer * scan,
    DpContext* context,
    BOOL isHorizontal,
    BOOL isVertical
    ) : DpOutputOneDGradientSpan(
            brush,
            scan,
            context,
            isHorizontal,
            isVertical)
{
    if(!IsValid())
        return;

    SetupPathGradientOneDData(brush->GetGammaCorrection());

    const GpPathGradient* pathBrush
        = static_cast<const GpPathGradient*> (brush);

    if(pathBrush->DeviceBrush.Path)
        pathBrush->Flatten(&WorldToDevice);

    Count = pathBrush->GetNumberOfPoints();
    PointF pt0, pt1, pt2;
    pathBrush->GetCenterPoint(&pt0);
    WorldToDevice.Transform(&pt0);
    
    // Round center point to nearest 1/16 of a pixel, since
    // this is the rasterizer resolution.  This eliminates
    // precision errors that can affect bilinear transforms.
    pt0.X = FIX4TOREAL(GpRealToFix4(pt0.X));
    pt0.Y = FIX4TOREAL(GpRealToFix4(pt0.Y));
    
    REAL xScale = pathBrush->DeviceBrush.FocusScaleX;
    REAL yScale = pathBrush->DeviceBrush.FocusScaleY;

    REAL inflation;
    pathBrush->GetInflationFactor(&inflation);

    // If we have falloff values, then there are twice the number of
    // transforms.  If we are inflating the gradient outwards, then
    // there are additional transforms also.
    INT  infCount;
    INT  blCount = Count;
    if (xScale != 0 || yScale != 0)
    {
        Count *= 2;
        infCount = Count;
    }
    else
    {
        infCount = blCount;
    }
    
    if (inflation > 1.0f)
    {
        Count += blCount;
    }

    BLTransforms = new GpBilinearTransform[Count];

    GpPointF points[4];
    GpRectF rect(0, 0, 1, 1);

    if(BLTransforms)
    {
        INT j;
        for(INT i = 0; i < blCount; i++)
        {
            if(i < blCount - 1)
                j = i + 1;
            else
                j = 0;

            pathBrush->GetPoint(&pt1, i);
            pathBrush->GetPoint(&pt2, j);

            if(pt1.X != pt2.X || pt1.Y != pt2.Y)
            {
                // Transform points if they have not been flattened,
                // since OutputSpan gets span data as Device units and 
                // the BLTransform must be in the same coordinate space.
                if (pathBrush->FlattenPoints.GetCount() == 0)
                {
                    WorldToDevice.Transform(&pt1);
                    WorldToDevice.Transform(&pt2);
                }

                // Round points to nearest 1/16 of a pixel, since
                // this is the rasterizer resolution.  This eliminates
                // precision errors that can affect bilinear transforms.
                pt1.X = FIX4TOREAL(GpRealToFix4(pt1.X));
                pt1.Y = FIX4TOREAL(GpRealToFix4(pt1.Y));
                pt2.X = FIX4TOREAL(GpRealToFix4(pt2.X));
                pt2.Y = FIX4TOREAL(GpRealToFix4(pt2.Y));
    
                points[1] = pt1;
                points[3] = pt2;

                if (inflation > 1.0f)
                {
                    // Create a quadralateral extension of the gradient away 
                    // from the outer edge, and set the fixed value to 1.0, so
                    // this entire quadralateral will be filled with the edge
                    // color.  This is useful in some printing cases.
                    points[0].X = pt0.X + inflation*(pt1.X - pt0.X);
                    points[0].Y = pt0.Y + inflation*(pt1.Y - pt0.Y);
                    points[2].X = pt0.X + inflation*(pt2.X - pt0.X);
                    points[2].Y = pt0.Y + inflation*(pt2.Y - pt0.Y);

                    GpPointF centerPoints[4];
                    GpRectF centerRect(0, 0, 1, 1);

                    centerPoints[0] = points[0];
                    centerPoints[1] = pt1;
                    centerPoints[2] = points[2];
                    centerPoints[3] = pt2;
                    
                    BLTransforms[infCount+i].SetBilinearTransform(centerRect, &centerPoints[0], 4, 1.0f);
                }

                if(xScale == 0 && yScale == 0)
                {
                    points[0] = pt0;
                    points[2] = pt0;
                }
                else
                {
                    // Set up an outer quadralateral for the gradient, plus an
                    // inner triangle for the single center gradient color.
                    points[0].X = pt0.X + xScale*(pt1.X - pt0.X);
                    points[0].Y = pt0.Y + yScale*(pt1.Y - pt0.Y);
                    points[2].X = pt0.X + xScale*(pt2.X - pt0.X);
                    points[2].Y = pt0.Y + yScale*(pt2.Y - pt0.Y);

                    GpPointF centerPoints[4];
                    GpRectF centerRect(0, 0, 1, 1);

                    centerPoints[0] = pt0;
                    centerPoints[1] = points[0];
                    centerPoints[2] = pt0;
                    centerPoints[3] = points[2];
                    // Set the fixed value to use for the inner triangular 
                    // to 0, so that the inner gradient color will be used to
                    // fill this region.
                    BLTransforms[blCount+i].SetBilinearTransform(centerRect, &centerPoints[0], 4, 0.0f);
                }

                BLTransforms[i].SetBilinearTransform(rect, &points[0], 4);
            }
        }
        SetValid(TRUE);
    }
    else
        SetValid(FALSE);
}

VOID
DpOutputOneDPathGradientSpan::SetupPathGradientOneDData(
    BOOL gammaCorrect
)
{
    REAL u, u0, du;

    u0 = 0;
    du = 1.0f/OneDDataMultiplier;
    ARGB* buffer = OneDData;

    ASSERT(buffer);
    if(!buffer)
        return;

    const GpPathGradient* pathBrush
        = static_cast<const GpPathGradient*> (Brush);

    GpColor c0, c1;
    pathBrush->GetCenterColor(&c0);
    pathBrush->GetSurroundColor(&c1, 0);
    
    GpFColor128 color[2];
    
    GammaLinearizeAndPremultiply(
        c0.GetValue(),
        gammaCorrect, 
        &color[0]
    );
    
    GammaLinearizeAndPremultiply(
        c1.GetValue(),
        gammaCorrect, 
        &color[1]
    );

    for(INT i = 0; i < OneDDataCount; i++, buffer++)
    {       
        u = u0;
        REAL w = u;

        GpFColor128 colorOut;

        if(!(pathBrush->HasPresetColors() &&
            pathBrush->DeviceBrush.PresetColors &&
            pathBrush->DeviceBrush.BlendPositions[0] &&
            pathBrush->DeviceBrush.BlendCounts[0] > 1))
        {
            w = ::adjustValue(
                w,
                pathBrush->DeviceBrush.BlendCounts[0],
                pathBrush->DeviceBrush.Falloffs[0],
                pathBrush->DeviceBrush.BlendFactors[0],
                pathBrush->DeviceBrush.BlendPositions[0]
            );

            colorOut.a = color[0].a + w*(color[1].a - color[0].a);
            colorOut.r = color[0].r + w*(color[1].r - color[0].r);
            colorOut.g = color[0].g + w*(color[1].g - color[0].g);
            colorOut.b = color[0].b + w*(color[1].b - color[0].b);
        }
        else
        {
            interpolatePresetColors(
                &colorOut,
                w,
                pathBrush->DeviceBrush.BlendCounts[0],
                pathBrush->DeviceBrush.PresetColors,
                pathBrush->DeviceBrush.BlendPositions[0],
                gammaCorrect
            );
        }
        
        if( (REALABS(colorOut.a) >= REAL_EPSILON) || 
            (CompositingMode == CompositingModeSourceCopy) )
        {
            GpColorConverter colorConv;

            // Make sure the colorOut is properly premultiplied.
            
            CLAMP_COLOR_CHANNEL(colorOut.a, 255.0f)
            CLAMP_COLOR_CHANNEL(colorOut.r, colorOut.a);
            CLAMP_COLOR_CHANNEL(colorOut.g, colorOut.a);
            CLAMP_COLOR_CHANNEL(colorOut.b, colorOut.a);
            
            if(gammaCorrect)
            {
                colorConv.argb = GammaUnlinearizePremultiplied128(colorOut);
            }
            else
            {
                colorConv.Channel.a = static_cast<BYTE>(GpRound(colorOut.a));
                colorConv.Channel.r = static_cast<BYTE>(GpRound(colorOut.r));
                colorConv.Channel.g = static_cast<BYTE>(GpRound(colorOut.g));
                colorConv.Channel.b = static_cast<BYTE>(GpRound(colorOut.b));
            }
            
            // Clamp to the alpha channel for the premultiplied alpha blender.
            
            *buffer = colorConv.argb;
        }
        else
        {
            *buffer = 0;    // case of CompositingModeSourceOver && alpha = 0
        }

        u0 += du;
    }
}

GpStatus
DpOutputOneDPathGradientSpan::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    FPUStateSaver::AssertMode();
    
    if(!IsValid())
    {
        return Ok;
    }

    INT     width  = xMax - xMin;
    ARGB *  buffer = Scan->NextBuffer(xMin, y, width);

    GpMemset(buffer, 0, width*sizeof(ARGB));

    REAL* u = (REAL*) GpMalloc(2*width*sizeof(REAL));
    REAL* v = u + width;

    if(u == NULL)
    {
        GpFree(u);

        return OutOfMemory;
    }

    for(INT i = 0; i < Count; i++)
    {
        INT pairCount;
        INT xSpans[4];

        pairCount = BLTransforms[i].GetSourceParameterArrays(
                    u, v, &xSpans[0], y, xMin, xMax);
        if(pairCount > 0)
        {
            REAL* u1 = u;

            for(INT k = 0; k < pairCount; k++)
            {
                ARGB* buffer1 = buffer + xSpans[2*k] - xMin;
                INT width = xSpans[2*k + 1] - xSpans[2*k];                
                for(INT j = 0; j < width; j++)
                {
                    REAL u2 = *u1;
                    if(u2 < 0)
                        u2 = 0;
                    *buffer1++ = OneDData[GpRound(OneDDataMultiplier*u2)];
                    u1++;
                }
                u1 = u + width;
            }
        }
    }

    GpFree(u);

    return Ok;
}

#undef CLAMP_COLOR_CHANNEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\drawimage.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   drawimage.cpp
*
* Abstract:
*
*   Software Rasterizer DrawImage routine and supporting functionality.
*
* Revision History:
*
*    10/20/1999 asecchia
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

// Include the template class definitions for the stretch
// filter modes.

#include "stretch.inc"

namespace DpDriverActiveEdge {

    // We make an array of these for use in the dda computation.

    struct PointFIX4
    {
        FIX4 X;
        FIX4 Y;
    };

    // Vertex iterator.
    // Has two Proxy methods for accessing the dda

    class DdaIterator
    {
        private:
        GpYDda dda;
        PointFIX4 *vertices;
        INT numVertices;
        INT direction;
        INT idx;          // keep this so we don't infinite loop on
                          // degenerate case
        INT idx1, idx2;
        BOOL valid;

        public:

        // GpYDda Proxy-like semantics

        INT GetX()
        {
            return dda.GetX();
        }

        // Initialize the dda and traversal direction

        DdaIterator(PointFIX4 *v, INT n, INT d, INT idx)
        {
            vertices=v;
            numVertices=n;
            ASSERT( (d==-1)||(d==1) );
            direction = d;
            ASSERT( (idx>=0)&&(idx<n) );
            this->idx=idx;
            idx1=idx;
            idx2=idx;
            valid = AdvanceEdge();
        }

        BOOL IsValid() { return valid; }

        // Advance to the next edge and initialize the dda.
        // Return FALSE if we're done.

        BOOL Next(INT y)
        {
            if(dda.DoneWithVector(y))
            {
                return AdvanceEdge();
            }

            // TRUE indicates more to do.

            return TRUE;
        }

        private:

        // Advance the internal state to the next edge.
        // Ignore horizontal edges.
        // Return FALSE if we're done.

        BOOL AdvanceEdge()
        {
            do {
                idx2 = idx1;
                if(direction==1)
                {
                    idx1++;
                    if(idx1>=numVertices) { idx1 = 0; }
                }
                else
                {
                    idx1--;
                    if(idx1<0) { idx1 = numVertices-1; }
                }

            // Loop till we get a non-horizontal edge.
            // Make sure we don't have an infinite loop on all horizontal edges.
            // The Ceiling is used to make almost horizontal lines appear to be
            // horizontal - this allows the algorithm to correctly compute the
            // end terminating case.

            } while(( GpFix4Ceiling(vertices[idx1].Y) ==
                      GpFix4Ceiling(vertices[idx2].Y) ) &&
                    (idx1!=idx));

            if(GpFix4Ceiling(vertices[idx1].Y) >
               GpFix4Ceiling(vertices[idx2].Y) )
            {
                // Initialize the dda

                dda.Init(
                    vertices[idx2].X,
                    vertices[idx2].Y,
                    vertices[idx1].X,
                    vertices[idx1].Y
                );
                return TRUE;
            }

            // terminate if we've wrapped around and started to come back up.
            // I.e return FALSE if we should stop.

            return FALSE;
        }

    };

} // End namespace DpDriverActiveEdge


/**************************************************************************\
*
* Function Description:
*
*   This handles axis aligned drawing. The cases include identity,
*   integer translation, general translation and scaling.
*
* Arguments:
*
*   output - span class to output the scanlines to.
*   dstTL  - top left destination point.
*   dstBR  - bottom right destination point.
*
* History:
*   10/19/1999 asecchia   created it.
*
\**************************************************************************/

VOID StretchBitsMainLoop(
    DpOutputSpan *output,
    GpPoint *dstTL,
    GpPoint *dstBR
    )
{
    // Input coordinates must be correctly ordered. This assumtion is required
    // by the output span routines which must have the spans come in strictly
    // increasing y order.

    ASSERT(dstTL->X < dstBR->X);
    ASSERT(dstTL->Y < dstBR->Y);

    // Main loop - output each scanline.

    const INT left = dstTL->X;
    const INT right = dstBR->X;

    for(INT y=dstTL->Y; y<(dstBR->Y); y++)
    {
        output->OutputSpan(y, left, right);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   CreateBilinearOutputSpan
*   Creates a bilinear or identity outputspan based on our hierarchy
*   of span classes.
*
* Arguments:
*
*   bitmap           - driver surface
*   scan             - scan class
*   xForm            - source rect to destination parallelogram transform
*   imageAttributes  - encapsulates the wrap mode settings.
*
* Return Value:
*
*   DpOutputSpan     - returns the created output span (NULL for failure)
*
* History:
*
*   09/03/2000 asecchia
*   borrowed this from the brush code.
*
\**************************************************************************/

DpOutputSpan*
CreateBilinearOutputSpan(
    IN DpBitmap *bitmap,
    IN DpScanBuffer *scan,
    IN GpMatrix *xForm,      // source rectangle to destination coordinates in
                             // device space.
    IN DpContext *context,
    IN DpImageAttributes *imageAttributes,
    IN bool fLargeImage      // need to handle really large stretches.
                             // usually used for stretch algorithms that punted
                             // due to overflow in internal computation.
    )
{
    // Validate input parameters.

    ASSERT(bitmap);
    ASSERT(scan);
    ASSERT(xForm);
    ASSERT(context);
    ASSERT(imageAttributes);

    DpOutputBilinearSpan *textureSpan;
    GpMatrix brushTransform;
    GpMatrix worldToDevice;

    // Go through our heirarchy of scan drawers:

    if ((!fLargeImage) &&
        xForm->IsIntegerTranslate() &&
        ((imageAttributes->wrapMode == WrapModeTile) ||
         (imageAttributes->wrapMode == WrapModeClamp)))
    {
        textureSpan = new DpOutputBilinearSpan_Identity(
            bitmap,
            scan,
            xForm,
            context,
            imageAttributes
        );
    }
    else if ((!fLargeImage) &&
             OSInfo::HasMMX &&
             GpValidFixed16(bitmap->Width) &&
             GpValidFixed16(bitmap->Height))
    {
        textureSpan = new DpOutputBilinearSpan_MMX(
            bitmap,
            scan,
            xForm,
            context,
            imageAttributes
        );
    }
    else
    {
        textureSpan = new DpOutputBilinearSpan(
            bitmap,
            scan,
            xForm,
            context,
            imageAttributes
        );
    }

    if ((textureSpan) && !textureSpan->IsValid())
    {
        delete textureSpan;
        textureSpan = NULL;
    }

    return textureSpan;
}

/**************************************************************************\
*
* Function Description:
*
*   CreateOutputSpan
*   Creates an outputspan based on our hierarchy of span classes.
*
* Arguments:
*
*   bitmap           - driver surface
*   scan             - scan class
*   xForm            - source rect to destination parallelogram transform
*   imageAttributes  - encapsulates the wrap mode settings.
*   filterMode       - which InterpolationMode setting to use
*
* Notes:
*
*   The long term plan is to make this and the similar routines in the
*   texture brush code converge. We'd like one routine doing this for
*   all the texture output spans and have both the texture brush and the
*   drawimage reuse the same code and support all the same filter/wrap
*   modes.
*
* Return Value:
*
*   DpOutputSpan     - returns the created output span (NULL for failure)
*
* History:
*
*   09/03/2000 asecchia   created it
*
\**************************************************************************/

DpOutputSpan *CreateOutputSpan(
    IN DpBitmap *bitmap,
    IN DpScanBuffer *scan,
    IN GpMatrix *xForm,      // source rectangle to destination coordinates in
                             // device space.
    IN DpImageAttributes *imageAttributes,
    IN InterpolationMode filterMode,

    // !!! [asecchia] shouldn't need any of this following stuff - the above
    // bitmap and xForm should be sufficient.
    // The possible exception is the srcRect which may be required if we
    // ever implement the clamp-to-srcRect feature.

    IN DpContext *context,
    IN const GpRectF *srcRect,
    IN const GpRectF *dstRect,
    IN const GpPointF *dstPoints,
    IN const INT numPoints
)
{
    // Validate input parameters.

    ASSERT(bitmap);
    ASSERT(scan);
    ASSERT(xForm);
    ASSERT(imageAttributes);

    // Validate the stuff we had to pass through for the
    // OutputSpan routines that can't handle the xForm.

    ASSERT(context);
    ASSERT(srcRect);
    ASSERT(dstRect);
    ASSERT(dstPoints);
    ASSERT(numPoints == 3);

    bool fPunted = false; 
    
    // Initialize up front so that all the error-out paths are covered.

    DpOutputSpan *output = NULL;

    // Copy to local so that we can modify it without breaking the
    // input parameter consistency.

    InterpolationMode theFilterMode = filterMode;

    // The so-called 'identity' transform which counter-intuitively includes
    // integer only translation.

    if(xForm->IsIntegerTranslate())
    {
        // Use a much simplified output span class for
        // special case CopyBits.
        // The big win is due to the fact that integer
        // translation only cases do not require filtering.

        // Note, we set InterpolationModeBilinear because we
        // will detect the identity in the bilinear span creation.

        theFilterMode = InterpolationModeBilinear;
    }

    switch(theFilterMode)
    {

        // Nearest neighbor filtering. Used mainly for printing scenarios.
        // Aliases badly - only really looks good on high-dpi output devices,
        // however it's the fastest reconstruction filter.

        case InterpolationModeNearestNeighbor:
            output = new DpOutputNearestNeighborSpan(
                bitmap,
                scan,
                context,
                *imageAttributes,
                numPoints,
                dstPoints,
                srcRect
            );
        break;

        // High quality bicubic filter convolution.

        case InterpolationModeHighQuality:
        case InterpolationModeHighQualityBicubic:

        // !!! [asecchia] the high quality bicubic filter code doesn't
        // know how to do rotation yet.

        if(xForm->IsTranslateScale())
        {

            output = new DpOutputSpanStretch<HighQualityBicubic>(
                bitmap,
                scan,
                context,
                *imageAttributes,
                dstRect,
                srcRect
            );

            if(output && !output->IsValid())
            {
                // Failed to create the output span, try fall through to the 
                // regular bilinear output code.
                
                delete output;
                output = NULL;
                fPunted = true;
                goto FallbackCreation;
            }
            
            break;
        }

        // else fall through to the regular bicubic code.

        // Bicubic filter kernel.

        case InterpolationModeBicubic:
            output = new DpOutputBicubicImageSpan(
                bitmap,
                scan,
                context,
                *imageAttributes,
                numPoints,
                dstPoints,
                srcRect
            );
        break;

        // High quality bilinear (tent) convolution filter

        case InterpolationModeHighQualityBilinear:

        // !!! [asecchia] the high quality bilinear filter code doesn't
        // know how to do rotation yet.

        if(xForm->IsTranslateScale())
        {
            output = new DpOutputSpanStretch<HighQualityBilinear>(
                bitmap,
                scan,
                context,
                *imageAttributes,
                dstRect,
                srcRect
            );

            if(output && !output->IsValid())
            {
                // Failed to create the output span, try fall through to the 
                // regular bilinear output code.
                
                delete output;
                output = NULL;
                fPunted = true;
                goto FallbackCreation;
            }
            
            break;
        }

        // else fall through to the regular bilinear code.

        // Bilinear filter kernel - default case.

        case InterpolationModeDefault:
        case InterpolationModeLowQuality:
        case InterpolationModeBilinear:
        default:

            FallbackCreation:
            
            // Create a bilinear span or an identity span.

            output = CreateBilinearOutputSpan(
                bitmap,
                scan,
                xForm,
                context,
                imageAttributes,
                fPunted          // somebody failed and this is the fallback.
            );
    }

    // Check to see that the constructor for the output span class succeeded.

    if(output && !output->IsValid())
    {
       delete output;
       output = NULL;
    }

    // This will be NULL on an error path.

    return output;
}


/**************************************************************************\
*
* Function Description:
*
*   Draws an image.
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] srcSurface - the source surface
*   [IN] dstSurface - the image to fill
*   [IN] drawBounds - the surface bounds
*   [IN] mapMode    - the mapping mode of the image
*   [IN] numPoints  - the number of points in dstPoints array (<= 4)
*   [IN] dstPoints  - the array of points for affine or quad transform.
*   [IN] srcRect    - the bounds of the src image.  If this is NULL,
*                     the whole image is used.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* History:
*
*   01/09/1999 ikkof      Created it.
*   10/19/1999 asecchia   rewrite to support rotation.
*
\**************************************************************************/

GpStatus
DpDriver::DrawImage(
    DpContext *          context,
    DpBitmap *           srcSurface,
    DpBitmap *           dstSurface,
    const GpRect *       drawBounds,
    const DpImageAttributes * imgAttributes,
    INT                  numPoints,
    const GpPointF *     dstPoints,
    const GpRectF *      srcRect,
    DriverDrawImageFlags flags
    )
{
    // Get the infrastructure to do active edge table stuff.

    using namespace DpDriverActiveEdge;

    // !!! [asecchia] Why do we have this if we don't use it?

    GpStatus status = Ok;

    // The caller is responsible for padding out the dstPoints structure so
    // that it has at least 3 valid points.

    ASSERT((numPoints==3)||(numPoints==4));

    // We need to do some reordering of points for warping (numPoints==4)
    // to work. For now we require numPoints == 3.

    ASSERT(numPoints==3);

    // Make a local copy so we don't end up modifying our callers' data.

    GpPointF fDst[4];
    GpMemcpy(fDst, dstPoints, sizeof(GpPointF)*numPoints);

    // Need to infer the transform for banding code.

    // !!! PERF: [asecchia] This transform actually gets computed by the Engine
    // before calling the Driver. We should have a way of passing it down
    // so that we don't have to recompute it.

    GpMatrix xForm;
    xForm.InferAffineMatrix(fDst, *srcRect);
    xForm.Append(context->WorldToDevice);
    
    // This is the source rectangle band.

    GpPointF fDst2[4];

    // If we are in HalfPixelMode Offset, we want to be able to read half
    // a pixel to the left of the image, to be able to center the drawing

    fDst2[0].X = srcRect->X;
    fDst2[0].Y = srcRect->Y;
    fDst2[1].X = srcRect->X+srcRect->Width;
    fDst2[1].Y = srcRect->Y;
    fDst2[2].X = srcRect->X;
    fDst2[2].Y = srcRect->Y+srcRect->Height;

    // Transform the points to the destination.

    xForm.Transform(fDst2, 3);

    if(numPoints==3)
    {
        // Force the four point destination format

        fDst[0].X = fDst2[0].X;
        fDst[0].Y = fDst2[0].Y;
        fDst[1].X = fDst2[2].X;
        fDst[1].Y = fDst2[2].Y;
        fDst[2].X = fDst2[1].X+fDst2[2].X-fDst2[0].X;
        fDst[2].Y = fDst2[1].Y+fDst2[2].Y-fDst2[0].Y;
        fDst[3].X = fDst2[1].X;
        fDst[3].Y = fDst2[1].Y;

    } else if (numPoints==4) {

        // !!! [asecchia] This code branch doesn't work yet.
        // The transforms required for correct banding need to be worked out
        // for the warp transform case.
        // This is a V2 feature.

        ASSERT(FALSE);
    }

    // Convert the transformed rectangle to fix point notation.

    PointFIX4 fix4Dst[4];
    fix4Dst[0].X = GpRealToFix4(fDst[0].X);
    fix4Dst[0].Y = GpRealToFix4(fDst[0].Y);
    fix4Dst[1].X = GpRealToFix4(fDst[1].X);
    fix4Dst[1].Y = GpRealToFix4(fDst[1].Y);
    fix4Dst[2].X = GpRealToFix4(fDst[2].X);
    fix4Dst[2].Y = GpRealToFix4(fDst[2].Y);
    fix4Dst[3].X = GpRealToFix4(fDst[3].X);
    fix4Dst[3].Y = GpRealToFix4(fDst[3].Y);

    // !!! [agodfrey] Perf: May want to add the noTransparentPixels parameter.
    // I guess we'd have to check that the coordinates are integer (after
    // translation and scaling), that there's no rotation, and that
    // the image contains no transparent pixels.

    DpScanBuffer scan(
        dstSurface->Scan,
        this,
        context,
        dstSurface
    );

    if(!scan.IsValid())
    {
        return(GenericError);
    }

    // Only valid if xForm->IsTranslateScale()

    GpRectF dstRect(
        fDst[0].X,
        fDst[0].Y,
        fDst[2].X-fDst[0].X,
        fDst[2].Y-fDst[0].Y
    );

    DpOutputSpan* output = CreateOutputSpan(
        srcSurface,
        &scan,
        &xForm,
        const_cast<DpImageAttributes*>(imgAttributes),
        context->FilterType,
        context,
        srcRect,
        &dstRect,
        dstPoints,
        numPoints
    );

    // if output is NULL, we failed to allocate the memory for the
    // output span class.

    if(output == NULL)
    {
        return(OutOfMemory);
    }

    // Set up the clipping.

    DpRegion::Visibility visibility = DpRegion::TotallyVisible;
    DpClipRegion *clipRegion = NULL;

    if (context->VisibleClip.GetRectVisibility(
          drawBounds->X,
          drawBounds->Y,
          drawBounds->GetRight(),
          drawBounds->GetBottom()
        ) != DpRegion::TotallyVisible
       )
    {
        clipRegion = &(context->VisibleClip);
        clipRegion->InitClipping(output, drawBounds->Y);
    }

    GpRect clippedRect;

    if(clipRegion)
    {
        visibility = clipRegion->GetRectVisibility(
            drawBounds->X,
            drawBounds->Y,
            drawBounds->GetRight(),
            drawBounds->GetBottom(),
            &clippedRect
        );
    }

    // Decide on our clipping strategy.

    DpOutputSpan *outspan;
    switch (visibility)
    {
        case DpRegion::TotallyVisible:    // no clipping is needed
            outspan = output;
        break;

        case DpRegion::ClippedVisible:    //
        case DpRegion::PartiallyVisible:  // some clipping is needed
            outspan = clipRegion;
        break;

        case DpRegion::Invisible:         // nothing on screen - quit
            goto DrawImage_Done;
    }

    if(xForm.IsTranslateScale() ||        // stretch
       xForm.IsIntegerTranslate())        // copybits
    {
        // Do the stretch/translate case

        GpPoint dstTL, dstBR;

        // Round to fixed point to eliminate the very close to integer
        // numbers that can result from transformation.
        // E.g. 300.0000000001 should become 300 after the ceiling operation
        // and not 301 (not the classical definition of ceiling).

        // Top Left corner.

        dstTL.X = GpFix4Ceiling(fix4Dst[0].X);
        dstTL.Y = GpFix4Ceiling(fix4Dst[0].Y);

        // Bottom Right corner

        dstBR.X = GpFix4Ceiling(fix4Dst[2].X);
        dstBR.Y = GpFix4Ceiling(fix4Dst[2].Y);

        // Swap coordinates if necessary.  StretchBitsMainLoop
        // assumes that TL corner is less than BR corner.

        if (dstTL.X > dstBR.X)
        {
            INT xTmp = dstTL.X;
            dstTL.X = dstBR.X;
            dstBR.X = xTmp;
        }
        if (dstTL.Y > dstBR.Y)
        {
            INT yTmp = dstTL.Y;
            dstTL.Y = dstBR.Y;
            dstBR.Y = yTmp;
        }

        // Due to the fixed point calculations used for image stretching, 
        // we are limited to how large an image can be stretched. 
        // If it is out of bounds, return an error.
        if (srcRect->Width > 32767.0f || srcRect->Height > 32767.0f)
        {
            WARNING(("Image width or height > 32767"));
            status = InvalidParameter;
            goto DrawImage_Done;
        }
    
        // This handles both the stretch and the copy case

        // Don't draw anything if there are no scanlines to draw or if
        // there are no pixels in the scanlines.

        if( (dstBR.X != dstTL.X) &&
            (dstBR.Y != dstTL.Y) )
        {
            StretchBitsMainLoop(outspan, &dstTL, &dstBR);
        }
    }
    else
    {
        // Default case - handles generic drawing including
        // rotation, shear, etc.

        INT yMinIdx = 0;    // index of the smallest y coordinate.
        INT y;              // current scanline.

        // Number of points - used for wrap computation.

        const INT points = 4;

        // search for the minimum y coordinate index.

        for(y=1;y<points;y++)
        {
            if(fix4Dst[y].Y < fix4Dst[yMinIdx].Y)
            {
                yMinIdx = y;
            }
        }
        y = GpFix4Ceiling(fix4Dst[yMinIdx].Y);

        // DDA for left and right edges.
        // ASSUMPTION: Convex polygon => two edges only.

        // Work out which edge is left and which is right.

        INT index1, index2;
        REAL det;

        index1 = yMinIdx-1;
        if(index1<0)
        {
            index1=points-1;
        }

        index2 = yMinIdx+1;
        if(index2>=points)
        {
            index2=0;
        }

        // Compute the determinant.
        // The sign of the determinant formed by the first two edges
        // will tell us if the polygon is specified clockwise
        // or anticlockwise.

        if( (fix4Dst[index1].Y==fix4Dst[yMinIdx].Y) &&
            (fix4Dst[index2].Y==fix4Dst[yMinIdx].Y) )
        {
            // Both initial edges are horizontal - compare x coordinates.
            // You get this formula by "cancelling out" the zero y terms
            // in the determinant formula below.
            // This part of the formula only works because we know that
            // yMinIdx is the index of the minimum y coordinate in the
            // polygon.

            det = (REAL)(fix4Dst[index1].X-fix4Dst[index2].X);
        }
        else
        {
            // Full determinant computation

            det = (REAL)
                  (fix4Dst[index2].Y-fix4Dst[yMinIdx].Y)*
                  (fix4Dst[index1].X-fix4Dst[yMinIdx].X)-
                  (REAL)
                  (fix4Dst[index1].Y-fix4Dst[yMinIdx].Y)*
                  (fix4Dst[index2].X-fix4Dst[yMinIdx].X);
        }

        // Even though we've discarded all the empty rectangle cases, it's 
        // still possible for really small non-zero matrix coefficients to
        // be multiplied together giving zero - due to rounding error at 
        // the precision limit of the real number representation.
        // If the det is zero (or really close) the quad has no area and
        // we succeed the call immediately.
        
        if(REALABS(det) < REAL_EPSILON)
        {
            goto DrawImage_Done;
        }

        {
            // Initialize the iterators with the direction dependent on the
            // sign of the determinant.
            // These are scoped because of the exit branches above (goto)
    
            DdaIterator left(fix4Dst, points, (det>0.0f)?1:-1, yMinIdx);
            DdaIterator right(fix4Dst, points, (det>0.0f)?-1:1, yMinIdx);
    
            // If both iterators are valid, start the loop.
    
            INT xLeft, xRight;
    
            if(left.IsValid() && right.IsValid())
            {
                do {
                    // Output the data. We know we only have one span because
                    // we're drawing a convex quad.
    
                    xLeft = left.GetX();
                    xRight = right.GetX();
    
                    // If this ever happens, we've broken a fundumental
                    // assumption of the OutputSpan code. Our x coordinates
                    // must be ordered.
    
                    ASSERT(xLeft <= xRight);
    
                    // Trivially reject any scanlines that don't have any
                    // pixels.
    
                    if(xRight>xLeft)
                    {
                        outspan->OutputSpan(y, xLeft, xRight);
                    }
    
                    // Update the y value to the new scanline
    
                    y++;
    
                    // Incrementaly update DDAs for this new scanline.
                    // End the loop if we're done with the last edge.
    
                } while(left.Next(y-1) && right.Next(y-1));
            }       // end if valid iterators
        }           // end scope
    }               // end else (rotation block)

    // We're done - clean up and return status.

    DrawImage_Done:

    output->End();

    if (clipRegion != NULL)
    {
        clipRegion->EndClipping();
    }


    delete output;
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\httables.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   HtTables.cpp
*
* Abstract:
*
*   Tables for doing halftoning, using Daniel Chou's supercell technique.
*   The tables and comments are DChou's.
*
* Created:
*
*   10/29/1999 DCurtis
*
\**************************************************************************/

#include "precomp.hpp"

GDIP_LOGPALETTE256 HTColorPalette = {
    0x300, 256,
  { { 0x00, 0x00, 0x00, 0 },                //      0   1st 8 VGA colors
    { 0x80, 0x00, 0x00, 0 },                //      1
    { 0x00, 0x80, 0x00, 0 },                //      2
    { 0x80, 0x80, 0x00, 0 },                //      3
    { 0x00, 0x00, 0x80, 0 },                //      4
    { 0x80, 0x00, 0x80, 0 },                //      5
    { 0x00, 0x80, 0x80, 0 },                //      6
    { 0xC0, 0xC0, 0xC0, 0 },                //      7

    { 0xC0, 0xDC, 0xC0, 0 },                //      8    4 configurable colors
    { 0xD4, 0xD0, 0xC8, 0 },                //      9    
    { 0xFF, 0xFB, 0xF0, 0 },                //     10
    { 0x3A, 0x6E, 0xA5, 0 },                //     11

    { 0x80, 0x80, 0x80, 0 },                //     12   Last 8 VGA colors
    { 0xFF, 0x00, 0x00, 0 },                //     13
    { 0x00, 0xFF, 0x00, 0 },                //     14
    { 0xFF, 0xFF, 0x00, 0 },                //     15
    { 0x00, 0x00, 0xFF, 0 },                //     16
    { 0xFF, 0x00, 0xFF, 0 },                //     17
    { 0x00, 0xFF, 0xFF, 0 },                //     18
    { 0xFF, 0xFF, 0xFF, 0 },                //     19

    { 0x00, 0x00, 0x00, 0 },                //     20   20 unused entries
    { 0x00, 0x00, 0x00, 0 },                //     21
    { 0x00, 0x00, 0x00, 0 },                //     22
    { 0x00, 0x00, 0x00, 0 },                //     23
    { 0x00, 0x00, 0x00, 0 },                //     24
    { 0x00, 0x00, 0x00, 0 },                //     25
    { 0x00, 0x00, 0x00, 0 },                //     26
    { 0x00, 0x00, 0x00, 0 },                //     27
    { 0x00, 0x00, 0x00, 0 },                //     28
    { 0x00, 0x00, 0x00, 0 },                //     29
    { 0x00, 0x00, 0x00, 0 },                //     30
    { 0x00, 0x00, 0x00, 0 },                //     31
    { 0x00, 0x00, 0x00, 0 },                //     32
    { 0x00, 0x00, 0x00, 0 },                //     33
    { 0x00, 0x00, 0x00, 0 },                //     34
    { 0x00, 0x00, 0x00, 0 },                //     35
    { 0x00, 0x00, 0x00, 0 },                //     36
    { 0x00, 0x00, 0x00, 0 },                //     37
    { 0x00, 0x00, 0x00, 0 },                //     38
    { 0x00, 0x00, 0x00, 0 },                //     39


    { 0x00, 0x00, 0x00, PC_NOCOLLAPSE },    //     40    6^3 palette
    { 0x00, 0x00, 0x33, PC_NOCOLLAPSE },    //     41
    { 0x00, 0x00, 0x66, PC_NOCOLLAPSE },    //     42
    { 0x00, 0x00, 0x99, PC_NOCOLLAPSE },    //     43
    { 0x00, 0x00, 0xCC, PC_NOCOLLAPSE },    //     44
    { 0x00, 0x00, 0xFF, PC_NOCOLLAPSE },    //     45
    { 0x00, 0x33, 0x00, PC_NOCOLLAPSE },    //     46
    { 0x00, 0x33, 0x33, PC_NOCOLLAPSE },    //     47
    { 0x00, 0x33, 0x66, PC_NOCOLLAPSE },    //     48
    { 0x00, 0x33, 0x99, PC_NOCOLLAPSE },    //     49
    { 0x00, 0x33, 0xCC, PC_NOCOLLAPSE },    //     50
    { 0x00, 0x33, 0xFF, PC_NOCOLLAPSE },    //     51
    { 0x00, 0x66, 0x00, PC_NOCOLLAPSE },    //     52
    { 0x00, 0x66, 0x33, PC_NOCOLLAPSE },    //     53
    { 0x00, 0x66, 0x66, PC_NOCOLLAPSE },    //     54
    { 0x00, 0x66, 0x99, PC_NOCOLLAPSE },    //     55
    { 0x00, 0x66, 0xCC, PC_NOCOLLAPSE },    //     56
    { 0x00, 0x66, 0xFF, PC_NOCOLLAPSE },    //     57
    { 0x00, 0x99, 0x00, PC_NOCOLLAPSE },    //     58
    { 0x00, 0x99, 0x33, PC_NOCOLLAPSE },    //     59
    { 0x00, 0x99, 0x66, PC_NOCOLLAPSE },    //     60
    { 0x00, 0x99, 0x99, PC_NOCOLLAPSE },    //     61
    { 0x00, 0x99, 0xCC, PC_NOCOLLAPSE },    //     62
    { 0x00, 0x99, 0xFF, PC_NOCOLLAPSE },    //     63
    { 0x00, 0xCC, 0x00, PC_NOCOLLAPSE },    //     64
    { 0x00, 0xCC, 0x33, PC_NOCOLLAPSE },    //     65
    { 0x00, 0xCC, 0x66, PC_NOCOLLAPSE },    //     66
    { 0x00, 0xCC, 0x99, PC_NOCOLLAPSE },    //     67
    { 0x00, 0xCC, 0xCC, PC_NOCOLLAPSE },    //     68
    { 0x00, 0xCC, 0xFF, PC_NOCOLLAPSE },    //     69
    { 0x00, 0xFF, 0x00, PC_NOCOLLAPSE },    //     70
    { 0x00, 0xFF, 0x33, PC_NOCOLLAPSE },    //     71
    { 0x00, 0xFF, 0x66, PC_NOCOLLAPSE },    //     72
    { 0x00, 0xFF, 0x99, PC_NOCOLLAPSE },    //     73
    { 0x00, 0xFF, 0xCC, PC_NOCOLLAPSE },    //     74
    { 0x00, 0xFF, 0xFF, PC_NOCOLLAPSE },    //     75
    { 0x33, 0x00, 0x00, PC_NOCOLLAPSE },    //     76
    { 0x33, 0x00, 0x33, PC_NOCOLLAPSE },    //     77
    { 0x33, 0x00, 0x66, PC_NOCOLLAPSE },    //     78
    { 0x33, 0x00, 0x99, PC_NOCOLLAPSE },    //     79
    { 0x33, 0x00, 0xCC, PC_NOCOLLAPSE },    //     80
    { 0x33, 0x00, 0xFF, PC_NOCOLLAPSE },    //     81
    { 0x33, 0x33, 0x00, PC_NOCOLLAPSE },    //     82
    { 0x33, 0x33, 0x33, PC_NOCOLLAPSE },    //     83
    { 0x33, 0x33, 0x66, PC_NOCOLLAPSE },    //     84
    { 0x33, 0x33, 0x99, PC_NOCOLLAPSE },    //     85
    { 0x33, 0x33, 0xCC, PC_NOCOLLAPSE },    //     86
    { 0x33, 0x33, 0xFF, PC_NOCOLLAPSE },    //     87
    { 0x33, 0x66, 0x00, PC_NOCOLLAPSE },    //     88
    { 0x33, 0x66, 0x33, PC_NOCOLLAPSE },    //     89
    { 0x33, 0x66, 0x66, PC_NOCOLLAPSE },    //     90
    { 0x33, 0x66, 0x99, PC_NOCOLLAPSE },    //     91
    { 0x33, 0x66, 0xCC, PC_NOCOLLAPSE },    //     92
    { 0x33, 0x66, 0xFF, PC_NOCOLLAPSE },    //     93
    { 0x33, 0x99, 0x00, PC_NOCOLLAPSE },    //     94
    { 0x33, 0x99, 0x33, PC_NOCOLLAPSE },    //     95
    { 0x33, 0x99, 0x66, PC_NOCOLLAPSE },    //     96
    { 0x33, 0x99, 0x99, PC_NOCOLLAPSE },    //     97
    { 0x33, 0x99, 0xCC, PC_NOCOLLAPSE },    //     98
    { 0x33, 0x99, 0xFF, PC_NOCOLLAPSE },    //     99
    { 0x33, 0xCC, 0x00, PC_NOCOLLAPSE },    //    100
    { 0x33, 0xCC, 0x33, PC_NOCOLLAPSE },    //    101
    { 0x33, 0xCC, 0x66, PC_NOCOLLAPSE },    //    102
    { 0x33, 0xCC, 0x99, PC_NOCOLLAPSE },    //    103
    { 0x33, 0xCC, 0xCC, PC_NOCOLLAPSE },    //    104
    { 0x33, 0xCC, 0xFF, PC_NOCOLLAPSE },    //    105
    { 0x33, 0xFF, 0x00, PC_NOCOLLAPSE },    //    106
    { 0x33, 0xFF, 0x33, PC_NOCOLLAPSE },    //    107
    { 0x33, 0xFF, 0x66, PC_NOCOLLAPSE },    //    108
    { 0x33, 0xFF, 0x99, PC_NOCOLLAPSE },    //    109
    { 0x33, 0xFF, 0xCC, PC_NOCOLLAPSE },    //    110
    { 0x33, 0xFF, 0xFF, PC_NOCOLLAPSE },    //    111
    { 0x66, 0x00, 0x00, PC_NOCOLLAPSE },    //    112
    { 0x66, 0x00, 0x33, PC_NOCOLLAPSE },    //    113
    { 0x66, 0x00, 0x66, PC_NOCOLLAPSE },    //    114
    { 0x66, 0x00, 0x99, PC_NOCOLLAPSE },    //    115
    { 0x66, 0x00, 0xCC, PC_NOCOLLAPSE },    //    116
    { 0x66, 0x00, 0xFF, PC_NOCOLLAPSE },    //    117
    { 0x66, 0x33, 0x00, PC_NOCOLLAPSE },    //    118
    { 0x66, 0x33, 0x33, PC_NOCOLLAPSE },    //    119
    { 0x66, 0x33, 0x66, PC_NOCOLLAPSE },    //    120
    { 0x66, 0x33, 0x99, PC_NOCOLLAPSE },    //    121
    { 0x66, 0x33, 0xCC, PC_NOCOLLAPSE },    //    122
    { 0x66, 0x33, 0xFF, PC_NOCOLLAPSE },    //    123
    { 0x66, 0x66, 0x00, PC_NOCOLLAPSE },    //    124
    { 0x66, 0x66, 0x33, PC_NOCOLLAPSE },    //    125
    { 0x66, 0x66, 0x66, PC_NOCOLLAPSE },    //    126
    { 0x66, 0x66, 0x99, PC_NOCOLLAPSE },    //    127
    { 0x66, 0x66, 0xCC, PC_NOCOLLAPSE },    //    128
    { 0x66, 0x66, 0xFF, PC_NOCOLLAPSE },    //    129
    { 0x66, 0x99, 0x00, PC_NOCOLLAPSE },    //    130
    { 0x66, 0x99, 0x33, PC_NOCOLLAPSE },    //    131
    { 0x66, 0x99, 0x66, PC_NOCOLLAPSE },    //    132
    { 0x66, 0x99, 0x99, PC_NOCOLLAPSE },    //    133
    { 0x66, 0x99, 0xCC, PC_NOCOLLAPSE },    //    134
    { 0x66, 0x99, 0xFF, PC_NOCOLLAPSE },    //    135
    { 0x66, 0xCC, 0x00, PC_NOCOLLAPSE },    //    136
    { 0x66, 0xCC, 0x33, PC_NOCOLLAPSE },    //    137
    { 0x66, 0xCC, 0x66, PC_NOCOLLAPSE },    //    138
    { 0x66, 0xCC, 0x99, PC_NOCOLLAPSE },    //    139
    { 0x66, 0xCC, 0xCC, PC_NOCOLLAPSE },    //    140
    { 0x66, 0xCC, 0xFF, PC_NOCOLLAPSE },    //    141
    { 0x66, 0xFF, 0x00, PC_NOCOLLAPSE },    //    142
    { 0x66, 0xFF, 0x33, PC_NOCOLLAPSE },    //    143
    { 0x66, 0xFF, 0x66, PC_NOCOLLAPSE },    //    144
    { 0x66, 0xFF, 0x99, PC_NOCOLLAPSE },    //    145
    { 0x66, 0xFF, 0xCC, PC_NOCOLLAPSE },    //    146
    { 0x66, 0xFF, 0xFF, PC_NOCOLLAPSE },    //    147
    { 0x99, 0x00, 0x00, PC_NOCOLLAPSE },    //    148
    { 0x99, 0x00, 0x33, PC_NOCOLLAPSE },    //    149
    { 0x99, 0x00, 0x66, PC_NOCOLLAPSE },    //    150
    { 0x99, 0x00, 0x99, PC_NOCOLLAPSE },    //    151
    { 0x99, 0x00, 0xCC, PC_NOCOLLAPSE },    //    152
    { 0x99, 0x00, 0xFF, PC_NOCOLLAPSE },    //    153
    { 0x99, 0x33, 0x00, PC_NOCOLLAPSE },    //    154
    { 0x99, 0x33, 0x33, PC_NOCOLLAPSE },    //    155
    { 0x99, 0x33, 0x66, PC_NOCOLLAPSE },    //    156
    { 0x99, 0x33, 0x99, PC_NOCOLLAPSE },    //    157
    { 0x99, 0x33, 0xCC, PC_NOCOLLAPSE },    //    158
    { 0x99, 0x33, 0xFF, PC_NOCOLLAPSE },    //    159
    { 0x99, 0x66, 0x00, PC_NOCOLLAPSE },    //    160
    { 0x99, 0x66, 0x33, PC_NOCOLLAPSE },    //    161
    { 0x99, 0x66, 0x66, PC_NOCOLLAPSE },    //    162
    { 0x99, 0x66, 0x99, PC_NOCOLLAPSE },    //    163
    { 0x99, 0x66, 0xCC, PC_NOCOLLAPSE },    //    164
    { 0x99, 0x66, 0xFF, PC_NOCOLLAPSE },    //    165
    { 0x99, 0x99, 0x00, PC_NOCOLLAPSE },    //    166
    { 0x99, 0x99, 0x33, PC_NOCOLLAPSE },    //    167
    { 0x99, 0x99, 0x66, PC_NOCOLLAPSE },    //    168
    { 0x99, 0x99, 0x99, PC_NOCOLLAPSE },    //    169
    { 0x99, 0x99, 0xCC, PC_NOCOLLAPSE },    //    170
    { 0x99, 0x99, 0xFF, PC_NOCOLLAPSE },    //    171
    { 0x99, 0xCC, 0x00, PC_NOCOLLAPSE },    //    172
    { 0x99, 0xCC, 0x33, PC_NOCOLLAPSE },    //    173
    { 0x99, 0xCC, 0x66, PC_NOCOLLAPSE },    //    174
    { 0x99, 0xCC, 0x99, PC_NOCOLLAPSE },    //    175
    { 0x99, 0xCC, 0xCC, PC_NOCOLLAPSE },    //    176
    { 0x99, 0xCC, 0xFF, PC_NOCOLLAPSE },    //    177
    { 0x99, 0xFF, 0x00, PC_NOCOLLAPSE },    //    178
    { 0x99, 0xFF, 0x33, PC_NOCOLLAPSE },    //    179
    { 0x99, 0xFF, 0x66, PC_NOCOLLAPSE },    //    180
    { 0x99, 0xFF, 0x99, PC_NOCOLLAPSE },    //    181
    { 0x99, 0xFF, 0xCC, PC_NOCOLLAPSE },    //    182
    { 0x99, 0xFF, 0xFF, PC_NOCOLLAPSE },    //    183
    { 0xCC, 0x00, 0x00, PC_NOCOLLAPSE },    //    184
    { 0xCC, 0x00, 0x33, PC_NOCOLLAPSE },    //    185
    { 0xCC, 0x00, 0x66, PC_NOCOLLAPSE },    //    186
    { 0xCC, 0x00, 0x99, PC_NOCOLLAPSE },    //    187
    { 0xCC, 0x00, 0xCC, PC_NOCOLLAPSE },    //    188
    { 0xCC, 0x00, 0xFF, PC_NOCOLLAPSE },    //    189
    { 0xCC, 0x33, 0x00, PC_NOCOLLAPSE },    //    190
    { 0xCC, 0x33, 0x33, PC_NOCOLLAPSE },    //    191
    { 0xCC, 0x33, 0x66, PC_NOCOLLAPSE },    //    192
    { 0xCC, 0x33, 0x99, PC_NOCOLLAPSE },    //    193
    { 0xCC, 0x33, 0xCC, PC_NOCOLLAPSE },    //    194
    { 0xCC, 0x33, 0xFF, PC_NOCOLLAPSE },    //    195
    { 0xCC, 0x66, 0x00, PC_NOCOLLAPSE },    //    196
    { 0xCC, 0x66, 0x33, PC_NOCOLLAPSE },    //    197
    { 0xCC, 0x66, 0x66, PC_NOCOLLAPSE },    //    198
    { 0xCC, 0x66, 0x99, PC_NOCOLLAPSE },    //    199
    { 0xCC, 0x66, 0xCC, PC_NOCOLLAPSE },    //    200
    { 0xCC, 0x66, 0xFF, PC_NOCOLLAPSE },    //    201
    { 0xCC, 0x99, 0x00, PC_NOCOLLAPSE },    //    202
    { 0xCC, 0x99, 0x33, PC_NOCOLLAPSE },    //    203
    { 0xCC, 0x99, 0x66, PC_NOCOLLAPSE },    //    204
    { 0xCC, 0x99, 0x99, PC_NOCOLLAPSE },    //    205
    { 0xCC, 0x99, 0xCC, PC_NOCOLLAPSE },    //    206
    { 0xCC, 0x99, 0xFF, PC_NOCOLLAPSE },    //    207
    { 0xCC, 0xCC, 0x00, PC_NOCOLLAPSE },    //    208
    { 0xCC, 0xCC, 0x33, PC_NOCOLLAPSE },    //    209
    { 0xCC, 0xCC, 0x66, PC_NOCOLLAPSE },    //    210
    { 0xCC, 0xCC, 0x99, PC_NOCOLLAPSE },    //    211
    { 0xCC, 0xCC, 0xCC, PC_NOCOLLAPSE },    //    212
    { 0xCC, 0xCC, 0xFF, PC_NOCOLLAPSE },    //    213
    { 0xCC, 0xFF, 0x00, PC_NOCOLLAPSE },    //    214
    { 0xCC, 0xFF, 0x33, PC_NOCOLLAPSE },    //    215
    { 0xCC, 0xFF, 0x66, PC_NOCOLLAPSE },    //    216
    { 0xCC, 0xFF, 0x99, PC_NOCOLLAPSE },    //    217
    { 0xCC, 0xFF, 0xCC, PC_NOCOLLAPSE },    //    218
    { 0xCC, 0xFF, 0xFF, PC_NOCOLLAPSE },    //    219
    { 0xFF, 0x00, 0x00, PC_NOCOLLAPSE },    //    220
    { 0xFF, 0x00, 0x33, PC_NOCOLLAPSE },    //    221
    { 0xFF, 0x00, 0x66, PC_NOCOLLAPSE },    //    222
    { 0xFF, 0x00, 0x99, PC_NOCOLLAPSE },    //    223
    { 0xFF, 0x00, 0xCC, PC_NOCOLLAPSE },    //    224
    { 0xFF, 0x00, 0xFF, PC_NOCOLLAPSE },    //    225
    { 0xFF, 0x33, 0x00, PC_NOCOLLAPSE },    //    226
    { 0xFF, 0x33, 0x33, PC_NOCOLLAPSE },    //    227
    { 0xFF, 0x33, 0x66, PC_NOCOLLAPSE },    //    228
    { 0xFF, 0x33, 0x99, PC_NOCOLLAPSE },    //    229
    { 0xFF, 0x33, 0xCC, PC_NOCOLLAPSE },    //    230
    { 0xFF, 0x33, 0xFF, PC_NOCOLLAPSE },    //    231
    { 0xFF, 0x66, 0x00, PC_NOCOLLAPSE },    //    232
    { 0xFF, 0x66, 0x33, PC_NOCOLLAPSE },    //    233
    { 0xFF, 0x66, 0x66, PC_NOCOLLAPSE },    //    234
    { 0xFF, 0x66, 0x99, PC_NOCOLLAPSE },    //    235
    { 0xFF, 0x66, 0xCC, PC_NOCOLLAPSE },    //    236
    { 0xFF, 0x66, 0xFF, PC_NOCOLLAPSE },    //    237
    { 0xFF, 0x99, 0x00, PC_NOCOLLAPSE },    //    238
    { 0xFF, 0x99, 0x33, PC_NOCOLLAPSE },    //    239
    { 0xFF, 0x99, 0x66, PC_NOCOLLAPSE },    //    240
    { 0xFF, 0x99, 0x99, PC_NOCOLLAPSE },    //    241
    { 0xFF, 0x99, 0xCC, PC_NOCOLLAPSE },    //    242
    { 0xFF, 0x99, 0xFF, PC_NOCOLLAPSE },    //    243
    { 0xFF, 0xCC, 0x00, PC_NOCOLLAPSE },    //    244
    { 0xFF, 0xCC, 0x33, PC_NOCOLLAPSE },    //    245
    { 0xFF, 0xCC, 0x66, PC_NOCOLLAPSE },    //    246
    { 0xFF, 0xCC, 0x99, PC_NOCOLLAPSE },    //    247
    { 0xFF, 0xCC, 0xCC, PC_NOCOLLAPSE },    //    248
    { 0xFF, 0xCC, 0xFF, PC_NOCOLLAPSE },    //    249
    { 0xFF, 0xFF, 0x00, PC_NOCOLLAPSE },    //    250
    { 0xFF, 0xFF, 0x33, PC_NOCOLLAPSE },    //    251
    { 0xFF, 0xFF, 0x66, PC_NOCOLLAPSE },    //    252
    { 0xFF, 0xFF, 0x99, PC_NOCOLLAPSE },    //    253
    { 0xFF, 0xFF, 0xCC, PC_NOCOLLAPSE },    //    254
    { 0xFF, 0xFF, 0xFF, PC_NOCOLLAPSE }, }  //    255
};

// Unfortunately, the Win9x Halftone palette is missing 4 of the 216 halftoning
// colors, namely:
//          0x00, 0x33, 0xFF
//          0x00, 0xFF, 0x33
//          0x33, 0x00, 0xFF
//          0x33, 0xFF, 0x00

GDIP_LOGPALETTE256 Win9xHalftonePalette = {
  0x300, 256,
  {
    // The first 10 system colors
    { 0x00, 0x00, 0x00, 0x00,          },   //      0  Sys Black, gray 0
    { 0x80, 0x00, 0x00, 0x00,          },   //      1  Sys Dk Red
    { 0x00, 0x80, 0x00, 0x00,          },   //      2  Sys Dk Green
    { 0x80, 0x80, 0x00, 0x00,          },   //      3  Sys Dk Yellow
    { 0x00, 0x00, 0x80, 0x00,          },   //      4  Sys Dk Blue
    { 0x80, 0x00, 0x80, 0x00,          },   //      5  Sys Dk Violet
    { 0x00, 0x80, 0x80, 0x00,          },   //      6  Sys Dk Cyan
    { 0xC0, 0xC0, 0xC0, 0x00,          },   //      7  Sys Lt Gray, gray 192

    // The following two system entries are modified for the desktop.
    { 0xC0, 0xDC, 0xC0, 0x00,          },   //      8  Sys 8 - VARIABLE
    { 0xA6, 0xCA, 0xF0, 0x00,          },   //      9  Sys 9 - VARIABLE

    // Gray scale entries (dark)
    { 0x04, 0x04, 0x04, PC_NOCOLLAPSE, },   //     10  Gray  4
    { 0x08, 0x08, 0x08, PC_NOCOLLAPSE, },   //     11  Gray  8
    { 0x0C, 0x0C, 0x0C, PC_NOCOLLAPSE, },   //     12  Gray 12
    { 0x11, 0x11, 0x11, PC_NOCOLLAPSE, },   //     13  Gray 17
    { 0x16, 0x16, 0x16, PC_NOCOLLAPSE, },   //     14  Gray 22
    { 0x1C, 0x1C, 0x1C, PC_NOCOLLAPSE, },   //     15  Gray 28
    { 0x22, 0x22, 0x22, PC_NOCOLLAPSE, },   //     16  Gray 34
    { 0x29, 0x29, 0x29, PC_NOCOLLAPSE, },   //     17  Gray 41
    { 0x55, 0x55, 0x55, PC_NOCOLLAPSE, },   //     18  Gray 85
    { 0x4D, 0x4D, 0x4D, PC_NOCOLLAPSE, },   //     19  Gray 77
    { 0x42, 0x42, 0x42, PC_NOCOLLAPSE, },   //     20  Gray 66
    { 0x39, 0x39, 0x39, PC_NOCOLLAPSE, },   //     21  Gray 57
    
    // Custom app/OS entries
    { 0xFF, 0x7C, 0x80, PC_NOCOLLAPSE, },   //     22  Salmon
    { 0xFF, 0x50, 0x50, PC_NOCOLLAPSE, },   //     23  Red
    { 0xD6, 0x00, 0x93, PC_NOCOLLAPSE, },   //     24  Purple
    { 0xCC, 0xEC, 0xFF, PC_NOCOLLAPSE, },   //     25  Lt Blue
    { 0xEF, 0xD6, 0xC6, PC_NOCOLLAPSE, },   //     26  Win95 Tan
    { 0xE7, 0xE7, 0xD6, PC_NOCOLLAPSE, },   //     27  Win95 Tan
    { 0xAD, 0xA9, 0x90, PC_NOCOLLAPSE, },   //     28  Win95 Grayish

    // Halftone palette entries
    { 0x33, 0x00, 0x00, PC_NOCOLLAPSE, },   //     29  
    { 0x66, 0x00, 0x00, PC_NOCOLLAPSE, },   //     30
    { 0x99, 0x00, 0x00, PC_NOCOLLAPSE, },   //     31
    { 0xCC, 0x00, 0x00, PC_NOCOLLAPSE, },   //     32
    { 0x00, 0x33, 0x00, PC_NOCOLLAPSE, },   //     33
    { 0x33, 0x33, 0x00, PC_NOCOLLAPSE, },   //     34
    { 0x66, 0x33, 0x00, PC_NOCOLLAPSE, },   //     35
    { 0x99, 0x33, 0x00, PC_NOCOLLAPSE, },   //     36
    { 0xCC, 0x33, 0x00, PC_NOCOLLAPSE, },   //     37
    { 0xFF, 0x33, 0x00, PC_NOCOLLAPSE, },   //     38
    { 0x00, 0x66, 0x00, PC_NOCOLLAPSE, },   //     39
    { 0x33, 0x66, 0x00, PC_NOCOLLAPSE, },   //     40
    { 0x66, 0x66, 0x00, PC_NOCOLLAPSE, },   //     41
    { 0x99, 0x66, 0x00, PC_NOCOLLAPSE, },   //     42
    { 0xCC, 0x66, 0x00, PC_NOCOLLAPSE, },   //     43
    { 0xFF, 0x66, 0x00, PC_NOCOLLAPSE, },   //     44
    { 0x00, 0x99, 0x00, PC_NOCOLLAPSE, },   //     45
    { 0x33, 0x99, 0x00, PC_NOCOLLAPSE, },   //     46
    { 0x66, 0x99, 0x00, PC_NOCOLLAPSE, },   //     47
    { 0x99, 0x99, 0x00, PC_NOCOLLAPSE, },   //     48
    { 0xCC, 0x99, 0x00, PC_NOCOLLAPSE, },   //     49
    { 0xFF, 0x99, 0x00, PC_NOCOLLAPSE, },   //     50
    { 0x00, 0xCC, 0x00, PC_NOCOLLAPSE, },   //     51
    { 0x33, 0xCC, 0x00, PC_NOCOLLAPSE, },   //     52
    { 0x66, 0xCC, 0x00, PC_NOCOLLAPSE, },   //     53
    { 0x99, 0xCC, 0x00, PC_NOCOLLAPSE, },   //     54
    { 0xCC, 0xCC, 0x00, PC_NOCOLLAPSE, },   //     55
    { 0xFF, 0xCC, 0x00, PC_NOCOLLAPSE, },   //     56
    { 0x66, 0xFF, 0x00, PC_NOCOLLAPSE, },   //     57
    { 0x99, 0xFF, 0x00, PC_NOCOLLAPSE, },   //     58
    { 0xCC, 0xFF, 0x00, PC_NOCOLLAPSE, },   //     59
    { 0x00, 0x00, 0x33, PC_NOCOLLAPSE, },   //     60
    { 0x33, 0x00, 0x33, PC_NOCOLLAPSE, },   //     61
    { 0x66, 0x00, 0x33, PC_NOCOLLAPSE, },   //     62
    { 0x99, 0x00, 0x33, PC_NOCOLLAPSE, },   //     63
    { 0xCC, 0x00, 0x33, PC_NOCOLLAPSE, },   //     64
    { 0xFF, 0x00, 0x33, PC_NOCOLLAPSE, },   //     65
    { 0x00, 0x33, 0x33, PC_NOCOLLAPSE, },   //     66
    { 0x33, 0x33, 0x33, PC_NOCOLLAPSE, },   //     67  Gray 51
    { 0x66, 0x33, 0x33, PC_NOCOLLAPSE, },   //     68
    { 0x99, 0x33, 0x33, PC_NOCOLLAPSE, },   //     69
    { 0xCC, 0x33, 0x33, PC_NOCOLLAPSE, },   //     70
    { 0xFF, 0x33, 0x33, PC_NOCOLLAPSE, },   //     71
    { 0x00, 0x66, 0x33, PC_NOCOLLAPSE, },   //     72
    { 0x33, 0x66, 0x33, PC_NOCOLLAPSE, },   //     73
    { 0x66, 0x66, 0x33, PC_NOCOLLAPSE, },   //     74
    { 0x99, 0x66, 0x33, PC_NOCOLLAPSE, },   //     75
    { 0xCC, 0x66, 0x33, PC_NOCOLLAPSE, },   //     76
    { 0xFF, 0x66, 0x33, PC_NOCOLLAPSE, },   //     77
    { 0x00, 0x99, 0x33, PC_NOCOLLAPSE, },   //     78
    { 0x33, 0x99, 0x33, PC_NOCOLLAPSE, },   //     79
    { 0x66, 0x99, 0x33, PC_NOCOLLAPSE, },   //     80
    { 0x99, 0x99, 0x33, PC_NOCOLLAPSE, },   //     81
    { 0xCC, 0x99, 0x33, PC_NOCOLLAPSE, },   //     82
    { 0xFF, 0x99, 0x33, PC_NOCOLLAPSE, },   //     83
    { 0x00, 0xCC, 0x33, PC_NOCOLLAPSE, },   //     84
    { 0x33, 0xCC, 0x33, PC_NOCOLLAPSE, },   //     85
    { 0x66, 0xCC, 0x33, PC_NOCOLLAPSE, },   //     86
    { 0x99, 0xCC, 0x33, PC_NOCOLLAPSE, },   //     87
    { 0xCC, 0xCC, 0x33, PC_NOCOLLAPSE, },   //     88
    { 0xFF, 0xCC, 0x33, PC_NOCOLLAPSE, },   //     89
    { 0x33, 0xFF, 0x33, PC_NOCOLLAPSE, },   //     90
    { 0x66, 0xFF, 0x33, PC_NOCOLLAPSE, },   //     91
    { 0x99, 0xFF, 0x33, PC_NOCOLLAPSE, },   //     92
    { 0xCC, 0xFF, 0x33, PC_NOCOLLAPSE, },   //     93
    { 0xFF, 0xFF, 0x33, PC_NOCOLLAPSE, },   //     94
    { 0x00, 0x00, 0x66, PC_NOCOLLAPSE, },   //     95
    { 0x33, 0x00, 0x66, PC_NOCOLLAPSE, },   //     96
    { 0x66, 0x00, 0x66, PC_NOCOLLAPSE, },   //     97
    { 0x99, 0x00, 0x66, PC_NOCOLLAPSE, },   //     98
    { 0xCC, 0x00, 0x66, PC_NOCOLLAPSE, },   //     99
    { 0xFF, 0x00, 0x66, PC_NOCOLLAPSE, },   //    100
    { 0x00, 0x33, 0x66, PC_NOCOLLAPSE, },   //    101
    { 0x33, 0x33, 0x66, PC_NOCOLLAPSE, },   //    102
    { 0x66, 0x33, 0x66, PC_NOCOLLAPSE, },   //    103
    { 0x99, 0x33, 0x66, PC_NOCOLLAPSE, },   //    104
    { 0xCC, 0x33, 0x66, PC_NOCOLLAPSE, },   //    105
    { 0xFF, 0x33, 0x66, PC_NOCOLLAPSE, },   //    106
    { 0x00, 0x66, 0x66, PC_NOCOLLAPSE, },   //    107
    { 0x33, 0x66, 0x66, PC_NOCOLLAPSE, },   //    108
    { 0x66, 0x66, 0x66, PC_NOCOLLAPSE, },   //    109  Gray 102
    { 0x99, 0x66, 0x66, PC_NOCOLLAPSE, },   //    110
    { 0xCC, 0x66, 0x66, PC_NOCOLLAPSE, },   //    111
    { 0x00, 0x99, 0x66, PC_NOCOLLAPSE, },   //    112
    { 0x33, 0x99, 0x66, PC_NOCOLLAPSE, },   //    113
    { 0x66, 0x99, 0x66, PC_NOCOLLAPSE, },   //    114
    { 0x99, 0x99, 0x66, PC_NOCOLLAPSE, },   //    115
    { 0xCC, 0x99, 0x66, PC_NOCOLLAPSE, },   //    116
    { 0xFF, 0x99, 0x66, PC_NOCOLLAPSE, },   //    117
    { 0x00, 0xCC, 0x66, PC_NOCOLLAPSE, },   //    118
    { 0x33, 0xCC, 0x66, PC_NOCOLLAPSE, },   //    119
    { 0x99, 0xCC, 0x66, PC_NOCOLLAPSE, },   //    120
    { 0xCC, 0xCC, 0x66, PC_NOCOLLAPSE, },   //    121
    { 0xFF, 0xCC, 0x66, PC_NOCOLLAPSE, },   //    122
    { 0x00, 0xFF, 0x66, PC_NOCOLLAPSE, },   //    123
    { 0x33, 0xFF, 0x66, PC_NOCOLLAPSE, },   //    124
    { 0x99, 0xFF, 0x66, PC_NOCOLLAPSE, },   //    125
    { 0xCC, 0xFF, 0x66, PC_NOCOLLAPSE, },   //    126
    { 0xFF, 0x00, 0xCC, PC_NOCOLLAPSE, },   //    127
    { 0xCC, 0x00, 0xFF, PC_NOCOLLAPSE, },   //    128
    { 0x00, 0x99, 0x99, PC_NOCOLLAPSE, },   //    129
    { 0x99, 0x33, 0x99, PC_NOCOLLAPSE, },   //    130
    { 0x99, 0x00, 0x99, PC_NOCOLLAPSE, },   //    131
    { 0xCC, 0x00, 0x99, PC_NOCOLLAPSE, },   //    132
    { 0x00, 0x00, 0x99, PC_NOCOLLAPSE, },   //    133
    { 0x33, 0x33, 0x99, PC_NOCOLLAPSE, },   //    134
    { 0x66, 0x00, 0x99, PC_NOCOLLAPSE, },   //    135
    { 0xCC, 0x33, 0x99, PC_NOCOLLAPSE, },   //    136
    { 0xFF, 0x00, 0x99, PC_NOCOLLAPSE, },   //    137
    { 0x00, 0x66, 0x99, PC_NOCOLLAPSE, },   //    138
    { 0x33, 0x66, 0x99, PC_NOCOLLAPSE, },   //    139
    { 0x66, 0x33, 0x99, PC_NOCOLLAPSE, },   //    140
    { 0x99, 0x66, 0x99, PC_NOCOLLAPSE, },   //    141
    { 0xCC, 0x66, 0x99, PC_NOCOLLAPSE, },   //    142
    { 0xFF, 0x33, 0x99, PC_NOCOLLAPSE, },   //    143
    { 0x33, 0x99, 0x99, PC_NOCOLLAPSE, },   //    144
    { 0x66, 0x99, 0x99, PC_NOCOLLAPSE, },   //    145
    { 0x99, 0x99, 0x99, PC_NOCOLLAPSE, },   //    146  Gray 153
    { 0xCC, 0x99, 0x99, PC_NOCOLLAPSE, },   //    147
    { 0xFF, 0x99, 0x99, PC_NOCOLLAPSE, },   //    148
    { 0x00, 0xCC, 0x99, PC_NOCOLLAPSE, },   //    149
    { 0x33, 0xCC, 0x99, PC_NOCOLLAPSE, },   //    150
    { 0x66, 0xCC, 0x66, PC_NOCOLLAPSE, },   //    151
    { 0x99, 0xCC, 0x99, PC_NOCOLLAPSE, },   //    152
    { 0xCC, 0xCC, 0x99, PC_NOCOLLAPSE, },   //    153
    { 0xFF, 0xCC, 0x99, PC_NOCOLLAPSE, },   //    154
    { 0x00, 0xFF, 0x99, PC_NOCOLLAPSE, },   //    155
    { 0x33, 0xFF, 0x99, PC_NOCOLLAPSE, },   //    156
    { 0x66, 0xCC, 0x99, PC_NOCOLLAPSE, },   //    157
    { 0x99, 0xFF, 0x99, PC_NOCOLLAPSE, },   //    158
    { 0xCC, 0xFF, 0x99, PC_NOCOLLAPSE, },   //    159
    { 0xFF, 0xFF, 0x99, PC_NOCOLLAPSE, },   //    160
    { 0x00, 0x00, 0xCC, PC_NOCOLLAPSE, },   //    161
    { 0x33, 0x00, 0x99, PC_NOCOLLAPSE, },   //    162
    { 0x66, 0x00, 0xCC, PC_NOCOLLAPSE, },   //    163
    { 0x99, 0x00, 0xCC, PC_NOCOLLAPSE, },   //    164
    { 0xCC, 0x00, 0xCC, PC_NOCOLLAPSE, },   //    165
    { 0x00, 0x33, 0x99, PC_NOCOLLAPSE, },   //    166
    { 0x33, 0x33, 0xCC, PC_NOCOLLAPSE, },   //    167
    { 0x66, 0x33, 0xCC, PC_NOCOLLAPSE, },   //    168
    { 0x99, 0x33, 0xCC, PC_NOCOLLAPSE, },   //    169
    { 0xCC, 0x33, 0xCC, PC_NOCOLLAPSE, },   //    170
    { 0xFF, 0x33, 0xCC, PC_NOCOLLAPSE, },   //    171
    { 0x00, 0x66, 0xCC, PC_NOCOLLAPSE, },   //    172
    { 0x33, 0x66, 0xCC, PC_NOCOLLAPSE, },   //    173
    { 0x66, 0x66, 0x99, PC_NOCOLLAPSE, },   //    174
    { 0x99, 0x66, 0xCC, PC_NOCOLLAPSE, },   //    175
    { 0xCC, 0x66, 0xCC, PC_NOCOLLAPSE, },   //    176
    { 0xFF, 0x66, 0x99, PC_NOCOLLAPSE, },   //    177
    { 0x00, 0x99, 0xCC, PC_NOCOLLAPSE, },   //    178
    { 0x33, 0x99, 0xCC, PC_NOCOLLAPSE, },   //    179
    { 0x66, 0x99, 0xCC, PC_NOCOLLAPSE, },   //    180
    { 0x99, 0x99, 0xCC, PC_NOCOLLAPSE, },   //    181
    { 0xCC, 0x99, 0xCC, PC_NOCOLLAPSE, },   //    182
    { 0xFF, 0x99, 0xCC, PC_NOCOLLAPSE, },   //    183
    { 0x00, 0xCC, 0xCC, PC_NOCOLLAPSE, },   //    184
    { 0x33, 0xCC, 0xCC, PC_NOCOLLAPSE, },   //    185
    { 0x66, 0xCC, 0xCC, PC_NOCOLLAPSE, },   //    186
    { 0x99, 0xCC, 0xCC, PC_NOCOLLAPSE, },   //    187
    { 0xCC, 0xCC, 0xCC, PC_NOCOLLAPSE, },   //    188  Gray 204
    { 0xFF, 0xCC, 0xCC, PC_NOCOLLAPSE, },   //    189
    { 0x00, 0xFF, 0xCC, PC_NOCOLLAPSE, },   //    190
    { 0x33, 0xFF, 0xCC, PC_NOCOLLAPSE, },   //    191
    { 0x66, 0xFF, 0x99, PC_NOCOLLAPSE, },   //    192
    { 0x99, 0xFF, 0xCC, PC_NOCOLLAPSE, },   //    193
    { 0xCC, 0xFF, 0xCC, PC_NOCOLLAPSE, },   //    194
    { 0xFF, 0xFF, 0xCC, PC_NOCOLLAPSE, },   //    195
    { 0x33, 0x00, 0xCC, PC_NOCOLLAPSE, },   //    196
    { 0x66, 0x00, 0xFF, PC_NOCOLLAPSE, },   //    197
    { 0x99, 0x00, 0xFF, PC_NOCOLLAPSE, },   //    198
    { 0x00, 0x33, 0xCC, PC_NOCOLLAPSE, },   //    199
    { 0x33, 0x33, 0xFF, PC_NOCOLLAPSE, },   //    200
    { 0x66, 0x33, 0xFF, PC_NOCOLLAPSE, },   //    201
    { 0x99, 0x33, 0xFF, PC_NOCOLLAPSE, },   //    202
    { 0xCC, 0x33, 0xFF, PC_NOCOLLAPSE, },   //    203
    { 0xFF, 0x33, 0xFF, PC_NOCOLLAPSE, },   //    204
    { 0x00, 0x66, 0xFF, PC_NOCOLLAPSE, },   //    205
    { 0x33, 0x66, 0xFF, PC_NOCOLLAPSE, },   //    206
    { 0x66, 0x66, 0xCC, PC_NOCOLLAPSE, },   //    207
    { 0x99, 0x66, 0xFF, PC_NOCOLLAPSE, },   //    208
    { 0xCC, 0x66, 0xFF, PC_NOCOLLAPSE, },   //    209
    { 0xFF, 0x66, 0xCC, PC_NOCOLLAPSE, },   //    210
    { 0x00, 0x99, 0xFF, PC_NOCOLLAPSE, },   //    211
    { 0x33, 0x99, 0xFF, PC_NOCOLLAPSE, },   //    212
    { 0x66, 0x99, 0xFF, PC_NOCOLLAPSE, },   //    213
    { 0x99, 0x99, 0xFF, PC_NOCOLLAPSE, },   //    214
    { 0xCC, 0x99, 0xFF, PC_NOCOLLAPSE, },   //    215
    { 0xFF, 0x99, 0xFF, PC_NOCOLLAPSE, },   //    216
    { 0x00, 0xCC, 0xFF, PC_NOCOLLAPSE, },   //    217
    { 0x33, 0xCC, 0xFF, PC_NOCOLLAPSE, },   //    218
    { 0x66, 0xCC, 0xFF, PC_NOCOLLAPSE, },   //    219
    { 0x99, 0xCC, 0xFF, PC_NOCOLLAPSE, },   //    220
    { 0xCC, 0xCC, 0xFF, PC_NOCOLLAPSE, },   //    221
    { 0xFF, 0xCC, 0xFF, PC_NOCOLLAPSE, },   //    222
    { 0x33, 0xFF, 0xFF, PC_NOCOLLAPSE, },   //    223
    { 0x66, 0xFF, 0xCC, PC_NOCOLLAPSE, },   //    224
    { 0x99, 0xFF, 0xFF, PC_NOCOLLAPSE, },   //    225
    { 0xCC, 0xFF, 0xFF, PC_NOCOLLAPSE, },   //    226
    { 0xFF, 0x66, 0x66, PC_NOCOLLAPSE, },   //    227
    { 0x66, 0xFF, 0x66, PC_NOCOLLAPSE, },   //    228
    { 0xFF, 0xFF, 0x66, PC_NOCOLLAPSE, },   //    229
    { 0x66, 0x66, 0xFF, PC_NOCOLLAPSE, },   //    230
    { 0xFF, 0x66, 0xFF, PC_NOCOLLAPSE, },   //    231
    { 0x66, 0xFF, 0xFF, PC_NOCOLLAPSE, },   //    232
    
    // App custom colors
    { 0xA5, 0x00, 0x21, PC_NOCOLLAPSE, },   //    233  Brick red

    // Gray palette
    { 0x5F, 0x5F, 0x5F, PC_NOCOLLAPSE, },   //    234  Gray 95
    { 0x77, 0x77, 0x77, PC_NOCOLLAPSE, },   //    235  Gray 119
    { 0x86, 0x86, 0x86, PC_NOCOLLAPSE, },   //    236  Gray 134
    { 0x96, 0x96, 0x96, PC_NOCOLLAPSE, },   //    237  Gray 150
    { 0xCB, 0xCB, 0xCB, PC_NOCOLLAPSE, },   //    238  Gray 203
    { 0xB2, 0xB2, 0xB2, PC_NOCOLLAPSE, },   //    239  Gray 178
    { 0xD7, 0xD7, 0xD7, PC_NOCOLLAPSE, },   //    240  Gray 215
    { 0xDD, 0xDD, 0xDD, PC_NOCOLLAPSE, },   //    241  Gray 221
    { 0xE3, 0xE3, 0xE3, PC_NOCOLLAPSE, },   //    242  Gray 227
    { 0xEA, 0xEA, 0xEA, PC_NOCOLLAPSE, },   //    243  Gray 234
    { 0xF1, 0xF1, 0xF1, PC_NOCOLLAPSE, },   //    244  Gray 241
    { 0xF8, 0xF8, 0xF8, PC_NOCOLLAPSE, },   //    245  Gray 248

    // The last 10 system colors

    // The following two system entries are modified for the desktop.
    { 0xFF, 0xFB, 0xF0, 0x00,          },   //    246  Sys 246 - VARIABLE
    { 0xA0, 0xA0, 0xA4, 0x00,          },   //    247  Sys 247 - VARIABLE

    { 0x80, 0x80, 0x80, 0x00,          },   //    248  Sys Lt Gray, gray 128
    { 0xFF, 0x00, 0x00, 0x00,          },   //    249  Sys Red
    { 0x00, 0xFF, 0x00, 0x00,          },   //    250  Sys Green
    { 0xFF, 0xFF, 0x00, 0x00,          },   //    251  Sys Yellow
    { 0x00, 0x00, 0xFF, 0x00,          },   //    252  Sys Blue
    { 0xFF, 0x00, 0xFF, 0x00,          },   //    253  Sys Violet
    { 0x00, 0xFF, 0xFF, 0x00,          },   //    254  Sys Cyan
    { 0xFF, 0xFF, 0xFF, 0x00,          },   //    255  Sys White, gray 255
  }
};

// The RGB values must be linearized before they are halftoned.

// The first gamma table is for 216-color halftoning.
// v = ((x/255)^0.90) * 255
const BYTE GammaTable216[256] = {
    0x00, 0x02, 0x03, 0x05, 0x06, 0x07, 0x09, 0x0A, 
    0x0B, 0x0D, 0x0E, 0x0F, 0x10, 0x12, 0x13, 0x14, 
    0x15, 0x16, 0x17, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 
    0x1E, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 
    0x27, 0x28, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 
    0x30, 0x31, 0x32, 0x33, 0x34, 0x36, 0x37, 0x38, 
    0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 
    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 
    0x49, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 
    0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 
    0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 
    0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 
    0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 
    0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 
    0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7E, 0x7F, 0x80, 
    0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 
    0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 
    0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 
    0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 
    0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 
    0xA8, 0xA9, 0xAA, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 
    0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 
    0xB7, 0xB8, 0xB9, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 
    0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 
    0xC6, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 
    0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD2, 0xD3, 
    0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 
    0xDC, 0xDD, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 
    0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE7, 0xE8, 0xE9, 
    0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 
    0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 
    0xF9, 0xFA, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 
};

// This table is designed so that for a value v,
// GammaTable16[InverseGammaTable16[v]] >= v.
// This is used for doing SrcOver alpha blending
// so that the dest that has already been gamma
// corrected can be inverse gamma corrected before
// we blend it and re-gamma correct it. 
const BYTE InverseGammaTable216[256] = {
    0x00, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x05, 
    0x06, 0x06, 0x07, 0x08, 0x09, 0x09, 0x0A, 0x0B, 
    0x0C, 0x0D, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12,
    0x13, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 
    0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 
    0x21, 0x22, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2D, 0x2E, 
    0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 
    0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E,
    0x3F, 0x40, 0x41, 0x41, 0x42, 0x43, 0x44, 0x45, 
    0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 
    0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55,
    0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 
    0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 
    0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
    0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x76, 
    0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 
    0x7F, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86,
    0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 
    0x8F, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 
    0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
    0xA0, 0xA1, 0xA2, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 
    0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 
    0xB1, 0xB2, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9,
    0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC2, 
    0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 
    0xCB, 0xCC, 0xCD, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 
    0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDB, 0xDC, 
    0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 
    0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED,
    0xEE, 0xEF, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 
    0xF7, 0xF8, 0xF9, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 
};

// The next gamma table is for 16-color halftoning.
// This is a hand-tuned table.  It started out as a table whose values 
// were calculated by:
//      v = ((x/255)^1.325) * 255
// But then some entries were removed by hand so that more black could 
// be added to the top of the table and more white could be added to the
// bottom of the table.  
const BYTE GammaTable16[256] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 
    0x05, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x08,
    0x09, 0x09, 0x0A, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 
    0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
    0x16, 0x17, 0x17, 0x18, 0x19, 0x1A, 0x1A, 0x1B,
    0x1C, 0x1D, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x21,
    0x22, 0x23, 0x24, 0x25, 0x25, 0x26, 0x27, 0x28,
    0x29, 0x2A, 0x2B, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
    0x30, 0x31, 0x32, 0x32, 0x33, 0x34, 0x35, 0x36,
    0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3B, 0x3C, 0x3D,
    0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45,
    0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D,
    0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55,
    0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D,
    0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65,
    0x66, 0x67, 0x68, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
    0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
    0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
    0x80, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 
    0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x92, 
    0x93, 0x94, 0x95, 0x96, 0x97, 0x99, 0x9A, 0x9B, 
    0x9C, 0x9D, 0x9E, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 
    0xA5, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAD, 0xAE, 
    0xAF, 0xB0, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB8, 
    0xB9, 0xBA, 0xBB, 0xBC, 0xBE, 0xBF, 0xC0, 0xC1, 
    0xC3, 0xC4, 0xC5, 0xC6, 0xC8, 0xC9, 0xCA, 0xCB, 
    0xCD, 0xCE, 0xCF, 0xD0, 0xD2, 0xD3, 0xD4, 0xD5, 
    0xD7, 0xD8, 0xD9, 0xDB, 0xDC, 0xDD, 0xDE, 0xE0, 
    0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE, 0xF0, 
    0xF2, 0xF4, 0xF6, 0xF8, 0xFA, 0xFC, 0xFE, 0xFF, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
};

// This table is designed so that for a value v,
// GammaTable16[InverseGammaTable16[v]] >= v.
// This is used for doing SrcOver alpha blending
// so that the dest that has already been gamma
// corrected can be inverse gamma corrected before
// we blend it and re-gamma correct it. 
const BYTE InverseGammaTable16[256] = {
    0x00, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 0x12, 0x14, 
    0x16, 0x18, 0x1A, 0x1C, 0x1D, 0x1E, 0x1F, 0x21, 
    0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 
    0x2B, 0x2C, 0x2D, 0x2F, 0x30, 0x31, 0x33, 0x34, 
    0x35, 0x36, 0x38, 0x39, 0x3A, 0x3B, 0x3D, 0x3E, 
    0x3F, 0x40, 0x41, 0x42, 0x44, 0x45, 0x46, 0x47, 
    0x48, 0x49, 0x4A, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 
    0x51, 0x52, 0x53, 0x54, 0x56, 0x57, 0x58, 0x59, 
    0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 
    0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 
    0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 
    0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 
    0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 
    0x82, 0x83, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 
    0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 
    0x98, 0x99, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 
    0x9F, 0xA0, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 
    0xA6, 0xA7, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 
    0xAD, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 
    0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xB9, 
    0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBE, 0xBF, 0xC0, 
    0xC1, 0xC2, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 
    0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCC, 0xCD, 
    0xCE, 0xCF, 0xD0, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 
    0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD8, 0xD9, 0xDA, 
    0xDB, 0xDC, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE0, 
    0xE1, 0xE2, 0xE3, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 
    0xE7, 0xE8, 0xE8, 0xE9, 0xE9, 0xEA, 0xEA, 0xEB, 
    0xEB, 0xEC, 0xEC, 0xED, 0xED, 0xEE, 0xEE, 0xEF, 
    0xEF, 0xF0, 0xF0, 0xF1, 0xF1, 0xF2, 0xF2, 0xF3, 
    0xF3, 0xF4, 0xF4, 0xF5, 0xF5, 0xF6, 0xF6, 0xFF, 
};

// Standard 8x8 halftoning matrix for 216 colors.
// Contains values between 0x00 and 0x32 (inclusive).

const BYTE HT_216_8x8[8*8] = {
    0x00, 0x19, 0x06, 0x20, 0x02, 0x1B, 0x08, 0x21, 
    0x26, 0x0D, 0x2C, 0x13, 0x28, 0x0E, 0x2E, 0x15,
    0x0A, 0x23, 0x03, 0x1D, 0x0B, 0x25, 0x05, 0x1E, 
    0x30, 0x16, 0x29, 0x10, 0x31, 0x18, 0x2B, 0x11,
    0x02, 0x1C, 0x09, 0x22, 0x01, 0x1A, 0x07, 0x21, 
    0x28, 0x0F, 0x2F, 0x15, 0x27, 0x0D, 0x2D, 0x14,
    0x0C, 0x25, 0x06, 0x1F, 0x0A, 0x24, 0x04, 0x1D, 
    0x32, 0x19, 0x2C, 0x12, 0x30, 0x17, 0x2A, 0x11,
};

// Daniel Chou's halftoning cells

// The first 3 cells are for halftoning to the 216 colors that contain
// all combinations of 0x00, 0x33, 0x66, 0x99, 0xCC, and 0xFF
// These cells contain values between 0x00 and 0x32 (inclusive).

const BYTE HT_SuperCell_Red216[91*91] = {
    0x21, 0x0C, 0x16, 0x31, 0x0E, 0x14, 0x23, 0x16, 0x20, 0x1A,         //  0
    0x01, 0x22, 0x13, 0x06, 0x0C, 0x1F, 0x00, 0x30, 0x0B, 0x05, 
    0x23, 0x19, 0x05, 0x29, 0x23, 0x19, 0x1E, 0x2C, 0x17, 0x2F, 
    0x0B, 0x14, 0x30, 0x0D, 0x2B, 0x1F, 0x0B, 0x05, 0x25, 0x0D, 
    0x01, 0x14, 0x31, 0x1E, 0x02, 0x2E, 0x0A, 0x21, 0x2F, 0x27, 
    0x0A, 0x2D, 0x1E, 0x29, 0x0E, 0x30, 0x06, 0x14, 0x0C, 0x04, 
    0x27, 0x15, 0x0C, 0x29, 0x14, 0x0A, 0x1C, 0x01, 0x22, 0x2C, 
    0x28, 0x1C, 0x0F, 0x2F, 0x16, 0x25, 0x30, 0x02, 0x2C, 0x16, 
    0x04, 0x08, 0x2D, 0x1B, 0x26, 0x13, 0x2A, 0x03, 0x10, 0x1B, 0x13, 
    
    0x1D, 0x2E, 0x10, 0x26, 0x1F, 0x09, 0x2C, 0x10, 0x0B, 0x2D,         //  1
    0x09, 0x31, 0x1D, 0x17, 0x26, 0x19, 0x12, 0x22, 0x1D, 0x15, 
    0x2C, 0x0D, 0x14, 0x2E, 0x00, 0x09, 0x11, 0x21, 0x09, 0x10, 
    0x23, 0x29, 0x08, 0x22, 0x19, 0x13, 0x32, 0x17, 0x2A, 0x1F, 
    0x2D, 0x22, 0x05, 0x17, 0x2A, 0x0D, 0x28, 0x04, 0x12, 0x1A, 
    0x02, 0x23, 0x12, 0x09, 0x16, 0x27, 0x1A, 0x2D, 0x21, 0x19, 
    0x2C, 0x09, 0x30, 0x19, 0x06, 0x2B, 0x11, 0x2F, 0x0B, 0x1A, 
    0x04, 0x15, 0x26, 0x01, 0x21, 0x0D, 0x1C, 0x0A, 0x26, 0x0F, 
    0x2E, 0x27, 0x15, 0x01, 0x2F, 0x0D, 0x1A, 0x21, 0x2F, 0x27, 0x02, 
    
    0x09, 0x24, 0x06, 0x1B, 0x03, 0x28, 0x19, 0x06, 0x27, 0x14,         //  2
    0x24, 0x10, 0x07, 0x2B, 0x03, 0x2F, 0x08, 0x0D, 0x2E, 0x02, 
    0x25, 0x07, 0x22, 0x1C, 0x16, 0x25, 0x30, 0x02, 0x1D, 0x2A, 
    0x18, 0x00, 0x1E, 0x11, 0x05, 0x25, 0x01, 0x1C, 0x08, 0x13, 
    0x07, 0x0E, 0x27, 0x0B, 0x1B, 0x13, 0x23, 0x18, 0x1F, 0x0D, 
    0x31, 0x1C, 0x05, 0x2E, 0x20, 0x0D, 0x08, 0x28, 0x01, 0x0E, 
    0x24, 0x03, 0x21, 0x0E, 0x1F, 0x26, 0x07, 0x17, 0x27, 0x11, 
    0x21, 0x2E, 0x09, 0x1A, 0x11, 0x06, 0x2A, 0x13, 0x20, 0x19, 
    0x0A, 0x1E, 0x0D, 0x23, 0x16, 0x04, 0x2C, 0x07, 0x0B, 0x15, 0x2C, 
    
    0x19, 0x11, 0x2B, 0x14, 0x2F, 0x0C, 0x20, 0x32, 0x1D, 0x03,         //  3
    0x1A, 0x29, 0x20, 0x0B, 0x13, 0x28, 0x23, 0x1A, 0x29, 0x10, 
    0x1B, 0x30, 0x0F, 0x06, 0x2D, 0x0C, 0x1B, 0x14, 0x25, 0x06, 
    0x0E, 0x2D, 0x16, 0x28, 0x2F, 0x0E, 0x2C, 0x10, 0x24, 0x30, 
    0x1D, 0x18, 0x2D, 0x20, 0x06, 0x32, 0x00, 0x2D, 0x09, 0x2B, 
    0x15, 0x0F, 0x2A, 0x18, 0x02, 0x24, 0x13, 0x1E, 0x17, 0x30, 
    0x13, 0x1C, 0x14, 0x2E, 0x00, 0x1B, 0x2C, 0x20, 0x03, 0x32, 
    0x07, 0x0E, 0x2A, 0x1E, 0x31, 0x23, 0x18, 0x05, 0x30, 0x00, 
    0x24, 0x12, 0x31, 0x09, 0x1F, 0x28, 0x18, 0x12, 0x1D, 0x24, 0x0F, 
    
    0x32, 0x20, 0x01, 0x23, 0x0F, 0x18, 0x00, 0x12, 0x0A, 0x2C,         //  4
    0x0D, 0x04, 0x17, 0x30, 0x1C, 0x0E, 0x05, 0x15, 0x07, 0x20, 
    0x0A, 0x17, 0x29, 0x1F, 0x12, 0x28, 0x05, 0x2B, 0x0B, 0x31, 
    0x1B, 0x21, 0x07, 0x0C, 0x1B, 0x20, 0x07, 0x29, 0x15, 0x02, 
    0x2A, 0x10, 0x01, 0x15, 0x26, 0x10, 0x1E, 0x14, 0x27, 0x05, 
    0x21, 0x08, 0x26, 0x0E, 0x1D, 0x31, 0x2A, 0x05, 0x0C, 0x26, 
    0x07, 0x2B, 0x0B, 0x24, 0x17, 0x12, 0x09, 0x0E, 0x14, 0x1D, 
    0x19, 0x24, 0x16, 0x05, 0x0B, 0x14, 0x2B, 0x0C, 0x1D, 0x15, 
    0x2D, 0x06, 0x19, 0x2A, 0x0F, 0x07, 0x23, 0x31, 0x00, 0x2A, 0x05, 
    
    0x0C, 0x16, 0x28, 0x0A, 0x1E, 0x2D, 0x29, 0x23, 0x16, 0x1F,         //  5
    0x26, 0x2D, 0x0F, 0x22, 0x02, 0x20, 0x2C, 0x24, 0x32, 0x13, 
    0x2B, 0x03, 0x0E, 0x24, 0x01, 0x18, 0x21, 0x10, 0x1F, 0x16, 
    0x03, 0x12, 0x2A, 0x24, 0x02, 0x12, 0x18, 0x1E, 0x0C, 0x22, 
    0x0A, 0x25, 0x30, 0x1D, 0x09, 0x2C, 0x07, 0x1B, 0x0F, 0x24, 
    0x17, 0x1E, 0x2F, 0x07, 0x14, 0x04, 0x10, 0x22, 0x2D, 0x1A, 
    0x10, 0x1F, 0x03, 0x29, 0x08, 0x30, 0x23, 0x27, 0x2D, 0x0A, 
    0x29, 0x00, 0x10, 0x2C, 0x26, 0x02, 0x1E, 0x26, 0x08, 0x2A, 
    0x0F, 0x1F, 0x26, 0x01, 0x15, 0x2E, 0x11, 0x0C, 0x20, 0x14, 0x1D, 
    
    0x24, 0x08, 0x1B, 0x30, 0x05, 0x13, 0x07, 0x0D, 0x30, 0x02,         //  6
    0x13, 0x1B, 0x09, 0x29, 0x14, 0x1A, 0x09, 0x11, 0x01, 0x1A, 
    0x26, 0x1D, 0x2E, 0x09, 0x1C, 0x31, 0x08, 0x2D, 0x05, 0x28, 
    0x23, 0x2F, 0x08, 0x17, 0x31, 0x25, 0x2C, 0x03, 0x2F, 0x17, 
    0x1C, 0x13, 0x04, 0x0D, 0x29, 0x16, 0x24, 0x2D, 0x03, 0x31, 
    0x0C, 0x01, 0x19, 0x23, 0x29, 0x18, 0x1F, 0x0A, 0x15, 0x02, 
    0x24, 0x32, 0x16, 0x11, 0x21, 0x1D, 0x02, 0x18, 0x05, 0x21, 
    0x12, 0x30, 0x1B, 0x20, 0x18, 0x0F, 0x2D, 0x11, 0x18, 0x22, 
    0x03, 0x16, 0x0B, 0x2C, 0x1C, 0x21, 0x03, 0x1A, 0x2D, 0x09, 0x29, 
    
    0x02, 0x2C, 0x14, 0x0D, 0x25, 0x20, 0x1A, 0x27, 0x18, 0x0B,         //  7
    0x23, 0x05, 0x31, 0x11, 0x25, 0x0D, 0x2F, 0x21, 0x29, 0x0D, 
    0x06, 0x11, 0x17, 0x2A, 0x13, 0x0C, 0x24, 0x14, 0x1A, 0x0E, 
    0x0A, 0x1A, 0x10, 0x1E, 0x06, 0x0D, 0x09, 0x21, 0x0F, 0x2A, 
    0x07, 0x2E, 0x24, 0x18, 0x1F, 0x02, 0x0B, 0x13, 0x1F, 0x15, 
    0x26, 0x2B, 0x13, 0x0B, 0x2F, 0x09, 0x27, 0x30, 0x1D, 0x2A, 
    0x0E, 0x07, 0x1B, 0x2E, 0x06, 0x15, 0x0C, 0x2F, 0x1E, 0x15, 
    0x09, 0x22, 0x0D, 0x05, 0x2F, 0x08, 0x1B, 0x04, 0x30, 0x0D, 
    0x1C, 0x2F, 0x23, 0x10, 0x06, 0x28, 0x16, 0x25, 0x05, 0x1B, 0x10, 
    
    0x18, 0x21, 0x04, 0x2A, 0x17, 0x03, 0x2C, 0x08, 0x1E, 0x2D,         //  8
    0x28, 0x15, 0x20, 0x00, 0x2C, 0x08, 0x1C, 0x05, 0x15, 0x1F, 
    0x30, 0x24, 0x02, 0x20, 0x05, 0x28, 0x1D, 0x02, 0x2A, 0x20, 
    0x2D, 0x01, 0x28, 0x22, 0x15, 0x29, 0x1A, 0x13, 0x26, 0x04, 
    0x1F, 0x16, 0x0B, 0x2C, 0x10, 0x31, 0x1B, 0x29, 0x06, 0x0A, 
    0x1A, 0x0E, 0x20, 0x03, 0x1D, 0x16, 0x00, 0x0F, 0x06, 0x13, 
    0x1F, 0x28, 0x0B, 0x25, 0x0F, 0x24, 0x2A, 0x12, 0x07, 0x24, 
    0x2E, 0x02, 0x17, 0x2A, 0x13, 0x27, 0x21, 0x13, 0x24, 0x07, 
    0x28, 0x13, 0x02, 0x19, 0x31, 0x09, 0x0E, 0x2F, 0x13, 0x23, 0x2E, 
    
    0x11, 0x31, 0x0F, 0x1D, 0x0A, 0x30, 0x0F, 0x16, 0x01, 0x12,         //  9
    0x09, 0x1C, 0x0C, 0x19, 0x22, 0x17, 0x27, 0x0F, 0x2B, 0x09, 
    0x18, 0x0E, 0x28, 0x0A, 0x2F, 0x15, 0x0F, 0x30, 0x08, 0x11, 
    0x1C, 0x14, 0x30, 0x04, 0x0F, 0x2E, 0x1F, 0x01, 0x30, 0x1A, 
    0x0D, 0x28, 0x06, 0x22, 0x04, 0x17, 0x25, 0x0F, 0x2D, 0x22, 
    0x30, 0x05, 0x27, 0x2D, 0x11, 0x25, 0x2C, 0x1A, 0x23, 0x2F, 
    0x03, 0x16, 0x2C, 0x01, 0x1A, 0x31, 0x04, 0x1C, 0x28, 0x0C, 
    0x2A, 0x1D, 0x25, 0x0B, 0x1F, 0x02, 0x0D, 0x2A, 0x19, 0x10, 
    0x1E, 0x09, 0x2B, 0x1F, 0x13, 0x25, 0x1D, 0x01, 0x2A, 0x0B, 0x06, 
    
    0x26, 0x1A, 0x07, 0x27, 0x22, 0x12, 0x28, 0x23, 0x2A, 0x1F,         // 10
    0x2F, 0x03, 0x29, 0x2F, 0x07, 0x12, 0x02, 0x31, 0x23, 0x01, 
    0x1C, 0x2D, 0x13, 0x1E, 0x19, 0x22, 0x09, 0x23, 0x17, 0x27, 
    0x0C, 0x23, 0x09, 0x19, 0x25, 0x0A, 0x15, 0x23, 0x08, 0x13, 
    0x25, 0x31, 0x13, 0x1E, 0x28, 0x0C, 0x07, 0x20, 0x00, 0x16, 
    0x10, 0x1E, 0x12, 0x19, 0x06, 0x0D, 0x1F, 0x14, 0x08, 0x27, 
    0x1C, 0x0D, 0x22, 0x1E, 0x12, 0x09, 0x20, 0x16, 0x01, 0x0F, 
    0x19, 0x12, 0x04, 0x30, 0x15, 0x2C, 0x1C, 0x0A, 0x2D, 0x00, 
    0x32, 0x17, 0x25, 0x0C, 0x04, 0x2B, 0x10, 0x1A, 0x22, 0x17, 0x1F, 
    
    0x01, 0x0B, 0x2A, 0x15, 0x00, 0x1B, 0x06, 0x0D, 0x19, 0x06,         // 11
    0x11, 0x24, 0x14, 0x0E, 0x1D, 0x2C, 0x20, 0x19, 0x0C, 0x13, 
    0x26, 0x0A, 0x03, 0x29, 0x0C, 0x00, 0x2C, 0x1A, 0x03, 0x2E, 
    0x06, 0x29, 0x10, 0x2C, 0x1D, 0x06, 0x29, 0x0F, 0x2C, 0x1E, 
    0x0A, 0x00, 0x19, 0x0D, 0x2F, 0x1B, 0x2C, 0x14, 0x1C, 0x28, 
    0x08, 0x2B, 0x01, 0x21, 0x27, 0x32, 0x03, 0x2A, 0x0C, 0x18, 
    0x06, 0x30, 0x14, 0x08, 0x2D, 0x26, 0x0D, 0x2C, 0x23, 0x32, 
    0x1F, 0x09, 0x27, 0x19, 0x07, 0x10, 0x23, 0x04, 0x14, 0x26, 
    0x20, 0x05, 0x0F, 0x2F, 0x18, 0x20, 0x08, 0x32, 0x04, 0x0E, 0x2F, 
    
    0x14, 0x2D, 0x20, 0x10, 0x2F, 0x2B, 0x16, 0x1F, 0x32, 0x0B,         // 12
    0x2C, 0x18, 0x20, 0x04, 0x27, 0x0A, 0x15, 0x06, 0x2A, 0x1F, 
    0x30, 0x18, 0x21, 0x15, 0x32, 0x11, 0x27, 0x13, 0x20, 0x0F, 
    0x1C, 0x16, 0x1F, 0x02, 0x13, 0x32, 0x17, 0x1C, 0x05, 0x28, 
    0x17, 0x21, 0x29, 0x08, 0x12, 0x02, 0x26, 0x0E, 0x32, 0x0B, 
    0x24, 0x18, 0x30, 0x0B, 0x16, 0x09, 0x1B, 0x13, 0x21, 0x2B, 
    0x11, 0x25, 0x04, 0x28, 0x17, 0x03, 0x13, 0x1B, 0x06, 0x14, 
    0x03, 0x23, 0x2C, 0x0C, 0x21, 0x2F, 0x17, 0x29, 0x1D, 0x0B, 
    0x12, 0x2C, 0x1B, 0x01, 0x24, 0x0B, 0x16, 0x27, 0x13, 0x2A, 0x1C, 
    
    0x24, 0x0E, 0x04, 0x1D, 0x0C, 0x07, 0x26, 0x02, 0x13, 0x27,         // 13
    0x1C, 0x01, 0x0B, 0x31, 0x1A, 0x10, 0x25, 0x2F, 0x12, 0x04, 
    0x0F, 0x09, 0x2C, 0x05, 0x1B, 0x23, 0x06, 0x0C, 0x31, 0x25, 
    0x04, 0x30, 0x09, 0x2B, 0x25, 0x0E, 0x01, 0x22, 0x0D, 0x30, 
    0x12, 0x07, 0x2E, 0x25, 0x20, 0x18, 0x0A, 0x22, 0x04, 0x12, 
    0x1D, 0x06, 0x13, 0x29, 0x1E, 0x11, 0x24, 0x2D, 0x02, 0x0E, 
    0x1F, 0x19, 0x2E, 0x0E, 0x1D, 0x21, 0x30, 0x0A, 0x29, 0x19, 
    0x2E, 0x10, 0x15, 0x1E, 0x01, 0x26, 0x08, 0x0D, 0x30, 0x19, 
    0x06, 0x21, 0x14, 0x27, 0x11, 0x2E, 0x1D, 0x06, 0x21, 0x0B, 0x06, 
    
    0x16, 0x1A, 0x31, 0x25, 0x18, 0x21, 0x10, 0x2D, 0x23, 0x06,         // 14
    0x0F, 0x29, 0x22, 0x11, 0x2B, 0x01, 0x1E, 0x08, 0x1B, 0x22, 
    0x28, 0x1C, 0x12, 0x26, 0x0B, 0x18, 0x2B, 0x1E, 0x07, 0x19, 
    0x13, 0x26, 0x0F, 0x18, 0x0A, 0x1F, 0x2D, 0x27, 0x15, 0x03, 
    0x24, 0x1A, 0x0E, 0x15, 0x06, 0x30, 0x29, 0x1E, 0x18, 0x2E, 
    0x2A, 0x0E, 0x20, 0x03, 0x2F, 0x06, 0x28, 0x0A, 0x1A, 0x31, 
    0x06, 0x0B, 0x21, 0x00, 0x12, 0x27, 0x05, 0x1E, 0x11, 0x26, 
    0x0A, 0x1D, 0x06, 0x31, 0x11, 0x1B, 0x13, 0x20, 0x02, 0x25, 
    0x2B, 0x0D, 0x30, 0x08, 0x1F, 0x03, 0x2A, 0x0E, 0x19, 0x30, 0x27, 
    
    0x02, 0x29, 0x0B, 0x05, 0x12, 0x30, 0x08, 0x19, 0x0B, 0x20,         // 15
    0x18, 0x2D, 0x14, 0x06, 0x20, 0x17, 0x28, 0x0C, 0x2C, 0x15, 
    0x00, 0x2E, 0x07, 0x1E, 0x2E, 0x01, 0x10, 0x15, 0x29, 0x0E, 
    0x2D, 0x01, 0x1D, 0x23, 0x03, 0x1A, 0x12, 0x07, 0x1E, 0x2B, 
    0x0A, 0x1F, 0x02, 0x2C, 0x1D, 0x10, 0x01, 0x13, 0x09, 0x25, 
    0x02, 0x1A, 0x26, 0x0D, 0x15, 0x1A, 0x0F, 0x20, 0x15, 0x24, 
    0x29, 0x14, 0x2B, 0x18, 0x2F, 0x0B, 0x16, 0x2D, 0x0C, 0x20, 
    0x01, 0x2B, 0x25, 0x0A, 0x29, 0x04, 0x2E, 0x27, 0x12, 0x0A, 
    0x17, 0x04, 0x1D, 0x16, 0x2C, 0x0C, 0x14, 0x23, 0x00, 0x1E, 0x10, 
    
    0x2E, 0x1F, 0x14, 0x26, 0x2B, 0x02, 0x1D, 0x29, 0x14, 0x31,         // 16
    0x05, 0x0D, 0x1C, 0x2F, 0x0A, 0x0F, 0x30, 0x13, 0x05, 0x25, 
    0x0D, 0x17, 0x23, 0x0E, 0x15, 0x27, 0x20, 0x2F, 0x03, 0x1C, 
    0x22, 0x0B, 0x29, 0x11, 0x2E, 0x28, 0x0D, 0x31, 0x19, 0x0F, 
    0x26, 0x32, 0x11, 0x23, 0x0A, 0x27, 0x1A, 0x2B, 0x21, 0x0F, 
    0x16, 0x31, 0x09, 0x2C, 0x22, 0x2A, 0x00, 0x2F, 0x08, 0x0F, 
    0x02, 0x1D, 0x07, 0x25, 0x06, 0x1B, 0x24, 0x03, 0x18, 0x30, 
    0x13, 0x18, 0x0E, 0x20, 0x15, 0x23, 0x18, 0x06, 0x1D, 0x31, 
    0x22, 0x29, 0x10, 0x25, 0x06, 0x1A, 0x27, 0x2F, 0x11, 0x2A, 0x09, 
    
    0x1A, 0x0F, 0x07, 0x1C, 0x17, 0x0E, 0x24, 0x11, 0x00, 0x26,         // 17
    0x1E, 0x24, 0x02, 0x27, 0x1A, 0x24, 0x02, 0x21, 0x1D, 0x31, 
    0x1A, 0x2A, 0x06, 0x30, 0x04, 0x1C, 0x08, 0x0C, 0x18, 0x28, 
    0x06, 0x16, 0x31, 0x05, 0x17, 0x08, 0x20, 0x05, 0x23, 0x00, 
    0x15, 0x08, 0x1A, 0x2A, 0x17, 0x06, 0x31, 0x0C, 0x05, 0x2D, 
    0x1E, 0x04, 0x14, 0x1C, 0x05, 0x12, 0x1E, 0x17, 0x28, 0x20, 
    0x19, 0x30, 0x0E, 0x1E, 0x11, 0x29, 0x0F, 0x2B, 0x08, 0x27, 
    0x06, 0x2C, 0x1C, 0x02, 0x30, 0x08, 0x0D, 0x29, 0x0F, 0x16, 
    0x07, 0x1B, 0x01, 0x2F, 0x11, 0x22, 0x09, 0x1B, 0x06, 0x17, 0x25, 
    
    0x03, 0x2B, 0x21, 0x32, 0x09, 0x20, 0x2F, 0x09, 0x2C, 0x17,         // 18
    0x08, 0x12, 0x2C, 0x15, 0x07, 0x12, 0x2D, 0x18, 0x10, 0x0B, 
    0x04, 0x21, 0x12, 0x18, 0x29, 0x11, 0x2C, 0x25, 0x13, 0x30, 
    0x10, 0x1B, 0x20, 0x0C, 0x25, 0x1C, 0x14, 0x2C, 0x10, 0x27, 
    0x1D, 0x2B, 0x0D, 0x02, 0x1F, 0x0F, 0x23, 0x1D, 0x15, 0x26, 
    0x0B, 0x29, 0x21, 0x0E, 0x2E, 0x0A, 0x26, 0x0C, 0x05, 0x2E, 
    0x12, 0x09, 0x27, 0x16, 0x31, 0x01, 0x21, 0x14, 0x1E, 0x1A, 
    0x0F, 0x22, 0x0A, 0x28, 0x11, 0x1D, 0x22, 0x2D, 0x00, 0x20, 
    0x2E, 0x0E, 0x27, 0x15, 0x20, 0x03, 0x2B, 0x0E, 0x20, 0x31, 0x0C, 
    
    0x24, 0x16, 0x11, 0x01, 0x2A, 0x15, 0x04, 0x1A, 0x1F, 0x0F,         // 19
    0x30, 0x19, 0x0A, 0x1E, 0x32, 0x25, 0x0C, 0x07, 0x25, 0x2C, 
    0x14, 0x28, 0x0C, 0x1E, 0x24, 0x07, 0x1A, 0x00, 0x1F, 0x04, 
    0x24, 0x09, 0x28, 0x13, 0x2D, 0x02, 0x29, 0x0B, 0x19, 0x30, 
    0x06, 0x12, 0x22, 0x30, 0x13, 0x2C, 0x03, 0x11, 0x2F, 0x00, 
    0x18, 0x11, 0x2D, 0x02, 0x25, 0x19, 0x31, 0x14, 0x1F, 0x0D, 
    0x24, 0x2B, 0x04, 0x22, 0x08, 0x19, 0x0D, 0x2F, 0x09, 0x25, 
    0x02, 0x32, 0x13, 0x19, 0x25, 0x04, 0x16, 0x11, 0x26, 0x0A, 
    0x13, 0x2B, 0x09, 0x1D, 0x0C, 0x32, 0x16, 0x24, 0x02, 0x12, 0x1D, 
    
    0x2F, 0x05, 0x28, 0x18, 0x1D, 0x0C, 0x25, 0x2A, 0x0B, 0x23,         // 20
    0x02, 0x2A, 0x21, 0x10, 0x04, 0x16, 0x1F, 0x2A, 0x1B, 0x02, 
    0x1E, 0x08, 0x2F, 0x01, 0x0E, 0x32, 0x14, 0x2D, 0x0E, 0x2A, 
    0x15, 0x2E, 0x01, 0x1E, 0x0A, 0x18, 0x24, 0x06, 0x21, 0x0D, 
    0x18, 0x26, 0x04, 0x1C, 0x08, 0x25, 0x18, 0x29, 0x0A, 0x1C, 
    0x24, 0x09, 0x1D, 0x17, 0x10, 0x07, 0x21, 0x03, 0x2C, 0x18, 
    0x01, 0x1A, 0x13, 0x0C, 0x2D, 0x1D, 0x29, 0x04, 0x13, 0x2D, 
    0x16, 0x1E, 0x04, 0x2B, 0x08, 0x2E, 0x0C, 0x1E, 0x2F, 0x18, 
    0x1D, 0x04, 0x21, 0x17, 0x27, 0x06, 0x11, 0x2A, 0x18, 0x2C, 0x09, 
    
    0x0F, 0x1E, 0x0A, 0x25, 0x06, 0x30, 0x10, 0x18, 0x06, 0x13,         // 21
    0x27, 0x0E, 0x06, 0x2E, 0x1B, 0x29, 0x00, 0x14, 0x0F, 0x2E, 
    0x16, 0x23, 0x18, 0x27, 0x16, 0x1F, 0x0B, 0x24, 0x1A, 0x07, 
    0x1D, 0x0F, 0x19, 0x2A, 0x10, 0x32, 0x11, 0x1B, 0x2D, 0x02, 
    0x1F, 0x2E, 0x0E, 0x17, 0x2B, 0x0C, 0x1E, 0x06, 0x22, 0x0E, 
    0x32, 0x27, 0x04, 0x2F, 0x1F, 0x2B, 0x16, 0x10, 0x27, 0x0B, 
    0x20, 0x32, 0x1E, 0x28, 0x17, 0x06, 0x25, 0x18, 0x21, 0x0D, 
    0x27, 0x0B, 0x23, 0x0F, 0x1F, 0x1A, 0x2A, 0x02, 0x0E, 0x07, 
    0x25, 0x30, 0x11, 0x02, 0x2E, 0x1B, 0x21, 0x0C, 0x07, 0x26, 0x1A, 
    
    0x22, 0x2B, 0x13, 0x2D, 0x12, 0x22, 0x01, 0x2C, 0x1D, 0x2E,         // 22
    0x1F, 0x1A, 0x15, 0x24, 0x09, 0x0E, 0x23, 0x31, 0x05, 0x25, 
    0x0B, 0x10, 0x2C, 0x07, 0x22, 0x03, 0x29, 0x05, 0x13, 0x21, 
    0x31, 0x04, 0x25, 0x07, 0x21, 0x03, 0x28, 0x08, 0x14, 0x28, 
    0x16, 0x07, 0x29, 0x20, 0x01, 0x10, 0x2E, 0x14, 0x2B, 0x17, 
    0x06, 0x12, 0x22, 0x13, 0x0C, 0x01, 0x25, 0x1D, 0x09, 0x2D, 
    0x12, 0x07, 0x0E, 0x02, 0x23, 0x10, 0x0A, 0x31, 0x00, 0x1C, 
    0x07, 0x2A, 0x17, 0x30, 0x13, 0x04, 0x25, 0x14, 0x21, 0x2C, 
    0x15, 0x0B, 0x29, 0x24, 0x0D, 0x14, 0x00, 0x30, 0x1E, 0x13, 0x02, 
    
    0x0C, 0x18, 0x01, 0x1F, 0x08, 0x1B, 0x15, 0x27, 0x0F, 0x03,         // 23
    0x0A, 0x31, 0x01, 0x2A, 0x14, 0x2D, 0x18, 0x0A, 0x1E, 0x1A, 
    0x29, 0x03, 0x1F, 0x0F, 0x2F, 0x12, 0x1C, 0x2F, 0x0F, 0x2B, 
    0x0B, 0x20, 0x14, 0x2E, 0x1A, 0x15, 0x1E, 0x2F, 0x0C, 0x1C, 
    0x10, 0x22, 0x0A, 0x14, 0x31, 0x1A, 0x26, 0x03, 0x0A, 0x1E, 
    0x29, 0x19, 0x0A, 0x26, 0x2C, 0x1B, 0x0E, 0x31, 0x05, 0x1A, 
    0x25, 0x2A, 0x19, 0x2F, 0x14, 0x2C, 0x1C, 0x13, 0x24, 0x11, 
    0x2E, 0x1B, 0x02, 0x0C, 0x27, 0x0A, 0x17, 0x32, 0x11, 0x1B, 
    0x01, 0x1F, 0x18, 0x09, 0x1E, 0x2C, 0x24, 0x18, 0x0E, 0x28, 0x2E, 
    
    0x06, 0x23, 0x31, 0x0D, 0x28, 0x2E, 0x0B, 0x07, 0x21, 0x16,         // 24
    0x25, 0x11, 0x21, 0x0D, 0x1D, 0x04, 0x21, 0x11, 0x2B, 0x07, 
    0x13, 0x31, 0x1B, 0x17, 0x09, 0x23, 0x0C, 0x17, 0x27, 0x03, 
    0x18, 0x10, 0x28, 0x09, 0x0D, 0x26, 0x0F, 0x01, 0x24, 0x2B, 
    0x03, 0x2F, 0x1B, 0x0C, 0x24, 0x05, 0x16, 0x1F, 0x30, 0x10, 
    0x01, 0x2E, 0x1D, 0x04, 0x17, 0x0A, 0x29, 0x13, 0x23, 0x16, 
    0x02, 0x0F, 0x22, 0x0C, 0x1E, 0x03, 0x28, 0x06, 0x2B, 0x1F, 
    0x05, 0x14, 0x25, 0x1F, 0x2D, 0x1C, 0x22, 0x08, 0x05, 0x26, 
    0x0E, 0x2B, 0x06, 0x31, 0x12, 0x04, 0x0B, 0x29, 0x03, 0x1F, 0x15, 
    
    0x2C, 0x0F, 0x1D, 0x05, 0x17, 0x10, 0x23, 0x32, 0x19, 0x2A,         // 25
    0x05, 0x2C, 0x1A, 0x06, 0x28, 0x13, 0x30, 0x02, 0x25, 0x17, 
    0x21, 0x0A, 0x26, 0x01, 0x28, 0x2D, 0x04, 0x1F, 0x09, 0x23, 
    0x1C, 0x30, 0x01, 0x1E, 0x2C, 0x05, 0x2E, 0x19, 0x1F, 0x08, 
    0x19, 0x26, 0x05, 0x2B, 0x1D, 0x10, 0x2D, 0x0C, 0x25, 0x18, 
    0x22, 0x08, 0x28, 0x10, 0x30, 0x22, 0x02, 0x1E, 0x0C, 0x28, 
    0x2F, 0x1D, 0x05, 0x29, 0x08, 0x25, 0x0F, 0x1A, 0x09, 0x0E, 
    0x27, 0x31, 0x0F, 0x07, 0x12, 0x01, 0x0D, 0x2A, 0x1E, 0x2E, 
    0x16, 0x23, 0x10, 0x1A, 0x27, 0x20, 0x1C, 0x15, 0x32, 0x09, 0x1B, 
    
    0x0B, 0x29, 0x16, 0x2C, 0x25, 0x02, 0x1C, 0x04, 0x11, 0x0C,         // 26
    0x1F, 0x15, 0x0F, 0x2E, 0x24, 0x08, 0x1A, 0x1F, 0x0D, 0x2E, 
    0x03, 0x11, 0x2C, 0x0D, 0x1C, 0x13, 0x19, 0x31, 0x12, 0x2C, 
    0x07, 0x0E, 0x24, 0x15, 0x1B, 0x23, 0x14, 0x07, 0x11, 0x31, 
    0x15, 0x0E, 0x20, 0x12, 0x07, 0x28, 0x08, 0x1B, 0x05, 0x12, 
    0x2C, 0x0D, 0x16, 0x1F, 0x08, 0x12, 0x19, 0x2E, 0x06, 0x11, 
    0x09, 0x15, 0x2D, 0x13, 0x19, 0x31, 0x15, 0x22, 0x2E, 0x16, 
    0x1D, 0x02, 0x19, 0x2B, 0x17, 0x2F, 0x25, 0x18, 0x13, 0x0B, 
    0x03, 0x1C, 0x2C, 0x01, 0x0C, 0x2F, 0x10, 0x06, 0x21, 0x10, 0x26, 
    
    0x1F, 0x04, 0x12, 0x09, 0x1E, 0x2D, 0x13, 0x28, 0x22, 0x2F,         // 27
    0x08, 0x27, 0x03, 0x1D, 0x16, 0x0E, 0x2A, 0x11, 0x05, 0x28, 
    0x1B, 0x24, 0x16, 0x20, 0x08, 0x26, 0x0E, 0x21, 0x00, 0x17, 
    0x27, 0x1A, 0x2E, 0x04, 0x11, 0x09, 0x2A, 0x21, 0x27, 0x0B, 
    0x29, 0x01, 0x2C, 0x17, 0x31, 0x1E, 0x14, 0x27, 0x2F, 0x1E, 
    0x03, 0x1B, 0x2F, 0x01, 0x29, 0x24, 0x0B, 0x26, 0x2B, 0x1B, 
    0x20, 0x26, 0x03, 0x24, 0x09, 0x1F, 0x0D, 0x01, 0x27, 0x07, 
    0x22, 0x0C, 0x28, 0x23, 0x0B, 0x20, 0x0F, 0x03, 0x31, 0x23, 
    0x29, 0x09, 0x14, 0x26, 0x19, 0x07, 0x23, 0x2A, 0x18, 0x2D, 0x02, 
    
    0x25, 0x1A, 0x31, 0x22, 0x0F, 0x08, 0x18, 0x0C, 0x06, 0x1C,         // 28
    0x17, 0x2C, 0x23, 0x0A, 0x31, 0x00, 0x22, 0x2D, 0x1D, 0x14, 
    0x0C, 0x2F, 0x06, 0x10, 0x30, 0x03, 0x2B, 0x0B, 0x2A, 0x1E, 
    0x05, 0x11, 0x0A, 0x29, 0x20, 0x31, 0x0E, 0x16, 0x04, 0x1A, 
    0x22, 0x1C, 0x09, 0x23, 0x03, 0x0D, 0x22, 0x00, 0x17, 0x0E, 
    0x29, 0x24, 0x0B, 0x14, 0x1A, 0x31, 0x04, 0x16, 0x13, 0x00, 
    0x32, 0x0D, 0x1A, 0x10, 0x2E, 0x05, 0x2A, 0x1B, 0x12, 0x2F, 
    0x10, 0x2C, 0x13, 0x04, 0x1C, 0x07, 0x2D, 0x1D, 0x07, 0x1A, 
    0x0E, 0x21, 0x30, 0x0F, 0x20, 0x2D, 0x13, 0x01, 0x0A, 0x1D, 0x14, 
    
    0x07, 0x0C, 0x28, 0x00, 0x1B, 0x25, 0x30, 0x1F, 0x2A, 0x13,         // 29
    0x01, 0x0D, 0x19, 0x12, 0x28, 0x1B, 0x09, 0x17, 0x07, 0x26, 
    0x04, 0x1A, 0x22, 0x2A, 0x17, 0x23, 0x15, 0x1B, 0x07, 0x13, 
    0x2F, 0x21, 0x16, 0x1D, 0x06, 0x19, 0x00, 0x1D, 0x2E, 0x13, 
    0x06, 0x30, 0x18, 0x13, 0x27, 0x1A, 0x12, 0x2D, 0x0A, 0x21, 
    0x16, 0x07, 0x2D, 0x21, 0x05, 0x11, 0x1C, 0x20, 0x0D, 0x24, 
    0x18, 0x06, 0x2B, 0x1E, 0x15, 0x23, 0x17, 0x07, 0x20, 0x03, 
    0x18, 0x0A, 0x1E, 0x32, 0x10, 0x25, 0x14, 0x28, 0x11, 0x2C, 
    0x15, 0x04, 0x1C, 0x06, 0x17, 0x0B, 0x28, 0x1E, 0x30, 0x0F, 0x29, 
    
    0x2F, 0x1F, 0x12, 0x17, 0x2B, 0x05, 0x15, 0x03, 0x0F, 0x24,         // 30
    0x31, 0x20, 0x2A, 0x07, 0x1F, 0x10, 0x26, 0x0E, 0x30, 0x20, 
    0x2B, 0x13, 0x0D, 0x01, 0x1C, 0x07, 0x0F, 0x31, 0x20, 0x25, 
    0x0D, 0x29, 0x01, 0x2E, 0x10, 0x27, 0x2C, 0x24, 0x0B, 0x2A, 
    0x0F, 0x26, 0x0A, 0x2C, 0x04, 0x2F, 0x06, 0x25, 0x2A, 0x05, 
    0x32, 0x12, 0x1C, 0x0E, 0x28, 0x23, 0x08, 0x2E, 0x28, 0x07, 
    0x2D, 0x12, 0x27, 0x01, 0x0E, 0x2C, 0x0A, 0x31, 0x26, 0x1C, 
    0x2A, 0x24, 0x05, 0x16, 0x28, 0x00, 0x18, 0x0B, 0x20, 0x02, 
    0x26, 0x2E, 0x0B, 0x2A, 0x24, 0x04, 0x1B, 0x14, 0x24, 0x06, 0x16, 
    
    0x10, 0x05, 0x2D, 0x08, 0x1F, 0x11, 0x27, 0x19, 0x2D, 0x1D,         // 31
    0x09, 0x13, 0x04, 0x2E, 0x16, 0x03, 0x2B, 0x1D, 0x01, 0x11, 
    0x0A, 0x1E, 0x32, 0x25, 0x12, 0x2E, 0x26, 0x02, 0x0B, 0x16, 
    0x04, 0x1A, 0x12, 0x24, 0x09, 0x15, 0x07, 0x18, 0x05, 0x22, 
    0x17, 0x02, 0x1F, 0x0F, 0x21, 0x15, 0x1D, 0x0F, 0x19, 0x11, 
    0x1E, 0x02, 0x2B, 0x17, 0x0A, 0x2D, 0x15, 0x03, 0x1A, 0x10, 
    0x21, 0x1C, 0x0C, 0x20, 0x28, 0x04, 0x1D, 0x12, 0x0D, 0x15, 
    0x06, 0x12, 0x2E, 0x21, 0x0A, 0x2F, 0x23, 0x06, 0x30, 0x0D, 
    0x19, 0x10, 0x1F, 0x13, 0x32, 0x10, 0x2D, 0x03, 0x0D, 0x2B, 0x22, 
    
    0x1B, 0x27, 0x19, 0x24, 0x0C, 0x30, 0x09, 0x21, 0x0C, 0x03,         // 32
    0x18, 0x26, 0x1C, 0x0D, 0x21, 0x31, 0x0B, 0x14, 0x25, 0x19, 
    0x29, 0x03, 0x17, 0x08, 0x29, 0x09, 0x1E, 0x18, 0x2C, 0x27, 
    0x1E, 0x32, 0x0B, 0x2A, 0x1C, 0x21, 0x0E, 0x1E, 0x32, 0x11, 
    0x1D, 0x2F, 0x29, 0x1A, 0x09, 0x2A, 0x08, 0x22, 0x03, 0x2E, 
    0x24, 0x0C, 0x25, 0x05, 0x1F, 0x19, 0x0E, 0x27, 0x0B, 0x30, 
    0x02, 0x17, 0x07, 0x31, 0x1A, 0x14, 0x22, 0x2A, 0x08, 0x27, 
    0x2D, 0x0C, 0x1B, 0x03, 0x0F, 0x19, 0x1E, 0x2A, 0x15, 0x1D, 
    0x24, 0x06, 0x28, 0x01, 0x1C, 0x08, 0x1F, 0x27, 0x18, 0x1D, 0x03, 
    
    0x32, 0x0E, 0x02, 0x2B, 0x15, 0x1C, 0x01, 0x29, 0x14, 0x23,         // 33
    0x2E, 0x0F, 0x29, 0x14, 0x06, 0x1B, 0x23, 0x05, 0x2F, 0x07, 
    0x21, 0x2E, 0x0C, 0x1B, 0x20, 0x15, 0x0E, 0x23, 0x12, 0x06, 
    0x0E, 0x21, 0x06, 0x18, 0x03, 0x30, 0x29, 0x02, 0x0D, 0x25, 
    0x06, 0x0B, 0x12, 0x03, 0x26, 0x10, 0x31, 0x17, 0x27, 0x0A, 
    0x18, 0x14, 0x30, 0x11, 0x2A, 0x00, 0x2F, 0x22, 0x1E, 0x13, 
    0x29, 0x23, 0x2B, 0x12, 0x0C, 0x07, 0x2E, 0x03, 0x1A, 0x1F, 
    0x01, 0x22, 0x15, 0x2B, 0x26, 0x13, 0x07, 0x10, 0x01, 0x2C, 
    0x09, 0x30, 0x15, 0x23, 0x11, 0x2B, 0x16, 0x0F, 0x07, 0x2C, 0x0A, 
    
    0x16, 0x1F, 0x13, 0x22, 0x05, 0x2C, 0x11, 0x18, 0x30, 0x06,         // 34
    0x1E, 0x0A, 0x00, 0x2F, 0x25, 0x0F, 0x17, 0x2B, 0x0D, 0x1D, 
    0x0F, 0x16, 0x24, 0x05, 0x30, 0x01, 0x2B, 0x08, 0x30, 0x19, 
    0x2A, 0x14, 0x2E, 0x26, 0x10, 0x15, 0x24, 0x14, 0x2C, 0x19, 
    0x29, 0x16, 0x22, 0x30, 0x18, 0x20, 0x01, 0x0E, 0x1C, 0x2C, 
    0x06, 0x22, 0x1C, 0x08, 0x21, 0x1B, 0x09, 0x11, 0x04, 0x19, 
    0x09, 0x10, 0x04, 0x1E, 0x2D, 0x25, 0x17, 0x10, 0x2F, 0x0E, 
    0x18, 0x31, 0x07, 0x1E, 0x0A, 0x2E, 0x22, 0x27, 0x18, 0x20, 
    0x0E, 0x1B, 0x05, 0x2D, 0x09, 0x26, 0x02, 0x31, 0x21, 0x13, 0x25, 
    
    0x2B, 0x0B, 0x2F, 0x09, 0x1E, 0x0D, 0x25, 0x1F, 0x0B, 0x11,         // 35
    0x2A, 0x17, 0x22, 0x1A, 0x08, 0x29, 0x02, 0x20, 0x13, 0x26, 
    0x00, 0x2B, 0x12, 0x28, 0x1A, 0x13, 0x25, 0x1C, 0x03, 0x1F, 
    0x0C, 0x00, 0x1C, 0x0D, 0x20, 0x08, 0x1C, 0x06, 0x20, 0x0B, 
    0x00, 0x2D, 0x1C, 0x06, 0x0C, 0x13, 0x2D, 0x23, 0x07, 0x11, 
    0x26, 0x01, 0x0E, 0x2E, 0x13, 0x29, 0x16, 0x25, 0x2C, 0x23, 
    0x31, 0x1B, 0x26, 0x15, 0x02, 0x1F, 0x0A, 0x27, 0x20, 0x08, 
    0x26, 0x13, 0x23, 0x10, 0x1A, 0x05, 0x15, 0x0C, 0x31, 0x06, 
    0x25, 0x2B, 0x10, 0x1E, 0x18, 0x0C, 0x1C, 0x29, 0x0A, 0x1C, 0x00, 
    
    0x20, 0x06, 0x1A, 0x27, 0x17, 0x31, 0x08, 0x03, 0x28, 0x1C,         // 36
    0x03, 0x32, 0x12, 0x0C, 0x2C, 0x1C, 0x10, 0x2E, 0x08, 0x1A, 
    0x31, 0x0A, 0x1E, 0x0E, 0x08, 0x2E, 0x0A, 0x0F, 0x15, 0x2E, 
    0x26, 0x17, 0x2B, 0x05, 0x2F, 0x28, 0x0F, 0x31, 0x12, 0x27, 
    0x1E, 0x12, 0x0E, 0x27, 0x2B, 0x1D, 0x05, 0x29, 0x15, 0x31, 
    0x1B, 0x2B, 0x16, 0x26, 0x03, 0x0C, 0x32, 0x06, 0x0B, 0x17, 
    0x01, 0x0C, 0x2E, 0x08, 0x2A, 0x12, 0x1C, 0x01, 0x15, 0x2C, 
    0x03, 0x0C, 0x2C, 0x00, 0x2F, 0x20, 0x2B, 0x03, 0x1D, 0x12, 
    0x18, 0x0A, 0x22, 0x03, 0x30, 0x21, 0x12, 0x04, 0x18, 0x2F, 0x11, 
    
    0x28, 0x14, 0x2C, 0x0F, 0x04, 0x12, 0x1A, 0x2B, 0x15, 0x23,         // 37
    0x13, 0x26, 0x04, 0x1F, 0x16, 0x05, 0x22, 0x18, 0x2A, 0x05, 
    0x21, 0x19, 0x03, 0x2C, 0x20, 0x18, 0x29, 0x21, 0x2B, 0x05, 
    0x1D, 0x08, 0x22, 0x13, 0x1A, 0x01, 0x17, 0x25, 0x03, 0x19, 
    0x2F, 0x04, 0x21, 0x17, 0x02, 0x24, 0x17, 0x0B, 0x20, 0x03, 
    0x10, 0x0A, 0x1F, 0x07, 0x23, 0x19, 0x21, 0x1C, 0x12, 0x20, 
    0x2B, 0x13, 0x20, 0x18, 0x22, 0x0B, 0x32, 0x29, 0x0F, 0x1A, 
    0x1F, 0x29, 0x1D, 0x18, 0x27, 0x0D, 0x19, 0x11, 0x2D, 0x27, 
    0x00, 0x2E, 0x13, 0x29, 0x0F, 0x06, 0x2C, 0x27, 0x0F, 0x23, 0x05, 
    
    0x0D, 0x1E, 0x02, 0x21, 0x2D, 0x26, 0x20, 0x0E, 0x2E, 0x08,         // 38
    0x0D, 0x1D, 0x2D, 0x10, 0x24, 0x30, 0x0A, 0x0D, 0x1E, 0x13, 
    0x0E, 0x29, 0x14, 0x25, 0x05, 0x12, 0x01, 0x1A, 0x09, 0x14, 
    0x0D, 0x2D, 0x10, 0x26, 0x0A, 0x2C, 0x1F, 0x0D, 0x2B, 0x09, 
    0x15, 0x25, 0x0B, 0x32, 0x11, 0x09, 0x2F, 0x10, 0x1B, 0x29, 
    0x22, 0x18, 0x30, 0x14, 0x2A, 0x10, 0x01, 0x28, 0x2D, 0x0E, 
    0x07, 0x27, 0x04, 0x0E, 0x2C, 0x17, 0x05, 0x23, 0x07, 0x2F, 
    0x0E, 0x16, 0x07, 0x0A, 0x13, 0x04, 0x26, 0x08, 0x22, 0x0D, 
    0x1B, 0x1F, 0x07, 0x17, 0x26, 0x1B, 0x14, 0x1D, 0x08, 0x2D, 0x1A, 
    
    0x31, 0x26, 0x17, 0x08, 0x1B, 0x0B, 0x00, 0x17, 0x06, 0x1F,         // 39
    0x30, 0x16, 0x07, 0x29, 0x02, 0x14, 0x2B, 0x23, 0x01, 0x30, 
    0x24, 0x06, 0x2F, 0x0B, 0x1C, 0x30, 0x27, 0x0E, 0x32, 0x23, 
    0x28, 0x19, 0x02, 0x31, 0x16, 0x21, 0x04, 0x13, 0x1C, 0x22, 
    0x0F, 0x2C, 0x07, 0x1A, 0x29, 0x1E, 0x26, 0x04, 0x2D, 0x0C, 
    0x07, 0x27, 0x02, 0x0D, 0x1B, 0x2F, 0x0A, 0x18, 0x04, 0x23, 
    0x1B, 0x15, 0x30, 0x1D, 0x02, 0x26, 0x10, 0x1E, 0x14, 0x24, 
    0x04, 0x27, 0x2D, 0x22, 0x31, 0x1E, 0x2A, 0x1B, 0x14, 0x06, 
    0x2B, 0x10, 0x30, 0x21, 0x01, 0x0D, 0x32, 0x03, 0x20, 0x12, 0x0A, 
    
    0x04, 0x10, 0x2E, 0x14, 0x2A, 0x11, 0x2F, 0x23, 0x29, 0x1A,         // 40
    0x01, 0x26, 0x0B, 0x19, 0x1F, 0x08, 0x1B, 0x12, 0x29, 0x17, 
    0x09, 0x1F, 0x19, 0x11, 0x23, 0x0C, 0x15, 0x20, 0x04, 0x17, 
    0x06, 0x20, 0x0C, 0x1E, 0x06, 0x11, 0x2F, 0x28, 0x08, 0x31, 
    0x01, 0x1E, 0x13, 0x23, 0x0C, 0x01, 0x18, 0x21, 0x13, 0x1A, 
    0x2E, 0x11, 0x21, 0x2C, 0x08, 0x25, 0x1F, 0x13, 0x31, 0x0B, 
    0x2C, 0x0F, 0x24, 0x09, 0x14, 0x2E, 0x1A, 0x0B, 0x2C, 0x09, 
    0x1C, 0x12, 0x01, 0x19, 0x10, 0x0B, 0x15, 0x02, 0x32, 0x26, 
    0x16, 0x03, 0x1A, 0x0B, 0x2B, 0x1E, 0x25, 0x0B, 0x18, 0x2B, 0x23, 
    
    0x1B, 0x20, 0x0C, 0x24, 0x04, 0x1F, 0x18, 0x0F, 0x0A, 0x14,         // 41
    0x2B, 0x11, 0x21, 0x31, 0x0E, 0x26, 0x2F, 0x06, 0x0C, 0x1D, 
    0x10, 0x28, 0x00, 0x2A, 0x07, 0x2C, 0x02, 0x1C, 0x2B, 0x10, 
    0x2F, 0x12, 0x2C, 0x24, 0x19, 0x26, 0x07, 0x17, 0x24, 0x12, 
    0x19, 0x28, 0x04, 0x2D, 0x15, 0x30, 0x0F, 0x08, 0x28, 0x00, 
    0x1F, 0x16, 0x05, 0x1D, 0x15, 0x04, 0x0D, 0x29, 0x21, 0x19, 
    0x00, 0x1E, 0x0C, 0x2A, 0x20, 0x0D, 0x24, 0x00, 0x28, 0x17, 
    0x31, 0x20, 0x0D, 0x25, 0x2B, 0x07, 0x2E, 0x24, 0x10, 0x1E, 
    0x09, 0x24, 0x29, 0x11, 0x18, 0x08, 0x10, 0x2E, 0x27, 0x01, 0x15, 
    
    0x08, 0x2C, 0x01, 0x1A, 0x30, 0x08, 0x28, 0x02, 0x32, 0x24,         // 42
    0x06, 0x1E, 0x04, 0x28, 0x12, 0x01, 0x19, 0x21, 0x2D, 0x25, 
    0x05, 0x32, 0x13, 0x1E, 0x18, 0x22, 0x12, 0x24, 0x0B, 0x27, 
    0x07, 0x1D, 0x04, 0x13, 0x0B, 0x2B, 0x0E, 0x1F, 0x03, 0x2A, 
    0x0E, 0x21, 0x0A, 0x1B, 0x07, 0x28, 0x23, 0x1C, 0x2F, 0x10, 
    0x0A, 0x26, 0x32, 0x0F, 0x28, 0x2E, 0x19, 0x03, 0x11, 0x09, 
    0x28, 0x13, 0x31, 0x03, 0x19, 0x06, 0x30, 0x15, 0x21, 0x0F, 
    0x03, 0x29, 0x17, 0x05, 0x1D, 0x18, 0x21, 0x0C, 0x06, 0x18, 
    0x2C, 0x0E, 0x1D, 0x05, 0x30, 0x22, 0x1C, 0x06, 0x12, 0x1E, 0x2F, 
    
    0x23, 0x13, 0x27, 0x0E, 0x15, 0x22, 0x13, 0x1B, 0x20, 0x0B,         // 43
    0x19, 0x2E, 0x0C, 0x17, 0x1D, 0x2E, 0x0B, 0x14, 0x03, 0x12, 
    0x19, 0x20, 0x09, 0x2D, 0x04, 0x0D, 0x31, 0x07, 0x1A, 0x14, 
    0x22, 0x17, 0x28, 0x2F, 0x00, 0x1C, 0x14, 0x30, 0x0B, 0x1B, 
    0x05, 0x30, 0x11, 0x2A, 0x1E, 0x0D, 0x03, 0x12, 0x18, 0x23, 
    0x2C, 0x06, 0x18, 0x09, 0x1F, 0x10, 0x23, 0x2B, 0x1D, 0x2F, 
    0x23, 0x05, 0x17, 0x26, 0x11, 0x29, 0x1B, 0x0E, 0x07, 0x27, 
    0x1A, 0x08, 0x2E, 0x11, 0x27, 0x01, 0x12, 0x1B, 0x2F, 0x27, 
    0x13, 0x01, 0x2E, 0x24, 0x14, 0x02, 0x29, 0x16, 0x22, 0x0A, 0x0F, 
    
    0x17, 0x06, 0x1D, 0x2D, 0x0A, 0x2A, 0x07, 0x2C, 0x04, 0x12,         // 44
    0x28, 0x10, 0x23, 0x08, 0x2A, 0x06, 0x24, 0x2A, 0x1D, 0x2F, 
    0x0B, 0x27, 0x18, 0x10, 0x26, 0x1C, 0x14, 0x27, 0x2C, 0x04, 
    0x30, 0x09, 0x0D, 0x1A, 0x21, 0x2C, 0x05, 0x27, 0x16, 0x2C, 
    0x1F, 0x16, 0x23, 0x00, 0x17, 0x21, 0x2C, 0x26, 0x04, 0x0C, 
    0x14, 0x1D, 0x24, 0x2B, 0x02, 0x16, 0x0B, 0x06, 0x15, 0x0E, 
    0x1A, 0x0A, 0x2D, 0x1D, 0x08, 0x21, 0x04, 0x2B, 0x1D, 0x2F, 
    0x13, 0x22, 0x0B, 0x23, 0x31, 0x0E, 0x2B, 0x25, 0x03, 0x0E, 
    0x20, 0x1A, 0x09, 0x10, 0x2B, 0x1A, 0x0D, 0x30, 0x05, 0x2C, 0x28, 
    
    0x21, 0x32, 0x11, 0x04, 0x1F, 0x19, 0x0D, 0x25, 0x16, 0x2F,         // 45
    0x1D, 0x00, 0x2B, 0x13, 0x1F, 0x0F, 0x19, 0x11, 0x08, 0x28, 
    0x0F, 0x06, 0x2E, 0x02, 0x2B, 0x08, 0x21, 0x00, 0x0E, 0x1F, 
    0x12, 0x2A, 0x23, 0x13, 0x07, 0x0C, 0x1F, 0x10, 0x01, 0x24, 
    0x07, 0x0D, 0x2D, 0x10, 0x31, 0x06, 0x15, 0x0A, 0x31, 0x1F, 
    0x29, 0x01, 0x12, 0x0D, 0x2F, 0x1C, 0x25, 0x31, 0x21, 0x02, 
    0x2B, 0x1F, 0x0F, 0x15, 0x2F, 0x0C, 0x13, 0x24, 0x17, 0x0A, 
    0x01, 0x2B, 0x1B, 0x03, 0x17, 0x22, 0x0A, 0x15, 0x1F, 0x08, 
    0x2F, 0x26, 0x16, 0x21, 0x0B, 0x1F, 0x04, 0x24, 0x1A, 0x14, 0x03, 
    
    0x19, 0x0B, 0x29, 0x16, 0x26, 0x02, 0x31, 0x1A, 0x0F, 0x07,         // 46
    0x26, 0x0D, 0x19, 0x31, 0x03, 0x27, 0x30, 0x01, 0x21, 0x15, 
    0x1C, 0x23, 0x14, 0x20, 0x1B, 0x12, 0x2F, 0x16, 0x1A, 0x26, 
    0x06, 0x1C, 0x02, 0x27, 0x32, 0x16, 0x26, 0x1A, 0x2E, 0x12, 
    0x1A, 0x28, 0x09, 0x1C, 0x26, 0x0E, 0x1B, 0x22, 0x10, 0x1A, 
    0x0A, 0x2E, 0x1A, 0x20, 0x27, 0x05, 0x11, 0x08, 0x17, 0x27, 
    0x12, 0x07, 0x29, 0x01, 0x25, 0x1A, 0x2E, 0x02, 0x10, 0x26, 
    0x1F, 0x16, 0x0F, 0x2C, 0x09, 0x1D, 0x05, 0x30, 0x19, 0x24, 
    0x12, 0x04, 0x2C, 0x06, 0x32, 0x13, 0x28, 0x10, 0x08, 0x26, 0x0D, 
    
    0x2E, 0x00, 0x22, 0x08, 0x2E, 0x11, 0x1E, 0x06, 0x22, 0x2C,         // 47
    0x15, 0x21, 0x06, 0x24, 0x0B, 0x15, 0x0D, 0x1D, 0x2C, 0x07, 
    0x30, 0x03, 0x28, 0x0E, 0x07, 0x24, 0x0C, 0x29, 0x07, 0x31, 
    0x0C, 0x2C, 0x17, 0x0E, 0x1F, 0x04, 0x2C, 0x0D, 0x09, 0x1F, 
    0x31, 0x02, 0x21, 0x14, 0x03, 0x2A, 0x2E, 0x01, 0x28, 0x06, 
    0x15, 0x25, 0x04, 0x0A, 0x13, 0x2C, 0x1A, 0x2B, 0x1D, 0x0A, 
    0x2F, 0x18, 0x21, 0x0C, 0x1D, 0x05, 0x14, 0x1F, 0x2C, 0x0C, 
    0x32, 0x06, 0x28, 0x21, 0x13, 0x2E, 0x27, 0x11, 0x02, 0x29, 
    0x0A, 0x1F, 0x0D, 0x1B, 0x24, 0x09, 0x17, 0x2F, 0x1F, 0x2B, 0x1D, 
    
    0x12, 0x28, 0x14, 0x1C, 0x0C, 0x18, 0x2A, 0x27, 0x0E, 0x02,         // 48
    0x1B, 0x0A, 0x2A, 0x10, 0x1C, 0x2B, 0x23, 0x0A, 0x13, 0x26, 
    0x0F, 0x18, 0x0A, 0x31, 0x17, 0x2B, 0x04, 0x1E, 0x15, 0x21, 
    0x13, 0x1F, 0x09, 0x29, 0x19, 0x0B, 0x13, 0x23, 0x2B, 0x06, 
    0x16, 0x11, 0x2B, 0x0B, 0x18, 0x22, 0x0A, 0x17, 0x1E, 0x2F, 
    0x21, 0x0F, 0x31, 0x17, 0x23, 0x00, 0x0B, 0x20, 0x04, 0x14, 
    0x23, 0x04, 0x2D, 0x16, 0x31, 0x27, 0x0A, 0x29, 0x06, 0x19, 
    0x13, 0x1E, 0x0A, 0x1A, 0x00, 0x0D, 0x1B, 0x22, 0x0C, 0x1D, 
    0x2F, 0x15, 0x28, 0x11, 0x03, 0x2D, 0x1D, 0x01, 0x0B, 0x16, 0x06, 
    
    0x25, 0x1A, 0x05, 0x2C, 0x25, 0x01, 0x0A, 0x13, 0x19, 0x31,         // 49
    0x27, 0x13, 0x2F, 0x1F, 0x02, 0x18, 0x06, 0x2E, 0x1A, 0x04, 
    0x1F, 0x2C, 0x1D, 0x23, 0x01, 0x1C, 0x11, 0x2F, 0x0B, 0x01, 
    0x28, 0x10, 0x2F, 0x03, 0x24, 0x30, 0x1D, 0x01, 0x19, 0x27, 
    0x0B, 0x1C, 0x24, 0x2F, 0x1E, 0x06, 0x11, 0x29, 0x0D, 0x14, 
    0x05, 0x1C, 0x2A, 0x07, 0x1E, 0x2E, 0x0F, 0x25, 0x31, 0x10, 
    0x2A, 0x1D, 0x13, 0x06, 0x0F, 0x21, 0x17, 0x10, 0x1D, 0x25, 
    0x02, 0x2D, 0x10, 0x30, 0x23, 0x29, 0x06, 0x16, 0x2C, 0x06, 
    0x19, 0x00, 0x2D, 0x22, 0x18, 0x0E, 0x25, 0x13, 0x22, 0x2D, 0x0C, 
    
    0x03, 0x31, 0x0A, 0x1F, 0x12, 0x30, 0x20, 0x2B, 0x05, 0x1D,         // 50
    0x0C, 0x03, 0x17, 0x09, 0x24, 0x32, 0x15, 0x0F, 0x21, 0x29, 
    0x0B, 0x10, 0x05, 0x13, 0x2D, 0x0D, 0x27, 0x19, 0x24, 0x2D, 
    0x1C, 0x05, 0x22, 0x16, 0x10, 0x06, 0x2B, 0x14, 0x0E, 0x20, 
    0x2D, 0x05, 0x10, 0x07, 0x13, 0x26, 0x32, 0x1A, 0x03, 0x24, 
    0x2C, 0x0B, 0x13, 0x27, 0x0D, 0x15, 0x29, 0x16, 0x09, 0x1A, 
    0x02, 0x0D, 0x24, 0x2B, 0x1C, 0x08, 0x2D, 0x03, 0x30, 0x0D, 
    0x29, 0x22, 0x04, 0x17, 0x08, 0x14, 0x32, 0x0E, 0x27, 0x20, 
    0x10, 0x24, 0x0C, 0x06, 0x1F, 0x2A, 0x09, 0x31, 0x05, 0x19, 0x20, 
    
    0x10, 0x16, 0x29, 0x0E, 0x19, 0x08, 0x1C, 0x0E, 0x22, 0x12,         // 51
    0x23, 0x2E, 0x1C, 0x28, 0x0D, 0x04, 0x1E, 0x25, 0x01, 0x16, 
    0x31, 0x23, 0x19, 0x28, 0x0B, 0x20, 0x05, 0x13, 0x07, 0x0F, 
    0x17, 0x27, 0x0A, 0x1B, 0x29, 0x20, 0x0A, 0x26, 0x31, 0x03, 
    0x1B, 0x29, 0x22, 0x19, 0x2A, 0x01, 0x0E, 0x20, 0x2D, 0x09, 
    0x18, 0x20, 0x01, 0x1A, 0x30, 0x05, 0x1C, 0x02, 0x20, 0x27, 
    0x2E, 0x18, 0x09, 0x27, 0x01, 0x19, 0x28, 0x13, 0x21, 0x17, 
    0x09, 0x14, 0x1F, 0x2A, 0x0E, 0x1C, 0x21, 0x02, 0x1B, 0x09, 
    0x31, 0x15, 0x1B, 0x2F, 0x14, 0x02, 0x1B, 0x15, 0x28, 0x0E, 0x2B, 
    
    0x1D, 0x07, 0x22, 0x03, 0x26, 0x2A, 0x04, 0x17, 0x2F, 0x09,         // 52
    0x2B, 0x06, 0x0F, 0x16, 0x2D, 0x13, 0x2A, 0x0C, 0x2D, 0x08, 
    0x1B, 0x02, 0x2E, 0x08, 0x17, 0x30, 0x1B, 0x29, 0x32, 0x21, 
    0x09, 0x2C, 0x13, 0x31, 0x01, 0x0F, 0x17, 0x1D, 0x09, 0x12, 
    0x16, 0x0C, 0x03, 0x30, 0x0B, 0x1D, 0x17, 0x06, 0x12, 0x28, 
    0x0F, 0x30, 0x25, 0x0C, 0x1F, 0x0A, 0x24, 0x2D, 0x0C, 0x13, 
    0x06, 0x1F, 0x31, 0x11, 0x20, 0x0D, 0x23, 0x07, 0x1B, 0x03, 
    0x2F, 0x1C, 0x0B, 0x24, 0x2E, 0x05, 0x29, 0x11, 0x2E, 0x13, 
    0x03, 0x26, 0x0A, 0x28, 0x0D, 0x2C, 0x23, 0x0A, 0x1E, 0x01, 0x25, 
    
    0x18, 0x2E, 0x13, 0x30, 0x15, 0x0B, 0x2D, 0x23, 0x00, 0x1C,         // 53
    0x14, 0x1F, 0x27, 0x01, 0x22, 0x1C, 0x07, 0x18, 0x1F, 0x13, 
    0x25, 0x11, 0x1F, 0x0F, 0x25, 0x00, 0x0E, 0x1F, 0x03, 0x14, 
    0x1D, 0x02, 0x23, 0x0B, 0x1D, 0x2E, 0x24, 0x05, 0x2C, 0x21, 
    0x2F, 0x27, 0x13, 0x20, 0x15, 0x27, 0x2E, 0x23, 0x1B, 0x02, 
    0x1E, 0x0A, 0x16, 0x2C, 0x12, 0x2A, 0x16, 0x10, 0x1C, 0x2B, 
    0x23, 0x0E, 0x03, 0x17, 0x2C, 0x15, 0x31, 0x0B, 0x2B, 0x25, 
    0x0F, 0x29, 0x01, 0x12, 0x1B, 0x09, 0x16, 0x23, 0x0C, 0x1E, 
    0x2B, 0x20, 0x05, 0x16, 0x1D, 0x04, 0x0F, 0x30, 0x13, 0x2D, 0x09, 
    
    0x26, 0x02, 0x1E, 0x08, 0x1B, 0x21, 0x10, 0x14, 0x28, 0x0D,         // 54
    0x25, 0x0A, 0x1A, 0x31, 0x11, 0x0B, 0x26, 0x30, 0x05, 0x2B, 
    0x0A, 0x28, 0x04, 0x1C, 0x2B, 0x15, 0x27, 0x17, 0x0C, 0x26, 
    0x2E, 0x11, 0x19, 0x28, 0x15, 0x06, 0x2A, 0x14, 0x1B, 0x0B, 
    0x00, 0x1D, 0x0D, 0x2D, 0x08, 0x03, 0x11, 0x0B, 0x31, 0x26, 
    0x14, 0x2B, 0x03, 0x1B, 0x06, 0x21, 0x03, 0x32, 0x09, 0x00, 
    0x15, 0x29, 0x1C, 0x24, 0x09, 0x04, 0x1C, 0x11, 0x1F, 0x15, 
    0x05, 0x21, 0x17, 0x2C, 0x0D, 0x1F, 0x30, 0x00, 0x29, 0x17, 
    0x07, 0x19, 0x11, 0x30, 0x24, 0x18, 0x27, 0x07, 0x19, 0x20, 0x0F, 
    
    0x2B, 0x0D, 0x28, 0x11, 0x25, 0x02, 0x1A, 0x06, 0x32, 0x18,         // 55
    0x04, 0x2E, 0x0F, 0x06, 0x18, 0x2C, 0x02, 0x16, 0x0F, 0x20, 
    0x1A, 0x2E, 0x16, 0x23, 0x05, 0x0B, 0x2F, 0x07, 0x2B, 0x1B, 
    0x0A, 0x22, 0x04, 0x2D, 0x09, 0x22, 0x0E, 0x02, 0x28, 0x11, 
    0x24, 0x18, 0x05, 0x23, 0x1A, 0x2C, 0x1F, 0x16, 0x08, 0x19, 
    0x06, 0x22, 0x10, 0x27, 0x2F, 0x0E, 0x1E, 0x18, 0x27, 0x1F, 
    0x30, 0x07, 0x13, 0x2F, 0x10, 0x2A, 0x26, 0x00, 0x2F, 0x09, 
    0x1B, 0x30, 0x08, 0x25, 0x04, 0x27, 0x10, 0x1C, 0x0A, 0x25, 
    0x0E, 0x2D, 0x22, 0x01, 0x0B, 0x2D, 0x11, 0x22, 0x2A, 0x04, 0x15, 
    
    0x22, 0x06, 0x17, 0x2C, 0x0E, 0x2F, 0x29, 0x20, 0x0E, 0x22,         // 56
    0x2A, 0x15, 0x21, 0x2A, 0x24, 0x1E, 0x10, 0x22, 0x29, 0x00, 
    0x14, 0x07, 0x0E, 0x31, 0x12, 0x21, 0x1A, 0x23, 0x10, 0x01, 
    0x15, 0x31, 0x0F, 0x1F, 0x12, 0x19, 0x32, 0x20, 0x18, 0x2D, 
    0x07, 0x31, 0x29, 0x14, 0x0F, 0x25, 0x05, 0x29, 0x21, 0x2B, 
    0x0E, 0x30, 0x1F, 0x07, 0x16, 0x25, 0x08, 0x2C, 0x11, 0x0D, 
    0x1B, 0x0B, 0x22, 0x02, 0x1A, 0x20, 0x0D, 0x18, 0x22, 0x12, 
    0x27, 0x0C, 0x1D, 0x13, 0x2E, 0x18, 0x05, 0x2C, 0x13, 0x31, 
    0x03, 0x1C, 0x0F, 0x29, 0x14, 0x07, 0x1E, 0x01, 0x0C, 0x2F, 0x1B, 
    
    0x12, 0x32, 0x20, 0x04, 0x1D, 0x0A, 0x12, 0x07, 0x1C, 0x02,         // 57
    0x10, 0x1C, 0x01, 0x0D, 0x13, 0x04, 0x2F, 0x19, 0x0A, 0x30, 
    0x25, 0x1E, 0x27, 0x09, 0x18, 0x2D, 0x04, 0x13, 0x2D, 0x20, 
    0x27, 0x05, 0x1B, 0x29, 0x00, 0x26, 0x07, 0x10, 0x09, 0x21, 
    0x13, 0x0C, 0x1F, 0x01, 0x2E, 0x0A, 0x19, 0x10, 0x00, 0x15, 
    0x1C, 0x02, 0x12, 0x1B, 0x0C, 0x2D, 0x13, 0x02, 0x23, 0x05, 
    0x26, 0x2C, 0x16, 0x28, 0x08, 0x13, 0x2E, 0x06, 0x28, 0x03, 
    0x16, 0x2C, 0x02, 0x21, 0x08, 0x1F, 0x14, 0x23, 0x06, 0x1F, 
    0x16, 0x2B, 0x06, 0x20, 0x1A, 0x27, 0x31, 0x18, 0x13, 0x25, 0x08, 
    
    0x01, 0x19, 0x0B, 0x13, 0x27, 0x18, 0x23, 0x2C, 0x16, 0x2D,         // 58
    0x27, 0x0B, 0x31, 0x26, 0x1B, 0x0B, 0x28, 0x06, 0x1F, 0x12, 
    0x0C, 0x03, 0x1B, 0x2A, 0x01, 0x1E, 0x0C, 0x25, 0x06, 0x18, 
    0x0A, 0x2B, 0x16, 0x0C, 0x2F, 0x1C, 0x16, 0x2C, 0x27, 0x02, 
    0x1C, 0x26, 0x08, 0x1B, 0x22, 0x15, 0x2C, 0x1D, 0x32, 0x26, 
    0x0B, 0x2D, 0x24, 0x2A, 0x03, 0x21, 0x1C, 0x2A, 0x16, 0x2E, 
    0x19, 0x10, 0x06, 0x1D, 0x31, 0x25, 0x0B, 0x1F, 0x10, 0x31, 
    0x22, 0x0F, 0x19, 0x2A, 0x10, 0x32, 0x0C, 0x28, 0x19, 0x0E, 
    0x25, 0x0A, 0x13, 0x2F, 0x02, 0x16, 0x09, 0x2B, 0x1F, 0x0D, 0x29, 
    
    0x1E, 0x2D, 0x23, 0x2A, 0x06, 0x31, 0x00, 0x0D, 0x24, 0x12,         // 59
    0x05, 0x20, 0x16, 0x08, 0x2E, 0x20, 0x15, 0x0E, 0x2D, 0x17, 
    0x28, 0x2D, 0x10, 0x15, 0x24, 0x0F, 0x29, 0x1B, 0x32, 0x11, 
    0x1D, 0x0F, 0x24, 0x04, 0x21, 0x12, 0x05, 0x1F, 0x11, 0x30, 
    0x16, 0x2C, 0x11, 0x30, 0x0D, 0x03, 0x23, 0x07, 0x0F, 0x05, 
    0x1F, 0x17, 0x06, 0x14, 0x31, 0x10, 0x06, 0x0D, 0x1E, 0x0A, 
    0x01, 0x20, 0x2B, 0x0D, 0x15, 0x02, 0x1B, 0x2B, 0x17, 0x0B, 
    0x1D, 0x07, 0x24, 0x0A, 0x26, 0x01, 0x1B, 0x09, 0x2B, 0x02, 
    0x2E, 0x1A, 0x28, 0x0D, 0x25, 0x10, 0x21, 0x12, 0x04, 0x2F, 0x16, 
    
    0x10, 0x0C, 0x03, 0x1C, 0x0F, 0x1F, 0x14, 0x1B, 0x06, 0x30,         // 60
    0x19, 0x25, 0x03, 0x1D, 0x11, 0x03, 0x2B, 0x25, 0x01, 0x1C, 
    0x07, 0x22, 0x05, 0x30, 0x0A, 0x2C, 0x14, 0x03, 0x09, 0x22, 
    0x2D, 0x07, 0x30, 0x19, 0x0E, 0x2B, 0x25, 0x0B, 0x19, 0x06, 
    0x0E, 0x21, 0x02, 0x17, 0x2A, 0x11, 0x28, 0x18, 0x20, 0x2E, 
    0x12, 0x28, 0x1D, 0x09, 0x25, 0x19, 0x28, 0x2F, 0x13, 0x27, 
    0x31, 0x17, 0x24, 0x04, 0x21, 0x2C, 0x11, 0x08, 0x26, 0x04, 
    0x28, 0x14, 0x30, 0x12, 0x1F, 0x17, 0x2D, 0x21, 0x12, 0x1E, 
    0x15, 0x04, 0x21, 0x07, 0x1C, 0x2D, 0x03, 0x26, 0x1A, 0x0A, 0x24, 
    
    0x2C, 0x19, 0x26, 0x12, 0x2D, 0x08, 0x2B, 0x27, 0x1F, 0x0F,         // 61
    0x09, 0x2A, 0x10, 0x2C, 0x26, 0x1A, 0x0A, 0x1D, 0x10, 0x32, 
    0x14, 0x0C, 0x18, 0x20, 0x1C, 0x06, 0x18, 0x20, 0x2A, 0x15, 
    0x01, 0x1F, 0x13, 0x29, 0x09, 0x1B, 0x02, 0x2E, 0x21, 0x2A, 
    0x25, 0x09, 0x1C, 0x25, 0x07, 0x1F, 0x2E, 0x0A, 0x14, 0x29, 
    0x0C, 0x01, 0x2F, 0x0E, 0x1F, 0x01, 0x0C, 0x22, 0x04, 0x1A, 
    0x0E, 0x07, 0x13, 0x2F, 0x19, 0x07, 0x1F, 0x30, 0x13, 0x1A, 
    0x2D, 0x01, 0x1C, 0x08, 0x2B, 0x11, 0x0D, 0x05, 0x30, 0x08, 
    0x26, 0x0F, 0x32, 0x14, 0x2A, 0x0D, 0x17, 0x30, 0x0F, 0x2A, 0x03, 
    
    0x1D, 0x07, 0x31, 0x05, 0x17, 0x24, 0x0B, 0x12, 0x02, 0x2C,         // 62
    0x1C, 0x14, 0x22, 0x0D, 0x06, 0x30, 0x12, 0x22, 0x06, 0x29, 
    0x1E, 0x26, 0x2B, 0x00, 0x0E, 0x24, 0x2F, 0x10, 0x0C, 0x25, 
    0x18, 0x0C, 0x24, 0x05, 0x1F, 0x31, 0x10, 0x16, 0x0C, 0x03, 
    0x17, 0x31, 0x0F, 0x2C, 0x15, 0x0B, 0x1B, 0x02, 0x24, 0x07, 
    0x1A, 0x22, 0x18, 0x2A, 0x13, 0x2C, 0x1D, 0x17, 0x09, 0x24, 
    0x2C, 0x1F, 0x27, 0x0A, 0x10, 0x26, 0x16, 0x00, 0x24, 0x0D, 
    0x20, 0x10, 0x27, 0x18, 0x04, 0x23, 0x2A, 0x19, 0x25, 0x0E, 
    0x2B, 0x1E, 0x09, 0x1A, 0x02, 0x20, 0x06, 0x1D, 0x08, 0x21, 0x13, 
    
    0x0A, 0x22, 0x14, 0x28, 0x1F, 0x02, 0x1A, 0x31, 0x17, 0x21,         // 63
    0x07, 0x32, 0x01, 0x18, 0x1F, 0x15, 0x02, 0x2E, 0x17, 0x0A, 
    0x11, 0x04, 0x15, 0x2F, 0x12, 0x28, 0x02, 0x1E, 0x2C, 0x08, 
    0x31, 0x1C, 0x2A, 0x11, 0x17, 0x25, 0x07, 0x1E, 0x2C, 0x1B, 
    0x11, 0x1F, 0x05, 0x19, 0x03, 0x2F, 0x22, 0x10, 0x30, 0x1D, 
    0x2C, 0x11, 0x0A, 0x04, 0x22, 0x08, 0x10, 0x32, 0x29, 0x13, 
    0x00, 0x18, 0x06, 0x2D, 0x1D, 0x2A, 0x0B, 0x1D, 0x2A, 0x05, 
    0x17, 0x2F, 0x0B, 0x21, 0x31, 0x0A, 0x14, 0x03, 0x1D, 0x16, 
    0x00, 0x13, 0x2C, 0x27, 0x11, 0x2F, 0x25, 0x13, 0x27, 0x18, 0x2E, 
    
    0x29, 0x10, 0x1C, 0x0A, 0x13, 0x2E, 0x0E, 0x23, 0x04, 0x28,         // 64
    0x0F, 0x1B, 0x25, 0x2E, 0x08, 0x2A, 0x24, 0x0D, 0x26, 0x1B, 
    0x2D, 0x23, 0x09, 0x1A, 0x1F, 0x0B, 0x19, 0x13, 0x05, 0x20, 
    0x10, 0x04, 0x0A, 0x2E, 0x01, 0x0D, 0x2A, 0x13, 0x23, 0x08, 
    0x28, 0x2E, 0x0C, 0x22, 0x27, 0x0E, 0x17, 0x2A, 0x0B, 0x15, 
    0x02, 0x23, 0x28, 0x1C, 0x2F, 0x18, 0x25, 0x02, 0x0E, 0x1D, 
    0x2E, 0x0C, 0x22, 0x19, 0x0D, 0x03, 0x32, 0x11, 0x18, 0x2C, 
    0x09, 0x23, 0x03, 0x15, 0x0F, 0x1E, 0x26, 0x2F, 0x08, 0x2C, 
    0x24, 0x1B, 0x04, 0x22, 0x08, 0x16, 0x0C, 0x2B, 0x05, 0x0F, 0x00, 
    
    0x19, 0x30, 0x03, 0x2B, 0x22, 0x07, 0x29, 0x1C, 0x0B, 0x14,         // 65
    0x2D, 0x05, 0x0C, 0x12, 0x21, 0x0F, 0x19, 0x07, 0x2B, 0x01, 
    0x0F, 0x1D, 0x2A, 0x0E, 0x2C, 0x05, 0x31, 0x24, 0x28, 0x17, 
    0x2B, 0x25, 0x16, 0x21, 0x1D, 0x27, 0x19, 0x03, 0x2E, 0x0F, 
    0x00, 0x14, 0x1B, 0x2C, 0x08, 0x1F, 0x01, 0x25, 0x06, 0x20, 
    0x0D, 0x31, 0x06, 0x14, 0x0C, 0x07, 0x2A, 0x1B, 0x22, 0x09, 
    0x25, 0x14, 0x2A, 0x04, 0x24, 0x15, 0x21, 0x06, 0x23, 0x0E, 
    0x1C, 0x12, 0x29, 0x1B, 0x2D, 0x01, 0x18, 0x0C, 0x20, 0x12, 
    0x06, 0x2F, 0x0D, 0x18, 0x2E, 0x1E, 0x04, 0x1B, 0x32, 0x20, 0x25, 
    
    0x07, 0x0D, 0x27, 0x19, 0x0F, 0x1F, 0x16, 0x06, 0x2F, 0x1F,         // 66
    0x18, 0x23, 0x2B, 0x1B, 0x05, 0x31, 0x22, 0x13, 0x1F, 0x15, 
    0x31, 0x05, 0x16, 0x06, 0x25, 0x14, 0x1C, 0x0F, 0x0B, 0x00, 
    0x1B, 0x0D, 0x30, 0x09, 0x12, 0x06, 0x30, 0x0C, 0x22, 0x1A, 
    0x26, 0x1E, 0x06, 0x12, 0x18, 0x32, 0x13, 0x1B, 0x2F, 0x17, 
    0x27, 0x12, 0x21, 0x19, 0x2C, 0x1F, 0x13, 0x05, 0x15, 0x30, 
    0x03, 0x1B, 0x0F, 0x30, 0x12, 0x29, 0x1B, 0x0B, 0x2D, 0x02, 
    0x25, 0x31, 0x06, 0x0D, 0x23, 0x08, 0x2B, 0x10, 0x28, 0x19, 
    0x0B, 0x27, 0x20, 0x10, 0x01, 0x29, 0x23, 0x11, 0x17, 0x0B, 0x13, 
    
    0x1E, 0x23, 0x15, 0x06, 0x32, 0x00, 0x2C, 0x11, 0x26, 0x0D,         // 67
    0x02, 0x13, 0x0A, 0x27, 0x16, 0x0C, 0x03, 0x2E, 0x08, 0x23, 
    0x0B, 0x28, 0x20, 0x30, 0x10, 0x21, 0x03, 0x2A, 0x1E, 0x30, 
    0x12, 0x20, 0x03, 0x1A, 0x2C, 0x23, 0x16, 0x1E, 0x07, 0x15, 
    0x31, 0x0A, 0x2A, 0x24, 0x04, 0x0C, 0x2A, 0x07, 0x0E, 0x2B, 
    0x03, 0x1E, 0x09, 0x28, 0x01, 0x10, 0x2F, 0x27, 0x0B, 0x29, 
    0x11, 0x21, 0x08, 0x1E, 0x0A, 0x01, 0x2F, 0x16, 0x28, 0x14, 
    0x1A, 0x0F, 0x20, 0x17, 0x28, 0x14, 0x1D, 0x24, 0x02, 0x32, 
    0x1F, 0x14, 0x05, 0x2A, 0x1B, 0x15, 0x0D, 0x26, 0x03, 0x2E, 0x28, 
    
    0x01, 0x2F, 0x09, 0x1D, 0x26, 0x0C, 0x1A, 0x21, 0x04, 0x1C,         // 68
    0x28, 0x31, 0x1D, 0x00, 0x2C, 0x1F, 0x29, 0x18, 0x10, 0x2B, 
    0x19, 0x12, 0x01, 0x1B, 0x08, 0x17, 0x2E, 0x09, 0x14, 0x25, 
    0x08, 0x2A, 0x15, 0x26, 0x0E, 0x02, 0x11, 0x27, 0x2B, 0x10, 
    0x04, 0x20, 0x0E, 0x2E, 0x21, 0x1B, 0x26, 0x1E, 0x13, 0x22, 
    0x0C, 0x17, 0x2E, 0x0D, 0x25, 0x19, 0x07, 0x21, 0x1C, 0x17, 
    0x07, 0x2C, 0x28, 0x16, 0x25, 0x19, 0x20, 0x07, 0x0D, 0x22, 
    0x0A, 0x2B, 0x03, 0x2F, 0x0B, 0x05, 0x2E, 0x09, 0x1B, 0x0F, 
    0x04, 0x2C, 0x19, 0x24, 0x0B, 0x31, 0x07, 0x2C, 0x1D, 0x09, 0x16, 
    
    0x1A, 0x0E, 0x2B, 0x12, 0x22, 0x14, 0x29, 0x0A, 0x30, 0x15,         // 69
    0x07, 0x10, 0x22, 0x0E, 0x19, 0x11, 0x0A, 0x26, 0x02, 0x1E, 
    0x09, 0x24, 0x2A, 0x0C, 0x2C, 0x26, 0x0E, 0x1A, 0x20, 0x05, 
    0x2E, 0x0B, 0x1E, 0x05, 0x29, 0x1C, 0x2F, 0x0C, 0x01, 0x1D, 
    0x28, 0x1A, 0x14, 0x01, 0x17, 0x10, 0x05, 0x2E, 0x00, 0x19, 
    0x24, 0x29, 0x05, 0x14, 0x1D, 0x2C, 0x0E, 0x15, 0x01, 0x2E, 
    0x1F, 0x13, 0x02, 0x0D, 0x2B, 0x06, 0x10, 0x2C, 0x1C, 0x30, 
    0x05, 0x27, 0x14, 0x1E, 0x22, 0x19, 0x0F, 0x21, 0x14, 0x2D, 
    0x25, 0x09, 0x11, 0x2F, 0x03, 0x1E, 0x12, 0x19, 0x22, 0x10, 0x2A, 
    
    0x20, 0x27, 0x17, 0x02, 0x0A, 0x2E, 0x03, 0x1D, 0x10, 0x24,         // 70
    0x2D, 0x1B, 0x09, 0x26, 0x30, 0x06, 0x21, 0x1A, 0x32, 0x14, 
    0x2D, 0x06, 0x16, 0x1F, 0x12, 0x07, 0x23, 0x02, 0x2C, 0x0F, 
    0x17, 0x23, 0x11, 0x31, 0x14, 0x0A, 0x20, 0x18, 0x24, 0x2D, 
    0x16, 0x07, 0x30, 0x25, 0x09, 0x2A, 0x14, 0x23, 0x0B, 0x31, 
    0x07, 0x11, 0x1F, 0x30, 0x09, 0x03, 0x23, 0x32, 0x0D, 0x24, 
    0x0A, 0x1A, 0x2F, 0x1C, 0x12, 0x31, 0x24, 0x18, 0x00, 0x12, 
    0x1E, 0x19, 0x09, 0x0F, 0x01, 0x26, 0x30, 0x04, 0x28, 0x0B, 
    0x16, 0x1C, 0x20, 0x0D, 0x16, 0x21, 0x2B, 0x00, 0x0C, 0x31, 0x04, 
    
    0x0B, 0x05, 0x23, 0x31, 0x1E, 0x18, 0x13, 0x28, 0x06, 0x1F,         // 71
    0x02, 0x15, 0x2B, 0x04, 0x23, 0x14, 0x2C, 0x0E, 0x08, 0x21, 
    0x0F, 0x1B, 0x30, 0x04, 0x2A, 0x1A, 0x32, 0x12, 0x27, 0x1D, 
    0x01, 0x29, 0x07, 0x18, 0x24, 0x04, 0x2D, 0x08, 0x13, 0x05, 
    0x0D, 0x23, 0x0B, 0x1C, 0x2D, 0x1F, 0x0D, 0x1C, 0x26, 0x15, 
    0x2B, 0x1A, 0x02, 0x24, 0x17, 0x2A, 0x12, 0x1A, 0x28, 0x04, 
    0x11, 0x26, 0x05, 0x23, 0x09, 0x1F, 0x04, 0x0D, 0x28, 0x23, 
    0x0C, 0x2C, 0x24, 0x32, 0x29, 0x11, 0x17, 0x0D, 0x1C, 0x21, 
    0x06, 0x2E, 0x01, 0x25, 0x2A, 0x06, 0x0E, 0x27, 0x16, 0x24, 0x14, 
    
    0x2F, 0x1D, 0x15, 0x0D, 0x29, 0x08, 0x21, 0x2D, 0x0C, 0x17,         // 72
    0x27, 0x0C, 0x20, 0x18, 0x0D, 0x1D, 0x01, 0x25, 0x19, 0x29, 
    0x02, 0x25, 0x0A, 0x10, 0x22, 0x14, 0x05, 0x20, 0x09, 0x19, 
    0x30, 0x0C, 0x1E, 0x2D, 0x0D, 0x1F, 0x11, 0x27, 0x1C, 0x32, 
    0x1F, 0x2C, 0x12, 0x04, 0x16, 0x02, 0x30, 0x08, 0x11, 0x03, 
    0x21, 0x0E, 0x28, 0x0B, 0x1E, 0x0E, 0x20, 0x06, 0x15, 0x1D, 
    0x30, 0x16, 0x0E, 0x2C, 0x18, 0x13, 0x2A, 0x1E, 0x14, 0x2F, 
    0x07, 0x17, 0x04, 0x13, 0x1A, 0x06, 0x1F, 0x2B, 0x01, 0x31, 
    0x13, 0x27, 0x18, 0x0A, 0x11, 0x1A, 0x2D, 0x1E, 0x08, 0x1B, 0x29, 
    
    0x12, 0x08, 0x2C, 0x04, 0x11, 0x26, 0x05, 0x11, 0x1B, 0x32,         // 73
    0x08, 0x2C, 0x11, 0x31, 0x08, 0x2A, 0x11, 0x2F, 0x06, 0x13, 
    0x2E, 0x16, 0x1E, 0x27, 0x00, 0x2E, 0x0E, 0x17, 0x2D, 0x04, 
    0x12, 0x22, 0x14, 0x03, 0x26, 0x17, 0x02, 0x2B, 0x0A, 0x11, 
    0x00, 0x18, 0x27, 0x22, 0x0F, 0x29, 0x24, 0x18, 0x28, 0x2E, 
    0x1B, 0x07, 0x31, 0x13, 0x2C, 0x00, 0x2F, 0x0B, 0x2B, 0x21, 
    0x0A, 0x29, 0x1F, 0x01, 0x27, 0x07, 0x2F, 0x0A, 0x03, 0x1A, 
    0x10, 0x2B, 0x20, 0x0C, 0x22, 0x2D, 0x0A, 0x26, 0x11, 0x1A, 
    0x0D, 0x07, 0x2B, 0x1E, 0x31, 0x23, 0x03, 0x13, 0x30, 0x02, 0x0D, 
    
    0x19, 0x27, 0x22, 0x1F, 0x1A, 0x30, 0x16, 0x20, 0x02, 0x23,         // 74
    0x14, 0x1D, 0x01, 0x27, 0x1E, 0x15, 0x22, 0x0B, 0x1C, 0x20, 
    0x0D, 0x08, 0x31, 0x19, 0x0B, 0x1D, 0x28, 0x23, 0x0C, 0x25, 
    0x2A, 0x08, 0x1A, 0x2B, 0x0B, 0x30, 0x1D, 0x14, 0x24, 0x1A, 
    0x29, 0x0E, 0x06, 0x31, 0x1A, 0x07, 0x14, 0x04, 0x1F, 0x0C, 
    0x14, 0x23, 0x18, 0x09, 0x1C, 0x26, 0x17, 0x25, 0x0F, 0x02, 
    0x19, 0x06, 0x10, 0x30, 0x0D, 0x1A, 0x21, 0x16, 0x2D, 0x20, 
    0x26, 0x03, 0x1B, 0x29, 0x00, 0x0F, 0x16, 0x20, 0x08, 0x29, 
    0x1F, 0x23, 0x14, 0x04, 0x0F, 0x09, 0x18, 0x28, 0x0F, 0x25, 0x20, 
    
    0x2E, 0x00, 0x0C, 0x15, 0x03, 0x23, 0x0E, 0x2D, 0x0B, 0x2A,         // 75
    0x06, 0x22, 0x19, 0x0D, 0x04, 0x2D, 0x06, 0x18, 0x26, 0x04, 
    0x28, 0x1B, 0x06, 0x11, 0x2B, 0x15, 0x08, 0x02, 0x1E, 0x16, 
    0x0F, 0x31, 0x24, 0x06, 0x12, 0x22, 0x0F, 0x08, 0x2E, 0x04, 
    0x20, 0x2E, 0x15, 0x1F, 0x0A, 0x2C, 0x21, 0x10, 0x32, 0x06, 
    0x27, 0x01, 0x2D, 0x21, 0x04, 0x11, 0x08, 0x1B, 0x30, 0x14, 
    0x24, 0x2D, 0x1B, 0x15, 0x24, 0x05, 0x11, 0x27, 0x0E, 0x08, 
    0x12, 0x31, 0x09, 0x16, 0x23, 0x31, 0x1C, 0x03, 0x2D, 0x16, 
    0x02, 0x10, 0x2C, 0x19, 0x26, 0x2E, 0x1D, 0x04, 0x2C, 0x16, 0x06, 
    
    0x13, 0x1C, 0x30, 0x28, 0x0A, 0x2B, 0x06, 0x1E, 0x18, 0x11,         // 76
    0x26, 0x0F, 0x2F, 0x15, 0x24, 0x1C, 0x10, 0x31, 0x13, 0x2C, 
    0x10, 0x21, 0x2C, 0x24, 0x04, 0x21, 0x31, 0x14, 0x2B, 0x07, 
    0x1B, 0x00, 0x14, 0x1D, 0x28, 0x01, 0x2C, 0x1F, 0x17, 0x12, 
    0x0C, 0x08, 0x24, 0x02, 0x12, 0x26, 0x0B, 0x1C, 0x25, 0x17, 
    0x0E, 0x2A, 0x14, 0x0D, 0x29, 0x31, 0x1F, 0x03, 0x22, 0x09, 
    0x2A, 0x07, 0x20, 0x03, 0x2A, 0x1D, 0x31, 0x01, 0x1D, 0x2B, 
    0x17, 0x1E, 0x0F, 0x2C, 0x11, 0x05, 0x27, 0x13, 0x23, 0x0C, 
    0x32, 0x25, 0x07, 0x1F, 0x00, 0x12, 0x22, 0x0D, 0x1F, 0x09, 0x29, 
    
    0x21, 0x07, 0x0F, 0x14, 0x20, 0x19, 0x13, 0x29, 0x00, 0x30,         // 77
    0x1F, 0x04, 0x28, 0x0B, 0x2C, 0x09, 0x28, 0x01, 0x1E, 0x07, 
    0x18, 0x02, 0x12, 0x1D, 0x0A, 0x1A, 0x0F, 0x25, 0x0D, 0x2E, 
    0x21, 0x28, 0x0D, 0x2D, 0x16, 0x0C, 0x1A, 0x06, 0x28, 0x30, 
    0x1C, 0x2A, 0x19, 0x2C, 0x17, 0x30, 0x00, 0x16, 0x09, 0x2D, 
    0x1B, 0x20, 0x08, 0x1D, 0x18, 0x0A, 0x13, 0x2D, 0x0C, 0x19, 
    0x1E, 0x13, 0x0C, 0x2F, 0x0F, 0x16, 0x0A, 0x22, 0x14, 0x05, 
    0x23, 0x02, 0x26, 0x07, 0x20, 0x1A, 0x0A, 0x2E, 0x06, 0x1D, 
    0x18, 0x13, 0x0C, 0x2E, 0x17, 0x28, 0x06, 0x15, 0x32, 0x1A, 0x0E, 
    
    0x2F, 0x26, 0x1E, 0x2C, 0x02, 0x31, 0x09, 0x24, 0x0D, 0x1B,         // 78
    0x14, 0x0A, 0x17, 0x20, 0x02, 0x13, 0x19, 0x21, 0x0E, 0x2F, 
    0x25, 0x1C, 0x32, 0x0E, 0x27, 0x2D, 0x01, 0x1F, 0x18, 0x04, 
    0x13, 0x09, 0x1F, 0x04, 0x24, 0x32, 0x13, 0x25, 0x0D, 0x01, 
    0x22, 0x13, 0x04, 0x0D, 0x21, 0x0F, 0x1E, 0x2B, 0x22, 0x03, 
    0x12, 0x05, 0x30, 0x24, 0x01, 0x28, 0x1A, 0x26, 0x11, 0x28, 
    0x00, 0x2D, 0x22, 0x19, 0x05, 0x20, 0x2C, 0x0F, 0x28, 0x30, 
    0x0C, 0x2D, 0x1A, 0x14, 0x30, 0x0E, 0x29, 0x19, 0x10, 0x29, 
    0x01, 0x21, 0x2A, 0x1C, 0x09, 0x0F, 0x2B, 0x23, 0x01, 0x25, 0x05, 
    
    0x10, 0x1A, 0x05, 0x0D, 0x23, 0x10, 0x1D, 0x15, 0x2E, 0x06,         // 79
    0x2A, 0x23, 0x32, 0x10, 0x1E, 0x25, 0x30, 0x08, 0x29, 0x14, 
    0x0C, 0x08, 0x29, 0x04, 0x18, 0x08, 0x14, 0x2F, 0x0B, 0x23, 
    0x2B, 0x18, 0x30, 0x11, 0x0A, 0x1D, 0x03, 0x2C, 0x1F, 0x17, 
    0x08, 0x27, 0x32, 0x1E, 0x08, 0x29, 0x06, 0x12, 0x0B, 0x2F, 
    0x1E, 0x26, 0x0B, 0x13, 0x2D, 0x0F, 0x05, 0x21, 0x08, 0x31, 
    0x15, 0x0E, 0x06, 0x27, 0x13, 0x26, 0x02, 0x1A, 0x08, 0x16, 
    0x1C, 0x11, 0x08, 0x2A, 0x05, 0x24, 0x02, 0x20, 0x09, 0x24, 
    0x2E, 0x08, 0x11, 0x03, 0x31, 0x1F, 0x19, 0x0B, 0x13, 0x2B, 0x17, 
    
    0x02, 0x2B, 0x15, 0x28, 0x19, 0x06, 0x2C, 0x03, 0x20, 0x27,         // 80
    0x11, 0x01, 0x1A, 0x06, 0x2D, 0x0C, 0x04, 0x17, 0x1D, 0x02, 
    0x2D, 0x19, 0x22, 0x14, 0x1F, 0x2B, 0x24, 0x06, 0x29, 0x1C, 
    0x0F, 0x05, 0x26, 0x1A, 0x2A, 0x22, 0x15, 0x08, 0x11, 0x2F, 
    0x1A, 0x10, 0x0A, 0x17, 0x25, 0x14, 0x2F, 0x1B, 0x28, 0x15, 
    0x0D, 0x2C, 0x16, 0x1C, 0x07, 0x1F, 0x2F, 0x14, 0x1D, 0x05, 
    0x20, 0x2A, 0x1B, 0x32, 0x0B, 0x1C, 0x2F, 0x12, 0x20, 0x26, 
    0x00, 0x21, 0x26, 0x1C, 0x0F, 0x16, 0x2C, 0x12, 0x30, 0x15, 
    0x0E, 0x1A, 0x27, 0x17, 0x24, 0x13, 0x04, 0x2F, 0x1C, 0x08, 0x1F, 
    
    0x25, 0x0C, 0x20, 0x09, 0x2F, 0x13, 0x27, 0x0E, 0x19, 0x09,         // 81
    0x1E, 0x2D, 0x0B, 0x27, 0x1B, 0x15, 0x2A, 0x24, 0x0E, 0x20, 
    0x27, 0x10, 0x00, 0x30, 0x0A, 0x0E, 0x1D, 0x11, 0x16, 0x03, 
    0x2F, 0x1E, 0x09, 0x13, 0x04, 0x0E, 0x2E, 0x1B, 0x28, 0x04, 
    0x24, 0x2D, 0x22, 0x05, 0x2C, 0x01, 0x0E, 0x20, 0x04, 0x19, 
    0x01, 0x20, 0x09, 0x25, 0x2A, 0x17, 0x02, 0x2A, 0x0B, 0x27, 
    0x17, 0x03, 0x12, 0x08, 0x1F, 0x0F, 0x07, 0x29, 0x05, 0x2C, 
    0x0C, 0x31, 0x13, 0x03, 0x2E, 0x1F, 0x08, 0x1C, 0x03, 0x22, 
    0x05, 0x1F, 0x2C, 0x0A, 0x0E, 0x2D, 0x26, 0x0F, 0x22, 0x0D, 0x31, 
    
    0x12, 0x1B, 0x2E, 0x00, 0x1B, 0x1F, 0x07, 0x23, 0x14, 0x31,         // 82
    0x0E, 0x16, 0x21, 0x13, 0x08, 0x21, 0x10, 0x09, 0x31, 0x16, 
    0x06, 0x1B, 0x25, 0x13, 0x2A, 0x19, 0x02, 0x31, 0x21, 0x0C, 
    0x25, 0x10, 0x2B, 0x23, 0x30, 0x18, 0x00, 0x23, 0x0A, 0x17, 
    0x0C, 0x02, 0x1C, 0x12, 0x1F, 0x19, 0x26, 0x0A, 0x32, 0x24, 
    0x2A, 0x12, 0x30, 0x03, 0x11, 0x0C, 0x24, 0x1A, 0x11, 0x2E, 
    0x0E, 0x25, 0x2D, 0x22, 0x15, 0x2E, 0x23, 0x1B, 0x15, 0x10, 
    0x1E, 0x17, 0x0A, 0x28, 0x18, 0x0E, 0x27, 0x0C, 0x25, 0x19, 
    0x2F, 0x12, 0x00, 0x22, 0x1C, 0x09, 0x16, 0x01, 0x2C, 0x17, 0x07, 
    
    0x2D, 0x05, 0x0F, 0x23, 0x11, 0x0B, 0x29, 0x2D, 0x01, 0x22,         // 83
    0x06, 0x2A, 0x03, 0x30, 0x28, 0x00, 0x2E, 0x1D, 0x03, 0x2A, 
    0x0C, 0x2E, 0x08, 0x1C, 0x04, 0x26, 0x2C, 0x0A, 0x19, 0x2B, 
    0x16, 0x01, 0x1B, 0x15, 0x07, 0x21, 0x2A, 0x11, 0x31, 0x20, 
    0x2A, 0x14, 0x25, 0x0D, 0x31, 0x09, 0x2C, 0x17, 0x11, 0x08, 
    0x1C, 0x06, 0x18, 0x1E, 0x2B, 0x1D, 0x32, 0x07, 0x22, 0x01, 
    0x1E, 0x0A, 0x18, 0x05, 0x2A, 0x02, 0x13, 0x0A, 0x30, 0x24, 
    0x04, 0x2B, 0x1F, 0x06, 0x24, 0x01, 0x32, 0x17, 0x2B, 0x07, 
    0x0E, 0x26, 0x15, 0x32, 0x05, 0x29, 0x20, 0x1B, 0x11, 0x28, 0x1F, 
    
    0x14, 0x25, 0x17, 0x2A, 0x32, 0x16, 0x04, 0x1E, 0x12, 0x1B,         // 84
    0x26, 0x18, 0x0F, 0x1C, 0x0C, 0x1A, 0x15, 0x25, 0x12, 0x19, 
    0x21, 0x11, 0x28, 0x23, 0x0F, 0x16, 0x08, 0x23, 0x10, 0x05, 
    0x1F, 0x32, 0x0B, 0x28, 0x11, 0x1C, 0x09, 0x18, 0x05, 0x0E, 
    0x1A, 0x2F, 0x07, 0x28, 0x03, 0x13, 0x1E, 0x05, 0x22, 0x2D, 
    0x15, 0x28, 0x0E, 0x26, 0x05, 0x12, 0x0A, 0x16, 0x2A, 0x19, 
    0x31, 0x13, 0x29, 0x1E, 0x0D, 0x19, 0x28, 0x1F, 0x01, 0x2A, 
    0x0B, 0x19, 0x0D, 0x2D, 0x1B, 0x14, 0x22, 0x05, 0x13, 0x22, 
    0x1C, 0x09, 0x2A, 0x1E, 0x13, 0x0F, 0x2F, 0x08, 0x25, 0x0C, 0x02, 
    
    0x29, 0x08, 0x1E, 0x03, 0x09, 0x26, 0x1C, 0x0E, 0x2F, 0x09,         // 85
    0x0D, 0x2D, 0x20, 0x07, 0x24, 0x2C, 0x05, 0x0B, 0x28, 0x07, 
    0x30, 0x02, 0x17, 0x0B, 0x32, 0x1F, 0x12, 0x1B, 0x2F, 0x26, 
    0x09, 0x11, 0x24, 0x04, 0x2F, 0x0C, 0x25, 0x2E, 0x1D, 0x24, 
    0x01, 0x11, 0x20, 0x16, 0x1B, 0x2A, 0x0F, 0x27, 0x1A, 0x0C, 
    0x03, 0x21, 0x2F, 0x0A, 0x1A, 0x2E, 0x27, 0x1F, 0x04, 0x0F, 
    0x08, 0x22, 0x04, 0x11, 0x24, 0x2D, 0x07, 0x0F, 0x17, 0x1D, 
    0x12, 0x30, 0x23, 0x12, 0x09, 0x2E, 0x0B, 0x1B, 0x2C, 0x02, 
    0x30, 0x18, 0x10, 0x02, 0x19, 0x26, 0x03, 0x15, 0x1D, 0x31, 0x19, 
    
    0x10, 0x30, 0x0D, 0x22, 0x19, 0x11, 0x2C, 0x06, 0x23, 0x17,         // 86
    0x28, 0x04, 0x15, 0x30, 0x13, 0x0D, 0x1F, 0x2E, 0x1C, 0x0F, 
    0x1F, 0x14, 0x2B, 0x1B, 0x01, 0x27, 0x06, 0x2A, 0x02, 0x15, 
    0x1C, 0x2D, 0x19, 0x1F, 0x15, 0x2B, 0x02, 0x14, 0x07, 0x2C, 
    0x27, 0x09, 0x2D, 0x0C, 0x24, 0x09, 0x2E, 0x02, 0x12, 0x2F, 
    0x1E, 0x10, 0x04, 0x14, 0x22, 0x00, 0x0E, 0x14, 0x2F, 0x26, 
    0x1D, 0x2B, 0x0B, 0x30, 0x15, 0x0A, 0x22, 0x32, 0x27, 0x06, 
    0x21, 0x0A, 0x03, 0x1E, 0x29, 0x04, 0x1F, 0x0F, 0x26, 0x0D, 
    0x21, 0x06, 0x28, 0x23, 0x30, 0x0C, 0x1F, 0x2D, 0x0B, 0x05, 0x22, 
    
    0x02, 0x1C, 0x15, 0x2E, 0x28, 0x01, 0x21, 0x15, 0x2A, 0x02,         // 87
    0x1F, 0x11, 0x25, 0x1B, 0x02, 0x27, 0x18, 0x12, 0x01, 0x29, 
    0x09, 0x25, 0x06, 0x22, 0x13, 0x2D, 0x0F, 0x18, 0x21, 0x0E, 
    0x29, 0x02, 0x0F, 0x09, 0x22, 0x10, 0x1B, 0x21, 0x0D, 0x12, 
    0x17, 0x1E, 0x14, 0x29, 0x00, 0x1E, 0x15, 0x22, 0x29, 0x0B, 
    0x25, 0x18, 0x29, 0x1D, 0x2C, 0x18, 0x23, 0x06, 0x1B, 0x12, 
    0x02, 0x16, 0x1A, 0x26, 0x01, 0x1F, 0x17, 0x03, 0x11, 0x2C, 
    0x15, 0x26, 0x2D, 0x16, 0x0E, 0x25, 0x17, 0x2F, 0x06, 0x16, 
    0x1B, 0x2E, 0x0E, 0x08, 0x1C, 0x06, 0x13, 0x27, 0x11, 0x2A, 0x16, 
    
    0x2D, 0x26, 0x0A, 0x05, 0x13, 0x0C, 0x30, 0x08, 0x1B, 0x12,         // 88
    0x32, 0x08, 0x2C, 0x0B, 0x20, 0x2B, 0x09, 0x32, 0x23, 0x15, 
    0x2D, 0x1A, 0x0F, 0x2E, 0x08, 0x1A, 0x24, 0x09, 0x31, 0x07, 
    0x23, 0x16, 0x28, 0x31, 0x04, 0x26, 0x0A, 0x28, 0x31, 0x20, 
    0x03, 0x2F, 0x05, 0x1B, 0x12, 0x31, 0x0D, 0x19, 0x08, 0x16, 
    0x01, 0x32, 0x07, 0x11, 0x0C, 0x08, 0x2E, 0x29, 0x0D, 0x22, 
    0x2D, 0x0E, 0x20, 0x08, 0x2C, 0x11, 0x29, 0x1B, 0x0A, 0x1F, 
    0x00, 0x0D, 0x19, 0x05, 0x31, 0x20, 0x01, 0x12, 0x23, 0x28, 
    0x01, 0x13, 0x1F, 0x15, 0x2D, 0x18, 0x23, 0x00, 0x1A, 0x1F, 0x09, 
    
    0x18, 0x11, 0x1F, 0x2C, 0x24, 0x18, 0x1E, 0x10, 0x26, 0x0B,         // 89
    0x24, 0x1C, 0x03, 0x18, 0x11, 0x05, 0x1D, 0x0F, 0x06, 0x1F, 
    0x0C, 0x02, 0x27, 0x16, 0x20, 0x03, 0x29, 0x15, 0x1E, 0x12, 
    0x2C, 0x0A, 0x1D, 0x13, 0x1A, 0x2E, 0x15, 0x02, 0x18, 0x09, 
    0x26, 0x0F, 0x22, 0x2C, 0x08, 0x26, 0x04, 0x2D, 0x1F, 0x2B, 
    0x1C, 0x0D, 0x21, 0x2E, 0x26, 0x15, 0x1D, 0x03, 0x18, 0x09, 
    0x28, 0x05, 0x2F, 0x13, 0x1B, 0x0C, 0x05, 0x2E, 0x26, 0x18, 
    0x31, 0x22, 0x2A, 0x12, 0x1C, 0x0C, 0x2B, 0x1A, 0x08, 0x32, 
    0x0B, 0x2B, 0x25, 0x03, 0x29, 0x0E, 0x32, 0x0A, 0x2C, 0x0E, 0x23, 
    
    0x07, 0x29, 0x01, 0x1B, 0x07, 0x2A, 0x02, 0x2E, 0x05, 0x2B,         // 90
    0x16, 0x0E, 0x28, 0x2F, 0x23, 0x2C, 0x14, 0x27, 0x19, 0x2A, 
    0x12, 0x31, 0x1E, 0x0A, 0x11, 0x30, 0x0D, 0x05, 0x26, 0x02, 
    0x1B, 0x21, 0x03, 0x26, 0x06, 0x0F, 0x22, 0x2C, 0x11, 0x1D, 
    0x2B, 0x1A, 0x09, 0x11, 0x23, 0x16, 0x1C, 0x13, 0x06, 0x0F, 
    0x24, 0x14, 0x05, 0x19, 0x01, 0x21, 0x10, 0x25, 0x32, 0x1E, 
    0x11, 0x1B, 0x22, 0x02, 0x24, 0x31, 0x20, 0x15, 0x0F, 0x07, 
    0x12, 0x06, 0x1F, 0x09, 0x28, 0x06, 0x14, 0x21, 0x0E, 0x1D, 
    0x22, 0x19, 0x11, 0x0B, 0x20, 0x06, 0x1E, 0x16, 0x25, 0x05, 0x30, 
};

const BYTE HT_SuperCell_Green216[91*91] = {
    0x12, 0x0A, 0x2A, 0x0E, 0x06, 0x1B, 0x14, 0x24, 0x11, 0x2F,         //  0
    0x03, 0x1A, 0x07, 0x31, 0x05, 0x27, 0x2D, 0x13, 0x0F, 0x00, 
    0x21, 0x11, 0x1E, 0x05, 0x15, 0x23, 0x11, 0x19, 0x0C, 0x1E, 
    0x16, 0x2D, 0x18, 0x27, 0x1B, 0x13, 0x24, 0x2F, 0x0D, 0x17, 
    0x30, 0x15, 0x0F, 0x09, 0x31, 0x01, 0x2B, 0x18, 0x1E, 0x0C, 
    0x12, 0x04, 0x2F, 0x12, 0x1D, 0x07, 0x28, 0x2E, 0x03, 0x0F, 
    0x06, 0x2C, 0x15, 0x02, 0x2E, 0x07, 0x29, 0x24, 0x12, 0x1A, 
    0x07, 0x2E, 0x06, 0x0E, 0x1A, 0x05, 0x1D, 0x18, 0x08, 0x22, 
    0x1A, 0x27, 0x14, 0x31, 0x03, 0x20, 0x0B, 0x2F, 0x14, 0x2A, 0x00, 

    0x28, 0x19, 0x03, 0x1E, 0x27, 0x2B, 0x0D, 0x07, 0x27, 0x0E,         //  1
    0x2B, 0x14, 0x29, 0x21, 0x15, 0x0E, 0x03, 0x1E, 0x29, 0x31, 
    0x06, 0x2C, 0x19, 0x0C, 0x26, 0x2C, 0x09, 0x29, 0x03, 0x2B, 
    0x08, 0x12, 0x07, 0x21, 0x04, 0x2A, 0x0F, 0x1A, 0x02, 0x2B, 
    0x05, 0x21, 0x1C, 0x23, 0x16, 0x1D, 0x0B, 0x06, 0x25, 0x2B, 
    0x1C, 0x18, 0x24, 0x02, 0x2A, 0x0C, 0x18, 0x11, 0x21, 0x25, 
    0x17, 0x1D, 0x0E, 0x24, 0x1A, 0x1F, 0x17, 0x00, 0x0C, 0x28, 
    0x20, 0x0D, 0x1D, 0x26, 0x31, 0x12, 0x2A, 0x26, 0x14, 0x2B, 
    0x0B, 0x00, 0x24, 0x11, 0x19, 0x29, 0x05, 0x25, 0x1D, 0x08, 0x23, 

    0x0E, 0x21, 0x30, 0x12, 0x18, 0x01, 0x1F, 0x2E, 0x1C, 0x17,         //  2
    0x09, 0x1F, 0x0F, 0x0A, 0x2B, 0x1B, 0x2F, 0x17, 0x0B, 0x22, 
    0x15, 0x28, 0x07, 0x30, 0x10, 0x01, 0x16, 0x1D, 0x24, 0x0F, 
    0x26, 0x1F, 0x31, 0x0C, 0x2D, 0x1F, 0x06, 0x22, 0x12, 0x23, 
    0x27, 0x0D, 0x07, 0x2D, 0x05, 0x29, 0x14, 0x30, 0x10, 0x01, 
    0x09, 0x2D, 0x0C, 0x15, 0x30, 0x23, 0x04, 0x1E, 0x0A, 0x2E, 
    0x01, 0x27, 0x08, 0x31, 0x04, 0x0D, 0x2F, 0x21, 0x1C, 0x31, 
    0x03, 0x15, 0x2D, 0x01, 0x09, 0x23, 0x0C, 0x03, 0x20, 0x10, 
    0x30, 0x17, 0x1F, 0x07, 0x2D, 0x0F, 0x1F, 0x16, 0x0D, 0x32, 0x16, 

    0x2B, 0x07, 0x0B, 0x25, 0x0D, 0x31, 0x11, 0x16, 0x03, 0x22,         //  3
    0x30, 0x01, 0x26, 0x18, 0x02, 0x20, 0x0C, 0x25, 0x05, 0x1B, 
    0x09, 0x10, 0x23, 0x17, 0x1E, 0x22, 0x32, 0x0B, 0x13, 0x2F, 
    0x19, 0x01, 0x16, 0x11, 0x1A, 0x0A, 0x16, 0x32, 0x1C, 0x09, 
    0x14, 0x30, 0x18, 0x11, 0x26, 0x0E, 0x21, 0x19, 0x20, 0x17, 
    0x23, 0x28, 0x1E, 0x07, 0x1A, 0x0F, 0x29, 0x32, 0x13, 0x1B, 
    0x10, 0x2B, 0x13, 0x20, 0x16, 0x26, 0x08, 0x13, 0x05, 0x0F, 
    0x24, 0x1A, 0x11, 0x21, 0x16, 0x1C, 0x2F, 0x17, 0x08, 0x1C, 
    0x04, 0x28, 0x0D, 0x25, 0x15, 0x08, 0x2E, 0x02, 0x26, 0x1B, 0x04, 

    0x11, 0x17, 0x2D, 0x1A, 0x06, 0x28, 0x23, 0x08, 0x2C, 0x0D,         //  4
    0x13, 0x1D, 0x2D, 0x11, 0x32, 0x07, 0x14, 0x2B, 0x11, 0x2E, 
    0x26, 0x1D, 0x02, 0x2A, 0x06, 0x0E, 0x1A, 0x05, 0x21, 0x07, 
    0x0D, 0x22, 0x2B, 0x27, 0x03, 0x24, 0x29, 0x03, 0x0F, 0x2B, 
    0x02, 0x20, 0x29, 0x00, 0x1F, 0x08, 0x2D, 0x03, 0x0D, 0x2E, 
    0x11, 0x04, 0x0E, 0x22, 0x20, 0x00, 0x15, 0x08, 0x24, 0x04, 
    0x21, 0x07, 0x1B, 0x0A, 0x2D, 0x0F, 0x2A, 0x23, 0x2C, 0x17, 
    0x2B, 0x08, 0x2A, 0x0D, 0x2C, 0x04, 0x10, 0x29, 0x24, 0x2D, 
    0x12, 0x18, 0x2C, 0x03, 0x1C, 0x28, 0x1A, 0x11, 0x2C, 0x0B, 0x1F, 

    0x30, 0x1E, 0x02, 0x22, 0x14, 0x1C, 0x0B, 0x1A, 0x25, 0x29,         //  5
    0x19, 0x06, 0x0D, 0x1A, 0x23, 0x28, 0x1C, 0x01, 0x20, 0x16, 
    0x04, 0x31, 0x14, 0x0B, 0x2E, 0x13, 0x27, 0x2D, 0x15, 0x26, 
    0x2C, 0x12, 0x06, 0x1C, 0x0E, 0x2E, 0x13, 0x1F, 0x27, 0x17, 
    0x1D, 0x0B, 0x13, 0x1B, 0x32, 0x18, 0x11, 0x25, 0x2A, 0x06, 
    0x1A, 0x31, 0x17, 0x2C, 0x11, 0x2D, 0x26, 0x1D, 0x0D, 0x2C, 
    0x16, 0x30, 0x24, 0x01, 0x18, 0x1E, 0x02, 0x1B, 0x09, 0x0C, 
    0x1E, 0x04, 0x23, 0x1B, 0x07, 0x27, 0x1F, 0x02, 0x19, 0x0C, 
    0x26, 0x09, 0x1D, 0x10, 0x2F, 0x13, 0x09, 0x20, 0x06, 0x18, 0x25, 

    0x10, 0x0A, 0x2A, 0x0E, 0x2C, 0x03, 0x2F, 0x12, 0x01, 0x09,         //  6
    0x20, 0x2C, 0x25, 0x04, 0x14, 0x0B, 0x2E, 0x0E, 0x29, 0x0B, 
    0x1A, 0x0E, 0x21, 0x1B, 0x24, 0x02, 0x1F, 0x0E, 0x01, 0x1C, 
    0x0A, 0x18, 0x30, 0x14, 0x20, 0x0B, 0x19, 0x07, 0x0D, 0x2F, 
    0x06, 0x2D, 0x25, 0x0E, 0x05, 0x27, 0x0A, 0x1D, 0x15, 0x0A, 
    0x24, 0x1F, 0x02, 0x0D, 0x1B, 0x0A, 0x18, 0x03, 0x28, 0x19, 
    0x05, 0x0C, 0x13, 0x2E, 0x26, 0x0B, 0x15, 0x32, 0x13, 0x28, 
    0x2F, 0x16, 0x0B, 0x31, 0x13, 0x18, 0x0A, 0x30, 0x13, 0x1F, 
    0x01, 0x31, 0x22, 0x07, 0x23, 0x01, 0x26, 0x31, 0x14, 0x29, 0x01, 

    0x21, 0x15, 0x1B, 0x06, 0x20, 0x10, 0x27, 0x1F, 0x16, 0x31,         //  7
    0x0F, 0x15, 0x0A, 0x30, 0x21, 0x03, 0x17, 0x1E, 0x06, 0x23, 
    0x2D, 0x26, 0x08, 0x11, 0x2C, 0x17, 0x08, 0x2A, 0x18, 0x31, 
    0x20, 0x04, 0x24, 0x08, 0x28, 0x00, 0x30, 0x24, 0x1D, 0x13, 
    0x22, 0x16, 0x09, 0x2C, 0x21, 0x15, 0x2F, 0x02, 0x20, 0x2D, 
    0x13, 0x08, 0x26, 0x2A, 0x05, 0x31, 0x20, 0x13, 0x2E, 0x0F, 
    0x1F, 0x29, 0x21, 0x0D, 0x04, 0x2B, 0x22, 0x07, 0x25, 0x03, 
    0x1C, 0x11, 0x26, 0x00, 0x21, 0x2C, 0x10, 0x23, 0x06, 0x2B, 
    0x15, 0x1A, 0x0E, 0x17, 0x2A, 0x0E, 0x1A, 0x0B, 0x1F, 0x0F, 0x2C, 

    0x05, 0x2F, 0x24, 0x13, 0x32, 0x17, 0x04, 0x0C, 0x29, 0x1B,         //  8
    0x05, 0x27, 0x1D, 0x18, 0x0F, 0x27, 0x2B, 0x12, 0x30, 0x15, 
    0x01, 0x18, 0x2A, 0x04, 0x21, 0x0F, 0x2F, 0x23, 0x11, 0x06, 
    0x0E, 0x29, 0x1A, 0x12, 0x2C, 0x17, 0x10, 0x2A, 0x03, 0x0A, 
    0x28, 0x01, 0x1E, 0x19, 0x03, 0x0C, 0x29, 0x18, 0x0D, 0x28, 
    0x0F, 0x2E, 0x16, 0x1E, 0x14, 0x25, 0x0E, 0x07, 0x23, 0x02, 
    0x31, 0x09, 0x17, 0x1B, 0x12, 0x1F, 0x10, 0x2E, 0x0E, 0x16, 
    0x21, 0x06, 0x2A, 0x1C, 0x0D, 0x05, 0x28, 0x1A, 0x0E, 0x25, 
    0x08, 0x27, 0x05, 0x2F, 0x1F, 0x15, 0x2D, 0x04, 0x22, 0x08, 0x19, 

    0x1D, 0x0D, 0x01, 0x28, 0x08, 0x1B, 0x24, 0x2E, 0x08, 0x22,         //  9
    0x11, 0x2E, 0x00, 0x2B, 0x08, 0x1B, 0x06, 0x24, 0x0C, 0x1D, 
    0x0A, 0x20, 0x14, 0x31, 0x0A, 0x1D, 0x15, 0x03, 0x1E, 0x27, 
    0x15, 0x2E, 0x02, 0x0D, 0x22, 0x1D, 0x05, 0x20, 0x15, 0x1A, 
    0x31, 0x10, 0x2A, 0x13, 0x30, 0x1C, 0x11, 0x25, 0x07, 0x1C, 
    0x01, 0x19, 0x07, 0x0C, 0x29, 0x01, 0x1C, 0x2B, 0x16, 0x1B, 
    0x12, 0x26, 0x01, 0x23, 0x31, 0x09, 0x1A, 0x00, 0x1D, 0x2C, 
    0x0A, 0x30, 0x0E, 0x18, 0x2F, 0x15, 0x1F, 0x01, 0x2F, 0x20, 
    0x12, 0x2D, 0x1E, 0x11, 0x0A, 0x06, 0x27, 0x1C, 0x13, 0x30, 0x27, 

    0x11, 0x2C, 0x17, 0x1E, 0x10, 0x2B, 0x0D, 0x16, 0x1D, 0x03,         // 10
    0x17, 0x23, 0x0C, 0x15, 0x25, 0x31, 0x0F, 0x18, 0x04, 0x29, 
    0x2F, 0x10, 0x03, 0x1C, 0x26, 0x05, 0x29, 0x0C, 0x2D, 0x1A, 
    0x09, 0x21, 0x1D, 0x32, 0x06, 0x13, 0x2E, 0x0E, 0x2B, 0x25, 
    0x0C, 0x1F, 0x06, 0x26, 0x08, 0x23, 0x01, 0x2B, 0x13, 0x32, 
    0x21, 0x2B, 0x23, 0x30, 0x11, 0x17, 0x2F, 0x0B, 0x28, 0x07, 
    0x2C, 0x1D, 0x0F, 0x2C, 0x06, 0x27, 0x15, 0x24, 0x29, 0x04, 
    0x1A, 0x13, 0x20, 0x04, 0x25, 0x08, 0x2B, 0x0C, 0x17, 0x04, 
    0x1B, 0x0C, 0x01, 0x28, 0x24, 0x1A, 0x10, 0x2E, 0x00, 0x17, 0x0B, 

    0x20, 0x26, 0x0A, 0x2F, 0x06, 0x21, 0x01, 0x27, 0x0F, 0x30,         // 11
    0x2A, 0x06, 0x1B, 0x20, 0x12, 0x02, 0x1F, 0x2D, 0x26, 0x1B, 
    0x0D, 0x23, 0x2C, 0x17, 0x10, 0x2F, 0x19, 0x20, 0x10, 0x04, 
    0x2B, 0x0F, 0x08, 0x15, 0x24, 0x28, 0x09, 0x1B, 0x02, 0x13, 
    0x08, 0x18, 0x2E, 0x0F, 0x17, 0x2D, 0x0C, 0x1F, 0x19, 0x05, 
    0x0C, 0x14, 0x04, 0x1A, 0x09, 0x21, 0x05, 0x1E, 0x13, 0x22, 
    0x0D, 0x05, 0x29, 0x13, 0x1F, 0x0E, 0x2F, 0x08, 0x12, 0x0D, 
    0x23, 0x27, 0x0A, 0x2E, 0x10, 0x1C, 0x13, 0x24, 0x2A, 0x10, 
    0x30, 0x22, 0x15, 0x19, 0x32, 0x03, 0x20, 0x09, 0x23, 0x29, 0x06, 

    0x14, 0x1A, 0x04, 0x24, 0x14, 0x1A, 0x31, 0x0A, 0x21, 0x15,         // 12
    0x0D, 0x26, 0x11, 0x2F, 0x0A, 0x29, 0x16, 0x0A, 0x11, 0x00, 
    0x18, 0x07, 0x28, 0x0B, 0x21, 0x07, 0x12, 0x00, 0x31, 0x24, 
    0x14, 0x26, 0x18, 0x2A, 0x01, 0x10, 0x18, 0x26, 0x30, 0x1E, 
    0x2C, 0x23, 0x01, 0x21, 0x1B, 0x06, 0x15, 0x2F, 0x0F, 0x27, 
    0x1B, 0x29, 0x10, 0x1F, 0x2C, 0x27, 0x12, 0x2A, 0x00, 0x19, 
    0x30, 0x21, 0x1B, 0x0A, 0x17, 0x02, 0x22, 0x1C, 0x2C, 0x17, 
    0x31, 0x02, 0x15, 0x1E, 0x28, 0x02, 0x32, 0x05, 0x1D, 0x09, 
    0x27, 0x06, 0x2B, 0x08, 0x0D, 0x13, 0x2B, 0x18, 0x0D, 0x1C, 0x2D, 

    0x0C, 0x31, 0x0E, 0x2A, 0x1E, 0x09, 0x12, 0x2A, 0x19, 0x05,         // 13
    0x1E, 0x09, 0x2A, 0x03, 0x19, 0x24, 0x05, 0x1D, 0x22, 0x30, 
    0x27, 0x1E, 0x14, 0x02, 0x2D, 0x1C, 0x2A, 0x26, 0x18, 0x0C, 
    0x1F, 0x05, 0x30, 0x0C, 0x1D, 0x2F, 0x22, 0x04, 0x0D, 0x11, 
    0x06, 0x29, 0x13, 0x0C, 0x2B, 0x26, 0x1D, 0x03, 0x23, 0x09, 
    0x2E, 0x00, 0x25, 0x16, 0x02, 0x0E, 0x1B, 0x0A, 0x2E, 0x10, 
    0x08, 0x16, 0x03, 0x2F, 0x23, 0x2B, 0x18, 0x04, 0x0B, 0x1F, 
    0x08, 0x1B, 0x2C, 0x07, 0x0D, 0x18, 0x20, 0x0F, 0x16, 0x22, 
    0x14, 0x1C, 0x10, 0x1F, 0x2D, 0x1D, 0x25, 0x05, 0x31, 0x11, 0x02, 

    0x27, 0x21, 0x17, 0x01, 0x11, 0x2D, 0x22, 0x03, 0x0E, 0x23,         // 14
    0x2D, 0x18, 0x14, 0x22, 0x0E, 0x2E, 0x13, 0x2B, 0x0D, 0x16, 
    0x09, 0x0F, 0x32, 0x1A, 0x25, 0x0D, 0x14, 0x09, 0x1D, 0x04, 
    0x2E, 0x0E, 0x1B, 0x23, 0x06, 0x12, 0x0A, 0x16, 0x2A, 0x21, 
    0x18, 0x0B, 0x1C, 0x2F, 0x04, 0x11, 0x0A, 0x28, 0x12, 0x1D, 
    0x14, 0x0D, 0x31, 0x07, 0x21, 0x30, 0x15, 0x26, 0x21, 0x1D, 
    0x27, 0x2B, 0x13, 0x26, 0x0B, 0x07, 0x12, 0x30, 0x26, 0x13, 
    0x28, 0x0E, 0x22, 0x13, 0x25, 0x2C, 0x09, 0x27, 0x2E, 0x01, 
    0x0D, 0x31, 0x03, 0x25, 0x12, 0x04, 0x0B, 0x15, 0x27, 0x21, 0x19, 

    0x05, 0x0B, 0x1D, 0x2E, 0x25, 0x06, 0x15, 0x1C, 0x30, 0x28,         // 15
    0x0D, 0x01, 0x32, 0x1D, 0x06, 0x1F, 0x08, 0x25, 0x02, 0x1C, 
    0x29, 0x04, 0x20, 0x09, 0x15, 0x05, 0x30, 0x21, 0x10, 0x29, 
    0x13, 0x27, 0x02, 0x14, 0x2C, 0x26, 0x1E, 0x2E, 0x1A, 0x00, 
    0x32, 0x25, 0x05, 0x1F, 0x16, 0x21, 0x31, 0x17, 0x2D, 0x04, 
    0x26, 0x19, 0x1E, 0x12, 0x29, 0x0C, 0x1E, 0x03, 0x08, 0x14, 
    0x0C, 0x05, 0x1E, 0x0F, 0x1A, 0x28, 0x1E, 0x0E, 0x20, 0x01, 
    0x2D, 0x06, 0x1A, 0x30, 0x00, 0x1C, 0x14, 0x06, 0x1A, 0x2B, 
    0x23, 0x19, 0x29, 0x09, 0x17, 0x27, 0x2F, 0x1B, 0x0F, 0x07, 0x2E, 

    0x13, 0x2B, 0x15, 0x08, 0x0F, 0x1E, 0x2C, 0x0B, 0x12, 0x04,         // 16
    0x1A, 0x25, 0x11, 0x0B, 0x2B, 0x17, 0x10, 0x31, 0x20, 0x12, 
    0x2E, 0x24, 0x12, 0x29, 0x2C, 0x1F, 0x19, 0x02, 0x2D, 0x23, 
    0x07, 0x19, 0x20, 0x29, 0x09, 0x16, 0x02, 0x0E, 0x09, 0x27, 
    0x0F, 0x14, 0x2C, 0x0D, 0x2A, 0x08, 0x1C, 0x02, 0x0E, 0x22, 
    0x2C, 0x08, 0x27, 0x0A, 0x19, 0x05, 0x2D, 0x10, 0x29, 0x32, 
    0x19, 0x22, 0x2E, 0x00, 0x31, 0x14, 0x04, 0x2D, 0x0A, 0x1C, 
    0x16, 0x23, 0x11, 0x09, 0x21, 0x0E, 0x30, 0x22, 0x0E, 0x15, 
    0x07, 0x0B, 0x13, 0x20, 0x2C, 0x0D, 0x1F, 0x02, 0x2C, 0x17, 0x1F, 

    0x24, 0x02, 0x28, 0x1F, 0x30, 0x17, 0x00, 0x27, 0x20, 0x16,         // 17
    0x22, 0x07, 0x29, 0x15, 0x24, 0x00, 0x28, 0x1A, 0x0A, 0x05, 
    0x18, 0x0C, 0x1B, 0x01, 0x10, 0x08, 0x28, 0x14, 0x0B, 0x1E, 
    0x15, 0x30, 0x0B, 0x12, 0x1D, 0x31, 0x22, 0x29, 0x13, 0x20, 
    0x1B, 0x07, 0x23, 0x18, 0x01, 0x25, 0x12, 0x2B, 0x1F, 0x07, 
    0x10, 0x16, 0x02, 0x2E, 0x22, 0x13, 0x25, 0x1C, 0x16, 0x04, 
    0x25, 0x0E, 0x08, 0x18, 0x24, 0x09, 0x2A, 0x17, 0x25, 0x11, 
    0x32, 0x04, 0x2B, 0x26, 0x16, 0x04, 0x29, 0x1D, 0x03, 0x25, 
    0x29, 0x1E, 0x2F, 0x01, 0x1A, 0x06, 0x13, 0x23, 0x09, 0x28, 0x0D, 

    0x32, 0x0F, 0x19, 0x0B, 0x04, 0x28, 0x0E, 0x1B, 0x07, 0x30,         // 18
    0x0A, 0x2C, 0x1B, 0x04, 0x2F, 0x1D, 0x0C, 0x14, 0x29, 0x2D, 
    0x22, 0x07, 0x2E, 0x26, 0x18, 0x2F, 0x0C, 0x1C, 0x2A, 0x03, 
    0x0E, 0x22, 0x00, 0x2D, 0x05, 0x10, 0x08, 0x18, 0x30, 0x03, 
    0x2D, 0x0D, 0x28, 0x11, 0x2F, 0x1A, 0x0B, 0x27, 0x14, 0x1A, 
    0x32, 0x1F, 0x2A, 0x1A, 0x0E, 0x31, 0x01, 0x0B, 0x21, 0x10, 
    0x2C, 0x13, 0x1D, 0x2B, 0x11, 0x1C, 0x21, 0x0F, 0x02, 0x28, 
    0x08, 0x1F, 0x18, 0x0C, 0x2F, 0x1B, 0x11, 0x0A, 0x17, 0x32, 
    0x10, 0x05, 0x16, 0x0F, 0x26, 0x31, 0x18, 0x2A, 0x12, 0x1C, 0x07, 

    0x16, 0x1E, 0x2D, 0x26, 0x13, 0x21, 0x2E, 0x14, 0x2A, 0x10,         // 19
    0x1D, 0x14, 0x0C, 0x20, 0x10, 0x07, 0x2E, 0x1F, 0x02, 0x10, 
    0x1D, 0x14, 0x23, 0x05, 0x1E, 0x12, 0x22, 0x05, 0x31, 0x25, 
    0x1B, 0x2B, 0x16, 0x25, 0x19, 0x27, 0x1E, 0x11, 0x24, 0x0B, 
    0x16, 0x21, 0x04, 0x1D, 0x09, 0x21, 0x05, 0x30, 0x0C, 0x25, 
    0x05, 0x0C, 0x12, 0x04, 0x21, 0x08, 0x18, 0x26, 0x2F, 0x06, 
    0x1F, 0x02, 0x26, 0x0B, 0x03, 0x2F, 0x07, 0x1A, 0x2E, 0x1D, 
    0x14, 0x0E, 0x29, 0x03, 0x20, 0x07, 0x23, 0x2D, 0x1F, 0x08, 
    0x22, 0x1C, 0x2C, 0x23, 0x08, 0x1D, 0x03, 0x0C, 0x2F, 0x00, 0x22, 

    0x08, 0x0E, 0x02, 0x16, 0x06, 0x1B, 0x0A, 0x02, 0x24, 0x05,         // 20
    0x26, 0x01, 0x31, 0x28, 0x15, 0x1B, 0x24, 0x0A, 0x17, 0x27, 
    0x06, 0x30, 0x0F, 0x0B, 0x2C, 0x02, 0x21, 0x16, 0x10, 0x08, 
    0x13, 0x06, 0x0D, 0x1F, 0x0A, 0x2F, 0x01, 0x2C, 0x07, 0x1D, 
    0x2B, 0x10, 0x31, 0x16, 0x2B, 0x10, 0x17, 0x1D, 0x02, 0x2B, 
    0x16, 0x28, 0x23, 0x17, 0x2C, 0x1D, 0x2A, 0x11, 0x0A, 0x18, 
    0x28, 0x16, 0x31, 0x22, 0x16, 0x28, 0x13, 0x24, 0x0C, 0x05, 
    0x23, 0x30, 0x1C, 0x11, 0x27, 0x14, 0x2A, 0x01, 0x15, 0x0D, 
    0x29, 0x17, 0x03, 0x0B, 0x19, 0x2D, 0x20, 0x16, 0x25, 0x19, 0x29, 

    0x30, 0x23, 0x2B, 0x1F, 0x31, 0x10, 0x2A, 0x1F, 0x17, 0x2E,         // 21
    0x0F, 0x1F, 0x17, 0x06, 0x25, 0x02, 0x2B, 0x11, 0x31, 0x20, 
    0x0B, 0x1A, 0x2A, 0x1C, 0x15, 0x27, 0x0E, 0x1B, 0x24, 0x2D, 
    0x1F, 0x28, 0x31, 0x11, 0x06, 0x15, 0x21, 0x0E, 0x17, 0x25, 
    0x01, 0x1A, 0x08, 0x26, 0x05, 0x24, 0x2E, 0x0F, 0x21, 0x12, 
    0x1E, 0x00, 0x30, 0x08, 0x0C, 0x14, 0x05, 0x22, 0x1C, 0x2E, 
    0x08, 0x10, 0x06, 0x1A, 0x0E, 0x1E, 0x01, 0x31, 0x12, 0x2B, 
    0x18, 0x00, 0x0B, 0x2D, 0x18, 0x08, 0x0E, 0x1A, 0x25, 0x2F, 
    0x06, 0x0E, 0x2F, 0x27, 0x15, 0x0F, 0x05, 0x2B, 0x07, 0x0D, 0x13, 

    0x03, 0x19, 0x09, 0x12, 0x26, 0x08, 0x23, 0x0C, 0x12, 0x1B,         // 22
    0x2A, 0x08, 0x23, 0x0F, 0x2D, 0x0E, 0x18, 0x07, 0x1C, 0x03, 
    0x28, 0x13, 0x00, 0x22, 0x07, 0x32, 0x09, 0x2B, 0x02, 0x0B, 
    0x15, 0x01, 0x1A, 0x24, 0x2A, 0x1D, 0x0B, 0x28, 0x32, 0x12, 
    0x0B, 0x28, 0x20, 0x13, 0x0C, 0x19, 0x04, 0x29, 0x07, 0x2F, 
    0x09, 0x1A, 0x10, 0x1F, 0x25, 0x32, 0x0F, 0x2C, 0x03, 0x13, 
    0x24, 0x2B, 0x1F, 0x2E, 0x05, 0x2C, 0x0B, 0x17, 0x20, 0x08, 
    0x27, 0x13, 0x20, 0x06, 0x22, 0x30, 0x1F, 0x2C, 0x04, 0x12, 
    0x1D, 0x24, 0x13, 0x1F, 0x04, 0x29, 0x23, 0x11, 0x1D, 0x2C, 0x20, 

    0x28, 0x10, 0x2A, 0x1C, 0x01, 0x18, 0x2C, 0x03, 0x32, 0x06,         // 23
    0x0D, 0x16, 0x29, 0x1B, 0x09, 0x1F, 0x22, 0x27, 0x12, 0x2C, 
    0x0E, 0x1F, 0x2F, 0x0D, 0x19, 0x12, 0x1F, 0x17, 0x27, 0x1C, 
    0x2F, 0x20, 0x0E, 0x04, 0x17, 0x2E, 0x03, 0x1A, 0x05, 0x22, 
    0x2E, 0x15, 0x05, 0x30, 0x1E, 0x27, 0x0D, 0x1F, 0x18, 0x26, 
    0x0D, 0x2B, 0x27, 0x06, 0x1A, 0x02, 0x1E, 0x16, 0x28, 0x0D, 
    0x19, 0x00, 0x0B, 0x14, 0x25, 0x19, 0x23, 0x2A, 0x05, 0x1C, 
    0x0E, 0x2C, 0x1A, 0x2A, 0x0F, 0x02, 0x13, 0x0A, 0x23, 0x18, 
    0x28, 0x00, 0x1B, 0x08, 0x30, 0x1A, 0x09, 0x32, 0x17, 0x05, 0x0C, 

    0x15, 0x20, 0x06, 0x2D, 0x0D, 0x20, 0x13, 0x1C, 0x24, 0x28,         // 24
    0x1E, 0x2D, 0x01, 0x13, 0x31, 0x15, 0x03, 0x2F, 0x0A, 0x18, 
    0x24, 0x06, 0x17, 0x2B, 0x26, 0x03, 0x2D, 0x06, 0x0E, 0x12, 
    0x08, 0x26, 0x14, 0x29, 0x09, 0x11, 0x26, 0x15, 0x1F, 0x09, 
    0x1D, 0x0D, 0x2A, 0x17, 0x02, 0x2B, 0x13, 0x32, 0x01, 0x15, 
    0x22, 0x04, 0x14, 0x2E, 0x12, 0x28, 0x0C, 0x24, 0x06, 0x1E, 
    0x31, 0x23, 0x18, 0x27, 0x07, 0x11, 0x03, 0x15, 0x0F, 0x30, 
    0x24, 0x0A, 0x03, 0x14, 0x1D, 0x27, 0x1B, 0x29, 0x0F, 0x06, 
    0x30, 0x0B, 0x2C, 0x10, 0x21, 0x0D, 0x15, 0x02, 0x24, 0x2E, 0x1C, 

    0x01, 0x30, 0x0B, 0x18, 0x25, 0x30, 0x07, 0x0D, 0x18, 0x04,         // 25
    0x11, 0x09, 0x20, 0x26, 0x05, 0x28, 0x0C, 0x1A, 0x20, 0x01, 
    0x2E, 0x11, 0x09, 0x20, 0x0C, 0x1C, 0x14, 0x23, 0x31, 0x1F, 
    0x2B, 0x05, 0x1B, 0x30, 0x1E, 0x22, 0x0C, 0x30, 0x0F, 0x2B, 
    0x02, 0x19, 0x24, 0x11, 0x0A, 0x22, 0x06, 0x1D, 0x0A, 0x2D, 
    0x10, 0x1E, 0x19, 0x0B, 0x21, 0x07, 0x2B, 0x12, 0x2E, 0x09, 
    0x10, 0x04, 0x2B, 0x0D, 0x32, 0x1D, 0x28, 0x2E, 0x22, 0x01, 
    0x17, 0x1E, 0x2E, 0x26, 0x0B, 0x32, 0x06, 0x16, 0x2D, 0x1E, 
    0x13, 0x19, 0x23, 0x16, 0x02, 0x2C, 0x26, 0x1E, 0x0B, 0x12, 0x29, 

    0x0F, 0x1A, 0x22, 0x13, 0x04, 0x0F, 0x29, 0x22, 0x2F, 0x14,         // 26
    0x23, 0x30, 0x18, 0x0B, 0x1D, 0x11, 0x2C, 0x24, 0x0F, 0x14, 
    0x28, 0x22, 0x1B, 0x02, 0x2D, 0x10, 0x29, 0x0A, 0x00, 0x1B, 
    0x10, 0x24, 0x0D, 0x01, 0x13, 0x07, 0x28, 0x00, 0x23, 0x18, 
    0x26, 0x31, 0x04, 0x1F, 0x2F, 0x1B, 0x10, 0x29, 0x24, 0x1B, 
    0x05, 0x31, 0x25, 0x01, 0x2D, 0x1B, 0x17, 0x02, 0x22, 0x18, 
    0x2A, 0x1C, 0x13, 0x1F, 0x01, 0x15, 0x09, 0x0D, 0x1F, 0x12, 
    0x2A, 0x0F, 0x08, 0x16, 0x05, 0x20, 0x0D, 0x24, 0x02, 0x22, 
    0x08, 0x27, 0x05, 0x2B, 0x1C, 0x11, 0x06, 0x2A, 0x1A, 0x07, 0x21, 

    0x08, 0x27, 0x03, 0x2B, 0x1F, 0x1B, 0x16, 0x01, 0x0A, 0x1B,         // 27
    0x2A, 0x03, 0x10, 0x2B, 0x23, 0x17, 0x08, 0x04, 0x32, 0x1C, 
    0x05, 0x0D, 0x2F, 0x14, 0x23, 0x05, 0x1F, 0x18, 0x27, 0x15, 
    0x09, 0x2C, 0x17, 0x27, 0x2D, 0x18, 0x1C, 0x2C, 0x09, 0x11, 
    0x06, 0x14, 0x0B, 0x28, 0x0D, 0x15, 0x2D, 0x03, 0x12, 0x0C, 
    0x2A, 0x08, 0x11, 0x29, 0x14, 0x0D, 0x2F, 0x1F, 0x0B, 0x26, 
    0x11, 0x07, 0x2F, 0x0A, 0x22, 0x2D, 0x25, 0x1A, 0x07, 0x26, 
    0x04, 0x30, 0x21, 0x1C, 0x2A, 0x11, 0x19, 0x2F, 0x12, 0x1B, 
    0x0E, 0x31, 0x14, 0x0A, 0x24, 0x2F, 0x18, 0x0E, 0x30, 0x16, 0x2B, 

    0x13, 0x32, 0x17, 0x09, 0x2E, 0x0C, 0x25, 0x2D, 0x20, 0x0E,         // 28
    0x07, 0x20, 0x1B, 0x0A, 0x00, 0x2E, 0x1F, 0x13, 0x26, 0x09, 
    0x2C, 0x16, 0x27, 0x07, 0x1A, 0x31, 0x0F, 0x2C, 0x0C, 0x2F, 
    0x22, 0x03, 0x1E, 0x0E, 0x23, 0x05, 0x0D, 0x15, 0x1E, 0x2F, 
    0x21, 0x1C, 0x2C, 0x18, 0x00, 0x25, 0x08, 0x21, 0x17, 0x26, 
    0x1E, 0x16, 0x21, 0x06, 0x1E, 0x03, 0x27, 0x07, 0x16, 0x30, 
    0x03, 0x21, 0x26, 0x18, 0x0F, 0x1C, 0x02, 0x11, 0x31, 0x15, 
    0x1B, 0x0B, 0x12, 0x00, 0x2E, 0x23, 0x03, 0x28, 0x07, 0x2B, 
    0x25, 0x01, 0x1F, 0x19, 0x10, 0x08, 0x1F, 0x00, 0x23, 0x05, 0x1C, 

    0x20, 0x0D, 0x1D, 0x11, 0x26, 0x03, 0x12, 0x08, 0x15, 0x28,         // 29
    0x2F, 0x12, 0x26, 0x31, 0x14, 0x0E, 0x28, 0x19, 0x0D, 0x20, 
    0x19, 0x00, 0x1F, 0x11, 0x25, 0x0A, 0x16, 0x02, 0x25, 0x06, 
    0x1C, 0x13, 0x32, 0x08, 0x15, 0x30, 0x28, 0x22, 0x04, 0x0C, 
    0x28, 0x0F, 0x05, 0x24, 0x1D, 0x2F, 0x0E, 0x1C, 0x31, 0x01, 
    0x10, 0x2E, 0x0B, 0x19, 0x2B, 0x23, 0x13, 0x1C, 0x2A, 0x0C, 
    0x1D, 0x16, 0x08, 0x2A, 0x04, 0x15, 0x27, 0x2A, 0x20, 0x09, 
    0x2C, 0x23, 0x28, 0x18, 0x09, 0x0E, 0x16, 0x1E, 0x0C, 0x14, 
    0x1A, 0x0F, 0x2D, 0x27, 0x03, 0x2A, 0x15, 0x28, 0x10, 0x2E, 0x0B, 

    0x01, 0x2D, 0x22, 0x06, 0x18, 0x30, 0x1D, 0x2B, 0x19, 0x03,         // 30
    0x1D, 0x08, 0x16, 0x04, 0x1E, 0x24, 0x03, 0x30, 0x06, 0x27, 
    0x11, 0x31, 0x0B, 0x2D, 0x03, 0x2A, 0x1D, 0x20, 0x11, 0x17, 
    0x2B, 0x0B, 0x24, 0x1B, 0x02, 0x20, 0x0A, 0x12, 0x2D, 0x1A, 
    0x01, 0x15, 0x32, 0x0A, 0x11, 0x05, 0x26, 0x14, 0x0A, 0x2A, 
    0x19, 0x05, 0x23, 0x2F, 0x0F, 0x09, 0x31, 0x10, 0x01, 0x25, 
    0x12, 0x2E, 0x0F, 0x23, 0x31, 0x1F, 0x0C, 0x06, 0x0F, 0x19, 
    0x02, 0x13, 0x0D, 0x2D, 0x1D, 0x27, 0x31, 0x05, 0x26, 0x30, 
    0x04, 0x21, 0x09, 0x12, 0x21, 0x1B, 0x31, 0x0A, 0x1D, 0x17, 0x29, 

    0x23, 0x19, 0x0A, 0x2B, 0x23, 0x14, 0x05, 0x21, 0x0A, 0x26,         // 31
    0x10, 0x22, 0x2A, 0x0C, 0x2C, 0x1A, 0x0B, 0x11, 0x1D, 0x2B, 
    0x04, 0x22, 0x15, 0x1B, 0x22, 0x13, 0x09, 0x30, 0x29, 0x0D, 
    0x1F, 0x01, 0x29, 0x10, 0x2C, 0x1C, 0x06, 0x18, 0x25, 0x11, 
    0x2B, 0x1F, 0x1B, 0x28, 0x17, 0x1F, 0x2C, 0x03, 0x23, 0x0E, 
    0x1F, 0x27, 0x13, 0x00, 0x16, 0x1B, 0x06, 0x20, 0x2D, 0x1E, 
    0x0A, 0x27, 0x00, 0x1B, 0x06, 0x12, 0x2D, 0x1D, 0x24, 0x2E, 
    0x28, 0x1F, 0x05, 0x24, 0x03, 0x14, 0x0A, 0x22, 0x19, 0x0E, 
    0x1E, 0x2B, 0x17, 0x2F, 0x06, 0x0C, 0x13, 0x03, 0x22, 0x07, 0x13, 

    0x31, 0x04, 0x15, 0x1D, 0x00, 0x0C, 0x29, 0x0F, 0x31, 0x14,         // 32
    0x2C, 0x01, 0x18, 0x23, 0x07, 0x16, 0x2E, 0x21, 0x15, 0x0C, 
    0x1B, 0x08, 0x2B, 0x04, 0x0D, 0x2E, 0x19, 0x03, 0x1B, 0x07, 
    0x2E, 0x15, 0x1A, 0x09, 0x25, 0x11, 0x29, 0x31, 0x03, 0x0B, 
    0x24, 0x07, 0x0E, 0x02, 0x2E, 0x0B, 0x19, 0x11, 0x2E, 0x16, 
    0x07, 0x32, 0x0A, 0x1F, 0x29, 0x24, 0x2B, 0x0C, 0x14, 0x06, 
    0x19, 0x2B, 0x22, 0x16, 0x0B, 0x28, 0x18, 0x03, 0x13, 0x0D, 
    0x07, 0x16, 0x31, 0x19, 0x0F, 0x2C, 0x1D, 0x11, 0x00, 0x29, 
    0x07, 0x11, 0x02, 0x24, 0x1C, 0x2C, 0x26, 0x19, 0x2E, 0x28, 0x0E, 

    0x0B, 0x27, 0x2C, 0x0F, 0x30, 0x26, 0x1E, 0x18, 0x04, 0x21,         // 33
    0x09, 0x1E, 0x0E, 0x31, 0x12, 0x26, 0x01, 0x29, 0x06, 0x30, 
    0x26, 0x12, 0x24, 0x18, 0x1F, 0x06, 0x27, 0x0F, 0x21, 0x14, 
    0x26, 0x0D, 0x22, 0x30, 0x04, 0x17, 0x0D, 0x22, 0x1E, 0x16, 
    0x2F, 0x14, 0x22, 0x2A, 0x12, 0x25, 0x07, 0x28, 0x1C, 0x01, 
    0x25, 0x12, 0x18, 0x2D, 0x0C, 0x12, 0x02, 0x19, 0x28, 0x31, 
    0x11, 0x07, 0x0D, 0x1F, 0x2C, 0x23, 0x09, 0x32, 0x27, 0x1B, 
    0x22, 0x10, 0x29, 0x0A, 0x21, 0x28, 0x06, 0x2D, 0x24, 0x14, 
    0x2E, 0x1A, 0x27, 0x0F, 0x18, 0x0A, 0x1E, 0x0D, 0x05, 0x16, 0x1F, 

    0x1C, 0x13, 0x20, 0x09, 0x17, 0x07, 0x12, 0x2E, 0x0C, 0x1B,         // 34
    0x2F, 0x15, 0x28, 0x04, 0x20, 0x0A, 0x1C, 0x11, 0x1F, 0x17, 
    0x01, 0x2D, 0x0A, 0x32, 0x11, 0x25, 0x15, 0x2C, 0x0A, 0x31, 
    0x03, 0x1D, 0x06, 0x13, 0x1F, 0x2D, 0x01, 0x19, 0x08, 0x26, 
    0x04, 0x1D, 0x09, 0x18, 0x04, 0x1D, 0x31, 0x0D, 0x22, 0x0C, 
    0x2C, 0x1D, 0x03, 0x22, 0x07, 0x1D, 0x2F, 0x0F, 0x22, 0x03, 
    0x24, 0x1C, 0x2F, 0x13, 0x02, 0x10, 0x20, 0x15, 0x0C, 0x00, 
    0x2F, 0x09, 0x1D, 0x14, 0x01, 0x1A, 0x0C, 0x16, 0x1B, 0x09, 
    0x21, 0x0D, 0x32, 0x07, 0x29, 0x02, 0x30, 0x14, 0x2B, 0x25, 0x01, 

    0x0A, 0x25, 0x02, 0x1B, 0x2C, 0x22, 0x02, 0x24, 0x2A, 0x10,         // 35
    0x03, 0x23, 0x0A, 0x19, 0x2B, 0x14, 0x2F, 0x0D, 0x28, 0x09, 
    0x22, 0x0E, 0x1C, 0x02, 0x29, 0x08, 0x1E, 0x01, 0x18, 0x24, 
    0x11, 0x2B, 0x27, 0x19, 0x0A, 0x24, 0x28, 0x11, 0x30, 0x0E, 
    0x2B, 0x11, 0x28, 0x2F, 0x21, 0x0F, 0x15, 0x05, 0x17, 0x28, 
    0x10, 0x09, 0x2F, 0x10, 0x2A, 0x15, 0x26, 0x05, 0x1E, 0x0B, 
    0x17, 0x29, 0x05, 0x26, 0x1B, 0x2D, 0x06, 0x1A, 0x29, 0x24, 
    0x13, 0x2C, 0x05, 0x26, 0x2F, 0x12, 0x22, 0x30, 0x03, 0x2B, 
    0x13, 0x01, 0x1E, 0x15, 0x23, 0x13, 0x20, 0x08, 0x1A, 0x11, 0x2F, 

    0x2A, 0x0F, 0x30, 0x11, 0x28, 0x0A, 0x1C, 0x16, 0x07, 0x20,         // 36
    0x27, 0x12, 0x2E, 0x0F, 0x1D, 0x03, 0x24, 0x05, 0x2C, 0x1A, 
    0x13, 0x27, 0x16, 0x22, 0x0F, 0x1B, 0x2E, 0x0D, 0x29, 0x1C, 
    0x09, 0x17, 0x0B, 0x2E, 0x10, 0x07, 0x1D, 0x05, 0x23, 0x17, 
    0x20, 0x00, 0x1A, 0x0C, 0x07, 0x2B, 0x27, 0x1F, 0x2D, 0x04, 
    0x1F, 0x16, 0x23, 0x19, 0x03, 0x20, 0x0A, 0x19, 0x2F, 0x13, 
    0x2D, 0x10, 0x09, 0x16, 0x0C, 0x27, 0x13, 0x2F, 0x04, 0x0F, 
    0x19, 0x21, 0x16, 0x1E, 0x0A, 0x2A, 0x04, 0x1E, 0x11, 0x25, 
    0x18, 0x22, 0x08, 0x2C, 0x0B, 0x2E, 0x0E, 0x28, 0x22, 0x06, 0x18, 

    0x04, 0x1D, 0x16, 0x07, 0x1F, 0x0F, 0x32, 0x0D, 0x2C, 0x18,         // 37
    0x06, 0x1B, 0x00, 0x22, 0x08, 0x29, 0x18, 0x13, 0x1E, 0x03, 
    0x30, 0x07, 0x2C, 0x06, 0x30, 0x14, 0x04, 0x21, 0x16, 0x05, 
    0x2D, 0x1F, 0x00, 0x21, 0x29, 0x1A, 0x2D, 0x14, 0x2A, 0x0C, 
    0x07, 0x32, 0x26, 0x17, 0x1E, 0x12, 0x01, 0x19, 0x09, 0x13, 
    0x31, 0x27, 0x07, 0x2B, 0x0C, 0x32, 0x12, 0x2A, 0x07, 0x23, 
    0x01, 0x1E, 0x22, 0x31, 0x1E, 0x01, 0x21, 0x0A, 0x1D, 0x2C, 
    0x06, 0x0B, 0x28, 0x02, 0x0F, 0x1B, 0x14, 0x29, 0x0C, 0x05, 
    0x30, 0x0F, 0x26, 0x19, 0x04, 0x1D, 0x18, 0x00, 0x32, 0x0D, 0x1F, 

    0x27, 0x09, 0x2C, 0x24, 0x03, 0x19, 0x25, 0x01, 0x1E, 0x0B,         // 38
    0x31, 0x29, 0x16, 0x2D, 0x1F, 0x0D, 0x32, 0x0A, 0x26, 0x0F, 
    0x21, 0x0D, 0x1E, 0x19, 0x0B, 0x25, 0x2B, 0x11, 0x31, 0x0E, 
    0x26, 0x12, 0x30, 0x0E, 0x16, 0x03, 0x0B, 0x1F, 0x02, 0x1C, 
    0x24, 0x15, 0x10, 0x03, 0x2E, 0x25, 0x0B, 0x30, 0x25, 0x1B, 
    0x0C, 0x00, 0x12, 0x1D, 0x14, 0x24, 0x01, 0x1F, 0x10, 0x28, 
    0x1A, 0x0C, 0x28, 0x04, 0x12, 0x2B, 0x18, 0x10, 0x27, 0x14, 
    0x23, 0x30, 0x13, 0x2B, 0x22, 0x32, 0x08, 0x23, 0x17, 0x2A, 
    0x1B, 0x0A, 0x2E, 0x11, 0x21, 0x0D, 0x25, 0x12, 0x1D, 0x15, 0x2D, 

    0x12, 0x1A, 0x0D, 0x29, 0x14, 0x2D, 0x10, 0x29, 0x13, 0x24,         // 39
    0x11, 0x20, 0x0E, 0x06, 0x13, 0x1A, 0x21, 0x06, 0x2D, 0x1A, 
    0x15, 0x2B, 0x04, 0x27, 0x11, 0x1F, 0x07, 0x1A, 0x02, 0x1E, 
    0x18, 0x04, 0x1B, 0x08, 0x1F, 0x32, 0x27, 0x0F, 0x2F, 0x12, 
    0x29, 0x09, 0x2C, 0x20, 0x0A, 0x15, 0x1C, 0x0F, 0x05, 0x2B, 
    0x22, 0x19, 0x2E, 0x25, 0x05, 0x18, 0x2D, 0x0A, 0x17, 0x05, 
    0x2C, 0x15, 0x08, 0x2D, 0x1A, 0x0C, 0x25, 0x07, 0x31, 0x01, 
    0x1B, 0x08, 0x1E, 0x0C, 0x18, 0x04, 0x11, 0x2E, 0x07, 0x20, 
    0x00, 0x13, 0x1E, 0x02, 0x28, 0x30, 0x05, 0x2A, 0x08, 0x25, 0x03, 

    0x23, 0x31, 0x00, 0x1D, 0x08, 0x22, 0x04, 0x1A, 0x07, 0x2D,         // 40
    0x0A, 0x04, 0x1A, 0x26, 0x2F, 0x02, 0x29, 0x17, 0x0E, 0x00, 
    0x26, 0x0A, 0x13, 0x2F, 0x01, 0x1C, 0x29, 0x0C, 0x23, 0x2D, 
    0x0B, 0x2A, 0x23, 0x2C, 0x13, 0x23, 0x07, 0x17, 0x25, 0x04, 
    0x18, 0x1F, 0x04, 0x19, 0x26, 0x05, 0x2C, 0x21, 0x18, 0x0A, 
    0x11, 0x1F, 0x08, 0x0E, 0x30, 0x0C, 0x1B, 0x27, 0x21, 0x31, 
    0x0E, 0x24, 0x1C, 0x10, 0x22, 0x05, 0x2D, 0x1F, 0x18, 0x0D, 
    0x2B, 0x11, 0x26, 0x06, 0x2D, 0x20, 0x26, 0x1B, 0x0F, 0x15, 
    0x2F, 0x23, 0x2A, 0x18, 0x07, 0x14, 0x21, 0x19, 0x2E, 0x0C, 0x18, 

    0x08, 0x0F, 0x21, 0x17, 0x2F, 0x0C, 0x1E, 0x30, 0x25, 0x17,         // 41
    0x1D, 0x22, 0x2A, 0x0C, 0x24, 0x0A, 0x12, 0x1E, 0x2B, 0x23, 
    0x31, 0x1C, 0x22, 0x18, 0x2B, 0x0E, 0x16, 0x30, 0x13, 0x06, 
    0x20, 0x14, 0x09, 0x10, 0x04, 0x19, 0x0D, 0x2C, 0x1D, 0x0A, 
    0x30, 0x0E, 0x2A, 0x13, 0x31, 0x0F, 0x24, 0x12, 0x01, 0x32, 
    0x27, 0x03, 0x2A, 0x17, 0x1E, 0x28, 0x06, 0x13, 0x08, 0x1A, 
    0x02, 0x13, 0x2F, 0x00, 0x28, 0x15, 0x1B, 0x03, 0x11, 0x26, 
    0x20, 0x03, 0x2F, 0x1B, 0x10, 0x16, 0x0A, 0x03, 0x2C, 0x27, 
    0x0D, 0x06, 0x10, 0x0B, 0x2C, 0x1B, 0x0B, 0x04, 0x10, 0x1F, 0x2B, 

    0x26, 0x15, 0x2C, 0x05, 0x10, 0x2A, 0x16, 0x0A, 0x12, 0x01,         // 42
    0x0E, 0x31, 0x12, 0x03, 0x16, 0x1F, 0x30, 0x0B, 0x05, 0x13, 
    0x07, 0x10, 0x03, 0x0A, 0x24, 0x06, 0x21, 0x03, 0x28, 0x1A, 
    0x0F, 0x31, 0x1C, 0x28, 0x2D, 0x1E, 0x25, 0x00, 0x15, 0x21, 
    0x11, 0x26, 0x07, 0x1D, 0x02, 0x18, 0x09, 0x2D, 0x1D, 0x24, 
    0x14, 0x1B, 0x0F, 0x24, 0x04, 0x11, 0x20, 0x2F, 0x0F, 0x2A, 
    0x1F, 0x26, 0x09, 0x1E, 0x0D, 0x31, 0x0B, 0x27, 0x2D, 0x09, 
    0x19, 0x15, 0x0B, 0x23, 0x02, 0x28, 0x31, 0x1F, 0x16, 0x05, 
    0x20, 0x1A, 0x32, 0x25, 0x1F, 0x11, 0x30, 0x23, 0x29, 0x14, 0x02, 

    0x1F, 0x0A, 0x1A, 0x27, 0x23, 0x1C, 0x02, 0x28, 0x1F, 0x2C,         // 43
    0x26, 0x07, 0x19, 0x2E, 0x1C, 0x06, 0x27, 0x1A, 0x22, 0x18, 
    0x1F, 0x27, 0x2C, 0x15, 0x32, 0x1D, 0x13, 0x25, 0x0A, 0x2C, 
    0x04, 0x24, 0x07, 0x17, 0x02, 0x0B, 0x31, 0x10, 0x29, 0x05, 
    0x2C, 0x1A, 0x22, 0x0B, 0x2A, 0x20, 0x27, 0x06, 0x16, 0x0C, 
    0x05, 0x2D, 0x09, 0x2F, 0x15, 0x2B, 0x00, 0x18, 0x23, 0x05, 
    0x16, 0x0C, 0x2A, 0x17, 0x24, 0x06, 0x13, 0x22, 0x1C, 0x06, 
    0x32, 0x28, 0x12, 0x2C, 0x1D, 0x0C, 0x11, 0x22, 0x0B, 0x1C, 
    0x2B, 0x13, 0x01, 0x16, 0x05, 0x2A, 0x01, 0x16, 0x1C, 0x0C, 0x2E, 

    0x10, 0x31, 0x02, 0x13, 0x07, 0x0D, 0x32, 0x11, 0x1A, 0x06,         // 44
    0x14, 0x21, 0x0C, 0x24, 0x10, 0x2C, 0x0D, 0x01, 0x2D, 0x09, 
    0x2F, 0x0C, 0x23, 0x1A, 0x0C, 0x07, 0x2E, 0x1A, 0x12, 0x1E, 
    0x16, 0x2E, 0x0D, 0x21, 0x26, 0x14, 0x1B, 0x08, 0x18, 0x1F, 
    0x0B, 0x01, 0x16, 0x2D, 0x13, 0x0D, 0x1B, 0x11, 0x2F, 0x20, 
    0x29, 0x11, 0x1D, 0x21, 0x0B, 0x1C, 0x26, 0x0A, 0x2C, 0x11, 
    0x30, 0x1A, 0x05, 0x11, 0x2E, 0x19, 0x2B, 0x03, 0x16, 0x10, 
    0x23, 0x00, 0x1F, 0x08, 0x16, 0x2B, 0x19, 0x01, 0x2F, 0x0F, 
    0x26, 0x0A, 0x2C, 0x22, 0x0F, 0x18, 0x26, 0x09, 0x2D, 0x05, 0x18, 

    0x07, 0x1D, 0x29, 0x20, 0x2D, 0x18, 0x22, 0x04, 0x2E, 0x0B,         // 45
    0x2A, 0x1B, 0x00, 0x29, 0x09, 0x17, 0x21, 0x13, 0x29, 0x0F, 
    0x1D, 0x05, 0x12, 0x02, 0x20, 0x26, 0x0E, 0x00, 0x28, 0x0C, 
    0x23, 0x02, 0x1C, 0x11, 0x2F, 0x06, 0x2A, 0x23, 0x2F, 0x0F, 
    0x28, 0x30, 0x10, 0x1E, 0x07, 0x31, 0x05, 0x29, 0x02, 0x19, 
    0x07, 0x24, 0x01, 0x13, 0x06, 0x32, 0x0E, 0x1A, 0x07, 0x1D, 
    0x01, 0x24, 0x2C, 0x21, 0x02, 0x0E, 0x1F, 0x0A, 0x2F, 0x29, 
    0x0C, 0x18, 0x0E, 0x30, 0x04, 0x21, 0x09, 0x27, 0x14, 0x23, 
    0x03, 0x18, 0x1E, 0x07, 0x2F, 0x1C, 0x0E, 0x20, 0x13, 0x28, 0x23, 

    0x2B, 0x15, 0x0D, 0x08, 0x11, 0x28, 0x0B, 0x15, 0x24, 0x1E,         // 46
    0x0F, 0x2F, 0x15, 0x1E, 0x31, 0x04, 0x1B, 0x26, 0x07, 0x16, 
    0x25, 0x18, 0x28, 0x30, 0x10, 0x2C, 0x18, 0x21, 0x30, 0x06, 
    0x2B, 0x14, 0x28, 0x08, 0x1A, 0x0F, 0x20, 0x0A, 0x02, 0x14, 
    0x1B, 0x21, 0x05, 0x27, 0x18, 0x24, 0x1E, 0x15, 0x23, 0x10, 
    0x31, 0x16, 0x2D, 0x27, 0x19, 0x23, 0x13, 0x2B, 0x22, 0x15, 
    0x28, 0x0A, 0x13, 0x08, 0x1C, 0x29, 0x13, 0x25, 0x1A, 0x05, 
    0x1E, 0x2D, 0x25, 0x1A, 0x28, 0x0E, 0x2E, 0x1E, 0x05, 0x1A, 
    0x30, 0x0D, 0x13, 0x27, 0x0B, 0x2A, 0x06, 0x32, 0x02, 0x1A, 0x0F, 

    0x03, 0x25, 0x19, 0x2E, 0x1B, 0x05, 0x1E, 0x2C, 0x09, 0x17,         // 47
    0x03, 0x24, 0x06, 0x0E, 0x23, 0x12, 0x2D, 0x0E, 0x1F, 0x30, 
    0x00, 0x2C, 0x09, 0x15, 0x1E, 0x05, 0x14, 0x0A, 0x1C, 0x10, 
    0x19, 0x09, 0x1F, 0x2D, 0x24, 0x01, 0x16, 0x1D, 0x2C, 0x25, 
    0x06, 0x0E, 0x15, 0x2E, 0x00, 0x12, 0x0C, 0x2E, 0x09, 0x2A, 
    0x0B, 0x1C, 0x0D, 0x08, 0x2B, 0x02, 0x1E, 0x0C, 0x04, 0x31, 
    0x0E, 0x20, 0x18, 0x30, 0x24, 0x0B, 0x30, 0x02, 0x11, 0x22, 
    0x14, 0x0A, 0x03, 0x11, 0x15, 0x05, 0x18, 0x10, 0x2C, 0x0B, 
    0x1F, 0x2A, 0x24, 0x02, 0x19, 0x12, 0x23, 0x16, 0x1E, 0x0B, 0x30, 

    0x21, 0x0A, 0x2A, 0x01, 0x23, 0x30, 0x13, 0x02, 0x26, 0x31,         // 48
    0x13, 0x2B, 0x1A, 0x28, 0x07, 0x18, 0x02, 0x2A, 0x06, 0x15, 
    0x0E, 0x1D, 0x22, 0x03, 0x2B, 0x0C, 0x24, 0x28, 0x03, 0x20, 
    0x26, 0x32, 0x10, 0x05, 0x14, 0x2A, 0x31, 0x11, 0x0D, 0x18, 
    0x30, 0x29, 0x1F, 0x0A, 0x25, 0x1A, 0x2B, 0x03, 0x18, 0x1E, 
    0x04, 0x26, 0x12, 0x1F, 0x17, 0x0B, 0x2F, 0x27, 0x18, 0x1E, 
    0x06, 0x2C, 0x02, 0x0D, 0x1A, 0x06, 0x16, 0x1D, 0x2C, 0x07, 
    0x31, 0x27, 0x1D, 0x2C, 0x20, 0x2F, 0x25, 0x07, 0x28, 0x12, 
    0x04, 0x14, 0x09, 0x31, 0x1F, 0x05, 0x2D, 0x0A, 0x2A, 0x25, 0x13, 

    0x17, 0x1D, 0x10, 0x16, 0x09, 0x0D, 0x21, 0x19, 0x10, 0x1D,         // 49
    0x08, 0x20, 0x0A, 0x14, 0x2F, 0x26, 0x1E, 0x0C, 0x1A, 0x23, 
    0x2E, 0x0A, 0x17, 0x0F, 0x20, 0x1A, 0x30, 0x0F, 0x2D, 0x14, 
    0x0B, 0x01, 0x17, 0x21, 0x0B, 0x1B, 0x07, 0x26, 0x03, 0x1F, 
    0x0A, 0x04, 0x1A, 0x11, 0x2C, 0x06, 0x22, 0x10, 0x28, 0x13, 
    0x21, 0x2E, 0x00, 0x31, 0x25, 0x12, 0x1B, 0x08, 0x0F, 0x2D, 
    0x14, 0x1B, 0x23, 0x29, 0x11, 0x2E, 0x22, 0x0C, 0x27, 0x0F, 
    0x20, 0x17, 0x07, 0x0E, 0x01, 0x1B, 0x0D, 0x1F, 0x17, 0x21, 
    0x2E, 0x19, 0x1D, 0x0F, 0x28, 0x14, 0x1B, 0x0F, 0x00, 0x1B, 0x08, 

    0x2F, 0x03, 0x2C, 0x24, 0x29, 0x1C, 0x2D, 0x09, 0x2A, 0x03,         // 50
    0x27, 0x0D, 0x2D, 0x01, 0x20, 0x0A, 0x13, 0x32, 0x27, 0x10, 
    0x04, 0x29, 0x24, 0x31, 0x13, 0x01, 0x09, 0x1F, 0x07, 0x1B, 
    0x2C, 0x27, 0x1C, 0x2C, 0x25, 0x10, 0x21, 0x19, 0x2D, 0x28, 
    0x14, 0x24, 0x2F, 0x02, 0x1E, 0x15, 0x0B, 0x1D, 0x32, 0x06, 
    0x0E, 0x17, 0x1E, 0x0D, 0x07, 0x2B, 0x03, 0x20, 0x25, 0x01, 
    0x29, 0x10, 0x07, 0x1D, 0x04, 0x26, 0x12, 0x00, 0x17, 0x1D, 
    0x03, 0x13, 0x2F, 0x23, 0x29, 0x15, 0x06, 0x31, 0x01, 0x0C, 
    0x25, 0x06, 0x29, 0x01, 0x21, 0x09, 0x29, 0x20, 0x30, 0x11, 0x28, 

    0x0E, 0x20, 0x09, 0x19, 0x04, 0x10, 0x00, 0x24, 0x14, 0x2F,         // 51
    0x1A, 0x15, 0x24, 0x1C, 0x0F, 0x2B, 0x04, 0x17, 0x08, 0x20, 
    0x1C, 0x14, 0x09, 0x05, 0x26, 0x2C, 0x17, 0x29, 0x12, 0x23, 
    0x06, 0x0E, 0x12, 0x04, 0x09, 0x2F, 0x02, 0x13, 0x08, 0x10, 
    0x1D, 0x0D, 0x16, 0x28, 0x0E, 0x30, 0x26, 0x01, 0x18, 0x24, 
    0x2C, 0x05, 0x29, 0x15, 0x1C, 0x24, 0x15, 0x31, 0x12, 0x1A, 
    0x0C, 0x25, 0x32, 0x15, 0x2B, 0x0A, 0x1F, 0x31, 0x2A, 0x08, 
    0x2D, 0x26, 0x0B, 0x18, 0x0F, 0x2D, 0x23, 0x12, 0x1B, 0x2B, 
    0x15, 0x0E, 0x2F, 0x17, 0x11, 0x2E, 0x04, 0x18, 0x0A, 0x23, 0x06, 

    0x15, 0x27, 0x12, 0x2F, 0x21, 0x15, 0x32, 0x19, 0x0C, 0x1F,         // 52
    0x0F, 0x07, 0x31, 0x05, 0x17, 0x24, 0x1C, 0x29, 0x0D, 0x2E, 
    0x02, 0x2C, 0x19, 0x1F, 0x0C, 0x21, 0x10, 0x1D, 0x02, 0x2F, 
    0x18, 0x20, 0x30, 0x18, 0x27, 0x15, 0x2B, 0x1E, 0x24, 0x32, 
    0x00, 0x2C, 0x06, 0x21, 0x08, 0x1A, 0x12, 0x2A, 0x10, 0x0A, 
    0x1B, 0x12, 0x21, 0x03, 0x2F, 0x09, 0x0F, 0x1E, 0x08, 0x2C, 
    0x1F, 0x09, 0x19, 0x01, 0x21, 0x14, 0x19, 0x07, 0x10, 0x22, 
    0x0C, 0x1B, 0x02, 0x20, 0x07, 0x1C, 0x0C, 0x2A, 0x08, 0x1E, 
    0x03, 0x21, 0x1B, 0x0B, 0x25, 0x1C, 0x0D, 0x27, 0x14, 0x2D, 0x1A, 

    0x31, 0x01, 0x1E, 0x0C, 0x07, 0x28, 0x1E, 0x06, 0x27, 0x04,         // 53
    0x25, 0x2A, 0x13, 0x21, 0x0C, 0x2E, 0x11, 0x01, 0x23, 0x18, 
    0x11, 0x27, 0x0E, 0x2F, 0x18, 0x04, 0x31, 0x0C, 0x25, 0x15, 
    0x08, 0x29, 0x01, 0x1E, 0x0D, 0x21, 0x0F, 0x06, 0x16, 0x0A, 
    0x20, 0x18, 0x27, 0x14, 0x2E, 0x04, 0x21, 0x07, 0x1F, 0x2E, 
    0x28, 0x08, 0x2C, 0x10, 0x27, 0x18, 0x2C, 0x04, 0x28, 0x15, 
    0x03, 0x2E, 0x12, 0x27, 0x0D, 0x2D, 0x03, 0x27, 0x1C, 0x16, 
    0x25, 0x12, 0x2A, 0x32, 0x14, 0x27, 0x02, 0x18, 0x26, 0x2E, 
    0x11, 0x27, 0x07, 0x2C, 0x05, 0x13, 0x31, 0x1F, 0x08, 0x03, 0x1E, 

    0x09, 0x29, 0x17, 0x2C, 0x1A, 0x11, 0x09, 0x2B, 0x11, 0x2E,         // 54
    0x17, 0x02, 0x1E, 0x0A, 0x2A, 0x05, 0x21, 0x1A, 0x30, 0x09, 
    0x1E, 0x0B, 0x23, 0x01, 0x13, 0x27, 0x1B, 0x06, 0x2B, 0x1E, 
    0x0D, 0x23, 0x19, 0x0A, 0x2D, 0x04, 0x1B, 0x2F, 0x27, 0x0E, 
    0x2B, 0x11, 0x09, 0x1D, 0x10, 0x29, 0x16, 0x30, 0x0D, 0x14, 
    0x01, 0x1E, 0x16, 0x23, 0x0C, 0x02, 0x22, 0x19, 0x0B, 0x24, 
    0x1B, 0x0F, 0x2A, 0x1E, 0x07, 0x1B, 0x23, 0x2F, 0x0C, 0x01, 
    0x30, 0x05, 0x1D, 0x0D, 0x06, 0x2D, 0x1F, 0x0F, 0x04, 0x1A, 
    0x09, 0x32, 0x15, 0x1F, 0x19, 0x2A, 0x01, 0x16, 0x2B, 0x25, 0x0F, 

    0x21, 0x12, 0x06, 0x24, 0x02, 0x2F, 0x24, 0x15, 0x1C, 0x0B,         // 55
    0x22, 0x10, 0x2F, 0x1A, 0x25, 0x16, 0x0E, 0x07, 0x28, 0x16, 
    0x2D, 0x05, 0x2A, 0x1D, 0x2C, 0x08, 0x16, 0x22, 0x12, 0x03, 
    0x32, 0x11, 0x2C, 0x15, 0x26, 0x13, 0x23, 0x02, 0x19, 0x1F, 
    0x04, 0x23, 0x31, 0x01, 0x24, 0x0A, 0x1C, 0x02, 0x23, 0x19, 
    0x26, 0x0B, 0x2E, 0x06, 0x1B, 0x32, 0x11, 0x2A, 0x10, 0x30, 
    0x08, 0x23, 0x02, 0x17, 0x30, 0x10, 0x09, 0x13, 0x1F, 0x2A, 
    0x18, 0x0F, 0x27, 0x17, 0x22, 0x19, 0x12, 0x31, 0x23, 0x14, 
    0x20, 0x0D, 0x00, 0x25, 0x0F, 0x09, 0x23, 0x0E, 0x1C, 0x13, 0x2C, 

    0x02, 0x1C, 0x30, 0x14, 0x1E, 0x0B, 0x18, 0x04, 0x31, 0x06,         // 56
    0x18, 0x26, 0x07, 0x14, 0x00, 0x31, 0x27, 0x1F, 0x10, 0x02, 
    0x22, 0x14, 0x19, 0x10, 0x0C, 0x23, 0x2A, 0x0D, 0x2D, 0x1A, 
    0x26, 0x09, 0x03, 0x21, 0x06, 0x31, 0x0E, 0x29, 0x13, 0x08, 
    0x2E, 0x16, 0x0C, 0x19, 0x2D, 0x13, 0x27, 0x11, 0x2C, 0x05, 
    0x31, 0x12, 0x19, 0x28, 0x13, 0x20, 0x07, 0x1C, 0x00, 0x20, 
    0x13, 0x2C, 0x0D, 0x25, 0x05, 0x20, 0x2B, 0x1A, 0x06, 0x24, 
    0x0A, 0x20, 0x2C, 0x00, 0x0A, 0x28, 0x05, 0x0B, 0x2A, 0x06, 
    0x27, 0x19, 0x2B, 0x08, 0x30, 0x27, 0x18, 0x2E, 0x05, 0x0B, 0x18, 

    0x26, 0x0D, 0x08, 0x2A, 0x0F, 0x21, 0x2C, 0x0F, 0x26, 0x1F,         // 57
    0x2D, 0x0D, 0x2B, 0x22, 0x0C, 0x1C, 0x13, 0x09, 0x2E, 0x1C, 
    0x0D, 0x32, 0x08, 0x20, 0x2E, 0x06, 0x14, 0x00, 0x20, 0x07, 
    0x13, 0x1F, 0x2B, 0x1A, 0x0B, 0x1E, 0x18, 0x09, 0x2C, 0x26, 
    0x0F, 0x1D, 0x2A, 0x07, 0x1F, 0x04, 0x2F, 0x09, 0x1E, 0x10, 
    0x20, 0x08, 0x25, 0x01, 0x2B, 0x0A, 0x2D, 0x25, 0x16, 0x2B, 
    0x04, 0x19, 0x1D, 0x12, 0x28, 0x15, 0x00, 0x26, 0x11, 0x2E, 
    0x1C, 0x06, 0x13, 0x1B, 0x30, 0x14, 0x21, 0x1C, 0x16, 0x0E, 
    0x2E, 0x11, 0x1F, 0x14, 0x1C, 0x12, 0x03, 0x22, 0x2A, 0x1F, 0x30, 

    0x11, 0x2C, 0x22, 0x19, 0x05, 0x27, 0x00, 0x1D, 0x0A, 0x12,         // 58
    0x02, 0x15, 0x1D, 0x04, 0x28, 0x2C, 0x03, 0x24, 0x17, 0x2A, 
    0x05, 0x27, 0x23, 0x02, 0x17, 0x1E, 0x31, 0x1C, 0x29, 0x0F, 
    0x2F, 0x17, 0x0D, 0x25, 0x13, 0x2C, 0x04, 0x20, 0x1A, 0x01, 
    0x21, 0x05, 0x11, 0x24, 0x17, 0x0D, 0x1B, 0x22, 0x16, 0x06, 
    0x2B, 0x1C, 0x0E, 0x16, 0x1E, 0x10, 0x18, 0x06, 0x0D, 0x1F, 
    0x0B, 0x31, 0x06, 0x2C, 0x0B, 0x1B, 0x31, 0x0A, 0x17, 0x02, 
    0x0E, 0x31, 0x25, 0x0C, 0x20, 0x0E, 0x2C, 0x01, 0x2F, 0x1F, 
    0x02, 0x0A, 0x22, 0x03, 0x29, 0x07, 0x1E, 0x10, 0x09, 0x14, 0x04, 

    0x17, 0x1E, 0x01, 0x14, 0x2F, 0x1B, 0x13, 0x30, 0x17, 0x2A,         // 59
    0x23, 0x31, 0x09, 0x17, 0x11, 0x1A, 0x0E, 0x30, 0x07, 0x11, 
    0x1F, 0x17, 0x12, 0x2B, 0x0E, 0x27, 0x11, 0x0B, 0x17, 0x25, 
    0x02, 0x22, 0x08, 0x30, 0x00, 0x27, 0x12, 0x2F, 0x0E, 0x16, 
    0x32, 0x19, 0x2C, 0x0B, 0x2E, 0x27, 0x12, 0x00, 0x2A, 0x24, 
    0x17, 0x04, 0x2F, 0x27, 0x04, 0x30, 0x21, 0x28, 0x2F, 0x12, 
    0x28, 0x22, 0x14, 0x1F, 0x03, 0x23, 0x11, 0x1F, 0x2D, 0x23, 
    0x2A, 0x15, 0x03, 0x29, 0x08, 0x1A, 0x26, 0x0A, 0x13, 0x25, 
    0x1A, 0x28, 0x17, 0x2E, 0x0B, 0x24, 0x32, 0x17, 0x28, 0x1B, 0x25, 

    0x0C, 0x31, 0x0F, 0x25, 0x07, 0x0C, 0x25, 0x08, 0x20, 0x04,         // 60
    0x0E, 0x19, 0x21, 0x2D, 0x24, 0x06, 0x1F, 0x15, 0x22, 0x29, 
    0x0C, 0x03, 0x2F, 0x09, 0x1B, 0x05, 0x24, 0x03, 0x2D, 0x0A, 
    0x1B, 0x2C, 0x10, 0x1E, 0x18, 0x0B, 0x1C, 0x24, 0x07, 0x28, 
    0x0A, 0x26, 0x13, 0x01, 0x20, 0x06, 0x1E, 0x32, 0x0F, 0x0A, 
    0x2D, 0x13, 0x20, 0x0C, 0x1B, 0x09, 0x15, 0x01, 0x1B, 0x07, 
    0x18, 0x02, 0x0F, 0x2D, 0x18, 0x0E, 0x29, 0x04, 0x1A, 0x12, 
    0x0B, 0x1F, 0x19, 0x13, 0x2D, 0x04, 0x16, 0x1E, 0x2B, 0x07, 
    0x0C, 0x31, 0x05, 0x0F, 0x1B, 0x13, 0x2A, 0x0D, 0x02, 0x2E, 0x07, 

    0x20, 0x05, 0x1B, 0x2A, 0x1F, 0x2C, 0x19, 0x11, 0x2D, 0x1C,         // 61
    0x28, 0x07, 0x12, 0x01, 0x0D, 0x2F, 0x28, 0x01, 0x0F, 0x1B, 
    0x2C, 0x24, 0x19, 0x1F, 0x2A, 0x13, 0x30, 0x1E, 0x15, 0x21, 
    0x12, 0x05, 0x29, 0x07, 0x2B, 0x22, 0x10, 0x02, 0x2C, 0x13, 
    0x1D, 0x04, 0x22, 0x1B, 0x15, 0x29, 0x09, 0x14, 0x1A, 0x20, 
    0x02, 0x26, 0x07, 0x16, 0x2C, 0x29, 0x10, 0x20, 0x0D, 0x25, 
    0x2E, 0x1E, 0x29, 0x08, 0x26, 0x30, 0x09, 0x16, 0x26, 0x05, 
    0x21, 0x07, 0x2F, 0x24, 0x0F, 0x23, 0x32, 0x05, 0x10, 0x22, 
    0x15, 0x1D, 0x12, 0x26, 0x20, 0x01, 0x0A, 0x1D, 0x22, 0x11, 0x29, 

    0x13, 0x2D, 0x17, 0x03, 0x14, 0x0E, 0x02, 0x27, 0x06, 0x0D,         // 62
    0x14, 0x30, 0x1E, 0x2A, 0x19, 0x14, 0x0A, 0x1C, 0x31, 0x04, 
    0x09, 0x13, 0x0D, 0x01, 0x23, 0x08, 0x1A, 0x0D, 0x2A, 0x03, 
    0x31, 0x1D, 0x16, 0x24, 0x13, 0x09, 0x30, 0x17, 0x20, 0x08, 
    0x2E, 0x0F, 0x2B, 0x0C, 0x30, 0x0F, 0x23, 0x2B, 0x06, 0x2E, 
    0x10, 0x19, 0x31, 0x11, 0x22, 0x06, 0x19, 0x32, 0x2A, 0x13, 
    0x04, 0x0B, 0x15, 0x1C, 0x01, 0x12, 0x21, 0x2C, 0x0E, 0x32, 
    0x17, 0x2A, 0x0D, 0x01, 0x1F, 0x0B, 0x14, 0x29, 0x1A, 0x2F, 
    0x00, 0x23, 0x2C, 0x09, 0x30, 0x17, 0x25, 0x2D, 0x18, 0x0B, 0x1B, 

    0x27, 0x08, 0x22, 0x0B, 0x28, 0x23, 0x32, 0x1E, 0x16, 0x22,         // 63
    0x26, 0x03, 0x0C, 0x25, 0x05, 0x1F, 0x2C, 0x12, 0x25, 0x17, 
    0x1F, 0x28, 0x31, 0x16, 0x2D, 0x11, 0x22, 0x06, 0x13, 0x23, 
    0x0E, 0x26, 0x0B, 0x01, 0x2E, 0x1C, 0x04, 0x29, 0x0E, 0x1A, 
    0x23, 0x18, 0x06, 0x25, 0x08, 0x19, 0x02, 0x1C, 0x0D, 0x26, 
    0x1D, 0x09, 0x29, 0x00, 0x1D, 0x0B, 0x26, 0x03, 0x08, 0x1B, 
    0x21, 0x28, 0x31, 0x0D, 0x22, 0x1A, 0x07, 0x1D, 0x03, 0x24, 
    0x09, 0x12, 0x27, 0x16, 0x1B, 0x2C, 0x02, 0x20, 0x08, 0x0E, 
    0x2A, 0x0A, 0x16, 0x04, 0x1C, 0x0E, 0x06, 0x13, 0x08, 0x31, 0x00, 

    0x0F, 0x2B, 0x11, 0x30, 0x1C, 0x06, 0x12, 0x0C, 0x2E, 0x09,         // 64
    0x1C, 0x2A, 0x1A, 0x12, 0x32, 0x09, 0x21, 0x06, 0x0C, 0x2E, 
    0x11, 0x07, 0x1C, 0x0A, 0x26, 0x03, 0x1C, 0x2E, 0x27, 0x19, 
    0x08, 0x2E, 0x1A, 0x20, 0x0E, 0x27, 0x14, 0x23, 0x06, 0x31, 
    0x02, 0x11, 0x2E, 0x1D, 0x13, 0x2D, 0x27, 0x15, 0x2C, 0x03, 
    0x14, 0x21, 0x0E, 0x25, 0x15, 0x2F, 0x13, 0x1F, 0x16, 0x2D, 
    0x0E, 0x17, 0x05, 0x25, 0x10, 0x2F, 0x14, 0x28, 0x12, 0x19, 
    0x2D, 0x1C, 0x06, 0x2F, 0x08, 0x25, 0x19, 0x11, 0x26, 0x1C, 
    0x14, 0x1F, 0x28, 0x11, 0x22, 0x2D, 0x27, 0x1B, 0x2A, 0x23, 0x1E, 

    0x05, 0x20, 0x18, 0x03, 0x13, 0x22, 0x19, 0x00, 0x29, 0x11,         // 65
    0x05, 0x13, 0x2D, 0x02, 0x23, 0x0F, 0x16, 0x29, 0x1A, 0x00, 
    0x23, 0x2B, 0x04, 0x20, 0x14, 0x2C, 0x0A, 0x16, 0x01, 0x10, 
    0x20, 0x04, 0x13, 0x2A, 0x06, 0x1A, 0x0A, 0x2C, 0x13, 0x1E, 
    0x2A, 0x26, 0x17, 0x03, 0x24, 0x06, 0x1E, 0x10, 0x08, 0x24, 
    0x30, 0x04, 0x18, 0x2E, 0x04, 0x1A, 0x0E, 0x29, 0x0A, 0x25, 
    0x02, 0x1F, 0x13, 0x2C, 0x06, 0x26, 0x02, 0x2C, 0x0C, 0x1F, 
    0x01, 0x24, 0x0F, 0x21, 0x13, 0x0C, 0x30, 0x0A, 0x2C, 0x06, 
    0x2F, 0x02, 0x19, 0x32, 0x0D, 0x02, 0x1F, 0x11, 0x03, 0x0D, 0x15, 

    0x1A, 0x2E, 0x0B, 0x26, 0x2E, 0x09, 0x2B, 0x25, 0x1F, 0x18,         // 66
    0x31, 0x21, 0x0B, 0x17, 0x28, 0x1B, 0x03, 0x30, 0x25, 0x0E, 
    0x1E, 0x17, 0x10, 0x30, 0x1A, 0x0F, 0x24, 0x1E, 0x31, 0x29, 
    0x1B, 0x2C, 0x0A, 0x23, 0x11, 0x2E, 0x20, 0x01, 0x18, 0x09, 
    0x0F, 0x07, 0x21, 0x0B, 0x32, 0x18, 0x0C, 0x2F, 0x20, 0x19, 
    0x0B, 0x2A, 0x10, 0x20, 0x0A, 0x2C, 0x22, 0x01, 0x31, 0x10, 
    0x1A, 0x2A, 0x0B, 0x1B, 0x20, 0x0B, 0x19, 0x22, 0x08, 0x30, 
    0x10, 0x17, 0x2B, 0x02, 0x1D, 0x29, 0x04, 0x1F, 0x18, 0x12, 
    0x25, 0x0F, 0x21, 0x06, 0x1D, 0x15, 0x0A, 0x29, 0x19, 0x30, 0x25, 

    0x29, 0x01, 0x14, 0x1D, 0x04, 0x0F, 0x1B, 0x13, 0x04, 0x09,         // 67
    0x27, 0x0E, 0x1E, 0x08, 0x2F, 0x0D, 0x22, 0x12, 0x07, 0x16, 
    0x2F, 0x06, 0x25, 0x0B, 0x01, 0x28, 0x06, 0x13, 0x0B, 0x05, 
    0x0F, 0x22, 0x19, 0x32, 0x03, 0x17, 0x0D, 0x25, 0x30, 0x22, 
    0x1A, 0x2E, 0x14, 0x1D, 0x0F, 0x2A, 0x00, 0x26, 0x05, 0x12, 
    0x1D, 0x26, 0x06, 0x1B, 0x25, 0x12, 0x07, 0x1D, 0x14, 0x21, 
    0x08, 0x2F, 0x24, 0x00, 0x16, 0x31, 0x0E, 0x1E, 0x15, 0x28, 
    0x06, 0x26, 0x0B, 0x31, 0x15, 0x0E, 0x24, 0x14, 0x2B, 0x03, 
    0x1D, 0x09, 0x2C, 0x13, 0x2A, 0x24, 0x2E, 0x05, 0x21, 0x0C, 0x07, 

    0x1C, 0x0E, 0x24, 0x2B, 0x17, 0x21, 0x31, 0x0C, 0x2C, 0x22,         // 68
    0x16, 0x01, 0x2B, 0x25, 0x14, 0x05, 0x1D, 0x2B, 0x20, 0x0C, 
    0x27, 0x13, 0x2C, 0x21, 0x1D, 0x2E, 0x19, 0x2A, 0x23, 0x17, 
    0x27, 0x00, 0x13, 0x08, 0x25, 0x1E, 0x2A, 0x13, 0x06, 0x0C, 
    0x28, 0x01, 0x29, 0x05, 0x24, 0x13, 0x1F, 0x15, 0x2A, 0x09, 
    0x2F, 0x17, 0x13, 0x31, 0x08, 0x2A, 0x18, 0x25, 0x0C, 0x2C, 
    0x16, 0x05, 0x0F, 0x28, 0x11, 0x23, 0x07, 0x2D, 0x02, 0x1A, 
    0x20, 0x12, 0x1A, 0x21, 0x06, 0x2D, 0x1B, 0x08, 0x0F, 0x27, 
    0x31, 0x16, 0x25, 0x0A, 0x04, 0x17, 0x0F, 0x1D, 0x13, 0x2C, 0x14, 

    0x20, 0x32, 0x06, 0x10, 0x09, 0x29, 0x02, 0x17, 0x1E, 0x10,         // 69
    0x2E, 0x1B, 0x11, 0x06, 0x20, 0x2E, 0x0F, 0x03, 0x19, 0x2D, 
    0x01, 0x1B, 0x05, 0x16, 0x08, 0x12, 0x0D, 0x02, 0x1C, 0x30, 
    0x0B, 0x2E, 0x1D, 0x29, 0x14, 0x0B, 0x04, 0x1A, 0x2C, 0x1D, 
    0x11, 0x17, 0x0A, 0x2F, 0x19, 0x07, 0x30, 0x0C, 0x1A, 0x23, 
    0x03, 0x0D, 0x24, 0x01, 0x19, 0x0F, 0x30, 0x05, 0x29, 0x02, 
    0x1E, 0x22, 0x1B, 0x2E, 0x05, 0x29, 0x19, 0x12, 0x2A, 0x0E, 
    0x2F, 0x01, 0x2A, 0x09, 0x17, 0x27, 0x01, 0x30, 0x22, 0x0C, 
    0x19, 0x00, 0x10, 0x1C, 0x2F, 0x23, 0x01, 0x28, 0x08, 0x24, 0x04, 

    0x0A, 0x17, 0x1F, 0x2D, 0x1B, 0x12, 0x23, 0x08, 0x27, 0x0A,         // 70
    0x06, 0x25, 0x31, 0x19, 0x0B, 0x29, 0x16, 0x25, 0x09, 0x23, 
    0x0F, 0x20, 0x2A, 0x0D, 0x32, 0x26, 0x20, 0x2C, 0x11, 0x06, 
    0x15, 0x21, 0x06, 0x0D, 0x2D, 0x23, 0x30, 0x0F, 0x21, 0x03, 
    0x31, 0x23, 0x1F, 0x11, 0x27, 0x0E, 0x22, 0x02, 0x2C, 0x16, 
    0x29, 0x1E, 0x2C, 0x0C, 0x23, 0x1F, 0x0B, 0x14, 0x1B, 0x10, 
    0x32, 0x13, 0x0B, 0x18, 0x21, 0x0A, 0x1F, 0x05, 0x24, 0x09, 
    0x16, 0x22, 0x0F, 0x2E, 0x1F, 0x0E, 0x13, 0x1D, 0x16, 0x05, 
    0x20, 0x2C, 0x28, 0x1F, 0x0B, 0x19, 0x11, 0x31, 0x1C, 0x16, 0x2E, 

    0x11, 0x29, 0x01, 0x0D, 0x22, 0x05, 0x2F, 0x1A, 0x2D, 0x15,         // 71
    0x1F, 0x0F, 0x03, 0x22, 0x12, 0x1C, 0x08, 0x32, 0x11, 0x1B, 
    0x30, 0x0A, 0x14, 0x24, 0x19, 0x04, 0x16, 0x09, 0x1F, 0x26, 
    0x2B, 0x10, 0x1A, 0x22, 0x01, 0x19, 0x06, 0x28, 0x15, 0x0D, 
    0x26, 0x0F, 0x02, 0x1B, 0x06, 0x2C, 0x14, 0x1D, 0x0F, 0x07, 
    0x13, 0x0A, 0x1A, 0x14, 0x2E, 0x04, 0x26, 0x2D, 0x20, 0x08, 
    0x27, 0x06, 0x2D, 0x02, 0x12, 0x2C, 0x14, 0x31, 0x18, 0x1F, 
    0x29, 0x04, 0x1B, 0x15, 0x03, 0x24, 0x2B, 0x09, 0x2D, 0x25, 
    0x13, 0x08, 0x0D, 0x15, 0x03, 0x2B, 0x25, 0x09, 0x0E, 0x02, 0x27, 

    0x07, 0x23, 0x13, 0x30, 0x18, 0x2A, 0x0B, 0x10, 0x01, 0x22,         // 72
    0x19, 0x2D, 0x29, 0x09, 0x27, 0x04, 0x2A, 0x1F, 0x02, 0x15, 
    0x26, 0x06, 0x2C, 0x02, 0x1E, 0x0B, 0x28, 0x30, 0x03, 0x19, 
    0x0C, 0x04, 0x2A, 0x14, 0x20, 0x11, 0x1D, 0x09, 0x2B, 0x1A, 
    0x06, 0x16, 0x2E, 0x2A, 0x16, 0x25, 0x09, 0x2E, 0x27, 0x20, 
    0x31, 0x26, 0x02, 0x2A, 0x08, 0x1D, 0x17, 0x02, 0x0D, 0x24, 
    0x16, 0x1C, 0x29, 0x1F, 0x26, 0x0E, 0x01, 0x27, 0x0E, 0x06, 
    0x12, 0x31, 0x24, 0x0B, 0x29, 0x07, 0x18, 0x21, 0x02, 0x10, 
    0x2F, 0x1A, 0x26, 0x32, 0x21, 0x07, 0x16, 0x1E, 0x2A, 0x21, 0x1A, 

    0x15, 0x2C, 0x1C, 0x09, 0x03, 0x15, 0x1D, 0x24, 0x29, 0x12,         // 73
    0x05, 0x0C, 0x15, 0x1A, 0x2F, 0x14, 0x19, 0x0C, 0x25, 0x2B, 
    0x0D, 0x18, 0x1F, 0x10, 0x2F, 0x13, 0x23, 0x0E, 0x15, 0x2D, 
    0x23, 0x1C, 0x2F, 0x09, 0x0E, 0x31, 0x25, 0x18, 0x00, 0x30, 
    0x1E, 0x28, 0x07, 0x21, 0x10, 0x01, 0x1B, 0x0E, 0x06, 0x19, 
    0x04, 0x0F, 0x21, 0x19, 0x12, 0x28, 0x0F, 0x2B, 0x19, 0x2F, 
    0x01, 0x0D, 0x14, 0x09, 0x18, 0x2F, 0x1D, 0x16, 0x21, 0x2D, 
    0x1D, 0x08, 0x10, 0x2C, 0x1E, 0x12, 0x32, 0x0C, 0x1C, 0x2A, 
    0x06, 0x1F, 0x01, 0x12, 0x1B, 0x0E, 0x2F, 0x05, 0x10, 0x30, 0x0C, 

    0x1F, 0x05, 0x10, 0x28, 0x25, 0x21, 0x06, 0x32, 0x0D, 0x1C,         // 74
    0x30, 0x26, 0x20, 0x00, 0x0F, 0x23, 0x06, 0x2D, 0x10, 0x05, 
    0x1E, 0x2F, 0x0A, 0x25, 0x07, 0x2B, 0x00, 0x1B, 0x20, 0x0A, 
    0x12, 0x01, 0x26, 0x19, 0x23, 0x03, 0x0B, 0x2C, 0x10, 0x22, 
    0x0C, 0x13, 0x1A, 0x0B, 0x1F, 0x32, 0x29, 0x17, 0x22, 0x12, 
    0x2B, 0x1D, 0x29, 0x0A, 0x32, 0x05, 0x22, 0x09, 0x1F, 0x11, 
    0x2A, 0x21, 0x30, 0x04, 0x24, 0x0C, 0x06, 0x2B, 0x0B, 0x02, 
    0x14, 0x28, 0x18, 0x00, 0x1A, 0x27, 0x04, 0x15, 0x26, 0x0E, 
    0x17, 0x0B, 0x24, 0x2C, 0x0A, 0x28, 0x23, 0x19, 0x14, 0x03, 0x26, 

    0x17, 0x31, 0x20, 0x0C, 0x2F, 0x12, 0x0B, 0x19, 0x02, 0x20,         // 75
    0x07, 0x11, 0x0A, 0x2C, 0x1E, 0x0A, 0x27, 0x1D, 0x17, 0x22, 
    0x13, 0x01, 0x2A, 0x15, 0x19, 0x20, 0x10, 0x2E, 0x05, 0x28, 
    0x32, 0x17, 0x0F, 0x06, 0x2D, 0x16, 0x28, 0x20, 0x14, 0x07, 
    0x2A, 0x02, 0x30, 0x25, 0x05, 0x14, 0x08, 0x24, 0x02, 0x30, 
    0x09, 0x14, 0x03, 0x10, 0x1F, 0x1A, 0x2D, 0x14, 0x03, 0x25, 
    0x07, 0x19, 0x0F, 0x27, 0x12, 0x1F, 0x29, 0x11, 0x1C, 0x25, 
    0x2F, 0x0D, 0x22, 0x30, 0x09, 0x0F, 0x23, 0x2D, 0x05, 0x20, 
    0x31, 0x28, 0x10, 0x06, 0x1F, 0x15, 0x00, 0x2B, 0x20, 0x2D, 0x09, 

    0x2A, 0x02, 0x14, 0x1A, 0x00, 0x1E, 0x27, 0x2C, 0x14, 0x2A,         // 76
    0x17, 0x2D, 0x1B, 0x26, 0x16, 0x31, 0x11, 0x01, 0x2F, 0x0D, 
    0x28, 0x1B, 0x0F, 0x04, 0x27, 0x08, 0x18, 0x27, 0x13, 0x1A, 
    0x08, 0x1F, 0x2C, 0x21, 0x12, 0x1D, 0x0F, 0x03, 0x1C, 0x2D, 
    0x24, 0x1C, 0x0F, 0x16, 0x2C, 0x1C, 0x10, 0x2E, 0x0D, 0x1E, 
    0x28, 0x18, 0x2E, 0x24, 0x15, 0x00, 0x0D, 0x29, 0x17, 0x31, 
    0x0C, 0x1D, 0x06, 0x2E, 0x1B, 0x01, 0x15, 0x32, 0x09, 0x18, 
    0x04, 0x1E, 0x06, 0x13, 0x2A, 0x1F, 0x17, 0x0A, 0x1C, 0x13, 
    0x03, 0x19, 0x22, 0x18, 0x30, 0x09, 0x1D, 0x0D, 0x06, 0x1A, 0x10, 

    0x0C, 0x23, 0x29, 0x09, 0x2D, 0x17, 0x06, 0x0E, 0x22, 0x0A,         // 77
    0x24, 0x02, 0x14, 0x06, 0x0D, 0x04, 0x1A, 0x2A, 0x08, 0x25, 
    0x07, 0x31, 0x20, 0x2B, 0x1C, 0x31, 0x0D, 0x03, 0x21, 0x0C, 
    0x25, 0x14, 0x02, 0x0C, 0x27, 0x08, 0x2F, 0x25, 0x09, 0x17, 
    0x0D, 0x04, 0x27, 0x09, 0x23, 0x02, 0x20, 0x27, 0x19, 0x04, 
    0x10, 0x20, 0x06, 0x2A, 0x0A, 0x30, 0x24, 0x1C, 0x05, 0x1F, 
    0x13, 0x23, 0x2B, 0x16, 0x09, 0x22, 0x27, 0x05, 0x22, 0x2C, 
    0x10, 0x2A, 0x1A, 0x25, 0x0B, 0x03, 0x2F, 0x0E, 0x2B, 0x27, 
    0x09, 0x2E, 0x0C, 0x02, 0x27, 0x10, 0x25, 0x30, 0x12, 0x28, 0x1E, 

    0x15, 0x06, 0x1D, 0x0F, 0x22, 0x11, 0x2F, 0x1C, 0x04, 0x30,         // 78
    0x10, 0x1E, 0x2E, 0x21, 0x2B, 0x27, 0x20, 0x13, 0x18, 0x1E, 
    0x11, 0x19, 0x05, 0x15, 0x09, 0x12, 0x23, 0x2C, 0x1B, 0x30, 
    0x05, 0x2A, 0x1C, 0x31, 0x16, 0x04, 0x1A, 0x13, 0x29, 0x32, 
    0x14, 0x21, 0x2F, 0x12, 0x2B, 0x18, 0x0C, 0x08, 0x13, 0x2C, 
    0x24, 0x0B, 0x1B, 0x0F, 0x21, 0x19, 0x07, 0x11, 0x2E, 0x0A, 
    0x28, 0x0E, 0x02, 0x20, 0x11, 0x2F, 0x0D, 0x1B, 0x0E, 0x15, 
    0x24, 0x07, 0x0F, 0x2E, 0x15, 0x24, 0x1B, 0x06, 0x21, 0x16, 
    0x10, 0x25, 0x1D, 0x13, 0x2C, 0x1A, 0x03, 0x16, 0x22, 0x02, 0x2D, 

    0x25, 0x30, 0x18, 0x2B, 0x03, 0x28, 0x08, 0x20, 0x15, 0x28,         // 79
    0x18, 0x07, 0x0B, 0x12, 0x1B, 0x0F, 0x08, 0x30, 0x0A, 0x2B, 
    0x00, 0x26, 0x0C, 0x2E, 0x21, 0x05, 0x29, 0x14, 0x08, 0x16, 
    0x0F, 0x22, 0x11, 0x0A, 0x1F, 0x2A, 0x22, 0x0B, 0x01, 0x1E, 
    0x06, 0x1A, 0x08, 0x1E, 0x04, 0x21, 0x31, 0x29, 0x1D, 0x06, 
    0x30, 0x16, 0x29, 0x02, 0x13, 0x2B, 0x0C, 0x20, 0x25, 0x01, 
    0x18, 0x30, 0x26, 0x0B, 0x2A, 0x18, 0x03, 0x2D, 0x20, 0x01, 
    0x31, 0x17, 0x20, 0x01, 0x1E, 0x0C, 0x29, 0x11, 0x31, 0x00, 
    0x1B, 0x2A, 0x07, 0x20, 0x05, 0x22, 0x0B, 0x2C, 0x08, 0x19, 0x0A, 

    0x10, 0x01, 0x13, 0x0A, 0x1F, 0x19, 0x12, 0x26, 0x0C, 0x03,         // 80
    0x22, 0x2A, 0x1F, 0x32, 0x05, 0x17, 0x22, 0x04, 0x24, 0x14, 
    0x1F, 0x2D, 0x12, 0x27, 0x17, 0x1B, 0x0E, 0x01, 0x20, 0x26, 
    0x2D, 0x03, 0x18, 0x29, 0x01, 0x0F, 0x2E, 0x18, 0x27, 0x0F, 
    0x24, 0x2D, 0x10, 0x2A, 0x0B, 0x14, 0x0E, 0x00, 0x16, 0x21, 
    0x11, 0x04, 0x22, 0x2E, 0x1C, 0x25, 0x04, 0x16, 0x2C, 0x13, 
    0x1D, 0x05, 0x15, 0x1B, 0x06, 0x1F, 0x13, 0x25, 0x09, 0x1C, 
    0x0C, 0x2B, 0x08, 0x26, 0x12, 0x2D, 0x04, 0x17, 0x1E, 0x0E, 
    0x2E, 0x0B, 0x18, 0x32, 0x0E, 0x14, 0x29, 0x1D, 0x12, 0x31, 0x20, 

    0x1B, 0x29, 0x24, 0x2F, 0x0E, 0x2B, 0x01, 0x31, 0x1A, 0x2C,         // 81
    0x10, 0x16, 0x00, 0x0E, 0x24, 0x2C, 0x1D, 0x11, 0x2E, 0x0C, 
    0x17, 0x07, 0x1D, 0x03, 0x0A, 0x2C, 0x25, 0x32, 0x19, 0x0B, 
    0x1C, 0x08, 0x2F, 0x23, 0x1C, 0x16, 0x06, 0x1D, 0x12, 0x2B, 
    0x0B, 0x17, 0x02, 0x25, 0x1A, 0x2E, 0x1C, 0x26, 0x2D, 0x0A, 
    0x2A, 0x1D, 0x09, 0x12, 0x07, 0x0F, 0x31, 0x1B, 0x0D, 0x08, 
    0x29, 0x22, 0x0F, 0x2E, 0x27, 0x0C, 0x31, 0x10, 0x29, 0x15, 
    0x23, 0x11, 0x1A, 0x2F, 0x0A, 0x1B, 0x25, 0x0A, 0x28, 0x06, 
    0x24, 0x12, 0x03, 0x24, 0x2B, 0x1B, 0x07, 0x23, 0x0C, 0x28, 0x06, 

    0x2E, 0x0D, 0x08, 0x1B, 0x05, 0x16, 0x22, 0x0D, 0x06, 0x1E,         // 82
    0x09, 0x2E, 0x1A, 0x29, 0x14, 0x03, 0x0C, 0x28, 0x1B, 0x02, 
    0x29, 0x24, 0x0F, 0x30, 0x14, 0x1F, 0x09, 0x12, 0x06, 0x29, 
    0x14, 0x20, 0x12, 0x0C, 0x08, 0x31, 0x25, 0x0A, 0x2F, 0x03, 
    0x1C, 0x27, 0x31, 0x15, 0x08, 0x23, 0x04, 0x13, 0x07, 0x19, 
    0x0E, 0x26, 0x17, 0x2F, 0x28, 0x19, 0x21, 0x03, 0x28, 0x1F, 
    0x32, 0x0A, 0x20, 0x00, 0x17, 0x21, 0x04, 0x1A, 0x07, 0x2E, 
    0x03, 0x29, 0x06, 0x15, 0x22, 0x03, 0x13, 0x2C, 0x1F, 0x15, 
    0x1A, 0x29, 0x1E, 0x0A, 0x13, 0x02, 0x2D, 0x17, 0x00, 0x1E, 0x14, 

    0x03, 0x16, 0x22, 0x12, 0x28, 0x2E, 0x11, 0x20, 0x29, 0x13,         // 83
    0x26, 0x05, 0x21, 0x0A, 0x1E, 0x30, 0x17, 0x07, 0x21, 0x13, 
    0x32, 0x08, 0x19, 0x28, 0x23, 0x04, 0x1C, 0x2B, 0x24, 0x0F, 
    0x30, 0x01, 0x26, 0x2B, 0x1F, 0x10, 0x04, 0x22, 0x15, 0x1F, 
    0x09, 0x10, 0x06, 0x22, 0x11, 0x2B, 0x0C, 0x2F, 0x1E, 0x24, 
    0x32, 0x03, 0x0C, 0x20, 0x00, 0x0B, 0x14, 0x2E, 0x18, 0x11, 
    0x02, 0x1C, 0x13, 0x2A, 0x08, 0x14, 0x2C, 0x26, 0x20, 0x0E, 
    0x1C, 0x0B, 0x20, 0x2B, 0x0E, 0x32, 0x1D, 0x0E, 0x01, 0x30, 
    0x08, 0x0E, 0x2E, 0x19, 0x27, 0x1F, 0x0E, 0x26, 0x2F, 0x0F, 0x23, 

    0x28, 0x1D, 0x31, 0x02, 0x1F, 0x08, 0x1B, 0x05, 0x18, 0x30,         // 84
    0x0E, 0x17, 0x2F, 0x12, 0x06, 0x23, 0x2A, 0x12, 0x2D, 0x05, 
    0x1C, 0x0C, 0x20, 0x01, 0x10, 0x2D, 0x0E, 0x15, 0x03, 0x1D, 
    0x18, 0x0B, 0x1B, 0x06, 0x15, 0x27, 0x2C, 0x19, 0x0D, 0x2A, 
    0x24, 0x19, 0x2C, 0x1F, 0x01, 0x19, 0x28, 0x17, 0x02, 0x0F, 
    0x15, 0x1C, 0x2B, 0x10, 0x1D, 0x2C, 0x25, 0x06, 0x0B, 0x26, 
    0x16, 0x2C, 0x0D, 0x25, 0x30, 0x1F, 0x0A, 0x11, 0x01, 0x17, 
    0x31, 0x25, 0x13, 0x00, 0x1A, 0x25, 0x06, 0x18, 0x26, 0x13, 
    0x2A, 0x21, 0x01, 0x10, 0x08, 0x31, 0x06, 0x13, 0x1B, 0x09, 0x2C, 

    0x06, 0x11, 0x0C, 0x27, 0x17, 0x0E, 0x26, 0x2D, 0x0B, 0x03,         // 85
    0x22, 0x1D, 0x02, 0x2B, 0x19, 0x0C, 0x01, 0x1E, 0x0E, 0x25, 
    0x16, 0x2B, 0x12, 0x2E, 0x17, 0x07, 0x26, 0x31, 0x21, 0x08, 
    0x2C, 0x28, 0x13, 0x2F, 0x1C, 0x01, 0x13, 0x08, 0x1E, 0x00, 
    0x30, 0x05, 0x13, 0x0A, 0x30, 0x0E, 0x1F, 0x0A, 0x25, 0x2C, 
    0x08, 0x22, 0x06, 0x26, 0x17, 0x05, 0x12, 0x1D, 0x22, 0x2D, 
    0x09, 0x21, 0x05, 0x1A, 0x03, 0x0F, 0x19, 0x2F, 0x24, 0x2A, 
    0x06, 0x0F, 0x1D, 0x2E, 0x09, 0x11, 0x29, 0x2D, 0x08, 0x1D, 
    0x04, 0x16, 0x1E, 0x2B, 0x24, 0x16, 0x1D, 0x2B, 0x04, 0x21, 0x15, 

    0x1F, 0x19, 0x2B, 0x06, 0x21, 0x30, 0x00, 0x14, 0x1F, 0x2B,         // 86
    0x12, 0x09, 0x27, 0x20, 0x10, 0x31, 0x25, 0x18, 0x09, 0x2F, 
    0x02, 0x26, 0x06, 0x1C, 0x22, 0x1F, 0x0A, 0x19, 0x0D, 0x14, 
    0x23, 0x0E, 0x03, 0x24, 0x0D, 0x21, 0x32, 0x25, 0x2B, 0x14, 
    0x0F, 0x21, 0x1B, 0x26, 0x16, 0x23, 0x05, 0x31, 0x11, 0x18, 
    0x28, 0x0E, 0x14, 0x2E, 0x0D, 0x27, 0x31, 0x0E, 0x17, 0x05, 
    0x1C, 0x10, 0x2D, 0x14, 0x22, 0x29, 0x06, 0x1C, 0x0A, 0x13, 
    0x1A, 0x2C, 0x04, 0x28, 0x16, 0x22, 0x02, 0x14, 0x21, 0x0E, 
    0x24, 0x31, 0x07, 0x13, 0x0C, 0x03, 0x25, 0x0D, 0x18, 0x32, 0x0E, 

    0x2C, 0x23, 0x09, 0x14, 0x1C, 0x11, 0x25, 0x1C, 0x0F, 0x26,         // 87
    0x19, 0x31, 0x0E, 0x05, 0x1C, 0x15, 0x07, 0x2C, 0x20, 0x14, 
    0x1D, 0x10, 0x31, 0x0B, 0x04, 0x12, 0x2E, 0x00, 0x28, 0x2D, 
    0x04, 0x1F, 0x19, 0x2C, 0x09, 0x1A, 0x11, 0x0B, 0x06, 0x1C, 
    0x28, 0x0A, 0x2E, 0x03, 0x0C, 0x29, 0x13, 0x1C, 0x07, 0x20, 
    0x01, 0x30, 0x1E, 0x04, 0x1A, 0x09, 0x21, 0x02, 0x29, 0x2F, 
    0x15, 0x28, 0x07, 0x1F, 0x0A, 0x2F, 0x25, 0x14, 0x21, 0x02, 
    0x23, 0x0C, 0x17, 0x24, 0x0B, 0x1B, 0x30, 0x0C, 0x1A, 0x2E, 
    0x12, 0x0B, 0x28, 0x1C, 0x2F, 0x19, 0x2E, 0x07, 0x28, 0x1C, 0x01, 

    0x13, 0x0D, 0x30, 0x27, 0x04, 0x2C, 0x07, 0x0C, 0x2E, 0x04,         // 88
    0x08, 0x1E, 0x17, 0x2A, 0x24, 0x0B, 0x29, 0x11, 0x03, 0x24, 
    0x07, 0x18, 0x21, 0x16, 0x2C, 0x26, 0x17, 0x1E, 0x0F, 0x1B, 
    0x12, 0x31, 0x07, 0x15, 0x27, 0x04, 0x29, 0x20, 0x18, 0x2F, 
    0x04, 0x15, 0x22, 0x11, 0x2C, 0x1A, 0x02, 0x24, 0x2C, 0x0D, 
    0x26, 0x19, 0x0B, 0x24, 0x2A, 0x14, 0x1D, 0x12, 0x24, 0x0D, 
    0x00, 0x23, 0x32, 0x0E, 0x17, 0x01, 0x10, 0x2C, 0x0D, 0x28, 
    0x32, 0x1F, 0x09, 0x2F, 0x13, 0x06, 0x1E, 0x29, 0x09, 0x03, 
    0x2A, 0x19, 0x02, 0x23, 0x06, 0x0F, 0x1F, 0x15, 0x10, 0x09, 0x26, 

    0x06, 0x22, 0x02, 0x19, 0x10, 0x20, 0x18, 0x29, 0x16, 0x21,         // 89
    0x13, 0x2D, 0x01, 0x12, 0x2E, 0x02, 0x1E, 0x17, 0x30, 0x0C, 
    0x2D, 0x29, 0x02, 0x0F, 0x1F, 0x0D, 0x08, 0x2A, 0x06, 0x26, 
    0x0B, 0x1C, 0x2A, 0x10, 0x20, 0x17, 0x2D, 0x02, 0x12, 0x24, 
    0x0F, 0x29, 0x19, 0x06, 0x1E, 0x09, 0x2F, 0x15, 0x10, 0x1B, 
    0x06, 0x14, 0x2C, 0x10, 0x01, 0x30, 0x06, 0x2C, 0x08, 0x1F, 
    0x1A, 0x13, 0x05, 0x1B, 0x2B, 0x23, 0x1C, 0x05, 0x1F, 0x17, 
    0x04, 0x10, 0x1C, 0x02, 0x2B, 0x25, 0x10, 0x16, 0x25, 0x1E, 
    0x15, 0x21, 0x10, 0x2A, 0x16, 0x2C, 0x01, 0x2A, 0x21, 0x30, 0x18, 

    0x2D, 0x1D, 0x15, 0x2E, 0x24, 0x0A, 0x32, 0x02, 0x1D, 0x0A,         // 90
    0x23, 0x27, 0x0D, 0x1F, 0x19, 0x10, 0x22, 0x07, 0x26, 0x1C, 
    0x16, 0x0A, 0x25, 0x2F, 0x1B, 0x03, 0x31, 0x21, 0x14, 0x2F, 
    0x02, 0x23, 0x0D, 0x00, 0x30, 0x08, 0x0C, 0x1C, 0x28, 0x08, 
    0x1E, 0x01, 0x2D, 0x26, 0x13, 0x21, 0x0E, 0x27, 0x03, 0x32, 
    0x21, 0x28, 0x09, 0x20, 0x17, 0x25, 0x0E, 0x1B, 0x15, 0x28, 
    0x30, 0x0B, 0x20, 0x27, 0x11, 0x0B, 0x15, 0x30, 0x09, 0x2B, 
    0x14, 0x24, 0x29, 0x15, 0x21, 0x0B, 0x2D, 0x01, 0x31, 0x0F, 
    0x05, 0x2E, 0x08, 0x1D, 0x0C, 0x26, 0x12, 0x1A, 0x05, 0x0E, 0x1F, 
};

const BYTE HT_SuperCell_Blue216[91*91] = {
    0x2D, 0x22, 0x16, 0x10, 0x25, 0x2E, 0x1E, 0x00, 0x28, 0x0F,         //  0
    0x2B, 0x06, 0x31, 0x12, 0x2D, 0x0C, 0x14, 0x1C, 0x27, 0x31, 
    0x08, 0x2B, 0x25, 0x15, 0x1D, 0x11, 0x2F, 0x04, 0x22, 0x06, 
    0x30, 0x01, 0x18, 0x1F, 0x11, 0x25, 0x06, 0x20, 0x10, 0x28, 
    0x16, 0x23, 0x18, 0x31, 0x1F, 0x09, 0x1B, 0x03, 0x1F, 0x10, 
    0x29, 0x1D, 0x02, 0x0E, 0x25, 0x00, 0x17, 0x11, 0x27, 0x2E, 
    0x1D, 0x06, 0x2E, 0x21, 0x14, 0x2A, 0x12, 0x1A, 0x1F, 0x11, 
    0x05, 0x1C, 0x2E, 0x1A, 0x25, 0x09, 0x1D, 0x2A, 0x19, 0x1E, 
    0x2E, 0x20, 0x16, 0x0D, 0x07, 0x28, 0x03, 0x14, 0x2C, 0x01, 0x24, 

    0x19, 0x03, 0x30, 0x0A, 0x19, 0x06, 0x14, 0x31, 0x0A, 0x20,         //  1
    0x15, 0x1A, 0x0B, 0x27, 0x16, 0x24, 0x2F, 0x10, 0x00, 0x1E, 
    0x19, 0x03, 0x2F, 0x0B, 0x21, 0x00, 0x28, 0x0C, 0x2C, 0x12, 
    0x1D, 0x14, 0x27, 0x06, 0x2C, 0x1B, 0x14, 0x2F, 0x02, 0x1C, 
    0x07, 0x0C, 0x26, 0x06, 0x16, 0x2E, 0x12, 0x2B, 0x15, 0x06, 
    0x2F, 0x0B, 0x18, 0x29, 0x13, 0x1F, 0x2F, 0x0A, 0x21, 0x01, 
    0x0D, 0x29, 0x17, 0x05, 0x25, 0x02, 0x32, 0x0A, 0x29, 0x17, 
    0x30, 0x26, 0x07, 0x0F, 0x01, 0x2C, 0x15, 0x0E, 0x01, 0x13, 
    0x08, 0x1A, 0x02, 0x2C, 0x1D, 0x17, 0x21, 0x09, 0x10, 0x1C, 0x0E, 

    0x28, 0x13, 0x1D, 0x28, 0x2D, 0x0C, 0x23, 0x19, 0x13, 0x2D,         //  2
    0x02, 0x2A, 0x22, 0x06, 0x1B, 0x03, 0x09, 0x2B, 0x21, 0x0B, 
    0x13, 0x21, 0x17, 0x05, 0x2C, 0x19, 0x13, 0x23, 0x17, 0x20, 
    0x07, 0x2A, 0x0A, 0x23, 0x15, 0x01, 0x26, 0x0A, 0x2A, 0x21, 
    0x13, 0x2B, 0x1D, 0x12, 0x27, 0x02, 0x21, 0x0D, 0x22, 0x26, 
    0x17, 0x20, 0x2C, 0x08, 0x19, 0x0D, 0x28, 0x04, 0x25, 0x1A, 
    0x15, 0x20, 0x0E, 0x1B, 0x2C, 0x0F, 0x16, 0x22, 0x04, 0x0E, 
    0x22, 0x0B, 0x18, 0x21, 0x28, 0x1B, 0x05, 0x30, 0x21, 0x27, 
    0x0F, 0x31, 0x25, 0x14, 0x0E, 0x2F, 0x0C, 0x24, 0x31, 0x1F, 0x06, 

    0x0A, 0x23, 0x07, 0x11, 0x01, 0x1C, 0x2A, 0x05, 0x26, 0x08,         //  3
    0x1E, 0x0D, 0x12, 0x2E, 0x25, 0x13, 0x1F, 0x18, 0x06, 0x26, 
    0x2E, 0x0D, 0x1E, 0x27, 0x0F, 0x1F, 0x07, 0x32, 0x02, 0x0B, 
    0x24, 0x10, 0x31, 0x1C, 0x0E, 0x2E, 0x1F, 0x11, 0x1B, 0x0D, 
    0x30, 0x00, 0x0E, 0x2D, 0x0B, 0x1D, 0x18, 0x07, 0x2E, 0x00, 
    0x0C, 0x12, 0x03, 0x22, 0x2D, 0x06, 0x1B, 0x13, 0x31, 0x0F, 
    0x2B, 0x03, 0x2F, 0x08, 0x23, 0x19, 0x06, 0x28, 0x2D, 0x1B, 
    0x01, 0x2C, 0x11, 0x32, 0x13, 0x0A, 0x1F, 0x25, 0x06, 0x2C, 
    0x17, 0x0A, 0x1F, 0x06, 0x2A, 0x01, 0x19, 0x29, 0x04, 0x15, 0x2D, 

    0x10, 0x32, 0x18, 0x20, 0x26, 0x15, 0x0E, 0x2D, 0x10, 0x1A,         //  4
    0x30, 0x24, 0x17, 0x01, 0x0E, 0x32, 0x27, 0x10, 0x2F, 0x15, 
    0x02, 0x2A, 0x07, 0x14, 0x30, 0x0A, 0x27, 0x11, 0x2A, 0x1A, 
    0x2E, 0x02, 0x18, 0x06, 0x29, 0x09, 0x18, 0x04, 0x2C, 0x07, 
    0x17, 0x25, 0x19, 0x22, 0x07, 0x31, 0x10, 0x2A, 0x13, 0x1B, 
    0x28, 0x31, 0x1C, 0x0F, 0x25, 0x11, 0x20, 0x2A, 0x0C, 0x06, 
    0x22, 0x11, 0x26, 0x14, 0x0B, 0x30, 0x1D, 0x0D, 0x12, 0x24, 
    0x15, 0x1F, 0x06, 0x25, 0x03, 0x2A, 0x16, 0x10, 0x0B, 0x1F, 
    0x04, 0x28, 0x11, 0x19, 0x26, 0x1F, 0x12, 0x08, 0x1B, 0x0E, 0x25, 

    0x19, 0x29, 0x03, 0x0C, 0x2F, 0x07, 0x1F, 0x02, 0x20, 0x15,         //  5
    0x04, 0x0A, 0x2C, 0x20, 0x19, 0x0A, 0x02, 0x1D, 0x0C, 0x23, 
    0x1B, 0x11, 0x23, 0x19, 0x01, 0x24, 0x17, 0x05, 0x22, 0x0E, 
    0x15, 0x29, 0x20, 0x13, 0x24, 0x10, 0x2F, 0x26, 0x15, 0x1F, 
    0x28, 0x11, 0x04, 0x29, 0x14, 0x1F, 0x26, 0x03, 0x1F, 0x0E, 
    0x23, 0x05, 0x15, 0x09, 0x2F, 0x01, 0x16, 0x07, 0x1F, 0x18, 
    0x2D, 0x1B, 0x06, 0x1E, 0x2A, 0x01, 0x16, 0x21, 0x03, 0x31, 
    0x07, 0x2A, 0x1A, 0x0C, 0x1D, 0x0E, 0x2F, 0x1B, 0x2D, 0x13, 
    0x1A, 0x2C, 0x02, 0x2E, 0x08, 0x0C, 0x24, 0x2D, 0x22, 0x2B, 0x00, 

    0x0D, 0x22, 0x14, 0x1D, 0x10, 0x28, 0x19, 0x32, 0x0C, 0x2B,         //  6
    0x26, 0x10, 0x1D, 0x08, 0x29, 0x23, 0x15, 0x2A, 0x04, 0x2C, 
    0x08, 0x31, 0x0A, 0x2B, 0x1D, 0x0D, 0x2E, 0x1B, 0x28, 0x04, 
    0x1D, 0x08, 0x0C, 0x30, 0x00, 0x1D, 0x07, 0x22, 0x0B, 0x02, 
    0x32, 0x0C, 0x1C, 0x2F, 0x05, 0x0D, 0x19, 0x0A, 0x30, 0x16, 
    0x0A, 0x2D, 0x27, 0x1F, 0x19, 0x2A, 0x23, 0x30, 0x12, 0x28, 
    0x00, 0x0D, 0x32, 0x17, 0x10, 0x23, 0x2D, 0x09, 0x28, 0x18, 
    0x10, 0x0A, 0x26, 0x15, 0x2B, 0x22, 0x09, 0x02, 0x28, 0x07, 
    0x24, 0x0E, 0x20, 0x14, 0x1D, 0x32, 0x15, 0x04, 0x0B, 0x13, 0x1E, 

    0x2B, 0x05, 0x25, 0x2D, 0x04, 0x22, 0x0B, 0x12, 0x24, 0x08,         //  7
    0x18, 0x2E, 0x04, 0x17, 0x11, 0x2D, 0x0D, 0x22, 0x19, 0x13, 
    0x1F, 0x16, 0x25, 0x05, 0x11, 0x29, 0x13, 0x0A, 0x31, 0x11, 
    0x25, 0x2E, 0x19, 0x26, 0x15, 0x2A, 0x1A, 0x0F, 0x2D, 0x1B, 
    0x13, 0x20, 0x08, 0x16, 0x22, 0x2C, 0x12, 0x27, 0x22, 0x01, 
    0x1F, 0x18, 0x10, 0x03, 0x0B, 0x14, 0x0D, 0x03, 0x1B, 0x0A, 
    0x25, 0x15, 0x22, 0x04, 0x27, 0x0A, 0x13, 0x1C, 0x0E, 0x22, 
    0x2D, 0x1E, 0x02, 0x30, 0x05, 0x12, 0x27, 0x15, 0x20, 0x0C, 
    0x31, 0x18, 0x09, 0x2A, 0x10, 0x01, 0x25, 0x19, 0x30, 0x27, 0x09, 

    0x2F, 0x11, 0x1B, 0x0A, 0x18, 0x2E, 0x03, 0x29, 0x1B, 0x00,         //  8
    0x1E, 0x13, 0x23, 0x30, 0x01, 0x1B, 0x06, 0x31, 0x0A, 0x27, 
    0x01, 0x0E, 0x1B, 0x2D, 0x1F, 0x08, 0x20, 0x00, 0x18, 0x22, 
    0x06, 0x14, 0x03, 0x21, 0x09, 0x11, 0x31, 0x04, 0x16, 0x24, 
    0x06, 0x2D, 0x26, 0x10, 0x28, 0x03, 0x1C, 0x07, 0x2C, 0x13, 
    0x29, 0x06, 0x22, 0x2E, 0x29, 0x1E, 0x25, 0x2C, 0x10, 0x2F, 
    0x1D, 0x0F, 0x2B, 0x09, 0x2F, 0x19, 0x1F, 0x05, 0x2F, 0x00, 
    0x15, 0x27, 0x1A, 0x0E, 0x22, 0x19, 0x07, 0x30, 0x1C, 0x12, 
    0x00, 0x1E, 0x27, 0x05, 0x19, 0x2B, 0x1E, 0x10, 0x05, 0x1D, 0x17, 

    0x22, 0x08, 0x29, 0x13, 0x27, 0x0F, 0x1E, 0x15, 0x2F, 0x0F,         //  9
    0x2C, 0x0A, 0x28, 0x0F, 0x1F, 0x27, 0x14, 0x1D, 0x0F, 0x2B, 
    0x22, 0x2F, 0x0B, 0x14, 0x02, 0x2E, 0x26, 0x1C, 0x2B, 0x0C, 
    0x2C, 0x1D, 0x0F, 0x2A, 0x1E, 0x06, 0x22, 0x27, 0x0A, 0x2B, 
    0x11, 0x1E, 0x01, 0x1B, 0x0A, 0x31, 0x15, 0x1F, 0x0C, 0x1B, 
    0x09, 0x31, 0x0D, 0x19, 0x11, 0x05, 0x09, 0x15, 0x20, 0x08, 
    0x29, 0x03, 0x18, 0x20, 0x12, 0x02, 0x24, 0x28, 0x11, 0x1D, 
    0x0B, 0x06, 0x12, 0x29, 0x09, 0x2C, 0x23, 0x10, 0x04, 0x2C, 
    0x23, 0x15, 0x0C, 0x2E, 0x23, 0x0E, 0x07, 0x2E, 0x21, 0x12, 0x02, 

    0x0E, 0x18, 0x31, 0x01, 0x20, 0x07, 0x21, 0x0B, 0x05, 0x27,         // 10
    0x20, 0x05, 0x15, 0x08, 0x19, 0x0C, 0x2E, 0x03, 0x20, 0x08, 
    0x17, 0x05, 0x29, 0x24, 0x19, 0x11, 0x0D, 0x15, 0x07, 0x12, 
    0x26, 0x05, 0x32, 0x16, 0x0D, 0x2D, 0x19, 0x0E, 0x1F, 0x02, 
    0x18, 0x0C, 0x2F, 0x15, 0x20, 0x0D, 0x26, 0x02, 0x2F, 0x11, 
    0x24, 0x15, 0x1D, 0x00, 0x24, 0x32, 0x1A, 0x2A, 0x01, 0x1B, 
    0x13, 0x31, 0x0C, 0x1B, 0x2C, 0x0E, 0x31, 0x0B, 0x18, 0x2A, 
    0x2D, 0x23, 0x32, 0x1D, 0x15, 0x01, 0x0D, 0x2A, 0x17, 0x25, 
    0x06, 0x2F, 0x11, 0x1F, 0x03, 0x14, 0x27, 0x16, 0x0C, 0x2C, 0x28, 

    0x24, 0x05, 0x1E, 0x10, 0x2B, 0x16, 0x31, 0x19, 0x22, 0x11,         // 11
    0x18, 0x1C, 0x32, 0x22, 0x2B, 0x06, 0x22, 0x11, 0x1A, 0x30, 
    0x13, 0x1E, 0x10, 0x07, 0x32, 0x1E, 0x05, 0x30, 0x28, 0x1F, 
    0x09, 0x18, 0x23, 0x01, 0x21, 0x13, 0x03, 0x2B, 0x13, 0x31, 
    0x23, 0x29, 0x08, 0x25, 0x04, 0x19, 0x11, 0x2A, 0x23, 0x05, 
    0x2C, 0x07, 0x27, 0x2D, 0x0B, 0x13, 0x22, 0x0E, 0x26, 0x0B, 
    0x24, 0x1E, 0x07, 0x27, 0x05, 0x17, 0x1E, 0x07, 0x20, 0x03, 
    0x0D, 0x1A, 0x02, 0x0E, 0x24, 0x2F, 0x1C, 0x1F, 0x0A, 0x13, 
    0x1C, 0x09, 0x29, 0x17, 0x0A, 0x30, 0x22, 0x02, 0x1F, 0x0A, 0x1A, 

    0x2D, 0x15, 0x26, 0x0A, 0x1B, 0x04, 0x10, 0x27, 0x09, 0x2B,         // 12
    0x03, 0x0F, 0x26, 0x02, 0x11, 0x16, 0x2A, 0x26, 0x0A, 0x28, 
    0x03, 0x2E, 0x18, 0x22, 0x0C, 0x2A, 0x17, 0x23, 0x01, 0x1A, 
    0x2D, 0x10, 0x29, 0x0B, 0x2F, 0x1D, 0x28, 0x0B, 0x1C, 0x06, 
    0x0F, 0x1D, 0x12, 0x2E, 0x22, 0x2B, 0x06, 0x1B, 0x0E, 0x19, 
    0x1F, 0x13, 0x0C, 0x21, 0x17, 0x04, 0x2C, 0x07, 0x30, 0x17, 
    0x03, 0x14, 0x2E, 0x12, 0x23, 0x2A, 0x0F, 0x2D, 0x13, 0x26, 
    0x16, 0x20, 0x13, 0x28, 0x07, 0x17, 0x11, 0x05, 0x32, 0x27, 
    0x0E, 0x21, 0x04, 0x26, 0x1B, 0x2A, 0x0F, 0x19, 0x32, 0x14, 0x03, 

    0x0D, 0x08, 0x2F, 0x13, 0x23, 0x2D, 0x1E, 0x02, 0x2F, 0x13,         // 13
    0x24, 0x2E, 0x0B, 0x1B, 0x2F, 0x1D, 0x0E, 0x00, 0x17, 0x1E, 
    0x0E, 0x23, 0x05, 0x2C, 0x13, 0x02, 0x1F, 0x0A, 0x0E, 0x14, 
    0x24, 0x05, 0x16, 0x1C, 0x11, 0x06, 0x18, 0x21, 0x2D, 0x16, 
    0x26, 0x03, 0x1A, 0x07, 0x0D, 0x13, 0x32, 0x20, 0x08, 0x29, 
    0x01, 0x30, 0x1A, 0x03, 0x2B, 0x26, 0x1D, 0x19, 0x10, 0x22, 
    0x2C, 0x26, 0x0D, 0x1C, 0x0A, 0x00, 0x1B, 0x24, 0x05, 0x30, 
    0x09, 0x2C, 0x05, 0x2E, 0x22, 0x0C, 0x2C, 0x23, 0x18, 0x01, 
    0x2B, 0x15, 0x30, 0x11, 0x00, 0x14, 0x08, 0x25, 0x06, 0x22, 0x2A, 

    0x1D, 0x20, 0x18, 0x01, 0x29, 0x08, 0x0E, 0x18, 0x20, 0x0B,         // 14
    0x1D, 0x06, 0x21, 0x14, 0x04, 0x0A, 0x2D, 0x20, 0x2B, 0x07, 
    0x14, 0x28, 0x16, 0x09, 0x1C, 0x27, 0x15, 0x2C, 0x26, 0x31, 
    0x0C, 0x1F, 0x2E, 0x03, 0x2B, 0x25, 0x09, 0x10, 0x00, 0x29, 
    0x0A, 0x30, 0x23, 0x16, 0x27, 0x1D, 0x00, 0x12, 0x2E, 0x16, 
    0x0B, 0x25, 0x11, 0x23, 0x0E, 0x09, 0x13, 0x01, 0x28, 0x0C, 
    0x08, 0x1A, 0x05, 0x21, 0x31, 0x15, 0x2B, 0x0C, 0x19, 0x10, 
    0x1C, 0x25, 0x0E, 0x18, 0x1C, 0x02, 0x27, 0x08, 0x10, 0x20, 
    0x08, 0x1A, 0x0D, 0x1E, 0x24, 0x2D, 0x1D, 0x29, 0x0E, 0x18, 0x11, 

    0x31, 0x06, 0x2A, 0x0E, 0x1F, 0x14, 0x30, 0x26, 0x05, 0x16,         // 15
    0x28, 0x11, 0x18, 0x2A, 0x22, 0x26, 0x16, 0x05, 0x11, 0x31, 
    0x20, 0x01, 0x2F, 0x24, 0x0F, 0x30, 0x06, 0x11, 0x1D, 0x03, 
    0x1A, 0x09, 0x26, 0x0F, 0x20, 0x14, 0x32, 0x1B, 0x23, 0x13, 
    0x1F, 0x0E, 0x2A, 0x05, 0x2C, 0x0A, 0x18, 0x25, 0x09, 0x20, 
    0x1C, 0x2B, 0x06, 0x2D, 0x16, 0x31, 0x25, 0x21, 0x2D, 0x1C, 
    0x13, 0x2F, 0x16, 0x28, 0x10, 0x08, 0x26, 0x03, 0x22, 0x28, 
    0x01, 0x15, 0x1F, 0x07, 0x10, 0x31, 0x1E, 0x15, 0x2E, 0x1B, 
    0x21, 0x2D, 0x05, 0x2A, 0x07, 0x0C, 0x16, 0x03, 0x2F, 0x24, 0x02, 

    0x17, 0x12, 0x24, 0x1A, 0x05, 0x24, 0x0A, 0x1A, 0x2B, 0x0E,         // 16
    0x31, 0x01, 0x2C, 0x08, 0x12, 0x31, 0x0C, 0x1C, 0x25, 0x09, 
    0x1A, 0x0D, 0x1D, 0x05, 0x19, 0x0C, 0x22, 0x19, 0x09, 0x21, 
    0x13, 0x2C, 0x1D, 0x08, 0x18, 0x02, 0x28, 0x05, 0x2E, 0x07, 
    0x19, 0x02, 0x14, 0x1C, 0x0F, 0x20, 0x2D, 0x10, 0x2A, 0x02, 
    0x0E, 0x18, 0x0A, 0x1E, 0x04, 0x1A, 0x0B, 0x06, 0x17, 0x03, 
    0x27, 0x1F, 0x01, 0x0B, 0x1E, 0x2E, 0x17, 0x1D, 0x32, 0x0E, 
    0x2D, 0x0A, 0x28, 0x2D, 0x23, 0x13, 0x05, 0x0C, 0x26, 0x03, 
    0x0B, 0x14, 0x23, 0x12, 0x18, 0x31, 0x20, 0x10, 0x1A, 0x0A, 0x27, 

    0x08, 0x2D, 0x0A, 0x30, 0x16, 0x2C, 0x13, 0x00, 0x23, 0x1C,         // 17
    0x0A, 0x20, 0x1B, 0x0E, 0x1E, 0x02, 0x20, 0x13, 0x29, 0x10, 
    0x2C, 0x15, 0x2A, 0x12, 0x2D, 0x26, 0x00, 0x2F, 0x2A, 0x0E, 
    0x25, 0x01, 0x12, 0x30, 0x24, 0x0E, 0x1D, 0x0C, 0x17, 0x2A, 
    0x25, 0x31, 0x20, 0x09, 0x2F, 0x03, 0x1C, 0x06, 0x23, 0x14, 
    0x31, 0x22, 0x28, 0x13, 0x20, 0x2A, 0x12, 0x2F, 0x0E, 0x2B, 
    0x09, 0x0F, 0x25, 0x2D, 0x1A, 0x04, 0x0F, 0x09, 0x13, 0x05, 
    0x18, 0x20, 0x12, 0x02, 0x09, 0x2B, 0x20, 0x19, 0x2A, 0x12, 
    0x1E, 0x31, 0x01, 0x1C, 0x26, 0x02, 0x29, 0x08, 0x2C, 0x13, 0x1F, 

    0x1C, 0x0E, 0x20, 0x02, 0x27, 0x08, 0x1F, 0x2D, 0x10, 0x04,         // 18
    0x27, 0x13, 0x05, 0x2F, 0x17, 0x2A, 0x07, 0x2E, 0x04, 0x1F, 
    0x07, 0x25, 0x03, 0x1F, 0x07, 0x13, 0x1E, 0x16, 0x05, 0x1B, 
    0x2F, 0x18, 0x28, 0x05, 0x1A, 0x2D, 0x26, 0x13, 0x20, 0x0B, 
    0x11, 0x06, 0x19, 0x28, 0x12, 0x26, 0x17, 0x0C, 0x2C, 0x1A, 
    0x0A, 0x11, 0x03, 0x30, 0x0F, 0x00, 0x1D, 0x26, 0x21, 0x14, 
    0x1B, 0x32, 0x17, 0x06, 0x13, 0x27, 0x21, 0x24, 0x2A, 0x1C, 
    0x26, 0x07, 0x31, 0x1C, 0x17, 0x25, 0x10, 0x01, 0x2F, 0x09, 
    0x18, 0x27, 0x0D, 0x2C, 0x0F, 0x0A, 0x16, 0x1C, 0x24, 0x00, 0x2A, 

    0x04, 0x27, 0x19, 0x13, 0x0F, 0x1B, 0x0C, 0x27, 0x15, 0x30,         // 19
    0x18, 0x2B, 0x21, 0x24, 0x0B, 0x11, 0x1B, 0x24, 0x0D, 0x18, 
    0x30, 0x16, 0x0B, 0x2E, 0x18, 0x2B, 0x0D, 0x27, 0x12, 0x20, 
    0x0C, 0x07, 0x1E, 0x0C, 0x14, 0x03, 0x0A, 0x30, 0x02, 0x1B, 
    0x23, 0x2C, 0x0D, 0x01, 0x23, 0x08, 0x31, 0x12, 0x1F, 0x04, 
    0x2D, 0x27, 0x16, 0x23, 0x0A, 0x2D, 0x15, 0x0C, 0x05, 0x29, 
    0x02, 0x1F, 0x0E, 0x21, 0x2B, 0x0A, 0x2D, 0x01, 0x15, 0x0C, 
    0x2C, 0x15, 0x0E, 0x29, 0x0C, 0x2F, 0x07, 0x1F, 0x15, 0x24, 
    0x04, 0x1F, 0x08, 0x18, 0x24, 0x1E, 0x2F, 0x06, 0x15, 0x32, 0x11, 

    0x21, 0x30, 0x06, 0x2B, 0x25, 0x31, 0x05, 0x19, 0x08, 0x20,         // 20
    0x06, 0x0C, 0x12, 0x01, 0x2D, 0x26, 0x09, 0x14, 0x29, 0x00, 
    0x23, 0x0F, 0x1C, 0x26, 0x10, 0x02, 0x23, 0x08, 0x30, 0x02, 
    0x2A, 0x14, 0x2E, 0x22, 0x2B, 0x1F, 0x18, 0x21, 0x15, 0x2E, 
    0x05, 0x16, 0x1E, 0x2F, 0x15, 0x1A, 0x27, 0x01, 0x24, 0x18, 
    0x09, 0x1D, 0x07, 0x2B, 0x18, 0x22, 0x06, 0x31, 0x18, 0x24, 
    0x0D, 0x2B, 0x08, 0x1B, 0x02, 0x17, 0x10, 0x1A, 0x30, 0x06, 
    0x20, 0x02, 0x24, 0x1E, 0x04, 0x14, 0x1B, 0x28, 0x0C, 0x2C, 
    0x10, 0x2B, 0x13, 0x30, 0x04, 0x13, 0x27, 0x0F, 0x20, 0x0B, 0x1A, 

    0x08, 0x16, 0x0C, 0x1D, 0x01, 0x21, 0x13, 0x2E, 0x25, 0x0F,         // 21
    0x1C, 0x28, 0x31, 0x16, 0x1C, 0x04, 0x1F, 0x32, 0x10, 0x1B, 
    0x2B, 0x05, 0x21, 0x09, 0x31, 0x1D, 0x29, 0x17, 0x1E, 0x0F, 
    0x25, 0x1B, 0x0F, 0x08, 0x27, 0x07, 0x0F, 0x2B, 0x09, 0x10, 
    0x25, 0x0A, 0x29, 0x0F, 0x06, 0x1E, 0x0C, 0x2B, 0x10, 0x30, 
    0x13, 0x21, 0x0E, 0x02, 0x26, 0x10, 0x29, 0x1F, 0x09, 0x12, 
    0x2F, 0x15, 0x24, 0x11, 0x31, 0x26, 0x1E, 0x08, 0x25, 0x11, 
    0x18, 0x2F, 0x09, 0x11, 0x2D, 0x25, 0x0A, 0x32, 0x05, 0x19, 
    0x1D, 0x00, 0x21, 0x1C, 0x0E, 0x2D, 0x01, 0x1A, 0x2B, 0x04, 0x26, 

    0x12, 0x1F, 0x2D, 0x10, 0x17, 0x0B, 0x1F, 0x03, 0x2A, 0x14,         // 22
    0x04, 0x24, 0x09, 0x20, 0x0E, 0x2B, 0x17, 0x05, 0x25, 0x0B, 
    0x16, 0x2F, 0x12, 0x19, 0x06, 0x14, 0x0C, 0x05, 0x2C, 0x1A, 
    0x07, 0x31, 0x01, 0x18, 0x11, 0x31, 0x1B, 0x00, 0x20, 0x1D, 
    0x2D, 0x1A, 0x03, 0x22, 0x26, 0x2E, 0x14, 0x07, 0x1D, 0x03, 
    0x25, 0x2B, 0x1A, 0x32, 0x15, 0x09, 0x1A, 0x01, 0x2B, 0x1C, 
    0x0A, 0x00, 0x28, 0x1D, 0x0C, 0x06, 0x2E, 0x0D, 0x22, 0x28, 
    0x0B, 0x1C, 0x2A, 0x18, 0x20, 0x01, 0x17, 0x11, 0x21, 0x13, 
    0x2F, 0x0C, 0x17, 0x09, 0x28, 0x15, 0x21, 0x0D, 0x24, 0x14, 0x2C, 

    0x02, 0x28, 0x06, 0x23, 0x2F, 0x29, 0x11, 0x1A, 0x09, 0x23,         // 23
    0x2F, 0x11, 0x1A, 0x05, 0x28, 0x13, 0x21, 0x0F, 0x2E, 0x1E, 
    0x07, 0x26, 0x01, 0x2A, 0x20, 0x2D, 0x25, 0x11, 0x20, 0x0C, 
    0x14, 0x22, 0x29, 0x1D, 0x23, 0x05, 0x26, 0x16, 0x2A, 0x04, 
    0x14, 0x0C, 0x31, 0x17, 0x12, 0x03, 0x19, 0x23, 0x28, 0x16, 
    0x0C, 0x05, 0x11, 0x1F, 0x06, 0x25, 0x2F, 0x11, 0x15, 0x26, 
    0x20, 0x17, 0x2E, 0x04, 0x15, 0x20, 0x13, 0x18, 0x04, 0x31, 
    0x14, 0x00, 0x23, 0x07, 0x0C, 0x27, 0x2B, 0x1E, 0x03, 0x26, 
    0x07, 0x29, 0x24, 0x32, 0x06, 0x1E, 0x0A, 0x17, 0x2F, 0x0B, 0x1B, 

    0x31, 0x0F, 0x1A, 0x13, 0x04, 0x08, 0x25, 0x2C, 0x0F, 0x1C,         // 24
    0x17, 0x02, 0x2C, 0x25, 0x0C, 0x30, 0x08, 0x1A, 0x02, 0x29, 
    0x11, 0x1A, 0x22, 0x13, 0x0D, 0x03, 0x19, 0x32, 0x00, 0x27, 
    0x2D, 0x04, 0x11, 0x0B, 0x2D, 0x14, 0x0C, 0x2F, 0x12, 0x0A, 
    0x27, 0x20, 0x10, 0x28, 0x0A, 0x20, 0x30, 0x0F, 0x09, 0x2F, 
    0x21, 0x18, 0x2E, 0x0D, 0x2A, 0x1C, 0x0B, 0x21, 0x04, 0x31, 
    0x07, 0x0F, 0x21, 0x19, 0x2C, 0x28, 0x01, 0x2B, 0x1C, 0x09, 
    0x1F, 0x2B, 0x11, 0x31, 0x14, 0x1B, 0x0E, 0x09, 0x2D, 0x18, 
    0x1E, 0x0F, 0x03, 0x13, 0x1A, 0x26, 0x2E, 0x04, 0x1D, 0x07, 0x23, 

    0x16, 0x09, 0x26, 0x2B, 0x1F, 0x1B, 0x15, 0x01, 0x2E, 0x07,         // 25
    0x2A, 0x0F, 0x22, 0x15, 0x1C, 0x03, 0x1F, 0x2A, 0x13, 0x23, 
    0x0C, 0x31, 0x0A, 0x2C, 0x1C, 0x16, 0x23, 0x08, 0x1D, 0x16, 
    0x0A, 0x1B, 0x30, 0x17, 0x02, 0x1E, 0x21, 0x03, 0x24, 0x19, 
    0x2C, 0x06, 0x1C, 0x01, 0x2C, 0x1A, 0x05, 0x2A, 0x14, 0x1C, 
    0x07, 0x28, 0x01, 0x23, 0x14, 0x03, 0x17, 0x2C, 0x0E, 0x1B, 
    0x14, 0x2B, 0x09, 0x11, 0x06, 0x1B, 0x0B, 0x21, 0x11, 0x27, 
    0x0E, 0x18, 0x06, 0x1D, 0x28, 0x04, 0x30, 0x21, 0x14, 0x0C, 
    0x30, 0x16, 0x21, 0x2C, 0x0F, 0x02, 0x15, 0x23, 0x10, 0x29, 0x12, 

    0x2C, 0x1E, 0x00, 0x0D, 0x11, 0x32, 0x0B, 0x21, 0x16, 0x27,         // 26
    0x1F, 0x08, 0x31, 0x04, 0x12, 0x28, 0x16, 0x09, 0x30, 0x04, 
    0x1D, 0x17, 0x06, 0x24, 0x04, 0x2F, 0x0B, 0x14, 0x2B, 0x0F, 
    0x26, 0x20, 0x06, 0x25, 0x2A, 0x10, 0x19, 0x2A, 0x08, 0x1F, 
    0x0E, 0x15, 0x2E, 0x23, 0x13, 0x0C, 0x25, 0x1F, 0x00, 0x2C, 
    0x0E, 0x1E, 0x15, 0x2C, 0x08, 0x30, 0x26, 0x06, 0x20, 0x29, 
    0x05, 0x24, 0x1D, 0x2F, 0x26, 0x0F, 0x32, 0x16, 0x07, 0x2D, 
    0x04, 0x25, 0x2E, 0x0A, 0x22, 0x10, 0x19, 0x07, 0x2A, 0x01, 
    0x27, 0x05, 0x1D, 0x0B, 0x28, 0x1F, 0x2C, 0x09, 0x30, 0x21, 0x04, 

    0x27, 0x19, 0x2F, 0x17, 0x24, 0x05, 0x28, 0x1D, 0x04, 0x0D,         // 27
    0x13, 0x18, 0x26, 0x0A, 0x20, 0x2F, 0x0D, 0x26, 0x1C, 0x10, 
    0x2C, 0x21, 0x12, 0x28, 0x0F, 0x1E, 0x2A, 0x24, 0x07, 0x30, 
    0x02, 0x18, 0x0E, 0x1D, 0x07, 0x32, 0x05, 0x0E, 0x16, 0x30, 
    0x02, 0x29, 0x09, 0x19, 0x06, 0x32, 0x11, 0x18, 0x0B, 0x24, 
    0x13, 0x31, 0x0A, 0x1A, 0x0F, 0x1E, 0x19, 0x13, 0x09, 0x16, 
    0x30, 0x0D, 0x13, 0x03, 0x16, 0x1F, 0x05, 0x27, 0x1A, 0x1F, 
    0x14, 0x1C, 0x10, 0x19, 0x02, 0x2D, 0x26, 0x12, 0x1C, 0x20, 
    0x19, 0x10, 0x2E, 0x06, 0x19, 0x0C, 0x12, 0x1B, 0x01, 0x18, 0x0D, 

    0x06, 0x13, 0x0B, 0x20, 0x08, 0x2C, 0x18, 0x10, 0x30, 0x22,         // 28
    0x2D, 0x00, 0x1D, 0x2B, 0x0F, 0x1A, 0x01, 0x14, 0x07, 0x29, 
    0x0B, 0x00, 0x1B, 0x2E, 0x0A, 0x1A, 0x01, 0x10, 0x19, 0x1E, 
    0x12, 0x2E, 0x28, 0x15, 0x0B, 0x1A, 0x26, 0x2D, 0x23, 0x11, 
    0x1B, 0x24, 0x0E, 0x20, 0x28, 0x1E, 0x03, 0x27, 0x2F, 0x19, 
    0x03, 0x20, 0x05, 0x24, 0x29, 0x00, 0x0C, 0x2F, 0x27, 0x1C, 
    0x01, 0x22, 0x19, 0x2B, 0x0B, 0x25, 0x13, 0x2E, 0x03, 0x0E, 
    0x30, 0x01, 0x2A, 0x25, 0x13, 0x1E, 0x0A, 0x04, 0x30, 0x0D, 
    0x08, 0x28, 0x15, 0x24, 0x31, 0x03, 0x2A, 0x25, 0x0F, 0x2D, 0x23, 

    0x31, 0x25, 0x04, 0x29, 0x1B, 0x0E, 0x03, 0x24, 0x07, 0x1A,         // 29
    0x09, 0x29, 0x11, 0x17, 0x06, 0x29, 0x1F, 0x2D, 0x22, 0x16, 
    0x24, 0x30, 0x14, 0x04, 0x21, 0x13, 0x31, 0x22, 0x04, 0x29, 
    0x0C, 0x21, 0x03, 0x2B, 0x24, 0x13, 0x1F, 0x01, 0x0A, 0x29, 
    0x08, 0x16, 0x30, 0x01, 0x14, 0x0A, 0x2D, 0x16, 0x06, 0x22, 
    0x29, 0x0D, 0x17, 0x2F, 0x12, 0x20, 0x2B, 0x22, 0x07, 0x0F, 
    0x2C, 0x28, 0x05, 0x1F, 0x30, 0x00, 0x1D, 0x10, 0x22, 0x26, 
    0x09, 0x20, 0x0D, 0x06, 0x32, 0x0E, 0x29, 0x18, 0x24, 0x14, 
    0x2C, 0x21, 0x00, 0x0E, 0x22, 0x15, 0x1C, 0x06, 0x1F, 0x14, 0x09, 

    0x0F, 0x1E, 0x17, 0x30, 0x13, 0x1F, 0x2F, 0x14, 0x2B, 0x0E,         // 30
    0x15, 0x24, 0x04, 0x31, 0x24, 0x08, 0x18, 0x0C, 0x03, 0x1C, 
    0x08, 0x0F, 0x27, 0x18, 0x2C, 0x06, 0x27, 0x0D, 0x2E, 0x15, 
    0x07, 0x1C, 0x10, 0x09, 0x2F, 0x06, 0x0D, 0x1A, 0x15, 0x1E, 
    0x2D, 0x05, 0x1C, 0x10, 0x2C, 0x1A, 0x0D, 0x20, 0x10, 0x09, 
    0x14, 0x2C, 0x1D, 0x07, 0x0B, 0x16, 0x05, 0x11, 0x19, 0x1F, 
    0x15, 0x0B, 0x11, 0x1B, 0x0E, 0x18, 0x2A, 0x08, 0x16, 0x2C, 
    0x13, 0x18, 0x2C, 0x1C, 0x16, 0x21, 0x01, 0x2D, 0x0C, 0x1C, 
    0x04, 0x12, 0x2E, 0x1D, 0x07, 0x2B, 0x10, 0x2F, 0x0B, 0x2A, 0x1B, 

    0x01, 0x2C, 0x09, 0x0E, 0x02, 0x26, 0x0B, 0x1C, 0x02, 0x1F,         // 31
    0x2F, 0x1B, 0x0B, 0x1F, 0x12, 0x2E, 0x0F, 0x28, 0x31, 0x11, 
    0x2C, 0x1D, 0x07, 0x1F, 0x0C, 0x1D, 0x16, 0x09, 0x1B, 0x23, 
    0x2C, 0x27, 0x18, 0x20, 0x16, 0x22, 0x27, 0x31, 0x21, 0x03, 
    0x10, 0x24, 0x29, 0x09, 0x22, 0x26, 0x02, 0x2A, 0x1C, 0x30, 
    0x25, 0x01, 0x0F, 0x24, 0x28, 0x1E, 0x2E, 0x25, 0x02, 0x30, 
    0x08, 0x21, 0x2F, 0x25, 0x07, 0x27, 0x0B, 0x31, 0x02, 0x1C, 
    0x05, 0x27, 0x11, 0x03, 0x28, 0x09, 0x14, 0x1F, 0x07, 0x31, 
    0x23, 0x0A, 0x26, 0x18, 0x0B, 0x24, 0x04, 0x27, 0x17, 0x06, 0x21, 

    0x16, 0x1C, 0x28, 0x20, 0x2E, 0x18, 0x06, 0x29, 0x16, 0x25,         // 32
    0x06, 0x10, 0x2D, 0x17, 0x01, 0x1B, 0x21, 0x06, 0x1A, 0x25, 
    0x02, 0x2A, 0x13, 0x32, 0x10, 0x01, 0x26, 0x2B, 0x10, 0x02, 
    0x12, 0x06, 0x2F, 0x00, 0x0C, 0x2A, 0x03, 0x0F, 0x08, 0x2E, 
    0x19, 0x0B, 0x16, 0x31, 0x06, 0x17, 0x2F, 0x13, 0x05, 0x18, 
    0x11, 0x20, 0x19, 0x32, 0x02, 0x19, 0x09, 0x14, 0x2B, 0x0D, 
    0x28, 0x19, 0x01, 0x15, 0x2D, 0x12, 0x21, 0x1A, 0x25, 0x10, 
    0x1F, 0x31, 0x08, 0x22, 0x2D, 0x1A, 0x26, 0x10, 0x29, 0x13, 
    0x1A, 0x2B, 0x03, 0x0F, 0x30, 0x14, 0x1A, 0x0C, 0x1E, 0x12, 0x2E, 

    0x0D, 0x05, 0x14, 0x08, 0x1C, 0x12, 0x24, 0x0E, 0x32, 0x0B,         // 33
    0x13, 0x27, 0x05, 0x21, 0x29, 0x09, 0x13, 0x1F, 0x0B, 0x16, 
    0x0E, 0x1A, 0x05, 0x27, 0x22, 0x2E, 0x19, 0x05, 0x21, 0x31, 
    0x17, 0x21, 0x0F, 0x1D, 0x2D, 0x12, 0x1B, 0x17, 0x28, 0x13, 
    0x20, 0x27, 0x02, 0x1B, 0x12, 0x0D, 0x1F, 0x0B, 0x21, 0x2C, 
    0x09, 0x2B, 0x06, 0x14, 0x0D, 0x29, 0x0F, 0x21, 0x1A, 0x12, 
    0x05, 0x1D, 0x10, 0x24, 0x04, 0x1E, 0x06, 0x15, 0x0D, 0x2A, 
    0x0A, 0x15, 0x1B, 0x0D, 0x13, 0x03, 0x30, 0x06, 0x1D, 0x04, 
    0x0C, 0x16, 0x1E, 0x21, 0x28, 0x01, 0x2C, 0x22, 0x32, 0x03, 0x26, 

    0x2B, 0x22, 0x31, 0x0F, 0x2A, 0x01, 0x2C, 0x1D, 0x04, 0x22,         // 34
    0x1A, 0x2C, 0x1D, 0x15, 0x0E, 0x2D, 0x25, 0x03, 0x2A, 0x23, 
    0x30, 0x21, 0x0D, 0x18, 0x04, 0x12, 0x1E, 0x0D, 0x14, 0x1D, 
    0x0B, 0x29, 0x19, 0x08, 0x23, 0x06, 0x20, 0x2C, 0x0B, 0x1C, 
    0x05, 0x2C, 0x11, 0x21, 0x2D, 0x24, 0x00, 0x29, 0x16, 0x03, 
    0x1D, 0x0D, 0x26, 0x1E, 0x2C, 0x23, 0x04, 0x30, 0x07, 0x29, 
    0x21, 0x32, 0x0A, 0x2A, 0x1A, 0x0F, 0x2E, 0x29, 0x03, 0x2F, 
    0x21, 0x00, 0x28, 0x2E, 0x23, 0x0B, 0x20, 0x16, 0x2E, 0x26, 
    0x22, 0x2D, 0x06, 0x12, 0x09, 0x1C, 0x0F, 0x06, 0x18, 0x0B, 0x1C, 

    0x02, 0x18, 0x07, 0x25, 0x19, 0x20, 0x0A, 0x11, 0x18, 0x2D,         // 35
    0x00, 0x0F, 0x08, 0x30, 0x02, 0x1C, 0x16, 0x32, 0x13, 0x0A, 
    0x01, 0x1D, 0x2E, 0x09, 0x1F, 0x2B, 0x07, 0x2F, 0x28, 0x02, 
    0x2D, 0x04, 0x13, 0x31, 0x28, 0x14, 0x0A, 0x25, 0x01, 0x31, 
    0x0E, 0x18, 0x08, 0x1D, 0x0A, 0x2A, 0x1C, 0x11, 0x31, 0x1F, 
    0x13, 0x30, 0x15, 0x04, 0x0B, 0x13, 0x1C, 0x16, 0x1F, 0x0C, 
    0x15, 0x03, 0x1F, 0x13, 0x2F, 0x09, 0x22, 0x11, 0x1C, 0x17, 
    0x0C, 0x1D, 0x0F, 0x05, 0x19, 0x2B, 0x1C, 0x0E, 0x09, 0x13, 
    0x00, 0x0F, 0x27, 0x2E, 0x19, 0x2A, 0x23, 0x13, 0x2B, 0x24, 0x14, 

    0x10, 0x2A, 0x1D, 0x0C, 0x04, 0x14, 0x30, 0x26, 0x08, 0x28,         // 36
    0x14, 0x21, 0x19, 0x23, 0x11, 0x27, 0x05, 0x0E, 0x1B, 0x2D, 
    0x18, 0x10, 0x29, 0x14, 0x26, 0x0F, 0x17, 0x23, 0x0A, 0x1B, 
    0x0F, 0x24, 0x1E, 0x0D, 0x02, 0x1C, 0x2F, 0x11, 0x1F, 0x15, 
    0x29, 0x22, 0x2E, 0x03, 0x16, 0x0F, 0x06, 0x19, 0x08, 0x0C, 
    0x28, 0x01, 0x21, 0x1B, 0x2F, 0x27, 0x0A, 0x2D, 0x00, 0x2A, 
    0x19, 0x2C, 0x0E, 0x27, 0x02, 0x17, 0x25, 0x04, 0x27, 0x07, 
    0x23, 0x2D, 0x16, 0x24, 0x09, 0x10, 0x02, 0x25, 0x2B, 0x1B, 
    0x30, 0x18, 0x1D, 0x0B, 0x14, 0x04, 0x30, 0x0D, 0x1F, 0x08, 0x2F, 

    0x0A, 0x22, 0x12, 0x29, 0x2E, 0x23, 0x05, 0x15, 0x1E, 0x0D,         // 37
    0x2F, 0x0B, 0x29, 0x07, 0x2C, 0x0A, 0x20, 0x28, 0x06, 0x21, 
    0x08, 0x23, 0x04, 0x1B, 0x06, 0x31, 0x00, 0x21, 0x13, 0x26, 
    0x16, 0x2B, 0x07, 0x21, 0x17, 0x27, 0x05, 0x18, 0x0D, 0x25, 
    0x05, 0x0B, 0x13, 0x23, 0x30, 0x1F, 0x2C, 0x27, 0x23, 0x2E, 
    0x18, 0x0E, 0x25, 0x08, 0x17, 0x02, 0x22, 0x12, 0x25, 0x0F, 
    0x08, 0x24, 0x1B, 0x07, 0x1E, 0x2C, 0x0B, 0x1A, 0x2E, 0x0F, 
    0x2A, 0x12, 0x04, 0x31, 0x1E, 0x28, 0x2F, 0x18, 0x04, 0x1F, 
    0x08, 0x0C, 0x21, 0x02, 0x26, 0x21, 0x0A, 0x17, 0x00, 0x1C, 0x26, 

    0x18, 0x31, 0x02, 0x16, 0x08, 0x0E, 0x1A, 0x29, 0x02, 0x25,         // 38
    0x1C, 0x03, 0x12, 0x1E, 0x14, 0x19, 0x10, 0x2F, 0x15, 0x26, 
    0x2B, 0x16, 0x30, 0x0C, 0x24, 0x1D, 0x11, 0x2B, 0x07, 0x2E, 
    0x04, 0x0B, 0x1C, 0x11, 0x2F, 0x0B, 0x22, 0x2C, 0x02, 0x30, 
    0x1F, 0x1C, 0x2B, 0x0D, 0x18, 0x04, 0x13, 0x0D, 0x02, 0x1D, 
    0x06, 0x2C, 0x13, 0x29, 0x10, 0x1E, 0x2B, 0x05, 0x18, 0x1F, 
    0x2E, 0x04, 0x12, 0x31, 0x14, 0x0D, 0x28, 0x13, 0x09, 0x20, 
    0x02, 0x1C, 0x28, 0x0C, 0x17, 0x13, 0x08, 0x21, 0x0F, 0x15, 
    0x23, 0x2C, 0x12, 0x31, 0x0E, 0x2C, 0x1B, 0x27, 0x2E, 0x13, 0x04, 

    0x1E, 0x0F, 0x25, 0x1B, 0x27, 0x1F, 0x2C, 0x0A, 0x2E, 0x10,         // 39
    0x16, 0x22, 0x2C, 0x05, 0x31, 0x24, 0x00, 0x1E, 0x04, 0x11, 
    0x0D, 0x01, 0x1F, 0x12, 0x2D, 0x0B, 0x18, 0x25, 0x0E, 0x1F, 
    0x19, 0x32, 0x28, 0x03, 0x23, 0x13, 0x08, 0x28, 0x1A, 0x12, 
    0x07, 0x17, 0x01, 0x27, 0x09, 0x25, 0x1B, 0x30, 0x16, 0x10, 
    0x21, 0x1B, 0x03, 0x20, 0x30, 0x07, 0x0D, 0x27, 0x31, 0x0A, 
    0x15, 0x28, 0x20, 0x09, 0x26, 0x20, 0x00, 0x32, 0x1D, 0x16, 
    0x26, 0x0B, 0x19, 0x21, 0x01, 0x26, 0x1B, 0x0C, 0x27, 0x32, 
    0x01, 0x26, 0x07, 0x16, 0x1E, 0x03, 0x15, 0x06, 0x23, 0x0E, 0x2C, 

    0x15, 0x07, 0x0B, 0x2B, 0x11, 0x01, 0x18, 0x12, 0x20, 0x08,         // 40
    0x30, 0x0D, 0x26, 0x17, 0x0E, 0x28, 0x0B, 0x2A, 0x18, 0x31, 
    0x1C, 0x25, 0x2B, 0x19, 0x03, 0x29, 0x06, 0x30, 0x15, 0x01, 
    0x23, 0x0F, 0x17, 0x0C, 0x2C, 0x19, 0x1E, 0x0F, 0x20, 0x0A, 
    0x2A, 0x22, 0x32, 0x13, 0x1F, 0x2D, 0x0A, 0x06, 0x24, 0x2A, 
    0x0A, 0x32, 0x0F, 0x0A, 0x1C, 0x15, 0x23, 0x19, 0x11, 0x02, 
    0x1C, 0x0C, 0x17, 0x2C, 0x05, 0x19, 0x11, 0x23, 0x05, 0x2D, 
    0x10, 0x2B, 0x06, 0x2C, 0x11, 0x2F, 0x04, 0x2B, 0x1E, 0x0A, 
    0x13, 0x1F, 0x1A, 0x29, 0x09, 0x23, 0x10, 0x2A, 0x1B, 0x0A, 0x20, 

    0x28, 0x2F, 0x22, 0x17, 0x08, 0x31, 0x25, 0x04, 0x1C, 0x27,         // 41
    0x01, 0x1B, 0x08, 0x1F, 0x03, 0x1A, 0x13, 0x22, 0x08, 0x20, 
    0x0B, 0x13, 0x07, 0x0F, 0x21, 0x14, 0x23, 0x0D, 0x1B, 0x2A, 
    0x09, 0x25, 0x04, 0x1F, 0x27, 0x00, 0x31, 0x06, 0x17, 0x2E, 
    0x14, 0x0E, 0x07, 0x1A, 0x03, 0x0F, 0x21, 0x2B, 0x19, 0x00, 
    0x14, 0x25, 0x17, 0x2C, 0x25, 0x01, 0x2D, 0x06, 0x21, 0x2A, 
    0x24, 0x30, 0x03, 0x0F, 0x1C, 0x2E, 0x08, 0x29, 0x0C, 0x1A, 
    0x01, 0x22, 0x15, 0x1D, 0x07, 0x22, 0x19, 0x10, 0x06, 0x18, 
    0x2B, 0x0E, 0x05, 0x2E, 0x13, 0x26, 0x31, 0x09, 0x16, 0x30, 0x05, 

    0x19, 0x01, 0x12, 0x2D, 0x1E, 0x0E, 0x15, 0x2E, 0x0B, 0x16,         // 42
    0x2B, 0x13, 0x2E, 0x11, 0x23, 0x30, 0x05, 0x2D, 0x10, 0x02, 
    0x2E, 0x17, 0x28, 0x32, 0x1C, 0x08, 0x2E, 0x03, 0x20, 0x10, 
    0x2D, 0x13, 0x2F, 0x1A, 0x12, 0x0A, 0x15, 0x29, 0x24, 0x08, 
    0x26, 0x1C, 0x2C, 0x23, 0x2F, 0x15, 0x1B, 0x0C, 0x12, 0x20, 
    0x2D, 0x04, 0x1F, 0x06, 0x1A, 0x12, 0x26, 0x0B, 0x2F, 0x0E, 
    0x06, 0x18, 0x1F, 0x29, 0x25, 0x0B, 0x16, 0x1E, 0x13, 0x2F, 
    0x27, 0x0B, 0x30, 0x0F, 0x28, 0x0A, 0x14, 0x2D, 0x28, 0x22, 
    0x03, 0x2F, 0x15, 0x21, 0x00, 0x0D, 0x18, 0x20, 0x02, 0x25, 0x11, 

    0x1E, 0x26, 0x09, 0x1B, 0x03, 0x21, 0x29, 0x06, 0x22, 0x0F,         // 43
    0x1E, 0x0A, 0x25, 0x07, 0x2A, 0x0E, 0x1D, 0x26, 0x17, 0x2A, 
    0x23, 0x05, 0x1F, 0x01, 0x0D, 0x2A, 0x19, 0x13, 0x2C, 0x06, 
    0x17, 0x1E, 0x08, 0x0E, 0x2B, 0x25, 0x1D, 0x04, 0x11, 0x21, 
    0x03, 0x0C, 0x13, 0x05, 0x0B, 0x26, 0x02, 0x31, 0x28, 0x09, 
    0x1B, 0x0E, 0x28, 0x10, 0x31, 0x0A, 0x1E, 0x14, 0x19, 0x1F, 
    0x13, 0x2C, 0x08, 0x11, 0x02, 0x21, 0x30, 0x04, 0x24, 0x07, 
    0x17, 0x1C, 0x04, 0x21, 0x17, 0x31, 0x24, 0x00, 0x0D, 0x1B, 
    0x12, 0x25, 0x0B, 0x1C, 0x2C, 0x1E, 0x06, 0x2B, 0x14, 0x2C, 0x0C, 

    0x32, 0x16, 0x2A, 0x10, 0x28, 0x0A, 0x11, 0x1A, 0x2D, 0x27,         // 44
    0x03, 0x32, 0x15, 0x1D, 0x18, 0x01, 0x15, 0x08, 0x0D, 0x1C, 
    0x13, 0x0E, 0x1A, 0x26, 0x13, 0x24, 0x09, 0x1E, 0x0F, 0x26, 
    0x21, 0x02, 0x29, 0x22, 0x03, 0x17, 0x2F, 0x0D, 0x2C, 0x16, 
    0x31, 0x28, 0x1F, 0x17, 0x29, 0x22, 0x11, 0x1D, 0x06, 0x24, 
    0x14, 0x2F, 0x08, 0x16, 0x22, 0x29, 0x05, 0x2C, 0x07, 0x27, 
    0x01, 0x25, 0x16, 0x30, 0x1B, 0x14, 0x0D, 0x19, 0x2B, 0x0F, 
    0x20, 0x12, 0x2B, 0x0D, 0x02, 0x1B, 0x08, 0x1F, 0x16, 0x30, 
    0x0A, 0x29, 0x18, 0x05, 0x13, 0x27, 0x0F, 0x1C, 0x0B, 0x20, 0x05, 

    0x23, 0x0E, 0x06, 0x22, 0x14, 0x2D, 0x1F, 0x01, 0x13, 0x0A,         // 45
    0x1A, 0x23, 0x0E, 0x04, 0x2F, 0x23, 0x27, 0x31, 0x20, 0x07, 
    0x27, 0x30, 0x09, 0x2C, 0x18, 0x04, 0x30, 0x28, 0x01, 0x31, 
    0x0C, 0x1A, 0x14, 0x30, 0x0C, 0x22, 0x06, 0x1A, 0x1F, 0x07, 
    0x0F, 0x19, 0x00, 0x30, 0x0D, 0x06, 0x2E, 0x16, 0x10, 0x2A, 
    0x03, 0x19, 0x25, 0x2C, 0x01, 0x0E, 0x17, 0x21, 0x0F, 0x32, 
    0x0C, 0x1C, 0x0D, 0x23, 0x06, 0x2C, 0x26, 0x09, 0x1D, 0x02, 
    0x31, 0x07, 0x27, 0x1E, 0x2D, 0x11, 0x2A, 0x10, 0x2B, 0x07, 
    0x1F, 0x02, 0x23, 0x32, 0x08, 0x23, 0x2D, 0x01, 0x27, 0x1A, 0x13, 

    0x03, 0x2C, 0x1A, 0x30, 0x03, 0x17, 0x08, 0x31, 0x1D, 0x2B,         // 46
    0x11, 0x06, 0x2D, 0x20, 0x17, 0x0B, 0x12, 0x04, 0x1A, 0x2D, 
    0x00, 0x21, 0x15, 0x06, 0x22, 0x10, 0x1C, 0x0A, 0x17, 0x1D, 
    0x11, 0x2D, 0x05, 0x1E, 0x11, 0x2B, 0x13, 0x28, 0x02, 0x25, 
    0x2D, 0x09, 0x23, 0x11, 0x1D, 0x18, 0x28, 0x01, 0x1F, 0x2E, 
    0x0D, 0x1E, 0x06, 0x11, 0x1C, 0x1F, 0x30, 0x02, 0x1A, 0x1F, 
    0x15, 0x2E, 0x04, 0x29, 0x11, 0x1E, 0x00, 0x12, 0x2E, 0x15, 
    0x24, 0x0E, 0x19, 0x14, 0x06, 0x24, 0x18, 0x05, 0x26, 0x1A, 
    0x13, 0x2C, 0x0E, 0x1E, 0x16, 0x0C, 0x18, 0x12, 0x30, 0x08, 0x2A, 

    0x1D, 0x21, 0x0A, 0x13, 0x1E, 0x2A, 0x25, 0x0D, 0x21, 0x02,         // 47
    0x25, 0x17, 0x29, 0x10, 0x08, 0x2C, 0x1C, 0x2A, 0x0A, 0x10, 
    0x18, 0x0D, 0x1D, 0x2F, 0x26, 0x0C, 0x2B, 0x13, 0x25, 0x06, 
    0x27, 0x09, 0x24, 0x19, 0x01, 0x25, 0x09, 0x30, 0x10, 0x1C, 
    0x14, 0x21, 0x2A, 0x05, 0x2D, 0x08, 0x21, 0x0C, 0x1A, 0x07, 
    0x23, 0x13, 0x32, 0x24, 0x0A, 0x14, 0x25, 0x12, 0x2A, 0x09, 
    0x03, 0x26, 0x21, 0x16, 0x0B, 0x32, 0x17, 0x29, 0x1F, 0x0B, 
    0x1B, 0x2D, 0x01, 0x21, 0x2F, 0x0B, 0x1E, 0x2E, 0x0E, 0x03, 
    0x24, 0x17, 0x07, 0x2A, 0x03, 0x2F, 0x1F, 0x05, 0x23, 0x16, 0x0B, 

    0x10, 0x18, 0x00, 0x28, 0x0C, 0x05, 0x12, 0x18, 0x09, 0x15,         // 48
    0x30, 0x0B, 0x1D, 0x04, 0x27, 0x1F, 0x02, 0x15, 0x24, 0x1E, 
    0x2B, 0x25, 0x05, 0x13, 0x01, 0x17, 0x20, 0x04, 0x2E, 0x21, 
    0x12, 0x17, 0x2A, 0x0A, 0x2E, 0x1B, 0x16, 0x1E, 0x0A, 0x2B, 
    0x05, 0x0C, 0x1A, 0x25, 0x15, 0x1F, 0x13, 0x2C, 0x25, 0x14, 
    0x29, 0x02, 0x19, 0x2A, 0x04, 0x2D, 0x0C, 0x06, 0x23, 0x2E, 
    0x12, 0x19, 0x09, 0x2C, 0x1A, 0x08, 0x23, 0x0F, 0x03, 0x28, 
    0x08, 0x10, 0x25, 0x09, 0x28, 0x10, 0x01, 0x14, 0x20, 0x2B, 
    0x0B, 0x30, 0x1B, 0x11, 0x25, 0x1A, 0x0A, 0x2C, 0x0E, 0x1F, 0x2E, 

    0x06, 0x25, 0x31, 0x20, 0x1B, 0x2C, 0x22, 0x2F, 0x27, 0x1B,         // 49
    0x05, 0x23, 0x14, 0x2F, 0x19, 0x0D, 0x30, 0x0F, 0x29, 0x03, 
    0x13, 0x0A, 0x2D, 0x1A, 0x28, 0x31, 0x08, 0x19, 0x0E, 0x29, 
    0x02, 0x32, 0x0E, 0x21, 0x11, 0x07, 0x27, 0x03, 0x24, 0x19, 
    0x27, 0x31, 0x10, 0x02, 0x0D, 0x30, 0x06, 0x0F, 0x03, 0x30, 
    0x0B, 0x1D, 0x09, 0x0F, 0x1F, 0x18, 0x28, 0x1C, 0x16, 0x0D, 
    0x1E, 0x29, 0x10, 0x01, 0x27, 0x1E, 0x05, 0x2E, 0x1A, 0x13, 
    0x2B, 0x1E, 0x31, 0x13, 0x17, 0x1D, 0x25, 0x32, 0x06, 0x1C, 
    0x12, 0x26, 0x00, 0x21, 0x08, 0x2B, 0x13, 0x27, 0x18, 0x02, 0x27, 

    0x1B, 0x0D, 0x16, 0x0F, 0x08, 0x15, 0x01, 0x10, 0x07, 0x2B,         // 50
    0x12, 0x2D, 0x00, 0x24, 0x12, 0x05, 0x23, 0x18, 0x08, 0x1B, 
    0x32, 0x17, 0x20, 0x0F, 0x09, 0x23, 0x10, 0x26, 0x1E, 0x09, 
    0x1A, 0x1F, 0x05, 0x15, 0x1E, 0x2C, 0x0D, 0x31, 0x13, 0x0E, 
    0x02, 0x17, 0x20, 0x2C, 0x26, 0x19, 0x1E, 0x2A, 0x17, 0x20, 
    0x10, 0x2E, 0x27, 0x15, 0x30, 0x03, 0x11, 0x30, 0x00, 0x28, 
    0x05, 0x31, 0x21, 0x14, 0x2F, 0x0D, 0x16, 0x28, 0x0C, 0x23, 
    0x06, 0x19, 0x03, 0x20, 0x07, 0x2A, 0x0B, 0x17, 0x10, 0x29, 
    0x09, 0x1E, 0x14, 0x2E, 0x17, 0x0E, 0x01, 0x1C, 0x08, 0x30, 0x14, 

    0x2D, 0x29, 0x04, 0x27, 0x2F, 0x23, 0x29, 0x19, 0x1E, 0x0D,         // 51
    0x20, 0x08, 0x1A, 0x0D, 0x29, 0x1D, 0x2D, 0x0B, 0x2B, 0x22, 
    0x0E, 0x06, 0x2A, 0x02, 0x1C, 0x14, 0x2C, 0x00, 0x2F, 0x13, 
    0x2B, 0x0B, 0x27, 0x2F, 0x02, 0x17, 0x22, 0x05, 0x1D, 0x2D, 
    0x23, 0x0A, 0x1D, 0x07, 0x12, 0x04, 0x0B, 0x24, 0x08, 0x1C, 
    0x01, 0x22, 0x06, 0x23, 0x0A, 0x1B, 0x25, 0x09, 0x22, 0x14, 
    0x1B, 0x08, 0x0C, 0x1D, 0x05, 0x24, 0x11, 0x1C, 0x01, 0x30, 
    0x16, 0x0B, 0x29, 0x0F, 0x2E, 0x1A, 0x04, 0x2B, 0x24, 0x02, 
    0x18, 0x31, 0x06, 0x0F, 0x28, 0x1F, 0x32, 0x24, 0x11, 0x20, 0x0B, 

    0x22, 0x09, 0x1E, 0x19, 0x03, 0x0F, 0x0A, 0x2D, 0x05, 0x26,         // 52
    0x15, 0x2A, 0x1F, 0x30, 0x07, 0x16, 0x01, 0x1E, 0x11, 0x03, 
    0x28, 0x1D, 0x12, 0x23, 0x30, 0x0C, 0x21, 0x17, 0x0F, 0x06, 
    0x22, 0x16, 0x0F, 0x1A, 0x0B, 0x2A, 0x0F, 0x26, 0x16, 0x06, 
    0x29, 0x12, 0x30, 0x16, 0x2A, 0x22, 0x32, 0x13, 0x2D, 0x15, 
    0x2C, 0x19, 0x0F, 0x2C, 0x13, 0x2B, 0x0E, 0x18, 0x2B, 0x0D, 
    0x2D, 0x24, 0x16, 0x29, 0x19, 0x2B, 0x06, 0x2D, 0x26, 0x0E, 
    0x1F, 0x2C, 0x24, 0x15, 0x01, 0x23, 0x13, 0x1F, 0x0D, 0x2D, 
    0x22, 0x0C, 0x2A, 0x1C, 0x04, 0x0B, 0x1A, 0x05, 0x2B, 0x18, 0x03, 

    0x17, 0x10, 0x2E, 0x12, 0x25, 0x1D, 0x17, 0x21, 0x13, 0x31,         // 53
    0x03, 0x0F, 0x17, 0x0B, 0x21, 0x11, 0x25, 0x29, 0x15, 0x30, 
    0x17, 0x07, 0x2E, 0x16, 0x05, 0x29, 0x07, 0x25, 0x1C, 0x27, 
    0x2E, 0x01, 0x1E, 0x29, 0x23, 0x08, 0x1B, 0x2E, 0x0A, 0x1F, 
    0x0E, 0x1A, 0x00, 0x23, 0x0A, 0x1A, 0x0F, 0x02, 0x26, 0x07, 
    0x11, 0x25, 0x04, 0x1D, 0x08, 0x1F, 0x02, 0x27, 0x06, 0x1F, 
    0x03, 0x10, 0x2F, 0x02, 0x12, 0x0B, 0x20, 0x15, 0x09, 0x1C, 
    0x13, 0x02, 0x0D, 0x1C, 0x27, 0x0E, 0x30, 0x09, 0x1C, 0x12, 
    0x05, 0x16, 0x23, 0x12, 0x26, 0x2C, 0x14, 0x0C, 0x25, 0x0F, 0x28, 

    0x1D, 0x01, 0x28, 0x06, 0x32, 0x08, 0x29, 0x04, 0x1E, 0x0A,         // 54
    0x1B, 0x2D, 0x25, 0x02, 0x1C, 0x2F, 0x06, 0x0E, 0x1B, 0x0C, 
    0x25, 0x20, 0x0B, 0x27, 0x0F, 0x1B, 0x12, 0x32, 0x03, 0x0C, 
    0x17, 0x09, 0x31, 0x04, 0x14, 0x30, 0x01, 0x11, 0x19, 0x2B, 
    0x04, 0x2E, 0x27, 0x0F, 0x2C, 0x04, 0x28, 0x1C, 0x0C, 0x1F, 
    0x29, 0x0B, 0x32, 0x14, 0x27, 0x2F, 0x13, 0x1B, 0x31, 0x17, 
    0x28, 0x1A, 0x09, 0x1F, 0x26, 0x31, 0x1B, 0x04, 0x24, 0x2F, 
    0x07, 0x22, 0x32, 0x08, 0x2B, 0x06, 0x16, 0x29, 0x00, 0x2F, 
    0x27, 0x09, 0x2E, 0x01, 0x18, 0x07, 0x1F, 0x2E, 0x1B, 0x06, 0x31, 

    0x14, 0x24, 0x0B, 0x18, 0x1F, 0x15, 0x0C, 0x2E, 0x10, 0x2A,         // 55
    0x21, 0x06, 0x14, 0x29, 0x10, 0x18, 0x2B, 0x23, 0x08, 0x2C, 
    0x00, 0x11, 0x1B, 0x03, 0x1F, 0x2E, 0x0A, 0x21, 0x14, 0x2C, 
    0x1C, 0x21, 0x12, 0x19, 0x0D, 0x1D, 0x20, 0x28, 0x06, 0x24, 
    0x15, 0x20, 0x13, 0x06, 0x20, 0x15, 0x2F, 0x23, 0x17, 0x30, 
    0x03, 0x18, 0x20, 0x00, 0x1A, 0x07, 0x23, 0x0D, 0x08, 0x12, 
    0x0B, 0x21, 0x2B, 0x0E, 0x05, 0x16, 0x0D, 0x2C, 0x10, 0x17, 
    0x2A, 0x1A, 0x15, 0x11, 0x1F, 0x1A, 0x25, 0x0F, 0x20, 0x14, 
    0x23, 0x1B, 0x0E, 0x20, 0x31, 0x10, 0x21, 0x00, 0x15, 0x23, 0x08, 

    0x0C, 0x2E, 0x1B, 0x10, 0x2A, 0x02, 0x1A, 0x23, 0x16, 0x00,         // 56
    0x1A, 0x0D, 0x32, 0x08, 0x20, 0x0B, 0x02, 0x15, 0x1F, 0x26, 
    0x16, 0x31, 0x29, 0x14, 0x2B, 0x17, 0x01, 0x1D, 0x0F, 0x28, 
    0x05, 0x0E, 0x2C, 0x22, 0x27, 0x06, 0x16, 0x0B, 0x32, 0x1B, 
    0x0D, 0x09, 0x1C, 0x31, 0x19, 0x08, 0x10, 0x01, 0x12, 0x08, 
    0x1B, 0x0F, 0x2A, 0x12, 0x26, 0x0C, 0x2C, 0x1E, 0x29, 0x23, 
    0x2D, 0x01, 0x16, 0x1D, 0x29, 0x22, 0x01, 0x28, 0x1E, 0x03, 
    0x0E, 0x24, 0x04, 0x2D, 0x0D, 0x03, 0x2E, 0x07, 0x19, 0x0A, 
    0x10, 0x2C, 0x05, 0x14, 0x0A, 0x1C, 0x2A, 0x0A, 0x2F, 0x11, 0x2A, 

    0x1F, 0x03, 0x28, 0x06, 0x22, 0x2D, 0x0F, 0x26, 0x0B, 0x2F,         // 57
    0x13, 0x26, 0x1D, 0x17, 0x2C, 0x27, 0x1C, 0x31, 0x10, 0x04, 
    0x1A, 0x0C, 0x07, 0x24, 0x05, 0x0E, 0x28, 0x2D, 0x07, 0x22, 
    0x15, 0x26, 0x0B, 0x00, 0x2B, 0x11, 0x2D, 0x21, 0x12, 0x01, 
    0x2E, 0x26, 0x03, 0x24, 0x0B, 0x29, 0x1D, 0x26, 0x2E, 0x22, 
    0x2B, 0x24, 0x0A, 0x2E, 0x05, 0x18, 0x12, 0x02, 0x19, 0x05, 
    0x1C, 0x12, 0x32, 0x09, 0x10, 0x2F, 0x13, 0x19, 0x08, 0x21, 
    0x2E, 0x09, 0x28, 0x22, 0x17, 0x28, 0x12, 0x1F, 0x30, 0x29, 
    0x03, 0x17, 0x27, 0x23, 0x2B, 0x04, 0x13, 0x19, 0x1E, 0x03, 0x1A, 

    0x26, 0x16, 0x0B, 0x30, 0x14, 0x08, 0x1E, 0x06, 0x29, 0x20,         // 58
    0x09, 0x2B, 0x02, 0x11, 0x06, 0x0C, 0x13, 0x06, 0x29, 0x0B, 
    0x2E, 0x21, 0x1D, 0x10, 0x30, 0x23, 0x12, 0x18, 0x0B, 0x2F, 
    0x02, 0x1A, 0x31, 0x14, 0x1D, 0x08, 0x25, 0x04, 0x18, 0x29, 
    0x21, 0x0F, 0x2B, 0x16, 0x11, 0x2D, 0x05, 0x1A, 0x09, 0x0D, 
    0x14, 0x02, 0x19, 0x1E, 0x22, 0x31, 0x27, 0x0E, 0x30, 0x14, 
    0x2A, 0x0C, 0x24, 0x19, 0x06, 0x1E, 0x0B, 0x24, 0x31, 0x12, 
    0x1B, 0x16, 0x10, 0x03, 0x31, 0x09, 0x1D, 0x01, 0x0F, 0x24, 
    0x1D, 0x32, 0x08, 0x1A, 0x0E, 0x30, 0x25, 0x0D, 0x23, 0x2C, 0x0E, 

    0x2F, 0x11, 0x1C, 0x20, 0x0D, 0x19, 0x31, 0x15, 0x11, 0x04,         // 59
    0x1D, 0x0E, 0x22, 0x2F, 0x1B, 0x23, 0x2E, 0x1F, 0x18, 0x25, 
    0x12, 0x02, 0x2D, 0x19, 0x0A, 0x1B, 0x03, 0x26, 0x1E, 0x13, 
    0x29, 0x1F, 0x06, 0x21, 0x0C, 0x19, 0x30, 0x0E, 0x24, 0x07, 
    0x14, 0x1A, 0x09, 0x1E, 0x01, 0x20, 0x0E, 0x27, 0x17, 0x1F, 
    0x28, 0x30, 0x07, 0x10, 0x15, 0x03, 0x1B, 0x20, 0x09, 0x24, 
    0x07, 0x1F, 0x03, 0x29, 0x2D, 0x15, 0x27, 0x05, 0x0E, 0x1F, 
    0x01, 0x2B, 0x1F, 0x1B, 0x0C, 0x24, 0x15, 0x2C, 0x18, 0x06, 
    0x12, 0x0C, 0x1F, 0x01, 0x15, 0x1E, 0x03, 0x29, 0x08, 0x14, 0x06, 

    0x24, 0x02, 0x2C, 0x04, 0x25, 0x2A, 0x01, 0x24, 0x2B, 0x18,         // 60
    0x30, 0x16, 0x25, 0x05, 0x14, 0x29, 0x00, 0x10, 0x08, 0x1D, 
    0x2A, 0x0E, 0x15, 0x04, 0x29, 0x1F, 0x09, 0x31, 0x0D, 0x19, 
    0x09, 0x10, 0x16, 0x2C, 0x27, 0x04, 0x15, 0x1C, 0x2E, 0x0B, 
    0x2C, 0x04, 0x30, 0x28, 0x18, 0x2F, 0x14, 0x06, 0x2E, 0x03, 
    0x12, 0x1A, 0x23, 0x2D, 0x09, 0x2B, 0x0C, 0x13, 0x2D, 0x18, 
    0x10, 0x2E, 0x16, 0x0E, 0x21, 0x00, 0x1B, 0x2A, 0x18, 0x2D, 
    0x0A, 0x27, 0x07, 0x2E, 0x13, 0x2A, 0x06, 0x23, 0x0A, 0x2B, 
    0x27, 0x16, 0x23, 0x2D, 0x28, 0x0B, 0x18, 0x11, 0x32, 0x20, 0x1B, 

    0x0D, 0x28, 0x13, 0x1B, 0x0A, 0x10, 0x1F, 0x0D, 0x07, 0x22,         // 61
    0x0A, 0x01, 0x2A, 0x0B, 0x1F, 0x0E, 0x1A, 0x26, 0x30, 0x16, 
    0x05, 0x1F, 0x27, 0x22, 0x0D, 0x2E, 0x14, 0x22, 0x01, 0x2C, 
    0x23, 0x2F, 0x02, 0x1B, 0x11, 0x20, 0x2A, 0x01, 0x10, 0x17, 
    0x1E, 0x25, 0x15, 0x0C, 0x24, 0x09, 0x1C, 0x2A, 0x23, 0x0B, 
    0x26, 0x06, 0x0C, 0x28, 0x1D, 0x18, 0x24, 0x05, 0x28, 0x01, 
    0x1C, 0x25, 0x08, 0x1D, 0x12, 0x0A, 0x30, 0x11, 0x03, 0x24, 
    0x13, 0x22, 0x0E, 0x1A, 0x00, 0x20, 0x10, 0x2E, 0x1E, 0x1A, 
    0x02, 0x2F, 0x09, 0x10, 0x05, 0x22, 0x2C, 0x1D, 0x01, 0x16, 0x09, 

    0x2F, 0x17, 0x07, 0x31, 0x26, 0x15, 0x2C, 0x1A, 0x2E, 0x14,         // 62
    0x28, 0x1C, 0x10, 0x18, 0x31, 0x09, 0x2C, 0x13, 0x03, 0x0D, 
    0x2E, 0x19, 0x09, 0x2C, 0x11, 0x03, 0x19, 0x28, 0x10, 0x1B, 
    0x07, 0x26, 0x1E, 0x0B, 0x2E, 0x07, 0x0D, 0x26, 0x22, 0x28, 
    0x02, 0x0D, 0x1C, 0x05, 0x11, 0x29, 0x02, 0x0E, 0x13, 0x1B, 
    0x31, 0x17, 0x1F, 0x13, 0x00, 0x0E, 0x32, 0x1E, 0x11, 0x21, 
    0x0B, 0x30, 0x04, 0x28, 0x2C, 0x18, 0x22, 0x08, 0x1F, 0x0C, 
    0x31, 0x04, 0x17, 0x2C, 0x28, 0x0B, 0x18, 0x04, 0x12, 0x0D, 
    0x20, 0x13, 0x1B, 0x29, 0x14, 0x26, 0x07, 0x10, 0x25, 0x2B, 0x22, 

    0x0F, 0x1E, 0x21, 0x11, 0x02, 0x1C, 0x05, 0x0B, 0x25, 0x04,         // 63
    0x0D, 0x20, 0x2C, 0x08, 0x27, 0x22, 0x06, 0x1C, 0x20, 0x29, 
    0x24, 0x10, 0x00, 0x16, 0x1C, 0x20, 0x0A, 0x2C, 0x05, 0x1F, 
    0x0D, 0x14, 0x06, 0x29, 0x15, 0x1A, 0x32, 0x13, 0x05, 0x30, 
    0x11, 0x29, 0x2D, 0x20, 0x32, 0x16, 0x21, 0x2F, 0x1F, 0x01, 
    0x0D, 0x29, 0x04, 0x2F, 0x21, 0x29, 0x07, 0x16, 0x09, 0x2A, 
    0x17, 0x10, 0x1F, 0x14, 0x0C, 0x04, 0x26, 0x2E, 0x15, 0x1A, 
    0x28, 0x1D, 0x0F, 0x21, 0x05, 0x1D, 0x32, 0x22, 0x27, 0x30, 
    0x06, 0x2B, 0x04, 0x20, 0x31, 0x0B, 0x1A, 0x2E, 0x0C, 0x13, 0x04, 

    0x1B, 0x00, 0x2E, 0x0B, 0x2A, 0x21, 0x30, 0x13, 0x1E, 0x18,         // 64
    0x32, 0x06, 0x16, 0x1E, 0x03, 0x13, 0x18, 0x2E, 0x0B, 0x15, 
    0x07, 0x1F, 0x2F, 0x27, 0x07, 0x31, 0x25, 0x12, 0x16, 0x2F, 
    0x2A, 0x1A, 0x30, 0x0F, 0x22, 0x02, 0x1D, 0x21, 0x0A, 0x17, 
    0x20, 0x07, 0x14, 0x01, 0x1A, 0x0C, 0x05, 0x18, 0x0A, 0x2D, 
    0x25, 0x11, 0x1C, 0x08, 0x18, 0x10, 0x1B, 0x26, 0x2F, 0x03, 
    0x1D, 0x2C, 0x0A, 0x21, 0x32, 0x1E, 0x0F, 0x02, 0x25, 0x0B, 
    0x01, 0x14, 0x2F, 0x0A, 0x26, 0x16, 0x0F, 0x02, 0x1A, 0x0B, 
    0x17, 0x25, 0x0E, 0x1A, 0x00, 0x1E, 0x15, 0x03, 0x1F, 0x19, 0x29, 

    0x24, 0x0E, 0x26, 0x16, 0x1A, 0x0E, 0x09, 0x28, 0x03, 0x2A,         // 65
    0x0F, 0x26, 0x12, 0x2F, 0x0E, 0x2B, 0x26, 0x10, 0x05, 0x32, 
    0x1C, 0x12, 0x0C, 0x22, 0x13, 0x0D, 0x02, 0x1F, 0x09, 0x22, 
    0x00, 0x0C, 0x24, 0x04, 0x27, 0x0C, 0x2A, 0x0F, 0x1B, 0x2B, 
    0x0D, 0x19, 0x26, 0x0A, 0x1E, 0x2A, 0x24, 0x10, 0x2A, 0x15, 
    0x04, 0x20, 0x2E, 0x0D, 0x24, 0x2D, 0x04, 0x0D, 0x20, 0x13, 
    0x0C, 0x24, 0x01, 0x1A, 0x07, 0x16, 0x2B, 0x1B, 0x13, 0x2F, 
    0x2A, 0x20, 0x07, 0x23, 0x11, 0x2D, 0x09, 0x2A, 0x13, 0x2C, 
    0x1D, 0x09, 0x2D, 0x12, 0x0D, 0x24, 0x2C, 0x27, 0x0A, 0x31, 0x06, 

    0x2C, 0x14, 0x08, 0x1F, 0x05, 0x2D, 0x17, 0x1D, 0x11, 0x22,         // 66
    0x09, 0x19, 0x02, 0x23, 0x1B, 0x0A, 0x01, 0x21, 0x1A, 0x28, 
    0x02, 0x26, 0x2B, 0x04, 0x1B, 0x29, 0x18, 0x2E, 0x1A, 0x10, 
    0x26, 0x16, 0x1D, 0x13, 0x2E, 0x19, 0x06, 0x2F, 0x02, 0x26, 
    0x04, 0x31, 0x22, 0x2D, 0x12, 0x06, 0x30, 0x1D, 0x08, 0x23, 
    0x1B, 0x09, 0x16, 0x2A, 0x02, 0x14, 0x1E, 0x29, 0x05, 0x1B, 
    0x31, 0x16, 0x2B, 0x12, 0x23, 0x0C, 0x27, 0x09, 0x20, 0x06, 
    0x17, 0x0F, 0x1B, 0x29, 0x01, 0x1A, 0x1F, 0x25, 0x07, 0x23, 
    0x02, 0x14, 0x21, 0x26, 0x30, 0x07, 0x13, 0x0F, 0x22, 0x17, 0x10, 

    0x03, 0x1A, 0x32, 0x29, 0x13, 0x23, 0x01, 0x2B, 0x07, 0x2F,         // 67
    0x1C, 0x27, 0x2C, 0x0B, 0x16, 0x31, 0x1E, 0x14, 0x2C, 0x0D, 
    0x17, 0x20, 0x08, 0x16, 0x2F, 0x0F, 0x24, 0x05, 0x29, 0x07, 
    0x32, 0x06, 0x2C, 0x09, 0x1F, 0x11, 0x24, 0x15, 0x20, 0x12, 
    0x1D, 0x13, 0x06, 0x0D, 0x27, 0x15, 0x1A, 0x03, 0x27, 0x0D, 
    0x32, 0x0F, 0x25, 0x07, 0x1A, 0x31, 0x0F, 0x17, 0x2C, 0x0A, 
    0x27, 0x06, 0x0E, 0x27, 0x2F, 0x02, 0x18, 0x2E, 0x10, 0x1C, 
    0x26, 0x03, 0x2E, 0x0D, 0x15, 0x31, 0x04, 0x0D, 0x18, 0x10, 
    0x31, 0x29, 0x04, 0x16, 0x0B, 0x20, 0x19, 0x05, 0x2B, 0x08, 0x1E, 

    0x28, 0x0A, 0x1E, 0x04, 0x0D, 0x2F, 0x10, 0x22, 0x18, 0x0C,         // 68
    0x13, 0x05, 0x11, 0x1F, 0x06, 0x29, 0x0F, 0x09, 0x25, 0x06, 
    0x11, 0x2F, 0x0E, 0x1D, 0x25, 0x01, 0x15, 0x0D, 0x1D, 0x14, 
    0x20, 0x10, 0x25, 0x18, 0x04, 0x31, 0x0C, 0x1D, 0x08, 0x2E, 
    0x0B, 0x29, 0x18, 0x1E, 0x02, 0x23, 0x0A, 0x2A, 0x12, 0x18, 
    0x00, 0x2B, 0x1D, 0x11, 0x20, 0x0B, 0x25, 0x08, 0x23, 0x10, 
    0x21, 0x18, 0x1D, 0x09, 0x1F, 0x12, 0x23, 0x05, 0x29, 0x08, 
    0x31, 0x13, 0x22, 0x05, 0x25, 0x1D, 0x13, 0x27, 0x2E, 0x1F, 
    0x0A, 0x1A, 0x0F, 0x1E, 0x2A, 0x03, 0x2E, 0x1C, 0x25, 0x13, 0x2F, 

    0x22, 0x11, 0x17, 0x25, 0x19, 0x1E, 0x0A, 0x26, 0x05, 0x29,         // 69
    0x20, 0x30, 0x19, 0x2D, 0x25, 0x02, 0x22, 0x19, 0x30, 0x1D, 
    0x2A, 0x1A, 0x03, 0x2C, 0x09, 0x1A, 0x31, 0x23, 0x2D, 0x0B, 
    0x1A, 0x02, 0x2B, 0x0E, 0x21, 0x28, 0x02, 0x2C, 0x17, 0x27, 
    0x00, 0x23, 0x2F, 0x11, 0x29, 0x31, 0x0F, 0x1E, 0x2E, 0x21, 
    0x1F, 0x14, 0x04, 0x2F, 0x27, 0x01, 0x19, 0x2E, 0x03, 0x14, 
    0x30, 0x00, 0x2C, 0x15, 0x05, 0x1C, 0x2A, 0x0D, 0x1B, 0x14, 
    0x1E, 0x0C, 0x18, 0x27, 0x11, 0x09, 0x2B, 0x06, 0x1B, 0x00, 
    0x14, 0x26, 0x2D, 0x07, 0x18, 0x11, 0x28, 0x0C, 0x01, 0x19, 0x0D, 

    0x27, 0x01, 0x30, 0x09, 0x2A, 0x03, 0x15, 0x31, 0x1B, 0x0E,         // 70
    0x15, 0x00, 0x08, 0x0F, 0x1A, 0x14, 0x2E, 0x07, 0x12, 0x00, 
    0x0B, 0x23, 0x13, 0x28, 0x11, 0x20, 0x06, 0x12, 0x02, 0x25, 
    0x2C, 0x14, 0x23, 0x09, 0x1A, 0x11, 0x16, 0x25, 0x06, 0x11, 
    0x1C, 0x15, 0x05, 0x0B, 0x1B, 0x08, 0x18, 0x02, 0x10, 0x07, 
    0x0C, 0x29, 0x09, 0x19, 0x0D, 0x2B, 0x1F, 0x16, 0x27, 0x1C, 
    0x0B, 0x25, 0x0F, 0x28, 0x31, 0x0C, 0x16, 0x2F, 0x03, 0x25, 
    0x2C, 0x01, 0x2A, 0x07, 0x2E, 0x20, 0x17, 0x23, 0x0F, 0x2A, 
    0x22, 0x04, 0x0D, 0x22, 0x32, 0x09, 0x21, 0x15, 0x31, 0x1F, 0x06, 

    0x2E, 0x1C, 0x13, 0x20, 0x0E, 0x2C, 0x21, 0x11, 0x03, 0x2D,         // 71
    0x23, 0x2A, 0x1E, 0x21, 0x0A, 0x2A, 0x0C, 0x1E, 0x24, 0x28, 
    0x16, 0x31, 0x06, 0x1E, 0x0C, 0x26, 0x17, 0x2A, 0x19, 0x09, 
    0x1C, 0x06, 0x30, 0x1D, 0x03, 0x2F, 0x0B, 0x1B, 0x23, 0x32, 
    0x0D, 0x20, 0x2D, 0x25, 0x13, 0x20, 0x2C, 0x26, 0x1C, 0x30, 
    0x17, 0x23, 0x2D, 0x1F, 0x15, 0x08, 0x11, 0x06, 0x0E, 0x2B, 
    0x07, 0x1F, 0x17, 0x08, 0x22, 0x01, 0x25, 0x10, 0x20, 0x0A, 
    0x12, 0x1C, 0x21, 0x0E, 0x1B, 0x02, 0x0D, 0x30, 0x15, 0x09, 
    0x2F, 0x18, 0x2A, 0x14, 0x01, 0x1E, 0x1A, 0x07, 0x28, 0x0F, 0x1A, 

    0x07, 0x0B, 0x29, 0x04, 0x15, 0x1C, 0x08, 0x1F, 0x27, 0x09,         // 72
    0x18, 0x0C, 0x12, 0x2F, 0x04, 0x25, 0x16, 0x05, 0x2C, 0x0E, 
    0x1F, 0x08, 0x18, 0x2D, 0x01, 0x2F, 0x08, 0x0F, 0x22, 0x31, 
    0x10, 0x28, 0x0D, 0x14, 0x26, 0x22, 0x2A, 0x09, 0x13, 0x04, 
    0x2A, 0x08, 0x18, 0x02, 0x29, 0x06, 0x0D, 0x15, 0x04, 0x27, 
    0x0E, 0x02, 0x11, 0x05, 0x30, 0x23, 0x29, 0x32, 0x22, 0x1A, 
    0x14, 0x2F, 0x03, 0x1B, 0x11, 0x2C, 0x1A, 0x06, 0x28, 0x17, 
    0x2F, 0x07, 0x16, 0x31, 0x13, 0x29, 0x24, 0x05, 0x21, 0x1C, 
    0x06, 0x10, 0x1F, 0x0C, 0x24, 0x2C, 0x0E, 0x2D, 0x03, 0x23, 0x14, 

    0x24, 0x17, 0x1F, 0x2E, 0x26, 0x01, 0x30, 0x0B, 0x13, 0x1C,         // 73
    0x31, 0x04, 0x27, 0x19, 0x10, 0x1C, 0x32, 0x11, 0x1A, 0x03, 
    0x13, 0x2A, 0x24, 0x0F, 0x15, 0x20, 0x1C, 0x2C, 0x03, 0x15, 
    0x21, 0x00, 0x18, 0x2B, 0x0A, 0x10, 0x01, 0x1F, 0x2D, 0x17, 
    0x24, 0x10, 0x1E, 0x12, 0x31, 0x19, 0x1F, 0x2F, 0x0B, 0x1A, 
    0x22, 0x2A, 0x1B, 0x26, 0x0D, 0x1B, 0x02, 0x18, 0x0A, 0x04, 
    0x28, 0x0D, 0x25, 0x2D, 0x1F, 0x0A, 0x14, 0x32, 0x1D, 0x02, 
    0x24, 0x0D, 0x26, 0x03, 0x1E, 0x08, 0x19, 0x11, 0x2C, 0x0C, 
    0x24, 0x28, 0x03, 0x2F, 0x17, 0x06, 0x12, 0x25, 0x18, 0x0C, 0x2A, 

    0x32, 0x0D, 0x06, 0x11, 0x1A, 0x0F, 0x29, 0x17, 0x2C, 0x02,         // 74
    0x1F, 0x14, 0x22, 0x08, 0x2C, 0x01, 0x20, 0x09, 0x26, 0x30, 
    0x23, 0x0B, 0x03, 0x1C, 0x29, 0x05, 0x12, 0x0A, 0x26, 0x1D, 
    0x0B, 0x2D, 0x1F, 0x05, 0x21, 0x19, 0x2F, 0x15, 0x0D, 0x1E, 
    0x01, 0x30, 0x26, 0x0A, 0x23, 0x0E, 0x01, 0x28, 0x12, 0x2B, 
    0x06, 0x14, 0x0A, 0x2C, 0x16, 0x09, 0x20, 0x10, 0x26, 0x2E, 
    0x12, 0x21, 0x09, 0x15, 0x05, 0x2A, 0x22, 0x0E, 0x09, 0x2B, 
    0x10, 0x1F, 0x2A, 0x0A, 0x2C, 0x0F, 0x30, 0x26, 0x01, 0x13, 
    0x31, 0x15, 0x1B, 0x09, 0x27, 0x1C, 0x20, 0x09, 0x30, 0x1D, 0x00, 

    0x12, 0x1C, 0x2C, 0x23, 0x09, 0x1E, 0x23, 0x06, 0x24, 0x10,         // 75
    0x2A, 0x06, 0x2F, 0x0C, 0x27, 0x16, 0x0C, 0x2B, 0x15, 0x07, 
    0x1B, 0x2C, 0x16, 0x2F, 0x0C, 0x24, 0x30, 0x16, 0x2B, 0x06, 
    0x12, 0x1A, 0x0E, 0x32, 0x12, 0x1D, 0x08, 0x28, 0x05, 0x27, 
    0x1A, 0x0C, 0x16, 0x05, 0x2C, 0x13, 0x1B, 0x21, 0x07, 0x1E, 
    0x17, 0x32, 0x20, 0x00, 0x24, 0x2E, 0x15, 0x2B, 0x0C, 0x1D, 
    0x19, 0x01, 0x31, 0x1D, 0x0F, 0x26, 0x00, 0x18, 0x26, 0x14, 
    0x1B, 0x06, 0x13, 0x1A, 0x21, 0x16, 0x04, 0x1E, 0x18, 0x23, 
    0x07, 0x21, 0x11, 0x2C, 0x0F, 0x03, 0x28, 0x15, 0x04, 0x10, 0x22, 

    0x07, 0x29, 0x02, 0x18, 0x31, 0x04, 0x14, 0x0D, 0x2F, 0x19,         // 76
    0x0E, 0x1D, 0x17, 0x20, 0x10, 0x1B, 0x25, 0x1D, 0x02, 0x21, 
    0x0D, 0x11, 0x1F, 0x06, 0x13, 0x21, 0x01, 0x1B, 0x0D, 0x22, 
    0x30, 0x25, 0x03, 0x28, 0x06, 0x26, 0x0E, 0x22, 0x31, 0x11, 
    0x07, 0x2D, 0x20, 0x29, 0x1E, 0x07, 0x30, 0x16, 0x0E, 0x2D, 
    0x03, 0x0B, 0x11, 0x1C, 0x0E, 0x07, 0x28, 0x02, 0x1F, 0x07, 
    0x10, 0x24, 0x29, 0x0C, 0x19, 0x2E, 0x11, 0x1E, 0x30, 0x03, 
    0x2C, 0x25, 0x31, 0x00, 0x0D, 0x28, 0x0B, 0x2B, 0x09, 0x2E, 
    0x0E, 0x1D, 0x01, 0x24, 0x15, 0x31, 0x0B, 0x2C, 0x24, 0x2A, 0x16, 

    0x25, 0x0C, 0x14, 0x27, 0x0E, 0x25, 0x2C, 0x1D, 0x02, 0x21,         // 77
    0x09, 0x28, 0x00, 0x2B, 0x07, 0x31, 0x05, 0x11, 0x2D, 0x17, 
    0x2F, 0x01, 0x29, 0x19, 0x27, 0x08, 0x2D, 0x13, 0x28, 0x04, 
    0x18, 0x0A, 0x22, 0x16, 0x1B, 0x2E, 0x14, 0x04, 0x19, 0x1F, 
    0x2A, 0x15, 0x0E, 0x00, 0x18, 0x0C, 0x25, 0x03, 0x29, 0x19, 
    0x25, 0x22, 0x29, 0x15, 0x30, 0x1D, 0x12, 0x19, 0x31, 0x25, 
    0x2D, 0x08, 0x14, 0x04, 0x23, 0x08, 0x21, 0x06, 0x0C, 0x21, 
    0x0E, 0x08, 0x14, 0x1E, 0x2E, 0x24, 0x13, 0x1C, 0x11, 0x05, 
    0x27, 0x17, 0x30, 0x09, 0x1A, 0x1F, 0x11, 0x1B, 0x07, 0x0D, 0x2E, 

    0x19, 0x1E, 0x2F, 0x06, 0x20, 0x17, 0x08, 0x10, 0x29, 0x13,         // 78
    0x32, 0x24, 0x12, 0x0B, 0x1E, 0x14, 0x29, 0x0B, 0x26, 0x0A, 
    0x1C, 0x24, 0x09, 0x31, 0x0E, 0x17, 0x1D, 0x0A, 0x24, 0x0F, 
    0x2B, 0x12, 0x2E, 0x09, 0x0F, 0x02, 0x2A, 0x20, 0x12, 0x0A, 
    0x03, 0x21, 0x1B, 0x32, 0x12, 0x21, 0x2C, 0x11, 0x1F, 0x0A, 
    0x13, 0x2E, 0x04, 0x0A, 0x24, 0x05, 0x23, 0x0A, 0x14, 0x03, 
    0x18, 0x20, 0x1D, 0x2F, 0x2A, 0x13, 0x1B, 0x2D, 0x17, 0x12, 
    0x1E, 0x18, 0x29, 0x0F, 0x09, 0x19, 0x03, 0x32, 0x25, 0x19, 
    0x2C, 0x12, 0x0D, 0x26, 0x05, 0x2B, 0x01, 0x21, 0x17, 0x1F, 0x02, 

    0x13, 0x05, 0x23, 0x12, 0x1B, 0x00, 0x30, 0x22, 0x19, 0x07,         // 79
    0x1C, 0x05, 0x1A, 0x2E, 0x24, 0x03, 0x1A, 0x20, 0x16, 0x05, 
    0x2A, 0x0F, 0x15, 0x1E, 0x03, 0x29, 0x21, 0x02, 0x32, 0x1A, 
    0x20, 0x01, 0x1C, 0x25, 0x2C, 0x1F, 0x1A, 0x0C, 0x25, 0x28, 
    0x2F, 0x0D, 0x08, 0x27, 0x23, 0x09, 0x04, 0x17, 0x31, 0x01, 
    0x1C, 0x0F, 0x1A, 0x2C, 0x18, 0x0E, 0x2D, 0x29, 0x1C, 0x0D, 
    0x29, 0x10, 0x0A, 0x16, 0x03, 0x0E, 0x29, 0x02, 0x22, 0x2A, 
    0x04, 0x2F, 0x22, 0x02, 0x28, 0x1F, 0x07, 0x22, 0x0C, 0x02, 
    0x1F, 0x06, 0x22, 0x2D, 0x14, 0x0E, 0x26, 0x09, 0x2F, 0x0F, 0x28, 

    0x31, 0x0E, 0x2A, 0x0A, 0x2D, 0x26, 0x14, 0x0B, 0x2B, 0x0F,         // 80
    0x20, 0x14, 0x29, 0x0D, 0x15, 0x30, 0x0A, 0x2B, 0x0E, 0x31, 
    0x1A, 0x04, 0x21, 0x0B, 0x2C, 0x14, 0x10, 0x2B, 0x15, 0x06, 
    0x0C, 0x29, 0x17, 0x04, 0x11, 0x16, 0x07, 0x30, 0x02, 0x17, 
    0x1E, 0x13, 0x2C, 0x04, 0x16, 0x2A, 0x1B, 0x24, 0x0D, 0x22, 
    0x29, 0x08, 0x1F, 0x02, 0x27, 0x13, 0x01, 0x21, 0x07, 0x23, 
    0x2C, 0x01, 0x27, 0x1B, 0x25, 0x22, 0x16, 0x0C, 0x31, 0x09, 
    0x26, 0x0D, 0x17, 0x13, 0x30, 0x10, 0x18, 0x2B, 0x14, 0x2F, 
    0x0F, 0x2A, 0x18, 0x0B, 0x1E, 0x2F, 0x1C, 0x13, 0x29, 0x05, 0x22, 

    0x02, 0x1A, 0x1F, 0x17, 0x05, 0x0F, 0x1D, 0x06, 0x24, 0x01,         // 81
    0x2E, 0x0A, 0x22, 0x02, 0x1D, 0x06, 0x11, 0x1E, 0x00, 0x23, 
    0x12, 0x27, 0x2F, 0x18, 0x24, 0x06, 0x1C, 0x0C, 0x22, 0x28, 
    0x13, 0x2F, 0x0D, 0x21, 0x31, 0x26, 0x0F, 0x2A, 0x1B, 0x10, 
    0x05, 0x21, 0x19, 0x1D, 0x0B, 0x0F, 0x2F, 0x12, 0x06, 0x2C, 
    0x14, 0x24, 0x31, 0x0C, 0x1D, 0x2F, 0x1A, 0x10, 0x30, 0x12, 
    0x17, 0x1E, 0x32, 0x0C, 0x07, 0x2F, 0x05, 0x1F, 0x10, 0x19, 
    0x1D, 0x06, 0x2C, 0x1C, 0x05, 0x25, 0x0C, 0x26, 0x08, 0x1C, 
    0x16, 0x25, 0x00, 0x21, 0x07, 0x17, 0x03, 0x20, 0x0A, 0x1B, 0x15, 

    0x0D, 0x28, 0x09, 0x30, 0x24, 0x2B, 0x20, 0x1A, 0x31, 0x17,         // 82
    0x27, 0x11, 0x2D, 0x18, 0x2A, 0x23, 0x2C, 0x19, 0x13, 0x29, 
    0x07, 0x1D, 0x02, 0x11, 0x09, 0x30, 0x26, 0x03, 0x2D, 0x09, 
    0x1B, 0x23, 0x06, 0x19, 0x0A, 0x00, 0x1D, 0x21, 0x07, 0x2E, 
    0x28, 0x0F, 0x02, 0x30, 0x27, 0x20, 0x01, 0x26, 0x16, 0x1C, 
    0x0A, 0x04, 0x19, 0x12, 0x07, 0x23, 0x0C, 0x28, 0x05, 0x1B, 
    0x0B, 0x06, 0x11, 0x17, 0x29, 0x12, 0x1B, 0x2C, 0x27, 0x01, 
    0x24, 0x12, 0x28, 0x09, 0x1F, 0x2D, 0x01, 0x1E, 0x11, 0x29, 
    0x04, 0x0D, 0x32, 0x12, 0x2B, 0x27, 0x0C, 0x31, 0x11, 0x2D, 0x26, 

    0x20, 0x2C, 0x11, 0x01, 0x14, 0x0B, 0x03, 0x12, 0x0D, 0x08,         // 83
    0x1D, 0x04, 0x21, 0x07, 0x12, 0x0D, 0x08, 0x25, 0x30, 0x0A, 
    0x17, 0x0D, 0x2A, 0x21, 0x1D, 0x16, 0x11, 0x1F, 0x18, 0x10, 
    0x01, 0x27, 0x10, 0x1D, 0x29, 0x2D, 0x17, 0x0B, 0x14, 0x23, 
    0x0C, 0x2B, 0x1F, 0x12, 0x06, 0x15, 0x1C, 0x09, 0x2E, 0x20, 
    0x0F, 0x29, 0x2D, 0x22, 0x16, 0x2B, 0x03, 0x15, 0x20, 0x27, 
    0x2E, 0x23, 0x2B, 0x20, 0x00, 0x24, 0x08, 0x16, 0x0A, 0x14, 
    0x2D, 0x07, 0x22, 0x15, 0x0E, 0x19, 0x13, 0x31, 0x05, 0x21, 
    0x2C, 0x1F, 0x1B, 0x16, 0x05, 0x10, 0x23, 0x19, 0x01, 0x1E, 0x08, 

    0x18, 0x04, 0x1C, 0x21, 0x19, 0x2F, 0x22, 0x2C, 0x25, 0x20,         // 84
    0x14, 0x30, 0x0C, 0x24, 0x2F, 0x1F, 0x15, 0x03, 0x0F, 0x22, 
    0x2D, 0x24, 0x14, 0x06, 0x2D, 0x00, 0x2A, 0x08, 0x31, 0x22, 
    0x2C, 0x15, 0x30, 0x08, 0x22, 0x12, 0x04, 0x31, 0x25, 0x02, 
    0x1B, 0x07, 0x17, 0x0A, 0x2D, 0x24, 0x0E, 0x28, 0x11, 0x02, 
    0x25, 0x15, 0x0D, 0x00, 0x27, 0x11, 0x1D, 0x2F, 0x08, 0x0F, 
    0x03, 0x18, 0x09, 0x0D, 0x1C, 0x2E, 0x0F, 0x23, 0x30, 0x1F, 
    0x0C, 0x1B, 0x32, 0x02, 0x2C, 0x21, 0x07, 0x28, 0x1B, 0x0A, 
    0x12, 0x07, 0x0C, 0x25, 0x2D, 0x1D, 0x07, 0x2C, 0x15, 0x28, 0x10, 

    0x0A, 0x32, 0x26, 0x0C, 0x27, 0x10, 0x09, 0x17, 0x01, 0x2E,         // 85
    0x07, 0x1A, 0x28, 0x16, 0x01, 0x1A, 0x2D, 0x28, 0x1C, 0x05, 
    0x19, 0x01, 0x32, 0x0C, 0x1A, 0x24, 0x0F, 0x1C, 0x14, 0x04, 
    0x0C, 0x20, 0x03, 0x17, 0x0D, 0x27, 0x1E, 0x0F, 0x2B, 0x1F, 
    0x13, 0x32, 0x22, 0x29, 0x1A, 0x03, 0x31, 0x07, 0x21, 0x18, 
    0x30, 0x06, 0x1E, 0x1A, 0x31, 0x06, 0x0D, 0x29, 0x17, 0x1D, 
    0x2C, 0x13, 0x26, 0x30, 0x14, 0x06, 0x2A, 0x02, 0x1A, 0x05, 
    0x28, 0x10, 0x18, 0x0B, 0x27, 0x10, 0x1D, 0x0D, 0x15, 0x2F, 
    0x18, 0x27, 0x2E, 0x02, 0x12, 0x19, 0x27, 0x0D, 0x22, 0x06, 0x2B, 

    0x24, 0x16, 0x12, 0x06, 0x2B, 0x04, 0x1D, 0x28, 0x11, 0x1F,         // 86
    0x0D, 0x2B, 0x11, 0x0A, 0x26, 0x07, 0x10, 0x0A, 0x23, 0x12, 
    0x2B, 0x10, 0x1C, 0x28, 0x13, 0x09, 0x2E, 0x06, 0x26, 0x2A, 
    0x1B, 0x0F, 0x29, 0x1C, 0x2C, 0x05, 0x19, 0x08, 0x16, 0x06, 
    0x0D, 0x24, 0x01, 0x0C, 0x12, 0x20, 0x14, 0x1B, 0x2B, 0x08, 
    0x13, 0x23, 0x2B, 0x0A, 0x14, 0x20, 0x19, 0x24, 0x01, 0x12, 
    0x25, 0x07, 0x1E, 0x03, 0x19, 0x21, 0x1E, 0x15, 0x0E, 0x2D, 
    0x24, 0x06, 0x2B, 0x20, 0x19, 0x04, 0x2E, 0x25, 0x01, 0x23, 
    0x04, 0x1D, 0x15, 0x20, 0x09, 0x30, 0x02, 0x13, 0x30, 0x1A, 0x12, 

    0x1C, 0x00, 0x2D, 0x1F, 0x17, 0x23, 0x14, 0x32, 0x06, 0x19,         // 87
    0x24, 0x02, 0x1D, 0x22, 0x32, 0x1D, 0x29, 0x17, 0x30, 0x07, 
    0x26, 0x0B, 0x21, 0x04, 0x2C, 0x1F, 0x18, 0x22, 0x0E, 0x17, 
    0x06, 0x31, 0x24, 0x08, 0x11, 0x2F, 0x23, 0x2A, 0x21, 0x2F, 
    0x19, 0x2C, 0x16, 0x1E, 0x2F, 0x0A, 0x26, 0x00, 0x0E, 0x27, 
    0x1D, 0x02, 0x0F, 0x25, 0x03, 0x2E, 0x08, 0x2C, 0x0B, 0x21, 
    0x2F, 0x0C, 0x29, 0x0F, 0x2D, 0x11, 0x09, 0x31, 0x22, 0x0A, 
    0x14, 0x1D, 0x12, 0x03, 0x30, 0x13, 0x09, 0x17, 0x2C, 0x0E, 
    0x2A, 0x11, 0x06, 0x29, 0x0E, 0x24, 0x17, 0x1E, 0x0B, 0x03, 0x2C, 

    0x08, 0x21, 0x0E, 0x08, 0x30, 0x0C, 0x02, 0x22, 0x0B, 0x28,         // 88
    0x13, 0x2F, 0x09, 0x14, 0x04, 0x0D, 0x13, 0x02, 0x1F, 0x1A, 
    0x14, 0x2E, 0x08, 0x17, 0x0F, 0x02, 0x12, 0x30, 0x01, 0x2D, 
    0x1F, 0x12, 0x02, 0x15, 0x1F, 0x0B, 0x01, 0x12, 0x0C, 0x03, 
    0x27, 0x07, 0x0E, 0x28, 0x04, 0x19, 0x2D, 0x1E, 0x12, 0x2E, 
    0x0C, 0x18, 0x2F, 0x1E, 0x16, 0x28, 0x0F, 0x15, 0x1E, 0x0F, 
    0x04, 0x1C, 0x15, 0x23, 0x05, 0x27, 0x1C, 0x03, 0x28, 0x19, 
    0x00, 0x30, 0x26, 0x0D, 0x1D, 0x28, 0x22, 0x10, 0x1F, 0x1B, 
    0x08, 0x23, 0x31, 0x1A, 0x14, 0x2B, 0x05, 0x2D, 0x22, 0x27, 0x0F, 

    0x31, 0x17, 0x27, 0x1B, 0x13, 0x26, 0x2C, 0x1B, 0x11, 0x2E,         // 89
    0x08, 0x17, 0x25, 0x2A, 0x19, 0x2B, 0x24, 0x2E, 0x0C, 0x2A, 
    0x02, 0x1F, 0x1B, 0x31, 0x22, 0x2B, 0x1C, 0x0A, 0x27, 0x15, 
    0x08, 0x23, 0x1A, 0x2A, 0x26, 0x16, 0x1E, 0x2C, 0x24, 0x15, 
    0x1E, 0x12, 0x21, 0x1B, 0x2B, 0x0F, 0x06, 0x16, 0x25, 0x04, 
    0x22, 0x27, 0x07, 0x12, 0x06, 0x1A, 0x23, 0x03, 0x32, 0x26, 
    0x18, 0x2B, 0x00, 0x31, 0x19, 0x0E, 0x2C, 0x16, 0x0F, 0x25, 
    0x1F, 0x0C, 0x17, 0x2B, 0x07, 0x18, 0x02, 0x32, 0x06, 0x14, 
    0x2C, 0x18, 0x0B, 0x00, 0x1E, 0x0A, 0x1B, 0x0E, 0x06, 0x15, 0x1E, 

    0x11, 0x06, 0x2B, 0x02, 0x1F, 0x08, 0x0E, 0x17, 0x24, 0x04,         // 90
    0x1C, 0x21, 0x0F, 0x01, 0x1E, 0x07, 0x20, 0x05, 0x17, 0x0F, 
    0x23, 0x12, 0x0D, 0x04, 0x27, 0x08, 0x17, 0x24, 0x0F, 0x1B, 
    0x28, 0x0E, 0x2E, 0x0B, 0x04, 0x32, 0x0D, 0x19, 0x08, 0x30, 
    0x04, 0x2D, 0x0B, 0x01, 0x13, 0x24, 0x29, 0x0C, 0x32, 0x1A, 
    0x09, 0x14, 0x2C, 0x21, 0x31, 0x0B, 0x2B, 0x1C, 0x07, 0x13, 
    0x0A, 0x24, 0x12, 0x0B, 0x1E, 0x08, 0x24, 0x05, 0x2E, 0x09, 
    0x2A, 0x13, 0x04, 0x22, 0x12, 0x2E, 0x0F, 0x24, 0x0B, 0x28, 
    0x04, 0x10, 0x26, 0x2E, 0x23, 0x12, 0x30, 0x24, 0x19, 0x2A, 0x0A, 
};

// The next 3 cells are for halftoning to the 8 colors that contain
// all combinations of 0x00 and 0xFF.
// These cells contain values between 0x00 and 0xFE (inclusive).

const BYTE HT_SuperCell_RedMono[91*91] = {
    0xA8, 0x3C, 0x72, 0xF9, 0x46, 0x65, 0xB1, 0x72, 0xA1, 0x86,         //  0
    0x03, 0xAD, 0x5E, 0x1D, 0x3C, 0x9B, 0x00, 0xF3, 0x36, 0x17, 
    0xB0, 0x81, 0x19, 0xCF, 0xB4, 0x7D, 0x99, 0xDD, 0x74, 0xEF, 
    0x39, 0x67, 0xF4, 0x43, 0xDA, 0x9B, 0x38, 0x1B, 0xBB, 0x40, 
    0x03, 0x68, 0xF7, 0x9A, 0x0A, 0xEC, 0x33, 0xAA, 0xF1, 0xC6, 
    0x31, 0xE5, 0x98, 0xD2, 0x49, 0xF3, 0x1C, 0x66, 0x3C, 0x16, 
    0xC6, 0x6C, 0x3D, 0xD0, 0x68, 0x33, 0x90, 0x07, 0xAF, 0xDF, 
    0xCC, 0x8E, 0x4A, 0xEE, 0x72, 0xBA, 0xF2, 0x0C, 0xDD, 0x6E, 
    0x12, 0x27, 0xE5, 0x8A, 0xC1, 0x5E, 0xD5, 0x0E, 0x50, 0x88, 0x61, 

    0x91, 0xE9, 0x4F, 0xC1, 0x9D, 0x2E, 0xE1, 0x4F, 0x3A, 0xE6,         //  1
    0x30, 0xF7, 0x95, 0x76, 0xC0, 0x7F, 0x59, 0xAC, 0x92, 0x6A, 
    0xDD, 0x42, 0x64, 0xEA, 0x02, 0x2E, 0x54, 0xA9, 0x2C, 0x51, 
    0xB1, 0xCF, 0x2B, 0xAF, 0x7F, 0x63, 0xFD, 0x75, 0xD3, 0x9B, 
    0xE7, 0xAF, 0x18, 0x74, 0xD5, 0x44, 0xCB, 0x15, 0x59, 0x84, 
    0x08, 0xB2, 0x5B, 0x2F, 0x71, 0xC4, 0x84, 0xE4, 0xA6, 0x80, 
    0xDF, 0x2D, 0xF5, 0x7F, 0x1C, 0xD8, 0x57, 0xEE, 0x38, 0x83, 
    0x12, 0x6A, 0xC3, 0x05, 0xA9, 0x43, 0x8E, 0x33, 0xC3, 0x4E, 
    0xEC, 0xC7, 0x6A, 0x07, 0xF1, 0x40, 0x86, 0xA8, 0xEE, 0xC6, 0x0A, 

    0x2C, 0xB9, 0x1F, 0x89, 0x11, 0xC9, 0x80, 0x1C, 0xC5, 0x68,         //  2
    0xB6, 0x52, 0x24, 0xDA, 0x0F, 0xED, 0x28, 0x40, 0xE8, 0x09, 
    0xBD, 0x25, 0xAD, 0x8D, 0x6E, 0xBD, 0xF5, 0x0C, 0x92, 0xD7, 
    0x7B, 0x00, 0x97, 0x55, 0x17, 0xBA, 0x05, 0x8D, 0x2B, 0x5E, 
    0x23, 0x48, 0xC7, 0x38, 0x8B, 0x60, 0xB0, 0x78, 0xA0, 0x40, 
    0xF9, 0x8D, 0x1A, 0xEB, 0xA3, 0x40, 0x28, 0xCD, 0x03, 0x49, 
    0xB5, 0x0E, 0xAA, 0x47, 0x9D, 0xBF, 0x24, 0x76, 0xC4, 0x55, 
    0xA6, 0xE9, 0x30, 0x83, 0x58, 0x20, 0xD5, 0x5F, 0xA5, 0x81, 
    0x31, 0x97, 0x42, 0xB3, 0x72, 0x14, 0xDF, 0x26, 0x37, 0x6D, 0xDE, 

    0x80, 0x57, 0xDB, 0x68, 0xEE, 0x3C, 0xA5, 0xFD, 0x94, 0x10,         //  3
    0x82, 0xD0, 0xA2, 0x37, 0x62, 0xCB, 0xB1, 0x83, 0xCE, 0x51, 
    0x8B, 0xF5, 0x4E, 0x1C, 0xE3, 0x3C, 0x87, 0x66, 0xBB, 0x20, 
    0x48, 0xE7, 0x6F, 0xCA, 0xEE, 0x45, 0xDE, 0x4F, 0xB5, 0xF5, 
    0x92, 0x7B, 0xE3, 0xA4, 0x1E, 0xFD, 0x02, 0xE7, 0x2F, 0xD9, 
    0x6A, 0x4E, 0xD4, 0x7A, 0x09, 0xB8, 0x60, 0x97, 0x76, 0xF4, 
    0x5F, 0x8F, 0x67, 0xEA, 0x00, 0x88, 0xE0, 0xA2, 0x0D, 0xFD, 
    0x24, 0x45, 0xD4, 0x9A, 0xFA, 0xB3, 0x7C, 0x17, 0xF6, 0x00, 
    0xB8, 0x5B, 0xFB, 0x2D, 0x9B, 0xC9, 0x7B, 0x5C, 0x94, 0xB6, 0x4A, 

    0xFC, 0xA1, 0x07, 0xB1, 0x4D, 0x7A, 0x00, 0x5A, 0x31, 0xDE,         //  4
    0x43, 0x15, 0x73, 0xF3, 0x8D, 0x49, 0x17, 0x6C, 0x23, 0xA4, 
    0x32, 0x74, 0xCE, 0x9C, 0x5B, 0xCA, 0x17, 0xD9, 0x38, 0xF9, 
    0x8B, 0xA7, 0x22, 0x3E, 0x87, 0xA4, 0x24, 0xCE, 0x6A, 0x0C, 
    0xD3, 0x51, 0x07, 0x6A, 0xBF, 0x50, 0x99, 0x65, 0xC8, 0x17, 
    0xA8, 0x29, 0xBF, 0x47, 0x94, 0xFB, 0xD6, 0x1B, 0x3C, 0xC2, 
    0x22, 0xDB, 0x3A, 0xB9, 0x77, 0x59, 0x2F, 0x48, 0x66, 0x95, 
    0x7D, 0xB9, 0x70, 0x18, 0x39, 0x66, 0xDC, 0x3F, 0x92, 0x69, 
    0xE4, 0x1E, 0x7E, 0xD4, 0x4C, 0x23, 0xB4, 0xF7, 0x01, 0xD6, 0x17, 

    0x3F, 0x6F, 0xCB, 0x33, 0x96, 0xE3, 0xCE, 0xB0, 0x70, 0x9C,         //  5
    0xBF, 0xE6, 0x4B, 0xAF, 0x0A, 0xA4, 0xE0, 0xB7, 0xFE, 0x60, 
    0xDC, 0x11, 0x45, 0xB9, 0x07, 0x78, 0xA6, 0x52, 0x9B, 0x6E, 
    0x0D, 0x5C, 0xD6, 0xB6, 0x09, 0x5B, 0x79, 0x96, 0x3C, 0xAE, 
    0x31, 0xBC, 0xF4, 0x92, 0x2E, 0xDD, 0x24, 0x87, 0x4B, 0xB8, 
    0x75, 0x97, 0xF0, 0x23, 0x65, 0x13, 0x51, 0xAE, 0xE5, 0x84, 
    0x51, 0x9C, 0x11, 0xD0, 0x2A, 0xF6, 0xB1, 0xC7, 0xE3, 0x35, 
    0xD0, 0x02, 0x50, 0xDF, 0xBF, 0x09, 0x9A, 0xC1, 0x27, 0xD4, 
    0x4B, 0x9E, 0xC0, 0x05, 0x6A, 0xEB, 0x56, 0x3D, 0xA4, 0x65, 0x92, 

    0xB9, 0x29, 0x8B, 0xF3, 0x18, 0x60, 0x24, 0x44, 0xF3, 0x0B,         //  6
    0x5F, 0x89, 0x2D, 0xCF, 0x68, 0x82, 0x2F, 0x58, 0x04, 0x84, 
    0xC1, 0x94, 0xEC, 0x2F, 0x8F, 0xFB, 0x29, 0xE6, 0x1A, 0xCC, 
    0xB2, 0xED, 0x2B, 0x76, 0xFA, 0xBD, 0xE1, 0x11, 0xF0, 0x73, 
    0x8D, 0x5E, 0x16, 0x44, 0xCF, 0x6F, 0xB5, 0xE5, 0x0F, 0xF7, 
    0x3C, 0x04, 0x80, 0xB0, 0xCE, 0x7C, 0x9D, 0x32, 0x6A, 0x09, 
    0xB6, 0xFE, 0x71, 0x54, 0xA8, 0x92, 0x09, 0x7A, 0x17, 0xA9, 
    0x5B, 0xF5, 0x8A, 0xA3, 0x79, 0x4B, 0xE6, 0x55, 0x7A, 0xAF, 
    0x11, 0x70, 0x37, 0xDF, 0x8D, 0xA7, 0x11, 0x84, 0xE3, 0x2F, 0xD0, 

    0x0A, 0xDD, 0x67, 0x44, 0xBD, 0xA3, 0x86, 0xC4, 0x7A, 0x3A,         //  7
    0xB2, 0x1B, 0xFB, 0x55, 0xBD, 0x42, 0xEF, 0xA6, 0xD0, 0x41, 
    0x20, 0x56, 0x75, 0xD7, 0x62, 0x3F, 0xB8, 0x66, 0x84, 0x46, 
    0x32, 0x82, 0x4F, 0x98, 0x1C, 0x44, 0x2D, 0xA7, 0x4C, 0xD6, 
    0x25, 0xE9, 0xB5, 0x7C, 0x9F, 0x08, 0x38, 0x60, 0x9E, 0x6C, 
    0xC2, 0xDC, 0x62, 0x3A, 0xED, 0x2C, 0xC4, 0xF5, 0x92, 0xD6, 
    0x46, 0x24, 0x89, 0xE8, 0x1C, 0x6D, 0x3F, 0xEE, 0x99, 0x6D, 
    0x2D, 0xAF, 0x44, 0x1B, 0xF0, 0x2B, 0x8A, 0x12, 0xF5, 0x40, 
    0x8D, 0xEE, 0xB2, 0x51, 0x20, 0xCD, 0x72, 0xBE, 0x1B, 0x8A, 0x50, 

    0x7B, 0xA6, 0x14, 0xD7, 0x76, 0x0D, 0xDE, 0x2B, 0x99, 0xE5,         //  8
    0xCA, 0x6D, 0xA5, 0x01, 0xDE, 0x28, 0x90, 0x19, 0x6D, 0x9F, 
    0xF4, 0xB5, 0x0A, 0xA2, 0x18, 0xCC, 0x93, 0x0A, 0xD5, 0xA3, 
    0xE4, 0x03, 0xC9, 0xAC, 0x6D, 0xD2, 0x84, 0x60, 0xC2, 0x14, 
    0x9F, 0x6E, 0x36, 0xE0, 0x53, 0xF8, 0x8B, 0xD1, 0x1E, 0x33, 
    0x85, 0x45, 0xA4, 0x11, 0x94, 0x6E, 0x01, 0x4D, 0x20, 0x5F, 
    0x9E, 0xCA, 0x36, 0xBE, 0x4C, 0xB5, 0xD3, 0x59, 0x25, 0xB7, 
    0xEA, 0x0C, 0x74, 0xD4, 0x5E, 0xC7, 0xA9, 0x63, 0xB9, 0x22, 
    0xCC, 0x5E, 0x0C, 0x81, 0xF8, 0x2F, 0x45, 0xEF, 0x5F, 0xB2, 0xE9, 

    0x58, 0xFA, 0x4E, 0x94, 0x32, 0xF6, 0x4A, 0x6F, 0x06, 0x5B,         //  9
    0x30, 0x8F, 0x3E, 0x7D, 0xAF, 0x75, 0xC7, 0x4E, 0xDA, 0x2E, 
    0x78, 0x45, 0xC9, 0x32, 0xEE, 0x6C, 0x4C, 0xF4, 0x27, 0x57, 
    0x8F, 0x67, 0xF5, 0x13, 0x4B, 0xEC, 0x9B, 0x07, 0xF4, 0x83, 
    0x43, 0xCD, 0x1D, 0xAC, 0x13, 0x73, 0xBC, 0x4D, 0xE6, 0xAE, 
    0xF2, 0x1A, 0xC8, 0xE7, 0x55, 0xBA, 0xE1, 0x84, 0xB3, 0xED, 
    0x0E, 0x6E, 0xDF, 0x05, 0x82, 0xF9, 0x16, 0x8E, 0xCD, 0x3B, 
    0xD7, 0x91, 0xBB, 0x38, 0x9B, 0x08, 0x43, 0xD6, 0x80, 0x51, 
    0x98, 0x30, 0xD8, 0x9D, 0x63, 0xBA, 0x95, 0x04, 0xD3, 0x37, 0x1F, 

    0xC0, 0x84, 0x24, 0xC6, 0xAB, 0x5C, 0xCB, 0xB3, 0xD7, 0xA0,         // 10
    0xF0, 0x11, 0xCF, 0xED, 0x22, 0x5A, 0x0C, 0xF9, 0xB1, 0x06, 
    0x90, 0xE5, 0x5F, 0x97, 0x7F, 0xAC, 0x2F, 0xB4, 0x73, 0xC5, 
    0x3C, 0xB0, 0x2F, 0x7F, 0xBB, 0x33, 0x69, 0xB4, 0x2A, 0x5E, 
    0xBA, 0xFB, 0x62, 0x96, 0xC9, 0x3D, 0x24, 0xA2, 0x01, 0x72, 
    0x50, 0x97, 0x5C, 0x80, 0x21, 0x43, 0x9E, 0x68, 0x28, 0xC7, 
    0x90, 0x42, 0xAE, 0x98, 0x5B, 0x30, 0xA4, 0x71, 0x03, 0x4E, 
    0x7D, 0x5A, 0x15, 0xF6, 0x6C, 0xE0, 0x8E, 0x32, 0xE7, 0x02, 
    0xFE, 0x74, 0xBD, 0x3D, 0x15, 0xDC, 0x52, 0x83, 0xAE, 0x74, 0x9D, 

    0x07, 0x3A, 0xD3, 0x6C, 0x02, 0x8B, 0x1F, 0x40, 0x7F, 0x1C,         // 11
    0x54, 0xB9, 0x66, 0x48, 0x94, 0xE2, 0xA5, 0x81, 0x3D, 0x63, 
    0xC0, 0x35, 0x10, 0xD1, 0x3E, 0x00, 0xE0, 0x85, 0x0E, 0xE8, 
    0x1E, 0xD2, 0x52, 0xE2, 0x93, 0x1E, 0xD0, 0x4D, 0xE1, 0x96, 
    0x35, 0x02, 0x81, 0x43, 0xEF, 0x89, 0xE0, 0x65, 0x8C, 0xCC, 
    0x27, 0xDA, 0x06, 0xA8, 0xC6, 0xFC, 0x10, 0xD5, 0x3B, 0x7B, 
    0x1C, 0xF6, 0x66, 0x2B, 0xE6, 0xC2, 0x43, 0xE0, 0xB4, 0xFD, 
    0xA0, 0x2F, 0xC8, 0x81, 0x22, 0x4F, 0xB3, 0x15, 0x68, 0xC2, 
    0xA1, 0x1A, 0x4D, 0xEF, 0x7B, 0xA5, 0x27, 0xFC, 0x13, 0x49, 0xED, 

    0x65, 0xE3, 0xA2, 0x53, 0xED, 0xD8, 0x71, 0x9B, 0xFD, 0x39,         // 12
    0xDF, 0x7A, 0xA4, 0x16, 0xC5, 0x31, 0x6C, 0x1D, 0xD3, 0x9B, 
    0xF5, 0x7C, 0xA9, 0x69, 0xFD, 0x57, 0xC8, 0x63, 0xA1, 0x4C, 
    0x8D, 0x70, 0xA0, 0x0B, 0x62, 0xFE, 0x77, 0x8C, 0x19, 0xC9, 
    0x75, 0xA7, 0xD2, 0x28, 0x5D, 0x0C, 0xC2, 0x47, 0xFE, 0x38, 
    0xB7, 0x7A, 0xF3, 0x39, 0x72, 0x2C, 0x8A, 0x5E, 0xA8, 0xDB, 
    0x58, 0xBB, 0x15, 0xCC, 0x76, 0x0E, 0x62, 0x8A, 0x21, 0x64, 
    0x10, 0xB1, 0xDD, 0x3F, 0xA7, 0xED, 0x74, 0xD2, 0x95, 0x37, 
    0x5A, 0xDF, 0x8A, 0x06, 0xB7, 0x37, 0x6F, 0xC7, 0x62, 0xD6, 0x8E, 

    0xB5, 0x45, 0x12, 0x93, 0x3D, 0x25, 0xC1, 0x0A, 0x62, 0xC6,         // 13
    0x90, 0x07, 0x37, 0xFA, 0x83, 0x4F, 0xBC, 0xEE, 0x59, 0x13, 
    0x4C, 0x2D, 0xDD, 0x17, 0x8B, 0xB1, 0x1C, 0x3B, 0xF8, 0xBA, 
    0x15, 0xF2, 0x2C, 0xDA, 0xBE, 0x48, 0x05, 0xAB, 0x41, 0xF2, 
    0x59, 0x22, 0xEB, 0xBB, 0xA3, 0x78, 0x33, 0xAF, 0x13, 0x5A, 
    0x94, 0x1F, 0x63, 0xCF, 0x99, 0x55, 0xB5, 0xE7, 0x08, 0x48, 
    0x9C, 0x7F, 0xE9, 0x47, 0x92, 0xA9, 0xF5, 0x32, 0xD1, 0x7F, 
    0xEA, 0x50, 0x6D, 0x98, 0x03, 0xC3, 0x28, 0x44, 0xF2, 0x80, 
    0x21, 0xAA, 0x64, 0xC8, 0x56, 0xEC, 0x91, 0x1D, 0xA8, 0x36, 0x20, 

    0x70, 0x86, 0xF8, 0xBB, 0x7C, 0xA6, 0x52, 0xE4, 0xB2, 0x21,         // 14
    0x4E, 0xCE, 0xAE, 0x57, 0xD9, 0x04, 0x98, 0x28, 0x87, 0xAD, 
    0xCC, 0x8F, 0x5C, 0xC3, 0x37, 0x7B, 0xDC, 0x99, 0x25, 0x80, 
    0x62, 0xC1, 0x4E, 0x7B, 0x34, 0x9F, 0xE4, 0xC4, 0x6A, 0x10, 
    0xB8, 0x86, 0x46, 0x6B, 0x1D, 0xF3, 0xD2, 0x98, 0x79, 0xEA, 
    0xD3, 0x49, 0xA5, 0x0D, 0xEE, 0x1D, 0xCB, 0x32, 0x83, 0xFA, 
    0x1F, 0x3A, 0xAA, 0x01, 0x59, 0xC8, 0x19, 0x9A, 0x55, 0xBF, 
    0x35, 0x91, 0x1C, 0xF9, 0x57, 0x8A, 0x62, 0xA1, 0x09, 0xBB, 
    0xD9, 0x42, 0xF6, 0x29, 0x9D, 0x0F, 0xD6, 0x47, 0x7D, 0xF4, 0xC4, 

    0x0C, 0xCF, 0x38, 0x19, 0x5C, 0xF2, 0x2A, 0x81, 0x37, 0xA2,         // 15
    0x78, 0xE5, 0x66, 0x1D, 0xA5, 0x76, 0xCA, 0x3E, 0xDE, 0x69, 
    0x02, 0xEC, 0x26, 0x99, 0xE8, 0x07, 0x4F, 0x6A, 0xCE, 0x45, 
    0xE5, 0x03, 0x92, 0xB3, 0x11, 0x85, 0x5D, 0x25, 0x96, 0xDB, 
    0x34, 0x9D, 0x0C, 0xE0, 0x92, 0x52, 0x04, 0x61, 0x2C, 0xBA, 
    0x08, 0x84, 0xC1, 0x40, 0x6B, 0x86, 0x4B, 0xA3, 0x69, 0xB8, 
    0xD1, 0x66, 0xDB, 0x79, 0xEE, 0x39, 0x6F, 0xE5, 0x3F, 0xA3, 
    0x05, 0xD8, 0xBB, 0x34, 0xD2, 0x15, 0xEA, 0xC7, 0x5C, 0x34, 
    0x75, 0x13, 0x95, 0x71, 0xE0, 0x3F, 0x65, 0xB1, 0x00, 0x96, 0x52, 

    0xEB, 0xA0, 0x67, 0xC3, 0xD9, 0x0C, 0x93, 0xD0, 0x66, 0xF8,         // 16
    0x18, 0x41, 0x8C, 0xED, 0x33, 0x4A, 0xF2, 0x63, 0x1B, 0xBD, 
    0x42, 0x73, 0xB3, 0x48, 0x6C, 0xC6, 0xA5, 0xEF, 0x0F, 0x90, 
    0xAC, 0x39, 0xD0, 0x57, 0xEB, 0xCB, 0x43, 0xF7, 0x7D, 0x4B, 
    0xC0, 0xFC, 0x57, 0xB3, 0x34, 0xC4, 0x82, 0xD9, 0xA6, 0x4E, 
    0x6F, 0xF9, 0x2E, 0xDD, 0xAD, 0xD6, 0x02, 0xEF, 0x27, 0x4E, 
    0x0B, 0x94, 0x26, 0xBC, 0x1C, 0x8B, 0xB5, 0x0F, 0x7C, 0xF5, 
    0x60, 0x78, 0x46, 0xA1, 0x6B, 0xB4, 0x7B, 0x1E, 0x94, 0xFB, 
    0xAD, 0xD2, 0x4F, 0xBA, 0x1F, 0x82, 0xC6, 0xED, 0x58, 0xD3, 0x2E, 

    0x82, 0x4A, 0x23, 0x8C, 0x73, 0x46, 0xB7, 0x57, 0x01, 0xC2,         // 17
    0x97, 0xB9, 0x08, 0xC6, 0x86, 0xB5, 0x0B, 0xAA, 0x95, 0xFA, 
    0x85, 0xD7, 0x1E, 0xF5, 0x13, 0x8E, 0x2B, 0x3E, 0x7A, 0xC9, 
    0x20, 0x6E, 0xFA, 0x17, 0x76, 0x2B, 0xA4, 0x17, 0xB1, 0x01, 
    0x6D, 0x27, 0x84, 0xD3, 0x74, 0x21, 0xF9, 0x3D, 0x1A, 0xE4, 
    0x98, 0x16, 0x66, 0x8D, 0x1A, 0x5C, 0x97, 0x77, 0xCC, 0xA5, 
    0x7E, 0xF2, 0x46, 0x9A, 0x57, 0xD0, 0x4B, 0xDB, 0x28, 0xC7, 
    0x1F, 0xE2, 0x8D, 0x09, 0xF3, 0x2B, 0x41, 0xD0, 0x4C, 0x6E, 
    0x23, 0x87, 0x06, 0xEF, 0x57, 0xAE, 0x2E, 0x89, 0x1E, 0x73, 0xBC, 

    0x10, 0xDC, 0xAA, 0xFC, 0x2E, 0xA3, 0xED, 0x30, 0xDE, 0x73,         // 18
    0x27, 0x5B, 0xDD, 0x69, 0x22, 0x5A, 0xE3, 0x7B, 0x52, 0x36, 
    0x13, 0xA7, 0x59, 0x7C, 0xD2, 0x55, 0xDD, 0xBB, 0x5E, 0xF3, 
    0x4F, 0x88, 0xA2, 0x3F, 0xBC, 0x8F, 0x65, 0xE1, 0x53, 0xC8, 
    0x95, 0xDC, 0x41, 0x08, 0x9F, 0x4B, 0xB1, 0x93, 0x6C, 0xC1, 
    0x3A, 0xD1, 0xA8, 0x47, 0xEB, 0x31, 0xC3, 0x3D, 0x18, 0xE9, 
    0x5B, 0x2F, 0xC6, 0x70, 0xF8, 0x06, 0xA7, 0x68, 0x9A, 0x84, 
    0x4E, 0xAC, 0x32, 0xCD, 0x54, 0x93, 0xAD, 0xE4, 0x01, 0xA4, 
    0xE8, 0x48, 0xC4, 0x69, 0xA1, 0x0E, 0xDA, 0x46, 0xA4, 0xF8, 0x3E, 

    0xB6, 0x6F, 0x54, 0x04, 0xD4, 0x69, 0x13, 0x84, 0x9F, 0x4D,         // 19
    0xF3, 0x81, 0x32, 0x9A, 0xFE, 0xBE, 0x3C, 0x24, 0xBA, 0xE0, 
    0x67, 0xCC, 0x3C, 0x96, 0xB6, 0x23, 0x86, 0x01, 0x9C, 0x16, 
    0xB5, 0x2E, 0xCA, 0x61, 0xE7, 0x0A, 0xD2, 0x38, 0x7F, 0xF4, 
    0x20, 0x5C, 0xAD, 0xF4, 0x63, 0xE2, 0x0F, 0x58, 0xEE, 0x00, 
    0x7B, 0x55, 0xE3, 0x0A, 0xBC, 0x81, 0xFA, 0x65, 0x9B, 0x44, 
    0xB7, 0xD9, 0x14, 0xAD, 0x2B, 0x7F, 0x42, 0xEF, 0x30, 0xBC, 
    0x0A, 0xFD, 0x61, 0x7D, 0xBB, 0x12, 0x72, 0x57, 0xC0, 0x31, 
    0x61, 0xD8, 0x2C, 0x93, 0x3B, 0xFD, 0x71, 0xB8, 0x09, 0x5B, 0x93, 

    0xF1, 0x1A, 0xCD, 0x7C, 0x95, 0x3F, 0xBC, 0xD7, 0x38, 0xB4,         // 20
    0x0B, 0xD4, 0xA9, 0x53, 0x13, 0x71, 0x9D, 0xD7, 0x88, 0x0B, 
    0x99, 0x27, 0xEF, 0x06, 0x47, 0xFE, 0x67, 0xE6, 0x45, 0xD4, 
    0x6B, 0xE9, 0x04, 0x99, 0x32, 0x7A, 0xB5, 0x1C, 0xAA, 0x42, 
    0x78, 0xC1, 0x15, 0x8E, 0x29, 0xBB, 0x7A, 0xCF, 0x35, 0x8D, 
    0xB6, 0x2C, 0x91, 0x75, 0x4F, 0x25, 0xA9, 0x10, 0xDE, 0x79, 
    0x03, 0x84, 0x61, 0x3C, 0xE6, 0x95, 0xD2, 0x15, 0x5E, 0xE3, 
    0x6E, 0x96, 0x15, 0xDB, 0x29, 0xEC, 0x3B, 0x99, 0xF1, 0x7C, 
    0x91, 0x14, 0xAA, 0x75, 0xC8, 0x21, 0x55, 0xD4, 0x7C, 0xDF, 0x2C, 

    0x4D, 0x96, 0x34, 0xBA, 0x1D, 0xF5, 0x52, 0x7A, 0x20, 0x63,         // 21
    0xC5, 0x45, 0x21, 0xEA, 0x8A, 0xCE, 0x00, 0x66, 0x4C, 0xEB, 
    0x6F, 0xB0, 0x79, 0xC7, 0x6F, 0x9B, 0x37, 0xB9, 0x82, 0x25, 
    0x91, 0x4C, 0x7D, 0xD7, 0x4F, 0xFD, 0x57, 0x8A, 0xE4, 0x09, 
    0x9D, 0xEC, 0x49, 0x76, 0xD8, 0x3B, 0x98, 0x1F, 0xAD, 0x48, 
    0xFD, 0xC8, 0x14, 0xF1, 0x9E, 0xD9, 0x70, 0x53, 0xC6, 0x3A, 
    0xA4, 0xFE, 0x9A, 0xCC, 0x73, 0x1D, 0xBD, 0x7A, 0xA8, 0x44, 
    0xC6, 0x37, 0xB0, 0x4A, 0x9F, 0x84, 0xD4, 0x0B, 0x46, 0x22, 
    0xBB, 0xF5, 0x57, 0x0C, 0xE8, 0x89, 0xAA, 0x3C, 0x23, 0xC0, 0x83, 

    0xAD, 0xD8, 0x63, 0xE4, 0x5B, 0xAD, 0x06, 0xE0, 0x93, 0xEB,         // 22
    0x9B, 0x83, 0x6D, 0xB7, 0x2C, 0x47, 0xB2, 0xF8, 0x1A, 0xBC, 
    0x36, 0x52, 0xDD, 0x24, 0xAC, 0x0E, 0xD1, 0x19, 0x63, 0xAA, 
    0xF9, 0x15, 0xBD, 0x24, 0xA9, 0x10, 0xC9, 0x2A, 0x64, 0xCC, 
    0x6E, 0x22, 0xD1, 0xA5, 0x03, 0x53, 0xEA, 0x64, 0xDA, 0x73, 
    0x1C, 0x59, 0xAB, 0x63, 0x3C, 0x04, 0xBD, 0x93, 0x2D, 0xE6, 
    0x5B, 0x23, 0x46, 0x0A, 0xB2, 0x50, 0x35, 0xFA, 0x00, 0x8D, 
    0x26, 0xD5, 0x74, 0xF4, 0x62, 0x16, 0xBE, 0x67, 0xAA, 0xDF, 
    0x6A, 0x39, 0xD0, 0xB5, 0x43, 0x67, 0x01, 0xF2, 0x97, 0x5F, 0x0C, 

    0x3D, 0x7B, 0x07, 0x9E, 0x29, 0x8A, 0x6C, 0xC7, 0x4D, 0x10,         // 23
    0x35, 0xF9, 0x05, 0xD7, 0x68, 0xE4, 0x7B, 0x34, 0x98, 0x82, 
    0xD1, 0x11, 0x9F, 0x4B, 0xF1, 0x5D, 0x8D, 0xED, 0x4A, 0xD8, 
    0x36, 0xA1, 0x65, 0xEC, 0x84, 0x6B, 0x98, 0xF1, 0x3D, 0x8E, 
    0x51, 0xAF, 0x31, 0x67, 0xFB, 0x84, 0xC1, 0x0D, 0x32, 0x99, 
    0xD0, 0x7F, 0x35, 0xC0, 0xE2, 0x8A, 0x48, 0xF7, 0x17, 0x86, 
    0xBA, 0xD6, 0x7E, 0xF0, 0x67, 0xE2, 0x8F, 0x63, 0xB8, 0x56, 
    0xEB, 0x87, 0x0C, 0x3C, 0xC8, 0x33, 0x77, 0xFC, 0x54, 0x8A, 
    0x04, 0xA0, 0x7A, 0x2C, 0x97, 0xDE, 0xB9, 0x78, 0x47, 0xC9, 0xEC, 

    0x1D, 0xB4, 0xF7, 0x44, 0xC9, 0xE9, 0x39, 0x25, 0xA7, 0x72,         // 24
    0xBC, 0x56, 0xA8, 0x40, 0x95, 0x14, 0xAA, 0x54, 0xDC, 0x25, 
    0x60, 0xFB, 0x88, 0x75, 0x2E, 0xB2, 0x3C, 0x73, 0xC5, 0x0D, 
    0x79, 0x53, 0xCB, 0x2E, 0x41, 0xC2, 0x4E, 0x05, 0xB8, 0xDA, 
    0x10, 0xEF, 0x87, 0x3F, 0xB8, 0x17, 0x6F, 0xA0, 0xF5, 0x4F, 
    0x06, 0xEC, 0x93, 0x12, 0x77, 0x31, 0xD2, 0x63, 0xB2, 0x71, 
    0x08, 0x4E, 0xAB, 0x3D, 0x97, 0x0E, 0xCD, 0x1E, 0xDB, 0x9D, 
    0x19, 0x65, 0xBA, 0x9C, 0xE4, 0x8E, 0xAF, 0x2B, 0x18, 0xC3, 
    0x45, 0xDA, 0x1D, 0xFA, 0x5D, 0x16, 0x37, 0xD2, 0x11, 0x9F, 0x6A, 

    0xE2, 0x4E, 0x91, 0x19, 0x76, 0x51, 0xB3, 0xFD, 0x81, 0xD7,         // 25
    0x17, 0xE0, 0x85, 0x1F, 0xCB, 0x5F, 0xF3, 0x09, 0xBD, 0x74, 
    0xA6, 0x32, 0xC1, 0x04, 0xCD, 0xE3, 0x13, 0x9D, 0x30, 0xB1, 
    0x8F, 0xF4, 0x06, 0x9A, 0xDF, 0x17, 0xEA, 0x81, 0x9E, 0x2B, 
    0x7E, 0xC0, 0x19, 0xD9, 0x92, 0x50, 0xE4, 0x3E, 0xBD, 0x79, 
    0xAE, 0x2B, 0xC9, 0x52, 0xF3, 0xAD, 0x0C, 0x98, 0x3F, 0xCB, 
    0xF1, 0x92, 0x1B, 0xD0, 0x27, 0xBC, 0x4C, 0x85, 0x2F, 0x45, 
    0xC4, 0xF8, 0x4C, 0x23, 0x5D, 0x04, 0x44, 0xD5, 0x98, 0xEA, 
    0x70, 0xB4, 0x50, 0x86, 0xC8, 0xA4, 0x8C, 0x6B, 0xFC, 0x2D, 0x87, 

    0x39, 0xD0, 0x70, 0xDD, 0xBC, 0x09, 0x90, 0x14, 0x58, 0x3E,         // 26
    0x9C, 0x69, 0x4B, 0xEB, 0xB5, 0x28, 0x82, 0x9E, 0x41, 0xEC, 
    0x0D, 0x55, 0xE1, 0x42, 0x90, 0x60, 0x7F, 0xFB, 0x59, 0xE1, 
    0x26, 0x45, 0xB7, 0x6A, 0x88, 0xB3, 0x66, 0x22, 0x55, 0xFB, 
    0x6A, 0x49, 0xA2, 0x59, 0x22, 0xCD, 0x2A, 0x88, 0x1B, 0x5B, 
    0xDD, 0x44, 0x71, 0xA0, 0x28, 0x5B, 0x7E, 0xEB, 0x1E, 0x57, 
    0x2E, 0x6B, 0xE5, 0x5F, 0x7F, 0xF8, 0x6A, 0xAE, 0xE9, 0x70, 
    0x91, 0x08, 0x80, 0xDA, 0x73, 0xF1, 0xBE, 0x7B, 0x5E, 0x38, 
    0x11, 0x90, 0xE1, 0x07, 0x3C, 0xEF, 0x4F, 0x1D, 0xA9, 0x52, 0xC3, 

    0xA0, 0x15, 0x5A, 0x2F, 0x98, 0xE7, 0x62, 0xCD, 0xAF, 0xEF,         // 27
    0x2A, 0xC5, 0x0F, 0x93, 0x6F, 0x46, 0xD5, 0x58, 0x1B, 0xCD, 
    0x8A, 0xB7, 0x6F, 0xA2, 0x29, 0xBF, 0x47, 0xA9, 0x00, 0x73, 
    0xC7, 0x86, 0xE8, 0x13, 0x56, 0x2F, 0xD6, 0xA8, 0xC8, 0x37, 
    0xD1, 0x04, 0xE2, 0x73, 0xF7, 0x9A, 0x66, 0xC7, 0xF1, 0x99, 
    0x11, 0x87, 0xEE, 0x03, 0xD2, 0xB6, 0x39, 0xBF, 0xD9, 0x89, 
    0xA2, 0xC3, 0x0E, 0xB7, 0x30, 0x9D, 0x43, 0x04, 0xC7, 0x24, 
    0xAC, 0x3B, 0xC9, 0xB0, 0x37, 0xA2, 0x4C, 0x0E, 0xF8, 0xB0, 
    0xD1, 0x2C, 0x64, 0xC1, 0x7D, 0x24, 0xB2, 0xD5, 0x79, 0xE6, 0x0A, 

    0xBC, 0x82, 0xFA, 0xAD, 0x4B, 0x27, 0x7B, 0x3B, 0x1F, 0x8E,         // 28
    0x75, 0xE2, 0xB0, 0x32, 0xF7, 0x02, 0xAD, 0xE7, 0x95, 0x67, 
    0x3B, 0xEF, 0x1D, 0x51, 0xF3, 0x10, 0xDB, 0x39, 0xD4, 0x98, 
    0x17, 0x54, 0x34, 0xCE, 0xA5, 0xF8, 0x46, 0x6F, 0x12, 0x85, 
    0xAB, 0x8E, 0x2E, 0xB3, 0x0D, 0x40, 0xAF, 0x01, 0x77, 0x47, 
    0xCE, 0xB5, 0x37, 0x65, 0x82, 0xF9, 0x12, 0x72, 0x5E, 0x00, 
    0xFC, 0x42, 0x86, 0x4F, 0xEC, 0x17, 0xD6, 0x8B, 0x5C, 0xF0, 
    0x52, 0xE1, 0x63, 0x12, 0x8C, 0x25, 0xE4, 0x94, 0x26, 0x84, 
    0x48, 0xA8, 0xF4, 0x4B, 0xA2, 0xE5, 0x5E, 0x03, 0x34, 0x91, 0x64, 

    0x26, 0x3E, 0xC9, 0x00, 0x89, 0xBD, 0xF6, 0x9E, 0xD6, 0x5E,         // 29
    0x04, 0x41, 0x7F, 0x5A, 0xCB, 0x88, 0x2E, 0x75, 0x25, 0xC0, 
    0x12, 0x83, 0xAD, 0xD4, 0x76, 0xB0, 0x6B, 0x89, 0x25, 0x5F, 
    0xF1, 0xAA, 0x72, 0x93, 0x20, 0x80, 0x02, 0x94, 0xEC, 0x61, 
    0x20, 0xF4, 0x7B, 0x5E, 0xC8, 0x86, 0x59, 0xE5, 0x35, 0xA6, 
    0x6F, 0x24, 0xE3, 0xA8, 0x19, 0x54, 0x90, 0xA5, 0x40, 0xB6, 
    0x78, 0x1F, 0xDC, 0x97, 0x6A, 0xB1, 0x76, 0x26, 0xA4, 0x0D, 
    0x7C, 0x31, 0x98, 0xFE, 0x52, 0xBC, 0x64, 0xCC, 0x58, 0xDD, 
    0x6D, 0x13, 0x8D, 0x1D, 0x75, 0x3A, 0xCA, 0x9A, 0xF6, 0x4B, 0xCF, 

    0xED, 0x9B, 0x5C, 0x73, 0xDC, 0x1B, 0x69, 0x0D, 0x4A, 0xB9,         // 30
    0xFB, 0xA3, 0xD4, 0x25, 0x9F, 0x53, 0xC3, 0x49, 0xF5, 0xA1, 
    0xDC, 0x63, 0x42, 0x03, 0x90, 0x22, 0x4E, 0xF7, 0xA2, 0xBE, 
    0x40, 0xD1, 0x07, 0xEC, 0x50, 0xC8, 0xE1, 0xB8, 0x3A, 0xD5, 
    0x4B, 0xBF, 0x35, 0xDF, 0x16, 0xF1, 0x20, 0xBB, 0xD3, 0x1A, 
    0xFE, 0x5D, 0x8F, 0x45, 0xCD, 0xB4, 0x2A, 0xEC, 0xCC, 0x26, 
    0xE3, 0x5D, 0xC5, 0x05, 0x49, 0xE1, 0x35, 0xFB, 0xC0, 0x8F, 
    0xD7, 0xB7, 0x1A, 0x71, 0xCD, 0x01, 0x7A, 0x3A, 0xA4, 0x0B, 
    0xC2, 0xE9, 0x37, 0xD3, 0xB5, 0x16, 0x87, 0x65, 0xB7, 0x1C, 0x72, 

    0x52, 0x19, 0xE7, 0x29, 0x9F, 0x55, 0xC7, 0x81, 0xE5, 0x92,         // 31
    0x2D, 0x61, 0x13, 0xE8, 0x72, 0x0F, 0xD8, 0x93, 0x07, 0x57, 
    0x33, 0x99, 0xFE, 0xBB, 0x5A, 0xE8, 0xC2, 0x0A, 0x36, 0x6E, 
    0x13, 0x84, 0x5D, 0xB5, 0x2E, 0x69, 0x26, 0x7B, 0x17, 0xAD, 
    0x74, 0x08, 0x9B, 0x4D, 0xA9, 0x6B, 0x95, 0x4A, 0x81, 0x55, 
    0x99, 0x08, 0xDA, 0x74, 0x32, 0xE5, 0x6A, 0x0F, 0x85, 0x52, 
    0xAA, 0x90, 0x3B, 0xA2, 0xCA, 0x13, 0x92, 0x5A, 0x41, 0x6D, 
    0x21, 0x5C, 0xEA, 0xA6, 0x35, 0xEF, 0xB3, 0x1D, 0xF6, 0x41, 
    0x7D, 0x52, 0x9B, 0x62, 0xFE, 0x50, 0xE7, 0x10, 0x41, 0xDA, 0xAC, 

    0x87, 0xC6, 0x7D, 0xB7, 0x3D, 0xF2, 0x30, 0xA7, 0x3F, 0x11,         // 32
    0x78, 0xC2, 0x90, 0x40, 0xAA, 0xFA, 0x38, 0x68, 0xBD, 0x7D, 
    0xCE, 0x11, 0x77, 0x27, 0xD2, 0x30, 0x96, 0x79, 0xE1, 0xC8, 
    0x96, 0xFC, 0x39, 0xD7, 0x8C, 0xA8, 0x49, 0x9A, 0xFE, 0x58, 
    0x93, 0xED, 0xCE, 0x84, 0x30, 0xD7, 0x27, 0xAE, 0x0F, 0xEA, 
    0xB7, 0x3B, 0xBE, 0x17, 0x9D, 0x7D, 0x49, 0xC6, 0x36, 0xF3, 
    0x0A, 0x73, 0x25, 0xF8, 0x84, 0x67, 0xAB, 0xD3, 0x2A, 0xC7, 
    0xE4, 0x3F, 0x8B, 0x0F, 0x4C, 0x80, 0x96, 0xD6, 0x69, 0x91, 
    0xB7, 0x20, 0xCA, 0x03, 0x8C, 0x28, 0xA0, 0xC8, 0x7C, 0x95, 0x0D, 

    0xFC, 0x45, 0x0A, 0xD8, 0x6B, 0x8F, 0x04, 0xD1, 0x64, 0xB4,         // 33
    0xE9, 0x4D, 0xD0, 0x67, 0x1E, 0x88, 0xB3, 0x1A, 0xF0, 0x26, 
    0xA7, 0xE8, 0x3F, 0x8B, 0xA5, 0x6D, 0x45, 0xB1, 0x59, 0x1C, 
    0x49, 0xAA, 0x21, 0x79, 0x0D, 0xF2, 0xD1, 0x09, 0x40, 0xBB, 
    0x21, 0x3A, 0x5A, 0x10, 0xC1, 0x53, 0xF8, 0x73, 0xC8, 0x35, 
    0x7C, 0x64, 0xF5, 0x54, 0xD6, 0x02, 0xF0, 0xAC, 0x98, 0x62, 
    0xD0, 0xB0, 0xD9, 0x5B, 0x3F, 0x23, 0xEA, 0x0F, 0x84, 0x9C, 
    0x07, 0xAD, 0x69, 0xDB, 0xC3, 0x60, 0x24, 0x4F, 0x07, 0xDE, 
    0x30, 0xF3, 0x6D, 0xB0, 0x58, 0xDA, 0x70, 0x4D, 0x23, 0xE2, 0x35, 

    0x70, 0x9D, 0x60, 0xAF, 0x19, 0xE0, 0x58, 0x7B, 0xF4, 0x1F,         // 34
    0x98, 0x33, 0x01, 0xEE, 0xBC, 0x4B, 0x74, 0xD9, 0x40, 0x93, 
    0x4D, 0x6F, 0xB6, 0x18, 0xF6, 0x07, 0xD9, 0x29, 0xF4, 0x7F, 
    0xD3, 0x64, 0xE8, 0xC1, 0x52, 0x6D, 0xB7, 0x65, 0xE1, 0x7E, 
    0xD2, 0x6E, 0xAE, 0xF4, 0x7C, 0xA1, 0x03, 0x47, 0x8F, 0xDF, 
    0x1F, 0xAC, 0x8E, 0x28, 0xA6, 0x88, 0x2D, 0x55, 0x13, 0x7F, 
    0x2E, 0x50, 0x16, 0x96, 0xE4, 0xBC, 0x76, 0x52, 0xF1, 0x48, 
    0x7A, 0xFA, 0x22, 0x9A, 0x32, 0xE9, 0xAD, 0xC8, 0x7C, 0xA2, 
    0x49, 0x87, 0x17, 0xE5, 0x2E, 0xBF, 0x09, 0xF7, 0xA7, 0x5F, 0xBC, 

    0xD8, 0x3A, 0xEF, 0x2E, 0x9A, 0x43, 0xBC, 0x9F, 0x38, 0x54,         // 35
    0xD5, 0x77, 0xAF, 0x83, 0x29, 0xCF, 0x08, 0xA1, 0x61, 0xC3, 
    0x00, 0xD9, 0x5B, 0xC9, 0x83, 0x60, 0xBA, 0x90, 0x0F, 0xA0, 
    0x3B, 0x01, 0x8E, 0x40, 0xA2, 0x2A, 0x8F, 0x1E, 0xA3, 0x36, 
    0x01, 0xE5, 0x8C, 0x20, 0x3B, 0x61, 0xE6, 0xB0, 0x26, 0x58, 
    0xBF, 0x05, 0x46, 0xEA, 0x5F, 0xCE, 0x6E, 0xBE, 0xDF, 0xB4, 
    0xF7, 0x8B, 0xBF, 0x6B, 0x0B, 0x9F, 0x32, 0xC8, 0xA5, 0x2B, 
    0xC0, 0x60, 0xB4, 0x51, 0x83, 0x19, 0x6C, 0x3C, 0xFA, 0x1E, 
    0xBD, 0xD8, 0x53, 0x97, 0x79, 0x3E, 0x8F, 0xCE, 0x33, 0x8D, 0x02, 

    0xA5, 0x21, 0x84, 0xC4, 0x76, 0xFB, 0x2A, 0x10, 0xCA, 0x8C,         // 36
    0x0D, 0xFE, 0x5A, 0x3B, 0xE1, 0x8F, 0x53, 0xEC, 0x2A, 0x85, 
    0xFA, 0x34, 0x9A, 0x49, 0x27, 0xEB, 0x32, 0x4D, 0x6B, 0xEC, 
    0xBF, 0x73, 0xDA, 0x19, 0xEF, 0xCB, 0x4A, 0xF7, 0x59, 0xC7, 
    0x98, 0x5D, 0x45, 0xC7, 0xDC, 0x91, 0x1B, 0xCF, 0x6B, 0xFB, 
    0x87, 0xDB, 0x71, 0xC3, 0x11, 0x3D, 0xFC, 0x1D, 0x38, 0x76, 
    0x04, 0x3F, 0xEB, 0x29, 0xD5, 0x5A, 0x8C, 0x04, 0x6B, 0xDF, 
    0x11, 0x3B, 0xE2, 0x02, 0xF1, 0xA1, 0xD9, 0x0D, 0x95, 0x5C, 
    0x78, 0x34, 0xAE, 0x0E, 0xF3, 0xA9, 0x5D, 0x14, 0x78, 0xF0, 0x56, 

    0xCD, 0x65, 0xDF, 0x4B, 0x14, 0x5D, 0x86, 0xDA, 0x69, 0xB4,         // 37
    0x61, 0xC2, 0x16, 0xA0, 0x6F, 0x19, 0xAE, 0x78, 0xD4, 0x19, 
    0xA9, 0x7D, 0x0D, 0xE2, 0xA3, 0x78, 0xD0, 0xA8, 0xD8, 0x17, 
    0x94, 0x28, 0xAB, 0x61, 0x86, 0x05, 0x75, 0xBB, 0x10, 0x80, 
    0xEF, 0x16, 0xA6, 0x75, 0x0B, 0xB6, 0x77, 0x37, 0xA3, 0x0E, 
    0x4F, 0x31, 0x9C, 0x24, 0xB2, 0x7D, 0xA7, 0x8D, 0x5C, 0xA3, 
    0xD8, 0x62, 0xA1, 0x7C, 0xAE, 0x38, 0xFD, 0xCF, 0x4D, 0x83, 
    0x9F, 0xD1, 0x94, 0x78, 0xC6, 0x42, 0x80, 0x55, 0xE7, 0xC8, 
    0x00, 0xEB, 0x62, 0xD0, 0x4B, 0x21, 0xE1, 0xC5, 0x4A, 0xB3, 0x17, 

    0x41, 0x96, 0x08, 0xA9, 0xE7, 0xC2, 0xA4, 0x47, 0xE9, 0x2B,         // 38
    0x41, 0x91, 0xE4, 0x50, 0xB8, 0xF6, 0x31, 0x43, 0x98, 0x63, 
    0x47, 0xD1, 0x67, 0xBD, 0x1A, 0x5A, 0x04, 0x86, 0x2F, 0x65, 
    0x43, 0xE7, 0x51, 0xC2, 0x34, 0xDE, 0x9B, 0x40, 0xDB, 0x2F, 
    0x6D, 0xBE, 0x3A, 0xFC, 0x57, 0x2F, 0xF0, 0x53, 0x8B, 0xD2, 
    0xAF, 0x7A, 0xF5, 0x64, 0xD4, 0x51, 0x06, 0xC9, 0xE6, 0x48, 
    0x24, 0xC7, 0x14, 0x49, 0xDE, 0x74, 0x19, 0xB0, 0x23, 0xF1, 
    0x46, 0x6E, 0x24, 0x35, 0x63, 0x13, 0xC0, 0x2B, 0xAB, 0x40, 
    0x8B, 0xA0, 0x26, 0x73, 0xC3, 0x87, 0x67, 0x94, 0x28, 0xE3, 0x83, 

    0xF9, 0xC0, 0x77, 0x29, 0x8B, 0x37, 0x01, 0x75, 0x1C, 0x9F,         // 39
    0xF2, 0x71, 0x25, 0xD2, 0x0B, 0x68, 0xD9, 0xB3, 0x07, 0xF2, 
    0xB8, 0x1E, 0xED, 0x36, 0x8E, 0xF3, 0xC5, 0x48, 0xFC, 0xB1, 
    0xCC, 0x80, 0x09, 0xFA, 0x6E, 0xA9, 0x14, 0x62, 0x8C, 0xAB, 
    0x4D, 0xDE, 0x23, 0x84, 0xD1, 0x96, 0xC3, 0x16, 0xE3, 0x3E, 
    0x24, 0xC6, 0x0A, 0x43, 0x88, 0xEF, 0x34, 0x78, 0x16, 0xB3, 
    0x89, 0x6D, 0xF2, 0x91, 0x09, 0xC3, 0x52, 0x9A, 0x66, 0xB8, 
    0x15, 0xC7, 0xE6, 0xAB, 0xF7, 0x9A, 0xD7, 0x89, 0x64, 0x1F, 
    0xDB, 0x4F, 0xF6, 0xAA, 0x06, 0x43, 0xFC, 0x0F, 0xA5, 0x5C, 0x31, 

    0x16, 0x51, 0xEA, 0x64, 0xD3, 0x57, 0xEE, 0xB2, 0xCF, 0x84,         // 40
    0x06, 0xBF, 0x39, 0x7E, 0x9D, 0x2B, 0x88, 0x59, 0xCE, 0x76, 
    0x30, 0x9E, 0x80, 0x55, 0xB4, 0x3D, 0x6D, 0xA2, 0x14, 0x77, 
    0x1D, 0xA5, 0x3D, 0x97, 0x1D, 0x54, 0xEE, 0xCA, 0x29, 0xF9, 
    0x05, 0x99, 0x62, 0xB2, 0x3F, 0x07, 0x7A, 0xAA, 0x63, 0x84, 
    0xEB, 0x57, 0xAA, 0xDD, 0x29, 0xBC, 0x9D, 0x60, 0xF8, 0x39, 
    0xDF, 0x4E, 0xB6, 0x2C, 0x66, 0xEA, 0x84, 0x36, 0xE2, 0x2F, 
    0x8E, 0x5D, 0x07, 0x81, 0x50, 0x37, 0x6D, 0x09, 0xFD, 0xC3, 
    0x71, 0x10, 0x85, 0x36, 0xDC, 0x99, 0xBB, 0x3A, 0x79, 0xD8, 0xB2, 

    0x88, 0xA1, 0x3B, 0xB7, 0x15, 0x9B, 0x7C, 0x4D, 0x33, 0x65,         // 41
    0xDC, 0x58, 0xA7, 0xFA, 0x45, 0xBF, 0xF0, 0x20, 0x3E, 0x94, 
    0x51, 0xCA, 0x02, 0xD5, 0x26, 0xE1, 0x0C, 0x8C, 0xDB, 0x4F, 
    0xED, 0x5A, 0xDD, 0xB9, 0x81, 0xC1, 0x24, 0x77, 0xB6, 0x5C, 
    0x7D, 0xCC, 0x14, 0xE6, 0x6B, 0xF5, 0x4D, 0x29, 0xCD, 0x00, 
    0x9E, 0x70, 0x17, 0x92, 0x6B, 0x14, 0x42, 0xD1, 0xA7, 0x7D, 
    0x02, 0x9A, 0x3D, 0xD5, 0xA3, 0x41, 0xB6, 0x00, 0xCC, 0x73, 
    0xFA, 0xA3, 0x41, 0xBD, 0xDC, 0x24, 0xE8, 0xB8, 0x52, 0x99, 
    0x2F, 0xB5, 0xCF, 0x58, 0x78, 0x27, 0x53, 0xE9, 0xC5, 0x03, 0x69, 

    0x28, 0xDD, 0x06, 0x85, 0xF6, 0x2B, 0xCB, 0x0B, 0xFC, 0xB9,         // 42
    0x21, 0x96, 0x12, 0xCA, 0x5D, 0x05, 0x7D, 0xA6, 0xE3, 0xBD, 
    0x17, 0xFE, 0x61, 0x99, 0x78, 0xAC, 0x5A, 0xB9, 0x37, 0xC4, 
    0x26, 0x93, 0x13, 0x62, 0x38, 0xD8, 0x48, 0xA0, 0x0F, 0xD7, 
    0x45, 0xA8, 0x35, 0x87, 0x25, 0xCA, 0xB4, 0x8E, 0xF0, 0x50, 
    0x34, 0xC1, 0xFD, 0x4A, 0xC9, 0xEC, 0x81, 0x0D, 0x56, 0x2C, 
    0xCB, 0x63, 0xFB, 0x0D, 0x7F, 0x21, 0xF6, 0x6A, 0xA6, 0x4D, 
    0x11, 0xD0, 0x75, 0x1A, 0x94, 0x79, 0xA8, 0x3C, 0x1C, 0x7A, 
    0xE2, 0x45, 0x92, 0x1A, 0xF3, 0xAF, 0x8D, 0x21, 0x5A, 0x96, 0xF1, 

    0xB4, 0x60, 0xC5, 0x49, 0x6C, 0xAD, 0x5E, 0x8B, 0xA3, 0x39,         // 43
    0x7D, 0xEC, 0x3D, 0x76, 0x92, 0xE8, 0x3A, 0x68, 0x0D, 0x5C, 
    0x81, 0xA4, 0x2F, 0xE5, 0x16, 0x41, 0xF8, 0x22, 0x82, 0x65, 
    0xAB, 0x74, 0xC9, 0xF0, 0x00, 0x8F, 0x66, 0xF5, 0x39, 0x8A, 
    0x19, 0xF3, 0x58, 0xD5, 0x97, 0x42, 0x0E, 0x5C, 0x7C, 0xB1, 
    0xE1, 0x1E, 0x79, 0x2D, 0x9F, 0x52, 0xB4, 0xDB, 0x95, 0xED, 
    0xB4, 0x19, 0x75, 0xBF, 0x56, 0xD2, 0x8A, 0x45, 0x22, 0xC4, 
    0x85, 0x2A, 0xE9, 0x56, 0xC7, 0x04, 0x5D, 0x89, 0xF0, 0xC8, 
    0x61, 0x03, 0xEA, 0xB7, 0x64, 0x08, 0xD2, 0x71, 0xAB, 0x35, 0x4A, 

    0x76, 0x1F, 0x94, 0xE5, 0x33, 0xD6, 0x22, 0xDF, 0x13, 0x5B,         // 44
    0xCA, 0x51, 0xB0, 0x28, 0xD3, 0x1D, 0xB5, 0xD7, 0x92, 0xEF, 
    0x36, 0xC5, 0x7C, 0x53, 0xBF, 0x8F, 0x67, 0xC8, 0xE0, 0x12, 
    0xF4, 0x2D, 0x42, 0x83, 0xA9, 0xDF, 0x1B, 0xC6, 0x71, 0xDE, 
    0x9B, 0x6E, 0xB2, 0x02, 0x74, 0xA6, 0xE1, 0xC3, 0x15, 0x3F, 
    0x66, 0x94, 0xB7, 0xD8, 0x0B, 0x72, 0x3A, 0x1E, 0x6A, 0x45, 
    0x85, 0x35, 0xE3, 0x95, 0x28, 0xAA, 0x13, 0xDC, 0x93, 0xF0, 
    0x5F, 0xAB, 0x3A, 0xB0, 0xF9, 0x46, 0xDB, 0xBE, 0x10, 0x49, 
    0xA2, 0x84, 0x2D, 0x4F, 0xD9, 0x83, 0x44, 0xF6, 0x19, 0xE2, 0xCC, 

    0xA6, 0xFE, 0x57, 0x15, 0xA0, 0x7D, 0x42, 0xBB, 0x72, 0xF1,         // 45
    0x91, 0x01, 0xDB, 0x62, 0x9C, 0x4C, 0x81, 0x57, 0x2A, 0xCB, 
    0x4E, 0x1E, 0xEC, 0x09, 0xDB, 0x2B, 0xA6, 0x01, 0x49, 0x9D, 
    0x5B, 0xD6, 0xB1, 0x5E, 0x26, 0x3F, 0x9B, 0x4F, 0x06, 0xB8, 
    0x24, 0x43, 0xE3, 0x51, 0xF7, 0x21, 0x6A, 0x31, 0xF9, 0xA0, 
    0xD2, 0x06, 0x5A, 0x40, 0xF1, 0x8E, 0xBE, 0xF8, 0xAA, 0x08, 
    0xDC, 0xA0, 0x4D, 0x6A, 0xF1, 0x3F, 0x60, 0xB8, 0x77, 0x31, 
    0x05, 0xD9, 0x8A, 0x11, 0x74, 0xAB, 0x35, 0x69, 0x9B, 0x29, 
    0xED, 0xC3, 0x72, 0xA7, 0x36, 0x9E, 0x13, 0xB5, 0x86, 0x65, 0x0D, 

    0x80, 0x3A, 0xD2, 0x72, 0xC0, 0x0C, 0xF7, 0x85, 0x4E, 0x26,         // 46
    0xC2, 0x44, 0x7F, 0xF8, 0x11, 0xC5, 0xF2, 0x03, 0xAA, 0x6D, 
    0x8C, 0xB2, 0x66, 0xA2, 0x87, 0x5A, 0xF0, 0x72, 0x86, 0xBF, 
    0x1C, 0x8C, 0x09, 0xC5, 0xFE, 0x6F, 0xBF, 0x85, 0xEB, 0x5B, 
    0x82, 0xCA, 0x2D, 0x90, 0xBF, 0x47, 0x88, 0xAE, 0x52, 0x82, 
    0x33, 0xE8, 0x86, 0xA2, 0xC6, 0x1B, 0x57, 0x29, 0x74, 0xC6, 
    0x59, 0x24, 0xCF, 0x03, 0xBD, 0x82, 0xEA, 0x0B, 0x53, 0xC1, 
    0xA0, 0x6E, 0x4B, 0xE2, 0x2C, 0x93, 0x18, 0xF5, 0x7D, 0xB7, 
    0x5C, 0x12, 0xDE, 0x1C, 0xFD, 0x62, 0xCC, 0x50, 0x27, 0xC1, 0x44, 

    0xEC, 0x00, 0xAB, 0x29, 0xEB, 0x55, 0x98, 0x1C, 0xAB, 0xE1,         // 47
    0x6A, 0xA7, 0x1C, 0xB9, 0x36, 0x6D, 0x43, 0x95, 0xDD, 0x24, 
    0xF4, 0x0D, 0xCC, 0x49, 0x23, 0xB8, 0x3E, 0xCE, 0x25, 0xF9, 
    0x3C, 0xE2, 0x75, 0x49, 0x9F, 0x12, 0xE1, 0x42, 0x2D, 0x9F, 
    0xFB, 0x0A, 0xA7, 0x67, 0x11, 0xD4, 0xEB, 0x05, 0xCA, 0x20, 
    0x6C, 0xBD, 0x13, 0x35, 0x63, 0xE0, 0x82, 0xD8, 0x93, 0x34, 
    0xF0, 0x7A, 0xA7, 0x3B, 0x91, 0x18, 0x68, 0x9E, 0xE1, 0x3C, 
    0xFE, 0x1C, 0xC9, 0xA7, 0x62, 0xE8, 0xC4, 0x56, 0x09, 0xD2, 
    0x34, 0x9D, 0x42, 0x89, 0xB9, 0x2E, 0x75, 0xEE, 0x9C, 0xD8, 0x94, 

    0x5B, 0xCB, 0x64, 0x8F, 0x3F, 0x7A, 0xD6, 0xC4, 0x45, 0x09,         // 48
    0x8B, 0x31, 0xD3, 0x53, 0x8D, 0xDA, 0xB3, 0x31, 0x60, 0xC0, 
    0x4C, 0x79, 0x31, 0xFB, 0x74, 0xD8, 0x14, 0x9A, 0x6A, 0xA8, 
    0x62, 0x9B, 0x2C, 0xD2, 0x7F, 0x36, 0x60, 0xB0, 0xD8, 0x1D, 
    0x72, 0x56, 0xDA, 0x36, 0x7A, 0xAC, 0x34, 0x73, 0x98, 0xF0, 
    0xA7, 0x4B, 0xFB, 0x77, 0xB4, 0x01, 0x39, 0xA1, 0x12, 0x68, 
    0xB0, 0x16, 0xE4, 0x70, 0xFB, 0xC6, 0x34, 0xD1, 0x21, 0x7E, 
    0x61, 0x97, 0x34, 0x83, 0x02, 0x42, 0x88, 0xAE, 0x3E, 0x91, 
    0xF1, 0x69, 0xCA, 0x57, 0x10, 0xE3, 0x91, 0x05, 0x39, 0x6F, 0x1F, 

    0xBC, 0x86, 0x1A, 0xE0, 0xBA, 0x05, 0x33, 0x63, 0x7E, 0xFB,         // 49
    0xC5, 0x60, 0xEF, 0x9F, 0x08, 0x7C, 0x1F, 0xEB, 0x83, 0x14, 
    0x9E, 0xDE, 0x94, 0xB0, 0x06, 0x90, 0x55, 0xED, 0x37, 0x05, 
    0xCD, 0x50, 0xEF, 0x0D, 0xB7, 0xF2, 0x91, 0x07, 0x7E, 0xC5, 
    0x39, 0x8F, 0xB9, 0xEF, 0x99, 0x1D, 0x58, 0xD0, 0x40, 0x65, 
    0x17, 0x8D, 0xD3, 0x22, 0x97, 0xEA, 0x4D, 0xBB, 0xFA, 0x50, 
    0xD4, 0x95, 0x5E, 0x1D, 0x4C, 0xA9, 0x77, 0x51, 0x92, 0xBB, 
    0x08, 0xE3, 0x53, 0xF3, 0xB4, 0xCF, 0x1D, 0x70, 0xE0, 0x1F, 
    0x7F, 0x00, 0xE5, 0xAC, 0x79, 0x47, 0xBD, 0x5E, 0xAF, 0xE6, 0x3F, 

    0x10, 0xFA, 0x35, 0x9E, 0x5C, 0xF6, 0xA4, 0xDC, 0x18, 0x95,         // 50
    0x3E, 0x0F, 0x76, 0x2D, 0xB7, 0xFD, 0x69, 0x4B, 0xA6, 0xD0, 
    0x37, 0x53, 0x1A, 0x62, 0xE3, 0x44, 0xC6, 0x7E, 0xB5, 0xE4, 
    0x8C, 0x19, 0xAB, 0x6E, 0x53, 0x20, 0xDB, 0x67, 0x47, 0xA2, 
    0xE7, 0x19, 0x50, 0x26, 0x63, 0xBF, 0xFE, 0x85, 0x0F, 0xB7, 
    0xDE, 0x38, 0x60, 0xC4, 0x44, 0x69, 0xD0, 0x72, 0x2D, 0x86, 
    0x08, 0x43, 0xB5, 0xDC, 0x8E, 0x2B, 0xE7, 0x0D, 0xF4, 0x43, 
    0xCF, 0xAE, 0x16, 0x77, 0x28, 0x65, 0xFC, 0x45, 0xC5, 0xA4, 
    0x50, 0xB9, 0x3D, 0x20, 0x9E, 0xD4, 0x2C, 0xF9, 0x1A, 0x7D, 0xA1, 

    0x53, 0x72, 0xD0, 0x49, 0x80, 0x29, 0x8C, 0x47, 0xAE, 0x59,         // 51
    0xB2, 0xE8, 0x90, 0xCC, 0x41, 0x15, 0x97, 0xBE, 0x05, 0x6E, 
    0xF8, 0xB3, 0x7F, 0xCA, 0x36, 0xA5, 0x18, 0x5E, 0x24, 0x4B, 
    0x75, 0xC5, 0x33, 0x88, 0xCE, 0xA4, 0x33, 0xC1, 0xF8, 0x0F, 
    0x87, 0xD2, 0xAB, 0x80, 0xD6, 0x03, 0x46, 0xA5, 0xE6, 0x2E, 
    0x79, 0xA3, 0x06, 0x82, 0xF5, 0x18, 0x8C, 0x0C, 0xA5, 0xC5, 
    0xEA, 0x79, 0x2F, 0xC5, 0x05, 0x7E, 0xCB, 0x5F, 0xA8, 0x75, 
    0x2D, 0x64, 0x9C, 0xD7, 0x49, 0x90, 0xA6, 0x0C, 0x87, 0x2D, 
    0xF8, 0x6C, 0x8B, 0xEF, 0x64, 0x0A, 0x89, 0x6D, 0xCA, 0x47, 0xDC, 

    0x92, 0x25, 0xAC, 0x0E, 0xBF, 0xD3, 0x15, 0x74, 0xF0, 0x2C,         // 52
    0xD9, 0x1D, 0x4A, 0x6E, 0xE5, 0x5F, 0xD5, 0x3F, 0xE5, 0x2B, 
    0x8A, 0x0B, 0xEB, 0x28, 0x75, 0xF3, 0x87, 0xD1, 0xFC, 0xA9, 
    0x2C, 0xDE, 0x5E, 0xF9, 0x04, 0x4D, 0x74, 0x94, 0x2D, 0x59, 
    0x72, 0x3B, 0x11, 0xF5, 0x37, 0x95, 0x74, 0x20, 0x5D, 0xCD, 
    0x4C, 0xF2, 0xBA, 0x3B, 0x9E, 0x32, 0xB9, 0xE6, 0x3D, 0x61, 
    0x21, 0x9B, 0xF7, 0x54, 0xA3, 0x40, 0xB3, 0x22, 0x87, 0x11, 
    0xEF, 0x8D, 0x36, 0xB9, 0xEC, 0x17, 0xCE, 0x56, 0xE8, 0x63, 
    0x0E, 0xC3, 0x33, 0xCA, 0x43, 0xE0, 0xB1, 0x33, 0x98, 0x03, 0xBA, 

    0x79, 0xE9, 0x5F, 0xF4, 0x6B, 0x38, 0xE6, 0xB4, 0x01, 0x8E,         // 53
    0x65, 0x9E, 0xC7, 0x06, 0xAC, 0x8F, 0x24, 0x7B, 0x9C, 0x5F, 
    0xBC, 0x56, 0x9F, 0x4C, 0xBA, 0x01, 0x47, 0x9D, 0x11, 0x65, 
    0x94, 0x0B, 0xB3, 0x3A, 0x91, 0xEB, 0xB5, 0x18, 0xDF, 0xAA, 
    0xEE, 0xC7, 0x60, 0xA1, 0x6A, 0xC5, 0xEA, 0xB4, 0x88, 0x09, 
    0x99, 0x31, 0x71, 0xE0, 0x5B, 0xD4, 0x6E, 0x51, 0x8F, 0xD9, 
    0xB1, 0x47, 0x11, 0x76, 0xDE, 0x6C, 0xFA, 0x38, 0xDA, 0xBE, 
    0x4E, 0xD2, 0x04, 0x5D, 0x88, 0x30, 0x70, 0xB0, 0x3B, 0x98, 
    0xDB, 0xA4, 0x19, 0x70, 0x95, 0x16, 0x4E, 0xF2, 0x5E, 0xE7, 0x2E, 

    0xC0, 0x0A, 0x99, 0x27, 0x8A, 0xAA, 0x4F, 0x67, 0xCA, 0x40,         // 54
    0xBE, 0x31, 0x85, 0xF7, 0x56, 0x36, 0xC0, 0xF4, 0x19, 0xDB, 
    0x33, 0xCC, 0x13, 0x8C, 0xDC, 0x69, 0xC4, 0x77, 0x3F, 0xC1, 
    0xEA, 0x54, 0x7E, 0xC9, 0x6B, 0x20, 0xD5, 0x66, 0x8B, 0x39, 
    0x02, 0x94, 0x44, 0xE5, 0x2B, 0x0D, 0x55, 0x39, 0xF7, 0xC1, 
    0x64, 0xD8, 0x10, 0x88, 0x1D, 0xA9, 0x10, 0xFE, 0x30, 0x02, 
    0x6C, 0xCF, 0x90, 0xB9, 0x30, 0x16, 0x8E, 0x57, 0x9D, 0x6B, 
    0x1A, 0xA7, 0x75, 0xDE, 0x44, 0xA0, 0xF4, 0x02, 0xD1, 0x75, 
    0x25, 0x80, 0x58, 0xF6, 0xB6, 0x79, 0xC6, 0x22, 0x7E, 0xA3, 0x4A, 

    0xDC, 0x42, 0xCB, 0x56, 0xBD, 0x09, 0x83, 0x1F, 0xFC, 0x79,         // 55
    0x16, 0xEA, 0x4D, 0x20, 0x78, 0xDF, 0x0C, 0x6F, 0x4A, 0xA3, 
    0x82, 0xE9, 0x70, 0xB2, 0x1B, 0x38, 0xF0, 0x23, 0xD9, 0x8B, 
    0x32, 0xAC, 0x15, 0xE5, 0x30, 0xAF, 0x47, 0x0C, 0xCD, 0x55, 
    0xB9, 0x78, 0x1A, 0xB2, 0x84, 0xDD, 0x9C, 0x6F, 0x29, 0x7E, 
    0x20, 0xAF, 0x50, 0xC7, 0xF0, 0x48, 0x96, 0x79, 0xC5, 0x9E, 
    0xF3, 0x23, 0x5E, 0xEE, 0x50, 0xD7, 0xC1, 0x00, 0xED, 0x30, 
    0x89, 0xF6, 0x2B, 0xBA, 0x12, 0xC6, 0x4F, 0x8E, 0x33, 0xBB, 
    0x46, 0xE6, 0xAE, 0x03, 0x3A, 0xE4, 0x55, 0xAC, 0xD3, 0x14, 0x69, 

    0xAC, 0x21, 0x76, 0xE2, 0x45, 0xEF, 0xD0, 0xA3, 0x46, 0xAE,         // 56
    0xD5, 0x6B, 0xA6, 0xD7, 0xB8, 0x97, 0x51, 0xAE, 0xD0, 0x02, 
    0x67, 0x24, 0x48, 0xFB, 0x5A, 0xA6, 0x82, 0xB0, 0x4F, 0x05, 
    0x6C, 0xF7, 0x4A, 0x9E, 0x5B, 0x81, 0xFD, 0xA1, 0x7B, 0xE6, 
    0x22, 0xFA, 0xCF, 0x65, 0x4A, 0xBE, 0x19, 0xD2, 0xA8, 0xDB, 
    0x46, 0xF4, 0x9F, 0x26, 0x72, 0xBB, 0x2A, 0xDF, 0x58, 0x43, 
    0x88, 0x38, 0xAC, 0x08, 0x82, 0xA1, 0x42, 0x7B, 0xAB, 0x5A, 
    0xC4, 0x3D, 0x92, 0x61, 0xE9, 0x7B, 0x18, 0xE0, 0x5F, 0xF9, 
    0x0E, 0x8F, 0x4D, 0xD1, 0x66, 0x25, 0x96, 0x07, 0x3D, 0xF0, 0x89, 

    0x5A, 0xFE, 0xA4, 0x12, 0x94, 0x31, 0x5D, 0x26, 0x90, 0x0C,         // 57
    0x52, 0x8D, 0x03, 0x43, 0x63, 0x15, 0xF0, 0x80, 0x31, 0xF6, 
    0xBA, 0x9A, 0xC4, 0x2F, 0x7B, 0xE4, 0x14, 0x63, 0xE7, 0xA2, 
    0xC6, 0x1B, 0x89, 0xCF, 0x01, 0xC3, 0x25, 0x4F, 0x30, 0xA9, 
    0x61, 0x3E, 0x9D, 0x06, 0xEC, 0x32, 0x80, 0x51, 0x00, 0x69, 
    0x8E, 0x0C, 0x59, 0x8A, 0x3C, 0xE6, 0x63, 0x0A, 0xB0, 0x1B, 
    0xBF, 0xE2, 0x6F, 0xCB, 0x2A, 0x60, 0xE8, 0x1F, 0xCD, 0x0F, 
    0x70, 0xE2, 0x0A, 0xA8, 0x27, 0x9C, 0x68, 0xB3, 0x1F, 0xA0, 
    0x6F, 0xD9, 0x1F, 0xA1, 0x86, 0xC4, 0xFB, 0x7C, 0x63, 0xBA, 0x29, 

    0x03, 0x7F, 0x36, 0x63, 0xC4, 0x79, 0xB1, 0xDE, 0x71, 0xE7,         // 58
    0xC8, 0x3A, 0xF9, 0xC3, 0x87, 0x38, 0xC9, 0x1E, 0x9F, 0x5B, 
    0x3E, 0x10, 0x88, 0xD5, 0x06, 0x99, 0x3C, 0xBD, 0x1F, 0x7A, 
    0x34, 0xDA, 0x70, 0x3B, 0xED, 0x90, 0x71, 0xE1, 0xC5, 0x08, 
    0x8D, 0xC3, 0x28, 0x89, 0xAC, 0x6B, 0xE1, 0x92, 0xFD, 0xC0, 
    0x37, 0xE4, 0xB5, 0xD3, 0x0F, 0xA6, 0x8D, 0xD4, 0x70, 0xE9, 
    0x7F, 0x50, 0x20, 0x92, 0xF9, 0xBA, 0x37, 0x9B, 0x50, 0xFB, 
    0xAE, 0x4B, 0x7E, 0xD7, 0x51, 0xFD, 0x3E, 0xCB, 0x7E, 0x49, 
    0xBA, 0x32, 0x62, 0xF1, 0x0C, 0x70, 0x2D, 0xD8, 0x9D, 0x43, 0xCE, 

    0x99, 0xE7, 0xB0, 0xD7, 0x21, 0xF7, 0x02, 0x40, 0xB8, 0x5B,         // 59
    0x1A, 0xA1, 0x70, 0x2A, 0xE9, 0xA4, 0x6D, 0x48, 0xE3, 0x76, 
    0xC9, 0xE7, 0x53, 0x6B, 0xB5, 0x4E, 0xCE, 0x89, 0xFE, 0x56, 
    0x94, 0x4E, 0xB8, 0x12, 0xAA, 0x5C, 0x18, 0x9C, 0x58, 0xF4, 
    0x6E, 0xDE, 0x58, 0xF4, 0x40, 0x11, 0xB2, 0x25, 0x4B, 0x17, 
    0x9C, 0x73, 0x1F, 0x68, 0xFA, 0x53, 0x21, 0x41, 0x9A, 0x33, 
    0x07, 0xA1, 0xD8, 0x43, 0x6B, 0x0A, 0x89, 0xD8, 0x77, 0x39, 
    0x95, 0x22, 0xB7, 0x32, 0xC1, 0x04, 0x8A, 0x2C, 0xD9, 0x08, 
    0xEB, 0x85, 0xCB, 0x41, 0xBA, 0x50, 0xA8, 0x5B, 0x16, 0xED, 0x70, 

    0x52, 0x3D, 0x0D, 0x8C, 0x4A, 0x9E, 0x67, 0x88, 0x21, 0xF3,         // 60
    0x7E, 0xBD, 0x11, 0x93, 0x57, 0x0E, 0xDB, 0xBD, 0x06, 0x8D, 
    0x26, 0xAE, 0x1A, 0xF6, 0x32, 0xE1, 0x65, 0x0E, 0x30, 0xAF, 
    0xE3, 0x25, 0xF4, 0x7F, 0x48, 0xDB, 0xBE, 0x37, 0x80, 0x1F, 
    0x46, 0xA6, 0x0B, 0x77, 0xD3, 0x56, 0xC9, 0x78, 0xA3, 0xEB, 
    0x5B, 0xC9, 0x92, 0x2E, 0xBE, 0x7D, 0xCB, 0xEE, 0x5E, 0xC4, 
    0xF8, 0x73, 0xB8, 0x12, 0xAA, 0xDF, 0x54, 0x29, 0xBF, 0x15, 
    0xCD, 0x68, 0xF3, 0x5C, 0x9D, 0x74, 0xE6, 0xA6, 0x5D, 0x96, 
    0x6D, 0x13, 0xA7, 0x23, 0x8E, 0xE6, 0x11, 0xC2, 0x86, 0x33, 0xB5, 

    0xDE, 0x7D, 0xBF, 0x5A, 0xE5, 0x28, 0xDA, 0xC7, 0x9F, 0x4B,         // 61
    0x30, 0xD5, 0x4F, 0xE1, 0xC0, 0x83, 0x34, 0x95, 0x51, 0xFD, 
    0x64, 0x3C, 0x7C, 0xA5, 0x8E, 0x21, 0x7A, 0xA4, 0xD4, 0x6A, 
    0x05, 0x9E, 0x61, 0xCE, 0x2E, 0x88, 0x09, 0xEB, 0xA9, 0xD5, 
    0xBE, 0x2F, 0x90, 0xBB, 0x23, 0x9B, 0xE8, 0x32, 0x66, 0xCF, 
    0x3E, 0x07, 0xF1, 0x47, 0x9D, 0x04, 0x3B, 0xAC, 0x13, 0x86, 
    0x47, 0x26, 0x5F, 0xF1, 0x80, 0x22, 0xA0, 0xF2, 0x5E, 0x84, 
    0xE4, 0x07, 0x90, 0x27, 0xDC, 0x55, 0x40, 0x19, 0xF6, 0x28, 
    0xC1, 0x4D, 0xFC, 0x68, 0xD3, 0x43, 0x76, 0xF6, 0x4D, 0xD5, 0x10, 

    0x95, 0x23, 0xFA, 0x18, 0x77, 0xB9, 0x39, 0x59, 0x0C, 0xDD,         // 62
    0x8F, 0x65, 0xAB, 0x40, 0x20, 0xF6, 0x5D, 0xAC, 0x1C, 0xCF, 
    0x9A, 0xC2, 0xD9, 0x00, 0x48, 0xB8, 0xEF, 0x50, 0x3B, 0xBE, 
    0x7C, 0x3F, 0xB6, 0x18, 0xA0, 0xFB, 0x53, 0x71, 0x3D, 0x0E, 
    0x73, 0xFA, 0x4E, 0xDD, 0x69, 0x3A, 0x88, 0x0B, 0xB8, 0x23, 
    0x82, 0xAC, 0x78, 0xD5, 0x61, 0xE2, 0x95, 0x73, 0x2F, 0xB5, 
    0xDE, 0x9B, 0xC7, 0x32, 0x50, 0xC0, 0x6F, 0x02, 0xB7, 0x40, 
    0xA2, 0x51, 0xC8, 0x7C, 0x13, 0xB1, 0xD3, 0x81, 0xBA, 0x45, 
    0xD8, 0x99, 0x30, 0x82, 0x08, 0xA3, 0x20, 0x93, 0x27, 0xA6, 0x62, 

    0x35, 0xAD, 0x68, 0xCC, 0x9D, 0x08, 0x84, 0xF7, 0x73, 0xA7,         // 63
    0x26, 0xFE, 0x04, 0x7A, 0x9C, 0x6C, 0x0A, 0xEA, 0x75, 0x31, 
    0x57, 0x13, 0x6B, 0xF1, 0x5D, 0xCB, 0x0B, 0x96, 0xE2, 0x29, 
    0xF8, 0x8D, 0xD6, 0x58, 0x77, 0xBA, 0x23, 0x99, 0xE0, 0x8B, 
    0x56, 0xA0, 0x18, 0x80, 0x0F, 0xEF, 0xAB, 0x53, 0xF5, 0x93, 
    0xE0, 0x56, 0x35, 0x12, 0xAE, 0x2A, 0x52, 0xFC, 0xCE, 0x61, 
    0x01, 0x78, 0x1C, 0xE6, 0x95, 0xD6, 0x36, 0x93, 0xD3, 0x18, 
    0x74, 0xEE, 0x39, 0xA8, 0xF8, 0x31, 0x64, 0x10, 0x94, 0x71, 
    0x01, 0x5F, 0xDF, 0xC4, 0x56, 0xF0, 0xBA, 0x5F, 0xC8, 0x7B, 0xEC, 

    0xD0, 0x50, 0x8E, 0x32, 0x5E, 0xEB, 0x48, 0xB4, 0x15, 0xCA,         // 64
    0x4D, 0x87, 0xBE, 0xE8, 0x29, 0xD3, 0xB7, 0x42, 0xBF, 0x88, 
    0xE7, 0xB1, 0x2D, 0x85, 0xA0, 0x36, 0x7E, 0x60, 0x1B, 0xA1, 
    0x53, 0x12, 0x35, 0xE9, 0x04, 0x44, 0xD7, 0x5F, 0xB4, 0x2B, 
    0xCA, 0xE8, 0x3C, 0xAE, 0xC8, 0x49, 0x73, 0xD3, 0x39, 0x6C, 
    0x0C, 0xB3, 0xCD, 0x90, 0xEF, 0x79, 0xBB, 0x0B, 0x49, 0x92, 
    0xEB, 0x3D, 0xAB, 0x7E, 0x44, 0x0F, 0xFE, 0x56, 0x7B, 0xE1, 
    0x2C, 0xB4, 0x0E, 0x6C, 0x4D, 0x98, 0xC1, 0xF0, 0x2A, 0xE2, 
    0xB6, 0x88, 0x16, 0xAD, 0x2B, 0x70, 0x3C, 0xDA, 0x1B, 0x4B, 0x02, 

    0x81, 0xF2, 0x0D, 0xDC, 0xAF, 0x26, 0xCE, 0x8D, 0x37, 0x64,         // 65
    0xE4, 0x1A, 0x3E, 0x5D, 0xA6, 0x4C, 0x81, 0x22, 0xD9, 0x06, 
    0x4C, 0x92, 0xD3, 0x45, 0xDD, 0x17, 0xFB, 0xB5, 0xCD, 0x74, 
    0xDB, 0xBC, 0x6F, 0xA9, 0x93, 0xC8, 0x7E, 0x10, 0xEB, 0x4C, 
    0x00, 0x66, 0x88, 0xE2, 0x2B, 0x9D, 0x06, 0xBA, 0x1D, 0xA3, 
    0x42, 0xFB, 0x1C, 0x64, 0x3F, 0x22, 0xD7, 0x88, 0xAE, 0x2D, 
    0xBE, 0x68, 0xD7, 0x15, 0xB9, 0x6B, 0xA6, 0x1E, 0xB0, 0x48, 
    0x90, 0x5D, 0xD2, 0x8B, 0xE6, 0x03, 0x79, 0x3B, 0xA2, 0x5C, 
    0x21, 0xF1, 0x42, 0x7B, 0xE9, 0x99, 0x14, 0x8A, 0xFD, 0xA1, 0xBC, 

    0x23, 0x43, 0xC5, 0x7E, 0x4E, 0x9B, 0x6F, 0x1F, 0xEF, 0xA0,         // 66
    0x7C, 0xB2, 0xDB, 0x8B, 0x18, 0xF8, 0xAE, 0x60, 0x9B, 0x6D, 
    0xF9, 0x18, 0x71, 0x21, 0xBE, 0x67, 0x8D, 0x4C, 0x38, 0x02, 
    0x89, 0x40, 0xF2, 0x2E, 0x5C, 0x21, 0xF6, 0x3B, 0xAC, 0x82, 
    0xC2, 0x99, 0x1D, 0x59, 0x7C, 0xFD, 0x5E, 0x87, 0xED, 0x77, 
    0xC7, 0x59, 0xAA, 0x81, 0xE1, 0x9F, 0x60, 0x17, 0x6D, 0xF5, 
    0x0E, 0x8A, 0x4A, 0xF6, 0x5C, 0xD1, 0x89, 0x39, 0xE7, 0x08, 
    0xBE, 0xFA, 0x1F, 0x41, 0xB2, 0x2A, 0xDC, 0x52, 0xCD, 0x7D, 
    0x38, 0xC7, 0xA3, 0x51, 0x05, 0xCF, 0xB1, 0x55, 0x77, 0x38, 0x60, 

    0x97, 0xB1, 0x6A, 0x1C, 0xFC, 0x01, 0xE0, 0x57, 0xC2, 0x44,         // 67
    0x0B, 0x61, 0x31, 0xC6, 0x6F, 0x3F, 0x10, 0xEB, 0x27, 0xB4, 
    0x39, 0xC9, 0xA2, 0xF3, 0x52, 0xA9, 0x0D, 0xD4, 0x97, 0xF5, 
    0x5B, 0xA5, 0x0E, 0x85, 0xE2, 0xB0, 0x70, 0x97, 0x25, 0x6B, 
    0xF9, 0x35, 0xD4, 0xB7, 0x13, 0x3B, 0xD6, 0x26, 0x46, 0xDC, 
    0x10, 0x96, 0x2C, 0xCA, 0x03, 0x51, 0xF1, 0xC6, 0x39, 0xCF, 
    0x54, 0xA9, 0x27, 0x9A, 0x35, 0x06, 0xEE, 0x6E, 0xC9, 0x65, 
    0x82, 0x4E, 0xA1, 0x75, 0xCC, 0x65, 0x92, 0xB8, 0x09, 0xFE, 
    0x9B, 0x65, 0x1B, 0xD7, 0x8A, 0x6A, 0x41, 0xC3, 0x0E, 0xE9, 0xCB, 

    0x07, 0xEF, 0x2E, 0x93, 0xC3, 0x3D, 0x82, 0xA8, 0x15, 0x8E,         // 68
    0xCC, 0xF9, 0x94, 0x00, 0xE2, 0x9C, 0xCF, 0x78, 0x4F, 0xDB, 
    0x80, 0x5A, 0x04, 0x8B, 0x28, 0x77, 0xEC, 0x2F, 0x66, 0xBA, 
    0x28, 0xD5, 0x6C, 0xBF, 0x47, 0x0A, 0x56, 0xC4, 0xDC, 0x51, 
    0x14, 0xA5, 0x48, 0xE9, 0xA7, 0x8A, 0xC2, 0x98, 0x63, 0xAB, 
    0x3B, 0x73, 0xEB, 0x44, 0xBA, 0x7E, 0x25, 0xA9, 0x90, 0x76, 
    0x22, 0xE2, 0xC9, 0x72, 0xBD, 0x7F, 0xA4, 0x24, 0x41, 0xAC, 
    0x33, 0xDA, 0x0D, 0xEE, 0x3A, 0x18, 0xE8, 0x2E, 0x88, 0x4C, 
    0x12, 0xDD, 0x7E, 0xB5, 0x36, 0xF7, 0x23, 0xE1, 0x93, 0x2D, 0x6F, 

    0x83, 0x47, 0xDA, 0x59, 0xAC, 0x67, 0xD1, 0x34, 0xF4, 0x6D,         // 69
    0x25, 0x53, 0xAC, 0x48, 0x7E, 0x58, 0x31, 0xC0, 0x0A, 0x98, 
    0x2F, 0xB8, 0xD6, 0x3F, 0xE2, 0xC0, 0x47, 0x82, 0xA4, 0x19, 
    0xE9, 0x3A, 0x96, 0x1A, 0xD0, 0x8C, 0xF0, 0x3E, 0x06, 0x92, 
    0xCC, 0x86, 0x64, 0x05, 0x77, 0x4F, 0x18, 0xEA, 0x01, 0x80, 
    0xB9, 0xD1, 0x19, 0x65, 0x92, 0xDE, 0x48, 0x6B, 0x05, 0xE8, 
    0x9F, 0x62, 0x0A, 0x41, 0xD8, 0x1D, 0x51, 0xDD, 0x8F, 0xF5, 
    0x18, 0xC6, 0x68, 0x96, 0xAF, 0x80, 0x4E, 0xA7, 0x67, 0xE4, 
    0xBC, 0x2D, 0x55, 0xED, 0x11, 0x97, 0x5C, 0x7E, 0xAF, 0x53, 0xD6, 

    0xA1, 0xC7, 0x76, 0x0A, 0x32, 0xEA, 0x0E, 0x93, 0x51, 0xB9,         // 70
    0xE6, 0x88, 0x2D, 0xC3, 0xF2, 0x1C, 0xA6, 0x84, 0xFD, 0x64, 
    0xE3, 0x1E, 0x71, 0x9E, 0x5C, 0x23, 0xB0, 0x0B, 0xDE, 0x4D, 
    0x76, 0xB2, 0x54, 0xFB, 0x66, 0x34, 0xA5, 0x7A, 0xB6, 0xE6, 
    0x6F, 0x23, 0xF4, 0xBD, 0x2E, 0xD4, 0x68, 0xB0, 0x38, 0xF9, 
    0x26, 0x56, 0x9E, 0xF3, 0x30, 0x11, 0xB3, 0xFD, 0x41, 0xB9, 
    0x33, 0x86, 0xEE, 0x8F, 0x59, 0xFB, 0xB9, 0x79, 0x01, 0x5A, 
    0x9A, 0x7E, 0x2C, 0x4A, 0x07, 0xBF, 0xF2, 0x14, 0xCC, 0x36, 
    0x70, 0x8F, 0xA4, 0x43, 0x71, 0xAA, 0xDB, 0x00, 0x3B, 0xFA, 0x15, 

    0x38, 0x1B, 0xB3, 0xF8, 0x97, 0x7C, 0x5E, 0xCA, 0x1F, 0x9F,         // 71
    0x09, 0x69, 0xD9, 0x12, 0xB4, 0x68, 0xE0, 0x46, 0x29, 0xA7, 
    0x4C, 0x89, 0xF2, 0x14, 0xD3, 0x86, 0xFD, 0x59, 0xC6, 0x95, 
    0x05, 0xCE, 0x23, 0x7C, 0xB9, 0x16, 0xE4, 0x27, 0x62, 0x19, 
    0x44, 0xB2, 0x39, 0x8E, 0xE4, 0x9C, 0x41, 0x8D, 0xC3, 0x6A, 
    0xDA, 0x82, 0x09, 0xB7, 0x74, 0xD4, 0x5A, 0x85, 0xCD, 0x13, 
    0x56, 0xC2, 0x1B, 0xB0, 0x2F, 0x9D, 0x14, 0x44, 0xCD, 0xB2, 
    0x3C, 0xE2, 0xB6, 0xFC, 0xCF, 0x55, 0x75, 0x42, 0x8C, 0xA9, 
    0x1D, 0xEA, 0x04, 0xBD, 0xD4, 0x1F, 0x46, 0xC5, 0x72, 0xB5, 0x64, 

    0xED, 0x91, 0x69, 0x43, 0xD2, 0x2A, 0xAA, 0xE5, 0x3F, 0x76,         // 72
    0xC4, 0x3C, 0xA1, 0x79, 0x41, 0x92, 0x06, 0xBB, 0x7D, 0xD1, 
    0x08, 0xBC, 0x34, 0x53, 0xAB, 0x68, 0x1B, 0xA2, 0x30, 0x80, 
    0xF2, 0x3F, 0x99, 0xE6, 0x44, 0x9D, 0x56, 0xC4, 0x8E, 0xFE, 
    0x9D, 0xDD, 0x5C, 0x16, 0x71, 0x09, 0xF3, 0x28, 0x54, 0x0E, 
    0xA6, 0x49, 0xC9, 0x37, 0x96, 0x45, 0xA3, 0x1E, 0x69, 0x91, 
    0xF6, 0x70, 0x46, 0xDF, 0x7B, 0x60, 0xD3, 0x97, 0x67, 0xF1, 
    0x24, 0x74, 0x16, 0x61, 0x85, 0x1E, 0x9C, 0xDC, 0x07, 0xF8, 
    0x61, 0xC4, 0x78, 0x33, 0x58, 0x82, 0xE5, 0x99, 0x2A, 0x89, 0xD0, 

    0x59, 0x28, 0xE1, 0x15, 0x54, 0xC1, 0x17, 0x58, 0x8A, 0xFC,         // 73
    0x2A, 0xE0, 0x55, 0xF7, 0x27, 0xD4, 0x56, 0xF0, 0x20, 0x61, 
    0xE8, 0x6E, 0x9A, 0xC8, 0x00, 0xEA, 0x48, 0x77, 0xE7, 0x14, 
    0x5D, 0xAB, 0x65, 0x0E, 0xC1, 0x76, 0x0B, 0xD9, 0x32, 0x54, 
    0x02, 0x7A, 0xC5, 0xAB, 0x4D, 0xCF, 0xB6, 0x7C, 0xCD, 0xE8, 
    0x8B, 0x23, 0xF7, 0x5F, 0xDD, 0x02, 0xED, 0x38, 0xDB, 0xA9, 
    0x35, 0xCE, 0x9C, 0x03, 0xC4, 0x25, 0xED, 0x34, 0x0D, 0x86, 
    0x4F, 0xD9, 0xA2, 0x3D, 0xAD, 0xE7, 0x32, 0xC2, 0x57, 0x85, 
    0x40, 0x25, 0xDB, 0x98, 0xF9, 0xB1, 0x0E, 0x60, 0xF3, 0x0A, 0x40, 

    0x7D, 0xC5, 0xAF, 0x9C, 0x83, 0xF4, 0x6F, 0xA5, 0x0C, 0xB3,         // 74
    0x64, 0x91, 0x04, 0xC7, 0x9A, 0x6C, 0xAF, 0x38, 0x8F, 0xA5, 
    0x44, 0x2A, 0xF7, 0x7D, 0x3A, 0x93, 0xCD, 0xB4, 0x3E, 0xBC, 
    0xD3, 0x29, 0x83, 0xDA, 0x37, 0xF6, 0x93, 0x67, 0xB8, 0x85, 
    0xCE, 0x48, 0x1F, 0xF8, 0x86, 0x23, 0x68, 0x12, 0x9B, 0x3C, 
    0x64, 0xB1, 0x79, 0x2E, 0x8C, 0xC3, 0x73, 0xBB, 0x4E, 0x08, 
    0x7F, 0x1E, 0x53, 0xF4, 0x41, 0x85, 0xA9, 0x72, 0xE3, 0xA4, 
    0xC0, 0x10, 0x89, 0xD2, 0x02, 0x4C, 0x6E, 0xA5, 0x2B, 0xD2, 
    0x9C, 0xB4, 0x67, 0x15, 0x4B, 0x30, 0x78, 0xC9, 0x4E, 0xBA, 0xA3, 

    0xE8, 0x02, 0x3E, 0x6D, 0x0F, 0xB2, 0x46, 0xE7, 0x38, 0xD7,         // 75
    0x20, 0xAD, 0x81, 0x43, 0x14, 0xE7, 0x1D, 0x7A, 0xC2, 0x12, 
    0xCD, 0x87, 0x1C, 0x56, 0xDA, 0x6D, 0x2B, 0x0C, 0x98, 0x72, 
    0x4C, 0xF9, 0xB6, 0x21, 0x5C, 0xAC, 0x4B, 0x27, 0xEB, 0x14, 
    0xA4, 0xE8, 0x69, 0x9B, 0x34, 0xE1, 0xAA, 0x50, 0xFD, 0x1E, 
    0xC5, 0x06, 0xE7, 0xAA, 0x16, 0x58, 0x29, 0x88, 0xF2, 0x65, 
    0xB8, 0xE7, 0x89, 0x69, 0xB9, 0x1B, 0x55, 0xC7, 0x45, 0x28, 
    0x5B, 0xF9, 0x30, 0x72, 0xB3, 0xF7, 0x8D, 0x10, 0xE4, 0x71, 
    0x0C, 0x4F, 0xE2, 0x81, 0xC2, 0xEC, 0x91, 0x16, 0xDE, 0x71, 0x1D, 

    0x62, 0x8C, 0xF6, 0xCA, 0x33, 0xD9, 0x1E, 0x99, 0x7A, 0x55,         // 76
    0xC3, 0x4A, 0xEE, 0x69, 0xB5, 0x8D, 0x50, 0xFA, 0x5F, 0xDE, 
    0x4F, 0xAA, 0xE1, 0xB9, 0x12, 0xA8, 0xF8, 0x64, 0xD8, 0x24, 
    0x8B, 0x01, 0x68, 0x91, 0xCA, 0x07, 0xDE, 0xA0, 0x73, 0x59, 
    0x3D, 0x29, 0xB9, 0x0B, 0x5A, 0xC0, 0x3A, 0x8E, 0xBE, 0x76, 
    0x48, 0xD6, 0x67, 0x44, 0xD2, 0xFB, 0xA0, 0x0F, 0xAD, 0x2D, 
    0xD5, 0x26, 0xA5, 0x0D, 0xD3, 0x94, 0xFA, 0x05, 0x91, 0xDA, 
    0x77, 0x9A, 0x4B, 0xDE, 0x58, 0x18, 0xC4, 0x61, 0xB0, 0x3C, 
    0xFD, 0xBE, 0x23, 0xA0, 0x02, 0x5B, 0xAF, 0x41, 0x9C, 0x30, 0xD1, 

    0xA7, 0x25, 0x4A, 0x64, 0xA1, 0x81, 0x5F, 0xCE, 0x02, 0xF4,         // 77
    0x9C, 0x12, 0xCC, 0x38, 0xDF, 0x30, 0xCA, 0x03, 0x97, 0x26, 
    0x78, 0x08, 0x5D, 0x95, 0x35, 0x85, 0x4E, 0xBE, 0x41, 0xEC, 
    0xA8, 0xCD, 0x44, 0xE4, 0x72, 0x3C, 0x86, 0x20, 0xC9, 0xF5, 
    0x8D, 0xD5, 0x80, 0xDD, 0x77, 0xF3, 0x00, 0x6E, 0x2C, 0xE3, 
    0x87, 0xA5, 0x29, 0x94, 0x78, 0x34, 0x61, 0xE3, 0x3E, 0x7D, 
    0x97, 0x60, 0x3D, 0xEE, 0x4C, 0x71, 0x32, 0xAE, 0x66, 0x1B, 
    0xB2, 0x0B, 0xC3, 0x22, 0xA1, 0x85, 0x35, 0xEC, 0x1E, 0x95, 
    0x7B, 0x63, 0x3E, 0xE9, 0x74, 0xCC, 0x20, 0x6C, 0xFE, 0x85, 0x48, 

    0xEE, 0xC2, 0x97, 0xE2, 0x08, 0xFB, 0x2E, 0xB8, 0x41, 0x87,         // 78
    0x66, 0x32, 0x77, 0xA5, 0x0B, 0x61, 0x7E, 0xAA, 0x49, 0xED, 
    0xBB, 0x8E, 0xFD, 0x49, 0xC5, 0xE5, 0x05, 0x9B, 0x7C, 0x12, 
    0x60, 0x2F, 0x9E, 0x12, 0xB6, 0xFC, 0x5E, 0xBA, 0x44, 0x05, 
    0xAD, 0x5F, 0x13, 0x42, 0xA9, 0x4D, 0x99, 0xD9, 0xAD, 0x0E, 
    0x5C, 0x18, 0xF5, 0xB6, 0x05, 0xC9, 0x83, 0xBF, 0x54, 0xC9, 
    0x01, 0xE3, 0xAF, 0x7F, 0x17, 0xA3, 0xDF, 0x4A, 0xCB, 0xF3, 
    0x3F, 0xE6, 0x82, 0x68, 0xF3, 0x46, 0xCE, 0x7E, 0x52, 0xD0, 
    0x06, 0xA7, 0xD4, 0x8F, 0x2D, 0x4A, 0xDC, 0xB4, 0x07, 0xBD, 0x1A, 

    0x53, 0x83, 0x18, 0x42, 0xB4, 0x52, 0x95, 0x6D, 0xEA, 0x21,         // 79
    0xD6, 0xB1, 0xFE, 0x51, 0x96, 0xBC, 0xF2, 0x2A, 0xD1, 0x67, 
    0x3E, 0x2A, 0xCF, 0x16, 0x7B, 0x29, 0x68, 0xF0, 0x37, 0xB3, 
    0xDA, 0x78, 0xF2, 0x54, 0x31, 0x93, 0x0F, 0xDD, 0x9D, 0x75, 
    0x27, 0xC6, 0xFC, 0x96, 0x28, 0xCE, 0x1E, 0x5A, 0x37, 0xF1, 
    0x96, 0xC2, 0x39, 0x5E, 0xE5, 0x4E, 0x1B, 0xA8, 0x2B, 0xF7, 
    0x6D, 0x49, 0x20, 0xC8, 0x61, 0xC0, 0x0B, 0x83, 0x2A, 0x6E, 
    0x8D, 0x54, 0x2B, 0xD5, 0x1B, 0xB5, 0x08, 0xA2, 0x2F, 0xB6, 
    0xE8, 0x2A, 0x57, 0x0F, 0xF7, 0x9C, 0x81, 0x37, 0x62, 0xD8, 0x75, 

    0x0A, 0xDB, 0x6A, 0xCB, 0x7D, 0x1D, 0xDE, 0x0E, 0xA2, 0xC4,         // 80
    0x58, 0x07, 0x83, 0x1D, 0xE5, 0x3E, 0x12, 0x76, 0x91, 0x0C, 
    0xE6, 0x7D, 0xAB, 0x66, 0xA0, 0xDB, 0xB7, 0x20, 0xCE, 0x8C, 
    0x4C, 0x19, 0xC1, 0x85, 0xD5, 0xAD, 0x6C, 0x2B, 0x54, 0xEE, 
    0x86, 0x50, 0x34, 0x74, 0xBC, 0x68, 0xED, 0x89, 0xC9, 0x69, 
    0x43, 0xDF, 0x71, 0x8C, 0x25, 0x9E, 0xF0, 0x65, 0x91, 0x19, 
    0xA2, 0xD6, 0x89, 0xFE, 0x36, 0x8C, 0xF0, 0x5A, 0xA1, 0xC3, 
    0x00, 0xA8, 0xBF, 0x90, 0x4E, 0x71, 0xDF, 0x5D, 0xF6, 0x6C, 
    0x45, 0x86, 0xC8, 0x75, 0xB6, 0x5E, 0x14, 0xEF, 0x90, 0x28, 0xA0, 

    0xBB, 0x3B, 0xA4, 0x30, 0xF1, 0x62, 0xC6, 0x46, 0x80, 0x2C,         // 81
    0x97, 0xE3, 0x3A, 0xC6, 0x8B, 0x6D, 0xD7, 0xB7, 0x45, 0xA3, 
    0xC8, 0x51, 0x01, 0xF3, 0x31, 0x47, 0x95, 0x57, 0x70, 0x0F, 
    0xED, 0x98, 0x2C, 0x60, 0x15, 0x46, 0xE8, 0x8A, 0xCA, 0x15, 
    0xB7, 0xE5, 0xAE, 0x1B, 0xE0, 0x06, 0x49, 0xA3, 0x16, 0x7F, 
    0x03, 0xA4, 0x2F, 0xBA, 0xD3, 0x74, 0x0A, 0xD5, 0x39, 0xC5, 
    0x76, 0x0F, 0x59, 0x27, 0x9E, 0x4A, 0x23, 0xCF, 0x18, 0xE1, 
    0x3B, 0xFA, 0x60, 0x0F, 0xEC, 0x9F, 0x27, 0x8E, 0x0F, 0xAB, 
    0x1B, 0x9D, 0xE0, 0x33, 0x47, 0xE4, 0xC1, 0x4D, 0xAF, 0x41, 0xF7, 

    0x5D, 0x8B, 0xE9, 0x00, 0x89, 0xA0, 0x26, 0xB1, 0x67, 0xF8,         // 82
    0x48, 0x71, 0xA9, 0x5F, 0x29, 0xA7, 0x53, 0x2E, 0xFB, 0x6E, 
    0x1E, 0x8A, 0xBB, 0x5F, 0xD5, 0x80, 0x09, 0xF8, 0xA8, 0x3B, 
    0xBC, 0x52, 0xDC, 0xB1, 0xF4, 0x7B, 0x00, 0xB1, 0x33, 0x73, 
    0x3E, 0x0B, 0x8D, 0x5B, 0x9F, 0x7E, 0xC0, 0x34, 0xFC, 0xB6, 
    0xD6, 0x59, 0xF6, 0x0D, 0x54, 0x3B, 0xB7, 0x83, 0x57, 0xE9, 
    0x46, 0xBC, 0xE7, 0xAC, 0x6B, 0xE9, 0xB3, 0x88, 0x6C, 0x50, 
    0x96, 0x73, 0x33, 0xCD, 0x7A, 0x49, 0xC8, 0x3E, 0xBE, 0x7D, 
    0xED, 0x5A, 0x00, 0xAC, 0x8C, 0x2C, 0x71, 0x04, 0xE0, 0x76, 0x22, 

    0xE3, 0x1B, 0x4B, 0xB1, 0x57, 0x3A, 0xD1, 0xE5, 0x04, 0xAD,         // 83
    0x1E, 0xD5, 0x0E, 0xF6, 0xCB, 0x02, 0xEB, 0x95, 0x0F, 0xD4, 
    0x3D, 0xE9, 0x27, 0x90, 0x16, 0xC0, 0xDF, 0x35, 0x7F, 0xD8, 
    0x72, 0x04, 0x8B, 0x6A, 0x22, 0xA6, 0xD4, 0x58, 0xFA, 0xA2, 
    0xD5, 0x66, 0xBE, 0x43, 0xF7, 0x2C, 0xDD, 0x74, 0x54, 0x2A, 
    0x90, 0x21, 0x79, 0x9A, 0xDC, 0x91, 0xFC, 0x22, 0xAC, 0x05, 
    0x99, 0x31, 0x7A, 0x1B, 0xD6, 0x0A, 0x5F, 0x34, 0xF2, 0xB5, 
    0x14, 0xD9, 0xA0, 0x1F, 0xB9, 0x03, 0xFE, 0x73, 0xD8, 0x26, 
    0x48, 0xC0, 0x6B, 0xFC, 0x1B, 0xD1, 0xA5, 0x87, 0x54, 0xCB, 0x9C, 

    0x66, 0xBE, 0x75, 0xD4, 0xFD, 0x72, 0x14, 0x9A, 0x5C, 0x8A,         // 84
    0xC0, 0x7A, 0x4D, 0x8F, 0x3D, 0x82, 0x6B, 0xBB, 0x5D, 0x81, 
    0xA8, 0x56, 0xCD, 0xB0, 0x4B, 0x72, 0x27, 0xB3, 0x4F, 0x19, 
    0x9F, 0xFD, 0x38, 0xCC, 0x54, 0x8F, 0x2C, 0x78, 0x17, 0x48, 
    0x82, 0xF1, 0x22, 0xCC, 0x0F, 0x63, 0x9A, 0x18, 0xAF, 0xE3, 
    0x6B, 0xCC, 0x46, 0xBF, 0x1A, 0x5D, 0x31, 0x70, 0xD6, 0x7E, 
    0xF8, 0x63, 0xD0, 0x96, 0x40, 0x80, 0xCB, 0x9F, 0x06, 0xD4, 
    0x38, 0x7F, 0x44, 0xE3, 0x88, 0x67, 0xAC, 0x1A, 0x5E, 0xAF, 
    0x90, 0x2D, 0xD7, 0x9A, 0x61, 0x4A, 0xED, 0x27, 0xBB, 0x3E, 0x0C, 

    0xCF, 0x28, 0x98, 0x10, 0x30, 0xBF, 0x8C, 0x46, 0xF1, 0x2D,         // 85
    0x41, 0xE7, 0xA3, 0x22, 0xB6, 0xDE, 0x18, 0x36, 0xCA, 0x23, 
    0xF4, 0x0C, 0x77, 0x36, 0xFC, 0x9E, 0x5C, 0x8B, 0xEE, 0xC1, 
    0x2E, 0x58, 0xB8, 0x12, 0xEE, 0x3D, 0xBD, 0xEA, 0x94, 0xB6, 
    0x06, 0x54, 0xA1, 0x71, 0x89, 0xD6, 0x4A, 0xC5, 0x85, 0x3E, 
    0x0E, 0xA8, 0xEE, 0x34, 0x84, 0xE8, 0xC7, 0x9E, 0x15, 0x4C, 
    0x2A, 0xAF, 0x12, 0x56, 0xB6, 0xE5, 0x22, 0x4C, 0x74, 0x91, 
    0x5D, 0xF5, 0xB3, 0x5B, 0x2D, 0xE9, 0x3A, 0x8B, 0xDF, 0x0B, 
    0xF5, 0x78, 0x53, 0x0A, 0x7F, 0xC2, 0x10, 0x6D, 0x93, 0xFA, 0x81, 

    0x4F, 0xF2, 0x42, 0xAB, 0x81, 0x54, 0xE0, 0x1F, 0xB3, 0x77,         // 86
    0xCC, 0x15, 0x69, 0xF2, 0x60, 0x44, 0x9F, 0xE8, 0x8C, 0x4D, 
    0x9B, 0x64, 0xDC, 0x8A, 0x04, 0xC4, 0x1E, 0xD6, 0x08, 0x69, 
    0x8E, 0xE6, 0x7E, 0x9C, 0x6D, 0xDA, 0x08, 0x68, 0x25, 0xDF, 
    0xC6, 0x2F, 0xE6, 0x3C, 0xB7, 0x2E, 0xEB, 0x0B, 0x5D, 0xF1, 
    0x97, 0x52, 0x15, 0x66, 0xAE, 0x00, 0x49, 0x68, 0xF0, 0xC3, 
    0x94, 0xDB, 0x39, 0xF5, 0x6C, 0x33, 0xAD, 0xFC, 0xC4, 0x21, 
    0xA7, 0x31, 0x0D, 0x97, 0xCE, 0x14, 0x9D, 0x4E, 0xC2, 0x42, 
    0xA6, 0x1E, 0xCB, 0xB1, 0xF2, 0x3F, 0xA0, 0xE4, 0x36, 0x1A, 0xAE, 

    0x09, 0x8F, 0x6B, 0xEA, 0xCA, 0x06, 0xA6, 0x6A, 0xD7, 0x09,         // 87
    0x9B, 0x54, 0xBC, 0x87, 0x08, 0xC4, 0x78, 0x59, 0x05, 0xD0, 
    0x2F, 0xBB, 0x1E, 0xAB, 0x5F, 0xE4, 0x4A, 0x7B, 0xA6, 0x45, 
    0xD2, 0x0C, 0x4A, 0x2C, 0xAD, 0x51, 0x89, 0xA8, 0x40, 0x5A, 
    0x77, 0x97, 0x64, 0xCE, 0x01, 0x99, 0x6A, 0xAD, 0xD0, 0x36, 
    0xBD, 0x7A, 0xCE, 0x95, 0xDD, 0x7B, 0xB3, 0x21, 0x8A, 0x5B, 
    0x08, 0x6F, 0x83, 0xC1, 0x03, 0x9E, 0x76, 0x10, 0x56, 0xE0, 
    0x6B, 0xC2, 0xE4, 0x6E, 0x47, 0xBE, 0x75, 0xEE, 0x21, 0x6E, 
    0x89, 0xE9, 0x45, 0x2A, 0x8F, 0x1C, 0x61, 0xC8, 0x56, 0xD7, 0x6F, 

    0xE5, 0xC0, 0x35, 0x1A, 0x62, 0x3E, 0xF6, 0x2A, 0x8B, 0x5D,         // 88
    0xFC, 0x2A, 0xDD, 0x3A, 0xA4, 0xD8, 0x2E, 0xFD, 0xB3, 0x6C, 
    0xE7, 0x85, 0x4B, 0xEC, 0x2B, 0x85, 0xB6, 0x30, 0xF9, 0x23, 
    0xB2, 0x6F, 0xCB, 0xF8, 0x14, 0xC2, 0x31, 0xCC, 0xF9, 0xA2, 
    0x11, 0xF0, 0x1B, 0x87, 0x5C, 0xFB, 0x41, 0x81, 0x27, 0x6E, 
    0x04, 0xFE, 0x26, 0x58, 0x3B, 0x28, 0xEC, 0xD1, 0x42, 0xAE, 
    0xE7, 0x47, 0xA2, 0x2A, 0xDD, 0x58, 0xCF, 0x8B, 0x35, 0x9C, 
    0x01, 0x42, 0x81, 0x17, 0xFA, 0xA3, 0x07, 0x5A, 0xB1, 0xCA, 
    0x03, 0x5E, 0x9C, 0x6C, 0xE3, 0x79, 0xB2, 0x02, 0x83, 0x9C, 0x2D, 

    0x79, 0x55, 0x9F, 0xDF, 0xB6, 0x7C, 0x98, 0x52, 0xC1, 0x36,         // 89
    0xB6, 0x8F, 0x11, 0x7A, 0x55, 0x19, 0x91, 0x4A, 0x1F, 0x9E, 
    0x3D, 0x0A, 0xC6, 0x71, 0xA4, 0x0E, 0xD1, 0x69, 0x96, 0x59, 
    0xE2, 0x32, 0x93, 0x5F, 0x83, 0xEA, 0x6C, 0x0C, 0x7C, 0x2C, 
    0xC2, 0x4A, 0xAB, 0xDD, 0x28, 0xC3, 0x12, 0xE3, 0x9E, 0xDA, 
    0x8C, 0x43, 0xA9, 0xE9, 0xC2, 0x6C, 0x92, 0x0D, 0x78, 0x2C, 
    0xCD, 0x1A, 0xEE, 0x5F, 0x87, 0x3F, 0x1A, 0xE8, 0xC0, 0x7C, 
    0xF7, 0xAF, 0xD7, 0x5A, 0x8C, 0x3D, 0xDA, 0x86, 0x28, 0xFC, 
    0x3A, 0xDA, 0xBD, 0x0E, 0xCF, 0x49, 0xFE, 0x34, 0xE0, 0x47, 0xB2, 

    0x24, 0xD1, 0x03, 0x87, 0x25, 0xD4, 0x0B, 0xEC, 0x1A, 0xD9,         // 90
    0x6E, 0x46, 0xCB, 0xF0, 0xB0, 0xE1, 0x67, 0xC5, 0x7E, 0xD6, 
    0x59, 0xF9, 0x97, 0x34, 0x56, 0xF2, 0x42, 0x1B, 0xC1, 0x09, 
    0x87, 0xA7, 0x10, 0xBF, 0x21, 0x4C, 0xAB, 0xE0, 0x58, 0x91, 
    0xD9, 0x82, 0x30, 0x54, 0xB2, 0x70, 0x90, 0x61, 0x1C, 0x4C, 
    0xB8, 0x68, 0x18, 0x80, 0x07, 0xA7, 0x50, 0xBE, 0xFC, 0x9A, 
    0x55, 0x8A, 0xAD, 0x0B, 0xB8, 0xF9, 0xA5, 0x6C, 0x4B, 0x26, 
    0x5D, 0x1C, 0x9E, 0x2C, 0xCB, 0x1C, 0x66, 0xA8, 0x47, 0x91, 
    0xAE, 0x7F, 0x54, 0x36, 0xA1, 0x20, 0x96, 0x70, 0xBD, 0x1A, 0xF6, 
};

const BYTE HT_SuperCell_GreenMono[91*91] = {
    0x59, 0x31, 0xD4, 0x47, 0x1D, 0x89, 0x68, 0xB8, 0x58, 0xF1,         //  0
    0x10, 0x83, 0x25, 0xF7, 0x1B, 0xC4, 0xE3, 0x63, 0x4B, 0x00, 
    0xA6, 0x56, 0x9A, 0x19, 0x69, 0xB1, 0x55, 0x81, 0x3D, 0x9A, 
    0x72, 0xE3, 0x7C, 0xC6, 0x87, 0x63, 0xB9, 0xED, 0x43, 0x77, 
    0xF6, 0x69, 0x4A, 0x2D, 0xF9, 0x07, 0xD9, 0x7B, 0x99, 0x3B, 
    0x5D, 0x15, 0xEE, 0x59, 0x93, 0x25, 0xC9, 0xEC, 0x0E, 0x4D, 
    0x21, 0xDD, 0x6D, 0x0A, 0xE8, 0x24, 0xD0, 0xB8, 0x59, 0x86, 
    0x26, 0xEC, 0x1E, 0x49, 0x82, 0x18, 0x95, 0x7B, 0x2B, 0xAF, 
    0x85, 0xC8, 0x65, 0xFA, 0x10, 0xA3, 0x36, 0xEE, 0x65, 0xD6, 0x01, 

    0xCC, 0x81, 0x10, 0x9A, 0xC5, 0xDB, 0x43, 0x22, 0xC7, 0x46,         //  1
    0xD8, 0x67, 0xD1, 0xA8, 0x6C, 0x45, 0x11, 0x96, 0xCF, 0xFB, 
    0x1F, 0xE0, 0x80, 0x3C, 0xC3, 0xDE, 0x2C, 0xD2, 0x10, 0xDA, 
    0x2A, 0x5A, 0x23, 0xA7, 0x14, 0xD5, 0x4B, 0x82, 0x0B, 0xD8, 
    0x1B, 0xA6, 0x8D, 0xB4, 0x70, 0x92, 0x39, 0x21, 0xBD, 0xDC, 
    0x90, 0x78, 0xB8, 0x0C, 0xD6, 0x3C, 0x7B, 0x56, 0xA6, 0xBD, 
    0x77, 0x95, 0x48, 0xB7, 0x82, 0x9D, 0x73, 0x01, 0x3D, 0xCB, 
    0xA2, 0x41, 0x93, 0xC1, 0xFA, 0x5C, 0xD7, 0xC3, 0x64, 0xDA, 
    0x39, 0x01, 0xB6, 0x54, 0x81, 0xD2, 0x1B, 0xBC, 0x92, 0x2A, 0xB2, 

    0x48, 0xA6, 0xF2, 0x5D, 0x79, 0x03, 0x9F, 0xE8, 0x8E, 0x76,         //  2
    0x2C, 0x9F, 0x4D, 0x31, 0xD8, 0x8A, 0xEF, 0x74, 0x37, 0xAB, 
    0x6A, 0xCC, 0x25, 0xF2, 0x53, 0x03, 0x71, 0x95, 0xB7, 0x4B, 
    0xC3, 0x9D, 0xF9, 0x3D, 0xE6, 0x9C, 0x20, 0xAE, 0x59, 0xB1, 
    0xC4, 0x41, 0x24, 0xE5, 0x17, 0xD1, 0x64, 0xF4, 0x51, 0x03, 
    0x30, 0xE6, 0x3F, 0x6A, 0xF4, 0xB2, 0x15, 0x97, 0x32, 0xE8, 
    0x04, 0xC5, 0x2B, 0xFA, 0x14, 0x44, 0xED, 0xA8, 0x8E, 0xF8, 
    0x0E, 0x6A, 0xE5, 0x04, 0x30, 0xB3, 0x3E, 0x0F, 0xA5, 0x50, 
    0xF4, 0x73, 0x9C, 0x22, 0xE5, 0x4C, 0x9E, 0x71, 0x41, 0xFC, 0x6E, 

    0xD8, 0x22, 0x38, 0xBD, 0x40, 0xF8, 0x54, 0x6E, 0x11, 0xAD,         //  3
    0xF6, 0x03, 0xC1, 0x7A, 0x0C, 0xA4, 0x3E, 0xBC, 0x17, 0x88, 
    0x2F, 0x50, 0xB4, 0x75, 0x98, 0xAF, 0xFD, 0x37, 0x63, 0xF0, 
    0x81, 0x06, 0x70, 0x54, 0x85, 0x34, 0x6E, 0xFD, 0x8D, 0x2E, 
    0x67, 0xF2, 0x7B, 0x56, 0xBF, 0x45, 0xAA, 0x81, 0xA2, 0x74, 
    0xB0, 0xCC, 0x96, 0x23, 0x82, 0x4B, 0xD0, 0xFE, 0x63, 0x89, 
    0x51, 0xD9, 0x60, 0xA5, 0x6E, 0xBF, 0x28, 0x63, 0x1A, 0x4E, 
    0xB9, 0x84, 0x55, 0xA6, 0x71, 0x8E, 0xEF, 0x73, 0x28, 0x90, 
    0x16, 0xCC, 0x40, 0xBE, 0x6C, 0x28, 0xEB, 0x09, 0xC3, 0x89, 0x12, 

    0x58, 0x75, 0xE4, 0x85, 0x1E, 0xCD, 0xB1, 0x27, 0xE1, 0x40,         //  4
    0x5E, 0x95, 0xE4, 0x54, 0xFE, 0x26, 0x68, 0xDC, 0x55, 0xEA, 
    0xC3, 0x95, 0x08, 0xD5, 0x21, 0x47, 0x84, 0x17, 0xA6, 0x23, 
    0x42, 0xAB, 0xD8, 0xC6, 0x0D, 0xB5, 0xD0, 0x11, 0x4A, 0xDC, 
    0x0C, 0xA4, 0xD0, 0x00, 0x9D, 0x28, 0xE3, 0x10, 0x41, 0xEB, 
    0x58, 0x14, 0x49, 0xAF, 0xA2, 0x00, 0x6C, 0x29, 0xB9, 0x14, 
    0xA8, 0x25, 0x8B, 0x35, 0xE3, 0x4E, 0xD4, 0xB0, 0xE2, 0x77, 
    0xD9, 0x29, 0xD3, 0x44, 0xE2, 0x16, 0x53, 0xD2, 0xB6, 0xE7, 
    0x5A, 0x7B, 0xE0, 0x0E, 0x8F, 0xCA, 0x85, 0x56, 0xDF, 0x36, 0xA0, 

    0xF5, 0x98, 0x0B, 0xAF, 0x68, 0x90, 0x38, 0x85, 0xBA, 0xCE,         //  5
    0x7D, 0x1D, 0x42, 0x86, 0xB0, 0xCA, 0x8C, 0x04, 0xA3, 0x6E, 
    0x14, 0xF8, 0x68, 0x38, 0xEC, 0x62, 0xC6, 0xE5, 0x6D, 0xC1, 
    0xDE, 0x59, 0x1E, 0x90, 0x48, 0xE9, 0x5E, 0x9F, 0xC5, 0x75, 
    0x91, 0x39, 0x5E, 0x89, 0xFC, 0x7A, 0x58, 0xBB, 0xD5, 0x1D, 
    0x85, 0xFA, 0x73, 0xDE, 0x57, 0xE7, 0xC2, 0x94, 0x43, 0xDF, 
    0x71, 0xF3, 0xB8, 0x07, 0x7C, 0x99, 0x0C, 0x88, 0x2C, 0x3F, 
    0x9A, 0x12, 0xB3, 0x88, 0x25, 0xC5, 0x9C, 0x0B, 0x7E, 0x3B, 
    0xC1, 0x2E, 0x95, 0x53, 0xF1, 0x61, 0x30, 0xA5, 0x1C, 0x79, 0xBA, 

    0x50, 0x31, 0xD4, 0x47, 0xDE, 0x0E, 0xED, 0x5D, 0x06, 0x2F,         //  6
    0xA3, 0xDD, 0xBC, 0x14, 0x64, 0x38, 0xEB, 0x49, 0xCF, 0x37, 
    0x83, 0x45, 0xA7, 0x88, 0xB9, 0x0C, 0x9B, 0x45, 0x04, 0x90, 
    0x35, 0x7A, 0xF3, 0x68, 0xA3, 0x37, 0x81, 0x23, 0x40, 0xF0, 
    0x1D, 0xE6, 0xBC, 0x49, 0x1B, 0xC4, 0x31, 0x92, 0x6C, 0x33, 
    0xB8, 0x9B, 0x0A, 0x42, 0x8B, 0x31, 0x78, 0x11, 0xCA, 0x81, 
    0x1B, 0x3B, 0x62, 0xEB, 0xC3, 0x39, 0x6D, 0xFD, 0x60, 0xC9, 
    0xED, 0x6F, 0x3A, 0xFB, 0x60, 0x7C, 0x33, 0xF6, 0x62, 0x9E, 
    0x07, 0xFB, 0xAE, 0x24, 0xB2, 0x05, 0xC0, 0xF9, 0x66, 0xCF, 0x07, 

    0xA8, 0x6B, 0x89, 0x21, 0xA2, 0x4F, 0xC5, 0x9E, 0x70, 0xFA,         //  7
    0x4A, 0x69, 0x32, 0xF2, 0xA6, 0x0E, 0x74, 0x98, 0x1D, 0xB1, 
    0xE3, 0xC1, 0x27, 0x56, 0xDD, 0x76, 0x2A, 0xD3, 0x7C, 0xF9, 
    0xA5, 0x13, 0xB8, 0x29, 0xC9, 0x01, 0xF6, 0xB9, 0x94, 0x5F, 
    0xAB, 0x71, 0x2E, 0xDE, 0xA8, 0x6A, 0xEE, 0x0B, 0xA5, 0xE5, 
    0x62, 0x2B, 0xBF, 0xD7, 0x19, 0xF8, 0xA4, 0x60, 0xEA, 0x4E, 
    0x9B, 0xD2, 0xA6, 0x43, 0x16, 0xD9, 0xAB, 0x24, 0xBA, 0x0E, 
    0x8C, 0x55, 0xC0, 0x00, 0xA8, 0xDF, 0x51, 0xB2, 0x20, 0xDC, 
    0x6A, 0x85, 0x45, 0x74, 0xD5, 0x47, 0x82, 0x3A, 0x9B, 0x4A, 0xDE, 

    0x18, 0xEE, 0xB7, 0x5E, 0xFD, 0x75, 0x16, 0x3C, 0xD2, 0x89,         //  8
    0x1A, 0xC5, 0x94, 0x7A, 0x4E, 0xC4, 0xD9, 0x59, 0xF6, 0x69, 
    0x07, 0x7B, 0xD4, 0x15, 0xAA, 0x4A, 0xF1, 0xB3, 0x56, 0x20, 
    0x49, 0xCE, 0x85, 0x5A, 0xDF, 0x74, 0x4F, 0xD5, 0x10, 0x32, 
    0xCA, 0x05, 0x98, 0x7E, 0x11, 0x3C, 0xD0, 0x7B, 0x41, 0xC9, 
    0x4D, 0xEB, 0x6F, 0x99, 0x64, 0xBB, 0x48, 0x26, 0xB2, 0x0B, 
    0xFB, 0x2D, 0x73, 0x8A, 0x5D, 0x9C, 0x51, 0xE8, 0x48, 0x72, 
    0xA9, 0x1E, 0xD4, 0x90, 0x40, 0x1A, 0xCB, 0x83, 0x48, 0xBC, 
    0x2A, 0xC6, 0x17, 0xED, 0x9F, 0x6B, 0xE3, 0x14, 0xAF, 0x28, 0x7D, 

    0x94, 0x41, 0x05, 0xCB, 0x2A, 0x8A, 0xB5, 0xE9, 0x29, 0xAE,         //  9
    0x57, 0xEB, 0x00, 0xDB, 0x28, 0x88, 0x20, 0xB5, 0x3E, 0x95, 
    0x31, 0xA5, 0x65, 0xFA, 0x35, 0x94, 0x6A, 0x0F, 0x98, 0xC5, 
    0x6A, 0xE9, 0x0A, 0x42, 0xAD, 0x91, 0x1A, 0xA5, 0x6B, 0x84, 
    0xFB, 0x53, 0xD4, 0x5E, 0xF6, 0x8F, 0x55, 0xBB, 0x25, 0x90, 
    0x07, 0x7F, 0x22, 0x3B, 0xCE, 0x06, 0x8D, 0xD9, 0x6E, 0x88, 
    0x5A, 0xC0, 0x05, 0xB3, 0xF7, 0x2F, 0x83, 0x02, 0x95, 0xE1, 
    0x32, 0xF3, 0x48, 0x78, 0xF0, 0x6C, 0x9D, 0x05, 0xEE, 0xA2, 
    0x5C, 0xE3, 0x97, 0x58, 0x34, 0x1F, 0xC8, 0x8E, 0x5F, 0xF5, 0xC4, 

    0x57, 0xDF, 0x73, 0x97, 0x53, 0xDB, 0x44, 0x6E, 0x95, 0x0D,         // 10
    0x77, 0xB3, 0x3C, 0x6C, 0xBC, 0xFB, 0x4A, 0x7A, 0x15, 0xD0, 
    0xED, 0x53, 0x0F, 0x8C, 0xC0, 0x18, 0xCE, 0x3B, 0xE5, 0x83, 
    0x2E, 0xA9, 0x95, 0xFE, 0x21, 0x62, 0xEB, 0x45, 0xDA, 0xBA, 
    0x3C, 0x9E, 0x1C, 0xBF, 0x2B, 0xB0, 0x03, 0xDA, 0x5F, 0xFD, 
    0xA6, 0xD9, 0xB4, 0xF5, 0x55, 0x77, 0xF0, 0x38, 0xC9, 0x22, 
    0xE2, 0x92, 0x4C, 0xDE, 0x1C, 0xC8, 0x69, 0xB6, 0xCE, 0x16, 
    0x85, 0x60, 0xA3, 0x12, 0xBA, 0x2B, 0xDC, 0x3C, 0x77, 0x13, 
    0x88, 0x3E, 0x03, 0xCD, 0xB7, 0x86, 0x50, 0xEA, 0x00, 0x75, 0x36, 

    0xA4, 0xC0, 0x33, 0xED, 0x1D, 0xAA, 0x03, 0xC6, 0x4E, 0xF4,         // 11
    0xD7, 0x1E, 0x8B, 0xA4, 0x5B, 0x09, 0x9F, 0xE7, 0xC0, 0x87, 
    0x42, 0xB1, 0xE0, 0x73, 0x4F, 0xED, 0x7F, 0xA4, 0x52, 0x16, 
    0xDC, 0x4D, 0x27, 0x6C, 0xB5, 0xCD, 0x2D, 0x8B, 0x08, 0x63, 
    0x28, 0x7A, 0xEC, 0x4B, 0x73, 0xE5, 0x3F, 0xA0, 0x7D, 0x19, 
    0x3D, 0x67, 0x16, 0x84, 0x2C, 0xA9, 0x19, 0x9A, 0x63, 0xAF, 
    0x42, 0x18, 0xD0, 0x63, 0x9E, 0x49, 0xEE, 0x28, 0x5B, 0x42, 
    0xB1, 0xC8, 0x35, 0xE8, 0x53, 0x8C, 0x61, 0xB6, 0xD6, 0x51, 
    0xF3, 0xAD, 0x6C, 0x7F, 0xFE, 0x0D, 0xA3, 0x2F, 0xB3, 0xCF, 0x1D, 

    0x66, 0x86, 0x14, 0xB7, 0x66, 0x83, 0xF8, 0x32, 0xA7, 0x69,         // 12
    0x41, 0xC1, 0x54, 0xEF, 0x35, 0xD2, 0x71, 0x31, 0x57, 0x02, 
    0x79, 0x22, 0xCC, 0x39, 0xA7, 0x24, 0x5A, 0x00, 0xFA, 0xB5, 
    0x67, 0xC2, 0x7C, 0xD5, 0x04, 0x4F, 0x7A, 0xC1, 0xF4, 0x96, 
    0xE1, 0xB2, 0x07, 0xA7, 0x87, 0x20, 0x6A, 0xEF, 0x4B, 0xC6, 
    0x8A, 0xD2, 0x4F, 0x9D, 0xE2, 0xC5, 0x5A, 0xD7, 0x02, 0x7F, 
    0xF6, 0xA9, 0x8B, 0x32, 0x76, 0x09, 0xAC, 0x8E, 0xDD, 0x75, 
    0xFA, 0x08, 0x6D, 0x98, 0xCD, 0x0C, 0xFC, 0x19, 0x94, 0x2C, 
    0xC8, 0x1C, 0xDA, 0x27, 0x40, 0x63, 0xD9, 0x7A, 0x42, 0x90, 0xE3, 

    0x3D, 0xFA, 0x49, 0xD3, 0x9A, 0x2C, 0x5D, 0xD4, 0x81, 0x18,         // 13
    0x99, 0x2C, 0xD4, 0x10, 0x81, 0xB9, 0x17, 0x91, 0xAD, 0xF3, 
    0xC6, 0x9A, 0x65, 0x08, 0xE5, 0x8E, 0xD7, 0xC2, 0x78, 0x3B, 
    0x9C, 0x1B, 0xF3, 0x3E, 0x92, 0xEF, 0xAC, 0x16, 0x40, 0x57, 
    0x1F, 0xCE, 0x63, 0x3D, 0xD8, 0xC0, 0x94, 0x0E, 0xB1, 0x2C, 
    0xEA, 0x01, 0xBB, 0x72, 0x0C, 0x45, 0x87, 0x31, 0xEA, 0x4F, 
    0x27, 0x71, 0x0E, 0xF1, 0xB0, 0xDB, 0x7C, 0x15, 0x37, 0x9C, 
    0x29, 0x8A, 0xDD, 0x22, 0x41, 0x79, 0xA3, 0x4C, 0x71, 0xAB, 
    0x65, 0x8F, 0x52, 0x9F, 0xE7, 0x91, 0xBA, 0x18, 0xF7, 0x56, 0x09, 

    0xC8, 0xAA, 0x75, 0x07, 0x54, 0xE4, 0xAE, 0x0E, 0x49, 0xB1,         // 14
    0xE5, 0x7C, 0x65, 0xAF, 0x49, 0xEB, 0x62, 0xDA, 0x40, 0x6E, 
    0x2D, 0x4E, 0xFE, 0x82, 0xBC, 0x41, 0x64, 0x2C, 0x91, 0x12, 
    0xE9, 0x49, 0x88, 0xB2, 0x1F, 0x5A, 0x33, 0x6E, 0xD4, 0xA7, 
    0x78, 0x36, 0x8C, 0xF1, 0x12, 0x54, 0x34, 0xCB, 0x59, 0x92, 
    0x66, 0x40, 0xF8, 0x24, 0xA6, 0xF2, 0x6C, 0xC2, 0xA7, 0x91, 
    0xC8, 0xDC, 0x5F, 0xBF, 0x3A, 0x23, 0x5D, 0xF4, 0xC0, 0x61, 
    0xCC, 0x48, 0xAC, 0x60, 0xBD, 0xDF, 0x30, 0xC5, 0xEB, 0x05, 
    0x41, 0xF7, 0x0E, 0xBC, 0x59, 0x12, 0x37, 0x6B, 0xC4, 0xA6, 0x7E, 

    0x19, 0x36, 0x91, 0xEA, 0xBB, 0x1F, 0x6D, 0x90, 0xF2, 0xCB,         // 15
    0x44, 0x06, 0xFD, 0x93, 0x1D, 0xA0, 0x29, 0xBC, 0x0C, 0x8E, 
    0xD2, 0x13, 0xA1, 0x2F, 0x6D, 0x17, 0xF5, 0xAA, 0x4F, 0xD0, 
    0x5E, 0xC8, 0x0C, 0x65, 0xE1, 0xBF, 0x9A, 0xE9, 0x86, 0x00, 
    0xFC, 0xBB, 0x17, 0x9C, 0x6E, 0xAA, 0xFA, 0x75, 0xE6, 0x16, 
    0xC0, 0x7D, 0x99, 0x5B, 0xD1, 0x3C, 0x9A, 0x0E, 0x2B, 0x64, 
    0x3B, 0x1A, 0x99, 0x4E, 0x86, 0xC9, 0x98, 0x46, 0xA4, 0x04, 
    0xE6, 0x1F, 0x83, 0xF2, 0x02, 0x8E, 0x64, 0x1E, 0x85, 0xDB, 
    0xB2, 0x80, 0xD2, 0x2D, 0x75, 0xC7, 0xF0, 0x8A, 0x4A, 0x24, 0xEC, 

    0x61, 0xDC, 0x69, 0x27, 0x4C, 0x96, 0xDD, 0x36, 0x5A, 0x15,         // 16
    0x86, 0xBE, 0x56, 0x36, 0xDC, 0x77, 0x4F, 0xF9, 0xA4, 0x5A, 
    0xEC, 0xB8, 0x5D, 0xCE, 0xE0, 0x9F, 0x7F, 0x08, 0xE7, 0xB3, 
    0x23, 0x7F, 0xA2, 0xCF, 0x2D, 0x72, 0x0B, 0x48, 0x2C, 0xC7, 
    0x4C, 0x68, 0xE2, 0x43, 0xD5, 0x2A, 0x8D, 0x0A, 0x46, 0xAC, 
    0xDF, 0x2A, 0xC5, 0x34, 0x7E, 0x1A, 0xE3, 0x53, 0xD2, 0xFE, 
    0x80, 0xAD, 0xE8, 0x00, 0xFA, 0x65, 0x12, 0xE5, 0x31, 0x8C, 
    0x6F, 0xB3, 0x54, 0x2E, 0xA7, 0x49, 0xF5, 0xAE, 0x47, 0x6A, 
    0x22, 0x3A, 0x60, 0xA5, 0xDE, 0x43, 0x9F, 0x08, 0xE2, 0x73, 0x9B, 

    0xB7, 0x0C, 0xC9, 0xA0, 0xF6, 0x76, 0x01, 0xC5, 0xA5, 0x71,         // 17
    0xAE, 0x22, 0xCF, 0x6D, 0xB5, 0x01, 0xC9, 0x83, 0x35, 0x19, 
    0x79, 0x3E, 0x89, 0x04, 0x4F, 0x27, 0xC9, 0x66, 0x37, 0x97, 
    0x6C, 0xF5, 0x39, 0x5C, 0x91, 0xF9, 0xAC, 0xD1, 0x61, 0xA1, 
    0x8B, 0x22, 0xB0, 0x7B, 0x04, 0xBE, 0x5C, 0xDB, 0x9C, 0x23, 
    0x52, 0x72, 0x08, 0xE9, 0xAE, 0x63, 0xBD, 0x8E, 0x72, 0x12, 
    0xBD, 0x45, 0x29, 0x78, 0xB5, 0x2F, 0xD5, 0x74, 0xBC, 0x56, 
    0xFE, 0x12, 0xDB, 0xBF, 0x70, 0x16, 0xD0, 0x94, 0x0D, 0xBD, 
    0xCF, 0x9A, 0xEF, 0x03, 0x85, 0x21, 0x5F, 0xB4, 0x2F, 0xCC, 0x43, 

    0xFD, 0x4E, 0x7F, 0x39, 0x15, 0xCC, 0x46, 0x8B, 0x25, 0xF5,         // 18
    0x34, 0xE1, 0x89, 0x14, 0xF0, 0x94, 0x3E, 0x65, 0xD0, 0xE4, 
    0xAD, 0x26, 0xE8, 0xC1, 0x79, 0xF1, 0x3D, 0x8D, 0xD3, 0x10, 
    0x48, 0xAD, 0x02, 0xE4, 0x18, 0x4F, 0x27, 0x7B, 0xF2, 0x0F, 
    0xE6, 0x40, 0xCD, 0x57, 0xEE, 0x85, 0x38, 0xC4, 0x64, 0x84, 
    0xFC, 0xA0, 0xD6, 0x86, 0x47, 0xF7, 0x03, 0x3A, 0xA6, 0x4F, 
    0xE1, 0x63, 0x92, 0xD9, 0x54, 0x8C, 0xA7, 0x4A, 0x0B, 0xCC, 
    0x2B, 0x9F, 0x78, 0x3B, 0xEE, 0x87, 0x56, 0x34, 0x77, 0xFD, 
    0x51, 0x18, 0x6E, 0x4E, 0xC3, 0xFA, 0x79, 0xD3, 0x59, 0x8F, 0x22, 

    0x6F, 0x97, 0xE6, 0xBF, 0x60, 0xAA, 0xEC, 0x68, 0xD3, 0x53,         // 19
    0x94, 0x67, 0x3D, 0xA4, 0x51, 0x26, 0xE9, 0xA0, 0x0A, 0x50, 
    0x92, 0x67, 0xB2, 0x1A, 0x99, 0x5B, 0xAF, 0x1A, 0xF8, 0xBE, 
    0x89, 0xDB, 0x72, 0xBD, 0x7E, 0xC8, 0x96, 0x57, 0xB6, 0x3A, 
    0x71, 0xA8, 0x12, 0x94, 0x2E, 0xA9, 0x17, 0xF4, 0x3E, 0xBA, 
    0x1B, 0x3B, 0x5B, 0x15, 0xA8, 0x2B, 0x79, 0xC3, 0xF1, 0x1E, 
    0x9C, 0x09, 0xC0, 0x38, 0x11, 0xEE, 0x25, 0x83, 0xE8, 0x94, 
    0x67, 0x45, 0xCF, 0x0D, 0xA1, 0x23, 0xB4, 0xE7, 0x9E, 0x27, 
    0xAB, 0x8D, 0xDE, 0xB3, 0x29, 0x93, 0x0F, 0x3C, 0xF0, 0x01, 0xAB, 

    0x29, 0x46, 0x09, 0x71, 0x20, 0x88, 0x34, 0x0B, 0xB5, 0x1B,         // 20
    0xC2, 0x04, 0xF8, 0xCD, 0x69, 0x87, 0xB7, 0x31, 0x75, 0xC5, 
    0x1C, 0xF4, 0x4E, 0x36, 0xE2, 0x0A, 0xA6, 0x70, 0x50, 0x29, 
    0x60, 0x1D, 0x40, 0xA0, 0x35, 0xEF, 0x07, 0xDD, 0x22, 0x94, 
    0xDA, 0x50, 0xF9, 0x6F, 0xDA, 0x53, 0x73, 0x91, 0x0B, 0xDC, 
    0x70, 0xCC, 0xB4, 0x76, 0xDF, 0x93, 0xD3, 0x55, 0x32, 0x7B, 
    0xCA, 0x70, 0xF8, 0xAC, 0x6E, 0xCB, 0x61, 0xB8, 0x3D, 0x18, 
    0xB4, 0xF4, 0x8F, 0x55, 0xC6, 0x66, 0xD5, 0x04, 0x69, 0x41, 
    0xD2, 0x76, 0x0D, 0x3A, 0x81, 0xE6, 0xA4, 0x6E, 0xBB, 0x81, 0xD0, 

    0xF2, 0xB1, 0xD9, 0x9B, 0xF8, 0x52, 0xD7, 0x9D, 0x75, 0xE9,         // 21
    0x4B, 0x9E, 0x77, 0x1D, 0xBE, 0x08, 0xDA, 0x54, 0xFB, 0xA4, 
    0x3A, 0x82, 0xD3, 0x90, 0x6C, 0xC8, 0x45, 0x88, 0xB6, 0xE5, 
    0x9B, 0xCA, 0xFB, 0x58, 0x1F, 0x6A, 0xAA, 0x49, 0x75, 0xBE, 
    0x03, 0x86, 0x2B, 0xC1, 0x1B, 0xB6, 0xE9, 0x4D, 0xA8, 0x5C, 
    0x99, 0x01, 0xF3, 0x28, 0x3F, 0x68, 0x19, 0xAB, 0x8D, 0xEA, 
    0x2B, 0x52, 0x20, 0x84, 0x47, 0x9A, 0x05, 0xF9, 0x59, 0xDA, 
    0x7C, 0x01, 0x38, 0xE6, 0x79, 0x2A, 0x46, 0x83, 0xBD, 0xF0, 
    0x21, 0x48, 0xED, 0xC7, 0x69, 0x4C, 0x1B, 0xD8, 0x25, 0x44, 0x62, 

    0x10, 0x7D, 0x2F, 0x5B, 0xC3, 0x29, 0xB2, 0x3D, 0x5B, 0x89,         // 22
    0xD7, 0x28, 0xB3, 0x4E, 0xE7, 0x45, 0x79, 0x22, 0x8E, 0x11, 
    0xCC, 0x63, 0x02, 0xAF, 0x22, 0xFD, 0x2D, 0xDB, 0x0C, 0x39, 
    0x6B, 0x06, 0x83, 0xB7, 0xD7, 0x93, 0x39, 0xCC, 0xFE, 0x5A, 
    0x38, 0xCC, 0xA3, 0x5E, 0x3C, 0x80, 0x13, 0xCF, 0x26, 0xEE, 
    0x30, 0x85, 0x52, 0x9D, 0xBD, 0xFC, 0x4B, 0xE2, 0x0D, 0x61, 
    0xB8, 0xD8, 0x9D, 0xEA, 0x17, 0xE1, 0x39, 0x77, 0xA3, 0x2A, 
    0xC6, 0x61, 0xA5, 0x1F, 0xAD, 0xF3, 0x9D, 0xE0, 0x14, 0x59, 
    0x94, 0xB9, 0x60, 0x9F, 0x12, 0xCE, 0xB0, 0x56, 0x94, 0xDD, 0xA1, 

    0xC9, 0x51, 0xD3, 0x8F, 0x05, 0x79, 0xE0, 0x0F, 0xFD, 0x1F,         // 23
    0x42, 0x6E, 0xD1, 0x8A, 0x2C, 0x9B, 0xAE, 0xC7, 0x5D, 0xDF, 
    0x46, 0x9B, 0xF1, 0x43, 0x81, 0x5A, 0xA0, 0x75, 0xC7, 0x8D, 
    0xED, 0xA5, 0x46, 0x14, 0x77, 0xEA, 0x0E, 0x85, 0x19, 0xAE, 
    0xE9, 0x69, 0x18, 0xF2, 0x96, 0xC4, 0x43, 0x9D, 0x7A, 0xC1, 
    0x44, 0xDC, 0xC5, 0x1E, 0x82, 0x0A, 0x96, 0x71, 0xCD, 0x43, 
    0x81, 0x02, 0x39, 0x64, 0xBA, 0x81, 0xB1, 0xD6, 0x1B, 0x8C, 
    0x45, 0xE2, 0x82, 0xD6, 0x4B, 0x08, 0x61, 0x32, 0xB0, 0x7A, 
    0xCD, 0x00, 0x8A, 0x2A, 0xF3, 0x86, 0x30, 0xFC, 0x74, 0x19, 0x3B, 

    0x6B, 0xA5, 0x1E, 0xE6, 0x44, 0xA2, 0x62, 0x90, 0xB9, 0xCB,         // 24
    0x96, 0xE6, 0x07, 0x5E, 0xF9, 0x6D, 0x0D, 0xEE, 0x31, 0x7C, 
    0xB9, 0x1E, 0x74, 0xD8, 0xC1, 0x0F, 0xE7, 0x20, 0x46, 0x5D, 
    0x27, 0xC2, 0x66, 0xD0, 0x2E, 0x56, 0xC0, 0x6B, 0x9D, 0x30, 
    0x92, 0x43, 0xD5, 0x77, 0x08, 0xDC, 0x63, 0xFD, 0x06, 0x6C, 
    0xAD, 0x12, 0x65, 0xEC, 0x5B, 0xCA, 0x3C, 0xB5, 0x1E, 0x99, 
    0xF7, 0xB0, 0x79, 0xC7, 0x26, 0x55, 0x11, 0x6A, 0x4D, 0xF5, 
    0xB7, 0x32, 0x0F, 0x64, 0x92, 0xC5, 0x87, 0xD2, 0x4A, 0x1E, 
    0xF4, 0x3A, 0xE0, 0x50, 0xAA, 0x42, 0x6D, 0x08, 0xB7, 0xEA, 0x8C, 

    0x04, 0xF2, 0x3A, 0x7C, 0xBE, 0xF5, 0x22, 0x40, 0x78, 0x13,         // 25
    0x54, 0x30, 0xA1, 0xC2, 0x19, 0xCC, 0x3F, 0x82, 0xA3, 0x06, 
    0xEA, 0x58, 0x30, 0xA4, 0x3B, 0x8E, 0x68, 0xB2, 0xF7, 0x9F, 
    0xDA, 0x18, 0x8A, 0xF6, 0x98, 0xAB, 0x3E, 0xF3, 0x4D, 0xDA, 
    0x0B, 0x80, 0xB6, 0x57, 0x31, 0xAE, 0x20, 0x92, 0x35, 0xE5, 
    0x51, 0x9A, 0x7D, 0x3A, 0xA6, 0x26, 0xD9, 0x5C, 0xE9, 0x2E, 
    0x50, 0x16, 0xDB, 0x44, 0xFD, 0x94, 0xCB, 0xE9, 0xAC, 0x06, 
    0x75, 0x98, 0xE9, 0xBF, 0x3A, 0xFD, 0x21, 0x6E, 0xE5, 0x99, 
    0x5F, 0x7F, 0xB0, 0x70, 0x0C, 0xE2, 0xC0, 0x9A, 0x38, 0x5A, 0xD0, 

    0x4D, 0x84, 0xAE, 0x5F, 0x16, 0x4E, 0xD2, 0xAB, 0xED, 0x64,         // 26
    0xB4, 0xF4, 0x79, 0x3A, 0x91, 0x55, 0xDE, 0xB7, 0x4B, 0x68, 
    0xCB, 0xAB, 0x8A, 0x0A, 0xE4, 0x52, 0xD2, 0x31, 0x01, 0x87, 
    0x52, 0xB7, 0x40, 0x07, 0x5E, 0x25, 0xCB, 0x00, 0xB1, 0x79, 
    0xC2, 0xF8, 0x16, 0x9C, 0xED, 0x87, 0x4F, 0xD1, 0xB8, 0x87, 
    0x18, 0xF9, 0xBB, 0x04, 0xE5, 0x8B, 0x74, 0x08, 0xAB, 0x7B, 
    0xD5, 0x8F, 0x62, 0x9D, 0x06, 0x6D, 0x2C, 0x41, 0x9B, 0x5D, 
    0xD3, 0x4E, 0x28, 0x71, 0x17, 0xA1, 0x40, 0xB8, 0x09, 0xAE, 
    0x2A, 0xC8, 0x19, 0xD8, 0x8F, 0x57, 0x1E, 0xD4, 0x86, 0x22, 0xA9, 

    0x28, 0xC4, 0x0D, 0xD8, 0x9E, 0x88, 0x71, 0x03, 0x35, 0x8A,         // 27
    0xD4, 0x0D, 0x52, 0xDB, 0xB3, 0x76, 0x2A, 0x12, 0xFE, 0x8F, 
    0x1A, 0x41, 0xF1, 0x64, 0xB3, 0x18, 0x9D, 0x7C, 0xC4, 0x69, 
    0x2E, 0xE2, 0x75, 0xC6, 0xE4, 0x7B, 0x8E, 0xDF, 0x2D, 0x58, 
    0x21, 0x65, 0x39, 0xCB, 0x42, 0x6D, 0xE3, 0x11, 0x5C, 0x3B, 
    0xD7, 0x2A, 0x58, 0xD1, 0x68, 0x43, 0xF1, 0x9E, 0x38, 0xC0, 
    0x58, 0x23, 0xEE, 0x33, 0xAF, 0xE6, 0xBC, 0x82, 0x22, 0xC2, 
    0x15, 0xF3, 0xA9, 0x8D, 0xD4, 0x57, 0x80, 0xEE, 0x5A, 0x8A, 
    0x45, 0xFB, 0x65, 0x33, 0xB9, 0xF0, 0x7B, 0x47, 0xF5, 0x6F, 0xDB, 

    0x61, 0xFE, 0x73, 0x2E, 0xEA, 0x3D, 0xBB, 0xE7, 0xA2, 0x49,         // 28
    0x23, 0xA5, 0x88, 0x32, 0x00, 0xE9, 0x9D, 0x61, 0xC0, 0x2F, 
    0xDE, 0x71, 0xC7, 0x26, 0x82, 0xFB, 0x4B, 0xDF, 0x3E, 0xF0, 
    0xAC, 0x11, 0x99, 0x48, 0xB0, 0x17, 0x44, 0x69, 0x98, 0xF0, 
    0xA8, 0x8F, 0xDF, 0x78, 0x02, 0xBC, 0x2B, 0xA7, 0x75, 0xC2, 
    0x98, 0x70, 0xAA, 0x20, 0x97, 0x11, 0xC6, 0x25, 0x6E, 0xF5, 
    0x0E, 0xA6, 0xC3, 0x7A, 0x4A, 0x8E, 0x0C, 0x56, 0xF9, 0x6B, 
    0x8B, 0x36, 0x5A, 0x02, 0xEC, 0xB1, 0x10, 0xCD, 0x26, 0xDC, 
    0xBB, 0x05, 0x9C, 0x7F, 0x4F, 0x2A, 0xA0, 0x02, 0xB3, 0x17, 0x8F, 

    0xA2, 0x40, 0x94, 0x55, 0xC2, 0x10, 0x5A, 0x28, 0x6A, 0xCB,         // 29
    0xF0, 0x5B, 0xC3, 0xF7, 0x67, 0x46, 0xCD, 0x7D, 0x43, 0xA3, 
    0x80, 0x02, 0x9D, 0x54, 0xBD, 0x35, 0x70, 0x0A, 0xBB, 0x1D, 
    0x8C, 0x5E, 0xFD, 0x29, 0x6C, 0xF2, 0xCD, 0xAE, 0x14, 0x3E, 
    0xCB, 0x4C, 0x1B, 0xB5, 0x94, 0xF1, 0x49, 0x8D, 0xF7, 0x07, 
    0x50, 0xE8, 0x39, 0x7D, 0xD8, 0xB0, 0x63, 0x8C, 0xD3, 0x3F, 
    0x92, 0x72, 0x29, 0xD6, 0x15, 0x6A, 0xC5, 0xD7, 0xA1, 0x2D, 
    0xDF, 0xB0, 0xCD, 0x79, 0x2C, 0x49, 0x72, 0x99, 0x3E, 0x68, 
    0x83, 0x4D, 0xE5, 0xC7, 0x0F, 0xD7, 0x6A, 0xC9, 0x52, 0xE8, 0x37, 

    0x07, 0xE3, 0xAE, 0x1E, 0x7A, 0xF6, 0x92, 0xDA, 0x80, 0x0E,         // 30
    0x91, 0x2B, 0x72, 0x16, 0x97, 0xB9, 0x0F, 0xF2, 0x1D, 0xC6, 
    0x56, 0xF7, 0x39, 0xE5, 0x0D, 0xD4, 0x92, 0xA5, 0x55, 0x77, 
    0xDC, 0x38, 0xB8, 0x87, 0x0B, 0xA2, 0x35, 0x5D, 0xE5, 0x86, 
    0x05, 0x6C, 0xFC, 0x32, 0x58, 0x1A, 0xC3, 0x68, 0x32, 0xD5, 
    0x81, 0x17, 0xB3, 0xEE, 0x4A, 0x2E, 0xF8, 0x52, 0x06, 0xBA, 
    0x5C, 0xEC, 0x4E, 0xB4, 0xF7, 0x9F, 0x3B, 0x1C, 0x4D, 0x7D, 
    0x09, 0x63, 0x41, 0xE5, 0x91, 0xC4, 0xFA, 0x1A, 0xC2, 0xF2, 
    0x16, 0xA9, 0x2E, 0x5C, 0xA6, 0x87, 0xFA, 0x34, 0x95, 0x77, 0xD1, 

    0xB2, 0x7D, 0x35, 0xD8, 0xB3, 0x65, 0x1B, 0xAA, 0x34, 0xC0,         // 31
    0x50, 0xAE, 0xD7, 0x3F, 0xDE, 0x85, 0x36, 0x58, 0x93, 0xDC, 
    0x13, 0xAB, 0x6A, 0x8B, 0xAE, 0x60, 0x2D, 0xF4, 0xCE, 0x40, 
    0xA0, 0x03, 0xD2, 0x4F, 0xE1, 0x8E, 0x1F, 0x79, 0xBD, 0x55, 
    0xDC, 0xA0, 0x88, 0xC9, 0x73, 0x9F, 0xDD, 0x10, 0xB1, 0x47, 
    0x9D, 0xC8, 0x62, 0x02, 0x6F, 0x89, 0x1C, 0xA3, 0xE4, 0x99, 
    0x32, 0xC4, 0x00, 0x89, 0x20, 0x5A, 0xE5, 0x92, 0xB8, 0xEC, 
    0xCB, 0x9B, 0x1B, 0xB7, 0x0E, 0x67, 0x33, 0xAD, 0x7D, 0x47, 
    0x98, 0xD8, 0x74, 0xF1, 0x1D, 0x3F, 0x5F, 0x0D, 0xAC, 0x24, 0x5E, 

    0xF8, 0x16, 0x69, 0x91, 0x00, 0x3F, 0xD2, 0x4C, 0xFA, 0x67,         // 32
    0xDF, 0x05, 0x7C, 0xB1, 0x22, 0x70, 0xE8, 0xAA, 0x6A, 0x3F, 
    0x88, 0x2B, 0xD8, 0x15, 0x44, 0xEA, 0x7E, 0x10, 0x8B, 0x23, 
    0xE9, 0x6C, 0x82, 0x2E, 0xBC, 0x57, 0xD0, 0xFA, 0x10, 0x39, 
    0xB7, 0x23, 0x49, 0x09, 0xEB, 0x37, 0x7F, 0x55, 0xEC, 0x72, 
    0x26, 0xFE, 0x33, 0x9B, 0xCE, 0xB6, 0xDA, 0x3C, 0x68, 0x1E, 
    0x7E, 0xDC, 0xAD, 0x6F, 0x36, 0xCA, 0x79, 0x0E, 0x61, 0x42, 
    0x22, 0x72, 0xF8, 0x7F, 0x4D, 0xE1, 0x94, 0x56, 0x02, 0xCF, 
    0x26, 0x58, 0x0C, 0xB5, 0x90, 0xDE, 0xC0, 0x7F, 0xEB, 0xCA, 0x48, 

    0x3A, 0xC7, 0xE1, 0x4D, 0xF2, 0xBF, 0x96, 0x7A, 0x13, 0xA7,         // 33
    0x2D, 0x97, 0x47, 0xFB, 0x59, 0xC2, 0x06, 0xD2, 0x20, 0xF5, 
    0xBF, 0x5C, 0xB5, 0x78, 0x9E, 0x1D, 0xC8, 0x4E, 0xAA, 0x64, 
    0xC1, 0x43, 0xAE, 0xF6, 0x13, 0x74, 0x41, 0xAB, 0x96, 0x70, 
    0xEE, 0x67, 0xAF, 0xD7, 0x5D, 0xBA, 0x22, 0xCD, 0x8C, 0x05, 
    0xBC, 0x5B, 0x7C, 0xE4, 0x3D, 0x5D, 0x0A, 0x81, 0xCA, 0xFA, 
    0x57, 0x25, 0x42, 0x9D, 0xE0, 0xB1, 0x2C, 0xFD, 0xC6, 0x8B, 
    0xAB, 0x50, 0xD1, 0x34, 0xA8, 0xCB, 0x1F, 0xE7, 0xB9, 0x66, 
    0xEA, 0x86, 0xC4, 0x4D, 0x79, 0x31, 0x9A, 0x42, 0x18, 0x6F, 0x9E, 

    0x8C, 0x62, 0xA5, 0x2C, 0x73, 0x24, 0x5B, 0xE8, 0x3B, 0x87,         // 34
    0xEF, 0x6C, 0xCC, 0x14, 0xA3, 0x34, 0x8C, 0x55, 0x9D, 0x75, 
    0x04, 0xE4, 0x33, 0xFD, 0x57, 0xBA, 0x6A, 0xE0, 0x33, 0xFB, 
    0x0E, 0x93, 0x1C, 0x5F, 0x9D, 0xE7, 0x05, 0x80, 0x2B, 0xC2, 
    0x14, 0x93, 0x2F, 0x78, 0x13, 0x91, 0xFA, 0x44, 0xAC, 0x3B, 
    0xDF, 0x93, 0x0D, 0xAC, 0x24, 0x92, 0xED, 0x4D, 0xAB, 0x0D, 
    0xB9, 0x8D, 0xF1, 0x60, 0x0B, 0x4F, 0xA1, 0x6C, 0x3B, 0x02, 
    0xEE, 0x2C, 0x92, 0x66, 0x05, 0x84, 0x3C, 0x6E, 0x8B, 0x2E, 
    0xA7, 0x40, 0xFC, 0x22, 0xD2, 0x09, 0xF5, 0x66, 0xDA, 0xBB, 0x06, 

    0x32, 0xBD, 0x0C, 0x87, 0xDE, 0xAB, 0x0B, 0xB9, 0xD3, 0x53,         // 35
    0x0F, 0xB4, 0x32, 0x7E, 0xDC, 0x67, 0xF1, 0x42, 0xCA, 0x30, 
    0xAE, 0x47, 0x8F, 0x0A, 0xD2, 0x2B, 0x9A, 0x04, 0x7A, 0xB5, 
    0x54, 0xDC, 0xC5, 0x7F, 0x32, 0xB6, 0xCD, 0x58, 0xF3, 0x46, 
    0xDB, 0x57, 0xCA, 0xF0, 0xAA, 0x4A, 0x6B, 0x1B, 0x76, 0xCB, 
    0x52, 0x2C, 0xEF, 0x50, 0xD4, 0x6D, 0xC2, 0x1A, 0x96, 0x39, 
    0x75, 0xD0, 0x17, 0xC0, 0x88, 0xE7, 0x20, 0x85, 0xD1, 0xB5, 
    0x5E, 0xDD, 0x18, 0xC1, 0xF0, 0x59, 0xAE, 0xF4, 0x0F, 0xDB, 
    0x60, 0x07, 0x97, 0x6C, 0xB2, 0x5F, 0xA2, 0x27, 0x85, 0x54, 0xED, 

    0xD4, 0x4C, 0xF6, 0x58, 0xCC, 0x34, 0x8F, 0x6F, 0x25, 0xA1,         // 36
    0xC8, 0x5C, 0xEC, 0x4E, 0x92, 0x0D, 0xB5, 0x1B, 0xE1, 0x82, 
    0x5F, 0xC7, 0x6E, 0xAB, 0x4C, 0x87, 0xE9, 0x41, 0xCF, 0x8F, 
    0x2C, 0x73, 0x3A, 0xEB, 0x53, 0x25, 0x91, 0x1A, 0xB0, 0x77, 
    0xA1, 0x00, 0x86, 0x3D, 0x23, 0xDC, 0xC6, 0xA0, 0xE5, 0x12, 
    0x9B, 0x6E, 0xB2, 0x81, 0x11, 0xA2, 0x33, 0x7E, 0xF1, 0x62, 
    0xE6, 0x52, 0x30, 0x72, 0x3B, 0xC8, 0x61, 0xF0, 0x14, 0x4B, 
    0x81, 0xA6, 0x6F, 0x99, 0x32, 0xD5, 0x16, 0x97, 0x54, 0xBD, 
    0x7B, 0xAE, 0x28, 0xDD, 0x37, 0xE9, 0x47, 0xCD, 0xAD, 0x20, 0x7A, 

    0x15, 0x95, 0x71, 0x23, 0x9E, 0x4C, 0xFD, 0x44, 0xE1, 0x78,         // 37
    0x1E, 0x8A, 0x02, 0xAF, 0x2B, 0xD1, 0x79, 0x61, 0x99, 0x0E, 
    0xF6, 0x25, 0xDF, 0x1C, 0xF3, 0x67, 0x14, 0xA8, 0x6E, 0x1B, 
    0xE5, 0xA0, 0x01, 0xAA, 0xCF, 0x83, 0xE6, 0x67, 0xD7, 0x3E, 
    0x25, 0xFC, 0xC0, 0x75, 0x99, 0x5C, 0x05, 0x7E, 0x30, 0x60, 
    0xF7, 0xC6, 0x25, 0xDB, 0x3E, 0xFC, 0x5C, 0xD5, 0x26, 0xB1, 
    0x06, 0x99, 0xAB, 0xFB, 0x96, 0x06, 0xA9, 0x33, 0x93, 0xE0, 
    0x1D, 0x39, 0xCB, 0x0A, 0x4E, 0x8A, 0x68, 0xCE, 0x3E, 0x1B, 
    0xF6, 0x4A, 0xC2, 0x7F, 0x14, 0x95, 0x78, 0x02, 0xFD, 0x41, 0xA0, 

    0xC5, 0x2F, 0xE1, 0xB5, 0x11, 0x7D, 0xBA, 0x04, 0x98, 0x36,         // 38
    0xF7, 0xCE, 0x6F, 0xE4, 0x9C, 0x41, 0xFE, 0x34, 0xC3, 0x4E, 
    0xA7, 0x43, 0x99, 0x7F, 0x36, 0xBB, 0xDA, 0x58, 0xF8, 0x47, 
    0xC1, 0x5C, 0xF3, 0x47, 0x6F, 0x0E, 0x3A, 0xA0, 0x09, 0x8D, 
    0xB6, 0x6A, 0x50, 0x0F, 0xEC, 0xBB, 0x3A, 0xF2, 0xBE, 0x8B, 
    0x3F, 0x01, 0x5A, 0x94, 0x66, 0xB6, 0x05, 0x9D, 0x51, 0xCB, 
    0x83, 0x3E, 0xC9, 0x14, 0x5C, 0xDB, 0x7A, 0x51, 0xC4, 0x66, 
    0xB1, 0xF4, 0x62, 0xD9, 0xAC, 0xFC, 0x2B, 0xB0, 0x76, 0xD5, 
    0x8B, 0x31, 0xE8, 0x57, 0xA9, 0x41, 0xBE, 0x59, 0x91, 0x69, 0xE6, 

    0x5B, 0x85, 0x44, 0xCF, 0x64, 0xE5, 0x52, 0xD1, 0x63, 0xB5,         // 39
    0x57, 0xA3, 0x48, 0x20, 0x60, 0x84, 0xA9, 0x1D, 0xE7, 0x85, 
    0x6B, 0xD8, 0x15, 0xC5, 0x55, 0xA0, 0x25, 0x84, 0x08, 0x98, 
    0x78, 0x13, 0x88, 0x27, 0x9B, 0xFE, 0xC5, 0x4E, 0xEE, 0x59, 
    0xD1, 0x2E, 0xE2, 0xA5, 0x34, 0x6D, 0x90, 0x4E, 0x1A, 0xDA, 
    0xAE, 0x7D, 0xE9, 0xBD, 0x17, 0x7A, 0xE4, 0x35, 0x73, 0x18, 
    0xDD, 0x6D, 0x27, 0xE5, 0x84, 0x3D, 0xBC, 0x26, 0xF7, 0x05, 
    0x88, 0x29, 0x96, 0x3F, 0x78, 0x12, 0x58, 0xE9, 0x23, 0xA2, 
    0x00, 0x63, 0x96, 0x0C, 0xC9, 0xF3, 0x1B, 0xD5, 0x29, 0xBB, 0x0F, 

    0xB0, 0xFA, 0x01, 0x92, 0x2A, 0xAC, 0x16, 0x82, 0x22, 0xE5,         // 40
    0x31, 0x12, 0x82, 0xC2, 0xED, 0x08, 0xCF, 0x73, 0x47, 0x00, 
    0xBF, 0x31, 0x60, 0xEF, 0x04, 0x8C, 0xD1, 0x3C, 0xB4, 0xE3, 
    0x37, 0xD4, 0xB4, 0xDD, 0x60, 0xB1, 0x22, 0x73, 0xBD, 0x13, 
    0x7B, 0x9C, 0x15, 0x7F, 0xC3, 0x18, 0xDD, 0xA6, 0x7C, 0x34, 
    0x54, 0x9F, 0x29, 0x46, 0xF4, 0x3B, 0x8B, 0xC7, 0xA8, 0xF9, 
    0x45, 0xB7, 0x8F, 0x52, 0xAC, 0x1B, 0xE3, 0x9E, 0x78, 0x41, 
    0xDB, 0x58, 0xC1, 0x1F, 0xE3, 0xA1, 0xC2, 0x89, 0x4B, 0x6A, 
    0xEF, 0xB3, 0xD3, 0x7C, 0x26, 0x65, 0xA6, 0x7F, 0xEC, 0x3B, 0x7C, 

    0x27, 0x4C, 0xA8, 0x74, 0xEF, 0x3C, 0x9A, 0xF3, 0xBD, 0x77,         // 41
    0x92, 0xAE, 0xD6, 0x3F, 0xB5, 0x31, 0x59, 0x97, 0xDA, 0xB1, 
    0xF8, 0x8C, 0xAB, 0x7A, 0xD8, 0x48, 0x71, 0xF2, 0x62, 0x20, 
    0xA4, 0x67, 0x2D, 0x50, 0x16, 0x7E, 0x43, 0xE1, 0x93, 0x33, 
    0xF6, 0x45, 0xD7, 0x5F, 0xF7, 0x4B, 0xB7, 0x5C, 0x06, 0xFD, 
    0xC8, 0x0F, 0xD7, 0x74, 0x97, 0xCD, 0x1F, 0x63, 0x29, 0x86, 
    0x0C, 0x60, 0xF0, 0x01, 0xCD, 0x6B, 0x8A, 0x0D, 0x57, 0xBF, 
    0xA3, 0x11, 0xEF, 0x87, 0x4F, 0x6E, 0x31, 0x0E, 0xDF, 0xC5, 
    0x40, 0x20, 0x52, 0x36, 0xE0, 0x8B, 0x3A, 0x13, 0x50, 0x9C, 0xDB, 

    0xC0, 0x6A, 0xDF, 0x19, 0x51, 0xD6, 0x6E, 0x32, 0x5B, 0x06,         // 42
    0x49, 0xFA, 0x5C, 0x0F, 0x6F, 0xA0, 0xF6, 0x3A, 0x17, 0x62, 
    0x23, 0x52, 0x0F, 0x34, 0xB9, 0x1C, 0xA6, 0x0F, 0xCA, 0x86, 
    0x4C, 0xFA, 0x8C, 0xCA, 0xE7, 0x98, 0xBB, 0x02, 0x6B, 0xA9, 
    0x58, 0xBF, 0x23, 0x94, 0x09, 0x7A, 0x2F, 0xE5, 0x92, 0xB6, 
    0x67, 0x8B, 0x4D, 0xB8, 0x13, 0x54, 0xA2, 0xEF, 0x4B, 0xD5, 
    0xA0, 0xC3, 0x2C, 0x97, 0x44, 0xFA, 0x38, 0xC8, 0xE7, 0x30, 
    0x81, 0x6C, 0x36, 0xB4, 0x0A, 0xCB, 0xF8, 0x9B, 0x71, 0x17, 
    0xA4, 0x85, 0xFC, 0xBC, 0x9C, 0x54, 0xF6, 0xB2, 0xCE, 0x65, 0x0A, 

    0x9F, 0x34, 0x84, 0xC7, 0xB4, 0x8E, 0x0A, 0xC9, 0xA0, 0xE1,         // 43
    0xC1, 0x25, 0x7E, 0xE8, 0x8F, 0x1D, 0xC5, 0x83, 0xAF, 0x78, 
    0x9C, 0xC8, 0xDF, 0x69, 0xFD, 0x91, 0x5F, 0xBC, 0x31, 0xE0, 
    0x13, 0xB9, 0x24, 0x74, 0x0B, 0x3A, 0xF8, 0x53, 0xD1, 0x1A, 
    0xE0, 0x82, 0xAF, 0x36, 0xD3, 0xA5, 0xC8, 0x21, 0x71, 0x3D, 
    0x18, 0xE4, 0x2C, 0xEF, 0x6D, 0xDA, 0x02, 0x78, 0xB3, 0x1A, 
    0x70, 0x3F, 0xD7, 0x74, 0xB6, 0x1F, 0x5F, 0xAB, 0x90, 0x1E, 
    0xFE, 0xCB, 0x5B, 0xE0, 0x93, 0x3B, 0x57, 0xAF, 0x36, 0x8C, 
    0xDB, 0x5E, 0x07, 0x70, 0x1B, 0xD6, 0x03, 0x6E, 0x90, 0x3E, 0xEB, 

    0x53, 0xF7, 0x08, 0x63, 0x22, 0x43, 0xFC, 0x54, 0x82, 0x1D,         // 44
    0x66, 0xA8, 0x3D, 0xB9, 0x52, 0xDD, 0x44, 0x06, 0xE6, 0x2C, 
    0xEF, 0x3B, 0xB2, 0x86, 0x3F, 0x24, 0xE9, 0x83, 0x59, 0x98, 
    0x6F, 0xE9, 0x43, 0xA8, 0xC3, 0x66, 0x89, 0x27, 0x7A, 0x9C, 
    0x38, 0x06, 0x71, 0xE4, 0x61, 0x42, 0x8A, 0x55, 0xED, 0xA1, 
    0xCF, 0x58, 0x93, 0xA9, 0x3A, 0x8E, 0xC1, 0x33, 0xE2, 0x57, 
    0xF4, 0x85, 0x18, 0x55, 0xEA, 0x81, 0xDA, 0x10, 0x71, 0x53, 
    0xB1, 0x01, 0xA0, 0x28, 0x6F, 0xD9, 0x80, 0x03, 0xEE, 0x4C, 
    0xC3, 0x32, 0xE2, 0xAD, 0x4D, 0x7A, 0xC1, 0x2F, 0xE4, 0x19, 0x7B, 

    0x22, 0x93, 0xCE, 0xA2, 0xE4, 0x7A, 0xAB, 0x14, 0xEA, 0x37,         // 45
    0xD3, 0x88, 0x01, 0xCF, 0x2D, 0x76, 0xA9, 0x61, 0xCF, 0x4D, 
    0x93, 0x1B, 0x5D, 0x09, 0xA2, 0xC2, 0x47, 0x01, 0xCD, 0x3F, 
    0xB0, 0x08, 0x8F, 0x56, 0xF0, 0x1C, 0xD7, 0xB4, 0xED, 0x4A, 
    0xC9, 0xF3, 0x4F, 0x97, 0x26, 0xFB, 0x17, 0xCE, 0x08, 0x81, 
    0x26, 0xB5, 0x07, 0x62, 0x1D, 0xFC, 0x46, 0x84, 0x25, 0x95, 
    0x06, 0xB6, 0xE0, 0xA6, 0x08, 0x48, 0x9E, 0x32, 0xED, 0xD0, 
    0x3B, 0x79, 0x49, 0xF5, 0x13, 0xA7, 0x2F, 0xC6, 0x66, 0xB2, 
    0x0F, 0x7C, 0x98, 0x23, 0xEF, 0x8F, 0x46, 0xA4, 0x5F, 0xCB, 0xB1, 

    0xDB, 0x69, 0x41, 0x27, 0x56, 0xCA, 0x3A, 0x6B, 0xB8, 0x9A,         // 46
    0x4A, 0xEE, 0x6A, 0x96, 0xF9, 0x15, 0x8B, 0xBF, 0x25, 0x72, 
    0xBB, 0x7C, 0xCA, 0xF3, 0x50, 0xE0, 0x7C, 0xAA, 0xF6, 0x1F, 
    0xDB, 0x64, 0xCC, 0x28, 0x82, 0x4B, 0xA5, 0x34, 0x0C, 0x64, 
    0x88, 0xA9, 0x18, 0xC7, 0x79, 0xB8, 0x99, 0x6B, 0xB0, 0x52, 
    0xF8, 0x70, 0xE6, 0xC7, 0x7D, 0xB2, 0x5E, 0xD9, 0xAE, 0x69, 
    0xCC, 0x35, 0x63, 0x29, 0x8E, 0xCF, 0x62, 0xBD, 0x82, 0x17, 
    0x96, 0xE4, 0xBA, 0x86, 0xCA, 0x47, 0xE8, 0x96, 0x1B, 0x84, 
    0xF6, 0x41, 0x60, 0xC8, 0x3A, 0xD3, 0x1E, 0xFE, 0x0C, 0x84, 0x4B, 

    0x0F, 0xBE, 0x7F, 0xEB, 0x88, 0x19, 0x98, 0xDD, 0x2D, 0x77,         // 47
    0x0F, 0xB5, 0x1E, 0x48, 0xB0, 0x59, 0xE7, 0x49, 0x9F, 0xF6, 
    0x02, 0xDD, 0x2F, 0x6D, 0x96, 0x19, 0x67, 0x32, 0x8D, 0x53, 
    0x7E, 0x2D, 0x9B, 0xE6, 0xB9, 0x03, 0x71, 0x94, 0xDD, 0xBA, 
    0x21, 0x46, 0x6C, 0xEB, 0x02, 0x5A, 0x3D, 0xEC, 0x2D, 0xD6, 
    0x37, 0x8D, 0x44, 0x27, 0xD8, 0x0A, 0x97, 0x3D, 0x12, 0xF8, 
    0x49, 0xA3, 0x7A, 0xF2, 0xB9, 0x36, 0xF6, 0x0C, 0x54, 0xAE, 
    0x64, 0x33, 0x0F, 0x54, 0x69, 0x19, 0x7B, 0x52, 0xE0, 0x36, 
    0x9E, 0xD6, 0xB5, 0x0B, 0x7F, 0x59, 0xB4, 0x70, 0x99, 0x38, 0xF2, 

    0xAA, 0x34, 0xD6, 0x06, 0xB1, 0xF6, 0x60, 0x0B, 0xC0, 0xF9,         // 48
    0x5E, 0xDB, 0x83, 0xCC, 0x26, 0x7B, 0x0A, 0xD5, 0x1D, 0x69, 
    0x47, 0x91, 0xAF, 0x11, 0xD9, 0x3C, 0xB6, 0xCA, 0x0E, 0xA5, 
    0xBF, 0xFC, 0x50, 0x19, 0x67, 0xD3, 0xF9, 0x57, 0x40, 0x78, 
    0xF6, 0xD1, 0xA0, 0x35, 0xBD, 0x86, 0xD9, 0x10, 0x7C, 0x9A, 
    0x14, 0xC3, 0x5D, 0xA0, 0x73, 0x37, 0xED, 0xC8, 0x78, 0x9A, 
    0x21, 0xDE, 0x0B, 0x43, 0x83, 0x1D, 0x72, 0x95, 0xDF, 0x23, 
    0xF8, 0xC6, 0x92, 0xDD, 0xA3, 0xF1, 0xBE, 0x26, 0xCC, 0x59, 
    0x12, 0x66, 0x30, 0xF9, 0x9E, 0x17, 0xE7, 0x31, 0xD7, 0xBD, 0x61, 

    0x77, 0x95, 0x51, 0x6E, 0x2F, 0x44, 0xA8, 0x80, 0x4F, 0x92,         // 49
    0x27, 0xA2, 0x35, 0x67, 0xF0, 0xBF, 0x99, 0x3B, 0x82, 0xB4, 
    0xE9, 0x35, 0x77, 0x4B, 0xA4, 0x83, 0xF2, 0x4D, 0xE7, 0x68, 
    0x3A, 0x07, 0x75, 0xAA, 0x39, 0x89, 0x23, 0xC2, 0x11, 0x9C, 
    0x33, 0x15, 0x82, 0x56, 0xE0, 0x20, 0xAE, 0x4F, 0xCA, 0x60, 
    0xAA, 0xE8, 0x01, 0xF7, 0xBD, 0x59, 0x88, 0x2B, 0x4C, 0xE7, 
    0x66, 0x88, 0xB2, 0xD2, 0x56, 0xE8, 0xAC, 0x3B, 0xC8, 0x4A, 
    0xA4, 0x75, 0x25, 0x46, 0x03, 0x89, 0x43, 0x9F, 0x75, 0xAA, 
    0xEB, 0x7F, 0x95, 0x4B, 0xCB, 0x67, 0x89, 0x4E, 0x00, 0x8B, 0x27, 

    0xED, 0x11, 0xE2, 0xB8, 0xD2, 0x8F, 0xE3, 0x30, 0xD3, 0x11,         // 50
    0xC7, 0x44, 0xE3, 0x04, 0xA1, 0x31, 0x61, 0xFE, 0xC5, 0x52, 
    0x15, 0xD1, 0xB7, 0xFB, 0x61, 0x04, 0x2E, 0x9E, 0x24, 0x87, 
    0xDD, 0xC6, 0x90, 0xE2, 0xBC, 0x52, 0xA7, 0x7F, 0xE6, 0xCB, 
    0x67, 0xB7, 0xEF, 0x0C, 0x9A, 0x6D, 0x36, 0x92, 0xFE, 0x21, 
    0x46, 0x76, 0x97, 0x41, 0x22, 0xDA, 0x0E, 0xA5, 0xBE, 0x03, 
    0xCF, 0x50, 0x26, 0x93, 0x16, 0xC0, 0x5C, 0x02, 0x77, 0x91, 
    0x11, 0x5F, 0xEE, 0xB3, 0xCE, 0x6B, 0x1C, 0xFA, 0x06, 0x3C, 
    0xBD, 0x21, 0xD0, 0x05, 0xAA, 0x2C, 0xD1, 0xA3, 0xF5, 0x58, 0xCC, 

    0x46, 0xA4, 0x2C, 0x7D, 0x16, 0x52, 0x01, 0xB5, 0x64, 0xEE,         // 51
    0x85, 0x6D, 0xB7, 0x8C, 0x4E, 0xDC, 0x14, 0x74, 0x27, 0xA3, 
    0x8E, 0x65, 0x2D, 0x1A, 0xC2, 0xDD, 0x73, 0xD2, 0x59, 0xB4, 
    0x1C, 0x45, 0x5B, 0x16, 0x2D, 0xF1, 0x08, 0x5F, 0x29, 0x51, 
    0x91, 0x41, 0x72, 0xCC, 0x47, 0xF3, 0xC1, 0x04, 0x79, 0xB5, 
    0xDE, 0x19, 0xD1, 0x69, 0x8D, 0xB5, 0x6D, 0xF8, 0x59, 0x83, 
    0x3E, 0xBA, 0xFE, 0x6C, 0xDC, 0x34, 0x9E, 0xFA, 0xD4, 0x2A, 
    0xE7, 0xC3, 0x36, 0x7C, 0x4D, 0xE7, 0xB1, 0x5D, 0x87, 0xDC, 
    0x6C, 0x48, 0xF1, 0x75, 0x56, 0xE9, 0x12, 0x7A, 0x34, 0xB0, 0x1C, 

    0x6A, 0xC4, 0x59, 0xF0, 0xA9, 0x6C, 0xFE, 0x7D, 0x3D, 0x9E,         // 52
    0x4B, 0x26, 0xFA, 0x17, 0x75, 0xB9, 0x8F, 0xD2, 0x44, 0xEA, 
    0x0C, 0xDF, 0x80, 0x9C, 0x3D, 0xA8, 0x4F, 0x93, 0x09, 0xEE, 
    0x78, 0xA2, 0xF5, 0x7A, 0xC8, 0x6D, 0xD8, 0x98, 0xB9, 0xFD, 
    0x00, 0xE1, 0x1D, 0xA6, 0x2B, 0x86, 0x5C, 0xD7, 0x53, 0x31, 
    0x87, 0x5B, 0xA6, 0x10, 0xEF, 0x2F, 0x4A, 0x99, 0x28, 0xE2, 
    0xA0, 0x2E, 0x80, 0x06, 0xAA, 0x64, 0x7E, 0x25, 0x52, 0xAB, 
    0x3B, 0x87, 0x0A, 0xA5, 0x26, 0x8F, 0x3B, 0xD6, 0x2B, 0x98, 
    0x0E, 0xA8, 0x89, 0x38, 0xBE, 0x90, 0x41, 0xC4, 0x64, 0xE3, 0x83, 

    0xFB, 0x04, 0x9A, 0x3F, 0x24, 0xCA, 0x98, 0x1D, 0xC5, 0x14,         // 53
    0xBA, 0xD6, 0x5F, 0xAA, 0x3F, 0xEC, 0x57, 0x06, 0xB3, 0x79, 
    0x58, 0xC4, 0x49, 0xF0, 0x7A, 0x14, 0xF7, 0x3C, 0xBE, 0x69, 
    0x28, 0xD0, 0x03, 0x9A, 0x42, 0xA8, 0x4C, 0x21, 0x70, 0x33, 
    0xA2, 0x7C, 0xC5, 0x67, 0xE8, 0x13, 0xA9, 0x25, 0x9C, 0xEA, 
    0xC9, 0x2A, 0xE2, 0x50, 0xC4, 0x7A, 0xDF, 0x16, 0xCA, 0x6B, 
    0x11, 0xEA, 0x5B, 0xC5, 0x44, 0xE4, 0x0F, 0xC7, 0x8E, 0x6E, 
    0xBD, 0x5B, 0xD4, 0xFD, 0x65, 0xC4, 0x09, 0x78, 0xBF, 0xE9, 
    0x57, 0xC8, 0x24, 0xE1, 0x17, 0x60, 0xF9, 0x9D, 0x2A, 0x0F, 0x97, 

    0x30, 0xCE, 0x75, 0xDD, 0x86, 0x55, 0x2E, 0xD8, 0x58, 0xE8,         // 54
    0x73, 0x09, 0x96, 0x31, 0xD5, 0x1B, 0xA7, 0x83, 0xF5, 0x2C, 
    0x9A, 0x37, 0xB0, 0x05, 0x5F, 0xC6, 0x8A, 0x20, 0xD9, 0x96, 
    0x43, 0xB1, 0x80, 0x33, 0xE7, 0x14, 0x89, 0xED, 0xC7, 0x48, 
    0xD8, 0x57, 0x2E, 0x95, 0x4F, 0xD1, 0x72, 0xF5, 0x41, 0x66, 
    0x07, 0x98, 0x6E, 0xB0, 0x3F, 0x0A, 0xAC, 0x7F, 0x39, 0xB9, 
    0x89, 0x4C, 0xD5, 0x97, 0x26, 0x88, 0xB2, 0xED, 0x3E, 0x07, 
    0xF4, 0x1B, 0x93, 0x42, 0x1E, 0xE4, 0x9E, 0x4B, 0x14, 0x85, 
    0x2F, 0xFC, 0x6C, 0x9E, 0x80, 0xD4, 0x06, 0x6F, 0xD9, 0xBC, 0x4A, 

    0xA9, 0x5C, 0x20, 0xB9, 0x0A, 0xEE, 0xB6, 0x69, 0x90, 0x38,         // 55
    0xAB, 0x4F, 0xF0, 0x83, 0xBB, 0x71, 0x46, 0x22, 0xCC, 0x6F, 
    0xE3, 0x18, 0xD5, 0x91, 0xE1, 0x29, 0x71, 0xAB, 0x5A, 0x11, 
    0xFE, 0x57, 0xE1, 0x6B, 0xC2, 0x5E, 0xB2, 0x09, 0x7F, 0x9B, 
    0x12, 0xB1, 0xF8, 0x06, 0xB6, 0x33, 0x8E, 0x0B, 0xB4, 0x7E, 
    0xC0, 0x39, 0xEB, 0x1D, 0x8A, 0xFC, 0x57, 0xD5, 0x50, 0xF5, 
    0x2A, 0xB0, 0x0B, 0x74, 0xF5, 0x51, 0x2E, 0x60, 0x9C, 0xD5, 
    0x78, 0x4D, 0xC6, 0x73, 0xAF, 0x80, 0x5A, 0xF7, 0xB3, 0x65, 
    0xA4, 0x43, 0x01, 0xBA, 0x4C, 0x30, 0xB0, 0x45, 0x8F, 0x60, 0xE1, 

    0x0C, 0x8F, 0xF5, 0x66, 0x96, 0x36, 0x7B, 0x13, 0xF7, 0x1F,         // 56
    0x7C, 0xC0, 0x24, 0x65, 0x00, 0xF9, 0xC6, 0x9E, 0x53, 0x08, 
    0xAC, 0x64, 0x80, 0x52, 0x3B, 0xB3, 0xD4, 0x41, 0xE7, 0x82, 
    0xC1, 0x30, 0x0D, 0xA7, 0x1F, 0xFA, 0x45, 0xCF, 0x61, 0x2A, 
    0xEA, 0x6E, 0x3F, 0x81, 0xE3, 0x62, 0xC4, 0x57, 0xDD, 0x18, 
    0xF9, 0x5A, 0x80, 0xCC, 0x5E, 0xA1, 0x24, 0x8E, 0x00, 0xA4, 
    0x63, 0xE2, 0x40, 0xBD, 0x19, 0xA2, 0xDB, 0x84, 0x1E, 0xB6, 
    0x34, 0xA5, 0xE1, 0x00, 0x32, 0xCD, 0x17, 0x38, 0xD3, 0x1D, 
    0xC5, 0x7E, 0xDC, 0x28, 0xF3, 0xC6, 0x79, 0xEC, 0x19, 0x37, 0x7B, 

    0xC1, 0x42, 0x2A, 0xD4, 0x4A, 0xA6, 0xDE, 0x4E, 0xC2, 0x9C,         // 57
    0xE3, 0x40, 0xD9, 0xAD, 0x3E, 0x8E, 0x61, 0x30, 0xE8, 0x8C, 
    0x43, 0xFD, 0x2A, 0xA3, 0xEA, 0x1C, 0x65, 0x00, 0xA3, 0x23, 
    0x62, 0x9B, 0xD8, 0x83, 0x39, 0x9A, 0x78, 0x30, 0xE2, 0xBF, 
    0x4C, 0x94, 0xD3, 0x24, 0x9F, 0x13, 0xF1, 0x2E, 0x98, 0x4F, 
    0xA5, 0x2A, 0xBB, 0x04, 0xDA, 0x33, 0xE4, 0xBC, 0x6F, 0xD8, 
    0x15, 0x7E, 0x94, 0x59, 0xCD, 0x6A, 0x02, 0xC3, 0x57, 0xEA, 
    0x8D, 0x21, 0x60, 0x8B, 0xF2, 0x64, 0xAA, 0x8D, 0x72, 0x47, 
    0xE9, 0x56, 0x9B, 0x66, 0x8C, 0x5B, 0x0D, 0xAC, 0xD6, 0x9F, 0xF2, 

    0x54, 0xDD, 0xAD, 0x7F, 0x1B, 0xC8, 0x02, 0x94, 0x32, 0x5A,         // 58
    0x08, 0x69, 0x95, 0x16, 0xCC, 0xDF, 0x10, 0xB6, 0x75, 0xD6, 
    0x1A, 0xC5, 0xB1, 0x08, 0x73, 0x97, 0xF9, 0x8D, 0xD0, 0x4A, 
    0xF0, 0x73, 0x42, 0xBC, 0x63, 0xDD, 0x15, 0xA5, 0x86, 0x04, 
    0xA7, 0x19, 0x56, 0xB9, 0x73, 0x42, 0x87, 0xAF, 0x6F, 0x21, 
    0xD9, 0x8F, 0x48, 0x6E, 0x9A, 0x4F, 0x79, 0x1C, 0x44, 0x9B, 
    0x37, 0xFB, 0x21, 0xDD, 0x38, 0x8A, 0xF9, 0x32, 0x75, 0x0B, 
    0x49, 0xF8, 0xBA, 0x3D, 0xA1, 0x47, 0xDF, 0x05, 0xF1, 0x9D, 
    0x0C, 0x33, 0xAF, 0x10, 0xD2, 0x25, 0x97, 0x4F, 0x2C, 0x65, 0x15, 

    0x76, 0x98, 0x06, 0x64, 0xF0, 0x89, 0x5F, 0xF3, 0x74, 0xD6,         // 59
    0xB4, 0xFB, 0x2F, 0x74, 0x54, 0x85, 0x46, 0xF3, 0x23, 0x57, 
    0x9C, 0x76, 0x59, 0xDA, 0x45, 0xC8, 0x55, 0x37, 0x77, 0xBE, 
    0x09, 0xAC, 0x28, 0xF5, 0x02, 0xC7, 0x5A, 0xEF, 0x47, 0x70, 
    0xFC, 0x7D, 0xE0, 0x37, 0xEC, 0xC8, 0x5A, 0x01, 0xD3, 0xB7, 
    0x76, 0x15, 0xEF, 0xC6, 0x13, 0xF5, 0xAA, 0xCB, 0xEE, 0x5B, 
    0xC9, 0xAD, 0x67, 0x9F, 0x11, 0xB4, 0x54, 0x9C, 0xE4, 0xB2, 
    0xD3, 0x6D, 0x0F, 0xCF, 0x27, 0x84, 0xC1, 0x35, 0x5E, 0xBE, 
    0x84, 0xCD, 0x76, 0xE8, 0x3A, 0xB5, 0xFE, 0x74, 0xCA, 0x8B, 0xBC, 

    0x3E, 0xFB, 0x4C, 0xBD, 0x25, 0x3B, 0xBA, 0x27, 0xA4, 0x13,         // 60
    0x48, 0x80, 0xA9, 0xE5, 0xB7, 0x21, 0x9F, 0x6D, 0xAD, 0xCF, 
    0x3B, 0x10, 0xF0, 0x2E, 0x88, 0x18, 0xB8, 0x11, 0xE6, 0x32, 
    0x87, 0xDF, 0x53, 0x96, 0x7A, 0x36, 0x8D, 0xB9, 0x24, 0xC9, 
    0x35, 0xC1, 0x60, 0x07, 0xA1, 0x1C, 0x97, 0xFC, 0x4A, 0x35, 
    0xE3, 0x60, 0xA1, 0x3C, 0x89, 0x2D, 0x6A, 0x06, 0x8B, 0x26, 
    0x78, 0x09, 0x4C, 0xE7, 0x79, 0x45, 0xCF, 0x12, 0x86, 0x5A, 
    0x37, 0x9B, 0x80, 0x5E, 0xE5, 0x13, 0x70, 0x96, 0xDA, 0x22, 
    0x3F, 0xF9, 0x18, 0x4B, 0x88, 0x62, 0xD6, 0x42, 0x0B, 0xEC, 0x24, 

    0xA4, 0x1A, 0x8B, 0xD7, 0x9B, 0xE2, 0x80, 0x56, 0xE7, 0x8C,         // 61
    0xCD, 0x25, 0x5D, 0x04, 0x44, 0xED, 0xC9, 0x07, 0x4C, 0x87, 
    0xE2, 0xB9, 0x7F, 0x9E, 0xD5, 0x62, 0xF3, 0x9A, 0x6B, 0xA6, 
    0x5A, 0x1A, 0xCE, 0x23, 0xDC, 0xAB, 0x52, 0x0A, 0xDD, 0x62, 
    0x93, 0x13, 0xAC, 0x8A, 0x6C, 0xD0, 0x30, 0x67, 0x84, 0xA4, 
    0x0A, 0xBF, 0x23, 0x72, 0xE1, 0xCE, 0x51, 0xA2, 0x40, 0xBA, 
    0xEB, 0x97, 0xD2, 0x29, 0xBF, 0xF2, 0x2F, 0x6F, 0xC3, 0x19, 
    0xA9, 0x22, 0xF1, 0xB9, 0x4E, 0xB0, 0xFC, 0x1A, 0x50, 0xAC, 
    0x6C, 0x91, 0x59, 0xC3, 0xA5, 0x04, 0x31, 0x94, 0xAE, 0x57, 0xD2, 

    0x62, 0xE6, 0x74, 0x10, 0x68, 0x47, 0x0B, 0xC7, 0x1C, 0x41,         // 62
    0x67, 0xF2, 0x96, 0xD6, 0x7E, 0x66, 0x33, 0x90, 0xF7, 0x15, 
    0x2F, 0x63, 0x44, 0x05, 0xB2, 0x2A, 0x82, 0x40, 0xD7, 0x0D, 
    0xFB, 0x91, 0x70, 0xB8, 0x60, 0x2E, 0xF6, 0x76, 0xA1, 0x2B, 
    0xE8, 0x4C, 0xD8, 0x3D, 0xF5, 0x4D, 0xB1, 0xD8, 0x1F, 0xEC, 
    0x52, 0x80, 0xF9, 0x55, 0xAD, 0x1C, 0x7E, 0xFE, 0xD3, 0x5E, 
    0x15, 0x36, 0x6B, 0x90, 0x04, 0x5D, 0xA6, 0xDE, 0x48, 0xFE, 
    0x76, 0xD5, 0x43, 0x03, 0x9E, 0x37, 0x65, 0xCE, 0x82, 0xED, 
    0x02, 0xB4, 0xDF, 0x2D, 0xF2, 0x76, 0xBE, 0xE7, 0x78, 0x38, 0x87, 

    0xC4, 0x29, 0xAC, 0x38, 0xCD, 0xB4, 0xFD, 0x97, 0x72, 0xAC,         // 63
    0xC0, 0x10, 0x3C, 0xBA, 0x19, 0x9B, 0xDE, 0x5D, 0xBC, 0x76, 
    0x9F, 0xC9, 0xFB, 0x71, 0xE6, 0x54, 0xAF, 0x20, 0x5F, 0xB3, 
    0x47, 0xC3, 0x3A, 0x06, 0xEA, 0x90, 0x14, 0xCE, 0x46, 0x82, 
    0xB3, 0x7A, 0x1F, 0xBC, 0x29, 0x7F, 0x08, 0x8E, 0x44, 0xC1, 
    0x93, 0x2E, 0xD2, 0x02, 0x95, 0x38, 0xC1, 0x10, 0x2B, 0x89, 
    0xAA, 0xCA, 0xF9, 0x40, 0xAE, 0x83, 0x25, 0x93, 0x10, 0xB5, 
    0x2E, 0x5D, 0xC6, 0x72, 0x89, 0xDE, 0x0A, 0xA5, 0x27, 0x46, 
    0xD4, 0x34, 0x72, 0x13, 0x8E, 0x49, 0x1C, 0x5F, 0x27, 0xF8, 0x00, 

    0x4C, 0xD9, 0x55, 0xF4, 0x8D, 0x21, 0x5C, 0x3D, 0xEA, 0x2C,         // 64
    0x8E, 0xD3, 0x83, 0x59, 0xFE, 0x2E, 0xA9, 0x1D, 0x3E, 0xE8, 
    0x55, 0x26, 0x8C, 0x35, 0xC1, 0x10, 0x90, 0xEB, 0xC6, 0x7E, 
    0x29, 0xEB, 0x82, 0xA2, 0x49, 0xC5, 0x67, 0xB0, 0x21, 0xFA, 
    0x09, 0x54, 0xEB, 0x92, 0x5E, 0xE3, 0xC7, 0x6D, 0xDF, 0x0D, 
    0x66, 0xA8, 0x45, 0xBC, 0x6A, 0xF0, 0x5F, 0x9E, 0x72, 0xE7, 
    0x45, 0x77, 0x17, 0xBB, 0x51, 0xED, 0x67, 0xCB, 0x5B, 0x7F, 
    0xE5, 0x90, 0x1D, 0xEE, 0x27, 0xBD, 0x7E, 0x57, 0xC1, 0x8E, 
    0x64, 0x9D, 0xCC, 0x56, 0xAF, 0xE3, 0xC7, 0x89, 0xD7, 0xB2, 0x97, 

    0x1B, 0xA3, 0x7C, 0x0D, 0x63, 0xAE, 0x7E, 0x01, 0xCF, 0x54,         // 65
    0x18, 0x62, 0xE3, 0x09, 0xB2, 0x4E, 0x71, 0xD0, 0x85, 0x01, 
    0xB4, 0xD9, 0x12, 0xA5, 0x64, 0xDD, 0x32, 0x6E, 0x06, 0x53, 
    0xA4, 0x13, 0x63, 0xD5, 0x1F, 0x86, 0x34, 0xDF, 0x5E, 0x98, 
    0xD4, 0xC0, 0x73, 0x0D, 0xB6, 0x21, 0x99, 0x53, 0x2A, 0xB6, 
    0xF6, 0x15, 0x7B, 0xE8, 0x13, 0x85, 0x46, 0xD0, 0x33, 0xBE, 
    0x0C, 0x9F, 0x5F, 0xE2, 0x21, 0xC3, 0x0A, 0xE0, 0x3E, 0xA0, 
    0x07, 0xB9, 0x4A, 0xA7, 0x62, 0x3F, 0xF5, 0x32, 0xE1, 0x1E, 
    0xF0, 0x0B, 0x7D, 0xFC, 0x40, 0x08, 0xA0, 0x56, 0x0F, 0x44, 0x6B, 

    0x82, 0xEC, 0x39, 0xC3, 0xE8, 0x30, 0xDC, 0xBD, 0x9C, 0x7C,         // 66
    0xF7, 0xA8, 0x37, 0x76, 0xCC, 0x8A, 0x0D, 0xF5, 0xBE, 0x47, 
    0x96, 0x77, 0x52, 0xF4, 0x83, 0x4B, 0xB8, 0x9A, 0xF8, 0xD0, 
    0x88, 0xE0, 0x34, 0xB2, 0x56, 0xEB, 0xA1, 0x03, 0x7B, 0x2E, 
    0x4D, 0x24, 0xA9, 0x3A, 0xFE, 0x7B, 0x3F, 0xEE, 0xA3, 0x7D, 
    0x38, 0xD6, 0x50, 0xA1, 0x35, 0xDF, 0xAC, 0x05, 0xF7, 0x52, 
    0x82, 0xD3, 0x39, 0x88, 0xA2, 0x36, 0x7D, 0xAF, 0x29, 0xF6, 
    0x52, 0x77, 0xD9, 0x0C, 0x94, 0xCF, 0x12, 0x9F, 0x7C, 0x5A, 
    0xBA, 0x4B, 0xA7, 0x20, 0x93, 0x6D, 0x35, 0xD2, 0x7D, 0xF3, 0xBE, 

    0xD0, 0x07, 0x68, 0x95, 0x16, 0x4B, 0x89, 0x5F, 0x14, 0x2F,         // 67
    0xC7, 0x48, 0x96, 0x28, 0xF0, 0x40, 0xAF, 0x5B, 0x24, 0x6F, 
    0xF1, 0x21, 0xBB, 0x3A, 0x03, 0xCA, 0x1F, 0x61, 0x3A, 0x1B, 
    0x4D, 0xAB, 0x7D, 0xFD, 0x0E, 0x74, 0x41, 0xBC, 0xF2, 0xAD, 
    0x85, 0xEA, 0x67, 0x95, 0x4B, 0xD5, 0x00, 0xBF, 0x18, 0x59, 
    0x95, 0xC2, 0x1C, 0x8B, 0xBE, 0x5C, 0x23, 0x92, 0x67, 0xA7, 
    0x2B, 0xF1, 0xB6, 0x00, 0x70, 0xFB, 0x49, 0x98, 0x69, 0xCA, 
    0x21, 0xC3, 0x36, 0xFB, 0x6C, 0x48, 0xB7, 0x68, 0xD9, 0x11, 
    0x93, 0x2C, 0xE2, 0x63, 0xD5, 0xB9, 0xEC, 0x1B, 0xA7, 0x3C, 0x26, 

    0x8E, 0x48, 0xB8, 0xDA, 0x76, 0xA6, 0xF9, 0x3D, 0xE0, 0xAD,         // 68
    0x6E, 0x05, 0xD9, 0xBD, 0x68, 0x18, 0x92, 0xDB, 0xA2, 0x3B, 
    0xC4, 0x5E, 0xE1, 0xAA, 0x93, 0xEA, 0x7E, 0xD7, 0xB1, 0x75, 
    0xC4, 0x00, 0x5E, 0x2B, 0xBE, 0x96, 0xD6, 0x61, 0x1F, 0x3B, 
    0xC9, 0x05, 0xD1, 0x17, 0xB8, 0x60, 0x9B, 0x6C, 0xD7, 0x2F, 
    0xEF, 0x76, 0x61, 0xFB, 0x29, 0xD3, 0x78, 0xBB, 0x3F, 0xDF, 
    0x70, 0x1A, 0x4B, 0xCA, 0x55, 0xB3, 0x23, 0xE7, 0x0C, 0x86, 
    0xA1, 0x5C, 0x83, 0xA9, 0x1D, 0xE3, 0x88, 0x29, 0x4E, 0xC6, 
    0xF8, 0x6F, 0xBE, 0x34, 0x15, 0x74, 0x4A, 0x95, 0x5E, 0xDF, 0x66, 

    0xA4, 0xFC, 0x1E, 0x53, 0x2C, 0xCE, 0x09, 0x74, 0x96, 0x51,         // 69
    0xEB, 0x88, 0x56, 0x1F, 0xA1, 0xE8, 0x4C, 0x10, 0x7D, 0xE4, 
    0x07, 0x87, 0x17, 0x72, 0x27, 0x5B, 0x41, 0x0A, 0x8C, 0xF3, 
    0x37, 0xE8, 0x93, 0xD1, 0x68, 0x37, 0x13, 0x84, 0xDE, 0x91, 
    0x58, 0x77, 0x35, 0xEE, 0x80, 0x24, 0xF6, 0x3B, 0x86, 0xB0, 
    0x0F, 0x44, 0xB9, 0x03, 0x80, 0x4E, 0xF2, 0x19, 0xCE, 0x09, 
    0x97, 0xAF, 0x8B, 0xEC, 0x18, 0xD2, 0x81, 0x59, 0xD6, 0x45, 
    0xF0, 0x04, 0xD4, 0x2D, 0x76, 0xC7, 0x05, 0xF3, 0xAE, 0x3C, 
    0x81, 0x00, 0x51, 0x8C, 0xF1, 0xB0, 0x04, 0xCC, 0x28, 0xB7, 0x14, 

    0x35, 0x76, 0x9B, 0xE3, 0x8B, 0x5D, 0xB4, 0x28, 0xC8, 0x34,         // 70
    0x1C, 0xBA, 0xFA, 0x7D, 0x38, 0xCE, 0x70, 0xBE, 0x2F, 0xB2, 
    0x4D, 0xA1, 0xD4, 0x44, 0xFE, 0xC2, 0xA3, 0xE0, 0x56, 0x20, 
    0x6D, 0xA8, 0x1E, 0x44, 0xE6, 0xB4, 0xF3, 0x4D, 0xA7, 0x10, 
    0xFB, 0xB4, 0x9F, 0x56, 0xC6, 0x45, 0xAB, 0x0B, 0xE2, 0x72, 
    0xD1, 0x99, 0xE2, 0x3E, 0xB3, 0x9B, 0x36, 0x65, 0x88, 0x51, 
    0xFC, 0x5E, 0x39, 0x79, 0xA7, 0x33, 0x9C, 0x17, 0xB8, 0x2F, 
    0x70, 0xAD, 0x4A, 0xEC, 0x9E, 0x45, 0x5E, 0x91, 0x70, 0x1A, 
    0xA2, 0xE0, 0xCD, 0xA0, 0x3A, 0x81, 0x58, 0xF9, 0x8C, 0x72, 0xE9, 

    0x55, 0xD2, 0x03, 0x42, 0xAD, 0x1A, 0xEE, 0x82, 0xE6, 0x69,         // 71
    0x9F, 0x4A, 0x0D, 0xAB, 0x5A, 0x90, 0x28, 0xFC, 0x57, 0x8A, 
    0xF3, 0x32, 0x67, 0xB7, 0x81, 0x16, 0x72, 0x30, 0x9B, 0xC0, 
    0xDC, 0x53, 0x84, 0xAF, 0x07, 0x7D, 0x21, 0xC9, 0x6A, 0x40, 
    0xC2, 0x4A, 0x0C, 0x8A, 0x1C, 0xE0, 0x68, 0x93, 0x4E, 0x24, 
    0x60, 0x31, 0x86, 0x65, 0xEC, 0x15, 0xC1, 0xE7, 0xA4, 0x29, 
    0xC6, 0x1F, 0xE4, 0x0C, 0x5A, 0xDE, 0x66, 0xF7, 0x7B, 0x9D, 
    0xD0, 0x16, 0x89, 0x6B, 0x10, 0xB8, 0xDA, 0x30, 0xE4, 0xBC, 
    0x63, 0x28, 0x40, 0x6B, 0x11, 0xDB, 0xBC, 0x2F, 0x49, 0x09, 0xC7, 

    0x22, 0xB4, 0x63, 0xF4, 0x7C, 0xD6, 0x39, 0x51, 0x04, 0xAF,         // 72
    0x80, 0xE3, 0xCF, 0x2D, 0xC4, 0x12, 0xD7, 0x9D, 0x09, 0x6B, 
    0xC0, 0x1C, 0xDE, 0x0A, 0x96, 0x3A, 0xCB, 0xF6, 0x0F, 0x7D, 
    0x3C, 0x16, 0xD4, 0x66, 0xA4, 0x58, 0x95, 0x30, 0xD8, 0x86, 
    0x1F, 0x6F, 0xEB, 0xD6, 0x71, 0xBA, 0x30, 0xEC, 0xC8, 0xA1, 
    0xF8, 0xBF, 0x0A, 0xD7, 0x2A, 0x92, 0x73, 0x0B, 0x40, 0xB6, 
    0x70, 0x8F, 0xD0, 0x9B, 0xC1, 0x45, 0x03, 0xC4, 0x46, 0x1E, 
    0x5C, 0xF9, 0xB5, 0x37, 0xD1, 0x25, 0x7B, 0xA6, 0x09, 0x53, 
    0xEF, 0x83, 0xC1, 0xFC, 0xA8, 0x24, 0x6F, 0x99, 0xD4, 0xA7, 0x86, 

    0x6B, 0xE1, 0x8D, 0x30, 0x10, 0x69, 0x92, 0xB7, 0xD1, 0x5D,         // 73
    0x17, 0x3D, 0x6C, 0x86, 0xF1, 0x65, 0x7E, 0x3C, 0xBA, 0xDC, 
    0x42, 0x7B, 0xA0, 0x53, 0xF0, 0x63, 0xB0, 0x45, 0x69, 0xE3, 
    0xB3, 0x90, 0xEF, 0x2C, 0x46, 0xFA, 0xBB, 0x78, 0x01, 0xF2, 
    0x98, 0xCA, 0x26, 0xA9, 0x50, 0x03, 0x8B, 0x46, 0x1F, 0x80, 
    0x16, 0x4A, 0xA9, 0x7D, 0x5B, 0xC9, 0x4D, 0xDB, 0x7F, 0xEE, 
    0x03, 0x42, 0x68, 0x2E, 0x7C, 0xEF, 0x91, 0x6F, 0xAA, 0xE4, 
    0x93, 0x28, 0x51, 0xE1, 0x97, 0x59, 0xFD, 0x3E, 0x8D, 0xD5, 
    0x20, 0x9C, 0x07, 0x5D, 0x88, 0x48, 0xED, 0x19, 0x51, 0xF4, 0x3E, 

    0x9C, 0x18, 0x50, 0xCC, 0xBB, 0xA6, 0x1F, 0xFE, 0x43, 0x8D,         // 74
    0xF3, 0xC1, 0xA5, 0x01, 0x4C, 0xB3, 0x1F, 0xE7, 0x51, 0x19, 
    0x98, 0xED, 0x35, 0xBB, 0x23, 0xD9, 0x02, 0x8B, 0xA4, 0x31, 
    0x59, 0x04, 0xC2, 0x81, 0xB4, 0x11, 0x36, 0xE2, 0x51, 0xAC, 
    0x3E, 0x61, 0x83, 0x38, 0x9C, 0xFC, 0xD0, 0x73, 0xAC, 0x5C, 
    0xD9, 0x92, 0xD1, 0x34, 0xFD, 0x1A, 0xAD, 0x30, 0x9C, 0x55, 
    0xD6, 0xA8, 0xF6, 0x12, 0xB7, 0x3C, 0x1F, 0xDB, 0x39, 0x09, 
    0x68, 0xC9, 0x78, 0x01, 0x82, 0xC7, 0x12, 0x6B, 0xC2, 0x46, 
    0x73, 0x38, 0xB8, 0xE1, 0x34, 0xCD, 0xB3, 0x7E, 0x66, 0x0F, 0xC0, 

    0x77, 0xFB, 0xA4, 0x3C, 0xED, 0x5A, 0x36, 0x80, 0x0C, 0xA1,         // 75
    0x24, 0x55, 0x31, 0xDD, 0x97, 0x33, 0xC5, 0x92, 0x74, 0xAD, 
    0x62, 0x06, 0xD4, 0x69, 0x80, 0xA3, 0x50, 0xEB, 0x1A, 0xCD, 
    0xFC, 0x76, 0x4C, 0x1F, 0xE7, 0x70, 0xCD, 0xA1, 0x68, 0x23, 
    0xD4, 0x08, 0xF4, 0xBE, 0x19, 0x65, 0x2A, 0xB8, 0x08, 0xF3, 
    0x2D, 0x65, 0x0E, 0x51, 0x9F, 0x85, 0xE5, 0x64, 0x11, 0xBE, 
    0x25, 0x7D, 0x4E, 0xC7, 0x5B, 0x9F, 0xCE, 0x54, 0x8D, 0xBC, 
    0xEE, 0x40, 0xAB, 0xF4, 0x2C, 0x4E, 0xB2, 0xE5, 0x19, 0xA3, 
    0xF7, 0xCD, 0x53, 0x1D, 0x9E, 0x6A, 0x02, 0xD9, 0xA5, 0xE6, 0x2D, 

    0xD6, 0x0C, 0x65, 0x86, 0x01, 0x9A, 0xC4, 0xDF, 0x64, 0xD3,         // 76
    0x74, 0xE5, 0x8A, 0xBF, 0x72, 0xF9, 0x58, 0x07, 0xEE, 0x40, 
    0xCD, 0x87, 0x4B, 0x12, 0xC4, 0x28, 0x7A, 0xC7, 0x5E, 0x82, 
    0x27, 0x9D, 0xDE, 0xA7, 0x5B, 0x95, 0x4A, 0x0D, 0x8C, 0xE6, 
    0xB5, 0x90, 0x4E, 0x70, 0xE2, 0x8D, 0x52, 0xE9, 0x43, 0x97, 
    0xCA, 0x79, 0xEC, 0xB7, 0x6D, 0x00, 0x44, 0xCF, 0x76, 0xFA, 
    0x3B, 0x93, 0x1C, 0xE9, 0x88, 0x06, 0x6B, 0xFD, 0x2D, 0x79, 
    0x13, 0x99, 0x1C, 0x61, 0xD7, 0x9D, 0x76, 0x31, 0x8E, 0x5F, 
    0x0E, 0x80, 0xAC, 0x78, 0xF6, 0x2D, 0x94, 0x43, 0x21, 0x84, 0x4F, 

    0x3E, 0xB3, 0xD1, 0x2D, 0xE4, 0x74, 0x1C, 0x49, 0xAB, 0x33,         // 77
    0xB9, 0x09, 0x66, 0x1E, 0x43, 0x12, 0x85, 0xD3, 0x2B, 0xBB, 
    0x23, 0xFB, 0xA4, 0xDA, 0x8F, 0xF7, 0x41, 0x0E, 0xA7, 0x3E, 
    0xBE, 0x65, 0x0B, 0x3F, 0xC6, 0x2B, 0xF1, 0xBB, 0x2E, 0x75, 
    0x41, 0x14, 0xC7, 0x2F, 0xB2, 0x0A, 0xA1, 0xC6, 0x80, 0x12, 
    0x4F, 0xA2, 0x1E, 0xD7, 0x31, 0xF4, 0xB9, 0x8D, 0x1B, 0x9F, 
    0x63, 0xB3, 0xDA, 0x70, 0x2C, 0xAF, 0xC4, 0x1B, 0xAC, 0xDE, 
    0x53, 0xD5, 0x84, 0xBE, 0x36, 0x0D, 0xF0, 0x49, 0xD9, 0xC4, 
    0x2C, 0xEB, 0x3F, 0x09, 0xC6, 0x51, 0xBE, 0xF3, 0x5C, 0xCA, 0x97, 

    0x6B, 0x1F, 0x94, 0x4B, 0xAD, 0x55, 0xF0, 0x8D, 0x15, 0xF6,         // 78
    0x4F, 0x98, 0xEB, 0xAA, 0xDB, 0xC8, 0xA2, 0x5F, 0x7B, 0x99, 
    0x54, 0x7F, 0x1B, 0x6B, 0x30, 0x5C, 0xB0, 0xE1, 0x8B, 0xF2, 
    0x19, 0xD6, 0x8D, 0xF8, 0x72, 0x16, 0x84, 0x5E, 0xCF, 0xFD, 
    0x64, 0xAA, 0xEF, 0x5D, 0xDA, 0x78, 0x3F, 0x27, 0x61, 0xDD, 
    0xB8, 0x37, 0x8A, 0x4D, 0xA6, 0x7D, 0x23, 0x58, 0xEA, 0x35, 
    0xCD, 0x47, 0x0C, 0xA1, 0x55, 0xEF, 0x41, 0x87, 0x49, 0x69, 
    0xB8, 0x23, 0x4A, 0xEC, 0x6D, 0xB7, 0x87, 0x20, 0xA7, 0x71, 
    0x50, 0xBA, 0x91, 0x61, 0xE2, 0x84, 0x11, 0x72, 0xAC, 0x09, 0xE4, 

    0xBD, 0xF4, 0x7B, 0xDC, 0x11, 0xCB, 0x2A, 0xA3, 0x6B, 0xCC,         // 79
    0x7C, 0x24, 0x39, 0x5D, 0x89, 0x4A, 0x28, 0xF5, 0x35, 0xDB, 
    0x00, 0xBF, 0x3D, 0xEB, 0xAA, 0x17, 0xD1, 0x66, 0x2A, 0x70, 
    0x4C, 0xAC, 0x56, 0x32, 0x9F, 0xD7, 0xAB, 0x37, 0x03, 0x99, 
    0x1D, 0x83, 0x29, 0x96, 0x15, 0xA9, 0xFA, 0xCE, 0x93, 0x20, 
    0xF6, 0x6F, 0xCF, 0x08, 0x62, 0xDC, 0x3D, 0xA2, 0xBC, 0x05, 
    0x7C, 0xF3, 0xBF, 0x37, 0xD6, 0x7B, 0x0E, 0xE3, 0xA3, 0x03, 
    0xF8, 0x76, 0xA3, 0x07, 0x96, 0x3F, 0xD0, 0x58, 0xF9, 0x02, 
    0x8A, 0xD4, 0x24, 0xA2, 0x1A, 0xAE, 0x39, 0xE0, 0x28, 0x7E, 0x35, 

    0x51, 0x06, 0x63, 0x33, 0x9E, 0x81, 0x5D, 0xC0, 0x3D, 0x0E,         // 80
    0xAE, 0xD6, 0x9F, 0xFC, 0x1A, 0x73, 0xAF, 0x12, 0xB7, 0x66, 
    0xA0, 0xE6, 0x5D, 0xC6, 0x75, 0x89, 0x49, 0x03, 0xA3, 0xC3, 
    0xE4, 0x11, 0x7A, 0xCE, 0x07, 0x4D, 0xE8, 0x7A, 0xC5, 0x4B, 
    0xB5, 0xE4, 0x51, 0xD3, 0x37, 0x66, 0x49, 0x01, 0x71, 0xA6, 
    0x56, 0x13, 0xAD, 0xE8, 0x8F, 0xBE, 0x14, 0x6F, 0xE0, 0x5E, 
    0x91, 0x1A, 0x69, 0x8A, 0x1E, 0x9C, 0x63, 0xBA, 0x2D, 0x90, 
    0x3C, 0xD9, 0x2B, 0xC3, 0x5B, 0xE6, 0x15, 0x77, 0x99, 0x47, 
    0xE8, 0x38, 0x79, 0xFE, 0x45, 0x68, 0xD1, 0x91, 0x5A, 0xFB, 0xA2, 

    0x87, 0xD0, 0xB6, 0xEF, 0x48, 0xD8, 0x05, 0xFB, 0x84, 0xE1,         // 81
    0x53, 0x6F, 0x02, 0x47, 0xB9, 0xE0, 0x92, 0x55, 0xEA, 0x3F, 
    0x77, 0x22, 0x94, 0x0D, 0x35, 0xE0, 0xBA, 0xFC, 0x7E, 0x38, 
    0x8F, 0x2B, 0xED, 0xB4, 0x8C, 0x70, 0x1E, 0x95, 0x5B, 0xDA, 
    0x39, 0x74, 0x08, 0xBB, 0x84, 0xE9, 0x8E, 0xBF, 0xE4, 0x33, 
    0xD7, 0x94, 0x2F, 0x5C, 0x23, 0x4C, 0xF8, 0x8B, 0x42, 0x27, 
    0xD1, 0xAF, 0x4D, 0xEB, 0xC6, 0x3D, 0xFA, 0x4F, 0xD2, 0x6D, 
    0xB2, 0x58, 0x85, 0xF1, 0x33, 0x8A, 0xBD, 0x32, 0xCC, 0x1C, 
    0xB5, 0x5C, 0x0F, 0xB7, 0xD9, 0x8A, 0x26, 0xB4, 0x3D, 0xCC, 0x1E, 

    0xEA, 0x42, 0x27, 0x8B, 0x19, 0x70, 0xAF, 0x43, 0x20, 0x99,         // 82
    0x30, 0xE8, 0x85, 0xCE, 0x65, 0x0D, 0x3C, 0xCA, 0x87, 0x0B, 
    0xCF, 0xB6, 0x4C, 0xF4, 0x64, 0x9B, 0x2D, 0x5D, 0x1C, 0xD1, 
    0x67, 0xA5, 0x5B, 0x3F, 0x27, 0xF7, 0xBE, 0x35, 0xF1, 0x10, 
    0x8E, 0xC7, 0xF9, 0x6B, 0x28, 0xB0, 0x16, 0x61, 0x24, 0x7E, 
    0x45, 0xC3, 0x77, 0xF1, 0xCB, 0x80, 0xA8, 0x0E, 0xC9, 0x9B, 
    0xFD, 0x33, 0xA2, 0x01, 0x77, 0xA9, 0x12, 0x82, 0x25, 0xE9, 
    0x10, 0xCF, 0x1C, 0x6D, 0xAC, 0x10, 0x62, 0xE1, 0xA0, 0x6A, 
    0x84, 0xCE, 0x97, 0x32, 0x60, 0x0C, 0xE6, 0x74, 0x01, 0x97, 0x64, 

    0x0F, 0x71, 0xAE, 0x5C, 0xCD, 0xEB, 0x55, 0xA5, 0xD0, 0x61,         // 83
    0xBF, 0x1A, 0xA8, 0x35, 0x97, 0xF2, 0x77, 0x26, 0xA8, 0x62, 
    0xFE, 0x29, 0x7D, 0xCC, 0xB1, 0x15, 0x8C, 0xD8, 0xB7, 0x4B, 
    0xF4, 0x04, 0xBF, 0xDB, 0x9D, 0x51, 0x13, 0xAE, 0x69, 0xA0, 
    0x2F, 0x53, 0x21, 0xAD, 0x58, 0xD9, 0x3D, 0xEF, 0x9A, 0xB6, 
    0xFE, 0x0E, 0x3C, 0xA4, 0x02, 0x38, 0x65, 0xEA, 0x7C, 0x54, 
    0x0A, 0x8C, 0x61, 0xD4, 0x2B, 0x65, 0xDD, 0xC3, 0xA1, 0x48, 
    0x8C, 0x37, 0xA2, 0xD8, 0x45, 0xFC, 0x95, 0x48, 0x07, 0xF5, 
    0x2B, 0x45, 0xEC, 0x7E, 0xC8, 0x9E, 0x48, 0xBF, 0xEF, 0x4C, 0xB0, 

    0xC9, 0x91, 0xF9, 0x09, 0x9B, 0x2B, 0x89, 0x18, 0x7B, 0xF4,         // 84
    0x45, 0x73, 0xED, 0x5D, 0x20, 0xB1, 0xD3, 0x5C, 0xE4, 0x1A, 
    0x90, 0x3D, 0xA3, 0x04, 0x52, 0xE3, 0x46, 0x6C, 0x0D, 0x95, 
    0x78, 0x36, 0x88, 0x1F, 0x6B, 0xC8, 0xE1, 0x80, 0x43, 0xD4, 
    0xB7, 0x7D, 0xDD, 0x9B, 0x05, 0x80, 0xC9, 0x73, 0x0A, 0x4D, 
    0x6C, 0x8E, 0xDC, 0x53, 0x95, 0xE0, 0xBB, 0x20, 0x39, 0xC3, 
    0x71, 0xDE, 0x42, 0xBB, 0xF5, 0x9C, 0x33, 0x58, 0x05, 0x73, 
    0xF7, 0xBC, 0x62, 0x00, 0x84, 0xBA, 0x21, 0x7B, 0xC0, 0x5E, 
    0xD6, 0xAA, 0x03, 0x53, 0x2A, 0xF7, 0x20, 0x5E, 0x89, 0x2F, 0xDE, 

    0x1C, 0x54, 0x3C, 0xC7, 0x73, 0x45, 0xC3, 0xE3, 0x37, 0x0E,         // 85
    0xAF, 0x91, 0x08, 0xD9, 0x81, 0x3F, 0x03, 0x98, 0x47, 0xBB, 
    0x71, 0xD8, 0x5D, 0xE9, 0x76, 0x24, 0xC0, 0xF7, 0xA7, 0x27, 
    0xDF, 0xCB, 0x60, 0xF1, 0x8F, 0x07, 0x5F, 0x28, 0x96, 0x00, 
    0xF5, 0x18, 0x60, 0x34, 0xF2, 0x49, 0x9E, 0x33, 0xBD, 0xE2, 
    0x29, 0xAD, 0x1E, 0xBF, 0x76, 0x17, 0x5D, 0x91, 0xAC, 0xE6, 
    0x2E, 0xA9, 0x17, 0x84, 0x0D, 0x4D, 0x7D, 0xF1, 0xB8, 0xD5, 
    0x21, 0x4D, 0x94, 0xEC, 0x2E, 0x54, 0xCE, 0xE6, 0x28, 0x91, 
    0x15, 0x71, 0x99, 0xDB, 0xB5, 0x6F, 0x95, 0xD8, 0x12, 0xA9, 0x6A, 

    0xA0, 0x7F, 0xDA, 0x1E, 0xA9, 0xF4, 0x00, 0x68, 0x9E, 0xD8,         // 86
    0x5A, 0x30, 0xC5, 0xA4, 0x4F, 0xF8, 0xBD, 0x7C, 0x30, 0xEF, 
    0x0A, 0xC1, 0x21, 0x8D, 0xAF, 0x9D, 0x34, 0x81, 0x40, 0x68, 
    0xB1, 0x48, 0x0D, 0xB8, 0x44, 0xA8, 0xFE, 0xBA, 0xDC, 0x68, 
    0x4A, 0xA6, 0x8A, 0xC3, 0x72, 0xB1, 0x19, 0xF7, 0x58, 0x7B, 
    0xCD, 0x49, 0x66, 0xEA, 0x43, 0xC8, 0xFB, 0x46, 0x74, 0x19, 
    0x8F, 0x51, 0xE5, 0x68, 0xAD, 0xCE, 0x1D, 0x8E, 0x31, 0x5F, 
    0x84, 0xDE, 0x14, 0xCB, 0x6F, 0xAD, 0x0A, 0x66, 0xA9, 0x46, 
    0xB8, 0xFB, 0x26, 0x62, 0x3E, 0x0D, 0xBC, 0x42, 0x78, 0xFD, 0x46, 

    0xE2, 0xB3, 0x2E, 0x67, 0x8F, 0x56, 0xBA, 0x8D, 0x4A, 0xC1,         // 87
    0x7F, 0xFB, 0x46, 0x1A, 0x8D, 0x6B, 0x22, 0xDE, 0xA2, 0x64, 
    0x95, 0x4F, 0xF9, 0x39, 0x12, 0x5A, 0xEB, 0x01, 0xC9, 0xE7, 
    0x15, 0xA0, 0x7E, 0xE1, 0x2F, 0x85, 0x55, 0x3A, 0x20, 0x8F, 
    0xC9, 0x31, 0xEC, 0x0E, 0x3E, 0xD1, 0x5F, 0x90, 0x25, 0xA1, 
    0x05, 0xF5, 0x99, 0x13, 0x86, 0x2F, 0xA8, 0x0B, 0xCE, 0xEF, 
    0x6B, 0xC9, 0x26, 0x9D, 0x34, 0xED, 0xBB, 0x67, 0xA7, 0x0B, 
    0xB3, 0x3F, 0x75, 0xB5, 0x39, 0x8A, 0xF5, 0x3D, 0x84, 0xE9, 
    0x5B, 0x38, 0xC9, 0x8D, 0xF1, 0x81, 0xE8, 0x23, 0xCA, 0x90, 0x07, 

    0x62, 0x44, 0xF6, 0xC5, 0x14, 0xDE, 0x24, 0x3C, 0xEC, 0x13,         // 88
    0x29, 0x9A, 0x74, 0xD4, 0xB6, 0x38, 0xD0, 0x54, 0x11, 0xB8, 
    0x25, 0x7C, 0xAA, 0x6F, 0xDD, 0xC2, 0x74, 0x98, 0x4D, 0x87, 
    0x5D, 0xFA, 0x24, 0x6A, 0xC4, 0x16, 0xD0, 0xA4, 0x7A, 0xF0, 
    0x15, 0x6D, 0xAC, 0x56, 0xE0, 0x84, 0x0B, 0xB6, 0xDE, 0x42, 
    0xC2, 0x7E, 0x36, 0xB5, 0xD5, 0x68, 0x95, 0x5B, 0xB6, 0x42, 
    0x02, 0xB4, 0xFC, 0x47, 0x76, 0x06, 0x50, 0xE1, 0x42, 0xCA, 
    0xFE, 0x9F, 0x2C, 0xF0, 0x5E, 0x1C, 0x9A, 0xCF, 0x2D, 0x10, 
    0xD7, 0x81, 0x08, 0xB1, 0x21, 0x4C, 0x9E, 0x6C, 0x51, 0x2E, 0xC2, 

    0x21, 0xAD, 0x0A, 0x7E, 0x4F, 0xA1, 0x79, 0xCE, 0x6F, 0xA8,         // 89
    0x5F, 0xE3, 0x04, 0x5B, 0xEB, 0x0B, 0x97, 0x77, 0xF4, 0x3F, 
    0xE5, 0xD0, 0x08, 0x4B, 0xA0, 0x43, 0x2A, 0xD6, 0x1D, 0xBF, 
    0x36, 0x8F, 0xD3, 0x53, 0xA1, 0x75, 0xE4, 0x08, 0x5C, 0xB7, 
    0x4E, 0xD2, 0x7F, 0x1F, 0x99, 0x30, 0xED, 0x6D, 0x52, 0x8B, 
    0x20, 0x68, 0xE0, 0x50, 0x03, 0xF4, 0x1D, 0xDE, 0x2A, 0x9D, 
    0x83, 0x5F, 0x18, 0x89, 0xDB, 0xB3, 0x90, 0x17, 0x9B, 0x76, 
    0x13, 0x50, 0x8D, 0x08, 0xDA, 0xBD, 0x50, 0x6E, 0xBB, 0x98, 
    0x6A, 0xA8, 0x50, 0xD6, 0x72, 0xE2, 0x05, 0xD3, 0xA9, 0xF2, 0x79, 

    0xE7, 0x93, 0x69, 0xEA, 0xB6, 0x32, 0xFD, 0x09, 0x93, 0x34,         // 90
    0xB2, 0xC4, 0x44, 0x9E, 0x7E, 0x50, 0xAD, 0x26, 0xC2, 0x8C, 
    0x6E, 0x32, 0xBE, 0xEE, 0x87, 0x0F, 0xF7, 0xA7, 0x65, 0xEE, 
    0x0B, 0xB2, 0x43, 0x02, 0xF4, 0x28, 0x3C, 0x90, 0xCB, 0x2B, 
    0x9A, 0x04, 0xE3, 0xC0, 0x61, 0xA7, 0x48, 0xC4, 0x11, 0xFC, 
    0xA8, 0xCA, 0x2D, 0xA3, 0x76, 0xBA, 0x47, 0x8A, 0x6D, 0xCB, 
    0xF2, 0x38, 0xA5, 0xC7, 0x57, 0x38, 0x6A, 0xF4, 0x2D, 0xDB, 
    0x64, 0xB6, 0xD2, 0x6D, 0xA6, 0x37, 0xE6, 0x05, 0xF8, 0x4B, 
    0x1B, 0xE9, 0x2A, 0x93, 0x3E, 0xBF, 0x5C, 0x86, 0x17, 0x47, 0x9D, 
};

const BYTE HT_SuperCell_BlueMono[91*91] = {
    0xE3, 0xAB, 0x6E, 0x4F, 0xBB, 0xEA, 0x9A, 0x02, 0xCD, 0x4D,         //  0
    0xDC, 0x1E, 0xF8, 0x5D, 0xE3, 0x3C, 0x67, 0x8C, 0xC8, 0xFB, 
    0x2B, 0xD8, 0xBC, 0x6B, 0x91, 0x54, 0xF0, 0x14, 0xAB, 0x1E, 
    0xF5, 0x03, 0x79, 0x9C, 0x55, 0xBA, 0x1F, 0xA5, 0x53, 0xCA, 
    0x72, 0xB3, 0x7B, 0xF8, 0x9E, 0x2D, 0x8B, 0x0E, 0x9F, 0x4F, 
    0xCE, 0x93, 0x0C, 0x48, 0xBB, 0x02, 0x74, 0x54, 0xC8, 0xE8, 
    0x95, 0x20, 0xEB, 0xA6, 0x66, 0xD5, 0x5B, 0x86, 0x9D, 0x57, 
    0x18, 0x90, 0xE9, 0x83, 0xBD, 0x2E, 0x94, 0xD6, 0x7D, 0x99, 
    0xEB, 0xA4, 0x6E, 0x42, 0x22, 0xCC, 0x0F, 0x68, 0xE0, 0x05, 0xB8, 

    0x80, 0x10, 0xF3, 0x33, 0x7E, 0x1C, 0x64, 0xF9, 0x33, 0xA1,         //  1
    0x6A, 0x83, 0x36, 0xC5, 0x71, 0xB6, 0xF0, 0x52, 0x00, 0x97, 
    0x81, 0x10, 0xF0, 0x3A, 0xA8, 0x02, 0xCC, 0x3E, 0xE0, 0x5A, 
    0x94, 0x67, 0xC4, 0x21, 0xE0, 0x88, 0x65, 0xED, 0x0B, 0x8F, 
    0x23, 0x3D, 0xC1, 0x1C, 0x70, 0xEA, 0x5A, 0xDC, 0x6C, 0x1D, 
    0xEF, 0x36, 0x7A, 0xD0, 0x61, 0x9D, 0xED, 0x35, 0xAA, 0x07, 
    0x42, 0xD1, 0x75, 0x17, 0xBE, 0x08, 0xFC, 0x34, 0xD0, 0x74, 
    0xF4, 0xC0, 0x26, 0x4A, 0x07, 0xE1, 0x6B, 0x45, 0x03, 0x61, 
    0x28, 0x86, 0x0C, 0xDD, 0x93, 0x75, 0xAA, 0x2C, 0x53, 0x8D, 0x49, 

    0xCD, 0x61, 0x93, 0xC9, 0xE3, 0x3F, 0xB1, 0x81, 0x5E, 0xE6,         //  2
    0x0A, 0xD3, 0xAC, 0x21, 0x8B, 0x11, 0x2F, 0xD8, 0xA6, 0x3A, 
    0x5F, 0xA9, 0x75, 0x1B, 0xE1, 0x81, 0x63, 0xB0, 0x77, 0xA2, 
    0x25, 0xD6, 0x34, 0xB0, 0x6C, 0x07, 0xC3, 0x35, 0xD3, 0xA8, 
    0x63, 0xD9, 0x93, 0x5B, 0xC7, 0x09, 0xA8, 0x41, 0xAF, 0xBF, 
    0x75, 0xA2, 0xDE, 0x28, 0x81, 0x40, 0xCB, 0x14, 0xBA, 0x85, 
    0x6D, 0xA2, 0x48, 0x8B, 0xDE, 0x4B, 0x71, 0xAB, 0x14, 0x47, 
    0xAE, 0x38, 0x79, 0xAA, 0xCB, 0x87, 0x19, 0xF5, 0xAA, 0xC4, 
    0x4B, 0xFB, 0xBA, 0x65, 0x49, 0xF0, 0x3D, 0xB9, 0xF8, 0xA0, 0x1F, 

    0x31, 0xB1, 0x24, 0x58, 0x06, 0x8E, 0xD4, 0x18, 0xBF, 0x2A,         //  3
    0x96, 0x41, 0x5B, 0xEA, 0xBE, 0x60, 0x9B, 0x79, 0x1F, 0xC0, 
    0xE8, 0x43, 0x96, 0xC8, 0x4B, 0x9B, 0x25, 0xFD, 0x09, 0x3A, 
    0xB9, 0x53, 0xF9, 0x8F, 0x46, 0xE8, 0x9E, 0x58, 0x88, 0x42, 
    0xF3, 0x01, 0x46, 0xE5, 0x39, 0x91, 0x7B, 0x26, 0xEB, 0x00, 
    0x3C, 0x5C, 0x0F, 0xAE, 0xE7, 0x1D, 0x8B, 0x63, 0xF9, 0x4E, 
    0xD9, 0x0F, 0xF0, 0x28, 0xB1, 0x80, 0x20, 0xC9, 0xE7, 0x87, 
    0x04, 0xDF, 0x55, 0xFE, 0x62, 0x33, 0x9E, 0xBC, 0x20, 0xDD, 
    0x76, 0x34, 0x9E, 0x20, 0xD6, 0x07, 0x80, 0xD1, 0x12, 0x6D, 0xE7, 

    0x52, 0xFE, 0x79, 0xA4, 0xC2, 0x6D, 0x48, 0xE4, 0x52, 0x86,         //  4
    0xF5, 0xB8, 0x76, 0x06, 0x48, 0xFC, 0xC7, 0x50, 0xF1, 0x6C, 
    0x0A, 0xD4, 0x22, 0x64, 0xF3, 0x34, 0xC4, 0x57, 0xD7, 0x84, 
    0xEB, 0x0C, 0x7B, 0x1C, 0xD1, 0x2E, 0x7A, 0x12, 0xE0, 0x25, 
    0x76, 0xBA, 0x80, 0xAD, 0x23, 0xFA, 0x4F, 0xD5, 0x63, 0x88, 
    0xCD, 0xFB, 0x8F, 0x4B, 0xBD, 0x55, 0xA4, 0xD5, 0x3B, 0x1C, 
    0xAF, 0x57, 0xC2, 0x66, 0x38, 0xF3, 0x95, 0x40, 0x5C, 0xB8, 
    0x6A, 0x9D, 0x1C, 0xBA, 0x0D, 0xD4, 0x72, 0x52, 0x39, 0x9B, 
    0x13, 0xC9, 0x57, 0x7E, 0xC0, 0x9B, 0x5C, 0x2A, 0x87, 0x46, 0xBA, 

    0x80, 0xD2, 0x0F, 0x3B, 0xF1, 0x25, 0x9B, 0x0A, 0xA4, 0x6B,         //  5
    0x12, 0x35, 0xDE, 0xA5, 0x81, 0x31, 0x0C, 0x93, 0x3D, 0xB3, 
    0x88, 0x54, 0xB0, 0x7E, 0x07, 0xB5, 0x73, 0x1B, 0xAB, 0x45, 
    0x6A, 0xCE, 0xA1, 0x5F, 0xB5, 0x52, 0xF0, 0xC1, 0x69, 0x9C, 
    0xCB, 0x56, 0x12, 0xCF, 0x64, 0x9B, 0xC0, 0x11, 0x9F, 0x47, 
    0xB4, 0x18, 0x6A, 0x2C, 0xF1, 0x05, 0x71, 0x26, 0x9D, 0x79, 
    0xE6, 0x8A, 0x20, 0x99, 0xD4, 0x05, 0x6E, 0xA6, 0x11, 0xF8, 
    0x25, 0xD7, 0x82, 0x3D, 0x91, 0x47, 0xEF, 0x8A, 0xE6, 0x62, 
    0x85, 0xE2, 0x0B, 0xEB, 0x27, 0x3F, 0xB5, 0xE5, 0xAB, 0xDC, 0x01, 

    0x42, 0xAC, 0x65, 0x92, 0x53, 0xCB, 0x7D, 0xFC, 0x3F, 0xD8,         //  6
    0xC1, 0x51, 0x94, 0x2A, 0xD0, 0xB2, 0x6B, 0xD5, 0x16, 0xE0, 
    0x27, 0xFB, 0x33, 0xDA, 0x91, 0x40, 0xE8, 0x88, 0xC9, 0x12, 
    0x95, 0x2B, 0x3F, 0xF3, 0x02, 0x94, 0x22, 0xAD, 0x3A, 0x09, 
    0xFD, 0x3C, 0x90, 0xED, 0x19, 0x40, 0x80, 0x32, 0xF4, 0x71, 
    0x35, 0xE4, 0xC6, 0x9F, 0x81, 0xD7, 0xB0, 0xF4, 0x5D, 0xCB, 
    0x01, 0x40, 0xFC, 0x77, 0x4F, 0xB4, 0xE6, 0x2C, 0xCD, 0x7B, 
    0x51, 0x34, 0xC0, 0x69, 0xDB, 0xAE, 0x30, 0x09, 0xCB, 0x23, 
    0xB9, 0x46, 0xA5, 0x68, 0x92, 0xFC, 0x6A, 0x14, 0x39, 0x62, 0x9A, 

    0xD8, 0x18, 0xBD, 0xE4, 0x15, 0xAE, 0x36, 0x5D, 0xB5, 0x2B,         //  7
    0x7B, 0xEB, 0x16, 0x75, 0x55, 0xE4, 0x42, 0xAD, 0x7D, 0x5E, 
    0x9D, 0x70, 0xBD, 0x19, 0x58, 0xCF, 0x63, 0x34, 0xF7, 0x54, 
    0xBD, 0xE8, 0x80, 0xC3, 0x6B, 0xD4, 0x82, 0x4E, 0xE5, 0x8A, 
    0x62, 0xA4, 0x29, 0x70, 0xAC, 0xE2, 0x5A, 0xC8, 0xAD, 0x07, 
    0x9B, 0x7A, 0x52, 0x10, 0x36, 0x65, 0x43, 0x11, 0x88, 0x31, 
    0xBA, 0x6B, 0xAE, 0x14, 0xC4, 0x34, 0x61, 0x8C, 0x47, 0xAF, 
    0xE3, 0x99, 0x0A, 0xF3, 0x17, 0x5D, 0xC6, 0x6D, 0xA3, 0x3F, 
    0xF9, 0x78, 0x2D, 0xD4, 0x51, 0x04, 0xBE, 0x7F, 0xF4, 0xC4, 0x2C, 

    0xEF, 0x56, 0x8A, 0x32, 0x79, 0xEB, 0x0E, 0xD2, 0x88, 0x01,         //  8
    0x99, 0x5F, 0xB1, 0xF4, 0x05, 0x89, 0x1F, 0xF8, 0x31, 0xC4, 
    0x03, 0x49, 0x89, 0xE3, 0x9C, 0x2A, 0xA5, 0x00, 0x78, 0xAC, 
    0x21, 0x68, 0x0F, 0xA6, 0x2F, 0x58, 0xF7, 0x12, 0x72, 0xB9, 
    0x1F, 0xE3, 0xC3, 0x4F, 0xCC, 0x0F, 0x8D, 0x24, 0xDE, 0x62, 
    0xD0, 0x1C, 0xAF, 0xE9, 0xCE, 0x97, 0xBE, 0xDF, 0x51, 0xED, 
    0x92, 0x4C, 0xD8, 0x2E, 0xED, 0x7F, 0x9E, 0x1B, 0xEF, 0x00, 
    0x6B, 0xC8, 0x85, 0x45, 0xAB, 0x81, 0x24, 0xF4, 0x8D, 0x5C, 
    0x00, 0x96, 0xC6, 0x1A, 0x80, 0xDB, 0x97, 0x4F, 0x1A, 0x91, 0x73, 

    0xAD, 0x29, 0xCF, 0x62, 0xC6, 0x4A, 0x96, 0x6A, 0xEF, 0x4C,         //  9
    0xE1, 0x35, 0xCD, 0x4B, 0xA0, 0xC8, 0x67, 0x94, 0x4E, 0xD9, 
    0xAE, 0xEE, 0x37, 0x68, 0x0B, 0xEA, 0xC3, 0x90, 0xD9, 0x3E, 
    0xE2, 0x91, 0x4B, 0xD7, 0x97, 0x1C, 0xAF, 0xC5, 0x33, 0xD8, 
    0x56, 0x97, 0x03, 0x89, 0x32, 0xF7, 0x6D, 0x9D, 0x3E, 0x89, 
    0x2E, 0xF7, 0x43, 0x7D, 0x58, 0x19, 0x2F, 0x6D, 0xA4, 0x27, 
    0xCE, 0x0D, 0x79, 0xA4, 0x5D, 0x09, 0xB7, 0xCA, 0x58, 0x93, 
    0x39, 0x20, 0x59, 0xD1, 0x2E, 0xE1, 0xB2, 0x4F, 0x13, 0xDF, 
    0xB0, 0x6D, 0x3B, 0xE9, 0xB4, 0x45, 0x25, 0xE8, 0xA8, 0x5C, 0x08, 

    0x49, 0x7C, 0xFA, 0x03, 0xA2, 0x25, 0xA9, 0x39, 0x19, 0xC8,         // 10
    0xA3, 0x17, 0x6C, 0x28, 0x80, 0x3C, 0xEB, 0x0E, 0xA4, 0x28, 
    0x76, 0x18, 0xCF, 0xB8, 0x80, 0x55, 0x41, 0x6C, 0x23, 0x5D, 
    0xC0, 0x19, 0xFC, 0x71, 0x40, 0xE5, 0x7E, 0x48, 0x9D, 0x0B, 
    0x7B, 0x3D, 0xF1, 0x69, 0xA2, 0x43, 0xC1, 0x09, 0xF0, 0x57, 
    0xB8, 0x6D, 0x91, 0x02, 0xB6, 0xFE, 0x83, 0xD6, 0x07, 0x8B, 
    0x5E, 0xF7, 0x3E, 0x89, 0xDE, 0x45, 0xFB, 0x36, 0x79, 0xD3, 
    0xE7, 0xB1, 0xFC, 0x93, 0x6C, 0x04, 0x40, 0xD4, 0x77, 0xBE, 
    0x1E, 0xF0, 0x56, 0x9C, 0x10, 0x68, 0xC7, 0x72, 0x3E, 0xE0, 0xCC, 

    0xB6, 0x1A, 0x98, 0x4F, 0xDB, 0x6E, 0xF8, 0x7F, 0xAF, 0x57,         // 11
    0x79, 0x8F, 0xFE, 0xAE, 0xDA, 0x1C, 0xAD, 0x57, 0x83, 0xF5, 
    0x5E, 0x9A, 0x4F, 0x23, 0xFE, 0x97, 0x1A, 0xF2, 0xCD, 0x9C, 
    0x2E, 0x7C, 0xB2, 0x04, 0xA8, 0x5F, 0x0E, 0xDC, 0x63, 0xF9, 
    0xB1, 0xD2, 0x29, 0xBD, 0x12, 0x7F, 0x54, 0xD4, 0xB0, 0x17, 
    0xDF, 0x24, 0xC8, 0xE6, 0x38, 0x5F, 0xAB, 0x48, 0xC3, 0x39, 
    0xB9, 0x99, 0x22, 0xC7, 0x18, 0x73, 0x96, 0x22, 0xA3, 0x0F, 
    0x43, 0x83, 0x0B, 0x48, 0xB9, 0xF0, 0x8C, 0xA0, 0x32, 0x60, 
    0x8E, 0x2E, 0xD2, 0x77, 0x34, 0xF3, 0xAB, 0x0A, 0x9C, 0x31, 0x86, 

    0xE7, 0x6C, 0xC3, 0x33, 0x87, 0x16, 0x53, 0xC4, 0x2D, 0xD9,         // 12
    0x0E, 0x4A, 0xC2, 0x08, 0x54, 0x71, 0xD5, 0xBF, 0x35, 0xCA, 
    0x0D, 0xE8, 0x7C, 0xAC, 0x3C, 0xD4, 0x77, 0xB4, 0x06, 0x85, 
    0xE7, 0x50, 0xD0, 0x37, 0xF1, 0x95, 0xCC, 0x36, 0x8C, 0x21, 
    0x4B, 0x94, 0x5B, 0xE9, 0xAB, 0xD8, 0x21, 0x87, 0x48, 0x7D, 
    0x9D, 0x61, 0x3F, 0xAA, 0x76, 0x16, 0xE2, 0x23, 0xF4, 0x74, 
    0x0F, 0x66, 0xE9, 0x5B, 0xB3, 0xD3, 0x4D, 0xE6, 0x62, 0xC3, 
    0x6F, 0xA2, 0x61, 0xCB, 0x26, 0x76, 0x58, 0x17, 0xFD, 0xC8, 
    0x49, 0xA6, 0x14, 0xC1, 0x8A, 0xD5, 0x4A, 0x80, 0xFC, 0x66, 0x11, 

    0x43, 0x2A, 0xEE, 0x5E, 0xB1, 0xE4, 0x97, 0x08, 0xED, 0x63,         // 13
    0xB7, 0xE8, 0x39, 0x89, 0xF0, 0x95, 0x49, 0x01, 0x77, 0x97, 
    0x46, 0xB3, 0x1B, 0xDE, 0x60, 0x0A, 0x9F, 0x32, 0x49, 0x66, 
    0xB9, 0x17, 0x6F, 0x8D, 0x56, 0x1E, 0x78, 0xA7, 0xE7, 0x71, 
    0xC0, 0x0F, 0x84, 0x25, 0x40, 0x63, 0xFD, 0xA5, 0x28, 0xCF, 
    0x07, 0xF6, 0x86, 0x0E, 0xD8, 0xC1, 0x94, 0x7E, 0x51, 0xAB, 
    0xDD, 0xC0, 0x43, 0x8E, 0x34, 0x02, 0x87, 0xB5, 0x1B, 0xF4, 
    0x2C, 0xDE, 0x17, 0xEC, 0xAE, 0x3D, 0xDD, 0xB3, 0x7B, 0x05, 
    0xDB, 0x6B, 0xF6, 0x54, 0x02, 0x64, 0x29, 0xBC, 0x20, 0xAD, 0xD5, 

    0x91, 0xA5, 0x7A, 0x07, 0xD0, 0x28, 0x49, 0x78, 0xA3, 0x36,         // 14
    0x92, 0x1F, 0xA6, 0x64, 0x14, 0x31, 0xE5, 0xA1, 0xD9, 0x25, 
    0x66, 0xCD, 0x6F, 0x30, 0x90, 0xC7, 0x6C, 0xE1, 0xC3, 0xFA, 
    0x3F, 0x9F, 0xEC, 0x11, 0xDA, 0xBD, 0x30, 0x50, 0x02, 0xD1, 
    0x35, 0xF2, 0xB1, 0x70, 0xC5, 0x95, 0x00, 0x5C, 0xEB, 0x6F, 
    0x3A, 0xBC, 0x58, 0xB1, 0x49, 0x2C, 0x60, 0x05, 0xCC, 0x3C, 
    0x27, 0x85, 0x17, 0xA6, 0xF8, 0x6C, 0xDB, 0x3E, 0x7D, 0x53, 
    0x8E, 0xBD, 0x45, 0x7A, 0x8E, 0x08, 0xC6, 0x2B, 0x4F, 0xA1, 
    0x28, 0x82, 0x40, 0x98, 0xB6, 0xE6, 0x92, 0xD1, 0x45, 0x7A, 0x55, 

    0xF7, 0x1C, 0xD7, 0x46, 0x9C, 0x68, 0xF6, 0xC1, 0x1A, 0x70,         // 15
    0xCB, 0x56, 0x7B, 0xD3, 0xAD, 0xC0, 0x72, 0x18, 0x57, 0xFB, 
    0xA5, 0x05, 0xF0, 0xB8, 0x4C, 0xF6, 0x1E, 0x55, 0x95, 0x0F, 
    0x82, 0x30, 0xC2, 0x4C, 0xA2, 0x64, 0xFE, 0x87, 0xB2, 0x5E, 
    0x9B, 0x49, 0xD4, 0x17, 0xDF, 0x33, 0x79, 0xBD, 0x2F, 0xA3, 
    0x8F, 0xDA, 0x1D, 0xE6, 0x70, 0xFA, 0xBB, 0xAA, 0xE7, 0x90, 
    0x5E, 0xF0, 0x6E, 0xCD, 0x53, 0x27, 0xC0, 0x10, 0xAC, 0xCB, 
    0x05, 0x6C, 0x9D, 0x22, 0x51, 0xF7, 0x97, 0x6D, 0xEC, 0x87, 
    0xA9, 0xE3, 0x1A, 0xD6, 0x25, 0x3E, 0x6E, 0x11, 0xED, 0xB5, 0x0A, 

    0x74, 0x5B, 0xB5, 0x85, 0x18, 0xB7, 0x34, 0x83, 0xDA, 0x48,         // 16
    0xFA, 0x07, 0xE1, 0x28, 0x5B, 0xF7, 0x3D, 0x8C, 0xBA, 0x2C, 
    0x85, 0x40, 0x95, 0x18, 0x81, 0x3B, 0xAF, 0x7D, 0x2D, 0xA9, 
    0x63, 0xDE, 0x91, 0x2A, 0x7A, 0x09, 0xCD, 0x1B, 0xEA, 0x26, 
    0x81, 0x0A, 0x66, 0x8D, 0x4E, 0xA2, 0xE7, 0x51, 0xD4, 0x0B, 
    0x47, 0x79, 0x31, 0x96, 0x15, 0x85, 0x39, 0x21, 0x77, 0x11, 
    0xC4, 0x9E, 0x06, 0x3A, 0x9A, 0xEB, 0x77, 0x95, 0xFD, 0x48, 
    0xE7, 0x35, 0xCA, 0xE3, 0xB1, 0x63, 0x1A, 0x3F, 0xBF, 0x11, 
    0x3A, 0x66, 0xB4, 0x59, 0x7A, 0xF7, 0xA4, 0x53, 0x86, 0x35, 0xC8, 

    0x27, 0xE3, 0x33, 0xF4, 0x70, 0xDD, 0x5E, 0x00, 0xB1, 0x8E,         // 17
    0x34, 0xA2, 0x88, 0x46, 0x99, 0x09, 0xA5, 0x63, 0xD1, 0x50, 
    0xE1, 0x69, 0xD3, 0x59, 0xE3, 0xBF, 0x01, 0xED, 0xD5, 0x46, 
    0xBC, 0x04, 0x59, 0xF5, 0xB7, 0x48, 0x94, 0x3F, 0x75, 0xD6, 
    0xBC, 0xFA, 0xA5, 0x30, 0xED, 0x10, 0x90, 0x1F, 0xB3, 0x67, 
    0xF9, 0xAC, 0xCC, 0x62, 0xA5, 0xD3, 0x5B, 0xEE, 0x48, 0xDB, 
    0x2E, 0x4E, 0xBB, 0xE3, 0x84, 0x13, 0x4D, 0x2D, 0x61, 0x17, 
    0x7C, 0xA3, 0x5B, 0x0A, 0x30, 0xD9, 0xA5, 0x81, 0xD3, 0x5A, 
    0x99, 0xFB, 0x07, 0x8E, 0xC2, 0x0C, 0xCF, 0x29, 0xE0, 0x5E, 0x9D, 

    0x8C, 0x49, 0xA2, 0x0B, 0xC6, 0x27, 0x9E, 0xE7, 0x50, 0x13,         // 18
    0xC4, 0x60, 0x1A, 0xEE, 0x76, 0xD6, 0x25, 0xEC, 0x12, 0x9C, 
    0x24, 0xBD, 0x0D, 0xA0, 0x26, 0x61, 0x96, 0x6F, 0x1A, 0x88, 
    0xEF, 0x78, 0xCA, 0x19, 0x86, 0xE5, 0xC1, 0x5E, 0xA5, 0x36, 
    0x56, 0x21, 0x7D, 0xCD, 0x5B, 0xBF, 0x75, 0x3C, 0xDD, 0x86, 
    0x35, 0x54, 0x0E, 0xF2, 0x4C, 0x01, 0x91, 0xBF, 0xAA, 0x65, 
    0x87, 0xFC, 0x73, 0x1F, 0x60, 0xC7, 0xAA, 0xB7, 0xD6, 0x90, 
    0xC0, 0x24, 0xF9, 0x8D, 0x76, 0xBC, 0x52, 0x04, 0xF1, 0x2E, 
    0x79, 0xC8, 0x42, 0xE0, 0x4D, 0x34, 0x71, 0x90, 0xB8, 0x01, 0xD5, 

    0x15, 0xC8, 0x7F, 0x63, 0x4A, 0x89, 0x3F, 0xC7, 0x6A, 0xF3,         // 19
    0x7A, 0xDA, 0xAA, 0xB6, 0x37, 0x57, 0x87, 0xB5, 0x42, 0x7C, 
    0xF5, 0x71, 0x38, 0xEB, 0x7A, 0xDB, 0x40, 0xC7, 0x5D, 0xA4, 
    0x3B, 0x22, 0x99, 0x3F, 0x65, 0x0F, 0x32, 0xF5, 0x0A, 0x8B, 
    0xB2, 0xDD, 0x44, 0x06, 0xB0, 0x29, 0xFB, 0x5C, 0x9D, 0x16, 
    0xE4, 0xC5, 0x72, 0xB0, 0x33, 0xE4, 0x6D, 0x3F, 0x17, 0xD1, 
    0x0C, 0x9B, 0x47, 0xA9, 0xDA, 0x35, 0xE7, 0x03, 0x6D, 0x3E, 
    0xDE, 0x6A, 0x49, 0xCF, 0x3C, 0xED, 0x25, 0x9D, 0x6A, 0xB7, 
    0x16, 0xA0, 0x27, 0x7C, 0xB7, 0x99, 0xEE, 0x1E, 0x6B, 0xFE, 0x56, 

    0xA7, 0xF2, 0x20, 0xD9, 0xBB, 0xFB, 0x19, 0x80, 0x2A, 0xA3,         // 20
    0x1F, 0x3D, 0x59, 0x03, 0xE5, 0xC3, 0x2D, 0x68, 0xCF, 0x02, 
    0xB1, 0x4A, 0x8E, 0xC3, 0x50, 0x0B, 0xB0, 0x2B, 0xF5, 0x0A, 
    0xD3, 0x68, 0xE8, 0xAE, 0xDB, 0x9C, 0x7B, 0xA9, 0x6A, 0xEC, 
    0x17, 0x6F, 0x96, 0xF0, 0x69, 0x83, 0xC7, 0x03, 0xB7, 0x78, 
    0x2D, 0x92, 0x25, 0xDB, 0x7B, 0xAB, 0x1F, 0xF7, 0x7C, 0xB5, 
    0x42, 0xD8, 0x27, 0x8A, 0x0C, 0x75, 0x51, 0x86, 0xF3, 0x1D, 
    0xA1, 0x0C, 0xB8, 0x96, 0x14, 0x67, 0x8A, 0xCA, 0x3D, 0xE0, 
    0x4F, 0xD8, 0x61, 0xF2, 0x14, 0x5E, 0xC6, 0x4B, 0xA1, 0x38, 0x83, 

    0x2B, 0x71, 0x3C, 0x93, 0x05, 0xA8, 0x60, 0xEA, 0xBB, 0x4A,         // 21
    0x8E, 0xCD, 0xF9, 0x6F, 0x8C, 0x12, 0x9B, 0xFD, 0x52, 0x89, 
    0xD8, 0x18, 0xA7, 0x30, 0xF8, 0x91, 0xD2, 0x74, 0x98, 0x4D, 
    0xBB, 0x8A, 0x4A, 0x2B, 0xC5, 0x23, 0x4C, 0xDA, 0x2F, 0x4F, 
    0xBD, 0x31, 0xD0, 0x4B, 0x1F, 0x9A, 0x3D, 0xDB, 0x4F, 0xF5, 
    0x5E, 0xA6, 0x48, 0x09, 0xC2, 0x4F, 0xCE, 0x9D, 0x2C, 0x5A, 
    0xEF, 0x6C, 0xB7, 0x55, 0xF8, 0xC0, 0x9A, 0x27, 0xBD, 0x55, 
    0x7B, 0xED, 0x2E, 0x54, 0xE7, 0xBA, 0x33, 0xFE, 0x1A, 0x81, 
    0x95, 0x01, 0xA9, 0x8F, 0x45, 0xE3, 0x06, 0x86, 0xDA, 0x12, 0xC3, 

    0x59, 0x9D, 0xE4, 0x50, 0x77, 0x37, 0x9B, 0x0D, 0xD6, 0x68,         // 22
    0x13, 0xB7, 0x30, 0xA1, 0x45, 0xDC, 0x76, 0x1A, 0xBA, 0x36, 
    0x6E, 0xEE, 0x5A, 0x80, 0x20, 0x67, 0x3B, 0x18, 0xDF, 0x82, 
    0x25, 0xF7, 0x06, 0x7A, 0x58, 0xFA, 0x8A, 0x00, 0xA4, 0x91, 
    0xE6, 0x85, 0x0D, 0xAC, 0xC2, 0xE8, 0x65, 0x25, 0x91, 0x0D, 
    0xBE, 0xD9, 0x85, 0xFE, 0x6C, 0x30, 0x83, 0x07, 0xDA, 0x8D, 
    0x35, 0x02, 0xCB, 0x93, 0x3E, 0x1F, 0xE9, 0x44, 0xAB, 0xCC, 
    0x38, 0x8D, 0xD3, 0x78, 0xA1, 0x07, 0x75, 0x54, 0xA9, 0x5E, 
    0xED, 0x3F, 0x75, 0x2E, 0xCC, 0x6B, 0xA9, 0x42, 0xB9, 0x65, 0xE2, 

    0x09, 0xCA, 0x1E, 0xB2, 0xF1, 0xD0, 0x54, 0x83, 0x30, 0xB0,         // 23
    0xF1, 0x56, 0x83, 0x1B, 0xCC, 0x5F, 0xA9, 0x4B, 0xE8, 0x97, 
    0x23, 0xC2, 0x06, 0xD5, 0xA2, 0xE5, 0xBE, 0x58, 0xA5, 0x3F, 
    0x66, 0xAC, 0xCE, 0x94, 0xB4, 0x1B, 0xC1, 0x71, 0xD4, 0x15, 
    0x68, 0x3B, 0xFA, 0x77, 0x59, 0x10, 0x7D, 0xB1, 0xCB, 0x6F, 
    0x3E, 0x19, 0x57, 0x9C, 0x1D, 0xBA, 0xED, 0x55, 0x6D, 0xC2, 
    0xA1, 0x77, 0xEB, 0x14, 0x6A, 0xA4, 0x60, 0x7C, 0x13, 0xF7, 
    0x67, 0x00, 0xB3, 0x23, 0x3D, 0xC5, 0xDB, 0x96, 0x0D, 0xC1, 
    0x25, 0xD2, 0xB6, 0xFC, 0x1D, 0x97, 0x32, 0x77, 0xF0, 0x3A, 0x89, 

    0xFA, 0x4A, 0x86, 0x63, 0x12, 0x2B, 0xBC, 0xDE, 0x4C, 0x90,         // 24
    0x74, 0x08, 0xE1, 0xBC, 0x3B, 0xF4, 0x2A, 0x84, 0x08, 0xCE, 
    0x55, 0x84, 0xAD, 0x60, 0x42, 0x0E, 0x81, 0xFE, 0x02, 0xC7, 
    0xE4, 0x15, 0x55, 0x36, 0xE3, 0x65, 0x3C, 0xF0, 0x5A, 0x34, 
    0xC5, 0xA2, 0x4F, 0xCA, 0x34, 0xA1, 0xF4, 0x4A, 0x2C, 0xEE, 
    0xA7, 0x7A, 0xE9, 0x41, 0xD3, 0x8F, 0x3A, 0xA8, 0x13, 0xFB, 
    0x24, 0x4A, 0xA8, 0x80, 0xE0, 0xC9, 0x05, 0xDC, 0x8F, 0x2E, 
    0xA0, 0xDA, 0x57, 0xF9, 0x66, 0x88, 0x47, 0x2D, 0xE3, 0x7A, 
    0x98, 0x4B, 0x0E, 0x60, 0x83, 0xC1, 0xE9, 0x15, 0x92, 0x22, 0xB2, 

    0x72, 0x2E, 0xC1, 0xDC, 0x9F, 0x89, 0x69, 0x05, 0xEC, 0x22,         // 25
    0xD5, 0x4A, 0xAB, 0x6D, 0x90, 0x0D, 0x9E, 0xD6, 0x62, 0xB3, 
    0x3B, 0xFB, 0x32, 0xDF, 0x8F, 0x6E, 0xB3, 0x29, 0x94, 0x72, 
    0x32, 0x88, 0xF2, 0x73, 0x09, 0x99, 0xA7, 0x10, 0xB8, 0x81, 
    0xE2, 0x1D, 0x8D, 0x07, 0xDD, 0x86, 0x1A, 0xD4, 0x67, 0x8C, 
    0x23, 0xC9, 0x07, 0xB0, 0x64, 0x0F, 0x74, 0xDF, 0x49, 0x88, 
    0x65, 0xD9, 0x2C, 0x55, 0x21, 0x8A, 0x39, 0xA8, 0x56, 0xC6, 
    0x47, 0x7A, 0x1D, 0x93, 0xCD, 0x13, 0xF3, 0xA7, 0x67, 0x3C, 
    0xF5, 0x6F, 0xA8, 0xE0, 0x4D, 0x09, 0x69, 0xB3, 0x51, 0xCF, 0x5C, 

    0xDE, 0x99, 0x01, 0x41, 0x57, 0xFD, 0x3A, 0xA7, 0x71, 0xC5,         // 26
    0x9C, 0x2A, 0xF8, 0x16, 0x5B, 0xCA, 0x72, 0x30, 0xF3, 0x14, 
    0x95, 0x73, 0x1F, 0xB6, 0x16, 0xEF, 0x39, 0x64, 0xD9, 0x4A, 
    0xC1, 0xA4, 0x1F, 0xBB, 0xD4, 0x53, 0x7D, 0xD7, 0x28, 0x9C, 
    0x45, 0x6B, 0xEC, 0xB4, 0x63, 0x3F, 0xBC, 0x9C, 0x02, 0xDE, 
    0x47, 0x97, 0x6C, 0xDD, 0x2B, 0xF6, 0xC0, 0x1C, 0xA2, 0xCE, 
    0x17, 0xB9, 0x94, 0xEE, 0xC1, 0x4A, 0xFE, 0x6E, 0x26, 0xE5, 
    0x15, 0xBD, 0xEA, 0x34, 0xAF, 0x4F, 0x7F, 0x24, 0xD6, 0x06, 
    0xC5, 0x1B, 0x91, 0x36, 0xCA, 0x9E, 0xDE, 0x2E, 0xF5, 0xAA, 0x14, 

    0xC6, 0x81, 0xED, 0x75, 0xB9, 0x18, 0xCB, 0x92, 0x15, 0x40,         // 27
    0x5F, 0x7C, 0xBF, 0x35, 0xA4, 0xEE, 0x42, 0xBF, 0x8C, 0x52, 
    0xDE, 0xA6, 0x59, 0xCA, 0x4E, 0x99, 0xD3, 0xB9, 0x23, 0xF4, 
    0x09, 0x78, 0x45, 0x94, 0x26, 0xFD, 0x19, 0x49, 0x70, 0xF6, 
    0x0B, 0xCE, 0x2F, 0x7D, 0x21, 0xFD, 0x54, 0x78, 0x38, 0xB8, 
    0x5E, 0xFA, 0x35, 0x86, 0x4C, 0x99, 0x7F, 0x5E, 0x30, 0x6F, 
    0xF4, 0x40, 0x5F, 0x0F, 0x72, 0x9C, 0x1B, 0xC8, 0x82, 0x9E, 
    0x68, 0x8D, 0x50, 0x7E, 0x0B, 0xE4, 0xC0, 0x5D, 0x90, 0xA5, 
    0x81, 0x52, 0xE8, 0x21, 0x7E, 0x3E, 0x5D, 0x88, 0x05, 0x7B, 0x43, 

    0x1D, 0x5F, 0x3A, 0xA3, 0x29, 0xDF, 0x7B, 0x53, 0xF5, 0xAF,         // 28
    0xE6, 0x01, 0x93, 0xDC, 0x4B, 0x85, 0x05, 0x65, 0x23, 0xD1, 
    0x39, 0x01, 0x8B, 0xE9, 0x33, 0x82, 0x07, 0x53, 0x7F, 0x9A, 
    0x5D, 0xEB, 0xC9, 0x6B, 0x39, 0x86, 0xC3, 0xE5, 0xB0, 0x55, 
    0x8A, 0xB9, 0x49, 0xA4, 0xCC, 0x96, 0x11, 0xC4, 0xEF, 0x80, 
    0x0F, 0xA4, 0x18, 0xB9, 0xD0, 0x01, 0x3D, 0xEF, 0xC6, 0x8D, 
    0x05, 0xAE, 0x7D, 0xD8, 0x36, 0xBB, 0x60, 0xE8, 0x10, 0x45, 
    0xF5, 0x05, 0xD4, 0xBA, 0x62, 0x96, 0x35, 0x16, 0xF2, 0x43, 
    0x28, 0xCC, 0x6D, 0xB8, 0xFA, 0x10, 0xD4, 0xBE, 0x4C, 0xE5, 0xB0, 

    0xF9, 0xBC, 0x12, 0xCF, 0x87, 0x47, 0x10, 0xB8, 0x26, 0x86,         // 29
    0x2E, 0xCF, 0x54, 0x73, 0x1C, 0xD1, 0x9E, 0xE6, 0xAF, 0x70, 
    0xB6, 0xF4, 0x66, 0x13, 0xA9, 0x61, 0xF8, 0xAB, 0x15, 0xCE, 
    0x3B, 0xA7, 0x0F, 0xDA, 0xB5, 0x5E, 0x9D, 0x04, 0x35, 0xD2, 
    0x2B, 0x71, 0xF2, 0x03, 0x68, 0x32, 0xE5, 0x6E, 0x1E, 0xAE, 
    0xD1, 0x43, 0x76, 0xEE, 0x5D, 0xA1, 0xD9, 0xAD, 0x22, 0x4B, 
    0xE1, 0xCB, 0x1B, 0xA0, 0xF4, 0x02, 0x94, 0x50, 0xAD, 0xC1, 
    0x2F, 0xA4, 0x41, 0x21, 0xFD, 0x47, 0xD1, 0x7A, 0xB7, 0x68, 
    0xDD, 0xAA, 0x00, 0x49, 0xAC, 0x6B, 0x8E, 0x1D, 0x9F, 0x68, 0x2C, 

    0x4E, 0x98, 0x73, 0xF4, 0x60, 0x9F, 0xED, 0x66, 0xD8, 0x46,         // 30
    0x6A, 0xB6, 0x13, 0xFB, 0xB8, 0x2B, 0x78, 0x3D, 0x11, 0x8E, 
    0x2B, 0x4A, 0xC4, 0x78, 0xDE, 0x21, 0xC7, 0x44, 0xEA, 0x69, 
    0x26, 0x8D, 0x52, 0x2F, 0xED, 0x1C, 0x44, 0x83, 0x69, 0x99, 
    0xE3, 0x19, 0x90, 0x53, 0xDD, 0x83, 0x44, 0xA4, 0x50, 0x2C, 
    0x67, 0xE2, 0x93, 0x23, 0x39, 0x70, 0x19, 0x54, 0x81, 0x9F, 
    0x6D, 0x38, 0x56, 0x88, 0x47, 0x79, 0xD6, 0x2A, 0x72, 0xE2, 
    0x5E, 0x7C, 0xDF, 0x8F, 0x6E, 0xA6, 0x03, 0xE5, 0x3C, 0x8C, 
    0x15, 0x5C, 0xEC, 0x92, 0x24, 0xDB, 0x53, 0xF1, 0x37, 0xD6, 0x87, 

    0x04, 0xDE, 0x30, 0x49, 0x0B, 0xC3, 0x3A, 0x8F, 0x08, 0x9E,         // 31
    0xEF, 0x8B, 0x38, 0x9D, 0x5A, 0xEB, 0x4E, 0xCB, 0xF7, 0x57, 
    0xE1, 0x95, 0x24, 0x9F, 0x3C, 0x94, 0x70, 0x2D, 0x8A, 0xB4, 
    0xDF, 0xC5, 0x7B, 0xA2, 0x6F, 0xAC, 0xC5, 0xF8, 0xA8, 0x0E, 
    0x50, 0xB5, 0xCF, 0x2F, 0xAC, 0xBF, 0x0C, 0xD3, 0x90, 0xF6, 
    0xBD, 0x05, 0x4D, 0xB5, 0xCB, 0x96, 0xEC, 0xBC, 0x09, 0xF4, 
    0x28, 0xA7, 0xED, 0xBD, 0x24, 0xC6, 0x39, 0xFA, 0x09, 0x90, 
    0x18, 0xC4, 0x55, 0x0D, 0xCA, 0x30, 0x67, 0x9D, 0x25, 0xFA, 
    0xB3, 0x34, 0xC3, 0x7C, 0x38, 0xB5, 0x13, 0xC6, 0x76, 0x21, 0xA9, 

    0x6E, 0x90, 0xC9, 0xA5, 0xE8, 0x78, 0x21, 0xD1, 0x70, 0xBE,         // 32
    0x1E, 0x4F, 0xE4, 0x75, 0x06, 0x8B, 0xA9, 0x1D, 0x82, 0xBE, 
    0x0B, 0xD3, 0x62, 0xFC, 0x51, 0x04, 0xBF, 0xDC, 0x50, 0x08, 
    0x59, 0x1F, 0xF1, 0x01, 0x3E, 0xD5, 0x11, 0x4C, 0x28, 0xEB, 
    0x7F, 0x37, 0x6E, 0xF9, 0x1C, 0x77, 0xF0, 0x61, 0x1B, 0x7B, 
    0x54, 0xA4, 0x81, 0xFD, 0x0B, 0x7E, 0x2C, 0x67, 0xD8, 0x44, 
    0xC9, 0x7D, 0x07, 0x6C, 0xE5, 0x5C, 0xA7, 0x85, 0xBD, 0x53, 
    0x9E, 0xF7, 0x28, 0xAD, 0xE3, 0x82, 0xBF, 0x4F, 0xCF, 0x5F, 
    0x84, 0xDA, 0x0E, 0x4E, 0xF6, 0x67, 0x84, 0x3D, 0x99, 0x5A, 0xEA, 

    0x43, 0x19, 0x67, 0x28, 0x8D, 0x5A, 0xB5, 0x49, 0xFC, 0x37,         // 33
    0x62, 0xC4, 0x18, 0xA8, 0xD2, 0x2F, 0x61, 0x9C, 0x38, 0x6E, 
    0x47, 0x84, 0x1B, 0xC8, 0xAF, 0xEA, 0x7D, 0x1B, 0xA7, 0xFB, 
    0x76, 0xA8, 0x4B, 0x93, 0xE4, 0x59, 0x8A, 0x74, 0xC9, 0x5E, 
    0xA2, 0xC7, 0x08, 0x8B, 0x5C, 0x41, 0x9B, 0x38, 0xA9, 0xE0, 
    0x30, 0xD8, 0x20, 0x65, 0x42, 0xD2, 0x4D, 0xA6, 0x86, 0x5D, 
    0x1A, 0x94, 0x50, 0xB5, 0x13, 0x9A, 0x1E, 0x6B, 0x40, 0xD5, 
    0x31, 0x6C, 0x89, 0x41, 0x60, 0x11, 0xF5, 0x1F, 0x93, 0x12, 
    0x3E, 0x6F, 0x96, 0xA6, 0xCA, 0x05, 0xE2, 0xAE, 0xFE, 0x11, 0xC1, 

    0xDC, 0xAF, 0xF7, 0x4E, 0xD7, 0x04, 0xE0, 0x93, 0x14, 0xAF,         // 34
    0x86, 0xDD, 0x95, 0x69, 0x45, 0xE5, 0xBB, 0x0E, 0xD5, 0xB2, 
    0xF2, 0xA6, 0x41, 0x7A, 0x12, 0x5B, 0x98, 0x41, 0x67, 0x95, 
    0x38, 0xD1, 0x81, 0x2A, 0xB2, 0x1D, 0xA2, 0xE1, 0x39, 0x8F, 
    0x1B, 0xDF, 0x55, 0xA8, 0xE6, 0xB9, 0x00, 0xCE, 0x6F, 0x11, 
    0x91, 0x43, 0xC3, 0x99, 0xE1, 0xB2, 0x12, 0xF6, 0x25, 0xD0, 
    0xA9, 0xFC, 0x32, 0xD3, 0x83, 0x4A, 0xE9, 0xCE, 0x0E, 0xF1, 
    0xA7, 0x00, 0xCD, 0xEC, 0xB3, 0x38, 0xA5, 0x70, 0xE9, 0xC2, 
    0xAE, 0xE4, 0x1E, 0x5A, 0x2C, 0x90, 0x4B, 0x1C, 0x7A, 0x37, 0x8C, 

    0x0A, 0x78, 0x22, 0xBE, 0x80, 0xA1, 0x34, 0x56, 0x7B, 0xE5,         // 35
    0x02, 0x4B, 0x2B, 0xF6, 0x0C, 0x8E, 0x72, 0xFE, 0x5E, 0x32, 
    0x03, 0x91, 0xE9, 0x2F, 0x9E, 0xD8, 0x25, 0xEE, 0xCC, 0x0C, 
    0xE7, 0x16, 0x62, 0xF8, 0xCD, 0x67, 0x32, 0xBB, 0x04, 0xFB, 
    0x48, 0x7B, 0x2A, 0x95, 0x32, 0xD5, 0x8E, 0x55, 0xFB, 0xA0, 
    0x5F, 0xF2, 0x6D, 0x16, 0x3A, 0x5F, 0x8D, 0x6F, 0x9B, 0x3E, 
    0x69, 0x0F, 0x9D, 0x61, 0xF1, 0x2E, 0xAB, 0x57, 0x8F, 0x73, 
    0x3B, 0x94, 0x4E, 0x1B, 0x7E, 0xDC, 0x8E, 0x47, 0x2F, 0x62, 
    0x02, 0x4D, 0xC6, 0xEC, 0x7F, 0xD3, 0xB4, 0x61, 0xD9, 0xB8, 0x66, 

    0x50, 0xD6, 0x92, 0x3F, 0x13, 0x65, 0xF5, 0xC0, 0x28, 0xC9,         // 36
    0x68, 0xA6, 0x7F, 0xB4, 0x58, 0xC6, 0x19, 0x46, 0x8A, 0xE3, 
    0x78, 0x4F, 0xD0, 0x66, 0xC3, 0x4A, 0x76, 0xB4, 0x31, 0x88, 
    0x4E, 0xB9, 0x9A, 0x44, 0x08, 0x8D, 0xF0, 0x57, 0x9B, 0x6A, 
    0xCF, 0xAD, 0xEB, 0x0E, 0x6F, 0x4B, 0x1E, 0x7E, 0x28, 0x3C, 
    0xC9, 0x04, 0xA6, 0x89, 0xEF, 0xC7, 0x34, 0xE7, 0x00, 0xD7, 
    0x81, 0xE1, 0x46, 0xC5, 0x09, 0x75, 0xBA, 0x14, 0xC6, 0x23, 
    0xB2, 0xE7, 0x70, 0xB9, 0x2C, 0x53, 0x09, 0xBC, 0xD9, 0x89, 
    0xF3, 0x79, 0x93, 0x36, 0x67, 0x16, 0xF4, 0x44, 0xA0, 0x29, 0xF0, 

    0x31, 0xAC, 0x5B, 0xD0, 0xEB, 0xB1, 0x1A, 0x6B, 0x97, 0x41,         // 37
    0xF1, 0x36, 0xD2, 0x22, 0xE2, 0x32, 0xA2, 0xCC, 0x20, 0xAA, 
    0x2B, 0xB4, 0x14, 0x88, 0x20, 0xFA, 0x01, 0xA9, 0x5E, 0xC2, 
    0x6F, 0xDB, 0x24, 0xA9, 0x74, 0xC6, 0x1A, 0x7C, 0x41, 0xBE, 
    0x17, 0x38, 0x5F, 0xB4, 0xF4, 0xA0, 0xDF, 0xC4, 0xB0, 0xE8, 
    0x79, 0x47, 0xBE, 0x2A, 0x76, 0x0B, 0xAC, 0x5C, 0xBB, 0x4E, 
    0x29, 0xB6, 0x88, 0x24, 0x97, 0xE1, 0x36, 0x85, 0xEB, 0x4D, 
    0xD7, 0x5A, 0x15, 0xFB, 0x98, 0xCC, 0xF1, 0x78, 0x16, 0x9F, 
    0x27, 0x3F, 0xA7, 0x0A, 0xC0, 0xAA, 0x31, 0x75, 0x01, 0x8F, 0xC3, 

    0x7C, 0xFB, 0x09, 0x70, 0x29, 0x47, 0x84, 0xCE, 0x0B, 0xBA,         // 38
    0x8C, 0x10, 0x5B, 0x96, 0x65, 0x81, 0x51, 0xED, 0x69, 0xBF, 
    0xDC, 0x6F, 0xF3, 0x3D, 0xB6, 0x92, 0x54, 0xD9, 0x23, 0xEA, 
    0x14, 0x3A, 0x8E, 0x58, 0xED, 0x38, 0xAC, 0xE0, 0x0C, 0xF2, 
    0xA0, 0x8C, 0xDA, 0x43, 0x7B, 0x12, 0x61, 0x44, 0x0B, 0x95, 
    0x21, 0xE1, 0x63, 0xD2, 0x50, 0x96, 0xDC, 0x1A, 0x78, 0x9E, 
    0xEA, 0x12, 0x59, 0xF7, 0x68, 0x44, 0xCC, 0x63, 0x2D, 0xA3, 
    0x0C, 0x8E, 0xCD, 0x3E, 0x74, 0x5E, 0x28, 0xA7, 0x4E, 0x6B, 
    0xB3, 0xDD, 0x5A, 0xF7, 0x49, 0xE1, 0x87, 0xC7, 0xEC, 0x62, 0x14, 

    0x98, 0x4D, 0xBC, 0x8A, 0xC6, 0x9D, 0xDF, 0x35, 0xE8, 0x53,         // 39
    0x70, 0xAE, 0xDE, 0x19, 0xFA, 0xB6, 0x01, 0x96, 0x16, 0x56, 
    0x40, 0x07, 0x9B, 0x5A, 0xE4, 0x36, 0x7C, 0xBB, 0x46, 0x9C, 
    0x7E, 0xFE, 0xCC, 0x0F, 0xB3, 0x5F, 0x27, 0xCD, 0x86, 0x5B, 
    0x22, 0x73, 0x03, 0xC7, 0x2E, 0xBE, 0x8B, 0xF5, 0x72, 0x51, 
    0xA8, 0x87, 0x0D, 0xA3, 0xF3, 0x26, 0x44, 0xC5, 0xFB, 0x34, 
    0x6A, 0xCC, 0xA3, 0x30, 0xC0, 0xA1, 0x02, 0xFE, 0x91, 0x6E, 
    0xC0, 0x38, 0x7D, 0xA6, 0x04, 0xC1, 0x8B, 0x3D, 0xC7, 0xFD, 
    0x07, 0xC2, 0x24, 0x72, 0x96, 0x10, 0x69, 0x1D, 0xB1, 0x47, 0xDD, 

    0x6A, 0x22, 0x38, 0xDA, 0x54, 0x06, 0x7B, 0x5D, 0xA4, 0x28,         // 40
    0xF6, 0x42, 0xC3, 0x76, 0x46, 0xCD, 0x39, 0xD7, 0x7C, 0xF8, 
    0x8F, 0xBD, 0xD8, 0x80, 0x0D, 0xCE, 0x1D, 0xF5, 0x6C, 0x06, 
    0xB1, 0x4D, 0x76, 0x3D, 0xE1, 0x7D, 0x9A, 0x4A, 0xA5, 0x32, 
    0xD3, 0xAE, 0xFE, 0x5E, 0x9B, 0xE4, 0x34, 0x1C, 0xB8, 0xD6, 
    0x33, 0xFD, 0x4C, 0x31, 0x8C, 0x69, 0xB0, 0x7D, 0x57, 0x08, 
    0x8D, 0x3D, 0x73, 0xDD, 0x19, 0x7E, 0x58, 0xB4, 0x1B, 0xE3, 
    0x53, 0xD9, 0x1E, 0xE2, 0x57, 0xEE, 0x13, 0xDB, 0x96, 0x33, 
    0x63, 0x9E, 0x85, 0xCE, 0x30, 0xB0, 0x4F, 0xD4, 0x8B, 0x34, 0xA4, 

    0xCB, 0xED, 0xAC, 0x74, 0x27, 0xFA, 0xBA, 0x15, 0x8F, 0xC8,         // 41
    0x03, 0x89, 0x29, 0x9F, 0x0F, 0x85, 0x62, 0xAE, 0x2B, 0xA2, 
    0x36, 0x61, 0x25, 0x4B, 0xA6, 0x68, 0xB1, 0x40, 0x8B, 0xD3, 
    0x2E, 0xBD, 0x16, 0x9E, 0xC5, 0x00, 0xFA, 0x1D, 0x77, 0xEC, 
    0x67, 0x47, 0x26, 0x82, 0x10, 0x4E, 0xA6, 0xDA, 0x7E, 0x02, 
    0x64, 0xBA, 0x73, 0xDD, 0xBE, 0x06, 0xE6, 0x1C, 0xAA, 0xD3, 
    0xB5, 0xF4, 0x0F, 0x4D, 0x8C, 0xE9, 0x28, 0xD2, 0x3F, 0x85, 
    0x06, 0xAE, 0x69, 0x92, 0x24, 0xAD, 0x81, 0x52, 0x20, 0x7B, 
    0xD8, 0x48, 0x1B, 0xE9, 0x60, 0xC2, 0xFA, 0x2C, 0x71, 0xF2, 0x1A, 

    0x80, 0x03, 0x5B, 0xE6, 0x99, 0x45, 0x6C, 0xEC, 0x3A, 0x72,         // 42
    0xD8, 0x61, 0xE8, 0x56, 0xB2, 0xF3, 0x1B, 0xE5, 0x53, 0x0A, 
    0xEA, 0x76, 0xCB, 0xFD, 0x8D, 0x28, 0xE9, 0x10, 0xA4, 0x51, 
    0xE7, 0x5F, 0xF1, 0x84, 0x59, 0x34, 0x6A, 0xD2, 0xB6, 0x29, 
    0xC2, 0x8F, 0xDD, 0xB4, 0xED, 0x6C, 0x88, 0x3B, 0x5A, 0xA1, 
    0xE6, 0x14, 0x9C, 0x1D, 0x82, 0x5A, 0xC3, 0x39, 0xEE, 0x46, 
    0x21, 0x7B, 0x9D, 0xD1, 0xBC, 0x38, 0x71, 0x9A, 0x5F, 0xEE, 
    0xC6, 0x36, 0xF3, 0x4C, 0xCB, 0x34, 0x64, 0xE7, 0xC9, 0xAF, 
    0x10, 0xF0, 0x6C, 0xA7, 0x02, 0x41, 0x7A, 0xA5, 0x0B, 0xBA, 0x55, 

    0x96, 0xBF, 0x2E, 0x8A, 0x0D, 0xA6, 0xD2, 0x1F, 0xAE, 0x4B,         // 43
    0x99, 0x31, 0xBD, 0x22, 0xD5, 0x47, 0x94, 0xC0, 0x77, 0xD7, 
    0xB4, 0x1A, 0x9E, 0x06, 0x42, 0xD6, 0x7E, 0x63, 0xDD, 0x20, 
    0x73, 0x97, 0x2A, 0x48, 0xDC, 0xBA, 0x92, 0x12, 0x58, 0xAA, 
    0x0D, 0x3C, 0x61, 0x1B, 0x37, 0xC1, 0x0B, 0xFA, 0xC9, 0x30, 
    0x8B, 0x46, 0xCA, 0x50, 0xF7, 0x32, 0x97, 0x66, 0x80, 0x9B, 
    0x60, 0xDF, 0x2B, 0x56, 0x09, 0xA6, 0xF6, 0x12, 0xB9, 0x26, 
    0x75, 0x8E, 0x14, 0xA7, 0x73, 0xFB, 0xB8, 0x00, 0x40, 0x8B, 
    0x5A, 0xBA, 0x3A, 0x8E, 0xE0, 0x98, 0x1F, 0xD9, 0x65, 0xE2, 0x3D, 

    0xFE, 0x6F, 0xD7, 0x4F, 0xC9, 0x34, 0x57, 0x83, 0xE4, 0xC4,         // 44
    0x10, 0xFD, 0x6B, 0x95, 0x7C, 0x05, 0x6A, 0x29, 0x42, 0x8D, 
    0x5F, 0x48, 0x84, 0xC3, 0x5E, 0xB5, 0x2D, 0x98, 0x4A, 0xBF, 
    0xA8, 0x0A, 0xCE, 0xAE, 0x10, 0x73, 0xEE, 0x42, 0xDD, 0x71, 
    0xF8, 0xCA, 0x9E, 0x76, 0xD2, 0xAB, 0x55, 0x94, 0x20, 0xB5, 
    0x68, 0xF1, 0x2A, 0x6F, 0xAC, 0xD0, 0x18, 0xDE, 0x26, 0xC8, 
    0x03, 0xBC, 0x71, 0xF2, 0x88, 0x65, 0x44, 0x81, 0xD8, 0x4D, 
    0xA5, 0x5C, 0xDB, 0x40, 0x0B, 0x8A, 0x2B, 0xA0, 0x70, 0xF6, 
    0x34, 0xD2, 0x79, 0x19, 0x5E, 0xC8, 0x4D, 0x8E, 0x37, 0xA2, 0x17, 

    0xB3, 0x46, 0x1E, 0xAF, 0x67, 0xE6, 0xA0, 0x04, 0x63, 0x35,         // 45
    0x86, 0xB2, 0x45, 0x12, 0xEE, 0xB1, 0xC8, 0xFB, 0xA4, 0x24, 
    0xC6, 0xF5, 0x30, 0xDF, 0x7A, 0x12, 0xF2, 0xCA, 0x03, 0xF9, 
    0x3B, 0x86, 0x65, 0xF6, 0x3B, 0xAB, 0x20, 0x82, 0x9E, 0x26, 
    0x4C, 0x7F, 0x02, 0xF4, 0x44, 0x1E, 0xE9, 0x71, 0x4F, 0xD5, 
    0x0D, 0x80, 0xBC, 0xDF, 0x03, 0x45, 0x74, 0xA8, 0x4C, 0xFC, 
    0x3B, 0x8D, 0x44, 0xB1, 0x20, 0xDD, 0xC0, 0x2F, 0x94, 0x0C, 
    0xFA, 0x22, 0xC7, 0x96, 0xE3, 0x58, 0xD4, 0x4F, 0xDA, 0x26, 
    0x9D, 0x08, 0xB0, 0xFC, 0x2B, 0xB2, 0xE5, 0x06, 0xC4, 0x83, 0x5F, 

    0x0E, 0xE1, 0x85, 0xF2, 0x11, 0x77, 0x2A, 0xF9, 0x91, 0xDA,         // 46
    0x57, 0x21, 0xE3, 0xA2, 0x73, 0x3A, 0x59, 0x16, 0x82, 0xE7, 
    0x01, 0xA6, 0x69, 0x21, 0xAC, 0x52, 0x8E, 0x34, 0x75, 0x92, 
    0x54, 0xE4, 0x1A, 0x99, 0x55, 0xD9, 0x60, 0xC9, 0x08, 0xBC, 
    0xE7, 0x2E, 0xB4, 0x57, 0x92, 0x79, 0xCC, 0x04, 0x9F, 0xEC, 
    0x43, 0x9A, 0x20, 0x55, 0x8C, 0xA0, 0xF2, 0x0C, 0x83, 0xA0, 
    0x6B, 0xE8, 0x15, 0xD0, 0x54, 0x98, 0x00, 0x5A, 0xEA, 0x6B, 
    0xB7, 0x45, 0x7E, 0x64, 0x1E, 0xB6, 0x7A, 0x19, 0xBF, 0x86, 
    0x5F, 0xE2, 0x48, 0x97, 0x6F, 0x3E, 0x7C, 0x5B, 0xF6, 0x27, 0xD4, 

    0x93, 0xA9, 0x35, 0x5F, 0x98, 0xD6, 0xBC, 0x44, 0xA7, 0x0C,         // 47
    0xBD, 0x77, 0xCE, 0x53, 0x2A, 0xE0, 0x8D, 0xD6, 0x33, 0x52, 
    0x79, 0x41, 0x94, 0xED, 0xC0, 0x3B, 0xDC, 0x60, 0xBB, 0x1F, 
    0xC8, 0x2C, 0xB6, 0x7E, 0x03, 0xBB, 0x2D, 0xF3, 0x52, 0x8C, 
    0x65, 0xAA, 0xD7, 0x1A, 0xE4, 0x2A, 0xA9, 0x3C, 0x83, 0x26, 
    0xB2, 0x60, 0xFC, 0xB5, 0x33, 0x67, 0xBD, 0x5B, 0xD5, 0x30, 
    0x0F, 0xC1, 0xAA, 0x6E, 0x3A, 0xFD, 0x75, 0xD2, 0x9F, 0x37, 
    0x8A, 0xE4, 0x03, 0xAA, 0xF0, 0x37, 0x9A, 0xE9, 0x47, 0x10, 
    0xB6, 0x73, 0x24, 0xD4, 0x0F, 0xEF, 0x9F, 0x18, 0xB4, 0x6F, 0x3A, 

    0x53, 0x78, 0x00, 0xCD, 0x3F, 0x19, 0x59, 0x7C, 0x2F, 0x6A,         // 48
    0xF5, 0x39, 0x91, 0x14, 0xC4, 0x9E, 0x08, 0x6B, 0xB8, 0x9A, 
    0xDB, 0xBE, 0x18, 0x5F, 0x07, 0x73, 0xA1, 0x12, 0xEC, 0xAA, 
    0x5D, 0x77, 0xD4, 0x33, 0xEC, 0x8A, 0x6E, 0x9A, 0x35, 0xDC, 
    0x18, 0x3C, 0x83, 0xBC, 0x6B, 0x9E, 0x61, 0xE2, 0xBC, 0x68, 
    0xCF, 0x0A, 0x7E, 0xD4, 0x15, 0xE3, 0x3B, 0x20, 0xB1, 0xEB, 
    0x5A, 0x7E, 0x2D, 0xE2, 0x85, 0x29, 0xB4, 0x4C, 0x11, 0xC9, 
    0x27, 0x52, 0xBB, 0x2F, 0xCD, 0x50, 0x07, 0x67, 0xA1, 0xDB, 
    0x36, 0xF2, 0x89, 0x54, 0xBB, 0x84, 0x32, 0xE0, 0x47, 0x9B, 0xE9, 

    0x1F, 0xBB, 0xFA, 0xA1, 0x87, 0xE2, 0xAB, 0xF0, 0xC5, 0x8B,         // 49
    0x18, 0xB0, 0x65, 0xED, 0x7E, 0x40, 0xF6, 0x4D, 0xCE, 0x0D, 
    0x5E, 0x31, 0xE5, 0x86, 0xCB, 0xFA, 0x27, 0x7F, 0x45, 0xD0, 
    0x09, 0xFD, 0x48, 0xA9, 0x57, 0x23, 0xC7, 0x0E, 0xB7, 0x80, 
    0xC5, 0xF8, 0x52, 0x08, 0x41, 0xF3, 0x1D, 0x4E, 0x11, 0xF5, 
    0x3A, 0x93, 0x2C, 0x4D, 0x9E, 0x79, 0xCA, 0x90, 0x72, 0x42, 
    0x97, 0xD1, 0x50, 0x06, 0xC4, 0x9A, 0x17, 0xEC, 0x85, 0x63, 
    0xDB, 0x96, 0xF8, 0x5E, 0x74, 0x92, 0xBB, 0xFC, 0x21, 0x8D, 
    0x5B, 0xC2, 0x02, 0xA6, 0x28, 0xD9, 0x63, 0xC8, 0x7A, 0x0A, 0xC4, 

    0x8B, 0x41, 0x6E, 0x4E, 0x29, 0x6A, 0x05, 0x50, 0x23, 0xDA,         // 50
    0x5A, 0xE4, 0x02, 0xB8, 0x5C, 0x1B, 0xB3, 0x7A, 0x27, 0x88, 
    0xFE, 0x77, 0xA4, 0x4D, 0x2E, 0xB0, 0x50, 0xC2, 0x96, 0x2E, 
    0x85, 0x9F, 0x19, 0x6B, 0x9A, 0xDD, 0x43, 0xFB, 0x61, 0x46, 
    0x0B, 0x73, 0xA3, 0xDF, 0xC2, 0x7F, 0x96, 0xD4, 0x76, 0xA5, 
    0x53, 0xEA, 0xC6, 0x6D, 0xF2, 0x0E, 0x55, 0xF6, 0x01, 0xC9, 
    0x18, 0xF9, 0xA6, 0x65, 0xEF, 0x42, 0x72, 0xCC, 0x3B, 0xB1, 
    0x1E, 0x80, 0x11, 0xA3, 0x25, 0xD6, 0x39, 0x77, 0x51, 0xCF, 
    0x2E, 0x9A, 0x68, 0xE9, 0x77, 0x46, 0x06, 0x90, 0x2B, 0xF3, 0x65, 

    0xE5, 0xD2, 0x15, 0xC4, 0xEE, 0xB0, 0xCE, 0x7F, 0x99, 0x41,         // 51
    0xA3, 0x29, 0x82, 0x44, 0xD2, 0x92, 0xE7, 0x38, 0xDC, 0xAE, 
    0x47, 0x1E, 0xD7, 0x0A, 0x8E, 0x66, 0xDD, 0x00, 0xF1, 0x63, 
    0xDA, 0x36, 0xC5, 0xEE, 0x0A, 0x75, 0xAB, 0x17, 0x92, 0xE6, 
    0xB3, 0x31, 0x91, 0x24, 0x5A, 0x12, 0x3A, 0xB5, 0x2B, 0x8F, 
    0x05, 0xAC, 0x1F, 0xB1, 0x33, 0x8B, 0xBA, 0x2E, 0xAC, 0x64, 
    0x87, 0x27, 0x3C, 0x95, 0x1A, 0xB6, 0x55, 0x8F, 0x04, 0xF5, 
    0x71, 0x36, 0xCF, 0x4D, 0xEC, 0x84, 0x15, 0xDC, 0xB5, 0x0C, 
    0x7C, 0xF8, 0x1F, 0x4D, 0xCA, 0xA0, 0xFD, 0xB6, 0x55, 0xA1, 0x38, 

    0xAF, 0x2F, 0x99, 0x7E, 0x0D, 0x4B, 0x32, 0xE7, 0x1A, 0xC0,         // 52
    0x6D, 0xD3, 0x9C, 0xF6, 0x24, 0x71, 0x06, 0x99, 0x54, 0x11, 
    0xC9, 0x92, 0x59, 0xB3, 0xF3, 0x3B, 0xAA, 0x74, 0x4B, 0x1F, 
    0xAE, 0x6F, 0x4D, 0x82, 0x3A, 0xD6, 0x4E, 0xC1, 0x6E, 0x20, 
    0xCF, 0x5C, 0xF3, 0x6F, 0xD4, 0xAB, 0xFE, 0x63, 0xE7, 0x6C, 
    0xDE, 0x7F, 0x4B, 0xE2, 0x5E, 0xD8, 0x49, 0x78, 0xDC, 0x44, 
    0xE4, 0xB7, 0x70, 0xD0, 0x7F, 0xDA, 0x21, 0xE6, 0xC1, 0x49, 
    0xA0, 0xE2, 0xB6, 0x6D, 0x05, 0xB0, 0x62, 0x9C, 0x42, 0xE3, 
    0xAB, 0x3F, 0xD4, 0x8E, 0x14, 0x38, 0x82, 0x17, 0xDB, 0x7C, 0x0F, 

    0x74, 0x52, 0xE8, 0x5C, 0xBB, 0x93, 0x74, 0xA8, 0x5F, 0xF8,         // 53
    0x0E, 0x4A, 0x74, 0x37, 0xA9, 0x58, 0xBC, 0xD2, 0x6A, 0xF3, 
    0x75, 0x26, 0xE9, 0x72, 0x18, 0xCE, 0x23, 0xBD, 0x8C, 0xC4, 
    0xE9, 0x06, 0x9A, 0xCE, 0xB4, 0x29, 0x89, 0xEA, 0x34, 0xA0, 
    0x49, 0x84, 0x00, 0xB0, 0x35, 0x84, 0x4C, 0x0C, 0xC1, 0x22, 
    0x58, 0xBB, 0x16, 0x92, 0x2A, 0x9C, 0x0A, 0xC4, 0x1E, 0x9C, 
    0x0F, 0x53, 0xF1, 0x0A, 0x5C, 0x36, 0xA4, 0x6A, 0x30, 0x8C, 
    0x5F, 0x0B, 0x42, 0x8D, 0xC4, 0x48, 0xF6, 0x2C, 0x8C, 0x5D, 
    0x18, 0x72, 0xB3, 0x5B, 0xC1, 0xDF, 0x65, 0x3D, 0xBE, 0x4A, 0xCB, 

    0x95, 0x04, 0xCD, 0x20, 0xFD, 0x2A, 0xD2, 0x12, 0x96, 0x34,         // 54
    0x89, 0xE4, 0xBB, 0x0A, 0x90, 0xF0, 0x1E, 0x46, 0x8B, 0x3B, 
    0xBA, 0xA3, 0x37, 0xC5, 0x4B, 0x87, 0x5D, 0xFC, 0x11, 0x3D, 
    0x77, 0x30, 0xF7, 0x16, 0x66, 0xF2, 0x07, 0x57, 0x7D, 0xDB, 
    0x13, 0xE9, 0xC5, 0x4E, 0xE0, 0x16, 0xCA, 0x8C, 0x3E, 0x9D, 
    0xCF, 0x39, 0xFC, 0x68, 0xC8, 0xEF, 0x62, 0x89, 0xFA, 0x74, 
    0xCB, 0x83, 0x2C, 0x9D, 0xBF, 0xF8, 0x8B, 0x15, 0xB7, 0xEF, 
    0x24, 0xAE, 0xFE, 0x29, 0xDA, 0x1D, 0x71, 0xD2, 0x00, 0xF0, 
    0xC7, 0x2C, 0xEA, 0x07, 0x7C, 0x24, 0x9B, 0xE8, 0x8A, 0x1D, 0xF9, 

    0x67, 0xB7, 0x39, 0x79, 0xA0, 0x69, 0x3F, 0xEC, 0x51, 0xD5,         // 55
    0xA8, 0x1F, 0x66, 0xD0, 0x4F, 0x7B, 0xD9, 0xB3, 0x28, 0xE1, 
    0x01, 0x55, 0x8B, 0x0E, 0x9E, 0xEA, 0x33, 0xA7, 0x68, 0xDF, 
    0x90, 0xA7, 0x5A, 0x7F, 0x40, 0x92, 0xA4, 0xCB, 0x21, 0xB8, 
    0x6B, 0xA4, 0x60, 0x1F, 0xA2, 0x6B, 0xEE, 0xB3, 0x74, 0xF4, 
    0x11, 0x78, 0xA2, 0x02, 0x85, 0x22, 0xB3, 0x43, 0x27, 0x59, 
    0x37, 0xA6, 0xDA, 0x49, 0x19, 0x72, 0x43, 0xE1, 0x51, 0x73, 
    0xD3, 0x84, 0x6A, 0x57, 0x9F, 0x86, 0xBA, 0x4C, 0xA5, 0x68, 
    0xB0, 0x8A, 0x49, 0xA2, 0xF7, 0x50, 0xA9, 0x01, 0x6D, 0xB3, 0x2A, 

    0x3F, 0xEC, 0x8B, 0x51, 0xD5, 0x08, 0x86, 0xB1, 0x72, 0x01,         // 56
    0x83, 0x40, 0xFC, 0x27, 0xA3, 0x37, 0x09, 0x6C, 0x9B, 0xC3, 
    0x6F, 0xFB, 0xCF, 0x65, 0xD8, 0x77, 0x04, 0x93, 0x4E, 0xCC, 
    0x19, 0x49, 0xE2, 0xAD, 0xC6, 0x1C, 0x70, 0x38, 0xFD, 0x8A, 
    0x44, 0x2F, 0x8D, 0xF9, 0x81, 0x29, 0x50, 0x03, 0x5C, 0x27, 
    0x8B, 0x4A, 0xD5, 0x59, 0xBF, 0x3D, 0xE0, 0x99, 0xD1, 0xB2, 
    0xE7, 0x03, 0x6F, 0x93, 0xD1, 0xAE, 0x07, 0xCC, 0x97, 0x0E, 
    0x45, 0xB8, 0x16, 0xE4, 0x41, 0x11, 0xE8, 0x25, 0x80, 0x31, 
    0x51, 0xDF, 0x1A, 0x68, 0x33, 0x8D, 0xD3, 0x31, 0xF0, 0x56, 0xD5, 

    0x9F, 0x11, 0xC9, 0x1C, 0xAF, 0xE3, 0x4D, 0xC3, 0x37, 0xF0,         // 57
    0x61, 0xBF, 0x94, 0x76, 0xE2, 0xC4, 0x8F, 0xF8, 0x52, 0x15, 
    0x86, 0x3F, 0x25, 0xB7, 0x1B, 0x45, 0xCA, 0xE6, 0x22, 0xAE, 
    0x6D, 0xC0, 0x36, 0x01, 0xD9, 0x56, 0xE3, 0xAA, 0x5B, 0x06, 
    0xEB, 0xC1, 0x10, 0xB7, 0x39, 0xD0, 0x94, 0xBF, 0xE8, 0xAB, 
    0xDC, 0xB7, 0x33, 0xE9, 0x1A, 0x78, 0x5C, 0x08, 0x7E, 0x1A, 
    0x8E, 0x5C, 0xFC, 0x2E, 0x52, 0xED, 0x60, 0x7E, 0x29, 0xA8, 
    0xEB, 0x2F, 0xCC, 0xAB, 0x76, 0xC9, 0x5C, 0xA0, 0xF4, 0xCE, 
    0x0D, 0x73, 0xC8, 0xB2, 0xD8, 0x16, 0x60, 0x7D, 0x97, 0x0D, 0x82, 

    0xC2, 0x72, 0x36, 0xF3, 0x66, 0x29, 0x97, 0x1C, 0xD0, 0xA1,         // 58
    0x2C, 0xDA, 0x0C, 0x57, 0x20, 0x3F, 0x61, 0x1E, 0xD2, 0x36, 
    0xEB, 0xA7, 0x95, 0x53, 0xF4, 0xB2, 0x5C, 0x7A, 0x36, 0xEE, 
    0x0C, 0x84, 0xFB, 0x64, 0x95, 0x2A, 0xBB, 0x15, 0x7C, 0xD0, 
    0xAA, 0x4C, 0xDA, 0x6F, 0x57, 0xE5, 0x17, 0x83, 0x2D, 0x40, 
    0x64, 0x09, 0x7D, 0x98, 0xAF, 0xF7, 0xC5, 0x47, 0xF2, 0x67, 
    0xD6, 0x3F, 0xB8, 0x80, 0x1D, 0x99, 0x37, 0xB7, 0xF9, 0x5A, 
    0x87, 0x6E, 0x50, 0x0D, 0xF9, 0x2D, 0x91, 0x07, 0x4A, 0xB5, 
    0x92, 0xFC, 0x2A, 0x83, 0x49, 0xF2, 0xBC, 0x40, 0xB4, 0xE0, 0x47, 

    0xEE, 0x55, 0x90, 0xA3, 0x43, 0x7D, 0xFA, 0x6D, 0x55, 0x12,         // 59
    0x91, 0x48, 0xAB, 0xEF, 0x87, 0xB1, 0xE8, 0xA0, 0x79, 0xBA, 
    0x5D, 0x08, 0xE5, 0x7E, 0x34, 0x87, 0x11, 0xC3, 0x99, 0x5E, 
    0xD2, 0x9F, 0x21, 0xA9, 0x3D, 0x80, 0xF5, 0x45, 0xB5, 0x23, 
    0x64, 0x85, 0x2C, 0x98, 0x06, 0xA4, 0x47, 0xC8, 0x74, 0x9B, 
    0xCD, 0xF4, 0x25, 0x4F, 0x69, 0x0F, 0x8A, 0xA2, 0x2C, 0xB7, 
    0x22, 0x9E, 0x0E, 0xCE, 0xE7, 0x69, 0xC6, 0x1B, 0x46, 0x9B, 
    0x06, 0xDC, 0x9F, 0x8B, 0x3E, 0xB9, 0x6B, 0xE2, 0x79, 0x1E, 
    0x5A, 0x3C, 0x9C, 0x04, 0x6C, 0x99, 0x10, 0xD1, 0x29, 0x66, 0x1C, 

    0xB6, 0x08, 0xDE, 0x16, 0xBC, 0xD6, 0x04, 0xB5, 0xD9, 0x7C,         // 60
    0xF6, 0x6E, 0xBC, 0x19, 0x66, 0xD0, 0x02, 0x4F, 0x29, 0x93, 
    0xD7, 0x46, 0x6B, 0x16, 0xD1, 0x9C, 0x2C, 0xF9, 0x43, 0x7D, 
    0x2D, 0x4F, 0x70, 0xDF, 0xC7, 0x13, 0x69, 0x90, 0xEA, 0x37, 
    0xDF, 0x14, 0xF5, 0xCA, 0x78, 0xF1, 0x67, 0x21, 0xEC, 0x10, 
    0x59, 0x86, 0xB3, 0xE6, 0x2C, 0xD9, 0x3B, 0x63, 0xE6, 0x7B, 
    0x50, 0xE9, 0x72, 0x47, 0xA8, 0x00, 0x8A, 0xD4, 0x79, 0xE4, 
    0x34, 0xC5, 0x24, 0xEC, 0x62, 0xD6, 0x20, 0xB2, 0x33, 0xDB, 
    0xC4, 0x70, 0xB4, 0xE7, 0xCA, 0x39, 0x79, 0x58, 0xFD, 0xA3, 0x89, 

    0x41, 0xCA, 0x62, 0x87, 0x31, 0x51, 0x9C, 0x44, 0x23, 0xAD,         // 61
    0x35, 0x05, 0xD7, 0x39, 0x9D, 0x47, 0x83, 0xBF, 0xF6, 0x71, 
    0x1B, 0x9F, 0xC8, 0xAF, 0x43, 0xEA, 0x65, 0xAD, 0x05, 0xE1, 
    0xB2, 0xF1, 0x08, 0x87, 0x54, 0xA1, 0xD7, 0x03, 0x51, 0x76, 
    0x97, 0xBA, 0x69, 0x3B, 0xB6, 0x2E, 0x8F, 0xD6, 0xB1, 0x37, 
    0xC1, 0x1D, 0x3E, 0xCA, 0x92, 0x79, 0xB9, 0x17, 0xCD, 0x04, 
    0x8C, 0xBE, 0x2B, 0x93, 0x5D, 0x34, 0xF4, 0x58, 0x11, 0xB9, 
    0x61, 0xAE, 0x45, 0x82, 0x01, 0xA1, 0x52, 0xEA, 0x98, 0x82, 
    0x09, 0xEE, 0x2D, 0x4F, 0x18, 0xAB, 0xE2, 0x93, 0x05, 0x70, 0x2D, 

    0xF1, 0x75, 0x25, 0xF8, 0xC3, 0x6C, 0xDF, 0x82, 0xEB, 0x65,         // 62
    0xCD, 0x8D, 0x53, 0x7B, 0xF9, 0x2F, 0xDD, 0x5E, 0x0D, 0x42, 
    0xE8, 0x81, 0x30, 0xE1, 0x58, 0x0F, 0x7E, 0xC9, 0x53, 0x89, 
    0x25, 0xC2, 0x9A, 0x37, 0xE9, 0x26, 0x43, 0xC0, 0xAB, 0xCA, 
    0x0B, 0x44, 0x8C, 0x1B, 0x56, 0xCE, 0x0C, 0x49, 0x63, 0x89, 
    0xFA, 0x73, 0x9F, 0x60, 0x00, 0x46, 0xFE, 0x97, 0x58, 0xA8, 
    0x38, 0xF5, 0x12, 0xCB, 0xDF, 0x7B, 0xAC, 0x2B, 0x9F, 0x3F, 
    0xFB, 0x15, 0x74, 0xE1, 0xCB, 0x3A, 0x7B, 0x15, 0x5C, 0x43, 
    0xA5, 0x60, 0x8A, 0xD0, 0x64, 0xC0, 0x22, 0x50, 0xBD, 0xDB, 0xAF, 

    0x4E, 0x98, 0xA8, 0x58, 0x0C, 0x8F, 0x19, 0x3A, 0xBD, 0x13,         // 63
    0x43, 0xA5, 0xE0, 0x27, 0xC4, 0xAD, 0x1D, 0x90, 0xA3, 0xCF, 
    0xB7, 0x51, 0x00, 0x72, 0x8F, 0xA4, 0x35, 0xDE, 0x19, 0xA0, 
    0x44, 0x66, 0x1D, 0xCF, 0x6C, 0x82, 0xFC, 0x62, 0x1B, 0xF2, 
    0x58, 0xD1, 0xE6, 0xA5, 0xFE, 0x6F, 0xA8, 0xEE, 0x9E, 0x05, 
    0x44, 0xD1, 0x13, 0xF1, 0xA6, 0xD2, 0x22, 0x6F, 0x30, 0xD6, 
    0x75, 0x52, 0x9D, 0x68, 0x3F, 0x15, 0xC2, 0xE8, 0x6C, 0x84, 
    0xCA, 0x94, 0x4C, 0xAA, 0x19, 0x92, 0xFD, 0xAF, 0xC5, 0xF3, 
    0x20, 0xD8, 0x14, 0xA2, 0xFA, 0x36, 0x86, 0xEC, 0x3C, 0x60, 0x15, 

    0x8A, 0x00, 0xE8, 0x36, 0xD6, 0xA7, 0xF5, 0x62, 0x9A, 0x79,         // 64
    0xFD, 0x1C, 0x70, 0x98, 0x10, 0x63, 0x79, 0xEB, 0x38, 0x6B, 
    0x24, 0x9B, 0xF1, 0xC6, 0x23, 0xFB, 0xBD, 0x5B, 0x71, 0xEF, 
    0xD3, 0x83, 0xF5, 0x4E, 0xAC, 0x09, 0x92, 0xA8, 0x31, 0x73, 
    0xA1, 0x25, 0x64, 0x03, 0x84, 0x3F, 0x17, 0x7C, 0x32, 0xE4, 
    0xBB, 0x57, 0x8C, 0x2A, 0x78, 0x51, 0x8A, 0xBF, 0xED, 0x0D, 
    0x94, 0xE1, 0x31, 0xA9, 0xFD, 0x97, 0x4C, 0x0C, 0xBB, 0x37, 
    0x04, 0x64, 0xEF, 0x33, 0xC2, 0x6F, 0x4C, 0x09, 0x86, 0x37, 
    0x74, 0xBC, 0x48, 0x82, 0x02, 0x98, 0x6B, 0x0D, 0x9E, 0x80, 0xD1, 

    0xB7, 0x46, 0xC3, 0x6F, 0x86, 0x49, 0x2D, 0xC9, 0x0D, 0xD7,         // 65
    0x4B, 0xBF, 0x5A, 0xED, 0x48, 0xD9, 0xC1, 0x50, 0x18, 0xFE, 
    0x8C, 0x5C, 0x3B, 0xAD, 0x62, 0x41, 0x0B, 0x9C, 0x2F, 0xAF, 
    0x01, 0x3B, 0xB5, 0x13, 0xC6, 0x3B, 0xD4, 0x4E, 0x88, 0xDC, 
    0x41, 0x7F, 0xC0, 0x33, 0x99, 0xD7, 0xB7, 0x51, 0xD4, 0x6A, 
    0x16, 0xA3, 0xEA, 0x43, 0xB6, 0xE4, 0x13, 0x44, 0xA3, 0x61, 
    0x3C, 0xB7, 0x06, 0x86, 0x22, 0x6E, 0xDC, 0x88, 0x5E, 0xF1, 
    0xD5, 0xA1, 0x23, 0xB1, 0x58, 0xE3, 0x30, 0xD7, 0x62, 0xE1, 
    0x94, 0x2D, 0xE7, 0x5D, 0x42, 0xB8, 0xE1, 0xC7, 0x31, 0xF8, 0x21, 

    0xDE, 0x68, 0x27, 0xA0, 0x1A, 0xE3, 0x75, 0x91, 0x57, 0xAF,         // 66
    0x2C, 0x80, 0x08, 0xB4, 0x8B, 0x32, 0x04, 0xA7, 0x82, 0xC9, 
    0x0A, 0xC0, 0xDB, 0x13, 0x8B, 0xD2, 0x78, 0xEA, 0x84, 0x53, 
    0xC3, 0x72, 0x92, 0x5F, 0xE8, 0x7E, 0x20, 0xEE, 0x0B, 0xC2, 
    0x15, 0xF8, 0xAB, 0xE5, 0x5B, 0x21, 0xF2, 0x92, 0x27, 0xB3, 
    0x89, 0x2D, 0x71, 0xD3, 0x0A, 0x65, 0x9A, 0xD0, 0x19, 0x87, 
    0xF8, 0x6E, 0xD9, 0x5C, 0xB4, 0x3E, 0xC5, 0x2D, 0xA5, 0x1C, 
    0x74, 0x4A, 0x87, 0xD2, 0x06, 0x83, 0x9F, 0xBD, 0x22, 0xB3, 
    0x0B, 0x66, 0xAA, 0xC2, 0xF2, 0x23, 0x63, 0x4B, 0xAE, 0x74, 0x52, 

    0x0D, 0x83, 0xFD, 0xCF, 0x60, 0xB4, 0x04, 0xDC, 0x25, 0xEE,         // 67
    0x90, 0xC7, 0xDD, 0x3A, 0x6E, 0xF8, 0x96, 0x65, 0xE0, 0x40, 
    0x76, 0xA2, 0x2A, 0x6E, 0xED, 0x4A, 0xB6, 0x19, 0xD0, 0x25, 
    0xFE, 0x1D, 0xE2, 0x2F, 0x9D, 0x54, 0xB9, 0x69, 0xA5, 0x59, 
    0x93, 0x61, 0x1D, 0x43, 0xC7, 0x6C, 0x82, 0x10, 0xC6, 0x40, 
    0xFC, 0x4D, 0xBE, 0x24, 0x85, 0xF9, 0x4B, 0x74, 0xE0, 0x31, 
    0xC7, 0x1C, 0x46, 0xC4, 0xEF, 0x09, 0x79, 0xEB, 0x52, 0x90, 
    0xC1, 0x10, 0xE8, 0x43, 0x6D, 0xF7, 0x13, 0x42, 0x79, 0x50, 
    0xF9, 0xCF, 0x13, 0x70, 0x39, 0xA3, 0x81, 0x19, 0xDB, 0x28, 0x98, 

    0xCC, 0x35, 0x9A, 0x13, 0x41, 0xEE, 0x52, 0xAB, 0x7A, 0x3C,         // 68
    0x61, 0x1A, 0x54, 0x9C, 0x21, 0xCE, 0x4D, 0x2C, 0xBA, 0x1C, 
    0x56, 0xEF, 0x48, 0x95, 0xBC, 0x03, 0x6B, 0x40, 0x93, 0x64, 
    0xA4, 0x50, 0xBD, 0x78, 0x15, 0xF9, 0x3E, 0x91, 0x2B, 0xEB, 
    0x39, 0xD2, 0x79, 0x98, 0x08, 0xB0, 0x34, 0xD7, 0x5C, 0x7A, 
    0x02, 0xDA, 0x92, 0x56, 0xA3, 0x37, 0xBC, 0x29, 0xB0, 0x51, 
    0xAA, 0x7B, 0x95, 0x2F, 0xA0, 0x59, 0xB1, 0x17, 0xCE, 0x29, 
    0xFB, 0x5F, 0xAD, 0x1B, 0xBA, 0x91, 0x5E, 0xC6, 0xEA, 0x9E, 
    0x33, 0x85, 0x4D, 0x99, 0xD5, 0x0D, 0xEB, 0x8F, 0xBE, 0x5F, 0xED, 

    0xAD, 0x55, 0x73, 0xBE, 0x7F, 0x97, 0x32, 0xC2, 0x18, 0xD1,         // 69
    0xA3, 0xF6, 0x7F, 0xE5, 0xBD, 0x0B, 0xAD, 0x7D, 0xF4, 0x93, 
    0xD3, 0x84, 0x0F, 0xE0, 0x2F, 0x86, 0xF7, 0xB0, 0xE6, 0x38, 
    0x83, 0x08, 0xD8, 0x49, 0xA7, 0xCC, 0x08, 0xE0, 0x77, 0xC8, 
    0x00, 0xB3, 0xEF, 0x54, 0xCE, 0xF7, 0x4C, 0x9A, 0xE8, 0xA9, 
    0x9D, 0x68, 0x14, 0xEF, 0xC4, 0x04, 0x81, 0xEC, 0x0E, 0x67, 
    0xF3, 0x01, 0xE1, 0x6A, 0x1B, 0x8E, 0xD6, 0x43, 0x87, 0x66, 
    0x9A, 0x3B, 0x7C, 0xC8, 0x55, 0x2E, 0xDB, 0x1E, 0x87, 0x00, 
    0x64, 0xBF, 0xE7, 0x24, 0x7B, 0x56, 0xC9, 0x3E, 0x05, 0x7D, 0x41, 

    0xC5, 0x07, 0xF3, 0x2C, 0xD4, 0x10, 0x6A, 0xFB, 0x88, 0x47,         // 70
    0x6A, 0x00, 0x2B, 0x4B, 0x86, 0x64, 0xE9, 0x25, 0x5D, 0x02, 
    0x38, 0xB1, 0x62, 0xCB, 0x58, 0xA3, 0x1E, 0x5B, 0x0C, 0xBE, 
    0xDE, 0x67, 0xB1, 0x2C, 0x85, 0x58, 0x6E, 0xBE, 0x1F, 0x55, 
    0x8E, 0x69, 0x1A, 0x3A, 0x89, 0x27, 0x78, 0x0A, 0x53, 0x23, 
    0x3C, 0xCE, 0x30, 0x7D, 0x44, 0xDB, 0x9D, 0x6E, 0xC6, 0x90, 
    0x3A, 0xBB, 0x4D, 0xCA, 0xF8, 0x3D, 0x71, 0xEE, 0x10, 0xBE, 
    0xDF, 0x03, 0xD7, 0x26, 0xEA, 0xA1, 0x74, 0xB3, 0x4B, 0xD4, 
    0xAC, 0x15, 0x43, 0xAF, 0xFE, 0x30, 0xA8, 0x69, 0xF7, 0xA0, 0x1D, 

    0xE8, 0x90, 0x5F, 0xA4, 0x48, 0xE1, 0xA9, 0x56, 0x0E, 0xE4,         // 71
    0xB2, 0xD6, 0x96, 0xA8, 0x31, 0xD5, 0x3F, 0x98, 0xB5, 0xCC, 
    0x71, 0xFA, 0x1D, 0x97, 0x3E, 0xC2, 0x75, 0xD3, 0x7F, 0x2E, 
    0x8E, 0x20, 0xF4, 0x95, 0x11, 0xED, 0x3A, 0x89, 0xB1, 0xFC, 
    0x41, 0xA3, 0xE5, 0xBC, 0x62, 0xA5, 0xE0, 0xBF, 0x90, 0xF6, 
    0x75, 0xB3, 0xE5, 0x9B, 0x69, 0x27, 0x57, 0x1C, 0x46, 0xDC, 
    0x22, 0x9E, 0x77, 0x2B, 0xAE, 0x07, 0xBB, 0x51, 0xA1, 0x35, 
    0x59, 0x8E, 0xA7, 0x46, 0x88, 0x08, 0x41, 0xF6, 0x6C, 0x30, 
    0xEE, 0x7C, 0xD7, 0x67, 0x04, 0x96, 0x82, 0x26, 0xCB, 0x4E, 0x85, 

    0x23, 0x39, 0xCF, 0x16, 0x6D, 0x8C, 0x28, 0x9D, 0xC7, 0x2D,         // 72
    0x78, 0x3C, 0x5C, 0xF0, 0x13, 0xBA, 0x72, 0x18, 0xE2, 0x45, 
    0x9B, 0x2A, 0x7C, 0xE3, 0x07, 0xF1, 0x29, 0x4A, 0xAF, 0xF9, 
    0x52, 0xC9, 0x42, 0x64, 0xC3, 0xAC, 0xD5, 0x2C, 0x5F, 0x14, 
    0xD4, 0x28, 0x7C, 0x0A, 0xD1, 0x1F, 0x41, 0x6B, 0x15, 0xC6, 
    0x47, 0x09, 0x58, 0x18, 0xF3, 0xB2, 0xCE, 0xFD, 0xAD, 0x85, 
    0x65, 0xF0, 0x0F, 0x87, 0x56, 0xDE, 0x84, 0x1F, 0xCD, 0x75, 
    0xF0, 0x22, 0x70, 0xF7, 0x62, 0xD2, 0xB9, 0x19, 0xAA, 0x8D, 
    0x1D, 0x51, 0x9B, 0x3C, 0xB8, 0xDD, 0x46, 0xE6, 0x10, 0xB1, 0x64, 

    0xB9, 0x77, 0x9C, 0xEC, 0xC2, 0x03, 0xF2, 0x3A, 0x60, 0x8D,         // 73
    0xF8, 0x15, 0xC5, 0x7F, 0x53, 0x8F, 0xFC, 0x56, 0x84, 0x0E, 
    0x60, 0xD5, 0xB9, 0x4C, 0x6A, 0xA1, 0x8C, 0xE0, 0x0F, 0x6A, 
    0xA8, 0x01, 0x7A, 0xDB, 0x31, 0x52, 0x05, 0xA0, 0xE3, 0x76, 
    0xB7, 0x50, 0x96, 0x5A, 0xFA, 0x7F, 0x9F, 0xED, 0x36, 0x82, 
    0xAD, 0xD6, 0x88, 0xBF, 0x42, 0x8B, 0x0C, 0x7A, 0x32, 0x12, 
    0xCC, 0x43, 0xBD, 0xE5, 0x9C, 0x32, 0x65, 0xFE, 0x91, 0x0A, 
    0xB5, 0x41, 0xC1, 0x10, 0x99, 0x28, 0x80, 0x55, 0xDD, 0x3D, 
    0xB8, 0xCD, 0x10, 0xF0, 0x73, 0x1D, 0x5D, 0xBC, 0x7A, 0x3C, 0xD7, 

    0xFC, 0x44, 0x1D, 0x56, 0x82, 0x4D, 0xD0, 0x76, 0xDD, 0x08,         // 74
    0xA0, 0x66, 0xAF, 0x27, 0xDF, 0x06, 0xA5, 0x2E, 0xC1, 0xF3, 
    0xB0, 0x37, 0x11, 0x90, 0xD0, 0x1A, 0x59, 0x33, 0xC0, 0x94, 
    0x37, 0xE3, 0x9C, 0x19, 0xA8, 0x7E, 0xEF, 0x6D, 0x42, 0x98, 
    0x07, 0xF2, 0xC2, 0x32, 0xB2, 0x48, 0x06, 0xCB, 0x5A, 0xDC, 
    0x1E, 0x64, 0x31, 0xDE, 0x71, 0x2D, 0xA3, 0x52, 0xBF, 0xEB, 
    0x5D, 0xAA, 0x2E, 0x6C, 0x17, 0xD6, 0xAD, 0x46, 0x2D, 0xDA, 
    0x50, 0x9B, 0xD7, 0x35, 0xE0, 0x4D, 0xF2, 0xC0, 0x04, 0x61, 
    0xF9, 0x69, 0x89, 0x2D, 0xC4, 0x8D, 0xA2, 0x2F, 0xF2, 0x92, 0x01, 

    0x5D, 0x8E, 0xDF, 0xB2, 0x2F, 0x98, 0xB0, 0x20, 0xB7, 0x53,         // 75
    0xD6, 0x20, 0xED, 0x3E, 0xC8, 0x6E, 0x3C, 0xDB, 0x69, 0x26, 
    0x88, 0xDD, 0x71, 0xEE, 0x3C, 0xB8, 0xF6, 0x72, 0xD9, 0x1F, 
    0x5D, 0x84, 0x49, 0xFC, 0x5B, 0x95, 0x29, 0xCC, 0x1B, 0xC5, 
    0x85, 0x3C, 0x70, 0x17, 0xDF, 0x63, 0x8B, 0xA8, 0x26, 0x99, 
    0x76, 0xFC, 0xA3, 0x01, 0xB7, 0xEA, 0x69, 0xDC, 0x3D, 0x91, 
    0x7D, 0x04, 0xFA, 0x95, 0x4E, 0xC3, 0x02, 0x7A, 0xC1, 0x67, 
    0x87, 0x1C, 0x5E, 0x84, 0xA7, 0x71, 0x14, 0x9A, 0x7A, 0xB2, 
    0x22, 0xA7, 0x54, 0xDD, 0x4A, 0x0D, 0xCB, 0x6B, 0x15, 0x51, 0xAC, 

    0x26, 0xD0, 0x0A, 0x78, 0xF9, 0x12, 0x68, 0x40, 0xEF, 0x7D,         // 76
    0x45, 0x91, 0x73, 0xA1, 0x50, 0x87, 0xBB, 0x93, 0x0B, 0xA7, 
    0x43, 0x58, 0xA0, 0x1D, 0x61, 0xAA, 0x03, 0x8A, 0x42, 0xAB, 
    0xF2, 0xBE, 0x0D, 0xCD, 0x21, 0xBF, 0x45, 0xAF, 0xF9, 0x54, 
    0x25, 0xE6, 0xA1, 0xCF, 0x98, 0x24, 0xF4, 0x6E, 0x45, 0xE7, 
    0x0D, 0x3A, 0x56, 0x8E, 0x48, 0x23, 0xC9, 0x08, 0x9E, 0x23, 
    0x4F, 0xB6, 0xCF, 0x3D, 0x7F, 0xEC, 0x56, 0x98, 0xF3, 0x0F, 
    0xE1, 0xBA, 0xFA, 0x01, 0x41, 0xCD, 0x37, 0xD9, 0x30, 0xE8, 
    0x45, 0x95, 0x06, 0xB6, 0x6D, 0xFB, 0x38, 0xE2, 0xB5, 0xD3, 0x71, 

    0xBB, 0x3C, 0x66, 0xC8, 0x45, 0xBE, 0xDE, 0x93, 0x0C, 0xA6,         // 77
    0x2E, 0xCC, 0x02, 0xDA, 0x23, 0xF7, 0x18, 0x58, 0xE6, 0x77, 
    0xEF, 0x05, 0xCE, 0x81, 0xC5, 0x29, 0xE7, 0x5F, 0xCC, 0x13, 
    0x78, 0x32, 0xAC, 0x6F, 0x8B, 0xEB, 0x67, 0x14, 0x7D, 0x9B, 
    0xD5, 0x69, 0x49, 0x01, 0x7B, 0x3F, 0xBC, 0x11, 0xCF, 0x7E, 
    0xBE, 0xAB, 0xCF, 0x6D, 0xF5, 0x95, 0x59, 0x80, 0xF8, 0xBD, 
    0xE6, 0x28, 0x64, 0x14, 0xB2, 0x2A, 0xA6, 0x20, 0x3B, 0xA9, 
    0x47, 0x27, 0x68, 0x96, 0xE9, 0xB7, 0x62, 0x8F, 0x57, 0x17, 
    0xC5, 0x75, 0xF3, 0x2F, 0x84, 0x9F, 0x58, 0x88, 0x22, 0x41, 0xEB, 

    0x7F, 0x97, 0xED, 0x21, 0xA1, 0x74, 0x2A, 0x51, 0xD0, 0x61,         // 78
    0xFD, 0xB7, 0x5B, 0x37, 0x98, 0x64, 0xD0, 0x3A, 0xC0, 0x31, 
    0x90, 0xB8, 0x2D, 0xF8, 0x47, 0x75, 0x92, 0x33, 0xB5, 0x4C, 
    0xDB, 0x5A, 0xEC, 0x2D, 0x4A, 0x08, 0xD7, 0xA5, 0x5C, 0x33, 
    0x0F, 0xA9, 0x89, 0xFE, 0x59, 0xAA, 0xE1, 0x54, 0x9D, 0x31, 
    0x60, 0xEC, 0x16, 0x34, 0xB9, 0x18, 0xB1, 0x32, 0x65, 0x11, 
    0x78, 0xA5, 0x93, 0xF1, 0xD7, 0x60, 0x88, 0xE4, 0x75, 0x5C, 
    0x97, 0x7B, 0xD1, 0x4C, 0x2F, 0x80, 0x0E, 0xFC, 0xBB, 0x81, 
    0xDE, 0x5C, 0x40, 0xBF, 0x17, 0xD8, 0x05, 0xA9, 0x75, 0x9B, 0x08, 

    0x5F, 0x18, 0xB4, 0x59, 0x8A, 0x02, 0xF4, 0xAF, 0x7F, 0x24,         // 79
    0x8F, 0x17, 0x82, 0xE9, 0xB9, 0x0E, 0x85, 0xA5, 0x70, 0x1B, 
    0xD7, 0x4E, 0x6C, 0x98, 0x0E, 0xD1, 0xA6, 0x0A, 0xFE, 0x85, 
    0xA2, 0x05, 0x8F, 0xBC, 0xDD, 0x9F, 0x82, 0x3D, 0xBB, 0xCD, 
    0xF0, 0x43, 0x29, 0xC5, 0xB2, 0x2D, 0x16, 0x76, 0xF9, 0x03, 
    0x8E, 0x4D, 0x83, 0xDD, 0x78, 0x45, 0xE6, 0xD2, 0x8D, 0x41, 
    0xCE, 0x51, 0x31, 0x6E, 0x0E, 0x47, 0xCE, 0x09, 0xAF, 0xD5, 
    0x12, 0xEF, 0xAD, 0x0B, 0xCA, 0x9E, 0x26, 0xAC, 0x3F, 0x09, 
    0x9C, 0x20, 0xAD, 0xE5, 0x65, 0x47, 0xC3, 0x2D, 0xF1, 0x4D, 0xCB, 

    0xFA, 0x48, 0xD5, 0x35, 0xE4, 0xC3, 0x66, 0x39, 0xDB, 0x4E,         // 80
    0xA2, 0x67, 0xD1, 0x43, 0x6D, 0xF2, 0x33, 0xDA, 0x46, 0xFB, 
    0x82, 0x15, 0xA7, 0x38, 0xE0, 0x66, 0x4F, 0xD9, 0x6D, 0x1E, 
    0x3B, 0xD2, 0x73, 0x16, 0x56, 0x6E, 0x22, 0xF3, 0x0A, 0x73, 
    0x99, 0x63, 0xE0, 0x14, 0x6E, 0xD7, 0x88, 0xB8, 0x41, 0xAC, 
    0xD2, 0x28, 0xA0, 0x0C, 0xC7, 0x62, 0x04, 0xAA, 0x25, 0xB4, 
    0xE2, 0x06, 0xC6, 0x8A, 0xBD, 0xAB, 0x72, 0x3E, 0xFB, 0x2F, 
    0xC1, 0x42, 0x73, 0x5E, 0xF5, 0x52, 0x78, 0xDC, 0x68, 0xF0, 
    0x4B, 0xD7, 0x7B, 0x37, 0x97, 0xEE, 0x8C, 0x63, 0xD2, 0x1B, 0xAE, 

    0x0C, 0x82, 0x9B, 0x73, 0x1A, 0x4B, 0x92, 0x1E, 0xB9, 0x07,         // 81
    0xEA, 0x31, 0xAF, 0x09, 0x93, 0x1E, 0x56, 0x9A, 0x00, 0xB0, 
    0x5A, 0xC7, 0xEE, 0x7A, 0xB9, 0x1D, 0x8C, 0x3F, 0xAC, 0xC9, 
    0x62, 0xEF, 0x44, 0xA7, 0xFB, 0xBF, 0x4C, 0xD3, 0x87, 0x53, 
    0x1B, 0xA9, 0x7D, 0x94, 0x38, 0x4C, 0xEF, 0x5B, 0x1C, 0xE2, 
    0x64, 0xB8, 0xF8, 0x3F, 0x95, 0xEE, 0x83, 0x52, 0xF6, 0x5B, 
    0x73, 0x9A, 0xFD, 0x3E, 0x26, 0xEF, 0x17, 0x9D, 0x52, 0x7D, 
    0x94, 0x1C, 0xE2, 0x8C, 0x18, 0xBA, 0x3C, 0xC3, 0x28, 0x8F, 
    0x70, 0xBD, 0x00, 0xA7, 0x26, 0x76, 0x10, 0xA5, 0x33, 0x87, 0x6A, 

    0x42, 0xC9, 0x2D, 0xF4, 0xB5, 0xD8, 0xA4, 0x83, 0xF9, 0x74,         // 82
    0xC6, 0x54, 0xE3, 0x78, 0xD4, 0xB2, 0xE2, 0x7E, 0x61, 0xD1, 
    0x24, 0x93, 0x0C, 0x54, 0x30, 0xF5, 0xC2, 0x11, 0xE6, 0x2F, 
    0x8B, 0xB3, 0x1C, 0x7F, 0x35, 0x00, 0x91, 0xA7, 0x26, 0xEC, 
    0xC9, 0x4E, 0x08, 0xF5, 0xC8, 0xA2, 0x06, 0xC3, 0x72, 0x8C, 
    0x33, 0x13, 0x80, 0x59, 0x23, 0xB4, 0x3B, 0xCC, 0x17, 0x89, 
    0x39, 0x1C, 0x57, 0x77, 0xD1, 0x5C, 0x88, 0xDD, 0xC7, 0x04, 
    0xB9, 0x59, 0xCC, 0x30, 0xA0, 0xE6, 0x03, 0x99, 0x56, 0xD0, 
    0x12, 0x44, 0xFE, 0x59, 0xD9, 0xC7, 0x3E, 0xF8, 0x56, 0xE7, 0xBF, 

    0xA2, 0xE2, 0x58, 0x06, 0x67, 0x37, 0x10, 0x5D, 0x42, 0x2B,         // 83
    0x91, 0x12, 0xAA, 0x24, 0x5B, 0x40, 0x28, 0xBB, 0xF4, 0x32, 
    0x76, 0x44, 0xD6, 0xA6, 0x94, 0x6F, 0x57, 0x9E, 0x79, 0x50, 
    0x07, 0xC6, 0x53, 0x95, 0xCF, 0xE5, 0x77, 0x38, 0x66, 0xB0, 
    0x3E, 0xDC, 0xA0, 0x5D, 0x1F, 0x6D, 0x8F, 0x30, 0xEB, 0xA1, 
    0x4D, 0xCE, 0xE6, 0xAD, 0x71, 0xDC, 0x0F, 0x6B, 0xA2, 0xC4, 
    0xEC, 0xB0, 0xD8, 0xA1, 0x02, 0xB9, 0x2A, 0x70, 0x32, 0x66, 
    0xE7, 0x24, 0xAE, 0x6C, 0x45, 0x7F, 0x63, 0xF9, 0x19, 0xA7, 
    0xE2, 0xA0, 0x8B, 0x72, 0x17, 0x4F, 0xB2, 0x7E, 0x03, 0x96, 0x27, 

    0x7C, 0x14, 0x8D, 0xA6, 0x7F, 0xEF, 0xAE, 0xDD, 0xBE, 0xA3,         // 84
    0x64, 0xF5, 0x3D, 0xB6, 0xEF, 0x9E, 0x6D, 0x0D, 0x4D, 0xAB, 
    0xE6, 0xB6, 0x68, 0x21, 0xE4, 0x02, 0xD3, 0x2A, 0xF8, 0xAF, 
    0xDE, 0x6B, 0xF2, 0x27, 0xAE, 0x5C, 0x13, 0xF7, 0xBE, 0x0A, 
    0x88, 0x24, 0x74, 0x33, 0xE3, 0xB7, 0x49, 0xCD, 0x57, 0x0B, 
    0xBE, 0x6D, 0x41, 0x00, 0xC4, 0x55, 0x93, 0xF1, 0x2B, 0x4B, 
    0x0D, 0x7C, 0x2C, 0x44, 0x8D, 0xE9, 0x4E, 0xB3, 0xF3, 0x9B, 
    0x3E, 0x8B, 0xFD, 0x09, 0xDE, 0xA8, 0x24, 0xCC, 0x89, 0x35, 
    0x5D, 0x23, 0x3D, 0xBA, 0xE4, 0x95, 0x23, 0xDE, 0x69, 0xCB, 0x51, 

    0x32, 0xFD, 0xC0, 0x3B, 0xC8, 0x52, 0x2F, 0x75, 0x03, 0xE8,         // 85
    0x22, 0x82, 0xCB, 0x70, 0x04, 0x84, 0xE5, 0xCA, 0x8D, 0x1A, 
    0x7F, 0x06, 0xFD, 0x3E, 0x84, 0xB8, 0x4C, 0x8F, 0x64, 0x15, 
    0x3B, 0xA1, 0x0F, 0x75, 0x40, 0xC5, 0x98, 0x4B, 0xD9, 0x9C, 
    0x5F, 0xFC, 0xAC, 0xD0, 0x84, 0x11, 0xF9, 0x23, 0xA6, 0x7C, 
    0xF6, 0x21, 0x9A, 0x84, 0xFB, 0x1F, 0x42, 0xD1, 0x76, 0x95, 
    0xDF, 0x62, 0xC1, 0xF6, 0x64, 0x21, 0xD3, 0x0A, 0x84, 0x17, 
    0xCA, 0x50, 0x78, 0x36, 0xC4, 0x51, 0x95, 0x40, 0x69, 0xF1, 
    0x7C, 0xC7, 0xEC, 0x08, 0x5D, 0x81, 0xC5, 0x40, 0xAC, 0x1C, 0xD8, 

    0xB6, 0x71, 0x5B, 0x1E, 0xDB, 0x14, 0x92, 0xCD, 0x54, 0x9B,         // 86
    0x44, 0xDA, 0x54, 0x35, 0xC2, 0x25, 0x51, 0x31, 0xB3, 0x5B, 
    0xD8, 0x52, 0x90, 0xC9, 0x62, 0x2E, 0xEA, 0x1C, 0xBF, 0xD6, 
    0x89, 0x4C, 0xCF, 0x8E, 0xDF, 0x19, 0x7D, 0x2B, 0x70, 0x1F, 
    0x44, 0xB7, 0x04, 0x3C, 0x59, 0xA4, 0x66, 0x88, 0xDC, 0x2B, 
    0x60, 0xB4, 0xDB, 0x35, 0x64, 0xA3, 0x7E, 0xB8, 0x05, 0x5D, 
    0xBA, 0x23, 0x97, 0x0E, 0x7E, 0xA9, 0x98, 0x6A, 0x49, 0xE3, 
    0xB5, 0x20, 0xD9, 0xA3, 0x81, 0x16, 0xE9, 0xBD, 0x05, 0xB2, 
    0x14, 0x94, 0x6C, 0xA3, 0x2E, 0xF2, 0x0C, 0x60, 0xF6, 0x85, 0x5D, 

    0x90, 0x00, 0xE5, 0x9B, 0x76, 0xB4, 0x66, 0xFC, 0x1E, 0x80,         // 87
    0xB6, 0x0B, 0x91, 0xAE, 0xFE, 0x94, 0xD0, 0x76, 0xF6, 0x22, 
    0xC0, 0x38, 0xA8, 0x16, 0xE0, 0x9F, 0x7A, 0xAD, 0x46, 0x77, 
    0x21, 0xFA, 0xB9, 0x2A, 0x56, 0xF1, 0xB4, 0xD3, 0xAA, 0xEE, 
    0x81, 0xDF, 0x6F, 0x98, 0xF1, 0x32, 0xC2, 0x02, 0x45, 0xC8, 
    0x91, 0x09, 0x4D, 0xBE, 0x0E, 0xE9, 0x28, 0xE1, 0x36, 0xA6, 
    0xF0, 0x3E, 0xD0, 0x4A, 0xE4, 0x56, 0x2F, 0xFA, 0xAC, 0x32, 
    0x67, 0x94, 0x59, 0x0E, 0xF2, 0x61, 0x2F, 0x76, 0xDE, 0x45, 
    0xD5, 0x54, 0x1E, 0xCF, 0x45, 0xB7, 0x74, 0x99, 0x39, 0x0E, 0xE1, 

    0x28, 0xA8, 0x48, 0x2B, 0xF4, 0x3D, 0x0C, 0xAC, 0x36, 0xCA,         // 88
    0x5F, 0xF1, 0x30, 0x65, 0x16, 0x43, 0x60, 0x08, 0x9C, 0x84, 
    0x67, 0xEA, 0x29, 0x74, 0x4A, 0x0C, 0x5A, 0xF6, 0x06, 0xE3, 
    0x9D, 0x5A, 0x0B, 0x69, 0x9F, 0x36, 0x03, 0x5D, 0x3E, 0x0D, 
    0xC6, 0x26, 0x48, 0xCA, 0x16, 0x7D, 0xE7, 0x9A, 0x5B, 0xEA, 
    0x3D, 0x79, 0xF0, 0x97, 0x72, 0xCA, 0x4A, 0x6D, 0x98, 0x4E, 
    0x15, 0x8E, 0x6C, 0xB1, 0x1A, 0xC6, 0x8C, 0x0E, 0xCD, 0x7E, 
    0x00, 0xF6, 0xBF, 0x41, 0x91, 0xCB, 0xAE, 0x53, 0x9F, 0x8A, 
    0x2A, 0xB0, 0xF9, 0x86, 0x64, 0xD8, 0x17, 0xE5, 0xAF, 0xC7, 0x4C, 

    0xF7, 0x77, 0xC7, 0x89, 0x60, 0xC3, 0xDE, 0x8A, 0x58, 0xEA,         // 89
    0x29, 0x75, 0xBE, 0xD4, 0x7E, 0xDC, 0xB9, 0xE9, 0x3B, 0xD5, 
    0x0C, 0xA0, 0x88, 0xF7, 0xAD, 0xD8, 0x8F, 0x33, 0xC8, 0x69, 
    0x2B, 0xB3, 0x84, 0xD7, 0xC1, 0x72, 0x97, 0xE0, 0xB8, 0x6A, 
    0x96, 0x5C, 0xA9, 0x89, 0xDB, 0x4E, 0x21, 0x71, 0xBA, 0x13, 
    0xAD, 0xC5, 0x26, 0x59, 0x1E, 0x85, 0xB2, 0x10, 0xFE, 0xC2, 
    0x7C, 0xDA, 0x02, 0xF7, 0x80, 0x46, 0xE1, 0x70, 0x4B, 0xBB, 
    0x9F, 0x3B, 0x77, 0xDA, 0x22, 0x7A, 0x0B, 0xFC, 0x1D, 0x68, 
    0xE2, 0x7B, 0x37, 0x01, 0x9A, 0x31, 0x89, 0x48, 0x20, 0x6A, 0x98, 

    0x58, 0x1F, 0xD9, 0x0A, 0x9F, 0x27, 0x48, 0x74, 0xB8, 0x13,         // 90
    0x8F, 0xA6, 0x4A, 0x04, 0x97, 0x26, 0xA2, 0x1B, 0x73, 0x4C, 
    0xB4, 0x5D, 0x42, 0x13, 0xC8, 0x2A, 0x73, 0xB9, 0x4E, 0x87, 
    0xCD, 0x46, 0xEA, 0x39, 0x13, 0xFE, 0x44, 0x81, 0x2B, 0xF6, 
    0x15, 0xE5, 0x37, 0x07, 0x61, 0xB6, 0xD1, 0x3D, 0xFD, 0x82, 
    0x2D, 0x65, 0xDF, 0xAA, 0xF7, 0x3A, 0xD9, 0x8D, 0x26, 0x63, 
    0x35, 0xB6, 0x5A, 0x38, 0x9A, 0x27, 0xB5, 0x17, 0xEC, 0x2C, 
    0xD7, 0x63, 0x12, 0xAD, 0x5A, 0xEB, 0x4C, 0xB5, 0x39, 0xC9, 
    0x12, 0x4F, 0xC2, 0xE9, 0xB2, 0x59, 0xF5, 0xB6, 0x7F, 0xD3, 0x32, 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\httables.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   HtTables.hpp
*
* Abstract:
*
*   Tables for doing halftoning, using Daniel Chou's supercell technique
*
* Created:
*
*   10/29/1999 DCurtis
*
\**************************************************************************/

#ifndef _HTTABLES_HPP
#define _HTTABLES_HPP

typedef struct {
    WORD            palVersion;
    WORD            palNumEntries;
    PALETTEENTRY    palPalEntry[256];
} GDIP_LOGPALETTE256;

extern GDIP_LOGPALETTE256 HTColorPalette;
extern GDIP_LOGPALETTE256 Win9xHalftonePalette;
extern const BYTE GammaTable216[];
extern const BYTE InverseGammaTable216[];
extern const BYTE GammaTable16[];
extern const BYTE InverseGammaTable16[];
extern const BYTE HT_216_8x8[];
extern const BYTE HT_SuperCell_Red216[];
extern const BYTE HT_SuperCell_Green216[];
extern const BYTE HT_SuperCell_Blue216[];
extern const BYTE HT_SuperCell_RedMono[];
extern const BYTE HT_SuperCell_GreenMono[];
extern const BYTE HT_SuperCell_BlueMono[];

#endif // _HTTABLES_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\formatconverter.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Format Converter
*
* Abstract:
*
*   A class which converts scanlines from one pixel format to another.
*   
* Created:
*
*   12/10/1999 agodfrey
*       Created it (using source in Imaging\Api\ConvertFmt.cpp)
*
\**************************************************************************/

#ifndef _FORMATCONVERTER_HPP
#define _FORMATCONVERTER_HPP

#include "ScanOperation.hpp"

/**************************************************************************\
*
* Description:
*
*   Class for handling the pixel format conversion for a scanline
*
\**************************************************************************/

class EpFormatConverter
{
public:
    EpFormatConverter()
    {
        TempBuf[0] = NULL;
        TempBuf[1] = NULL;
        ClonedSourcePalette = NULL;
    }
    
    ~EpFormatConverter()
    {
        FreeBuffers();
    }

    HRESULT
    Initialize(
        const BitmapData *dstbmp,
        const ColorPalette *dstpal,
        const BitmapData *srcbmp,
        const ColorPalette *srcpal
        );

    BOOL
    CanDoConvert(
        const PixelFormatID srcFmt,
        const PixelFormatID dstFmt
        );

    VOID Convert(VOID *dst, const VOID *src)
    {
        PipelineItem *pipelinePtr = &Pipeline[0];
        const VOID *currentSrc = src;
        VOID *currentDst = pipelinePtr->Dst;
        
        // Do the intermediate operations, if any
        
        while (currentDst)
        {
            pipelinePtr->Op(currentDst, currentSrc, Width, &OperationParameters);
            pipelinePtr++;
            currentSrc = currentDst;
            currentDst = pipelinePtr->Dst;
        }
        
        // Do the last operation, to the final destination
        
        pipelinePtr->Op(dst, currentSrc, Width, &OperationParameters);
    }

private:
    // We represent the pipeline with an array of PipelineItem structures.
    // PixelFormat is the destination pixel format.
    // Dst is the destination temporary buffer, or NULL for the last
    //   item in the pipeline (in which case we output to the final 
    //   destination.)
        
    struct PipelineItem
    {
        ScanOperation::ScanOpFunc Op;
        PixelFormatID PixelFormat;
        VOID *Dst;
    };

    HRESULT AddOperation(
        PipelineItem **pipelinePtr,
        const ScanOperation::ScanOpFunc newOperation,
        PixelFormatID pixelFormat
        );
        
    VOID FreeBuffers()
    {
        if (TempBuf[0])
        {   
            GpFree(TempBuf[0]); 
            TempBuf[0] = NULL;
        }
        if (TempBuf[1])
        {    
            GpFree(TempBuf[1]); 
            TempBuf[1] = NULL;
        }
        if (ClonedSourcePalette)
        {
            GpFree(ClonedSourcePalette);
            ClonedSourcePalette = NULL;
        }
    }
    
    UINT Width;                 // scanline width

    ColorPalette *ClonedSourcePalette;    
    ScanOperation::OtherParams OperationParameters;
    PipelineItem Pipeline[3];   // the scan operation pipeline
    VOID *TempBuf[2];           // temporary buffers for indirect conversion
};

/**************************************************************************\
*
* Function Description:
*
*   Halftone an image from 32bpp to 8bpp.
*
*   The GIF encoder wants to use our halftone code to convert from 32bpp 
*   to 8bpp. But neither it nor Imaging want to use our full-blown AlphaBlender
*   interface, because that pulls in all of the scan operation code. This
*   function exposes the 8bpp halftone code to the GIF encoder, to address
*   its specific needs.
*
*   !!![agodfrey] This needs to be revisited. The way I see it working
*      eventually: We get rid of this function and EpFormatConverter; all
*      clients use EpAlphaBlender to get what they want. (Imaging format
*      conversion would ask for a 'SrcCopy' operation.) But this would
*      require EpAlphaBlender to be expanded - it would need to support an
*      arbitrary input format, at least for SrcCopy.
*
* Arguments:
*
*   [IN]      src        - pointer to scan0 of source image
*   [IN]      srcStride  - stride of src image (can be negative)
*   [IN]      dst        - pointer to scan0 of destination 8-bpp image
*   [IN]      dstStride  - stride of dst image (can be negative)
*   [IN]      width      - image width
*   [IN]      height     - image height
*   [IN]      orgX       - where the upper-left corner of image starts
*   [IN]      orgY       - for computing the halftone cell origin
*
* Return Value:
*
*   NONE
*
* History:
*
*   10/29/1999 DCurtis
*     Created it.
*   01/20/2000 AGodfrey
*     Moved it from Imaging\Api\Colorpal.cpp/hpp.
*
\**************************************************************************/

VOID
Halftone32bppTo8bpp(
    const BYTE* src,
    INT srcStride,
    BYTE* dst,
    INT dstStride,
    UINT width,
    UINT height,
    INT orgX,
    INT orgY
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\line.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   One-pixel-wide solid aliased lines
*
* Abstract:
*
*   Draws aliased solid-color lines which are one pixel wide.
*   Supports clipping against complex clipping regions. 
*
* History:
*
*   03/31/1999 AMatos
*       Created it.
*   08/17/1999 AGodfrey
*       Separated aliased from antialiased.
*
\**************************************************************************/

#include "precomp.hpp" 

#pragma optimize("a",on)

//------------------------------------------------------------------------
// Global array that stores all the different options of drawing functions. 
// If the order of the functions change, the offset constants must also 
// change.  
//------------------------------------------------------------------------

#define FUNC_X_MAJOR     0
#define FUNC_Y_MAJOR     1
#define FUNC_CLIP_OFFSET 2

typedef VOID (OnePixelLineDDAAliased::*DDAFunc)(DpScanBuffer*);

static DDAFunc gDrawFunctions[] = { 
    OnePixelLineDDAAliased::DrawXMajor, 
    OnePixelLineDDAAliased::DrawYMajor, 
    OnePixelLineDDAAliased::DrawXMajorClip, 
    OnePixelLineDDAAliased::DrawYMajorClip, 
};

//------------------------------------------------------------------------
// Constants used for manipulating fixed point and doing all the bitwise 
// operations on the aliased and antialiased DDA. I know some of these
// are already defined elsewhere, but I do it again here as it might be nice to 
// keep this independent of the rest of gdiplus. 
//------------------------------------------------------------------------

// Fixed point 

#define RealToFix GpRealToFix4 

#define FBITS     4
#define FMASK     0xf
#define FINVMASK  0xfffffff0
#define FSIZE     16
#define FHALF     8
#define FHALFMASK 7

/**************************************************************************\
*
* Function Description:
*
* Does all the DDA setup that is common to aliased and antialiased
* lines. 
*
* Arguments:
*
*   [IN] point1   - end point
*   [IN] point2   - end point
*   [IN] drawLast - FALSE if the line is to be end-exclusive

* Return Value:
*
* Returns TRUE if the drawing should continue, meaning the line
* has non-zero length. 
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/


BOOL
OnePixelLineDDAAliased::SetupCommon( 
    GpPointF *point1, 
    GpPointF *point2, 
    BOOL drawLast,
    INT width
    )
{
    MaximumWidth = width;
    
    // Turn the points into fixed 28.4 

    INT x1 = RealToFix(point1->X); 
    INT x2 = RealToFix(point2->X); 
    
    REAL rDeltaX = point2->X - point1->X; 
    REAL rDeltaY = point2->Y - point1->Y; 

    if( rDeltaX == 0 && rDeltaY == 0 ) 
    {
        return FALSE; 
    }

    INT xDir = 1; 

    if(rDeltaX < 0)
    {
        rDeltaX = -rDeltaX; 
        xDir = -1; 
    }

    INT y1 = RealToFix(point1->Y); 
    INT y2 = RealToFix(point2->Y); 

    INT yDir = 1; 

    if( rDeltaY < 0)
    {
        rDeltaY = -rDeltaY; 
        yDir = -1;
    }

    Flipped = FALSE; 

    if( rDeltaY >= rDeltaX ) 
    {
        // y-major 
                
        // Invert the endpoints if necessary       

        if(yDir == -1)
        {
            INT tmp = y1; 
            y1 = y2; 
            y2 = tmp; 
            tmp = x1;
            x1 = x2; 
            x2 = tmp; 
            xDir = -xDir; 
            Flipped = TRUE; 
        }

        // Determine the Slope 
        
        Slope = xDir*rDeltaX/rDeltaY; 

        // Initialize the Start and End points 

        IsXMajor = FALSE; 
        MajorStart = y1; 
        MajorEnd = y2; 
        MinorStart = x1; 
        MinorEnd = x2; 
        MinorDir = xDir;

        // Mark that we'll use the y-major functions. 

        DrawFuncIndex = FUNC_Y_MAJOR; 
    }
    else
    {
        // x-major        

        // Invert the endpoints if necessary        

        if(xDir == -1)
        {
            INT tmp = x1; 
            x1 = x2; 
            x2 = tmp; 
            tmp = y1;
            y1 = y2; 
            y2 = tmp; 
            yDir = -yDir; 
            Flipped = TRUE; 
        }

        Slope = yDir*rDeltaY/rDeltaX; 

        // Initialize the rest

        IsXMajor = TRUE; 
        MajorStart = x1; 
        MajorEnd = x2; 
        MinorStart = y1; 
        MinorEnd = y2; 
        MinorDir = yDir; 

        // Mark that we'll use the x-major functions. 

        DrawFuncIndex = FUNC_X_MAJOR;
    }

    // Initialize the Deltas. In fixed point. 

    DMajor = MajorEnd - MajorStart; 
    DMinor = (MinorEnd - MinorStart)*MinorDir; 

    // Mark if we're drawing end-exclusive 

    IsEndExclusive = !drawLast; 

    return TRUE; 
}


//------------------------------------------------------------------------
// Functions specific to the aliased lines
//------------------------------------------------------------------------


/**************************************************************************\
*
* Function Description:
*
* Does the part of the DDA setup that is specific for aliased lines. 
*
* Basically it uses the diamond rule to find the integer endpoints 
* based on the fixed point values and substitutes these for the 
* integer results coordinates. Also calculates the error values. 
*
* Arguments:
*
* Return Value:
*
* Returns FALSE if the drawing should not continue, meaning the line
* has a length of less than 1, and should not be drawn by the GIQ rule.
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

BOOL
OnePixelLineDDAAliased::SetupAliased()
{            
    // Do the GIQ rule to determine which pixel to start at.         

    BOOL SlopeIsOne = (DMajor == DMinor); 
    BOOL SlopeIsPosOne =  SlopeIsOne && (1 == MinorDir); 

    // These will store the integer values. 

    INT major, minor;
    INT majorEnd, minorEnd;

    // Find the rounded values in fixed point. The rounding
    // rules when a coordinate is halfway between two 
    // integers is given by the GIQ rule. 

    minor    = (MinorStart + FHALFMASK) & FINVMASK;
    minorEnd = (MinorEnd   + FHALFMASK) & FINVMASK; 

    BOOL isEndIn, isStartIn; 

    if(IsXMajor)
    {   
        if(SlopeIsPosOne)
        {
            major    = (MajorStart + FHALF) & FINVMASK;
            majorEnd = (MajorEnd   + FHALF) & FINVMASK;         
        }
        else
        {
            major    = (MajorStart + FHALFMASK) & FINVMASK;
            majorEnd = (MajorEnd   + FHALFMASK) & FINVMASK;                 
        }

        isStartIn = IsInDiamond(MajorStart - major, MinorStart - minor, 
            SlopeIsOne, SlopeIsPosOne);
        isEndIn   = IsInDiamond(MajorEnd - majorEnd, MinorEnd - minorEnd, 
            SlopeIsOne, SlopeIsPosOne);
    }
    else
    {
        major = (MajorStart + FHALFMASK) & FINVMASK;
        majorEnd = (MajorEnd + FHALFMASK) & FINVMASK;                 
        
        isStartIn = IsInDiamond(MinorStart - minor, MajorStart - major, 
            FALSE, FALSE);
        isEndIn   = IsInDiamond(MinorEnd - minorEnd, MajorEnd - majorEnd, 
            FALSE, FALSE);
    }

    // Determine if we need to advance the initial point. 

    if(!(Flipped && IsEndExclusive))
    {
        if(((MajorStart & FMASK) <= FHALF) && !isStartIn)
        {
            major += FSIZE;    
        }
    }
    else
    {   
        if(isStartIn || ((MajorStart & FMASK) <= FHALF))
        {
            major += FSIZE; 
        }
    }
    
    // Adjust the initial minor coordinate accodingly

    minor = GpFloor(MinorStart + (major - MajorStart)*Slope); 

    // Bring the initial major coordinate to integer

    major = major >> FBITS;                 

    // Do the same for the end point. 

    if(!Flipped && IsEndExclusive)
    {
        if(((MajorEnd & FMASK) > FHALF) || isEndIn)
        {
            majorEnd -= FSIZE;    
        }
    }
    else
    {   
        if(!isEndIn && ((MajorEnd & FMASK) > FHALF))
        {
            majorEnd -= FSIZE; 
        }
    }

    minorEnd = GpFloor(MinorEnd + (majorEnd - MajorEnd)*Slope); 

    majorEnd = majorEnd >> FBITS;

    // If End is smaller than Start, that means we have a line that
    // is smaller than a pixel and bu the diamond rule it should
    // not be drawn. 

    if(majorEnd < major)
    {
        return FALSE; 
    }

    // Get the error correction values. 
    
    ErrorUp     = DMinor << 1; 
    ErrorDown   = DMajor << 1; 

   
    INT MinorInt;

    // Take out the fractions from the DDA. GDI's rounding
    // doesn't depend on direction, so for compatability
    // round down as GDI does when LINEADJUST281816 is
    // defined (see Office 10 bug 281816).  Otherwise the rounding 
    // rule for the minor coordinate depends on the direction
    // we are going. 
    
#ifdef LINEADJUST281816
    MinorInt = (minor + FHALFMASK) & FINVMASK;
    minorEnd = (minorEnd + FHALFMASK) >> FBITS; 
#else
    if(MinorDir == 1)
    {
        MinorInt = (minor + FHALF) & FINVMASK;
        minorEnd = (minorEnd + FHALF) >> FBITS; 
    }
    else
    {
        MinorInt = (minor + FHALFMASK) & FINVMASK;
        minorEnd = (minorEnd + FHALFMASK) >> FBITS; 
    }
#endif   

    // Calculate the initial error based on our fractional 
    // position in fixed point and convert to integer. 

    Error = -ErrorDown*(FHALF + MinorDir*(MinorInt - minor)); 
    minor = MinorInt >> FBITS; 
    Error >>= FBITS;  

    // Update the class variables

    MinorStart = minor; 
    MinorEnd   = minorEnd; 
    MajorStart = major; 
    MajorEnd   = majorEnd; 
            
    return TRUE; 
}


/**************************************************************************\
*
* Function Description:
*
* Draws a y major line. Does not support clipping, it assumes that 
* it is completely inside any clipping area. 
*
* Arguments:
*
*   [IN] DpScanBuffer - The scan buffer for accessing the surface. 

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/


VOID 
OnePixelLineDDAAliased::DrawYMajor(
    DpScanBuffer *scan
    )
{
    // Do the DDA loop for the case where there is no complex 
    // clipping region. 
    
    ARGB *buffer;          
    INT numPixels = MajorEnd - MajorStart; 

    while(numPixels >= 0) 
    {
        buffer = scan->NextBuffer(MinorStart, MajorStart, 1);          

        *buffer = Color;
        MajorStart++; 
        Error += ErrorUp; 
    
        if( Error > 0 ) 
        {
            MinorStart += MinorDir; 
            Error -= ErrorDown; 
        }

        numPixels--; 
    } 
    
}


/**************************************************************************\
*
* Function Description:
*
* Draws a x major line. Does not support clipping, it assumes that 
* it is completely inside any clipping area. 
*
* Arguments:
*
*   [IN] DpScanBuffer - The scan buffer for accessing the surface. 

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

VOID 
OnePixelLineDDAAliased::DrawXMajor(
    DpScanBuffer *scan
    )
{    
    INT numPixels = MajorEnd - MajorStart + 1; 
    ARGB *buffer;  
    INT width = 0;

    const INT maxWidth = MaximumWidth;
    // Run the DDA. First accumulate the width, and when 
    // the scanline changes write the whole scanline at
    // once. 

    buffer = scan->NextBuffer(MajorStart, MinorStart, maxWidth); 

    while(numPixels--) 
    {
        MajorStart++;
        *buffer++ = Color; 
        width++; 
        Error += ErrorUp; 

        if( Error > 0 && numPixels) 
        {              
            MinorStart += MinorDir;    
            Error -= ErrorDown;       
            scan->UpdateWidth(width);           
            buffer = scan->NextBuffer(MajorStart, MinorStart, maxWidth); 
            width = 0; 
        }
    }

    scan->UpdateWidth(width); 
}


/**************************************************************************\
*
* Function Description:
*
* Draws a y major line taking clipping into account. It uses the member
* variables MajorIn, MajorOut, MinorIn, MinorOut of the class as the 
* clip rectangle. It advances untill the line is in the clip rectangle and 
* draws untill it gets out or the end point is reached. In the first case, 
* it leaves the DDA in a state so that it can be called again with another
* clipping rectangle. 
*
* Arguments:
*
*   [IN] DpScanBuffer - The scan buffer for accessing the surface. 

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/


VOID 
OnePixelLineDDAAliased::DrawYMajorClip(
    DpScanBuffer *scan
    )
{
    INT saveMajor2 = MajorEnd; 
    INT saveMinor2 = MinorEnd; 
    
    // Do the DDA if all the clipping left the line 
    // valid. 

    if(StepUpAliasedClip())
    {                   
        // The length given by the minor coord. Whichever length
        // comes to 0 first, minor or major, we stop. 
    
        INT minorDiff = (MinorEnd - MinorStart)*MinorDir; 

        ARGB *buffer;          
        INT numPixels = MajorEnd - MajorStart; 

        while((minorDiff >= 0) && (numPixels >= 0)) 
        {
            buffer = scan->NextBuffer(MinorStart, MajorStart, 1);          
    
            *buffer = Color;
            MajorStart++; 
            Error += ErrorUp; 
        
            if( Error > 0 ) 
            {
                MinorStart += MinorDir; 
                Error -= ErrorDown; 
                minorDiff--; 
            }
    
            numPixels--; 
        } 

    }

    // Restore the saved end values

    MajorEnd = saveMajor2; 
    MinorEnd = saveMinor2; 
}


/**************************************************************************\
*
* Function Description:
*
* Draws a x major line taking clipping into account. It uses the member
* variables MajorIn, MajorOut, MinorIn, MinorOut of the class as the 
* clip rectangle. It advances untill the line is in the clip rectangle and 
* draws untill it gets out or the end point is reached. In the first case, 
* it leaves the DDA in a state so that it can be called again with another
* clipping rectangle. 
*
* Arguments:
*
*   [IN] DpScanBuffer - The scan buffer for accessing the surface. 

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/


VOID 
OnePixelLineDDAAliased::DrawXMajorClip(
    DpScanBuffer *scan
    )
{
    INT saveMajor2 = MajorEnd; 
    INT saveMinor2 = MinorEnd; 
    const INT maxWidth = MaximumWidth;

    if(StepUpAliasedClip())
    {
        INT minorDiff = (MinorEnd - MinorStart)*MinorDir; 

        INT numPixels = MajorEnd - MajorStart + 1; 
        ARGB *buffer;  
    
        INT width = 0;
    
        // Run the DDA for the case where there is no 
        // complex clipping region, which is a lot easier. 
    
        buffer = scan->NextBuffer(MajorStart, MinorStart, maxWidth); 

        while(numPixels--) 
        {
            MajorStart++;
            width++; 
            *buffer++ = Color; 
            Error += ErrorUp; 
    
            if( Error > 0 && numPixels) 
            {   
                MinorStart += MinorDir;
                Error -= ErrorDown;                 
                minorDiff--; 
                scan->UpdateWidth(width); 
                
                // If all of the scanlines in the minor direction have
                // been filled, then quit now.
                if(minorDiff < 0)
                {
                    break;
                }

                buffer = scan->NextBuffer(MajorStart, MinorStart, maxWidth); 
                width = 0; 

            }
        }
        scan->UpdateWidth(width); 
    }

    MajorEnd = saveMajor2; 
    MinorEnd = saveMinor2; 
}

/**************************************************************************\
*
* Function Description:
*
* Steps the DDA until the start point is at the edge of the 
* clipping rectangle. Also, correct the end values so that 
* they stop at the end of the rectangle. The caller must save 
* these values to restore at the end of the loop. 
*
* Arguments:
*
* Return Value:
*
* 
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/


BOOL
OnePixelLineDDAAliased::StepUpAliasedClip()
{
    // Step up on the DDA untill the major coordinate 
    // is aligned with the rectangles edge

    while(MajorStart < MajorIn) 
    {
        MajorStart++; 
        Error += ErrorUp;     
        if( Error > 0 ) 
        {
            MinorStart += MinorDir; 
            Error -= ErrorDown; 
        }                   
    }

    // If the minor coordinate is still out, step up untill 
    // this one is also aligned. In doing that we might pass
    // the on the major coordinate, in which case we are done
    // and there is no intersection. 

    INT minorDiff = (MinorIn - MinorStart)*MinorDir; 

    while(minorDiff > 0 && MajorStart <= MajorOut)
    {
        MajorStart++; 
        Error += ErrorUp;     
        if( Error > 0 ) 
        {
            MinorStart += MinorDir;
            minorDiff--;
            Error -= ErrorDown; 
        }                   
    }
        
    minorDiff = (MinorEnd - MinorOut)*MinorDir;
    
    if(minorDiff > 0)
    {
        if((MinorStart - MinorOut)*MinorDir > 0)
        {
            return FALSE; 
        }
        MinorEnd = MinorOut;    
    }
    
    if(MajorOut < MajorEnd) 
    {
        MajorEnd = MajorOut; 
    }
    
    // Return if the line is still valid. 

    return(MajorStart <= MajorEnd);
}


//--------------------------------------------------------------------
// Auxiliary functions 
//--------------------------------------------------------------------


/**************************************************************************\
*
* Function Description:
*
* Clips the line against a rectangle. It assumes that the line endpoints 
* are stored in the class in floating point format. This sets an 
* order in which this function can be called. It must be after the 
* SetupCommon function and before the specific setups for antialiasing 
* and aliasing. This is a pain, but it's better than requirering on of
* these to have to know about clipping. The clipping here is done by 
* using the Slope and InvSlope members of the class to advance the 
* endpoints to the rectangle edges. Thus the function also assumes that
* Slope and InvSlope have been calculated.
*
* Arguments:
*
*   [IN] clipRect - The rectangle to clip against

* Return Value:
*
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/


BOOL 
OnePixelLineDDAAliased::ClipRectangle(
    const GpRect* clipRect
    )
{

    INT clipBottom, clipTop, clipLeft, clipRight; 

    // Set the major and minor edges of the clipping
    // region, converting to fixed point 28.4. Note that
    // we don't convert to the pixel center, but to a 
    // that goes all the way up to the pixel edges. This 
    // makes a difference for antialiasing. We don't go all
    // the way to the edge since some rounding rules could 
    // endup lighting the next pixel outside of the clipping
    // area. That's why we add/subtract 7 instead of 8 for the
    // bottom and right, since these are exclusive. 
    // For the left and top, subtract 8 (1/2 pixel), since here
    // we are inclusive.
    
    INT majorMin = (clipRect->GetLeft() << FBITS) - FHALF;
    INT majorMax = ((clipRect->GetRight() - 1) << FBITS) + FHALFMASK; 
    INT minorMax = ((clipRect->GetBottom() - 1) << FBITS) + FHALFMASK; 
    INT minorMin = (clipRect->GetTop() << FBITS) - FHALF; 

    if(!IsXMajor)
    {
        INT tmp; 
        tmp      = majorMin; 
        majorMin = minorMin; 
        minorMin = tmp; 
        tmp      = majorMax; 
        majorMax = minorMax; 
        minorMax = tmp; 
    }

    // First clip in the major coordinate 

    BOOL minOut, maxOut; 

    minOut = MajorStart < majorMin; 
    maxOut = MajorEnd > majorMax; 

    if( minOut || maxOut )
    {
        if(MajorStart > majorMax || MajorEnd < majorMin)
        {
            return FALSE; 
        }

        if(minOut)
        {
            MinorStart += GpFloor((majorMin - MajorStart)*Slope); 
            MajorStart = majorMin;
        }

        if(maxOut)
        {
            MinorEnd += GpFloor((majorMax - MajorEnd)*Slope); 
            MajorEnd = majorMax; 

            // If we clipped the last point, we don't need to be IsEndExclusive
            // anymore, as the last point now is not the line's last 
            // point but some in the middle. 

            IsEndExclusive = FALSE; 
        }
    }

    // Now clip the minor coordinate 

    INT *pMajor1, *pMinor1, *pMajor2, *pMinor2; 

    if(MinorDir == 1)
    {
        pMajor1 = &MajorStart; 
        pMajor2 = &MajorEnd; 
        pMinor1 = &MinorStart; 
        pMinor2 = &MinorEnd; 
    }
    else
    {
        pMajor1 = &MajorEnd; 
        pMajor2 = &MajorStart; 
        pMinor1 = &MinorEnd; 
        pMinor2 = &MinorStart; 
    }

    minOut = *pMinor1 < minorMin; 
    maxOut = *pMinor2 > minorMax; 

    if(minOut || maxOut)
    {
        if(*pMinor1 > minorMax || *pMinor2 < minorMin)
        {
            return FALSE; 
        }

        if(minOut)
        {
            *pMajor1 += GpFloor((minorMin - *pMinor1)*InvSlope); 
            *pMinor1 = minorMin;
        }

        if(maxOut)
        {
            *pMajor2 += GpFloor((minorMax - *pMinor2)*InvSlope); 
            *pMinor2 = minorMax;

            // If we clipped the last point, we don't need to be endExclusive
            // anymore, as the last point now is not the line's last 
            // point but some in the middle. 

            IsEndExclusive = FALSE; 
        }
    }

    return(TRUE); 
}

/**************************************************************************\
*
* Function Description:
*
* Given the fractional parts of a coordinate in fixed point, this 
* function returns if the coordinate is inside the diamond at the 
* nearest integer position. 
*
* Arguments:
*
*   [IN] xFrac - Fractional part of the x coordinate 
*   [IN] yFrac - Fractional part of the y coordinate 
*   [IN] SlopeIsOne    - TRUE if the line has Slope +/- 1 
*   [IN] SlopeIsPosOne - TRUE if the line has Slope +1 

* Return Value:
*
* TRUE if the coordinate is inside the diamond 
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

BOOL 
OnePixelLineDDAAliased::IsInDiamond( 
    INT xFrac, 
    INT yFrac, 
    BOOL SlopeIsOne, 
    BOOL SlopeIsPosOne 
    )
{
    // Get the fractional parts of the fix points, and the
    // sum of their absolute values. 

    INT fracSum = 0; 

    if(xFrac > 0) 
    {
        fracSum += xFrac; 
    }
    else
    {
        fracSum -= xFrac; 
    }

    if(yFrac > 0) 
    {
        fracSum += yFrac; 
    }
    else
    {
        fracSum -= yFrac; 
    }

    // Return true if the point is inside the diamond.

    if(fracSum < FHALF) 
    {
        return TRUE; 
    }

    // Check the cases where we are at the two vertices of the
    // diamond which are considered inside. 

    if(yFrac == 0) 
    {
        if((SlopeIsPosOne && xFrac == -FHALF) || 
           (!SlopeIsPosOne && xFrac == FHALF))
        {
            return TRUE; 
        }
    }

    if((xFrac == 0) && (yFrac == FHALF))
    {
        return TRUE; 
    }

    // Check for the cases where we are at the edges of the 
    // diamond with a Slope of one. 

    if (SlopeIsOne && (fracSum == FHALF))
    {
        if (SlopeIsPosOne && (xFrac < 0) && (yFrac > 0))
        {
            return TRUE;
        }

        if (!SlopeIsPosOne && (xFrac > 0) && (yFrac > 0))
        {
            return TRUE;
        }    
    }
    
    return FALSE;
}

typedef GpStatus DrawSolidLineFunc(
    DpScanBuffer *scan, 
    const GpRect *clipRect, 
    const DpClipRegion* clipRegionIn, 
    GpPointF *point1, 
    GpPointF *point2,
    ARGB inColor,
    BOOL drawLast
    );
        
DrawSolidLineFunc DrawSolidLineOnePixelAliased;
DrawSolidLineFunc DrawSolidLineOnePixelAntiAliased;

/**************************************************************************\
*
* Function Description:
*
*   Called back by the path enumeration function, this draws a list
*   of lines.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   03/31/2000 andrewgo
*
\**************************************************************************/

struct EpSolidStrokeOnePixelContext
{
    DrawSolidLineFunc *DrawLineFunction;
    DpScanBuffer *Scan;
    GpRect *ClipBoundsPointer;
    DpClipRegion *ClipRegion;
    ARGB Argb;
    BOOL DrawLast;   // TRUE if draw last pixel in subpaths
};

BOOL
DrawSolidStrokeOnePixel(
    VOID *voidContext,
    POINT *point,     // 28.4 format, an arary of size 'count'
    INT vertexCount,
    PathEnumerateTermination lastSubpath
    )
{
    EpSolidStrokeOnePixelContext *context 
        = static_cast<EpSolidStrokeOnePixelContext*>(voidContext);

    ASSERT(vertexCount >= 2);

    for (INT i = vertexCount - 1; i != 0; i--, point++)
    {
        PointF pointOne(TOREAL((point)->x) / 16, TOREAL((point)->y) / 16);
        PointF pointTwo(TOREAL((point + 1)->x) / 16, TOREAL((point + 1)->y) / 16) ;

        // Note that we're always drawing the last pixel, which is
        // fine when we're 100% opaque, because we'll be re-drawing
        // the same pixel for consecutive joined lines (it's a little
        // more work, but the cost is small and is actually comparable 
        // to the overhead of deciding whether to do the last pixel
        // or not).
        //
        // This is the wrong thing to do for non-opaque lines, because
        // of the redraw issue.  But we shouldn't be coming through
        // here for the non-opaque case anyway, since any self-overlaps
        // of the lines will cause pixel overdraw, which produces the
        // 'wrong' result (or at least different from the 'right' result
        // as defined by the widener code).

        (context->DrawLineFunction)(
            context->Scan,
            context->ClipBoundsPointer,
            context->ClipRegion,
            &pointOne,
            &pointTwo,
            context->Argb,
            (lastSubpath==PathEnumerateCloseSubpath) || context->DrawLast
        );
    }

    return(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Draws a one-pixel wide path with a solid color.
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to fill
*   [IN] drawBounds - the surface bounds
*   [IN] path       - the path to fill
*   [IN] pen        - the pen to use
*   [IN] drawLast   - TRUE if last pixels in subpaths are to be drawn.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

GpStatus
DpDriver::SolidStrokePathOnePixel(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpPath *path,
    const DpPen *pen,
    BOOL drawLast
    )
{
    GpBrush *brush = GpBrush::GetBrush(pen->Brush);

    ASSERT(pen->Brush->Type == BrushTypeSolidColor);
    ASSERT(pen->Brush->SolidColor.IsOpaque());

    // Antialiased lines are usually drawn using aarasterizer.cpp 
    // rather than aaline.cpp.  If aaline.cpp is to be used, define
    // AAONEPIXELLINE_SUPPORT
    
#ifdef AAONEPIXELLINE_SUPPORT
    DrawSolidLineFunc *drawLineFunc = context->AntiAliasMode 
        ? DrawSolidLineOnePixelAntiAliased 
        : DrawSolidLineOnePixelAliased;
#else
    ASSERT(context->AntiAliasMode == 0);
    DrawSolidLineFunc *drawLineFunc = DrawSolidLineOnePixelAliased;
#endif
    
    // Determine if alpha blending is necessary 

    BOOL noTransparentPixels;
    
    noTransparentPixels = (!context->AntiAliasMode) &&
                          (brush->IsOpaque());

    DpScanBuffer scan(
        surface->Scan,
        this,
        context,
        surface,
        noTransparentPixels);

    if (!scan.IsValid())
    {
        return(GenericError);
    }

    GpSolidFill * solidBrush = static_cast<GpSolidFill *>(brush);
    
    ARGB argb = solidBrush->GetColor().GetValue(); 

    DpClipRegion *clipRegion = &context->VisibleClip; 

    GpRect clipBounds; 
    GpRect *clipBoundsPointer; 
    RECT clipRect;
    RECT *clipRectPointer;
    DpRegion::Visibility visibility;

    visibility = clipRegion->GetRectVisibility(
                drawBounds->X,
                drawBounds->Y,
                drawBounds->X + drawBounds->Width,
                drawBounds->Y + drawBounds->Height);

    if (visibility == DpRegion::TotallyVisible)
    {
        clipBoundsPointer = NULL; 
        clipRectPointer = NULL;
        clipRegion = NULL; 
    }
    else
    {
        // !!![andrewgo] Is clipBoundsPointer actually needed?

        clipRegion->GetBounds(&clipBounds);
        clipBoundsPointer = &clipBounds;

        // Scale the clip bounds rectangle by 16 to account for our scaling 
        // to 28.4 coordinates:

        clipRect.left = clipBounds.GetLeft() << 4;
        clipRect.top = clipBounds.GetTop() << 4;
        clipRect.right = clipBounds.GetRight() << 4;
        clipRect.bottom = clipBounds.GetBottom() << 4;
        clipRectPointer = &clipRect;

        // !!![andrewgo] Why is this needed?  Why wasn't this covered in 
        //               GetRectVisibility?

        if (clipRegion->IsSimple())
        {
            clipRegion = NULL;
        }
    }

    EpSolidStrokeOnePixelContext drawContext;

    drawContext.DrawLineFunction = drawLineFunc;
    drawContext.Scan = &scan;
    drawContext.ClipBoundsPointer = clipBoundsPointer;
    drawContext.ClipRegion = clipRegion;
    drawContext.Argb = argb;
    drawContext.DrawLast = drawLast;

    // Scale the transform by 16 to get 28.4 units:

    GpMatrix transform = context->WorldToDevice;
    transform.AppendScale(TOREAL(16), TOREAL(16));

    FixedPointPathEnumerate(path, 
                            &transform,
                            clipRectPointer,
                            PathEnumerateTypeStroke,
                            DrawSolidStrokeOnePixel,
                            &drawContext);

    return(Ok);
}

/**************************************************************************\
*
* Function Description:
*
* Draws a one-pixe-wide line with a solid color. Calls on the 
* OnePixelLineDDAAliased class to do the actual drawing. 
*
* Arguments:
*
*   [IN] scan         - The DpScanBuffer to access the drawing surface 
*   [IN] clipRect     - A single rectangle that includes all the clipping 
*                       region. If there is no clipping, should be set to NULL.                          
*   [IN] clipRegionIn - A complex clipping region. If the clipping region is 
*                       simple, this should be NULL, and clipRect will be used. 
*   [IN] point1       - line end point 
*   [IN] point2       - line end point 
*   [IN] inColor      - the solid color
*   [IN] drawLast     - FALSE if the line is to be end-exclusive.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   03/31/1999 AMatos
*
\**************************************************************************/

GpStatus
DrawSolidLineOnePixelAliased( 
    DpScanBuffer *scan, 
    const GpRect *clipRect, 
    const DpClipRegion* clipRegionIn, 
    GpPointF *point1, 
    GpPointF *point2,
    ARGB inColor,
    BOOL drawLast
    )
{
    // Take out the const for now because the Enumeration method
    // is not const. 

    DpClipRegion *clipRegion = const_cast<DpClipRegion*>(clipRegionIn); 

    // Setup the common part of the DDA

    OnePixelLineDDAAliased dda; 

    INT width = scan->GetSurface()->Width;
    
    if(clipRect)
    {
        // We have a bug in the driver architecture which allows the 
        // surface associated with the scan to be smaller than the actual
        // surface in the screen case (EpScanGdiDci).
        // Therefore we need to look at the visible clip bounds also.
        // If it turns out that the visible clip is bigger, our maximum
        // width needs to be expanded.
        // 350997 Aliased line is not clipped to surface

        width = max(width, clipRect->Width);
    }

    if(!dda.SetupCommon(point1, point2, drawLast, width))
    {
        return Ok;
    }

    dda.Color = GpColor::ConvertToPremultiplied(inColor); 
    
    // Now handle the different clipping cases 

    if(!clipRect)
    {
        // This is easy, there is no clipping so just draw.

        if(!dda.SetupAliased())
        {
            return Ok; 
        }

        (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 

        return Ok;
    }
    else
    {
        // The inverse of the Slope might be needed. 
       
        // Can't use the inverse slope if the slope is zero.

        if(dda.Slope==0.0F) 
        {
            dda.InvSlope=0.0F;
        } 
        else 
        {
            dda.InvSlope =  (1.0F/dda.Slope); 
        }

        // First of all clip against the bounding rectangle 

        if(!dda.ClipRectangle(clipRect))
        {
            return Ok;            
        }

        // Do the specific setup 

        if(!dda.SetupAliased())
        {
            return Ok; 
        }

        // For each clip rectangle we store it's limits in 
        // an array of four elements. We then index this array using 
        // the variables below which depend on the slope and 
        // direction of the line in the following way: majorIn is edge crossed 
        // to go into the rect in the major direction, majorOut is the edge 
        // crossed to go out of the rect in the major direction, and so on.
        // The same for xIn, xOut, yIn, yOut. 

        INT majorIn, majorOut, minorIn, minorOut; 
        INT xIn, xOut, yIn, yOut;
        
        // Direction to enumerate the rectangles which depends on the 
        // line 

        DpClipRegion::Direction enumDirection; 
        
        INT clipBounds[4]; 
               
        // We store all our info in terms of major and minor 
        // direction, but to deal with cliping rectangles we
        // need to know them in terms of x and y, so calculate
        // xDir, yDir, the advance slope. 

        REAL xAdvanceRate; 
        INT  xDir, yDir; 
        INT  yEndLine;        
    
        // If the line crosses a span completely, (xStart, yStart)
        // is the position where it enters the span and (xEnd, yEnd)
        // is the position that it leaves. If it starts inside the 
        // span, then (xStart, yStart) is the start point

        REAL yStart, xStart, xEnd, yEnd; 

        if(dda.IsXMajor)
        {
            // Calculate the in-out indices

            majorIn  = xIn  = 0; 
            majorOut = xOut = 2; 
            if(dda.MinorDir == 1)
            {
                minorIn  = 1;
                minorOut = 3;
                enumDirection = DpClipRegion::TopLeftToBottomRight;
            }
            else
            {
                minorIn  = 3;
                minorOut = 1;
                enumDirection = DpClipRegion::BottomLeftToTopRight; 
            }
            
            yIn = minorIn;
            yOut = minorOut;

            // Make (xStart, yStart) be the initial point

            yStart = (REAL)dda.MinorStart; 
            xStart = (REAL)dda.MajorStart;

            // Always advance in positive direction when X is major
            xAdvanceRate = REALABS(dda.InvSlope); 
            xDir = 1; 
            yDir = dda.MinorDir; 
            yEndLine =  dda.MinorEnd; 
        }
        else
        {
            majorIn = yIn =  1; 
            majorOut = yOut = 3; 
            if(dda.MinorDir == 1)
            {
                minorIn = 0;
                minorOut = 2;
                enumDirection = DpClipRegion::TopLeftToBottomRight;
            }
            else
            {
                minorIn = 2;
                minorOut = 0;
                enumDirection = DpClipRegion::TopRightToBottomLeft;
            }
            
            xIn = minorIn; 
            xOut = minorOut; 

            // Make (xStart, yStart) be the initial point

            yStart = (REAL)dda.MajorStart;
            xStart = (REAL)dda.MinorStart; 

            xAdvanceRate = dda.Slope; 
            xDir = dda.MinorDir; 
            yDir = 1;
            yEndLine = dda.MajorEnd; 
        }

        // Update the drawing function to the correct 
        // slipping version

        dda.DrawFuncIndex += FUNC_CLIP_OFFSET; 
    
        if(!clipRegion)
        {
            // In this case there is only a single rect, so just
            // draw clipped to that 

            // Store the rectangle in an array so we can atribute the 
            // right values to the MajorIn, majorOut, etc... variables. 
            // Remember that bottom and right are exclusive. 

            clipBounds[0] = clipRect->GetLeft(); 
            clipBounds[1] = clipRect->GetTop(); 
            clipBounds[2] = clipRect->GetRight() - 1; 
            clipBounds[3] = clipRect->GetBottom() - 1; 

            dda.MajorIn  = clipBounds[majorIn]; 
            dda.MajorOut = clipBounds[majorOut]; 
            dda.MinorIn  = clipBounds[minorIn]; 
            dda.MinorOut = clipBounds[minorOut]; 

            (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 

            return Ok;
        }
        else
        {
            BOOL agregating = FALSE; 
            INT  agregateBounds[4];

            // We have a complex clipping region. So what we'll do 
            // is clip against each individual rectangle in the 
            // cliping region. 

            clipRegion->StartEnumeration(GpFloor(yStart), enumDirection);            

            GpRect rect; 

            // Get the first rectangle. 

            INT numRects = 1;        

            clipRegion->Enumerate(&rect, numRects); 
            
            clipBounds[0] = rect.GetLeft(); 
            clipBounds[1] = rect.GetTop(); 
            clipBounds[2] = rect.GetRight() - 1; 
            clipBounds[3] = rect.GetBottom() - 1; 
            
            // Store the y position into the span 

            INT currSpanYMin = clipBounds[yIn]; 

            // We need some special treatment for the case where the 
            // line is horizontal, since is this case it's not going 
            // to cross different spans. And it it's not in the current
            // span, it's totally clipped out. 

            if(dda.IsXMajor && dda.ErrorUp == 0)
            {
                if(yStart >= clipBounds[1] && yStart <= clipBounds[3])
                {
                    xStart  = (REAL)dda.MajorStart;
                    xEnd    = (REAL)dda.MajorEnd; 
                }
                else
                {
                    return Ok; 
                }
            }
            else
            {
                if(yStart < clipBounds[1] || yStart > clipBounds[3])
                {
                    xStart  = xStart + (clipBounds[yIn] - yStart)*xAdvanceRate; 
                    yStart  = (REAL)clipBounds[yIn];
                }

                // Account for initial DDA error when calculating xEnd so that clipping
                // will track what the DDA is actually drawing.
                xEnd = xStart + ((clipBounds[yOut] - yStart)*yDir - ((REAL)dda.Error / (REAL)dda.ErrorDown))*xAdvanceRate; 
            }
            
            yEnd = (REAL)clipBounds[yOut]; 

            while(1)
            {
                // Get to the first rectangle on the span that crosses the
                // line 
                
                while((xStart - clipBounds[xOut])*xDir > 0)
                {
                    numRects = 1; 
                    
                    clipRegion->Enumerate(&rect, numRects); 
                    
                    clipBounds[0] = rect.GetLeft(); 
                    clipBounds[1] = rect.GetTop(); 
                    clipBounds[2] = rect.GetRight() - 1; 
                    clipBounds[3] = rect.GetBottom() - 1; 

                    if(numRects != 1)
                    {
                        goto draw_agregated;
                    }
                    if(clipBounds[yIn] != currSpanYMin)
                    {
                        // There may be pending aggregated drawing operations.  If so
                        // perform them now before doing the next span.
                        if (agregating)
                            break;
                        else
                            goto process_next_span; 
                    }
                }

                // Draw on all the rectangles that intersect the 
                // line 

                if((xStart - clipBounds[xIn])*xDir > 0 && 
                   (clipBounds[xOut] - xEnd)*xDir > 0)
                {
                    if(agregating) 
                    {
                        if((clipBounds[xIn] - agregateBounds[xIn])*xDir < 0)
                        {
                            agregateBounds[xIn] = clipBounds[xIn];        
                        }
                        if((clipBounds[xOut] - agregateBounds[xOut])*xDir > 0)
                        {
                            agregateBounds[xOut] = clipBounds[xOut];        
                        }
                        agregateBounds[yOut] = clipBounds[yOut];
                    }
                    else
                    {
                        agregateBounds[0] = clipBounds[0];
                        agregateBounds[1] = clipBounds[1];
                        agregateBounds[2] = clipBounds[2];
                        agregateBounds[3] = clipBounds[3];

                        agregating = TRUE; 
                    }
                }
                else
                {
                    if(agregating)
                    {
                        dda.MajorIn  = agregateBounds[majorIn]; 
                        dda.MajorOut = agregateBounds[majorOut]; 
                        dda.MinorIn  = agregateBounds[minorIn]; 
                        dda.MinorOut = agregateBounds[minorOut]; 
            
                        (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 
                        
                        agregating = FALSE; 
                    }
                    while((xEnd - clipBounds[xIn])*xDir > 0)
                    {
                        dda.MajorIn  = clipBounds[majorIn]; 
                        dda.MajorOut = clipBounds[majorOut]; 
                        dda.MinorIn  = clipBounds[minorIn]; 
                        dda.MinorOut = clipBounds[minorOut]; 
            
                        (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 

                        if(dda.MajorStart > dda.MajorEnd)
                        {
                            return Ok; 
                        }

                        numRects = 1; 
                        
                        clipRegion->Enumerate(&rect, numRects); 
                        
                        clipBounds[0] = rect.GetLeft(); 
                        clipBounds[1] = rect.GetTop(); 
                        clipBounds[2] = rect.GetRight() - 1; 
                        clipBounds[3] = rect.GetBottom() - 1; 
    
                        if(numRects != 1) 
                        {
                            goto draw_agregated;
                        }
                        if(clipBounds[yIn] != currSpanYMin)
                        {
                            goto process_next_span; 
                        }
                    }
                }

                // Get to the next span

                while(clipBounds[yIn] == currSpanYMin)
                {
                    numRects = 1; 
                    
                    clipRegion->Enumerate(&rect, numRects); 
                    
                    clipBounds[0] = rect.GetLeft(); 
                    clipBounds[1] = rect.GetTop(); 
                    clipBounds[2] = rect.GetRight() - 1; 
                    clipBounds[3] = rect.GetBottom() - 1; 

                    if(numRects != 1) 
                    {
                        goto draw_agregated;
                    }
                }

process_next_span:

                if((clipBounds[yIn] - yEndLine)*yDir > 0)
                {
                    // We are done. 
                    goto draw_agregated; 
                }

                if((clipBounds[yIn] - yEnd)*yDir == 1)
                {
                    xStart  = xEnd;
                }
                else
                {
                    if(agregating)
                    {
                        dda.MajorIn  = agregateBounds[majorIn]; 
                        dda.MajorOut = agregateBounds[majorOut]; 
                        dda.MinorIn  = agregateBounds[minorIn]; 
                        dda.MinorOut = agregateBounds[minorOut]; 
                        
                        (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan); 
                        
                        if(dda.MajorStart > dda.MajorEnd)
                        {
                            return Ok; 
                        }

                        agregating = FALSE; 
                    }

                    xStart  = xStart + (clipBounds[yIn] - yStart)*yDir*xAdvanceRate;
                }

                yStart  = (REAL)clipBounds[yIn];                 
                // Add 1 to make the amount added to xStart proportional to height of
                // the clipping rectangle, since clipBounds are inset by 1.
                xEnd    = xStart + ((clipBounds[yOut] - yStart)*yDir + 1)*xAdvanceRate; 
                yEnd    = (REAL)clipBounds[yOut];
                currSpanYMin = GpFloor(yStart); 
            }

draw_agregated: 

            if(agregating)
            {
                dda.MajorIn  = agregateBounds[majorIn]; 
                dda.MajorOut = agregateBounds[majorOut]; 
                dda.MinorIn  = agregateBounds[minorIn]; 
                dda.MinorOut = agregateBounds[minorOut]; 
                
                (dda.*(gDrawFunctions[dda.DrawFuncIndex]))(scan);                 
            }

        }
    }

    return Ok; 
}

#pragma optimize("a", off)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\halftone.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Halftoning (for GIF codec)
*
* Abstract:
*
*   Halftone 32 bpp to 8 bpp using 216-color halftoning
*
* Revision History:
*
*   02/21/2000 dcurtis
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#if defined(_USE_X86_ASSEMBLY)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder)\
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder)\
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#endif

/**************************************************************************\
*
* Operation Description:
*
*   Halftone from 32bpp ARGB to 8bpp, using the 216-color halftone palette.
*
* Arguments:
*
*   d           - The destination scan
*   s           - The source scan (32bpp ARGB)
*   count       - The length of the scan, in pixels
*   orgX        - X origin 
*   orgY        - Y origin 
*
* Return Value:
*
*   None
*
* Notes:
*   
*   This version doesn't use a palette map and doesn't care about the
*   20 Windows system colors.
*
* History:
*
*   2/21/2000 DCurtis
*
\**************************************************************************/

VOID
Halftone_sRGB_8_216(
    BYTE* d,
    const BYTE* s,
    UINT count,
    INT orgX,
    INT orgY
    )
{
    orgX %= 91;
    orgY %= 91;
    
    INT     htStartX   = orgX;
    INT     htStartRow = orgY * 91;
    INT     htIndex    = htStartRow + orgX;

    ULONG   r, g, b;
    ULONG   rQuo, gQuo, bQuo;
    ULONG   rRem, gRem, bRem;
    ULONG   divisor = 0x33;
    
    for (;;)
    {
        r = s[2];
        g = s[1];
        b = s[0];

        s += 4;

        QUOTIENT_REMAINDER(r, divisor, rQuo, rRem);
        QUOTIENT_REMAINDER(g, divisor, gQuo, gRem);
        QUOTIENT_REMAINDER(b, divisor, bQuo, bRem);

        // MUST do >, not >= so that a remainder of 0 works correctly
        r = rQuo + (rRem > HT_SuperCell_Red216  [htIndex]);
        g = gQuo + (gRem > HT_SuperCell_Green216[htIndex]);
        b = bQuo + (bRem > HT_SuperCell_Blue216 [htIndex]);

        *d++ = (BYTE)((r*36) + (g*6) + b + 40);

        if (--count == 0)
        {
            break;
        }

        htIndex++;
        if (++orgX >= 91)
        {
            orgX = 0;
            htIndex = htStartRow;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Halftone an image from 32bpp to 8bpp. See the .hpp file for caveats.
*
* Arguments:
*
*   [IN]      src        - pointer to scan0 of source image
*   [IN]      srcStride  - stride of src image (can be negative)
*   [IN]      dst        - pointer to scan0 of destination 8-bpp image
*   [IN]      dstStride  - stride of dst image (can be negative)
*   [IN]      width      - image width
*   [IN]      height     - image height
*   [IN]      orgX       - where the upper-left corner of image starts
*   [IN]      orgY       - for computing the halftone cell origin
*
* Return Value:
*
*   NONE
*
* History:
*
*   10/29/1999 DCurtis
*     Created it.
*   01/20/2000 AGodfrey
*     Moved it from Imaging\Api\Colorpal.cpp/hpp.
*
\**************************************************************************/

VOID
Halftone32bppTo8bpp(
    const BYTE* src,
    INT srcStride,
    BYTE* dst,
    INT dstStride,
    UINT width,
    UINT height,
    INT orgX,
    INT orgY
    )
{
    ASSERT (((srcStride >= 0) && (srcStride >= (INT)(width * 4))) ||
            ((srcStride < 0) && (-srcStride >= (INT)(width * 4))));
    ASSERT (((dstStride >= 0) && (dstStride >= (INT)width)) || 
            ((dstStride < 0) && (-dstStride >= (INT)width)));
    ASSERT((src != NULL) && (dst != NULL));            
    
    if (width == 0)
    {
        return;
    }
    
    for (; height > 0; height--)
    {
        Halftone_sRGB_8_216(dst, src, width, orgX, orgY);
        orgY++;
        src += srcStride;
        dst += dstStride;
    }
}

extern "C" {
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\nearestneighbor.cpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   nearestneighbor.cpp
*
* Abstract:
*
*   Nearest Neighbor Resampling code
*
* Created:
*
*   3/3/2000 asecchia
\**************************************************************************/

#include "precomp.hpp"

DpOutputNearestNeighborSpan::DpOutputNearestNeighborSpan(
    DpBitmap* bitmap,
    DpScanBuffer * scan,
    DpContext* context,
    DpImageAttributes imageAttributes,
    INT numPoints,
    const GpPointF *dstPoints,
    const GpRectF *srcRect
    )
{
    Scan     = scan;
    NWrapMode = imageAttributes.wrapMode;
    ClampColor = imageAttributes.clampColor;
    SrcRectClamp = imageAttributes.srcRectClamp;
    dBitmap   = bitmap;

    ASSERT(dBitmap != NULL);
    ASSERT(dBitmap->IsValid());

    // on bad bitmap, we return with Valid = FALSE
    if (dBitmap == NULL ||
        !dBitmap->IsValid() )
    {
        dBitmap = NULL;
        return;
    } else {
        BmpData.Width = dBitmap->Width;
        BmpData.Height = dBitmap->Height;
        BmpData.PixelFormat = PIXFMT_32BPP_PARGB;
        BmpData.Stride = dBitmap->Delta;
        BmpData.Scan0 = dBitmap->Bits;
    }

    WorldToDevice = context->WorldToDevice;
    context->GetDeviceToWorld(&DeviceToWorld);

    if(srcRect)
        SrcRect = *srcRect;
    else
    {
        SrcRect.X = 0;
        SrcRect.Y = 0;
        SrcRect.Width  = (REAL)dBitmap->Width;
        SrcRect.Height = (REAL)dBitmap->Height;
    }

    GpPointF points[4];

    GpMatrix xForm;
    BOOL existsTransform = TRUE;

    switch(numPoints)
    {
    case 0:
        points[0].X = 0;
        points[0].Y = 0;
        points[1].X = (REAL) SrcRect.Width;
        points[1].Y = 0;
        points[2].X = 0;
        points[2].Y = (REAL) SrcRect.Height;
        break;

    case 1:
        points[0] = dstPoints[0];
        points[1].X = (REAL) (points[0].X + SrcRect.Width);
        points[1].Y = points[0].Y;
        points[2].X = points[0].X;
        points[2].Y = (REAL) (points[0].Y + SrcRect.Height);
        break;

    case 3:
    case 4:
        GpMemcpy(&points[0], dstPoints, numPoints*sizeof(GpPointF));
        break;

    default:
        existsTransform = FALSE;
    }

    if(existsTransform)
    {
        xForm.InferAffineMatrix(points, SrcRect);
    }

    WorldToDevice = context->WorldToDevice;
    WorldToDevice.Prepend(xForm);
    if(WorldToDevice.IsInvertible())
    {
        DeviceToWorld = WorldToDevice;
        DeviceToWorld.Invert();
    }
}


GpStatus
DpOutputNearestNeighborSpan::OutputSpan(
  INT y,
  INT xMin,
  INT xMax     // xMax is exclusive
)
{
    // Nothing to do.

    if(xMin==xMax)
    {
        return Ok;
    }

    ASSERT(xMin < xMax);

    GpPointF p1, p2;
    p1.X = (REAL) xMin;
    p1.Y = p2.Y = (REAL) y;
    p2.X = (REAL) xMax;

    DeviceToWorld.Transform(&p1);
    DeviceToWorld.Transform(&p2);

    // Convert to Fixed point notation - 16 bits of fractional precision.
    FIX16 dx, dy, x0, y0;
    x0 = GpRound(p1.X*FIX16_ONE);
    y0 = GpRound(p1.Y*FIX16_ONE);

    ASSERT(xMin < xMax);
    dx = GpRound(((p2.X - p1.X)*FIX16_ONE)/(xMax-xMin));
    dy = GpRound(((p2.Y - p1.Y)*FIX16_ONE)/(xMax-xMin));

    return OutputSpanIncremental(y, xMin, xMax, x0, y0, dx, dy);
}

GpStatus
DpOutputNearestNeighborSpan::OutputSpanIncremental(
    INT      y,
    INT      xMin,
    INT      xMax,
    FIX16    x0,
    FIX16    y0,
    FIX16    dx,
    FIX16    dy
    )
{
    INT width  = xMax - xMin;
    ARGB *buffer = Scan->NextBuffer(xMin, y, width);
    ARGB *srcPtr0 = static_cast<ARGB*> (BmpData.Scan0);
    INT stride = BmpData.Stride/sizeof(ARGB);

    INT ix;
    INT iy;

    // For all pixels in the destination span...
    for(int i=0; i<width; i++)
    {
        // .. compute the position in source space.

        // round to the nearest neighbor
        ix = (x0 + FIX16_HALF) >> FIX16_SHIFT;
        iy = (y0 + FIX16_HALF) >> FIX16_SHIFT;

        if( ((UINT)ix >= (UINT)BmpData.Width ) ||
            ((UINT)iy >= (UINT)BmpData.Height) )
        {
            ApplyWrapMode(NWrapMode, ix, iy, BmpData.Width, BmpData.Height);
        }

        // Make sure the pixel is within the bounds of the source before
        // accessing it.

        if( (ix >= 0) &&
            (iy >= 0) &&
            (ix < (INT)BmpData.Width) &&
            (iy < (INT)(BmpData.Height)) )
        {
            *buffer++ = *(srcPtr0+stride*iy+ix);
        }
        else
        {
            // This means that this source pixel is outside of the valid
            // bits in the source. (edge condition)
            *buffer++ = ClampColor;
        }


        // Update source position
        x0 += dx;
        y0 += dy;
    }

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\nearestneighbor.hpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   nearestneighbor.hpp
*
* Abstract:
*
*   Nearest Neighbor Resampling code
*
* Created:
*
*   3/3/2000 asecchia
\**************************************************************************/

#pragma once

class DpOutputNearestNeighborSpan : public DpOutputSpan
{
public:
    DpBitmap *dBitmap;
    BitmapData BmpData;
    DpScanBuffer *  Scan;
    WrapMode NWrapMode;
    ARGB ClampColor;
    BOOL SrcRectClamp;
    GpRectF SrcRect;
    GpMatrix WorldToDevice;
    GpMatrix DeviceToWorld;

public:
    DpOutputNearestNeighborSpan(
        DpBitmap* bitmap,
        DpScanBuffer * scan,
        DpContext* context,
        DpImageAttributes imageAttributes,
        INT numPoints,
        const GpPointF *dstPoints,
        const GpRectF *srcRect
    );

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
    );

    virtual GpStatus OutputSpanIncremental(
        INT      y,
        INT      xMin,
        INT      xMax,
        FIX16    x0,
        FIX16    y0,
        FIX16    dx,
        FIX16    dy
    );

    virtual BOOL IsValid() const { return (dBitmap!=NULL); }
    DpScanBuffer* GetScanBuffer(){ return Scan; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\precomp.hpp ===
#ifdef _M_IX86
#pragma warning(disable:4799)       // No EMMS.
#endif
#include "..\Runtime\Runtime.hpp"
#include "..\Common\Common.hpp"

#include "..\..\sdkinc\gdiplusimaging.h"

#include "..\..\ddkinc\ddiplus.hpp"
#include "..\..\privinc\pixelformats.h"

#include "scan.hpp"
#include "scandib.hpp"

// Hack:
#include "..\..\privinc\imaging.h"
#include "..\imaging\api\ImgUtils.hpp"
#include "..\imaging\api\colorpal.hpp"
#include "..\Entry\device.hpp"
#include "..\Entry\ImageAttr.hpp"
#include "..\Entry\gpbitmap.hpp"
#include "..\Entry\brush.hpp"
#include "..\Entry\pen.hpp"
#include "..\Entry\QuadTransforms.hpp"
#include "..\Entry\geometry.hpp"
// EndHack

#include "ScanOperationInternal.hpp"
#include "srgb.hpp"

#include "vgahash.hpp"
#include "formatconverter.hpp"
#include "alphablender.hpp"
#include "httables.hpp"
#include "output.hpp"
#include "bicubic.hpp"
#include "nearestneighbor.hpp"
#include "aarasterizer.hpp"
#include "line.hpp"
#include "stretch.hpp"

// Hack:
// font stuff

#define _NO_DDRAWINT_NO_COM

#include "..\fondrv\tt\ttfd\fontddi.h"
#include "..\Entry\fontface.hpp"
#include "..\Entry\facerealization.hpp"
#include "..\Entry\aatext.hpp"
// EndHack
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\line.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Line.hpp
*
* Abstract:
*
* Definition of the classes used for drawing one-pixel-wide lines. 
*
* History:
*
*   3/31/1999 AMatos
*       Created it
*   9/17/1999 AGodfrey
*       Separated aliased from antialiased
*
\**************************************************************************/

#ifndef LINE_HPP
#define LINE_HPP

// If line coordinate rounding is NOT to be dependent on line direction,
// then define the following (see Office 10 bug 281816).  The original
// behavior of the DDA is to have rounding dependent on line direction,
// so don't define the following if you want that behavior.
#define LINEADJUST281816

// This class implements drawing of solid one-pixel wide lines. 
// The lines can be aliased or anti-aliased and supports clipping. 
// The class keeps all the DDA state as member variables. Note that 
// currently it must be declared on the stack because of the Real 
// member (!!!Take this out) 

class OnePixelLineDDAAliased
{

public:

    // General members, used by aliased and anti-aliased 
    // drawing. 

    BOOL IsXMajor;                  
    BOOL Flipped;                  // Set when the end-points are switched
    INT  DMajor, DMinor;           // Deltas
    INT  MinorDir;                 // 1 if minor is increasing and -1 if not. 
    INT  MajorStart, MajorEnd;     // Major limits. 
    INT  MinorStart, MinorEnd;     // Minor limits. 
    REAL Slope;                    // Slope and its inverse. 
    REAL InvSlope;
    ARGB Color;                    // The solid color in ARGB format. 
    INT  ErrorUp;                  // Increase in the error
    INT  ErrorDown;                // Decrease when steping
    BOOL IsEndExclusive;           

    // Aliased specific 
    
    INT Error;                     // The current error for aliased lines. 

    // Used for clipping 

    INT MajorIn;                    // The limits of the clipping rectangle. 
    INT MajorOut;
    INT MinorIn;
    INT MinorOut; 

    // Index of the drawing function to be used. 

    INT DrawFuncIndex; 
    
    // Maximum width of the clipping rectangle in pixels.
    
    INT MaximumWidth;

public: 

    // Public Functions 

    BOOL     SetupAliased();
    BOOL     SetupCommon( GpPointF *point1, GpPointF *point2, BOOL drawLast, INT width );
    VOID     DrawXMajor(DpScanBuffer *scan); 
    VOID     DrawYMajor(DpScanBuffer *scan); 
    VOID     DrawXMajorClip(DpScanBuffer *scan); 
    VOID     DrawYMajorClip(DpScanBuffer *scan); 
    BOOL     IsInDiamond( INT xFrac, INT yFrac, BOOL slopeIsOne, 
                BOOL slopeIsPosOne );
    BOOL     ClipRectangle(const GpRect* clipRect);
    BOOL     StepUpAliasedClip();
};

    // Antialiased lines are usually drawn using aarasterizer.cpp 
    // rather than aaline.cpp.  If aaline.cpp is to be used, define
    // AAONEPIXELLINE_SUPPORT

#ifdef AAONEPIXELLINE_SUPPORT

class OnePixelLineDDAAntiAliased
{

public:

    // General members, used by aliased and anti-aliased 
    // drawing. 

    BOOL IsXMajor;                  
    BOOL Flipped;                  // Set when the end-points are switched
    INT  DMajor, DMinor;           // Deltas
    INT  MinorDir;                 // 1 if minor is increasing and -1 if not. 
    INT  MajorStart, MajorEnd;     // Major limits. 
    INT  MinorStart, MinorEnd;     // Minor limits. 
    REAL Slope;                    // Slope and its inverse. 
    REAL InvSlope;
    ARGB Color;                    // The solid color in ARGB format. 
    INT  ErrorUp;                  // Increase in the error
    INT  ErrorDown;                // Decrease when steping
    BOOL IsEndExclusive;           

    // AntiAliased specific 

    REAL InvDelta;                  // The inverse of the major delta, needed 
                                    // to calculate the 4 end points of the 
                                    // aa line. 
    REAL LineLength; 

    // An antialised line is drawed as 2 or three common lines. The dda state
    // must be kept for each. All variables that end with First refer to the
    // first one of this line, and all that end with Last refers to the last. 

    INT  ErrorFirst;                // The DDA error.                
    INT  ErrorLast; 
    INT  FracStart;                 // The fraction of the start and end 
    INT  FracEnd;                   // points that are covered due to the cap.  
    INT  MinorFirst;                // The minor position of each DDA. 
    INT  MinorLast; 
    INT  MajorFirst;                // The major position of each DDA
    INT  MajorLast;
    INT  SwitchFirstLast;           // Specifies if the first and last DDAs 
                                    // should be switched, which is simpler in 
                                    // some cases for the x-major line. 
    INT  AlphaFirst;                // The currently calculated coverage for
    INT  AlphaLast;                 // each DDA. 
    INT  AlphaMid; 
    INT  AlphaBiasFirst;            // Bias for calculating the coverage. 
    INT  AlphaBiasLast; 

    // Used for clipping 

    INT MajorIn;                    // The limits of the clipping rectangle. 
    INT MajorOut;
    INT MinorIn;
    INT MinorOut; 

    // Index of the drawing function to be used. 

    INT DrawFuncIndex; 

public: 

    // Public Functions 

    BOOL     SetupAntiAliased();
    BOOL     SetupCommon( GpPointF *point1, GpPointF *point2, BOOL drawLast );
    VOID     DrawXMajor(DpScanBuffer *scan); 
    VOID     DrawYMajor(DpScanBuffer *scan); 
    VOID     DrawXMajorClip(DpScanBuffer *scan); 
    VOID     DrawYMajorClip(DpScanBuffer *scan); 
    BOOL     ClipRectangle(const GpRect* clipRect);
};

#endif  // AAONEPIXELLINE_SUPPORT
                                             
#endif  // LINE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\palettemap.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Abstract:
*
*   Object which maps one palette to another.
*
*   It only maps colors which match exactly - its purpose is to deal
*   with, e.g., the halftone palette which has identical colors on different
*   platforms, but colors may be in different positions.
*
* Revision History:
*
*   12/09/1999 ericvan
*       Created it.
*   01/20/2000 agodfrey
*       Moved it from Imaging\Api. Renamed it to EpPaletteMap.
*
\**************************************************************************/

#ifndef __PALETTEMAP_HPP
#define __PALETTEMAP_HPP

class EpPaletteMap;

class EpPaletteMap
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagPaletteMap : ObjectTagInvalid;
    }

private:
    UINT        uniqueness;
    BYTE        translate[256];
    BOOL        isVGAOnly;
    
public:
    VOID
    CreateFromColorPalette(
        ColorPalette *palette
        );
    
    EpPaletteMap(
        HDC hdc, 
        ColorPalette **palette = NULL,
        BOOL isDib8 = FALSE);
    
    ~EpPaletteMap();
    
    VOID UpdateTranslate(
        HDC hdc, 
        ColorPalette **palette = NULL);
    
    VOID UpdateTranslate();
    
    VOID SetUniqueness(UINT Uniqueness)
    {
        uniqueness = Uniqueness;
    }
    
    UINT GetUniqueness()
    {
        return uniqueness;
    }
    
    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagPaletteMap) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid PaletteMap");
        }
    #endif

        return (Tag == ObjectTagPaletteMap);
    }

    __forceinline BYTE Translate(BYTE i) const
    {
        return translate[i];
    }
    
    BOOL IsVGAOnly() const
    {
        return isVGAOnly;
    }

    const BYTE *GetTranslate() const
    {
        return translate;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\scan.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Abstract:
*
*   Contains all the 32-bit scan-buffer routines for the default supported
*   bitmap formats.
*
* Revision History:
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Scan class helper function that SrcOver alpha blends two ARGB buffers.
*
* Arguments:
*
*   [IN] driver - Driver interface
*   [IN] context - Drawing context
*   [IN] surface - Destination surface
*   [OUT] nextBuffer - Points to a EpScan:: type function to return
*                      the next buffer
*   [IN] scanType - The type of scan.
*   [IN] pixFmtGeneral - the input pixel format for the color data,
*          in the "Blend" and "CT" scan types.
*   [IN] pixFmtOpaque - the input pixel format for the color data,
*          in the "Opaque" scan type.
*   [IN] solidColor - the solid fill color for "*SolidFill" scan types.
*
* Return Value:
*
*   FALSE if all the necessary buffers couldn't be created
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

BOOL
EpScanEngine::Start(
    DpDriver *driver,
    DpContext *context,
    DpBitmap *surface,
    NEXTBUFFERFUNCTION *nextBuffer,
    EpScanType scanType,                  
    PixelFormatID pixFmtGeneral,
    PixelFormatID pixFmtOpaque,
    ARGB solidColor
    )
{
    // Inherit initialization
    
    EpScan::Start(
        driver, 
        context, 
        surface, 
        nextBuffer,
        scanType,
        pixFmtGeneral,
        pixFmtOpaque,
        solidColor
    );    
    
    // DIBSection destinations don't have an alpha channel
    
    ASSERT(surface->SurfaceTransparency == TransparencyNoAlpha);
    
    Surface = surface;

    if(surface->Type == DpBitmap::D3D)
    {
        DDSURFACEDESC2             ddsd;

        memset(&ddsd, 0, sizeof(ddsd));
         ddsd.dwSize = sizeof(ddsd);

        HRESULT err;

        err = Surface->DdrawSurface7->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL);
        if(err != DD_OK)
            return(FALSE);

        Surface->Bits = ddsd.lpSurface;
        Surface->Delta = ddsd.lPitch;
    }

    Dst = NULL;
    Stride = surface->Delta;
    Bits = (BYTE*) surface->Bits;
    PixelSize = GetPixelFormatSize(surface->PixelFormat) >> 3;

    // [agodfrey] This Scan class is only designed for use with formats
    // which are supported natively, so it ignores the DIBSection and
    // corresponding PixelFormatID returned by GetScanBuffers.

    PixelFormatID dstFormat = surface->PixelFormat;

    ASSERTMSG(dstFormat != PIXFMT_UNDEFINED,(("Unexpected surface format")));

    *nextBuffer = (NEXTBUFFERFUNCTION) EpScanEngine::NextBuffer;

    if (!driver->Device->GetScanBuffers(
        surface->Width, 
        NULL, 
        NULL, 
        NULL, 
        Buffers)
       )
    {
        return NULL;
    }
  
    // initialize the AlphaBlenders.

    BlenderConfig[0].Initialize(
        dstFormat,
        context,
        context->Palette, 
        Buffers,
        TRUE,
        FALSE,
        solidColor
    );
    
    BlenderConfig[1].Initialize(
        dstFormat, 
        context,
        context->Palette, 
        Buffers,
        TRUE,
        FALSE,
        solidColor
    );
    
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Flushes the previous buffer (if there was), and returns the
*   next buffer for doing a SrcOver blend.
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

VOID *EpScanEngine::NextBuffer(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    if (updateWidth != 0)
    {
        // Make sure we're not drawing outside the bounds of the surface.
        // If these ASSERTs are triggered, the clipping code is broken.
        // This class absolutely must have input clipped to the surface
        // bounds otherwise we will AV writing on bad memory, or corrupt some
        // other data structure.
        
        ASSERT( CurrentX >= 0 );
        ASSERT( CurrentY >= 0 );
        ASSERT( CurrentX + updateWidth <= Surface->Width );
        ASSERT( CurrentY < Surface->Height );
        
        // Handle the previous scanline segment.
        
        BlenderConfig[LastBlenderNum].AlphaBlender.Blend(
            Dst, 
            Buffers[3], 
            updateWidth, 
            CurrentX - DitherOriginX, 
            CurrentY - DitherOriginY,
            static_cast<BYTE *>(Buffers[4])
        );
    }
        
    // Now move on to processing this scanline segment.
    // The actual blend will be done on the next call through this routine
    // when we know the width and the bits have been set into the buffer
    // we're returning.
    
    LastBlenderNum = blenderNum;
    
    // Remember the x and y for the brush offset (halftone & dither).
    
    CurrentX = x;
    CurrentY = y;
    
    // Calculate the destination for the scan:
    
    Dst = Bits + (y * Stride) + (x * PixelSize);

    return (Buffers[3]);
}

/**************************************************************************\
*
* Function Description:
*
*   Denotes the end of the use of the scan buffer.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
EpScanEngine::End(
    INT updateWidth
    )
{
    // Flush the last scan:

    NextBuffer(0, 0, 0, updateWidth, 0);

    if(Surface->Type == DpBitmap::D3D)
    {
        Surface->DdrawSurface7->Unlock(NULL);
        Surface->Bits = NULL;
        Surface->Delta = 0;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Scan class helper function that SrcOver alpha blends two ARGB buffers.
*
* Arguments:
*
*   [IN] driver - Driver interface
*   [IN] context - Drawing context
*   [IN] surface - Destination surface
*   [OUT] nextBuffer - Points to a EpScan:: type function to return
*                      the next buffer
*   [IN] scanType - The type of scan.
*   [IN] pixFmtGeneral - the input pixel format for the color data,
*          in the "Blend" and "CT" scan types.
*   [IN] pixFmtOpaque - the input pixel format for the color data,
*          in the "Opaque" scan type.
*   [IN] solidColor - the solid fill color for "*SolidFill" scan types.
*
* Return Value:
*
*   FALSE if all the necessary buffers couldn't be created
*
* History:
*
*   09/22/1999 gilmanw
*       Created it using EpScanEngine as a template
*
\**************************************************************************/

BOOL
EpScanBitmap::Start(
    DpDriver *driver,
    DpContext *context,
    DpBitmap *surface,
    NEXTBUFFERFUNCTION *nextBuffer,
    EpScanType scanType,                  
    PixelFormatID pixFmtGeneral, 
    PixelFormatID pixFmtOpaque,
    ARGB solidColor
    )
{
    // Inherit initialization
    
    EpScan::Start(
        driver, 
        context, 
        surface, 
        nextBuffer,
        scanType,
        pixFmtGeneral, 
        pixFmtOpaque,
        solidColor
    );    
    
    GpStatus status;
    BOOL writeOnly = FALSE;
    GpCompositingMode compositingMode = context->CompositingMode;
    
    Surface = surface;

    if (scanType == EpScanTypeOpaque)
    {
        writeOnly = TRUE;
    }
    else
    {
        // Work out if this operation will write transparent pixels (alpha != 1)
        // into the surface for the first time.

        switch (surface->SurfaceTransparency)
        {
        case TransparencyUnknown:
        case TransparencyNoAlpha:
        break;
        
        case TransparencyOpaque:
            // If the surface contains only opaque pixels, the SourceOver
            // operation will produce only opaque pixels. So for SourceOver,
            // a transition from TransparencyOpaque to TransparencyUnknown is
            // impossible.
            
            if (   (scanType == EpScanTypeBlend)
                && (compositingMode == CompositingModeSourceOver))
            {
                break;
            }
            
            // Else, fall through:
        
        case TransparencySimple:
            // !!![agodfrey]: Theoretically, if the destination pixel format
            //    is 1555, we could set it to 'TransparencySimple' here.
            
            surface->SurfaceTransparency = TransparencyUnknown;
            Bitmap->SetTransparencyHint(surface->SurfaceTransparency);
            break;
            
        default:
            RIP(("Unrecognized surface transparency"));    
            break;
        }
    }

    // Pick the appropriate blending function based on the format of the
    // bitmap.
    
    ASSERTMSG(Bitmap != NULL, ("EpScanBitmap not initialized"));

    PixelFormatID dstFormat;
    if (FAILED(Bitmap->GetPixelFormatID(&dstFormat)))
        return FALSE;

    switch (dstFormat)
    {
    case PIXFMT_16BPP_RGB555:
    case PIXFMT_16BPP_RGB565:
    case PIXFMT_24BPP_RGB:
    case PIXFMT_32BPP_RGB:
    case PIXFMT_32BPP_ARGB:
    case PIXFMT_24BPP_BGR:
    case PIXFMT_32BPP_PARGB:

        // Since we're doing just one lock of the whole image, we have
        // to allow read-modify-write since only a portion of the bitmap
        // may be written.

        BitmapLockFlags = (IMGLOCK_WRITE | IMGLOCK_READ);

        *nextBuffer = (NEXTBUFFERFUNCTION) EpScanBitmap::NextBufferNative;
        EndFunc = (SCANENDFUNCTION) EpScanBitmap::EndNative;

        status = Bitmap->LockBits(NULL, BitmapLockFlags,
                                  dstFormat, &LockedBitmapData);
        if (status == Ok)
        {
            CurrentScan = NULL;
            PixelSize = GetPixelFormatSize(dstFormat) >> 3;
            break;
        }

        // else fall into the generic case and use 32bpp ARGB

    default:

        // When locking a scanline at a time and the mode is SourceCopy,
        // the read is unnecessary.

        if (writeOnly)
        {
            BitmapLockFlags = IMGLOCK_WRITE;
        }
        else
        {
            BitmapLockFlags = (IMGLOCK_WRITE | IMGLOCK_READ);
        }
    
        dstFormat = PIXFMT_32BPP_ARGB;

        *nextBuffer = (NEXTBUFFERFUNCTION) EpScanBitmap::NextBuffer32ARGB;
        EndFunc = (SCANENDFUNCTION) EpScanBitmap::End32ARGB;

        break;
    }

    // Allocate the temporary buffers. 
    // Buffers[3] will be given to the caller to be used to pass scans to us.
    // Buffers[4] will be used for ClearType data.

    if (Buffers[0] == NULL)
    {
        Size bitmapSize;
        status = Bitmap->GetSize(&bitmapSize);

        if (status == Ok)
        {
            Width  = bitmapSize.Width;
            Height = bitmapSize.Height;

            Buffers[0] = GpMalloc(sizeof(ARGB64) * bitmapSize.Width * 5);
            
            if (Buffers[0])
            {
                int i;
                for (i=1;i<5;i++)
                {
                    Buffers[i] = static_cast<BYTE *>(Buffers[i-1]) + 
                                 sizeof(ARGB64) * bitmapSize.Width;
                }
            }
            else
            {
                ONCE(WARNING(("(once) Buffer allocation failed")));
                return FALSE;
            }
        }
        else
        {
            ONCE(WARNING(("(once) GetSize failed")));
            return FALSE;
        }
    }
    
    // initialize the AlphaBlenders.

    BlenderConfig[0].Initialize(
        dstFormat,
        context,
        context->Palette, 
        Buffers,
        TRUE,
        FALSE,
        solidColor
    );
    
    BlenderConfig[1].Initialize(
        dstFormat, 
        context,
        context->Palette, 
        Buffers,
        TRUE,
        FALSE,
        solidColor
    );
    
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   NextBuffer function used when we have low-level functions that match
*   native format of the GpBitmap and we can read/write directly into the
*   bitmap bits.
*
*   Flushes the previous buffer (if there was), and returns the
*   next buffer for doing a SrcOver blend.
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   09/22/1999 gilmanw
*       Created it using EpScanEngine as a template
*
\**************************************************************************/

VOID *EpScanBitmap::NextBufferNative(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    // Flush the previous buffer:

    if ((updateWidth != 0) && (CurrentScan != NULL))
    {
        ASSERTMSG(Buffers[0] != NULL, ("no buffers"));
        ASSERTMSG(updateWidth <= Width, ("updateWidth too big"));

        // Handle the previous scanline segment.
        
        BlenderConfig[LastBlenderNum].AlphaBlender.Blend(
            CurrentScan,
            Buffers[3], 
            updateWidth, 
            CurrentX - DitherOriginX,
            CurrentY - DitherOriginY,
            static_cast<BYTE *>(Buffers[4])
        );
    }
    
    // Now move on to processing this scanline segment.
    // The actual blend will be done on the next call through this routine
    // when we know the width and the bits have been set into the buffer
    // we're returning.
    
    LastBlenderNum = blenderNum;

    // Remember the x and y for the brush offset (halftone & dither).
    
    CurrentX = x;
    CurrentY = y;
    
    // Get the next destination scan:

    CurrentScan = NULL;

    // Check that surface clipping has been done properly.
    
    if((y >= 0) && (y < Height) && (x >= 0) && (x < Width))
    {
        // Clip against the right edge of the bitmap. newWidth is an upper
        // bound only - not guaranteed to be clipped.
        
        if (newWidth > (Width - x))
        {
            newWidth = Width - x;
        }
    
        if (newWidth > 0)
        {
            CurrentScan = static_cast<VOID *>
                            (static_cast<BYTE *>(LockedBitmapData.Scan0)
                             + (y * LockedBitmapData.Stride)
                             + (x * PixelSize));
        }
    }
    else
    {
        // If we hit this, we're hosed. The OutputSpan routines in the
        // DpOutputSpan classes are built assuming correct clipping (at least
        // to the data buffer) and hence, if we hit this assert, we're going 
        // to crash horibly later writing all over memory when we start writing
        // outside of the bounds of the destination allocation.
    
        // if you're here, someone broke clipping or the dpi computation.
    
        ASSERTMSG(!((y >= 0) && (y < Height) && (x >= 0) && (x < Width)),
                  (("EpScanBitmap::NextBufferNative: x, y out of bounds")));

    }

    return (Buffers[3]);
}

/**************************************************************************\
*
* Function Description:
*
*   Generic NextBuffer function that accesses GpBitmap bits
*   via GpBitmap::Lock/UnlockBits for each scan.
*
*   Flushes the previous buffer (if there was), and returns the
*   next buffer for doing a SrcOver blend.
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   09/22/1999 gilmanw
*       Created it using EpScanEngine as a template
*
\**************************************************************************/

VOID *EpScanBitmap::NextBuffer32ARGB(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    // Flush the previous buffer:

    if (updateWidth != 0 && BitmapLocked)
    {
        ASSERTMSG(Buffers[0] != NULL, ("no buffers"));
        ASSERTMSG(LockedBitmapData.Scan0 != NULL, ("no previous buffer"));

        // Handle the previous scanline segment.
        
        BlenderConfig[LastBlenderNum].AlphaBlender.Blend(
            LockedBitmapData.Scan0, 
            Buffers[3], 
            updateWidth, 
            CurrentX - DitherOriginX, 
            CurrentY - DitherOriginY,
            static_cast<BYTE *>(Buffers[4])
        );

        Bitmap->UnlockBits(&LockedBitmapData);
        BitmapLocked = FALSE;
    }
    else if (BitmapLocked)
    {
        EpScanBitmap::Flush();
    }

    // Now move on to processing this scanline segment.
    // The actual blend will be done on the next call through this routine
    // when we know the width and the bits have been set into the buffer
    // we're returning.
    
    LastBlenderNum = blenderNum;
    
    // Remember the x and y for the brush offset (halftone & dither).
    
    CurrentX = x;
    CurrentY = y;
    
    // Lock the next destination:

    // Check that surface clipping has been done properly.

    if((y >= 0) && (y < Height) && (x >= 0) && (x < Width))
    {
        // Clip against the right edge of the bitmap. newWidth is an upper
        // bound only - not guaranteed to be clipped. LockBits needs it
        // to be clipped.
        
        if (newWidth > (Width - x))
        {
            newWidth = Width - x;
        }
    
        if (newWidth > 0)
        {
            GpRect nextRect(x, y, newWidth, 1);
    
            GpStatus status = Bitmap->LockBits(
                &nextRect, 
                BitmapLockFlags,
                PixelFormat32bppARGB, 
                &LockedBitmapData
            );
    
            if (status == Ok)
                BitmapLocked = TRUE;
        }
    
    } 
    else
    {
        // If we hit this, we're hosed. The OutputSpan routines in the
        // DpOutputSpan classes are built assuming correct clipping (at least
        // to the data buffer) and hence, if we hit this assert, we're going 
        // to crash horibly later writing all over memory when we start writing
        // outside of the bounds of the destination allocation.
    
        // if you're here, someone broke clipping or the dpi computation.
        
        ASSERTMSG(!((y >= 0) && (y < Height) && (x >= 0) && (x < Width)),
                  (("EpScanBitmap::NextBufferNative: x, y out of bounds")));
    }

    return (Buffers[3]);
}

/**************************************************************************\
*
* Function Description:
*
*   Denotes the end of the use of the scan buffer.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* History:
*
*   09/22/1999 gilmanw
*       Created it using EpScanEngine as a template
*
\**************************************************************************/

VOID
EpScanBitmap::End32ARGB(
    INT updateWidth
    )
{
    // Flush the last scan:

    EpScanBitmap::NextBuffer32ARGB(0, 0, 0, updateWidth, 0);
}

VOID
EpScanBitmap::EndNative(
    INT updateWidth
    )
{
    // Flush the last scan and release bitmap access:

    EpScanBitmap::NextBufferNative(0, 0, 0, updateWidth, 0);
    Bitmap->UnlockBits(&LockedBitmapData);
}

VOID
EpScanBitmap::End(
    INT updateWidth
    )
{
    (this->*EndFunc)(updateWidth);

    // Lock/UnlockBitmap has to be very aggressive about setting
    // TransparancyUnknown in the GpBitmap since the caller could be
    // doing anything to the alpha channel.  However, the EpScanBitmap
    // knows what it is doing, so the surface->SurfaceTransparency is
    // more accurate.

    Bitmap->SetTransparencyHint(Surface->SurfaceTransparency);
}

/**************************************************************************\
*
* Function Description:
*
*   Flush any batched rendering and optionally wait for rendering to finish.
*
* Return Value:
*
*   NONE
*
* History:
*
*   09/22/1999 gilmanw
*       Created it using EpScanEngine as a template
*
\**************************************************************************/

VOID EpScanBitmap::Flush()
{
    if (BitmapLocked && Bitmap)
    {
        Bitmap->UnlockBits(&LockedBitmapData);
        BitmapLocked = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\output.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Output.hpp
*
* Abstract:
*
*   Classes to output a span for a particular brush type
*
* Created:
*
*   2/24/1999 DCurtis
*
\**************************************************************************/

#ifndef _OUTPUT_HPP
#define _OUTPUT_HPP

void ApplyWrapMode(INT WrapMode, INT &x, INT &y, INT w, INT h);

//--------------------------------------------------------------------------
// Solid color output
//--------------------------------------------------------------------------

class DpOutputSolidColorSpan : public DpOutputSpan
{
public:
    ARGB            Argb;
    DpScanBuffer *  Scan;

public:
    DpOutputSolidColorSpan(ARGB argb, DpScanBuffer * scan)
    {
        Argb = argb;
        Scan = scan;
    }

    GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

    virtual BOOL IsValid() const { return TRUE; }
    virtual DpScanBuffer* GetScanBuffer(){ return Scan; }
};

//--------------------------------------------------------------------------
// Gradient output base class
//--------------------------------------------------------------------------

class DpOutputGradientSpan : public DpOutputSpan
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagOutputGradientSpan : ObjectTagInvalid;
    }

public:
    virtual BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagOutputGradientSpan) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid OutputGradientSpan");
        }
    #endif

        return (Tag == ObjectTagOutputGradientSpan);
    }

public:
    DpScanBuffer *  Scan;
    const GpBrush* Brush;
    INT BrushType;
    INT WrapMode;
    INT CompositingMode;
    GpRectF BrushRect;
    GpMatrix WorldToDevice;
    GpMatrix DeviceToWorld;
    REAL A[4], R[4], G[4], B[4];

public:

    DpOutputGradientSpan() { SetValid (TRUE); }

    DpOutputGradientSpan(
        const GpElementaryBrush *brush,
        DpScanBuffer * scan,
        DpContext* context
        );

    ~DpOutputGradientSpan()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

    DpScanBuffer* GetScanBuffer(){ return Scan; }

protected:

    VOID InitDefaultColorArrays(const GpElementaryBrush* brush)
    {
        const GpGradientBrush *gradBrush
            = static_cast<const GpGradientBrush*> (brush);

        if(gradBrush->UsesDefaultColorArray())
        {
            GpColor colors[4];  // Default array is up to
                                // 4 colors.

            gradBrush->GetColors(colors);
            INT num = gradBrush->GetNumberOfColors();

            for(INT i = 0; i < num; i++)
            {
                ARGB argb = colors[i].GetPremultipliedValue();
                A[i] = (REAL)GpColor::GetAlphaARGB(argb);
                R[i] = (REAL)GpColor::GetRedARGB(argb);
                G[i] = (REAL)GpColor::GetGreenARGB(argb);
                B[i] = (REAL)GpColor::GetBlueARGB(argb);
            }
        }
    }

};

//--------------------------------------------------------------------------
// Handle one-dimension gradients (we call 'em 'textures' for reasons that
// should be obvious)
//--------------------------------------------------------------------------

class DpOutputOneDGradientSpan : public DpOutputGradientSpan
{
protected:
    INT      OneDDataMultiplier;
    INT      OneDDataCount;
    ARGB*    OneDData;
    BOOL     IsHorizontal;
    BOOL     IsVertical;

public:

    DpOutputOneDGradientSpan()
    {
        Initialize();
    }

    DpOutputOneDGradientSpan(
        const GpElementaryBrush *brush,
        DpScanBuffer *scan,
        DpContext *context,
        BOOL isHorizontal = TRUE,
        BOOL isVertical = FALSE
        );

    ~DpOutputOneDGradientSpan();

    virtual GpStatus OutputSpan(
        INT y,
        INT xMin,
        INT xMax
        );

protected:
    VOID Initialize()
    {
        OneDDataMultiplier = 1;
        OneDDataCount = 0;
        OneDData = NULL;
        IsHorizontal = FALSE;
        IsVertical = FALSE;
        SetValid(FALSE);
    }

    GpStatus AllocateOneDData(BOOL isHorizontal,BOOL isVertical);
    VOID SetupRectGradientOneDData();
    VOID SetupRadialGradientOneDData();

};

//--------------------------------------------------------------------------
// Linear gradients
//--------------------------------------------------------------------------

// The AGRB64TEXEL structure is sort of funky in order to optimize the
// inner loop of our C-code linear gradient routine.

struct AGRB64TEXEL      // Note that it's 'AGRB', not 'ARGB'
{
    UINT32 A00rr00bb;   // Texel's R and B components
    UINT32 A00aa00gg;   // Texel's A and G components
};

// # of pixels in our 1-D texture:

//#define ONEDMAXIMUMTEXELS 32
#define ONEDMAXIMUMTEXELS 1024


// # of fractional bits that we iterate across the texture with:

#define ONEDNUMFRACTIONALBITS 16

// Get the integer portion of our fixed point texture coordinate, using
// a floor function:

#define ONEDGETINTEGERBITS(x) ((x) >> ONEDNUMFRACTIONALBITS)

// Get the 8-bit fractional portion of our fixed point texture coordinate.
// We could round, but I can't be bothered:

#define ONEDGETFRACTIONAL8BITS(x) ((x) >> ((ONEDNUMFRACTIONALBITS - 8)) & 0xff)

class DpOutputLinearGradientSpan : public DpOutputGradientSpan
{
protected:

    GpMatrix DeviceToNormalized;    // Transforms from the device-space brush
                                    //   parallogram to fixed-point-scaled
                                    //   brush texture coordinates
    INT32 M11;                      // Fixed point representation of
                                    //   M11 element of DeviceToNormalized
    INT32 M21;                      // Fixed point representation of
                                    //   M21 element of DeviceToNormalized
    INT32 Dx;                       // Fixed point representation of
                                    //   Dx element of DeviceToNormalized
    INT32 XIncrement;               // Fixed point increment (in format
                                    //   defined by ONEDNUMFRACTIONALBITS)
                                    //   representing texture x-distance
                                    //   traveled for every x pixel increment
                                    //   in device space
    UINT32 IntervalMask;            // One less than the number of texels in
                                    //   our texture
    UINT32 NumberOfIntervalBits;    // log2 of the number of texels

    union
    {
        ULONGLONG StartTexelArgb[ONEDMAXIMUMTEXELS];
                                    // Array of colors (at 16-bits per channel,
                                    //   with zeroes in the significant bytes)
                                    //   representing the start color of the
                                    //   linear approximation at interval 'x'
                                    //   (in A-R-G-B format)
        AGRB64TEXEL StartTexelAgrb[ONEDMAXIMUMTEXELS];
                                    // Similarly, but for the non-MMX renderer
                                    //   (in A-G-R-B format)
    };
    union
    {
        ULONGLONG EndTexelArgb[ONEDMAXIMUMTEXELS];
                                    // End color for the interval (in A-R-G-B
                                    //   format)
        AGRB64TEXEL EndTexelAgrb[ONEDMAXIMUMTEXELS];
                                    // Similarly, but for the non-MMX renderer
                                    //   (in A-G-R-B format)
    };

public:

    DpOutputLinearGradientSpan(
        const GpElementaryBrush *brush,
        DpScanBuffer *scan,
        DpContext *context
        );

    virtual GpStatus OutputSpan(
        INT y,
        INT xMin,
        INT xMax
        );
};

//--------------------------------------------------------------------------
// Gradient special case - MMX
//--------------------------------------------------------------------------

class DpOutputLinearGradientSpan_MMX : public DpOutputLinearGradientSpan
{
public:

    DpOutputLinearGradientSpan_MMX(
        const GpElementaryBrush *brush,
        DpScanBuffer *scan,
        DpContext *context
        );

    virtual GpStatus OutputSpan(
        INT y,
        INT xMin,
        INT xMax
        );
};

//--------------------------------------------------------------------------
// Path gradients
//--------------------------------------------------------------------------

class DpOutputOneDPathGradientSpan : public DpOutputOneDGradientSpan
{
public:

    DpOutputOneDPathGradientSpan()
    {
        BLTransforms = NULL;
        Count = 0;
    }

    ~DpOutputOneDPathGradientSpan()
    {
        if(BLTransforms)
            delete[] BLTransforms;
    }

    DpOutputOneDPathGradientSpan(
        const GpElementaryBrush *brush,
        DpScanBuffer * scan,
        DpContext* context,
        BOOL isHorizontal = TRUE,
        BOOL isVertical = FALSE
        );

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

protected:
    VOID SetupPathGradientOneDData(BOOL gammaCorrect);

protected:
    GpBilinearTransform* BLTransforms;
    INT Count;
};

class DpTriangleData
{
friend class DpOutputTriangleGradientSpan;
friend class DpOutputPathGradientSpan;

private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagTriangleData : ObjectTagInvalid;
    }

    virtual BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagTriangleData) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid TriangleData");
        }
    #endif

        return (Tag == ObjectTagTriangleData);
    }

public:

    DpTriangleData();
    ~DpTriangleData()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }
    VOID SetTriangle(
        GpPointF& pt0, 
        GpPointF& pt1, 
        GpPointF& pt2,
        GpColor& color0, 
        GpColor& color1, 
        GpColor& color2,
        BOOL isPolygonMode = FALSE,
        BOOL isGammaCorrected = FALSE
    );
    GpStatus OutputSpan(ARGB* buffer, INT compositingMode,
                INT y, INT &xMin, INT &xMax);

private:
    BOOL GetXSpan(REAL y, REAL xmin, REAL xmax, REAL* x, GpPointF* s);
    BOOL SetXSpan(REAL y, REAL xmin, REAL xmax, REAL* x);

private:

    BOOL    IsPolygonMode;
    BOOL    GammaCorrect;
    INT     Index[3];
    REAL    X[3];
    REAL    Y[3];
    
    GpFColor128 Color[3];
    
    REAL    Falloff0;
    REAL    Falloff1;
    REAL    Falloff2;
    INT     BlendCount0;
    INT     BlendCount1;
    INT     BlendCount2;
    REAL*   BlendFactors0;
    REAL*   BlendFactors1;
    REAL*   BlendFactors2;
    REAL*   BlendPositions0;
    REAL*   BlendPositions1;
    REAL*   BlendPositions2;
    ARGB*   PresetColors;
    BOOL    UsesPresetColors;

    REAL    Xmin, Xmax;
    REAL    M[3];      // dx/dy
    REAL    DeltaY[3]; // Inverse of dy.

    PointF  STGradient[2];  // Cached starting and ending fractional values of
                            // the color gradients for the current XSpan

    REAL    XSpan[2];       // Cached X range covered by this triangle for
                            // the current value of Y being output
};

//--------------------------------------------------------------------------
// Triangle Gradients
//--------------------------------------------------------------------------

class DpOutputTriangleGradientSpan : public DpOutputGradientSpan
{
public:

    DpOutputTriangleGradientSpan() {}

    DpOutputTriangleGradientSpan(
        const GpElementaryBrush *brush,
        DpScanBuffer * scan,
        DpContext* context
        );

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

    DpScanBuffer* GetScanBuffer(){ return Scan; }

private:
    DpTriangleData Triangle;

};

//--------------------------------------------------------------------------
// Path Gradients
//--------------------------------------------------------------------------

class DpOutputPathGradientSpan : public DpOutputGradientSpan
{
public:
    INT         Count;
    DpTriangleData** Triangles;

public:

    DpOutputPathGradientSpan()
    {
        Count = 0;
        Triangles = NULL;
        SetValid(FALSE);
    }

    DpOutputPathGradientSpan(
        const GpElementaryBrush *brush,
        DpScanBuffer * scan,
        DpContext* context
        );

    virtual ~DpOutputPathGradientSpan();
    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

    DpScanBuffer* GetScanBuffer(){ return Scan; }

protected:

    VOID FreeData();
};

//--------------------------------------------------------------------------
// Textures
//--------------------------------------------------------------------------

class DpOutputBilinearSpan : public DpOutputSpan
{
protected:

    const GpBitmap *Bitmap;
    const DpBitmap *dBitmap;
    BitmapData BmpData;
    DpScanBuffer *Scan;
    WrapMode BilinearWrapMode;
    ARGB ClampColor;
    BOOL SrcRectClamp;

    GpRectF SrcRect;
    GpMatrix WorldToDevice;
    GpMatrix DeviceToWorld;

public:

    DpOutputBilinearSpan(
        const GpTexture *textureBrush,
        DpScanBuffer *scan,
        GpMatrix *worldToDevice,
        DpContext *context
        );

    DpOutputBilinearSpan(
        const DpBitmap *bitmap,
        DpScanBuffer *scan,
        GpMatrix *worldToDevice,
        DpContext *context,
        DpImageAttributes *imageAttributes
        );

    DpOutputBilinearSpan(
        DpBitmap* bitmap,
        DpScanBuffer * scan,
        DpContext* context,
        DpImageAttributes imageAttributes,
        INT numPoints,
        const GpPointF *dstPoints,
        const GpRectF *srcRect
        );

    virtual ~DpOutputBilinearSpan();

    virtual GpStatus OutputSpan(
        INT y,
        INT xMin,
        INT xMax
        );

    virtual BOOL IsValid() const
    {
        return ((dBitmap != NULL) || (Bitmap != NULL));
    }

    DpScanBuffer* GetScanBuffer()
    {
        return Scan;
    }
};

//--------------------------------------------------------------------------
// Textures - MMX
//
// The MMX code uses the same setup as the non-MMX, hence the reason
// we're derived from it.
//--------------------------------------------------------------------------

class DpOutputBilinearSpan_MMX : public DpOutputBilinearSpan
{
protected:

    BOOL TranslateMatrixValid; // TRUE if Dx, and Dy are valid
    BOOL ScaleMatrixValid;     // TRUE if M11-M22 are valid
    INT M11;                   // 16.16 fixed point representation of the
    INT M12;                   //   device-to-world transform
    INT M21;
    INT M22;
    INT Dx;
    INT Dy;

    INT UIncrement;         // Increment in texture space for every one-
    INT VIncrement;         //   pixel-to-the-right in device space

    INT ModulusWidth;       // Modulus value for doing tiling
    INT ModulusHeight;

    INT XEdgeIncrement;     // Edge condition increments.
    INT YEdgeIncrement;

public:

    VOID InitializeFixedPointState();

    DpOutputBilinearSpan_MMX(
        const GpTexture *textureBrush,
        DpScanBuffer *scan,
        GpMatrix *worldToDevice,
        DpContext *context
        ) : DpOutputBilinearSpan(textureBrush, scan, worldToDevice, context)
    {
        InitializeFixedPointState();
    }

    DpOutputBilinearSpan_MMX(
        const DpBitmap *bitmap,
        DpScanBuffer *scan,
        GpMatrix *worldToDevice,
        DpContext *context,
        DpImageAttributes *imageAttributes
        ) : DpOutputBilinearSpan(
            bitmap,
            scan,
            worldToDevice,
            context,
            imageAttributes
        )
    {
        InitializeFixedPointState();
    }

    virtual GpStatus OutputSpan(
        INT y,
        INT xMin,
        INT xMax
        );
        
    virtual BOOL IsValid() const
    {
        return (ScaleMatrixValid && DpOutputBilinearSpan::IsValid());
    }
};

//--------------------------------------------------------------------------
// Textures - Identity transform
//
// Actually, this object handles texture output for any translating
// transform, so long as the translate is integer.
//
//--------------------------------------------------------------------------

class DpOutputBilinearSpan_Identity : public DpOutputBilinearSpan
{
protected:

    INT Dx;
    INT Dy;

    BOOL PowerOfTwo;    // True if both texture dimensions power of two

public:

    DpOutputBilinearSpan_Identity(
        const GpTexture *textureBrush,
        DpScanBuffer * scan,
        GpMatrix *worldToDevice,
        DpContext *context
        ) : DpOutputBilinearSpan(textureBrush, scan, worldToDevice, context)
    {
        PowerOfTwo = !(BmpData.Width & (BmpData.Width - 1)) &&
                     !(BmpData.Height & (BmpData.Height - 1));

        // Compute the device-to-world transform (easy, eh?):

        Dx = -GpRound(worldToDevice->GetDx());
        Dy = -GpRound(worldToDevice->GetDy());
    }

    DpOutputBilinearSpan_Identity(
        const DpBitmap *bitmap,
        DpScanBuffer * scan,
        GpMatrix *worldToDevice,
        DpContext *context,
        DpImageAttributes *imageAttributes
        ) : DpOutputBilinearSpan(
            bitmap,
            scan,
            worldToDevice,
            context,
            imageAttributes
        )
    {
        PowerOfTwo = !(BmpData.Width & (BmpData.Width - 1)) &&
                     !(BmpData.Height & (BmpData.Height - 1));

        // Compute the device-to-world transform (easy, eh?):

        Dx = -GpRound(worldToDevice->GetDx());
        Dy = -GpRound(worldToDevice->GetDy());
    }

    virtual GpStatus OutputSpan(
        INT y,
        INT xMin,
        INT xMax
        );
};

//--------------------------------------------------------------------------
// Hatch brushes
//--------------------------------------------------------------------------

class DpOutputHatchSpan : public DpOutputSpan
{
public:
    DpScanBuffer *  Scan;
    ARGB ForeARGB;
    ARGB BackARGB;
    ARGB AverageARGB;
    BYTE Data[8][8];

protected:    
    INT m_BrushOriginX;
    INT m_BrushOriginY;
    

public:
    DpOutputHatchSpan(
        const GpHatch *hatchBrush,
        DpScanBuffer * scan,
        DpContext* context
        );

    virtual ~DpOutputHatchSpan()
    {
    }

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

    virtual BOOL IsValid() const { return TRUE; }
    DpScanBuffer* GetScanBuffer(){ return Scan; }

};

class DpOutputStretchedHatchSpan : public DpOutputHatchSpan
{
public:
    DpOutputStretchedHatchSpan(
        const GpHatch *hatchBrush,
        DpScanBuffer * scan,
        DpContext* context,
        INT scaleFactor
        ) : DpOutputHatchSpan(hatchBrush,
                              scan,
                              context)
    {
        ScaleFactor = scaleFactor;
    }
    
    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

private:
    INT ScaleFactor;
};

#endif // _OUTPUT_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\palettemap.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Abstract:
*
*   Object which maps one palette to another.
*
*   It only maps colors which match exactly - its purpose is to deal
*   with, e.g., the halftone palette which has identical colors on different
*   platforms, but colors may be in different positions.
*
* Revision History:
*
*   12/09/1999 ericvan
*       Created it.
*   01/20/2000 agodfrey
*       Moved it from Imaging\Api. Renamed it to EpPaletteMap.
*       Replaced the halftoning function pointer with 'isVGAOnly'.
*
\**************************************************************************/

#include "precomp.hpp"

//#define GDIPLUS_WIN9X_HALFTONE_MAP

#if defined(GDIPLUS_WIN9X_HALFTONE_MAP)

// The first array maps from our halftone color palette to the Windows 9x
// halftone color palette, while the second array does the reverse. Negative
// values indicate an unmatched color:
//
//   -1  no exact match (Win9x is missing 4 of our halftone colors)
//   -2  magic color

INT HTToWin9xPaletteMap[256] = {
      0,   1,   2,   3,   4,   5,   6,   7,
     -2,  -2,  -2,  -2, 248, 249, 250, 251,
    252, 253, 254, 255,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,
      0,  60,  95, 133, 161, 252,  33,  66,
    101, 166, 199,  -1,  39,  72, 107, 138,
    172, 205,  45,  78, 112, 129, 178, 211,
     51,  84, 118, 149, 184, 217, 250,  -1,
    123, 155, 190, 254,  29,  61,  96, 162,
    196,  -1,  34,  67, 102, 134, 167, 200,
     40,  73, 108, 139, 173, 206,  46,  79,
    113, 144, 179, 212,  52,  85, 119, 150,
    185, 218,  -1,  90, 124, 156, 191, 223,
     30,  62,  97, 135, 163, 197,  35,  68,
    103, 140, 168, 201,  41,  74, 109, 174,
    207, 230,  47,  80, 114, 145, 180, 213,
     53,  86, 151, 157, 186, 219,  57,  91,
    228, 192, 224, 232,  31,  63,  98, 131,
    164, 198,  36,  69, 104, 130, 169, 202,
     42,  75, 110, 141, 175, 208,  48,  81,
    115, 146, 181, 214,  54,  87, 120, 152,
    187, 220,  58,  92, 125, 158, 193, 225,
     32,  64,  99, 132, 165, 128,  37,  70,
    105, 136, 170, 203,  43,  76, 111, 142,
    176, 209,  49,  82, 116, 147, 182, 215,
     55,  88, 121, 153, 188, 221,  59,  93,
    126, 159, 194, 226, 249,  65, 100, 137,
    127, 253,  38,  71, 106, 143, 171, 204,
     44,  77, 227, 177, 210, 231,  50,  83,
    117, 148, 183, 216,  56,  89, 122, 154,
    189, 222, 251,  94, 229, 160, 195, 255
};

INT HTFromWin9xPaletteMap[256] = {
      0,   1,   2,   3,   4,   5,   6,   7,
     -2,  -2,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  76, 112, 148,
    184,  46,  82, 118, 154, 190, 226,  52,
     88, 124, 160, 196, 232,  58,  94, 130,
    166, 202, 238,  64, 100, 136, 172, 208,
    244, 142, 178, 214,  41,  77, 113, 149,
    185, 221,  47,  83, 119, 155, 191, 227,
     53,  89, 125, 161, 197, 233,  59,  95,
    131, 167, 203, 239,  65, 101, 137, 173,
    209, 245, 107, 143, 179, 215, 251,  42,
     78, 114, 150, 186, 222,  48,  84, 120,
    156, 192, 228,  54,  90, 126, 162, 198,
     60,  96, 132, 168, 204, 240,  66, 102,
    174, 210, 246,  72, 108, 180, 216, 224,
    189,  61, 157, 151, 187,  43,  85, 115,
    193, 223,  55,  91, 121, 163, 199, 229,
     97, 133, 169, 205, 241,  67, 103, 138,
    175, 211, 247,  73, 109, 139, 181, 217,
    253,  44,  79, 116, 152, 188,  49,  86,
    122, 158, 194, 230,  56,  92, 127, 164,
    200, 235,  62,  98, 134, 170, 206, 242,
     68, 104, 140, 176, 212, 248,  74, 110,
    145, 182, 218, 254,  80, 117, 153,  50,
     87, 123, 159, 195, 231,  57,  93, 128,
    165, 201, 236,  63,  99, 135, 171, 207,
    243,  69, 105, 141, 177, 213, 249, 111,
    146, 183, 219, 234, 144, 252, 129, 237,
    147,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -2,  -2,
     12,  13,  14,  15,  16,  17,  18,  19
};

#endif

BYTE
GetNearestColorIndex(
    GpColor color,
    ColorPalette *palette
    )
{
    INT i;
    BYTE nearestIndex = 0;
    INT nearestDistance = INT_MAX;

    // Note: This does not optimize for the exact match case because it's
    //       assumed we already did this check first.
    
    for (i = 0; i < (INT) palette->Count; i++)
    {
        // Compute the distance (squared) between colors:

        GpColor palColor = GpColor(palette->Entries[i]);

        INT r = (INT) color.GetRed() - (INT) palColor.GetRed();
        INT g = (INT) color.GetGreen() - (INT) palColor.GetGreen();
        INT b = (INT) color.GetBlue() - (INT) palColor.GetBlue();

        INT distance = (r * r) + (g * g) + (b * b);

        if (distance < nearestDistance)
        {
            nearestDistance = distance;
            nearestIndex = static_cast<BYTE>(i);

            if (nearestDistance == 0)
            {
                break;
            }
        }
    }

    return nearestIndex;
}

VOID
EpPaletteMap::CreateFromColorPalette(
    ColorPalette *palette
    )
{
    INT i;
    INT matchCount = 0;

#if defined(GDIPLUS_WIN9X_HALFTONE_MAP)

    // Check for the Win9x halftone palette:

    PALETTEENTRY *palEntry = Win9xHalftonePalette.palPalEntry;

    for (i = 0; i < 256; i++, palEntry++)
    {
        // Ignore magic or unmatched colors:

        if (HTFromWin9xPaletteMap[i] >= 0)
        {
            GpColor palColor(palette->Entries[i]);

            if ((palColor.GetRed() != palEntry->peRed) ||
                (palColor.GetGreen() != palEntry->peGreen) ||
                (palColor.GetBlue() != palEntry->peBlue))
            {
                break;
            }
        }
    }

    if (i == 256) // --- Win9x halftone palette ---
    {
        matchCount = 212;

        for (i = 0; i < 256; i++)
        {
            INT win9xIndex = HTToWin9xPaletteMap[i];

            if (win9xIndex >= 0)
            {
                translate[i] = static_cast<BYTE>(win9xIndex);
            }
            else
            {
                GpColor halftoneColor;

                if (win9xIndex == -1)
                {
                    halftoneColor =
                        GpColor(HTColorPalette.palPalEntry[i].peRed,
                                HTColorPalette.palPalEntry[i].peGreen,
                                HTColorPalette.palPalEntry[i].peBlue);
                }
                else
                {
                    ASSERT(win9xIndex == -2);
                    ASSERT((i >= 8) && (i <= 11));

                    COLORREF systemColor = Globals::SystemColors[i + 8];
                    
                    halftoneColor = GpColor(GetRValue(systemColor),
                                            GetGValue(systemColor),
                                            GetBValue(systemColor));
                }

                translate[i] = GetNearestColorIndex(halftoneColor,
                                                    palette);
            }
        }
    }
    else // --- Any other palette ---

#endif

    {
        for (i = 0; i < 256; i++)
        {
            GpColor color;
            
            if ((i > 11) || (i < 8))
            {
                color = GpColor(HTColorPalette.palPalEntry[i].peRed,
                                HTColorPalette.palPalEntry[i].peGreen,
                                HTColorPalette.palPalEntry[i].peBlue);
            }
            else
            {
                COLORREF systemColor = Globals::SystemColors[i + 8];
                
                color = GpColor(GetRValue(systemColor),
                                GetGValue(systemColor),
                                GetBValue(systemColor));
            }

            // First look for exact matches:
    
            INT j;

            for (j = 0; j < (INT) palette->Count; j++)
            {
                if (GpColor(palette->Entries[j]).IsEqual(color))
                {
                    // We found an exact match:

                    translate[i] = static_cast<BYTE>(j);

                    if (i >= 40)
                    {
                        matchCount++;
                    }

                    break;
                }
            }

            // If we didn't find an exact match, look for the nearest:

            if (j == (INT) palette->Count)
            {
                translate[i] = GetNearestColorIndex(color,
                                                    palette);
            }
        }
    }

    uniqueness = 0;

    // See comments in UpdateTranslate to see why we look for 212 colors.
    
    isVGAOnly = (matchCount >= 212) ? FALSE : TRUE;
}

EpPaletteMap::EpPaletteMap(HDC hdc, ColorPalette **palette, BOOL isDib8)
{
    // isDib8 is TRUE when the caller has already determined that the HDC
    // bitmap is an 8 bpp DIB section. If the caller hasn't determined, we
    // check here:

    if (!isDib8 && (GetDCType(hdc) == OBJ_MEMDC))
    {
        HBITMAP hbm = (HBITMAP) GetCurrentObject(hdc, OBJ_BITMAP);

        if (hbm)
        {
            DIBSECTION dibInfo;
            INT infoSize = GetObjectA(hbm, sizeof(dibInfo), &dibInfo);

            // Comment below copied from GpGraphics::GetFromGdiBitmap:
            //
            // WinNT/Win95 differences in GetObject:
            //
            // WinNT always returns the number of bytes filled, either
            // sizeof(BITMAP) or sizeof(DIBSECTION).
            //
            // Win95 always returns the original requested size (filling the
            // remainder with NULLs).  So if it is a DIBSECTION, we expect
            // dibInfo.dsBmih.biSize != 0; otherwise it is a BITMAP.

            if ((infoSize == sizeof(DIBSECTION)) &&
                (Globals::IsNt || dibInfo.dsBmih.biSize))
            {
                if (dibInfo.dsBmih.biBitCount == 8)
                {
                    isDib8 = TRUE;
                }
            }
        }
    }

    // If we've got an 8 bpp DIB section, extract its color table and create
    // the palette map from this. Otherwise, call UpdateTranslate which will
    // handle screen and compatible bitmaps.
    
    if (isDib8)
    {
        // Get the color table from the DIBSection

        RGBQUAD colorTable[256];
        GetDIBColorTable(hdc, 0, 256, colorTable);

        // Create a GDI+ ColorPalette object from it
        // Note: the reason we use "255" here is because
        // ColorPalette object already has 1 allocation for ARGB

        ColorPalette *newPalette =
            static_cast<ColorPalette *>(
                GpMalloc(sizeof(ColorPalette) + 255 * sizeof(ARGB)));

        if (newPalette)
        {
            newPalette->Flags = 0;
            newPalette->Count = 256;

            for (int i = 0; i < 256; i++)
            {
                newPalette->Entries[i] =
                    MAKEARGB(255,
                             colorTable[i].rgbRed,
                             colorTable[i].rgbGreen,
                             colorTable[i].rgbBlue);
            }

            CreateFromColorPalette(newPalette);

            if (palette)
            {
                *palette = newPalette;
            }
            else
            {
                GpFree(newPalette);
            }

            SetValid(TRUE);
            return;
        }

        SetValid(FALSE);
    }
    else
    {
        UpdateTranslate(hdc, palette);
    }
}

EpPaletteMap::~EpPaletteMap()
{
    SetValid(FALSE);    // so we don't use a deleted object
}

VOID EpPaletteMap::UpdateTranslate(HDC hdc, ColorPalette **palette)
{
    SetValid(FALSE);
    
    HPALETTE hSysPal = NULL;
    struct
    {
        LOGPALETTE logpalette;
        PALETTEENTRY palEntries[256];
    } pal;

    pal.logpalette.palVersion = 0x0300;
    
    // <SystemPalette>
    
    // !!! [agodfrey] On Win9x, GetSystemPaletteEntries(hdc, 0, 256, NULL) 
    //    doesn't do what MSDN says it does. It seems to return the number
    //    of entries in the logical palette of the DC instead. So we have
    //    to make it up ourselves.
    
    pal.logpalette.palNumEntries = (1 << (GetDeviceCaps(hdc, BITSPIXEL) *
                                          GetDeviceCaps(hdc, PLANES)));

    GetSystemPaletteEntries(hdc, 0, 256, &pal.logpalette.palPalEntry[0]);

    hSysPal = CreatePalette(&pal.logpalette);

    if (hSysPal == NULL) 
    {
        return;
    }

    if (palette) 
    {
        // system palette is required for ScanDci case.

        if (*palette == NULL)
        {   
            *palette = (ColorPalette*)GpMalloc(sizeof(ColorPalette)+sizeof(ARGB)*256); 
           
            if (*palette == NULL) 
            {
                goto exit;
            }
        }
        (*palette)->Count = pal.logpalette.palNumEntries;

        for (INT j=0; j<pal.logpalette.palNumEntries; j++) 
        {
            (*palette)->Entries[j] = GpColor::MakeARGB(0xFF,
                                                       pal.logpalette.palPalEntry[j].peRed,
                                                       pal.logpalette.palPalEntry[j].peGreen,
                                                       pal.logpalette.palPalEntry[j].peBlue);
        }
    }

    {    
        GpMemset(translate, 0, 256);
        
        INT         matchCount;
        INT             i;
        PALETTEENTRY *  halftonePalEntry = HTColorPalette.palPalEntry;
        COLORREF        halftoneColor;
        COLORREF        sysColor;
        COLORREF        matchedColor;
        UINT            matchingIndex;
        
        // Create a translation table for the 216 halftone colors, and count
        // how many exact matches we get.
        
        for (i = 0, matchCount = 0; i < 256; i++, halftonePalEntry++)
        {
           if ((i > 11) || (i < 8))
           {
               halftoneColor = PALETTERGB(halftonePalEntry->peRed, 
                                          halftonePalEntry->peGreen, 
                                          halftonePalEntry->peBlue);
           }
           else    // it is one of the magic 4 changeable system colors
           {
               halftoneColor = Globals::SystemColors[i + 8] | 0x02000000;
           }
        
           // See if the color is actually available in the system palette.
        
           matchedColor = ::GetNearestColor(hdc, halftoneColor) | 0x02000000;
        
           // Find the index of the matching color in the system palette
           
           matchingIndex = ::GetNearestPaletteIndex(hSysPal, matchedColor);
        
           if (matchingIndex == CLR_INVALID)
           {
               goto exit;
           }
        
           // We should never match to an entry outside of the device palette.
           ASSERT(matchingIndex < pal.logpalette.palNumEntries);

           translate[i] = static_cast<BYTE>(matchingIndex);
        
           sysColor = PALETTERGB(pal.logpalette.palPalEntry[matchingIndex].peRed,
                                 pal.logpalette.palPalEntry[matchingIndex].peGreen,
                                 pal.logpalette.palPalEntry[matchingIndex].peBlue);
        
           // see if we got an exact match
        
           if ((i >= 40) && (sysColor == halftoneColor))
           {
               matchCount++;
           }
        }
        
        // If we matched enough colors, we'll do 216-color halftoning.
        // Otherwise, we'll have to halftone with the VGA colors.
        // The palette returned from CreateHalftonePalette() on Win9x has
        // only 212 of the required 216 halftone colors.  (On NT it has all 216).
        // The 4 colors missing from the Win9x halftone palette are:
        //      0x00, 0x33, 0xFF
        //      0x00, 0xFF, 0x33
        //      0x33, 0x00, 0xFF
        //      0x33, 0xFF, 0x00
        // We require that all 212 colors be available because our GetNearestColor
        // API assumes that all 216 colors are there if we're doing 216-color
        // halftoning.
        
        SetValid(TRUE);
        
        if (matchCount >= 212)
        {
           isVGAOnly = FALSE;
        }
        else
        {
           isVGAOnly = TRUE;
        }
    }

exit:
    DeleteObject(hSysPal);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\scan.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Abstract:
*
*   Internal "scan class" prototypes. These classes represent a set of
*   "primitive" operations, which are characterized by being quick to render,
*   and fairly simple to represent.
*
*   [agodfrey] At time of writing, they are all scan-line operations, so the
*   name "scan class" kinda fits; however, we may need to add ones which
*   aren't scan-line oriented - e.g. one for aliased single-pixel-wide 
*   opaque solid-filled lines.
*
* Revision History:
*
*   12/01/1998 andrewgo
*       Created it.
*   02/22/2000 agodfrey
*       For ClearType, but also useful for other future improvements:
*       Expanded it to allow different types of record.
*       Cleared up some of the CachedBitmap confusion,
*       and removed the confusion between "opaque" and "SourceCopy".
*                  
\**************************************************************************/

#ifndef _SCAN_HPP
#define _SCAN_HPP

#include <dciman.h>
#include "alphablender.hpp"

struct EpScanRecord;

// This color is used as a default to detect bugs.

const ARGB HorridInfraPurpleColor = 0x80ff80ff;

// blenderNum: 
//   Used when an operation mixes different scan types.
//   We don't use an enum because the meaning of each blender depends
//   on the situation.
//
//   At the time of writing, only CachedBitmap uses this - to select
//   between the regular and opaque scan types.
// BlenderMax: The number of different scan types allowed in one
//   Start() ... End() sequence. e.g. if this is 2, blenderNum can be 0 or 1.

typedef VOID *(EpScan::* NEXTBUFFERFUNCTION)(
    INT x, 
    INT y, 
    INT newWidth, 
    INT updateWidth, 
    INT blenderNum
);

const INT BlenderMax = 2;

//--------------------------------------------------------------------------
// Scan iterator class
//
// [agodfrey]: The naming is confusing. Suggestions:
//             Rename "EpScan*" to "EpScanIterator". 
//             Rename "NEXTBUFFERFUNCTION"
//               to something about "next scan", not "next buffer".
//             Make a stronger name distinction between EpScanIterator* and 
//             EpScanBufferNative. 
//
// NOTE: These classes are not reentrant, and therefore cannot be used
//       by more than one thread at a time.  In actual use, this means
//       that their use must be synchronized under the device lock.
//--------------------------------------------------------------------------

class EpScan
{
public:

    // Some scan types have settings which are constant for an entire
    // Start() ... End() operation. Right now, there are only a few such 
    // settings. So, we just pass them as parameters with defaults.
    //
    // But if this grows, we might need to put them in a structure, 
    // or pass them in a separate call.
    //
    // pixFmtGeneral - the input pixel format for the color data,
    //   in the "Blend" and "CT" scan types.
    // pixFmtOpaque - the input pixel format for the color data,
    //   in the "Opaque" scan type.
    // solidColor - the solid fill color for "*SolidFill" scan types.
    //   The default is chosen to detect bugs.

    virtual BOOL Start(
        DpDriver *driver,
        DpContext *context,
        DpBitmap *surface,
        NEXTBUFFERFUNCTION *getBuffer,
        EpScanType scanType,                  
        PixelFormatID pixFmtGeneral = PixelFormat32bppPARGB,
        PixelFormatID pixFmtOpaque = PixelFormat32bppPARGB,
        ARGB solidColor = HorridInfraPurpleColor
    ) 
    {
        // Common initialization stuff.
        
        BlenderConfig[0].ScanType = scanType;
        BlenderConfig[0].SourcePixelFormat = pixFmtGeneral;
        
        // For now, blender 1 is only used for CachedBitmap rendering;
        // it's the blender for the opaque, "native format" data.
        
        BlenderConfig[1].ScanType = EpScanTypeOpaque;
        BlenderConfig[1].SourcePixelFormat = pixFmtOpaque;
        
        CurrentX = 0;
        CurrentY = 0;
        
        DitherOriginX = context->RenderingOriginX;
        DitherOriginY = context->RenderingOriginY;
        
        return TRUE;
    }
    
    virtual VOID End(INT currentWidth) = 0;

    virtual VOID *GetCurrentBuffer() = 0;

    virtual BYTE *GetCurrentCTBuffer() = 0;

    virtual VOID Flush() = 0;

    // This function processes an entire batch of scans -
    // it handles multiple pixel formats and combinations
    // of Blend and Opaque

    // If a scan class doesn't support it, it returns FALSE.

    virtual BOOL ProcessBatch(
        EpScanRecord *batchStart, 
        EpScanRecord *batchEnd,
        INT minX,
        INT minY,
        INT maxX, 
        INT maxY
    ) 
    {
        return FALSE;
    }
    
    // The x and y coordinates for the current scanline (blending scanline).
    // not the current requested next buffer.
    
    INT CurrentX;
    INT CurrentY;
    
    // The origin for the dither pattern.
    
    INT DitherOriginX;
    INT DitherOriginY;

    // "Blender configuration"
    //
    // For one Start() ... End() sequence, at most two different scan types are
    // used, and often there's just one. 
    // So, we allocate two EpAlphaBlender objects, and set them up 
    // appropriately during Start().
    //
    // Right now, the second one is only used for CachedBitmap. But in the
    // future, it might be used e.g. to mix "solidfill" scans with 
    // "blend" scans for antialiased solid fills. In that case, Start() will
    // need more parameters to tell it how to set up the blender objects.
    //
    // Note:
    //
    // In V2, we may want to avoid reinitializing the AlphaBlenders
    // for every primitive. But that'll take some work - there are many reasons
    // we might need to reinitialize. It wouldn't be enough to have
    // an EpAlphaBlender for each scan type (and I wouldn't recommend it 
    // anyway.)

    // !!! [agodfrey] "EpBlenderConfig" and "BlenderConfig" could do with
    //     better names. But I can't think of any.
    
    struct EpBlenderConfig
    {
        EpAlphaBlender AlphaBlender;
        PixelFormatID SourcePixelFormat;
        EpScanType ScanType;
        
        VOID Initialize(
            PixelFormatID dstFormat,
            const DpContext *context,
            const ColorPalette *dstpal,
            VOID **tempBuffers,
            BOOL dither16bpp,
            BOOL useRMW,
            ARGB solidColor)
        {
            AlphaBlender.Initialize(
                ScanType,
                dstFormat,
                SourcePixelFormat,
                context,
                dstpal,
                tempBuffers,
                dither16bpp,
                useRMW,
                solidColor);
        }
    };
    
    EpBlenderConfig BlenderConfig[BlenderMax];
    
    // LastBlenderNum:
    // Used by the flush mechanism in the NextBuffer functions 
    // to figure out which AlphaBlender to use to flush the buffer.
    
    INT LastBlenderNum;
};

//--------------------------------------------------------------------------
// Scan buffer class
//
// This class is intended to be used be any drawing code wishing to output
// to a scan buffer; callers should not use the EpScan class directly.
//--------------------------------------------------------------------------

template<class T>
class EpScanBufferNative
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagScanBufferNative : ObjectTagInvalid;
    }

private:

    DpBitmap *Surface;
    EpScan *Scan;
    NEXTBUFFERFUNCTION NextBufferFunction;
    INT CurrentWidth;

public:

    // noTransparentPixels - TRUE if there will be no transparent pixels.
    //   If you're not sure, set it to FALSE.
    //
    //   If it's set to TRUE, we'll substitute "Opaque" scan types for "Blend"
    //   scan types - if the pixels are all opaque, they're equivalent,
    //   and "Opaque" is faster.
    // solidColor - The solid color for *SolidFill scan types.    
    //   The default is chosen to detect bugs.
    
    EpScanBufferNative(
        EpScan *scan,
        DpDriver *driver,
        DpContext *context,
        DpBitmap *surface,
        BOOL noTransparentPixels = FALSE,
        EpScanType scanType = EpScanTypeBlend,
        PixelFormatID pixFmtGeneral = PixelFormat32bppPARGB,
        PixelFormatID pixFmtOpaque = PixelFormat32bppPARGB,
        ARGB solidColor = HorridInfraPurpleColor
        )
    {
        if (   noTransparentPixels
            && (scanType == EpScanTypeBlend))
        {
            scanType = EpScanTypeOpaque;
        }
        
        CurrentWidth = 0;
        Surface = surface;
        Scan = scan;
        SetValid(Scan->Start(
            driver,
            context,
            surface,
            &NextBufferFunction,
            scanType,
            pixFmtGeneral,
            pixFmtOpaque,
            solidColor
        ));
    }
    
    ~EpScanBufferNative()
    {
        if (IsValid())
        {
            Scan->End(CurrentWidth);
        }
        SetValid(FALSE);    // so we don't use a deleted object
    }
    
    // This function processes an entire batch of scans -
    // it handles multiple pixel formats and combinations
    // of SourceOver and SourceCopy.

    // If it's unsupported, it returns FALSE.

    BOOL ProcessBatch(
        EpScanRecord *batchStart, 
        EpScanRecord *batchEnd,
        INT minX, 
        INT minY,
        INT maxX, 
        INT maxY
    ) 
    {
        return Scan->ProcessBatch(batchStart, batchEnd, minX, minY, maxX, maxY);
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagScanBufferNative) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid ScanBufferNative");
        }
    #endif

        return (Tag == ObjectTagScanBufferNative);
    }

    // NextBuffer() flushes the previous scan (if there was one) and
    // returns a pointer to the new buffer.  Note that NextBuffer()
    // will never fail (but the constructor to EpScanBufferNative might
    // have!).
    //
    // blenderNum: 
    //     Used when an operation mixes different scan types.
    //     We don't use an enum because the meaning of each blender depends
    //     on the situation.
    //
    //     At the time of writing, only CachedBitmap uses this - to select
    //     between the regular and opaque scan types.
    //
    // Note: The contents of the buffer are not zeroed by NextBuffer().
    //       Use NextBufferClear() if you want the contents zeroed if
    //       you're doing an accumulation type of operation.
    //
    // Note: NextBuffer() may or may not return the same pointer as the
    //       previous NextBuffer() call.

    T *NextBuffer(
        INT x, INT y,
        INT nextWidth,
        INT blenderNum = 0
    )
    {
        ASSERT(IsValid());
        T *buffer = (T *)((Scan->*NextBufferFunction)(
            x, 
            y, 
            nextWidth, 
            CurrentWidth,
            blenderNum
        ));
        CurrentWidth = nextWidth;
        return buffer;
    }

    T *NextBufferClear(
        INT x, INT y, 
        INT width,
        INT blenderNum = 0
    )
    {
        T *buffer = NextBuffer(x, y, width, blenderNum);
        GpMemset(buffer, 0, width * sizeof(T));
        return buffer;
    }
    
    // !!! [agodfrey]: It would be better to remove the CurrentWidth member,
    //     and have UpdateWidth call a member in the Scan object.
    //
    //     It would also make this class' NextBuffer implementation less 
    //     confusing - it wouldn't mix parameters describing the next scan 
    //     with parameters describing the current one.

    VOID UpdateWidth(INT width)
    {
        // The width can only be shrunk:

        ASSERT(width <= CurrentWidth);
        CurrentWidth = width;
    }

    DpBitmap *GetSurface()
    {
        return Surface;
    }

    T *GetCurrentBuffer()
    {
        return (T *)(Scan->GetCurrentBuffer());
    }

    BYTE *GetCurrentCTBuffer()
    {
        return Scan->GetCurrentCTBuffer();
    }
};


class EpPaletteMap;

//--------------------------------------------------------------------------
// Direct access to the bits
//--------------------------------------------------------------------------

// [agodfrey] EpScanEngine and EpScanBitmap have some common code. Consider
//    merging that code into a single class, derived from EpScan, and then
//    deriving EpScanEngine and EpScanBitmap from it.

class EpScanEngine : public EpScan
{
private:

    BYTE *Dst;
    BYTE *Bits;
    INT Stride;
    INT PixelSize;       // Presumably the pixel size of the destination.
    DpBitmap * Surface;
    
    VOID *Buffers[5];

private:

    VOID *NextBuffer(
        INT x, INT y, 
        INT newWidth, 
        INT updateWidth, 
        INT blenderNum
    );

public:

    EpScanEngine() {}
    ~EpScanEngine() {}

    virtual BOOL Start(
        DpDriver *driver,
        DpContext *context,
        DpBitmap *surface,
        NEXTBUFFERFUNCTION *getBuffer,
        EpScanType scanType,                  
        PixelFormatID pixFmtGeneral, 
        PixelFormatID pixFmtOpaque ,
        ARGB solidColor
    );

    virtual VOID End(INT updateWidth);
    virtual VOID* GetCurrentBuffer() { return static_cast<VOID *>(Buffers[3]); }
    virtual BYTE* GetCurrentCTBuffer() 
    { 
        ASSERT(   (BlenderConfig[0].ScanType == EpScanTypeCT)
               || (BlenderConfig[0].ScanType == EpScanTypeCTSolidFill));

        return static_cast<BYTE *>(Buffers[4]);
    }
    virtual VOID Flush() {}
};

//--------------------------------------------------------------------------
// Access to the GpBitmap bits
//
// This scan interface is used for scan drawing to a GpBitmap object.
// The GpBitmap object is the internal representation of a GDI+ bitmap.
//--------------------------------------------------------------------------

class EpScanBitmap;
typedef VOID (EpScanBitmap::*SCANENDFUNCTION)(INT updateWidth);

class EpScanBitmap : public EpScan
{
private:

    DpBitmap* Surface;
    GpBitmap* Bitmap;
    INT Width;
    INT Height;

    BOOL BitmapLocked;
    BitmapData LockedBitmapData;
    UINT BitmapLockFlags;

    VOID* CurrentScan;  // only used by NextBufferNative
    INT PixelSize;      // only used by NextBufferNative
    
    VOID *Buffers[5];

    SCANENDFUNCTION EndFunc;

private:

    VOID *NextBuffer32ARGB(
        INT x, INT y, 
        INT newWidth, 
        INT updateWidth, 
        INT blenderNum
    );
    
    VOID *NextBufferNative(
        INT x, INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );
    
    VOID End32ARGB(INT updateWidth);
    VOID EndNative(INT updateWidth);

public:

    EpScanBitmap()
    {
        Buffers[0] = NULL;
        BitmapLocked = FALSE;
        Bitmap = NULL;
    }

    ~EpScanBitmap() { FreeData(); }

    VOID SetBitmap(GpBitmap* bitmap)
    {
        Bitmap = bitmap;
    }

    VOID FreeData()
    {
        if (Buffers[0])
            GpFree(Buffers[0]);

        Buffers[0] = NULL;
    }

    virtual BOOL Start(
        DpDriver *driver,
        DpContext *context,
        DpBitmap *surface,
        NEXTBUFFERFUNCTION *getBuffer,
        EpScanType scanType,                  
        PixelFormatID pixFmtGeneral,
        PixelFormatID pixFmtOpaque,
        ARGB solidColor
    );

    virtual VOID End(INT updateWidth);

    virtual VOID *GetCurrentBuffer()
    { 
        return static_cast<ARGB *>(Buffers[3]); 
    }

    virtual BYTE* GetCurrentCTBuffer() 
    { 
        ASSERT(   (BlenderConfig[0].ScanType == EpScanTypeCT)
               || (BlenderConfig[0].ScanType == EpScanTypeCTSolidFill));

        return static_cast<BYTE *>(Buffers[4]); 
    }
    
    virtual VOID Flush();

    GpBitmap *GetBitmap()
    {
        return Bitmap;
    }
};

//--------------------------------------------------------------------------
// Use either GDI or DCI for all scan drawing
//--------------------------------------------------------------------------

// MAKE_*WORD_ALIGNED:
// Increments the pointer, if necessary, to the next aligned address.
//
// WARNING: If you use this, you need to remember the original pointer,
// so that you can free the memory later.
//
// "p = MAKE_QWORD_ALIGNED(blah, p)" is a bug.

#define MAKE_QWORD_ALIGNED(type, p) (\
    reinterpret_cast<type>((reinterpret_cast<INT_PTR>(p) + 7) & ~7))

#define MAKE_DWORD_ALIGNED(type, p) (\
    reinterpret_cast<type>((reinterpret_cast<INT_PTR>(p) + 3) & ~3))

// Adds the given number of bytes to a pointer

#define ADD_POINTER(type, p, increment) (\
    reinterpret_cast<type>(reinterpret_cast<BYTE *>(p) + (increment)))

#define ASSERT_DWORD_ALIGNED(p) ASSERTMSG(!(reinterpret_cast<INT_PTR>(p) & 3), ("'" #p "' not DWORD aligned"))
#define ASSERT_QWORD_ALIGNED(p) ASSERTMSG(!(reinterpret_cast<INT_PTR>(p) & 7), ("'" #p "' not QWORD aligned"))

// The variable-format structure for all batch record types.
// Must be stored at a QWORD-aligned location

struct EpScanRecord
{
    UINT16 BlenderNum;  // Identifies the AlphaBlender to be used to render
                        // the scan. (0 through BlenderMax-1).
    UINT16 ScanType;    // EpScanType explicitly coerced into 2 bytes.
    INT X;
    INT Y;
    INT Width;          // Number of pixels to output
    INT OrgWidth;       // The original width when the record was allocated.
                        // (The width may change later, and we need the original
                        //  width in order to calculate the positions of 
                        //  the variable-length records.)

    // Different scan types have different fields after the header:
    // 1) EpScanTypeOpaque, EpScanTypeBlend: 
    //    A color buffer, of "Width" pixels, in some pixel format. 8-byte aligned.
    // 2) EpScanTypeCT:
    //    A color buffer, of "Width" pixels, in some pixel format. 8-byte aligned.
    //    A CT coverage buffer, of "Width" bytes. 4-byte aligned.
    // 3) EpScanTypeCTSolidFill:
    //    A CT coverage buffer, of "Width" bytes. 4-byte aligned.

    // Return the color buffer, of "Width" pixels. Valid for
    // EpScanTypeOpaque, EpScanTypeBlend and EpScanTypeCT.
    
    VOID *GetColorBuffer()
    {
        if (GetScanType() == EpScanTypeCTSolidFill)
            return NULL;
        return CalculateColorBufferPosition(
            this,
            GetScanType()
            );
    }
    
    EpScanType GetScanType()
    {
        return static_cast<EpScanType>(ScanType);
    }
    
    VOID SetScanType(EpScanType type)
    {
        ASSERT(type < (1<<sizeof(ScanType)));

        ScanType = static_cast<UINT16>(type);
    }
    
    // A safe way to set blenderNum - the cast is protected by an assertion.

    VOID SetBlenderNum(INT blenderNum)
    {
        ASSERT(   (blenderNum >= 0)
               && (blenderNum < BlenderMax));

        BlenderNum = static_cast<UINT16>(blenderNum);
    }

    // Return the CT buffer, of "Width" pixels.
    // Valid for EpScanTypeCT and EpScanTypeCTSolidFill only.
    //
    // colorFormatSize - the size of a "color buffer" pixel, in bytes.
    
    BYTE *GetCTBuffer(
        INT colorFormatSize
        )
    {
        EpScanType type = GetScanType();
        ASSERT(   (type == EpScanTypeCT)
               || (type == EpScanTypeCTSolidFill));
        
        if (type == EpScanTypeCT)
        {
            return CalculateCTBufferPosition(
                this,
                type,
                OrgWidth,
                colorFormatSize);
        }
        else
        {
            return CalculateCTBufferPositionCTSolidFill(this);
        }
    }
    
    // Calculates the position of the next scan record, given enough data
    // about the current one.
    //
    // This is like NextScanRecord, but it doesn't require the "currentRecord"
    // pointer to point to valid memory. Instead, the necessary data is
    // passed in parameters.
    //
    // Callers can use this to decide whether the record will fit into
    // available memory.  
    //
    // currentRecord   - points to the "current" record. This doesn't need
    //                   to be a valid record, and the memory it points to
    //                   doesn't need to be big enough to hold the current
    //                   record. Must be QWORD-aligned.
    // type            - the type of record
    // width           - the actual number of pixels
    // colorFormatSize - the size of a "color buffer" pixel, in bytes.

    static EpScanRecord *CalculateNextScanRecord(
        EpScanRecord *currentRecord,
        EpScanType type,
        INT width,
        INT colorFormatSize
        )
    {
        return InternalCalculateNextScanRecord(
            currentRecord,
            type,
            width,
            width,
            colorFormatSize);
    }
    
    // Returns a pointer to the next scan record, based on the current,
    // valid scan record.
    //
    // colorFormatSize - the size of a "color buffer" pixel, in bytes.

    EpScanRecord *NextScanRecord(
        INT colorFormatSize
        )
    {
        return InternalCalculateNextScanRecord(
            this,
            GetScanType(),
            Width,
            OrgWidth,
            colorFormatSize);
    }

private:
    
    // These functions are 'static' to emphasize that they're usable on
    // EpScanRecord pointers which don't point to valid memory.

    // Calculates the position of the next scan record, given enough data
    // about the current one.
    //
    // currentRecord   - points to the "current" record. This doesn't need
    //                   to be a valid record, and the memory it points to
    //                   doesn't need to be big enough to hold the current
    //                   record. Must be QWORD-aligned.
    // type            - the type of record
    // width           - the actual number of pixels
    // orgWidth        - the "original" width - the width at the time the
    //                   scan was first allocated. Can't be smaller than
    //                   'width'.
    // colorFormatSize - the size of a "color buffer" pixel, in bytes.

    static EpScanRecord *InternalCalculateNextScanRecord(
        EpScanRecord *currentRecord,
        EpScanType type,
        INT width,
        INT orgWidth,
        INT colorFormatSize
        )
    {
        ASSERT_QWORD_ALIGNED(currentRecord);
        
        EpScanRecord *p;
 
        // If width < orgWidth, we can reclaim some of the space at the end.
        // However, the record positions are based on orgWidth, so
        // only the final record can be shrunk.
        //
        // So, the pattern for the below is:
        // 1) Get the pointer to the last field, using "orgWidth".
        // 2) Add the field size, using "width" (not "orgWidth").
        // 3) QWORD-align it.
            
        switch (type)
        {
        case EpScanTypeBlend:
        case EpScanTypeOpaque:
            p = ADD_POINTER(
                EpScanRecord *,
                CalculateColorBufferPosition(currentRecord, type),
                width * colorFormatSize);
            break;
        
        case EpScanTypeCT:
            p = ADD_POINTER(
                EpScanRecord *,
                CalculateCTBufferPosition(
                    currentRecord, 
                    type, 
                    orgWidth, 
                    colorFormatSize),
                width);
            break;
        
        case EpScanTypeCTSolidFill:
            p = ADD_POINTER(
                EpScanRecord *,
                CalculateCTBufferPositionCTSolidFill(
                    currentRecord),
                width);
            break;
        }

        return MAKE_QWORD_ALIGNED(EpScanRecord *, p);
    }
    
    // Return a pointer to the color buffer. Valid for
    // EpScanTypeOpaque, EpScanTypeBlend and EpScanTypeCT.
    //
    // currentRecord   - the "current" record, QWORD-aligned.
    // type            - the type of record
    
    static VOID *CalculateColorBufferPosition(
        EpScanRecord *currentRecord,
        EpScanType type
        )
    {
        ASSERT_QWORD_ALIGNED(currentRecord);
        ASSERT(   (type == EpScanTypeOpaque)
               || (type == EpScanTypeBlend)
               || (type == EpScanTypeCT));
        
        // Since the pointer is QWORD-aligned, we can do this by adding
        // the 'QWORD-aligned size' of this structure. 
        // 
        // The "regular" way would be to add the size and then 
        // QWORD-align the pointer. But this is more efficient, because
        // qwordAlignedSize is a compile-time constant.
        
        const INT qwordAlignedSize = (sizeof(EpScanRecord) + 7) & ~7;

        return ADD_POINTER(VOID *, currentRecord, qwordAlignedSize);
    }

    // Return a pointer to the CT buffer.
    // Valid for EpScanTypeCT only.
    //
    // currentRecord   - the "current" record, QWORD-aligned.
    // type            - the type of record
    // width           - the number of pixels
    // colorFormatSize - the size of a "color buffer" pixel, in bytes.
    
    static BYTE *CalculateCTBufferPosition(
        EpScanRecord *currentRecord,
        EpScanType type,
        INT width,
        INT colorFormatSize
        )
    {
        ASSERT_QWORD_ALIGNED(currentRecord);
        ASSERT(type == EpScanTypeCT);
        
        BYTE *p = ADD_POINTER(
            BYTE *,
            CalculateColorBufferPosition(currentRecord, type),
            colorFormatSize * width);
            
        return MAKE_DWORD_ALIGNED(BYTE *, p);
    }
    
    // Return a pointer to the CT buffer, of "Width" pixels. 
    // Valid for EpScanTypeCTSolidFill only.
    //
    // currentRecord   - the "current" record, QWORD-aligned.
    // type            - the type of record
    // width           - the number of pixels
    // colorFormatSize - the size of a "color buffer" pixel, in bytes.
    
    static BYTE *CalculateCTBufferPositionCTSolidFill(
        EpScanRecord *currentRecord
    )
    {
        ASSERT_QWORD_ALIGNED(currentRecord);

        BYTE *p = reinterpret_cast<BYTE *>(currentRecord+1);
            
        ASSERT_DWORD_ALIGNED(p);
            
        return p;
    }

};

// Queue data structures:

enum GdiDciStatus
{
    GdiDciStatus_TryDci,    // We're to try using DCI, but it hasn't been 
                            //   initialized yet (which if it fails will 
                            //   cause us to fall back to GDI)
    GdiDciStatus_UseDci,    // We successfully initialized DCI, so use it 
                            //   for all drawing
    GdiDciStatus_UseGdi,    // Use only GDI for all drawing
};

// Minimum buffer size for the DCI drawing queue:

#define SCAN_BUFFER_SIZE 64*1024

class EpScanGdiDci : public EpScan
{

private:

    // Persistent state:

    GdiDciStatus Status;                // Class status
    GpDevice* Device;                   // Associate device; must exist for
                                        //   the lifetime of this object
    DpContext* Context;                 // Points to the context object related
                                        //   to any records sitting in the batch.
                                        //   May be invalid if the batch is
                                        //   empty.
    DpBitmap* Surface;                  // Similarly points to the surface
                                        //   related to any records sitting in
                                        //   the batch.
    BOOL IsPrinter;                     // Is the destination a printer?
    DCISURFACEINFO *DciSurface;         // DCI surface state, allocated by
                                        //   DCI
    INT PixelSize;                      // Pixel size, in bytes for the current
                                        // batch record
    VOID *Buffers[5];                   // Temporary scan buffers
                                        
    // Cache objects:

    HRGN CacheRegionHandle;             // Region we hang on to so that we
                                        //   don't have to re-create on every
                                        //   query
    RGNDATA *CacheRegionData;           // Clipping data allocation (may be 
                                        //   NULL)
    INT CacheDataSize;
    RECT *EnumerateRect;
    INT EnumerateCount;

    // Bounds accumulation:

    INT MinX;
    INT MaxX;
    INT MinY;
    INT MaxY;                           // Note that YMax is 'inclusive'

    // Global offset for the batch processing.

    INT BatchOffsetX;
    INT BatchOffsetY;
    
    // For *SolidFill scan types, we need to record the solid color passed
    // to Start(). We use it when we call EpAlphaBlender::Initialize()
    
    ARGB SolidColor;                  

    // Enumeration information:

    VOID *BufferMemory;                 // Points to start of buffer memory
                                        // block
    EpScanRecord *BufferStart;          // Points to queue buffer start.
                                        // QWORD-aligned.
    EpScanRecord *BufferEnd;            // Points to end of queue buffer
    EpScanRecord *BufferCurrent;        // Points to current queue position
    INT BufferSize;                     // Size of queue buffer in bytes

private:

    VOID *NextBuffer(
        INT x, INT y, 
        INT newWidth, 
        INT updateWidth, 
        INT blenderNum
    );
    
    VOID LazyInitialize();
    VOID EmptyBatch();

    VOID DownloadClipping_Dci(HDC hdc, POINT *clientOffset);
    VOID ProcessBatch_Dci(HDC hdc, EpScanRecord* bufferStart, EpScanRecord* bufferEnd);
    BOOL Reinitialize_Dci();
    VOID LazyInitialize_Dci();
    
    EpScanRecord* FASTCALL DrawScanRecords_Dci(
        BYTE* bits, INT stride,
        EpScanRecord* record, 
        EpScanRecord* endRecord, 
        INT xOffset, INT yOffset,
        INT xClipLeft, INT yClipTop, 
        INT xClipRight, INT yClipBottom
    );

    VOID ProcessBatch_Gdi(
        HDC hdc, 
        EpScanRecord* bufferStart, 
        EpScanRecord* bufferEnd
    );

    // Perform SrcOver blend using GDI for 32bpp (P)ARGB source pixels only.

    VOID SrcOver_Gdi_ARGB(
        HDC destinationHdc, 
        HDC dibSectionHdc, 
        VOID *dibSection,
        EpScanRecord *scanRecord
    );

public:

    // Pass TRUE for 'tryDci' if it's okay to try using DCI for our rendering;
    // otherwise only use GDI:

    EpScanGdiDci(GpDevice *device, BOOL tryDci = FALSE);

    ~EpScanGdiDci();

    virtual BOOL Start(
        DpDriver *driver, 
        DpContext *context,
        DpBitmap *surface,
        NEXTBUFFERFUNCTION *getBuffer,
        EpScanType scanType,                  
        PixelFormatID pixFmtGeneral,
        PixelFormatID pixFmtOpaque,
        ARGB solidColor
    );
    
    virtual VOID End(INT updateWidth);

    virtual VOID* GetCurrentBuffer()
    {
        return BufferCurrent->GetColorBuffer();
    }

    virtual BYTE* GetCurrentCTBuffer() 
    { 
        // We assume that in ClearType cases,
        // there is only one scan type for the Start()...End() sequence

        ASSERT(BufferCurrent->BlenderNum == 0);
        
        // This should only be called for ClearType scan types

        ASSERT(   (BlenderConfig[0].ScanType == EpScanTypeCT)
               || (BlenderConfig[0].ScanType == EpScanTypeCTSolidFill));
        
        ASSERT(BlenderConfig[0].ScanType == BufferCurrent->GetScanType());
        
        return BufferCurrent->GetCTBuffer(
            GetPixelFormatSize(BlenderConfig[0].SourcePixelFormat) >> 3
            );
    }
    
    virtual VOID Flush();

    // This function processes an entire batch of scans -
    // it handles multiple pixel formats and combinations
    // of SourceOver and SourceCopy.

    virtual BOOL ProcessBatch(
        EpScanRecord *batchStart, 
        EpScanRecord *batchEnd,
        INT minX,
        INT minY,
        INT maxX,
        INT maxY
    );
};

#endif // !_SCAN_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\scandib.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Abstract:
*
*   Internal output banding class for use with printing.
*
*   This class supports two major forms of DIB banding.  Both are useful
*   when printing.
*  
*      1. Output at a 'capped DPI' either 32bpp or 24bpp.
*      2. Output at a 'device DPI' only the alpha channel.
*
* Revision History:
*
*   07/26/1999 ericvan
*       Created it.
*
\**************************************************************************/

#ifndef __SCANDIB_HPP
#define __SCANDIB_HPP

// Internally generate a bottom up DIB
#define PRINT_BOTTOM_UP 1

enum ScanDIBOptions
{     
    ScanCappedBounds    = 0x00000001,     // allocate 24bpp buffer at capped size
    ScanDeviceBounds    = 0x00000002,     // allocate 1bpp mask at device size
    ScanCapped32bpp     = 0x00000004,     // otherwise the default is 24bpp
    ScanCapped32bppOver = 0x00000008,     // otherwise the default is 24bpp
    ScanCappedOver      = 0x00000010,     // do whiteness source over on 24bpp
    ScanDeviceZeroOut   = 0x00000020,     // zero out 0's in capped buffer when
                                          // generating 0's in alpha mask buffer
                                          // !! ONLY if dev/cap is integer.
    ScanDeviceAlpha     = 0x00000040,     // generate alpha vs. opaque 1bpp mask
    ScanBleedOut        = 0x00000080,     // bleed color data
    
    ScanDeviceFlags     = ScanDeviceAlpha | ScanDeviceZeroOut | ScanDeviceBounds,
    ScanCappedFlags     = ScanCappedBounds | ScanCapped32bpp | ScanCappedOver |
                          ScanCapped32bppOver
};

class EpScanDIB : public EpScan
{
private:
   GpRect     CappedBounds;      // bounds at capped DPI (24bpp)
   GpRect     DeviceBounds;      // bounds at device DPI (1bpp)

   INT        CappedStride;

   GpPoint    MinBound;
   GpPoint    MaxBound;
   
   INT        ScaleX;
   INT        ScaleY;

   // Last output scan operation
   INT        OutputX, OutputY, OutputWidth, OutputBleed, OutputLastY;
   
   // 32bpp/24bpp DIB section
   BYTE*      BufStart; 
   ARGB*      Buf32bpp;
   ARGB*      CurBuffer;
   struct {
       BITMAPINFO BMI;
       RGBQUAD rgbQuad[4];
   } Buf;
   
   // Transparency mask
   BYTE*      MaskStart;
   INT        MaskStride;        // # of bytes in one stride
   struct {
       BITMAPINFO BMI;
       RGBQUAD rgbQuad[4];
   } Mask;

   // pointer to 32bpp scanline which we halftone FROM into the 1bpp mask above
   ARGB*      AlphaStart;

   // array for keeping count for zeroing out scans of capped image
   BYTE*      ZeroStart;

   NEXTBUFFERFUNCTION NextBuffer;
   DWORD      ScanOptions;
   BOOL       RenderAlpha;
   BOOL       Rasterizing;

   // padding of pixels that we don't zeroout.
   INT        ZeroOutPad;

private:
    // output at capped dpi at 32bpp
    VOID *NextBufferFunc32bpp(
        INT x, 
        INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );

    // output at capped dpi at 32bpp
    VOID *NextBufferFunc32bppOver(
        INT x, 
        INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );

    // output at capped dpi at 24bpp
    VOID *NextBufferFunc24bpp(
        INT x, 
        INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );

    // output at capped dpi at 24bpp
    VOID *NextBufferFunc24bppBleed(
        INT x, 
        INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );

    // output at capped dpi at 24bpp, does implicit alpha blend on white 
    // surface
    VOID *NextBufferFunc24bppOver(
        INT x, 
        INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );
                                       
    // output alpha mask at device dpi at 1bpp
    VOID *NextBufferFuncAlpha(
        INT x, 
        INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );

    // output opaque mask at device dpi at 1bpp
    VOID *NextBufferFuncOpaque(
        INT x, 
        INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );
    
    // doesn't output a mask, but zero's out clipped portions of 24bpp DIB
    VOID *NextBufferFuncZeroOut(
        INT x, 
        INT y, 
        INT newWidth, 
        INT updateWidth,
        INT blenderNum
    );
    
public:
    EpScanDIB();

    ~EpScanDIB() {}

    virtual BOOL Start(
        DpDriver *driver, 
        DpContext *context, 
        DpBitmap *surface,
        NEXTBUFFERFUNCTION *nextBuffer,
        EpScanType scanType,                  
        PixelFormatID pixFmtGeneral,
        PixelFormatID pixFmtOpaque,
        ARGB solidColor
    );
    
    VOID End(INT updateWidth);

    VOID Flush();

    // ARGB buffer
    BYTE *GetStartBuffer()
    {
        return BufStart;
    }

    BITMAPINFO *GetBufferBITMAPINFO()
    {
        return &Buf.BMI;
    }

    DWORD GetBufferStride()
    {
        return CappedStride;
    }

    // Mask Buffer
    BYTE *GetMaskBuffer()
    {
        return MaskStart;
    }

    DWORD GetMaskStride()
    {
        return MaskStride;
    }

    BITMAPINFO *GetMaskBITMAPINFO()
    {
         return &Mask.BMI;
    }
    
    VOID *GetCurrentBuffer() 
    {
        return CurBuffer;
    }
    
    virtual BYTE* GetCurrentCTBuffer() 
    { 
        // Since this class is meant for printers, higher-level
        // code should prevent us from getting here.
        // GpGraphics::GetTextRenderingHintInternal() guards against this.
        
        ASSERT(FALSE);
        return NULL;
    }

    DWORD GetOptions() 
    {
        return ScanOptions;
    }

    BOOL GetActualBounds(GpRect *rect);

    VOID SetRenderMode(BOOL RenderAlpha, GpRect* newBounds);
    
    // Allocate DIB and monochrome DIB memory
    GpStatus CreateBufferDIB(const GpRect* boundsCap,
                             const GpRect* boundsDev,
                             DWORD scanDIBOptions,
                             INT scaleX,
                             INT scaleY);

    VOID DestroyBufferDIB();

    INT GetZeroOutPad()
    {
        return ZeroOutPad;
    }

    VOID SetZeroOutPad(INT pad)
    {
        ASSERT(pad >= 0);
        ZeroOutPad = pad;
    }

    VOID ResetZeroOutPad()
    {
        ZeroOutPad = 2;
    }

#if 0
    // create 1bpp monochrome mask of DIB
    GpStatus CreateAlphaMask();

    // create simple opaque monochrome mask of DIB (alpha>0 => opaque)
    GpStatus CreateOpaqueMask();    // not used
#endif

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\scandci.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Abstract:
*
*   Contains the scan-buffer routines for DCI and GDI.
*
* Plan:
*
*   !!! [agodfrey] 
*       For batching across primitives, the DpContext code
*       needs to flush the batch whenever the Context changes state.
*    
*       If that isn't feasible for some kinds of state, then EpScanGdiDci
*       could keep its own DpContext, updated when "context update" records
*       are inserted into the batch. (This would happen during a call to
*       Start()).
*
* Revision History:
*
*   12/08/1998 andrewgo
*       Created it.
*   01/20/2000 agodfrey
*       Moved it from Engine\Entry.
*   03/23/2000 andrewgo
*       Integrate DCI and GDI scan cases, for IsMoveSizeActive handling.
*   02/22/2000 agodfrey
*       For ClearType, but also useful for other future improvements:
*       Expanded the batch structure to allow different types of record.
*
\**************************************************************************/

#include "precomp.hpp"

#include <limits.h>

/**************************************************************************\
*
* Function Description:
*
*   Downloads the clipping rectangles for the specified window.  Updates
*   internal class clipping variables and returns the window offset to
*   be used.
*
* Return Value:
*
*   None
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
EpScanGdiDci::DownloadClipping_Dci(
    HDC hdc,
    POINT *clientOffset         // In/Out
    )
{
    INT i;
    RECT *rect;

    HRGN regionHandle = CacheRegionHandle;
    RGNDATA *data = CacheRegionData;
    INT size = CacheDataSize;

    // Query the VisRgn:

    INT getResult = GetRandomRgn(hdc, regionHandle, SYSRGN);
    if (getResult == TRUE)
    {
        INT newSize = GetRegionData(regionHandle, size, data);

        // The spec says that  GetRegionData returns '1' in the event of 
        // success, but NT returns the actual number of bytes written if 
        // successful, and returns '0' if the buffer wasn't large enough:

        if ((newSize < 1) || (newSize > size))
        {
            do {
                newSize = GetRegionData(regionHandle, 0, NULL);

                // Free the old buffer and allocate a new one:

                GpFree(data);
                data = NULL;
                size = 0;

                if (newSize < 1)
                    break;

                data = static_cast<RGNDATA*>(GpMalloc(newSize));
                if (data == NULL)
                    break;

                size = newSize;
                newSize = GetRegionData(CacheRegionHandle, size, data);

                // On NT, it's possible due to multithreading that the
                // regionHandle could have increased in complexity since we
                // asked for the size.  (On Win9x, this isn't possible due
                // to the fact that BeginAccess acquires the Win16Lock.)
                // So in the rare case that this might happen, loop again:

            } while (newSize < size);

            CacheRegionData = data;
            CacheDataSize = size;
        }

        if (data != NULL)
        {
            INT xOffset = clientOffset->x;
            INT yOffset = clientOffset->y;

            // Set up some enumeration state:

            EnumerateCount = data->rdh.nCount;
            EnumerateRect = reinterpret_cast<RECT*>(&data->Buffer[0]);

            // Handle our multimon goop:

            INT screenOffsetX = Device->ScreenOffsetX;
            INT screenOffsetY = Device->ScreenOffsetY;

            if ((screenOffsetX != 0) || (screenOffsetY != 0))
            {
                // Adjust for screen offset for the multimon case:

                xOffset -= screenOffsetX;
                yOffset -= screenOffsetY;

                // Adjust and intersect every clip rectangle to account for
                // this monitor's location:
                
                if(Globals::IsNt)
                {
                    for (rect = EnumerateRect, i = EnumerateCount; 
                         i != 0; 
                         i--, rect++)
                    {
                        // subtract off the screen origin so we can get 
                        // screen relative rectangles. This is only appropriate
                        // on NT - Win9x is window relative.
                                                
                        rect->left -= screenOffsetX;
                        rect->right -= screenOffsetX;
                        rect->top -= screenOffsetY;
                        rect->bottom -= screenOffsetY;
                        
                        // Clamp to the screen dimension.
                        
                        if (rect->left < 0) 
                        {
                            rect->left = 0;
                        }
        
                        if (rect->right > Device->ScreenWidth) 
                        {
                            rect->right = Device->ScreenWidth;
                        }
        
                        if (rect->top < 0) 
                        {
                            rect->top = 0;
                        }
        
                        if (rect->bottom > Device->ScreenHeight) 
                        {
                            rect->bottom = Device->ScreenHeight;
                        }
                    }
                }
            }

            // On Win9x, GetRandomRgn returns the rectangles in window
            // coordinates, not screen coordinates, so we adjust them
            // here:

            if (!Globals::IsNt)
            {
                for (rect = EnumerateRect, i = EnumerateCount; 
                     i != 0; 
                     rect++, i--)
                {
                    // Add the screen relative window offset to the rect.
                    // The rect is window relative on Win9x, so this 
                    // calculation will give us the screen relative rectangle
                    // we need.
                    
                    rect->left += xOffset;
                    rect->right += xOffset;
                    rect->top += yOffset;
                    rect->bottom += yOffset;
        
                    // clamp to the screen dimentions.
                                
                    if (rect->left < 0) 
                    {
                        rect->left = 0;
                    }
                    
                    if (rect->top < 0) 
                    {
                        rect->top = 0;
                    }
                    
                    if (rect->right > Device->ScreenWidth) 
                    {
                        rect->right = Device->ScreenWidth;
                    }

                    if (rect->bottom > Device->ScreenHeight) 
                    {
                        rect->bottom = Device->ScreenHeight;
                    }
                }
            }

            // Return the offset:

            clientOffset->x = xOffset;
            clientOffset->y = yOffset;

            return;
        }
    }

    // Something failed (could have been a bad 'hdc' specified, or low
    // memory).  As a result we set the clip regionHandle to 'empty':

    EnumerateCount = 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Sits in a tight loop to read the scan data structures, do any 
*   necessary clipping, and render the result.
*
* Return Value:
*
*   Points to the queue record it couldn't understand (typically a 
*   header record), or end of the buffer if reached.
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

EpScanRecord*
FASTCALL
EpScanGdiDci::DrawScanRecords_Dci(
    BYTE* bits,
    INT stride,
    EpScanRecord* record,
    EpScanRecord* endRecord,
    INT xOffset,
    INT yOffset,
    INT xClipLeft,
    INT yClipTop,
    INT xClipRight,
    INT yClipBottom
    )
{
    INT blenderNum;
    INT x;
    INT y;
    INT width;
    INT xLeft;
    INT xRight;
    INT count;

    INT pixelSize = PixelSize;

    // Set up the AlphaBlender objects
    
    PixelFormatID dstFormat = Surface->PixelFormat;
    
    BOOL result = Device->GetScanBuffers(
        Surface->Width,
        NULL,
        NULL,
        NULL,
        Buffers);
        
    if (result && (dstFormat != PIXFMT_UNDEFINED))
    {
        // Palette and PaletteMap are set up by Start().
        // initialize the AlphaBlenders.

        BlenderConfig[0].Initialize(
            dstFormat,
            Context,
            Context->Palette ? Context->Palette : Device->Palette, 
            Buffers,
            TRUE,
            TRUE,
            SolidColor
        );
        
        BlenderConfig[1].Initialize(
            dstFormat,
            Context,
            Context->Palette ? Context->Palette : Device->Palette, 
            Buffers,
            TRUE,
            TRUE,
            SolidColor
        );
    }    
    else
    {
        ONCE(WARNING(("DrawScanRecords_Dci: Unrecognized pixel format")));
        return endRecord;
    }
    
    INT ditherOriginX = DitherOriginX;
    INT ditherOriginY = DitherOriginY;
    
    do {


        // SrcOver_Gdi_ARGB assumes that if the format is lower than 8bpp,
        // then the DIBSection format is 8bpp.

        // Bug 310285:  This assert is disabled and should be reinvestigated
        // for v2.  It is likely the Surface pointer needs to be changed
        // to the real surface that's being rendered.
        
        //ASSERT(   (Surface->PixelFormat == PixelFormatUndefined)
        //       || (GetPixelFormatSize(Surface->PixelFormat) >= 8)
        //       || (dstFormat == PixelFormat8bppIndexed));
        
        blenderNum = record->BlenderNum;
        ASSERT(record->GetScanType() == BlenderConfig[blenderNum].ScanType);

        x = record->X + xOffset + BatchOffsetX;
        y = record->Y + yOffset + BatchOffsetY;
        width = record->Width;

        INT recordFormatSize =  
            GetPixelFormatSize(BlenderConfig[blenderNum].SourcePixelFormat) >> 3;

        if ((y >= yClipTop) && (y < yClipBottom))
        {
            xRight = x + width;
            if (xRight > xClipRight)
                xRight = xClipRight;

            xLeft = x;
            if (xLeft < xClipLeft)
                xLeft = xClipLeft;

            count = xRight - xLeft;
            if (count > 0)
            {
                BYTE *src = NULL;
                BYTE *ctBuffer = NULL;
                EpScanType scanType = record->GetScanType();
                
                if (scanType != EpScanTypeCTSolidFill)
                {
                    src = reinterpret_cast<BYTE*>(record->GetColorBuffer());
                    src += (xLeft - x)*recordFormatSize;
                }
                
                if (   (scanType == EpScanTypeCT)
                    || (scanType == EpScanTypeCTSolidFill))
                {
                    ctBuffer = record->GetCTBuffer(
                        GetPixelFormatSize(BlenderConfig[0].SourcePixelFormat) >> 3
                        );
                    ctBuffer += (xLeft - x);
                }
                
                BYTE *dst = bits + (y * stride) + (xLeft * pixelSize);
                    
                BlenderConfig[blenderNum].AlphaBlender.Blend(
                    dst, 
                    src, 
                    count, 
                    xLeft - ditherOriginX, 
                    y     - ditherOriginY,
                    ctBuffer
                );
            }
        }

        // Advance to the next record:

        record = record->NextScanRecord(recordFormatSize);

    } while (record < endRecord);

    return(record);
}

/**************************************************************************\
*
* Function Description:
*
*   Processes all the data in the queue.
*
*   Note that it does not empty the queue; the caller is responsible.
*
* Return Value:
*
*   None
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
EpScanGdiDci::ProcessBatch_Dci(
    HDC hdc,                // Only used to query window offset and clipping
    EpScanRecord *buffer,
    EpScanRecord *bufferEnd
    )
{
    INT i;
    RECT *clipRect;
    EpScanRecord *nextBuffer;
    POINT clientOffset;
    POINT duplicateOffset;
    INT result;
    
    while (TRUE)
    {
        // Peek at the window offset so that we can specify the bounds on
        // the DCI lock properly.  Note that the window offset may change
        // between the time we do this peak, and the time we do the
        // BeginAccess.
        //
        // GetDCOrgEx may fail if the DC is bad, in which case we shouldn't
        // draw anything:
    
        if (!GetDCOrgEx(hdc, &clientOffset))
        {
            return;
        }

        // Adjust for the monitor's offset:

        INT xOffset = clientOffset.x - Device->ScreenOffsetX;
        INT yOffset = clientOffset.y - Device->ScreenOffsetY;

        // Clip to the surface bounds (multi-mon might cause the bounds
        // to be bigger than our surface):
    
        INT x = max(MinX + xOffset, 0);
        INT y = max(MinY + yOffset, 0);

        // MaxY is inclusive:

        INT width  = min(MaxX + xOffset,     Device->ScreenWidth) - x;
        INT height = min(MaxY + yOffset + 1, Device->ScreenHeight) - y;

        if ((width <= 0) || (height <= 0))
        {
            return;
        }

        // Acquire the DCI lock:
        
        result = Globals::DciBeginAccessFunction(
            DciSurface, 
            x, y, 
            width, 
            height
         );

        if (result < DCI_OK)
        {
            // The DCI lock failed.  There are really two possible reasons:
            //
            //  1.  There was a mode change;
            //  2.  The system at some point switched to a secure desktop
            //      (such as by Ctrl-Alt-Del or by a screen saver) on NT.
            //
            // For the former case, we get a WM_DISPLAYCHANGED notification 
            // message, and we have code that recreates all the GDI+ surface
            // representations (because a color-depth change happened, or
            // the multi-mon configuration might have changed, and we can't
            // recover from either of those this deep in the rendering
            // pipeline).
            //
            // For the second case, we get no notification other than the 
            // DCI lock failure.  So for this case, we try to reinitialize
            // our DCI state right here.  

            if (!Reinitialize_Dci())
            {
                return;
            }
            
            result = Globals::DciBeginAccessFunction(
                DciSurface, 
                x, y, 
                width, 
                height
            );
        }

        // If we failed to get a DCI lock, don't bother processing any
        // of the queue.  We're outta here:
    
        if (result < DCI_OK)
        {
            return;
        }

        // Check the window offset again and verify that it's still
        // the same as the value we used to compute the lock rectangle:

        GetDCOrgEx(hdc, &duplicateOffset);

        if ((duplicateOffset.x == clientOffset.x) &&
            (duplicateOffset.y == clientOffset.y))
        {
            break;
        }

        // The window moved between the time we computed the
        // DCI lock area and the time we actually did the DCI 
        // lock.  Unlock and repeat:
        
        Globals::DciEndAccessFunction(DciSurface);
    } 

    // Every time we acquire the DCI lock, we have to requery the
    // clipping.  
    //
    // Now that we've acquired the DCI lock (or we failed to acquire
    // it but won't actually draw anything), then it's safe to
    // download the clipping, because it won't change until we do
    // the DCI unlock:

    DownloadClipping_Dci(hdc, &clientOffset);

    // Copy the data to the surface:

    BYTE *bits = reinterpret_cast<BYTE*>(DciSurface->dwOffSurface);
    INT stride = DciSurface->lStride;

    // We don't have to do any rendering when the clipping is empty:

    if (EnumerateCount != 0)
    {
        while (buffer < bufferEnd)
        {
            // Redraw each scan buffer once for every clip rectangle:

            i = EnumerateCount;
            clipRect = EnumerateRect;
            
            do {
                nextBuffer = DrawScanRecords_Dci(
                    bits, 
                    stride,
                    buffer, 
                    bufferEnd,
                    clientOffset.x,
                    clientOffset.y,
                    clipRect->left, 
                    clipRect->top, 
                    clipRect->right, 
                    clipRect->bottom
                );
                
            } while (clipRect++, --i);

            buffer = nextBuffer;
        }
    }

    // Unlock the primary:

    Globals::DciEndAccessFunction(DciSurface);   
}

/**************************************************************************\
*
* Function Description:
*
*   Try to re-initialize DCI after a Lock failure (as may be caused by
*   a switch to a secure desktop).  This will succeed only if the mode
*   is exactly the same resolution and color depth as it was before
*   (otherwise our clipping or halftone or whatever would be wrong if
*   we continued).
*
* Return Value:
*
*   TRUE if successfully re-initialized; FALSE if not (with the side
*   effect that we switch to using GDI).
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

BOOL
EpScanGdiDci::Reinitialize_Dci()
{
    ASSERT(Status == GdiDciStatus_UseDci);

    DWORD oldBitCount = DciSurface->dwBitCount;
    DWORD oldWidth = DciSurface->dwWidth;
    DWORD oldHeight = DciSurface->dwHeight;

    Globals::DciDestroyFunction(DciSurface);

    DciSurface = NULL;

    if (Globals::DciCreatePrimaryFunction(Device->DeviceHdc, 
                                          &DciSurface) == DCI_OK)
    {
        if ((DciSurface->dwBitCount == oldBitCount) &&
            (DciSurface->dwWidth == oldWidth) &&
            (DciSurface->dwHeight == oldHeight))
        {
            return(TRUE);
        }
    }

    // Uh oh, we failed to recreate exactly the same surface.  Switch
    // over to using GDI:

    Status = GdiDciStatus_UseGdi;

    return(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Return the PixelFormatID for the given DCI surface.
*
*   Added because of bug #96879 - when I fixed it, I found that 
*   DCI would then succeed on the ATI Mach 64 GX's
*   non-standard 32bpp mode, and we were happily trying to draw it
*   (and getting our colors mixed up).
*
* Arguments:
*
*   si - The DCISURFACEINFO to examine
*
* Return Value:
*
*   The PixelFormatID.
*
* History:
*
*   09/10/2000 agodfrey
*       Created it.
*
\**************************************************************************/

static PixelFormatID
ExtractPixelFormatFromDCISurface(
    DCISURFACEINFO *si
    )
{
    // 8bpp
    if (si->dwBitCount == 8)
    {
        return PixelFormat8bppIndexed;
    }
    
    // 24bpp RGB and 32bpp RGB
    if ((si->dwMask[0] == 0x00ff0000) &&       
        (si->dwMask[1] == 0x0000ff00) &&     
        (si->dwMask[2] == 0x000000ff))        
    {                                             
        if (si->dwBitCount == 24)
        {
            return PixelFormat24bppRGB;
        }
        else if (si->dwBitCount == 32)
        {
            return PixelFormat32bppRGB;
        }
    }

    // 16bpp 555
    if ((si->dwMask[0] == 0x00007c00) &&  
        (si->dwMask[1] == 0x000003e0) &&
        (si->dwMask[2] == 0x0000001f) && 
        (si->dwBitCount == 16))       
    {
        return PixelFormat16bppRGB555;
    }
    
    // 16bpp 565
    if ((si->dwMask[0] == 0x0000f800) &&  
        (si->dwMask[1] == 0x000007e0) &&
        (si->dwMask[2] == 0x0000001f) && 
        (si->dwBitCount == 16))       
    {
        return PixelFormat16bppRGB565;
    }

    // Unsupported format
    return PixelFormatUndefined;
}

/**************************************************************************\
*
* Function Description:
*
*   Does all the initialization needed for DCI.
*
* Return Value:
*
*   None
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
EpScanGdiDci::LazyInitialize_Dci()
{
    // If a mirror driver is active, never use DCI:

    if (Globals::IsMirrorDriverActive || Globals::g_fAccessibilityPresent)
    {
        Status = GdiDciStatus_UseGdi;
        return;
    }

    // Use the LoadLibrary critical section to protect access
    // to our global variables.

    LoadLibraryCriticalSection llcs;

    // We'll lose memory if we're called more than once:

    ASSERT(Status == GdiDciStatus_TryDci);

    // DCIMAN32 exists on all versions of Win9x and NT4 and newer.  

    if (Globals::DcimanHandle == NULL)
    {
        // Note: [minliu: 12/18/2000] The reason I added this following line
        // here:
        // 1) This is Office bug #300329
        // 2) The basic problem is that on Windows 98, with ATI Fury Pro/Xpert
        // 2000 Pro (English) card, with latest display driver,
        // wme_w98_r128_4_12_6292.exe. The floating point control state get
        // changed after we call LoadLibraryA("dciman32.dll"). Apparently the
        // display driver changes it. We are going to reporting this problem to
        // ATI Tech. In the meantime we need to check this in so that
        // PowerPointer can be launched on that machine

        FPUStateSandbox fps;

        HMODULE module = LoadLibraryA("dciman32.dll");
        if (module)
        {
            Globals::DciEndAccessFunction = (DCIENDACCESSFUNCTION)
                GetProcAddress(module, "DCIEndAccess");
            Globals::DciBeginAccessFunction = (DCIBEGINACCESSFUNCTION)
                GetProcAddress(module, "DCIBeginAccess");
            Globals::DciDestroyFunction = (DCIDESTROYFUNCTION)
                GetProcAddress(module, "DCIDestroy");
            Globals::DciCreatePrimaryFunction = (DCICREATEPRIMARYFUNCTION)
                GetProcAddress(module, "DCICreatePrimary");

            if ((Globals::DciEndAccessFunction     != NULL) &&
                (Globals::DciBeginAccessFunction   != NULL) &&
                (Globals::DciDestroyFunction       != NULL) &&
                (Globals::DciCreatePrimaryFunction != NULL))
            {
                Globals::DcimanHandle = module;
            }
            else
            {
                // It failed, so free the library.

                FreeLibrary(module);
            }
        }    
    }

    if (Globals::DcimanHandle != NULL)
    {
        if (Globals::DciCreatePrimaryFunction(Device->DeviceHdc,
                                              &DciSurface) == DCI_OK)
        {
            // Check that the format is one we can handle natively.

            if (EpAlphaBlender::IsSupportedPixelFormat(
                    ExtractPixelFormatFromDCISurface(DciSurface)))
            {
                PixelSize = DciSurface->dwBitCount >> 3;

                CacheRegionHandle = CreateRectRgn(0, 0, 0, 0);
                if (CacheRegionHandle)
                {
                    // Okay, initialize the whole class:

                    // We're all set to use DCI:

                    Status = GdiDciStatus_UseDci;
                    return;
                }
            }
            
            Globals::DciDestroyFunction(DciSurface);
            DciSurface = NULL;
        }
    }

    // Darn, we can't use DCI.  

    Status = GdiDciStatus_UseGdi;
}

/**************************************************************************\
*
* Function Description:
*
*   Handles a SrcOver call via GDI routines, making sure to do the
*   smallest GDI calls possible
*
* Return Value:
*
*   None
*
* History:
*
*   03/22/2000 andrewgo
*       Created it.
*
\**************************************************************************/

static BOOL OptimizeRuns(ARGB *src, INT width)
{
    if (width <= 8)
        return TRUE;

    BYTE * alpha = reinterpret_cast<BYTE*>(src) + 3;
    UINT numberOfRuns = 0;
    BOOL inRun = FALSE;
    for (INT pos = 0; pos < width; ++pos, alpha += 4)
    {
        if (static_cast<BYTE>(*alpha + 1) <= 1)
        {
            if (inRun)
            {
                ++numberOfRuns;
                if (numberOfRuns > 4)
                    return TRUE;
                inRun = FALSE;
            }
        }
        else
        {
            inRun = TRUE;
        }
    }
    return FALSE;
} // OptimizeRuns

VOID
EpScanGdiDci::SrcOver_Gdi_ARGB(
    HDC destinationHdc,
    HDC dibSectionHdc,
    VOID *dibSection,
    EpScanRecord *scanRecord
    )
{
    BYTE* alpha;
    INT left;
    INT right;
    INT bltWidth;
    
    VOID *src = NULL;
    BYTE *ctBuffer = NULL;
    EpScanType scanType = scanRecord->GetScanType();
    
    if (scanType != EpScanTypeCTSolidFill)
    {
        src = scanRecord->GetColorBuffer();
    }

    if (   (scanType == EpScanTypeCT)
        || (scanType == EpScanTypeCTSolidFill))
    {
        ctBuffer = scanRecord->GetCTBuffer(
            GetPixelFormatSize(BlenderConfig[0].SourcePixelFormat) >> 3
            );
    }
    
    INT x = scanRecord->X;
    INT y = scanRecord->Y;
    INT width = scanRecord->Width;

    if (GetPixelFormatSize(Surface->PixelFormat) < 8)
    {
        // [agodfrey]: #98904 - we hit an assert or potential AV in 
        //   Convert_8_sRGB, because the buffer contains values that 
        //   are out-of-range of the palette. To fix this, zero the
        //   temporary buffer whenever we're in less than 8bpp mode.
        
        GpMemset(dibSection, 0, width);
    }

    BOOL optimizeStretchBlt = FALSE;
    if (   (BlenderConfig[0].ScanType == EpScanTypeCT)
        || (BlenderConfig[0].ScanType == EpScanTypeCTSolidFill))
        optimizeStretchBlt = TRUE;
    else
        optimizeStretchBlt = OptimizeRuns(
            reinterpret_cast<ARGB *>(src), 
            width
            );

    if (optimizeStretchBlt)
    {
        StretchBlt(dibSectionHdc, 0, 0, width, 1, 
                   destinationHdc, x, y, width, 1, 
                   SRCCOPY);
    }
    else
    {
        ASSERT(src != NULL);
        
        // We discovered on NT5 that some printer drivers will fall over
        // if we ask to blt from their surface.  Consequently, we must
        // ensure we never get into this code path for printers!
    
        // [ericvan] This improperly asserts on compatible printer DC's
        // [agodfrey] No, see Start().

        // ASSERT(GetDeviceCaps(destinationHdc, TECHNOLOGY) != DT_RASPRINTER);

        // Only read those pixels that we have to read.  In benchmarks
        // where we're going through GDI to the screen or to a compatible
        // bitmap, we're getting killed by our per-pixel read costs.
        // Terminal Server at least has the 'frame buffer' sitting in
        // system memory, but with NetMeeting we still have to read from
        // video memory.
        //
        // Unfortunately, the per-call overhead of StretchBlt is fairly
        // high (but not too bad when we're using a DIB-section - it 
        // beats the heck out of StretchDIBits).

        alpha = reinterpret_cast<BYTE*>(src) + 3;
        right = 0;
        while (TRUE)
        {
            // Find the first translucent pixel:

            left = right;
            while ((left < width) && (static_cast<BYTE>(*alpha + 1) <= 1))
            {
                left++;
                alpha += 4;
            }

            // If there are no more runs of translucent pixels,
            // we're done:

            if (left >= width)
                break;

            // Now find the next completely transparent or opaque 
            // pixel:

            right = left;
            while ((right < width) && (static_cast<BYTE>(*alpha + 1) > 1))
            {
                right++;
                alpha += 4;
            }

            bltWidth = right - left;

            // BitBlt doesn't work on Multimon on Win2K when the destinationHdc
            // is 8bpp.  But StretchBlt does work.

            StretchBlt(dibSectionHdc, left, 0, bltWidth, 1, 
                       destinationHdc, x + left, y, bltWidth, 1, 
                       SRCCOPY);
        }
    }

    // Do the blend:

    BlenderConfig[scanRecord->BlenderNum].AlphaBlender.Blend(
        dibSection, 
        src, 
        width, 
        x - DitherOriginX, 
        y - DitherOriginY,
        ctBuffer
    );

    if (optimizeStretchBlt)
    {
        StretchBlt(destinationHdc, x, y, width, 1,
                   dibSectionHdc, 0, 0, width, 1,
                   SRCCOPY);
    }
    else
    {
        // Write the portions that aren't completely transparent back 
        // to the screen:

        alpha = reinterpret_cast<BYTE*>(src) + 3;
        right = 0;
        while (TRUE)
        {
            // Find the first non-transparent pixel:

            left = right;
            while ((left < width) && (*alpha == 0))
            {
                left++;
                alpha += 4;
            }

            // If there are no more runs of non-transparent pixels,
            // we're done:

            if (left >= width)
                break;

            // Now find the next completely transparent pixel:

            right = left;
            while ((right < width) && (*alpha != 0))
            {
                right++;
                alpha += 4;
            }

            bltWidth = right - left;

            // BitBlt doesn't work on Multimon on Win2K when the 
            // destinationHdc is 8bpp.  But StretchBlt does work.

            StretchBlt(destinationHdc, x + left, y, bltWidth, 1,
                       dibSectionHdc, left, 0, bltWidth, 1,
                       SRCCOPY);
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Processes all the data in the queue and resets it to be empty.
*
* Return Value:
*
*   None
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
EpScanGdiDci::ProcessBatch_Gdi(
    HDC destinationHdc,
    EpScanRecord *buffer,
    EpScanRecord *bufferEnd
    )
{
    ULONG type;
    INT x;
    INT y;
    INT width;
    VOID *dibSection;
    HDC dibSectionHdc;

    // Set up the AlphaBlender objects
    
    PixelFormatID dstFormat;

    // We must never be called with an empty batch.
    
    ASSERT(MaxX >= MinX);
    
    // We should be using Surface->Width as an upper bound on 
    // our internal blending buffer, but because of other bugs
    // we're potentially using the wrong Surface here.
    // Instead we use the width of the bounding rectangle for
    // all the spans in the batch.
    
    BOOL result = Device->GetScanBuffers(
        //Surface->Width,
        MaxX - MinX,
        &dibSection,
        &dibSectionHdc,
        &dstFormat,
        Buffers
    );
        
    if (result && (dstFormat != PIXFMT_UNDEFINED))
    {
        // Palette and PaletteMap are set up by Start().
        // initialize the AlphaBlenders.
        
        BlenderConfig[0].Initialize(
            dstFormat,
            Context,
            Context->Palette ? Context->Palette : Device->Palette, 
            Buffers,
            TRUE,
            TRUE,
            SolidColor
        );
        
        BlenderConfig[1].Initialize(
            dstFormat,
            Context,
            Context->Palette ? Context->Palette : Device->Palette, 
            Buffers,
            TRUE,
            TRUE,
            SolidColor
        );
    }    
    else
    {
        ONCE(WARNING(("EmptyBatch_Gdi: Unrecognized pixel format")));
        return;
    }
    
    INT ditherOriginX = DitherOriginX;
    INT ditherOriginY = DitherOriginY;
    
    do {
        INT blenderNum = buffer->BlenderNum;
        
        x = buffer->X + BatchOffsetX;
        y = buffer->Y + BatchOffsetY;
        width = buffer->Width;

        // This must never happen. If it does, we are going to write off
        // the end of our DIBSection and blending buffers. On win9x this will
        // overwrite some stuff in GDI and bring down the entire system.
        // On NT we'll AV and bring down the app.
                
        ASSERT(width <= Device->BufferWidth);
        
        EpScanType scanType = buffer->GetScanType();
        
        if (scanType != EpScanTypeOpaque)
        {
            SrcOver_Gdi_ARGB(
                destinationHdc, 
                dibSectionHdc, 
                dibSection, 
                buffer
            );
        }
        else
        {
            ASSERT(scanType == EpScanTypeOpaque);

            // Do the copy:
    
            BlenderConfig[blenderNum].AlphaBlender.Blend(
                dibSection, 
                buffer->GetColorBuffer(),
                width, 
                x - ditherOriginX, 
                y - ditherOriginY,
                NULL
            );
    
            // Write the result back to the screen:
    
            StretchBlt(destinationHdc, x, y, width, 1, 
                       dibSectionHdc, 0, 0, width, 1, 
                       SRCCOPY);
        }

        // Advance to the next buffer:

        buffer = buffer->NextScanRecord(
            GetPixelFormatSize(BlenderConfig[blenderNum].SourcePixelFormat) >> 3
        );

    } while (buffer < bufferEnd);
}


/**************************************************************************\
*
* Function Description:
*
*   Takes a batch as input and calls the internal flush 
*   mechanism to process it after which it restores the 
*   internal state.
*
* Notes
*   
*   This routine can handle multiple pixel formats with different
*   SourceOver or SourceCopy combinations.
*
* Return Value:
*
*   TRUE
*
* History:
*
*   5/4/2000 asecchia
*       Created it.
*
\**************************************************************************/
    
BOOL EpScanGdiDci::ProcessBatch(
    EpScanRecord *batchStart, 
    EpScanRecord *batchEnd,
    INT minX,
    INT minY, 
    INT maxX,
    INT maxY
)
{
    // NOTE: From the comments for class EpScan:
    // NOTE: These classes are not reentrant, and therefore cannot be used
    //       by more than one thread at a time.  In actual use, this means
    //       that their use must be synchronized under the device lock.
    
    // Flush the batch
    
    Flush();

    // Save the buffers
    
    EpScanRecord *bs = BufferStart;          // Points to queue buffer start
    EpScanRecord *be = BufferEnd;            // Points to end of queue buffer
    EpScanRecord *bc = BufferCurrent;        // Points to current queue position
    INT size = BufferSize;                   // Size of queue buffer in bytes
    
    // Set up the buffers for the new batch.
    
    BufferStart   = batchStart;
    BufferEnd     = batchEnd;
    BufferCurrent = batchEnd;

    // note this implies that the buffer is not larger than MAXINT
    // !!! [asecchia] not sure if the Flush needs this to be set.

    BufferSize    = (INT)((INT_PTR)batchEnd - (INT_PTR)batchStart);

    // Set the bounds:
    // Don't need to save the old bounds because the flush will reset them.

    MinX = minX;
    MinY = minY;
    MaxX = maxX;
    MaxY = maxY;

    // Set the batch offset to the drawing offset.

    BatchOffsetX = minX;
    BatchOffsetY = minY;

    // Flush the batch.
    
    Flush();

    // Restore the buffers.

    BufferStart = bs;
    BufferEnd = be;
    BufferCurrent = bc;
    BufferSize = size;

    BatchOffsetX = 0;
    BatchOffsetY = 0;

    return TRUE;
}


/**************************************************************************\
*
* Function Description:
*
*   Instantiates a scan instance for rendering to the screen via either
*   DCI or GDI.
*
* Return Value:
*
*   FALSE if all the necessary buffers couldn't be created
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

BOOL
EpScanGdiDci::Start(
    DpDriver *driver,
    DpContext *context,
    DpBitmap *surface,
    NEXTBUFFERFUNCTION *nextBuffer,
    EpScanType scanType,                  
    PixelFormatID pixFmtGeneral,
    PixelFormatID pixFmtOpaque,
    ARGB solidColor
    )
{
    // Inherit initialization
    
    // This sets up BlenderConfig[]. Mostly, these will be used at the time
    // we flush the batch. But BlenderConfig[0].ScanType is also used in
    // GetCurrentCTBuffer().
    
    EpScan::Start(
        driver, 
        context, 
        surface, 
        nextBuffer,
        scanType,
        pixFmtGeneral, 
        pixFmtOpaque,
        solidColor
    );

    BOOL bRet = TRUE;
    
    // Record the solid color for later
    
    SolidColor = solidColor;

    // The ScanBuffer and EpScan classes _MUST_ be protected by
    // the Device Lock - if you hit this ASSERT, go and acquire
    // the Devlock before entering the driver.
    // EpScanGdiDci is used exclusively for drawing to the screen, therefore
    // we assert on the DesktopDriver Device being locked. If you're locking
    // some other device, that's also a bug - use a different EpScan class.

    ASSERT(Globals::DesktopDriver->Device->DeviceLock.IsLockedByCurrentThread());

    // First check to see if we have something in the queue for a different
    // Graphics (which can happen with multiple threads drawing to different 
    // windows, since we only have one queue):

    if ((context != Context) || (surface != Surface))
    {
        // Check to see if we have to do a lazy initialize:
    
        if (Status == GdiDciStatus_TryDci)
        {
            LazyInitialize_Dci();
        }

        EmptyBatch();

        // We stash away a pointer to the context.  Note that the GpGraphics
        // destructor always calls us to flush, thus ensuring that we
        // won't use a stale Context pointer in the EmptyBatch call above.

        Context = context;
        Surface = surface;
    }

    GpCompositingMode compositingMode = context->CompositingMode;
    
    // !!![andrewgo] We discovered that NT will fall over with some printer
    //               drivers if we ask to read from the printer surface.
    //               But we should never be hitting the scan interface in
    //               the printer case!  (Scans are too much overhead, and
    //               alpha should be handled via screen-door anyway.)

    // [ericvan] This improperly asserts on compatible printer DC's
    // [agodfrey] No, we should have a separate scan class for that case
    //            - one which doesn't batch up the scans, and doesn't try to
    //            use DCI. Printer DC's also shouldn't have a pointer
    //            to the desktop device.
    //            If this is fixed, the assertion below can be reenabled.
    
    //ASSERT(GetDeviceCaps(Context->Hdc, TECHNOLOGY) != DT_RASPRINTER);

    // GDI and DCI destinations don't have an alpha channel:
    
    ASSERT(surface->SurfaceTransparency == TransparencyNoAlpha);
    
    // Allocate our queue buffer, if necessary:

    // This makes some assumptions:
    // 1) The records in blender 0 are bigger than records in blender 1.
    // 2) The biggest color buffer format is 4 bytes per pixel.
    
    EpScanRecord *maxRecordEnd = EpScanRecord::CalculateNextScanRecord(
        BufferCurrent,
        BlenderConfig[0].ScanType,
        surface->Width,
        4);
        
    INT_PTR requiredSize = reinterpret_cast<BYTE *>(maxRecordEnd) - 
                           reinterpret_cast<BYTE *>(BufferCurrent);
    
    if (requiredSize > BufferSize)
    {
        // If we need to resize, it follows that there should be nothing
        // sitting in the queue for this surface:
        //
        // [agodfrey] It does? More explanation needed.

        ASSERT(BufferCurrent == BufferStart);

        // Free the old queue and allocate a new one:

        GpFree(BufferMemory);

        // Scan records are much smaller than 2GB, so 'requiredSize' will fit
        // into an INT.
        
        ASSERT(requiredSize < INT_MAX);
    
        BufferSize = (INT)max(requiredSize, SCAN_BUFFER_SIZE);
        
        // We may need up to 7 extra bytes in order to QWORD align BufferStart.
        
        BufferMemory = GpMalloc(BufferSize+7);
        if (BufferMemory == NULL)
        {
            BufferSize = 0;
            bRet = FALSE;
            return bRet;
        }
        BufferStart = MAKE_QWORD_ALIGNED(EpScanRecord *, BufferMemory);

        // Make sure that we didn't overstep the 7 
        // padding bytes in the allocation.
        
        ASSERT(((INT_PTR) BufferStart) - ((INT_PTR) BufferMemory) <= 7);

        BufferEnd = reinterpret_cast<EpScanRecord *>
                        (reinterpret_cast<BYTE*>(BufferStart) + BufferSize);

        BufferCurrent = BufferStart;
    }

    *nextBuffer = (NEXTBUFFERFUNCTION) EpScanGdiDci::NextBuffer;

    // Cache the translation vector and palette for the device.  We only 
    // need to do so in 8bpp mode.
    //
    // Update the color palette and palette map if necessary.

    if (Device->Palette != NULL)
    {
        // Grab the DC just for the purposes of looking at the palette
        // selected:

        HDC destinationHdc = context->GetHdc(surface);

        EpPaletteMap *paletteMap = context->PaletteMap;
        if (paletteMap != NULL) 
        {
            // IsValid() check isn't necessary because if we are in an
            // invalid state, we may be able to get out of it in
            // UpdateTranslate()

            if (paletteMap->GetUniqueness() != Globals::PaletteChangeCount)
            {
                paletteMap->UpdateTranslate(destinationHdc);
                paletteMap->SetUniqueness(Globals::PaletteChangeCount);
            }
        }
        else
        {
            paletteMap = new EpPaletteMap(destinationHdc);

            if (paletteMap != NULL)
            {
                paletteMap->SetUniqueness(Globals::PaletteChangeCount);

                // This is very silly, but we must update this map to
                // the entire DpContext chain...
                // !!![andrewgo] Is this thread safe?
                // !!![andrewgo] Is this stuff cleaned up?
                // !!![andrewgo] This all looks really wrong...

                DpContext* curContext = Context;
                while (curContext != NULL)
                {
                    curContext->PaletteMap = paletteMap;
                    curContext = curContext->Prev;
                }
            }
            else
            {
                bRet = FALSE;
            }
        }

        context->ReleaseHdc(destinationHdc);
    }

    return bRet;
}


/**************************************************************************\
*
* Function Description:
*
*   Processes all the data in the queue and resets it to be empty.
*
* Return Value:
*
*   None
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
EpScanGdiDci::EmptyBatch()
{
    // Watch out for an empty batch (which can happen with Flush or with 
    // the first allocation of the queue buffer):

    if (BufferCurrent != BufferStart)
    {
        // If we're emptying a non-empty batch, it follows that we
        // should no longer be unsure whether we'll be using DCI or GDI:

        ASSERT(Status != GdiDciStatus_TryDci);

        // Remember where we are in the queue:

        EpScanRecord *bufferStart = BufferStart;
        EpScanRecord *bufferEnd = BufferCurrent;
    
        // Reset the queue before doing anything else, in case whatever
        // we're doing causes us to force a 'surface->Flush()' call
        // (which would re-enter this routine):
    
        BufferCurrent = BufferStart;

        // Use DCI to process the queue if DCI was successfully enabled.
        //
        // On NT we also add the weird condition that we won't invoke
        // DCI if the user is actively moving a window around.  The 
        // reason is that NT is forced to repaint the whole desktop if
        // the Visrgn for any window changes while a DCI primary surface
        // lock is held (this is how NT avoids having something like
        // the Win16Lock, which would let a user-mode app prevent windows
        // from moving, an obvious robustness issue).
        //
        // Note that the 'IsMoveSizeActive' thing is not a fool-proof 
        // solution for avoiding whole-desktop repaints (since there's
        // a chance the user could still move a window while we're 
        // in ProcessBatch_Dci), but as a heuristic it works quite well.
        //
        // To summarize, drop through to GDI rendering codepath if any
        // of the following conditions are TRUE:
        //
        //  ICM required
        //      Thus we must go through GDI to use ICM2.0 support.
        //
        //  DCI disabled
        //      We have no choice but to fallback to GDI.
        //
        //  GDI layering
        //      GDI layering means that GDI is hooking rendering to the
        //      screen and invisibly redirecting output to a backing store.
        //      Thus, the actual rendering surface is inaccessible via DCI
        //      and we must fallback to GDI.
        //
        //  Window move or resize processing
        //      To prevent excessive repainting

        if ((Context->IcmMode != IcmModeOn) && 
            (Context->GdiLayered == FALSE) &&
            (Status == GdiDciStatus_UseDci) && 
            (!Globals::IsMoveSizeActive) &&
            (!Globals::g_fAccessibilityPresent))
        {
            // If the Graphics was derived using an Hwnd, we have to use that
            // to first get an HDC which we can query for clipping.
            //
            // Note that we don't need a 'clean' DC in order to query the
            // clipping, so we don't call GetHdc() if we already have a DC
            // hanging around:

            HDC hdc = Context->Hdc;
            if (Context->Hwnd != NULL)
            {
                hdc = Context->GetHdc(Surface);   
            }                                   

            ProcessBatch_Dci(hdc, bufferStart, bufferEnd);

            if (Context->Hwnd != NULL)
            {
                Context->ReleaseHdc(hdc, Surface);
            }
        }
        else
        {
            // We need a clean DC if we're going to draw using GDI:

            HDC hdc = Context->GetHdc(Surface);

            ProcessBatch_Gdi(hdc, bufferStart, bufferEnd);

            Context->ReleaseHdc(hdc);
        }

        // Reset our bounds.  

        MinX = INT_MAX;
        MinY = INT_MAX;
        MaxX = INT_MIN;
        MaxY = INT_MIN;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Flushes any buffers in the DCI queue.  Note that the DCI queue can
*   be accumulated over numerous API calls without flushing, which forces
*   us to expose a Flush mechanism to the application.
*
* Return Value:
*
*   None
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
EpScanGdiDci::Flush()
{
    // Note that we might be called to Flush even before we've
    // initialized DCI:

    EmptyBatch();
}

/**************************************************************************\
*
* Function Description:
*
*   Ends the previous buffer (if there was one), and returns the
*   next buffer for doing a SrcOver blend.
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

VOID *EpScanGdiDci::NextBuffer(
    INT x,
    INT y,
    INT nextWidth,
    INT currentWidth,
    INT blenderNum
    )
{
    ASSERT(nextWidth >= 0);
    ASSERT(currentWidth >= 0);

    // Avoid pointer aliasing by loading up a local copy:

    EpScanRecord *bufferCurrent = BufferCurrent;

    // The first call that a drawing routine makes to us always has
    // a 'currentWidth' of 0 (since it doesn't have a 'current'
    // buffer yet):

    if (currentWidth != 0)
    {
        // Accumulate the bounds using the final, completed scan:

        INT xCurrent = bufferCurrent->X;
        MinX = min(MinX, xCurrent);
        MaxX = max(MaxX, xCurrent + currentWidth);

        INT yCurrent = bufferCurrent->Y;
        MinY = min(MinY, yCurrent);
        MaxY = max(MaxY, yCurrent);

        // Complete the previous scan request.

        // Now that we know how much the caller actually wrote into
        // the buffer, update the width in the old record and advance
        // to the next:

        bufferCurrent->Width = currentWidth;
                
        bufferCurrent = bufferCurrent->NextScanRecord(
            GetPixelFormatSize(
                BlenderConfig[bufferCurrent->BlenderNum].SourcePixelFormat
            ) >> 3
        );

        // Don't forget to update the class version:

        BufferCurrent = bufferCurrent;
    }

    // From here on, the code is operating on the current scan request
    // I.e. bufferCurrent applies to the current scan - it has been updated
    // and no longer refers to the last scan.
    
    // See if there's room in the buffer for the next scan:

    // bufferCurrent is not initialized for this scan yet, so we can't rely
    // on it having a valid PixelFormat - we need to get the PixelFormat
    // from the context of the call.

    PixelFormatID pixFmt = BlenderConfig[blenderNum].SourcePixelFormat;

    EpScanRecord* scanEnd = EpScanRecord::CalculateNextScanRecord(
        bufferCurrent,
        BlenderConfig[blenderNum].ScanType,
        nextWidth,
        GetPixelFormatSize(pixFmt) >> 3
    );

    if (scanEnd > BufferEnd)
    {
        EmptyBatch();

        // Reload our local variable:

        bufferCurrent = BufferCurrent;
    }

    // Remember the x and y for the brush offset (halftone & dither).
    // Note: We do not have to remember x and y in CurrentX and CurrentY
    // because we remember them in bufferCurrent (below).
    // CurrentX = x;
    // CurrentY = y;
    
    // Initialize the bufferCurrent.
    // We initialize everything except the width - which we don't know till
    // the caller is done and we get called for the subsequent scan.
    
    bufferCurrent->SetScanType(BlenderConfig[blenderNum].ScanType);
    bufferCurrent->SetBlenderNum(blenderNum);
    bufferCurrent->X = x;
    bufferCurrent->Y = y;
    bufferCurrent->OrgWidth = nextWidth;
   
    // Note: we don't actually use LastBlenderNum in the EpScanGdiDci
    // See EpScanEngine for a class that uses it.
    // LastBlenderNum = blenderNum;
    
    return bufferCurrent->GetColorBuffer();
}

/**************************************************************************\
*
* Function Description:
*
*   Denotes the end of the use of the scan buffer for this API call.
*   Note that this does not force a flush of the buffer.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
EpScanGdiDci::End(
    INT updateWidth
    )
{
    // Get the last record into the queue:

    NextBuffer(0, 0, 0, updateWidth, 0);

    // Note that we do not flush the buffer here for DCI!  This is VERY 
    // INTENDED, to allow spans to be batched across primitives.  In fact, 
    // THAT'S THE WHOLE POINT OF THE BATCHING!

    // !!![andrewgo] Actually, our scan architecture needs to be fixed
    //               to allow this for the GDI cases too.  If I don't
    //               flush here for the GDI case, we die running
    //               Office CITs in Graphics::GetHdc when we do the
    //               EmptyBatch, because there's a stale Context in 
    //               the non-empty batch buffer from previous drawing
    //               that didn't get flushed on ~GpGraphics because
    //               the driver didn't pass the Flush through to the
    //               scan class!

    // if (Status != GdiDciStatus_UseDci)
    {
        EmptyBatch();
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor for all GDI/DCI drawing.  
*
* Return Value:
*
*   None
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

EpScanGdiDci::EpScanGdiDci(GpDevice *device, BOOL tryDci)
{
    Device = device;
    Status = (tryDci) ? GdiDciStatus_TryDci : GdiDciStatus_UseGdi;

    Context = NULL;
    Surface = NULL;

    BufferSize = 0;
    BufferMemory = NULL;
    BufferCurrent = NULL;
    BufferStart = NULL;
    BufferEnd = NULL;
    CacheRegionHandle = NULL;
    CacheRegionData = NULL;
    CacheDataSize = 0;

    MinX = INT_MAX;
    MinY = INT_MAX;
    MaxX = INT_MIN;
    MaxY = INT_MIN;

    BatchOffsetX = 0;
    BatchOffsetY = 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Destructor for the GDI/DCI interface.  Typically only called when
*   the 'device' is destroyed.
*
* Return Value:
*
*   None
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*
\**************************************************************************/

EpScanGdiDci::~EpScanGdiDci()
{
    if (Status == GdiDciStatus_UseDci)
    {
        // DciDestroy doesn't do anything if 'DciSurface' is NULL:

        Globals::DciDestroyFunction(DciSurface);
    }

    DeleteObject(CacheRegionHandle);
    GpFree(CacheRegionData);
    GpFree(BufferMemory);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\scandib.cpp ===
/**************************************************************************\
*  
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Abstract:
*
*   Internal scan class.
*   Use ARGB buffer for all scan drawing, and Blt to destination when done.
*
* Revision History:
*
*   07/26/1999 t-wehunt
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#ifdef DBGALPHA
const ULONG gDebugAlpha = 0;
#endif

#define ALPHA_BYTE_INDEX 3
#define SRC_PIX_SIZE 4

#define RoundDWORD(x) (x + ((x%sizeof(DWORD))>0?(sizeof(DWORD)-(x%sizeof(DWORD))):0))
#define IsInteger(x) (GpFloor(x) == x)

static int TranslateHTTable = 0;

EpScanDIB::EpScanDIB() :
   BufStart(NULL),
   CurBuffer(NULL),
   MaskStart(NULL),
   AlphaStart(NULL),
   OutputWidth(-1),
   OutputBleed(0),
   NextBuffer(NULL),
   ZeroOutPad(2)
{
}

/**************************************************************************\
*
* Function Description:
*
*   Starts a scan.
*
* Arguments:
*
*   [IN] driver - Driver interface
*   [IN] context - Drawing context
*   [IN] surface - Destination surface
*   [IN] compositeMode - Alpha blend mode
*   [OUT] nextBuffer - Points to a EpScan:: type function to return
*                      the next buffer
*
* Return Value:
*
*   FALSE if all the necessary buffers couldn't be created
*
* History:
*
*   07/13/1999 t-wehunt
*       Created it.
*
\**************************************************************************/

BOOL
EpScanDIB::Start(
    DpDriver *driver,
    DpContext *context,
    DpBitmap *surface,
    NEXTBUFFERFUNCTION *nextBuffer,
    EpScanType scanType,                  
    PixelFormatID pixFmtGeneral,
    PixelFormatID pixFmtOpaque,
    ARGB solidColor
    )
{
    // Inherit initialization
    
    EpScan::Start(
        driver, 
        context, 
        surface, 
        nextBuffer, 
        scanType,
        pixFmtGeneral, 
        pixFmtOpaque,
        solidColor
    );    
    
    // Printer surfaces don't have an alpha channel.
    ASSERT(surface->SurfaceTransparency == TransparencyNoAlpha);
    
    *nextBuffer = NextBuffer;
    ASSERT(NextBuffer != NULL);

    // !! Add more asserts for valid state.
    OutputX = -1;
    OutputY = -1;
    OutputWidth = -1;
    OutputBleed = -1;
    Rasterizing = TRUE;

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Denotes the end of the use of the scan buffer.
*
* Arguments:
*
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   None.
*
* History:
*
*   07/13/1999 t-wehunt
*       Created it.
*
\**************************************************************************/

VOID 
EpScanDIB::End(INT updateWidth)
{
    // it is the driver's job to decide what to do with us and they
    // MUST call ReleaseBuffer() as appropriate

    // Flush the last scan... This is always required, since at the very
    // least, we unpremultiply the scan line.

    Rasterizing = FALSE;

    if (RenderAlpha)
    {
        if (!(ScanOptions & ScanDeviceZeroOut))
        {
            (this->*NextBuffer)(
                DeviceBounds.X + DeviceBounds.Width,
                DeviceBounds.Y + DeviceBounds.Height, 
                0, 
                updateWidth,
                0
            );
        }
        else if (OutputWidth > 0)
        {
            // we must flush the last zeroArray.
            BYTE* bitsPtr = BufStart + CappedStride * 
              ((CappedBounds.Height-1) - ((OutputY/ScaleY) - CappedBounds.Y));
            DWORD* zeroPtr = (DWORD*) ZeroStart;

            INT count = CappedBounds.Width;
            while (count--)
            {
                if (*zeroPtr++ == 0)
                { 
                    *bitsPtr++ = '\0';
                    *bitsPtr++ = '\0';
                    *bitsPtr++ = '\0';
                }
                else
                {
                    bitsPtr += 3;
                }
            }
        }
    }
    else
    {
        (this->*NextBuffer)(
            CappedBounds.X + CappedBounds.Width,
            CappedBounds.Y + CappedBounds.Height, 
            0, 
            updateWidth,
            0
        );
    }

    // Ensure we don't flush if we're called on another band
    OutputWidth = -1;
}

/**************************************************************************\
*
* Function Description:
*
* NextBufferFunc32bpp - Handles output when we are rasterizing at capped
*                       dpi to a 32bpp unpremultiplied DIB
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   3/9/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID*
EpScanDIB::NextBufferFunc32bpp(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    LastBlenderNum = blenderNum;
    ASSERT(!RenderAlpha);
    ASSERT(newWidth >= 0);
    ASSERTMSG(newWidth <= CappedBounds.Width, 
        ("Width exceeds SetBounds() request"));
    ASSERT(x >= CappedBounds.X && x <= (CappedBounds.X + CappedBounds.Width));
    ASSERT(y >= CappedBounds.Y && y <= (CappedBounds.Y + CappedBounds.Height));
    ASSERT((x + newWidth) <= (CappedBounds.X + CappedBounds.Width));
       
    ASSERT((ScanOptions & ScanCappedBounds) && (ScanOptions & ScanCapped32bpp));

    // !! Remove this when we standardize on unpremultiplied
#if 1
    if (OutputWidth > 0) 
    {
        while (OutputWidth--) 
        {
            // unpremultiply
            *CurBuffer = Unpremultiply(*CurBuffer);
            CurBuffer++;
        }
    }

    OutputWidth = newWidth;
#endif

    // return pointer directly into our 32bpp buffer
    return (CurBuffer = (((ARGB*)BufStart) + 
                         ((CappedBounds.Height - 1) - (y - CappedBounds.Y)) * 
                             CappedBounds.Width +
                         (x - CappedBounds.X)));
}

/**************************************************************************\
*
* Function Description:
*
* NextBufferFunc32bppOver - Handles output when we are rasterizing at capped
*                           DPI to a 32bpp unpremultiplied DIB.  Blends any
*                           alpha with background WHITENESS.
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   3/9/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID*
EpScanDIB::NextBufferFunc32bppOver(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    LastBlenderNum = blenderNum;
    ASSERT(!RenderAlpha);
    ASSERT(newWidth >= 0);
    ASSERTMSG(newWidth <= CappedBounds.Width, 
        ("Width exceeds SetBounds() request"));
    ASSERT(x >= CappedBounds.X && x <= (CappedBounds.X + CappedBounds.Width));
    ASSERT(y >= CappedBounds.Y && y <= (CappedBounds.Y + CappedBounds.Height));
    ASSERT((x + newWidth) <= (CappedBounds.X + CappedBounds.Width));
       
    ASSERT((ScanOptions & ScanCappedBounds) && (ScanOptions & ScanCapped32bppOver));

    // !! Remove this when we standardize on unpremultiplied
#if 1
    if (OutputWidth > 0) 
    {
        while (OutputWidth--) 
        {
            // An adaptation of the blending code from Andrew Godfrey's 
            // BlendOver function, but onto a white surface.  This is done to
            // improve the output quality of postscript.

            GpColor color(*CurBuffer);
            UINT32 alpha = color.GetAlpha();
            
            UINT32 alphaContrib;
            
            if (alpha == 0) 
            {
                *CurBuffer++ = 0x00FFFFFF;
            }
            else if (alpha == 255)
            {
                CurBuffer++;
            }
            else
            {
                // Dst = Src + (1-Alpha) * Dst
                UINT32 multA = 255 - alpha;
          
                UINT32 D1_000000FF = 0xFF;
                UINT32 D2_0000FFFF = D1_000000FF * multA + 0x00000080;
                UINT32 D3_000000FF = (D2_0000FFFF & 0x0000ff00) >> 8;
                UINT32 D4_0000FF00 = (D2_0000FFFF + D3_000000FF) & 0x0000FF00;
           
                alphaContrib = D4_0000FF00 >> 8;
            
                // store: (1-alpha)*0xFF + color for each B, G, R
                *CurBuffer++ = ((DWORD)(alphaContrib + color.GetBlue()) << GpColor::BlueShift) |
                               ((DWORD)(alphaContrib + color.GetGreen()) << GpColor::GreenShift) |
                               ((DWORD)(alphaContrib + color.GetRed()) << GpColor::RedShift) |
                               (alpha << GpColor::AlphaShift);
            }
        }
    }

    OutputWidth = newWidth;
#endif

    // return pointer directly into our 32bpp buffer
    return (CurBuffer = (((ARGB*)BufStart) + 
                         ((CappedBounds.Height - 1) - (y - CappedBounds.Y)) * 
                             CappedBounds.Width +
                         (x - CappedBounds.X)));
}

/**************************************************************************\
*
* Function Description:
*
* NextBufferFunc24bpp - Handles output when we are rasterizing at capped
*                       dpi to a 24bpp unpremultiplied DIB.
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   3/9/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID*
EpScanDIB::NextBufferFunc24bpp(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    LastBlenderNum = blenderNum;
    ASSERT(!RenderAlpha);
    ASSERT(newWidth >= 0);
    ASSERTMSG(newWidth <= CappedBounds.Width, 
        ("Width exceeds SetBounds() request"));
    ASSERT(x >= CappedBounds.X && x <= (CappedBounds.X + CappedBounds.Width));
    ASSERT(y >= CappedBounds.Y && y <= (CappedBounds.Y + CappedBounds.Height));
    ASSERT((x + newWidth) <= (CappedBounds.X + CappedBounds.Width));
       
    ASSERT((ScanOptions & ScanCappedBounds) && !(ScanOptions & ScanCapped32bpp));

    if (OutputWidth > 0) 
    {
        // compute destination location into 24bpp buffer
        BYTE* dstPos = BufStart + (OutputX - CappedBounds.X) * 3 +
             CappedStride * ((CappedBounds.Height - 1) - 
                             (OutputY - CappedBounds.Y));
        ARGB* srcPos = Buf32bpp;

        while (OutputWidth--) 
        {
            // convert from 32 ARGB to 24bpp RGB
#if 1
            // !! Remove this when we standardize on non-premultiplied
            GpColor color(Unpremultiply(*srcPos++));
#else
            GpColor color(*srcPos++);
#endif
            // NOTICE: Bytes are stored as Blue, Green, Red.
            *dstPos++ = (BYTE)color.GetBlue();
            *dstPos++ = (BYTE)color.GetGreen();
            *dstPos++ = (BYTE)color.GetRed();
        }
    }

    // record location of next scan
    OutputX = x;
    OutputY = y;
    OutputWidth = newWidth;
    
    return (ARGB*)Buf32bpp;
}

/**************************************************************************\
*
* Function Description:
*
* NextBufferFunc24bppBleed - Handles output when we are rasterizing at capped
*                            dpi to a 24bpp unpremultiplied DIB.  It bleeds
*                            the output to left and right of the scanned area.
*                            This prevents black jaggies from appearing in the
*                            output.
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   3/9/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID*
EpScanDIB::NextBufferFunc24bppBleed(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    LastBlenderNum = blenderNum;
    ASSERT(!RenderAlpha);
    ASSERT(newWidth >= 0);
    ASSERTMSG(newWidth <= CappedBounds.Width, 
        ("Width exceeds SetBounds() request"));
    ASSERT(x >= CappedBounds.X && x <= (CappedBounds.X + CappedBounds.Width));
    ASSERT(y >= CappedBounds.Y && y <= (CappedBounds.Y + CappedBounds.Height));
    ASSERT((x + newWidth) <= (CappedBounds.X + CappedBounds.Width));
       
    ASSERT((ScanOptions & ScanCappedBounds) && 
           !(ScanOptions & ScanCapped32bpp) &&
           (ScanOptions & ScanBleedOut));

    if (OutputWidth > 0) 
    {
        ARGB* srcPos = Buf32bpp;
        GpColor color(Unpremultiply(*srcPos));

        if ((OutputLastY == -1) && ((OutputY-CappedBounds.Y) != 0))
        {
            // Bleed up all previous subsequent scan lines.
            // compute destination location into 24bpp buffer
            BYTE* clearPos = BufStart + CappedStride * (CappedBounds.Height - 
                                 (OutputY - CappedBounds.Y));
            INT capHeight = OutputY - CappedBounds.Y;

            for (int cntY=0; cntY<capHeight; cntY++)
            {
                for (int cntX=0; cntX<CappedBounds.Width; cntX++)
                {
                    clearPos[cntX*3] = (BYTE)color.GetBlue();
                    clearPos[cntX*3+1] = (BYTE)color.GetGreen();
                    clearPos[cntX*3+2] = (BYTE)color.GetRed();
                }
                clearPos += CappedStride;
            }
        }

        // compute destination location into 24bpp buffer
        BYTE* dstPos = BufStart + (OutputBleed - CappedBounds.X) * 3 +
             CappedStride * ((CappedBounds.Height - 1) - 
                             (OutputY - CappedBounds.Y));
        
        // Bleed to the left
        INT count = OutputBleed;
        while (count++ < OutputX) 
        {
            *dstPos++ = (BYTE)color.GetBlue();
            *dstPos++ = (BYTE)color.GetGreen();
            *dstPos++ = (BYTE)color.GetRed();
        }

        // Output source pixels into destination surface
        count = OutputWidth;
        while (count--) 
        {
            // convert from 32 ARGB to 24bpp RGB
            GpColor refColor = color;                  // save last ARGB color

            color.SetValue(Unpremultiply(*srcPos++));
            
            // NTRAID#NTBUG9-436131-2001-07-13-jerryste "P1CD: Printing:When printing the image, noise will appear in the surrounding of the image." 
            // Real problem: color bitmap and scaled-up alpha mask misalignment. halftoned low-alpha region let black see through

            // Problems in DriverPrint::DrawImage
            //           1) Calculation of boundsCap in integers has rounding error
            //           2) Low level scanline rendering code offset coordinates by 0.5 before rounding
            //           3) Scale integer version of boundsCap to boundsDev introduces more error
            //           4) Single precision floating-point number calculation can lose precision 

            // We do not have a clean way to fix the real problem for the moment (7/28/01).

            // Workaround: Change color to (white+neighbour)/2 when alpha is low to remove black pixels. Neighbor is
            // either the previous pixel, or the next pixel if the previous pixel has a small alpha
            
            const BYTE smallalpha = 10;

            if ( color.GetAlpha()<smallalpha )                              // if alpha is low
            {
                if ( ( refColor.GetAlpha()<smallalpha) && (count!=0) )      // if previous pixel has small alpha and there is next pixel
                    refColor.SetValue(Unpremultiply(*srcPos));              // use next pixel 
                
                if ( refColor.GetAlpha()>=smallalpha )
                {
                    *dstPos++ = (BYTE) ( ( 255 + (UINT32) refColor.GetBlue() )  / 2 );   // blend with white
                    *dstPos++ = (BYTE) ( ( 255 + (UINT32) refColor.GetGreen() ) / 2 );
                    *dstPos++ = (BYTE) ( ( 255 + (UINT32) refColor.GetRed() )   / 2 );
                }
                else
                {
                    *dstPos++ = 255;                                    // set to white
                    *dstPos++ = 255;
                    *dstPos++ = 255;
                }
            }
            else
            {
                *dstPos++ = (BYTE)color.GetBlue();
                *dstPos++ = (BYTE)color.GetGreen();
                *dstPos++ = (BYTE)color.GetRed();
            }
        }

        // Bleed to the right
        if (y != OutputY)
        {
            count = CappedBounds.X + CappedBounds.Width - OutputX - OutputWidth;
            while (count--)
            {
                *dstPos++ = (BYTE)color.GetBlue();
                *dstPos++ = (BYTE)color.GetGreen();
                *dstPos++ = (BYTE)color.GetRed();
            }
        }
        
        // Bleed down all subsequent scan lines.  This should only happen when called
        // implicitly by EpScanDIB::End()
        if ((newWidth == 0) && 
            (x == CappedBounds.X + CappedBounds.Width) &&
            (y == CappedBounds.Y + CappedBounds.Height) &&
            (OutputY != 0))
        {
            // Bleed down all previous subsequent scan lines.
            // compute destination location into 24bpp buffer
            BYTE* clearPos = BufStart;
            INT capHeight = (CappedBounds.Height - 1) - (OutputY - CappedBounds.Y);

            for (int cntY=0; cntY<capHeight; cntY++)
            {
                for (int cntX=0; cntX<CappedBounds.Width; cntX++)
                {
                    clearPos[cntX*3] = (BYTE)color.GetBlue();
                    clearPos[cntX*3+1] = (BYTE)color.GetGreen();
                    clearPos[cntX*3+2] = (BYTE)color.GetRed();
                }
                clearPos += CappedStride;
            }
        }
    }

    // Compute size of bleed scan range
    if (y == OutputY) 
    {
        ASSERT(x >= OutputX + OutputWidth);

        OutputBleed = OutputX + OutputWidth;
    }
    else
    {
        OutputBleed = CappedBounds.X;
    }

    OutputLastY = OutputY;

    OutputX = x;
    OutputY = y;
    OutputWidth = newWidth;
    
    return (ARGB*)Buf32bpp;
}

/**************************************************************************\
*
* Function Description:
*
* NextBufferFunc24bppOver - Handles output when we are rasterizing at capped
*                           dpi to a 24bpp unpremultiplied DIB.  We do an
*                           implicit blend onto a white opaque surface.
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   3/9/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID*
EpScanDIB::NextBufferFunc24bppOver(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    LastBlenderNum = blenderNum;
    ASSERT(!RenderAlpha);
    ASSERT(newWidth >= 0);
    ASSERTMSG(newWidth <= CappedBounds.Width, 
        ("Width exceeds SetBounds() request"));
    ASSERT(x >= CappedBounds.X && x <= (CappedBounds.X + CappedBounds.Width));
    ASSERT(y >= CappedBounds.Y && y <= (CappedBounds.Y + CappedBounds.Height));
    ASSERT((x + newWidth) <= (CappedBounds.X + CappedBounds.Width));
       
    ASSERT((ScanOptions & ScanCappedBounds) && 
           !(ScanOptions & ScanCapped32bpp) &&
           (ScanOptions & ScanCappedOver));

    if (OutputWidth > 0) 
    {
        // compute destination location into 24bpp buffer
        BYTE* dstPos = BufStart + (OutputX - CappedBounds.X) * 3 +
             CappedStride * ((CappedBounds.Height - 1) - 
                             (OutputY - CappedBounds.Y));
        ARGB* srcPos = Buf32bpp;

        while (OutputWidth--) 
        {
            // An adaptation of the blending code from Andrew Godfrey's 
            // BlendOver function, but onto a white surface.  This is done to
            // improve the output quality of postscript.

            GpColor color(*srcPos++);
            UINT32 alpha = color.GetAlpha();
            
            UINT32 alphaContrib;
            
            if (alpha == 0) 
            {
                *dstPos++ = 0xFF;
                *dstPos++ = 0xFF;
                *dstPos++ = 0xFF;
            }
            else if (alpha == 255)
            {
                *dstPos++ = color.GetBlue();
                *dstPos++ = color.GetGreen();
                *dstPos++ = color.GetRed();
            }
            else
            {
                // Dst = Src + (1-Alpha) * Dst
                UINT32 multA = 255 - alpha;
          
                UINT32 D1_000000FF = 0xFF;
                UINT32 D2_0000FFFF = D1_000000FF * multA + 0x00000080;
                UINT32 D3_000000FF = (D2_0000FFFF & 0x0000ff00) >> 8;
                UINT32 D4_0000FF00 = (D2_0000FFFF + D3_000000FF) & 0x0000FF00;
           
                alphaContrib = D4_0000FF00 >> 8;
            
                // convert from 32 ARGB to 24bpp RGB
                // store: (1-alpha)*0xFF + color for each B, G, R
                *dstPos++ = (BYTE)(alphaContrib + color.GetBlue());
                *dstPos++ = (BYTE)(alphaContrib + color.GetGreen());
                *dstPos++ = (BYTE)(alphaContrib + color.GetRed());
            }
        }
    }

    // record location of next scan
    OutputX = x;
    OutputY = y;
    OutputWidth = newWidth;
    
    return (ARGB*)Buf32bpp;
}

/**************************************************************************\
*
* Function Description:
*
* NextBufferFuncAlpha - Handles output when we are rasterizing at device
*                       dpi to a 1bpp mask, we generate the mask on the fly
*                       using DonC's halftoning table.
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   3/9/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID*
EpScanDIB::NextBufferFuncAlpha(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    LastBlenderNum = blenderNum;
    ASSERT(RenderAlpha);
    ASSERT(newWidth >= 0);
    ASSERTMSG(newWidth <= DeviceBounds.Width, 
        ("Width exceeds SetBounds() request"));
    ASSERT(x >= DeviceBounds.X && x <= (DeviceBounds.X + DeviceBounds.Width));
    ASSERT(y >= DeviceBounds.Y && y <= (DeviceBounds.Y + DeviceBounds.Height));
    ASSERT((x + newWidth) <= (DeviceBounds.X + DeviceBounds.Width));
       
    ASSERT((ScanOptions & ScanDeviceBounds) && (ScanOptions & ScanDeviceAlpha));

    if (OutputWidth > 0) 
    {
        // update bounding box for this band
        if (OutputX < MinBound.X) MinBound.X = OutputX;
        if (OutputY < MinBound.Y) MinBound.Y = OutputY;
        if ((OutputX + OutputWidth) > MaxBound.X) MaxBound.X = OutputX + OutputWidth;
        if (OutputY > MaxBound.Y) MaxBound.Y = OutputY;
        
        INT startX = OutputX - DeviceBounds.X;
        INT endX = startX + OutputWidth;
        
        // !! Shift '91' into some global constant!?!
        INT orgX = OutputX % 91;
        INT orgY = (OutputY + TranslateHTTable) % 91;
        INT htIndex = orgY*91 + orgX;

        // compute destination location into 24bpp buffer
#ifdef PRINT_BOTTOM_UP
        BYTE* dstPos = MaskStart +
                       MaskStride * ((DeviceBounds.Height - 1) - 
                                     (OutputY - DeviceBounds.Y)) + (startX >> 3);
#else
        BYTE* dstPos = MaskStart +
                       MaskStride * (OutputY - DeviceBounds.Y) + (startX >> 3);
#endif
        ARGB* srcPos = AlphaStart;

        BYTE outByte = 0;

        // using FOR loop makes it easier to detect relative bit position
        for (INT xPos = startX; xPos < endX; xPos++)
        {
            GpColor color(*srcPos++);
            
            INT maskBit = color.GetAlpha() >
                              HT_SuperCell_GreenMono[htIndex++] ? 1 : 0;
            
            outByte = (outByte << 1) | maskBit;

            if (((xPos+1) % 8) == 0)
               *dstPos++ |= outByte;

            if (++orgX >= 91) 
            {
                orgX = 0;
                htIndex = orgY*91;
            }
        }
        
        // output the last partial byte
        if ((xPos % 8) != 0) 
        {
            *dstPos |= outByte << (8 - (xPos % 8));
        }
    }

    // record location of next scan
    OutputX = x;
    OutputY = y;
    OutputWidth = newWidth;
    
    return (ARGB*)AlphaStart;
}

/**************************************************************************\
*
* Function Description:
*
* NextBufferFuncOpaque - Handles output when we are rasterizing at device
*                       dpi to a 1bpp opaque mask (1 if alpha > 0, 0 otherwise)
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   3/9/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID*
EpScanDIB::NextBufferFuncOpaque(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    LastBlenderNum = blenderNum;
    ASSERT(RenderAlpha);
    ASSERT(newWidth >= 0);
    ASSERTMSG(newWidth <= DeviceBounds.Width, 
        ("Width exceeds SetBounds() request"));
    ASSERT(x >= DeviceBounds.X && x <= (DeviceBounds.X + DeviceBounds.Width));
    ASSERT(y >= DeviceBounds.Y && y <= (DeviceBounds.Y + DeviceBounds.Height));
    ASSERT((x + newWidth) <= (DeviceBounds.X + DeviceBounds.Width));
       
    ASSERT((ScanOptions & ScanDeviceBounds) && !(ScanOptions & ScanDeviceAlpha));
    
    if (OutputWidth > 0) 
    {
        // update bounding box for this band
        if (OutputX < MinBound.X) MinBound.X = OutputX;
        if (OutputY < MinBound.Y) MinBound.Y = OutputY;
        if ((OutputX + OutputWidth) > MaxBound.X) MaxBound.X = OutputX + OutputWidth;
        if (OutputY > MaxBound.Y) MaxBound.Y = OutputY;
        
        INT startX = OutputX - DeviceBounds.X;
        INT endX = startX + OutputWidth;
        
        // compute destination location into 24bpp buffer
        BYTE* dstPos = MaskStart +
                       MaskStride * ((DeviceBounds.Height - 1) -
                                  (OutputY - DeviceBounds.Y)) + (startX >> 3);
        ARGB* srcPos = AlphaStart;

        BYTE outByte = 0;

        // using FOR loop makes it easier to detect relative bit position
        for (INT xPos = startX; xPos < endX; xPos++)
        {
            GpColor color(*srcPos++);
            
            INT maskBit = (color.GetAlpha() == 0) ? 0 : 1;
            
            outByte = (outByte << 1) | maskBit;

            if (((xPos+1) % 8) == 0)
                *dstPos++ |= outByte;
        }
        
        // output the last partial byte
        if ((xPos % 8) != 0) 
        {
            *dstPos |= outByte << (8 - (xPos % 8));
        }
    }

    // record location of next scan
    OutputX = x;
    OutputY = y;
    OutputWidth = newWidth;
    
    return (ARGB*)AlphaStart;
}

/**************************************************************************\
*
* Function Description:
*
* NextBufferFuncZeroOut - Handles output where we aren't rasterizing to a 
*                         DIB section, but only zeroing out portions of the
*                         the original 24bpp bitmap
*
* Arguments:
*
*   [IN] x - Destination pixel coordinate in destination surface
*   [IN] y - ""
*   [IN] width - Number of pixels needed for the next buffer (can be 0)
*   [IN] updateWidth - Number of pixels to update in the current buffer
*
* Return Value:
*
*   Points to the resulting scan buffer
*
* History:
*
*   3/10/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID*
EpScanDIB::NextBufferFuncZeroOut(
    INT x,
    INT y,
    INT newWidth,
    INT updateWidth,
    INT blenderNum
    )
{
    LastBlenderNum = blenderNum;
    ASSERT(RenderAlpha);
    ASSERT(newWidth >= 0);
    ASSERTMSG(newWidth <= DeviceBounds.Width, 
        ("Width exceeds SetBounds() request"));
    ASSERT(x >= DeviceBounds.X && x <= (DeviceBounds.X + DeviceBounds.Width));
    ASSERT(y >= DeviceBounds.Y && y <= (DeviceBounds.Y + DeviceBounds.Height));
    ASSERT((x + newWidth) <= (DeviceBounds.X + DeviceBounds.Width));
       
    ASSERT(!(ScanOptions & ScanDeviceBounds) && !(ScanOptions & ScanDeviceAlpha)
           && !(ScanOptions & (ScanCapped32bpp | ScanCapped32bppOver))
           && (ScanOptions & ScanDeviceZeroOut));

    ASSERT(ZeroOutPad >= 0);
    
    // THIS IS AN IMPORTANT CONDITION.  If it's untrue, then we may fail to
    // generate proper masks in some cases.  Also causes problems in zeroing out.
    ASSERT(y>=OutputY);

    if (newWidth > 0) 
    {
        // update bounding box for this band
        if (x < MinBound.X) 
        {
            MinBound.X = x;
        }
        if (y < MinBound.Y) 
        {
            MinBound.Y = y;
        }
        if ((x + newWidth) > MaxBound.X) 
        {
            MaxBound.X = x + newWidth;
        }
        if (y > MaxBound.Y) 
        {
            MaxBound.Y = y;
        }
    }

    if (OutputWidth < 0) 
    {
        OutputX = x;
        OutputY = y;
    }

    if ((y/ScaleY) != (OutputY/ScaleY)) 
    {
        // tally counts and zero out
        BYTE* bitsPtr = BufStart + CappedStride * 
                                          ((CappedBounds.Height - 1) -
                                          ((OutputY/ScaleY) - CappedBounds.Y));
        DWORD* zeroPtr = (DWORD*) ZeroStart;

        INT count = CappedBounds.Width;
        while (count--)
        {
            if (*zeroPtr++ == 0)
            {
                *bitsPtr++ = '\0';
                *bitsPtr++ = '\0';
                *bitsPtr++ = '\0';
            }
            else
            {
                bitsPtr += 3;
            }
        }

        ZeroMemory(ZeroStart, (CappedBounds.Width+ZeroOutPad)*sizeof(DWORD));
    }

    // bleed the color ZeroOutPad pixels to left and right
    INT xPos = (x/ScaleX) - CappedBounds.X;
    INT count = (newWidth/ScaleX) + ((newWidth % ScaleX) ? 1 : 0) + 1;

    // Calculate how many pixels on the left we can pad
    INT subtract = min(xPos, ZeroOutPad);
    if (subtract > 0)
    {
        xPos -= subtract;
        count += subtract;
    }

    count = min(count+ZeroOutPad, CappedBounds.Width + ZeroOutPad - xPos);

    DWORD *zeroPtr = ((DWORD*)ZeroStart) + xPos;
    ASSERT((xPos+count) <= CappedBounds.Width + ZeroOutPad);
    while (count--) 
    {
        *zeroPtr += 1;
        zeroPtr++;
    }

    // record location of next scan
    OutputX = x;
    OutputY = y;
    OutputWidth = newWidth;
    
    return (ARGB*)AlphaStart;
}

/**************************************************************************\
*
* Function Description:
*
*   Sets the bounds of the current scan.
*
* Arguments:
*
*   [IN] bounds - the bounds.
*
* Return Value:
*
*   None.
*
* History:
*
*   07/13/1999 t-wehunt
*       Created it.
*
\**************************************************************************/

VOID EpScanDIB::SetRenderMode(
    BOOL renderAlpha,
    GpRect *newBounds
    )
{
    RenderAlpha = renderAlpha;

    MinBound.X = INFINITE_MAX;
    MinBound.Y = INFINITE_MAX;
    MaxBound.X = INFINITE_MIN;
    MaxBound.Y = INFINITE_MIN;

    if (RenderAlpha)
    {
        DeviceBounds = *newBounds;
        
        ZeroMemory(AlphaStart, DeviceBounds.Width * sizeof(ARGB));
        
        if (ScanOptions & ScanDeviceBounds) 
        {
            ZeroMemory(MaskStart, MaskStride * DeviceBounds.Height);

            if (ScanOptions & ScanDeviceAlpha) 
            {
                NextBuffer = (NEXTBUFFERFUNCTION) EpScanDIB::NextBufferFuncAlpha;
            }
            else
            {
                NextBuffer = (NEXTBUFFERFUNCTION) EpScanDIB::NextBufferFuncOpaque;
            }
        }
        else
        {
            ASSERT(ScanOptions & ScanDeviceZeroOut);
            ASSERT(!(ScanOptions & (ScanCapped32bpp | ScanCapped32bppOver)));
            
            ZeroMemory(ZeroStart, (CappedBounds.Width + ZeroOutPad)*sizeof(DWORD));
            NextBuffer = (NEXTBUFFERFUNCTION) EpScanDIB::NextBufferFuncZeroOut;
        }
        
        CurBuffer = AlphaStart;
    }
    else
    {
        CappedBounds = *newBounds;

        if (ScanOptions & ScanCapped32bpp)
        {
            ZeroMemory(BufStart, CappedBounds.Width
                       * CappedBounds.Height * sizeof(ARGB));
            NextBuffer = (NEXTBUFFERFUNCTION) NextBufferFunc32bpp;
        }
        else if (ScanOptions & ScanCapped32bppOver)
        {
            ZeroMemory(BufStart, CappedBounds.Width
                       * CappedBounds.Height * sizeof(ARGB));
            NextBuffer = (NEXTBUFFERFUNCTION) NextBufferFunc32bppOver;
        }
        else
        {
            ASSERT(CappedStride != 0);
            
            ZeroMemory(BufStart, CappedStride * CappedBounds.Height);

            if (ScanOptions & ScanCappedOver) 
            {
                NextBuffer = (NEXTBUFFERFUNCTION) NextBufferFunc24bppOver;
            }
            else
            {
                if (ScanOptions & ScanBleedOut) 
                {
                    NextBuffer = (NEXTBUFFERFUNCTION) NextBufferFunc24bppBleed;
                }
                else
                {
                    NextBuffer = (NEXTBUFFERFUNCTION) NextBufferFunc24bpp;
                }
            }
            CurBuffer = Buf32bpp;
        }
    }

    OutputWidth = -1;
}

/**************************************************************************\
*
* Function Description:
*
*   Flushes the current scan.
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   None.
*
* History:
*
*   07/13/1999 t-wehunt
*       Created it.
*
\**************************************************************************/

VOID 
EpScanDIB::Flush()
{
}

/**************************************************************************\
*
* Function Description:
*
*   Resets the DIBSection buffer, safely releasing resources and resetting
*   them.
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   None.
*
* History:
*
*   07/26/1999 t-wehunt
*       Created it.
*
\**************************************************************************/

VOID
EpScanDIB::DestroyBufferDIB()
{
    if (BufStart != NULL) 
    {
        GpFree(BufStart);
    }

    if (AlphaStart != NULL)
    {
        GpFree(AlphaStart);
    }

    BufStart    = NULL;
    Buf32bpp    = NULL;
    CurBuffer   = NULL;

    // Transparency mask
    MaskStart   = NULL;

    // Alpha buffer
    AlphaStart  = NULL;
    ZeroStart   = NULL;
    RenderAlpha = FALSE;
    ScanOptions = 0;
    OutputWidth = -1;

    NextBuffer = NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   In pre-multiplies an ARGB value
*
* Arguments:
*
*
* Return Value:
*
*   GpStatus.
*
* History:
*
*   10/08/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
EpScanDIB::CreateBufferDIB(
    const GpRect* BoundsCap,
    const GpRect* BoundsDev,
    DWORD options,
    INT scaleX,
    INT scaleY)
{
    ScanOptions = options;
    CappedBounds = *BoundsCap;
    DeviceBounds = *BoundsDev;

    ScaleX = scaleX;
    ScaleY = scaleY;

    if (options & ScanCappedBounds) 
    {
        ZeroMemory(&Buf.BMI, sizeof(Buf.BMI));
   
        Buf.BMI.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
        Buf.BMI.bmiHeader.biWidth       =  CappedBounds.Width;
        Buf.BMI.bmiHeader.biHeight      = CappedBounds.Height;
        Buf.BMI.bmiHeader.biPlanes      = 1;
    
        if (options & (ScanCapped32bpp | ScanCapped32bppOver)) 
        {
            RGBQUAD red = { 0, 0, 0xFF, 0}; // red
            RGBQUAD green = { 0, 0xFF, 0, 0}; // green
            RGBQUAD blue = { 0xFF, 0, 0, 0}; // blue

            Buf.BMI.bmiColors[0] = red;
            Buf.BMI.bmiColors[1] = green;
            Buf.BMI.bmiColors[2] = blue;
            
            Buf.BMI.bmiHeader.biBitCount = 32;
            Buf.BMI.bmiHeader.biCompression = BI_BITFIELDS;
        }
        else
        {   
            Buf.BMI.bmiHeader.biHeight += 2;
            Buf.BMI.bmiHeader.biBitCount = 24;
            Buf.BMI.bmiHeader.biClrUsed = 0;
            Buf.BMI.bmiHeader.biCompression = BI_RGB;
        }

        if (options & (ScanCapped32bpp | ScanCapped32bppOver)) 
        {
            CappedStride = CappedBounds.Width*sizeof(ARGB);
        }
        else
        { 
            // use extra allocation at the end of DIB for temp 32bpp storage
            CappedStride = RoundDWORD((CappedBounds.Width * 3));
        }

        BufStart = (BYTE*) GpMalloc(CappedStride * 
                                    Buf.BMI.bmiHeader.biHeight);
         
        if (BufStart == NULL)
            return OutOfMemory;

        if (options & (ScanCapped32bpp | ScanCapped32bppOver))
        {
            Buf32bpp = NULL;
        }
        else
        {
            Buf.BMI.bmiHeader.biHeight -= 2;
            Buf32bpp = (ARGB*) (BufStart + CappedStride*CappedBounds.Height);
        }
    }
    else
    {
        BufStart = NULL;
        Buf32bpp = NULL;
    }
   
    if (options & ScanDeviceBounds) 
    {
        ZeroMemory(&Mask.BMI, sizeof(Mask.BMI));
        
        // if we do zeroing out of the capped bitmap, then we require that
        // their sizes be an integer ratio of each other (device>= capped).

        ASSERT(!(options & ScanDeviceZeroOut) ||
               ((options & ScanDeviceZeroOut) &&
                IsInteger((REAL)DeviceBounds.Height/(REAL)CappedBounds.Height) &&
                IsInteger((REAL)DeviceBounds.Width/(REAL)CappedBounds.Width)));

        ASSERT(DeviceBounds.Height > 0);

        Mask.BMI.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
        Mask.BMI.bmiHeader.biWidth       = DeviceBounds.Width;
        Mask.BMI.bmiHeader.biHeight      = DeviceBounds.Height;
        Mask.BMI.bmiHeader.biPlanes      = 1;
        Mask.BMI.bmiHeader.biBitCount    = 1;
        Mask.BMI.bmiHeader.biCompression = BI_RGB;

        RGBQUAD opaque = { 0,0,0,0 };
        RGBQUAD transparent = { 0xFF, 0xFF, 0xFF, 0xFF }; 

        Mask.BMI.bmiColors[0] = transparent;
        Mask.BMI.bmiColors[1] = opaque;

        MaskStride = (DeviceBounds.Width - 1) >> 3;
        MaskStride = MaskStride + (sizeof(DWORD) - MaskStride % sizeof(DWORD));
        
        INT AlphaSize = DeviceBounds.Width * sizeof(ARGB);

        AlphaStart = (ARGB*) GpMalloc(MaskStride * DeviceBounds.Height + 
                                      AlphaSize);

        if (AlphaStart == NULL) 
        {
            return OutOfMemory;
        }

        // device space bounds only for alpha channel
        MaskStart = (BYTE*)(AlphaStart) + AlphaSize;
        ASSERT(MaskStart != NULL);

        ZeroStart = NULL;
    }
    else
    {
        MaskStart = NULL;

        if (ScanOptions & ScanDeviceZeroOut)
        {
            // device space bounds only for alpha channel
            AlphaStart = (ARGB*) GpMalloc(DeviceBounds.Width * sizeof(ARGB) +
                                          (CappedBounds.Width+ZeroOutPad) * sizeof(DWORD));
            if (AlphaStart == NULL)
                return OutOfMemory;

            // array for maintaining zero out counts
            ZeroStart = (BYTE*)(AlphaStart + DeviceBounds.Width);
        }
        else
        {
            AlphaStart = NULL;
            ZeroStart = NULL;
        }
    }

    // To prevent bad output when overlapping images have same alpha value
    // we increment our position in the HT Table matrix.
    TranslateHTTable++;
    
    // NOTE: We don't bother filling the monochrome DIB with 0's or 1's
    return Ok;
}

BOOL EpScanDIB::GetActualBounds(GpRect *rect)
{
    if (!(ScanOptions & (ScanDeviceBounds | ScanDeviceZeroOut))) 
    {
        rect->X = 0;
        rect->Y = 0;
        rect->Width = DeviceBounds.Width;
        rect->Height = DeviceBounds.Height;
        return TRUE;
    }

    if (MaxBound.X <= 0) 
    {
        return FALSE;
    }

    ASSERT(MaxBound.X > -1 && MaxBound.Y > -1);

    GpRect tempRect;

    // relative to (0, 0) in device units (not device space)
    tempRect.X = (rect->X = MinBound.X - DeviceBounds.X);
    tempRect.Y = (rect->Y = MinBound.Y - DeviceBounds.Y);
    rect->Width = MaxBound.X - MinBound.X;
    rect->Height = MaxBound.Y - MinBound.Y + 1;

    // Round bounds to multiples of ScaleX, ScaleY.  This is so 
    // We map between capped and device rectangles easily
    
    rect->X = (rect->X / ScaleX) * ScaleX;
    rect->Y = (rect->Y / ScaleY) * ScaleY;

    rect->Width = rect->Width + tempRect.X - rect->X;
    rect->Height = rect->Height + tempRect.Y - rect->Y;

    INT remainderX = rect->Width % ScaleX;
    INT remainderY = rect->Height % ScaleY;

    if (remainderX > 0) rect->Width += (ScaleX - remainderX);
    if (remainderY > 0) rect->Height += (ScaleY - remainderY);
    
    ASSERT((rect->X + rect->Width) <= (DeviceBounds.Width + ScaleX));
    ASSERT((rect->Y + rect->Height) <= (DeviceBounds.Height + ScaleY));

    return TRUE;
}

// !! Out of commission for the time being.
#if 0
/**************************************************************************\
*
* Function Description:
*
*   Creates a monochrome bitmap from the alpha channel of the DIB.
*   This code uses DonC's halftoning table cells to determine the pattern
*   for use in mask generation.
*
*   NOTE: The mask is generated at device Dpi not capped Dpi.
*
* Arguments:
*
*   zeroOut - only modify the original DIB for non-Postscript since we
*             OR the dib in.  For PS, we use imagemask exclusively.
* 
* Return Value:
*
*   GpStatus.
*
* History:
*
*   10/08/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
EpScanDIB::CreateAlphaMask()
{
    DWORD MaskStride;

    MaskStride = (ScanBounds.Width - 1) >> 3;
    MaskStride = MaskStride + ( 4 - (MaskStride % 4));
    
    // SetBounds() multiplies the ScanBounds for the DPI scaling.
    INT width = ScanBounds.Width;
    INT height = ScanBounds.Height;

    INT orgXsrc = ScanBounds.X + TranslateHTTable;
    INT orgYsrc = ScanBounds.Y + TranslateHTTable;

    BYTE* dst = MaskStart;
    BYTE* src = AlphaStart;
    ARGB* orig = BufStart;

    INT srcStride = ScanBounds.Width;
    INT dstStride = MaskStride;

    if (width == 0)
    {
        return GenericError;
    }

    for (INT yPos=0; yPos < height; yPos++)
    {
        src = AlphaStart + yPos*srcStride;
        dst = MaskStart + yPos*dstStride;
        
        INT orgX = orgXsrc % 91;
        INT orgY = orgYsrc % 91;

        INT     htStartX   = orgX;
        INT     htStartRow = orgY * 91;
        INT     htIndex    = htStartRow + orgX;

        BYTE    outByte = 0;

        for (INT xPos=0; xPos < width; xPos++)
        {
            // unpremultiply or zero out only once per pixel of source image
            // at capped DPI

           if (((yPos % MaskScaleY) == 0) && ((xPos % MaskScaleX) == 0))
           {
               // Check if we should ZERO out his pixel in the original
               // source image.  We do so if all alpha values for this pixel
               // in the device DPI alpha image are 0.  This is done for 
               // better compression in the postscript output case.

               BOOL zeroIt = TRUE;
               
               for (INT xTmp=0; xTmp < MaskScaleX; xTmp++)
               {
                   for (INT yTmp=0; yTmp < MaskScaleY; yTmp++)
                   {
                       if (*(src + xTmp + (yTmp * srcStride)) != 0)
                       {   
                           zeroIt = FALSE;
                           break;
                       }
                   }
               }

               if (zeroIt)
                   *orig = 0;
               else
                   *orig = Unpremultiply(*(ARGB*)orig);
               
               orig++;
           }
            
            INT maskBit = *src++ > HT_SuperCell_GreenMono[htIndex] ? 0 : 1;

            outByte = (outByte << 1) | maskBit;

            if (((xPos+1) % 8) == 0) 
                *dst++ = outByte;

            htIndex++;
            if (++orgX >= 91)
            {
                orgX = 0;
                htIndex = htStartRow;
            }
        }
   
        // output last partial byte
        if ((xPos % 8) != 0) 
        {
           // shift remaining bits & output
           outByte = outByte << (8 - (xPos % 8));
           *dst = outByte;
        }

        orgYsrc++;
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Creates a 0-1 bitmap where we know the alpha channel is always
*   0x00 or 0xFF.  We iterate through the bits and where-ever pixel is != 0 we
*   output a 1 otherwise a 0.  This is better than the Floyd-Steinberg 
*   which still produces spurious 0 bits even though there shouldn't really
*   be any.
*
* Arguments:
*
* Return Value:
*
*   GpStatus.
*
* History:
*
*   10/08/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus 
EpScanDIB::CreateOpaqueMask()
{
    ARGB*   orig = BufStart;
    BYTE*   AlphaPos = AlphaStart;
    BYTE*   MaskPos = MaskStart;
    
    INT    DstWidth = ScanBounds.Width;
    INT    DstHeight = ScanBounds.Height;
    INT    SrcWidth = ScanBounds.Width;
    INT    &Height = ScanBounds.Height;

    LONG    BitStride = (DstWidth - 1) >> 3;
    
    BitStride = BitStride + (4 - (BitStride % 4));

    BYTE    outByte = 0;
    
    for (INT y=0; y<DstHeight; y++)
    {
        AlphaPos = AlphaStart + SrcWidth*y;
        MaskPos  = MaskStart + BitStride*y;
            
        for (INT x=0; x<DstWidth; x++)
        {
            if (((y % MaskScaleY) == 0) && ((x % MaskScaleX) == 0))
            {
               // Check if we should ZERO out his pixel in the original
               // source image.  We do so if all alpha values for this pixel
               // in the device DPI alpha image are 0.  This is done for 
               // better compression in the postscript output case.
               
               BOOL zeroIt = TRUE;
    
               for (INT xTmp=0; xTmp < MaskScaleX; xTmp++)
               {
                  for (INT yTmp=0; yTmp < MaskScaleY; yTmp++)
                  {
                     if (*(AlphaPos + xTmp + (yTmp * SrcWidth)) != 0)
                     {   
                        zeroIt = FALSE;
                        break;
                     }
                  }
               }

               // no need to unpremultiply since this is a 0-1 source image
               if (zeroIt)
                   *orig = 0;
    
               orig++;
            }
            
            BYTE alpha = *AlphaPos++;
            
            outByte = (outByte << 1) | ((alpha != 0) ? 0:1);

            if (((x + 1) % 8) == 0) 
                *MaskPos++ = outByte;
        }

        if ((x % 8) != 0) 
        {
            *MaskPos = (BYTE)(outByte << (8 - (x % 8)));
        }
    }

    return Ok;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\scanoperation.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Scan operations
*
* Abstract:
*
*   Public scan-operation definitions (in the ScanOperation namespace).
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*   
* Created:
*
*   07/16/1999 agodfrey
*
\**************************************************************************/

#ifndef _SCANOPERATION_HPP
#define _SCANOPERATION_HPP

#include "palettemap.hpp"

namespace ScanOperation
{
    // OtherParams:
    //   If a scan operation needs extra information about how to perform
    //   an operation, it is passed in the OtherParams structure.
    
    struct OtherParams
    {
        const ColorPalette* Srcpal; // source palette
        const ColorPalette* Dstpal; // destination palette
        
        const EpPaletteMap *PaletteMap; // palette translation vector, used when 
                                        // halftoning
        
        INT X,Y; // x and y coordinates of the leftmost pixel of the scan.
                 // Used when halftoning/dithering

        BOOL DoingDither; // dithering enabled (for 16bpp)
        
        BYTE *CTBuffer;  // ClearType coverage buffer, used for ClearType
                         // scan types.
        ARGB SolidColor; // Solid fill color, used in the OpaqueSolidFill and
                         // CTSolidFill scan types.
        ULONG TextContrast; // Text contrast value for blending, used in CTFill and CTSolidFill types
        
        // blendingScan: Used in the RMW optimization (see ReadRMW and 
        //   WriteRMW). Can be in either ARGB or ARGB64 format.
        
        const void *BlendingScan;

        void *TempBuffers[3];
    };
    
    /**************************************************************************\
    *
    * Operation Description:
    *
    *   ScanOpFunc is the signature of every Scan Operation.
    *
    * Arguments:
    *
    *   dst         - The destination scan
    *   src         - The source scan
    *   count       - The length of the scan, in pixels
    *   otherParams - Additional data.
    *
    * Return Value:
    *
    *   None
    *
    * Notes:
    *
    *   The formats of the destination and source depend on the specific
    *   scan operation.
    *
    *   dst and src must point to non-overlapping buffers. The one exception
    *   is that they may be equal, but some scan operations don't allow this
    *   (most notably, those which deal with different-sized source and
    *   destination formats.)
    *
    *   If you know which operations you're going to be invoking, you can
    *   omit to set fields in otherParams, trusting that they won't be
    *   used. This can be error-prone, which is why we try to limit
    *   the code which uses scan operations directly.
    *   As an example, if you know you're not going to deal with palettized
    *   formats, you don't need to set up Srcpal, Dstpal or PaletteMap.
    *
    \**************************************************************************/

    // The common scan operation function signature
    
    typedef VOID (FASTCALL *ScanOpFunc)(
        VOID *dst, 
        const VOID *src, 
        INT count, 
        const OtherParams *otherParams
        );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\soalphamultiply.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "AlphaMultiply" and "AlphaDivide" scan operations.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
*   These scan operations multiply/divide the color components by the alpha
*   component. API-level input colors are (usually) specified in 
*   'non-premultiplied'. Given a non-premultiplied
*   color (R, G, B, A), its 'premultiplied' form is (RA, GA, BA, A).
*
* Notes:
*
*   Since "AlphaMultiply" loses information, "AlphaDivide" is not a true
*   inverse operation. (But it is an inverse if all pixels have an alpha of 1.)
*
*   If the alpha is 0, "AlphaDivide" won't cause a divide-by-zero exception or
*   do anything drastic. But it may do something random. Currently, the pixel 
*   value is unchanged. It could, instead, set the pixel to 0.
*
* Revision History:
*
*   12/14/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Operation Description:
*
*   AlphaMultiply/AlphaDivide: Convert between premultiplied and
*       non-premultiplied alpha.
*
* Arguments:
*
*   dst         - The destination scan
*   src         - The source scan
*   count       - The length of the scan, in pixels
*   otherParams - Additional data. (Ignored.)
*
* Return Value:
*
*   None
*
* Notes:
*
*   !!![agodfrey] Currently we use 'Unpremultiply' from imgutils.cpp. 
*   While we may keep the tables and lookup in imgutils.cpp, 
*   it needs better naming, and we want the alpha=0 and alpha=255 cases in
*   here, not out-of-line in imgutils.cpp.
*
* History:
*
*   12/14/1999 agodfrey
*       Created it.
*
\**************************************************************************/

ARGB Unpremultiply(ARGB argb);

// AlphaDivide from 32bpp PARGB

VOID FASTCALL
ScanOperation::AlphaDivide_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, ARGB)

    while (count--)
    {
        sRGB::sRGBColor c;
        c.argb = *s;
        if (sRGB::isTranslucent(c.argb))
        {
            c.argb = Unpremultiply(c.argb);
        }
        *d = c.argb;
        d++;
        s++;
    }
}

// !!![agodfrey] This should be sorted out. It should be out-of-line, and kept
//     with its mates in imgutils.cpp (which should maybe move), but it 
//     shouldn't have a translucency check (we want to do that in
//     AlphaMultiply_sRGB).

ARGB MyPremultiply(ARGB argb)
{
    ARGB a = (argb >> ALPHA_SHIFT);

    ARGB _000000gg = (argb >> 8) & 0x000000ff;
    ARGB _00rr00bb = (argb & 0x00ff00ff);

    ARGB _0000gggg = _000000gg * a + 0x00000080;
    _0000gggg += (_0000gggg >> 8);

    ARGB _rrrrbbbb = _00rr00bb * a + 0x00800080;
    _rrrrbbbb += ((_rrrrbbbb >> 8) & 0x00ff00ff);

    return (a << ALPHA_SHIFT) |
           (_0000gggg & 0x0000ff00) |
           ((_rrrrbbbb >> 8) & 0x00ff00ff);
}

// AlphaMultiply from 32bpp ARGB

VOID FASTCALL
ScanOperation::AlphaMultiply_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, ARGB)

    while (count--)
    {
        sRGB::sRGBColor c;
        c.argb = *s;
        ARGB alpha = c.argb & 0xff000000;
        
        if (alpha != 0xff000000)
        {
            if (alpha != 0x00000000)
            {
                c.argb = MyPremultiply(c.argb);
            }
            else
            {
                c.argb = 0;
            }
        }
        *d = c.argb;
        d++;
        s++;
    }
}

// !!![agodfrey] We may want to round off, in both AlphaDivide_sRGB64 and
//     AlphaMultiply_sRGB64.

// AlphaDivide from 64bpp PARGB

VOID FASTCALL
ScanOperation::AlphaDivide_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB64, ARGB64)

    while (count--)
    {
        using namespace sRGB;
        
        sRGB64Color c;
        c.argb = *s;
        if (isTranslucent64(c.a))
        {
            c.r = ((INT) c.r << SRGB_FRACTIONBITS) / c.a;
            c.g = ((INT) c.g << SRGB_FRACTIONBITS) / c.a;
            c.b = ((INT) c.b << SRGB_FRACTIONBITS) / c.a;
        }
        *d = c.argb;
        d++;
        s++;
    }
}

// AlphaMultiply from 64bpp ARGB

VOID FASTCALL
ScanOperation::AlphaMultiply_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB64, ARGB64)

    while (count--)
    {
        using namespace sRGB;
        
        sRGB64Color c;
        c.argb = *s;
        if (c.a != SRGB_ONE)
        {
            if (c.a != 0)
            {
                c.r = ((INT) c.r * c.a) >> SRGB_FRACTIONBITS;
                c.g = ((INT) c.g * c.a) >> SRGB_FRACTIONBITS;
                c.b = ((INT) c.b * c.a) >> SRGB_FRACTIONBITS;
            }
            else
            {
                c.argb = 0;
            }
        }
        *d = c.argb;
        d++;
        s++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\scanoperation.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Scan operations
*
* Abstract:
*
*   Definitions for the ScanOperation namespace.
*
* Notes:
*
*   EpAlphaBlender, EpFormatConverter, and the scan operations, all use the
*   idea of the "closest" canonical format to a particular format.
*   We define this as follows: If the format is not extended,
*   the closest canonical format is sRGB. Otherwise, it's sRGB64.
*
* Revision History:
*
*   01/04/2000 agodfrey
*     Created it.
*
\**************************************************************************/

#include "precomp.hpp"

namespace ScanOperation
{
    /**************************************************************************\
    *
    * Operations which copy pixels, preserving the pixel format.
    *
    \**************************************************************************/
    
    ScanOpFunc CopyOps[PIXFMT_MAX] =
    {
        NULL,           // PIXFMT_UNDEFINED
        Copy_1,         // PIXFMT_1BPP_INDEXED
        Copy_4,         // PIXFMT_4BPP_INDEXED
        Copy_8,         // PIXFMT_8BPP_INDEXED
        Copy_16,        // PIXFMT_16BPP_GRAYSCALE
        Copy_16,        // PIXFMT_16BPP_RGB555
        Copy_16,        // PIXFMT_16BPP_RGB565
        Copy_16,        // PIXFMT_16BPP_ARGB1555
        Copy_24,        // PIXFMT_24BPP_RGB
        Copy_32,        // PIXFMT_32BPP_RGB
        Copy_32,        // PIXFMT_32BPP_ARGB
        Copy_32,        // PIXFMT_32BPP_PARGB
        Copy_48,        // PIXFMT_48BPP_RGB
        Copy_64,        // PIXFMT_64BPP_ARGB
        Copy_64,        // PIXFMT_64BPP_PARGB
        Copy_24         // PIXFMT_24BPP_BGR
    };
    
    /**************************************************************************\
    *
    * Operations which convert into the closest canonical format.
    *
    \**************************************************************************/
    
    ScanOpFunc ConvertIntoCanonicalOps[PIXFMT_MAX] =
    {
        NULL,                  // PIXFMT_UNDEFINED
        Convert_1_sRGB,        // PIXFMT_1BPP_INDEXED
        Convert_4_sRGB,        // PIXFMT_4BPP_INDEXED
        Convert_8_sRGB,        // PIXFMT_8BPP_INDEXED
        NULL, // !!! TODO      // PIXFMT_16BPP_GRAYSCALE
        Convert_555_sRGB,      // PIXFMT_16BPP_RGB555
        Convert_565_sRGB,      // PIXFMT_16BPP_RGB565
        Convert_1555_sRGB,     // PIXFMT_16BPP_ARGB1555
        Convert_24_sRGB,       // PIXFMT_24BPP_RGB
        Convert_32RGB_sRGB,    // PIXFMT_32BPP_RGB
        Copy_32,               // PIXFMT_32BPP_ARGB
        AlphaDivide_sRGB,      // PIXFMT_32BPP_PARGB
        Convert_48_sRGB64,     // PIXFMT_48BPP_RGB
        Copy_64,               // PIXFMT_64BPP_ARGB
        AlphaDivide_sRGB64,    // PIXFMT_64BPP_PARGB
        Convert_24BGR_sRGB     // PIXFMT_24BPP_BGR
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\soblend.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "Blend" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
* Notes:
*
* Revision History:
*
*   12/07/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Operation Description:
*
*   Blend: Does a SrcOver alpha-blend operation.
*
* Arguments:
*
*   dst         - The destination scan
*   src         - The source scan (usually equal to dst).
*   count       - The length of the scan, in pixels
*   otherParams - Additional data. (We use BlendingScan.)
*
* Return Value:
*
*   None
*
* Notes:
*
*   This is a ternary operation. We take pixels from 'src', blend pixels
*   from 'otherParams->BlendingScan' over them, and write the result to 'dst'.
*
*   Since the formats of the 'dst' and 'src' scans are the same for all
*   the blend functions we implement, the naming is simplified to list just
*   the format of BlendingScan, then the format of 'dst'.
*
*   src and dst may be equal; otherwise, they must point to scans which do
*   not overlap in memory.
*
*   The blend operation adheres to the following rule:
*   "If the blending alpha value is zero, do not write the destination pixel."
*   
*   In other words, it is also a 'WriteRMW' operation. This allows us to
*   avoid a separate 'WriteRMW' step in some cases. See SOReadRMW.cpp and 
*   SOWriteRMW.cpp.
*
*   The impact of this is that you have to be careful if you want 'blend'
*   to be a true ternary operation. Remember, if a blend pixel
*   is transparent, NOTHING gets written to the corresponding destination
*   pixel. One way to solve this is to make sure that the final operation in
*   your pipeline is a WriteRMW operation.
*
* History:
*
*   04/04/1999 andrewgo
*       Created it.
*   12/07/1999 agodfrey
*       Included the 32bpp blend (moved from from Ddi/scan.cpp)
*   01/06/2000 agodfrey
*       Added AndrewGo's code for 565, 555, RGB24 and BGR24. Changed the
*       blends to be 'almost' ternary operations.
*
\**************************************************************************/


VOID FASTCALL
ScanOperation::BlendLinear_sRGB_32RGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    int nRun;
    void *buffer0=otherParams->TempBuffers[0];
    void *buffer1=otherParams->TempBuffers[1];
    void *buffer2=otherParams->TempBuffers[2];
    DEFINE_POINTERS(ARGB, ARGB)
    DEFINE_BLEND_POINTER(ARGB)
    using namespace sRGB;
    OtherParams otherParams2=*otherParams;

    while (count>0)
    {
        // Find the run of translucent pixels
        nRun=0;
        while (isTranslucent(*((ARGB*)(bl+nRun))))
        {
            nRun++;
            if (nRun==count) { break; }
        }

        if (nRun==0)
        {
            while ((count>0) && (((*((DWORD*)bl))>>24)==0xFF))
            {
                *d=*bl;
                count--;
                d++;
                bl++;
                s++;
            }
            while ((count>0) && (((*((DWORD*)bl))>>24)==0x00))
            {
                count--;
                d++;
                bl++;
                s++;
            }
        }
        else
        {
            // Source
            GammaConvert_sRGB_sRGB64(buffer1,s,nRun,otherParams);

            // Surface to blend
            AlphaDivide_sRGB(buffer0,bl,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer2,buffer0,nRun,otherParams);
            AlphaMultiply_sRGB64(buffer0,buffer2,nRun,otherParams);

            // Blend to destination.
            // Must blend using the previous result as the bl
            otherParams2.BlendingScan=buffer0;
            Blend_sRGB64_sRGB64(buffer1,buffer1,nRun,&otherParams2);
            GammaConvert_sRGB64_sRGB(d,buffer1,nRun,otherParams);

            count-=nRun;
            d+=nRun;
            bl+=nRun;
            s+=nRun;
        }
    }
}

VOID FASTCALL
ScanOperation::BlendLinear_sRGB_32RGB_MMX(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    int nRun;
    void *buffer0=otherParams->TempBuffers[0];
    void *buffer1=otherParams->TempBuffers[1];
    void *buffer2=otherParams->TempBuffers[2];
    DEFINE_POINTERS(ARGB, ARGB)
    DEFINE_BLEND_POINTER(ARGB)
    using namespace sRGB;
    OtherParams otherParams2=*otherParams;

    while (count>0)
    {
        // Find the run of translucent pixels
        nRun=0;
        while (isTranslucent(*((ARGB*)(bl+nRun))))
        {
            nRun++;
            if (nRun==count) { break; }
        }

        if (nRun==0)
        {
            while ((count>0) && (((*((DWORD*)bl))>>24)==0xFF))
            {
                *d=*bl;
                count--;
                d++;
                bl++;
                s++;
            }
            while ((count>0) && (((*((DWORD*)bl))>>24)==0x00))
            {
                count--;
                d++;
                bl++;
                s++;
            }
        }
        else
        {
            // Source
            GammaConvert_sRGB_sRGB64(buffer1,s,nRun,otherParams);

            // Surface to blend
            AlphaDivide_sRGB(buffer0,bl,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer2,buffer0,nRun,otherParams);
            AlphaMultiply_sRGB64(buffer0,buffer2,nRun,otherParams);

            // Blend to destination
            // Must blend using the previous result as the bl
            otherParams2.BlendingScan=buffer0;
            Blend_sRGB64_sRGB64_MMX(buffer1,buffer1,nRun,&otherParams2);
            GammaConvert_sRGB64_sRGB(d,buffer1,nRun,otherParams);

            count-=nRun;
            d+=nRun;
            bl+=nRun;
            s+=nRun;
        }
    }
}

VOID FASTCALL
ScanOperation::BlendLinear_sRGB_565(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    int nRun;
    void *buffer0=otherParams->TempBuffers[0];
    void *buffer1=otherParams->TempBuffers[1];
    void *buffer2=otherParams->TempBuffers[2];
    DEFINE_POINTERS(UINT16,UINT16)
    DEFINE_BLEND_POINTER(ARGB)
    using namespace sRGB;
    OtherParams otherParams2=*otherParams;

    while (count>0)
    {
        // Find the run of translucent pixels
        nRun=0;
        while (isTranslucent(*((ARGB*)(bl+nRun))))
        {
            nRun++;
            if (nRun==count) { break; }
        }

        if (nRun==0)
        {
            while (((*((DWORD*)bl+nRun))>>24)==0xFF)
            {
                nRun++;
                if (nRun==count) { break; }
            }
            if (nRun>0)
            {
                Dither_sRGB_565(d,bl,nRun,otherParams);

                count-=nRun;
                d+=nRun;
                bl+=nRun;
                s+=nRun;
            }
            while ((count>0) && (((*((DWORD*)bl))>>24)==0x00))
            {
                count--;
                d++;
                bl++;
                s++;
            }
        }
        else
        {
            // Source
            Convert_565_sRGB(buffer2,s,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer1,buffer2,nRun,otherParams);

            // Surface to blend
            AlphaDivide_sRGB(buffer0,bl,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer2,buffer0,nRun,otherParams);
            AlphaMultiply_sRGB64(buffer0,buffer2,nRun,otherParams);

            // Blend to destination
            otherParams2.BlendingScan=buffer0;
            Blend_sRGB64_sRGB64(buffer1,buffer1,nRun,&otherParams2);
            GammaConvert_sRGB64_sRGB(buffer2,buffer1,nRun,otherParams);

            Dither_sRGB_565(d,buffer2,nRun,otherParams);

            count-=nRun;
            d+=nRun;
            bl+=nRun;
            s+=nRun;
        }
    }
}

VOID FASTCALL
ScanOperation::BlendLinear_sRGB_565_MMX(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    int nRun;
    void *buffer0=otherParams->TempBuffers[0];
    void *buffer1=otherParams->TempBuffers[1];
    void *buffer2=otherParams->TempBuffers[2];
    DEFINE_POINTERS(UINT16,UINT16)
    DEFINE_BLEND_POINTER(ARGB)
    using namespace sRGB;
    OtherParams otherParams2=*otherParams;

    while (count>0)
    {
        // Find the run of translucent pixels
        nRun=0;
        while (isTranslucent(*((ARGB*)(bl+nRun))))
        {
            nRun++;
            if (nRun==count) { break; }
        }

        if (nRun==0)
        {
            while (((*((DWORD*)bl+nRun))>>24)==0xFF)
            {
                nRun++;
                if (nRun==count) { break; }
            }
            if (nRun>0)
            {
                Dither_sRGB_565_MMX(d,bl,nRun,otherParams);

                count-=nRun;
                d+=nRun;
                bl+=nRun;
                s+=nRun;
            }
            while ((count>0) && (((*((DWORD*)bl))>>24)==0x00))
            {
                count--;
                d++;
                bl++;
                s++;
            }
        }
        else
        {
            // Source
            Convert_565_sRGB(buffer2,s,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer1,buffer2,nRun,otherParams);

            // Surface to blend
            AlphaDivide_sRGB(buffer0,bl,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer2,buffer0,nRun,otherParams);
            AlphaMultiply_sRGB64(buffer0,buffer2,nRun,otherParams);

            // Blend to destination
            otherParams2.BlendingScan=buffer0;
            Blend_sRGB64_sRGB64_MMX(buffer1,buffer1,nRun,&otherParams2);
            GammaConvert_sRGB64_sRGB(buffer2,buffer1,nRun,otherParams);

            Dither_sRGB_565_MMX(d,buffer2,nRun,otherParams);

            count-=nRun;
            d+=nRun;
            bl+=nRun;
            s+=nRun;
        }
    }
}

VOID FASTCALL
ScanOperation::BlendLinear_sRGB_555(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    int nRun;
    void *buffer0=otherParams->TempBuffers[0];
    void *buffer1=otherParams->TempBuffers[1];
    void *buffer2=otherParams->TempBuffers[2];
    DEFINE_POINTERS(UINT16,UINT16)
    DEFINE_BLEND_POINTER(ARGB)
    using namespace sRGB;
    OtherParams otherParams2=*otherParams;

    while (count>0)
    {
        // Find the run of translucent pixels
        nRun=0;
        while (isTranslucent(*((ARGB*)(bl+nRun))))
        {
            nRun++;
            if (nRun==count) { break; }
        }

        if (nRun==0)
        {
            while (((*((DWORD*)bl+nRun))>>24)==0xFF)
            {
                nRun++;
                if (nRun==count) { break; }
            }
            if (nRun>0)
            {
                Dither_sRGB_555(d,bl,nRun,otherParams);

                count-=nRun;
                d+=nRun;
                bl+=nRun;
                s+=nRun;
            }
            while ((count>0) && (((*((DWORD*)bl))>>24)==0x00))
            {
                count--;
                d++;
                bl++;
                s++;
            }
        }
        else
        {
            // Source
            Convert_555_sRGB(buffer2,s,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer1,buffer2,nRun,otherParams);

            // Surface to blend
            AlphaDivide_sRGB(buffer0,bl,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer2,buffer0,nRun,otherParams);
            AlphaMultiply_sRGB64(buffer0,buffer2,nRun,otherParams);

            // Blend to destination
            otherParams2.BlendingScan=buffer0;
            Blend_sRGB64_sRGB64(buffer1,buffer1,nRun,&otherParams2);
            GammaConvert_sRGB64_sRGB(buffer2,buffer1,nRun,otherParams);

            Dither_sRGB_555(d,buffer2,nRun,otherParams);

            count-=nRun;
            d+=nRun;
            bl+=nRun;
            s+=nRun;
        }
    }
}

VOID FASTCALL
ScanOperation::BlendLinear_sRGB_555_MMX(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    int nRun;
    void *buffer0=otherParams->TempBuffers[0];
    void *buffer1=otherParams->TempBuffers[1];
    void *buffer2=otherParams->TempBuffers[2];
    DEFINE_POINTERS(UINT16,UINT16)
    DEFINE_BLEND_POINTER(ARGB)
    using namespace sRGB;
    OtherParams otherParams2=*otherParams;

    while (count>0)
    {
        // Find the run of translucent pixels
        nRun=0;
        while (isTranslucent(*((ARGB*)(bl+nRun))))
        {
            nRun++;
            if (nRun==count) { break; }
        }

        if (nRun==0)
        {
            while (((*((DWORD*)bl+nRun))>>24)==0xFF)
            {
                nRun++;
                if (nRun==count) { break; }
            }
            if (nRun>0)
            {
                Dither_sRGB_555_MMX(d,bl,nRun,otherParams);

                count-=nRun;
                d+=nRun;
                bl+=nRun;
                s+=nRun;
            }
            while ((count>0) && (((*((DWORD*)bl))>>24)==0x00))
            {
                count--;
                d++;
                bl++;
                s++;
            }
        }
        else
        {
            // Source
            Convert_555_sRGB(buffer2,s,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer1,buffer2,nRun,otherParams);

            // Surface to blend
            AlphaDivide_sRGB(buffer0,bl,nRun,otherParams);
            GammaConvert_sRGB_sRGB64(buffer2,buffer0,nRun,otherParams);
            AlphaMultiply_sRGB64(buffer0,buffer2,nRun,otherParams);

            // Blend to destination
            otherParams2.BlendingScan=buffer0;
            Blend_sRGB64_sRGB64_MMX(buffer1,buffer1,nRun,&otherParams2);
            GammaConvert_sRGB64_sRGB(buffer2,buffer1,nRun,otherParams);

            Dither_sRGB_555_MMX(d,buffer2,nRun,otherParams);

            count-=nRun;
            d+=nRun;
            bl+=nRun;
            s+=nRun;
        }
    }
}

// Blend sRGB over sRGB, ignoring the non-linear gamma.

VOID FASTCALL
ScanOperation::Blend_sRGB_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, ARGB)
    DEFINE_BLEND_POINTER(ARGB)

    ASSERT(count>0);

    UINT32 dstPixel;
    do {
        UINT32 blendPixel = *bl;
        UINT32 alpha = blendPixel >> 24;

        // If alpha is zero, skip everything, including writing the
        // destination pixel. This is needed for the RMW optimization.
        
        if (alpha != 0)
        {

            if (alpha == 255)
            {
                dstPixel = blendPixel;
            }
            else
            {
                //
                // Dst = B + (1-Alpha) * S
                //

                dstPixel = *s;

                ULONG Multa = 255 - alpha;
                ULONG _D1_00AA00GG = (dstPixel & 0xff00ff00) >> 8;
                ULONG _D1_00RR00BB = (dstPixel & 0x00ff00ff);

                ULONG _D2_AAAAGGGG = _D1_00AA00GG * Multa + 0x00800080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * Multa + 0x00800080;

                ULONG _D3_00AA00GG = (_D2_AAAAGGGG & 0xff00ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;

                ULONG _D4_AA00GG00 = (_D2_AAAAGGGG + _D3_00AA00GG) & 0xFF00FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;

                dstPixel = blendPixel + _D4_AA00GG00 + _D4_00RR00BB;
            }

            *d = dstPixel;
        }

        bl++;
        s++;
        d++;
    } while (--count != 0);
}

VOID FASTCALL
ScanOperation::Blend_sRGB_sRGB_MMX(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
#if defined(_X86_)
    using namespace sRGB;
    DEFINE_POINTERS(ARGB64, ARGB64)
    const void *pbl=otherParams->BlendingScan;
    static ULONGLONG halfMask=0x0080008000800080;
    DWORD dwBlendPixel;

    _asm {
        mov        ecx,count                   ; ecx=pixel counter
        mov        ebx,pbl                     ; ebx=blend pixel pointer
        mov        esi,s                       ; esi=source pixel pointer
        mov        edi,d                       ; edi=dest pixel pointer
        pxor       mm7,mm7                     ; mm7=[0|0|0|0]
        movq       mm3,halfMask

main_loop:
        mov        eax,DWORD ptr [ebx]
        mov        edx,eax                     ; eax=blend pixel
        shr        edx,24                      ; edx=alpha
        cmp        edx,0                       ; For some reason, doing a jz right after a shr stalls
        jz         alpha_blend_done            ; if alpha=0, no blending

        cmp        edx,0xFF
        jne        alpha_blend
        mov        [edi],eax                   ; if alpha=0xFF, copy bl to dest
        jmp        alpha_blend_done

alpha_blend:
        movd       mm4,eax

        mov        eax,[esi]                   ; eax=source
        movd       mm0,eax                     ; mm0=[0|0|AR|GB]
        punpcklbw  mm0,mm7                     ; mm0=[A|R|G|B]

        xor        edx,0xFF                    ; C=255-Alpha
        movd       mm2,edx                     ; mm2=[0|0|0|C]
        punpcklwd  mm2,mm2                     ; mm2=[0|0|C|C]
        punpckldq  mm2,mm2                     ; mm2=[C|C|C|C]

        pmullw     mm0,mm2
        paddw      mm0,mm3                     ; mm0=[AA|RR|GG|BB]
        movq       mm2,mm0                     ; mm2=[AA|RR|GG|BB]

        psrlw      mm0,8                       ; mm0=[A|R|G|B]
        paddw      mm0,mm2                     ; mm0=[AA|RR|GG|BB]
        psrlw      mm0,8                       ; mm0=[A|R|G|B]

        packuswb   mm0,mm0                     ; mm0=[AR|GB|AR|GB]
        paddd      mm0,mm4                     ; Add the blend pixel
        movd       edx,mm0                     ; edx=[ARGB] -> result pixel
        mov        [edi],edx

alpha_blend_done:
        add        edi,4
        add        esi,4
        add        ebx,4
        dec        ecx
        jg         main_loop

        emms
    }
#endif
}

// Blend from sRGB64 to sRGB64.

VOID FASTCALL
ScanOperation::Blend_sRGB64_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB64, ARGB64)
    DEFINE_BLEND_POINTER(ARGB64)
    using namespace sRGB;
    
    while (count--)
    {
        sRGB64Color blendPixel;
        blendPixel.argb = *bl;
        INT16 alpha = blendPixel.a;

        // If alpha is zero, skip everything, including writing the
        // destination pixel. This is needed for the RMW optimization.
        
        if (alpha != 0)
        {
            sRGB64Color dstPixel;

            if (alpha == SRGB_ONE)
            {
                dstPixel.argb = blendPixel.argb;
            }
            else
            {
                //
                // Dst = Src + (1-Alpha) * Dst
                //

                dstPixel.argb = *s;

                INT Multa = SRGB_ONE - alpha;
                
                dstPixel.r = ((dstPixel.r * Multa + SRGB_HALF) >> SRGB_FRACTIONBITS) + blendPixel.r;
                dstPixel.g = ((dstPixel.g * Multa + SRGB_HALF) >> SRGB_FRACTIONBITS) + blendPixel.g;
                dstPixel.b = ((dstPixel.b * Multa + SRGB_HALF) >> SRGB_FRACTIONBITS) + blendPixel.b;
                dstPixel.a = ((dstPixel.a * Multa + SRGB_HALF) >> SRGB_FRACTIONBITS) + blendPixel.a;
            }

            *d = dstPixel.argb;
        }

        bl++;
        s++;
        d++;
    }
}

// Blend from sRGB64 to sRGB64 MMX.

VOID FASTCALL
ScanOperation::Blend_sRGB64_sRGB64_MMX(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
#if defined(_X86_)
    using namespace sRGB;
    DEFINE_POINTERS(ARGB64, ARGB64)
    const void *pbl=otherParams->BlendingScan;
    static ULONGLONG ullSRGBHalfMask=0x1000100010001000;

    _asm {
        mov        ecx,count                   ; ecx=pixel counter
        mov        ebx,pbl                     ; ebx=blend pixel pointer
        mov        esi,s                       ; esi=source pixel pointer
        mov        edi,d                       ; edi=dest pixel pointer
        movq       mm4,ullSRGBHalfMask         ; mm4=mask with srgb half

main_loop:
        movsx      eax,word ptr [ebx+3*2]      ; eax=alpha
        or         eax,eax                     ; eax==0?
        jz         alpha_blend_done            ; if alpha=0, no blending

        movq       mm0,[ebx]                   ; mm0=blend pixel
        cmp        eax,SRGB_ONE                ; if alpha=SRGB_ONE, dest=blend
        jne        alpha_blend
        movq       [edi],mm0                   ; copy blend pixel to dest
        jmp        alpha_blend_done

alpha_blend:
        ; Get SRGB_ONE-Alpha
        neg        eax
        add        eax,SRGB_ONE                ; C=SRGB_ONE-Alpha
        movd       mm2, eax                    ; mm2=[0|0|0|C]
        punpcklwd  mm2, mm2
        punpckldq  mm2, mm2                    ; mm2=[C|C|C|C]

        ; Blend pixels
        movq       mm1,[esi]                   ; mm1=[A|R|G|B] source pixel
        movq       mm3,mm1                     ; mm3=[A|R|G|B] source pixel
        pmullw     mm1,mm2                     ; low word of source*C
        paddw      mm1,mm4                     ; add an srgb half for rounding
        psrlw      mm1,SRGB_FRACTIONBITS       ; truncate low SRGB_FRACTIONBITS
        pmulhw     mm3,mm2                     ; high word of source*C
        psllw      mm3,SRGB_INTEGERBITS        ; truncate high SRGB_INTEGERBITS
        por        mm1,mm3                     ; mm1=[A|R|G|B]
        paddw      mm1,mm0                     ; add blend pixel
        movq       [edi],mm1                   ; copy result to dest

alpha_blend_done:
        add        edi,8
        add        esi,8
        add        ebx,8

        dec        ecx
        jg         main_loop
        emms
    }
#endif
}


// Blend from sRGB to 16bpp 565, ignoring sRGB's non-linear gamma.

VOID FASTCALL
ScanOperation::Blend_sRGB_565(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT16, UINT16)
    DEFINE_BLEND_POINTER(ARGB)
    
    ASSERT(count>0);

    do {
        UINT32 blendPixel = *bl;
        UINT32 alpha = blendPixel >> 27;

        if (alpha != 0)
        {
            UINT32 dstPixel;

            // Blend: S + [ (255 - sA) * D ] / 255

            // First, convert the source pixel from 32bpp BGRA to
            // 5-5-5 16bpp, pre-multiplied.  
            //
            // Note: No rounding needs to be done on this conversion!

            blendPixel = ((blendPixel >> 8) & 0xf800) |
                         ((blendPixel >> 5) & 0x07e0) |
                         ((blendPixel >> 3) & 0x001f);
        
            if (alpha == 31)
            {
                dstPixel = blendPixel;
            }
            else
            {
                dstPixel = (UINT32) *s;

                UINT32 multA = 31 - alpha;

                UINT32 D1_00rr00bb = (dstPixel & 0xf81f);
                UINT32 D2_rrrrbbbb = D1_00rr00bb * multA + 0x00008010;
                UINT32 D3_00rr00bb = (D2_rrrrbbbb & 0x001f03e0) >> 5;
                UINT32 D4_rrxxbbxx = ((D2_rrrrbbbb + D3_00rr00bb) >> 5) & 0xf81f;

                UINT32 D1_000000gg = (dstPixel & 0x7e0) >> 5;
                UINT32 D2_0000gggg = D1_000000gg * 2 * multA + 0x00000020;
                UINT32 D3_000000gg = (D2_0000gggg & 0x00000fc0) >> 6;
                UINT32 D4_0000ggxx = ((D2_0000gggg + D3_000000gg) & 0x0fc0) >> 1;

                dstPixel = (UINT16) ((D4_rrxxbbxx | D4_0000ggxx) + blendPixel);
            }

            *d = (UINT16) dstPixel;
        }

        bl++;
        s++;
        d++;
    } while (--count != 0);
}

// Blend from sRGB to 16bpp 555, ignoring sRGB's non-linear gamma.

VOID FASTCALL
ScanOperation::Blend_sRGB_555(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT16, UINT16)
    DEFINE_BLEND_POINTER(ARGB)
    
    ASSERT(count>0);

    do {
        UINT32 blendPixel = *bl;
        UINT32 alpha = blendPixel >> 27;

        if (alpha != 0)
        {
            UINT32 dstPixel;

            // Blend: S + [ (255 - sA) * D ] / 255

            // First, convert the source pixel from 32bpp BGRA to
            // 5-5-5 16bpp, pre-multiplied.  
            //
            // Note: No rounding needs to be done on this conversion!

            blendPixel = ((blendPixel & 0x00f80000) >> 9) | 
                         ((blendPixel & 0x0000f800) >> 6) | 
                         ((blendPixel & 0x000000f8) >> 3);

            if (alpha == 31)
            {
                dstPixel = blendPixel;
            }                       
            else
            {
                dstPixel = (UINT32) *s;

                UINT32 multA = 31 - alpha;

                UINT32 D1_00rr00bb = (dstPixel & 0x7c1f);
                UINT32 D2_rrrrbbbb = D1_00rr00bb * multA + 0x00004010;
                UINT32 D3_00rr00bb = (D2_rrrrbbbb & 0x000f83e0) >> 5;
                UINT32 D4_rrxxbbxx = ((D2_rrrrbbbb + D3_00rr00bb) >> 5) & 0x7c1f;

                UINT32 D1_000000gg = (dstPixel & 0x3e0) >> 5;
                UINT32 D2_0000gggg = D1_000000gg * multA + 0x00000010;
                UINT32 D3_000000gg = (D2_0000gggg & 0x000003e0) >> 5;
                UINT32 D4_0000ggxx = (D2_0000gggg + D3_000000gg) & 0x03e0;

                dstPixel = (UINT16) ((D4_rrxxbbxx | D4_0000ggxx) + blendPixel);
            }

            *d = (UINT16) dstPixel;
        }

        bl++;
        s++;
        d++;
    } while (--count != 0);
}

// Blend from sRGB to RGB24, ignoring sRGB's non-linear gamma.

VOID FASTCALL
ScanOperation::Blend_sRGB_24(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DEFINE_BLEND_POINTER(ARGB)
    
    ASSERT(count>0);
    
    do {

        if (((UINT_PTR) d & 0x3) == 0)
        {
            while (count >= 4)
            {
                BYTE *bb = (BYTE *) bl;

                if ((bb[3] & bb[7] & bb[11] & bb[15]) != 0xFF)
                {
                    break;
                }

                ((UINT32 *) d)[0] = (bb[4] << 24)  | (bb[2] << 16)  | (bb[1] << 8)  | bb[0];
                ((UINT32 *) d)[1] = (bb[9] << 24)  | (bb[8] << 16)  | (bb[6] << 8)  | bb[5];
                ((UINT32 *) d)[2] = (bb[14] << 24) | (bb[13] << 16) | (bb[12] << 8) | bb[10];

                count -= 4;
                bl += 4;
                d += 12;
                s += 12;
            }
        }
        
        if (count == 0)
        {
            break;
        }

        UINT32 blendPixel = *bl;
        UINT32 alpha = blendPixel >> 24;

        if (alpha != 0)
        {
            UINT32 dstPixel;

            if (alpha == 255)
            {
                dstPixel = blendPixel;
            }
            else
            {
                // Dst = Src + (1-Alpha) * Dst

                UINT32 multA = 255 - alpha;

                UINT32 D1_000000GG = *(s + 1);
                UINT32 D2_0000GGGG = D1_000000GG * multA + 0x00800080;
                UINT32 D3_000000GG = (D2_0000GGGG & 0xff00ff00) >> 8;
                UINT32 D4_0000GG00 = (D2_0000GGGG + D3_000000GG) & 0xFF00FF00;

                UINT32 D1_00RR00BB = *(s) | (ULONG) *(s + 2) << 16;
                UINT32 D2_RRRRBBBB = D1_00RR00BB * multA + 0x00800080;
                UINT32 D3_00RR00BB = (D2_RRRRBBBB & 0xff00ff00) >> 8;
                UINT32 D4_00RR00BB = ((D2_RRRRBBBB + D3_00RR00BB) & 0xFF00FF00) >> 8;

                dstPixel = (D4_0000GG00 | D4_00RR00BB) + blendPixel;
            }

            *(d)     = (BYTE) (dstPixel);
            *(d + 1) = (BYTE) (dstPixel >> 8);
            *(d + 2) = (BYTE) (dstPixel >> 16);
        }

        bl++;
        d += 3;
        s += 3;
    } while (--count != 0);
}

// Blend from sRGB to BGR24, ignoring sRGB's non-linear gamma.

VOID FASTCALL
ScanOperation::Blend_sRGB_24BGR(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DEFINE_BLEND_POINTER(ARGB)
    
    ASSERT(count>0);
    
    do {
        UINT32 blendPixel = *bl;
        UINT32 alpha = blendPixel >> 24;

        if (alpha != 0)
        {
            UINT32 dstPixel;

            if (alpha == 255)
            {
                dstPixel = blendPixel;
            }
            else
            {
                // Dst = Src + (1-Alpha) * Dst

                UINT32 multA = 255 - alpha;

                UINT32 D1_000000GG = *(s + 1);
                UINT32 D2_0000GGGG = D1_000000GG * multA + 0x00800080;
                UINT32 D3_000000GG = (D2_0000GGGG & 0xff00ff00) >> 8;
                UINT32 D4_0000GG00 = (D2_0000GGGG + D3_000000GG) & 0xFF00FF00;

                UINT32 D1_00RR00BB = *(s) | (ULONG) *(s + 2) << 16;
                UINT32 D2_RRRRBBBB = D1_00RR00BB * multA + 0x00800080;
                UINT32 D3_00RR00BB = (D2_RRRRBBBB & 0xff00ff00) >> 8;
                UINT32 D4_00RR00BB = ((D2_RRRRBBBB + D3_00RR00BB) & 0xFF00FF00) >> 8;

                dstPixel = (D4_0000GG00 | D4_00RR00BB) + blendPixel;
            }

            *(d)     = (BYTE) (dstPixel >> 16);
            *(d + 1) = (BYTE) (dstPixel >> 8);
            *(d + 2) = (BYTE) (dstPixel);
        }

        bl++;
        d += 3;
        s += 3;
    } while (--count != 0);
}

/*

!!![agodfrey]
So we're going to move to standardizing on non-premultiplied alpha.
When we do, the above routines will all have to change - but we may
want to keep the above versions around too.

Below, I've implemented the sRGB and sRGB64 versions for a non-premultiplied
source. Now, these really blend from a non-premultiplied source, 
to a pre-multiplied destination. You can see this from the fact that they 
are equivalent to combining the above pre-multiplied Blends with an
AlphaMultiply step on the source data.

Since pre-multiplied and non-premultiplied formats are identical for alpha==1,
the functions below work fine when the destination has no alpha (i.e. alpha==1).

Otherwise, we can use them when the destination is in premultiplied format.
If we somehow let the user draw to such a destination, they can use an off-screen
premultiplied buffer to accumulate drawing, and then using a
pre-multiplied blend, draw that to the final destination. This gives them
the same functionality that standardizing on pre-multiplied alpha is supposed
to give.

// Blend sRGB over sRGB, ignoring the non-linear gamma.

VOID FASTCALL
ScanOperation::Blend_sRGB_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, ARGB)
    DEFINE_BLEND_POINTER(ARGB)
    
    ASSERT(count>0);

    do {
        UINT32 blendPixel = *bl;
        UINT32 alpha = blendPixel >> 24;

        // If alpha is zero, skip everything, including writing the
        // destination pixel. This is needed for the RMW optimization.
        
        if (alpha != 0)
        {
            UINT32 dstPixel;

            if (alpha == 255)
            {
                dstPixel = blendPixel;
            }
            else
            {
                // Dst = Dst * (1-Alpha) + Src * Alpha
                
                dstPixel = *s;

                ULONG invalpha = 255 - alpha;
                
                ULONG _D1_00AA00GG = (dstPixel & 0xff00ff00) >> 8;
                ULONG _D1_00RR00BB = (dstPixel & 0x00ff00ff);
                
                // For the alpha channel, the result we want is this:
                //
                //     Dst = Dst * (1-Alpha) + Src.
                //
                // Or equivalently:
                //
                //     Dst = Dst * (1-Alpha) + Alpha.
                //                
                // We want to apply the same operations to the alpha channel as
                // we do to the others. So, to get the above result from
                //
                //     Dst = Dst * (1-Alpha) + Src * Alpha
                //
                // we fake a 'Src' value of 1 (represented by 255).
                
                ULONG _S1_00ff00GG = (blendPixel & 0xff00ff00) >> 8 + 0xff0000;
                ULONG _S1_00RR00BB = (blendPixel & 0x00ff00ff);

                ULONG _D2_AAAAGGGG = _D1_00AA00GG * invalpha + 
                                     _S1_00ff00GG * alpha +
                                     0x00800080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * invalpha + 
                                     _S1_00RR00BB * alpha + 
                                     0x00800080;

                ULONG _D3_00AA00GG = (_D2_AAAAGGGG & 0xff00ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;

                ULONG _D4_AA00GG00 = (_D2_AAAAGGGG + _D3_00AA00GG) & 0xFF00FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;

                
                dstPixel = _D4_AA00GG00 + _D4_00RR00BB;
            }

            *d = dstPixel;
        }

        bl++;
        s++;
        d++;
    } while (--count != 0);
}

// Blend from sRGB64 to sRGB64.

VOID FASTCALL
ScanOperation::Blend_sRGB64_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB64, ARGB64)
    DEFINE_BLEND_POINTER(ARGB64)
    using namespace sRGB;
    
    while (count--)
    {
        sRGB64Color blendPixel;
        blendPixel.argb = *bl;
        INT alpha = blendPixel.a;

        // If alpha is zero, skip everything, including writing the
        // destination pixel. This is needed for the RMW optimization.
        
        if (alpha != 0)
        {
            sRGB64Color dstPixel;

            if (alpha == SRGB_ONE)
            {
                dstPixel.argb = blendPixel.argb;
            }
            else
            {
                // Dst = Dst * (1-Alpha) + Src * Alpha

                dstPixel.argb = *s;

                INT invalpha = SRGB_ONE - alpha;
                
                dstPixel.r = ((dstPixel.r * invalpha) + 
                              (blendPixel.r * alpha) +
                              SRGB_HALF) >> 
                              SRGB_FRACTIONBITS;
                dstPixel.g = ((dstPixel.g * invalpha) + 
                              (blendPixel.g * alpha) +
                              SRGB_HALF) >> 
                              SRGB_FRACTIONBITS;
                dstPixel.b = ((dstPixel.b * invalpha) + 
                              (blendPixel.b * alpha) +
                              SRGB_HALF) >> 
                              SRGB_FRACTIONBITS;
                dstPixel.a = (((dstPixel.a * invalpha) + SRGB_HALF) >> 
                              SRGB_FRACTIONBITS) + 
                             blendPixel.a;
            }

            *d = dstPixel.argb;
        }

        bl++;
        s++;
        d++;
    }
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\socopy.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "Copy" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
*   Scan operations for copying a scan. Because the operation doesn't need
*   to interpret the pixel data, we only need one function per pixel
*   size (in bits).
*
* Notes:
*
*   The destination and source scans must not overlap in memory.
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*   12/02/1999 agodfrey
*       Moved it from Imaging\Api\convertfmt.cpp.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Operation Description:
*
*   Copy: Copy a scan, to the same destination format.
*
* Arguments:
*
*   dst         - The destination scan (same format as src)
*   src         - The source scan
*   count       - The length of the scan, in pixels
*   otherParams - Additional data. (Ignored.)
*
* Return Value:
*
*   None
*
* History:
*
*   05/13/1999 davidx
*       Created it.
*   12/02/1999 agodfrey
*       Moved & reorganized it.
*
\**************************************************************************/

// Copy 1bpp

VOID FASTCALL
ScanOperation::Copy_1(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    GpMemcpy(dst, src, (count + 7) >> 3);
}

// Copy 4bpp

VOID FASTCALL
ScanOperation::Copy_4(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    GpMemcpy(dst, src, (4*count + 4) >> 3);
}

// Copy 8bpp

VOID FASTCALL
ScanOperation::Copy_8(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    GpMemcpy(dst, src, count);
}

// Copy 16bpp

VOID FASTCALL
ScanOperation::Copy_16(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    GpMemcpy(dst, src, 2*count);
}

// Copy 24bpp

VOID FASTCALL
ScanOperation::Copy_24(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    GpMemcpy(dst, src, 3*count);
}

// Copy 32bpp

VOID FASTCALL
ScanOperation::Copy_32(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, ARGB)
    
    while (count--)
    {
        *d++ = *s++;
    }
}

// Copy 48bpp

VOID FASTCALL
ScanOperation::Copy_48(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    GpMemcpy(dst, src, 6*count);
}

// Copy 64bpp

VOID FASTCALL
ScanOperation::Copy_64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB64, ARGB64)
    
    while (count--)
    {
        *d++ = *s++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\soctblend.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Abstract:
*
*   Contains ClearType scan operations
*
* Revision History:
*
*   07/19/2000 mleonov
*       Created it.
*   01/11/2001 mleonov
*       Reengineered ClearType architecture to allow variable length scan records
*
\**************************************************************************/

#include "precomp.hpp"

static inline VOID
SetupGammaTables(ULONG ulGamma, const BYTE ** gamma, const BYTE ** gammaInv)
{
    static BYTE const * const gammaTables[] =
    {
        Globals::TextContrastTableIdentity, Globals::TextContrastTableIdentity,
        Globals::TextContrastTablesDir[0],  Globals::TextContrastTablesInv[0],
        Globals::TextContrastTablesDir[1],  Globals::TextContrastTablesInv[1],
        Globals::TextContrastTablesDir[2],  Globals::TextContrastTablesInv[2],
        Globals::TextContrastTablesDir[3],  Globals::TextContrastTablesInv[3],
        Globals::TextContrastTablesDir[4],  Globals::TextContrastTablesInv[4],
        Globals::TextContrastTablesDir[5],  Globals::TextContrastTablesInv[5],
        Globals::TextContrastTablesDir[6],  Globals::TextContrastTablesInv[6],
        Globals::TextContrastTablesDir[7],  Globals::TextContrastTablesInv[7],
        Globals::TextContrastTablesDir[8],  Globals::TextContrastTablesInv[8],
        Globals::TextContrastTablesDir[9],  Globals::TextContrastTablesInv[9],
        Globals::TextContrastTablesDir[10], Globals::TextContrastTablesInv[10],
        Globals::TextContrastTablesDir[11], Globals::TextContrastTablesInv[11]
    };

    if (ulGamma > 12)
    {
        ASSERT(FALSE);
        ulGamma = 12;
    }
    *gamma    = gammaTables[2 * ulGamma];
    *gammaInv = gammaTables[2 * ulGamma + 1];
} // SetupGammaTables

static __forceinline BYTE
BlendOneChannel(BYTE alphaCT, BYTE alphaBrush, BYTE foreground, BYTE background, const BYTE * gamma, const BYTE * gammaInv)
{
    ASSERT(0 <= alphaCT && alphaCT <= CT_SAMPLE_F);
    if (alphaCT == 0)
        return background;
    foreground = gamma[foreground];
    background = gamma[background];
    ULONG ulongRet = ULONG(0.5 + background + ((double)alphaBrush * (foreground - background) * alphaCT) / (255 * CT_SAMPLE_F));
    ASSERT(ulongRet <= 255);
    BYTE ret = (BYTE)ulongRet;
    ret = gammaInv[ret];
    return ret;
} // BlendOneChannel

namespace
{

class ClearTypeSolidBlend
{
    const ARGB      ArgbF;
    const BYTE *    ClearTypeBits;

public:
    ClearTypeSolidBlend(const ScanOperation::OtherParams * otherParams)
        : ClearTypeBits(otherParams->CTBuffer), ArgbF(otherParams->SolidColor)
    {}

    // always call IsCompletelyTransparent in the beginning of RMW operation
    bool IsCompletelyTransparent() const
    {
        return GetAlpha() == 0;
    }
    BYTE GetCT() const
    {
        return *ClearTypeBits;
    }
    ARGB GetARGB() const
    {
        return ArgbF;
    }
    BYTE GetAlpha() const
    {
        return (BYTE)GpColor::GetAlphaARGB(ArgbF);
    }
    BYTE GetRed() const
    {
        return (BYTE)GpColor::GetRedARGB(ArgbF);
    }
    BYTE GetGreen() const
    {
        return (BYTE)GpColor::GetGreenARGB(ArgbF);
    }
    BYTE GetBlue() const
    {
        return (BYTE)GpColor::GetBlueARGB(ArgbF);
    }
    bool IsOpaque() const
    {
        return GetCT() == CT_LOOKUP - 1 && GetAlpha() == 255;
    }
    bool IsTransparent() const
    {
        // we took care of zero GetAlpha() in IsCompletelyTransparent()
        return GetCT() == 0;
    }
    bool IsTranslucent() const
    {
        return !IsTransparent() && !IsOpaque();
    }
    void operator++()
    {
        ++ClearTypeBits;
    }
}; // class ClearTypeSolidBlend

class ClearTypeCARGBBlend
{
    const ARGB *    ArgbBrushBits;
    const BYTE *    ClearTypeBits;
public:
    ClearTypeCARGBBlend(const ScanOperation::OtherParams * otherParams)
        : ClearTypeBits(otherParams->CTBuffer),
          ArgbBrushBits(static_cast<const ARGB*>(otherParams->BlendingScan))
    {}

    bool IsCompletelyTransparent() const
    {
        return false;
    }
    BYTE GetCT() const
    {
        return *ClearTypeBits;
    }
    ARGB GetARGB() const
    {
        return *ArgbBrushBits;
    }
    BYTE GetAlpha() const
    {
        return (BYTE)GpColor::GetAlphaARGB(*ArgbBrushBits);
    }
    BYTE GetRed() const
    {
        return (BYTE)GpColor::GetRedARGB(*ArgbBrushBits);
    }
    BYTE GetGreen() const
    {
        return (BYTE)GpColor::GetGreenARGB(*ArgbBrushBits);
    }
    BYTE GetBlue() const
    {
        return (BYTE)GpColor::GetBlueARGB(*ArgbBrushBits);
    }
    bool IsOpaque() const
    {
        return GetCT() == CT_LOOKUP - 1 && GetAlpha() == 255;
    }
    bool IsTransparent() const
    {
        return GetCT() == 0 || GetAlpha() == 0;
    }
    bool IsTranslucent() const
    {
        return !IsTransparent() && !IsOpaque();
    }
    void operator++()
    {
        ++ClearTypeBits;
        ++ArgbBrushBits;
    }
}; // class ClearTypeCARGBBlend

} // namespace

template <class BLENDTYPE>
static VOID ClearTypeBlend(
    VOID *dst,
    const VOID *src,
    INT count,
    const ScanOperation::OtherParams *otherParams,
    BLENDTYPE & bl
    )
{
    if (bl.IsCompletelyTransparent())
        return;

    DEFINE_POINTERS(ARGB, ARGB)

    ASSERT(count > 0);

    ULONG gammaValue = otherParams->TextContrast;

    const BYTE * gamma, * gammaInv;
    SetupGammaTables(gammaValue, &gamma, &gammaInv);

    do {
        if (bl.IsTransparent())
            ; // fully transparent case, nothing to do
        else if (bl.IsOpaque())
        {   // fully opaque case, copy the foreground color
            *d = bl.GetARGB();
        }
        else
        {
            const BYTE blendIndex = bl.GetCT();
            ASSERT(0 <= blendIndex && blendIndex <= CT_LOOKUP - 1);

            const Globals::F_RGB blend = Globals::gaOutTable[blendIndex];
            const ARGB source = *s;
            const BYTE alphaBrush = bl.GetAlpha();

            const BYTE dstRed = BlendOneChannel(
                blend.kR,
                alphaBrush,
                bl.GetRed(),
                (BYTE)GpColor::GetRedARGB(source),
                gamma,
                gammaInv);

            const BYTE dstGre = BlendOneChannel(
                blend.kG,
                alphaBrush,
                bl.GetGreen(),
                (BYTE)GpColor::GetGreenARGB(source),
                gamma,
                gammaInv);

            const BYTE dstBlu = BlendOneChannel(
                blend.kB,
                alphaBrush,
                bl.GetBlue(),
                (BYTE)GpColor::GetBlueARGB(source),
                gamma,
                gammaInv);

            *d = GpColor::MakeARGB(255, dstRed, dstGre, dstBlu);
        }
        ++bl;
        ++s;
        ++d;
    } while (--count);
} // ClearTypeBlend


VOID FASTCALL
ScanOperation::CTBlendCARGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeCARGBBlend bl(otherParams);
    ClearTypeBlend(dst, src, count, otherParams, bl);
} // ScanOperation::CTBlendCARGB

VOID FASTCALL
ScanOperation::CTBlendSolid(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeSolidBlend bl(otherParams);
    ClearTypeBlend(dst, src, count, otherParams, bl);
} // ScanOperation::CTBlendSolid

template <class BLENDTYPE>
static VOID
CTReadRMW16(
    VOID *dst,
    const VOID *src,
    INT count,
    const ScanOperation::OtherParams *otherParams,
    BLENDTYPE & bl
    )
{
    if (bl.IsCompletelyTransparent())
        return;

    DEFINE_POINTERS(UINT16, UINT16)
    
    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    if (((ULONG_PTR) s) & 0x2)
    {
        if (bl.IsTranslucent())
        {
            *(d) = *(s);
        }
                                        
        d++;
        s++;
        ++bl;
        count--;
    }

    // Now go through the aligned dword loop:

    while ((count -= 2) >= 0)
    {
        if (bl.IsTranslucent())
        {
            ++bl;
            if (bl.IsTranslucent())
            {
                // Both pixels have partial alpha, so do a dword read:

                *((UNALIGNED UINT32*) d) = *((UINT32*) s);
            }
            else
            {
                // Only the first pixel has partial alpha, so do a word read:

                *(d) = *(s);
            }
        }
        else
        {
            ++bl;
            if (bl.IsTranslucent())
            {
                // Only the second pixel has partial alpha, so do a word read:

                *(d + 1) = *(s + 1);
            }
        }

        d += 2;
        s += 2;
        ++bl;
    }

    // Handle the end alignment:

    if (count & 1)
    {
        if (bl.IsTranslucent())
        {
            *(d) = *(s);
        }
    }
} // CTReadRMW16

VOID FASTCALL ScanOperation::ReadRMW_16_CT_CARGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeCARGBBlend bl(otherParams);
    CTReadRMW16(dst, src, count, otherParams, bl);
} // ScanOperation::ReadRMW_16_CT_CARGB

VOID FASTCALL ScanOperation::ReadRMW_16_CT_Solid(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeSolidBlend bl(otherParams);
    CTReadRMW16(dst, src, count, otherParams, bl);
} // ScanOperation::ReadRMW_16_CT_Solid

template <class BLENDTYPE>
static VOID
CTReadRMW24(
    VOID *dst,
    const VOID *src,
    INT count,
    const ScanOperation::OtherParams *otherParams,
    BLENDTYPE & bl
    )
{
    if (bl.IsCompletelyTransparent())
        return;

    DEFINE_POINTERS(BYTE, BYTE)
    
    ULONG_PTR srcToDstDelta = (ULONG_PTR) d - (ULONG_PTR) s;

    // Handle the initial partial read:

    INT initialAlignment = (INT) ((ULONG_PTR) s & 3);
    if (initialAlignment)
    {
        if (bl.IsTranslucent())
        {
            UINT32 *alignedSrc = (UINT32*) ((ULONG_PTR) s & ~3);
            DWORD dwBuffer[2];

            // Get pointer to start of pixel inside dwBuffer
            BYTE *pByte = (BYTE*) dwBuffer + initialAlignment;

            // Copy first aligned DWORDS from the source
            dwBuffer[0] = *alignedSrc;
            // Copy next one only if pixel is split between 2 aligned DWORDS
            if (initialAlignment >= 2)
                dwBuffer[1] = *(alignedSrc + 1);

            // Copy 4 bytes to the destination
            //  This will cause an extra byte to have garbage in the
            //  destination buffer, but will be overwritten if next pixel
            //  is used.
            *((DWORD*) d) = *((UNALIGNED DWORD*) pByte);
        }

        ++bl;
        s += 3;
        if (--count == 0)
            return;
    }

    while (TRUE)
    {
        // Find the first pixel to copy
    
        while (!bl.IsTranslucent())
        {
            ++bl;
            s += 3;
            if (--count == 0)
            {                           
                return;
            }
        }

        UINT32 *startSrc = (UINT32*) ((ULONG_PTR) (s) & ~3);
    
        // Now find the first "don't copy" pixel after that:
    
        while (bl.IsTranslucent())
        {
            ++bl;
            s += 3;
            if (--count == 0)
            {
                break;
            }
        }

        // 'endSrc' is inclusive of the last pixel's last byte:

        UINT32 *endSrc = (UINT32*) ((ULONG_PTR) (s + 2) & ~3);
        UNALIGNED UINT32 *dstPtr = (UNALIGNED UINT32*) ((ULONG_PTR) startSrc + srcToDstDelta);
    
        while (startSrc <= endSrc)
        {
            *dstPtr++ = *startSrc++;
        }

        if (count == 0)
            return;
    }
} // CTReadRMW24

VOID FASTCALL ScanOperation::ReadRMW_24_CT_CARGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeCARGBBlend bl(otherParams);
    CTReadRMW24(dst, src, count, otherParams, bl);
} // ScanOperation::ReadRMW_24_CT_CARGB

VOID FASTCALL ScanOperation::ReadRMW_24_CT_Solid(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeSolidBlend bl(otherParams);
    CTReadRMW24(dst, src, count, otherParams, bl);
} // ScanOperation::ReadRMW_24_CT_Solid


template <class BLENDTYPE>
static VOID
CTWriteRMW16(
    VOID *dst,
    const VOID *src,
    INT count,
    const ScanOperation::OtherParams *otherParams,
    BLENDTYPE & bl
    )
{
    if (bl.IsCompletelyTransparent())
        return;

    DEFINE_POINTERS(UINT16, UINT16)

    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    if (((ULONG_PTR) d) & 0x2)
    {
        if (!bl.IsTransparent())
        {
            *(d) = *(s);
        }

        d++;
        s++;
        ++bl;
        count--;
    }

    // Now go through the aligned dword loop:

    while ((count -= 2) >= 0)
    {
        if (!bl.IsTransparent())
        {
            ++bl;
            if (!bl.IsTransparent())
            {
                // Both pixels have partial bl, so do a dword read:

                *((UINT32*) d) = *((UNALIGNED UINT32*) s);
            }
            else
            {
                // Only the first pixel has partial bl, so do a word read:

                *(d) = *(s);
            }
        }
        else
        {
            ++bl;
            if (!bl.IsTransparent())
            {
                // Only the second pixel has partial bl, so do a word read:

                *(d + 1) = *(s + 1);
            }
        }

        d += 2;
        s += 2;
        ++bl;
    }

    // Handle the end alignment:

    if (count & 1)
    {
        if (!bl.IsTransparent())
        {
            *(d) = *(s);
        }
    }
} // CTWriteRMW16

VOID FASTCALL ScanOperation::WriteRMW_16_CT_CARGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeCARGBBlend bl(otherParams);
    CTWriteRMW16(dst, src, count, otherParams, bl);
} // ScanOperation::WriteRMW_16_CT_CARGB

VOID FASTCALL ScanOperation::WriteRMW_16_CT_Solid(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeSolidBlend bl(otherParams);
    CTWriteRMW16(dst, src, count, otherParams, bl);
} // ScanOperation::WriteRMW_16_CT_Solid


template <class BLENDTYPE>
static VOID
CTWriteRMW24(
    VOID *dst,
    const VOID *src,
    INT count,
    const ScanOperation::OtherParams *otherParams,
    BLENDTYPE & bl
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    
    ASSERT(count>0);

    do {
        if (!bl.IsTransparent())
        {
            // Doing byte per byte writes are much faster than finding
            //  runs and doing DWORD copies.
            *(d)     = *(s);
            *(d + 1) = *(s + 1);
            *(d + 2) = *(s + 2);
        }
        d += 3;
        s += 3;
        ++bl;
    } while (--count != 0);
} // CTWriteRMW24


VOID FASTCALL ScanOperation::WriteRMW_24_CT_CARGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeCARGBBlend bl(otherParams);
    CTWriteRMW24(dst, src, count, otherParams, bl);
} // ScanOperation::WriteRMW_24_CT_CARGB

VOID FASTCALL ScanOperation::WriteRMW_24_CT_Solid(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    ClearTypeSolidBlend bl(otherParams);
    CTWriteRMW24(dst, src, count, otherParams, bl);
} // ScanOperation::WriteRMW_24_CT_CARGB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\sodither.inc ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module name:
*
*   Include file to generate either 5-5-5 or 5-6-5 versions of the
*   dither code.
*
* Notes:
*
*   When DITHER_BLEND_555 is #defined to 1, then this file will generate
*   5-5-5 versions of the included routines.
*
*   When DITHER_BLEND_555 is #defined to 0, then we will generate 5-6-5
*   versions.
*
* Revision History:
*
*   03/15/2000 andrewgo
*       Created it.
*
\**************************************************************************/

#undef DITHER_ARRAY
#undef RED_SHIFT
#undef GREEN_SHIFT
#undef BLUE_SHIFT
#undef DITHERBLEND_FUNC
#undef DITHER_FUNC

#if DITHER_BLEND_555

    #define DITHER_ARRAY Dither555
    #define RED_SHIFT 9
    #define GREEN_SHIFT 6
    #define BLUE_SHIFT 3
    #define DITHERBLEND_FUNC ScanOperation::Dither_Blend_sRGB_555_MMX
    #define DITHER_FUNC ScanOperation::Dither_sRGB_555_MMX

#else

    #define DITHER_ARRAY Dither565
    #define RED_SHIFT 8
    #define GREEN_SHIFT 5
    #define BLUE_SHIFT 3
    #define DITHERBLEND_FUNC ScanOperation::Dither_Blend_sRGB_565_MMX
    #define DITHER_FUNC ScanOperation::Dither_sRGB_565_MMX
    
#endif

// Do a dithered blend to 16bpp using MMX

VOID FASTCALL
DITHERBLEND_FUNC(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
#if defined(_X86_)

    DEFINE_POINTERS(ARGB, WORD);
    DEFINE_BLEND_POINTER(ARGB);
    
    ASSERT(count != 0);
    ASSERT(otherParams);

    static ULONGLONG redBlueMask = 0x00f800f800f800f8;
    static ULONGLONG flipAlphaBits = 0x00ff00ff00ff00ff;

#if DITHER_BLEND_555
    static ULONGLONG greenMask = 0x0000f8000000f800;
    static ULONGLONG redBlueMultiplier = 0x0400000104000001;
#else
    static ULONGLONG greenMask = 0x0000fc000000fc00;
    static ULONGLONG redBlueMultiplier = 0x0800000108000001;
#endif

    INT x = otherParams->X;
    INT y = otherParams->Y;

    UINT32 *dither = (otherParams->DoingDither) 
                   ? &DITHER_ARRAY[8 * (y & 3)] 
                   : &DitherNone[0];
    UINT32 ditherIncrement = (x & 3) * 4;               

    const ARGB *blendPixel = bl;

    _asm
    {
        ; ecx = count
        ; esi = source
        ; edi = destination
        ; mm4 = red and blue mask (0xf800f8)
        ; mm5 = green mask (0x00fc00) (0x00f800 for 5-5-5)
        ; mm6 = C1 | C0 dither
        ; mm7 = C3 | C2 dither

        mov             eax, ditherIncrement
        mov             esi, blendPixel
        mov             edi, d
        mov             ecx, count
        movq            mm4, redBlueMask
        movq            mm5, greenMask
    
        ; We always want our qword reads from the screen to be aligned.
        ; So if the initial pixel is not qword-aligned, we handle up to
        ; three pixels up front to make it qword-aligned.
        ;
        ; (Note that as a consequence of us aligning to the destination,
        ; we're often doing unaligned reads on the source.  But it's
        ; a much bigger performance win to align operations to the screen
        ; than to system memory, due to the terrible screen read
        ; performance.)

alignment_loop:
        add             eax, dither
        test            edi, 6
        movq            mm6, [eax]      
        movq            mm7, [eax+8]    
        jz              done_start_alignment
        call            do_single_pixel        

        ; Adjust our pointers and load our new dither values:

        mov             eax, ditherIncrement
        add             eax, 4
        and             eax, 0x0000000F
        mov             ditherIncrement, eax
        add             esi, 4
        add             edi, 2
        dec             ecx
        jz              all_done
        jmp             alignment_loop

    done_start_alignment:
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    do_main_loop:
        sub             ecx, 4                  ; pre-decrement by 4
        jl              do_pair

        ; We do chunks of 4 pixels at a time so that we can unroll our
        ; dither loop (our dither repeats every 4 pixels).
        
    do_main_loop_2:
        mov             al, [esi+3]           
        and             al, [esi+7]
        and             al, [esi+11]
        and             al, [esi+15]
        inc             al                      ; if all alphas were 0xff, this
        jnz             do_pair                 ;   will wrap to zero
    

        ; The four pixels starting at [esi] are opaque.  We only need to
        ; dither them and convert to 16bpp.  The following codepath will
        ; process all four in parallel (two at a time) in order to optimize
        ; usage of the execution units and minimize dependencies between
        ; consecutive instructions.
            
        ; We start by reading the four pixels into mm0 and mm1, adding
        ; the dither component, and then breaking into group 0 (pixels 0
        ; and 2) and group 1 (pixels 1 and 3).  I will use **0** and **1**
        ; in the comments below to show which pixel group the instruction is
        ; processing

        movq            mm0, [esi]              ; mm0 = DW1 | DW0
        movq            mm1, [esi + 8]          ; mm1 = DW3 | DW2

        paddusb         mm0, mm6                ; add dither
        movq            mm2, mm0
        paddusb         mm1, mm7                ; add dither

        add             edi, 8
        
        punpckhdq       mm2, mm1         ; **1**  mm2 = DW3 | DW1
        punpckldq       mm0, mm1         ; **0**  mm0 = DW2 | DW0
        
        movq            mm3, mm2         ; **1**
        pand            mm2, mm4         ; **1**  red and blue
        
        movq            mm1, mm0         ; **0**
        pand            mm0, mm4         ; **0**  red and blue

        pand            mm3, mm5         ; **1**  green

        psrlw           mm0, 3           ; **0**  shift red and blue to lowest 
                                         ; 5 bits in register
        
        ; Note the use of the pmaddwd to simultaneously shift both the red and
        ; blue bits into their appropriate positions.  The constant 
        ; redBlueMultiplier contains four shorts, each of which is equal to
        ; 2^i where i is the number of bits that we need to shift that color
        ; component by in order to attain the correct position in the 16bpp
        ; color.  This is possible only because the red and blue
        ; components lie on different shorts in the 64bits register (green has
        ; been masked earlier), and so we can dedicate an entire 16bit short
        ; to red and to blue.

        pmaddwd         mm2, redBlueMultiplier  ; **1**
                
        add             esi, 16

        pand            mm1, mm5         ; **0**  green

        psrld           mm3, GREEN_SHIFT-3 ; **1**
        
        pmaddwd         mm0, redBlueMultiplier  ; **0**
            
        sub             ecx, 4                  ; pre-decrement for next iteration

        por             mm2, mm3         ; **1**  combine green with red/blue
                                         ;        mm2 = 0  | W3 | 0  | W1
        
        psrld           mm1, GREEN_SHIFT ; **0**

        psllq           mm2, 13          ; **1**  mm2 = W3 | 0  | W1 | 0

        por             mm0, mm1         ; **0**  combine green with red/blue
                                         ;        mm1 = 0  | W2 | 0  | W0

        por             mm0, mm2                ; mm2 = W3 | W2 | W1 | W0
        movq            [edi - 8], mm0

        jge             do_main_loop_2
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    do_pair:
        add             ecx, 2                  ; pre-decrement for this iteration
        jl              do_last_pixel
    
        ; We're doing only a single pair of pixels, so swap our dither
        ; values in preparation for the next iteration:
    
        pxor            mm6, mm7
        pxor            mm7, mm6
        pxor            mm6, mm7                ; swap mm6 and mm7
    
        mov             al, [esi+3]
        inc             al
        cmp             al, 1
        ja              do_pair_blend

        mov             al, [esi+7]
        inc             al
        cmp             al, 1
        ja              do_pair_blend

        mov             al, [esi+3]             ; Do we really want this here?
        or              al, [esi+7]
        jz              do_pair_done
    
        movq            mm0, [esi]
        paddusb         mm0, mm7                ; add dither
        movq            mm2, mm0
        pand            mm0, mm5                ; green
        pand            mm2, mm4                ; red and blue
        psrld           mm0, GREEN_SHIFT        ; green (6 for 5-5-5)
        movq            mm3, mm2
        psrld           mm3, BLUE_SHIFT         ; blue
        psrld           mm2, RED_SHIFT          ; red (9 for 5-5-5)
        por             mm0, mm3
        por             mm0, mm2                ; mm0 = X | C1 | X | C0
        movq            mm1, mm0
        psrlq           mm1, 32
        punpcklwd       mm0, mm1                ; mm0 = X | X | C1 | C0
    
        movd            eax, mm0
        cmp             byte ptr [esi+3], 0
        je              do_pair_done_first_write        
        mov             [edi], ax        
    do_pair_done_first_write:
        cmp             byte ptr [esi+7], 0
        je              do_pair_done_second_write
        shr             eax, 16
        mov             [edi+2], ax
    do_pair_done_second_write:
        add             edi, 4
        add             esi, 8
        jmp             do_main_loop
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    do_pair_blend:
        movd            mm1, [edi]              ; read destination, X | X | C1 | C0
        punpcklwd       mm1, mm1                ; C1 | C1 | C0 | C0
        psrld           mm1, 16                 ; 0 | C1 | 0 | C0
                                                ;  (trick using single red and
                                                ;  blue mask requires high bits
                                                ;  to be zero)
        movq            mm0, mm1
        movq            mm2, mm1
        pslld           mm1, BLUE_SHIFT         ; blue
        pslld           mm0, GREEN_SHIFT        ; green (6 for 5-5-5)
        pslld           mm2, RED_SHIFT          ; red (9 for 5-5-5)
        por             mm1, mm2                ; combine red and blue
        pand            mm1, mm4                ; leave valid red and blue bits
        pand            mm0, mm5                ; leave valid green bits
        por             mm1, mm0                ; mm1 = C1 | C0        
    
        ; Okay now we've got the destination read and split.  Handle the first 
        ; blend:
    
        movd            mm2, [esi]
        punpcklbw       mm2, mm2
        psrlw           mm2, 8                  ; mm2 = S
        movq            mm3, mm2
        punpckhwd       mm3, mm3
        punpckhdq       mm3, mm3                ; mm3 = alpha
        movq            mm0, mm1
        punpcklbw       mm0, mm0
        psrlw           mm0, 8                  ; mm0 = D
    #if NO_PREMULTIPLIED_ALPHA
        psubw           mm2, mm0               
        pmullw          mm2, mm3                ; mm2 = alpha * (S - D)
        movq            mm3, mm2
        psrlw           mm3, 8
        paddw           mm2, mm3                ; approximate x/255 by 257/65536
        psrlw           mm2, 8                  ; mm2 = alpha * (S - D)
        paddb           mm0, mm2                ; mm0 = C0 = D + alpha * (S - D)
    #else
        pxor            mm3, flipAlphaBits
        pmullw          mm0, mm3                ; mm2 = (255 - alpha) * D
        movq            mm3, mm0
        psrlw           mm0, 8                  ; approximate x/255 by 257/65536
        paddw           mm0, mm3                ; mm2 = (255 - alpha) * D / 255
        psrlw           mm0, 8                  ; don't care about rounding, not enough bits
        paddb           mm0, mm2                ; mm0 = C0 = S + (1 - alpha) * D
    #endif
    
        ; Handle the second blend (change mm0 to mm1):
    
        movd            mm2, [esi+4]
        punpcklbw       mm2, mm2
        psrlw           mm2, 8                  ; mm2 = S
        movq            mm3, mm2
        punpckhwd       mm3, mm3
        punpckhdq       mm3, mm3                ; mm3 = alpha
        punpckhbw       mm1, mm1
        psrlw           mm1, 8                  ; mm1 = D
    #if NO_PREMULTIPLIED_ALPHA
        psubw           mm2, mm1               
        pmullw          mm2, mm3                ; mm2 = alpha * (S - D)
        movq            mm3, mm2
        psrlw           mm3, 8
        paddw           mm2, mm3                ; approximate x/255 by 257/65536
        psrlw           mm2, 8                  ; mm2 = alpha * (S - D)
        paddb           mm1, mm2                ; mm1 = C1 = D + alpha * (S - D)
    #else
        pxor            mm3, flipAlphaBits    
        pmullw          mm1, mm3                ; mm2 = (255 - alpha) * D
        movq            mm3, mm1
        psrlw           mm1, 8                  ; approximate x/255 by 257/65536
        paddw           mm1, mm3                ; mm2 = (255 - alpha) * D / 255
        psrlw           mm1, 8                  ; don't care about rounding, not enough bits
        paddb           mm1, mm2                ; mm1 = C1 = S + (1 - alpha) * D
    #endif
        packuswb        mm0, mm1                ; mm0 = C1 | C0
    
        ; Dither and pack everything back up:
    
        paddusb         mm0, mm7                ; add dither
        movq            mm2, mm0
        pand            mm0, mm5                ; green
        pand            mm2, mm4                ; red and blue
        psrld           mm0, GREEN_SHIFT        ; green
        movq            mm3, mm2
        psrld           mm3, BLUE_SHIFT         ; blue
        psrld           mm2, RED_SHIFT          ; red
        por             mm0, mm3
        por             mm0, mm2                ; mm0 = X | C1 | X | C0
        movq            mm1, mm0
        psrlq           mm1, 32                 ; mm1 = 0 | 0 | X | C1
        punpcklwd       mm0, mm1                ; mm0 = X | X | C1 | C0
    
        movd            [edi], mm0
    
    do_pair_done:
        add             edi, 4
        add             esi, 8
        jmp             do_main_loop
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    do_single_pixel:
        movd            mm0, [esi]
        mov             al, [esi+3]
        inc             al
        jnz             do_single_blend         ; if not completely opaque 
    
        paddusb         mm0, mm6                ; add dither
        movq            mm2, mm0
        pand            mm0, mm5                ; green
        pand            mm2, mm4                ; red and blue
        psrld           mm0, GREEN_SHIFT
        movq            mm3, mm2
        psrld           mm3, BLUE_SHIFT
        psrld           mm2, RED_SHIFT
        por             mm0, mm3
        por             mm0, mm2                ; mm0 = X | C1 | X | C0
    
        movd            eax, mm0
        mov             [edi], ax        
    do_single_done:
        ret
    
    do_single_blend:
        dec             al
        jz              do_single_done          ; completely transparent pixel
    
        ; alpha is between 0 and 255
    
        movzx           eax, word ptr [edi]     ; do the destination read
        movd            mm1, eax                ; mm1 = 0 | 0 | 0 | C0
        movq            mm0, mm1
        movq            mm2, mm1
        pslld           mm1, BLUE_SHIFT         ; blue 
        pslld           mm0, GREEN_SHIFT        ; green (6 for 5-5-5)
        pslld           mm2, RED_SHIFT          ; red (9 for 5-5-5)
        por             mm1, mm2                ; combine red and blue
        pand            mm1, mm4                ; leave valid red and blue bits
        pand            mm0, mm5                ; leave valid green bits
        por             mm1, mm0                ; mm1 = C1 | C0        
    
        ; Okay now we've got the destination read and split.  Handle the first blend:
    
        movd            mm2, [esi]
        punpcklbw       mm2, mm2
        psrlw           mm2, 8                  ; mm2 = S
        movq            mm3, mm2
        punpckhwd       mm3, mm3
        punpckhdq       mm3, mm3                ; mm3 = alpha
        movq            mm0, mm1
        punpcklbw       mm0, mm0
        psrlw           mm0, 8                  ; mm0 = D
    #if NO_PREMULTIPLIED_ALPHA
        psubw           mm2, mm0               
        pmullw          mm2, mm3                ; mm2 = alpha * (S - D)
        movq            mm3, mm2
        psrlw           mm3, 8
        paddw           mm2, mm3                ; approximate x/255 by 257/65536
        psrlw           mm2, 8                  ; mm2 = alpha * (S - D)
        paddb           mm0, mm2                ; mm0 = C0 = D + alpha * (S - D)
    #else
        pxor            mm3, flipAlphaBits    
        pmullw          mm0, mm3                ; mm2 = (255 - alpha) * D
        movq            mm3, mm0
        psrlw           mm0, 8                  ; approximate x/255 by 257/65536
        paddw           mm0, mm3                ; mm2 = (255 - alpha) * D / 255
        psrlw           mm0, 8                  ; don't care about rounding, not enough bits
        paddb           mm0, mm2                ; mm0 = C0 = S + (1 - alpha) * D
    #endif
        packuswb        mm0, mm0                ; mm0 = C1 | C0
    
        ; Dither and pack everything back up:
    
        paddusb         mm0, mm6                ; add dither
        movq            mm2, mm0
        pand            mm0, mm5                ; green
        pand            mm2, mm4                ; red and blue
        psrld           mm0, GREEN_SHIFT
        movq            mm3, mm2
        psrld           mm3, BLUE_SHIFT
        psrld           mm2, RED_SHIFT
        por             mm0, mm3
        por             mm0, mm2                ; mm0 = X | C1 | X | C0
    
        movd            eax, mm0
        mov             [edi], ax        
        ret
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    do_last_pixel:
        test            ecx, 1
        jz              all_done
        call            do_single_pixel

    all_done:
        emms      
    }

#endif
}

// Dither to 16bpp using MMX

VOID FASTCALL
DITHER_FUNC(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
#if defined(_X86_)

    DEFINE_POINTERS(ARGB, WORD);
    
    ASSERT(count != 0);
    ASSERT(otherParams);

    static ULONGLONG redBlueMask = 0x00f800f800f800f8;
    static ULONGLONG flipAlphaBits = 0x00ff00ff00ff00ff;

#if DITHER_BLEND_555
    static ULONGLONG greenMask = 0x0000f8000000f800;
#else
    static ULONGLONG greenMask = 0x0000fc000000fc00;
#endif

    INT x = otherParams->X;
    INT y = otherParams->Y;

    UINT32 *dither = (otherParams->DoingDither) 
                   ? &DITHER_ARRAY[8 * (y & 3) + (x & 3)] 
                   : &DitherNone[0];
                   
    _asm
    {
        ; ecx = count
        ; esi = source
        ; edi = destination
        ; mm4 = red and blue mask (0xf800f8)
        ; mm5 = green mask (0x00fc00) (0x00f800 for 5-5-5)
        ; mm6 = C1 | C0 dither
        ; mm7 = C3 | C2 dither

        mov             eax, dither
        mov             esi, s
        mov             edi, d
        mov             ecx, count
        movq            mm4, redBlueMask
        movq            mm5, greenMask
        movq            mm6, [eax]      
        movq            mm7, [eax+8]    
        sub             ecx, 4                  ; pre-decrement by 4
        jl              do_last_3_pixels_or_less
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ; We do chunks of 4 pixels at a time so that we can unroll our
        ; dither loop (our dither repeats every 4 pixels).

    do_main_loop:
        movq            mm0, [esi]
        paddusb         mm0, mm6                ; add dither
        movq            mm2, mm0
        pand            mm0, mm5                ; green
        pand            mm2, mm4                ; red and blue
        psrld           mm0, GREEN_SHIFT        ; green (6 for 5-5-5)
        movq            mm3, mm2
        psrld           mm3, BLUE_SHIFT         ; blue
        psrld           mm2, RED_SHIFT          ; red (9 for 5-5-5)
        por             mm0, mm3
        por             mm0, mm2                ; mm0 = X | C1 | X | C0
        movq            mm1, mm0
        psrlq           mm1, 32                 ; mm1 = X | X | X | C1
        punpcklwd       mm0, mm1                ; mm0 = X | X | C1 | C0
        movd            [edi], mm0
    
        movq            mm0, [esi+8]
        paddusb         mm0, mm7                ; add dither
        movq            mm2, mm0
        pand            mm0, mm5                ; green
        pand            mm2, mm4                ; red and blue
        psrld           mm0, GREEN_SHIFT
        movq            mm3, mm2
        psrld           mm3, BLUE_SHIFT
        psrld           mm2, RED_SHIFT
        por             mm0, mm3
        por             mm0, mm2                ; mm0 = X | C1 | X | C0
        movq            mm1, mm0
        psrlq           mm1, 32
        punpcklwd       mm0, mm1                ; mm0 = X | X | C1 | C0
        movd            [edi+4], mm0
    
        add             edi, 8
        add             esi, 16
        sub             ecx, 4                  ; pre-decrement for next iteration
        jge             do_main_loop
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    do_last_3_pixels_or_less:
        add             ecx, 4                  ; get back 'real' count
        jz              all_done

        dec             ecx                     ; if exactly 1 pixel left
        jz              do_last_pixel
        
    ; do 2 pixels
        ; we'll decrement ecx again later

        movq            mm0, [esi]
        paddusb         mm0, mm6                ; add dither
        movq            mm2, mm0
        pand            mm0, mm5                ; green
        pand            mm2, mm4                ; red and blue
        psrld           mm0, GREEN_SHIFT        ; green (6 for 5-5-5)
        movq            mm3, mm2
        psrld           mm3, BLUE_SHIFT         ; blue
        psrld           mm2, RED_SHIFT          ; red (9 for 5-5-5)
        por             mm0, mm3
        por             mm0, mm2                ; mm0 = X | C1 | X | C0
        movq            mm1, mm0
        psrlq           mm1, 32                 ; mm1 = X | X | X | C1
        punpcklwd       mm0, mm1                ; mm0 = X | X | C1 | C0
        movd            eax, mm0
        mov             [edi], eax
        
        dec             ecx
        jz              all_done
        
        add             esi, 8
        add             edi, 4

    do_last_pixel:    
        movd            mm0, [esi]
        paddusb         mm0, mm7                ; add dither
        movq            mm2, mm0
        pand            mm0, mm5                ; green
        pand            mm2, mm4                ; red and blue
        psrld           mm0, GREEN_SHIFT
        movq            mm3, mm2
        psrld           mm3, BLUE_SHIFT
        psrld           mm2, RED_SHIFT
        por             mm0, mm3
        por             mm0, mm2                ; mm0 = X | C1 | X | C0
        movq            mm1, mm0
        psrlq           mm1, 32
        punpcklwd       mm0, mm1                ; mm0 = X | X | C1 | C0
        movd            eax, mm0
        mov             [edi], ax

    all_done:
        emms      
    }

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\sogammaconvert.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "GammaConvert" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
*   These operations convert from one format to another, accounting
*   for differing gamma ramps.
*
* Revision History:
*
*   12/06/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Operation Description:
*
*   GammaConvert: Convert from one format to another, accounting
*                 for differing gamma ramps.
*
* Arguments:
*
*   dst         - The destination scan
*   src         - The source scan
*   count       - The length of the scan, in pixels
*   otherParams - Additional conversion data.
*
* Return Value:
*
*   None
*
* History:
*
*   12/07/1999 agodfrey
*       Created it.
*
\**************************************************************************/

// 32bpp sRGB to 64bpp sRGB64

VOID FASTCALL
ScanOperation::GammaConvert_sRGB_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, ARGB64)
    while (count--)
    {
        sRGB::ConvertTosRGB64(*s++,d++);
    }
}

// 64bpp sRGB64 to 32bpp sRGB

VOID FASTCALL
ScanOperation::GammaConvert_sRGB64_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB64, ARGB)
    while (count--)
    {
        *d++ = sRGB::ConvertTosRGB(*s++);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\soconvert.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "Convert" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
*   This module implements scan operations for converting pixels from
*   one format, to another of equal or greater color precision.
*   (Conversion to a lesser color precision is done with either a "Quantize"
*   operation or a "Halftone" operation.)
*
* Notes:
*
*   If the source format doesn't have alpha, we assume an alpha of 1.
*
*   If the source format has a palette, it is supplied in otherParams->Srcpal.
*
*   When converting to greater color precision, we need to be careful.
*   The operation must:
*     + Map 0 to 0
*     + Map the maximum value to the maxmimum value (e.g. in 555->32bpp,
*       it must map 31 to 255).
*
*   In addition, we desire that the mapping is as close to linear as possible.
*
*   Currently (12/16/1999), our 16bpp->32bpp code does have slight rounding
*   errors. e.g. we get a different value from "round(x*31/255)" when x is
*   3, 7, 24, or 28. This is probably acceptable. We could also speed
*   the code up by using byte lookup tables. (From an unpublished paper
*   by Blinn & Marr of MSR.)
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*   12/02/1999 agodfrey
*       Moved it to from Imaging\Api\convertfmt.cpp.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Operation Description:
*
*   Convert: Convert pixel format up to 32bpp ARGB.
*
* Arguments:
*
*   dst         - The destination scan (32bpp ARGB)
*   src         - The source scan
*   count       - The length of the scan, in pixels
*   otherParams - Additional conversion data.
*
* Return Value:
*
*   None
*
* History:
*
*   05/13/1999 davidx
*       Created it.
*   12/02/1999 agodfrey
*       Moved & reorganized it.
*
\**************************************************************************/

// Convert from 1bpp indexed to sRGB

VOID FASTCALL
ScanOperation::Convert_1_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, ARGB)
    ASSERT(otherParams->Srcpal);
    ASSERT(otherParams->Srcpal->Count >= 2);
    
    UINT n, bits;

    ARGB c0 = otherParams->Srcpal->Entries[0];
    ARGB c1 = otherParams->Srcpal->Entries[1];

    // NOTE: We choose code size over speed here

    while (count)
    {
        bits = *s++;
        n = count > 8 ? 8 : count;
        count -= n;

        while (n--)
        {
            *d++ = (bits & 0x80) ? c1 : c0;
            bits <<= 1;
        }
    }
}

// Convert from 4bpp indexed to sRGB

VOID FASTCALL
ScanOperation::Convert_4_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, ARGB)
    ASSERT(otherParams->Srcpal);
    
    const ARGB* colors = otherParams->Srcpal->Entries;
    UINT n = count >> 1;

    // Handle whole bytes

    while (n--)
    {
        UINT bits = *s++;

        ASSERT((bits >> 4)  < otherParams->Srcpal->Count);
        ASSERT((bits & 0xf) < otherParams->Srcpal->Count);
        
        d[0] = colors[bits >> 4];
        d[1] = colors[bits & 0xf];

        d += 2;
    }

    // Handle the last odd nibble, if any

    if (count & 1)
        *d = colors[*s >> 4];
}

// Convert from 8bpp indexed to sRGB

VOID FASTCALL
ScanOperation::Convert_8_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, ARGB)
    ASSERT(otherParams->Srcpal);
    
    const ARGB* colors = otherParams->Srcpal->Entries;
    
    while (count--)
    {
#if DBG
        if (*s >= otherParams->Srcpal->Count)
        {
            WARNING(("Palette missing entries on conversion from 8bpp to sRGB"));
        }
#endif
        *d++ = colors[*s++];
    }
}

// Convert 16bpp RGB555 to sRGB

VOID FASTCALL
ScanOperation::Convert_555_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(WORD, ARGB)
    
    while (count--)
    {
        ARGB v = *s++;
        ARGB r = (v >> 10) & 0x1f;
        ARGB g = (v >>  5) & 0x1f;
        ARGB b = (v      ) & 0x1f;

        *d++ = ALPHA_MASK |
               (((r << 3) | (r >> 2)) << RED_SHIFT) |
               (((g << 3) | (g >> 2)) << GREEN_SHIFT) |
               (((b << 3) | (b >> 2)) << BLUE_SHIFT);
    }
}

// Convert from 16bpp RGB565 to sRGB

VOID FASTCALL
ScanOperation::Convert_565_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(WORD, ARGB)
    
    while (count--)
    {
        ARGB v = *s++;
        ARGB r = (v >> 11) & 0x1f;
        ARGB g = (v >>  5) & 0x3f;
        ARGB b = (v      ) & 0x1f;

        *d++ = ALPHA_MASK |
              (((r << 3) | (r >> 2)) << RED_SHIFT) |
              (((g << 2) | (g >> 4)) << GREEN_SHIFT) |
              (((b << 3) | (b >> 2)) << BLUE_SHIFT);
    }
}

// Convert from 16bpp ARGB1555 to sRGB

VOID FASTCALL
ScanOperation::Convert_1555_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(WORD, ARGB)
    
    while (count--)
    {
        ARGB v = *s++;
        ARGB a = (v & 0x8000) ? ALPHA_MASK : 0;
        ARGB r = (v >> 10) & 0x1f;
        ARGB g = (v >>  5) & 0x1f;
        ARGB b = (v      ) & 0x1f;

        *d++ = a |
               (((r << 3) | (r >> 2)) << RED_SHIFT) |
               (((g << 3) | (g >> 2)) << GREEN_SHIFT) |
               (((b << 3) | (b >> 2)) << BLUE_SHIFT);
    }
}

// Convert from 24bpp RGB to sRGB

VOID FASTCALL
ScanOperation::Convert_24_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, ARGB)
    
    while (count--)
    {
        *d++ = ALPHA_MASK |
               ((ARGB) s[0] << BLUE_SHIFT) |
               ((ARGB) s[1] << GREEN_SHIFT) |
               ((ARGB) s[2] << RED_SHIFT);

        s += 3;
    }
}

// Convert from 24bpp BGR to sRGB

VOID FASTCALL
ScanOperation::Convert_24BGR_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, ARGB)
    
    while (count--)
    {
        *d++ = ALPHA_MASK |
               ((ARGB) s[0] << RED_SHIFT) |
               ((ARGB) s[1] << GREEN_SHIFT) |
               ((ARGB) s[2] << BLUE_SHIFT);

        s += 3;
    }
}

// Convert from 32bpp RGB to sRGB

VOID FASTCALL
ScanOperation::Convert_32RGB_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, ARGB)
    
    while (count--)
    {
        *d++ = *s++ | ALPHA_MASK;
    }
}

// Convert from 48bpp RGB to sRGB64

VOID FASTCALL
ScanOperation::Convert_48_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(INT16, ARGB64)
    
    while (count--)
    {
        using namespace sRGB;
        sRGB64Color c;
        c.a = SRGB_ONE;
        c.b = s[0];
        c.g = s[1];
        c.r = s[2];
        
        *d++ = c.argb;

        s += 3;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\sodither.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module name:
*
*   The "Dither" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
* Notes:
*
* Revision History:
*
*   01/19/2000 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Operation Description:
*
*   Dither: Dither from 32bpp ARGB to 16bpp.
*
* Arguments:
*
*   dst         - The destination scan
*   src         - The source scan (32bpp ARGB)
*   count       - The length of the scan, in pixels
*   otherParams - Additional data. (We use X and Y.)
*
* Return Value:
*
*   None
*
* Notes:
*
*   Special cases which alpha-blend and dither in one step, should probably
*   go in this file, but be named e.g. Blend_sRGB_565_Dithered.
*
* History:
*
*   01/19/2000 andrewgo
*       Created it.
*   01/19/2000 agodfrey
*       Stashed it here for the time being.
*
\**************************************************************************/

UINT32 Saturate5Bit[] = { 0,  1,  2,  3,  4,  5,  6,  7,
                          8,  9,  10, 11, 12, 13, 14, 15,
                          16, 17, 18, 19, 20, 21, 22, 23,
                          24, 25, 26, 27, 28, 29, 30, 31,
                          31 };

UINT32 Saturate6Bit[] = { 0,  1,  2,  3,  4,  5,  6,  7,
                          8,  9,  10, 11, 12, 13, 14, 15,
                          16, 17, 18, 19, 20, 21, 22, 23,
                          24, 25, 26, 27, 28, 29, 30, 31,
                          32, 33, 34, 35, 36, 37, 38, 39,
                          40, 41, 42, 43, 44, 45, 46, 47,
                          48, 49, 50, 51, 52, 53, 54, 55,
                          56, 57, 58, 59, 60, 61, 62, 63,
                          63 };

UINT32 Dither5BitR[16] = { 0x00000000, 0x00040000, 0x00010000, 0x00050000,
                           0x00060000, 0x00020000, 0x00070000, 0x00030000,
                           0x00010000, 0x00050000, 0x00000000, 0x00040000,
                           0x00070000, 0x00030000, 0x00060000, 0x00020000 };

UINT32 Dither5BitG[16] = { 0x00000000, 0x00000400, 0x00000100, 0x00000500,
                           0x00000600, 0x00000200, 0x00000700, 0x00000300,
                           0x00000100, 0x00000500, 0x00000000, 0x00000400,
                           0x00000700, 0x00000300, 0x00000600, 0x00000200 };

UINT32 Dither6BitG[16] = { 0x00000000, 0x00000200, 0x00000000, 0x00000200,
                           0x00000300, 0x00000100, 0x00000300, 0x00000100,
                           0x00000000, 0x00000200, 0x00000000, 0x00000200, 
                           0x00000300, 0x00000100, 0x00000300, 0x00000100 };

UINT32 Dither5BitB[16] = { 0x00000000, 0x00000004, 0x00000001, 0x00000005,
                           0x00000006, 0x00000002, 0x00000007, 0x00000003, 
                           0x00000001, 0x00000005, 0x00000000, 0x00000004,
                           0x00000007, 0x00000003, 0x00000006, 0x00000002 };

// The following 'Dither565' and 'Dither555' matrices are 4 by 4
// arrays for adding straight to an ARGB dword value.  Every row
// is repeated to allow us to do 128-bit reads with wrapping.

UINT32 Dither565[32] = { 0x00000000, 0x00040204, 0x00010001, 0x00050205,
                         0x00000000, 0x00040204, 0x00010001, 0x00050205,
                         0x00060306, 0x00020102, 0x00070307, 0x00030103,
                         0x00060306, 0x00020102, 0x00070307, 0x00030103,
                         0x00010001, 0x00050205, 0x00000000, 0x00040204,
                         0x00010001, 0x00050205, 0x00000000, 0x00040204,
                         0x00070307, 0x00030103, 0x00060306, 0x00020102,
                         0x00070307, 0x00030103, 0x00060306, 0x00020102 };

UINT32 Dither555[32] = { 0x00000000, 0x00040404, 0x00010101, 0x00050505, 
                         0x00000000, 0x00040404, 0x00010101, 0x00050505, 
                         0x00060606, 0x00020202, 0x00070707, 0x00030303,
                         0x00060606, 0x00020202, 0x00070707, 0x00030303,
                         0x00010101, 0x00050505, 0x00000000, 0x00040404,
                         0x00010101, 0x00050505, 0x00000000, 0x00040404,
                         0x00070707, 0x00030303, 0x00060606, 0x00020202,
                         0x00070707, 0x00030303, 0x00060606, 0x00020202 };

// The 'DitherNone' matrix allows us to disable dithering in a dithering
// routine:

UINT32 DitherNone[4] = { 0, 0, 0, 0 };

// Dither to 16bpp 565

VOID FASTCALL
ScanOperation::Dither_sRGB_565(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    // Since the MMX versions easily handle both dithering and non-dithering,
    // it makes it simpler if all the 16bpp functions handle both.

    if (!otherParams->DoingDither)
    {
        Quantize_sRGB_565(dst, src, count, otherParams);
        return;
    }

    DEFINE_POINTERS(ARGB, WORD);
    
    ASSERT(count != 0);
    ASSERT(otherParams);
    
    INT x = otherParams->X;
    INT y = otherParams->Y;

    // !!![andrewgo] Are we getting the window-relative (x, y)?  (Don't think so!)

    INT startDitherIndex = (y & 3) * 4;

    do {
        UINT32 src = *s;
        x = (x & 3) + startDitherIndex;

        *d = (WORD)
             (Saturate5Bit[((src & 0xff0000) + Dither5BitR[x]) >> 19] << 11) +
             (Saturate6Bit[((src & 0x00ff00) + Dither6BitG[x]) >> 10] << 5) +
             (Saturate5Bit[((src & 0x0000ff) + Dither5BitB[x]) >> 3]);

        s++;
        d++;
        x++;
    } while (--count != 0);
}

// Dither to 16bpp 555

VOID FASTCALL
ScanOperation::Dither_sRGB_555(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    // Since the MMX versions easily handle both dithering and non-dithering,
    // it makes it simpler if all the 16bpp functions handle both.

    if (!otherParams->DoingDither)
    {
        Quantize_sRGB_555(dst, src, count, otherParams);
        return;
    }

    DEFINE_POINTERS(ARGB, WORD);
    
    ASSERT(count != 0);
    ASSERT(otherParams);
    
    INT x = otherParams->X;
    INT y = otherParams->Y;

    INT startDitherIndex = (y & 3) * 4;

    do {
        UINT32 src = *s;
        x = (x & 3) + startDitherIndex;

        *d = (WORD)
             (Saturate5Bit[((src & 0xff0000) + Dither5BitR[x]) >> 19] << 10) +
             (Saturate5Bit[((src & 0x00ff00) + Dither5BitG[x]) >> 11] << 5) +
             (Saturate5Bit[((src & 0x0000ff) + Dither5BitB[x]) >> 3]);

        s++;
        d++;
        x++;
    } while (--count != 0);
}

// Blend from sRGB to 16bpp 565, with dithering.

VOID FASTCALL
ScanOperation::Dither_Blend_sRGB_565(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    // Since the MMX versions easily handle both dithering and non-dithering,
    // it makes it simpler if all the 16bpp functions handle both.

    if (!otherParams->DoingDither)
    {
        Blend_sRGB_565(dst, src, count, otherParams);
        return;
    }

    DEFINE_POINTERS(UINT16, UINT16)
    DEFINE_BLEND_POINTER(ARGB)
    
    ASSERT(count>0);

    INT x = otherParams->X;
    INT y = otherParams->Y;

    INT startDitherIndex = (y & 3) * 4;
    
    do {
        UINT32 blendPixel = *bl;
        UINT32 alpha = blendPixel >> 24;
        x = (x & 3) + startDitherIndex;

        if (alpha != 0)
        {
            UINT32 srcPixel;
            UINT r, g, b;

            r = blendPixel & 0xff0000;
            g = blendPixel & 0x00ff00;
            b = blendPixel & 0x0000ff;
            
            if (alpha != 255)
            {
                srcPixel = *s;
        
                UINT sr = (srcPixel >> 11) & 0x1f;
                UINT sg = (srcPixel >>  5) & 0x3f;
                UINT sb = (srcPixel      ) & 0x1f;

                sr = (sr << 3) | (sr >> 2);
                sg = (sg << 2) | (sg >> 4);
                sb = (sb << 3) | (sb >> 2);

                //
                // Dst = B + (1-Alpha) * S
                //

                ULONG Multa = 255 - alpha;
                ULONG _D1_000000GG = sg;
                ULONG _D1_00RR00BB = sb | (sr << 16);

                ULONG _D2_0000GGGG = _D1_000000GG * Multa + 0x00000080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * Multa + 0x00800080;

                ULONG _D3_000000GG = (_D2_0000GGGG & 0x0000ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;

                ULONG _D4_0000GG00 = (_D2_0000GGGG + _D3_000000GG) & 0x0000FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;

                r += _D4_00RR00BB; // The BB part will be shifted off
                g += _D4_0000GG00;
                b += _D4_00RR00BB & 0x0000ff;
            }

            *d = (WORD)
                 (Saturate5Bit[(r + Dither5BitR[x]) >> 19] << 11) +
                 (Saturate6Bit[(g + Dither6BitG[x]) >> 10] << 5) +
                 (Saturate5Bit[(b + Dither5BitB[x]) >> 3]);
        }

        bl++;
        s++;
        d++;
        x++;
    } while (--count != 0);
}

// Blend from sRGB to 16bpp 555, with dithering.

VOID FASTCALL
ScanOperation::Dither_Blend_sRGB_555(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    // Since the MMX versions easily handle both dithering and non-dithering,
    // it makes it simpler if all the 16bpp functions handle both.

    if (!otherParams->DoingDither)
    {
        Blend_sRGB_555(dst, src, count, otherParams);
        return;
    }

    DEFINE_POINTERS(UINT16, UINT16)
    DEFINE_BLEND_POINTER(ARGB)
    
    ASSERT(count>0);

    INT x = otherParams->X;
    INT y = otherParams->Y;

    INT startDitherIndex = (y & 3) * 4;
    
    do {
        UINT32 blendPixel = *bl;
        UINT32 alpha = blendPixel >> 24;
        x = (x & 3) + startDitherIndex;

        if (alpha != 0)
        {
            UINT32 srcPixel;
            UINT r, g, b;

            r = blendPixel & 0xff0000;
            g = blendPixel & 0x00ff00;
            b = blendPixel & 0x0000ff;
            
            if (alpha != 255)
            {
                srcPixel = *s;

                UINT sr = (srcPixel >> 10) & 0x1f;
                UINT sg = (srcPixel >>  5) & 0x1f;
                UINT sb = (srcPixel      ) & 0x1f;

                sr = (sr << 3) | (sr >> 2);
                sg = (sg << 3) | (sg >> 2);
                sb = (sb << 3) | (sb >> 2);
                
                //
                // Dst = B + (1-Alpha) * S
                //

                ULONG Multa = 255 - alpha;
                ULONG _D1_000000GG = sg;
                ULONG _D1_00RR00BB = sb | (sr << 16);

                ULONG _D2_0000GGGG = _D1_000000GG * Multa + 0x00000080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * Multa + 0x00800080;

                ULONG _D3_000000GG = (_D2_0000GGGG & 0x0000ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;

                ULONG _D4_0000GG00 = (_D2_0000GGGG + _D3_000000GG) & 0x0000FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;

                r += _D4_00RR00BB; // The BB part will be shifted off
                g += _D4_0000GG00;
                b += _D4_00RR00BB & 0x0000ff;
            }

            *d = (WORD)
                 (Saturate5Bit[(r + Dither5BitR[x]) >> 19] << 10) +
                 (Saturate5Bit[(g + Dither5BitG[x]) >> 11] << 5) +
                 (Saturate5Bit[(b + Dither5BitB[x]) >> 3]);
        }

        bl++;
        s++;
        d++;
        x++;
    } while (--count != 0);
}

// Generate 555 versions of the routines defined in 'sodither.inc'

#define DITHER_BLEND_555 1

#include "SODither.inc"

// Generate 565 versions of the routines defined in 'sodither.inc'

#undef DITHER_BLEND_555 
#define DITHER_BLEND_555 0

#include "SODither.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\scanoperationinternal.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   Scan operations
*
* Abstract:
*
*   The internal portion of the ScanOperation namespace.
*
*   This is kept separate from ScanOperation.hpp so that files which use
*   AlphaBlender.hpp or FormatConvert.hpp don't end up including all these
*   implementation details.
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview of scan operations.
*   
* Created:
*
*   07/16/1999 agodfrey
*
\**************************************************************************/

#ifndef _SCANOPERATIONINTERNAL_HPP
#define _SCANOPERATIONINTERNAL_HPP

#include "ScanOperation.hpp"
#include "CPUSpecificOps.hpp"

namespace ScanOperation
{
    // Helper macros for defining scan operations
    
    #define DEFINE_POINTERS(srctype, dsttype) \
        const srctype* s = static_cast<const srctype *>(src); \
        dsttype* d = static_cast<dsttype *>(dst);
    
    #define DEFINE_BLEND_POINTER(type) \
        const type* bl = static_cast<const type *>(otherParams->BlendingScan);
            
    // Convert: Convert to a higher-precision format
    
    VOID FASTCALL Convert_1_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_4_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_8_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_555_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_565_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_1555_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_24_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_24BGR_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_32RGB_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Convert_48_sRGB64(VOID *, const VOID *, INT, const OtherParams *);

    // Quantize: Quickly convert to a lower-precision format
    
    VOID FASTCALL Quantize_sRGB_555(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Quantize_sRGB_565(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Quantize_sRGB_1555(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Quantize_sRGB_24(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Quantize_sRGB_24BGR(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Quantize_sRGB_32RGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Quantize_sRGB64_48(VOID *, const VOID *, INT, const OtherParams *);
 
    // Halftone: Halftone to a palettized screen format
    
    VOID FASTCALL HalftoneToScreen_sRGB_8_216(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL HalftoneToScreen_sRGB_8_16(VOID *, const VOID *, INT, const OtherParams *);
    
    // Dither: Dither to a 16bpp format
    
    VOID FASTCALL Dither_sRGB_565(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Dither_sRGB_555(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Dither_sRGB_565_MMX(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Dither_sRGB_555_MMX(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Dither_Blend_sRGB_565(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Dither_Blend_sRGB_555(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Dither_Blend_sRGB_565_MMX(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Dither_Blend_sRGB_555_MMX(VOID *, const VOID *, INT, const OtherParams *);
    
    // Copy: Copy a scan, in the same format
    
    VOID FASTCALL Copy_1(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Copy_4(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Copy_8(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Copy_16(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Copy_24(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Copy_32(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Copy_48(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Copy_64(VOID *, const VOID *, INT, const OtherParams *);
    
    // GammaConvert: Convert between formats with differing gamma ramps
    
    VOID FASTCALL GammaConvert_sRGB64_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL GammaConvert_sRGB_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    
    // Blend: An alpha-blend 'SourceOver' operation.
        
    VOID FASTCALL Blend_sRGB_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Blend_sRGB_sRGB_MMX(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Blend_sRGB64_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Blend_sRGB64_sRGB64_MMX(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Blend_sRGB_555(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Blend_sRGB_565(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Blend_sRGB_24(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL Blend_sRGB_24BGR(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL BlendLinear_sRGB_32RGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL BlendLinear_sRGB_32RGB_MMX(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL BlendLinear_sRGB_565(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL BlendLinear_sRGB_565_MMX(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL BlendLinear_sRGB_555(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL BlendLinear_sRGB_555_MMX(VOID *, const VOID *, INT, const OtherParams *);

    // ReadRMW: For each pixel in "otherParams->blendingScan" that is 
    //   translucent (i.e. has (0 < alpha < 1)), copy the 
    //   corresponding pixel from "src" to "dst".
    
    VOID FASTCALL ReadRMW_8_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_8_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_16_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_16_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_24_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_24_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_32_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_32_sRGB64(VOID *, const VOID *, INT, const OtherParams *);

    // WriteRMW: For each pixel in "otherParams->blendingScan" that is not
    //   completely transparent (i.e. has (alpha != 0)), copy the 
    //   corresponding pixel from "src" to "dst".
    
    VOID FASTCALL WriteRMW_8_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_8_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_16_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_16_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_24_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_24_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_32_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_32_sRGB64(VOID *, const VOID *, INT, const OtherParams *);

    // AlphaMultiply: Multiply each component by the alpha value
    
    VOID FASTCALL AlphaMultiply_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL AlphaMultiply_sRGB64(VOID *, const VOID *, INT, const OtherParams *);
    
    // AlphaDivide: Divide each component by the alpha value
    
    VOID FASTCALL AlphaDivide_sRGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL AlphaDivide_sRGB64(VOID *, const VOID *, INT, const OtherParams *);

    // ClearType blend
    // solid brush case
    VOID FASTCALL CTBlendSolid(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_16_CT_Solid(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_16_CT_Solid(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_24_CT_Solid(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_24_CT_Solid(VOID *, const VOID *, INT, const OtherParams *);

    // arbitrary brush case
    VOID FASTCALL CTBlendCARGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_16_CT_CARGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_16_CT_CARGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL ReadRMW_24_CT_CARGB(VOID *, const VOID *, INT, const OtherParams *);
    VOID FASTCALL WriteRMW_24_CT_CARGB(VOID *, const VOID *, INT, const OtherParams *);   

    // These arrays organize the operations according to their use,
    // indexed by a pixel format:
    //
    // ConvertCopyOps: Copy pixels of the given format
    // ConvertIntoCanonicalOps: Convert from the given format into the
    //   closest canonical format.

    extern ScanOpFunc CopyOps[PIXFMT_MAX];
    extern ScanOpFunc ConvertIntoCanonicalOps[PIXFMT_MAX];
    
    // These are specific to EpAlphaBlender, and can't be used by 
    // EpFormatConverter (not without changing its logic).
    //
    // All 16bpp/15bpp functions must fully support OtherParams::DoingDither.
    //
    // ABConvertFromCanonicalOps: Convert to the given format from the closest
    //   canonical format.
    // BlendOpsLowQuality: Blend directly to the given format.
    // BlendOpsHighQuality: Gamma-corrected blend directly to the given format
    //   (with the source data in 32BPP_PARGB format).

    extern ScanOpFunc ABConvertFromCanonicalOps[PIXFMT_MAX];
    extern ScanOpFunc BlendOpsLowQuality[PIXFMT_MAX];
    extern ScanOpFunc BlendOpsHighQuality[PIXFMT_MAX];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\sohalftone.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "HalftoneToScreen" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
* Notes:
*
*   The "ToScreen" indicates that we make assumptions that are
*   screen-specific. For instance, we special-case the 20 default system 
*   colors.
*
* Revision History:
*
*   10/29/1999 DCurtis
*       Wrote it.
*   12/02/1999 agodfrey
*       Moved it from Imaging\Api\Colorpal.cpp.
*
\**************************************************************************/

#include "precomp.hpp"

#define DIV_51(ulNumerator, ulQuotient, ulRemainder)\
{ \
    ulQuotient = Div51lut[ulNumerator].quotient; \
    ulRemainder = Div51lut[ulNumerator].remainder; \
}

static struct
{
    BYTE quotient;
    BYTE remainder;
}
Div51lut[256] =
{
    0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,
    0x00, 0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07,
    0x00, 0x08, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x0b,
    0x00, 0x0c, 0x00, 0x0d, 0x00, 0x0e, 0x00, 0x0f,
    0x00, 0x10, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13,
    0x00, 0x14, 0x00, 0x15, 0x00, 0x16, 0x00, 0x17,
    0x00, 0x18, 0x00, 0x19, 0x00, 0x1a, 0x00, 0x1b,
    0x00, 0x1c, 0x00, 0x1d, 0x00, 0x1e, 0x00, 0x1f,
    0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23,
    0x00, 0x24, 0x00, 0x25, 0x00, 0x26, 0x00, 0x27,
    0x00, 0x28, 0x00, 0x29, 0x00, 0x2a, 0x00, 0x2b,
    0x00, 0x2c, 0x00, 0x2d, 0x00, 0x2e, 0x00, 0x2f,
    0x00, 0x30, 0x00, 0x31, 0x00, 0x32, 0x01, 0x00,
    0x01, 0x01, 0x01, 0x02, 0x01, 0x03, 0x01, 0x04,
    0x01, 0x05, 0x01, 0x06, 0x01, 0x07, 0x01, 0x08,
    0x01, 0x09, 0x01, 0x0a, 0x01, 0x0b, 0x01, 0x0c,
    0x01, 0x0d, 0x01, 0x0e, 0x01, 0x0f, 0x01, 0x10,
    0x01, 0x11, 0x01, 0x12, 0x01, 0x13, 0x01, 0x14,
    0x01, 0x15, 0x01, 0x16, 0x01, 0x17, 0x01, 0x18,
    0x01, 0x19, 0x01, 0x1a, 0x01, 0x1b, 0x01, 0x1c,
    0x01, 0x1d, 0x01, 0x1e, 0x01, 0x1f, 0x01, 0x20,
    0x01, 0x21, 0x01, 0x22, 0x01, 0x23, 0x01, 0x24,
    0x01, 0x25, 0x01, 0x26, 0x01, 0x27, 0x01, 0x28,
    0x01, 0x29, 0x01, 0x2a, 0x01, 0x2b, 0x01, 0x2c,
    0x01, 0x2d, 0x01, 0x2e, 0x01, 0x2f, 0x01, 0x30,
    0x01, 0x31, 0x01, 0x32, 0x02, 0x00, 0x02, 0x01,
    0x02, 0x02, 0x02, 0x03, 0x02, 0x04, 0x02, 0x05,
    0x02, 0x06, 0x02, 0x07, 0x02, 0x08, 0x02, 0x09,
    0x02, 0x0a, 0x02, 0x0b, 0x02, 0x0c, 0x02, 0x0d,
    0x02, 0x0e, 0x02, 0x0f, 0x02, 0x10, 0x02, 0x11,
    0x02, 0x12, 0x02, 0x13, 0x02, 0x14, 0x02, 0x15,
    0x02, 0x16, 0x02, 0x17, 0x02, 0x18, 0x02, 0x19,
    0x02, 0x1a, 0x02, 0x1b, 0x02, 0x1c, 0x02, 0x1d,
    0x02, 0x1e, 0x02, 0x1f, 0x02, 0x20, 0x02, 0x21,
    0x02, 0x22, 0x02, 0x23, 0x02, 0x24, 0x02, 0x25,
    0x02, 0x26, 0x02, 0x27, 0x02, 0x28, 0x02, 0x29,
    0x02, 0x2a, 0x02, 0x2b, 0x02, 0x2c, 0x02, 0x2d,
    0x02, 0x2e, 0x02, 0x2f, 0x02, 0x30, 0x02, 0x31,
    0x02, 0x32, 0x03, 0x00, 0x03, 0x01, 0x03, 0x02,
    0x03, 0x03, 0x03, 0x04, 0x03, 0x05, 0x03, 0x06,
    0x03, 0x07, 0x03, 0x08, 0x03, 0x09, 0x03, 0x0a,
    0x03, 0x0b, 0x03, 0x0c, 0x03, 0x0d, 0x03, 0x0e,
    0x03, 0x0f, 0x03, 0x10, 0x03, 0x11, 0x03, 0x12,
    0x03, 0x13, 0x03, 0x14, 0x03, 0x15, 0x03, 0x16,
    0x03, 0x17, 0x03, 0x18, 0x03, 0x19, 0x03, 0x1a,
    0x03, 0x1b, 0x03, 0x1c, 0x03, 0x1d, 0x03, 0x1e,
    0x03, 0x1f, 0x03, 0x20, 0x03, 0x21, 0x03, 0x22,
    0x03, 0x23, 0x03, 0x24, 0x03, 0x25, 0x03, 0x26,
    0x03, 0x27, 0x03, 0x28, 0x03, 0x29, 0x03, 0x2a,
    0x03, 0x2b, 0x03, 0x2c, 0x03, 0x2d, 0x03, 0x2e,
    0x03, 0x2f, 0x03, 0x30, 0x03, 0x31, 0x03, 0x32,
    0x04, 0x00, 0x04, 0x01, 0x04, 0x02, 0x04, 0x03,
    0x04, 0x04, 0x04, 0x05, 0x04, 0x06, 0x04, 0x07,
    0x04, 0x08, 0x04, 0x09, 0x04, 0x0a, 0x04, 0x0b,
    0x04, 0x0c, 0x04, 0x0d, 0x04, 0x0e, 0x04, 0x0f,
    0x04, 0x10, 0x04, 0x11, 0x04, 0x12, 0x04, 0x13,
    0x04, 0x14, 0x04, 0x15, 0x04, 0x16, 0x04, 0x17,
    0x04, 0x18, 0x04, 0x19, 0x04, 0x1a, 0x04, 0x1b,
    0x04, 0x1c, 0x04, 0x1d, 0x04, 0x1e, 0x04, 0x1f,
    0x04, 0x20, 0x04, 0x21, 0x04, 0x22, 0x04, 0x23,
    0x04, 0x24, 0x04, 0x25, 0x04, 0x26, 0x04, 0x27,
    0x04, 0x28, 0x04, 0x29, 0x04, 0x2a, 0x04, 0x2b,
    0x04, 0x2c, 0x04, 0x2d, 0x04, 0x2e, 0x04, 0x2f,
    0x04, 0x30, 0x04, 0x31, 0x04, 0x32, 0x05, 0x00
};

// LUT's which act on inputs in the range 0-5.

static BYTE Mult6plus40LUT[] =
{
    40, 40+6, 40+6*2, 40+6*3, 40+6*4, 40+6*5
};

static BYTE Mult36LUT[] =
{
    0, 36, 36*2, 36*3, 36*4, 36*5
};

// Halftone dither pattern arrays.

#define HALFTONE_SIZE 91

#if defined(_X86_)

// The following packed tables are used for the MMX implementation. To enable
// the MMX implementation, define HALFTONE_MMX. Define HALFTONE_SIZE to either
// 23 or 91 for the respective table. However, only 91 is currently supported
// because the C version does not support 23. Also, these tables should be
// moved to the HtTables files, along with the HALFTONE_SIZE definition.

#define HALFTONE_MMX

#if defined(HALFTONE_MMX)

#if (HALFTONE_SIZE == 23)

const DWORD HT_SuperCell_Packed[23*23] = {
    0x00220C18, 0x0010181F, 0x00180829, 0x00052A17, 0x00320225,         //  0
    0x001A2C04, 0x0020071B, 0x000F3111, 0x00041D2F, 0x000A131D,
    0x0021180F, 0x0027032A, 0x000F1E16, 0x0003322D, 0x002B2308,
    0x00261031, 0x00152901, 0x002B0326, 0x0009251C, 0x00261D07,
    0x000F1721, 0x001F0626, 0x00142C0E, 

    0x000C1D24, 0x002E2903, 0x00260F13, 0x001E2307, 0x0029190C,         //  1
    0x00021F32, 0x00151022, 0x002D1902, 0x0026280A, 0x00180929,
    0x00122F06, 0x002A0F19, 0x001B2802, 0x00200C12, 0x0018011C,
    0x000A1820, 0x001F0913, 0x000D2118, 0x0022120C, 0x00170529,
    0x00073115, 0x002A2205, 0x0003132C, 

    0x001B2608, 0x0016002F, 0x0001311A, 0x000E142D, 0x00130D1D,         //  2
    0x000A2F12, 0x00230417, 0x0007252C, 0x001E0D1A, 0x002F0014,
    0x000D2324, 0x00051A30, 0x002F061E, 0x000C1626, 0x00252B0C,
    0x00011D28, 0x00303005, 0x00190D2E, 0x00042723, 0x002F1903,
    0x001C0B30, 0x00102A1B, 0x00310911, 

    0x00240F15, 0x0009171F, 0x002C1E0D, 0x00200623, 0x002F2701,         //  3
    0x0019092A, 0x002B2108, 0x000E1425, 0x00132E0D, 0x00011D21,
    0x00251110, 0x001A2C0B, 0x00151E05, 0x0006252E, 0x002D1207,
    0x00162210, 0x0011052B, 0x0025160D, 0x000F2D1D, 0x00280F12,
    0x00131F09, 0x00270321, 0x00061A28, 

    0x001D2E02, 0x00290829, 0x00142406, 0x000C2D13, 0x00061B27,         //  4
    0x00271210, 0x00032B1E, 0x001C1A05, 0x0022052E, 0x002B2800,
    0x0009172B, 0x001F0418, 0x00270B21, 0x00103014, 0x001C0E1A,
    0x00210821, 0x00082916, 0x002D1C07, 0x001D0127, 0x000A2417,
    0x00012E2B, 0x0020130C, 0x000D2819, 

    0x0012200F, 0x00041522, 0x00191031, 0x00250317, 0x001D0D20,         //  5
    0x0011260B, 0x00170230, 0x00310F13, 0x000B2019, 0x0018081E,
    0x00122F0A, 0x00301027, 0x00082111, 0x002B0226, 0x0004192D,
    0x00282E02, 0x000E1325, 0x0002231B, 0x00160A32, 0x00231600,
    0x002C0723, 0x00191C06, 0x002E052F, 

    0x00220A16, 0x00312F08, 0x0008291A, 0x002A1903, 0x0000222C,         //  6
    0x002E1506, 0x000D2D17, 0x00250A23, 0x00062729, 0x00291610,
    0x00032431, 0x001B1C04, 0x000D2A1A, 0x00221507, 0x0017250E,
    0x00131E0A, 0x0032032A, 0x00200E13, 0x002A320A, 0x00101F11,
    0x00072A1B, 0x00140D29, 0x000A251E, 

    0x00011827, 0x001C012C, 0x00101D11, 0x001F0724, 0x0013320E,         //  7
    0x0023061C, 0x00051E27, 0x001D1902, 0x0015310D, 0x001F1108,
    0x00240122, 0x002C0D14, 0x0015052C, 0x0000311F, 0x002E0830,
    0x001F1018, 0x00052C1D, 0x00192605, 0x000D1A22, 0x001B102C,
    0x00300215, 0x001E300E, 0x00291204, 

    0x00172C0B, 0x00281013, 0x000B241E, 0x002F0D2A, 0x00171F09,         //  8
    0x000A1131, 0x002C2A10, 0x00110C1E, 0x002E042F, 0x000B1D17,
    0x00102C1B, 0x00062725, 0x001D1A10, 0x00291201, 0x00092323,
    0x000F1C11, 0x00260A27, 0x0009142E, 0x00280417, 0x0003241F,
    0x00251609, 0x00052030, 0x000E1B23, 

    0x00232703, 0x00130930, 0x00052E18, 0x00241600, 0x00022915,         //  9
    0x00200020, 0x00281804, 0x001B240A, 0x00031323, 0x00262303,
    0x0019082D, 0x002F1505, 0x0012210D, 0x00220729, 0x00182D09,
    0x002D0016, 0x001B2903, 0x0014210D, 0x002E2E07, 0x00180826,
    0x00112801, 0x00200E19, 0x002D061D, 

    0x00081424, 0x002F1F0E, 0x001E0528, 0x002A1B0C, 0x001A0A25,         // 10
    0x000F222D, 0x00063019, 0x0016052A, 0x00302D0E, 0x00081A28,
    0x001F0F12, 0x0002301D, 0x00270C2E, 0x00082918, 0x000E1720,
    0x00021331, 0x00230E1C, 0x00061B24, 0x00200B13, 0x000B172B,
    0x002C2D10, 0x001A032D, 0x000C2214, 

    0x00210C2A, 0x00182B07, 0x00101220, 0x0008251A, 0x00142C05,         // 11
    0x0032140F, 0x00250914, 0x000E1E1F, 0x00210D17, 0x00132809,
    0x002B0221, 0x000F2515, 0x00161C07, 0x00300427, 0x00201E0C,
    0x002A2706, 0x0012310F, 0x0031052A, 0x000F2A18, 0x00001F1E,
    0x0028110B, 0x00061B21, 0x00143005, 

    0x0005271B, 0x002B0115, 0x0001192F, 0x00230C12, 0x002C032B,         // 12
    0x000A1A26, 0x001E110A, 0x00012A2F, 0x00291703, 0x001B0726,
    0x000B2031, 0x00241400, 0x001C0923, 0x00042E12, 0x0014101D,
    0x0019032B, 0x00091822, 0x001C2301, 0x00241408, 0x00160131,
    0x001D2604, 0x00230A28, 0x0031180D, 

    0x00110F2D, 0x00261D0F, 0x001A3104, 0x000C2722, 0x001F1F0C,         // 13
    0x00042F1C, 0x00192306, 0x002D0222, 0x00112511, 0x00053219,
    0x0031110F, 0x00072B1C, 0x0029190B, 0x000C262F, 0x002D2204,
    0x00260B13, 0x0002201B, 0x002A082E, 0x000B2815, 0x002F0E25,
    0x00102C12, 0x00092217, 0x0019071F, 

    0x001E2408, 0x000A1524, 0x00300518, 0x00120F29, 0x00291601,         // 14
    0x00160732, 0x00250D16, 0x000B1D2A, 0x0023140C, 0x00150B2D,
    0x00211C08, 0x0019022B, 0x00120E25, 0x00230618, 0x00051520,
    0x000E2F27, 0x0020120B, 0x00142B0E, 0x00051820, 0x00181E0A,
    0x0028041C, 0x0003162B, 0x00252F01, 

    0x002A0219, 0x00022A31, 0x0017200B, 0x00220A1D, 0x00082C13,         // 15
    0x000F2720, 0x0030190E, 0x00052D1B, 0x001A2202, 0x002D0423,
    0x0001281F, 0x000F2114, 0x002E3002, 0x001D1B0D, 0x00162908,
    0x0032012C, 0x001B1C02, 0x00240519, 0x002E0B28, 0x001E3103,
    0x000C112F, 0x002D1C0D, 0x00140C22, 

    0x000F1928, 0x001C1011, 0x002D2E05, 0x0004182D, 0x002B2209,         // 16
    0x001A0127, 0x001F1304, 0x00130725, 0x0027102F, 0x000E2F12,
    0x001D1806, 0x00260828, 0x0006111C, 0x000B2332, 0x002A0D16,
    0x00101F12, 0x00042D23, 0x000C1530, 0x00112610, 0x00012018,
    0x00220924, 0x001A2D06, 0x00062314, 

    0x002E2802, 0x0024081F, 0x000D1C15, 0x00150424, 0x00210F19,         // 17
    0x000B1E2E, 0x00022B16, 0x002B260A, 0x00071A1D, 0x00210C17,
    0x000A252E, 0x002C150A, 0x00192B0F, 0x00220321, 0x00001829,
    0x0027071B, 0x00182306, 0x002C0E1D, 0x00271908, 0x0015012A,
    0x0031290F, 0x000D171E, 0x0020052D, 

    0x00051325, 0x000A2F19, 0x001A0C2A, 0x00272403, 0x0012310F,         // 18
    0x002F1507, 0x00240B1F, 0x0018052A, 0x00112010, 0x00312A04,
    0x00160025, 0x00031F19, 0x00140A2C, 0x00302603, 0x00123009,
    0x0021130F, 0x000A2A2D, 0x001F0414, 0x00052F22, 0x001B2401,
    0x00091332, 0x00290E15, 0x00171E09, 

    0x0011002F, 0x00232110, 0x0031150B, 0x0000281C, 0x001D0630,         // 19
    0x00081A26, 0x000D2313, 0x00273000, 0x00031431, 0x001C0722,
    0x0023120C, 0x002A3106, 0x000C1720, 0x001D0F14, 0x00081B26,
    0x002D0B1F, 0x001A1D02, 0x00101227, 0x002E0919, 0x00241B0D,
    0x00130620, 0x0002321A, 0x0025260E, 

    0x001E0A21, 0x00152B05, 0x00081B2C, 0x000F1122, 0x002B0916,         // 20
    0x00212C0A, 0x00150221, 0x001E0E1A, 0x002C190E, 0x000D2D1C,
    0x00071C28, 0x00102411, 0x00260430, 0x0004221B, 0x00292B0C,
    0x0016012F, 0x00022612, 0x00222D09, 0x0007172E, 0x000D2A25,
    0x002A2005, 0x00180C28, 0x00301A07, 

    0x00032515, 0x002D1026, 0x001C051A, 0x00282E01, 0x00172110,         // 21
    0x0003122B, 0x002F1D05, 0x0007292D, 0x00132208, 0x00240A14,
    0x00190F2D, 0x002D0818, 0x001E2D01, 0x00170B29, 0x00221505,
    0x000E201A, 0x002F0E23, 0x0027061E, 0x00172104, 0x001C0F16,
    0x00210212, 0x00092D2C, 0x000E161D, 

    0x00280331, 0x00073011, 0x00231F09, 0x000B162E, 0x00110B1E,         // 22
    0x0025250D, 0x000C1727, 0x00280D16, 0x001B0324, 0x00302B03,
    0x00012123, 0x0015270A, 0x00091220, 0x00311A0F, 0x00120624,
    0x00072E15, 0x001D1B0B, 0x0004142B, 0x00122F0F, 0x00320A30,
    0x0000271A, 0x002C110B, 0x001A2000 
};

#elif (HALFTONE_SIZE == 91)

const DWORD HT_SuperCell_Packed[91*91] = {
    0x00112005, 0x00262810, 0x001C081C, 0x00012422, 0x00242C0D,         //  0
    0x001E1704, 0x000F1E14, 0x001C0E32, 0x0012210A, 0x00180323,
    0x00312F07, 0x0010182C, 0x001F2B01, 0x002C0120, 0x00262D05,
    0x00130B26, 0x0032051E, 0x00021F16, 0x0027230B, 0x002D3201,
    0x000F112A, 0x00192107, 0x002D140D, 0x00092D1D, 0x000F1D15,
    0x00190F21, 0x00142103, 0x0006192E, 0x001B2610, 0x0003142C,
    0x00271C02, 0x001E0531, 0x00021A1A, 0x00250B13, 0x00071721,
    0x00131F0D, 0x00270E2C, 0x002D0312, 0x000D2522, 0x00251B0A,
    0x0031021C, 0x001E1D0F, 0x0001231A, 0x00142901, 0x00300113,
    0x00043129, 0x00280717, 0x00111A2F, 0x00031413, 0x000B2622,
    0x00282009, 0x00052E15, 0x00140330, 0x00092024, 0x0024150D,
    0x00022B32, 0x002C0A1B, 0x001E0421, 0x00262F0B, 0x002E2304,
    0x000B2C15, 0x001D062C, 0x00261D04, 0x00093011, 0x001E041E,
    0x00282B08, 0x00160920, 0x00310E18, 0x00102013, 0x00061821,
    0x000A2B2D, 0x00160416, 0x00232C04, 0x00032418, 0x001C180D,
    0x000D2D29, 0x00021515, 0x00301A08, 0x00062A19, 0x001C1014,
    0x002E1804, 0x002A0B12, 0x00051E1C, 0x00170125, 0x000C2F2B,
    0x001F120A, 0x0008272F, 0x002F031E, 0x00221E06, 0x00170831,
    0x001F320E, 

    0x00150A19, 0x0004192F, 0x00222F02, 0x000C1428, 0x00130B19,         //  1
    0x0029072C, 0x0006251E, 0x00222B01, 0x00270B28, 0x00052412,
    0x0029071D, 0x00011E18, 0x00150927, 0x001B110B, 0x000C1D1C,
    0x0019240E, 0x00202F03, 0x00101422, 0x00150932, 0x001D0114,
    0x00062C19, 0x0025062F, 0x001E1903, 0x00042627, 0x00320C11,
    0x00290632, 0x0021290A, 0x00110926, 0x00292F06, 0x00220720,
    0x000F2A15, 0x0009201E, 0x002A2B0B, 0x0010112C, 0x00192E06,
    0x001F0817, 0x0000231E, 0x001B1803, 0x00083030, 0x00130716,
    0x00052D2B, 0x00101126, 0x002D160C, 0x001B0F2C, 0x00081C1C,
    0x00251504, 0x000A2720, 0x002E2C07, 0x00200D1D, 0x0018072C,
    0x00301603, 0x000F1A27, 0x00200E1A, 0x00293009, 0x001C081F,
    0x000B2613, 0x00181A03, 0x00052128, 0x00111111, 0x00190D31,
    0x00061B25, 0x00291509, 0x0002241B, 0x00190E2D, 0x002C180D,
    0x00071330, 0x00211B00, 0x00033228, 0x00272609, 0x00180A1B,
    0x002E1202, 0x001D250C, 0x000C152B, 0x00310C23, 0x00110131,
    0x00252006, 0x0016081D, 0x00280C24, 0x000C1E31, 0x0023071F,
    0x0004272A, 0x000B3218, 0x001D0E30, 0x00312106, 0x00031915,
    0x0025091B, 0x00182D11, 0x00110D29, 0x00031522, 0x000B2A16,
    0x00300F24, 

    0x0029240A, 0x000E111F, 0x002C0215, 0x0017200A, 0x002F1A05,         //  2
    0x000A3126, 0x0019130F, 0x002C0419, 0x000B161F, 0x001E1B05,
    0x000E2930, 0x00221308, 0x002B2310, 0x0007282C, 0x002F0717,
    0x0003172F, 0x002A0329, 0x00251B07, 0x00042711, 0x00301027,
    0x000D1D1F, 0x002B0A11, 0x00102B1B, 0x0016022D, 0x001C2206,
    0x000D3119, 0x00021C1F, 0x0030150F, 0x00150E1B, 0x00082312,
    0x001A0C2B, 0x00321308, 0x00140128, 0x0021260F, 0x002D051D,
    0x000D1331, 0x00312C0C, 0x00161028, 0x002A2008, 0x001F0F11,
    0x002B0B1F, 0x00242507, 0x000B2B15, 0x00270520, 0x00172D0B,
    0x001F0930, 0x000F1E11, 0x001A0225, 0x00132210, 0x0025310C,
    0x0001291B, 0x00160512, 0x002D2606, 0x00041D2A, 0x00120219,
    0x00250F25, 0x002A2E0A, 0x000A142E, 0x0031280D, 0x00240418,
    0x000E311D, 0x002F0B12, 0x00112A24, 0x00240117, 0x00132E06,
    0x000C2523, 0x002B031C, 0x001B1110, 0x000B162E, 0x00210124,
    0x00112F10, 0x00041D27, 0x0029051A, 0x00183111, 0x0021290A,
    0x002C0F17, 0x0008262D, 0x001F2F02, 0x00121211, 0x0019220B,
    0x00280223, 0x00141B01, 0x0025130D, 0x000F2B1E, 0x001C0524,
    0x002E2303, 0x00061326, 0x002B1C0E, 0x00272501, 0x001D0013,
    0x00061C2C, 

    0x00190728, 0x00212B0F, 0x0007272B, 0x001E0D21, 0x00032531,         //  3
    0x00260116, 0x00122108, 0x00001C2D, 0x00152F0C, 0x002F102A,
    0x00180214, 0x00093125, 0x00120C20, 0x00271A04, 0x001F300D,
    0x000A121F, 0x000F2613, 0x00180D1A, 0x00092D2C, 0x0022170C,
    0x00172904, 0x00022225, 0x00230F14, 0x002C1B0B, 0x00051423,
    0x00261013, 0x0017002B, 0x001E2700, 0x000D1F30, 0x002C0327,
    0x0024190E, 0x00053122, 0x001C1C01, 0x000A2116, 0x00031824,
    0x00242804, 0x00061C13, 0x00220021, 0x000E1617, 0x00022925,
    0x00151E02, 0x001A0232, 0x00051A24, 0x00122105, 0x002C0C27,
    0x00002415, 0x0032111A, 0x0005192B, 0x00291204, 0x00071B32,
    0x001D0F26, 0x00230A20, 0x0008142F, 0x001A2B10, 0x00301805,
    0x000E232C, 0x001F0917, 0x0014001F, 0x001B1F01, 0x00021723,
    0x001F2207, 0x0016072F, 0x001E1F03, 0x0004122A, 0x00321C0F,
    0x00170C19, 0x00062A2C, 0x00121F0A, 0x002F2D05, 0x00002317,
    0x002B0E31, 0x00241806, 0x00082121, 0x00141100, 0x00011C1F,
    0x000F1628, 0x001A0313, 0x002D1B0D, 0x00022A2C, 0x00321606,
    0x000E2E1B, 0x00200A28, 0x00012513, 0x00290D2C, 0x00131D08,
    0x000A2A31, 0x001A0419, 0x00203009, 0x00150C2E, 0x000E171D,
    0x00232E05, 

    0x00002122, 0x00121B00, 0x0031051A, 0x000F1812, 0x00232C0C,         //  4
    0x001A0A1D, 0x00320F24, 0x00202A05, 0x00280622, 0x00062518,
    0x00251F02, 0x002E150E, 0x001B051B, 0x00022131, 0x00160024,
    0x00242B00, 0x002D1E0B, 0x001D0722, 0x002B2103, 0x0012041D,
    0x00280C30, 0x001B1508, 0x0009302B, 0x0013081E, 0x00202C02,
    0x000A2428, 0x002D180B, 0x00072D21, 0x00271108, 0x00012B18,
    0x00172504, 0x00111030, 0x002B071A, 0x00260B2C, 0x00172F09,
    0x00120E29, 0x002B091A, 0x00092F2E, 0x001D2306, 0x0030072B,
    0x0008301B, 0x0022120D, 0x00310919, 0x001D3210, 0x000C132B,
    0x00222A01, 0x00140522, 0x001E2F08, 0x000B251F, 0x002D0417,
    0x0011210A, 0x002A2E01, 0x000C2416, 0x00241023, 0x0015120D,
    0x00013221, 0x00081D12, 0x002D2A08, 0x00260E26, 0x000C2E2C,
    0x002B1110, 0x00072B21, 0x0027170C, 0x000E281E, 0x001B0527,
    0x00202302, 0x00290815, 0x00240F25, 0x001E0620, 0x00151B0E,
    0x0019071D, 0x000E2A13, 0x001C082C, 0x002D250D, 0x0027062F,
    0x001E2E08, 0x0007221C, 0x00260922, 0x00150E27, 0x001D0513,
    0x0005202E, 0x002C1A0A, 0x00190621, 0x00082F19, 0x0023160C,
    0x002B0A13, 0x000F1820, 0x0001212A, 0x00320617, 0x00082724,
    0x002D130D, 

    0x00260219, 0x001C1409, 0x000A302F, 0x00281026, 0x00141E03,         //  5
    0x0005162B, 0x00092713, 0x000F1830, 0x001C0D12, 0x0013091D,
    0x000C192E, 0x00052C28, 0x00232506, 0x00101812, 0x00300F19,
    0x00120A28, 0x00061630, 0x000E3115, 0x00001226, 0x001F1C0F,
    0x00072E17, 0x002F0121, 0x00241E0F, 0x000E2719, 0x00310431,
    0x001A1F0E, 0x00110B1B, 0x0022052D, 0x00131D10, 0x001C0C24,
    0x002F061D, 0x00202009, 0x00082C12, 0x000E161F, 0x0030240E,
    0x00200422, 0x001A1F03, 0x0014130C, 0x00260B1D, 0x00101B13,
    0x0028150A, 0x000D2721, 0x00021F2E, 0x00151709, 0x0029001E,
    0x00061A13, 0x002B210C, 0x00170D2F, 0x00230813, 0x000E2C24,
    0x001B180F, 0x0014012D, 0x00031B1D, 0x002B0629, 0x001E2103,
    0x002E0531, 0x00220C1C, 0x0010152B, 0x00052513, 0x0018061A,
    0x00221C05, 0x00130217, 0x002F0E2C, 0x00093114, 0x002A1A08,
    0x00021431, 0x000F301C, 0x000B1711, 0x0005292F, 0x00282601,
    0x0009142B, 0x00322E08, 0x00220F18, 0x00061726, 0x000C2B15,
    0x00300B24, 0x00141303, 0x000C3017, 0x002A1905, 0x0008261F,
    0x00230C18, 0x00132906, 0x000C1530, 0x00312204, 0x001D032A,
    0x00041F26, 0x0021290E, 0x00261205, 0x00122C10, 0x001E1A07,
    0x00150D32, 

    0x000E2225, 0x002A2810, 0x0017081E, 0x00022415, 0x002D0622,         //  6
    0x001F2F0A, 0x002B0319, 0x00252000, 0x00023126, 0x00302907,
    0x001F120C, 0x00170622, 0x00290D15, 0x00092E2A, 0x001E1E09,
    0x0018270F, 0x0029041D, 0x00212408, 0x0031092E, 0x00182706,
    0x000C182A, 0x00152401, 0x00041128, 0x00291707, 0x00160E15,
    0x00013025, 0x002A1304, 0x00052417, 0x002D310A, 0x000A162E,
    0x000F2815, 0x00031A2A, 0x002A0226, 0x001B1E02, 0x00011232,
    0x000D2715, 0x0006192B, 0x002F2B10, 0x00032527, 0x001B0330,
    0x00162C00, 0x001F0526, 0x002E0D16, 0x00252403, 0x00092D2D,
    0x001C0B25, 0x000E2819, 0x00051528, 0x002F1D02, 0x0001281C,
    0x00260E28, 0x00311305, 0x0019300B, 0x000F2513, 0x00091719,
    0x001A2808, 0x00131A0F, 0x00282F02, 0x001D0A20, 0x0030190A,
    0x000E2D32, 0x00002625, 0x001C1F00, 0x0021041B, 0x00110C22,
    0x0015270F, 0x00301D05, 0x001A0029, 0x002D1F0A, 0x00110A1A,
    0x00200322, 0x00021C28, 0x0017270C, 0x0012011D, 0x001A1F07,
    0x00231A10, 0x00052829, 0x00210230, 0x001A1F0A, 0x0010132B,
    0x002F310E, 0x001C0124, 0x00271012, 0x00062B1E, 0x00160F15,
    0x00113100, 0x002F0C1D, 0x0018012E, 0x00051E27, 0x0029091F,
    0x00093114, 

    0x00301107, 0x00061D2D, 0x001E170D, 0x00252C05, 0x000D122E,         //  7
    0x00122210, 0x00180B27, 0x000B1320, 0x001A1C0E, 0x0027012A,
    0x000F231A, 0x002D1D04, 0x0001282E, 0x0021021B, 0x000D1121,
    0x00252F05, 0x00031B25, 0x00111410, 0x00092C19, 0x00250F1F,
    0x002C0513, 0x00210C1C, 0x001B2A0D, 0x0008212D, 0x001F0621,
    0x00261B09, 0x000E2A1F, 0x001E0828, 0x00181A01, 0x00240121,
    0x0028120D, 0x00182E04, 0x00220E19, 0x00142A0C, 0x002C0A1D,
    0x00253208, 0x00290218, 0x00110E23, 0x00231505, 0x00081F17,
    0x002B101F, 0x00041C12, 0x000E292A, 0x001A061C, 0x00131110,
    0x00301D06, 0x00270320, 0x001F300B, 0x00131210, 0x001D0531,
    0x000C1F13, 0x00072A1A, 0x001F0C22, 0x0027082F, 0x00032D27,
    0x0029011E, 0x000B1225, 0x00021F2F, 0x00150417, 0x00082328,
    0x0024130D, 0x002B091D, 0x00171110, 0x0004252E, 0x002C2E0B,
    0x001D0728, 0x0026101F, 0x00032B16, 0x00140D24, 0x001D2F10,
    0x00291605, 0x00102114, 0x00250C30, 0x002D3202, 0x0003112D,
    0x002A0620, 0x0017220B, 0x002E0F1D, 0x00022C12, 0x00250726,
    0x00161D01, 0x0003181A, 0x000F2429, 0x00221B08, 0x002C0822,
    0x000A2431, 0x001C180D, 0x000D2719, 0x002D1302, 0x0017230B,
    0x00220629, 

    0x001A2D03, 0x00110321, 0x002E0E17, 0x00081F28, 0x001B001A,         //  8
    0x002F1B04, 0x00062E2F, 0x002A2609, 0x00140917, 0x00051732,
    0x000A2D14, 0x001D0B1F, 0x0012150F, 0x00321A02, 0x00062331,
    0x002A0B17, 0x0016072C, 0x002D2001, 0x001D0228, 0x00131D0B,
    0x00023131, 0x000E1A24, 0x00300817, 0x00122E05, 0x002D1113,
    0x000A232A, 0x00150312, 0x00300F32, 0x0008211A, 0x00122C10,
    0x0005242C, 0x0031091E, 0x000A182F, 0x00102011, 0x001D0629,
    0x00091B21, 0x00182201, 0x001F082E, 0x000C2F1C, 0x002E280E,
    0x00130A2C, 0x001C3105, 0x0027140C, 0x00061922, 0x00222F0A,
    0x0001262F, 0x00170916, 0x00091A2B, 0x002C2506, 0x00280A1F,
    0x00182309, 0x0024042C, 0x00121C10, 0x002F1404, 0x00151E09,
    0x001C0D14, 0x0032240D, 0x00232B06, 0x002C0F22, 0x001F3003,
    0x00130115, 0x000A2923, 0x00271B07, 0x000D1729, 0x00232003,
    0x000E1319, 0x00082213, 0x0020042D, 0x002B2403, 0x000E1C32,
    0x0004111D, 0x00302C0B, 0x001B0818, 0x00081624, 0x001F2510,
    0x000B2D19, 0x00110A2B, 0x001F1802, 0x000E2416, 0x002B0D20,
    0x000A2A32, 0x001F0B14, 0x00302D0B, 0x0019032D, 0x00011319,
    0x00291D07, 0x00240514, 0x00032E22, 0x001F102D, 0x000F2A15,
    0x0004191B, 

    0x00211510, 0x0001252A, 0x00233109, 0x00150A1F, 0x00282A0B,         //  9
    0x00021723, 0x00230E14, 0x001C041D, 0x00312A03, 0x00201023,
    0x00292106, 0x00160428, 0x0026320A, 0x00190723, 0x00102A13,
    0x001B170B, 0x000B2C1E, 0x00230E15, 0x00072623, 0x00291507,
    0x001A2810, 0x00241203, 0x000A1E27, 0x0028011E, 0x00032830,
    0x001D1504, 0x00231D0C, 0x00022F16, 0x002A1407, 0x00210B26,
    0x00161D06, 0x001E0415, 0x00023023, 0x002E2508, 0x00231014,
    0x0004152C, 0x00132D10, 0x0031120B, 0x00021D28, 0x00181807,
    0x00250121, 0x000A2214, 0x002C0831, 0x00101F17, 0x002E0228,
    0x001B1601, 0x000D211D, 0x00230D13, 0x00052B26, 0x00101617,
    0x00023129, 0x002D1901, 0x000B2B25, 0x00052619, 0x00210921,
    0x000D312D, 0x00061629, 0x0018071D, 0x000F1C12, 0x0003172A,
    0x002F2009, 0x001C0C2F, 0x0006311A, 0x00310F12, 0x00180120,
    0x00012930, 0x002E180E, 0x0016320A, 0x000A1521, 0x00260615,
    0x00082827, 0x0015022C, 0x000D2420, 0x00271A09, 0x00130329,
    0x00301D06, 0x0025130F, 0x00083122, 0x0019032E, 0x00221206,
    0x0014200F, 0x0029051D, 0x00071426, 0x00132104, 0x001F280F,
    0x000D2C24, 0x00150B2B, 0x00311604, 0x00081F11, 0x00270220,
    0x002C0B30, 

    0x000C2124, 0x0018061A, 0x002B1B01, 0x000B1431, 0x00102212,         // 10
    0x0020072B, 0x000A2511, 0x000F1C27, 0x0008152D, 0x00132F0B,
    0x00031B12, 0x002F0F2D, 0x0009261D, 0x00031D2A, 0x002B0D19,
    0x00200126, 0x00302304, 0x00011A2F, 0x000F2E12, 0x0031092A,
    0x0016031B, 0x0005222D, 0x001F2F09, 0x0014160E, 0x00190C19,
    0x00102D21, 0x00290925, 0x000F261D, 0x001B052B, 0x000B1820,
    0x0026290C, 0x000F112D, 0x00291500, 0x0019001C, 0x000D2C25,
    0x00281F05, 0x001D0419, 0x000F2424, 0x002A0713, 0x001F0D30,
    0x000D261A, 0x00011326, 0x001F2C03, 0x00140C1D, 0x000A2A12,
    0x00260F25, 0x002B310C, 0x00120730, 0x00321F03, 0x001C0021,
    0x0022110E, 0x0014071D, 0x00200F15, 0x00190232, 0x002C210E,
    0x00251B00, 0x00130318, 0x001E2708, 0x002A0A31, 0x000B2B17,
    0x0016061F, 0x00251501, 0x00102326, 0x00140617, 0x00202C06,
    0x00290B24, 0x00121D01, 0x001C0E27, 0x0031091A, 0x00232E08,
    0x00191805, 0x00201F0F, 0x002E1200, 0x00022E15, 0x001D0D1D,
    0x00062A31, 0x00160725, 0x00282608, 0x00051B1B, 0x00322E0D,
    0x0000172C, 0x001B2603, 0x000D3121, 0x00260A13, 0x002E0E2F,
    0x0007181E, 0x0022220B, 0x0018041C, 0x00103226, 0x001B1B06,
    0x0013270A, 

    0x0031120E, 0x00270C2D, 0x00082814, 0x001D0322, 0x00322C07,         // 11
    0x0017111C, 0x002C3101, 0x00250B19, 0x00192310, 0x002C0221,
    0x0021081A, 0x000E2C16, 0x001E1700, 0x00241210, 0x00152007,
    0x0006302C, 0x00121310, 0x00190521, 0x00260C18, 0x001F1702,
    0x000C251F, 0x00280F14, 0x002F0622, 0x00091B2B, 0x00262200,
    0x00320314, 0x0006192D, 0x00181202, 0x002F220A, 0x00042E13,
    0x002C0729, 0x0009231A, 0x00222A0F, 0x00061D31, 0x00150E11,
    0x002C0A1F, 0x0009292F, 0x00231707, 0x0006301F, 0x00141F01,
    0x00282A0F, 0x00321A09, 0x0019042A, 0x0025230D, 0x00031B2E,
    0x00170519, 0x00062621, 0x001E1308, 0x0016190F, 0x000A2D2D,
    0x002A2606, 0x00071E2B, 0x00312E0B, 0x00111805, 0x000B2927,
    0x0000111F, 0x002F2D10, 0x00081424, 0x00261F0C, 0x001A1027,
    0x002C250E, 0x00022D14, 0x001E092B, 0x002A1F0B, 0x0005132D,
    0x000C241B, 0x00250314, 0x00062A2B, 0x000F2012, 0x0000252F,
    0x00130F25, 0x00290B18, 0x000B2830, 0x00190424, 0x002B220E,
    0x00221603, 0x000F1F16, 0x002E0E13, 0x001E0828, 0x000C221F,
    0x00120216, 0x002D1029, 0x00231D09, 0x0003191B, 0x001A0028,
    0x00122F02, 0x002A1210, 0x00002930, 0x002E0F13, 0x00240928,
    0x00032C18, 

    0x001E1E05, 0x0005181D, 0x00122E0C, 0x00220E28, 0x00031E17,         // 12
    0x0007182E, 0x001C0122, 0x0013280B, 0x00001129, 0x00271D07,
    0x0006252F, 0x001A0C23, 0x0012210C, 0x002E0330, 0x000B2821,
    0x0028091C, 0x001D1C08, 0x002C280C, 0x00082128, 0x0013320A,
    0x00021A2F, 0x001A2B04, 0x00110A1A, 0x001D2710, 0x00001126,
    0x00212B08, 0x000B201B, 0x001F320F, 0x00120131, 0x00230E18,
    0x00161E05, 0x001C0C22, 0x00131A09, 0x00300827, 0x001F3103,
    0x00002215, 0x001B1A0A, 0x00160C27, 0x002D0216, 0x000A142C,
    0x001B0623, 0x00110F15, 0x00093120, 0x002A1104, 0x00201710,
    0x00302C07, 0x000C1D2C, 0x00240317, 0x00002324, 0x00270B19,
    0x000E1713, 0x001A091F, 0x00022226, 0x00271311, 0x001C061B,
    0x00290B2E, 0x00172006, 0x001F082B, 0x00113202, 0x0007191B,
    0x0021022F, 0x000D111E, 0x002E1704, 0x000A2820, 0x001B1B0F,
    0x002F3008, 0x001F1023, 0x00171605, 0x002C061F, 0x001E1B0C,
    0x002F011C, 0x000F3012, 0x00061D1F, 0x0026140A, 0x00110A2B,
    0x0003301B, 0x001B0021, 0x00092D2D, 0x00151500, 0x0027290B,
    0x00200B24, 0x00062C11, 0x0017072E, 0x00312A0C, 0x000E2517,
    0x00271F08, 0x001C0723, 0x000B1A19, 0x001F2500, 0x0008161E,
    0x0016052F, 

    0x000E2625, 0x0024012A, 0x002E2403, 0x0015081F, 0x0026140F,         // 13
    0x002B2905, 0x000C2014, 0x00300830, 0x001F1903, 0x000B2D1F,
    0x0016140E, 0x00312904, 0x00270827, 0x00012F17, 0x00181903,
    0x00220E15, 0x000D2D24, 0x00031532, 0x0020101B, 0x002E0214,
    0x00230B24, 0x0029140F, 0x00061E2D, 0x002D3006, 0x0017051F,
    0x000F1630, 0x002C0813, 0x00260C28, 0x00011A24, 0x000D261E,
    0x002E130E, 0x00022D2D, 0x0029021C, 0x00072616, 0x000D1521,
    0x0024032C, 0x0031101A, 0x00102E11, 0x00252505, 0x0002211C,
    0x00202C0C, 0x002B092F, 0x00041F18, 0x000D262B, 0x00120725,
    0x001A0C1F, 0x00281500, 0x00102F12, 0x002E0F2A, 0x00202909,
    0x00150431, 0x002C3202, 0x001F0D18, 0x00091C2F, 0x00143007,
    0x0021240C, 0x000E1715, 0x00052819, 0x00300422, 0x00242210,
    0x00132A06, 0x00191C0C, 0x00042F25, 0x00240316, 0x00150F28,
    0x00110732, 0x00021A17, 0x00282E0E, 0x0009272D, 0x00191302,
    0x00042A29, 0x00221706, 0x001D062D, 0x00142B04, 0x00312510,
    0x000C1A26, 0x002A1206, 0x0025230F, 0x00021C1A, 0x00191031,
    0x002C1E07, 0x0011161D, 0x001E2202, 0x000B1321, 0x00210532,
    0x0004151E, 0x00150D2A, 0x002C2D0D, 0x0011012C, 0x00272110,
    0x002C3008, 

    0x001C0B15, 0x00181112, 0x00011B1A, 0x000D3131, 0x001A2109,         // 14
    0x0011052A, 0x00221024, 0x00052F1A, 0x000F2412, 0x002C0F27,
    0x00230515, 0x00091A2C, 0x00101E11, 0x0021101E, 0x0007242E,
    0x00310428, 0x00141F05, 0x002A0712, 0x00172507, 0x00101C2B,
    0x000A291E, 0x0016230A, 0x0020001C, 0x000C1829, 0x00270D16,
    0x001A250B, 0x00071E1D, 0x00142906, 0x002B150C, 0x00192E01,
    0x001F0426, 0x000C2413, 0x00231704, 0x001A0F2F, 0x00282C07,
    0x0013200D, 0x00052829, 0x000B1C22, 0x001D0832, 0x002F1109,
    0x000E1A28, 0x00182702, 0x0024160F, 0x001D031C, 0x002C2E0B,
    0x00022115, 0x00092832, 0x00140A20, 0x001A2004, 0x0004151C,
    0x00081E27, 0x0024250D, 0x00120121, 0x002F2B0F, 0x00031124,
    0x002C0229, 0x000A1D1F, 0x00280C31, 0x0018110A, 0x00011526,
    0x002C0B2A, 0x00270718, 0x00111F2D, 0x00320C11, 0x00202701,
    0x000B2B1D, 0x002D2007, 0x00140226, 0x00210C19, 0x000C1F22,
    0x00280A16, 0x0015240D, 0x002C1024, 0x00011F1A, 0x00210D16,
    0x00170630, 0x001F290B, 0x00120B2A, 0x00300422, 0x000D3112,
    0x0007252A, 0x00250118, 0x00022F25, 0x002A0D14, 0x0013200E,
    0x002F2E05, 0x00082715, 0x00241D09, 0x00190B24, 0x0002111A,
    0x000B1921, 

    0x00302D01, 0x0009272C, 0x00271508, 0x002D0424, 0x00200D13,         // 15
    0x00022C1E, 0x002A1D02, 0x0019160C, 0x0027022D, 0x00120A1C,
    0x001A250A, 0x00053121, 0x001E001A, 0x002C1508, 0x00122C10,
    0x001B130C, 0x000A2A1C, 0x00260D2D, 0x00063021, 0x001D1601,
    0x00320912, 0x00042E31, 0x002B1203, 0x0014290E, 0x00041D23,
    0x00312D02, 0x0022022C, 0x001D1121, 0x00092215, 0x0024092F,
    0x00051F18, 0x00310B29, 0x0015300C, 0x000F1E23, 0x002F0612,
    0x00180C1E, 0x00201400, 0x002B0417, 0x0014180F, 0x0007321F,
    0x00280013, 0x00130D24, 0x00302D08, 0x0006132D, 0x00151C06,
    0x00221128, 0x0031011A, 0x001F1B0D, 0x00290529, 0x000D2E12,
    0x00300C16, 0x00181907, 0x000C142C, 0x00252005, 0x001D091C,
    0x00182601, 0x0023140D, 0x00122F11, 0x001D2A05, 0x000E1E16,
    0x0009261F, 0x001E2D03, 0x0007141C, 0x001A230A, 0x00031822,
    0x00270A2A, 0x001C140C, 0x0005242F, 0x00261210, 0x0012310A,
    0x00310531, 0x00072C1D, 0x000D1813, 0x0028022B, 0x00093222,
    0x002E1601, 0x00041E14, 0x000B2C1D, 0x00201804, 0x00280717,
    0x001B0F11, 0x002E1905, 0x0015092D, 0x001C2908, 0x00061B2B,
    0x00260B26, 0x001E031C, 0x000F172F, 0x00322303, 0x00142B0E,
    0x00220430, 

    0x00041F1B, 0x00130720, 0x001E1D0E, 0x000C2A18, 0x0007232D,         // 16
    0x0030140E, 0x00150628, 0x00092718, 0x001E2007, 0x00012E24,
    0x002D1801, 0x00250D31, 0x00162106, 0x0003272A, 0x00280720,
    0x00231B01, 0x00022226, 0x001F0116, 0x002D120D, 0x000D2029,
    0x00250418, 0x001B0E25, 0x000F2015, 0x0024092D, 0x001D0619,
    0x000B1326, 0x00121910, 0x00033019, 0x002F0529, 0x00160F11,
    0x00102B1F, 0x00271906, 0x00091215, 0x0021092A, 0x0004291A,
    0x000A1C30, 0x0025300A, 0x0001242D, 0x00192904, 0x00230B2B,
    0x000C2319, 0x00001E30, 0x0021061E, 0x000F2516, 0x00280823,
    0x000B2A12, 0x00181605, 0x00073022, 0x00112408, 0x00231030,
    0x001C0624, 0x00012A1A, 0x00290B28, 0x00062814, 0x0010192E,
    0x00082D18, 0x00320527, 0x0003222C, 0x002A091B, 0x0023002F,
    0x0030190B, 0x00151013, 0x002B0431, 0x000D3227, 0x002C0114,
    0x00171E04, 0x000E2E1B, 0x002F0515, 0x001A2800, 0x00021624,
    0x001F1C05, 0x001A0F28, 0x0024210A, 0x00122905, 0x001D110F,
    0x000F241F, 0x001A022D, 0x002C1026, 0x0015240C, 0x00011D2F,
    0x00102B27, 0x0009271E, 0x00221F0F, 0x000D1220, 0x002C061A,
    0x00182501, 0x000B1312, 0x00033022, 0x00210618, 0x00081B28,
    0x0029130B, 

    0x00180E2A, 0x00233005, 0x002B0A28, 0x00161302, 0x001B021C,         // 17
    0x00241B06, 0x000E321F, 0x00210B32, 0x0032120F, 0x000C1C16,
    0x00141028, 0x000E2B12, 0x00300917, 0x000B1D24, 0x00180E14,
    0x000E3230, 0x00300A12, 0x0011181F, 0x00152809, 0x00012D22,
    0x00181A06, 0x0008261D, 0x002C1708, 0x00023120, 0x002E2205,
    0x00162A0C, 0x002A0A32, 0x00261E03, 0x001A2708, 0x000A1424,
    0x002C1D0D, 0x001C0231, 0x00012720, 0x002D2002, 0x001B150E,
    0x002A0124, 0x00121015, 0x002D0926, 0x000F1F1B, 0x00321208,
    0x001D170D, 0x002A2B01, 0x00180F12, 0x00081A29, 0x001B3103,
    0x002C0D2F, 0x00012016, 0x0026072C, 0x002D130F, 0x00052B1E,
    0x00142201, 0x002E1C10, 0x001E300A, 0x0016041F, 0x002D1012,
    0x00201F08, 0x00140D20, 0x001B1603, 0x000A1C24, 0x00122E07,
    0x00190D29, 0x00022423, 0x00242A0D, 0x00141A05, 0x00210E18,
    0x0009292E, 0x00230823, 0x00071B29, 0x002A0D1F, 0x000B212D,
    0x002C001A, 0x00062E12, 0x00160720, 0x00300C30, 0x00021C29,
    0x002A2E07, 0x00250912, 0x00091519, 0x00232F08, 0x001C0D20,
    0x002B0914, 0x00171401, 0x00310331, 0x00033116, 0x0021180C,
    0x00102C30, 0x00291F09, 0x00170F2A, 0x002C2906, 0x001B0A1F,
    0x000D2513, 

    0x002F0016, 0x00072324, 0x00111912, 0x00002730, 0x00292E0B,         // 18
    0x00120A2A, 0x00032413, 0x00291705, 0x00062B22, 0x001B022E,
    0x002A280B, 0x0020061F, 0x0006172D, 0x001D2E03, 0x002B031B,
    0x00201508, 0x0005262B, 0x001A1E04, 0x0022092E, 0x00270513,
    0x002E102B, 0x00112B0D, 0x0020042F, 0x001A0C13, 0x00091A2B,
    0x0021031F, 0x00062614, 0x000D161C, 0x001F082D, 0x00022F17,
    0x00222403, 0x0017101A, 0x0012320A, 0x0026052D, 0x000D2D18,
    0x00162205, 0x001E2A0C, 0x00061A1F, 0x00220212, 0x000B2F27,
    0x00150521, 0x0007252C, 0x00250A19, 0x0030210A, 0x00130320,
    0x0023180C, 0x000F271B, 0x00150B26, 0x001D1E06, 0x000C1818,
    0x00270028, 0x00091321, 0x0011082F, 0x00241802, 0x00042423,
    0x00280132, 0x000C3115, 0x0026270C, 0x002D1111, 0x0004221E,
    0x00200617, 0x00291F00, 0x000B151B, 0x001C072C, 0x0001211F,
    0x0031160B, 0x00111111, 0x001E230E, 0x00143008, 0x00180A16,
    0x00232A0C, 0x0010132B, 0x00281A01, 0x000A2616, 0x0021031B,
    0x0015170D, 0x00102122, 0x00052831, 0x00321B03, 0x00120029,
    0x0004221A, 0x00242D0B, 0x000B1C25, 0x001D2306, 0x00120C23,
    0x002F0128, 0x00071A1C, 0x00240816, 0x0012200E, 0x00011632,
    0x00262B08, 

    0x000E1C2E, 0x001C140B, 0x00210519, 0x00310C1F, 0x00081F23,         // 19
    0x001D1117, 0x002E0426, 0x00181E0B, 0x0013081D, 0x00232202,
    0x0002151A, 0x00191E07, 0x00282611, 0x0014120E, 0x00002227,
    0x000D2B21, 0x00260417, 0x002B130E, 0x000D3025, 0x0006221A,
    0x001E1502, 0x000A1E1C, 0x00260F27, 0x00142D04, 0x000E141A,
    0x002B2007, 0x00181025, 0x00322D0B, 0x00130120, 0x002E0D12,
    0x000E1726, 0x0029072B, 0x000A1C14, 0x001F0D26, 0x0005191E,
    0x00300B2F, 0x00091428, 0x00272102, 0x00190E30, 0x00022717,
    0x002C1C0F, 0x00201106, 0x00102E25, 0x00021531, 0x001F290F,
    0x0006112A, 0x002F2D01, 0x00210220, 0x00032613, 0x00320D2E,
    0x001A2D05, 0x0021260B, 0x0005201C, 0x00302E0F, 0x000D1128,
    0x00192A05, 0x00011A1D, 0x001E0C26, 0x0013032D, 0x00252C09,
    0x000E1330, 0x00073013, 0x002E0C24, 0x00102711, 0x002A2F07,
    0x00190328, 0x00252B05, 0x00031831, 0x0029041D, 0x000D1526,
    0x00301E06, 0x0000241D, 0x001F0924, 0x00192F09, 0x000D1226,
    0x002E2B03, 0x001C0F2B, 0x00210513, 0x000C131D, 0x00282A0E,
    0x001F102E, 0x00071613, 0x0029062A, 0x00150F1A, 0x00262A0E,
    0x00001514, 0x001C2F03, 0x000E262C, 0x0030031D, 0x00203200,
    0x00151021, 

    0x00032A11, 0x002D2402, 0x000A302C, 0x001A1C07, 0x00152C0D,         // 20
    0x00261701, 0x000D282D, 0x00083019, 0x00270E2A, 0x000F2D12,
    0x00300C2C, 0x00083126, 0x00110120, 0x00220A31, 0x002E1D05,
    0x001C170C, 0x00130E29, 0x0008281E, 0x00171B09, 0x00300B32,
    0x00142C0F, 0x002A0223, 0x00032316, 0x0031270C, 0x00240622,
    0x00003030, 0x001E110F, 0x00051C2A, 0x00242202, 0x00082A30,
    0x001D1F08, 0x00042C1E, 0x00312504, 0x00141310, 0x00282807,
    0x001A0313, 0x000E311A, 0x002C0611, 0x00112B1D, 0x00251504,
    0x001A072D, 0x000C221C, 0x002E0114, 0x00161C03, 0x002A071D,
    0x000D2218, 0x001A1B0B, 0x00091531, 0x0028300E, 0x0016071A,
    0x000E1C29, 0x00290A15, 0x00150F2B, 0x001B1B07, 0x0022061A,
    0x002B1510, 0x0011082C, 0x002F2101, 0x0006281A, 0x001A1A0E,
    0x00310A25, 0x00181C07, 0x001F012A, 0x00261017, 0x00051C30,
    0x00150A1B, 0x00091F22, 0x002E0E18, 0x001F2602, 0x00052D2C,
    0x001C0F12, 0x00140230, 0x002E160E, 0x00072114, 0x002A0B2E,
    0x00041E1E, 0x00260817, 0x0014310A, 0x00031D26, 0x001A2506,
    0x00150922, 0x002E1B07, 0x00112F1F, 0x001B2702, 0x000B192E,
    0x002C051F, 0x0021120B, 0x00081C23, 0x001A0D12, 0x00061927,
    0x00290918, 

    0x0023022A, 0x00140F1C, 0x00280726, 0x000D1315, 0x002C0131,         // 21
    0x00022211, 0x0022081F, 0x001A1304, 0x002C1B0D, 0x001F0423,
    0x000B2316, 0x0024130A, 0x002C1B01, 0x00042C1C, 0x00170D16,
    0x0009302E, 0x00320713, 0x001E2100, 0x00230122, 0x00041217,
    0x001C2707, 0x000F182D, 0x001A0811, 0x000B1629, 0x001C1D01,
    0x00130B15, 0x00272409, 0x000E171B, 0x00180E14, 0x002B0523,
    0x0015130D, 0x00230A17, 0x00190123, 0x0008212A, 0x00222C0B,
    0x00001D2B, 0x00211123, 0x00172407, 0x00051B29, 0x00300D22,
    0x0013310D, 0x00041828, 0x00242A09, 0x001B0C23, 0x00072D2C,
    0x00260E14, 0x00140426, 0x002C2307, 0x00101122, 0x00242002,
    0x0000141F, 0x000B3211, 0x002E0224, 0x00032A30, 0x0013260C,
    0x00071E22, 0x001C2D09, 0x00221013, 0x000B1629, 0x00270420,
    0x00122A03, 0x0000221D, 0x00142C0E, 0x000A1821, 0x001B2401,
    0x002C140C, 0x000D3114, 0x001A012A, 0x0011200D, 0x00250721,
    0x000B1A1A, 0x00273203, 0x000F2729, 0x00230521, 0x00131A05,
    0x00182A0D, 0x00082428, 0x00301800, 0x00240D2D, 0x002B0319,
    0x000D2C15, 0x00022432, 0x00210311, 0x00300B16, 0x00041D24,
    0x00172305, 0x00112D31, 0x00260718, 0x002B2B07, 0x000C252E,
    0x00181F0C, 

    0x00102F20, 0x00071913, 0x001F2905, 0x00052022, 0x00200C1B,         // 22
    0x00102A27, 0x00310F13, 0x0006262F, 0x00152008, 0x0004171E,
    0x0013082E, 0x00182A0E, 0x001D0F29, 0x000E2312, 0x00290524,
    0x00242407, 0x000F1A1B, 0x00012B2D, 0x002D160D, 0x000D2F27,
    0x00270A1C, 0x00221F03, 0x00063220, 0x002B1019, 0x00102B2C,
    0x002F001E, 0x00092926, 0x002D072D, 0x001F3006, 0x00112718,
    0x00011D2B, 0x002E3101, 0x000D1831, 0x002B0E1A, 0x00110821,
    0x002F1501, 0x000A2717, 0x002A0A32, 0x001E0012, 0x000A2015,
    0x001C2705, 0x002B0A18, 0x0009122F, 0x00121F10, 0x0031260C,
    0x00221904, 0x00042E1E, 0x001E092B, 0x00072B15, 0x001B032F,
    0x002C290D, 0x00201807, 0x00102218, 0x001F1300, 0x00260D1D,
    0x00310029, 0x000D2318, 0x00150631, 0x00292F07, 0x00051F16,
    0x00200E28, 0x002B0732, 0x0024130A, 0x00300415, 0x000F2D26,
    0x0022062C, 0x00282704, 0x00011B25, 0x00321210, 0x00162A0A,
    0x002B0B27, 0x00081F16, 0x001B1208, 0x00022C1A, 0x001F1012,
    0x002E0231, 0x000D131B, 0x001E0621, 0x00112E11, 0x0006201F,
    0x001D1503, 0x00270E26, 0x00091F1B, 0x000E1329, 0x00252E0A,
    0x001E091D, 0x00320F11, 0x00022125, 0x0014150E, 0x001F061E,
    0x00301206, 

    0x00260A30, 0x001A220A, 0x0031082C, 0x0013160F, 0x002A3103,         // 23
    0x00171A09, 0x001D0621, 0x000B2F18, 0x00230029, 0x002F2C0F,
    0x00282503, 0x00011C21, 0x00310918, 0x0008172D, 0x001E290A,
    0x0005131F, 0x001A1011, 0x00280B23, 0x00142004, 0x00180614,
    0x0009242B, 0x002F130C, 0x00130331, 0x00232508, 0x00031912,
    0x00202005, 0x0016130D, 0x00031B21, 0x00230B12, 0x00071626,
    0x0027031E, 0x00121210, 0x001E2409, 0x00042E15, 0x00181B0F,
    0x001D042D, 0x00142F0C, 0x0003181C, 0x00262D08, 0x0016102E,
    0x0022041E, 0x00101D26, 0x00282D01, 0x001E021B, 0x00011420,
    0x00180B2F, 0x000C2519, 0x002F130F, 0x00281A0A, 0x00140C1C,
    0x00092526, 0x0019072D, 0x00280B21, 0x000C2C13, 0x0006182C,
    0x0017300D, 0x00241403, 0x00011C21, 0x002D0A1D, 0x0018250C,
    0x000D1912, 0x0008321B, 0x00192704, 0x00031E2E, 0x001E0D1D,
    0x00061912, 0x00160F1F, 0x001F081A, 0x000E2D2E, 0x00211601,
    0x0004241E, 0x00170632, 0x0030180F, 0x0026082B, 0x000B2326,
    0x0028300B, 0x001B1F07, 0x00002814, 0x00210F2F, 0x00171A0C,
    0x00310A2B, 0x00133209, 0x001A170E, 0x00292A00, 0x0014022C,
    0x00061814, 0x000E2928, 0x001A001B, 0x00241B03, 0x000A2D27,
    0x00042617, 

    0x002C1D01, 0x000F1223, 0x00012C18, 0x0025051F, 0x000A252E,         // 24
    0x0004122A, 0x00271F0D, 0x002B1606, 0x00110E23, 0x001C0A16,
    0x000D141B, 0x00210530, 0x00113106, 0x00251F0D, 0x00150126,
    0x002E1D02, 0x00112F2A, 0x00210318, 0x00072830, 0x002B1A09,
    0x001F0E21, 0x00012C18, 0x00171B10, 0x001B071F, 0x00290C25,
    0x000F2F2F, 0x00260519, 0x001B2C00, 0x000B2432, 0x002F200B,
    0x001A2A05, 0x00220C2E, 0x000A1E21, 0x00290927, 0x00252905,
    0x000C211E, 0x00230C26, 0x00311D03, 0x000E1320, 0x00072928,
    0x002F150B, 0x00032512, 0x00170822, 0x00261B0A, 0x000E3028,
    0x002D0712, 0x001C1F02, 0x00130023, 0x00023129, 0x00221D03,
    0x00311011, 0x00042E1A, 0x00151E04, 0x002E0425, 0x001B2008,
    0x00280A16, 0x00092627, 0x001F0E11, 0x000F2C2E, 0x001C1401,
    0x0030012B, 0x00230F23, 0x00101A11, 0x00260B19, 0x00142B06,
    0x002F210A, 0x000A2F31, 0x002C1D07, 0x00072316, 0x00130229,
    0x002D0E13, 0x001E2807, 0x000D2F21, 0x00131E01, 0x0005151E,
    0x00160B17, 0x00101724, 0x002A0929, 0x002D2305, 0x000C2C1A,
    0x00240214, 0x00072723, 0x002C062F, 0x0001221F, 0x00201118,
    0x002E250C, 0x00271D04, 0x0009302E, 0x002F0E15, 0x0013042B,
    0x001D160F, 

    0x0006311C, 0x00230229, 0x0015270C, 0x002D1A07, 0x001B0D13,         // 25
    0x00220217, 0x000F2B1D, 0x00002531, 0x00191A04, 0x00082E2B,
    0x002D2108, 0x00062923, 0x00181210, 0x002C0C1D, 0x000A2D16,
    0x001F0A2F, 0x00022613, 0x00301808, 0x000D121F, 0x001B310F,
    0x00110426, 0x00282101, 0x000C2928, 0x00311206, 0x000A2616,
    0x0005161C, 0x002E1E0F, 0x00130F2A, 0x00290115, 0x000F131C,
    0x00160728, 0x00022D17, 0x00311702, 0x0014021B, 0x00061430,
    0x002D1014, 0x00042611, 0x0019022F, 0x0013230E, 0x002A0719,
    0x00193006, 0x000C192C, 0x002D0E16, 0x00072131, 0x00152806,
    0x00221018, 0x00052C2D, 0x00261508, 0x000D281E, 0x001A0516,
    0x0010222B, 0x002A140A, 0x000A1931, 0x0022270F, 0x0002111E,
    0x00102B2F, 0x0030071B, 0x00142006, 0x00260424, 0x000A2917,
    0x0003221E, 0x00152E07, 0x002D0729, 0x00092521, 0x002A002C,
    0x000D1517, 0x00230A27, 0x00180411, 0x00291021, 0x0024310B,
    0x000B1B24, 0x0001141A, 0x0023042C, 0x002B0C15, 0x0020270A,
    0x0031002E, 0x00252C02, 0x00081C11, 0x0014051E, 0x00041426,
    0x001C1F02, 0x000F191C, 0x00220F11, 0x00181C06, 0x000B3023,
    0x00120630, 0x00160C1D, 0x001D140F, 0x00002722, 0x00292009,
    0x00170920, 

    0x00272306, 0x00091814, 0x001C1032, 0x00061F25, 0x000D2E21,         // 26
    0x00302300, 0x00160927, 0x002E1011, 0x0021031C, 0x00261E0B,
    0x00130F13, 0x001D022A, 0x00231A01, 0x0004272E, 0x000E1520,
    0x002A210A, 0x0018061C, 0x00130E29, 0x00252302, 0x00041E2E,
    0x002F0A15, 0x0021101B, 0x0006172C, 0x0025300E, 0x0016052E,
    0x001F2203, 0x00190927, 0x0001281E, 0x00203207, 0x00061723,
    0x002B220C, 0x00240E12, 0x000E252C, 0x001D310D, 0x00171F08,
    0x000F2B22, 0x001E0A19, 0x002B3208, 0x00210F2A, 0x00011A13,
    0x001D0C24, 0x0024011D, 0x00122E04, 0x0020130F, 0x002B031F,
    0x000A1726, 0x002A220D, 0x00170913, 0x002D0E32, 0x00201706,
    0x00062D24, 0x00250114, 0x001C0D1D, 0x00133106, 0x002A052A,
    0x00201702, 0x00191B0C, 0x0004302C, 0x002C1012, 0x00211A09,
    0x0029082D, 0x001D160E, 0x00051F15, 0x001F1303, 0x0019310C,
    0x00011D23, 0x001D2900, 0x0010251C, 0x0004132B, 0x001C2005,
    0x0015082E, 0x0030230D, 0x00192A04, 0x00071C28, 0x001B2D10,
    0x00031222, 0x000D2519, 0x001A0E2B, 0x001F3008, 0x00271031,
    0x002F2A0B, 0x00160B2D, 0x00062D15, 0x00310727, 0x0026160A,
    0x00032113, 0x00222C06, 0x002C0829, 0x00111802, 0x00222B11,
    0x000C112E, 

    0x00132A0B, 0x002E0B19, 0x00202F03, 0x0029071B, 0x0014130E,         // 27
    0x0005172D, 0x001F1C0A, 0x000A3115, 0x0010282E, 0x00031725,
    0x002A081F, 0x000B2F1A, 0x002F220C, 0x00150728, 0x001C0F12,
    0x00241B03, 0x00082A25, 0x00212E0C, 0x002D0016, 0x000A1622,
    0x00172D06, 0x000E2511, 0x001C0320, 0x00121E0A, 0x002A0F23,
    0x000C2D14, 0x00241308, 0x00111A0E, 0x00320B2B, 0x001B1D02,
    0x000B2930, 0x0018061A, 0x00041B24, 0x002E0B15, 0x0021052B,
    0x00291A00, 0x0008162D, 0x00110624, 0x000B291C, 0x00272102,
    0x00092C30, 0x00311E09, 0x00062729, 0x001B0A19, 0x0001252C,
    0x00141D00, 0x001E0521, 0x000B2F1A, 0x00032027, 0x0014260E,
    0x002F081F, 0x00172A01, 0x00032128, 0x00310918, 0x00091E23,
    0x000E2514, 0x00270319, 0x000C131F, 0x00072729, 0x00170C1C,
    0x00122102, 0x000C2B25, 0x002F031F, 0x000E282F, 0x0029101C,
    0x00130513, 0x00250D2D, 0x0031180B, 0x000B2B18, 0x002B0C13,
    0x00102E1E, 0x00260216, 0x000A1122, 0x000F1619, 0x00270830,
    0x00122105, 0x0023190C, 0x002F0320, 0x00012016, 0x000F1712,
    0x00092419, 0x00290122, 0x001E1E04, 0x000C282C, 0x00190E19,
    0x002B0326, 0x000F1A20, 0x00082417, 0x001A0231, 0x00051C1A,
    0x00300725, 

    0x000D1F2C, 0x0018001F, 0x00011B27, 0x00102912, 0x0023042A,         // 28
    0x002A2606, 0x001A0D1A, 0x00260522, 0x002C1202, 0x00162410,
    0x001B2B05, 0x00061232, 0x000F1715, 0x00282807, 0x00013223,
    0x00320418, 0x00101331, 0x00051F1E, 0x00150C2B, 0x001E2909,
    0x00260627, 0x00031C32, 0x002C0B17, 0x00222B04, 0x00021828,
    0x002F0118, 0x00072331, 0x00270622, 0x00082619, 0x00140314,
    0x002D1020, 0x00212F04, 0x0028140A, 0x0009241D, 0x00120F27,
    0x00012D18, 0x0024250C, 0x001C1D05, 0x002E140F, 0x00180321,
    0x00101117, 0x0016160E, 0x00290624, 0x000F1A12, 0x002F320A,
    0x00250D14, 0x00102A2F, 0x0032110B, 0x001B1B03, 0x00240C19,
    0x0009142F, 0x000E1C12, 0x0027112D, 0x001E2C0E, 0x00181409,
    0x00012F32, 0x002E0B26, 0x001C2B03, 0x001F1C0B, 0x00320216,
    0x00002F31, 0x00251110, 0x00180C19, 0x00221A07, 0x00042327,
    0x002D160D, 0x0008301F, 0x00172104, 0x0020012F, 0x00031D24,
    0x00221702, 0x00062731, 0x001F2008, 0x002E320D, 0x0016041F,
    0x002B0F14, 0x00052F28, 0x00150A2E, 0x002B2B02, 0x00180725,
    0x00240D2A, 0x0011310A, 0x0002131D, 0x0023190E, 0x00122201,
    0x00052A2F, 0x001F1308, 0x0031320D, 0x00280F23, 0x00152D05,
    0x001E160F, 

    0x002B1201, 0x0026250D, 0x000A152E, 0x00322109, 0x00170C17,         // 29
    0x000D2F24, 0x0002202F, 0x00132A0E, 0x00081D2B, 0x001F0A18,
    0x00310329, 0x00252009, 0x00190C21, 0x0020011B, 0x000A1E2C,
    0x00172409, 0x00290A13, 0x001B1905, 0x002B2510, 0x000C121C,
    0x002E190E, 0x00183202, 0x0010131E, 0x0008212E, 0x001B0D11,
    0x000F281F, 0x001D1C01, 0x00173010, 0x002B0D2E, 0x001F2C09,
    0x00031626, 0x00111F11, 0x001C002F, 0x00152A07, 0x002C1D0E,
    0x0019021F, 0x00320A13, 0x00151031, 0x00042E28, 0x001F2609,
    0x002C0A2A, 0x0002231C, 0x001A2D02, 0x001F0E31, 0x000B151E,
    0x00180328, 0x00202405, 0x0005161C, 0x0028012C, 0x00113110,
    0x001C2209, 0x002B0425, 0x0005271B, 0x00111903, 0x002D0720,
    0x00210F12, 0x00161F07, 0x00121610, 0x0025082B, 0x000E2623,
    0x001A1506, 0x002C1C0A, 0x00072A2D, 0x00140813, 0x001D2E02,
    0x000F1D32, 0x001B0B15, 0x002B0822, 0x00121210, 0x002F290C,
    0x001A0629, 0x00280F12, 0x00140A25, 0x00001A2C, 0x00222900,
    0x000D2424, 0x001E1C09, 0x000A141A, 0x0021260E, 0x00061E1E,
    0x001D1806, 0x002E2311, 0x00160532, 0x002C0B24, 0x001B2F10,
    0x0027081D, 0x000A1D16, 0x00140A2C, 0x00022213, 0x0023041E,
    0x00092729, 

    0x00033123, 0x00130514, 0x0020101B, 0x001B2C02, 0x00071A1F,         // 30
    0x002D0213, 0x001D1503, 0x002F071E, 0x00231907, 0x000E2F24,
    0x0001151D, 0x00122A0E, 0x00081C2E, 0x002B2E01, 0x0013140E,
    0x00220E2A, 0x000C2F1A, 0x00240226, 0x00022C2F, 0x00120B16,
    0x0007212A, 0x001F0123, 0x0025270B, 0x0031051A, 0x00162F06,
    0x002B082C, 0x0023150B, 0x00011225, 0x00122104, 0x000D1B1D,
    0x0025072B, 0x00092716, 0x00310E22, 0x00041729, 0x00223003,
    0x000B122C, 0x00062825, 0x000E2018, 0x0027051D, 0x00081814,
    0x00233105, 0x000C1D2D, 0x00280016, 0x00062822, 0x002E2106,
    0x00032D18, 0x002C0C25, 0x000D1E12, 0x00082822, 0x002D0829,
    0x0000191E, 0x00202D06, 0x00160F15, 0x0024032B, 0x000A2327,
    0x000F291C, 0x002A012D, 0x00042221, 0x000A3119, 0x002B0D13,
    0x0005201D, 0x00200427, 0x000B2321, 0x00310F17, 0x00240124,
    0x0006131A, 0x00282608, 0x00012C2A, 0x000C231C, 0x00161906,
    0x0008301F, 0x000E1F1A, 0x002D2506, 0x001C0516, 0x000A151C,
    0x00320B11, 0x001A0131, 0x00272D05, 0x00120C26, 0x00300216,
    0x000C2E2E, 0x00041120, 0x00272904, 0x00082015, 0x000E112B,
    0x002E1707, 0x00170122, 0x001E2803, 0x000E1527, 0x002C1B08,
    0x001C0917, 

    0x00220F31, 0x002D1906, 0x00052829, 0x002A0724, 0x00130F30,         // 31
    0x00211E0C, 0x000B2D27, 0x00191116, 0x00052830, 0x00150C13,
    0x00292203, 0x001F1017, 0x002E0827, 0x00042613, 0x001C0620,
    0x002F1804, 0x00072723, 0x0015210A, 0x00311501, 0x00210721,
    0x00282E06, 0x00141015, 0x00001D2B, 0x000D1713, 0x00201026,
    0x00041F15, 0x000C291C, 0x00300229, 0x00270917, 0x001C250F,
    0x002E1306, 0x0018310B, 0x0020091A, 0x000E2212, 0x0029061C,
    0x001D1610, 0x002B2C0B, 0x001A1A01, 0x002D0D11, 0x0010212F,
    0x001B0722, 0x0030130E, 0x00131709, 0x00230A29, 0x00111B10,
    0x001D130C, 0x00150630, 0x00232F08, 0x00190F16, 0x00212402,
    0x0014130D, 0x00300B31, 0x00071F23, 0x001B320E, 0x00281C0A,
    0x00051714, 0x001D2C04, 0x002F120D, 0x00180530, 0x00221402,
    0x0011282A, 0x00160B11, 0x00263203, 0x0012170D, 0x000A2C2B,
    0x002E200B, 0x00150527, 0x00201501, 0x00250E30, 0x001D0416,
    0x002C0A2D, 0x0020130B, 0x00042D21, 0x00110E2F, 0x00282F0A,
    0x00031E29, 0x000F281E, 0x002C1013, 0x0002192B, 0x00252401,
    0x0019140F, 0x00220728, 0x00131B0C, 0x001F031A, 0x00002C27,
    0x0022260E, 0x00051F2E, 0x002F2F0B, 0x0025101B, 0x00072B2C,
    0x00101F11, 

    0x0017011C, 0x000B2E16, 0x00191D0A, 0x000E1512, 0x00263204,         // 32
    0x0002261A, 0x0029092C, 0x00112309, 0x0026011C, 0x002F1E0D,
    0x001A062C, 0x000C3122, 0x00161A05, 0x00250F1B, 0x00112B31,
    0x00011C17, 0x00270411, 0x001E112C, 0x000D1D18, 0x0019260D,
    0x00091730, 0x002F2A08, 0x001B071F, 0x002A2E00, 0x00092522,
    0x00290431, 0x0014190C, 0x001A2F07, 0x00061722, 0x000B2B30,
    0x00140420, 0x00001D2C, 0x00271803, 0x00082932, 0x00160D26,
    0x00112108, 0x0024092F, 0x00140123, 0x00002F2A, 0x00212704,
    0x00150E19, 0x00032B27, 0x0009241C, 0x00183001, 0x0029042C,
    0x0008271B, 0x002A1903, 0x0010211F, 0x002F042D, 0x00041C1A,
    0x000E2B21, 0x00260012, 0x000D2819, 0x002D1300, 0x00130930,
    0x00190E19, 0x00240729, 0x000B261E, 0x00271E07, 0x00022C25,
    0x0030190A, 0x001B0719, 0x002B1031, 0x00011C1D, 0x00182705,
    0x001E0A20, 0x00101A11, 0x00082F18, 0x002A1F0D, 0x000B2522,
    0x00052B13, 0x00261C01, 0x0017012A, 0x002F1910, 0x00232305,
    0x00190618, 0x0014150C, 0x00082122, 0x001D3209, 0x0015091F,
    0x000E2B18, 0x002C2107, 0x000A302F, 0x00310E23, 0x00161602,
    0x002A061E, 0x00130C18, 0x000B1926, 0x001A0414, 0x00150A20,
    0x002F2404, 

    0x00002725, 0x00240B2D, 0x0030061E, 0x0007232A, 0x001D0216,         // 33
    0x00160C20, 0x0031140E, 0x00091A24, 0x001E2E00, 0x000F1127,
    0x0004291F, 0x0023140B, 0x0009242D, 0x001E0111, 0x002C2009,
    0x00170C29, 0x000F311F, 0x002D0913, 0x00032C27, 0x002B021C,
    0x00110C24, 0x00042018, 0x00260E2D, 0x00171A0B, 0x00121310,
    0x001D2C04, 0x00240B19, 0x000F232D, 0x00201111, 0x002C1E01,
    0x00240C1B, 0x00112511, 0x002C1023, 0x001A0215, 0x002F2E05,
    0x00021B20, 0x00092517, 0x0030101B, 0x0025140A, 0x000D1C1F,
    0x002C0312, 0x00271E0B, 0x00201030, 0x002F0817, 0x000C2020,
    0x00220D25, 0x00012B13, 0x001B0A27, 0x000B1611, 0x00283106,
    0x001A0D29, 0x001E2007, 0x00021A2C, 0x0021051E, 0x00082625,
    0x00322009, 0x00033023, 0x00101911, 0x00140A18, 0x001F0120,
    0x0009212D, 0x000F2B15, 0x00072522, 0x0020130E, 0x0026062E,
    0x002B0F14, 0x0004292C, 0x002F001D, 0x00180B25, 0x00131708,
    0x00311028, 0x0010221D, 0x001D0917, 0x00072825, 0x000C111F,
    0x001F0A2F, 0x002B2C02, 0x0022052C, 0x00310E15, 0x00061E2E,
    0x00290426, 0x0002181C, 0x001D0B14, 0x000F2311, 0x00211A0A,
    0x00072831, 0x001C1406, 0x00232510, 0x002B2D00, 0x00061C2F,
    0x0028130C, 

    0x001C1607, 0x00131F10, 0x001F1201, 0x00102923, 0x002D1B08,         // 34
    0x00062B31, 0x00212006, 0x001A0415, 0x0002262E, 0x002C1710,
    0x00140318, 0x00281D06, 0x00320A15, 0x00032E1D, 0x000D1224,
    0x00232805, 0x001B160D, 0x0007212F, 0x00251308, 0x00151B0F,
    0x00233102, 0x001C0511, 0x000E2825, 0x002D001A, 0x0002212E,
    0x00310D20, 0x00071D14, 0x002A0625, 0x0002281E, 0x00190115,
    0x00082F27, 0x001E1509, 0x00042C19, 0x000C1F2A, 0x0022130F,
    0x001D052C, 0x000E3112, 0x001E1906, 0x00062A27, 0x00190C16,
    0x00092E2D, 0x001C1506, 0x00102921, 0x00021A11, 0x001A2E05,
    0x0012150E, 0x00310132, 0x00242509, 0x0016101C, 0x0006262F,
    0x002C0615, 0x00101525, 0x00162F0C, 0x002A1014, 0x00112B06,
    0x0017150F, 0x0029032E, 0x00212302, 0x002E102B, 0x00192F09,
    0x00290E11, 0x00221600, 0x002E0328, 0x00141F08, 0x00053018,
    0x000D2223, 0x001B1204, 0x00221D09, 0x0003262F, 0x00243203,
    0x001A0311, 0x00012932, 0x002B150A, 0x00141E04, 0x0028310F,
    0x00041827, 0x00102612, 0x000B1C1C, 0x001A1704, 0x0012290C,
    0x00241110, 0x00172505, 0x002D002C, 0x00052B20, 0x00290929,
    0x000C3016, 0x00300223, 0x00011E2C, 0x0011071A, 0x001F0D27,
    0x000D3116, 

    0x00072830, 0x00270D1A, 0x0003302B, 0x0029170D, 0x00140619,         // 35
    0x00251012, 0x000D3028, 0x00130E21, 0x0027081A, 0x00212205,
    0x00082F32, 0x001B0F23, 0x0010282A, 0x00181902, 0x002A0730,
    0x00091E16, 0x0030031C, 0x00122500, 0x001F0A1F, 0x000C2928,
    0x00321031, 0x00072415, 0x00201604, 0x000A3029, 0x00180913,
    0x001F2A07, 0x000D142B, 0x00163103, 0x002F1A0A, 0x00130E30,
    0x00262105, 0x0032072E, 0x00160B1F, 0x00251901, 0x0012280A,
    0x002A0E1E, 0x00160A28, 0x002C210D, 0x00120231, 0x00272401,
    0x00320724, 0x0005211A, 0x00160A2A, 0x002C0315, 0x00261128,
    0x001F2308, 0x00051D16, 0x000F2D21, 0x002B1B01, 0x00210A13,
    0x000C221F, 0x00312902, 0x0024031D, 0x0004222E, 0x001F0827,
    0x00091D1F, 0x001C0C16, 0x000D2D1C, 0x00061413, 0x000F2726,
    0x00011B1D, 0x0017092F, 0x000C2D13, 0x001D0C1F, 0x00301703,
    0x00130529, 0x00282C10, 0x000B1821, 0x00120916, 0x002A0E1B,
    0x000C1F26, 0x001F0615, 0x000F2D23, 0x00220C2D, 0x00180319,
    0x002D2007, 0x001D1016, 0x00260224, 0x00012F29, 0x002C071F,
    0x000D1F32, 0x00073123, 0x0022140B, 0x00141D04, 0x001A0F19,
    0x00261F08, 0x0016120F, 0x00092A1F, 0x00281807, 0x0016210E,
    0x0032031E, 

    0x00120822, 0x002C2308, 0x00180215, 0x000B2126, 0x001B0A2E,         // 36
    0x0001281E, 0x002A1602, 0x002F1C0C, 0x000A2B2A, 0x0016120A,
    0x002F0B1E, 0x00002011, 0x00200419, 0x0026230F, 0x00061521,
    0x00162F0B, 0x00220E2D, 0x00042D24, 0x002A0617, 0x00181805,
    0x00011F1A, 0x00280B22, 0x00141C09, 0x0024101E, 0x002A230C,
    0x00041723, 0x0028041B, 0x0023250F, 0x001D0928, 0x00041617,
    0x000C2923, 0x001B1B0E, 0x00072714, 0x002D0425, 0x00032230,
    0x000A2B16, 0x00231503, 0x00012D21, 0x00200F13, 0x000B1B1D,
    0x00141209, 0x00203210, 0x00241804, 0x000B262F, 0x00072B1C,
    0x00150723, 0x002D0B2C, 0x00091319, 0x001D052A, 0x00012E26,
    0x0017130A, 0x00071C31, 0x001C0F11, 0x000C1917, 0x002F2F03,
    0x0026120B, 0x00002828, 0x002C1905, 0x00270332, 0x001B1F08,
    0x00310519, 0x00262206, 0x00042924, 0x002A1C0B, 0x00082630,
    0x00200B1B, 0x00161F0D, 0x0031032E, 0x001D2E0B, 0x0006232B,
    0x002F190F, 0x00261105, 0x00061C1C, 0x0032140E, 0x00032829,
    0x00120822, 0x00072E30, 0x002F140D, 0x00152107, 0x00200D17,
    0x001A1A02, 0x0028101A, 0x00102A15, 0x002F0627, 0x0002271E,
    0x0011042E, 0x00202402, 0x002E0A25, 0x001A1013, 0x00032C2A,
    0x00211A03, 

    0x000A2E28, 0x001E1510, 0x00061C20, 0x00232B09, 0x002E1304,         // 37
    0x0020230F, 0x0018002D, 0x0007251D, 0x001D0614, 0x000F1A25,
    0x001F2C03, 0x000C1727, 0x002E3209, 0x0013102B, 0x001C2A06,
    0x002D0928, 0x00101A12, 0x001A1F0A, 0x0008142C, 0x002D2F11,
    0x0011022A, 0x00192B0F, 0x002F062E, 0x00062C17, 0x0012022C,
    0x001A1E01, 0x00092E32, 0x00111111, 0x00071C1F, 0x002D2D0C,
    0x0015051C, 0x002A1307, 0x0010322B, 0x001F1111, 0x0018091B,
    0x0031180B, 0x001B052D, 0x000D1E1A, 0x002F0825, 0x0019260D,
    0x00032B2D, 0x002E0027, 0x00110C1F, 0x001B1B0F, 0x00301402,
    0x000E2013, 0x001B3106, 0x0027190B, 0x0012290F, 0x002F1F04,
    0x0022011A, 0x00280B24, 0x00132B0D, 0x002B072A, 0x000F261B,
    0x00190030, 0x00112010, 0x00160820, 0x00202B0D, 0x00120F23,
    0x0007312A, 0x001F140E, 0x00121017, 0x001A012B, 0x00101414,
    0x00273106, 0x00001127, 0x00092818, 0x00231504, 0x00180623,
    0x00132C08, 0x00092720, 0x00150A2E, 0x001A3001, 0x000B2314,
    0x0025170A, 0x00191E03, 0x0021091A, 0x0005262E, 0x000B2D13,
    0x0032022A, 0x00042326, 0x001F0C11, 0x00091930, 0x00232E0C,
    0x002C1511, 0x00061A28, 0x000B321B, 0x00230032, 0x000F2516,
    0x002D130C, 

    0x00250B1A, 0x00142901, 0x00300630, 0x00110E1C, 0x00052F2A,         // 38
    0x000C1924, 0x00120D18, 0x00243109, 0x00041430, 0x002A270D,
    0x00250116, 0x0015092F, 0x00051C20, 0x00220514, 0x000E131E,
    0x00022519, 0x00280022, 0x00252803, 0x00140C1D, 0x001F230C,
    0x00241107, 0x0009251C, 0x001E1402, 0x000D1926, 0x002D270E,
    0x00200D15, 0x00310721, 0x00182107, 0x0029012B, 0x001E2404,
    0x00250C2E, 0x00052027, 0x00220216, 0x000C2421, 0x00281C03,
    0x00062F27, 0x00132710, 0x00251306, 0x00073030, 0x00291602,
    0x001D0E13, 0x000D1D16, 0x00272207, 0x00002F25, 0x0021041A,
    0x00290D2E, 0x0003271F, 0x00220225, 0x00170D30, 0x00091715,
    0x0010262C, 0x001A3206, 0x0002201F, 0x001E1509, 0x00081E22,
    0x00220E14, 0x00313107, 0x000A132D, 0x0005221A, 0x00240A13,
    0x002B1804, 0x000B262E, 0x002E0A20, 0x00242E01, 0x0006201E,
    0x001B0725, 0x002D1A0A, 0x000F221F, 0x002B0B29, 0x00031E12,
    0x00240F30, 0x001C0216, 0x002B1F0A, 0x00280726, 0x001F101B,
    0x002E001F, 0x000C2A2A, 0x002A0F11, 0x00101B23, 0x0025081D,
    0x0017170F, 0x00132806, 0x002B0420, 0x001B2101, 0x000C1124,
    0x00172506, 0x001E0D17, 0x0015200B, 0x002A1504, 0x00051D1F,
    0x0018052E, 

    0x00012014, 0x000C1823, 0x001B250D, 0x002A0917, 0x00171E0B,         // 39
    0x00270513, 0x00322206, 0x001B0928, 0x002C1F04, 0x00130E22,
    0x0002211C, 0x001C1210, 0x002B2406, 0x00092C2D, 0x00301F01,
    0x001E180E, 0x00071132, 0x000F2C14, 0x0031052E, 0x00021821,
    0x000E1D25, 0x002C0731, 0x00032E13, 0x00270B20, 0x00162105,
    0x00021327, 0x000B2B1A, 0x0024180D, 0x00003024, 0x000F1413,
    0x000A1A19, 0x00192E00, 0x0030170A, 0x00012A2F, 0x001C130F,
    0x0011001F, 0x002E0B2A, 0x001F230A, 0x00160318, 0x00102020,
    0x0023092B, 0x0006291B, 0x002B0631, 0x0018120B, 0x00092829,
    0x00141D0D, 0x000C1617, 0x002E2302, 0x00052D1C, 0x00260722,
    0x002B1011, 0x000B1917, 0x0030042F, 0x00250D12, 0x00172D02,
    0x00031A2B, 0x00280525, 0x001A280B, 0x002E1B01, 0x000F2D28,
    0x0017061D, 0x001D1D0A, 0x00022A12, 0x00150529, 0x0030180C,
    0x000C2612, 0x00220D32, 0x00142B00, 0x001E0115, 0x000E311C,
    0x002E170C, 0x000B2A27, 0x00051419, 0x00102611, 0x00011A31,
    0x00142E0C, 0x00082117, 0x00170426, 0x001E2B0B, 0x002C1200,
    0x00073231, 0x00221F0C, 0x0002142B, 0x0011301C, 0x00310A14,
    0x0025022F, 0x00002D1D, 0x002F082C, 0x00122A0F, 0x00200D24,
    0x00282F06, 

    0x002E0F1D, 0x0022012B, 0x00043227, 0x001E1507, 0x00082A21,         // 40
    0x00211031, 0x00032E1A, 0x000F1820, 0x00092B12, 0x0018052A,
    0x00312802, 0x000C2E25, 0x0027180C, 0x00190C1B, 0x00130324,
    0x002A300A, 0x00170927, 0x00201B08, 0x0009241A, 0x001B3201,
    0x00290C16, 0x0013280D, 0x00191F07, 0x00210319, 0x000F312F,
    0x00261609, 0x001D092C, 0x00122602, 0x002E0F1D, 0x001B0531,
    0x002C270F, 0x00120823, 0x00260F1B, 0x00140626, 0x002C1F06,
    0x00210F19, 0x00032B14, 0x000A1B23, 0x002A0D12, 0x00012E28,
    0x00311A08, 0x00141310, 0x001F2E00, 0x000F191F, 0x00260C13,
    0x00312D05, 0x001A0628, 0x0011112C, 0x001F1A0E, 0x00182808,
    0x00042128, 0x00211300, 0x00112A23, 0x00062428, 0x002A0216,
    0x000D261D, 0x0013170F, 0x001F0B19, 0x00011121, 0x00270130,
    0x00062416, 0x00230E26, 0x000E161B, 0x00292206, 0x001E102D,
    0x00042D19, 0x00180521, 0x0027130F, 0x00061A2D, 0x00292505,
    0x00160722, 0x00202107, 0x00310C2C, 0x00192C06, 0x00220521,
    0x00271203, 0x001D0C2E, 0x00301707, 0x00002314, 0x000C1D28,
    0x001C031F, 0x002F0F13, 0x00180818, 0x00271A09, 0x00072B29,
    0x00141E0F, 0x000D1122, 0x00271908, 0x001A0417, 0x00072628,
    0x000F1A12, 

    0x00172A0A, 0x00122303, 0x00261110, 0x000E1B1B, 0x002E032A,         // 41
    0x00132601, 0x001A140D, 0x0023022E, 0x00280D16, 0x001E1B0B,
    0x00071531, 0x00211017, 0x0011082A, 0x00012613, 0x00240E2F,
    0x000C2818, 0x0003201F, 0x002C1410, 0x0026072A, 0x00150F12,
    0x00220127, 0x000A161F, 0x0032102B, 0x00081A23, 0x002B0711,
    0x0006241E, 0x00301C0F, 0x00160225, 0x00071F17, 0x00222C08,
    0x00031229, 0x00201E0D, 0x0006292E, 0x000E2213, 0x00192E0B,
    0x000C1932, 0x002B2501, 0x001B062C, 0x000E151B, 0x00202804,
    0x0019021E, 0x000A2424, 0x002E082B, 0x00051F18, 0x001D012F,
    0x00022323, 0x00230E11, 0x002A2007, 0x000A3119, 0x00320032,
    0x00130B1E, 0x001C2F0D, 0x002D081B, 0x00151B06, 0x001D140D,
    0x002E0A31, 0x00252C05, 0x00091F2C, 0x00112A11, 0x00191808,
    0x0032300E, 0x00141F02, 0x0026032F, 0x00083223, 0x00120A16,
    0x00251D04, 0x000E172A, 0x00322F09, 0x000A2126, 0x001B0C18,
    0x00011231, 0x00122F10, 0x0025031D, 0x000D1715, 0x0007222B,
    0x002B1C10, 0x00042819, 0x000E2F22, 0x0022062C, 0x00140B1A,
    0x00292507, 0x000E2C24, 0x0009222D, 0x00212704, 0x001A061F,
    0x002A170C, 0x00222701, 0x00042E29, 0x000B221C, 0x00311302,
    0x001D072D, 

    0x002A0C19, 0x00061D31, 0x00310620, 0x00182D05, 0x00022214,         // 42
    0x002A0824, 0x000A1C1D, 0x00302804, 0x00002027, 0x000E311C,
    0x002C2407, 0x0014011F, 0x002E2004, 0x000A2F21, 0x00201C0F,
    0x00311302, 0x0019022D, 0x00112705, 0x00052D22, 0x000D1F30,
    0x002D2B04, 0x0000221B, 0x001F2F0A, 0x00142800, 0x001A0E16,
    0x00102C2A, 0x00201104, 0x000E2F2F, 0x00270A12, 0x000B1822,
    0x002B2305, 0x0015011F, 0x002E1603, 0x001F0A18, 0x00270520,
    0x00071428, 0x00240D1D, 0x00133209, 0x002F1D0E, 0x0008112A,
    0x0024210C, 0x00110C16, 0x00282B06, 0x0017150F, 0x002B3003,
    0x000A1A1D, 0x000F2917, 0x00160526, 0x00031520, 0x00220E12,
    0x00281E05, 0x000C172E, 0x00002313, 0x00230E2C, 0x000A2E18,
    0x00042120, 0x0019120C, 0x002F0327, 0x00212303, 0x00290824,
    0x000A132C, 0x001F0C1A, 0x00012913, 0x002F1409, 0x0019250D,
    0x002C0127, 0x0002271C, 0x001D0B14, 0x0011051F, 0x00232903,
    0x002F190B, 0x00091D27, 0x001B2702, 0x002D0F23, 0x0015300A,
    0x001A0A28, 0x0011011E, 0x00261305, 0x002C1C0A, 0x001A2D10,
    0x0006122F, 0x00241803, 0x0015001D, 0x002D0D11, 0x00021332,
    0x00102125, 0x0016021A, 0x002C0F12, 0x00200930, 0x00141E0D,
    0x00033021, 

    0x000F1314, 0x001F280C, 0x000B1829, 0x00240B17, 0x001D0F2F,         // 43
    0x00101611, 0x001F3009, 0x00170A2C, 0x00121310, 0x00270623,
    0x00190C14, 0x00042B28, 0x0026190D, 0x001B042B, 0x00151608,
    0x00042C24, 0x00270B15, 0x001E180C, 0x002F101B, 0x00201A08,
    0x0019130F, 0x00120B2D, 0x00290613, 0x00051D31, 0x002E0025,
    0x00251508, 0x00011F19, 0x002B0D1F, 0x00182806, 0x001E062C,
    0x00102E1B, 0x001B0E14, 0x000A2B2A, 0x00031B24, 0x00323007,
    0x0016270D, 0x001E0115, 0x0002222E, 0x00270921, 0x00172D11,
    0x002D062F, 0x00021826, 0x0021101F, 0x0008272D, 0x00140827,
    0x0025120C, 0x002F0B30, 0x00202C01, 0x001A1C0A, 0x000F2629,
    0x00062D17, 0x002C0524, 0x001A290A, 0x00290322, 0x00131D01,
    0x00220728, 0x000F3214, 0x00071A1E, 0x00150F19, 0x00032D13,
    0x000F1C1F, 0x002D2606, 0x001B082A, 0x000C1B21, 0x00210E30,
    0x00092C11, 0x00171F02, 0x0024102E, 0x002B160E, 0x000B2C2B,
    0x0018001B, 0x002A0A16, 0x0004202E, 0x00210611, 0x000B151B,
    0x00312601, 0x0020210E, 0x00171032, 0x00032725, 0x000B1617,
    0x001F0720, 0x00311F0D, 0x00043127, 0x000E1C16, 0x001E2D06,
    0x00300814, 0x0009312C, 0x001C1C07, 0x0010161E, 0x00282606,
    0x00230426, 

    0x001B2200, 0x002C011C, 0x00153008, 0x00051F22, 0x00282B0A,         // 44
    0x00082528, 0x002B0021, 0x00062118, 0x002E1805, 0x00202C0B,
    0x000A1E2F, 0x00221100, 0x000F261D, 0x002A0E15, 0x0008221A,
    0x002C0631, 0x000E251D, 0x0008312A, 0x00150525, 0x00032916,
    0x0027031F, 0x000B2624, 0x001A0F18, 0x0022180C, 0x000C261F,
    0x00162B0E, 0x001E0429, 0x000B1814, 0x00062023, 0x002E140C,
    0x00021C11, 0x00290430, 0x00252509, 0x00181110, 0x00110C2F,
    0x00061E1B, 0x002D1703, 0x000B2A25, 0x001C1A06, 0x0006131C,
    0x00132701, 0x001C310A, 0x000F1C13, 0x0032051B, 0x001B1F09,
    0x00112510, 0x00061721, 0x000C2115, 0x002E032C, 0x0026120E,
    0x001E091E, 0x00152103, 0x000E152A, 0x0007111C, 0x00302710,
    0x001C1609, 0x00270C2D, 0x002C2806, 0x001D062B, 0x0024210B,
    0x00180231, 0x0028180D, 0x00052D1C, 0x00152102, 0x002A0417,
    0x0011191E, 0x002E0725, 0x00072F19, 0x00151C07, 0x00032223,
    0x001F0F12, 0x00103220, 0x00271307, 0x000F2A25, 0x00011C30,
    0x00240717, 0x0007192A, 0x000D3113, 0x002F031C, 0x00242302,
    0x00120C28, 0x00182809, 0x0029061A, 0x0022102D, 0x0007231F,
    0x00181A0B, 0x00250C23, 0x00022916, 0x002D0527, 0x00062D12,
    0x000A1A2D, 

    0x00112B0F, 0x00001524, 0x0021092C, 0x002E1210, 0x0013051E,         // 45
    0x00191A05, 0x00251013, 0x000D2E31, 0x001C041F, 0x00032728,
    0x00150818, 0x0032170F, 0x00073224, 0x001F092E, 0x00132903,
    0x00231B0F, 0x0019110B, 0x00211F01, 0x002A0912, 0x000A232B,
    0x0023150B, 0x002C2D02, 0x00042029, 0x00303006, 0x0007121A,
    0x002A0C2E, 0x00112402, 0x0032320A, 0x00240A31, 0x00132601,
    0x00200F26, 0x00083018, 0x000F161E, 0x001F2102, 0x002B0326,
    0x00262C10, 0x0013082C, 0x00220F18, 0x00310313, 0x000E232B,
    0x002B0A23, 0x00250219, 0x00052232, 0x00221402, 0x00012B25,
    0x002C012C, 0x001D2D04, 0x0028091C, 0x00013022, 0x00131908,
    0x00092B2F, 0x00310E19, 0x0020310D, 0x00251F06, 0x00032C31,
    0x00160024, 0x000D241B, 0x00011811, 0x00112B23, 0x00301500,
    0x00073126, 0x00130E16, 0x00230625, 0x001D110F, 0x0003302C,
    0x00262406, 0x001F130C, 0x000E2829, 0x001B0315, 0x00280930,
    0x00312601, 0x00071A2B, 0x0017240B, 0x002F0214, 0x001B2E05,
    0x00101121, 0x00282908, 0x001D0B22, 0x00131E07, 0x002A0F2B,
    0x00032F13, 0x000C1A30, 0x001C140F, 0x00112B00, 0x0027032A,
    0x0013160F, 0x002E2405, 0x000E1231, 0x00181F0B, 0x001E0A18,
    0x002F0F1F, 

    0x0019072F, 0x00271D06, 0x00092518, 0x001C2A02, 0x000C212F,         // 46
    0x00300A1B, 0x0001272A, 0x00181D01, 0x00230E15, 0x002B1407,
    0x000C2321, 0x0025032C, 0x00191D05, 0x00011412, 0x002F011B,
    0x000B2E27, 0x00021720, 0x00310C2E, 0x00112B18, 0x001D1C05,
    0x00160D32, 0x000F1A11, 0x001E0A1D, 0x0012022C, 0x00172210,
    0x00200622, 0x00031A16, 0x001C1128, 0x0018021B, 0x000C2C15,
    0x002C0721, 0x00161E05, 0x00300A2D, 0x000B2A14, 0x00001821,
    0x001C2307, 0x000C121F, 0x0018280A, 0x00043030, 0x00201E0D,
    0x00181705, 0x000A1129, 0x00292D0F, 0x00160B21, 0x000C1A15,
    0x00240E1A, 0x0017140A, 0x00101D31, 0x00220F13, 0x00182204,
    0x00280125, 0x00041C14, 0x0018052C, 0x00120B21, 0x000B1916,
    0x002D0F13, 0x00211F02, 0x002A0730, 0x001B1018, 0x000B1D13,
    0x00200A1D, 0x002B2804, 0x00091F2E, 0x00312A09, 0x000D1621,
    0x00180914, 0x00041F32, 0x00300D20, 0x00221804, 0x000C2D1D,
    0x0013140E, 0x001C0524, 0x00230D19, 0x0006181E, 0x00290A2C,
    0x0015240E, 0x002D041A, 0x0002142D, 0x00192D0C, 0x000E1818,
    0x0020021F, 0x002E2506, 0x00061F24, 0x002C0B14, 0x0000271C,
    0x001F0826, 0x000A2C1A, 0x00220020, 0x002A3002, 0x000C182A,
    0x00252308, 

    0x00042F15, 0x00320D11, 0x00101928, 0x002A041F, 0x00041714,         // 47
    0x00212D08, 0x0014140D, 0x002C0625, 0x00102911, 0x00061B30,
    0x001D2F0D, 0x00110E1B, 0x002C2C09, 0x000E2422, 0x00270F2A,
    0x001D2006, 0x00250516, 0x00152408, 0x00061328, 0x002B0222,
    0x0002321A, 0x002F0625, 0x000A2915, 0x00241D03, 0x002B140C,
    0x000E2D26, 0x00261E07, 0x0009281F, 0x002B160D, 0x0001222C,
    0x0026190B, 0x00062929, 0x001B130E, 0x00240519, 0x00130E31,
    0x002E310D, 0x00061C29, 0x00251502, 0x00290622, 0x00130D16,
    0x00012C1E, 0x00302411, 0x00111D08, 0x001E042D, 0x002F3205,
    0x0008202A, 0x00042611, 0x00310426, 0x000A2918, 0x002C082B,
    0x001D270F, 0x000D161F, 0x002E2500, 0x00282A0E, 0x001F0728,
    0x0006301E, 0x0018140D, 0x00072620, 0x00152E08, 0x00280129,
    0x0003242F, 0x001A120C, 0x00111A11, 0x0026021C, 0x00150E27,
    0x002D2700, 0x001E021B, 0x00133009, 0x00062113, 0x00261027,
    0x00001E17, 0x002C2805, 0x000A2F31, 0x00112111, 0x001F1D03,
    0x00042D27, 0x000B1A14, 0x00212204, 0x00300624, 0x0009272F,
    0x0028130E, 0x0013081B, 0x00250E2B, 0x00173008, 0x000E192F,
    0x00292003, 0x001B0F13, 0x00031C2D, 0x0013140F, 0x0007271C,
    0x00150227, 

    0x00201122, 0x000A281A, 0x001E0832, 0x0016310A, 0x00260F26,         // 48
    0x001A022D, 0x00081F20, 0x000B301A, 0x00240C29, 0x0030011D,
    0x00171F02, 0x00280727, 0x00081815, 0x00220A2E, 0x00162B0B,
    0x00071A13, 0x000F3030, 0x0028081D, 0x001F2C0E, 0x000C1D14,
    0x00232407, 0x001A150D, 0x0028102D, 0x00012F1F, 0x001B0731,
    0x0007261B, 0x002E0E12, 0x00140A2E, 0x001D2F04, 0x00111211,
    0x001F0C20, 0x0013001B, 0x00292208, 0x00092D28, 0x00191E04,
    0x00270817, 0x001F011C, 0x000F2114, 0x00072528, 0x002C1A07,
    0x001C022D, 0x00210926, 0x00071318, 0x0027280D, 0x001A0D1D,
    0x00101813, 0x0028071F, 0x001B2F06, 0x00141A0D, 0x0003141E,
    0x00112E09, 0x00230C30, 0x00012019, 0x001B1308, 0x000F1B2E,
    0x00322705, 0x00270326, 0x00120B2C, 0x002E1A0F, 0x001E1404,
    0x000F2C20, 0x002E0619, 0x00053029, 0x001C2506, 0x00011818,
    0x000B2C2A, 0x00281C0F, 0x00091523, 0x002C062F, 0x00192B0A,
    0x001F012A, 0x00140B22, 0x0028150D, 0x00180629, 0x0032120A,
    0x00250322, 0x00170D31, 0x00102B1E, 0x00260A12, 0x00152007,
    0x00032E27, 0x001D1E02, 0x000A2917, 0x00210121, 0x002F130D,
    0x00052D18, 0x00150528, 0x00312806, 0x00270824, 0x001C0D13,
    0x002C1F04, 

    0x000D1B2C, 0x0018150D, 0x002D2201, 0x00061C12, 0x000D2917,         // 49
    0x00312506, 0x00281110, 0x001F1903, 0x0019220B, 0x00011517,
    0x000B2A2D, 0x001F120F, 0x0003281E, 0x00131E03, 0x00300319,
    0x001A0C25, 0x002C1402, 0x00042623, 0x00181809, 0x002E0F2F,
    0x0013041F, 0x00062828, 0x00151B05, 0x000F2318, 0x0031120A,
    0x00161801, 0x0021022A, 0x00032319, 0x00270524, 0x00311E09,
    0x000A2730, 0x00223100, 0x00031B24, 0x002F1111, 0x000E2721,
    0x0002172B, 0x00152B0B, 0x00310C2F, 0x00192F0E, 0x000B1319,
    0x0027280B, 0x00162E01, 0x000E1822, 0x00032130, 0x00140625,
    0x002C2C02, 0x0021102C, 0x00092223, 0x00250A2F, 0x001E1F02,
    0x002D1127, 0x00160415, 0x00083229, 0x002B0123, 0x00140D13,
    0x0004201A, 0x0023170A, 0x000D2A16, 0x0001231C, 0x00220525,
    0x00081E14, 0x00151709, 0x001F0F22, 0x002C0931, 0x0023210B,
    0x00110414, 0x001B102D, 0x00222604, 0x00150B18, 0x000D231F,
    0x00301207, 0x00051B14, 0x00222B01, 0x0002241F, 0x000F311B,
    0x00091715, 0x002C250D, 0x001C1300, 0x00061B2C, 0x002C1116,
    0x00190420, 0x0032190C, 0x00051532, 0x00102311, 0x001A0A2A,
    0x00241E07, 0x000D171F, 0x001F230B, 0x0010321A, 0x00051730,
    0x00262A0B, 

    0x002F0317, 0x00012F25, 0x0028061C, 0x00130E23, 0x0020092A,         // 50
    0x0002161D, 0x00120531, 0x00072922, 0x002D082B, 0x00152F07,
    0x00260B20, 0x002F2505, 0x001B0532, 0x0029310E, 0x000E1220,
    0x0000282D, 0x001D1F0F, 0x0023001A, 0x00110B2A, 0x00092217,
    0x00272E00, 0x0022091B, 0x002D0E12, 0x001F0123, 0x00051F29,
    0x0025310F, 0x000B2922, 0x0019130C, 0x000E2B14, 0x00051729,
    0x00160618, 0x002D0B13, 0x0010162D, 0x001C061D, 0x00220D14,
    0x002C2206, 0x00071125, 0x001E1901, 0x0024051F, 0x00120A24,
    0x00051E30, 0x002D0E1B, 0x00220312, 0x002B3006, 0x001F140C,
    0x000C1D19, 0x00002714, 0x00181508, 0x002F001B, 0x000E2C12,
    0x00062422, 0x00271B04, 0x001F140B, 0x000B251D, 0x00252B02,
    0x001D072F, 0x00092F21, 0x001C1202, 0x00290D32, 0x0018310A,
    0x0030092D, 0x00252201, 0x000E2B11, 0x0007151E, 0x00162E03,
    0x002A0C25, 0x0005201C, 0x002F320A, 0x00021B26, 0x0025150F,
    0x00092F2C, 0x00101F19, 0x002E032F, 0x001B0F12, 0x002A092B,
    0x001E1D08, 0x00002C27, 0x0024011B, 0x000B3122, 0x00122609,
    0x00220D29, 0x000E2C14, 0x0026091E, 0x002C3104, 0x0013111B,
    0x00082924, 0x00290931, 0x00011216, 0x002D022A, 0x00192102,
    0x00120A1E, 

    0x00222405, 0x001C1209, 0x0009292E, 0x0024190B, 0x00192E03,         // 51
    0x002A220F, 0x00163209, 0x00240E19, 0x00101E14, 0x00200325,
    0x000F1812, 0x00041D2A, 0x00160E18, 0x000A1625, 0x00252309,
    0x002E0715, 0x00142E05, 0x000D1B27, 0x00312A07, 0x001C1210,
    0x00011624, 0x000F1E2C, 0x00192908, 0x000A2D30, 0x00270C16,
    0x0012061E, 0x002D1B06, 0x001F0932, 0x002B2003, 0x00230F1F,
    0x001B2C07, 0x000B2427, 0x0028200B, 0x00172E03, 0x00092930,
    0x0012031B, 0x00283010, 0x000C1F2D, 0x00012A15, 0x002F2205,
    0x0017150F, 0x00092528, 0x00101C15, 0x00190A2B, 0x00082420,
    0x0031022E, 0x00240C27, 0x0012310E, 0x00051A2A, 0x00290E16,
    0x001A0631, 0x00122D10, 0x0031092C, 0x00181D0F, 0x00021628,
    0x002D0E17, 0x00161D0D, 0x00300129, 0x00122010, 0x000B181E,
    0x00042617, 0x001A0D2A, 0x00290026, 0x000B1D15, 0x0031072D,
    0x0019280E, 0x000A1321, 0x001F0116, 0x00110831, 0x001B2A02,
    0x0029051C, 0x001E0C27, 0x00132709, 0x00081A23, 0x00242304,
    0x00160518, 0x00110F2E, 0x00302007, 0x0017170E, 0x00290730,
    0x00011D1A, 0x001D2401, 0x0017032C, 0x00031B23, 0x001E210A,
    0x00300413, 0x00172E00, 0x001D1A0E, 0x000A2821, 0x00240F12,
    0x00072C27, 

    0x00151D10, 0x002B0B29, 0x00102014, 0x002F0319, 0x000C112F,         // 52
    0x00081D23, 0x002E0028, 0x001B1905, 0x0003262D, 0x0029130C,
    0x0007231D, 0x002C2B08, 0x00230113, 0x001C2D02, 0x00051B2B,
    0x001F0E1C, 0x00081631, 0x00260914, 0x00052521, 0x002A042F,
    0x0017300A, 0x00300615, 0x00041920, 0x002A130F, 0x001B2602,
    0x00021126, 0x00172211, 0x0009151B, 0x00003023, 0x0011032C,
    0x00291A10, 0x0006121C, 0x001F0223, 0x00011A18, 0x00310B27,
    0x00231D08, 0x001B0723, 0x0015140C, 0x00290E1C, 0x0020002C,
    0x001C3209, 0x00260620, 0x002F2C02, 0x0002111C, 0x00272A08,
    0x00151810, 0x001B2000, 0x002C081F, 0x00202205, 0x000A281D,
    0x00231706, 0x00022019, 0x000D1123, 0x00262F06, 0x0013031F,
    0x00282907, 0x000E2324, 0x0005141A, 0x00262A07, 0x001F0625,
    0x002C1305, 0x0013290E, 0x0001191C, 0x00213109, 0x00121119,
    0x00251E07, 0x000F192C, 0x002B2B05, 0x0017220C, 0x002F1024,
    0x00032613, 0x00161706, 0x0027300E, 0x000E121D, 0x00042B31,
    0x002D160F, 0x0009261F, 0x00210813, 0x00042A25, 0x001F1405,
    0x002F2F10, 0x000C1126, 0x00281708, 0x000A2716, 0x00250D2E,
    0x00061627, 0x000F2518, 0x00280B2D, 0x00141E07, 0x0031051A,
    0x000D182F, 

    0x001A011B, 0x00043122, 0x001F1404, 0x00022620, 0x001D2B0D,         // 53
    0x00270A15, 0x0005141B, 0x000F2C11, 0x00320B1F, 0x00162E01,
    0x001E0D2F, 0x00130823, 0x000B1F1B, 0x00311127, 0x00102611,
    0x00160421, 0x002B210D, 0x001A3109, 0x00130F1D, 0x001F1A02,
    0x000D211B, 0x00210B2B, 0x00132404, 0x0023031C, 0x000D1A2D,
    0x00322E09, 0x0024012B, 0x0013260D, 0x002F0D16, 0x001E1D0B,
    0x00152A04, 0x00300931, 0x000F3114, 0x00271409, 0x0015250F,
    0x0004112A, 0x000E2317, 0x002D2C04, 0x00061C28, 0x00112813,
    0x00031224, 0x000B1A18, 0x001F0B32, 0x00121E0F, 0x001D0428,
    0x000B2E18, 0x00041123, 0x000F2B30, 0x0017130C, 0x0030042B,
    0x00140A21, 0x00282A0D, 0x001C062E, 0x00062215, 0x00200B2A,
    0x00081A13, 0x001C0630, 0x00222E0B, 0x00160A2C, 0x00071D13,
    0x000F2F2F, 0x00240422, 0x002F2003, 0x001B0B30, 0x00062520,
    0x001D0527, 0x00012F12, 0x00270B1D, 0x00071629, 0x000D1C16,
    0x00230D1F, 0x00092030, 0x00310825, 0x00200016, 0x00171E0B,
    0x00290B24, 0x001C3002, 0x000F1A29, 0x00260C16, 0x00140420,
    0x0007212D, 0x00120B1C, 0x002D2B0F, 0x001C0620, 0x00152D0C,
    0x002E1F06, 0x0023011E, 0x00021326, 0x001F2A0D, 0x00052F23,
    0x0029140A, 

    0x000C2915, 0x00300931, 0x00141B0A, 0x002A062C, 0x00171800,         // 54
    0x0011212A, 0x00222909, 0x001E072E, 0x000A2114, 0x00250428,
    0x000D1B17, 0x00283005, 0x0018140D, 0x00012830, 0x00210816,
    0x00272D03, 0x000C112C, 0x00021824, 0x002D0217, 0x00072926,
    0x0028140D, 0x000A2712, 0x002E0F27, 0x0016310B, 0x00071F23,
    0x001D0B17, 0x000B1720, 0x001B2C00, 0x0026072F, 0x000C1426,
    0x0004251B, 0x00210F29, 0x00191901, 0x000A282E, 0x001D051E,
    0x002C2E02, 0x00081731, 0x001E0321, 0x00170B19, 0x00272407,
    0x0032072E, 0x00152104, 0x0025290B, 0x00051523, 0x002A2206,
    0x002F092E, 0x00211C0A, 0x00270216, 0x00012526, 0x000C1E13,
    0x001E3109, 0x00071427, 0x002F1C00, 0x00170F1E, 0x002C260B,
    0x00113003, 0x002F101F, 0x00001917, 0x00292701, 0x00320E1B,
    0x001D170A, 0x00092318, 0x00160829, 0x000E1413, 0x00292B0C,
    0x002E1701, 0x00160F17, 0x0021032E, 0x0013260E, 0x001D3103,
    0x002D022B, 0x00112D10, 0x001B1500, 0x0006252A, 0x00252C07,
    0x0013052C, 0x0002131C, 0x00322309, 0x00092E32, 0x001B1803,
    0x002B290B, 0x00190029, 0x00211D04, 0x00021331, 0x000E191A,
    0x001A082B, 0x000B3113, 0x002B1C04, 0x00190717, 0x00120D2C,
    0x00232301, 

    0x0007111E, 0x0025200E, 0x000A2C27, 0x00210E1A, 0x000D3013,         // 55
    0x0030031D, 0x00180E26, 0x002C1D04, 0x00001622, 0x001A2708,
    0x002E1011, 0x0004222C, 0x0023031E, 0x002C1809, 0x001A0D22,
    0x00061C1A, 0x00302407, 0x001C2B0F, 0x00230A2A, 0x00121C06,
    0x00180532, 0x00042D21, 0x001C0817, 0x000F152F, 0x002D0613,
    0x00272A04, 0x00031C28, 0x002B1011, 0x0007201E, 0x00172F06,
    0x00280016, 0x00102111, 0x002E0620, 0x00051D19, 0x00290C25,
    0x00101F15, 0x00240F12, 0x0030300A, 0x000A192C, 0x0021130E,
    0x000E2E1D, 0x001A0F12, 0x002D011F, 0x000F312C, 0x00180E12,
    0x0006281D, 0x00131603, 0x001C300F, 0x002A0F1B, 0x00191902,
    0x002C0C2F, 0x0010271A, 0x00220412, 0x000B2C32, 0x00031718,
    0x0024002B, 0x0014210F, 0x001A0825, 0x000B222A, 0x00130220,
    0x00022A27, 0x002B0F11, 0x001F3007, 0x00031B24, 0x0022022D,
    0x0008221C, 0x000C2925, 0x00321F06, 0x00031322, 0x0029081B,
    0x00171A08, 0x00022318, 0x002A0B1D, 0x000D1B21, 0x002E1013,
    0x000B1918, 0x0022200D, 0x00160123, 0x00280F12, 0x000D1E1E,
    0x0024120F, 0x00052517, 0x00103224, 0x00310D12, 0x00272301,
    0x00052922, 0x00210F11, 0x00102432, 0x0008161D, 0x002E1F0F,
    0x001D062A, 

    0x00103026, 0x002C1604, 0x001B0217, 0x00061E22, 0x00241408,         // 56
    0x00032730, 0x00091A18, 0x00122E0F, 0x0024011C, 0x00102C32,
    0x00081A18, 0x001D0C25, 0x00112B00, 0x00081E2A, 0x000E3212,
    0x00140127, 0x00220B30, 0x0010131D, 0x00092213, 0x0032300C,
    0x001E101C, 0x002B1E01, 0x00241909, 0x0001221E, 0x00202607,
    0x00110F1B, 0x00180831, 0x000F2515, 0x00220523, 0x0031180A,
    0x001D0C2D, 0x00012924, 0x00232F06, 0x00131110, 0x00202C0B,
    0x0019012C, 0x0000241C, 0x00120927, 0x001A1F00, 0x00052A17,
    0x002B0425, 0x00011C29, 0x00092616, 0x001E1901, 0x00230519,
    0x000D1F2A, 0x002D0B22, 0x00092131, 0x00110620, 0x00072D2A,
    0x00240117, 0x00022023, 0x00131908, 0x002B0A20, 0x001C1F0C,
    0x000D1226, 0x002A2B06, 0x00061614, 0x00213209, 0x0025120F,
    0x00171F05, 0x00270631, 0x0010251C, 0x00300D15, 0x00182D09,
    0x00121210, 0x00250731, 0x001A180A, 0x00102C14, 0x00200E2F,
    0x000B2824, 0x0026120E, 0x0015062E, 0x001F3205, 0x00042825,
    0x001A0A2F, 0x002D2D04, 0x0006272B, 0x001F0819, 0x00012C28,
    0x002F0B22, 0x00161906, 0x0023072D, 0x00092A1E, 0x001E0228,
    0x002B0B16, 0x00141A08, 0x00310428, 0x00262D03, 0x00032721,
    0x00171A08, 

    0x00200C13, 0x0000252F, 0x00122A0A, 0x002E082C, 0x00152310,         // 57
    0x00281105, 0x00200623, 0x002B230C, 0x00160C27, 0x00301303,
    0x0022051F, 0x0016250C, 0x00310715, 0x0025101B, 0x001F2606,
    0x002E160B, 0x00031F16, 0x00192901, 0x00280422, 0x0002162E,
    0x000D2518, 0x00140026, 0x000B2A2B, 0x0029120E, 0x001A042D,
    0x00052C24, 0x002E1E0A, 0x001F3205, 0x0005122B, 0x00122B10,
    0x000B1F1D, 0x002D130C, 0x00170727, 0x00091832, 0x00322707,
    0x000C1421, 0x002B1A05, 0x00222911, 0x00290620, 0x00110C31,
    0x001F2304, 0x0026150C, 0x0013082F, 0x00312B0E, 0x00041327,
    0x00282E09, 0x00190315, 0x0022290C, 0x00321404, 0x001D2210,
    0x00161207, 0x00302A0E, 0x00200D28, 0x00173104, 0x0026072D,
    0x0005281A, 0x001F0520, 0x00300D30, 0x000F1C19, 0x002D072D,
    0x000C2E16, 0x00061920, 0x001C1500, 0x000A2029, 0x002A0A22,
    0x001F1D03, 0x0004321F, 0x002C0C19, 0x000A212A, 0x002F0411,
    0x001C1604, 0x00062C29, 0x00301F0A, 0x00111710, 0x002A021B,
    0x00131E0A, 0x001E1120, 0x000F1613, 0x002C1C02, 0x00132409,
    0x001C042F, 0x0007211B, 0x002C130B, 0x00121E0F, 0x00181607,
    0x000B202E, 0x00012F1F, 0x001A1019, 0x001F0814, 0x000D132F,
    0x002A0218, 

    0x0031210C, 0x0019061C, 0x00271027, 0x001F1902, 0x000B2D1E,         // 58
    0x001A0B2A, 0x000F3214, 0x0006152C, 0x001C2809, 0x00052012,
    0x000B3029, 0x00271D07, 0x00011530, 0x000C2E21, 0x00170A2C,
    0x00270626, 0x000A2F1F, 0x002C0E2C, 0x00131B09, 0x00200827,
    0x00262D04, 0x002F0B11, 0x00170F15, 0x00083022, 0x00311B02,
    0x0014140F, 0x00260120, 0x000D161A, 0x002C0927, 0x001A2303,
    0x00280330, 0x00071B18, 0x001C2501, 0x00260D1E, 0x00031F15,
    0x0016062A, 0x001C2E0D, 0x0006122E, 0x000B181A, 0x00303109,
    0x00161111, 0x000C2D23, 0x002A2107, 0x00170E1C, 0x00101B21,
    0x001D2505, 0x0006172D, 0x00151018, 0x00001C29, 0x000C2C25,
    0x0027071E, 0x00051630, 0x000E2419, 0x00081C14, 0x002F1410,
    0x00112201, 0x00161A0B, 0x00082C24, 0x001C2502, 0x0004131E,
    0x00192708, 0x00220126, 0x002C2C0E, 0x00150619, 0x0001272C,
    0x000D1714, 0x00270127, 0x0013280E, 0x00221B01, 0x00013020,
    0x00102417, 0x0023011C, 0x00190D22, 0x0008262F, 0x00221201,
    0x00002429, 0x00260615, 0x000A3131, 0x00190323, 0x0024130E,
    0x000D3015, 0x00282800, 0x001F102A, 0x00032F18, 0x00300924,
    0x001C2B02, 0x0029140D, 0x00072225, 0x0013290F, 0x00251E06,
    0x00092E24, 

    0x00141B03, 0x00051421, 0x000F3116, 0x00081E12, 0x002C0325,         // 59
    0x00011719, 0x00321F01, 0x0025021D, 0x000E1B21, 0x0020082E,
    0x002D0F15, 0x00120124, 0x001C2910, 0x002A1B03, 0x00042117,
    0x0012180F, 0x001D2404, 0x00240213, 0x00052B1A, 0x001B210D,
    0x000A1320, 0x00051B30, 0x00222005, 0x001D0719, 0x000E2428,
    0x00230B17, 0x0009212F, 0x0017270C, 0x00001B14, 0x00210D1F,
    0x00153009, 0x00231013, 0x000E2A2C, 0x002E0211, 0x00113226,
    0x00200B19, 0x002D2002, 0x00130324, 0x0021240E, 0x00021C2B,
    0x001C001E, 0x00061918, 0x00210629, 0x00022714, 0x00250431,
    0x002F0B12, 0x000F2024, 0x002B320B, 0x0023081B, 0x002D0E13,
    0x00131B0A, 0x001B2E02, 0x002C032B, 0x001E0B22, 0x00012E1D,
    0x0022022F, 0x002C1117, 0x00250A12, 0x00140329, 0x0028200E,
    0x00310A2B, 0x00121013, 0x00071E2F, 0x00251309, 0x001D2F05,
    0x00300F1D, 0x0017210B, 0x0007132D, 0x001B0524, 0x00270F13,
    0x00150831, 0x002B1D07, 0x000E2F13, 0x00280917, 0x000C2A26,
    0x0031180E, 0x00170C1D, 0x00292806, 0x00071F1A, 0x00300D2C,
    0x00041820, 0x00180A26, 0x000A1B13, 0x00250431, 0x000D271D,
    0x00220E14, 0x0011002F, 0x00201B09, 0x002E0A2A, 0x0003171E,
    0x001C0D2C, 

    0x0022260E, 0x00260130, 0x002F2306, 0x00160D2E, 0x00232B0D,         // 60
    0x00132608, 0x001E0D31, 0x00172A0E, 0x002C1207, 0x00022E1A,
    0x00192402, 0x000D191C, 0x002F110D, 0x0015052D, 0x00210E1E,
    0x002F2C09, 0x00071332, 0x000D1D22, 0x0031102A, 0x00160915,
    0x002B2608, 0x00102F24, 0x002D031D, 0x0002292E, 0x00281709,
    0x00062D13, 0x001E0E29, 0x002F2F01, 0x00290525, 0x00102819,
    0x00051729, 0x002B0622, 0x0002221C, 0x00191406, 0x00241A0B,
    0x0007272E, 0x000D161D, 0x00270E16, 0x00192B04, 0x002C0A27,
    0x00242806, 0x00110C2E, 0x00301F02, 0x001B310A, 0x0008121A,
    0x00212C03, 0x000A141E, 0x001A002C, 0x00122304, 0x0004282F,
    0x00200520, 0x000A1F18, 0x0015120F, 0x00292605, 0x000D1729,
    0x00192907, 0x000A1D26, 0x0003311F, 0x001F1705, 0x000B2B1A,
    0x00011A22, 0x001B3004, 0x000E231C, 0x002E0524, 0x00111A11,
    0x00062432, 0x00210917, 0x002A2E08, 0x000C181A, 0x002E2005,
    0x000A2728, 0x001E130B, 0x0002192B, 0x00201F04, 0x0013051F,
    0x001B2E08, 0x00051C2C, 0x0011140F, 0x00200728, 0x00142B07,
    0x001D260B, 0x002E011C, 0x00112D0F, 0x002B2305, 0x0016170A,
    0x00051F27, 0x002F081A, 0x000C2521, 0x00183000, 0x00280412,
    0x000E2B17, 

    0x00061225, 0x00192D0A, 0x000C171F, 0x00200817, 0x00051328,         // 61
    0x002A0622, 0x00071913, 0x000B2125, 0x0013052B, 0x00231610,
    0x00290A28, 0x00082B31, 0x00222008, 0x00063127, 0x000C2513,
    0x00180324, 0x00280A18, 0x0015310C, 0x00222302, 0x0000171C,
    0x001E062D, 0x00260E13, 0x001A190B, 0x00121310, 0x00160825,
    0x002C1F04, 0x001A021E, 0x00121410, 0x00081D31, 0x001D1106,
    0x0031200F, 0x00132D03, 0x001F0930, 0x00092B17, 0x00290721,
    0x00171012, 0x00302208, 0x00043031, 0x00110622, 0x00081F1B,
    0x000D1514, 0x00292E0D, 0x0016101D, 0x000D1726, 0x002B1D0E,
    0x00130929, 0x00042916, 0x00281E08, 0x001E180F, 0x00091227,
    0x0026300C, 0x00310C2C, 0x00032B26, 0x00241C0A, 0x00130615,
    0x0031091A, 0x0026220E, 0x0010122D, 0x002E250A, 0x00180D31,
    0x00240416, 0x002B140D, 0x001F092A, 0x00032A15, 0x00190C20,
    0x002B0228, 0x00132902, 0x00021C21, 0x001F0C2F, 0x00182D0E,
    0x0005111F, 0x00312B10, 0x00160324, 0x002A0E18, 0x00072332,
    0x00210F12, 0x00250022, 0x002D2D04, 0x00022214, 0x002A1018,
    0x000C1D30, 0x00231503, 0x00002029, 0x001E0C22, 0x0008122D,
    0x00253110, 0x001B2806, 0x00021515, 0x00231031, 0x0008211C,
    0x002F0929, 

    0x00151F03, 0x002B051B, 0x00011B2B, 0x002D2F01, 0x001B1E0C,         // 62
    0x000E241D, 0x00273006, 0x00200B18, 0x00302C04, 0x0006251E,
    0x00161E0A, 0x001E0216, 0x00101422, 0x0025081A, 0x002C1901,
    0x00021E29, 0x00202806, 0x0010161F, 0x002C012F, 0x00092E25,
    0x00142904, 0x000C1F19, 0x00072529, 0x00323106, 0x00240F21,
    0x000E2A2F, 0x00031819, 0x0022250A, 0x00260822, 0x000D2F17,
    0x001A012B, 0x0026150C, 0x000E1C14, 0x002D0E27, 0x00131F04,
    0x0001292B, 0x00220225, 0x001C1B0C, 0x00261210, 0x002F2A0A,
    0x001B0430, 0x00012325, 0x00230716, 0x0006262D, 0x001D0221,
    0x00272309, 0x00170F30, 0x00300724, 0x000E2C1F, 0x002B0417,
    0x00182201, 0x0010191B, 0x001A0113, 0x0008211F, 0x001F1032,
    0x00062C24, 0x00151900, 0x001B0014, 0x00290821, 0x000E1F11,
    0x00062E27, 0x00132702, 0x000B1D2E, 0x0028160A, 0x00223106,
    0x000C201A, 0x001C1110, 0x0032062A, 0x000E2413, 0x00250026,
    0x00121B01, 0x0022082E, 0x000B251B, 0x001A3106, 0x002E130A,
    0x000F2727, 0x00081E1A, 0x0019092E, 0x000D1820, 0x00240325,
    0x00073212, 0x00140F1F, 0x00290617, 0x00182909, 0x0030021E,
    0x00121B0C, 0x002C0D2B, 0x00150522, 0x002A1A0D, 0x00112707,
    0x001F1710, 

    0x00280B23, 0x00102A14, 0x001E1011, 0x000A2721, 0x00130A30,         // 63
    0x00300F16, 0x0018002D, 0x00011427, 0x001B1C0D, 0x0011102E,
    0x002B0C25, 0x00002F12, 0x00312606, 0x001A0D2A, 0x00132D0B,
    0x001D1310, 0x0030062C, 0x00042016, 0x001B0D12, 0x00281B09,
    0x0021130E, 0x002E0A22, 0x001D0132, 0x00031C1C, 0x00200516,
    0x000A2112, 0x00301028, 0x00142C06, 0x00061F2D, 0x002A0F13,
    0x00012425, 0x00160C1E, 0x0008272C, 0x00213109, 0x001B041D,
    0x000D1618, 0x002B2E00, 0x0014091F, 0x0006242D, 0x00171802,
    0x00210F21, 0x00131A09, 0x002D2C05, 0x00190D12, 0x002F2A00,
    0x0003191C, 0x00103011, 0x00221603, 0x00022513, 0x00150C31,
    0x00061525, 0x00212909, 0x0028092E, 0x002E3203, 0x00101511,
    0x002A2709, 0x00220C2B, 0x00002F1C, 0x00092A29, 0x001F1708,
    0x0032111B, 0x001A0A22, 0x002C0113, 0x0005251E, 0x00151026,
    0x0008182E, 0x00272B0C, 0x00151504, 0x00082F1D, 0x002D0E18,
    0x001B290A, 0x00032015, 0x00270B23, 0x00111C11, 0x0001172D,
    0x00280615, 0x001E3000, 0x002F1210, 0x00152A0B, 0x001C2402,
    0x0032082C, 0x001F2807, 0x00061C2E, 0x000B2E12, 0x00211601,
    0x00032427, 0x000D2C18, 0x001F1F04, 0x000B2A26, 0x001A011F,
    0x0004322E, 

    0x00092317, 0x00220732, 0x00162104, 0x00280227, 0x001F1608,         // 64
    0x00042C11, 0x00242002, 0x000F261F, 0x002E0414, 0x000A291A,
    0x00231600, 0x0017082C, 0x000D181C, 0x00042014, 0x002A002F,
    0x0008291F, 0x000E111A, 0x00252C04, 0x000C2627, 0x0017041D,
    0x0005212B, 0x000F2B13, 0x00291603, 0x0018280B, 0x00130C2B,
    0x00272F01, 0x0019160D, 0x001F0420, 0x002D0B1C, 0x00121903,
    0x00222A08, 0x002E0418, 0x00281802, 0x00041223, 0x00312410,
    0x00250B30, 0x00081E15, 0x001F0F11, 0x000F2C28, 0x002A011B,
    0x000A3012, 0x0004212B, 0x0026041E, 0x00101531, 0x000B1F18,
    0x00240526, 0x001B0B2D, 0x00081D1A, 0x00270628, 0x001D2F05,
    0x00301E0D, 0x000F1121, 0x000A2416, 0x00160D2A, 0x00031D1A,
    0x001A0322, 0x000D1F17, 0x0030130C, 0x00241C03, 0x0015052F,
    0x00042415, 0x00261B06, 0x00102D28, 0x00190D11, 0x00252200,
    0x002F0314, 0x00001E23, 0x00210A30, 0x001A200D, 0x00061927,
    0x00290531, 0x000F161E, 0x002F2C03, 0x001D0328, 0x00232A0C,
    0x00140D1C, 0x000C1923, 0x00032130, 0x002A0C18, 0x00061627,
    0x000E1E1B, 0x0017130D, 0x002E0A24, 0x00102118, 0x002A1032,
    0x001C0514, 0x00260B1D, 0x0007172F, 0x002D0813, 0x00230F19,
    0x00321409, 

    0x00192D0E, 0x00021224, 0x002F1A0C, 0x00072F1C, 0x00101F18,         // 65
    0x002B1024, 0x00091929, 0x0016320A, 0x0027092F, 0x001E2108,
    0x00052D23, 0x002D1F0C, 0x00260520, 0x00203003, 0x00110F24,
    0x00232307, 0x00191C0C, 0x002B0922, 0x0007182D, 0x00313200,
    0x00230F16, 0x00150720, 0x00082E26, 0x00241210, 0x00061E1F,
    0x002D0625, 0x00012830, 0x000E1C13, 0x000A3129, 0x001B2210,
    0x00071232, 0x000D2E26, 0x001C1F0E, 0x0011082E, 0x00152C0B,
    0x000B1826, 0x00192808, 0x002F0623, 0x00041F17, 0x00231407,
    0x00320825, 0x001E0C19, 0x00171B0C, 0x00062F28, 0x002A0E14,
    0x00132C08, 0x0031140E, 0x000D2222, 0x002C2A08, 0x00120E1D,
    0x0025022E, 0x00012E12, 0x002C1A04, 0x001E0425, 0x00262E0E,
    0x002B1805, 0x0008242E, 0x00170925, 0x00102812, 0x00290D1F,
    0x000D3026, 0x001E130E, 0x00081F31, 0x002E0618, 0x000E2C2B,
    0x001D0C1C, 0x00113007, 0x002C0617, 0x000F261F, 0x00241303,
    0x00163108, 0x00200E12, 0x0009232B, 0x0017110F, 0x00051F21,
    0x00312605, 0x001A0229, 0x00262808, 0x0012061F, 0x00202C06,
    0x002C0315, 0x00033029, 0x00251905, 0x001A0020, 0x00042525,
    0x0014300E, 0x002E1306, 0x0017210B, 0x00002F28, 0x00122501,
    0x000D1D2C, 

    0x002B1806, 0x0025041E, 0x000B272A, 0x00190C13, 0x0023042D,         // 66
    0x00132905, 0x001C071B, 0x002C0D15, 0x00031321, 0x00131A10,
    0x001A0129, 0x000F1119, 0x00072730, 0x00171B0F, 0x002D0A17,
    0x00011728, 0x00102F31, 0x001F0211, 0x00130D18, 0x001D240A,
    0x00011430, 0x002D1B0C, 0x001C2207, 0x002C022E, 0x000D1817,
    0x001E2309, 0x00160E1A, 0x00231404, 0x00270118, 0x00320922,
    0x0017170C, 0x0025061C, 0x00022815, 0x00290F1F, 0x00202104,
    0x002C0419, 0x0002122C, 0x00263103, 0x00101A30, 0x0018290C,
    0x000C232E, 0x00142B01, 0x002C1110, 0x00202705, 0x001A0020,
    0x00001A2C, 0x001F2602, 0x00170315, 0x0003122A, 0x001B190F,
    0x000B2717, 0x00200829, 0x0011221C, 0x00191208, 0x00062830,
    0x0013061E, 0x001F1014, 0x002D3109, 0x001D012D, 0x00022217,
    0x002F1801, 0x0017081C, 0x00232707, 0x00021720, 0x0020120F,
    0x00092726, 0x0017190B, 0x00271029, 0x00052A12, 0x0030022C,
    0x000D221B, 0x00011B23, 0x002C0717, 0x00253009, 0x000F1531,
    0x002A0918, 0x00072E13, 0x0022130D, 0x000A1A2B, 0x0019200F,
    0x00270D30, 0x000B231E, 0x00121111, 0x00222C0C, 0x00311502,
    0x00091D2B, 0x000F281F, 0x00210923, 0x001B1910, 0x0027021B,
    0x001F0D22, 

    0x0014092F, 0x000F3118, 0x001D1E00, 0x002C1509, 0x00002E1F,         // 67
    0x0032230F, 0x00061731, 0x00211F07, 0x000C2E2B, 0x00252903,
    0x00300B16, 0x001F240B, 0x00281406, 0x000B2A27, 0x001C031C,
    0x00262501, 0x002F1014, 0x0004201E, 0x002A2B06, 0x000F1C25,
    0x0027031B, 0x000A2C12, 0x00120D2A, 0x0002271C, 0x00223103,
    0x00110A23, 0x002F2C0E, 0x00081F2D, 0x00142709, 0x00022D2B,
    0x00202300, 0x0012102C, 0x002F1906, 0x00180029, 0x00062F13,
    0x000F1B21, 0x001C250E, 0x00140D1D, 0x002B0212, 0x001D1020,
    0x00011815, 0x0028041F, 0x00081E2C, 0x000E1525, 0x002E230B,
    0x0026081D, 0x00083218, 0x002B0C2F, 0x00242D0B, 0x00072025,
    0x002F1500, 0x00140C23, 0x00292C0D, 0x000A172B, 0x00310D18,
    0x00222001, 0x00032B23, 0x000B151B, 0x00271E06, 0x00091128,
    0x00212A0B, 0x0011032C, 0x002A0E24, 0x0014320B, 0x00281C03,
    0x00310130, 0x0003241A, 0x001C1404, 0x000A1D22, 0x001E0A16,
    0x00182C0C, 0x00230C2F, 0x00122704, 0x001B0125, 0x000A1D1D,
    0x001E2401, 0x00150E2E, 0x000E1E25, 0x0030071A, 0x00002F22,
    0x00131501, 0x001E2909, 0x002D062E, 0x00081F1C, 0x00170827,
    0x001D0E12, 0x00250419, 0x000C2D2D, 0x002F1107, 0x0004262A,
    0x000A2B14, 

    0x0031160A, 0x00032428, 0x00290E14, 0x0015072E, 0x000C1B25,         // 68
    0x00261103, 0x00180122, 0x00112610, 0x002E061A, 0x00161026,
    0x000A1C1F, 0x0001312D, 0x00150721, 0x00320D13, 0x00061E2C,
    0x00132D09, 0x00091523, 0x001A0729, 0x0022120D, 0x0007262C,
    0x00190B21, 0x00201F03, 0x00310624, 0x00171115, 0x002A150D,
    0x001B0431, 0x0004191D, 0x00290825, 0x001E0F15, 0x000D1B1E,
    0x002A0B12, 0x00083222, 0x001D1F0D, 0x000C2A1A, 0x00240D2E,
    0x00301401, 0x00210826, 0x000B1F15, 0x00072C2A, 0x00222604,
    0x002E0A27, 0x00123109, 0x0024091A, 0x00042D14, 0x00110E30,
    0x00171F0F, 0x000C1328, 0x00141D08, 0x001F0820, 0x0010291A,
    0x00260332, 0x001B1B07, 0x00041F15, 0x00250121, 0x000D2A12,
    0x00190827, 0x002B1A0D, 0x00110D2A, 0x0016260F, 0x001B0622,
    0x002B1C11, 0x00062D1A, 0x000A2315, 0x001C0A29, 0x000D2113,
    0x00190F20, 0x00122B0F, 0x002B052D, 0x00253009, 0x0010182A,
    0x00281201, 0x0007201F, 0x002F1810, 0x0003112D, 0x00272C0D,
    0x002D0515, 0x0004171F, 0x00292A0B, 0x00172304, 0x00230B13,
    0x002E0128, 0x00061C18, 0x00190D23, 0x000E2814, 0x00272E08,
    0x00011B2F, 0x002B2304, 0x00061516, 0x00151F0D, 0x0029061F,
    0x001C1E03, 

    0x00181210, 0x00240021, 0x00072C1B, 0x0020220D, 0x00102919,         // 69
    0x001E0914, 0x00093028, 0x00281B0C, 0x0002142D, 0x001D2209,
    0x002B0412, 0x00221702, 0x00102119, 0x00242C05, 0x0019120D,
    0x00210430, 0x00282310, 0x000C2F19, 0x00301902, 0x00140515,
    0x00293108, 0x000E1718, 0x00082D2F, 0x00261C06, 0x00062A29,
    0x000C2018, 0x00242501, 0x0018300F, 0x00121605, 0x002D0227,
    0x00042718, 0x00270430, 0x00141507, 0x002D0924, 0x00091E11,
    0x0016270A, 0x00032E30, 0x00261806, 0x0031061B, 0x0015150B,
    0x000A2132, 0x00181B0F, 0x001E2803, 0x00310321, 0x001B1909,
    0x00222B01, 0x002D0223, 0x00042614, 0x00321804, 0x00190F11,
    0x000E2F13, 0x0009251E, 0x002D0E2E, 0x001E3103, 0x0015190B,
    0x00062331, 0x00240219, 0x001D2D04, 0x0031092F, 0x0004301E,
    0x00131402, 0x001F1032, 0x00301706, 0x0025041D, 0x00072D2D,
    0x002C0916, 0x00221908, 0x00062025, 0x00160817, 0x0002241E,
    0x002D0314, 0x000B3126, 0x001E081A, 0x0014290B, 0x00101B21,
    0x00190B29, 0x00233107, 0x0011022C, 0x001E1017, 0x00052632,
    0x000D191E, 0x0029320C, 0x00212205, 0x0003162B, 0x002F031A,
    0x00140F21, 0x0020310A, 0x00190A26, 0x00102A31, 0x00220E19,
    0x00082E25, 

    0x0012280B, 0x000B1B31, 0x001B1302, 0x00300529, 0x00281708,         // 70
    0x0004202F, 0x002F0F1D, 0x00152A01, 0x00220B17, 0x000E2824,
    0x00052C1D, 0x00170D32, 0x0029012A, 0x000C1923, 0x00022718,
    0x002C091E, 0x00111C04, 0x00180D2B, 0x00002920, 0x001E0F32,
    0x00052327, 0x002C120F, 0x001C081F, 0x0013250A, 0x00200021,
    0x002B0C12, 0x000F122C, 0x00300620, 0x00062130, 0x00232C0D,
    0x001B1D06, 0x000F111E, 0x00212C0F, 0x00012529, 0x001E0518,
    0x00280F21, 0x0012021C, 0x001A230D, 0x000E112C, 0x00052F21,
    0x001C0116, 0x002B0F1D, 0x0002132D, 0x000D2127, 0x00290B17,
    0x0008242A, 0x001E101A, 0x000F3030, 0x00270622, 0x00011C2B,
    0x002B0926, 0x00211409, 0x00130629, 0x00022619, 0x00290F25,
    0x002F1307, 0x000F2713, 0x00001E1C, 0x0025170B, 0x000E2216,
    0x00280027, 0x00181F0D, 0x00032723, 0x00161A0A, 0x00201101,
    0x00012826, 0x000E131C, 0x001A2D03, 0x00320E2F, 0x0020290D,
    0x00141C06, 0x00191031, 0x00292308, 0x0023042B, 0x00311304,
    0x000C2412, 0x00021F1B, 0x002E150F, 0x000A1C23, 0x00272D08,
    0x001C1210, 0x0016062E, 0x00120A25, 0x00251310, 0x001C2700,
    0x00111929, 0x00072111, 0x0032011D, 0x00261601, 0x00011C13,
    0x002E042C, 

    0x00272104, 0x002D0916, 0x000F311F, 0x00012512, 0x00141024,         // 71
    0x001A2D06, 0x001F0311, 0x000A1821, 0x002C052F, 0x00131D05,
    0x0030130F, 0x001D2308, 0x00072F14, 0x002E1011, 0x000F2028,
    0x001E1608, 0x00062A26, 0x00240014, 0x002A210E, 0x0011170A,
    0x0023021C, 0x00172801, 0x00021E2C, 0x002E0E14, 0x00081926,
    0x00182E0C, 0x00001C1B, 0x00202908, 0x000B1319, 0x00150C29,
    0x00310716, 0x0009222C, 0x002B1802, 0x001A1015, 0x000E312F,
    0x002E1903, 0x00052C27, 0x002A0A17, 0x001F1D0F, 0x002D2500,
    0x00250C25, 0x000F2312, 0x00273005, 0x0016170D, 0x00052C1F,
    0x00130612, 0x00251E06, 0x0016150C, 0x000C2316, 0x001D2B02,
    0x00071F1B, 0x0018280F, 0x00301805, 0x000E1E13, 0x001B041D,
    0x00082E2A, 0x00200C21, 0x0018052C, 0x000A1224, 0x002E2A07,
    0x00210B2B, 0x000C2C13, 0x002D051B, 0x000F302A, 0x00292010,
    0x00130631, 0x002E1E0D, 0x00250122, 0x000A1A12, 0x000F1328,
    0x00260920, 0x00062E16, 0x000E1711, 0x00001D24, 0x00092F17,
    0x00210E30, 0x001B0725, 0x00252902, 0x0016051D, 0x00110D29,
    0x002C1F03, 0x00042A1A, 0x00312508, 0x000D1D1E, 0x00082F31,
    0x002C0714, 0x00240D18, 0x000B292B, 0x001C240A, 0x000E3023,
    0x001E0B18, 

    0x00032B2B, 0x00150F27, 0x001D1F09, 0x0025022E, 0x00091A1D,         // 72
    0x002A0816, 0x0011272A, 0x00052213, 0x0026310B, 0x001B1029,
    0x000B191A, 0x00260526, 0x00120920, 0x001A2903, 0x00250B2E,
    0x00152E0D, 0x0031081C, 0x000D132D, 0x00193006, 0x00091D24,
    0x00300C13, 0x000D2C2A, 0x0028061A, 0x00223005, 0x00101431,
    0x001E2703, 0x002D0A2A, 0x00120223, 0x00292F10, 0x00191901,
    0x00022622, 0x00262E0A, 0x00140825, 0x00051E1E, 0x0025120C,
    0x00132110, 0x00211508, 0x000B2929, 0x0016071F, 0x0000182E,
    0x00132C08, 0x00061C2A, 0x0020041A, 0x002E0830, 0x001C1C09,
    0x00300D2C, 0x00022925, 0x002A041D, 0x00210B2E, 0x002F120B,
    0x00110124, 0x00240C30, 0x000A3021, 0x0027082D, 0x00142A02,
    0x0024150F, 0x00121B09, 0x002C3000, 0x001D2510, 0x00150E18,
    0x00021C1E, 0x001C1603, 0x0024092F, 0x00061317, 0x001A0C21,
    0x001F2406, 0x00083118, 0x00140B2C, 0x001E240A, 0x00032C1B,
    0x002B2003, 0x001B012B, 0x002E0E1C, 0x001F2701, 0x0018091F,
    0x002C2B09, 0x00131A0E, 0x0007112D, 0x00313011, 0x00012216,
    0x001F032C, 0x000B1822, 0x001A0C13, 0x00280026, 0x0021110E,
    0x00182B06, 0x00051C24, 0x00141405, 0x002A082F, 0x0017110F,
    0x0009181E, 

    0x00201D0E, 0x002A061B, 0x00061613, 0x002E2904, 0x00212F0C,         // 73
    0x000C1D31, 0x002D1502, 0x00210E27, 0x0017091F, 0x00002016,
    0x002A2D01, 0x0006262E, 0x00211D0B, 0x00011819, 0x002A0322,
    0x00081E16, 0x00211900, 0x00032621, 0x002C0D18, 0x001F072F,
    0x0004251F, 0x001C1A08, 0x0014130E, 0x000B2223, 0x0032031D,
    0x00041F12, 0x00240F16, 0x001B2406, 0x00051D2F, 0x002E051D,
    0x00200F11, 0x00101632, 0x001E031A, 0x002F2907, 0x000C2428,
    0x001B0122, 0x00300D31, 0x00071A13, 0x00283205, 0x0021021B,
    0x0032140E, 0x001A0A22, 0x000B2B14, 0x00101120, 0x00232201,
    0x00093119, 0x000E1713, 0x001A2403, 0x000A2C27, 0x00041918,
    0x00172E10, 0x002B2308, 0x00011117, 0x001F190C, 0x00062025,
    0x00320A17, 0x00032330, 0x0027071A, 0x00071928, 0x0011032E,
    0x0028310A, 0x00092525, 0x00131E0D, 0x00312905, 0x000B1A13,
    0x002B0328, 0x0003151E, 0x00281C00, 0x002F1115, 0x00180530,
    0x0022150E, 0x00072A25, 0x0012220C, 0x0026062F, 0x00101414,
    0x0005202A, 0x00280019, 0x000C2621, 0x00211606, 0x00180826,
    0x00252C0E, 0x002B130A, 0x0007312F, 0x00142003, 0x0001171B,
    0x000F242C, 0x002F0320, 0x001F2D0D, 0x0002221A, 0x00300226,
    0x00252608, 

    0x00191300, 0x000B2D25, 0x0010222C, 0x00130A21, 0x00180D18,         // 74
    0x00021123, 0x001C2C09, 0x0012001B, 0x00302506, 0x000F1630,
    0x001E0213, 0x00150C1E, 0x00311210, 0x000B322A, 0x00142306,
    0x001D0F31, 0x00102C12, 0x00270529, 0x0016220C, 0x00122D02,
    0x0025140F, 0x002A0327, 0x0001282F, 0x00190D16, 0x00272B09,
    0x0015072D, 0x000A3220, 0x000F1728, 0x0026120C, 0x000D2815,
    0x00082027, 0x002A3105, 0x00180C13, 0x0007192D, 0x00270F11,
    0x00022F19, 0x00152703, 0x001E061D, 0x000E2225, 0x00181014,
    0x00092631, 0x00241F02, 0x002C180C, 0x00012728, 0x0018130F,
    0x002B0024, 0x001E0931, 0x002E1B0A, 0x00131020, 0x00262007,
    0x001E072C, 0x000F151E, 0x001A0928, 0x00292806, 0x0016001C,
    0x000C2D29, 0x001B1012, 0x000D2922, 0x0023130C, 0x00302104,
    0x00190820, 0x002C1111, 0x00220229, 0x00022E1D, 0x00250E2D,
    0x00182608, 0x00112C10, 0x001C0724, 0x00052729, 0x00123007,
    0x000C1E22, 0x002F0A13, 0x00171A08, 0x00093228, 0x00321806,
    0x00230B23, 0x001C2E02, 0x00121D0C, 0x002A0C31, 0x0009241F,
    0x00131B01, 0x000F271D, 0x001E0E17, 0x002E0629, 0x0023280B,
    0x00290A16, 0x001A0F12, 0x000A1929, 0x00231E02, 0x000D2F15,
    0x00120C32, 

    0x00041B20, 0x00320116, 0x00261206, 0x001D260F, 0x002F0329,         // 75
    0x000F2014, 0x0024270F, 0x0005192C, 0x0027300E, 0x00081222,
    0x002C2B08, 0x0010212C, 0x00192803, 0x00250626, 0x002E140B,
    0x0005281C, 0x002C0B26, 0x001A1507, 0x000C1B1D, 0x002E102B,
    0x000A1F17, 0x00173106, 0x002C081C, 0x00211D03, 0x00071926,
    0x001D120E, 0x002A2202, 0x0030041C, 0x00142D07, 0x001C0A2C,
    0x00230020, 0x00011B18, 0x000E2324, 0x002C2C00, 0x00200520,
    0x00101C15, 0x00230A2A, 0x002A120A, 0x00041E2D, 0x002E2B0B,
    0x00120818, 0x00043026, 0x001D021C, 0x00130D2D, 0x00282D06,
    0x00061E1F, 0x00112A17, 0x00220E11, 0x0000302B, 0x002C0214,
    0x000B291B, 0x00311E00, 0x00052F12, 0x00112232, 0x002E130E,
    0x00211804, 0x002A051D, 0x00171E07, 0x00022F26, 0x001E0D15,
    0x000E2B19, 0x00051931, 0x00172301, 0x001D0B15, 0x000E2023,
    0x002D130C, 0x00210932, 0x000B211A, 0x0024160C, 0x002A0D1E,
    0x00200317, 0x0001252C, 0x0029101F, 0x001C0218, 0x000F2911,
    0x0001231C, 0x00160F2E, 0x002F0514, 0x00052D1A, 0x001C120F,
    0x0030012B, 0x00220A11, 0x00062221, 0x00192C06, 0x000C1323,
    0x00041D2F, 0x0015320A, 0x002E071D, 0x0006122E, 0x001C0522,
    0x002C2910, 

    0x001F082B, 0x00163009, 0x00021E30, 0x000A181A, 0x00283201,         // 76
    0x0007142E, 0x002C0B1E, 0x00140625, 0x001A1E03, 0x00210819,
    0x000C1B24, 0x00230515, 0x0003171B, 0x001D0C12, 0x000E1C22,
    0x00160117, 0x0022210D, 0x00013115, 0x001F0330, 0x00062511,
    0x00220A25, 0x00111721, 0x00062313, 0x000E2E2C, 0x002E0B1F,
    0x00112A11, 0x00011A31, 0x001E0B17, 0x00071F25, 0x002B1810,
    0x00172A02, 0x0032130D, 0x001E062F, 0x0015110A, 0x000A202C,
    0x0031150C, 0x00062324, 0x00132F10, 0x001B1601, 0x00200521,
    0x00260E2B, 0x002A1605, 0x000E2312, 0x00301C09, 0x00200614,
    0x000C162B, 0x00272202, 0x0016041C, 0x000D2524, 0x001B1405,
    0x00240A2F, 0x00081A27, 0x001E0421, 0x00250E16, 0x00091D24,
    0x0001322B, 0x0013250A, 0x002F0930, 0x00101B13, 0x0029012B,
    0x00082622, 0x002B150E, 0x00122C09, 0x002F0426, 0x00081719,
    0x00153104, 0x00011D21, 0x00310014, 0x00152902, 0x00071A2F,
    0x001B2E06, 0x0014140D, 0x00232C01, 0x00061F32, 0x00210825,
    0x002D130A, 0x000B1B27, 0x001F2807, 0x000F1629, 0x00261F04,
    0x00002F24, 0x000D1915, 0x002B1031, 0x00131A0E, 0x0032021D,
    0x00202901, 0x00101527, 0x00252506, 0x00132C0E, 0x00291808,
    0x0009221C, 

    0x0011260D, 0x002B0F26, 0x0023091E, 0x001E290B, 0x00120524,         // 77
    0x00191B0D, 0x001F2C06, 0x00092415, 0x00321030, 0x00022811,
    0x00130E29, 0x002E300A, 0x000A1E32, 0x00272C07, 0x0006252B,
    0x00292E01, 0x000A182D, 0x00310821, 0x00142A05, 0x002B0D1B,
    0x001A2B03, 0x00300131, 0x00201209, 0x00150719, 0x0028160B,
    0x0018012A, 0x00232505, 0x000D2F1F, 0x0025110A, 0x0004262E,
    0x00110D1A, 0x000A1E28, 0x00253010, 0x0005261C, 0x001C0B17,
    0x00262A04, 0x0018031E, 0x002C0D2E, 0x000A2919, 0x00021B13,
    0x00162508, 0x00082E1D, 0x00190B24, 0x00062932, 0x001B0F1A,
    0x00023026, 0x0032120D, 0x001C0B2F, 0x00291909, 0x00052E19,
    0x0017220D, 0x00121210, 0x002A2C09, 0x0015081D, 0x001A2802,
    0x00280215, 0x001F0E20, 0x00051619, 0x00262D01, 0x0019130D,
    0x00141F05, 0x001F0F2A, 0x0026071E, 0x00031C2E, 0x0023290F,
    0x001C102A, 0x00280B11, 0x00102D2C, 0x001E1026, 0x002D0611,
    0x000F2224, 0x0030082A, 0x000C181E, 0x002B0D14, 0x00122704,
    0x00182F0E, 0x0028031F, 0x00042416, 0x002C0721, 0x00150B2D,
    0x001A290B, 0x001F041B, 0x00262602, 0x00043029, 0x001B0B18,
    0x000A2213, 0x002C0D21, 0x001D0217, 0x0000202B, 0x00180A25,
    0x00241404, 

    0x00031D19, 0x000C2C14, 0x00141503, 0x0006232C, 0x00301012,         // 78
    0x0001211B, 0x0029032A, 0x000E1622, 0x00252E09, 0x0017021F,
    0x001E2200, 0x0028140E, 0x001B0420, 0x00121127, 0x00300714,
    0x001F0B1E, 0x00191209, 0x00111F27, 0x00241A0C, 0x00031428,
    0x000D2116, 0x0016190E, 0x00002D29, 0x00241D01, 0x000B2924,
    0x0005201B, 0x00310F15, 0x00130628, 0x001A170E, 0x002E0223,
    0x001F2D07, 0x00290820, 0x00131604, 0x002E0129, 0x000E1C23,
    0x00002E30, 0x001F1808, 0x000D1F12, 0x00250920, 0x00310028,
    0x00101E2F, 0x001F1111, 0x002E0317, 0x00252000, 0x00110720,
    0x00231A11, 0x00142606, 0x00072A21, 0x00101F13, 0x002F0628,
    0x00200E1F, 0x002D2704, 0x0002172E, 0x000E2328, 0x0031110E,
    0x000A192D, 0x00182B0F, 0x000C2128, 0x0021041E, 0x000A282F,
    0x00320A1A, 0x00052412, 0x00103015, 0x00191203, 0x002D2108,
    0x0012031F, 0x00062517, 0x00231705, 0x000A241B, 0x00021D20,
    0x00260E14, 0x00052B1A, 0x00182309, 0x001E0423, 0x00021D29,
    0x00240E19, 0x0009172F, 0x00192C00, 0x0022110D, 0x00091C19,
    0x00312206, 0x00110D20, 0x00081525, 0x00161F0C, 0x0029062D,
    0x00231807, 0x00072F31, 0x000F1C11, 0x0031101B, 0x000D3013,
    0x002D0530, 

    0x00220D1F, 0x0018022D, 0x002D1A0F, 0x00250720, 0x000F2F17,         // 79
    0x00220A32, 0x00152A02, 0x001D1210, 0x00041D19, 0x002C0A2B,
    0x00081A16, 0x000F2B2D, 0x00002718, 0x00222004, 0x0014170E,
    0x000D232F, 0x00022A18, 0x002A0212, 0x0009281C, 0x001E072D,
    0x00263208, 0x002A0C23, 0x0009261D, 0x002E0414, 0x001A112F,
    0x002A2D09, 0x001E0911, 0x00031E30, 0x00272A00, 0x000F1C18,
    0x00072312, 0x001A1031, 0x00022116, 0x0021280D, 0x00281306,
    0x00150813, 0x002F1018, 0x00062726, 0x0013310D, 0x001B140A,
    0x002A2C03, 0x000B1825, 0x00002A2A, 0x0014140B, 0x002A2E0F,
    0x00091129, 0x002C012E, 0x0020091B, 0x00271501, 0x00032C31,
    0x00140216, 0x000C1C23, 0x00270918, 0x001F3006, 0x00051F1A,
    0x00230724, 0x002D2605, 0x00111209, 0x002A0D16, 0x00013125,
    0x001D1A09, 0x00240222, 0x002C0C28, 0x000B271C, 0x001F082F,
    0x000C1A24, 0x00302F09, 0x00180530, 0x002A1210, 0x001C3108,
    0x0016012E, 0x00211B03, 0x002A1210, 0x00083130, 0x002D140A,
    0x000E2613, 0x0030092B, 0x00122110, 0x00290126, 0x000E3230,
    0x00041713, 0x002A082C, 0x00212B10, 0x002F1205, 0x00012D1E,
    0x00131024, 0x0019270C, 0x00270629, 0x001F2A03, 0x00071923,
    0x001B280A, 

    0x00302201, 0x00073124, 0x001D1F08, 0x000A2828, 0x00191305,         // 80
    0x002C190C, 0x0006201E, 0x002F0C27, 0x00122607, 0x000B2F23,
    0x00211012, 0x0031081E, 0x00181309, 0x002C0025, 0x00052D1D,
    0x00261B02, 0x002E1028, 0x001B2E07, 0x00150E24, 0x00301E01,
    0x00051318, 0x0019052E, 0x00102011, 0x001E0B27, 0x00131B06,
    0x0007171E, 0x000E2422, 0x002C3107, 0x0009121D, 0x00160C2C,
    0x00230526, 0x002D2F09, 0x000C1A1B, 0x0018092E, 0x00083121,
    0x0010231C, 0x001D042B, 0x002A1A02, 0x00210B30, 0x0003231B,
    0x00180E14, 0x0022051F, 0x00282206, 0x001B082E, 0x000D271C,
    0x001E1E08, 0x00032417, 0x0017320E, 0x000A1C25, 0x001D1110,
    0x00252109, 0x00062E2A, 0x001C1013, 0x00160430, 0x002B160B,
    0x00130D1F, 0x00032E31, 0x001E1C11, 0x0015062B, 0x002D1F0F,
    0x00121506, 0x00082D31, 0x00171D0B, 0x00001717, 0x00272C0D,
    0x00161310, 0x00031F1C, 0x00200D26, 0x00122901, 0x000C1629,
    0x0032260C, 0x00110725, 0x000C2A1B, 0x00160C1F, 0x00232002,
    0x001C0522, 0x00062E1A, 0x00201B07, 0x0002141E, 0x001D2403,
    0x00240423, 0x00182708, 0x000B1A1A, 0x001B0027, 0x000E2414,
    0x001F1E03, 0x002E0916, 0x0003151F, 0x00162009, 0x002A012D,
    0x00131210, 

    0x000D1730, 0x00260918, 0x00120E13, 0x0029031B, 0x0003242D,         // 81
    0x001F0723, 0x000B3115, 0x0024012C, 0x0019180E, 0x00290631,
    0x00142204, 0x00051C28, 0x00273210, 0x000B2430, 0x00170E15,
    0x001D062C, 0x00081521, 0x000E2114, 0x00240432, 0x0012260F,
    0x000B1B20, 0x00222B0B, 0x00321503, 0x00022F1A, 0x0028280E,
    0x0024062C, 0x00150D16, 0x00210026, 0x001C1910, 0x002F270A,
    0x0003161F, 0x00142A03, 0x00290325, 0x001F0F11, 0x002E1601,
    0x00241C0C, 0x00042C23, 0x00171508, 0x000A2017, 0x002E0722,
    0x000E272D, 0x00051B11, 0x00103019, 0x002D0D15, 0x00061827,
    0x00310423, 0x00241603, 0x00120C20, 0x002E052C, 0x00192806,
    0x0031081E, 0x0012150E, 0x00292901, 0x000D2026, 0x00082B15,
    0x001B2303, 0x00300118, 0x00081722, 0x00272502, 0x000B2A20,
    0x001B091B, 0x002F1014, 0x00202300, 0x002A0426, 0x00130B2B,
    0x00232603, 0x002B012D, 0x00092213, 0x002D0922, 0x00061D19,
    0x00260F15, 0x0001212C, 0x001F1806, 0x002F0316, 0x0004282D,
    0x0013170D, 0x002A0D26, 0x0016280C, 0x002F0A2A, 0x00102C16,
    0x002D0E1C, 0x0013200D, 0x00062F32, 0x00280E11, 0x0024072B,
    0x0005171B, 0x000C2B2F, 0x00230F12, 0x00102628, 0x00250A17,
    0x00012C1D, 

    0x00200425, 0x0017250A, 0x00042A29, 0x00321702, 0x00172D0E,         // 82
    0x00131C07, 0x002B1012, 0x000F2518, 0x001E2C01, 0x0001141B,
    0x0024290B, 0x001C0421, 0x00111805, 0x001F091A, 0x002A1E08,
    0x00112F0F, 0x00222606, 0x00290A19, 0x0001171F, 0x001C3009,
    0x002C092B, 0x00170E15, 0x000D2330, 0x001F0221, 0x00081E29,
    0x00191302, 0x0030290C, 0x0001202F, 0x00112C05, 0x00260929,
    0x000D1E17, 0x0022120F, 0x0007202C, 0x000F2619, 0x00022A28,
    0x001A0132, 0x00320D15, 0x000F2811, 0x0028032B, 0x001B2F04,
    0x0026160A, 0x00300B23, 0x00160130, 0x00201D02, 0x00132A0B,
    0x00190F12, 0x000C2E31, 0x00281F0C, 0x00002B1C, 0x000E1916,
    0x00082428, 0x00200C2E, 0x00021B19, 0x002F0320, 0x00210A2B,
    0x0026190F, 0x000E1126, 0x00182F0A, 0x00210A2D, 0x00041317,
    0x00240027, 0x000D282C, 0x00051221, 0x0010321B, 0x001D1B09,
    0x00041120, 0x000F2E17, 0x00171806, 0x001D2B0B, 0x00220431,
    0x00142F0E, 0x001B0920, 0x00282C0A, 0x000A1D29, 0x001A1013,
    0x00242F05, 0x000B1F31, 0x00260614, 0x000D1321, 0x00191D09,
    0x0003182E, 0x00200925, 0x00321400, 0x00102820, 0x00161F07,
    0x0029300B, 0x001C0526, 0x00311B01, 0x00063221, 0x001B1405,
    0x002B1E0C, 

    0x00052F12, 0x002D1C06, 0x00231021, 0x000F2031, 0x00210A1E,         // 83
    0x00270427, 0x0009212F, 0x00051220, 0x00310925, 0x00101F2A,
    0x002C0C15, 0x00082D2E, 0x002F1111, 0x0002282B, 0x000A1420,
    0x00320225, 0x00041B2A, 0x00152B0D, 0x002F1102, 0x00081F28,
    0x0026001B, 0x00042A25, 0x002A1908, 0x00160A11, 0x002E0F15,
    0x000C2E1C, 0x00061621, 0x00280713, 0x00190E1A, 0x00072322,
    0x001C0231, 0x0031310B, 0x00170C22, 0x001D0715, 0x002B1309,
    0x00112205, 0x00082E1B, 0x00211027, 0x00011D1E, 0x0012130F,
    0x00082926, 0x001E2207, 0x000D2C13, 0x00251020, 0x0001212C,
    0x0029071D, 0x00062616, 0x001B0329, 0x00211404, 0x002A0E12,
    0x00160023, 0x002C2F09, 0x001A2605, 0x00141210, 0x0007321C,
    0x00152707, 0x00001E2F, 0x002B041D, 0x00101A12, 0x0031210B,
    0x00143004, 0x0028160F, 0x001A1F07, 0x002D0812, 0x00082A32,
    0x00301E0E, 0x001F062A, 0x00280C1C, 0x00021228, 0x000E241E,
    0x002E1605, 0x0007272B, 0x00131210, 0x002C071D, 0x000E2424,
    0x00310019, 0x0000151F, 0x001B2401, 0x0007312D, 0x002B0211,
    0x00242A06, 0x000C2413, 0x001D0417, 0x0000191C, 0x002D0B2D,
    0x00091322, 0x0012240F, 0x00170C19, 0x00210331, 0x000A2314,
    0x00130F2A, 

    0x001E0A1A, 0x000D152E, 0x001B0116, 0x00083011, 0x00001319,         // 84
    0x001C2A03, 0x002E1710, 0x00142D06, 0x00201A0D, 0x00170212,
    0x000C241E, 0x001A1B02, 0x00230326, 0x0016200E, 0x00262C03,
    0x00180F13, 0x001D081D, 0x000D202F, 0x00200523, 0x00192D10,
    0x00111605, 0x0021260E, 0x000A121E, 0x000F312C, 0x00232205,
    0x001C0532, 0x002A2408, 0x000F1D2A, 0x00222F01, 0x002D1510,
    0x00131A06, 0x0000271D, 0x00271702, 0x000A2C2A, 0x00211D10,
    0x00160B20, 0x0029062E, 0x001A1901, 0x002D250D, 0x00240830,
    0x00180E17, 0x0003192B, 0x002B061B, 0x000A1328, 0x002F3105,
    0x001F190E, 0x00140A24, 0x002D1B0A, 0x00103021, 0x00052330,
    0x001D1D0D, 0x000A161D, 0x00240725, 0x000C2232, 0x002D150B,
    0x00200621, 0x00280D15, 0x001C2C03, 0x0008272A, 0x00190C23,
    0x00011C2F, 0x001F061A, 0x00092529, 0x00140D25, 0x00250216,
    0x00191304, 0x000A2823, 0x0013210F, 0x00313102, 0x00081B13,
    0x00270126, 0x00190D17, 0x00251F00, 0x00053230, 0x00171806,
    0x001E0D11, 0x00102C2B, 0x002D1A0A, 0x001F0C17, 0x00101F28,
    0x00160820, 0x0029112B, 0x00083126, 0x0014220D, 0x001F2A05,
    0x00230115, 0x00032C2B, 0x002A1F06, 0x000D171D, 0x0026290A,
    0x00300622, 

    0x00092C28, 0x002A2100, 0x0014260C, 0x002F0B26, 0x00291B0B,         // 85
    0x000C2422, 0x00160C29, 0x0024051B, 0x00032731, 0x00292F04,
    0x0025102B, 0x00051518, 0x0012300A, 0x002B071C, 0x000E1931,
    0x00062618, 0x002D3105, 0x0027140A, 0x000A2416, 0x002B0D2D,
    0x00021C19, 0x00300731, 0x001B2000, 0x00270426, 0x00001B18,
    0x00132B0E, 0x00200C23, 0x00170116, 0x0003111E, 0x000C2A2E,
    0x00290626, 0x00210A12, 0x000E1F2F, 0x002E031B, 0x00031625,
    0x0026310B, 0x000D1F14, 0x00042A23, 0x00151407, 0x000E3213,
    0x0031021F, 0x00212D00, 0x00121F10, 0x001C2809, 0x00170218,
    0x0008242F, 0x00231301, 0x000B282B, 0x00180D11, 0x0026061A,
    0x002F2A02, 0x0011102C, 0x00032C14, 0x00280C18, 0x00181B01,
    0x00042D2C, 0x000B2025, 0x00131509, 0x002E101B, 0x00230515,
    0x002A2906, 0x0010111F, 0x002E2D0C, 0x00211802, 0x000E2F1E,
    0x0005232C, 0x002B1908, 0x00230330, 0x001B0E18, 0x0015082D,
    0x00202C0A, 0x00022322, 0x000F151A, 0x00200427, 0x0029290B,
    0x00042122, 0x00270915, 0x00170525, 0x00062A1D, 0x00301503,
    0x00022E1A, 0x001A1C0B, 0x00221404, 0x00300730, 0x00190E20,
    0x000C1C19, 0x002F150B, 0x001D0725, 0x00152E10, 0x0001112C,
    0x00191D07, 

    0x0022130E, 0x0002191C, 0x00250720, 0x00102C2C, 0x00191107,         // 86
    0x0021022E, 0x00063215, 0x002C1E0A, 0x000F1321, 0x001B0713,
    0x000A2025, 0x002E2907, 0x001D0B21, 0x00021228, 0x001F220C,
    0x0025012B, 0x00130D22, 0x00041A28, 0x0016290F, 0x00230320,
    0x00133007, 0x001E0C22, 0x00072C16, 0x0017160A, 0x0031101F,
    0x000B1329, 0x002C2804, 0x0008192C, 0x0030250C, 0x001D1E08,
    0x00160F17, 0x00052423, 0x00192F09, 0x00130E16, 0x001D2506,
    0x0007112D, 0x00300019, 0x001E0D2A, 0x002B071C, 0x00061E2C,
    0x000B2325, 0x0029110E, 0x00051731, 0x00260C26, 0x000E1C20,
    0x00290F12, 0x00042D1E, 0x00300117, 0x00202107, 0x00031A2A,
    0x00140A1F, 0x0022240F, 0x002E1E07, 0x001E0428, 0x0010251E,
    0x00320B12, 0x00240119, 0x001E240E, 0x00031B31, 0x000C2D20,
    0x0015160D, 0x0007222B, 0x00270514, 0x00021E2F, 0x001D1019,
    0x00280911, 0x00102C14, 0x0000161D, 0x000B2824, 0x002C1F05,
    0x0011180E, 0x0028062C, 0x002F2E07, 0x00140A12, 0x00091C19,
    0x002E102E, 0x00133004, 0x00231E0D, 0x000C1131, 0x0025240F,
    0x00110E2E, 0x002C0115, 0x000A2B1D, 0x000F1F12, 0x00022629,
    0x00262F02, 0x00130D30, 0x0005251F, 0x00271A02, 0x002D0018,
    0x00102420, 

    0x00300616, 0x00160F32, 0x001D2905, 0x00041E13, 0x000A161B,         // 87
    0x0031210F, 0x00110D1E, 0x001D1600, 0x0008232C, 0x00300C19,
    0x0013190E, 0x00210130, 0x000D2415, 0x00172D10, 0x00301600,
    0x000B1D15, 0x001A2B09, 0x0020061B, 0x00311202, 0x00091E2B,
    0x0029150C, 0x000D2227, 0x002C0111, 0x0010272E, 0x001F2E06,
    0x00052013, 0x0023041A, 0x001A3210, 0x00110A24, 0x0024051B,
    0x00092E2C, 0x00301301, 0x0023190E, 0x0029062A, 0x00102921,
    0x00221803, 0x0017210F, 0x00112708, 0x00252C11, 0x00201603,
    0x001B0A19, 0x00142806, 0x001E041C, 0x00092F14, 0x00322603,
    0x00140928, 0x001D1F0C, 0x00101632, 0x00092B24, 0x0027120B,
    0x000D3115, 0x001A0230, 0x00091423, 0x00152E0D, 0x0006182F,
    0x001A2904, 0x000F112A, 0x002C3006, 0x00170927, 0x00200311,
    0x00301D03, 0x001C0A26, 0x00182B09, 0x000C1323, 0x00312805,
    0x00130321, 0x001B0D29, 0x002F1E01, 0x00211110, 0x00063028,
    0x001D0F1E, 0x000C2615, 0x00051B20, 0x001C0E2F, 0x00242702,
    0x000D171F, 0x001B0229, 0x0003261B, 0x002C1806, 0x001C0424,
    0x00172008, 0x00042721, 0x00240A2C, 0x002A1609, 0x00160324,
    0x002C190E, 0x001F041B, 0x000B2B14, 0x00210A27, 0x0008162F,
    0x001C3106, 

    0x00051F2A, 0x000C2511, 0x00280224, 0x002D0B2A, 0x001F2E02,         // 88
    0x00260626, 0x00022B30, 0x002A2610, 0x00170427, 0x00202E0A,
    0x00002A1F, 0x002A1403, 0x00061B29, 0x0027081E, 0x00120E2E,
    0x00072725, 0x0029091F, 0x00002130, 0x000F2F13, 0x001D0E18,
    0x00052B1E, 0x00181A04, 0x0023112A, 0x00041C1B, 0x002A0623,
    0x00180C30, 0x000E1B20, 0x00291402, 0x00012331, 0x002B1705,
    0x000F2013, 0x001C0120, 0x000A2B30, 0x00011D1D, 0x002E0B13,
    0x000C2E27, 0x00280931, 0x000A1220, 0x00011A26, 0x0012032F,
    0x002F2E0B, 0x00031D2B, 0x002D1024, 0x0017210A, 0x0020062E,
    0x00011819, 0x00253005, 0x00190E14, 0x002A0620, 0x001C2504,
    0x00310C26, 0x0000191A, 0x002B2703, 0x00210E14, 0x0026081C,
    0x002A1E0A, 0x00041523, 0x0009201D, 0x00250E14, 0x00102523,
    0x0005322E, 0x00240F16, 0x0012001D, 0x002A240F, 0x00061B2D,
    0x0021310B, 0x00092216, 0x0017062F, 0x0028250A, 0x00130A19,
    0x00320032, 0x00251302, 0x0019290C, 0x002D0325, 0x00011F15,
    0x00122C0A, 0x00311410, 0x00200922, 0x000F2913, 0x000A2F17,
    0x0031082A, 0x001F190F, 0x00133001, 0x001D0F18, 0x00052C1E,
    0x001A2307, 0x000F132D, 0x00321D05, 0x00182210, 0x0013290B,
    0x00290C23, 

    0x001A2C01, 0x0021101B, 0x0013300B, 0x00061917, 0x000E221F,         // 89
    0x001A120C, 0x00141A06, 0x00220917, 0x000C1C21, 0x00271104,
    0x000E1F2A, 0x0016051B, 0x002F310D, 0x001A2008, 0x00210419,
    0x002D3007, 0x0015140E, 0x00231B04, 0x002C0226, 0x00132608,
    0x00260530, 0x00300913, 0x000B3017, 0x001C2301, 0x00121310,
    0x002F2507, 0x00092A16, 0x001D0828, 0x00142C0B, 0x00200C1D,
    0x0006272A, 0x0028160F, 0x00150818, 0x001F2208, 0x0018120C,
    0x00041B1C, 0x001D0514, 0x00303006, 0x001A200E, 0x00290E1D,
    0x000C2314, 0x00230920, 0x00101911, 0x00062C17, 0x002A1407,
    0x000C2923, 0x002E032C, 0x00051D1C, 0x0013220D, 0x0007172E,
    0x00162C10, 0x00251E0B, 0x0011062B, 0x00042220, 0x000C312C,
    0x001D0218, 0x00152C0F, 0x002F062F, 0x001A2A00, 0x0029130C,
    0x000A181A, 0x002D1F07, 0x00032D32, 0x001F1701, 0x00170719,
    0x00260F24, 0x002D1606, 0x00042D1C, 0x000C1323, 0x001A1B0D,
    0x00012E13, 0x00102226, 0x0008161B, 0x00203007, 0x0016072B,
    0x00260D1A, 0x00072230, 0x00181C00, 0x002A0D2C, 0x0000141E,
    0x00271D06, 0x0007111A, 0x000D2227, 0x002F0832, 0x00091C14,
    0x00240628, 0x00003117, 0x00280824, 0x0006112C, 0x0024021D,
    0x000F1A14, 

    0x002B0521, 0x0009152C, 0x00311D07, 0x00170430, 0x002B0E13,         // 90
    0x0008282A, 0x00300024, 0x0004301B, 0x002D150E, 0x0007282E,
    0x001C0F16, 0x00240B11, 0x000A2523, 0x00031331, 0x000F1914,
    0x0006222B, 0x001E1012, 0x000B2B2D, 0x00190C1B, 0x00081623,
    0x00201C0F, 0x00012820, 0x00140D25, 0x0028032E, 0x0021170B,
    0x00022F2A, 0x0025011B, 0x002D110E, 0x000C1E23, 0x00300317,
    0x0017300A, 0x00110F24, 0x002F2504, 0x000C3227, 0x002C022E,
    0x00232A00, 0x00102625, 0x00061619, 0x00210A2A, 0x00152A02,
    0x0007142E, 0x00183105, 0x00290527, 0x00210C31, 0x000F1F1F,
    0x001C110E, 0x00162409, 0x001F0B26, 0x002C2F00, 0x00230018,
    0x000E1129, 0x001E0A1E, 0x002D2906, 0x00191211, 0x00311B01,
    0x00110D27, 0x00222407, 0x000D1716, 0x00001D2B, 0x00140A1F,
    0x00210228, 0x0017270E, 0x00101220, 0x00300B27, 0x000E2114,
    0x0001272A, 0x00121D0E, 0x001D022D, 0x00232904, 0x002B0729,
    0x00201E08, 0x002C0E1F, 0x0013092E, 0x00291D10, 0x000A1120,
    0x002C2704, 0x001E0523, 0x0011310E, 0x00240127, 0x0015230A,
    0x00102D2E, 0x00190422, 0x00212A0C, 0x00271504, 0x0012260F,
    0x002C0C20, 0x00142002, 0x001C180E, 0x000D2D19, 0x002D2408,
    0x00021328 
};

#else // HALFTONE_SIZE

#error HALFTONE_SIZE must be 91 because no C support for 23.

#undef HALFTONE_MMX

#endif // HALFTONE_SIZE

#endif // defined(HALFTONE_MMX)
#endif // defined(_X86_)

const BYTE identityTranslate[256] = { 
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
};

#define SPECIAL_COLORS

// Halftone a solid color into a packed DIB, using an 8x8 halftone matrix,
// using the 216-color halftone color palette. This method assumes we've
// already checked that the color is not anywhere in the palette, so it does
// need to be halftoned.

VOID
HalftoneColorRef_216(
    COLORREF color,     // color to halftone
    UNALIGNED VOID *dib // packed 8 bpp DIB buffer with 8 colors
    )
{
    ASSERT(dib != NULL);
    
    UINT    r, g, b;
    
    r = GetRValue(color);
    g = GetGValue(color);
    b = GetBValue(color);

    ULONG   rQuo, gQuo, bQuo;
    ULONG   rRem, gRem, bRem;

    DIV_51(r, rQuo, rRem);
    DIV_51(g, gQuo, gRem);
    DIV_51(b, bQuo, bRem);
    
    UNALIGNED BITMAPINFOHEADER *bmih = (UNALIGNED BITMAPINFOHEADER *)dib;
    
    bmih->biSize          = sizeof(BITMAPINFOHEADER);
    bmih->biWidth         = 8;
    bmih->biHeight        = 8;
    bmih->biPlanes        = 1;
    bmih->biBitCount      = 8;
    bmih->biCompression   = BI_RGB;
    bmih->biSizeImage     = 0;
    bmih->biXPelsPerMeter = 0;
    bmih->biYPelsPerMeter = 0;
    bmih->biClrUsed       = 8;
    bmih->biClrImportant  = 0;

    INT i;

    // Generate all 8 required colors, based on the quotient values.
    // The index bit format is: BGR

    UNALIGNED RGBQUAD *bmiColors = (UNALIGNED RGBQUAD *)(bmih + 1);
    
    r = Mult36LUT[rQuo];      // 36 * rQuo
    g = Mult6plus40LUT[gQuo]; //  6 * gQuo + 40 (halftone base)
    b = bQuo;                 //      bQuo

    ULONG rNext = rRem ? 36 : 0;
    ULONG gNext = gRem ?  6 : 0;
    ULONG bNext = bRem ?  1 : 0;
    
    for (i = 0; i < 8; i++)
    {
        // Get the palette entry in HTColorTable by computing the index:

        PALETTEENTRY *palEntry = HTColorPalette.palPalEntry +
                                 r + ((i & 1) ? rNext : 0) +
                                 g + ((i & 2) ? gNext : 0) +
                                 b + ((i & 4) ? bNext : 0);

        bmiColors[i].rgbRed   = palEntry->peRed;
        bmiColors[i].rgbGreen = palEntry->peGreen;
        bmiColors[i].rgbBlue  = palEntry->peBlue;
        
        bmiColors[i].rgbReserved = 0;
    }
    
    BYTE *buffer = (BYTE *)(bmiColors + 8);

    for (i = 0; i < 64; i++)
    {
        ULONG halftoneValue = HT_216_8x8[i];

        // MUST do >, not >= so that a remainder of 0 works correctly

        *buffer++ = ((rRem > halftoneValue) << 0) |
                    ((gRem > halftoneValue) << 1) |
                    ((bRem > halftoneValue) << 2);
    }
}

/**************************************************************************\
*
* Operation Description:
*
*   HalftoneToScreen: Halftone from 32bpp ARGB, to the screen.
*
* Arguments:
*
*   dst         - The destination scan
*   src         - The source scan (32bpp ARGB)
*   count       - The length of the scan, in pixels
*   otherParams - Additional data. (We use PaletteMap, X, and Y.)
*
* Return Value:
*
*   None
*
* Notes:
*
*   The naming of the HalftoneToScreen operations works as follows:
*     HalftoneToScreen_<src>_<dst>_<palette>
*
*   At the time of writing, <src> is always sRGB, <dst> is always 8 (for
*   8bpp), and <palette> is either 16 (VGA palette) or 216 (standard
*   halftone palette).
*
* History:
*
*   05/13/1999 davidx
*       Created it.
*   10/29/1999 DCurtis
*       Rewrote to use Daniel Chou's halftoning patterns.
*   12/02/1999 agodfrey
*       Moved & reorganized it.
*
\**************************************************************************/

#pragma optimize ("t", on)            

// Halftone to 8bpp, using the 216-color halftone palette

VOID FASTCALL
ScanOperation::HalftoneToScreen_sRGB_8_216(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    
    ASSERT((s != NULL) && (d != NULL));
    ASSERT(s != d);
    ASSERT(otherParams);
    
    if (count == 0)
    {
        return;
    }
    
    INT orgX = RemainderI(otherParams->X, HALFTONE_SIZE);
    INT orgY = RemainderI(otherParams->Y, HALFTONE_SIZE);
    INT htStartRow = orgY*HALFTONE_SIZE;

    // Bug #360060: Some times it's possible the PaletteMap may be NULL
    // if we are in the process of a display mode change, say 32 to 8bpp.  In 
    // these cases we just assume an identity palette map to avoid AVing.
    // This means we may render improperly but we expect this to occur
    // only briefly before a new WM_PAINT occurs.

    const BYTE *pTranslate = otherParams->PaletteMap ?
        otherParams->PaletteMap->GetTranslate() : &identityTranslate[0];

#if defined(_X86_) && defined (HALFTONE_MMX)
    if (OSInfo::HasMMX)
    {
        // Multiply by multApproxDiv51 and divide by 65536. We will use this
        // to divide numbers in the range [0,305] (255+50), and for these
        // values, the "approximation" always returns the correct value.
    
        static ULONGLONG multApproxDiv51 = 0x0000050605060506;

        // Multiplier for palette indicies:
    
        static ULONGLONG multForPalIndex = 0x0000002400060001;

        __asm
        {
            movq        mm3, multForPalIndex
            movq        mm2, multApproxDiv51
            pxor        mm7, mm7                // mm7 = 0

            mov         edi, d                  // edi = d

            mov         edx, htStartRow
            mov         eax, orgX
            lea         ebx, HT_SuperCell_Packed
            add         edx, eax
            shl         edx, 2
            add         ebx, edx                // ebx = start in dither table            
            mov         edx, HALFTONE_SIZE
            sub         edx, eax                // edx = HALFTONE_SIZE - orgX

            mov         esi, s                  // esi = s

outer_loop:
            
            mov         ecx, count
            cmp         ecx, edx
            jb          setup_inner_loop

            mov         ecx, edx

setup_inner_loop:

            sub         count, ecx

inner_loop:

            // [johnstep] The following does not currently support
            //            GDIP_DO_HALFTONE_GAMMA, which will be necessary if
            //            reenabled in the C code; see the C code below.
            
            movd        mm0, [esi]              // mm0 = 0 | 0 | AR | GB

#if defined(SPECIAL_COLORS)
            xor         eax, eax
            mov         al, [esi + 0]
            shr         al, 2
            xor         al, [esi + 1]
            shr         al, 2
            xor         al, [esi + 2]
            shr         al, 1                   // eax = hashKey

check_special:
            
            lea         edx, VgaColorHash
            shl         eax, 2
            add         eax, edx                // eax = &VgaColorHash[hashKey]

            mov         edx, [eax]
            xor         edx, [esi]
            and         edx, 0x00FFFFFF
            jz          special_color           // colors match

            test        [eax], 0x80000000
            jnz         special_collision       // hash table collision

#endif
            movd        mm1, [ebx]              // mm1 = 0 | 0 | R | GB

            punpcklbw   mm0, mm7                // mm0 = A | R | G | B
            punpcklbw   mm1, mm7                // mm1 = 0 | R | G | B

            paddw       mm0, mm1                // mm0 = A | R | G | B
            pmulhw      mm0, mm2                // divide by 51

            pmaddwd     mm0, mm3                // mm0 = (36 * R) | ((6 * G) + B)
            movq        mm4, mm0
            psrlq       mm4, 32                 // mm4 = 0 | (36 * R)
            paddsw      mm0, mm4                // mm0 = (36 * R) | ((36 * R) + (6 * G) + B)
            
            movd        eax, mm0                // eax = (36 * R) + (6 * G) + B
            add         eax, pTranslate         // eax = &pTranslate[(36 * R) + (6 * G) + B]
            
            mov         al, BYTE PTR [eax + 40] // al = pTranslate[(36 * R) + (6 * G) + B + 40]
#if defined(SPECIAL_COLORS)

set_pixel:

#endif
            add         ebx, 4                  // Prepare for next iteration: pHtStartRow++
            mov         BYTE PTR [edi], al      // Write al to destination
            add         esi, 4                  // Prepare for next iteration: s++
            inc         edi                     // Prepare for next iteration: d++

            dec         ecx
            jg          inner_loop

            cmp         count, 0
            je          exit_loop

            mov         edx, HALFTONE_SIZE
            sub         ebx, 4 * HALFTONE_SIZE
            jmp         outer_loop
#if defined(SPECIAL_COLORS)

special_color:

            mov         eax, [eax]
            shr         eax, 24
            and         eax, 0x3F
            add         eax, pTranslate
            mov         al, BYTE PTR [eax]      // al = pTranslate[index from hash]
            
            jmp         set_pixel

special_collision:

            sub         eax, VgaColorHash
            shr         eax, 2
            inc         eax
            and         eax, (1 << VGA_HASH_BITS) - 1 // eax = next hashKey

            jmp         check_special
#endif

exit_loop:

            emms
        }
    }
    else
#endif // defined(_X86_) && defined(HALFTONE_MMX)
    {
        UINT   r, g, b;
    
        for (;;)
        {
#ifdef GDIP_DO_HALFTONE_GAMMA
            // Have to linearize the color before halftoning it
            b = GammaTable216[s[0]];
            g = GammaTable216[s[1]];
            r = GammaTable216[s[2]];
        
            // The gamma correction is messing up the colors in 
            // Office's color dialogs :(
#else
            b = s[0];
            g = s[1];
            r = s[2];
#endif
            s += 4;

            INT palIndex;

#if defined(SPECIAL_COLORS)
            BOOL found = 0;

            // We have to guarantee that if the color is one of the
            // 20 system colors, it will be solid (not halftoned).  Since
            // several of these colors are not a subset of the 216 halftoning
            // colors, we have to check for them as a special case.
        
            // We use a hash table to detect these colors quickly.

            UINT hashKey = VGAHashColor(r, g, b);
       
            ARGB tblEntry = VgaColorHash[hashKey];

            // Re-read the source pixel in ARGB form - it's quicker than
            // constructing it from r, g, and b.
        
            ARGB color = *reinterpret_cast<const ARGB *>(s-4);
        
            // See if the lower 3 bytes of 'tblEntry' match the
            // lower 3 bytes of 'color'.

            if (((tblEntry ^ color) & 0xffffff) == 0)
            {
                palIndex = (tblEntry >> 24) & 0x3f;
                found = 1;
            }
            else
            {
                // If there was a collision at this position, iterate through
                // all the possible values at this address. Collision entries
                // are marked by setting the high bit.
            
                while (static_cast<INT>(tblEntry) < 0)
                {
                    hashKey++;
                    hashKey &= (1 << VGA_HASH_BITS) - 1;
                
                    tblEntry = VgaColorHash[hashKey];
                
                    if (((tblEntry ^ color) & 0xffffff) == 0)
                    {
                        palIndex = (tblEntry >> 24) & 0x3f;
                        found = 1;
                        break;
                    }
                }
            }
        
            if (!found)
#endif
            {
                ULONG   rQuo, gQuo, bQuo;
                ULONG   rRem, gRem, bRem;
                // MUST do >, not >= so that a remainder of 0 works correctly

                DIV_51(r, rQuo, rRem);
                r = rQuo + (rRem > HT_SuperCell_Red216  [htStartRow + orgX]);
            
                DIV_51(g, gQuo, gRem);
                g = gQuo + (gRem > HT_SuperCell_Green216[htStartRow + orgX]);
            
                DIV_51(b, bQuo, bRem);
                b = bQuo + (bRem > HT_SuperCell_Blue216 [htStartRow + orgX]);

                palIndex = b + Mult6plus40LUT[g] + Mult36LUT[r];
            }
            *d++ = pTranslate[palIndex];
                        
            if (--count == 0)
            {
                break;
            }

            orgX++;
        
            orgX = (orgX == HALFTONE_SIZE) ? 0 : orgX;
        }
    }
}
#pragma optimize ("", on)

// Halftone to 8bpp, using the 16-color VGA palette

VOID FASTCALL
ScanOperation::HalftoneToScreen_sRGB_8_16(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    
// NOTE: this algorithm assumes the default palette 
//       (and that the default palette is the same as HTColorPalette[]).
    
    ASSERT((s != NULL) && (d != NULL));
    ASSERT(s != d);
    ASSERT(otherParams);
        
    if (count == 0)
    {
        return;
    }
    
    INT orgX = RemainderI(otherParams->X, HALFTONE_SIZE);
    INT orgY = RemainderI(otherParams->Y, HALFTONE_SIZE);
    INT htStartRow = orgY * HALFTONE_SIZE;
    
    INT             htIndex    = htStartRow + orgX;
    INT             palIndex;
    INT             numFF;
    INT             num80;
    INT             htCell;
    INT             max;
    INT             rFF, gFF, bFF;
    INT             r, g, b;
    COLORREF        rgb;
    
    // Bug #360060: Some times it's possible the PaletteMap may be NULL
    // if we are in the process of a display mode change, say 32 to 8bpp.  In 
    // these cases we just assume an identity palette map to avoid AVing.
    // This means we may render improperly but we expect this to occur
    // only briefly before a new WM_PAINT occurs.

    const BYTE *pTranslate = otherParams->PaletteMap ?
        otherParams->PaletteMap->GetTranslate() : &identityTranslate[0];

    for (;;)
    {
#ifdef GDIP_DO_HALFTONE_GAMMA
        // Have to linearize the color before halftoning it
        r = GammaTable16[s[2]];
        g = GammaTable16[s[1]];
        b = GammaTable16[s[0]];
#else
        // The gamma correction is messing up the UI icons for WFC :(
        r = s[2];
        g = s[1];
        b = s[0];
#endif
        s += 4;

        // We have to guarantee that if the color is one of the
        // 20 system colors, it will be solid (not halftoned).  Since
        // we halftone with only 15 of the colors, there are 5
        // that we have to check for as a special case.

        rgb = (b << 16) | (g << 8) | r;     // Equivalent of RGB macro
        
        // If the the order of the colors in HTColorPalette changes,
        // this code will have to change as well!
        
        if (rgb == 0x00C0C0C0)
        {
            palIndex = 7;
        }
        else if (rgb == Globals::SystemColors[16])
        {
            palIndex = 8;
        }
        else if (rgb == Globals::SystemColors[17])
        {
            palIndex = 9;
        }
        else if (rgb == Globals::SystemColors[18])
        {
            palIndex = 10;
        }
        else if (rgb == Globals::SystemColors[19])
        {
            palIndex = 11;
        }
        else
        {
            max = (r > g) ? r : g;
            if (b > max)
            {
                max = b;
            }

            htCell = HT_SuperCell_GreenMono[htIndex];

            if (max > 0x80)
            {
                if (max < 255)
                {
                    numFF = ((max - 128) * 2);
                    num80 = 256 - numFF;
                    num80 = (num80 >> 1);
    
                    if ((rFF = (r - num80)) > 0)
                    {
                        r = 0xff;
                    }

                    if ((gFF = (g - num80)) > 0)
                    {
                        g = 0xff;
                    }

                    if ((bFF = (b - num80)) > 0)
                    {
                        b = 0xff;
                    }
                }
                else
                {
                    rFF = r;
                    gFF = g;
                    bFF = b;
                    goto UseTopOfPalette;
                }
        
                if (numFF > htCell)
                {
UseTopOfPalette:
                    palIndex = 12;
                    if (bFF > htCell)
                    {
                        palIndex += 4;
                    }
                    if (gFF > htCell)
                    {
                        palIndex += 2;
                    }
                    if (rFF > htCell)
                    {
                        palIndex++;
                    }
                }
                else
                {
                    goto UseBottomOfPalette;
                }
            }
            else
            {
UseBottomOfPalette:
                htCell = (255 - htCell) >> 1;
                palIndex = 0;
                if (b > htCell)
                {
                    palIndex += 4;
                }
                if (g > htCell)
                {
                    palIndex += 2;
                }
                if (r > htCell)
                {
                    palIndex++;
                    if (palIndex == 7)
                    {
                        palIndex = 12;
                    }
                }
            }
        }

        *d++ = pTranslate[palIndex];

        if (--count == 0)
        {
            break;
        }

        htIndex++;
        if (++orgX >= 91)
        {
            orgX = 0;
            htIndex = htStartRow;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\soreadrmw.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "ReadRMW" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
*   This module implements scan operations for prereading from the
*   destination surface, when we are later going to do a SrcOver operation.
*   We call this the 'RMW optimization' ('read-modify-write' optimization).
*
*   Reads from video memory (or AGP memory) are stupendously expensive.
*   (For example, on my PCI Pentium II, which is representative of both
*   PCI and AGP machines, reads max out at 5.5 MB/s, whereas writes are
*   90 MB/s.  Not only is there that raw throughput difference, but
*   writes can be buffered and so allow some CPU cycles between writes,
*   which isn't possible on reads.)
*
*       o Aligned dword reads are typically twice as fast as aligned
*         word reads.  That is, an aligned dword read typically takes
*         the same amount of time as an aligned word read.  
*         BUT: This rule is a little complicated.  Random dword reads 
*         on my machine do indeed take the same amount of time as random 
*         word reads, but consecutive dword reads are significantly slower 
*         than consecutive word reads (although are still faster in terms
*         of throughput).
*       o Most alpha values in the source buffer are 0 or 255, meaning
*         that we really don't need to do the read of the destination
*         at all for those pixels
*       o Write combining is more effective with a batch of writes.
*         That is, instead of doing read/write for every pixel, 
*         doing all the reads up front and then doing all the writes
*         is more efficient.
*
*   In some cases (e.g. if we do the blend in sRGB64), we want to do other 
*   operations between the read and the blend. If we use ReadRMW as a separate
*   operation, we don't need to write RMW versions of those intermediate
*   operations.
*
*   So for an sRGB blend, it's more efficient to do a separate 
*   pre-read pass when the destination format is 16-bit or 24-bit.
*   There are sRGB64 versions for 16-bit, 24-bit and 
*   32-bit destination formats.
*
*   If we use ReadRMW, we have to be careful about the final write. 
*   If a blend pixel has an alpha of 0, we won't read from the destination,
*   so we must avoid writing to the destination for that pixel, or we'll
*   write garbage. So the final scan operation used must be a WriteRMW
*   operation. (The 'Blend' operations are also classified as WriteRMW
*   operations, so if the destination format is canonical, we don't have to
*   use a separate WriteRMW.)
*
* Revision History:
*
*   12/08/1998 andrewgo
*       Created it.
*   07/14/1999 agodfrey
*       Removed TRANSLUCENT5, added sRGB64, moved it from Ddi\scan.cpp.
*
\**************************************************************************/

#include "precomp.hpp"

// SHOULDCOPY* returns FALSE if the specified alpha value is either
// completely transparent or completely opaque. In either case, we
// don't actually need to read the destination.

#define SHOULDCOPY_sRGB64(x) (sRGB::isTranslucent64(x))

// Helper macros for declaring pointers to the blend pixels.

#define DECLARE_BLEND_sRGB \
    const ARGB *bl = \
        static_cast<const ARGB *>(otherParams->BlendingScan);
    
#define DECLARE_ALPHA_sRGB64 \
    const INT16 *alpha = \
        static_cast<const INT16 *>(otherParams->BlendingScan) + 3;

/**************************************************************************\
*
* Operation Description:
*
*   ReadRMW: Copy all pixels where the corresponding pixel in
*            otherParams->BlendingScan is translucent (i.e. alpha is
*            neither 0 nor 1.)
*
* Arguments:
*
*   dst         - The destination scan
*   src         - The source scan
*   count       - The length of the scan, in pixels
*   otherParams - Additional data (we use BlendingScan).
*
* Return Value:
*
*   None
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*   07/14/1999 agodfrey
*       Removed TRANSLUCENT5, added sRGB64, moved it from Ddi\scan.cpp. 
*   08/10/2000 agodfrey
*       Made it write zero when it decides not to read - the palette may
*       not have 256 entries (e.g. we hit this for 16-color mode, though we
*       probably shouldn't).
*
\**************************************************************************/

// 8bpp, for sRGB

VOID FASTCALL
ScanOperation::ReadRMW_8_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DECLARE_BLEND_sRGB
    
    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    INT align = (INT) ((-((LONG_PTR) s)) & 0x3);
    align = min(count, align);
    
    count -= align;
    
    while (align)
    {
        if (sRGB::isTranslucent(*bl))
        {
            *d = *s;
        }
        else
        {
            *d = 0;
        }
                                        
        d++;
        s++;
        bl++;
        align--;
    }

    // Now go through the aligned dword loop:
    
    while (count >= 4)
    {
        ASSERT((((ULONG_PTR) s) & 0x3) == 0);
    
        if (sRGB::isTranslucent(*bl) ||
            sRGB::isTranslucent(*(bl+1)) ||
            sRGB::isTranslucent(*(bl+2)) ||
            sRGB::isTranslucent(*(bl+3)))
        {
            // Do a dword read. We can be sloppy here (but not in WriteRMW)
            // - reading extra bytes doesn't hurt correctness, and
            // the perf impact (of possibly reading bytes we don't need to)
            // should be quite small.
            
            *((UNALIGNED UINT32*) d) = *((UINT32*) s);
        }
        else
        {
            *((UNALIGNED UINT32*) d) = 0;
        }
        
        
        d += 4;
        s += 4;
        bl += 4;
        count -= 4;
    }

    // Handle the last few pixels:

    while (count)
    {
        if (sRGB::isTranslucent(*bl))
        {
            *d = *s;
        }
        else
        {
            *d = 0;
        }
                                        
        d++;
        s++;
        bl++;
        count--;
    }
}

// 8bpp, for sRGB64

VOID FASTCALL
ScanOperation::ReadRMW_8_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DECLARE_ALPHA_sRGB64
    
    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    INT align = (INT) ((-((LONG_PTR) s)) & 0x3);
    align = min(count, align);
    
    count -= align;
    
    while (align)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *d = *s;
        }
                                        
        d++;
        s++;
        alpha += 4;
        align--;
    }

    // Now go through the aligned dword loop:

    while (count >= 4)
    {
        ASSERT((((ULONG_PTR) s) & 0x3) == 0);
    
        if (SHOULDCOPY_sRGB64(*alpha) ||
            SHOULDCOPY_sRGB64(*(alpha+4)) ||
            SHOULDCOPY_sRGB64(*(alpha+8)) ||
            SHOULDCOPY_sRGB64(*(alpha+12)))
        {
            // Do a dword read.

            *((UNALIGNED UINT32*) d) = *((UINT32*) s);
        }
        
        d += 4;
        s += 4;
        alpha += 16;
        count -= 4;
    }
    
    // Handle the last few pixels:

    while (count)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *d = *s;
        }
                                        
        d++;
        s++;
        alpha += 4;
        count--;
    }
}

// 16bpp, for sRGB

VOID FASTCALL
ScanOperation::ReadRMW_16_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT16, UINT16)
    DECLARE_BLEND_sRGB
    
    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    if (((ULONG_PTR) s) & 0x2)
    {
        if (sRGB::isTranslucent(*bl))
        {
            *(d) = *(s);
        }
                                        
        d++;
        s++;
        bl++;
        count--;
    }

    // Now go through the aligned dword loop:

    while ((count -= 2) >= 0)
    {
        if (sRGB::isTranslucent(*bl))
        {
            if (sRGB::isTranslucent(*(bl+1)))
            {
                // Both pixels have partial alpha, so do a dword read:

                *((UNALIGNED UINT32*) d) = *((UINT32*) s);
            }
            else
            {
                // Only the first pixel has partial alpha, so do a word read:

                *(d) = *(s);
            }
        }
        else if (sRGB::isTranslucent(*(bl+1)))
        {
            // Only the second pixel has partial alpha, so do a word read:

            *(d + 1) = *(s + 1);
        }

        d += 2;
        s += 2;
        bl += 2;
    }

    // Handle the end alignment:

    if (count & 1)
    {
        if (sRGB::isTranslucent(*bl))
        {
            *(d) = *(s);
        }
    }
}

// 16bpp, for sRGB64

VOID FASTCALL
ScanOperation::ReadRMW_16_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT16, UINT16)
    DECLARE_ALPHA_sRGB64

    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    if (((ULONG_PTR) s) & 0x2)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *(d) = *(s);
        }
                                        
        d++;
        s++;
        alpha += 4;
        count--;
    }

    // Now go through the aligned dword loop:

    while ((count -= 2) >= 0)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            if (SHOULDCOPY_sRGB64(*(alpha + 4)))
            {
                // Both pixels have partial alpha, so do a dword read:

                *((UNALIGNED UINT32*) d) = *((UINT32*) s);
            }
            else
            {
                // Only the first pixel has partial alpha, so do a word read:

                *(d) = *(s);
            }
        }
        else if (SHOULDCOPY_sRGB64(*(alpha + 4)))
        {
            // Only the second pixel has partial alpha, so do a word read:

            *(d + 1) = *(s + 1);
        }

        d += 2;
        s += 2;
        alpha += 8;
    }

    // Handle the end alignment:

    if (count & 1)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *(d) = *(s);
        }
    }
}

// 24bpp, for sRGB

VOID FASTCALL
ScanOperation::ReadRMW_24_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DECLARE_BLEND_sRGB
    
    ULONG_PTR srcToDstDelta = (ULONG_PTR) d - (ULONG_PTR) s;

    // Handle the initial partial read:

    INT initialAlignment = (INT) ((ULONG_PTR) s & 3);
    if (initialAlignment)
    {
        if (sRGB::isTranslucent(*bl))
        {
            UINT32 *alignedSrc = (UINT32*) ((ULONG_PTR) s & ~3);
            DWORD dwBuffer[2];

            // Get pointer to start of pixel inside dwBuffer
            BYTE *pByte = (BYTE*) dwBuffer + initialAlignment;

            // Copy first aligned DWORDS from the source
            dwBuffer[0] = *alignedSrc;
            // Copy next one only if pixel is split between 2 aligned DWORDS
            if (initialAlignment >= 2)
                dwBuffer[1] = *(alignedSrc + 1);

            // Copy 4 bytes to the destination
            //  This will cause an extra byte to have garbage in the
            //  destination buffer, but will be overwritten if next pixel
            //  is used.
            *((DWORD*) d) = *((UNALIGNED DWORD*) pByte);
        }

        bl++;
        s += 3;
        if (--count == 0)
            return;
    }

    while (TRUE)
    {
        // Find the first pixel to copy
    
        while (!sRGB::isTranslucent(*bl))
        {
            bl++;
            s += 3;
            if (--count == 0)
            {                           
                return;
            }
        }

        UINT32 *startSrc = (UINT32*) ((ULONG_PTR) (s) & ~3);
    
        // Now find the first "don't copy" pixel after that:
    
        while (sRGB::isTranslucent(*bl))
        {
            bl++;
            s += 3;
            if (--count == 0)
            {
                break;
            }
        }

        // 'endSrc' is inclusive of the last pixel's last byte:

        UINT32 *endSrc = (UINT32*) ((ULONG_PTR) (s + 2) & ~3);
        UNALIGNED UINT32 *dstPtr = (UNALIGNED UINT32*) ((ULONG_PTR) startSrc + srcToDstDelta);
    
        while (startSrc <= endSrc)
        {
            *dstPtr++ = *startSrc++;
        }

        if (count == 0)
            return;
    }
}

// 24bpp, for sRGB64

VOID FASTCALL
ScanOperation::ReadRMW_24_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DECLARE_ALPHA_sRGB64
    
    ULONG_PTR srcToDstDelta = (ULONG_PTR) d - (ULONG_PTR) s;

    // Handle the initial partial read:

    INT initialAlignment = (INT) ((ULONG_PTR) s & 3);
    if (initialAlignment)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            UINT32 *alignedSrc = (UINT32*) ((ULONG_PTR) s & ~3);
            DWORD dwBuffer[2];

            // Get pointer to start of pixel inside dwBuffer
            BYTE *pByte = (BYTE*) dwBuffer + initialAlignment;

            // Copy first aligned DWORDS from the source
            dwBuffer[0] = *alignedSrc;
            // Copy next one only if pixel is split between 2 aligned DWORDS
            if (initialAlignment >= 2)
                dwBuffer[1] = *(alignedSrc + 1);

            // Copy 4 bytes to the destination
            //  This will cause an extra byte to have garbage in the
            //  destination buffer, but will be overwritten if next pixel
            //  is used.
            *((DWORD*) d) = *((UNALIGNED DWORD*) pByte);
        }

        alpha += 4;
        s += 3;
        if (--count == 0)
            return;
    }

    while (TRUE)
    {
        // Find the first pixel to copy
    
        while (!SHOULDCOPY_sRGB64(*alpha))
        {
            alpha += 4;
            s += 3;
            if (--count == 0)
            {                           
                return;
            }
        }

        UINT32 *startSrc = (UINT32*) ((ULONG_PTR) (s) & ~3);
    
        // Now find the first "don't copy" pixel after that:
    
        while (SHOULDCOPY_sRGB64(*alpha))
        {
            alpha += 4;
            s += 3;
            if (--count == 0)
            {
                break;
            }
        }

        // 'endSrc' is inclusive of the last pixel's last byte:

        UINT32 *endSrc = (UINT32*) ((ULONG_PTR) (s + 2) & ~3);
        UNALIGNED UINT32 *dstPtr = (UNALIGNED UINT32*) ((ULONG_PTR) startSrc + srcToDstDelta);
    
        while (startSrc <= endSrc)
        {
            *dstPtr++ = *startSrc++;
        }

        if (count == 0)
            return;
    }
}

// 32bpp, for sRGB

VOID FASTCALL
ScanOperation::ReadRMW_32_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT32, UINT32)
    DECLARE_BLEND_sRGB
    
    while (count--)
    {
        if (sRGB::isTranslucent(*bl))
        {
            *d = *s;
        }
        
        d++;
        s++;
        bl++;
    }
}

// 32bpp, for sRGB64

VOID FASTCALL
ScanOperation::ReadRMW_32_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT32, UINT32)
    DECLARE_ALPHA_sRGB64
    
    while (count--)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *d = *s;
        }
        
        d++;
        s++;
        alpha += 4;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\solidfill.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Engine solid fill routines.
*
* Revision History:
*
*   12/11/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster as a solid color.
*   Is called by the rasterizer.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus
DpOutputSolidColorSpan::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    INT width = xMax - xMin;

    FillMemoryInt32(Scan->NextBuffer(xMin, y, width), width, Argb);

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Fills a path.  This distributes to the individual brush fill method.  
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to fill
*   [IN] drawBounds - the surface bounds
*   [IN] path       - the path to fill
*   [IN] brush      - the brush to use
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/21/1999 ikkof
*
\**************************************************************************/

GpStatus
DpDriver::FillPath(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpPath *path,
    const DpBrush *brush
    )
{
    GpStatus status = GenericError;

    const GpBrush *gpBrush = GpBrush::GetBrush(brush);

    BOOL noTransparentPixels = (!context->AntiAliasMode) && (gpBrush->IsOpaque()); 

    DpScanBuffer scan(
        surface->Scan,
        this,
        context,
        surface,
        noTransparentPixels);

    if (scan.IsValid())
    {
        if (brush->Type == BrushTypeSolidColor)
        {
            GpColor color(brush->SolidColor.GetValue());    
            DpOutputSolidColorSpan output(color.GetPremultipliedValue(), &scan);

            status = RasterizePath(path, 
                                   &context->WorldToDevice, 
                                   path->GetFillMode(),
                                   context->AntiAliasMode, 
                                   FALSE,
                                   &output, 
                                   &context->VisibleClip, 
                                   drawBounds);
        }
        else
        {
            // If there is a shrinking world to device transform when using
            // a path gradient, then scale the brush and the path to be 
            // in device units. This eliminates the need to create potentially 
            // very large gradients or textures.
            
            // Only handle positive scale because some of our driver rectangle
            // filling code can't handle negative rects. Doing ABS preserves
            // the sign of the input world coordinate rectangles/path.
            
            REAL scaleX = REALABS(context->WorldToDevice.GetM11());
            REAL scaleY = REALABS(context->WorldToDevice.GetM22());
            DpOutputSpan * output = NULL;
            
            if (brush->Type == BrushTypePathGradient &&
                context->WorldToDevice.IsTranslateScale() &&
                REALABS(scaleX) > REAL_EPSILON && 
                REALABS(scaleY) > REAL_EPSILON &&
                (REALABS(scaleX) < 1.0f || REALABS(scaleY) < 1.0f))
            {
                // I don't like the following hack for magically getting
                // a GpBrush from a DpBrush, but DpOutputSpan already does this...
                GpBrush * gpbrush = GpBrush::GetBrush( (DpBrush *)(brush));
                GpPathGradient *scaledBrush = (GpPathGradient*)(gpbrush->Clone());

                if (scaledBrush == NULL)
                {
                    return OutOfMemory;
                }

                // Scale the cloned brush's path and bounding rect into
                // device units.
                scaledBrush->ScalePath(scaleX,scaleY);

                REAL mOrig[6];
                context->WorldToDevice.GetMatrix(mOrig);
                context->WorldToDevice.Scale(1.0f/scaleX, 1.0f/scaleY);
                output = DpOutputSpan::Create(scaledBrush->GetDeviceBrush(), &scan, context, drawBounds);

                if (output != NULL)
                {
                    GpPath *scalePath = ((GpPath*)path)->Clone();
                    
                    if (scalePath != NULL)
                    {
                        GpMatrix  scaleMatrix (scaleX, 0.0f, 0.0f, scaleY, 0.0f, 0.0f);
                        scalePath->Transform(&scaleMatrix);
                        
                        status = RasterizePath(scalePath, 
                                       &context->WorldToDevice, 
                                       path->GetFillMode(),
                                       context->AntiAliasMode, 
                                       FALSE,
                                       output, 
                                       &context->VisibleClip, 
                                       drawBounds);
    
                        delete scalePath;
                    }
                    else
                    {
                        status = OutOfMemory;
                    }
                    delete output;
                }
                else
                {
                    status = OutOfMemory;
                }
                delete scaledBrush;
                context->WorldToDevice.SetMatrix(mOrig);
            }
            else
            {
                output = DpOutputSpan::Create(brush, &scan, context, drawBounds);
                if (output != NULL)
                {
                    status = RasterizePath(path, 
                                       &context->WorldToDevice, 
                                       path->GetFillMode(),
                                       context->AntiAliasMode, 
                                       FALSE,
                                       output, 
                                       &context->VisibleClip, 
                                       drawBounds);                
                    delete output;
                }

            }
        }
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Draws a path.  This distributes to the individual pen draw method.  
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to draw to
*   [IN] drawBounds - the surface bounds
*   [IN] path       - the path to stroke
*   [IN] pen        - the pen to use
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 ikkof
*
\**************************************************************************/

GpStatus
DpDriver::StrokePath(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpPath *path,
    const DpPen *pen
    )
{
    GpStatus status = GenericError;

    const DpBrush *brush = pen->Brush;

    REAL dpiX = (context->GetDpiX() > 0) 
              ? (context->GetDpiX())
              : (Globals::DesktopDpiX);

    BOOL isOnePixelWide = pen->IsOnePixelWide(&context->WorldToDevice, dpiX) &&
                          pen->IsCenterNoAnchor();
    BOOL isOnePixelWideOpaque = isOnePixelWide &&
                                (brush->Type == BrushTypeSolidColor) && 
                                (brush->SolidColor.IsOpaque()) &&
                                !(context->AntiAliasMode);
    BOOL isOnePixelWideSolid = isOnePixelWide && 
                                pen->IsSimple();

    // We have a special fast-path for doing single-pixel-wide, 
    // solid color, opaque, aliased lines:

    // !!! [asecchia] RAID 239905.
    // The single pixel wide optimized code has significant rounding problems
    // that are particularly problematic on bezier curves.
    // Bezier curves tend to be enumerated in a particular way that causes
    // the SolidStrokePathOnePixel code to enumerate the line segments backward
    // hitting badly tested end point conditions, though the problem seems
    // to be pervasive. 
    // The general rasterizer does not have these problems but is about 
    // 30% slower for single pixel solid lines. 
    // Turn on the optimization only for polylines until this is fixed.
    
    if (isOnePixelWideOpaque && isOnePixelWideSolid && !path->HasCurve())
    {
        return SolidStrokePathOnePixel(
            context,
            surface,
            drawBounds,
            path,
            pen,
            TRUE
        ); 
    }

    const DpPath* widenedPath;
    const DpPath* allocatedPath;

    GpMatrix *transform;
    GpMatrix identityTransform;

    if (isOnePixelWideSolid)
    {
        // Our RasterizePath code can directly draw a one-pixel-wide solid 
        // line directly:

        widenedPath = path;
        allocatedPath = NULL;
        transform = &context->WorldToDevice;
    }
    else
    {
        // We have to widen  the path before we can give it to the
        // rasterizer.  Generate new path now:

        REAL dpiX = context->GetDpiX();
        REAL dpiY = context->GetDpiY();

        if ((dpiX <= 0) || (dpiY <= 0))
        {
            dpiX = Globals::DesktopDpiX;
            dpiY = Globals::DesktopDpiY;
        }

        widenedPath = path->GetFlattenedPath(
            isOnePixelWideOpaque ? NULL : &context->WorldToDevice,
            isOnePixelWideOpaque ? Flattened : Widened,
            pen
        );

        allocatedPath = widenedPath;
        transform = &identityTransform;

        if (!widenedPath)
            return OutOfMemory;

        // If this line is aliased, opaque and dashed, dash it now and pass the
        // dashed path to the single pixel stroking code.
        if (isOnePixelWideOpaque && pen->DashStyle != DashStyleSolid)
        {
            DpPath *dashPath = NULL;

            dashPath = ((GpPath*)widenedPath)->CreateDashedPath(pen, 
                NULL, 
                dpiX, 
                dpiY,
                1.0f,
                FALSE /* don't need caps in 1 px wide case */);
            
            if (!dashPath)
            {
                delete widenedPath;
                return OutOfMemory;
            }

            Status status = SolidStrokePathOnePixel(context,
                                                    surface,
                                                    drawBounds,
                                                    dashPath,
                                                    pen,
                                                    FALSE); 
            delete dashPath;
            delete widenedPath;
            
            return status;
        }
    }

    const GpBrush *gpBrush = GpBrush::GetBrush(brush);
    BOOL noTransparentPixels = (!context->AntiAliasMode) && (gpBrush->IsOpaque()); 

    DpScanBuffer scan(surface->Scan, this, context, surface, noTransparentPixels);

    if (scan.IsValid())
    {
        if (brush->Type == BrushTypeSolidColor)
        {
            GpColor color(brush->SolidColor.GetValue());    
            DpOutputSolidColorSpan output(color.GetPremultipliedValue(), &scan);

            status = RasterizePath(widenedPath, 
                                   transform, 
                                   widenedPath->GetFillMode(),
                                   context->AntiAliasMode, 
                                   isOnePixelWideSolid,
                                   &output, 
                                   &context->VisibleClip, 
                                   drawBounds);
        }
        else
        {
            DpOutputSpan * output = DpOutputSpan::Create(brush, &scan, context, 
                                                         drawBounds);
            if (output != NULL)
            {
                status = RasterizePath(widenedPath, 
                                       transform, 
                                       widenedPath->GetFillMode(),
                                       context->AntiAliasMode, 
                                       isOnePixelWideSolid,
                                       output, 
                                       &context->VisibleClip, 
                                       drawBounds);
    
                delete output;
            }
        }
    }

    if (allocatedPath)
    {
        delete allocatedPath;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Fills a region.  This distributes to the individual brush fill method.  
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to fill
*   [IN] drawBounds - the surface bounds
*   [IN] region     - the region to fill
*   [IN] brush      - the brush to use
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/25/1999 DCurtis
*
\**************************************************************************/

GpStatus
DpDriver::FillRegion(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpRegion *region,
    const DpBrush *brush
    )
{
    GpStatus    status = GenericError;

    const GpBrush *gpBrush = GpBrush::GetBrush(brush);

    DpScanBuffer scan(
        surface->Scan,
        this,
        context,
        surface,
        gpBrush->IsOpaque());

    if (scan.IsValid())
    {
        DpOutputSpan * output = DpOutputSpan::Create(brush, &scan, 
                                                     context, drawBounds);

        if (output != NULL)
        {
            DpClipRegion *          clipRegion = &(context->VisibleClip);
            GpRect                  clipBounds;
            GpRect *                clipBoundsPointer = NULL;
            DpRegion::Visibility    visibility;
        
            visibility = clipRegion->GetRectVisibility(
                            drawBounds->X,
                            drawBounds->Y,
                            drawBounds->X + drawBounds->Width,
                            drawBounds->Y + drawBounds->Height);

            switch (visibility)
            {
              default:                          // Need to clip
                clipRegion->GetBounds(&clipBounds);
                clipBoundsPointer = &clipBounds;
                clipRegion->InitClipping(output, drawBounds->Y);
                status = region->Fill(clipRegion, clipBoundsPointer);
                break;

              case DpRegion::TotallyVisible:    // No clipping needed
                status = region->Fill(output, clipBoundsPointer);
                break;
            
              case DpRegion::Invisible:
                status = Ok;
                break;
            }

            delete output;
            clipRegion->EndClipping();
        }
    }

    return status;
}

GpStatus
DpDriver::MoveBits(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const GpRect *dstRect,     
    const GpPoint *srcPoint
    )
{
    return(GenericError);
}

GpStatus 
DpDriver::Lock(
    DpBitmap *surface,
    const GpRect *drawBounds,
    INT *stride,                    // [OUT] - Returned stride
    VOID **bits                     // [OUT] - Returned pointer to bits
    )
{
    return(Ok);
}

VOID 
DpDriver::Unlock(
    DpBitmap *surface
    )
{
}

/**************************************************************************\
*
* Function Description:
*
*   Engine version of routine to fill rectangles.
*   This is not limited to filling solid color.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   TRUE if successful.
*
* History:
*
*   01/13/1999 ikkof
*       Created it.
*
\**************************************************************************/

// !!![andrewgo] What is this doing in a file called "solidfill.cpp"?

GpStatus
DpDriver::FillRects(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    INT numRects, 
    const GpRectF *rects,
    const DpBrush *brush
    )
{
    GpStatus    status = Ok;
    GpBrushType type   = brush->Type;

    const GpBrush *gpBrush = GpBrush::GetBrush(brush);

    DpScanBuffer scan(
        surface->Scan,
        this,
        context,
        surface,
        gpBrush->IsOpaque());

    if(!scan.IsValid())
    {
        return(GenericError);
    }

    DpOutputSpan * output = DpOutputSpan::Create(brush, &scan, 
                                           context, drawBounds);

    if(output == NULL)
        return(GenericError);

    DpRegion::Visibility visibility = DpRegion::TotallyVisible;
    DpClipRegion * clipRegion = NULL;

    if (context->VisibleClip.GetRectVisibility(
        drawBounds->X, drawBounds->Y, 
        drawBounds->GetRight(), drawBounds->GetBottom()) != 
        DpRegion::TotallyVisible)
    {
        clipRegion = &(context->VisibleClip);
        clipRegion->InitClipping(output, drawBounds->Y);
    }
   
    GpMatrix *worldToDevice = &context->WorldToDevice;
    
    const GpRectF * rect = rects;
    INT y;

    for (INT i = numRects; i != 0; i--, rect++)
    {
        // We have to check for empty rectangles in world space (because
        // after the transform they might have flipped):

        if ((rect->Width > 0) && (rect->Height > 0))
        {
            GpPointF points[4];

            points[0].X = rect->X;
            points[0].Y = rect->Y;
            points[1].X = rect->X + rect->Width;
            points[1].Y = rect->Y + rect->Height;

            // FillRects only ever gets called when a scaling transform:
            // !!![ericvan] printing code calls this to render the brush onto a rectangle,
            //              but the transform in effect may not be TranslateScale
            // !!![andrewgo] Yeah but then isn't the printer case completely
            //               broken when there is an arbitrary transform?!?

            ASSERT(context->IsPrinter ||
                   worldToDevice->IsTranslateScale());
            
            worldToDevice->Transform(points, 2);

            INT left;
            INT right;

            // convert to INT the same way the GDI+ rasterizer does
            // so we get the same rounding error in both places.

            if (points[0].X <= points[1].X)
            {
                left  = RasterizerCeiling(points[0].X);
                right = RasterizerCeiling(points[1].X);     // exclusive
            }
            else
            {
                left  = RasterizerCeiling(points[1].X);
                right = RasterizerCeiling(points[0].X);     // exclusive
            }

            // Since right is exclusive, we don't draw anything
            // if left >= right.

            INT width = right - left;
            INT top;
            INT bottom;

            if (points[0].Y <= points[1].Y)
            {
                top    = RasterizerCeiling(points[0].Y);
                bottom = RasterizerCeiling(points[1].Y);    // exclusive
            }
            else
            {
                top    = RasterizerCeiling(points[1].Y);
                bottom = RasterizerCeiling(points[0].Y);    // exclusive
            }
             
            // Since bottom is exclusive, we don't draw anything
            // if top >= bottom.

            if ((width > 0) && (top < bottom))
            {
                GpRect clippedRect;
                
                if(clipRegion)
                {
                    visibility = 
                            clipRegion->GetRectVisibility(
                                left, top, 
                                right, bottom, &clippedRect);
                }

                switch (visibility)
                {
                case DpRegion::ClippedVisible:
                    left   = clippedRect.X;
                    top    = clippedRect.Y;
                    right  = clippedRect.GetRight();
                    bottom = clippedRect.GetBottom();
                    width  = right - left;
                    // FALLTHRU
        
                case DpRegion::TotallyVisible:
                    for (y = top; y < bottom; y++)
                    {
                        output->OutputSpan(y, left, right);
                    }
                    break;
        
                case DpRegion::PartiallyVisible:
                    for (y = top; y < bottom; y++)
                    {
                        clipRegion->OutputSpan(y, left, right);
                    }
                    break;

                case DpRegion::Invisible:
                    break;
                }
            }
        }
    }

    if (clipRegion != NULL)
    {
        clipRegion->EndClipping();
    }

    delete output;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\soquantize.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "Quantize" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
*   This module implements scan operations for converting pixels from
*   one format, to another of less color precision.
*   "Quantize" uses a simple, fixed mapping, which maps each source color
*   level to a particular destination color level.
*
* Notes:
*
*   The "Quantize" operation is fast but can cause Mach banding.
*   An alternative is the "Halftone" operation, in SOHalftone.cpp.
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*   12/01/1999 agodfrey
*       Moved to it from Imaging\Api\convertfmt.cpp.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Operation Description:
*
*   Quantize: Quickly convert format down from 32bpp ARGB.
*
* Arguments:
*
*   dst         - The destination scan
*   src         - The source scan (32bpp ARGB)
*   count       - The length of the scan, in pixels
*   otherParams - Additional data. (Ignored.)
*
* Return Value:
*
*   None
*
* History:
*
*   05/13/1999 davidx
*       Created it.
*   12/02/1999 agodfrey
*       Moved & reorganized it.
*
\**************************************************************************/

// Quantize from sRGB to 16bpp RGB555

VOID FASTCALL
ScanOperation::Quantize_sRGB_555(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, WORD)
    
    while (count--)
    {
        ARGB argb = *s++;

        *d++ = (WORD) ((((argb >> (RED_SHIFT+3)) & 0x1f) << 10) |
                       (((argb >> (GREEN_SHIFT+3)) & 0x1f) << 5) |
                       ((argb >> (BLUE_SHIFT+3)) & 0x1f));
    }
}

// Quantize from sRGB to 16bpp RGB565

VOID FASTCALL
ScanOperation::Quantize_sRGB_565(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, WORD)
    
    while (count--)
    {
        ARGB argb = *s++;

        *d++ = (WORD) ((((argb >> (RED_SHIFT+3)) & 0x1f) << 11) |
                       (((argb >> (GREEN_SHIFT+2)) & 0x3f) << 5) |
                       ((argb >> (BLUE_SHIFT+3)) & 0x1f));
    }
}

// Quantize from sRGB to 16bpp RGB1555

VOID FASTCALL
ScanOperation::Quantize_sRGB_1555(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, WORD)
    
    while (count--)
    {
        ARGB argb = *s++;

        // NOTE: Very crude conversion of alpha data
        // from 8bpp down to 1bpp

        *d++ = (WORD) ((((argb >> ALPHA_SHIFT) >= 128) ? 0x8000 : 0) |
                       (((argb >> (RED_SHIFT+3)) & 0x1f) << 10) |
                       (((argb >> (GREEN_SHIFT+3)) & 0x1f) << 5) |
                       ((argb >> (BLUE_SHIFT+3)) & 0x1f));
    }
}

// Quantize from sRGB to 24bpp RGB

VOID FASTCALL
ScanOperation::Quantize_sRGB_24(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, BYTE)
    
    while (count--)
    {
        ARGB argb = *s++;

        d[0] = (BYTE) (argb >> BLUE_SHIFT);
        d[1] = (BYTE) (argb >> GREEN_SHIFT);
        d[2] = (BYTE) (argb >> RED_SHIFT);
        d += 3;
    }
}

// Quantize from sRGB to 24bpp BGR

VOID FASTCALL
ScanOperation::Quantize_sRGB_24BGR(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, BYTE)
    
    while (count--)
    {
        ARGB argb = *s++;

        d[0] = (BYTE) (argb >> RED_SHIFT);
        d[1] = (BYTE) (argb >> GREEN_SHIFT);
        d[2] = (BYTE) (argb >> BLUE_SHIFT);
        d += 3;
    }
}

// Quantize from sRGB to 32bpp RGB

VOID FASTCALL
ScanOperation::Quantize_sRGB_32RGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, ARGB)
    
    while (count--)
    {
        *d++ = *s++ | ALPHA_MASK;
    }
}

// Quantize from sRGB64 to 48bpp RGB

VOID FASTCALL
ScanOperation::Quantize_sRGB64_48(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB64, INT16)
    
    while (count--)
    {
        sRGB::sRGB64Color c;
        c.argb = *s++;

        d[0] = c.b;
        d[1] = c.g;
        d[2] = c.r;
        d += 3;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\srgb.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   sRGB <-> sRGB64 color conversion
*
* Abstract:
*
*   Converts colors between the sRGB and sRGB64 color spaces.
*
* Notes:
*
*   !!![agodfrey]
*   For sRGB64->sRGB, we just clamp out-of-range components to [0,255].
*   We may need to provide the option of doing something more sophisticated.
*
* Revision History:
*
*   06/09/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

namespace sRGB
{
    BYTE UnlinLookup(INT16 input);
}

// UnlinearizeLUT, UnlinearizeLUT2: Lookup tables used to convert from
// sRGB64 to sRGB.
//
// The first table maps the high byte of the input to the smallest possible
// corresponding output.
//
// The second table describes, for each output, the maximum input which
// produces that output. The algorithm uses the first table to find an
// approximate answer, then scans the second table to find the exact result.

static BYTE UnlinearizeLUT[32] = 
{
    0x0, 0x31, 0x47, 0x56, 0x63, 0x6e, 0x78, 0x81,
    0x89, 0x91, 0x98, 0x9e, 0xa5, 0xab, 0xb1, 0xb6,
    0xbc, 0xc1, 0xc6, 0xca, 0xcf, 0xd4, 0xd8, 0xdc,
    0xe1, 0xe5, 0xe9, 0xed, 0xf0, 0xf4, 0xf8, 0xfb,
};

static INT16 UnlinearizeLUT2[256] = 
{
    0x1, 0x3, 0x6, 0x8, 0xb, 0xd, 0x10, 0x12,
    0x15, 0x17, 0x1a, 0x1c, 0x1f, 0x22, 0x25, 0x28,
    0x2c, 0x2f, 0x33, 0x37, 0x3b, 0x3f, 0x43, 0x48,
    0x4d, 0x52, 0x57, 0x5c, 0x61, 0x67, 0x6d, 0x73,
    0x79, 0x7f, 0x86, 0x8d, 0x94, 0x9b, 0xa2, 0xa9,
    0xb1, 0xb9, 0xc1, 0xca, 0xd2, 0xdb, 0xe4, 0xed,
    0xf6, 0x100, 0x10a, 0x114, 0x11e, 0x128, 0x133, 0x13e,
    0x149, 0x154, 0x160, 0x16c, 0x178, 0x184, 0x190, 0x19d,
    0x1aa, 0x1b7, 0x1c5, 0x1d2, 0x1e0, 0x1ee, 0x1fc, 0x20b,
    0x21a, 0x229, 0x238, 0x248, 0x257, 0x268, 0x278, 0x288,
    0x299, 0x2aa, 0x2bb, 0x2cd, 0x2df, 0x2f1, 0x303, 0x316,
    0x328, 0x33b, 0x34f, 0x362, 0x376, 0x38a, 0x39f, 0x3b3,
    0x3c8, 0x3dd, 0x3f3, 0x409, 0x41e, 0x435, 0x44b, 0x462,
    0x479, 0x490, 0x4a8, 0x4c0, 0x4d8, 0x4f1, 0x509, 0x522,
    0x53c, 0x555, 0x56f, 0x589, 0x5a3, 0x5be, 0x5d9, 0x5f4,
    0x610, 0x62c, 0x648, 0x664, 0x681, 0x69e, 0x6bb, 0x6d9,
    0x6f7, 0x715, 0x733, 0x752, 0x771, 0x791, 0x7b0, 0x7d0,
    0x7f1, 0x811, 0x832, 0x853, 0x875, 0x896, 0x8b8, 0x8db,
    0x8fe, 0x921, 0x944, 0x968, 0x98b, 0x9b0, 0x9d4, 0x9f9,
    0xa1e, 0xa44, 0xa6a, 0xa90, 0xab6, 0xadd, 0xb04, 0xb2b,
    0xb53, 0xb7b, 0xba4, 0xbcc, 0xbf5, 0xc1f, 0xc48, 0xc72,
    0xc9c, 0xcc7, 0xcf2, 0xd1d, 0xd49, 0xd75, 0xda1, 0xdce,
    0xdfb, 0xe28, 0xe55, 0xe83, 0xeb2, 0xee0, 0xf0f, 0xf3e,
    0xf6e, 0xf9e, 0xfce, 0xfff, 0x1030, 0x1061, 0x1093, 0x10c5,
    0x10f7, 0x1129, 0x115c, 0x1190, 0x11c3, 0x11f7, 0x122c, 0x1261,
    0x1296, 0x12cb, 0x1301, 0x1337, 0x136d, 0x13a4, 0x13db, 0x1413,
    0x144b, 0x1483, 0x14bb, 0x14f4, 0x152e, 0x1567, 0x15a1, 0x15dc,
    0x1616, 0x1651, 0x168d, 0x16c8, 0x1705, 0x1741, 0x177e, 0x17bb,
    0x17f9, 0x1837, 0x1875, 0x18b4, 0x18f3, 0x1932, 0x1972, 0x19b2,
    0x19f2, 0x1a33, 0x1a74, 0x1ab6, 0x1af8, 0x1b3a, 0x1b7d, 0x1bc0,
    0x1c04, 0x1c47, 0x1c8c, 0x1cd0, 0x1d15, 0x1d5a, 0x1da0, 0x1de6,
    0x1e2c, 0x1e73, 0x1eba, 0x1f02, 0x1f4a, 0x1f92, 0x1fdb, 0x7fff,
};

// Method of unlinearizing using a lookup table
//
// This has two steps - first, we use the high byte of the input
// to get an approximate answer for the output (using UnlinearizeLUT).
//
// Then we scan UnlinearizeLUT2 to find the exact answer.
// The i'th entry of UnlinearizeLUT2 is the highest input which will map
// to i.

BYTE
sRGB::UnlinLookup(
    INT16 input
    )
{
    BYTE temp = UnlinearizeLUT[(input & 0xff00)>>8];
    INT16 *lutPtr = &UnlinearizeLUT2[temp];
    
    while (*lutPtr < input) 
    {
        temp++;
        lutPtr++;
    }
    return temp;
}

// CLAMP64: Map inputs below 0 to 0, above SRGB_ONE to 255,
//   and in between to the given expression.

#define CLAMP64(input, expr) (((input) <= 0) ? 0 : \
                              (((input) >= SRGB_ONE) ? 255 : \
                              (expr)))

ARGB
sRGB::ConvertTosRGB(
    ARGB64 color
    ) 
{
    sRGBColor result;
    sRGB64Color c;
    
    c.argb = color;
    
    // [agodfrey] The compiler generates an IMUL for the multiply by 255, 
    // and I can't get it to use a MUL instead. Oh well, it's probably
    // insignificant.
    
    result.a = CLAMP64(c.a, (c.a * 255) >> SRGB_FRACTIONBITS);
    result.r = CLAMP64(c.r, UnlinLookup(c.r));
    result.g = CLAMP64(c.g, UnlinLookup(c.g));
    result.b = CLAMP64(c.b, UnlinLookup(c.b));
    
    return result.argb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\sowritermw.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "WriteRMW" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
*   This module implements scan operations for writing to the final destination
*   when we've done the 'RMW optimization' (see SOReadRMW.cpp).
*
*   We use ReadRMW in some cases when we do a SrcOver alpha-blend operation.
*   When a pixel to be blended has 0 alpha, this means that the destination
*   pixel will be unchanged. The ReadRMW operation skips reading the pixel,
*   so the WriteRMW operation must skip writing to it (to avoid writing
*   garbage).
*
* Revision History:
*
*   12/10/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

// SHOULDCOPY* returns FALSE if the specified alpha value is 
// completely transparent.

#define SHOULDCOPY_sRGB(x)   ((x) != 0)
#define SHOULDCOPY_sRGB64(x) ((x) != 0)

// Helper macros for declaring 'alpha', a pointer to the
// first alpha component in the blending scan.

#define DECLARE_ALPHA_sRGB \
    const BYTE *alpha = \
        static_cast<const BYTE *>(otherParams->BlendingScan) + 3;
    
#define DECLARE_ALPHA_sRGB64 \
    const INT16 *alpha = \
        static_cast<const INT16 *>(otherParams->BlendingScan) + 3;

/**************************************************************************\
*
* Operation Description:
*
*   ReadRMW: Copy all pixels where the corresponding pixel in
*            otherParams->BlendingScan is not completely transparent
*            (i.e. alpha is not 0.)
*
* Arguments:
*
*   dst         - The destination scan
*   src         - The source scan
*   count       - The length of the scan, in pixels
*   otherParams - Additional data (we use BlendingScan).
*
* Return Value:
*
*   None
*
* History:
*
*   12/10/1999 agodfrey
*       Created it.
*
\**************************************************************************/

// 8bpp, for sRGB

VOID FASTCALL
ScanOperation::WriteRMW_8_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DECLARE_ALPHA_sRGB
    
    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    INT align = (INT) ((-((LONG_PTR) d)) & 0x3);
    align = min(count, align);
    
    count -= align;
    
    while (align)
    {
        if (SHOULDCOPY_sRGB(*alpha))
        {
            *d = *s;
        }
                                        
        d++;
        s++;
        alpha += 4;
        align--;
    }

    // Now go through the aligned dword loop:

    while (count >= 4)
    {
        ASSERT((((ULONG_PTR) d) & 0x3) == 0);
    
        int mask = 0;
        if (SHOULDCOPY_sRGB(*alpha))
        {
            mask = 1;
        }
        if (SHOULDCOPY_sRGB(*(alpha+4)))
        {
            mask |= 2;
        }
        if (SHOULDCOPY_sRGB(*(alpha+8)))
        {
            mask |= 4;
        }
        if (SHOULDCOPY_sRGB(*(alpha+12)))
        {
            mask |= 8;
        }
        
        if (mask == 15)
        {
            // Do a dword write.

            *((UINT32*) d) = *((UNALIGNED UINT32*) s);
        } 
        else
        {
            int idx = 0;

            while (mask)
            {
                if (mask & 1)
                {
                    *(d + idx) = *(s + idx);
                }
                idx ++;
                mask >>= 1;
            }
        }
        
        d += 4;
        s += 4;
        alpha += 16;
        count -= 4;
    }

    // Handle the last few pixels:

    while (count)
    {
        if (SHOULDCOPY_sRGB(*alpha))
        {
            *d = *s;
        }
                                        
        d++;
        s++;
        alpha += 4;
        count--;
    }
}

// 8bpp, for sRGB64

VOID FASTCALL
ScanOperation::WriteRMW_8_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DECLARE_ALPHA_sRGB64
    
    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    INT align = (INT) ((-((LONG_PTR) d)) & 0x3);
    align = min(count, align);
    
    count -= align;
    
    while (align)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *d = *s;
        }
                                        
        d++;
        s++;
        alpha += 4;
        align--;
    }

    // Now go through the aligned dword loop:

    while (count >= 4)
    {
        ASSERT((((ULONG_PTR) d) & 0x3) == 0);
    
        int mask = 0;
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            mask = 1;
        }
        if (SHOULDCOPY_sRGB64(*(alpha+4)))
        {
            mask |= 2;
        }
        if (SHOULDCOPY_sRGB64(*(alpha+8)))
        {
            mask |= 4;
        }
        if (SHOULDCOPY_sRGB64(*(alpha+12)))
        {
            mask |= 8;
        }
        
        if (mask == 15)
        {
            // Do a dword write.

            *((UINT32*) d) = *((UNALIGNED UINT32*) s);
        } 
        else
        {
            int idx = 0;

            while (mask)
            {
                if (mask & 1)
                {
                    *(d + idx) = *(s + idx);
                }
                idx ++;
                mask >>= 1;
            }
        }
        
        d += 4;
        s += 4;
        alpha += 16;
        count -= 4;
    }
    
    // Handle the last few pixels:

    while (count)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *d = *s;
        }
                                        
        d++;
        s++;
        alpha += 4;
        count--;
    }
}

// 16bpp, for sRGB

VOID FASTCALL
ScanOperation::WriteRMW_16_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT16, UINT16)
    DECLARE_ALPHA_sRGB
    
    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    if (((ULONG_PTR) d) & 0x2)
    {
        if (SHOULDCOPY_sRGB(*alpha))
        {
            *(d) = *(s);
        }
                                        
        d++;
        s++;
        alpha += 4;
        count--;
    }

    // Now go through the aligned dword loop:

    while ((count -= 2) >= 0)
    {
        if (SHOULDCOPY_sRGB(*alpha))
        {
            if (SHOULDCOPY_sRGB(*(alpha + 4)))
            {
                // Both pixels have partial alpha, so do a dword read:

                *((UINT32*) d) = *((UNALIGNED UINT32*) s);
            }
            else
            {
                // Only the first pixel has partial alpha, so do a word read:

                *(d) = *(s);
            }
        }
        else if (SHOULDCOPY_sRGB(*(alpha + 4)))
        {
            // Only the second pixel has partial alpha, so do a word read:

            *(d + 1) = *(s + 1);
        }

        d += 2;
        s += 2;
        alpha += 8;
    }

    // Handle the end alignment:

    if (count & 1)
    {
        if (SHOULDCOPY_sRGB(*alpha))
        {
            *(d) = *(s);
        }
    }
}

// 16bpp, for sRGB64

VOID FASTCALL
ScanOperation::WriteRMW_16_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT16, UINT16)
    DECLARE_ALPHA_sRGB64

    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    if (((ULONG_PTR) d) & 0x2)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *(d) = *(s);
        }
                                        
        d++;
        s++;
        alpha += 4;
        count--;
    }

    // Now go through the aligned dword loop:

    while ((count -= 2) >= 0)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            if (SHOULDCOPY_sRGB64(*(alpha + 4)))
            {
                // Both pixels have partial alpha, so do a dword read:

                *((UINT32*) d) = *((UNALIGNED UINT32*) s);
            }
            else
            {
                // Only the first pixel has partial alpha, so do a word read:

                *(d) = *(s);
            }
        }
        else if (SHOULDCOPY_sRGB64(*(alpha + 4)))
        {
            // Only the second pixel has partial alpha, so do a word read:

            *(d + 1) = *(s + 1);
        }

        d += 2;
        s += 2;
        alpha += 8;
    }

    // Handle the end alignment:

    if (count & 1)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *(d) = *(s);
        }
    }
}

// 24bpp, for sRGB

VOID FASTCALL
ScanOperation::WriteRMW_24_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DECLARE_ALPHA_sRGB

    ASSERT(count>0);

    do {
        if (SHOULDCOPY_sRGB(*alpha))
        {
            // Doing byte per byte writes are much faster than finding
            //  runs and doing DWORD copies.
            *(d)     = *(s);
            *(d + 1) = *(s + 1);
            *(d + 2) = *(s + 2);
        }
        d += 3;
        s += 3;
        alpha += 4;
    } while (--count != 0);
}

// 24bpp, for sRGB64

VOID FASTCALL
ScanOperation::WriteRMW_24_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DECLARE_ALPHA_sRGB64

    ASSERT(count>0);

    do {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            // Doing byte per byte writes are much faster than finding
            //  runs and doing DWORD copies.
            *(d)     = *(s);
            *(d + 1) = *(s + 1);
            *(d + 2) = *(s + 2);
        }
        d += 3;
        s += 3;
        alpha += 4;
    } while (--count != 0);
}

// 32bpp, for sRGB

VOID FASTCALL
ScanOperation::WriteRMW_32_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT32, UINT32)
    DECLARE_ALPHA_sRGB
    
    while (count--)
    {
        if (SHOULDCOPY_sRGB(*alpha))
        {
            *d = *s;
        }
        
        d++;
        s++;
        alpha += 4;
    }
}

// 32bpp, for sRGB64

VOID FASTCALL
ScanOperation::WriteRMW_32_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT32, UINT32)
    DECLARE_ALPHA_sRGB64
    
    while (count--)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *d = *s;
        }
        
        d++;
        s++;
        alpha += 4;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\srgb.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   sRGB/sRGB64 conversion.
*
* Abstract:
*
*   Conversion between the sRGB and sRGB64 color spaces.
*
* Created:
*
*   6/9/1999 agodfrey
*
\**************************************************************************/

#ifndef _SRGB_HPP
#define _SRGB_HPP

// We cast ARGB and ARGB64 variables to these unions when necessary.
// We could instead define ARGB and ARGB64 to be unions themselves, but the
// compiler is bad at enregistering unions.

namespace sRGB
{

    // LinearizeLUT: Lookup table used to convert from sRGB to sRGB64
    static DWORD LinearizeLUT[256] = 
    {
        0x0, 0x2, 0x5, 0x7, 0xa, 0xc, 0xf, 0x11,
        0x14, 0x16, 0x19, 0x1b, 0x1e, 0x21, 0x24, 0x27,
        0x2a, 0x2e, 0x32, 0x35, 0x39, 0x3d, 0x42, 0x46,
        0x4b, 0x50, 0x55, 0x5a, 0x5f, 0x65, 0x6a, 0x70,
        0x76, 0x7d, 0x83, 0x8a, 0x91, 0x98, 0x9f, 0xa6,
        0xae, 0xb6, 0xbe, 0xc6, 0xce, 0xd7, 0xe0, 0xe9,
        0xf2, 0xfc, 0x105, 0x10f, 0x119, 0x124, 0x12e, 0x139,
        0x144, 0x14f, 0x15b, 0x166, 0x172, 0x17e, 0x18b, 0x197,
        0x1a4, 0x1b1, 0x1be, 0x1cc, 0x1da, 0x1e8, 0x1f6, 0x204,
        0x213, 0x222, 0x231, 0x240, 0x250, 0x260, 0x270, 0x281,
        0x291, 0x2a2, 0x2b3, 0x2c5, 0x2d6, 0x2e8, 0x2fa, 0x30d,
        0x31f, 0x332, 0x346, 0x359, 0x36d, 0x381, 0x395, 0x3a9,
        0x3be, 0x3d3, 0x3e9, 0x3fe, 0x414, 0x42a, 0x440, 0x457,
        0x46e, 0x485, 0x49d, 0x4b4, 0x4cc, 0x4e5, 0x4fd, 0x516,
        0x52f, 0x549, 0x562, 0x57c, 0x597, 0x5b1, 0x5cc, 0x5e7,
        0x603, 0x61e, 0x63a, 0x657, 0x673, 0x690, 0x6ad, 0x6cb,
        0x6e8, 0x706, 0x725, 0x743, 0x762, 0x781, 0x7a1, 0x7c1,
        0x7e1, 0x801, 0x822, 0x843, 0x864, 0x886, 0x8a8, 0x8ca,
        0x8ed, 0x910, 0x933, 0x956, 0x97a, 0x99e, 0x9c2, 0x9e7,
        0xa0c, 0xa32, 0xa57, 0xa7d, 0xaa3, 0xaca, 0xaf1, 0xb18,
        0xb40, 0xb68, 0xb90, 0xbb8, 0xbe1, 0xc0a, 0xc34, 0xc5e,
        0xc88, 0xcb2, 0xcdd, 0xd08, 0xd34, 0xd5f, 0xd8b, 0xdb8,
        0xde5, 0xe12, 0xe3f, 0xe6d, 0xe9b, 0xec9, 0xef8, 0xf27,
        0xf57, 0xf86, 0xfb6, 0xfe7, 0x1018, 0x1049, 0x107a, 0x10ac,
        0x10de, 0x1111, 0x1143, 0x1177, 0x11aa, 0x11de, 0x1212, 0x1247,
        0x127c, 0x12b1, 0x12e6, 0x131c, 0x1353, 0x1389, 0x13c0, 0x13f7,
        0x142f, 0x1467, 0x14a0, 0x14d8, 0x1511, 0x154b, 0x1585, 0x15bf,
        0x15f9, 0x1634, 0x166f, 0x16ab, 0x16e7, 0x1723, 0x1760, 0x179d,
        0x17da, 0x1818, 0x1856, 0x1895, 0x18d4, 0x1913, 0x1952, 0x1992,
        0x19d3, 0x1a13, 0x1a54, 0x1a96, 0x1ad7, 0x1b1a, 0x1b5c, 0x1b9f,
        0x1be2, 0x1c26, 0x1c6a, 0x1cae, 0x1cf3, 0x1d38, 0x1d7e, 0x1dc3,
        0x1e0a, 0x1e50, 0x1e97, 0x1edf, 0x1f26, 0x1f6f, 0x1fb7, 0x2000,
    };

    // Lookup table to convert alpha to sRGB64, which is:
    // LinearizeAlphaLUT[i]=i*SRGB_ONE/255;
    static DWORD LinearizeAlphaLUT[256]=
    {
        0x0000, 0x0020, 0x0040, 0x0060, 0x0080, 0x00A0, 0x00C0, 0x00E0,
        0x0101, 0x0121, 0x0141, 0x0161, 0x0181, 0x01A1, 0x01C1, 0x01E1,
        0x0202, 0x0222, 0x0242, 0x0262, 0x0282, 0x02A2, 0x02C2, 0x02E2,
        0x0303, 0x0323, 0x0343, 0x0363, 0x0383, 0x03A3, 0x03C3, 0x03E3,
        0x0404, 0x0424, 0x0444, 0x0464, 0x0484, 0x04A4, 0x04C4, 0x04E4,
        0x0505, 0x0525, 0x0545, 0x0565, 0x0585, 0x05A5, 0x05C5, 0x05E5,
        0x0606, 0x0626, 0x0646, 0x0666, 0x0686, 0x06A6, 0x06C6, 0x06E6,
        0x0707, 0x0727, 0x0747, 0x0767, 0x0787, 0x07A7, 0x07C7, 0x07E7,
        0x0808, 0x0828, 0x0848, 0x0868, 0x0888, 0x08A8, 0x08C8, 0x08E8,
        0x0909, 0x0929, 0x0949, 0x0969, 0x0989, 0x09A9, 0x09C9, 0x09E9,
        0x0A0A, 0x0A2A, 0x0A4A, 0x0A6A, 0x0A8A, 0x0AAA, 0x0ACA, 0x0AEA,
        0x0B0B, 0x0B2B, 0x0B4B, 0x0B6B, 0x0B8B, 0x0BAB, 0x0BCB, 0x0BEB,
        0x0C0C, 0x0C2C, 0x0C4C, 0x0C6C, 0x0C8C, 0x0CAC, 0x0CCC, 0x0CEC,
        0x0D0D, 0x0D2D, 0x0D4D, 0x0D6D, 0x0D8D, 0x0DAD, 0x0DCD, 0x0DED,
        0x0E0E, 0x0E2E, 0x0E4E, 0x0E6E, 0x0E8E, 0x0EAE, 0x0ECE, 0x0EEE,
        0x0F0F, 0x0F2F, 0x0F4F, 0x0F6F, 0x0F8F, 0x0FAF, 0x0FCF, 0x0FEF,
        0x1010, 0x1030, 0x1050, 0x1070, 0x1090, 0x10B0, 0x10D0, 0x10F0,
        0x1111, 0x1131, 0x1151, 0x1171, 0x1191, 0x11B1, 0x11D1, 0x11F1,
        0x1212, 0x1232, 0x1252, 0x1272, 0x1292, 0x12B2, 0x12D2, 0x12F2,
        0x1313, 0x1333, 0x1353, 0x1373, 0x1393, 0x13B3, 0x13D3, 0x13F3,
        0x1414, 0x1434, 0x1454, 0x1474, 0x1494, 0x14B4, 0x14D4, 0x14F4,
        0x1515, 0x1535, 0x1555, 0x1575, 0x1595, 0x15B5, 0x15D5, 0x15F5,
        0x1616, 0x1636, 0x1656, 0x1676, 0x1696, 0x16B6, 0x16D6, 0x16F6,
        0x1717, 0x1737, 0x1757, 0x1777, 0x1797, 0x17B7, 0x17D7, 0x17F7,
        0x1818, 0x1838, 0x1858, 0x1878, 0x1898, 0x18B8, 0x18D8, 0x18F8,
        0x1919, 0x1939, 0x1959, 0x1979, 0x1999, 0x19B9, 0x19D9, 0x19F9,
        0x1A1A, 0x1A3A, 0x1A5A, 0x1A7A, 0x1A9A, 0x1ABA, 0x1ADA, 0x1AFA,
        0x1B1B, 0x1B3B, 0x1B5B, 0x1B7B, 0x1B9B, 0x1BBB, 0x1BDB, 0x1BFB,
        0x1C1C, 0x1C3C, 0x1C5C, 0x1C7C, 0x1C9C, 0x1CBC, 0x1CDC, 0x1CFC,
        0x1D1D, 0x1D3D, 0x1D5D, 0x1D7D, 0x1D9D, 0x1DBD, 0x1DDD, 0x1DFD,
        0x1E1E, 0x1E3E, 0x1E5E, 0x1E7E, 0x1E9E, 0x1EBE, 0x1EDE, 0x1EFE,
        0x1F1F, 0x1F3F, 0x1F5F, 0x1F7F, 0x1F9F, 0x1FBF, 0x1FDF, 0x2000
    };

    union sRGBColor
    {
        struct 
        {
            BYTE b, g, r, a;
        };
        ARGB argb;
    };

    #define SRGB_FRACTIONBITS 13
    #define SRGB_INTEGERBITS (16-SRGB_FRACTIONBITS)
    #define SRGB_ONE (1<<(SRGB_FRACTIONBITS))
    #define SRGB_HALF (1<<(SRGB_FRACTIONBITS-1))

    union sRGB64Color
    {
        struct
        {
            INT16 b, g, r, a;
        };
        ARGB64 argb;
    };

    inline VOID ConvertTosRGB64(ARGB color,ARGB64 *result)
    {
        (*(DWORD*)result)=(LinearizeLUT[(DWORD)(color&0x0000ff00)>>8]<<16) | (LinearizeLUT[(DWORD)color&0x000000ff]);       // GGBB
        (*((DWORD*)result+1))=(LinearizeAlphaLUT[(DWORD)color>>24]<<16) | (LinearizeLUT[(DWORD)(color&0x00ff0000)>>16]);    // AARR
    }
    ARGB   ConvertTosRGB(ARGB64 color);

    // isTranslucent* returns FALSE if the specified alpha value is either
    // completely transparent or completely opaque.
    //
    // NOTE: This method EXPECTS overflow on the alpha byte (a tricky
    //       way to avoid an extra 'if')

    // Equivalent to: (alpha != 0) && (alpha != 255)
    inline BOOL isTranslucent(ARGB argb)
    {
		ASSERT((((ARGB)0)-1) > 0);         // Make sure ARGB is an unsigned dword
        return ((argb>>24)-1 < 0xFE);
    }

    // Equivalent to: (alpha > 0) && (alpha < sRGB::SRGB_ONE)
    // !!![agodfrey] Revisit this when we know the meaning of
    //     alpha > 1 and alpha < 0.
    
    inline BOOL isTranslucent64(INT16 alpha)
    {
        return (((UINT16) (alpha-1)) <= ((UINT16) SRGB_ONE));
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\stretch.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name & Abstract
*
*   Stretch. This module contains the code to do various stretching
*   by applying a kernel filter. The code correctly handles minification.
*
* Notes:
*
*   This code does not handle rotation or shear.
*
* Created:
*
*   04/17/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _STRETCH_HPP
#define _STRETCH_HPP


// All the filter modes supported by DpOutputSpanStretch.

enum FilterModeType {
    HighQualityBilinear = 0,
    HighQualityBicubic = 1,
    FilterModeMax
};

// Filter width is 1 for Bilinear and 2 for Bicubic.

const INT FilterWidth[FilterModeMax] = {1, 2};


template<FilterModeType FilterMode>
class DpOutputSpanStretch : public DpOutputSpan
{
public:
    const DpBitmap *dBitmap;
    BitmapData BmpData;
    DpScanBuffer *Scan;
    GpRectF SrcRect;
    GpRectF DstRect;

    // Wrap mode state

    WrapMode QWrapMode;
    ARGB ClampColor;
    BYTE ClampColorA;
    BYTE ClampColorR;
    BYTE ClampColorG;
    BYTE ClampColorB;
    BOOL WrapZeroClamp;

    // Destination rectangle for valid bits.
    // The valid bits are the translation of the source valid bits to
    // the destination space.

    FIX16 fixDLeft;
    FIX16 fixDTop;
    FIX16 fixDRight;
    FIX16 fixDBottom;

    // x scale state.

    FIX16 xkci;       // Initial x- kernel position 
    FIX16 xw;         // Width of x- kernel from center to edge
    FIX16 xa;         // 1/xw
    FIX16 xscale;     // x- scale factor (magnification or minification)
    FIX16 xscaleinv;  // 1/xscale
    INT ixleft;

    // y scale state.

    FIX16 ykci;       // Initial y- kernel position                           
    FIX16 yw;         // Width of y- kernel from center to edge               
    FIX16 ya;         // 1/yw                                                 
    FIX16 yscale;     // y- scale factor (magnification or minification)      
    FIX16 yscaleinv;  // 1/yscale                                             

    // This is the last y scanline that contributed to the previous run.

    INT last_k;

    // This is the destination y scanline corresponding to the top of the
    // destination rectangle.

    INT iytop;

    // Buffer to store the temporary results for the 1D x-scale.
    // The xbuffer is implemented as a rotational buffer of scanlines.
    // Each scanline is the width required to hold one destination width
    // scanline and there are enough scanlines to fill a y-dimension kernel.

    ARGB *xbuffer;

    // This represents the first scanline in the rotational xbuffer.

    INT xbuffer_start_scanline;

    // These represent the dimensions of the xbuffer - height is the number
    // of scanlines and width is the x-size in pixels.

    INT xbuffer_height;
    INT xbuffer_width;

    // This is an array of y-coefficient values.
    // The kernel weights are computed for each contributing scanline and
    // stored in this array (1-1 correspondence with the xbuffer) so that
    // they don't have to be recomputed for every x coordinate.

    FIX16 *ycoeff;

    bool isValid;

public:
    DpOutputSpanStretch(
        DpBitmap* bitmap,
        DpScanBuffer * scan,
        DpContext* context,
        DpImageAttributes imgAttributes,
        const GpRectF *dstRect,
        const GpRectF *srcRect
    )
    {
        InitializeClass(bitmap, scan, context, imgAttributes, dstRect, srcRect);
    }

    void InitializeClass(
        DpBitmap* bitmap,
        DpScanBuffer * scan,
        DpContext* context,
        DpImageAttributes imgAttributes,
        const GpRectF *dstRect,
        const GpRectF *srcRect
    );


    virtual GpStatus OutputSpan(
        INT y,
        INT xMin,
        INT xMax
    );

    void StretchScanline(
        ARGB *dst,       // destination pointer                                 
        ARGB *src,       // source pointer                                      
        INT dw,          // destination width (pixels)                          
        INT sw,          // source width (pixels)                               
        FIX16 kci,       // initial position of the kernel center               
        FIX16 scale,     // scale factor                                        
        FIX16 w,         // width from center of the kernel to the edge         
        FIX16 a          // 1/w                                                 
    );

    void StretchMiddleScanline2_MMX(
        ARGB *dst, 
        ARGB *src, 
        INT dw, 
        FIX16 kci
    );

    virtual BOOL IsValid() const { return (isValid && (dBitmap!=NULL)); }
    DpScanBuffer* GetScanBuffer(){ return Scan; }

    virtual ~DpOutputSpanStretch()
    {
        // throw away our working buffer.

        GpFree(xbuffer);
        GpFree(ycoeff);
    }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\stretch.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name & Abstract
*
*   Stretch. This module contains the code to do various stretching
*   by applying a kernel filter. The code correctly handles minification.
*
* Note:
*   This module is not compiled into an .obj file, rather it is included
*   directly into the header file stretch.hpp.
*   This is due to the use of template functions.
*
*
* Notes:
*
*   This code does not handle rotation or shear.
*
* Created:
*
*   04/17/2000 asecchia
*      Created it.
*
**************************************************************************/

// Actually all the code is moved to stretch.inc because
// it's implemented as a template class and has to be included in
// the module that causes it to be instantiated.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\texturefill.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   TextureFill.cpp
*
* Abstract:
*
*   texture fill routines.
*
* Revision History:
*
*    01/21/1999 ikkof
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Initializes the fixed point variables needed for texture mapping.
*
* Created:
*
*   03/14/2000 andrewgo
*
\**************************************************************************/

VOID
DpOutputBilinearSpan_MMX::InitializeFixedPointState()
{
    // If the numbers are too large for 16.16 fixed, we'll do the computation
    // in floating-point, per call to OutputSpan:

    ScaleMatrixValid =  GpValidFixed16(DeviceToWorld.GetM11()) &&
                        GpValidFixed16(DeviceToWorld.GetM12()) &&
                        GpValidFixed16(DeviceToWorld.GetM21()) &&
                        GpValidFixed16(DeviceToWorld.GetM22());

    if (ScaleMatrixValid)
    {
        GpPointF vector(1.0f, 0.0f);
        DeviceToWorld.VectorTransform(&vector);
        UIncrement = GpRound(vector.X * (1L << 16));
        VIncrement = GpRound(vector.Y * (1L << 16));

        TranslateMatrixValid = GpValidFixed16(DeviceToWorld.GetDx()) &&
                               GpValidFixed16(DeviceToWorld.GetDy());
                               
        if (TranslateMatrixValid)
        {
            M11 = GpRound(DeviceToWorld.GetM11() * (1L << 16));
            M12 = GpRound(DeviceToWorld.GetM12() * (1L << 16));
            M21 = GpRound(DeviceToWorld.GetM21() * (1L << 16));
            M22 = GpRound(DeviceToWorld.GetM22() * (1L << 16));
            Dx  = GpRound(DeviceToWorld.GetDx() * (1L << 16));
            Dy  = GpRound(DeviceToWorld.GetDy() * (1L << 16));
        }

        ModulusWidth = (BmpData.Width << 16);
        ModulusHeight = (BmpData.Height << 16);

        // When the u,v coordinates have the pixel in the last row or column
        // of the texture space, the offset of the pixel to the right and the
        // pixel below (for bilinear filtering) is the following (for tile modes)
        // because they wrap around the texture space.

        // The XEdgeIncrement is the byte increment of the pixel to the right of
        // the pixel on the far right hand column of the texture. In tile mode,
        // we want the pixel on the same scanline, but in the first column of the
        // texture hence 4bytes - stride

        XEdgeIncrement = 4-BmpData.Stride;

        // The YEdgeIncrement is the byte increment of the pixel below the current
        // pixel when the current pixel is in the last scanline of the texture.
        // In tile mode the correct pixel is the one directly above this one in
        // the first scanline - hence the increment below:

        YEdgeIncrement = -(INT)(BmpData.Height-1)*(INT)(BmpData.Stride);

        if ((BilinearWrapMode == WrapModeTileFlipX) ||
            (BilinearWrapMode == WrapModeTileFlipXY))
        {
            ModulusWidth *= 2;

            // Wrap increment is zero for Flip mode

            XEdgeIncrement = 0;
        }
        if ((BilinearWrapMode == WrapModeTileFlipY) ||
            (BilinearWrapMode == WrapModeTileFlipXY))
        {
            ModulusHeight *= 2;

            // Wrap increment is zero for Flip mode

            YEdgeIncrement = 0;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Texture brush constructor.
*
* Arguments:
*
* Created:
*
*   04/26/1999 ikkof
*
\**************************************************************************/

DpOutputBilinearSpan::DpOutputBilinearSpan(
    const GpTexture *textureBrush,
    DpScanBuffer *scan,
    GpMatrix *worldToDevice,
    DpContext *context
    )
{
    ASSERT(textureBrush);

    dBitmap = NULL;
    Scan     = scan;

    // Initialize the wrap state.

    BilinearWrapMode = textureBrush->GetWrapMode();
    ClampColor = 0;
    SrcRectClamp = FALSE;

    if(textureBrush->GetImageType() != ImageTypeBitmap)
    {
        // Currently, Metafile is not implemented yet.

        Bitmap = NULL;
        return;
    }

    Bitmap = textureBrush->GetBitmap();

    // on bad bitmap, we return with Valid = FALSE
    if (Bitmap == NULL ||
        !Bitmap->IsValid() ||
        Bitmap->LockBits(
            NULL,
            IMGLOCK_READ,
            PixelFormat32bppPARGB,
            &BmpData
        ) != Ok)
    {
        Bitmap = NULL;
        return;
    }

    Size size;
    Bitmap->GetSize(&size);

    SrcRect.X = SrcRect.Y = 0;
    SrcRect.Width  = (REAL)size.Width;
    SrcRect.Height = (REAL)size.Height;
    WorldToDevice = *worldToDevice;

    // If we have a PixelOffset of Half then offset the srcRect by -0.5
    // need to change the WorldToDevice to take this into account.
    // We need to do this here because texture brushes don't have enough
    // information to handle the PixelOffset at a higher level. We construct
    // the SrcRect here, so we apply the PixelOffset immediately.
    
    if (context->PixelOffset == PixelOffsetModeHalf ||
        context->PixelOffset == PixelOffsetModeHighQuality)
    {
        SrcRect.Offset(-0.5f, -0.5f);
        WorldToDevice.Translate(0.5f, 0.5f, MatrixOrderPrepend);
    }

    if(WorldToDevice.IsInvertible())
    {
        // !!![andrewgo] This failure case is bad, we will fall over
        //               later with an uninitialized DeviceToWorld.

        DeviceToWorld = WorldToDevice;
        DeviceToWorld.Invert();
    }
}

DpOutputBilinearSpan::DpOutputBilinearSpan(
    const DpBitmap *bitmap,
    DpScanBuffer *scan,
    GpMatrix *worldToDevice,
    DpContext *context,
    DpImageAttributes *imageAttributes
    )
{
    ASSERT(bitmap);

    dBitmap = bitmap;
    Scan     = scan;

    // Set the imageAttributes state that's relevant to the bilinear span.

    BilinearWrapMode = imageAttributes->wrapMode;
    ClampColor = imageAttributes->clampColor;
    SrcRectClamp = imageAttributes->srcRectClamp;

    Bitmap = NULL;

    // on bad bitmap, we return with Valid = FALSE
    if (dBitmap == NULL || !dBitmap->IsValid() )
    {
        dBitmap = NULL;
        return;
    }
    else
    {
        BmpData.Width = dBitmap->Width;
        BmpData.Height = dBitmap->Height;
        BmpData.PixelFormat = PIXFMT_32BPP_PARGB;
        BmpData.Stride = dBitmap->Delta;
        BmpData.Scan0 = dBitmap->Bits;
    }

    // NOTE: SrcRect is not used.
    // The HalfPixelOffset is already incorporated into the 
    // wordToDevice matrix passed in - which is not the same matrix as
    // context->WorldToDevice
    
    SrcRect.X = 0;
    SrcRect.Y = 0;
    SrcRect.Width  = (REAL)dBitmap->Width;
    SrcRect.Height = (REAL)dBitmap->Height;

    WorldToDevice = *worldToDevice;

    if(WorldToDevice.IsInvertible())
    {
        // !!![andrewgo] This failure case is bad, we will fall over
        //               later with an uninitialized DeviceToWorld.

        DeviceToWorld = WorldToDevice;
        DeviceToWorld.Invert();
    }
}



/**************************************************************************\
*
* Function Description:
*
*   Texture brush constructor.
*
* Arguments:
*
* Created:
*
*   04/26/1999 ikkof
*
\**************************************************************************/

DpOutputBilinearSpan::DpOutputBilinearSpan(
    DpBitmap* bitmap,
    DpScanBuffer * scan,
    DpContext* context,
    DpImageAttributes imageAttributes,
    INT numPoints,
    const GpPointF *dstPoints,
    const GpRectF *srcRect
    )
{
    // NOTE: This constructor is not used.
    // I have no idea if it even works anymore.
    
    WARNING(("DpOutputBilinearSpan: unsupported constructor"));
    
    Scan     = scan;
    BilinearWrapMode = imageAttributes.wrapMode;
    ClampColor = imageAttributes.clampColor;
    SrcRectClamp = imageAttributes.srcRectClamp;
    dBitmap  = bitmap;
    Bitmap   = NULL;

    // on bad bitmap, we return with Valid = FALSE
    if (dBitmap == NULL || !dBitmap->IsValid() )
    {
        dBitmap = NULL;
        return;
    }
    else
    {
        BmpData.Width = dBitmap->Width;
        BmpData.Height = dBitmap->Height;
        BmpData.PixelFormat = PIXFMT_32BPP_PARGB;
        BmpData.Stride = dBitmap->Delta;
        BmpData.Scan0 = dBitmap->Bits;
    }

    WorldToDevice = context->WorldToDevice;
    context->GetDeviceToWorld(&DeviceToWorld);

    // If we have a srcRect then it's already taking the PixelOffset mode into
    // account.
    if(srcRect)
        SrcRect = *srcRect;
    else
    {
        SrcRect.X = 0;
        SrcRect.Y = 0;
        SrcRect.Width  = (REAL)dBitmap->Width;
        SrcRect.Height = (REAL)dBitmap->Height;
        if (context->PixelOffset == PixelOffsetModeHalf ||
            context->PixelOffset == PixelOffsetModeHighQuality)
        {
            SrcRect.Offset(-0.5f, -0.5f);
        }
    }

    GpPointF points[4];

    GpMatrix xForm;
    BOOL existsTransform = TRUE;

    switch(numPoints)
    {
    case 0:
        points[0].X = 0;
        points[0].Y = 0;
        points[1].X = (REAL) SrcRect.Width;
        points[1].Y = 0;
        points[2].X = 0;
        points[2].Y = (REAL) SrcRect.Height;
        break;

    case 1:
        points[0] = dstPoints[0];
        points[1].X = (REAL) (points[0].X + SrcRect.Width);
        points[1].Y = points[0].Y;
        points[2].X = points[0].X;
        points[2].Y = (REAL) (points[0].Y + SrcRect.Height);
        break;

    case 3:
    case 4:
        GpMemcpy(&points[0], dstPoints, numPoints*sizeof(GpPointF));
        break;

    default:
        existsTransform = FALSE;
    }

    if(existsTransform)
    {
        xForm.InferAffineMatrix(points, SrcRect);
    }

    WorldToDevice = context->WorldToDevice;
    WorldToDevice.Prepend(xForm);
    if(WorldToDevice.IsInvertible())
    {
        DeviceToWorld = WorldToDevice;
        DeviceToWorld.Invert();
    }
}

/**************************************************************************\
*
* Function Description:
*
*   From the ARGB value of the four corners, this returns
*   the bilinearly interpolated ARGB value.
*
* Arguments:
*
*   [IN] colors - ARGB values at the four corners.
*   [IN] xFrac  - the fractional value of the x-coordinates.
*   [IN] yFrac  - the fractional value of the y-coordinates.
*   [IN] one, shift. half2, shift2 - the extra arguments used in the
*                                       calculations.
*
* Return Value:
*
*   ARGB: returns the biliearly interpolated ARGB.
*
* Created:
*
*   04/26/1999 ikkof
*
\**************************************************************************/

inline ARGB
getBilinearFilteredARGB(
    ARGB* colors,
    INT xFrac,
    INT yFrac,
    INT one,
    INT shift,
    INT half2,
    INT shift2)
{
    INT a[4], r[4], g[4], b[4];
    INT alpha, red, green, blue;

    for(INT k = 0; k < 4; k++)
    {
        ARGB c = colors[k];
        a[k] = GpColor::GetAlphaARGB(c);
        r[k] = GpColor::GetRedARGB(c);
        g[k] = GpColor::GetGreenARGB(c);
        b[k] = GpColor::GetBlueARGB(c);
    }

    alpha =
        (
            (one - yFrac)*((a[0] << shift)
            + (a[1] - a[0])*xFrac)
            + yFrac*((a[2] << shift)
            + (a[3] - a[2])*xFrac)
            + half2
        ) >> shift2;
    red =
        (
            (one - yFrac)*((r[0] << shift)
            + (r[1] - r[0])*xFrac)
            + yFrac*((r[2] << shift)
            + (r[3] - r[2])*xFrac)
            + half2
        ) >> shift2;
    green =
        (
            (one - yFrac)*((g[0] << shift)
            + (g[1] - g[0])*xFrac)
            + yFrac*((g[2] << shift)
            + (g[3] - g[2])*xFrac)
            + half2
        ) >> shift2;
    blue =
        (
            (one - yFrac)*((b[0] << shift)
            + (b[1] - b[0])*xFrac)
            + yFrac*((b[2] << shift)
            + (b[3] - b[2])*xFrac)
            + half2
        ) >> shift2;

    return  GpColor::MakeARGB
                (
                    (BYTE) alpha,
                    (BYTE) red,
                    (BYTE) green,
                    (BYTE) blue
                );
}



/**************************************************************************\
*
* Function Description:
*   virtual destructor for DpOutputBilinearSpan
*
\**************************************************************************/

DpOutputBilinearSpan::~DpOutputBilinearSpan()
{
    if (Bitmap != NULL)
    {
        Bitmap->UnlockBits(&BmpData);
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Applies the correct wrap mode to a set of coordinates
*
* Created:
*
*   03/10/2000 asecchia
*
\**************************************************************************/

void ApplyWrapMode(INT WrapMode, INT &x, INT &y, INT w, INT h)
{
    INT xm, ym;
    switch(WrapMode) {
    case WrapModeTile:
        x = RemainderI(x, w);
        y = RemainderI(y, h);
        break;
    case WrapModeTileFlipX:
        xm = RemainderI(x, w);
        if(((x-xm)/w) & 1) {
            x = w-1-xm;
        }
        else
        {
            x = xm;
        }
        y = RemainderI(y, h);
        break;
    case WrapModeTileFlipY:
        x = RemainderI(x, w);
        ym = RemainderI(y, h);
        if(((y-ym)/h) & 1) {
            y = h-1-ym;
        }
        else
        {
            y = ym;
        }
        break;
    case WrapModeTileFlipXY:
        xm = RemainderI(x, w);
        if(((x-xm)/w) & 1) {
            x = w-1-xm;
        }
        else
        {
            x = xm;
        }
        ym = RemainderI(y, h);
        if(((y-ym)/h) & 1) {
            y = h-1-ym;
        }
        else
        {
            y = ym;
        }
        break;
/*
    // WrapModeExtrapolate is no longer used.

    case WrapModeExtrapolate:
        // Clamp the coordinates to the edge pixels of the source
        if(x<0) x=0;
        if(x>w-1) x=w-1;
        if(y<0) y=0;
        if(y>h-1) y=h-1;
        break;
*/
    case WrapModeClamp:
        // Don't do anything - the filter code will substitute the clamp
        // color when it detects clamp.
    default:
        break;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster with a texture.
*   Is called by the rasterizer.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   01/21/1999 ikkof
*
\**************************************************************************/

GpStatus
DpOutputBilinearSpan::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    // Nothing to do.

    if(xMin==xMax)
    {
        return Ok;
    }

    ASSERT(xMin < xMax);

    ARGB    argb;
    INT     width  = xMax - xMin;
    ARGB *  buffer = Scan->NextBuffer(xMin, y, width);

    GpPointF pt1, pt2;
    pt1.X = (REAL) xMin;
    pt1.Y = pt2.Y = (REAL) y;
    pt2.X = (REAL) xMax;

    DeviceToWorld.Transform(&pt1);
    DeviceToWorld.Transform(&pt2);

    ARGB *srcPtr0 = static_cast<ARGB*> (BmpData.Scan0);
    INT stride = BmpData.Stride/sizeof(ARGB);
    INT i;

    REAL dx, dy, x0, y0;
    INT ix, iy;

    x0 = pt1.X;
    y0 = pt1.Y;

    ASSERT(width > 0);
    dx = (pt2.X - pt1.X)/width;
    dy = (pt2.Y - pt1.Y)/width;

    // Filtered image stretch.

    ARGB *srcPtr1, *srcPtr2;
    INT shift = 11;  // (2*shift + 8 < 32 bits --> shift < 12)
    INT shift2 = shift + shift;
    INT one = 1 << shift;
    INT half2 = 1 << (shift2 - 1);
    INT xFrac, yFrac;
    REAL real;
    ARGB colors[4];

    INT x1, y1, x2, y2;
    for(i = 0; i < width; i++)
    {
        iy = GpFloor(y0);
        ix = GpFloor(x0);
        xFrac = GpRound((x0 - ix)*one);
        yFrac = GpRound((y0 - iy)*one);

        x1=ix;
        x2=ix+1;
        y1=iy;
        y2=iy+1;

        if( ((UINT)ix >= (UINT)(BmpData.Width-1) ) ||
            ((UINT)iy >= (UINT)(BmpData.Height-1)) )
        {
            ApplyWrapMode(BilinearWrapMode, x1, y1, BmpData.Width, BmpData.Height);
            ApplyWrapMode(BilinearWrapMode, x2, y2, BmpData.Width, BmpData.Height);
        }

        if(y1 >= 0 && y1 < (INT) BmpData.Height)
        {
            srcPtr1 = srcPtr0 + stride*y1;
        }
        else
        {
            srcPtr1 = NULL;
        }

        if(y2 >= 0 && y2 < (INT) BmpData.Height)
        {
            srcPtr2 = srcPtr0 + stride*y2;
        }
        else
        {
            srcPtr2 = NULL;
        }

        if(x1 >= 0 && x1 < (INT) BmpData.Width)
        {
            if(srcPtr1)
            {
                colors[0] = *(srcPtr1 + x1);
            }
            else
            {
                colors[0] = ClampColor;
            }

            if(srcPtr2)
            {
                colors[2] = *(srcPtr2 + x1);
            }
            else
            {
                colors[2] = ClampColor;
            }
        }
        else
        {
            colors[0] = ClampColor;
            colors[2] = ClampColor;
        }

        if(x2 >= 0 && x2 < (INT) BmpData.Width)
        {
            if(srcPtr1)
            {
                colors[1] = *(srcPtr1 + x2);
            }
            else
            {
                colors[1] = ClampColor;
            }

            if(srcPtr2)
            {
                colors[3] = *(srcPtr2 + x2);
            }
            else
            {
                colors[3] = ClampColor;
            }
        }
        else
        {
            colors[1] = ClampColor;
            colors[3] = ClampColor;
        }

        if((x2 >= 0) &&
           (x1 < (INT) BmpData.Width) &&
           (y2 >= 0) &&
           (y1 < (INT) BmpData.Height))
        {
            *buffer++ = ::getBilinearFilteredARGB(
                colors,
                xFrac,
                yFrac,
                one,
                shift,
                half2,
                shift2
            );
        }
        else
        {
            *buffer++ = ClampColor;
        }

        x0 += dx;
        y0 += dy;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Handles bilinear texture drawing with arbitrary rotation using MMX.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   01/06/2000 andrewgo
*
\**************************************************************************/

GpStatus
DpOutputBilinearSpan_MMX::OutputSpan(
    INT y,
    INT xMin,
    INT xMax   // xMax is exclusive
    )
{
    // Be a little paranoid in checking some state.

    ASSERT((((ULONG_PTR) BmpData.Scan0) & 3) == 0);
    ASSERT((BmpData.Stride & 3) == 0);
    ASSERT(xMax > xMin);

#if defined(_X86_)

    INT count = xMax - xMin;
    ARGB *buffer = Scan->NextBuffer(xMin, y, count);

    // Transform an array of points using the matrix v' = v M:
    //
    //                                  ( M11 M12 0 )
    //      (vx', vy', 1) = (vx, vy, 1) ( M21 M22 0 )
    //                                  ( dx  dy  1 )
    //
    // All (u, v) calculations are done in 16.16 fixed point.

    INT u;
    INT v;

    // If the values were out of range for fixed point, compute u and v in
    // floating-point, then convert:

    if (TranslateMatrixValid)
    {
        u = M11 * xMin + M21 * y + Dx;
        v = M12 * xMin + M22 * y + Dy;
    }
    else
    {
        GpPointF point(TOREAL(xMin), TOREAL(y));
        DeviceToWorld.Transform(&point, 1);

        u = GpRound(point.X * (1 << 16));
        v = GpRound(point.Y * (1 << 16));
    }

    INT uIncrement = UIncrement;
    INT vIncrement = VIncrement;
    INT modulusWidth = ModulusWidth;
    INT modulusHeight = ModulusHeight;
    VOID *scan0 = BmpData.Scan0;
    INT stride = BmpData.Stride;
    INT width = BmpData.Width;
    INT height = BmpData.Height;
    INT xEdgeIncrement = XEdgeIncrement;
    INT yEdgeIncrement = YEdgeIncrement;

    INT widthMinus1 = width - 1;
    INT heightMinus1 = height - 1;
    UINT uMax = widthMinus1 << 16;
    UINT vMax = heightMinus1 << 16;
    BOOL clampMode = (BilinearWrapMode == WrapModeClamp);
    ARGB clampColor = ClampColor;
    static ULONGLONG Half8dot8 = 0x0080008000800080;

    _asm
    {
        mov         eax, u
        mov         ebx, v
        mov         ecx, stride
        mov         edi, buffer
        pxor        mm0, mm0
        movq        mm3, Half8dot8

        ; edx = scratch
        ; esi = source pixel

    PixelLoop:

        ; Most of the time, our texture coordinate will be from the interior
        ; of the texture.  Things only really get tricky when we have to
        ; span the texture edges.
        ;
        ; Fortunately, the interior case will happen most of the time,
        ; so we make that as fast as possible.  We pop out-of-line to
        ; handle the tricky cases.

        cmp         eax, uMax
        jae         HandleTiling            ; Note unsigned compare

        cmp         ebx, vMax
        jae         HandleTiling            ; Note unsigned compare

        mov         edx, eax
        shr         edx, 14
        and         edx, 0xfffffffc

        mov         esi, ebx
        shr         esi, 16
        imul        esi, ecx

        add         esi, edx
        add         esi, scan0              ; esi = upper left pixel

        ; Stall city.  Write first, then reorder with VTune.

        movd        mm4, [esi]
        movd        mm5, [esi+4]
        movd        mm6, [esi+ecx]
        movd        mm7, [esi+ecx+4]

    ContinueLoop:
        movd        mm1, eax
        punpcklwd   mm1, mm1
        punpckldq   mm1, mm1
        psrlw       mm1, 8                  ; mm1 = x fraction in low bytes

        movd        mm2, ebx
        punpcklwd   mm2, mm2
        punpckldq   mm2, mm2
        psrlw       mm2, 8                  ; mm2 = y fraction in low bytes

        punpcklbw   mm4, mm0
        punpcklbw   mm5, mm0                ; unpack pixels A & B to low bytes

        psubw       mm5, mm4
        pmullw      mm5, mm1
        paddw       mm5, mm3
        psrlw       mm5, 8
        paddb       mm5, mm4                ; mm5 = A' = A + xFrac * (B - A)

        punpcklbw   mm6, mm0
        punpcklbw   mm7, mm0                ; unpack pixels C & D to low bytes

        psubw       mm7, mm6
        pmullw      mm7, mm1
        paddw       mm7, mm3
        psrlw       mm7, 8
        paddb       mm7, mm6                ; mm7 = B' = C + xFrac * (D - C)

        psubw       mm7, mm5
        pmullw      mm7, mm2
        paddw       mm7, mm3
        psrlw       mm7, 8
        paddb       mm7, mm5                ; mm7 = A' + yFrac * (B' - A')

        packuswb    mm7, mm7
        movd        [edi], mm7              ; write the final pixel

        add         eax, uIncrement
        add         ebx, vIncrement
        add         edi, 4

        dec         count
        jnz         PixelLoop
        jmp         AllDone

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;
    ; Handle tiling cases here
    ;
    ; All the tough edge cases are handled here, where we deal with
    ; texture coordinates that span the texture boundary.

    HandleTiling:
        cmp         clampMode, 0
        jnz         HandleClamping

        ; Get 'u' in the range 0 <= u < modulusWidth:

        cmp         eax, modulusWidth
        jb          WidthInRange            ; note unsigned compare

        cdq
        idiv        modulusWidth
        mov         eax, edx                ; u %= modulusWidth

        cmp         eax, 0
        jge         WidthInRange
        add         eax, modulusWidth       ; 0 <= u < modulusWidth

    WidthInRange:

        ; Get 'v' in the range 0 <= v < modulusHeight:

        cmp         ebx, modulusHeight
        jb          HeightInRange

        push        eax
        mov         eax, ebx
        cdq
        idiv        modulusHeight
        mov         ebx, edx                ; v %= modulusHeight
        pop         eax

        cmp         ebx, 0
        jge         HeightInRange
        add         ebx, modulusHeight      ; 0 <= v < modulusHeight

    HeightInRange:

        ; Now we're going to need to convert our 'u' and 'v' values
        ; to integers, so save the 16.16 versions:

        push        eax
        push        ebx
        push        ecx
        push        edi

        sar         eax, 16
        sar         ebx, 16                 ; note arithmetic shift

        ; Handle 'flipping'.  Note that edi hold flipping flags, where
        ; the bits have the following meanings:
        ;   1 = X flip in progress
        ;   2 = Y flip in progress
        ;   4 = X flip end boundary not yet reached
        ;   8 = Y flip end boundary not yet reached.

        xor         edi, edi
        cmp         eax, width
        jb          XFlipHandled

        ; u is in the range (width <= u < 2*width).
        ;
        ; We want to flip it such that (0 <= u' < width), which we do by
        ; u' = 2*width - u - 1.  Don't forget ~u = -u - 1.

        or          edi, 1                  ; mark the flip
        not         eax
        add         eax, width
        add         eax, width
        jz          XFlipHandled
        sub         eax, 1
        or          edi, 4                  ; mark flip where adjacent pixels available


    XFlipHandled:
        cmp         ebx, height
        jb          YFlipHandled


        ; v is in the range (height <= v < 2*height).
        ;
        ; We want to flip it such that (0 <= v' < height), which we do by
        ; v' = 2*height - v - 1.  Don't forget ~v = -v - 1.

        or          edi, 2                  ; mark the flip
        not         ebx
        add         ebx, height
        add         ebx, height
        jz          YFlipHandled
        sub         ebx, 1
        or          edi, 8                  ; mark flip where adjacent pixels available

    YFlipHandled:
        mov         esi, ebx
        imul        esi, ecx                ; esi = y * stride

        ; Set 'edx' to the byte offset to the pixel one to the right, accounting
        ; for wrapping past the edge of the bitmap.  Only set the byte offset to
        ; point to right pixel for non edge cases.

        mov         edx, 4
        test        edi, 4
        jnz         RightIncrementCalculated
        test        edi, 1
        jnz         SetXEdgeInc
        cmp         eax, widthMinus1
        jb          RightIncrementCalculated
    SetXEdgeInc:
        mov         edx, xEdgeIncrement

        ; When we flipX and the current pixel is the last pixel in the texture
        ; line, wrapping past the end of the bitmap wraps back in the same side
        ; of the bitmap. I.e. for this one specific pixel we can set the pixel
        ; on-the-right to be the same as this pixel (increment of zero).
        ; Only valid because this is the edge condition.
        ; Note that this will occur for two successive pixels as the texture
        ; wrap occurs - first at width-1 and then at width-1 after wrapping.
        ;
        ; A | B
        ; --+--
        ; C | D
        ;
        ; At this point, pixel A has been computed correctly accounting for the
        ; flip/tile and wrapping beyond the edge of the texture. We work out
        ; the offset of B from A, but we again need to take into account the
        ; possible flipX mode if pixel A happens to be the last pixel in the
        ; texture scanline (the code immediately above takes into account
        ; tiling across the texture boundary, but not the flip)


    RightIncrementCalculated:

        ; Set 'ecx' to the byte offset to the pixel one down, accounting for
        ; wrapping past the edge of the bitmap.  Only set the byte offset to
        ; point to one pixel down for non edge cases.

        test        edi, 8
        jnz         DownIncrementCalculated
        test        edi, 2
        jnz         SetYEdgeInc
        cmp         ebx, heightMinus1
        jb          DownIncrementCalculated
    SetYEdgeInc:
        mov         ecx, yEdgeIncrement

        ; When we flipY and the current pixel is in the last scanline in the
        ; texture, wrapping past the end of the bitmap wraps back in the same
        ; side of the bitmap. I.e. for this one specific scanline we can set
        ; the pixel offset one down to be the same as this pixel
        ; (increment of zero).
        ; Only valid because this is the edge condition.
        ; (see comment above RightIncrementCalculated:)

    DownIncrementCalculated:

        ; Finish calculating the upper-left pixel address:

        add         esi, scan0
        shl         eax, 2
        add         esi, eax                ; esi = upper left pixel

        ; Load the 4 pixels:

        movd        mm4, [esi]
        movd        mm5, [esi+edx]
        add         esi, ecx
        movd        mm6, [esi]
        movd        mm7, [esi+edx]

        ; Finish handling the flip:

        test        edi, 1
        jz          XSwapDone

        movq        mm1, mm5
        movq        mm5, mm4
        movq        mm4, mm1                ; swap pixels A and B

        movq        mm1, mm6
        movq        mm6, mm7
        movq        mm7, mm1                ; swap pixels C and D

    XSwapDone:
        test        edi, 2
        jz          YSwapDone

        movq        mm1, mm4
        movq        mm4, mm6
        movq        mm6, mm1                ; swap pixels A and C

        movq        mm1, mm5
        movq        mm5, mm7
        movq        mm7, mm1                ; swap pixels B and D

    YSwapDone:

        ; Restore everything and get out:

        pop         edi
        pop         ecx
        pop         ebx
        pop         eax
        jmp         ContinueLoop

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;
    ; Clamp mode.
    ;
    ; Set the pixel values to 0 for any not on the texture.

    HandleClamping:
        push        eax
        push        ebx

        movd        mm4, clampColor
        movq        mm5, mm4
        movq        mm6, mm4                ; initialize invisible pixels to
        movq        mm7, mm4                ; the clampColor.

        sar         eax, 16
        sar         ebx, 16                 ; note these are arithmetic shifts

        ; We need to look at a 2x2 square of pixels in the texture, where
        ; (eax, ebx) represents the (x, y) texture coordinates.  First we
        ; check for the case where none of the four pixel locations are
        ; actually anywhere on the texture.

        cmp         eax, -1
        jl          FinishClamp
        cmp         eax, width
        jge         FinishClamp             ; early out if (x < -1) or (x >= width)

        cmp         ebx, -1
        jl          FinishClamp
        cmp         ebx, height
        jge         FinishClamp             ; handle trivial rejection

        ; Okay, now we know that we have to pull at least one pixel from
        ; the texture.  Find the address of the upper-left pixel:

        mov         edx, eax
        shl         edx, 2
        mov         esi, ebx
        imul        esi, ecx
        add         esi, edx
        add         esi, scan0              ; esi = upper left pixel

        ; Our pixel nomenclature for the 2x2 square is as follows:
        ;
        ;   A | B
        ;  ---+---
        ;   C | D

        cmp         ebx, 0                  ; if (y < 0), we can't look at
        jl          Handle_CD               ;   row y
        cmp         eax, 0                  ; if (x < 0), we can't look at
        jl          Done_A                  ;   column x
        movd        mm4, [esi]              ; read pixel (x, y)

    Done_A:
        cmp         eax, widthMinus1        ; if (x >= width - 1), we can't
        jge         Handle_CD               ;   look at column x
        movd        mm5, [esi+4]            ; read pixel (x+1, y)

    Handle_CD:
        cmp         ebx, heightMinus1       ; if (y >= height - 1), we can't
        jge         FinishClamp             ;   look at row y
        cmp         eax, 0                  ; if (x < 0), we can't look at
        jl          Done_C                  ;   column x
        movd        mm6, [esi+ecx]          ; read pixel (x, y+1)

    Done_C:
        cmp         eax, widthMinus1        ; if (x >= width - 1), we can't
        jge         FinishClamp             ;   look at column x
        movd        mm7, [esi+ecx+4]        ; read pixel (x+1, y+1)

    FinishClamp:
        pop         ebx
        pop         eax
        jmp         ContinueLoop

    AllDone:
        emms

    }

#endif

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Output routine for handling texture brushes with indentity transforms
*   and either 'Tile' or 'Clamp' wrap modes.
*
* Created:
*
*   03/14/2000 andrewgo
*
\**************************************************************************/
GpStatus
DpOutputBilinearSpan_Identity::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    ASSERT(xMax > xMin);

    INT count = xMax - xMin;
    ARGB *buffer = Scan->NextBuffer(xMin, y, count);

    INT u = xMin + Dx;
    INT v = y + Dy;
    INT width = BmpData.Width;
    INT height = BmpData.Height;
    INT i;

    if (BilinearWrapMode == WrapModeTile)
    {
        if (PowerOfTwo)
        {
            u &= (width - 1);
            v &= (height - 1);
        }
        else
        {
            // Single unsigned compare handles (u < 0) and (u >= width)

            if (static_cast<unsigned>(u) >= static_cast<unsigned>(width))
            {
                u = RemainderI(u, width);
            }

            // Single unsigned compare handles (v < 0) and (v >= width)

            if (static_cast<unsigned>(v) >= static_cast<unsigned>(height))
            {
                v = RemainderI(v, height);
            }
        }

        ARGB *row = reinterpret_cast<ARGB*>
                    (static_cast<BYTE*>(BmpData.Scan0) + (v * BmpData.Stride));
        ARGB *src;

        src = row + u;
        i = min(width - u, count);
        count -= i;

        // We don't call GpMemcpy here because by doing the copy explicitly,
        // the compiler still converts to a 'rep movsd', but it doesn't have
        // to add to the destination 'buffer' pointer when done:

        do {
            *buffer++ = *src++;

        } while (--i != 0);

        while (count > 0)
        {
            src = row;
            i = min(width, count);
            count -= i;

            do {
                *buffer++ = *src++;

            } while (--i != 0);
        }
    }
    else
    {
        ASSERT(BilinearWrapMode == WrapModeClamp);

        ARGB borderColor = ClampColor;

        // Check for trivial rejection.  Unsigned compare handles
        // (v < 0) and (v >= height).

        if ((static_cast<unsigned>(v) >= static_cast<unsigned>(height)) ||
            (u >= width) ||
            (u + count <= 0))
        {
            // The whole scan should be the border color:

            i = count;
            do {
                *buffer++ = borderColor;

            } while (--i != 0);
        }
        else
        {
            ARGB *src = reinterpret_cast<ARGB*>
                        (static_cast<BYTE*>(BmpData.Scan0) + (v * BmpData.Stride));

            if (u < 0)
            {
                i = -u;
                count -= i;
                do {
                    *buffer++ = borderColor;

                } while (--i != 0);
            }
            else
            {
                src += u;
                width -= u;
            }

            i = min(count, width);
            ASSERT(i > 0);              // Trivial rejection ensures this
            count -= i;


            /*
            The compiler was generating particularly stupid code
            for this loop.

            do {
                *buffer++ = *src++;

            } while (--i != 0);
            */

            GpMemcpy(buffer, src, i*sizeof(ARGB));
            buffer += i;

            while (count-- > 0)
            {
                *buffer++ = borderColor;
            }
        }
    }

    return(Ok);
}

/**************************************************************************\
*
* Function Description:
*
*   Hatch brush constructor.
*
* Arguments:
*
* Created:
*
*   04/15/1999 ikkof
*
\**************************************************************************/

DpOutputHatchSpan::DpOutputHatchSpan(
    const GpHatch *hatchBrush,
    DpScanBuffer * scan,
    DpContext* context
    )
{
    Scan = scan;
    ForeARGB = hatchBrush->DeviceBrush.Colors[0].GetPremultipliedValue();
    BackARGB = hatchBrush->DeviceBrush.Colors[1].GetPremultipliedValue();

    // Store the context rendering origin for the brush origin.
    
    m_BrushOriginX = context->RenderingOriginX;
    m_BrushOriginY = context->RenderingOriginY;

    INT a[3], r[3], g[3], b[3];

    a[0] = (BYTE) GpColor::GetAlphaARGB(ForeARGB);
    r[0] = (BYTE) GpColor::GetRedARGB(ForeARGB);
    g[0] = (BYTE) GpColor::GetGreenARGB(ForeARGB);
    b[0] = (BYTE) GpColor::GetBlueARGB(ForeARGB);
    a[1] = (BYTE) GpColor::GetAlphaARGB(BackARGB);
    r[1] = (BYTE) GpColor::GetRedARGB(BackARGB);
    g[1] = (BYTE) GpColor::GetGreenARGB(BackARGB);
    b[1] = (BYTE) GpColor::GetBlueARGB(BackARGB);

    a[2] = (a[0] + 3*a[1]) >> 2;
    r[2] = (r[0] + 3*r[1]) >> 2;
    g[2] = (g[0] + 3*g[1]) >> 2;
    b[2] = (b[0] + 3*b[1]) >> 2;
    AverageARGB = GpColor::MakeARGB((BYTE) a[2], (BYTE) r[2],
                        (BYTE) g[2], (BYTE) b[2]);

    // Antialiase diagonal hatches.
    if(hatchBrush->DeviceBrush.Style == HatchStyleForwardDiagonal ||
        hatchBrush->DeviceBrush.Style == HatchStyleBackwardDiagonal ||
        hatchBrush->DeviceBrush.Style == HatchStyleDiagonalCross)
    {
        REAL temp;

        // occupied = (2*sqrt(2) - 1)/2

        REAL occupied = TOREAL(0.914213562);

        if(a[0] != 255 || a[1] != 255)
        {
            temp = TOREAL(occupied*(a[0] - a[1]) + a[1]);
            a[0] = (BYTE) temp;
        }
        temp = TOREAL(occupied*(r[0] - r[1]) + r[1]);
        if(temp > 255)
            r[0] = 255;
        else
            r[0] = (BYTE) temp;
        temp = TOREAL(occupied*(g[0] - g[1]) + g[1]);
        if(temp > 255)
            g[0] = 255;
        else
            g[0] = (BYTE) temp;
        temp = TOREAL(occupied*(b[0] - b[1]) + b[1]);
        if(temp > 255)
            b[0] = 255;
        else
            b[0] = (BYTE) temp;
        ForeARGB = GpColor::MakeARGB((BYTE) a[0], (BYTE) r[0],
                            (BYTE) g[0], (BYTE) b[0]);
    }

    for(INT i = 0; i < 8; i++)
    {
        for(INT j= 0; j < 8; j++)
        {
            Data[i][j] = hatchBrush->DeviceBrush.Data[i][j];
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster with a hatch brush
*   Is called by the rasterizer.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   04/15/1999 ikkof
*
\**************************************************************************/

GpStatus
DpOutputHatchSpan::OutputSpan(
    INT y,
    INT xMin,
    INT xMax   // xMax is exclusive
    )
{
    ARGB    argb;
    INT     width  = xMax - xMin;
    ARGB*   buffer = Scan->NextBuffer(xMin, y, width);

    INT yMod = (y - m_BrushOriginY) & 0x7;

    for(INT x = xMin; x < xMax; x++)
    {
        INT xMod = (x - m_BrushOriginX) & 0x7;
        INT value = Data[yMod][xMod];
        if(value == 255)
            *buffer++ = ForeARGB;
        else if(value == 0)
            *buffer++ = BackARGB;
        else
            *buffer++ = AverageARGB;    // for antialising.
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster with a hatch brush
*   Is called by the rasterizer.  This is a special version which stretches
*   up the size of the hatch span to device resolution.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   2/20/1 - ericvan
*
\**************************************************************************/

GpStatus
DpOutputStretchedHatchSpan::OutputSpan(
    INT y,
    INT xMin,
    INT xMax   // xMax is exclusive
    )
{
    ARGB    argb;
    INT     width  = xMax - xMin;
    ARGB*   buffer = Scan->NextBuffer(xMin, y, width);

    INT yMod = (y - m_BrushOriginY) % (8*ScaleFactor);
        
    for(INT x = xMin; x < xMax; x++)
    {
        INT xMod = (x - m_BrushOriginX) % (8*ScaleFactor);
        INT value = Data[yMod/ScaleFactor][xMod/ScaleFactor];
        if(value == 255)
            *buffer++ = ForeARGB;
        else if(value == 0)
            *buffer++ = BackARGB;
        else
            *buffer++ = AverageARGB;    // for antialising.
    }

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\vgahash.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   VGA color hash table
*
* Abstract:
*
*   This module maintains a hash table which holds the 20 VGA colors
*   (this includes the 4 which can be modified.)
*   The 8bpp halftone code, for example, needs to detect these colors
*   so that it doesn't halftone them.
*
* Notes:
*
*   The collision algorithm is designed to place very little
*   burden on the lookup code. It'll produce bad performance when there
*   are many collisions - which is fine since we expect only
*   a few collisions at most.
*
* Created:
*
*   04/06/2000 agodfrey
*      Created it.
*
**************************************************************************/

#include "precomp.hpp"

// The hash table. VgaColorHash is the actual hash table. It is
// initialized from VgaColorHashInit, and then the 4 magic colors are added.
//
// An entry has the following layout:
//
// Bits 0-23:  The RGB color
// Bits 24-29: The palette index for that color. This is an index into
//             our logical palette (HTColorPalette).
// Bit 30:     FALSE if the entry is empty, TRUE if it is occupied.
// Bit 31:     Used for collisions - if this is TRUE, the lookup function
//             should continue to the next entry.

ARGB VgaColorHash[VGA_HASH_SIZE];
static ARGB VgaColorHashInit[VGA_HASH_SIZE] = {
    0x40000000, 0x00000000, 0x00000000, 0x00000000,
    0x44000080, 0x00000000, 0x00000000, 0x500000ff,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x42008000, 0x00000000, 0x00000000, 0x00000000,
    0x46008080, 0x00000000, 0x00000000, 0x00000000,
    0x5200ffff, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x4e00ff00,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x41800000, 0x00000000, 0x00000000, 0x00000000,
    0x45800080, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x43808000, 0x00000000, 0x00000000, 0x00000000,
    0x4c808080, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x4fffff00, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x53ffffff,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x51ff00ff, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x47c0c0c0, 0x4dff0000
};

/**************************************************************************
*
* Function Description:
*
*   Finds an entry in the table.
*
* Arguments:
*
*   color - the color to find
*
* Return Value:
*
*   The index corresponding to that color, or 0xff if not found.
*
* Notes:
*
*   I don't expect performance-critical code to use this -
*   e.g. HalftoneToScreen_sRGB_8_216 needs to do this inline -
*   but it's useful for other code.
*
* Created:
*
*   04/08/2000 agodfrey
*      Created it.
*
**************************************************************************/

BYTE 
VGAHashLookup(
    COLORREF color
    )
{
    UINT hashKey = VGAHashColor(
        GetRValue(color),
        GetGValue(color),
        GetBValue(color)
        );

    ARGB rgbColor = (GetRValue(color) << 16) |
        (GetGValue(color) << 8) |
        GetBValue(color);
        
    UINT tblEntry;
    
    do
    {
        tblEntry = VgaColorHash[hashKey];
        
        if (((tblEntry ^ rgbColor) & 0xffffff) == 0)
        {
            return (tblEntry >> 24) & 0x3f;
        }
        
        if (static_cast<INT>(tblEntry) >= 0)
        {
            break;
        }
        
        hashKey++;
        hashKey &= (1 << VGA_HASH_BITS) - 1;
    } while (1);
            
    return 0xff;
}

/**************************************************************************
*
* Function Description:
*
*   Adds an entry to the hash table. If the same color is already in
*   the table, adds nothing.
*
* Arguments:
*
*   color - the color to add
*   index - the palette index of the color
*
* Return Value:
*
*   NONE
*
* Created:
*
*   04/06/2000 agodfrey
*      Created it.
*
**************************************************************************/

VOID 
VGAHashAddEntry(
    COLORREF color,
    INT index
    )
{
    ASSERT ((index >= 0) & (index < 0x40));
    
    if (VGAHashLookup(color) != 0xff)
    {
        return;
    }
    
    UINT hashKey = VGAHashColor(
        GetRValue(color),
        GetGValue(color),
        GetBValue(color)
        );

    ARGB rgbColor = (GetRValue(color) << 16) |
        (GetGValue(color) << 8) |
        GetBValue(color);
   
    // Find an empty location
        
    while (VgaColorHash[hashKey] & 0x40000000)
    {
        // Set the high bit of each occupied location we hit, so that
        // the lookup code will find the value we're about to add.
        
        VgaColorHash[hashKey] |= 0x80000000;
        hashKey++;
        if (hashKey == VGA_HASH_SIZE)
        {
            hashKey = 0;
        }
    }
    
    // Store the new entry
    
    VgaColorHash[hashKey] = (rgbColor & 0xffffff) | (index << 24) | 0x40000000;
}

/**************************************************************************
*
* Function Description:
*
*   Reinitializes the hash table, and adds the given 4 magic colors.
*
* Arguments:
*
*   magicColors - the 4 magic colors
*
* Return Value:
*
*   NONE
*
* Created:
*
*   04/06/2000 agodfrey
*      Created it.
*
**************************************************************************/

VOID 
VGAHashRebuildTable(
    COLORREF *magicColors
    )
{
    GpMemcpy(VgaColorHash, VgaColorHashInit, sizeof(VgaColorHashInit));
    VGAHashAddEntry(magicColors[0], 8);
    VGAHashAddEntry(magicColors[1], 9);
    VGAHashAddEntry(magicColors[2], 10);
    VGAHashAddEntry(magicColors[3], 11);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\basetypes.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   BaseTypes.hpp
*
* Abstract:
*
*   Basic types used by GDI+ implementation
*
* Revision History:
*
*   12/01/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _BASETYPES_HPP
#define _BASETYPES_HPP

#ifdef _X86_
#define FASTCALL _fastcall
#else
#define FASTCALL
#endif

//
// TODO: Remove the 'Gp' prefix from all these classes
// TODO: What is a GlyphPos? Why is it a base type?
// 

namespace GpRuntime
{

//--------------------------------------------------------------------------
// Forward declarations of various internal classes
//--------------------------------------------------------------------------

typedef double REALD;

//--------------------------------------------------------------------------
// Represents a dimension in a 2D coordinate system
//  (integer coordinates)
//--------------------------------------------------------------------------

class GpSize
{
public:

    // Default constructor

    GpSize()
    {
        // NOTE: Size is uninitialized by default.
        // Specicifically, it's not initialized to 0,0.
    }

    // Construct a Size object using the specified
    // x- and y- dimensions.

    GpSize(INT width, INT height)
    {
        Width = width;
        Height = height;
    }

public:

    // The fields are public here.

    INT Width;
    INT Height;
};

//--------------------------------------------------------------------------
// Represents a location in a 2D coordinate system
//  (integer coordinates)
//--------------------------------------------------------------------------

class GpPoint
{
public:

    // Default constructor

    GpPoint()
    {
    }

    // Construct a Point object using the specified
    // x- and y- coordinates.

    GpPoint(INT x, INT y)
    {
        X = x;
        Y = y;
    }

public:

    INT X;
    INT Y;
};

class GpPointD
{
public:

    // Default constructor

    GpPointD()
    {
    }

    // Construct a Point object using the specified
    // x- and y- coordinates.

    GpPointD(REALD x, REALD y)
    {
        X = x;
        Y = y;
    }

public:

    REALD X;
    REALD Y;
};

class GpPoint3F
{
public:

    // Default constructor

    GpPoint3F()
    {
    }

    // Construct a Point object using the specified
    // x- and y- coordinates.

    GpPoint3F(REAL x, REAL y, REAL z)
    {
        X = x;
        Y = y;
        Z = z;
    }

public:

    REAL X;
    REAL Y;
    REAL Z;
};

class GpPoint3D
{
public:

    // Default constructor

    GpPoint3D()
    {
    }

    // Construct a Point object using the specified
    // x- and y- coordinates.

    GpPoint3D(REALD x, REALD y, REALD z)
    {
        X = x;
        Y = y;
        Z = z;
    }

public:

    REALD X;
    REALD Y;
    REALD Z;
};

//--------------------------------------------------------------------------
// Represents a rectangle in a 2D coordinate system
//  (integer coordinates)
//--------------------------------------------------------------------------

class GpRect
{
public:

    // Default constructor

    GpRect()
    {
    }

    // Construct a Rect object using the specified
    // location and size.

    GpRect(INT x, INT y, INT width, INT height)
    {
        X = x;
        Y = y;
        Width = width;
        Height = height;
    }

    GpRect(const GpPoint& location, const GpSize& size)
    {
        X = location.X;
        Y = location.Y;
        Width = size.Width;
        Height = size.Height;
    }

    // Determine if the rectangle is empty

    BOOL IsEmpty() const
    {
        return (Width <= 0) || (Height <= 0);
    }

    // Return the left, top, right, and bottom
    // coordinates of the rectangle

    INT GetLeft() const
    {
        return X;
    }

    INT GetTop() const
    {
        return Y;
    }

    INT GetRight() const
    {
        return X+Width;
    }

    INT GetBottom() const
    {
        return Y+Height;
    }

    // Determine if the specified rect intersects with the
    // current rect object.

    BOOL IntersectsWith(const GpRect& rect)
    {
        return (GetLeft()   < rect.GetRight()  &&
                GetTop()    < rect.GetBottom() &&
                GetRight()  > rect.GetLeft()   &&
                GetBottom() > rect.GetTop());
    }

    // Intersect the current rect with the specified object

    BOOL Intersect(const GpRect& rect)
    {
        return IntersectRect(*this, *this, rect);
    }

    // Intersect rect a and b and save the result into c
    // Notice that c may be the same object as a or b.
    // !!! Consider moving out-of-line

    static BOOL IntersectRect(GpRect& c, const GpRect& a, const GpRect& b)
    {
        INT right = min(a.GetRight(), b.GetRight());
        INT bottom = min(a.GetBottom(), b.GetBottom());
        INT left = max(a.GetLeft(), b.GetLeft());
        INT top = max(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmpty();
    }

public:

    INT X;
    INT Y;
    INT Width;
    INT Height;
};

//--------------------------------------------------------------------------
// Represents a 32-bit ARGB color in AARRGGBB format
//--------------------------------------------------------------------------

class GpColor 
{
public:

    GpColor() 
    {
        Argb = Color::Black;
    }

    GpColor(BYTE r, BYTE g, BYTE b) 
    {
        Argb = MakeARGB(255, r, g, b);
    }

    GpColor(BYTE a, BYTE r, BYTE g, BYTE b) 
    {
        Argb = MakeARGB(a, r, g, b);
    }

    GpColor(ARGB argb)
    {
        Argb = argb;
    }

    // Retrieve ARGB values

    ARGB GetValue() const
    {
        return Argb;
    }

    VOID SetValue(IN ARGB argb)
    {
        Argb = argb;
    }

    // Extract A, R, G, B components

    BYTE GetAlpha() const
    {
        return (BYTE) (Argb >> AlphaShift);
    }

    BYTE GetRed() const
    {
        return (BYTE) (Argb >> RedShift);
    }

    BYTE GetGreen() const
    {
        return (BYTE) (Argb >> GreenShift);
    }

    BYTE GetBlue() const
    {
        return (BYTE) (Argb >> BlueShift);
    }

    // Return premultiplied ARGB values

    ARGB GetPremultipliedValue() const
    {
        return ConvertToPremultiplied(Argb);
    }

    // Determine if the color is completely opaque

    BOOL IsOpaque() const
    {
        return (Argb & AlphaMask) == AlphaMask;
    }

    // Determine if the two colors are the same

    BOOL IsEqual(const GpColor & color) const
    {
        return (Argb == color.Argb);
    }


    VOID SetColor(ARGB argb)
    {
        this->Argb = argb;
    }

    COLORREF ToCOLORREF() const
    {
        return RGB(GetRed(), GetGreen(), GetBlue());
    }

    VOID BlendOpaqueWithWhite()
    {
        UINT32 alpha = this->GetAlpha();
        if (alpha == 0) 
        {
            this->Argb = 0xFFFFFFFF;
        }
        else if (alpha != 255)
        {
            UINT32 multA = 255 - alpha;
        
            UINT32 D1_000000FF = 0xFF;
            UINT32 D2_0000FFFF = D1_000000FF * multA + 0x00000080;
            UINT32 D3_000000FF = (D2_0000FFFF & 0x0000FF00) >> 8;
            UINT32 D4_0000FF00 = (D2_0000FFFF + D3_000000FF) & 0x0000FF00;
        
            UINT32 alphaContrib = D4_0000FF00 >> 8 |
                                  D4_0000FF00 << 8 |
                                  D4_0000FF00;
        
            this->Argb = 0xFF000000 | (this->Argb + alphaContrib);
        }
    }

    // Shift count and bit mask for A, R, G, B components
    enum
    {
        AlphaShift  = 24,
        RedShift    = 16,
        GreenShift  = 8,
        BlueShift   = 0
    };

    enum
    {
        AlphaMask   = 0xff000000,
        RedMask     = 0x00ff0000,
        GreenMask   = 0x0000ff00,
        BlueMask    = 0x000000ff
    };

    // Assemble A, R, G, B values into a 32-bit integer
    static ARGB MakeARGB(IN BYTE a,
                         IN BYTE r,
                         IN BYTE g,
                         IN BYTE b)
    {
        return (((ARGB) (b) <<  BlueShift) |
                ((ARGB) (g) << GreenShift) |
                ((ARGB) (r) <<   RedShift) |
                ((ARGB) (a) << AlphaShift));
    }

    // Convert an ARGB value to premultiplied form

    static ARGB ConvertToPremultiplied(ARGB argb)
    {
        UINT alpha = (argb & AlphaMask) >> AlphaShift;

        if (alpha == 0xff)
        {
            // fully opaque - don't need to do anything
        }
        else if (alpha == 0)
        {
            // fully transparent

            argb = 0;
        }
        else
        {
            // translucent
            // Approximate 1/255 by 257/65536:

            UINT red = ((argb & RedMask) >> RedShift) * alpha + 0x80;
            UINT green = ((argb & GreenMask) >> GreenShift) * alpha + 0x80;
            UINT blue = ((argb & BlueMask) >> BlueShift) * alpha + 0x80;

            argb = MakeARGB((BYTE) alpha,
                            (BYTE) ((red + (red >> 8)) >> 8),
                            (BYTE) ((green + (green >> 8)) >> 8),
                            (BYTE) ((blue + (blue >> 8)) >> 8));
        }

        return(argb);
    }

    // This is a variation of the above which is useful for
    // antialiasing. It takes the argb value plus an additional
    // alpha value (0-255) which is to multiply the alpha in the
    // color before converting to premultiplied. In the antialiasing
    // case, this extra alpha value is the coverage.

    static ARGB PremultiplyWithCoverage(ARGB argb, BYTE coverage)
    {
        UINT alpha = (argb & AlphaMask) >> AlphaShift;

        alpha = alpha*coverage + 0x80;
        alpha = ((alpha + (alpha >> 8)) >> 8);

        // translucent
        // Approximate 1/255 by 257/65536:

        UINT red = ((argb & RedMask) >> RedShift) * alpha + 0x80;
        UINT green = ((argb & GreenMask) >> GreenShift) * alpha + 0x80;
        UINT blue = ((argb & BlueMask) >> BlueShift) * alpha + 0x80;

        argb = MakeARGB((BYTE) alpha,
                        (BYTE) ((red + (red >> 8)) >> 8),
                        (BYTE) ((green + (green >> 8)) >> 8),
                        (BYTE) ((blue + (blue >> 8)) >> 8));

        return(argb);
    }

    static ARGB MultiplyCoverage(ARGB argb, BYTE coverage)
    {
        UINT alpha = (argb & AlphaMask) >> AlphaShift;

        alpha = alpha*coverage + 0x80;
        alpha = ((alpha + (alpha >> 8)) >> 8);

        // translucent
        // Approximate 1/255 by 257/65536:

        UINT red = ((argb & RedMask) >> RedShift) * coverage + 0x80;
        UINT green = ((argb & GreenMask) >> GreenShift) * coverage + 0x80;
        UINT blue = ((argb & BlueMask) >> BlueShift) * coverage + 0x80;

        argb = MakeARGB((BYTE) alpha,
                        (BYTE) ((red + (red >> 8)) >> 8),
                        (BYTE) ((green + (green >> 8)) >> 8),
                        (BYTE) ((blue + (blue >> 8)) >> 8));

        return(argb);
    }

    static INT GetAlphaARGB(ARGB argb)
    {
        return ((argb & AlphaMask) >> AlphaShift);
    }

    static INT GetRedARGB(ARGB argb)
    {
        return ((argb & RedMask) >> RedShift);
    }

    static INT GetGreenARGB(ARGB argb)
    {
        return ((argb & GreenMask) >> GreenShift);
    }

    static INT GetBlueARGB(ARGB argb)
    {
        return ((argb & BlueMask) >> BlueShift);
    }

private:

    ARGB Argb;

};

// Union for converting between ARGB and 4 separate BYTE channel values.

union GpColorConverter 
{
    ARGB argb;
    struct {
        BYTE b;
        BYTE g;
        BYTE r;
        BYTE a;
    } Channel;
};

// 32 bits per channel floating point color value.

class GpFColor128 
{
    public:
    
    REAL b;
    REAL g;
    REAL r;
    REAL a;
};


class GpGlyphPos
{
public:
    GpGlyphPos(int x0=0, int y0=0, int cx=0, int cy=0, BYTE* bts=NULL)
    :   Left(x0), Top(y0), Width(cx), Height(cy), BitsOrPath((PVOID) bts), bTempBits(FALSE), bIsBits(TRUE)
    {}

    inline INT         GetLeft(void) const         { return Left; }
    inline INT         GetTop(void) const          { return Top; }
    inline INT         GetWidth(void) const        { return Width; }
    inline INT         GetHeight(void) const       { return Height; }
    
    
    void        SetLeft(INT l)              { Left = l; }
    void        SetTop(INT t)               { Top = t; }
    void        SetWidth(INT w)             { Width = w; }
    void        SetHeight(INT h)            { Height = h; }

    BYTE * GetBits(void) const         
    { 
        if (bIsBits)
            return (BYTE *) BitsOrPath;

        return (BYTE *) NULL;
    }

    PVOID GetPath(void) const
    { 
        if (!bIsBits)
            return BitsOrPath; 
        else
            return (PVOID) NULL; 
    }

    void SetPath(PVOID path=NULL)     
    { 
        BitsOrPath = path; 
        bIsBits = FALSE;
    }
    
    void SetBits(BYTE* bts=NULL)     
    { 
        BitsOrPath = (PVOID) bts; 
        bIsBits = TRUE;
    }

    void SetTempBits(BYTE* bts=NULL) 
    { 
        BitsOrPath = (PVOID) bts;

        if (bts)
        {
            bTempBits = TRUE;
        }
    }

    BYTE * GetTempBits()
    {
        if (bTempBits)
            return (BYTE *) BitsOrPath;
        return NULL;
    }                                         

private:
    INT     Left;
    INT     Top;
    INT     Width;
    INT     Height;
    BOOL    bTempBits;
    BOOL    bIsBits;
    PVOID   BitsOrPath;
};

}

#endif // !_BASETYPES_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\critsec.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   critsec.cpp
*
* Abstract:
*
*   Critical Section object for protecting LoadLibrary calls
*
* Revision History:
*
*   3/17/2000 asecchia
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

CRITICAL_SECTION LoadLibraryCriticalSection::critSec;
BOOL             LoadLibraryCriticalSection::initialized= FALSE;

CRITICAL_SECTION GpMallocTrackingCriticalSection::critSec;
INT GpMallocTrackingCriticalSection::refCount = 0;

CRITICAL_SECTION GdiplusStartupCriticalSection::critSec;
BOOL             GdiplusStartupCriticalSection::initialized = FALSE;

CRITICAL_SECTION BackgroundThreadCriticalSection::critSec;
BOOL             BackgroundThreadCriticalSection::initialized = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\autopointers.hpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   AutoPointers smart pointer classes library.
*
* Abstract:
*
*   Implements AutoArray and AutoPointer smart pointer classes.
*
* Notes:
*
*   To avoid cleanup code in our functions we need to use smart pointer classes
*   for holding allocation results. These classes are roughly similar to std::auto_ptr,
*   although there are differences regarding ownership, operator&, defensive code etc.
*
* Revision History:
*
*   07/18/2000 mleonov
*       Created it.
*
\**************************************************************************/

#ifndef __AUTOPOINTERS_HPP_
#define __AUTOPOINTERS_HPP_

// The following 2 classes are very similar, except that:
// AutoPointer uses operator delete and provides operator->
// AutoArray uses operator delete[] and provides operator[]





/////   AutoArray - Pointer to array of items with automatic freeing
//
//      This class is used for storing arrays allocated using new [].
//      For example:
//
//      {
//          AutoArray<BYTE> buffer(new BYTE[count]);
//          if (!buffer)
//              return OutOfMemory;
//          buffer[0] = 0;
//          DoSomething(buffer.Get());
//          // buffer is automatically deallocated
//      }

template<class T>
class AutoArray
{
    typedef AutoArray<T>    self;
public:
    // This constructor is made explicit so that compiler
    // doesn't create implicit temporaries of type AutoArray<T>
    explicit AutoArray(T * source = 0) : Pointer(source) {}

    // Copy constructor and assignment operators need to ensure that
    // pointer is freed only once
    AutoArray(self & rhs) : Pointer(rhs.Release()) {}

    self & operator=(self & rhs)
    {
        SafeAssign(rhs.Release());
        return *this;
    }

    // Safe assignment for regular pointer
    self & operator=(T * rhs)
    {
        SafeAssign(rhs);
        return *this;
    }

    // Destructor is the whole point of having this class
    ~AutoArray()
    {
        Clear();
    }

    // This operator is for functions which allocate pointer and return it using T **
    T ** operator&()
    {
        Clear();
        Pointer = 0;
        return &Pointer;
    }

    // The following 2 operators are for checks for NULL
    operator BOOL() const
    {
        return (Pointer != 0);
    }

    BOOL operator!() const
    {
        return !Pointer;
    }

// We disallow implicit conversion to pointer because it's dangerous,
// for example we don't want people do explicitly delete underlying pointer
//    operator T* () const { return Pointer; }

    T & operator*() const
    {
        AssertNotEmpty();
        return *Get();
    }

    // Make indexing work the same way as for built-in arrays
    template <typename INDEXTYPE>
    T & operator[](INDEXTYPE ndx) const
    {
        AssertNotEmpty();
        return *(Get() + ndx);
    }

    // Obtain the underlying pointer
    T * Get() const
    {
        return Pointer;
    }

    // Obtain the underlying pointer and release ownership,
    // normally this is used to safely return the pointer from a function
    // and let caller take care of deallocation
    T * Release()
    {
        T * tmp = Pointer;
        Pointer = 0;
        return tmp;
    }

private:
    // Note that one should always assign a new value to Pointer after calling Clear()
    void Clear()
    {
        delete[] Pointer;
    }

    void SafeAssign(T * rhs)
    {
        // We don't want to have 2 smart pointers pointing to the same object
        // as it will result in double free
        ASSERT(!(Pointer != NULL && Pointer == rhs));

        Clear();
        Pointer = rhs;
    }

    void AssertNotEmpty() const
    {
        ASSERT(Get() != 0);
    }

    T *     Pointer;    // underlying pointer
}; // class AutoArray




/////   AutoPointer - Pointer to single item with automatic freeing
//
//      This class is used for storing objects allocated using new.
//      For example:
//
//      {
//          AutoPointer<OBJECT> object(new OBJECT);
//          if (!object)
//              return OutOfMemory;
//          object->Method();
//          DoSomething(object.Get());
//          // object is automatically deallocated
//      }

template<class T>
class AutoPointer
{
    typedef AutoPointer<T>  self;
public:
    // This constructor is made explicit so that compiler
    // doesn't create implicit temporaries of type AutoPointer<T>
    explicit AutoPointer(T * source = 0) : Pointer(source) {}

    // Copy constructor and assignment operators need to ensure that
    // pointer is freed only once
    AutoPointer(self & rhs) : Pointer(rhs.Release()) {}

    self & operator=(self & rhs)
    {
        SafeAssign(rhs.Release());
        return *this;
    }

    // Safe assignment for regular pointer
    self & operator=(T * rhs)
    {
        SafeAssign(rhs);
        return *this;
    }

    // Destructor is the whole point of having this class
    ~AutoPointer()
    {
        Clear();
    }

    // This operator is for functions which allocate pointer and return it using T **
    T ** operator&()
    {
        Clear();
        Pointer = 0;
        return &Pointer;
    }

    // The following 2 operators are for checks for NULL
    operator BOOL() const
    {
        return (Pointer != 0);
    }

    BOOL operator!() const
    {
        return !Pointer;
    }

// We disallow implicit conversion to pointer because it's dangerous,
// for example we don't want people do explicitly delete underlying pointer
//    operator T* () const { return Pointer; }

    T & operator*() const
    {
        AssertNotEmpty();
        return *Get();
    }

    // Allow method calls using -> notation
    T * operator->() const
    {
        AssertNotEmpty();
        return Get();
    }

    // Obtain the underlying pointer
    T * Get() const
    {
        return Pointer;
    }

    // Obtain the underlying pointer and release ownership,
    // normally this is used to safely return the pointer from a function
    // and let caller take care of deallocation
    T * Release()
    {
        T * tmp = Pointer;
        Pointer = 0;
        return tmp;
    }

private:
    // Note that one should always assign a new value to Pointer after calling Clear()
    void Clear()
    {
        delete Pointer;
    }

    void SafeAssign(T * rhs)
    {
        // We don't want to have 2 smart pointers pointing to the same object
        // as it will result in double free
        ASSERT(!(Pointer != NULL && Pointer == rhs));

        Clear();
        Pointer = rhs;
    }

    void AssertNotEmpty() const
    {
        ASSERT(Get() != 0);
    }

    T *     Pointer;    // underlying pointer
}; // class AutoPointer






/////   AutoBuffer - Pointer to array of items with stack alloc and automatic freeing
//
//      This class is used for creating buffers.
//      For example:
//
//      {
//          AutoBuffer<BYTE, 100> buffer(count);
//          if (!buffer)
//              return OutOfMemory;
//          buffer[0] = 0;
//          DoSomething(buffer.Get());
//          // buffer is automatically deallocated
//      }
//
//      Creates an array of count BYTEs. Reserves 100 bytes of stack space.
//      If count <= 100, the reserved stack space is used for the buffer, else
//      teh space is allocated on the heap.

template<class T, INT StackSize>
class AutoBuffer
{
public:
    // This constructor is made explicit so that compiler
    // doesn't create implicit temporaries of type AutoArray<T>
    explicit AutoBuffer(INT requestedSize = -1)
    :   Size    (requestedSize),    // Allocated lazily if > StackSize
        Pointer (StackBuffer)       // Pointer is never NULL
    {
        if (requestedSize > StackSize)
        {
            // Stack buffer is not big enough
            SetSize(requestedSize);
        }
    }

    void Clear()
    {
        if (Pointer != StackBuffer)
        {
            delete [] Pointer;
        }
        Pointer = StackBuffer;
        Size = -1;
    }

    void SetSize(INT size)
    {
        // Fast case if existing buffer is big enough

        if (size < Size  ||  size < StackSize)
        {
            // Use existing buffer, whether it is the stack buffer or whether
            // it is allocated separately.
            Size = size;
            return;
        }


        if (Pointer != StackBuffer)
        {
            // Exisiting buffer is not big enough
            delete [] Pointer;
            Pointer = StackBuffer;
        }

        Size = size;

        if (Size > StackSize)
        {
            // Attempt to allocate a buffer bigger than stacksize.
            // This doesn't have to succeed. (If it fails it leaves
            // Size and Pointer in the defined 'unallocated' state.)
            T *newBuffer = new T[Size];
            if (newBuffer != NULL)
            {
                Pointer = newBuffer;
            }
            else
            {
                // Cannot handle requested size
                Size = -1;  // Uninitialised
            }
        }
    }


    ~AutoBuffer()
    {
        Clear();
    }

    // The following 2 operators check whether the buffer needs allocating

    operator BOOL()
    {
        return initialized();
    }

    BOOL operator!()
    {
        return !initialized();
    }

// We disallow implicit conversion to pointer because it's dangerous,
// for example we don't want people do explicitly delete underlying pointer
//    operator T* () const  { return Pointer; }
//    T & operator*() const { AssertNotEmpty(); return *Get(); }

    // Provide index checked array lookup
    template <typename INDEXTYPE>
    T & operator[](INDEXTYPE ndx)
    {
        ASSERT(ndx >= 0  &&  ndx < Size);
        return *(Pointer + ndx);
    }

    // Obtain the underlying pointer
    T * Get()
    {
        return Pointer;
    }


private:

    BOOL initialized()
    {
        return Size >= 0  &&  (Size <= StackSize  ||  Pointer != StackBuffer);
    }

    // Possible states:
    //
    //                          |    Size <= StackSize   |   Size > StackSize
    //                          |    -----------------   |   ----------------
    //                          |                        |
    //   Pointer == StackBuffer | Buffer up to StackSize | Allocation failed
    //   ---------------------- | is available.          |
    //                          |                        |
    //                          |                        |
    //   Pointer != StackBuffer | Dynamic buffer was     | Heap buffer available
    //   ---------------------- | previously allocated   | sufficient for Size.
    //                          | since when SetSize has |
    //                          | reduced required size. |
    //
    //   Note that when SetSize reduces the required size after a heap buffer
    //   has already been allocated, the spare buffer space is NOT released.
    //   The client may call Clear() to guarantee freeing any heap buffer.
    //
    //   If uninitialized, or if cleared, Size is recorded internally as -1,
    //   and BOOL tests return false. SetSize(0) is valid, always succeeds, and
    //   causes BOOL tests to return TRUE.

    INT Size;                       // Requested size
    T * Pointer;                    // Underlying pointer

    // Note: be sure to keep the following buffer pointer size aligned.
    T StackBuffer[StackSize];       // Note: prior pointer causes alignment

}; // class AutoBuffer

class AutoLock
{
    CRITICAL_SECTION &  CriticalSection;
public:
    AutoLock(CRITICAL_SECTION & cs) : CriticalSection(cs)
    {
        ::EnterCriticalSection(&CriticalSection);
    }
    ~AutoLock()
    {
        ::LeaveCriticalSection(&CriticalSection);
    }
};

#endif // __AUTOPOINTERS_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\stretch.inc ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name & Abstract
*
*   Stretch. This module contains the code to do various stretching
*   by applying a kernel filter. The code correctly handles minification.
*
* Note:
*   This module is not compiled into an .obj file, rather it is included
*   directly into the header file stretch.hpp.
*   This is due to the use of template functions.
*
*
* Notes:
*
*   This code does not handle rotation or shear.
*
* Created:
*
*   04/17/2000 asecchia
*      Created it.
*
**************************************************************************/

#define LAST_K_UNUSED ((INT)0x7fffffff)

const INT BicubicKernelShift = 7;
const INT BicubicKernelSize = 1 << BicubicKernelShift;
const FIX16 BicubicKernel[BicubicKernelSize+1] =
{
    65536, 65496, 65379, 65186, 64920, 64583, 64177, 63705,
    63168, 62569, 61911, 61195, 60424, 59600, 58725, 57802,
    56832, 55818, 54763, 53668, 52536, 51369, 50169, 48939,
    47680, 46395, 45087, 43757, 42408, 41042, 39661, 38268,
    36864, 35452, 34035, 32614, 31192, 29771, 28353, 26941,
    25536, 24141, 22759, 21391, 20040, 18708, 17397, 16110,
    14848, 13614, 12411, 11240, 10104,  9005,  7945,  6927,
     5952,  5023,  4143,  3313, 2536,  1814,  1149,   544,
        0,  -496,  -961, -1395, -1800, -2176, -2523, -2843,
    -3136, -3403, -3645, -3862, -4056, -4227, -4375, -4502,
    -4608, -4694, -4761, -4809, -4840, -4854, -4851, -4833,
    -4800, -4753, -4693, -4620, -4536, -4441, -4335, -4220,
    -4096, -3964, -3825, -3679, -3528, -3372, -3211, -3047,
    -2880, -2711, -2541, -2370, -2200, -2031, -1863, -1698,
    -1536, -1378, -1225, -1077, -936,  -802,  -675,  -557,
     -448,  -349,  -261,  -184, -120,   -69,   -31,    -8,
        0
};

const FIX16 SymmetricBicubicKernel[BicubicKernelSize * 2 + 1] =
{
    0,
     -8, -31, -69, -120, -184, -261,-349, -448,
    -557, -675,  -802, -936, -1077, -1225, -1378, -1536,
    -1698, -1863, -2031, -2200, -2370, -2541, -2711, -2880,
    -3047, -3211, -3372, -3528, -3679, -3825, -3964, -4096,
    -4220, -4335, -4441, -4536, -4620, -4693, -4753, -4800,
    -4833, -4851, -4854, -4840, -4809, -4761, -4694, -4608,
    -4502, -4375, -4227, -4056, -3862, -3645, -3403, -3136,
    -2843, -2523, -2176, -1800, -1395, -961, -496,
    0,
    544, 1149, 1814, 2536, 3313, 4143, 5023, 5952,
    6927,  7945,9005, 10104, 11240, 12411, 13614, 14848,
    16110,  17397, 18708, 20040, 21391, 22759, 24141, 25536,
    26941, 28353, 29771, 31192, 32614, 34035, 35452, 36864,
    38268, 39661, 41042, 42408, 43757,  45087, 46395, 47680,
    48939,  50169, 51369, 52536, 53668, 54763, 55818, 56832,
    57802,  58725, 59600, 60424, 61195, 61911, 62569, 63168,
    63705,  64177, 64583, 64920, 65186, 65379, 65496,
65536,
    65496, 65379, 65186, 64920, 64583, 64177, 63705,
    63168, 62569, 61911, 61195, 60424, 59600, 58725, 57802,
    56832, 55818, 54763, 53668, 52536, 51369, 50169, 48939,
    47680, 46395, 45087, 43757, 42408, 41042, 39661, 38268,
    36864, 35452, 34035, 32614, 31192, 29771, 28353, 26941,
    25536, 24141, 22759, 21391, 20040, 18708, 17397, 16110,
    14848, 13614, 12411, 11240, 10104,  9005,  7945,  6927,
     5952,  5023,  4143,  3313, 2536,  1814,  1149,   544,
     0,
    -496,  -961, -1395, -1800, -2176, -2523, -2843,
    -3136, -3403, -3645, -3862, -4056, -4227, -4375, -4502,
    -4608, -4694, -4761, -4809, -4840, -4854, -4851, -4833,
    -4800, -4753, -4693, -4620, -4536, -4441, -4335, -4220,
    -4096, -3964, -3825, -3679, -3528, -3372, -3211, -3047,
    -2880, -2711, -2541, -2370, -2200, -2031, -1863, -1698,
    -1536, -1378, -1225, -1077, -936,  -802,  -675,  -557,
     -448,  -349,  -261,  -184, -120,   -69,   -31,    -8,
     0
};

/*
// Higher precision bicubic kernel - more data.
// Commented out in case we eventually need it.
const FIX16 BK[512+1] = 
{
    0,
    -2, -8, -18, -31, -48, -69, -93, -120, 
    -151, -184, -221, -261, -304, -349, -397, -448, 
    -501, -557, -615, -675, -737, -802, -868, -936, 
    -1006, -1077, -1150, -1225, -1301, -1378, -1457, -1536, 
    -1616, -1698, -1780, -1863, -1947, -2031, -2115, -2200, 
    -2285, -2370, -2456, -2541, -2626, -2711, -2796, -2880, 
    -2964, -3047, -3129, -3211, -3292, -3372, -3450, -3528, 
    -3604, -3679, -3753, -3825, -3895, -3964, -4031, -4096, 
    -4159, -4220, -4279, -4335, -4389, -4441, -4490, -4536, 
    -4580, -4620, -4658, -4693, -4725, -4753, -4778, -4800, 
    -4818, -4833, -4844, -4851, -4854, -4854, -4849, -4840, 
    -4827, -4809, -4787, -4761, -4730, -4694, -4654, -4608, 
    -4557, -4502, -4441, -4375, -4304, -4227, -4144, -4056, 
    -3962, -3862, -3757, -3645, -3527, -3403, -3273, -3136, 
    -2993, -2843, -2686, -2523, -2353, -2176, -1991, -1800, 
    -1601, -1395, -1182, -961, -732, -496, -252, 
    0, 
    264, 544, 839, 1149, 1474, 1814, 2168, 2536, 
    2918, 3313, 3722, 4143, 4577, 5023, 5482, 5952, 
    6434, 6927, 7430, 7945, 8470, 9005, 9550, 10104, 
    10668, 11240, 11821, 12411, 13009, 13614, 14228, 14848, 
    15475, 16110, 16750, 17397, 18050, 18708, 19371, 20040, 
    20713, 21391, 22073, 22759, 23449, 24141, 24837, 25536, 
    26237, 26941, 27646, 28353, 29061, 29771, 30481, 31192, 
    31903, 32614, 33325, 34035, 34744, 35452, 36159, 36864, 
    37567, 38268, 38966, 39661, 40353, 41042, 41727, 42408, 
    43085, 43757, 44425, 45087, 45744, 46395, 47041, 47680, 
    48313, 48939, 49557, 50169, 50773, 51369, 51957, 52536, 
    53107, 53668, 54220, 54763, 55296, 55818, 56331, 56832, 
    57322, 57802, 58269, 58725, 59169, 59600, 60018, 60424, 
    60816, 61195, 61560, 61911, 62248, 62569, 62876, 63168, 
    63444, 63705, 63949, 64177, 64388, 64583, 64760, 64920, 
    65062, 65186, 65292, 65379, 65447, 65496, 65526, 
    65536, 
    65526, 65496, 65447, 65379, 65292, 65186, 65062, 64920, 
    64760, 64583, 64388, 64177, 63949, 63705, 63444, 63168, 
    62876, 62569, 62248, 61911, 61560, 61195, 60816, 60424, 
    60018, 59600, 59169, 58725, 58269, 57802, 57322, 56832, 
    56331, 55818, 55296, 54763, 54220, 53668, 53107, 52536, 
    51957, 51369, 50773, 50169, 49557, 48939, 48313, 47680, 
    47041, 46395, 45744, 45087, 44425, 43757, 43085, 42408, 
    41727, 41042, 40353, 39661, 38966, 38268, 37567, 36864, 
    36159, 35452, 34744, 34035, 33325, 32614, 31903, 31192, 
    30481, 29771, 29061, 28353, 27646, 26941, 26237, 25536, 
    24837, 24141, 23449, 22759, 22073, 21391, 20713, 20040, 
    19371, 18708, 18050, 17397, 16750, 16110, 15475, 14848, 
    14228, 13614, 13009, 12411, 11821, 11240, 10668, 10104, 
    9550, 9005, 8470, 7945, 7430, 6927, 6434, 5952, 
    5482, 5023, 4577, 4143, 3722, 3313, 2918, 2536, 
    2168, 1814, 1474, 1149, 839, 544, 264, 
    0,
    -252, -496, -732, -961, -1182, -1395, -1601, -1800, 
    -1991, -2176, -2353, -2523, -2686, -2843, -2993, -3136, 
    -3273, -3403, -3527, -3645, -3757, -3862, -3962, -4056, 
    -4144, -4227, -4304, -4375, -4441, -4502, -4557, -4608, 
    -4654, -4694, -4730, -4761, -4787, -4809, -4827, -4840, 
    -4849, -4854, -4854, -4851, -4844, -4833, -4818, -4800, 
    -4778, -4753, -4725, -4693, -4658, -4620, -4580, -4536, 
    -4490, -4441, -4389, -4335, -4279, -4220, -4159, -4096, 
    -4031, -3964, -3895, -3825, -3753, -3679, -3604, -3528, 
    -3450, -3372, -3292, -3211, -3129, -3047, -2964, -2880, 
    -2796, -2711, -2626, -2541, -2456, -2370, -2285, -2200, 
    -2115, -2031, -1947, -1863, -1780, -1698, -1616, -1536, 
    -1457, -1378, -1301, -1225, -1150, -1077, -1006, -936, 
    -868, -802, -737, -675, -615, -557, -501, -448, 
    -397, -349, -304, -261, -221, -184, -151, -120, 
    -93, -69, -48, -31, -18, -8, -2, 
    0
};


// Bicubic kernel with the 'perceptual' coefficient tweaked
// see Wolberg. Provides a slightly different experience.
// Commented out in case we eventually need it.

const FIX16 BK_V[512+1] =
{

    0,
    -4, -16, -35, -62, -96, -137, -185, -240, 
    -301, -369, -442, -522, -607, -698, -795, -896, 
    -1002, -1114, -1230, -1350, -1475, -1603, -1736, -1872, 
    -2012, -2155, -2301, -2450, -2602, -2756, -2913, -3072, 
    -3233, -3396, -3560, -3726, -3893, -4061, -4230, -4400, 
    -4570, -4741, -4911, -5082, -5252, -5422, -5592, -5760, 
    -5927, -6094, -6259, -6422, -6584, -6743, -6901, -7056, 
    -7209, -7359, -7506, -7650, -7791, -7928, -8062, -8192, 
    -8318, -8440, -8557, -8670, -8778, -8881, -8979, -9072, 
    -9159, -9241, -9316, -9386, -9449, -9506, -9557, -9600, 
    -9636, -9666, -9688, -9702, -9709, -9707, -9698, -9680, 
    -9654, -9619, -9575, -9522, -9460, -9388, -9307, -9216, 
    -9115, -9004, -8882, -8750, -8607, -8453, -8288, -8112, 
    -7924, -7725, -7513, -7290, -7054, -6806, -6546, -6272, 
    -5985, -5686, -5373, -5046, -4706, -4351, -3983, -3600, 
    -3203, -2791, -2364, -1922, -1465, -992, -504, 
    0, 
    516, 1040, 1571, 2110, 2656, 3209, 3769, 4336, 
    4909, 5489, 6074, 6666, 7263, 7866, 8475, 9088, 
    9706, 10330, 10958, 11590, 12227, 12867, 13512, 14160, 
    14812, 15467, 16125, 16786, 17450, 18116, 18785, 19456, 
    20129, 20804, 21480, 22158, 22837, 23517, 24198, 24880, 
    25562, 26245, 26927, 27610, 28292, 28974, 29656, 30336, 
    31015, 31694, 32371, 33046, 33720, 34391, 35061, 35728, 
    36393, 37055, 37714, 38370, 39023, 39672, 40318, 40960, 
    41598, 42232, 42861, 43486, 44106, 44721, 45331, 45936, 
    46535, 47129, 47716, 48298, 48873, 49442, 50005, 50560, 
    51108, 51650, 52184, 52710, 53229, 53739, 54242, 54736, 
    55222, 55699, 56167, 56626, 57076, 57516, 57947, 58368, 
    58779, 59180, 59570, 59950, 60319, 60677, 61024, 61360, 
    61684, 61997, 62297, 62586, 62862, 63126, 63378, 63616, 
    63841, 64054, 64253, 64438, 64610, 64767, 64911, 65040, 
    65155, 65255, 65340, 65410, 65465, 65504, 65528, 
    65536, 
    65528, 65504, 65465, 65410, 65340, 65255, 65155, 65040, 
    64911, 64767, 64610, 64438, 64253, 64054, 63841, 63616, 
    63378, 63126, 62862, 62586, 62297, 61997, 61684, 61360, 
    61024, 60677, 60319, 59950, 59570, 59180, 58779, 58368, 
    57947, 57516, 57076, 56626, 56167, 55699, 55222, 54736, 
    54242, 53739, 53229, 52710, 52184, 51650, 51108, 50560, 
    50005, 49442, 48873, 48298, 47716, 47129, 46535, 45936, 
    45331, 44721, 44106, 43486, 42861, 42232, 41598, 40960, 
    40318, 39672, 39023, 38370, 37714, 37055, 36393, 35728, 
    35061, 34391, 33720, 33046, 32371, 31694, 31015, 30336, 
    29656, 28974, 28292, 27610, 26927, 26245, 25562, 24880, 
    24198, 23517, 22837, 22158, 21480, 20804, 20129, 19456, 
    18785, 18116, 17450, 16786, 16125, 15467, 14812, 14160, 
    13512, 12867, 12227, 11590, 10958, 10330, 9706, 9088, 
    8475, 7866, 7263, 6666, 6074, 5489, 4909, 4336, 
    3769, 3209, 2656, 2110, 1571, 1040, 516, 
    0, 
    -504, -992, -1465, -1922, -2364, -2791, -3203, -3600, 
    -3983, -4351, -4706, -5046, -5373, -5686, -5985, -6272, 
    -6546, -6806, -7054, -7290, -7513, -7725, -7924, -8112, 
    -8288, -8453, -8607, -8750, -8882, -9004, -9115, -9216, 
    -9307, -9388, -9460, -9522, -9575, -9619, -9654, -9680, 
    -9698, -9707, -9709, -9702, -9688, -9666, -9636, -9600, 
    -9557, -9506, -9449, -9386, -9316, -9241, -9159, -9072, 
    -8979, -8881, -8778, -8670, -8557, -8440, -8318, -8192, 
    -8062, -7928, -7791, -7650, -7506, -7359, -7209, -7056, 
    -6901, -6743, -6584, -6422, -6259, -6094, -5927, -5760, 
    -5592, -5422, -5252, -5082, -4911, -4741, -4570, -4400, 
    -4230, -4061, -3893, -3726, -3560, -3396, -3233, -3072, 
    -2913, -2756, -2602, -2450, -2301, -2155, -2012, -1872, 
    -1736, -1603, -1475, -1350, -1230, -1114, -1002, -896, 
    -795, -698, -607, -522, -442, -369, -301, 
    -240, -185, -137, -96, -62, -35, -16, -4, 
    0
};
*/


// This is the table of partial sums of the bilinear kernel.
// Simply put, each point in the array represents the integral
// from -infinity to position x in the kernel function.
// We can subtract two table lookups to get the integral
// of the kernel (area) between the two points.
// The table is padded with zeros and ones at the beginning and end
// so we can consistently address areas outside of the actual kernel
// Currently we don't make use of the zeros at the beginning but
// we definitely sample past the end by at least one half-width
// of the kernel.

const FIX16 BilinearPartialIntegral[512+1] =
{   
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    
    0,2, 8, 18, 32, 50, 72, 98, 
    128, 162, 200, 242, 288, 338, 392, 450, 
    512, 578, 648, 722, 800, 882, 968, 1058, 
    1152, 1250, 1352, 1458, 1568, 1682, 1800, 1922, 
    2048, 2178, 2312, 2450, 2592, 2738, 2888, 3042, 
    3200, 3362, 3528, 3698, 3872, 4050, 4232, 4418, 
    4608, 4802, 5000, 5202, 5408, 5618, 5832, 6050, 
    6272, 6498, 6728, 6962, 7200, 7442, 7688, 7938, 
    8192, 8450, 8712, 8978, 9248, 9522, 9800, 10082, 
    10368, 10658, 10952, 11250, 11552, 11858, 12168, 12482, 
    12800, 13122, 13448, 13778, 14112, 14450, 14792, 15138, 
    15488, 15842, 16200, 16562, 16928, 17298, 17672, 18050, 
    18432, 18818, 19208, 19602, 20000, 20402, 20808, 21218, 
    21632, 22050, 22472, 22898, 23328, 23762, 24200, 24642, 
    25088, 25538, 25992, 26450, 26912, 27378, 27848, 28322, 
    28800, 29282, 29768, 30258, 30752, 31250, 31752, 32258, 
    
    32768, // center of the kernel. Index 256
    
    33278, 33784, 34286, 34784, 35278, 35768, 36254, 36736, 
    37214, 37688, 38158, 38624, 39086, 39544, 39998, 40448, 
    40894, 41336, 41774, 42208, 42638, 43064, 43486, 43904, 
    44318, 44728, 45134, 45536, 45934, 46328, 46718, 47104, 
    47486, 47864, 48238, 48608, 48974, 49336, 49694, 50048, 
    50398, 50744, 51086, 51424, 51758, 52088, 52414, 52736, 
    53054, 53368, 53678, 53984, 54286, 54584, 54878, 55168, 
    55454, 55736, 56014, 56288, 56558, 56824, 57086, 57344, 
    57598, 57848, 58094, 58336, 58574, 58808, 59038, 59264, 
    59486, 59704, 59918, 60128, 60334, 60536, 60734, 60928, 
    61118, 61304, 61486, 61664, 61838, 62008, 62174, 62336, 
    62494, 62648, 62798, 62944, 63086, 63224, 63358, 63488, 
    63614, 63736, 63854, 63968, 64078, 64184, 64286, 64384, 
    64478, 64568, 64654, 64736, 64814, 64888, 64958, 65024, 
    65086, 65144, 65198, 65248, 65294, 65336, 65374, 65408, 
    65438, 65464, 65486, 65504, 65518, 65528, 65534, 65536,
    
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
};

// This is the table of partial sums of the bicubic kernel.
// Simply put, each point in the array represents the integral
// from -infinity to position x in the kernel function.
// We can subtract two table lookups to get the integral
// of the kernel (area) between the two points.
// The table is padded with zeros and ones at the beginning and end
// so we can consistently address areas outside of the actual kernel
// Currently we don't make use of the zeros at the beginning but
// we definitely sample past the end by at least one half-width
// of the kernel.

const FIX16 BicubicPartialIntegral[1024+1] =
{   
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,

    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,

    0, 0, 0, 0, -1, -2, -3, -4, 
    -6, -8, -11, -15, -19, -24, -29, -35, 
    -42, -50, -59, -68, -79, -90, -103, -117, 
    -131, -147, -164, -182, -201, -221, -243, -265, 
    -289, -315, -341, -369, -398, -429, -460, -493, 
    -528, -563, -600, -639, -679, -720, -762, -806, 
    -851, -897, -945, -993, -1044, -1095, -1148, -1202, 
    -1257, -1313, -1371, -1429, -1489, -1550, -1612, -1675, 
    -1739, -1804, -1870, -1937, -2004, -2073, -2142, -2212, 
    -2283, -2355, -2427, -2500, -2573, -2647, -2721, -2796, 
    -2871, -2946, -3022, -3097, -3173, -3249, -3325, -3401, 
    -3476, -3552, -3627, -3702, -3776, -3850, -3923, -3996, 
    -4068, -4139, -4209, -4279, -4347, -4414, -4481, -4545, 
    -4609, -4671, -4731, -4790, -4847, -4902, -4955, -5006, 
    -5055, -5102, -5146, -5188, -5228, -5264, -5298, -5329, 
    -5358, -5383, -5404, -5423, -5438, -5449, -5457, -5461, 
    -5461, -5457, -5449, -5437, -5420, -5399, -5374, -5345, 
    -5311, -5273, -5230, -5182, -5130, -5073, -5012, -4946, 
    -4875, -4799, -4718, -4633, -4542, -4447, -4346, -4240, 
    -4130, -4014, -3893, -3767, -3636, -3500, -3358, -3212, 
    -3060, -2902, -2740, -2572, -2399, -2220, -2037, -1848, 
    -1653, -1454, -1249, -1038, -822, -601, -375, -143, 
    94, 336, 584, 836, 1095, 1358, 1627, 1901, 
    2180, 2464, 2754, 3048, 3348, 3653, 3963, 4278, 
    4598, 4923, 5253, 5588, 5927, 6272, 6621, 6975, 
    7334, 7698, 8066, 8439, 8816, 9198, 9584, 9975, 
    10370, 10769, 11173, 11580, 11992, 12408, 12828, 13252, 
    13679, 14111, 14546, 14985, 15427, 15873, 16322, 16775, 
    17231, 17690, 18152, 18618, 19086, 19557, 20032, 20508, 
    20988, 21470, 21954, 22441, 22930, 23421, 23914, 24409, 
    24906, 25405, 25905, 26407, 26911, 27415, 27921, 28428, 
    28937, 29446, 29955, 30466, 30977, 31488, 32000, 32512, 
    
    33024, // center of the kernel. Index 512
    
    33536, 34048, 34559, 35070, 35581, 36090, 36599, 37108, 
    37615, 38121, 38625, 39129, 39631, 40131, 40630, 41127, 
    41622, 42115, 42606, 43095, 43582, 44066, 44548, 45028, 
    45504, 45979, 46450, 46918, 47384, 47846, 48305, 48761, 
    49214, 49663, 50109, 50551, 50990, 51425, 51857, 52284, 
    52708, 53128, 53544, 53956, 54363, 54767, 55166, 55561, 
    55952, 56338, 56720, 57097, 57470, 57838, 58202, 58561, 
    58915, 59264, 59609, 59948, 60283, 60613, 60938, 61258, 
    61573, 61883, 62188, 62488, 62782, 63072, 63356, 63635, 
    63909, 64178, 64441, 64700, 64952, 65200, 65442, 65679, 
    65911, 66137, 66358, 66574, 66785, 66990, 67189, 67384, 
    67573, 67756, 67935, 68108, 68276, 68438, 68596, 68748, 
    68894, 69036, 69172, 69303, 69429, 69550, 69666, 69776, 
    69882, 69983, 70078, 70169, 70254, 70335, 70411, 70482, 
    70548, 70609, 70666, 70718, 70766, 70809, 70847, 70881, 
    70910, 70935, 70956, 70973, 70985, 70993, 70997, 70997, 
    70993, 70985, 70974, 70959, 70940, 70919, 70894, 70865, 
    70834, 70800, 70764, 70724, 70682, 70638, 70591, 70542, 
    70491, 70438, 70383, 70326, 70267, 70207, 70145, 70081, 
    70017, 69950, 69883, 69815, 69745, 69675, 69604, 69532, 
    69459, 69386, 69312, 69238, 69163, 69088, 69012, 68937, 
    68861, 68785, 68709, 68633, 68558, 68482, 68407, 68332, 
    68257, 68183, 68109, 68036, 67963, 67891, 67819, 67748, 
    67678, 67609, 67540, 67473, 67406, 67340, 67275, 67211, 
    67148, 67086, 67025, 66965, 66907, 66849, 66793, 66738, 
    66684, 66631, 66580, 66529, 66481, 66433, 66387, 66342, 
    66298, 66256, 66215, 66175, 66136, 66099, 66064, 66029, 
    65996, 65965, 65934, 65905, 65877, 65851, 65825, 65801, 
    65779, 65757, 65737, 65718, 65700, 65683, 65667, 65653, 
    65639, 65626, 65615, 65604, 65595, 65586, 65578, 65571, 
    65565, 65560, 65555, 65551, 65547, 65544, 65542, 65540, 
    65539, 65538, 65537, 65536, 65536, 65536, 65536, 65536, 

    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 

    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
};


// We use a biased pointer to the center of the array
// so that we can look up the negative part of the kernel
// without repositioning the index or using an absolute value
// computation in the inner loop.

// Linear Partial Integral Center.
const FIX16 *LPIC = &BilinearPartialIntegral[256];

// Cubic Partial Integral Center.
const FIX16 *CPIC = &BicubicPartialIntegral[512];

const FIX16 *SymmetricBicubicKernelCenter = &SymmetricBicubicKernel[128];

const ULONGLONG FIX14_HALF_MMX = 0x0000200000002000;

/**************************************************************************
*
* Function Description:
*
*   Constructor for the DpOutputSpanStretch class.
*
* Return Value:
*
*   NONE
*
* Created:
*
*   04/17/2000 asecchia
*      Created it.
*
**************************************************************************/

#define FIX4TOFIX16_SHIFT (FIX16_SHIFT - FIX4_SHIFT)

template<FilterModeType FilterMode>
void DpOutputSpanStretch<FilterMode>::InitializeClass(
    DpBitmap* bitmap,
    DpScanBuffer * scan,
    DpContext* /*context*/,
    DpImageAttributes imgAttributes,
    const GpRectF *dstRect,
    const GpRectF *srcRect
    )
{
    isValid = true;
    
    // Make sure these get initialized up front before we can early out
    // otherwise we could end up freeing uninitialized pointers in our
    // destructor.
    
    ycoeff = NULL;
    xbuffer = NULL;
    
    Scan     = scan;
    dBitmap   = bitmap;

    QWrapMode = imgAttributes.wrapMode;

    ClampColor = imgAttributes.clampColor;

    ClampColorA = (BYTE)( (ClampColor >> 24) );
    ClampColorR = (BYTE)( (ClampColor >> 16) & 0xff);
    ClampColorG = (BYTE)( (ClampColor >> 8) & 0xff);
    ClampColorB = (BYTE)(  ClampColor & 0xff);

    // Accleration for clamp mode with zero clamp color (transparent)

    WrapZeroClamp = FALSE;
    if((QWrapMode == WrapModeClamp) &&
       (imgAttributes.clampColor == 0))
    {
        WrapZeroClamp = TRUE;
    }



    ASSERT(dBitmap != NULL);
    ASSERT(dBitmap->IsValid());

    // on bad bitmap, we return with Valid = FALSE
    if (dBitmap == NULL ||
        !dBitmap->IsValid()
        )
    {
        dBitmap = NULL;
        isValid = false;
        return;
    } else {
        BmpData.Width = dBitmap->Width;
        BmpData.Height = dBitmap->Height;
        BmpData.PixelFormat = PIXFMT_32BPP_PARGB;
        BmpData.Stride = dBitmap->Delta;
        BmpData.Scan0 = dBitmap->Bits;
    }

    if(srcRect)
        SrcRect = *srcRect;
    else
    {
        SrcRect.X = 0.0f;
        SrcRect.Y = 0.0f;
        SrcRect.Width  = (REAL)dBitmap->Width;
        SrcRect.Height = (REAL) dBitmap->Height;
    }

    // Set up the translation.
    if(dstRect)
    {
         DstRect = *dstRect;
    }
    else
    {
         DstRect.X = 0.0f;
         DstRect.Y = 0.0f;
         DstRect.Width = (REAL)SrcRect.Width;
         DstRect.Height = (REAL)SrcRect.Height;
    }


    if( !GpValidFixed16(SrcRect.X) ||
        !GpValidFixed16(SrcRect.Y) ||
        !GpValidFixed16(SrcRect.Width) ||
        !GpValidFixed16(SrcRect.Height) ||
        !GpValidFixed16(DstRect.X) ||
        !GpValidFixed16(DstRect.Y) ||
        !GpValidFixed16(DstRect.Width) ||
        !GpValidFixed16(DstRect.Height) )
    {
        // punt
        
        isValid = false;
        return;
    }
        

    // Initialize the state for the x-dimension scale.

    xscale = GpRealToFix16(SrcRect.Width/DstRect.Width);
    xscaleinv = GpRealToFix16(DstRect.Width/SrcRect.Width);

    // Initialize the state for the y-dimension scale.

    yscale = GpRealToFix16(SrcRect.Height/DstRect.Height);
    yscaleinv = GpRealToFix16(DstRect.Height/SrcRect.Height);

    // Compute the destination contribution.
    // Note: the actual pixels touched are the floor of
    // the top left to the ceiling of the bottom right.
    // (modulus the clipping)

    // Note: We want to be tracking our internal state in FIX16 so we have
    // the extra fractional precision, but when we compute our bounds for the
    // drawing, we use Ceiling and Floor on these FIX16 numbers below. We want
    // the rounding to match the rounding of the FIX4 numbers (i.e. we don't
    // want to track any extra fractional precision errors from the float
    // representation) because we use FIX4 in our DrawImage loop.
    // To accomplish this, we round to FIX4 dropping all error that is smaller
    // than the FIX4 precision and then upconvert to FIX16. Now when we use
    // Fix16Ceiling and Floor, we'll get the same results as Fix4Ceiling and
    // Floor.

    REAL xinv = DstRect.Width/SrcRect.Width;
    REAL yinv = DstRect.Height/SrcRect.Height;

    fixDLeft = GpRealToFix4(DstRect.X);
    fixDRight = GpRealToFix4(xinv * (SrcRect.Width) + DstRect.X);
    fixDTop = GpRealToFix4(DstRect.Y);
    fixDBottom = GpRealToFix4(yinv * (SrcRect.Height) + DstRect.Y);

    // Handle negative scale

    FIX16 fixTemp;

    if(fixDLeft > fixDRight)
    {
        // Swap the left and right x coordinates.
        fixTemp = fixDLeft;
        fixDLeft = fixDRight;
        fixDRight = fixTemp;
    }

    if(fixDTop > fixDBottom)
    {
        // Swap the top and bottom x coordinates.
        fixTemp = fixDTop;
        fixDTop = fixDBottom;
        fixDBottom = fixTemp;
    }

    // Compute the left edge using the rasterizer rounding rules. Used
    // for clipping in x.
    
    ixleft = GpFix4Ceiling(fixDLeft);
    
    // Convert up to FIX16.
    
    fixDLeft   <<= FIX4TOFIX16_SHIFT;    
    fixDRight  <<= FIX4TOFIX16_SHIFT;    
    fixDTop    <<= FIX4TOFIX16_SHIFT;    
    fixDBottom <<= FIX4TOFIX16_SHIFT;    

    // Get the initial kernel center. This specifies the x-dimension
    // fractional pixel offset.

    if(xscale < 0)
    {
        xkci = GpRealToFix16(
            (((DstRect.X+DstRect.Width) - GpFix16Ceiling(fixDRight)) *
            (xscale)) / FIX16_ONE +
            SrcRect.X
        );
    }
    else
    {
        xkci = GpRealToFix16(
            ((DstRect.X - GpFix16Floor(fixDLeft)) *
            xscale) / FIX16_ONE +
            SrcRect.X
        );
    }

    // Get the width of the kernel.
    // Make sure to multiply by the actual width of the filter kernel in
    // normalized space (FilterWidth[i])

    xw = GpRealToFix16(
        (SrcRect.Width*FilterWidth[FilterMode]) /
        DstRect.Width
    );       // convert to FIX16

    // Handle the negative transform

    if(xscale < 0)
    {
        xw = -xw;
    }

    // the width of the kernel must be a positive quantity.

    ASSERT(xw >= 0);

    // if the width is less than one we're doing a stretch, not a shrink.
    // in this case we clamp the kernel size to one.

    if(xw < FIX16_ONE * FilterWidth[FilterMode])
    {
        xw = FIX16_ONE * FilterWidth[FilterMode];
    }

    // a is 1/w - used to work out the tent filter.

    xa = GpRealToFix16(65536.0f/xw);

    // Get the initial kernel center. This specifies the y-dimension
    // fractional pixel offset.

    if(yscale < 0)
    {
        ykci = GpRealToFix16(
            ((GpFix16Ceiling(fixDBottom) - (DstRect.Y+DstRect.Height)) *
            (-yscale)) / FIX16_ONE +
            SrcRect.Y
        );
    }
    else
    {
        ykci = GpRealToFix16(
            ((GpFix16Floor(fixDTop) - DstRect.Y) *
            yscale) / FIX16_ONE +
            SrcRect.Y
        );
    }

    // Get the width of the kernel.
    // Make sure to multiply by the actual width of the filter kernel in
    // normalized space (FilterWidth[i])

    yw = GpRealToFix16(
        (SrcRect.Height * FilterWidth[FilterMode]) /
        DstRect.Height
    );      // Convert to FIX16

    // Handle the negative transform

    if(yscale < 0)
    {
        yw = -yw;
    }

    // the width of the kernel must be a positive quantity.

    ASSERT(yw >= 0);

    // if the kernel width is less than one we're doing a stretch, not
    // a shrink. In this case we clamp the kernel size to one.

    if(yw < (FIX16_ONE * FilterWidth[FilterMode]))
    {
        yw = FIX16_ONE * FilterWidth[FilterMode];
    }

    // a is 1/w - used to work out the tent filter.

    ya = GpRealToFix16(65536.0f/yw);

    // !!! [asecchia] The rounding used here should match the rounding used to compute
    // the parameters to StretchBitsMainLoop.

    iytop = GpFix16Floor(fixDTop);

    // Compute the width of one scanline in the destination.

    xbuffer_width = GpFix16Ceiling(fixDRight) - GpFix16Floor(fixDLeft);
    ASSERT(xbuffer_width >= 0);

    xbuffer_height = GpFix16Ceiling(yw)*2+1;
    ASSERT(xbuffer_height >= 0);

    // set the rotational array to start at the first scanline.

    xbuffer_start_scanline = 0;

    // allocate the xbuffer.

    // !!! PERF [asecchia]. Ouch this is ugly.
    // we should at least try use a stack buffer for small images.
    // Maybe a lookaside list or something.

    xbuffer = (ARGB *)GpMalloc(xbuffer_height*xbuffer_width*sizeof(ARGB));
    
    // ycoeff needs to have 2 entries more than xbuffer_height because
    // it may be reused to store the MMX coefficients (see OutputSpan
    // routine for details).

    ycoeff = (FIX16 *)GpMalloc((xbuffer_height + 2) * sizeof(FIX16));

    if((NULL == ycoeff) || (NULL == xbuffer))
    {
        isValid = false;
        
        GpFree(xbuffer);
        GpFree(ycoeff);
        
        // Make sure these get initialized to NULL before we can early out
        // otherwise we could end up double freeing the pointers in our
        // destructor.
    
        xbuffer = NULL;
        ycoeff = NULL;
        
        return;
    }

    // set the initial value of last_k to maxint

    last_k = LAST_K_UNUSED;
}



/**************************************************************************\
*
* Function Description:
*
*   This function performs a 1d stretch using the tent filter
*
* Arguments:
*
*   dst   - destination buffer
*   src   - source pixels
*   dw    - destination width in pixels
*   sw    - source width in pixels
*   kci   - the initial kernel centering position (for fractional translate)
*   scale - the scale of the filter - sw/dw
*   w     - the width of the filter kernel - typically the ceiling of sw/dw
*   a     - 1/w
*
* History:
*   04/16/2000 asecchia   created it.
*
\**************************************************************************/

// !!! Perf [asecchia] For really complicated wrapmodes where many of the
//     pixels are outside of the source and hence need to be wrapped, it may
//     make more sense to copy the source into an extended buffer and pre-wrap
//     the end points (i.e. overallocate) for each scanline.
//     This could simplify the code for the complex wrap conditions.
//     However, for the simple codepath, this would give an extra copy per
//     pixel and might not be worth it.


// Ick. Why does the compiler do a better job of optimizing macros?
// These should really be inline function calls.

#define ClampColors() \
        if(FilterMode == HighQualityBilinear)       \
        {                                           \
            ta = GpFix16Round(ta);                  \
            tr = GpFix16Round(tr);                  \
            tg = GpFix16Round(tg);                  \
            tb = GpFix16Round(tb);                  \
            if(ta>255) ta = 255;                    \
            if(tr>255) tr = 255;                    \
            if(tg>255) tg = 255;                    \
            if(tb>255) tb = 255;                    \
        }                                           \
        if(FilterMode == HighQualityBicubic)        \
        {                                           \
            ta = GpFix16Round(ta);                  \
            tr = GpFix16Round(tr);                  \
            tg = GpFix16Round(tg);                  \
            tb = GpFix16Round(tb);                  \
            if(ta>255) ta = 255;                    \
            if(tr>ta) tr = ta;                      \
            if(tg>ta) tg = ta;                      \
            if(tb>ta) tb = ta;                      \
            if(ta<0) ta = 0;                        \
            if(tr<0) tr = 0;                        \
            if(tg<0) tg = 0;                        \
            if(tb<0) tb = 0;                        \
        }


// Compute the kernel in the inner loop
// Note: the If statements are compiled away in the final code
// because they are template variable comparisons which can be 
// done at compile time.

// This macro looks up the new kernel value, subtracts the old one
// to get the area of contribution for this pixel, computes the 
// new kernel position and stores the current table lookup.

#define ComputeKernel(pc, a, pa, pa_old, krn) \
            if(FilterMode == HighQualityBilinear)              \
            {                                                  \
                pa = LPIC[krn >> 9];                           \
                pc = pa-pa_old;                                \
                krn += (a);                                    \
                pa_old = pa;                                   \
            }                                                  \
            if(FilterMode == HighQualityBicubic)               \
            {                                                  \
                pa = CPIC[krn >> 8];                           \
                pc = pa-pa_old;                                \
                krn += (a);                                    \
                pa_old = pa;                                   \
            }

// This block of code accumulates the individual channels from
// kptr into the accumulation buffers tb, tg, tr, and ta.

#define AccumulateChannels(pc, kptr) \
{                        \
    tb += pc * kptr[0];  \
    tg += pc * kptr[1];  \
    tr += pc * kptr[2];  \
    ta += pc * kptr[3];  \
}



inline void Apply1DWrapModeX(INT WrapMode, INT &x, INT w)
{
    INT xm;
    switch(WrapMode) {

    case WrapModeTileFlipY:
    case WrapModeTile:
        x = RemainderI(x, w);
    break;

    case WrapModeTileFlipX:
    case WrapModeTileFlipXY:
        xm = RemainderI(x, w);
        if(((x-xm)/w) & 1) {
            x = w-1-xm;
        }
        else
        {
            x = xm;
        }
    break;

    default:
        // Caller should correctly anticipate other wrap modes.
        ASSERT(FALSE);
    break;
    }
}

inline void Apply1DWrapModeY(INT WrapMode, INT &y, INT h)
{
    INT ym;
    switch(WrapMode) {

    case WrapModeTile:
    case WrapModeTileFlipX:
        y = RemainderI(y, h);
        break;

    case WrapModeTileFlipY:
    case WrapModeTileFlipXY:
        ym = RemainderI(y, h);
        if(((y-ym)/h) & 1) {
            y = h-1-ym;
        }
        else
        {
            y = ym;
        }
    break;

    default:
        // Caller should correctly anticipate other wrap modes.
        ASSERT(FALSE);
    break;
    }
}


#undef RemainderI


/**************************************************************************
*
* Function Description:
*
*   Outputs the middle pixels in a 2:1 stretched scanline.  Note that
*   this function doesn't need to handle wrap modes.
*
*   Note:  this function must not use floating point values, because it could be
*   called with an invalid floating point state (prior to the call to emms)
*
* Arguments:
*
*   dst - The first pixel to be output
*   src - The first pixel in the source that will affect the destination
*         pixel in a bicubic 2:1 stretch
*   dw  - The number of pixels in the destination
*   kci - The subpixel shift in the position of the destination pixels
*
**************************************************************************/

void DpOutputSpanStretch<HighQualityBilinear>::StretchMiddleScanline2_MMX(
    ARGB *dst, 
    ARGB *src, 
    INT dw, 
    FIX16 kci 
)
{
    ASSERT(FALSE);
}

void DpOutputSpanStretch<HighQualityBicubic>::StretchMiddleScanline2_MMX(
    ARGB *dst, 
    ARGB *src, 
    INT dw, 
    FIX16 kci 
)
{
#if defined(_X86_)

    //
    // In order to store the kernel multipliers in 16bit registers, we 
    // will lose the bottom 3 precision bits (hence each k[i] must be 
    // right shifted by three).  The summation of the kernel multipliers
    // should come to 16K, hence KERNEL_SHIFT_AMOUNT is 14.
    //
     
#define KERNEL_SHIFT_AMOUNT 14     
     
    FIX16 k[8];
    FIX16 kernelIncrement = FIX16_ONE >> 2 ;
    FIX16 kCurrent = (kci >> 2) - FIX16_ONE;
    for (INT i = 0; i < 8; i++)
    {
        ASSERT(kCurrent >= -FIX16_ONE);
        ASSERT(kCurrent <= FIX16_ONE);

        k[i] = SymmetricBicubicKernelCenter[kCurrent >> (FIX16_SHIFT-BicubicKernelShift)]; 
        k[i] >>= 3;

        kCurrent += kernelIncrement;        
    }
    
    //
    // Setup 64bit aligned workspace for the MMX code
    //
    // 0 - zero
    // 8  - kernel multiplier 0
    // 16 - kernel multiplier 1
    // 24 - kernel multiplier 2
    // 32 - kernel multiplier 3
    // 40 - accumulator 3: g, b
    // 48 - accumulator 3: a, r
    // 56 - FIX14_HALF
    //

    #define BUFFER_SIZE 16    
    INT buffer[BUFFER_SIZE + 1];
    INT *buffer_64bitAligned = (INT *) ((((UINT_PTR) buffer) + 4) & ~0x7);
    
    buffer_64bitAligned[0]  = 0; // zero
    buffer_64bitAligned[1]  = 0;
    
    buffer_64bitAligned[2]  = (k[7] << 16) | (k[6] & 0xFFFF);   // kernel multiplier 0 
    buffer_64bitAligned[3]  = buffer_64bitAligned[2];

    buffer_64bitAligned[4]  = (k[5] << 16) | (k[4] & 0xFFFF);   // kernel multiplier 1 
    buffer_64bitAligned[5]  = buffer_64bitAligned[4];

    buffer_64bitAligned[6]  = (k[3] << 16) | (k[2] & 0xFFFF);   // kernel multiplier 2 
    buffer_64bitAligned[7]  = buffer_64bitAligned[6];

    buffer_64bitAligned[8]  = (k[1] << 16) | (k[0] & 0xFFFF);   // kernel multiplier 3 
    buffer_64bitAligned[9]  = buffer_64bitAligned[8];

    buffer_64bitAligned[10]  = 0; // Accumulator 3
    buffer_64bitAligned[11]  = 0;
    buffer_64bitAligned[12]  = 0;
    buffer_64bitAligned[13]  = 0;
    
    buffer_64bitAligned[14] = (1 << (14 - 1));       // FIX14_HALF
    buffer_64bitAligned[15] = (1 << (14 - 1));

    //
    // eax - counter for the first loop
    // ebx - 0xffffffff
    // esi - source
    // edi - destination
    // ecx - counter
    // edx - 64it aligned workspace buffer
    //
    // mm6, mm7: accumulator 0
    // mm4, mm5: accumulator 1
    //
    
    _asm
    {
        mov ebx, 0xFFFFFFFF
        mov esi, src
        mov edi, dst
        mov ecx, dw
        mov edx, buffer_64bitAligned
   

        //
        // The first loop loads the initial values into the accumulators, but
        // doesn't write out any pixels.  It executes exactly three times.
        //

        pxor mm4, mm4
        pxor mm5, mm5
        mov  eax, 3
            
loop1:
        
        //
        // Read expanded pixel values into mm0 and mm1
        //

        movd      mm1, [esi]         ; mm1 = 00000000a1r1g1b1
        movd      mm2, [esi + 4]     ; mm2 = 00000000a2r2g2b2
        add       esi, 8

        punpcklbw mm1, [edx]         ; mm1 = 00a100r100g100b1
        punpcklbw mm2, [edx]         ; mm2 = 00a200r200g200b2

        movq      mm0, mm1           ; mm0 = 00a100r100g100b1

        punpckhwd mm1, mm2           ; mm1 = 00a200a100r200r1
        punpcklwd mm0, mm2           ; mm0 = 00g200g100b200b1

        //
        // Add the contribution to accumulator 1
        //

        movq      mm6, [edx + 16]    ; kernel multiplier 1
        movq      mm7, mm6           ; kernel multiplier 1
        pmaddwd   mm6, mm0
        pmaddwd   mm7, mm1
        paddd     mm6, mm4
        paddd     mm7, mm5

        //
        // Add the contribution to accumulator 2
        //

        movq      mm4, [edx + 24]    ; kernel multiplier 2
        movq      mm5, mm4           ; kernel multiplier 2
        pmaddwd   mm4, mm0
        pmaddwd   mm5, mm1
        paddd     mm4, [edx + 40]
        paddd     mm5, [edx + 48]

        //
        // Compute the new third accumulator
        //

        pmaddwd   mm0, [edx + 32]    ; multiply by kernel multiplier 3
        pmaddwd   mm1, [edx + 32]
        movq      [edx + 40], mm0
        movq      [edx + 48], mm1

        dec eax
        jnz loop1


        //
        // The second loop continues to compute the accumulators, but
        // also writes out destination pixels.
        //

loop2:
        
        //
        // Read expanded pixel values into mm0 and mm1
        //

        movd      mm1, [esi]         ; mm1 = 00000000a1r1g1b1
        movd      mm2, [esi + 4]     ; mm2 = 00000000a2r2g2b2
        add       esi, 8

        punpcklbw mm1, [edx]         ; mm1 = 00a100r100g100b1
        punpcklbw mm2, [edx]         ; mm2 = 00a200r200g200b2

        movq      mm0, mm1           ; mm0 = 00a100r100g100b1

        punpckhwd mm1, mm2           ; mm1 = 00a200a100r200r1
        punpcklwd mm0, mm2           ; mm0 = 00g200g100b200b1

        //
        // Add the contribution to accumulator 0
        //

        movq      mm2, [edx + 8]     ; mm2 = kernel multiplier 0
        movq      mm3, mm2           ; mm3 = kernel multiplier 0
        pmaddwd   mm2, mm0           ; mm2 = 0000gggg0000bbbb
        pmaddwd   mm3, mm1           ; mm3 = 0000aaaa0000rrrr
        paddd     mm6, mm2           ; add contributions to accumulator 0
        paddd     mm7, mm3

        //
        // Extract the pixel value from accumulator 0.
        //

        paddd     mm6, [edx + 56]    ; round
        psrad     mm6, KERNEL_SHIFT_AMOUNT
        paddd     mm7, [edx + 56]
        psrad     mm7, KERNEL_SHIFT_AMOUNT
        packssdw  mm6, mm7           ; mm6 = 00aa00rr00gg00bb    
        packuswb  mm6, mm6           ; mm6 = 00000000aarrggbb

        //
        // Clip all channels to alpha
        //

        movd      mm2, ebx           ; mm2 = 00000000ffffffff
        movq      mm7, mm6           ; mm7 = 00000000aarrggbb
        psrad     mm7, 24            ; mm7 = 00000000000000aa
        punpcklbw mm7, mm7           ; mm7 = 000000000000aaaa
        punpcklbw mm7, mm7           ; mm7 = 00000000aaaaaaaa
        psubusb   mm2, mm7
        paddusb   mm6, mm2
        psubusb   mm6, mm2

        movd      [edi], mm6
        add       edi, 4
        
        //
        // Add the contribution to accumulator 1
        //

        movq      mm6, [edx + 16]    ; kernel multiplier 1
        movq      mm7, mm6           ; kernel multiplier 1
        pmaddwd   mm6, mm0
        pmaddwd   mm7, mm1
        paddd     mm6, mm4
        paddd     mm7, mm5

        //
        // Add the contribution to accumulator 2
        //

        movq      mm4, [edx + 24]    ; kernel multiplier 2
        movq      mm5, mm4           ; kernel multiplier 2
        pmaddwd   mm4, mm0
        pmaddwd   mm5, mm1
        paddd     mm4, [edx + 40]
        paddd     mm5, [edx + 48]

        //
        // Compute the new third accumulator
        //

        pmaddwd   mm0, [edx + 32]    ; multiply by kernel multiplier 3
        pmaddwd   mm1, [edx + 32]
        movq      [edx + 40], mm0
        movq      [edx + 48], mm1

        dec ecx
        jnz loop2
        emms
    }

#undef KERNEL_SHIFT_AMOUNT

#endif // defined(_X86_)
}

/**************************************************************************\
*
* Function Description:
*
*   DpOutputSpanStretch<FilterMode>::StretchScanline
*   Stretches a single scanline (magnification or minification) using
*   the reconstruction/interpolation mode specified by the template
*   parameter. Currently this is used for bilinear and bicubic filters.
*
* Arguments:
*
*    ARGB *dst,    // destination pointer
*    ARGB *src,    // source pointer
*    INT dw,       // destination width (pixels)
*    INT sw,       // source width (pixels)
*    FIX16 kci,    // initial position of the kernel center
*    FIX16 scale,  // scale factor
*    FIX16 w,      // width from center of the kernel to the edge
*    FIX16 a,      // 1/w
*
* Notes:
*   

The following description is based on the bilinear (tent) filter but it is
equally applicable to the bicubic - though the pictures and description would
be slightly more complicated.

The code below is significantly complicated by the fact that we want the inner
kernel loop to be quick and therefore not handle the wrap modes. In order to 
make this work, we first compute the number of pixels on the left and right
of the scanline that need to consider the wrap mode. We process the left first
and then run the optimized loop for all the inner pixels (which ignores the 
wrap conditions). After that we run the right edge.
          
Bilinear filter convolution kernel:
Note that each kernel has an intrinsic width - bilinear = 1 and bicubic = 2.
This width is scaled by the inverse of the stretch factor - i.e. a shrink
that results in 1/3 of the size being output requires a width (w) of 3 for the
bilinear and 6 for the bicubic. Also the height of the filter kernel is scaled
by the scale factor - i.e. the height of 1 (for all kernels) becomes 1/3 in 
the above example.

          
                            --- | ---                      ^
                        ---  .  |  .  ---                  |
                    ---      .  |  .     .---              h
                ---    .     .  |  .     .    ---          |
            ---  .     .     .  |  .     .     .  ---      |
        ---.     .     .     .  |  .     .     .     .---  v
-----0-----1-----2-----3-----4--|--5-----6-----7-----8-----9------------        
                                |
     kb                         kc                         ke
                                <------------w----------->

The filter kernel is shifted so that kc is exactly at the position of the
required destination pixel transformed into the source pixel array by the
scale factor. This will in general fall somewhere between two pixel samples - 
in the above picture, between pixels 4 and 5.

The goal is to get a color value for the position at kc and emit that into
the destination pixel stream. The standard evaluation method is to compute 
the height of the filter kernel at each of the pixel samples under the filter 
convolution corresponding to pixels 0, 1, ... 9. These heights are used to
weight each pixel sample and the result is summed giving the destination pixel
at kc. 

The problem with the standard evaluation is that at non-integer shrinks 
the mathematical evaluation of the kernel produces ripples in the output - i.e.
a solid field of pixels responds with a sine-wave-like ripple output. This is 
a theoretical problem with the discrete evaluation of the kernel integral.

Our evaluation actually stores a table of partial integrals from -inf to x. We
use this table to compute the area around each pixel and the area is used as
the weight. This evaluation is guaranteed to respond with exactly one for any
position and scale factor of the kernel. This property gives a stable field 
response allowing us to have non-ripple shrinks.

                            ---.: ---                       
                        ---.....:     ---                   
                    ---   :.....:         ---               
                ---       :.....:             ---           
            ---           :.....:                 ---       
        ---               :.....:                     ---   
-----0-----1-----2-----3-----4-----5-----6-----7-----8-----9------------        
                                                              
To evaluate this properly, we lookup the integral from -inf to 4.5 ( actually
we rescale so that the center of the kernel is at 0 ) and then subtract the 
table lookup for the integral from -inf to 3.5. This gives us an exact 
(within the error of the table) computation for the area from 3.5 to 4.5. 
This is what we use for the weight of pixel 4. Note that contrary to the 
standard evaluation pixel 9 does contribute even though 9 is outside of the
kernel. 8.5 is inside the kernel so the area under the kernel from 8.5 to 9.5 
is a small triangular area and is not equal to zero. Not accounting for this is 
the major source of error in the standard evaluation.

Note that the lookup for the end point integral for pixel 4 of -inf to 4.5 can 
be reused as the start point for the next pixel (5). An important property of 
this is that any error (e) in the lookup for -inf to 4.5 is added in pixel 
4's contribution and subtracted in pixel 5's contribution which results in 
the total error for the filter response -- due to table discretization -- being
completely subtracted away --- the end points have an error of exactly zero 
because we sample from beyond the left (area of exactly 0) to beyond the right 
(area of exactly 1). This is not precisely true because the error is scaled
by the pixel values, but it does help.

Note that this integral method is equivalent to convolving the input pixels
(comb) with the box filter of width 1 pixel and then convolving the result
with the filter kernel. [analysis due to Jim Blinn - see documentation in 
the Specs directory.]

Further documentation is available in the specs directory:
gdiplus\specs\filter\convolution.doc


*   Note:  this function must not use floating point values, because it could be
*   called with an invalid floating point state (prior to the call to emms)
*
* History:
*
*   04/16/2000 asecchia   created it
*
\**************************************************************************/


template<FilterModeType FilterMode>
void DpOutputSpanStretch<FilterMode>::StretchScanline(
    ARGB *dst,    // destination pointer
    ARGB *src,    // source pointer
    INT dw,       // destination width (pixels)
    INT sw,       // source width (pixels)
    FIX16 kci,    // initial position of the kernel center
    FIX16 scale,  // scale factor
    FIX16 w,      // width from center of the kernel to the edge
    FIX16 a       // 1/w
)
{
    // Note: this is a template class so the value of FilterMode
    // is defined at compile time. We're relying on the compiler
    // to perform dead code removal for each template instantiation
    // eliminating both the constant comparison and all the
    // code branches corresponding to other FilterMode values.
    // That way our inner loop is not impacted by extra code for
    // filter modes we're not using and extraneous conditional
    // statements.

    // Center of the filter kernel.
    // Shift over to the left by half because we want to center the area of
    // contribution for each sample on the sample - rather than taking the 
    // area between two point samples as the contribution for the sample on 
    // the right.

    FIX16 kc = kci - FIX16_HALF;

    // Left and right extent of the kernel, intra-kernel position,
    // and pixel contribution.

    INT kb, ke;
    INT kbt, ket;
    FIX16 kp, pc, pa, pa_old;

    // Loop variables

    INT x, k;

    // Incremental loop state, intermediate computation.

    ARGB *d = dst;
    FIX16 krn = 0;

    // Color channel accumulators.

    FIX16 ta, tr, tg, tb;

    // Compute the first pixel along the destination scanline that doesn't
    // have any wrap contribution and then the last pixel (l & r).
    // Note that all the terms have a FIX16_ONE factor which cancel out.

    // !!! Perf: [asecchia] This stuff is computed every scanline -
    //     and it's always the same. We could pass these coordinates to
    //     this routine and have them precomputed.

    INT lWrapX;
    INT rWrapX;

    if(scale>=0)
    {
        // x==sw is considered outside of the source.

        FIX16 fix_sw = (sw-1) << FIX16_SHIFT;

        // add (scale-1) and use idiv to get a Ceiling()

        lWrapX = (w-kc+(scale-1))/scale;

        // idiv should give us Floor().

        rWrapX = (fix_sw-w-kc)/scale;
    }
    else
    {
        // x==sw is considered outside of the source.

        FIX16 fix_sw = (sw-1) << FIX16_SHIFT;

        // note: in the -x scale transform, the sense of lWrapX and rWrapX
        // can be confusing. The l&r apply to the destination left and right
        // and are swapped here when we compute the initial position from
        // the inverted left and right source points.
        // As we traverse the destination from left to right we'll encounter
        // lWrapX first and then rWrapX, but the kc (kernel center) will be
        // moving through the source from right to left decrementing by
        // scale each time.

        // use idiv to get a Floor()

        rWrapX = (w-kc)/scale;

        // add scale+1 and use idiv for Ceiling().

        lWrapX = (fix_sw-w-kc+(scale+1))/scale;
    }

    // Now clamp to the range of the destination we're going to draw.

    lWrapX = max(0, lWrapX);
    rWrapX = min(dw, rWrapX);

    BYTE *kptr;
    INT  k_wrap;

    // Do the left wrapmode pixels.
/*          
                            --- | ---                      ^
                        ---     |     ---                  |
                    ---         |         ---              h
                ---             |             ---          |
            ---                 |                 ---      |
        ---                     |                     ---  v
-----0-----1-----2-----3-----4--|--5-----6-----7-----8-----9------------        
     kb                         kc <-----------w---------->ke
                   kbt                     ket
      <----wrap----><---------texture------><----wrap----->
       +ve transform                         -ve transform
      or straddle case                      or straddle case

The following loop handles the case where the wrap happens on the left of the
kernel. There are three subloops - first to handle the pixels in the wrap 
segment on the left, then to handle the pixels in the texture. Normally the
texture pixels will extend to the right edge of the kernel and we'll be done, 
but two cases make the right wrap essential at this point. First if the 
transform is negative, the sense is flipped and the texture extends from the 
left edge to the middle point and the wrap extends the rest of the kernel to 
the right edge. Also if the texture is sufficiently small and the shrink factor 
sufficiently large, the filter kernel could overlap both the left and right edge
of the texture and require wrapping on both sides.
*/

    for(x=0; x<min(lWrapX, dw); x++)
    {
        ASSERT(x<dw);
        // Compute the start and end of the filter kernel coverage

        kb = GpFix16Ceiling(kc-w);
        ke = GpFix16Ceiling(kc+w);

        // Bound the pixels in the texture.

        // kbt == kernel begin texture coordinate.
        // ket == kernel end texture coordinate.

        kbt = max(0,kb);
        ket = min(ke, sw-1);

        // Initialize the component accumulators. We accumulate the
        // contribution of each color component scaled by the kernel
        // response into these variables.

        ta = tr = tg = tb = 0;

        // These pixels are off the left of the texture.
        pa_old = 0;

        // Iterate over each pixel under the filter kernel.
        // if ke==kb then there is one point.
        krn = Int32x32Mod16(a, (kb << FIX16_SHIFT) - kc);

        if(QWrapMode == WrapModeClamp)
        {
            // Clamp modes.

            for(k=kb; k<min(kbt, ke+1); k++)
            {
                // these pixels are always off the left of the texture.

                ASSERT(k<0);

                ComputeKernel(pc, a, pa, pa_old, krn);

                ta += pc * ClampColorA;
                tr += pc * ClampColorR;
                tg += pc * ClampColorG;
                tb += pc * ClampColorB;
            }
        }
        else
        {
            // Do the full wrap computation.

            for(k=kb; k<min(kbt, ke+1); k++)
            {
                // these pixels are always off the left of the texture.

                k_wrap = k;

                ASSERT(k<0);

                // !!! Perf: [asecchia] This is really slow.
                //     If we ever decide to make wrap modes propagate
                //     through the outcrop region and decide that wrap
                //     tile and flip x,y are important perf scenarios,
                //     we should come back and replace this divide with
                //     repeated subtraction - most times it can be avoided.
                //     However, right now this is only used for a few
                //     pixels on the edges and we don't really mind the
                //     perf hit for these modes.

                Apply1DWrapModeX(QWrapMode, k_wrap, sw);
                ComputeKernel(pc, a, pa, pa_old, krn);
                kptr = (BYTE*)(src + k_wrap);
                AccumulateChannels(pc, kptr);
            }

        }

        // Initialize the color channel accessor pointer to the beginning
        // of the source pixel array for this kernel.

        kptr = (BYTE*)(src + kbt);

        // HighQualityBicubic needs to initialize the krn value.
        // It is used to do the kernel table lookup.
        // HighQualityBilinear doesn't use this as it works out it's
        // kernel by direct computation.

        krn = Int32x32Mod16(a, (kbt << FIX16_SHIFT) - kc);

        // These pixels hit the texture.

        for(k=kbt; k<=ket; k++)
        {
            ComputeKernel(pc, a, pa, pa_old, krn);

            // Accumulate the contribution of this source pixel to the pixel
            // we're working on.
            AccumulateChannels(pc, kptr);
            kptr += 4;
        }

        // These pixels are off the right of the texture.
        // This can happen if the kernel spans the entire source texture.

        // Iterate over each pixel under the filter kernel.
        // if ke==kb then there is one point.

        krn = Int32x32Mod16(a, (max(ket+1, kb) << FIX16_SHIFT) - kc);

        if(QWrapMode == WrapModeClamp)
        {
            // Clamp modes.

            for(k=max(ket+1, kb); k<=ke; k++)
            {
                ComputeKernel(pc, a, pa, pa_old, krn);

                ta += pc * ClampColorA;
                tr += pc * ClampColorR;
                tg += pc * ClampColorG;
                tb += pc * ClampColorB;
            }
        }
        else
        {
            // Do the full wrap computation.

            for(k=max(ket+1, kb); k<=ke; k++)
            {
                k_wrap = k;
                Apply1DWrapModeX(QWrapMode, k_wrap, sw);
                ComputeKernel(pc, a, pa, pa_old, krn);
                kptr = (BYTE*)(src + k_wrap);
                AccumulateChannels(pc, kptr);
            }

        }
        // Done with this pixel - store it in the destination buffer.

        // clamp the results to byte range.

        ClampColors();

        // Combine the channels, set the destination pixel and increment
        // to the next pixel

        *d++ = (ta << 24) | (tr << 16) | (tg << 8) | tb;
        kc += scale;
    }

    // For all points, x, in the destination compute the position of the
    // kernel center in the source and sum the contribution under the filter.

    const INT minCenterWidthMMX = 16;
    INT dstCenterWidth = rWrapX - lWrapX;
    INT srcFirst = GpFix16Ceiling(kc - w);
    INT srcLast  = GpFix16Floor(kc+w + (dstCenterWidth - 1) * scale);

    // srcLast_2Stretch is the last pixel touched by the MMX routine.
    // The number of pixels touched by the routine is equal to six
    // (setup pixels) plus two times the width of the center strip
    // in the destination.  We subtract one in order the get the actual
    // last pixel touched by StretchMiddleScanline2_MMX (so that we can
    // compare it with srcLast).

    INT srcLast_2Stretch = srcFirst + (dstCenterWidth + 3) * 2 - 1;

#if defined(_X86_)
    if ((OSInfo::HasMMX) &&
        (FilterMode == HighQualityBicubic))
    {
        // MMX and high quality bicubic

        if ((dstCenterWidth >= minCenterWidthMMX) &&
            ((srcLast_2Stretch == srcLast) || (srcLast_2Stretch == (srcLast - 1))))
        {
            ASSERT(srcFirst >= 0);
            ASSERT(srcLast_2Stretch < sw);

            // Stretch the middle pixels by a factor of two using optimized MMX
            // code.

            FIX16 kc_center = kc + FIX16_HALF;
            StretchMiddleScanline2_MMX(d,
                                       src + srcFirst,
                                       dstCenterWidth,
                                       kc_center - (GpFix16Floor(kc_center) * FIX16_ONE));
            d += dstCenterWidth;
            kc += scale * dstCenterWidth;
            x += dstCenterWidth;
        }
        else
        {
            // This is the MMX version of the general purpose bicubic scaling
            // code.

            for(x=lWrapX; x<rWrapX; x++)
            {
                // Cannot go over dw because rWrap is < dw

                ASSERT(x<dw);

                // Compute the start and end of the filter kernel coverage

                kb = GpFix16Ceiling(kc-w);
                ke = GpFix16Ceiling(kc+w);

                // Default loop assumes most pixels don't have to worry about
                // wrap mode along the ends of the scanline.

                ASSERT(kb>=0);
                ASSERT(ke<sw);

                // Initialize the color channel accessor pointer to the beginning
                // of the source pixel array for this kernel.

                kptr = (BYTE*)(src + kb);

                // HighQualityBicubic needs to initialize the krn value.
                // It is used to do the kernel table lookup.
                // HighQualityBilinear doesn't use this as it works out it's
                // kernel by direct computation.

                krn = Int32x32Mod16(a, (kb << FIX16_SHIFT) - kc);

                // Iterate over each pixel under the filter kernel.
                // if ke==kb then there is one point.

                INT bcl_count = ke - kb + 1;
                INT bcl_half_count = bcl_count >> 1;
                bcl_count &= 0x1;

                _asm
                {
                    // eax - krn
                    // ebx - kptr
                    // esi - LPIC
                    // edi - a
                    //
                    // mm5 - pold
                    // mm6 - green ; blue
                    // mm7 - alpha ; red

                    mov          eax, krn
                    mov          ebx, kptr
                    mov          esi, CPIC
                    mov          edi, a
                    pxor         mm5, mm5
                    movq         mm6, FIX14_HALF_MMX
                    movq         mm7, mm6
                    pxor         mm0, mm0

                    dec          bcl_half_count
                    jl           bicubic_center_loop_last_pixel

                bicubic_center_loop:

                    // Read the next two pixels into mm2 and mm1

                    movd         mm2, [ebx]      // mm2 = pixel1
                    movd         mm1, [ebx + 4]  // mm1 = pixel2
                    add          ebx, 8

                    // Compute the kernel values for these two pixels

                    mov          edx, eax
                    sar          edx, 8
                      punpcklbw    mm2, mm0
                    movd         mm3, [esi + 4 * edx] // mm3 = p1

                    lea          edx, [eax + edi]
                    sar          edx, 8
                      punpcklbw    mm1, mm0
                    movd         mm4, [esi + 4 * edx] // mm4 = p2

                    punpckldq    mm5, mm3             // mm5 = p1 | pold
                    lea          eax, [eax + 2 * edi]
                    punpckldq    mm3, mm4             // mm3 = p2 | p1

                    psrad        mm5, 2
                    psrad        mm3, 2

                    psubd        mm3, mm5             // mm3 = kernel2 | kernel1
                    movq         mm5, mm4             // mm5 = pold
                    packssdw     mm3, mm3             // mm3 = kernel2 | kernel1 | kernel2 | kernel1

                    // At this point:
                    // mm3 = kernel2 | kernel1 | kernel2 | kernel1
                    // mm2, mm1 contain pixel1 and pixel2 respectively

                    movq         mm4, mm2
                    punpcklwd    mm2, mm1
                    pmaddwd      mm2, mm3    
                    punpckhwd    mm4, mm1
                    paddd        mm6, mm2
                    dec          bcl_half_count
                    pmaddwd      mm4, mm3
                    paddd        mm7, mm4

                    jge          bicubic_center_loop

                bicubic_center_loop_last_pixel:

                    dec          bcl_count
                    jl           bicubic_center_loop_done

                    // Read the last pixel into mm2

                    movd         mm2, [ebx]
                    punpcklbw    mm2, mm0 // mm2 = a | r | g | b
                    movq         mm3, mm2
                    punpcklwd    mm2, mm0 // mm2 = 0 | g | 0 | b
                    punpckhwd    mm3, mm0 // mm3 = 0 | a | 0 | r

                    // Compute the kernel value for this pixel

                    sar          eax, 8
                    psrad        mm5, 2
                    movd         mm4, [esi + 4 * eax] // mm4 = p
                    psrad        mm4, 2
                    psubd        mm4, mm5
                    packssdw     mm4, mm4

                    pmaddwd      mm2, mm4
                    pmaddwd      mm3, mm4

                    paddd        mm6, mm2
                    paddd        mm7, mm3

                bicubic_center_loop_done:

                    // At this point, mm6 and mm7 contain the output channels
                    // for the pixel.  We need to clamp the alpha and store it
                    // in the destination buffer.

                    psrad        mm6, 14
                    psrad        mm7, 14
                    packssdw     mm6, mm7 // mm6 = a | r | g | b
                    packuswb     mm6, mm6 // mm6 = 00000000aarrggbb

                    movq         mm7, mm6 // mm7 = 00000000aarrggbb
                    psrad        mm6, 24  // mm6 = xxxxxxxxxxxxxxaa
                      mov          eax, 0xFFFFFFFF
                    punpcklbw    mm6, mm6 // mm6 = xxxxxxxxxxxxaaaa
                      movd         mm2, eax
                    punpcklbw    mm6, mm6 // mm6 = xxxxxxxxaaaaaaaa

                    psubusb      mm2, mm6
                      mov          eax, d
                    paddusb      mm7, mm2
                    psubusb      mm7, mm2

                    movd         [eax], mm7
                    add          eax, 4
                    mov          d, eax
                }
            
                kc += scale;
            }
        }
    }
    else
#endif // defined(_X86_)    
/*          
                            --- | ---                      ^
                        ---     |     ---                  |
                    ---         |         ---              h
                ---             |             ---          |
            ---                 |                 ---      |
        ---                     |                     ---  v
-----0-----1-----2-----3-----4--|--5-----6-----7-----8-----9------------        
     kb                         kc <-----------w---------->ke
                                
      <-----------------------texture--------------------->

The following loop is guaranteed to only hit texture for every pixel under
the kernel. This is the majority of the pixels in most normal stretch 
cases. We can simplify this loop because of this assumption and therefore
get a performance win.
Many of the degenerate wrap cases will simply skip this loop.
*/
    {
        // no MMX

        for(x=lWrapX; x<rWrapX; x++)
        {
            // Cannot go over dw because rWrap is < dw

            ASSERT(x<dw);

            // Compute the start and end of the filter kernel coverage

            kb = GpFix16Ceiling(kc-w);
            ke = GpFix16Ceiling(kc+w);

            // Default loop assumes most pixels don't have to worry about
            // wrap mode along the ends of the scanline.

            ASSERT(kb>=0);
            ASSERT(ke<sw);

            // Initialize the component accumulators. We accumulate the
            // contribution of each color component scaled by the kernel
            // response into these variables.

            ta = tr = tg = tb = 0;

            // Initialize the color channel accessor pointer to the beginning
            // of the source pixel array for this kernel.

            kptr = (BYTE*)(src + kb);

            // HighQualityBicubic needs to initialize the krn value.
            // It is used to do the kernel table lookup.
            // HighQualityBilinear doesn't use this as it works out it's
            // kernel by direct computation.

            krn = Int32x32Mod16(a, (kb << FIX16_SHIFT) - kc);
            pa_old = 0;

            // Iterate over each pixel under the filter kernel.
            // if ke==kb then there is one point.

            for(k=kb; k<=ke; k++)
            {
                ComputeKernel(pc, a, pa, pa_old, krn);

                // Accumulate the contribution of this source pixel to the pixel
                // we're working on.
                
                AccumulateChannels(pc, kptr);

                kptr += 4;
            }

            // Done with this pixel - store it in the destination buffer.

            // clamp the results to byte range.

            ClampColors();
        
            ASSERT(tr<=ta);
            ASSERT(tg<=ta);
            ASSERT(tb<=ta);
            ASSERT(ta>=0);
            ASSERT(tr>=0);
            ASSERT(tg>=0);
            ASSERT(tb>=0);

            // Combine the channels, set the destination pixel and increment
            // to the next pixel

            *d++ = (ta << 24) | (tr << 16) | (tg << 8) | tb;
            
            kc += scale;
        }
    }

    // Need to use max() here to handle the case where lWrapX > rWrapX
    // which can happen if the filter spans both edges of the scanline.

    // Do the right wrapmode pixels.

/*          
                            --- | ---                      ^
                        ---     |     ---                  |
                    ---         |         ---              h
                ---             |             ---          |
            ---                 |                 ---      |
        ---                     |                     ---  v
-----0-----1-----2-----3-----4--|--5-----6-----7-----8-----9------------        
     kb                         kc <-----------w---------->ke
                   kbt                     ket
      <----wrap----><---------texture------><----wrap----->
      -ve transform                           +ve tranform
        case only                               case only
      
The following loop handles the case where the wrap happens on the right of the
kernel. There are three subloops - first to handle the pixels in the wrap 
segment on the left - if any, then to handle the pixels in the texture. After 
that handle the pixels in the right wrap. Normally the texture pixels will 
extend to the left edge of the kernel and the first subloop will simply be 
skipped, but the left wrap is essential if the transform is negative --- the 
sense is flipped and the texture extends from the right edge to the middle 
point and the wrap extends the rest of the kernel to the left edge. 
Note it's not possible at this point to have wrapping at both edges of the 
kernel the wrap is on the left iff the transform is negative. The wrap is on 
the right iff the transform is positive. The case where both wrapmodes is 
present has already been taken care of in the first loop.
*/

    for(x=max(x, rWrapX); x<dw; x++)
    {
        // Compute the start and end of the filter kernel coverage

        kb = GpFix16Ceiling(kc-w);
        ke = GpFix16Ceiling(kc+w);

        // Bound the pixels in the texture.

        // ket == kernel end texture coordinate (inclusive).
        // kbt == kernel begin texture coordinate.

        kbt = max(0,kb);
        ket = min(ke, sw-1);

        // Initialize the component accumulators. We accumulate the
        // contribution of each color component scaled by the kernel
        // response into these variables.

        ta = tr = tg = tb = 0;

        // Initialize the color channel accessor pointer to the beginning
        // of the source pixel array for this kernel.

        kptr = (BYTE*)(src + kb);

        // HighQualityBicubic needs to initialize the krn value.
        // It is used to do the kernel table lookup.
        // HighQualityBilinear doesn't use this as it works out it's
        // kernel by direct computation.

        pa_old = 0;

        if(kb<kbt)
        {  
            krn = Int32x32Mod16(a, (kb << FIX16_SHIFT) - kc);
        }

        // Iterate over each pixel under the filter kernel.
        // if ke==kb then there is one point.

        // These pixels are off the left of the texture.
        // This is possible for negative transform cases.

        if(QWrapMode == WrapModeClamp)
        {
            // Clamp modes.

            for(k=kb; k<min(kbt, ke+1); k++)
            {
                // these pixels are always off the left of the texture.

                ASSERT(k<0);

                ComputeKernel(pc, a, pa, pa_old, krn);

                ta += pc * ClampColorA;
                tr += pc * ClampColorR;
                tg += pc * ClampColorG;
                tb += pc * ClampColorB;
            }
        }
        else
        {
            // Do the full wrap computation.

            for(k=kb; k<min(kbt, ke+1); k++)
            {
                // these pixels are always off the left of the texture.

                k_wrap = k;

                ASSERT(k<0);

                // !!! Perf: [asecchia] This is really slow.
                //     If we ever decide to make wrap modes propagate
                //     through the outcrop region and decide that wrap
                //     tile and flip x,y are important perf scenarios,
                //     we should come back and replace this divide with
                //     repeated subtraction - most times it can be avoided.
                //     However, right now this is only used for a few
                //     pixels on the edges and we don't really mind the
                //     perf hit for these modes.

                Apply1DWrapModeX(QWrapMode, k_wrap, sw);
                ComputeKernel(pc, a, pa, pa_old, krn);
                kptr = (BYTE*)(src + k_wrap);
                AccumulateChannels(pc, kptr);
            }

        }

        // Initialize the color channel accessor pointer to the beginning
        // of the source pixel array for this kernel.

        kptr = (BYTE*)(src + kbt);

        // HighQualityBicubic needs to initialize the krn value.
        // It is used to do the kernel table lookup.
        // HighQualityBilinear doesn't use this as it works out it's
        // kernel by direct computation.

        krn = Int32x32Mod16(a, (kbt << FIX16_SHIFT) - kc);

        // These pixels hit the texture.

        for(k=kbt; k<=ket; k++)
        {
            ComputeKernel(pc, a, pa, pa_old, krn);

            // Accumulate the contribution of this source pixel to the pixel
            // we're working on.
            
            AccumulateChannels(pc, kptr);
            kptr += 4;
        }

        // These pixels are off the right of the texture.
        
        // Iterate over each pixel under the filter kernel.
        // if ke==kb then there is one point.
        krn = Int32x32Mod16(a, ((max(ket+1, kb)) << FIX16_SHIFT) - kc);

        if(QWrapMode == WrapModeClamp)
        {
            // Clamp modes.

            for(k=max(ket+1, kb); k<=ke; k++)
            {
                ComputeKernel(pc, a, pa, pa_old, krn);

                ta += pc * ClampColorA;
                tr += pc * ClampColorR;
                tg += pc * ClampColorG;
                tb += pc * ClampColorB;
            }
        }
        else
        {
            // Do the full wrap computation.

            for(k=max(ket+1, kb); k<=ke; k++)
            {
                // Apply the general pixel wrap

                k_wrap = k;
                Apply1DWrapModeX(QWrapMode, k_wrap, sw);
                ComputeKernel(pc, a, pa, pa_old, krn);
                kptr = (BYTE*)(src + k_wrap);
                AccumulateChannels(pc, kptr);
            }
        }

        // Done with this pixel - store it in the destination buffer.

        // clamp the results to byte range.

        ClampColors();

        // Combine the channels, set the destination pixel and increment
        // to the next pixel

        *d++ = (ta << 24) | (tr << 16) | (tg << 8) | tb;
        kc += scale;
    }
#ifdef _X86_
    if ((OSInfo::HasMMX) &&
        (FilterMode == HighQualityBicubic))
    {
        _asm
        {
            emms
        }
    }
#endif // _X86_
}



/**************************************************************************
*
* Function Description:
*
*   Outputs one scanline on the destination device
*
*   Note:  this function must not use floating point values because of
*   potential conflicts with the MMX register values.
*
* Return Value:
*
*   GpStatus. Always returns Ok.
*   !!! [asecchia] are we going to remove this return value - these
*   always return success.
*
* Created:
*
*   04/17/2000 asecchia
*      Created it.
*
**************************************************************************/

template<FilterModeType FilterMode>
GpStatus DpOutputSpanStretch<FilterMode>::OutputSpan(
  INT y,
  INT xMin,
  INT xMax     // xMax is exclusive
)
{
    ASSERT(isValid);
    
    // This function assumes that it's called with a correctly ordered span.

    ASSERT((xMax-xMin)>=0);

    INT width = xMax-xMin;

    // We can't have someone draw outside our specified destination.
    // If this assert fires, we don't have enough buffer space to store the
    // destination xscale so we'd overrun the buffer. The caller set us up
    // with an incorrect destination rectangle or got their rounding wrong.

    ASSERT(width <= xbuffer_width);

    INT left = xMin;
    INT right = xMax;
    // If there's nothing to do, simply return.

    if(right < left)
    {
        return Ok;
    }

    ASSERT(right >= left);

    // Make sure the caller clipped correctly - we can't handle
    // being called to draw outside out destination rectangle.

    ASSERT(y >= iytop);

    // Compute the kernel center for this y coordinate relative to the first
    // y coordinate (y coordinate corresponding to DstRect.Y) and offset
    // by the source rectangle.

    FIX16 kc;

    if(yscale < 0)
    {
        kc = ykci - (y - iytop) * (-yscale);
    }
    else
    {
        kc = ykci + (y - iytop) * yscale;
    }
    
    // Center of the filter kernel.
    // Shift over to the left by half because we want to center the area of
    // contribution for each sample on the sample - rather than taking the 
    // area between two point samples as the contribution for the sample on 
    // the right.
    
    kc -= FIX16_HALF;

    // Compute the start and end of the filter kernel coverage

    FIX16 kb = GpFix16Ceiling(kc-yw);
    FIX16 ke = GpFix16Ceiling(kc+yw);

    // Get the source pointer.

    ARGB *srcPtr0 = static_cast<ARGB*> (BmpData.Scan0);
    INT stride = BmpData.Stride/sizeof(ARGB);

    ARGB *src;
    ARGB *dst;

    FIX16 pc, kp, pa, pa_old;
    FIX16 ta, tr, tg, tb;

    ARGB pix;

    INT k, x, kmod;

    FIX16 krn = 0;

    // if there was a last_k before this iteration

    // compute the new xbuffer_start_scanline

    if(last_k != LAST_K_UNUSED)
    {
        // If there is no overlap in the rotational buffer from the
        // last time, initialize the rotational buffer to the start.

        if(yscale < 0)
        {
            // Negative y scale.

            if(ke-last_k < 0)
            {
                xbuffer_start_scanline = 0;
            }
            else
            {
                xbuffer_start_scanline -= last_k-kb;
                if(xbuffer_start_scanline < 0)
                {
                    xbuffer_start_scanline += xbuffer_height;
                }

            }
        }
        else
        {
            // Positive y scale.

            if(last_k-kb < 0)
            {
                xbuffer_start_scanline = 0;
            }
            else
            {
                // Figure out where to start in the xbuffer so that we
                // can reuse the already scaled scanlines.

                xbuffer_start_scanline -= (last_k-kb)+1;
                if(xbuffer_start_scanline < 0)
                {
                    xbuffer_start_scanline += xbuffer_height;
                }
            }
        }
    }
    else
    {
        // this should be the first time we're hitting this
        // routine. xbuffer_start_scanline should be properly
        // initialized.

        ASSERT(xbuffer_start_scanline == 0);
    }

    // make sure we're going to access valid memory in the xbuffer.

    ASSERT(xbuffer_start_scanline >= 0);
    ASSERT(xbuffer_start_scanline < xbuffer_height);

    // !!! [asecchia] if we thought about it some, we could probably
    // import the code in StretchScanline into this loop
    // and merge this and the next loop significantly reducing the memory
    // requirements for the xbuffer.

    // The xbuffer_height should be == (ke-kb)+1 for all cases except when
    // the center (kc) is exactly on an integer in which case the first and
    // last entries under the kernel have a contribution of zero so it doesn't
    // matter if we drop one scanline in that case.
    // Start at the position we left off from the previous scanline. Use the
    // rotational buffer to remember the data from the previous scanline work.

    // HighQualityBicubic needs to initialize the krn value.
    // It is used to do the kernel table lookup.
    // HighQualityBilinear doesn't use this as it works out it's
    // kernel by direct computation.

    // Note: this is a template class so the value of FilterMode
    // is defined at compile time. We're relying on the compiler
    // to perform dead code removal for each template instantiation
    // eliminating both the constant comparison and all the
    // code branches corresponding to other FilterMode values.
    // That way our inner loop is not impacted by extra code for
    // filter modes we're not using and extraneous conditional
    // statements.

    krn = Int32x32Mod16(ya, (kb << FIX16_SHIFT) - kc);
    pa_old = 0;

    for(k=0; k<xbuffer_height; k++)
    {
        kmod = xbuffer_start_scanline + k;
        if(kmod >= xbuffer_height) kmod -= xbuffer_height;

        // We avoid using a mod (%) computation above because we
        // know that the xbuffer_start_scanline is always within
        // the range 0..xbuffer_height-1.
        // ASSERT that this assumption is true.

        ASSERT(kmod < xbuffer_height);
        ASSERT(kmod >= 0);

        // Compute the kernel response for this pixel based on the
        // positive value of kp


        if(kb+k>ke)
        {
            // The buffer could be larger than the actual kernel,
            // in that case, simply set the extra coefficients to 
            // zero.
            
            ycoeff[kmod] = 0;
        }
        else
        {
            ComputeKernel(ycoeff[kmod], ya, pa, pa_old, krn);
        }

        // Compute the position in the destination buffer to draw to.

        dst = xbuffer + xbuffer_width * kmod;

        // This assert fires if the arithmetic for computing the size of the
        // xbuffer or the iteration over the kernel support has a bug. The
        // xbuffer_height should be the maximum width of the kernel support.

        ASSERT(k < xbuffer_height);
        ASSERT(kmod < xbuffer_height);

        INT k_wrap = kb+k;

        // NTRAID#NTBUG9-370168-2001/04/18-asecchia
        // This is an unsigned/signed comparison.
        // NOTE: the (INT) cast is the invalid one. BmpData.Height is UINT
        // and is always positive - casting it to int is irrelevant.
        // However, the k_wrap is signed and _can_ be negative. The unsigned
        // cast is by design - it allows us to figure out both sides of the 
        // wrap using one comparison.
        // The unsigned comparison >= Height tells us if k_wrap does not fall 
        // within the range 0..Height-1 and therefore needs wrapping because 
        // negative numbers cast to huge positive numbers and succeed the 
        // comparison too.
        // NOTE also that this kind of comparison limits the effective range
        // of Height to (max unsigned)/2 with the single caveat of k_wrap being
        // equal to -MAXINT.
        // For code that's executed once per scanline, this kind of subtlety
        // is probably not warranted.

        if((UINT)(k_wrap) >= (INT)BmpData.Height)
        {
            // Handle the wrap mode here.

            if(WrapZeroClamp)
            {
                // GpMemset(dst, 0, (right-left)*sizeof(ARGB));

                // If we're filling with zero, we may as well optimize the kernel
                // contribution.

                ycoeff[kmod] = 0;

                // done this scan - go on to the next

                continue;
            }
            else
            {
                if(QWrapMode == WrapModeClamp)
                {
                    INT i = right-left;
                    ARGB *d = dst;
                    while(i--)
                    {
                        *d++ = ClampColor;
                    }

                    // done this scan - go on to the next

                    continue;
                }
                else
                {
                    // Apply the general wrap code.

                    Apply1DWrapModeY(QWrapMode, k_wrap, (INT)BmpData.Height);
                    src = srcPtr0 + stride*k_wrap;

                    // Not done yet - fall through and call StretchScanline.
                }
            }
        }
        else
        {
            // If the x2 and x1 are out of order, we failed to correctly
            // compute the span in the above logic.

            // Seek to the start of the scanline.
            // Note: whatever X coordinate we add to the src pointer
            // we need to subtract from the width passed to the
            // StretchScanline routine below.

            src = srcPtr0 + stride*(k_wrap);
        }

        // Only x-scale if we haven't already done this scanline on a previous
        // call and stored the result in the xbuffer.

        if((last_k==LAST_K_UNUSED) || (
               (yscale >= 0) && (last_k-(kb+k) < 0) ||
               (yscale < 0) && (last_k-(kb+k) > 0)
            )
           )
        {

            // Filter in the x-dimension.

            StretchScanline(
                dst,
                src,
                xbuffer_width,
                static_cast<INT>(BmpData.Width),
                xkci,
                xscale,
                xw,
                xa
            );
        }
    }

    // set up the k_last for the next iteration. This represents the last
    // scanline for which we actually have x-scaled data.

    if(yscale < 0)
    {
        last_k = kb;
    }
    else
    {
        last_k = kb + xbuffer_height - 1;
    }

    
    // Get the final destination buffer

    ARGB *buffer = Scan->NextBuffer(left, y, width);

    // Now we have the entire buffer full with the x-dimension scaled data.

    // for every x coordinate, apply the y kernel.
    
#ifdef _X86_
    if (OSInfo::HasMMX)
    {
        // MMX
    
        INT *ycoeffMMX = (INT *) ((((UINT_PTR) ycoeff) + 4) & ~0x7);
        INT n = (xbuffer_height + 1) >> 1;

        // Transform the kernel coeffecient array into a form that is
        // easily usable by MMX code.  The loop must go backward so that
        // we don't erase kernel coefficients (MMX starting point could
        // be 4 bytes ahead of integer starting point).
        // ycoeff must be large enough to hold the MMX coefficients (2 extra
        // entries)

        for (INT i = n-1; i >= 0; i--)
        {
            INT kernel1   = ycoeff[i * 2]     >> 2;
            INT kernel2   = ycoeff[i * 2 + 1] >> 2;
            INT kernelMMX = (kernel1 & 0xFFFF) | (kernel2 << 16); 

            ycoeffMMX[i * 2]     = kernelMMX;
            ycoeffMMX[i * 2 + 1] = kernelMMX;
        }

        for(x=0; x<width; x++)
        {
            // iterate over every point under the kernel

            // Note we don't need the kmod arithmetic here because
            // we've precomputed the coefficients and we don't care what order
            // we sum them.

            BYTE *kptr = (BYTE*)(xbuffer + x + (left - ixleft));

            // Compute the increment in bytes to move from the current scanline
            // to the next in the xbuffer.

            INT kptr_inc_MMX = xbuffer_width*sizeof(ARGB);

            INT bos_count      = xbuffer_height;
            INT bos_half_count = bos_count >> 1;
            bos_count &= 0x1;

            _asm
            {
                    // eax - kptr
                    // ebx - kptr_inc
                    // ecx - counter
                    // esi - ycoeff current pointer

                    pxor       mm0, mm0
                    movq       mm6, FIX14_HALF_MMX
                    movq       mm7, mm6
                    mov        eax, kptr
                    mov        ebx, kptr_inc_MMX
                    mov        ecx, bos_half_count
                    mov        esi, ycoeffMMX

                    dec        ecx
                    jl         bicubic_output_span_loop_last_pixel

                bicubic_output_span_loop:

                    movd       mm2, [eax]  // mm2 = 00000000a1r1b1g1
                    movd       mm4, [eax + ebx]

                    punpcklbw  mm2, mm0    // mm2 = 00a100r100g100b1
                    movq       mm1, [esi]  // mm1 = kernel2 | kernel1 | kernel2 | kernel1

                    punpcklbw  mm4, mm0    // mm4 = 00a200r200g200b2
                    movq       mm3, mm2    // mm3 = 00a100r100g100b1

                    punpcklwd  mm2, mm4    // mm2 = 00g200g100b200b1
                    add        esi, 8
                    pmaddwd    mm2, mm1
                    punpckhwd  mm3, mm4    // mm3 = 00a200a100r200r1
                    paddd      mm6, mm2
                    dec        ecx
                    pmaddwd    mm3, mm1
                    lea        eax, [eax + 2 * ebx] // does not affect flags      
                    paddd      mm7, mm3

                    jge        bicubic_output_span_loop

                bicubic_output_span_loop_last_pixel:

                    dec        bos_count
                    jl         bicubic_output_span_loop_done

                    movd       mm2, [eax]  // mm2 = 00000000aarrggbb
                    punpcklbw  mm2, mm0    // mm2 = 00aa00rr00gg00bb
                    movq       mm3, mm2
                    punpcklwd  mm2, mm0    // mm2 = 000000gg000000bb
                    movq       mm1, [esi]  // mm1 = xxxx | kernel1 | xxxx |kernel1
                    punpckhwd  mm3, mm0    // mm3 = 000000aa000000bb

                    pmaddwd    mm2, mm1
                    pmaddwd    mm3, mm1

                    paddd      mm6, mm2
                    paddd      mm7, mm3

                bicubic_output_span_loop_done:

                    // At this point, mm6 and mm7 contain the output channels
                    // for the pixel.  We need to clamp the alpha and store it
                    // in the destination buffer.

                    psrad        mm6, 14
                    psrad        mm7, 14
                    packssdw     mm6, mm7 // mm6 = a | r | g | b
                    packuswb     mm6, mm6 // mm6 = 00000000aarrggbb

                    movq         mm7, mm6 // mm7 = 00000000aarrggbb
                    psrad        mm6, 24  // mm6 = xxxxxxxxxxxxxxaa
                      mov          eax, 0xFFFFFFFF
                    punpcklbw    mm6, mm6 // mm6 = xxxxxxxxxxxxaaaa
                      movd         mm2, eax
                    punpcklbw    mm6, mm6 // mm6 = xxxxxxxxaaaaaaaa

                    psubusb      mm2, mm6
                      mov          eax, buffer
                    paddusb      mm7, mm2
                    psubusb      mm7, mm2

                    movd         [eax], mm7
                    add          eax, 4
                    mov          buffer, eax
            }
        }
    }
    else
#endif // _X86_
    {
        // No MMX

        for(x=0; x<width; x++)
        {
            // Initialize the component accumulators. We accumulate the
            // contribution of each color component scaled by the kernel
            // response into these variables.

            ta = tr = tg = tb = 0;

            // iterate over every point under the kernel

            // Note we don't need the kmod arithmetic here because
            // we've precomputed the coefficients and we don't care what order
            // we sum them.

            BYTE *kptr = (BYTE*)(xbuffer + x + (left - ixleft));

            // Compute the increment in bytes to move from the current scanline
            // to the next in the xbuffer after incrementing through 3 of the
            // color channels.

            INT kptr_inc = xbuffer_width*sizeof(ARGB);
            
            for(k=0; k<xbuffer_height; k++)
            {
                // Find the pixel contributing to this part of the kernel
                // taking into account the edge conditions.

                // lookup the kernel coefficient for this scanline.

                pc = ycoeff[k];

                // Accumulate the contribution of this source pixel to the pixel
                // we're working on.

                AccumulateChannels(pc, kptr);

                kptr += kptr_inc;
            }

            // Done with this pixel - store it in the destination buffer.

            // clamp the results to byte range.

            ClampColors();

            // Combine the channels, set the destination pixel and increment
            // to the next pixel

            *buffer++ = (ta << 24) | (tr << 16) | (tg << 8) | tb;
        }
    }

#ifdef _X86_
    if (OSInfo::HasMMX)
    {
        _asm
        {
            emms
        }
    }
#endif // _X86_


    return Ok;
}

#undef ClampColors
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\critsec.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   critsec.hpp
*
* Abstract:
*
*   Critical Section object for protecting LoadLibrary calls
*
* Revision History:
*
*   3/17/2000 asecchia
*       Created it.
*
\**************************************************************************/

#ifndef _CRITSEC_HPP
#define _CRITSEC_HPP

// !!! [agodfrey]: We should establish a ranking of critical sections and
// assert that it doesn't get inverted. 

// Here's a start: 
//
// GdiplusStartupCriticalSection
//     BackgroundThreadCriticalSection
//
// (e.g. to acquire both BackgroundThreadCriticalSection and 
//       GdiplusStartupCriticalSection, acquire GdiplusStartupCriticalSection
//       first, and release it last.)


// This is a CriticalSection Proxy designed to 
// automatically acquire the critical section 
// when the instance is created and release 
// it when it goes out of scope.

class LoadLibraryCriticalSection
{
public:

    static VOID InitializeCriticalSection()
    {
        __try
        {
            ::InitializeCriticalSection(&critSec);
        }
        __except(EXCEPTION_CONTINUE_SEARCH)
        {
        }
        // If we throw then initialized will be false;
        // It's the caller's responsability to ensure that the throw is caught
        initialized = TRUE;
    }

    static VOID DeleteCriticalSection()
    {
        if (initialized)
        {
            ::DeleteCriticalSection(&critSec);
            initialized = FALSE;
        }
    }

    LoadLibraryCriticalSection()
    {
        ASSERT(initialized);
        EnterCriticalSection(&critSec);
    }

    ~LoadLibraryCriticalSection()
    {
        ASSERT(initialized);
        LeaveCriticalSection(&critSec);
    }

private:
    static CRITICAL_SECTION critSec;
    static BOOL initialized;
};

// This is a CriticalSection Proxy used for GdiplusStartup and GdiplusShutdown.

class GdiplusStartupCriticalSection
{
public:

    static VOID InitializeCriticalSection()
    {
        __try
        {
            ::InitializeCriticalSection(&critSec);
        }
        __except(EXCEPTION_CONTINUE_SEARCH)
        {
        }

        // If we throw then initialized will be false;
        // It's the caller's responsability to ensure that the throw is caught
        initialized = TRUE;
    }

    static VOID DeleteCriticalSection()
    {
        if (initialized)
        {
            ::DeleteCriticalSection(&critSec);
            initialized = FALSE;
        }
    }

    GdiplusStartupCriticalSection()
    {
        ASSERT(initialized);
        EnterCriticalSection(&critSec);
    }

    ~GdiplusStartupCriticalSection()
    {
        ASSERT(initialized);
        LeaveCriticalSection(&critSec);
    }

private:
    static CRITICAL_SECTION critSec;
    static BOOL initialized;
};

// [agodfrey] This is a CriticalSection Proxy used for globals touched
// by the background thread. We can't use GdiplusStartupCriticalSection for
// these, because (at least as things are now) the background thread can't 
// acquire GdiplusStartupCriticalSection.
//
// If it did, we could deadlock when we wait for the background thread to
// finish.

class BackgroundThreadCriticalSection
{
public:

    static VOID InitializeCriticalSection()
    {
        __try
        {
            ::InitializeCriticalSection(&critSec);
        }
        __except(EXCEPTION_CONTINUE_SEARCH)
        {
        }

        // If we throw then initialized will be false;
        // It's the caller's responsability to ensure that the throw is caught
        initialized = TRUE;
    }

    static VOID DeleteCriticalSection()
    {
        if (initialized)
        {
            ::DeleteCriticalSection(&critSec);
            initialized = FALSE;
        }
    }
    
    BackgroundThreadCriticalSection()
    {
        ASSERT(initialized);
        EnterCriticalSection(&critSec);
    }

    ~BackgroundThreadCriticalSection()
    {
        ASSERT(initialized);
        LeaveCriticalSection(&critSec);
    }

private:
    static CRITICAL_SECTION critSec;
    static BOOL initialized;
};

// This is a CriticalSection Proxy designed to 
// automatically acquire the critical section 
// when the instance is created and release 
// it when it goes out of scope.

// NB: this critical section should only be used for the malloc tracking
// code. If you use it for anything else, then you should probably make sure you
// don't allocate or free memory under this critsec.

class GpMallocTrackingCriticalSection
{
public:

    static VOID InitializeCriticalSection()
    {
        // Only call InitializeCriticalSection if this is the first
        // time we're calling this code.

        // Note: this refCount thing is not actually thread safe, but
        // we only call this from our dllinit function so we should be
        // ok.

        // The refcount can tell us if the critical section is initialized

        if(refCount==0)
        {
            __try
            {
                ::InitializeCriticalSection(&critSec);
            }
            __except(EXCEPTION_CONTINUE_SEARCH)
            {
            }
        }

        refCount++;
    }

    static VOID DeleteCriticalSection()
    {
        // Decrement the refCount. If it hits zero, 
        // delete the critical section.

        refCount--;

        // If the refCount is ever negative that means we're being called
        // to delete the critical section without ever having initialized it.

        #if DBG
        if(refCount<0)
        {
            // !!! [asecchia] don't know if deleting an uninitialized critical
            // section is bad or not. This could happen if we failed 
            // initialization somewhere and we're trying to clean up
            // afterward.

            WARNING(("Trying to delete the GpMallocTrackingCriticalSection without initializing it first"));
        }
        #endif

        if(refCount==0)
        {
            ::DeleteCriticalSection(&critSec);
        }
    }

    GpMallocTrackingCriticalSection()
    {
        // Entering the critical section without first having called
        // InitializeCriticalSection will cause a crash.
        
        ASSERT(refCount>0);
        
        EnterCriticalSection(&critSec);
    }

    ~GpMallocTrackingCriticalSection()
    {
        // Leaving the critical section without first having called 
        // InitializeCriticalSection will cause a crash.
        
        ASSERT(refCount>0);

        LeaveCriticalSection(&critSec);
    }

private:
    static CRITICAL_SECTION critSec;

    // This critical section is initialized in imaging.dll and gdiplus.dll.
    // The gdiplus initialization code initializes the imaging module. 
    // To avoid initializing and deleting this critical section more 
    // than once, we refcount it.

    // !!! [agodfrey]: Now that we've eliminated imaging.dll, I don't think
    //     we need this refcount.
    
    static INT refCount;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\render\vgahash.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   VGA color hash table
*
* Abstract:
*
*   This module maintains a hash table which holds the 20 VGA colors
*   (this includes the 4 which can be modified.)
*   The 8bpp halftone code, for example, needs to detect these colors
*   so that it doesn't halftone them.
*
* Created:
*
*   04/06/2000 agodfrey
*      Created it.
*
**************************************************************************/

#ifndef _VGAHASH_HPP
#define _VGAHASH_HPP

#define VGA_HASH_BITS 7
#define VGA_HASH_SIZE (1 << VGA_HASH_BITS)

extern ARGB VgaColorHash[VGA_HASH_SIZE];

VOID VGAHashRebuildTable(COLORREF *magicColors);

/**************************************************************************
*
* Function Description:
*
*   Hashes an RGB color
*
* Arguments:
*
*   r, g, b - the red, green and blue components of the color
*
* Return Value:
*
*   The hash table value
*
* Created:
*
*   04/06/2000 agodfrey
*      Created it.
*
**************************************************************************/

__forceinline UINT
VGAHashColor(
    UINT r, 
    UINT g, 
    UINT b
    )
{
    UINT hashKey = (r >> 1) ^ (g >> 3) ^ (b >> 5);
    
    ASSERT(hashKey < VGA_HASH_SIZE);
    return hashKey;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\lockable.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   Locking
*
* Abstract:
*
*   Lockable: A base class for lockable objects, which contains a lock.
*   Lock: Represents a held lock on an object (acquires and releases an
*         object's lock in its constructor and destructor).
*
* Revision History:
*
*   02/22/1999 davidx
*       Created it.
*   09/08/1999 agodfrey
*       Moved to Runtime\Lockable.hpp
*
\**************************************************************************/

#ifndef _LOCKABLE_HPP
#define _LOCKABLE_HPP

namespace GpRuntime 
{

//
// TODO: Remove the 'Gp' prefix from GpLockable and GpLock
//           
           
//--------------------------------------------------------------------------
// Base class for lockable API objects
//--------------------------------------------------------------------------

class GpLockable
{
    friend class GpLock;

public:

    GpLockable()
    {
        LockCount = -1;
    }

    ~GpLockable()
    {
        // Comment out to prevent Office crash.  3/14/00 -- ikkof
//        ASSERTMSG(LockCount == -1, ("~GpLock: non-zero lock count"));
    }

    LONG* GetLockCount()
    {
        return &LockCount;
    }

    BOOL IsLocked() const
    {
        return (LockCount != -1);
    }

    VOID Reset()
    {
        LockCount = -1;
    }
    
    // Copy constructor and assignment operator

    GpLockable(GpLockable & lockable)
    {
        LockCount = -1;
    }

    GpLockable &operator=(const GpLockable & lockable)
    {
        return *this;
    }

protected:

    LONG LockCount;             // number of locks, minus one
};

//--------------------------------------------------------------------------
// Class for locking API objects
// NOTE: These locks are not reentrant!
//--------------------------------------------------------------------------

class GpLock
{
public:

    GpLock(GpLockable* lockable)
    {
        // In flatapi, we sometimes need to check if an optional (NULL)
        // parameter is busy, which means we would pass NULL into this
        // constructor.  An optional parameter should not be considered locked. 
        if (lockable != NULL)
        {
            LockCount = &lockable->LockCount;

            // Note that it generates less code when we store the result
            // here than it is to convert to a BOOL here and store that.

            Result = InterlockedIncrement(LockCount);
        }
        else
        {
            Result = 0;
            LockCount = &Result;
        }
    }

    ~GpLock()
    {
        InterlockedDecrement(LockCount);
    }

    BOOL IsValid()  const
    {
        return (Result == 0);
    }

    BOOL LockFailed() const
    {
        return (Result != 0);
    }

    VOID MakePermanentLock()
    {
        // This is useful when deleting an object.  First, lock it, then 
        // leave it in a locked state.  Technically the memory will be released
        // and available for reuse, but the ObjectLock will still be left in
        // a locked state.

        LockCount = &Result;
    }

private:

    LONG Result;
    LONG *LockCount;
};

}

#endif // !_LOCKABLE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\mem.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   GDI+ memory allocation functions
*
* Abstract:
*
*   This module provides GpMalloc, GpRealloc and GpFree.
*
* Notes:
*
*   Office provides their own versions of these functions.
*
* Created:
*
*   07/08/1999 agodfrey
*
\**************************************************************************/

#include "precomp.hpp"

namespace GpRuntime
{
HANDLE GpMemHeap = NULL;
};

#if GPMEM_ALLOC_CHK

#if GPMEM_FAULT_INJECTION
#include <time.h>
#include <stdlib.h>
#endif

// Get the definition of Globals::CaptureStackBackTraceFunction

#include "..\common\common.hpp"

                  
// Size of the start and end memory guards (DWORDS)
// Probably should be QWORD aligned (even number).

const unsigned int GPMEM_GUARD_START = 0x10;
const unsigned int GPMEM_GUARD_END   = 0x10;
const unsigned int GPMEM_GS = GPMEM_GUARD_START*sizeof(DWORD);
const unsigned int GPMEM_GE = GPMEM_GUARD_END*sizeof(DWORD);

const unsigned char GPMEM_FILL_ALLOC = 0xbf;
const unsigned char GPMEM_FILL_GS    = 0xac;
const unsigned char GPMEM_FILL_GE    = 0xfe;
const unsigned char GPMEM_FILL_FREE  = 0x73;

#define GPMEM_ALLOC_TRACKING 1
#define GPMEM_ALLOC_FILL     1

enum AllocTrackHeaderFlags
{
    MemoryAllocated     = 0x00000001,
    MemoryFreed         = 0x00000002,     // useful in catching double frees
    APIAllocation       = 0x00000004
};
// Head of every tracked allocation.


// From <ntrtl.h> - 
// #define MAX_STACK_DEPTH 32                  
// Therefore we define our stack trace size to be 32 entries.
// Number of Stack Frames stash away on every allocation.

// Bear in mind that every allocation will have 4xGPMEM_STACKSIZE bytes 
// additional overhead. (8xGPMEM_STACKSIZE on ptr64 machines)

#define GPMEM_STACKSIZE 32


struct AllocTrackHeader {
  struct  AllocTrackHeader *flink;
  struct  AllocTrackHeader *blink;
  DWORD   size;
  PVOID   caller_address[GPMEM_STACKSIZE];
  DWORD   flags;
#if GPMEM_ALLOC_CHK_LIST
  char    *callerFileName;
  INT     callerLineNumber;
#endif
  DWORD   tag;
  DWORD   padding;       // padding to keep 8 byte alignment
};

#define GPMEM_OVERHEAD (GPMEM_GS + GPMEM_GE + sizeof(AllocTrackHeader))

// Head of double linked list of tracked memory allocations.

AllocTrackHeader *gpmemAllocList=NULL;

// An allocation fails if rand() < gpmemDefFailRate (gpmemInitFailRate for
// gdiplus initialization code.
// set to RAND_MAX/2 if you want 50% failure rate, 0 if you want no failures.
//
// The system starts off failing allocations at a rate specified by
// gpmemInitFailRate. Once GpDoneInitializeAllocFailureMode() is called,
// allocations are failed at the rate specified by gpmemDefFailRate().
// This is so that dll initialization code can have a different fail rate
// to regular code.

int gpmemInitFailRate = 0;
int gpmemDefFailRate = 0;

// This would give a failure rate of 25%
// int gpmemDefFailRate = (RAND_MAX/4)

BOOL gpmemDoneInitialization = FALSE;

// Some statistics
struct AllocTrackStats {
  // Totals over the entire run

  long CumulativeAllocations;   // The number of calls to GpMalloc or GpRealloc
  long CumulativeMemorySize;    // Cumulative total of allocated memory
  long CumulativeReallocs;      // The number of calls to GpRealloc
  long ForcedFailures;
  long AllocationFailures;

  // Current values

  long OutstandingAllocations;  // The number of allocation requests
  long OutstandingMemorySize;   // The amount of memory currently allocated

  // Maxima of the 'Outstanding' values

  long MaxAllocations;          // The maximum of OutstandingAllocations
  long MaxMemorySize;           // The maximum of OutstandingMemorySize

  void Allocated(long size)
  {
      size -= GPMEM_OVERHEAD;

      CumulativeMemorySize += size;
      OutstandingMemorySize += size;
      if (OutstandingMemorySize > MaxMemorySize)
      {
          MaxMemorySize = OutstandingMemorySize;
      }
      CumulativeAllocations++;
      OutstandingAllocations++;
      if (OutstandingAllocations > MaxAllocations)
      {
          MaxAllocations = OutstandingAllocations;
      }
  }

  void Freed(long size)
  {
      size -= GPMEM_OVERHEAD;

      OutstandingMemorySize -= size;
      OutstandingAllocations--;
  }
};

AllocTrackStats gpmemAllocTotal = {0};


// Hash Table for tracking memory allocations sorted by callsite.
// This table stores some total memory usage statistics for each
// callsite.
// Turn this on by setting GPMEM_DEBUG_SORT 1

#define GPMEM_DEBUG_SORT 0
#if GPMEM_DEBUG_SORT

struct HashMem {
  long callsite;
  long size;
  long count;
};

// It is very important that this hash size be larger than the number of
// possible callsites for GpMalloc.
//
// Set HASHSIZE to some big prime number.

#define HASHSIZE 1069
HashMem HashTable[HASHSIZE];

// Hashing algorithm.
long Hash(long cs) {
  long tmp = cs % HASHSIZE;
  long tmploop = tmp;
  while( (HashTable[tmp].callsite != 0) &&
         (HashTable[tmp].callsite != cs) ) {
    tmp++;
    if(tmp>=HASHSIZE) tmp=0;
    if(tmp==tmploop) return -1;
  }
  return tmp;
}
#endif

#endif



/**************************************************************************\
*
* Function Description:
*
*   Do we fail this memory allocation?
*
* Arguments: [NONE]
* Return Value: [NONE]
*
* History:
*
*   09/20/1999 asecchia
*       Created it.
*
\**************************************************************************/


#if GPMEM_ALLOC_CHK
BOOL GpFailMemoryAllocation() {
  #if GPMEM_FAULT_INJECTION
  int rndnum = rand();
  if(gpmemDoneInitialization)
  {
      if(rndnum<gpmemDefFailRate)
      {
          return TRUE;
      }
  }
  else
  {
    if(rndnum<gpmemInitFailRate)
    {
        return TRUE;
    }
  }
  #endif
  return FALSE;
}
#endif

/**************************************************************************\
*
* Function Description:
*
*   Initializes the random seed.
*
* Arguments: [NONE]
* Return Value: [NONE]
*
* History:
*
*   09/20/1999 asecchia
*       Created it.
*
\**************************************************************************/

void GpInitializeAllocFailures() {
  #if GPMEM_ALLOC_CHK
  #if GPMEM_FAULT_INJECTION
  srand((unsigned)time(NULL));
  #endif
  #endif
}


/**************************************************************************\
*
* Function Description:
*
*   Sets the flag indicating that we're done initialization code and
*   we're now into regular code. The memory failure mode changes based
*   on the value of this flag.
*
* Arguments: [NONE]
* Return Value: [NONE]
*
* History:
*
*   09/20/1999 asecchia
*       Created it.
*
\**************************************************************************/

void GpDoneInitializeAllocFailureMode() {
  #if GPMEM_ALLOC_CHK
  gpmemDoneInitialization=TRUE;
  #endif
}

void GpStartInitializeAllocFailureMode() {
  #if GPMEM_ALLOC_CHK
  gpmemDoneInitialization=FALSE;
  #endif
}


#if GPMEM_ALLOC_CHK_LIST
char *skipGdiPlus(char *s) {
    // Quick hack to return pointer just beyond 'gdiplus'

    INT i = 0;
    while (    s[i] != 0
           &&  (    s[i] != 'g' &&  s[i] != 'G'
                ||  CompareStringA(
                        LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                        s+i, 7,
                        "gdiplus", 7) != CSTR_EQUAL))
    {
        i++;
    }
    if (    CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, s+i, 7, "gdiplus", 7) == CSTR_EQUAL
        &&  s[i+7] != 0)
    {
        return s + i + 8;   // Skip over 'gdiplus/'
    }
    else
    {
        return s; // Didn't find gdiplus so return the whole string
    }
}
#endif

/**************************************************************************\
*
* Function Description:
*
*   Asserts that there are no memory leaks. Called just before process
*   termination, the list of allocated memory blocks should be NULL indicating
*   that all allocated memory was properly disposed. Any memory that relies on
*   process termination to clean up is leaked and provision should be made
*   for appropriate cleanup.
*
* Notes:
*
*   Designed only to be called during shutdown, because it doesn't acquire
*   GpMallocTrackingCriticalSection. 
*
*   This is because, during shutdown, the critsec has not necessarily been
*   initialized. It's safe during shutdown because shutdown itself is
*   expected to be single-threaded.
*
* Todo after we ship:
*
*   NTRAID#NTBUG9-411495-2001/06/06-agodfrey
*   The refcount is legacy anyway, and the "single-threaded shutdown" thing
*   may need to be changed. We should initialize all our global critsecs
*   in DllMain, so that we can rely on them during startup/shutdown.
*
*   Once we've done that, this function can have the "shutdown only"
*   restriction removed - by making it once again acquire 
*   GpMallocTrackingCriticalSection.
*
* Arguments: [NONE]
* Return Value: [NONE]
*
* History:
*
*   09/19/1999 asecchia
*       Created it.
*
\**************************************************************************/

void GpAssertShutdownNoMemoryLeaks()
{
  #if GPMEM_ALLOC_CHK


  #if GPMEM_ALLOC_CHK_LIST

  // Report up to 100 leaked headers

  if (gpmemAllocList)
  {
      INT i=0; INT j=0;
      AllocTrackHeader *header = gpmemAllocList;
      while (header  && j < 100)
      {
          if (i % 20 == 0)  // Title every so often
          {
              WARNING(("Address- --Size-- API TAG  -Caller- -Line- File"));
          }

          // Drop everything up to 'gdiplus' off the filename string

          char  str[200];
          char *tagStr;

          tagStr = (char *) &header->tag;

          lstrcpynA(str, skipGdiPlus(header->callerFileName), 200);

          WARNING((
              "%p %8d %-3.3s %c%c%c%c %p %6d %s",
              header,
              header->size,
              header->flags & APIAllocation ? "API" : "",
              tagStr[3], tagStr[2], tagStr[1], tagStr[0],
              header->caller_address,
              header->callerLineNumber,
              str
          ));
          header = header->flink;

          i++; j++;
      }
  }
  #endif


  ASSERTMSG(
      gpmemAllocList==NULL,
      ("Memory leaks detected.\n"
       "List header (gdiplus!gpmemAllocList) at %p\n"
       "Use: dt AllocTrackHeader [address] to display the memory block headers.\n"
       "Use: dds [AllocTrackHeader.caller_address] to display the allocation stack.",
      gpmemAllocList)
  );


  // Display the report stored in the Hash Table
  #if GPMEM_DEBUG_SORT
  for(int i=0; i<HASHSIZE; i++) {
    if(HashTable[i].callsite != 0) {
      WARNING(("%4d callsite %p size %8d count %8d", i, HashTable[i].callsite,
               HashTable[i].size, HashTable[i].count));
    }
  }
  #endif

  #endif
}

#if GPMEM_ALLOC_CHK_LIST
void
GpTagMalloc(void * mem, GpTag tag, int bApi)
{
    if(mem)
    {
        AllocTrackHeader *hdr = (AllocTrackHeader *)((char *) mem - sizeof(AllocTrackHeader) - GPMEM_GS);
        hdr->tag = (unsigned long) tag;
        if(bApi) hdr->flags |= APIAllocation;
    }
}
#endif

/**************************************************************************\
*
* Function Description:
*
*   Allocates a block of memory.
*
* Arguments:
*
*   [IN] size - number of bytes to allocate
*
* Return Value:
*
*   A pointer to the new block, or NULL on failure.
*
* History:
*
*   09/14/1999 asecchia
*       Added the checked build memory guard code.
*   07/08/1999 agodfrey
*       Created it.
*
\**************************************************************************/

/*
Here's the structure of the memory block allocated under GPMEM_ALLOC_CHK

|+AllocTrackHeader Two DWORDS - contains
|  |+flink
|  |  Pointer to the next memory allocation in the tracked allocation list
|  |+blink
|  |  Pointer to the previous memory allocation in the tracked allocation link
|
|+Guard Area
|  GPMEM_GUARD_START DWORDs filled with the gpmemGuardFill string.
|
|+Data Area
|  This is the location we return to the caller. It is pre-initialized to
|  the repeated DWORD value in gpmemAllocFillBlock (usually 0xbaadf00d)
|
|+Guard Area:
|  GPMEM_GUARD_END DWORDs filled with gpmemGuardFill string.

*/
#if GPMEM_ALLOC_CHK_LIST
extern "C" void *GpMallocDebug(size_t size, char *fileName, INT lineNumber)
#else
extern "C" void *GpMalloc(size_t size)
#endif
{

    #if GPMEM_ALLOC_CHK
        // If we're playing with the tracking headers, we need to be thread safe.
        GpMallocTrackingCriticalSection critsecobj;

        //
        // Memory? _Real_ programmers don't need memory!
        //
        if(GpFailMemoryAllocation()) {
            gpmemAllocTotal.AllocationFailures++;
            gpmemAllocTotal.ForcedFailures++;
            return NULL;
        }

        //
        // Make the allocation request a multiple of a QWORD
        //
        if(size & (sizeof(DWORD)*2-1))
        {
          size = (size & ~(sizeof(DWORD)*2-1)) + sizeof(DWORD)*2;
        }

        size_t origsize = size;

        //
        // Allocate space for the FLink and BLink
        //
        size += sizeof(AllocTrackHeader);

        if(GPMEM_GUARD_START)
        {
          size += GPMEM_GS;
        }

        if(GPMEM_GUARD_END)
        {
          size += GPMEM_GE;
        }

        void *tmpalloc = HeapAlloc(GpMemHeap, GPMEMHEAPFLAGS, size);

        if(!tmpalloc)
        {
            gpmemAllocTotal.AllocationFailures++;
            return NULL;
        }

        ASSERTMSG(HeapSize(GpMemHeap, GPMEMHEAPFLAGS, tmpalloc) >= size,
                  ("GpMalloc() allocated %d, but requested %d bytes",
                   HeapSize(GpMemHeap, GPMEMHEAPFLAGS, tmpalloc), size));

        // Add the per-callsite allocation statistics
        #if GPMEM_DEBUG_SORT
        long hidx = Hash(calleraddr);
        if(hidx>=0) {
            HashTable[hidx].callsite = calleraddr;
            HashTable[hidx].size += size-GPMEM_OVERHEAD;
            HashTable[hidx].count ++;
        } else {
          WARNING(("Hash Table too small - increase HASHSIZE"));
        }
        #endif

        gpmemAllocTotal.Allocated(size);
    #else
        //
        // This is the only piece of code that's executed if
        // GPMEM_ALLOC_CHK is turned off.
        //
        
        #if PROFILE_MEMORY_USAGE
        MC_LogAllocation(size);
        #endif
        
        return HeapAlloc(GpMemHeap, GPMEMHEAPFLAGS, size);
        
    #endif


    #if GPMEM_ALLOC_CHK
        //
        // Fill up the entire allocation with the value
        // set in GPMEM_FILL_ALLOC
        //
        if(GPMEM_ALLOC_FILL)
        {
            GpMemset((unsigned char *)tmpalloc + sizeof(AllocTrackHeader) + GPMEM_GS,
                     GPMEM_FILL_ALLOC,
                     origsize);
        }

        //
        // Fill up the start guard area - if we have one.
        //
        if(GPMEM_GUARD_START)
        {
            unsigned char *p = (unsigned char *)tmpalloc+sizeof(AllocTrackHeader);
            GpMemset(p, GPMEM_FILL_GS, GPMEM_GS);
        }

        //
        // Fill up the end guard area - if we have one.
        //
        if(GPMEM_GUARD_END)
        {
            unsigned char *p = (unsigned char *)tmpalloc+size-GPMEM_GE;
            GpMemset(p, GPMEM_FILL_GE, GPMEM_GE);
        }

        //
        // setup the double linked-list to track all pool allocations.
        //
        AllocTrackHeader *hdr = (AllocTrackHeader *)tmpalloc;
        hdr->size = size;
        

        // zero out any unused frame pointers.
        
        GpMemset(hdr->caller_address, 0, sizeof(ULONG_PTR)*GPMEM_STACKSIZE);        
        
        // Lets stash away the entire stack trace if we have a 
        // backtrace function.
        
        if(Globals::CaptureStackBackTraceFunction)
        {
            ULONG hash;                         // dummy hash 
            
            USHORT frames = Globals::CaptureStackBackTraceFunction(
                0,                              // don't skip any frames
                GPMEM_STACKSIZE,                // get this many frames
                (PVOID*)(hdr->caller_address),  // ... into here.
                &hash                          
            );
        }
        
        hdr->flags = MemoryAllocated;
        hdr->tag = 'unkn';

        #if GPMEM_ALLOC_CHK_LIST
        hdr->callerFileName = fileName;
        hdr->callerLineNumber = lineNumber;
        #endif

        if(GPMEM_ALLOC_TRACKING)
        {
            hdr->blink = NULL;
            hdr->flink = gpmemAllocList;
            if(gpmemAllocList)
            {
                gpmemAllocList->blink = (AllocTrackHeader *)tmpalloc;
            }
            gpmemAllocList = (AllocTrackHeader *)tmpalloc;
        }
        else
        {
            GpMemset(hdr, 0, sizeof(AllocTrackHeader));
        }

        //
        // Give them a pointer just after the guard bits.
        //
        return (char *)tmpalloc+sizeof(AllocTrackHeader)+GPMEM_GS;
    #endif
}

/**************************************************************************\
*
* Function Description:
*    Allocates memory for APIs. Used to track the memory with a separate
*    identifying flag so that API allocations can be distinguished from
*    internal allocations.
*    Used on debug builds.
*
* Arguments:
*    [IN] size - size to pass to GpMalloc
*
* Return Value:
*    Returns the memory with the appropriately hacked up caller address
*
* History:
*
*   4/30/2000 asecchia
*       Created it.
*
\**************************************************************************/

#if DBG

#if GPMEM_ALLOC_CHK

#if GPMEM_ALLOC_CHK_LIST
extern "C" void * __stdcall GpMallocAPIDebug(size_t size, char *fileName, INT lineNumber)
#else
extern "C" void *GpMallocAPI(size_t size)
#endif
{
    // If we're playing with the tracking headers, we need to be thread safe.
    GpMallocTrackingCriticalSection critsecobj;

    #if GPMEM_ALLOC_CHK_LIST
    void *p = GpMallocDebug(size, fileName, lineNumber);
    #else
    void *p = GpMalloc(size);
    #endif

    if(p)
    {
        AllocTrackHeader *hdr = (AllocTrackHeader *)(
            (unsigned char *)p-(GPMEM_GS+sizeof(AllocTrackHeader)));
        hdr->flags |= APIAllocation;
    }
    return p;
}

#else // !GPMEM_ALLOC_CHK

extern "C" void *GpMallocAPI(size_t size, unsigned int caddr)
{
    return GpMalloc(size);
}

#endif // !GPMEM_ALLOC_CHK
#endif // DBG

/**************************************************************************\
*
* Function Description:
*
*   Computes the original size of a memory block allocated under GPMEM_ALLOC_CHK
*
* Arguments:
*
*   [IN] p - current memory block
*
* Return Value:
*
*   size of the original request for a memory block (i.e. excluding guard
*   areas, headers, etc). The size returned is the DWORD aligned size - so it
*   may differ slighly from the original size requested.
*
* Notes:
*
*   Returns a size of zero if called with NULL
*   Only compiled under GPMEM_ALLOC_CHK
*
* History:
*
*   09/14/1999 asecchia
*       Created it.
*
\**************************************************************************/

#if GPMEM_ALLOC_CHK
extern "C" size_t GpSizeBlock(void *p)
{
  if(p)
  {
      // Find the beginning of the allocated block header.
      
      p = (char *)p-(GPMEM_GS+sizeof(AllocTrackHeader));
      
      ASSERT(
          HeapSize(GpMemHeap, GPMEMHEAPFLAGS, p) >= 
          ((AllocTrackHeader *)p)->size
      );
      
      // Compute the size of the allocated block's data area.
      
      return (((AllocTrackHeader *)p)->size -
              (GPMEM_GS+GPMEM_GE+sizeof(AllocTrackHeader)));
  }
  else
  {
      return 0;
  }
}
#else
// Non-debug build, just call HeapSize
#define GpSizeBlock(p) HeapSize(GpMemHeap, GPMEMHEAPFLAGS, p)
#endif


/**************************************************************************\
*
* Function Description:
*
*   Reallocates a memory block.
*
* Arguments:
*
*   [IN] memblock - current memory block
*   [IN] size - new allocation size
*
* Return Value:
*
*   A pointer to the new block, or NULL on failure.
*
* Notes:
*
*   If size is 0, frees the block.
*   If memblock is NULL, allocates a new block.
*   (If both, does nothing.)
*
*   LocalReAlloc only grows if it can expand the current allocation
*   - otherwise it fails.
*
* History:
*
*   09/14/1999 asecchia
*       Added the checked build memory guard code.
*   07/08/1999 agodfrey
*       Created it.
*
\**************************************************************************/

extern "C" void *GpRealloc(void *memblock, size_t size)
{
    #if GPMEM_ALLOC_CHK
    gpmemAllocTotal.CumulativeReallocs++;
    #endif

    // Free.
    
    if (!size)
    {
        if (memblock)
            GpFree(memblock);
        return NULL;
    }
    
    // Alloc.
    
    if (!memblock)
    {
        return GpMalloc(size);
    }

    // Realloc - Use GpMalloc/GpMemcpy/GpFree for debug so that the
    // extra buffers line up (would require duplicating the code
    // from the GpMalloc/GpFree functions otherwise
    
    #if GPMEM_ALLOC_CHK

    VOID *  p = GpMalloc(size);
    if (p != NULL)
    {
        size_t oldSize = GpSizeBlock(memblock);

        // Are we shrinking the block?
        
        if (oldSize > size)
        {
            oldSize = size;
        }
        
        GpMemcpy(p, memblock, oldSize);
        GpFree(memblock);
    }

    #else // !GPMEM_ALLOC_CHK

    #if PROFILE_MEMORY_USAGE
    MC_LogAllocation(size);
    #endif

    VOID *p = HeapReAlloc(GpMemHeap, GPMEMHEAPFLAGS, memblock, size);

    #endif // !GPMEM_ALLOC_CHK

    return p;
}

/**************************************************************************\
*
* Function Description:
*
*   Frees a block of memory.
*
* Arguments:
*
*   [IN] memblock - block to free
*
* Notes:
*
*   If memblock is NULL, does nothing.
*
* History:
*
*   09/14/1999 asecchia
*       Added the checked build memory guard code.
*   07/08/1999 agodfrey
*       Created it.
*
\**************************************************************************/

extern "C" void GpFree(void *memblock)
{
    // Do nothing if the pointer is NULL.
    
    if(memblock)
    {
        #if GPMEM_ALLOC_CHK
        // If we're playing with the tracking headers, we need to be thread safe.
        GpMallocTrackingCriticalSection critsecobj;

        memblock = (unsigned char *)memblock-(GPMEM_GS+sizeof(AllocTrackHeader));


        // Let's do the header stuff.

        AllocTrackHeader *hdr = (AllocTrackHeader *)memblock;
        DWORD size = hdr->size;
        gpmemAllocTotal.Freed(size);

        ASSERTMSG(
            (hdr->flags & MemoryAllocated) &&
            !(hdr->flags & MemoryFreed),
            ("GpFree() already freed memory %p (freed by GpFree())",
            memblock)
        );

        hdr->flags &= ~MemoryAllocated;
        hdr->flags |= MemoryFreed;

        ASSERTMSG(
            HeapSize(GpMemHeap, GPMEMHEAPFLAGS, memblock) >= hdr->size,
            (
                "GpFree() already freed memory %p (freed somewhere else?)"
                " local size=%d, size=%d",
                memblock,
                HeapSize(GpMemHeap, GPMEMHEAPFLAGS, memblock),
                hdr->size
            )
        );

        if(GPMEM_ALLOC_TRACKING)
        {
            // Useful on checked Win2k builds because they fill guard
            // area with 0xFEEEFEEE

            ASSERTMSG((hdr->flink == NULL) ||
                      ((DWORD)((ULONG_PTR)(hdr->flink->blink) & 0xFFFFFFFF) != 0xFEEEFEEE),
                      ("GpFree() updating forward link to freed page, header %p",
                       memblock));

            ASSERTMSG((hdr->blink == NULL) ||
                      ((DWORD)((ULONG_PTR)(hdr->blink->flink) & 0xFFFFFFFF) != 0xFEEEFEEE),
                      ("GpFree() updating backward link to freed page, header %p",
                       memblock));

            if(hdr->flink) hdr->flink->blink = hdr->blink;
            if(hdr->blink) hdr->blink->flink = hdr->flink;
            if(gpmemAllocList==memblock) gpmemAllocList = hdr->flink;
        }
        else
        {
            ASSERTMSG(hdr->flink==NULL, ("GpFree() corrupt header %p", memblock));
            ASSERTMSG(hdr->blink==NULL, ("GpFree() corrupt header %p", memblock));
        }

        int i;
        unsigned char *p;

        // Check the start guard area

        if(GPMEM_GUARD_START)
        {
            p = (unsigned char *)memblock+sizeof(AllocTrackHeader);
            for(i=0; i<GPMEM_GS; i++)
            {
                ASSERTMSG(*p==GPMEM_FILL_GS, ("GpFree() pre-guard area corrupt %p", memblock));
                p++;
            }
        }

        // Check the end guard area

        if(GPMEM_GUARD_END)
        {
            p = (unsigned char *)memblock+size-GPMEM_GE;
            for(i=0; i<GPMEM_GE; i++)
            {
                ASSERTMSG(*p==GPMEM_FILL_GE, ("GpFree() post-guard area corrupt %p", memblock));
                p++;
            }
        }

        // Now lets fill the entire block with something to prevent
        // use of free data.

        GpMemset(memblock, GPMEM_FILL_FREE, size);

        #endif
    
        // HeapFree may fail freeing a NULL pointer on Win98.

        BOOL ret = HeapFree(GpMemHeap, GPMEMHEAPFLAGS, memblock);

        ASSERTMSG(
            ret, (
                "HeapFree() failed at %p, GetLastError()=%08x",
                memblock,
                GetLastError()
            )
        );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\enums.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   GDI+ private enumsruntime
*
* Abstract:
*
*   Enums moved from sdkinc because we don't want them public.
*
* Revision History:
*
*   2/15/2k ericvan
*       Created it.
*
\**************************************************************************/

#include "..\..\sdkinc\gdiplusenums.h"

enum EnumerationType
{
    LinesAndBeziers = 0,
    Flattened       = 1,
    Widened         = 2
};

const UINT MAX_TEXT_CONTRAST_VALUE = 12;
const UINT DEFAULT_TEXT_CONTRAST = 4;


// UnitWorld and UnitDisplay are NOT valid as a srcUnit
inline BOOL
SrcUnitIsValid(
    Unit        unit
    )
{
    return ((unit >= UnitPixel) && (unit <= UnitMillimeter));
}

inline BOOL
MetafileFrameUnitIsValid(
    MetafileFrameUnit   frameUnit
    )
{
    return ((frameUnit >= MetafileFrameUnitPixel) && (frameUnit <= MetafileFrameUnitGdi));
}

inline BOOL
WrapModeIsValid(
    WrapMode    mode
    )
{
    return ((mode >= WrapModeTile) && (mode <= WrapModeClamp));
}

inline BOOL
CombineModeIsValid(
    CombineMode         combineMode
    )
{
    return ((combineMode >= CombineModeReplace) &&
            (combineMode <= CombineModeComplement));
}

inline BOOL
MatrixOrderIsValid(
    MatrixOrder     order
    )
{
    return ((order == MatrixOrderPrepend) || (order == MatrixOrderAppend));
}

inline BOOL
EmfTypeIsValid(
    EmfType     type
    )
{
    return ((type >= EmfTypeEmfOnly) && (type <= EmfTypeEmfPlusDual));
}

inline BOOL
ColorAdjustTypeIsValid(
    ColorAdjustType     type
    )
{
    return ((type >= ColorAdjustTypeDefault) && (type < ColorAdjustTypeCount));
}

#if 0
GpStatus
WINGDIPAPI
GdipCreateRectGradient(
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    ARGB* colors,
    GpWrapMode wrapMode,
    GpRectGradient **rectgrad
    )
{
    CheckParameter(rectgrad && colors);

    GpRectF rect(x, y, width, height);

    GpColor gpcolor[4];

    gpcolor[0].SetColor(colors[0]);
    gpcolor[1].SetColor(colors[1]);
    gpcolor[2].SetColor(colors[2]);
    gpcolor[3].SetColor(colors[3]);

    *rectgrad = new GpRectGradient(rect, gpcolor, wrapMode);

    if (CheckValid(*rectgrad))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateRectGradientI(
    INT x,
    INT y,
    INT width,
    INT height,
    ARGB* colors,
    GpWrapMode wrapMode,
    GpRectGradient **rectgrad
    )
{
     return GdipCreateRectGradient(TOREAL(x),
                                   TOREAL(y),
                                   TOREAL(width),
                                   TOREAL(height),
                                   colors,
                                   wrapMode,
                                   rectgrad);
}

GpStatus
WINGDIPAPI
GdipGetRectGradientColor(
    GpRectGradient *brush,
    ARGB* colors
    )
{
    CheckParameter(colors);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor gpcolor[4];

    brush->GetColors(gpcolor);

    colors[0] = gpcolor[0].GetValue();
    colors[1] = gpcolor[1].GetValue();
    colors[2] = gpcolor[2].GetValue();
    colors[3] = gpcolor[3].GetValue();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetRectGradientColor(
    GpRectGradient *brush,
    ARGB* colors
    )
{
    CheckParameter(colors);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor gpcolor[4];

    gpcolor[0].SetColor(colors[0]);
    gpcolor[1].SetColor(colors[1]);
    gpcolor[2].SetColor(colors[2]);
    gpcolor[3].SetColor(colors[3]);

    brush->SetColors(gpcolor);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRectGradientRect(
    GpRectGradient *brush,
    GpRectF *rect
    )
{
    CheckParameter(rect);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->GetRect(*rect);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRectGradientRectI(
    GpRectGradient *brush,
    GpRect *rect
    )
{
    CheckParameter(rect);

    GpRectF rectF;

    GpStatus status = GdipGetRectGradientRect(brush, &rectF);

    if (status == Ok)
    {
        FPUStateSaver fpuState;

        rect->X = GpRound(rectF.X);
        rect->Y = GpRound(rectF.Y);
        rect->Width = GpRound(rectF.Width);
        rect->Height = GpRound(rectF.Height);
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipGetRectGradientBlendCountH(
    GpRectGradient *brush,
    INT *count
    )
{
    CheckParameter(count);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetHorizontalBlendCount();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRectGradientBlendH(
    GpRectGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->GetHorizontalBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipSetRectGradientBlendH(
    GpRectGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetHorizontalBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipGetRectGradientBlendCountV(
    GpRectGradient *brush,
    INT *count
    )
{
    CheckParameter(count > 0);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetVerticalBlendCount();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRectGradientBlendV(
    GpRectGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->GetVerticalBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipSetRectGradientBlendV(
    GpRectGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetVerticalBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipSetRectGradientWrapMode(
    GpRectGradient *brush,
    GpWrapMode wrapmode
    )
{
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->SetWrapMode(wrapmode);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRectGradientWrapMode(
    GpRectGradient *brush,
    GpWrapMode *wrapmode
    )
{
    CheckParameter(wrapmode);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *wrapmode = (GpWrapMode)brush->GetWrapMode();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetRectGradientTransform(
    GpRectGradient *brush,
    GpMatrix *matrix
    )
{
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    brush->SetTransform(*matrix);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRectGradientTransform(
    GpRectGradient *brush,
    GpMatrix *matrix
    )
{
   CheckParameterValid(brush);
   CheckObjectBusy(brush);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   brush->GetTransform(matrix);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateRadialBrush(
    GpRectF *gprect,
    ARGB centercol,
    ARGB boundarycol,
    GpWrapMode wrapmode,
    GpRadialGradient **radgrad
    )
{
    CheckParameter(radgrad && gprect);

    GpColor center(centercol);
    GpColor boundary(boundarycol);

    *radgrad = new GpRadialGradient(*gprect, center, boundary, wrapmode);

    if (CheckValid(*radgrad))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateRadialBrushI(
    GpRect *gprect,
    ARGB centercol,
    ARGB boundarycol,
    GpWrapMode wrapmode,
    GpRadialGradient **radgrad
    )
{
    CheckParameter(gprect);

    GpRectF rectF(TOREAL(gprect->X),
                  TOREAL(gprect->Y),
                  TOREAL(gprect->Width),
                  TOREAL(gprect->Height));

    return GdipCreateRadialBrush(&rectF,
                                 centercol,
                                 boundarycol,
                                 wrapmode,
                                 radgrad);
}

GpStatus
WINGDIPAPI
GdipSetRadialCenterColor(
    GpRadialGradient *brush,
    ARGB argb
    )
{
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor center(argb);

    brush->SetCenterColor(center);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetRadialBoundaryColor(
    GpRadialGradient *brush,
    ARGB argb
    )
{
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   GpColor boundary(argb);

   brush->SetBoundaryColor(boundary);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRadialCenterColor(
    GpRadialGradient *brush,
    ARGB *argb
    )
{
   CheckParameter(argb);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   GpColor center = brush->GetCenterColor();

   *argb = center.GetValue();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRadialBoundaryColor(
    GpRadialGradient *brush,
    ARGB *argb
    )
{
   CheckParameter(argb);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   GpColor boundary = brush->GetBoundaryColor();

   *argb = boundary.GetValue();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRadialRect(
    GpRadialGradient *brush,
    GpRectF *rect
    )
{
   CheckParameter(rect);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   brush->GetRect(*rect);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRadialRectI(
    GpRadialGradient *brush,
    GpRect *rect
    )
{
   CheckParameter(rect);

   GpRectF rectF;

   GpStatus status = GdipGetRadialRect(brush, &rectF);

   if (status == Ok)
   {
       FPUStateSaver fpuState;

       rect->X = GpRound(rectF.X);
       rect->Y = GpRound(rectF.Y);
       rect->Width = GpRound(rectF.Width);
       rect->Height = GpRound(rectF.Height);
   }

   return status;
}

GpStatus
WINGDIPAPI
GdipGetRadialBlendCount(
    GpRadialGradient *brush,
    INT *count
    )
{
   CheckParameter(count);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   *count = brush->GetBlendCount();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRadialBlend(
    GpRadialGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
   CheckParameter(blend);
   CheckParameter(positions);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   return brush->GetBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipSetRadialBlend(
    GpRadialGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
   CheckParameter(blend);
   CheckParameter(positions);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   return brush->SetBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipGetRadialPresetBlendCount(
    GpRadialGradient *brush,
    INT *count
    )
{
   CheckParameter(count);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   *count = brush->GetPresetBlendCount();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRadialPresetBlend(
    GpRadialGradient *brush,
    ARGB *blend,
    REAL *blendPositions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    StackBuffer buffer;

    GpColor* gpcolors = (GpColor*) buffer.GetBuffer(count*sizeof(GpColor));
    
    if(!gpcolors) return OutOfMemory;

    if (gpcolors)
    {
        GpStatus status = brush->GetPresetBlend(gpcolors, blendPositions, count);

        for(INT i = 0; i < count; i++)
        {
            blend[i] = gpcolors[i].GetValue();
        }

        return status;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipSetRadialPresetBlend(
    GpRadialGradient *brush,
    ARGB *blend,
    REAL* blendPositions, INT count    )
{
    CheckParameter(blend);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    StackBuffer buffer;

    GpColor* gpcolors = (GpColor*) buffer.GetBuffer(count*sizeof(GpColor));

    if(!gpcolors) return OutOfMemory;
    
    if (gpcolors)
    {
        for(INT i = 0; i < count; i++)
        {
            gpcolors[i].SetColor(blend[i]);
        }

        GpStatus status = brush->SetPresetBlend(gpcolors, blendPositions, count);

        return status;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipSetRadialSigmaBlend(
    GpRadialGradient *brush,
    REAL focus,
    REAL scale
    )
{
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetSigmaBlend(focus, scale);
}

GpStatus
WINGDIPAPI
GdipSetRadialLinearBlend(
    GpRadialGradient *brush,
    REAL focus,
    REAL scale
    )
{
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetLinearBlend(focus, scale);
}

GpStatus
WINGDIPAPI
GdipSetRadialWrapMode(
    GpRadialGradient *brush,
    GpWrapMode wrapmode
    )
{
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   brush->SetWrapMode(wrapmode);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRadialWrapMode(
    GpRadialGradient *brush,
    GpWrapMode *wrapmode
    )
{
   CheckParameter(wrapmode);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   *wrapmode = (GpWrapMode)brush->GetWrapMode();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetRadialTransform(
    GpRadialGradient *brush,
    GpMatrix *matrix
    )
{
   CheckParameterValid(brush);
   CheckObjectBusy(brush);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   brush->SetTransform(*matrix);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRadialTransform(
    GpRadialGradient *brush,
    GpMatrix *matrix
    )
{
   CheckParameterValid(brush);
   CheckObjectBusy(brush);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   brush->GetTransform(matrix);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateTriangleGradient(
    GpPointF* points,
    ARGB* colors,
    GpWrapMode wrapMode,
    GpTriangleGradient **trigrad
    )
{
    CheckParameter(points && trigrad && colors);

    GpColor gpcolor[3];

    gpcolor[0].SetColor(colors[0]);
    gpcolor[1].SetColor(colors[1]);
    gpcolor[2].SetColor(colors[2]);

    *trigrad = new GpTriangleGradient(points, gpcolor, wrapMode);

    if (CheckValid(*trigrad))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateTriangleGradientI(
    GpPoint* points,
    ARGB* colors,
    GpWrapMode wrapMode,
    GpTriangleGradient **trigrad
    )
{
    CheckParameter(points);

    GpPointF pointsF[3];

    pointsF[0].X = TOREAL(points[0].X);
    pointsF[0].Y = TOREAL(points[0].Y);
    pointsF[1].X = TOREAL(points[1].X);
    pointsF[1].Y = TOREAL(points[1].Y);
    pointsF[2].X = TOREAL(points[2].X);
    pointsF[2].Y = TOREAL(points[2].Y);

    return GdipCreateTriangleGradient(&pointsF[0], colors, wrapMode, trigrad);
}

GpStatus
GdipGetTriangleGradientColor(
    GpTriangleGradient *brush,
    ARGB* colors
    )
{
    CheckParameter(colors);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor gpcolor[3];

    brush->GetColors(gpcolor);

    colors[0] = gpcolor[0].GetValue();
    colors[1] = gpcolor[1].GetValue();
    colors[2] = gpcolor[2].GetValue();

    return Ok;
}

GpStatus
GdipSetTriangleGradientColor(
    GpTriangleGradient *brush,
    ARGB* colors
    )
{
    CheckParameter(colors);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor gpcolor[3];

    gpcolor[0].SetColor(colors[0]);
    gpcolor[1].SetColor(colors[1]);
    gpcolor[2].SetColor(colors[2]);

    brush->SetColors(gpcolor);

    return Ok;
}

GpStatus
GdipGetTriangleGradientTriangle(
    GpTriangleGradient *brush,
    GpPointF* points
    )
{
    CheckParameter(points);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->GetTriangle(points);

    return Ok;
}

GpStatus
GdipGetTriangleGradientTriangleI(
    GpTriangleGradient *brush,
    GpPoint* points
    )
{
    CheckParameter(points);

    GpPointF pointsF[3];

    GpStatus status = GdipGetTriangleGradientTriangle(brush, &pointsF[0]);

    if (status == Ok)
    {
        FPUStateSaver fpuState;

        points[0].X = GpRound(pointsF[0].X);
        points[0].Y = GpRound(pointsF[0].Y);
        points[1].X = GpRound(pointsF[1].X);
        points[1].Y = GpRound(pointsF[1].Y);
        points[2].X = GpRound(pointsF[2].X);
        points[2].Y = GpRound(pointsF[2].Y);
    }

    return status;
}

GpStatus
GdipSetTriangleGradientTriangle(
    GpTriangleGradient *brush,
    GpPointF* points
    )
{
    CheckParameter(points);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->SetTriangle(points);

    return Ok;
}

GpStatus
GdipSetTriangleGradientTriangleI(
    GpTriangleGradient *brush,
    GpPoint* points
    )
{
    CheckParameter(points);

    GpPointF pointsF[3];

    pointsF[0].X = TOREAL(points[0].X);
    pointsF[0].Y = TOREAL(points[0].Y);
    pointsF[1].X = TOREAL(points[1].X);
    pointsF[1].Y = TOREAL(points[1].Y);
    pointsF[2].X = TOREAL(points[2].X);
    pointsF[2].Y = TOREAL(points[2].Y);

    return GdipSetTriangleGradientTriangle(brush, &pointsF[0]);
}

GpStatus
GdipGetTriangleGradientRect(
    GpTriangleGradient *brush,
    GpRectF *rect
    )
{
    CheckParameter(rect);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->GetRect(*rect);

    return Ok;
}

GpStatus
GdipGetTriangleGradientRectI(
    GpTriangleGradient *brush,
    GpRect *rect
    )
{
    CheckParameter(rect);

    GpRectF rectf;

    GpStatus status = GdipGetTriangleGradientRect(brush, &rectf);

    if (status == Ok)
    {
        FPUStateSaver fpuState;

        rect->X = GpRound(rectf.X);
        rect->Y = GpRound(rectf.Y);
        rect->Width = GpRound(rectf.Width);
        rect->Height = GpRound(rectf.Height);
    }

    return status;
}

GpStatus
GdipGetTriangleGradientBlendCount0(
    GpTriangleGradient *brush,
    INT *count
    )
{
    CheckParameter(count);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetBlendCount0();

    return Ok;
}

GpStatus
GdipGetTriangleGradientBlend0(
    GpTriangleGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->GetBlend0(blend, positions, count);
}

GpStatus
GdipSetTriangleGradientBlend0(
    GpTriangleGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetBlend0(blend, positions, count);
}

GpStatus
GdipGetTriangleGradientBlendCount1(
    GpTriangleGradient *brush,
    INT *count
    )
{
    CheckParameter(count);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetBlendCount1();

    return Ok;
}

GpStatus
GdipGetTriangleGradientBlend1(
    GpTriangleGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->GetBlend1(blend, positions, count);
}

GpStatus
GdipSetTriangleGradientBlend1(
    GpTriangleGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetBlend1(blend, positions, count);
}

GpStatus
GdipGetTriangleGradientBlendCount2(
    GpTriangleGradient *brush,
    INT *count
    )
{
    CheckParameter(count);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetBlendCount2();

    return Ok;
}

GpStatus
GdipGetTriangleGradientBlend2(
    GpTriangleGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->GetBlend2(blend, positions, count);
}

GpStatus
GdipSetTriangleGradientBlend2(
    GpTriangleGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetBlend2(blend, positions, count);
}

GpStatus
GdipGetTriangleGradientWrapMode(
    GpTriangleGradient *brush,
    GpWrapMode *wrapmode
    )
{
    CheckParameter(wrapmode);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *wrapmode = (GpWrapMode)brush->GetWrapMode();

    return Ok;
}

GpStatus
GdipSetTriangleGradientWrapMode(
    GpTriangleGradient *brush,
    GpWrapMode wrapmode
    )
{
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->SetWrapMode(wrapmode);

    return Ok;
}

GpStatus
GdipGetTriangleGradientTransform(
    GpTriangleGradient *brush,
    GpMatrix *matrix
    )
{
   CheckParameterValid(brush);
   CheckObjectBusy(brush);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   brush->GetTransform(matrix);

   return Ok;
}

GpStatus
GdipSetTriangleGradientTransform(
    GpTriangleGradient *brush,
    GpMatrix *matrix
    )
{
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    brush->SetTransform(*matrix);

    return Ok;
}

// For reference in V2

/**
 * Represent line texture objects
 */
class LineTexture
{
public:
    friend class Pen;

    /**
     * Create a new line texture object
     */
    // !! Take Image* instead?
    LineTexture(const Bitmap* bitmap, 
                REAL length)
    {
        GpLineTexture *lineTexture = NULL;

        lastResult = DllExports::GdipCreateLineTexture((GpBitmap*)
                                                          bitmap->nativeImage,
                                                          length,
                                                          0,
                                                          &lineTexture);
        SetNativeLineTexture(lineTexture);
    }

    LineTexture(const Bitmap* bitmap, 
                REAL length, 
                REAL offset)
    {
        GpLineTexture *lineTexture = NULL;
        
        lastResult = DllExports::GdipCreateLineTexture((GpBitmap*)
                                                          bitmap->nativeImage,
                                                          length,
                                                          offset,
                                                          &lineTexture);
        SetNativeLineTexture(lineTexture);
    }

    LineTexture* Clone() const
    {
        GpLineTexture *cloneLineTexture = NULL;

        SetStatus(DllExports::GdipCloneLineTexture(nativeLineTexture,
                                                         &cloneLineTexture));

        return new LineTexture(cloneLineTexture, lastResult);
    }

    /**
     * Dispose of resources associated with the line texture
     */
    ~LineTexture()
    {
        DllExports::GdipDeleteLineTexture(nativeLineTexture);
    }

    /**
     * Get line texture attributes
     */
    Bitmap* GetBitmap() const
    {
        SetStatus(NotImplemented);

        return NULL;
    }

    REAL GetLength() const
    {
        REAL len = 0;

        SetStatus(DllExports::GdipGetLineTextureLength(nativeLineTexture,
                                                         &len));
        return len;
    }

    REAL GetOffset() const
    {
        REAL offset = 0;

        SetStatus(DllExports::GdipGetLineTextureOffset(nativeLineTexture, 
                                                         &offset));
        return offset;
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

protected:
    LineTexture(GpLineTexture* lineTexture, Status status)
    {
        lastResult = status;
        SetNativeLineTexture(lineTexture);
    }

    VOID SetNativeLineTexture(GpLineTexture *lineTexture)
    {
        nativeLineTexture = lineTexture;
    }
    
    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

private:
    /*
     * handle to native line texture object
     */

    GpLineTexture* nativeLineTexture;
    mutable Status lastResult;
};

//--------------------------------------------------------------------------
// Represent triangular gradient brush object
//--------------------------------------------------------------------------

class TriangleGradientBrush : public Brush
{
public:
    friend class Pen;

    // Constructors

    TriangleGradientBrush(
                         const PointF* points,
                         const Color* colors,
                         WrapMode wrapMode = WrapModeClamp)
    {
        ARGB argb[3];

        argb[0] = colors[0].GetValue();
        argb[1] = colors[1].GetValue();
        argb[2] = colors[2].GetValue();

        GpTriangleGradient *brush = NULL;

        lastResult = DllExports::GdipCreateTriangleGradient(
                                                           points, argb, 
                                                           wrapMode, &brush);
        SetNativeBrush(brush);
    }

    TriangleGradientBrush(
                         const Point* points,
                         const Color* colors,
                         WrapMode wrapMode = WrapModeClamp)
    {
        ARGB argb[3];

        argb[0] = colors[0].GetValue();
        argb[1] = colors[1].GetValue();
        argb[2] = colors[2].GetValue();

        GpTriangleGradient *brush = NULL;

        lastResult = DllExports::GdipCreateTriangleGradientI(
                                                            points, argb, 
                                                            wrapMode, &brush);
        SetNativeBrush(brush);
    }

    // Get/set colors

    Status GetColors(Color colors[]) const
    {
        ARGB argb[3];

        SetStatus(DllExports::GdipGetTriangleGradientColor(
                                                          (GpTriangleGradient*) nativeBrush, argb));

        if (lastResult == Ok)
        {
            // use bitwise copy operator for Color copy
            colors[0] = Color(argb[0]);
            colors[1] = Color(argb[1]);
            colors[2] = Color(argb[2]);
        }

        return lastResult;
    }

    Status SetColors(Color colors[])
    {
        ARGB argb[3];

        argb[0] = colors[0].GetValue();
        argb[1] = colors[1].GetValue();
        argb[2] = colors[2].GetValue();

        return SetStatus(DllExports::GdipSetTriangleGradientColor(
                                                                 (GpTriangleGradient*)nativeBrush, argb));
    }

    // Get/set triangle

    Status GetTriangle(PointF* points) const
    {
        return SetStatus(DllExports::GdipGetTriangleGradientTriangle(
                                                                    (GpTriangleGradient*)nativeBrush, points));
    }

    Status GetTriangle(Point* points) const
    {
        return SetStatus(DllExports::GdipGetTriangleGradientTriangleI(
                                                                     (GpTriangleGradient*)nativeBrush, points));
    }

    Status SetTriangle(PointF* points)
    {
        return SetStatus(DllExports::GdipSetTriangleGradientTriangle(
                                                                    (GpTriangleGradient*)nativeBrush, points));
    }

    Status SetTriangle(Point* points)
    {
        return SetStatus(DllExports::GdipSetTriangleGradientTriangleI(
                                                                     (GpTriangleGradient*)nativeBrush, points));
    }

    Status GetRectangle(RectF& rect) const
    {
        return SetStatus(DllExports::GdipGetTriangleGradientRect(
                                                                (GpTriangleGradient*)nativeBrush, &rect));
    }

    Status GetRectangle(Rect& rect) const
    {
        return SetStatus(DllExports::GdipGetTriangleGradientRectI(
                                                                 (GpTriangleGradient*)nativeBrush, &rect));
    }

    // Get/set blend factors
    //
    // If the blendFactors.length = 1, then it's treated
    // as the falloff parameter. Otherwise, it's the array
    // of blend factors.

    // NOTE: Differing semantics from COM+ version where we return
    // an array containing the implicit length value.

    INT GetBlendCount0() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetTriangleGradientBlendCount0(
                                                                (GpTriangleGradient*) nativeBrush, &count));

        return count;
    }

    Status GetBlend0(REAL** blendFactors, REAL** blendPositions, INT count) const
    {
        if (!blendFactors || !blendPositions || count <= 0)
            return SetStatus(InvalidParameter);

        *blendFactors = new REAL[count];
        *blendPositions = new REAL[count];

        if (!*blendFactors || !*blendPositions)
        {
            if (*blendFactors)
                delete[] *blendFactors;
            if (*blendPositions)
                delete[] *blendPositions;
            
            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetTriangleGradientBlend0(
                                                                  (GpTriangleGradient*)nativeBrush,
                                                                  *blendFactors, *blendPositions, count));

        if (status != Ok) 
        {
            delete[] *blendFactors;
            *blendFactors = NULL;
            delete[] *blendPositions;
            *blendPositions = NULL;
        }

        return status;
    }

    Status SetBlend0(REAL* blendFactors, REAL* blendPositions, INT count)
    {
        return SetStatus(DllExports::GdipSetTriangleGradientBlend0(
                                                                  (GpTriangleGradient*)nativeBrush,
                                                                  blendFactors, blendPositions, count));
    }

    INT GetBlendCount1() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetTriangleGradientBlendCount1(
                                                                (GpTriangleGradient*) nativeBrush, &count));

        return count;
    }

    Status GetBlend1(REAL** blendFactors, REAL** blendPositions, INT count) const 
    {
        if (!blendFactors || !blendPositions || count <= 0)
            return SetStatus(InvalidParameter);

        *blendFactors = new REAL[count];
        *blendPositions = new REAL[count];

        if (!*blendFactors || !*blendPositions)
        {
            if (*blendFactors)
                delete[] *blendFactors;
            if (*blendPositions)
                delete[] *blendPositions;

            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetTriangleGradientBlend1(
                                                                  (GpTriangleGradient*)nativeBrush,
                                                                  *blendFactors, *blendPositions, count));
        if (status != Ok) 
        {
            delete[] *blendFactors;
            *blendFactors = NULL;
            delete[] *blendPositions;
            *blendPositions = NULL;
        }
    
        return status;
    }

    Status SetBlend1(REAL* blendFactors, REAL* blendPositions, INT count)
    {
        return SetStatus(DllExports::GdipSetTriangleGradientBlend1(
                                                                  (GpTriangleGradient*)nativeBrush,
                                                                  blendFactors, blendPositions, count));
    }

    INT GetBlendCount2() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetTriangleGradientBlendCount2(
                                                                (GpTriangleGradient*) nativeBrush, &count));

        return count;
    }

    Status GetBlend2(REAL** blendFactors, REAL** blendPositions, INT count) const
    {
        if (!blendFactors || !blendPositions || count <= 0)
            return SetStatus(InvalidParameter);

        *blendFactors = new REAL[count];
        *blendPositions = new REAL[count];

        if (!*blendFactors || !*blendPositions)
        {
            if (*blendFactors)
                delete[] *blendFactors;
            if (*blendPositions)
                delete[] *blendPositions;
            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetTriangleGradientBlend2(
                                                                  (GpTriangleGradient*)nativeBrush,
                                                                  *blendFactors, *blendPositions, count));
    
        if (status != Ok) 
        {
            delete[] *blendFactors;
            *blendFactors = NULL;
            delete[] *blendPositions;
            *blendPositions = NULL;
        }

        return status;
    }

    Status SetBlend2(REAL* blendFactors, REAL* blendPositions, INT count)
    {
        return SetStatus(DllExports::GdipSetTriangleGradientBlend2(
                                                                  (GpTriangleGradient*)nativeBrush,
                                                                  blendFactors, blendPositions, count));
    }

    // Check the opacity of this brush element.

    /**
     * Get/set brush transform
     */
    Status GetTransform(Matrix *matrix) const
    {
        return SetStatus(DllExports::GdipGetTriangleGradientTransform(
                                                                     (GpTriangleGradient*) nativeBrush, matrix->nativeMatrix));
    }

    Status SetTransform(const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetTriangleGradientTransform(
                                                                     (GpTriangleGradient*) nativeBrush, matrix->nativeMatrix));
    }


    /**
     * Get/set brush wrapping mode
     */
    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetTriangleGradientWrapMode(
                                                             (GpTriangleGradient*) nativeBrush, &wrapMode));

        return wrapMode;
    }

    Status SetWrapMode(WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetTriangleGradientWrapMode(
                                                                    (GpTriangleGradient*) nativeBrush, wrapMode));
    }

protected:

    TriangleGradientBrush()
    {
    }
};

//--------------------------------------------------------------------------
// Represent rectangular gradient brush object
//--------------------------------------------------------------------------
class RectangleGradientBrush : public Brush
{
public:
    friend class Pen;

    // Constructors

    RectangleGradientBrush(const RectF& rect, 
                           const Color* colors,
                           WrapMode wrapMode = WrapModeTile)
    {
        ARGB argb[4];

        argb[0] = colors[0].GetValue();
        argb[1] = colors[1].GetValue();
        argb[2] = colors[2].GetValue();
        argb[3] = colors[3].GetValue();

        GpRectGradient *brush = NULL;

        lastResult = DllExports::GdipCreateRectGradient(rect.X, 
                                                        rect.Y,
                                                        rect.Width,
                                                        rect.Height,
                                                        argb, 
                                                        wrapMode, 
                                                        &brush);
        SetNativeBrush(brush);
    }

    // integer version
    RectangleGradientBrush(const Rect& rect, 
                           const Color* colors,
                           WrapMode wrapMode = WrapModeTile)
    {
        ARGB argb[4];

        argb[0] = colors[0].GetValue();
        argb[1] = colors[1].GetValue();
        argb[2] = colors[2].GetValue();
        argb[3] = colors[3].GetValue();

        GpRectGradient *brush = NULL;

        lastResult = DllExports::GdipCreateRectGradientI(rect.X, 
                                                         rect.Y,
                                                         rect.Width,
                                                         rect.Height,
                                                         argb, 
                                                         wrapMode, 
                                                         &brush);
        SetNativeBrush(brush);
    }

    // Get/set colors

    Status SetColors(const Color colors[])
    {
        ARGB argb[4];

        argb[0] = colors[0].GetValue();
        argb[1] = colors[1].GetValue();
        argb[2] = colors[2].GetValue();
        argb[3] = colors[3].GetValue();

        return SetStatus(DllExports::GdipSetRectGradientColor(
                                                             (GpRectGradient*)nativeBrush,
                                                             argb));
    }

    Status GetColors(Color colors[]) const
    {
        ARGB argb[4];

        SetStatus(DllExports::GdipGetRectGradientColor((GpRectGradient*)
                                                       nativeBrush, 
                                                       argb));

        if (lastResult == Ok)
        {
            // use bitwise copy operator for Color copy
            colors[0] = Color(argb[0]);
            colors[1] = Color(argb[1]);
            colors[2] = Color(argb[2]);
            colors[3] = Color(argb[3]);
        }

        return lastResult;
    }


    Status GetRectangle(RectF& rect) const
    {
        return SetStatus(DllExports::GdipGetRectGradientRect((GpRectGradient*)nativeBrush,
                                                             &rect));
    }

    Status GetRectangle(Rect& rect) const
    {
        return SetStatus(DllExports::GdipGetRectGradientRectI((GpRectGradient*)nativeBrush,
                                                              &rect));
    }

    // Get/set blend factors
    //
    // If the blendFactors.length = 1, then it's treated
    // as the falloff parameter. Otherwise, it's the array
    // of blend factors.

    // NOTE: Differing semantics from COM+ version where we return
    // an array containing the implicit length value.

    INT GetHorizontalBlendCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetRectGradientBlendCountH((GpRectGradient*)
                                                             nativeBrush,
                                                             &count));
        return count;
    }

    Status GetHorizontalBlend(REAL** blendFactors, REAL** blendPositions, INT count) const
    {
        if (!blendFactors || !blendPositions || count <= 0)
            return SetStatus(InvalidParameter);

        *blendFactors = new REAL[count];
        *blendPositions = new REAL[count];

        if (!*blendFactors || !*blendPositions)
        {
            if (*blendFactors)
                delete *blendFactors;
            if (*blendPositions)
                delete *blendPositions;
            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetRectGradientBlendH((GpRectGradient*)nativeBrush,
                                                               *blendFactors, *blendPositions, count));
    
        if (status != Ok) 
        {
            delete[] *blendFactors;
            *blendFactors = NULL;
            delete[] *blendPositions;
            *blendPositions = NULL;
        }

        return status;
    }

    Status SetHorizontalBlend(const REAL* blendFactors, const REAL* blendPositions, INT count)
    {
        return SetStatus(DllExports::GdipSetRectGradientBlendH((GpRectGradient*)nativeBrush,
                                                               blendFactors, blendPositions, count));
    }

    INT GetVerticalBlendCount() const 
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetRectGradientBlendCountV((GpRectGradient*)
                                                             nativeBrush,
                                                             &count));
        return count;
    }

    Status GetVerticalBlend(REAL** blendFactors, REAL** blendPositions, INT count) const
    {
        if (!blendFactors || !blendPositions || count <= 0)
            return SetStatus(OutOfMemory);

        *blendFactors = new REAL[count];
        *blendPositions = new REAL[count];

        if (!*blendFactors || !*blendPositions)
        {
            if (*blendFactors)
                delete[] *blendFactors;
            if (*blendPositions)
                delete[] *blendPositions;
            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetRectGradientBlendV((GpRectGradient*)nativeBrush,
                                                               *blendFactors, *blendPositions, count));
    
        if (status != Ok) 
        {
            delete[] *blendFactors;
            *blendFactors = NULL;
            delete[] *blendPositions;
            *blendPositions = NULL;
        }

        return status;
    }

    Status SetVerticalBlend(const REAL* blendFactors, const REAL* blendPositions, INT count)
    {
        return SetStatus(DllExports::GdipSetRectGradientBlendV((GpRectGradient*)nativeBrush,
                                                               blendFactors, blendPositions, count));
    }

    // Check the opacity of this brush element.

    /**
     * Set/get brush transform
     */
    Status SetTransform(const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetRectGradientTransform((GpRectGradient*)
                                                                  nativeBrush, 
                                                                  matrix->nativeMatrix));
    }

    Status GetTransform(Matrix *matrix) const
    {
        return SetStatus(DllExports::GdipGetRectGradientTransform((GpRectGradient*)
                                                                  nativeBrush, 
                                                                  matrix->nativeMatrix));
    }

    /**
     * Set/get brush wrapping mode
     */
    Status SetWrapMode(WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetRectGradientWrapMode((GpRectGradient*)
                                                                 nativeBrush, 
                                                                 wrapMode));
    }

    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetRectGradientWrapMode((GpRectGradient*)
                                                          nativeBrush, 
                                                          &wrapMode));

        return wrapMode;
    }

protected:

    RectangleGradientBrush()
    {
    }
};

class RadialGradientBrush : public Brush
{
public:
    friend class Pen;

    RadialGradientBrush(
                       const RectF& rect,
                       const Color& centerColor,
                       const Color& boundaryColor,
                       WrapMode wrapMode = WrapModeClamp
                       )
    {
        GpRadialGradient *brush = NULL;

        lastResult = DllExports::GdipCreateRadialBrush(&rect, 
                                                       centerColor.GetValue(),
                                                       boundaryColor.GetValue(),
                                                       wrapMode, &brush);

        SetNativeBrush(brush);
    }

    RadialGradientBrush(
                       const Rect& rect,
                       const Color& centerColor,
                       const Color& boundaryColor,
                       WrapMode wrapMode = WrapModeClamp
                       )
    {
        GpRadialGradient *brush = NULL;

        lastResult = DllExports::GdipCreateRadialBrushI(&rect, 
                                                        centerColor.GetValue(),
                                                        boundaryColor.GetValue(),
                                                        wrapMode, &brush);

        SetNativeBrush(brush);
    }
    // Get/set color attributes

    Status SetCenterColor(const Color& color)
    {
        return SetStatus(DllExports::GdipSetRadialCenterColor((GpRadialGradient*)nativeBrush,
                                                              color.GetValue()));
    }

    Status SetBoundaryColor(const Color& color)
    {
        return SetStatus(DllExports::GdipSetRadialBoundaryColor((GpRadialGradient*)nativeBrush, 
                                                                color.GetValue()));
    }

    Status GetCenterColor(Color& centerColor)
    {
        ARGB argb;

        SetStatus(DllExports::GdipGetRadialCenterColor((GpRadialGradient*)
                                                       nativeBrush, &argb));

        centerColor = Color(argb);

        return lastResult;
    }

    Status GetBoundaryColor(Color& boundaryColor)
    {
        ARGB argb = 0;

        SetStatus(DllExports::GdipGetRadialBoundaryColor((GpRadialGradient*)
                                                         nativeBrush, &argb));

        boundaryColor = Color(argb);

        return lastResult;
    }

    Status GetRectangle(RectF& rect) const
    {
        return SetStatus(DllExports::GdipGetRadialRect(
                                                      (GpRadialGradient*)nativeBrush, &rect));
    }

    Status GetRectangle(Rect& rect) const
    {
        return SetStatus(DllExports::GdipGetRadialRectI(
                                                       (GpRadialGradient*)nativeBrush, &rect));
    }

    // !!!  This diverges from COM+ implemention in that we give 
    // them all blend values instead of upto 'count' of them.

    Status SetBlend(const REAL* blendFactors, const REAL* blendPositions, INT count)
    {
        return SetStatus(DllExports::GdipSetRadialBlend((GpRadialGradient*)
                                                        nativeBrush,
                                                        blendFactors,
                                                        blendPositions,
                                                        count));
    }

    INT GetBlendCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetRadialBlendCount((GpRadialGradient*)
                                                      nativeBrush,
                                                      &count));

        return count;
    }

    Status GetBlend(REAL** blendFactors, REAL** blendPositions, INT count) const 
    {
        if (!blendFactors || !blendPositions || count <= 0)
            return SetStatus(InvalidParameter);
        
        *blendFactors = new REAL[count];
        *blendPositions = new REAL[count];

        if (!*blendFactors || !*blendPositions)
        {
            if (*blendFactors)
                delete[] *blendFactors;
            if (*blendPositions)
                delete[] *blendPositions;
            
            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetRadialBlend((GpRadialGradient*)nativeBrush,
                                                                 *blendFactors,
                                                                 *blendPositions,
                                                                 count));
        if (status != Ok)
        {
            delete[] *blendFactors;
            *blendFactors = NULL;
            delete[] *blendPositions;
            *blendPositions = NULL;
        }
    
        return status;
    }

    INT GetPresetBlendCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetRadialPresetBlendCount((GpRadialGradient*)
                                                            nativeBrush,
                                                            &count));

        return count;
    }

    Status SetPresetBlend(const Color* presetColors,
                          const REAL* blendPositions, INT count)
    {
        if (!presetColors || !blendPositions || count <= 0)
            return SetStatus(InvalidParameter);
        
        ARGB* argbs = (ARGB*) malloc(count*sizeof(ARGB));
        
        if (argbs)
        {
            for (INT i = 0; i < count; i++)
            {
                argbs[i] = presetColors[i].GetValue();
            }

            Status status = SetStatus(DllExports::GdipSetRadialPresetBlend(
                                                                          (GpRadialGradient*) nativeBrush,
                                                                          argbs,
                                                                          blendPositions,
                                                                          count));
            free(argbs);
            return status;
        } 
        else
        {
            return SetStatus(OutOfMemory);
        }
    }

    Status GetPresetBlend(Color** presetColors, REAL** blendPositions, INT count) const 
    {
        if (!presetColors || !blendPositions || count <= 0)
            return SetStatus(InvalidParameter);

        *presetColors = new Color[count];
        *blendPositions = new REAL[count];
        
        ARGB* argbs = (ARGB*) malloc(count*sizeof(ARGB));

        if (!*presetColors || !*blendPositions || !argbs)
        {
            if (*presetColors)
                delete[] *presetColors;
            if (*blendPositions)
                delete[] *blendPositions;
            free(argbs);

            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetRadialPresetBlend(
                                                                        (GpRadialGradient*)nativeBrush,
                                                                        argbs,
                                                                        *blendPositions,
                                                                        count));
        if (status == Ok) 
        {
           for (INT i = 0; i < count; i++)
           {
              *presetColors[i] = Color(argbs[i]);
           }
        }
        else
        {
           delete[] *presetColors;
           *presetColors = NULL;
           delete[] *blendPositions;
           *blendPositions = NULL;
        }

        free(argbs);

        return status;
    }

    Status SetSigmaBlend(REAL focus, REAL scale = 1.0)
    {
        return SetStatus(DllExports::GdipSetRadialSigmaBlend(
                                                            (GpRadialGradient*)nativeBrush, focus, scale));
    }

    Status SetLinearBlend(REAL focus, REAL scale = 1.0)
    {
        return SetStatus(DllExports::GdipSetRadialLinearBlend(
                                                             (GpRadialGradient*)nativeBrush, focus, scale));
    }

    /**
     * Set/get brush transform
     */
    Status SetTransform(const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetRadialTransform((GpRadialGradient*)nativeBrush, 
                                                            matrix->nativeMatrix));
    }

    Status GetTransform(Matrix *matrix) const
    {
        return SetStatus(DllExports::GdipGetRadialTransform((GpRadialGradient*)nativeBrush, 
                                                            matrix->nativeMatrix));
    }

    /**
     * Set/get brush wrapping mode
     */
    Status SetWrapMode(WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetRadialWrapMode((GpRadialGradient*)nativeBrush, 
                                                           wrapMode));
    }

    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetRadialWrapMode((GpRadialGradient*)
                                                    nativeBrush, 
                                                    &wrapMode));

        return wrapMode;
    }

protected:

    RadialGradientBrush()
    {
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\debug.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   Debugging macros
*
* Abstract:
*
*   Macros used for debugging purposes
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*   09/07/1999 agodfrey
*       Moved from Engine\Common
*   02/07/2000 agodfrey
*       Made more of it private (for bug #35561).
*       Changed the output function to add "\n" automatically.
*
\**************************************************************************/

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

#if DBG

// Global debug level

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_RIP     4

extern INT GpDebugLevel;

///////////////////////////// DEPRECATED STUFF ///////////////////////////////

// Raw output function. Emits debug messages. Its direct use is depracated.
// It's useful for private debugging, though.

ULONG _cdecl DbgPrint(CHAR*, ...);

// Strip the directory prefix from a filename

const CHAR*
StripDirPrefix(
    const CHAR* filename
    );

// Use of DBGMSG is depracated - it's supplied only because driverd3d.cpp uses
// it.

#define DBGMSG(level, prefix, msg)       \
        {                                \
            if (GpDebugLevel <= (level)) \
            {                            \
                DbgPrint("%s %s (%d): ", prefix, StripDirPrefix(__FILE__), __LINE__); \
                DbgPrint msg;            \
            }                            \
        }

///////////////////////////// PRIVATE STUFF //////////////////////////////////

// Just leave this function alone. You don't want to call it yourself. Trust me.
CHAR * _cdecl GpParseDebugString(CHAR* format, ...);

// Ditto for this one.
VOID _cdecl GpLogDebugEvent(INT level, CHAR *file, UINT line, CHAR *message);

#define LOG_DEBUG_EVENT(level, msg)                                  \
    {                                                                \
        if (GpDebugLevel <= (level))                                 \
        {                                                            \
            CHAR *debugOutput = GpParseDebugString msg;              \
            GpLogDebugEvent(level, __FILE__, __LINE__, debugOutput); \
        }                                                            \
    }

//////////////////////////////// THE GOOD STUFF //////////////////////////////

// These macros are used for debugging. They expand to
// whitespace on a free build.
//
// GpDebugLevel
//  Global variable which holds the current debug level. You can use it to
//  control the quantity of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ASSERT(cond)
//  Verify that a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify that a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// ONCE(code block)
//  Use this to make a code block execute only once per run.
//  Useful for cutting down on spew.
//  e.g.:
//      ONCE(WARNING(("Invalid arguments")));
//
// Usage:
//
//  These macros require extra parentheses for the msg argument
//  for example:
//      WARNING(("App passed NULL pointer; ignoring it."));
//      ASSERTMSG(x > 0, ("x is less than 0"));
//
//  Each call to an output function is treated as a separate event -
//  if you want to build up a message, e.g. in a loop, build it up in a
//  string, and then call the output function.
//
//  This is because we don't always just output the string to the debugger -
//  when we link statically, we may send the output to a user-defined handler.
//
//  Don't put a trailing \n on the message. If the output is sent to the
//  debugger, the output function will add the \n itself.

#define VERBOSE(msg) LOG_DEBUG_EVENT(DBG_VERBOSE, msg)
#define TERSE(msg) LOG_DEBUG_EVENT(DBG_TERSE, msg)
#define WARNING(msg) LOG_DEBUG_EVENT(DBG_WARNING, msg)

// SAVE_WARNING must be identical to WARNING
#define SAVE_WARNING(msg) LOG_DEBUG_EVENT(DBG_WARNING, msg)

// same as WARNING, but doesn't require extra set of ()'s for single string
#define WARNING1(msg) LOG_DEBUG_EVENT(DBG_WARNING, (msg))
#define RIP(msg) LOG_DEBUG_EVENT(DBG_RIP, msg)

#define ASSERT(cond)   \
    {                  \
        if (! (cond))  \
        {              \
            RIP(("Assertion failure: %s", #cond)); \
        }              \
    }

#define ASSERTMSG(cond, msg) \
    {                        \
        if (! (cond))        \
        {                    \
            RIP(msg);        \
        }                    \
    }

#define ONCE(codeblock)      \
    {                        \
        static int doneOnce; \
        if (!doneOnce)       \
        {                    \
            { codeblock ; }  \
            doneOnce=1;      \
        }                    \
    }

#else // !DBG

//--------------------------------------------------------------------------
// Retail build
//--------------------------------------------------------------------------

#define DBGMSG(level, prefix, msg) {}
#define VERBOSE(msg) {}
#define TERSE(msg) {}
#define WARNING(msg) {}
#define SAVE_WARNING(msg) {}
#define WARNING1(msg) {}

#define RIP(msg) {}
#define ASSERT(cond) {}
#define ASSERTMSG(cond, msg) {}

#define ONCE(codeblock) {}

#endif // !DBG

// IF_NOT_OK_WARN_AND_RETURN(statusValue)
// This macro is used when you want to return early in case of a failure
// and spit out a debug warning.
// 
// Originally we had an ASSERT instead of WARNING, but this prevented test
// from running automation on checked build
// 
// from David Brown:
//      I got fed up writing this little block again and again all over the
//      place.
//
//      Looking at all the places that needed it I found I was often missing
//      the ASSERT, and sometimes doing the ASSERT but missing the return.
//
//      Futhermore when written in full, this block takes more space than the
//      code around it making it difficult to see the wood for the trees.
//
//      Although I generally avoid macros because thay make code less
//      obvious, I believe this one makes it safer in the long run.

#define IF_NOT_OK_WARN_AND_RETURN(a)  \
    if ((a) != Ok)                             \
    {                                          \
        WARNING(("Status != Ok"));             \
        return a;                              \
    }

#ifdef __cplusplus
}
#endif

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\fix.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Fix.hpp
*
* Abstract:
*
*   Fixed Point types, defines, and methods
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/

#ifndef _FIX_HPP
#define _FIX_HPP

typedef INT FIX4;       // 28.4 fixed point value
typedef INT FIX16;      // 16.16 fixed point value

// constants for working with 28.4 fixed point values
#define FIX4_SHIFT  4
#define FIX4_PRECISION  4
#define FIX4_ONE        (1 << FIX4_PRECISION)
#define FIX4_HALF       (1 << (FIX4_PRECISION-1))
#define FIX4_MASK       (FIX4_ONE - 1)


enum
{
    FIX16_SHIFT = 16,
    FIX16_ONE = 1 << FIX16_SHIFT,
    FIX16_HALF = 1 << (FIX16_SHIFT - 1),
    FIX16_MASK = FIX16_ONE - 1
};

inline INT
GpFix16Floor(
    FIX16        fixedValue
    )
{
    return fixedValue >> FIX16_SHIFT;
}

inline INT
GpFix16Ceiling(
    FIX16        fixedValue
    )
{
    return (fixedValue + FIX16_MASK) >> FIX16_SHIFT;
}

inline INT
GpFix16Round(FIX16 fixedValue)
{
    // Add half and truncate down towards negative infinity.
    return (fixedValue + FIX16_HALF) >> FIX16_SHIFT;
}

inline FIX16
GpRealToFix16(
    REAL        realValue
    )
{
    return GpRound(realValue * FIX16_ONE);
}

/**************************************************************************\
*
* Function Description:
*
*   Take the ceiling of a fixed-pt value, without doing overflow checking
*
* Arguments:
*
*   [IN] fixedValue - 28.4 Fixed Point value
*
* Return Value:
*
*   INT - The integer ceiling (32.0) of the fixed point value
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/

inline INT
GpFix4Ceiling(
    FIX4        fixedValue
    )
{
    return (fixedValue + FIX4_MASK) >> FIX4_PRECISION;
}

inline INT
GpFix4Floor(
    FIX4        fixedValue
    )
{
    return fixedValue >> FIX4_PRECISION;
}

inline INT
GpFix4Round(
    FIX4        fixedValue
    )
{
    // Add half and truncate down towards negative infinity.

    return (fixedValue + FIX4_HALF) >> FIX4_PRECISION;
}


/**************************************************************************\
*
* Function Description:
*
*   Convert a real, floating point value to a 28.4 fixed-point value,
*   without doing overflow checking
*
* Arguments:
*
*   [IN] r         - Real class to make rounding faster
*   [IN] realValue - the real value to convert
*
* Return Value:
*
*   FIX4 - The 28.4 fixed point value
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
inline FIX4
GpRealToFix4(
    REAL        realValue
    )
{
    return GpRound(realValue * FIX4_ONE);
}

inline REAL
FIX4TOREAL(
    FIX4    fix
    )
{
    return (((REAL)fix)/16);
}

class PointFix4
{
public:
    FIX4    X;
    FIX4    Y;
    
    VOID Set(REAL x, REAL y)
    {
        X = GpRealToFix4(x);
        Y = GpRealToFix4(y);
    }
};

//--------------------------------------------------------------------------
// The following are simple functions to check if a number is within range
// of fixed point types.
//--------------------------------------------------------------------------

#define FIXED16_INT_MAX ( (1 << 15) - 1)
#define FIXED16_INT_MIN (-(1 << 15))

#define FIXED4_INT_MAX ( (1 << 27) - 1)
#define FIXED4_INT_MIN (-(1 << 27))

inline BOOL GpValidFixed16(REAL x)
{
    return (x >= FIXED16_INT_MIN) && (x <= FIXED16_INT_MAX);
}

inline BOOL GpValidFixed4(REAL x)
{
    return (x >= FIXED4_INT_MIN) && (x <= FIXED4_INT_MAX);
}

inline BOOL GpValidFixed16(INT x)
{
    return (x >= FIXED16_INT_MIN) && (x <= FIXED16_INT_MAX);
}

inline BOOL GpValidFixed4(INT x)
{
    return (x >= FIXED4_INT_MIN) && (x <= FIXED4_INT_MAX);
}


/**************************************************************************\
*
* Function Description:
*
*   This function multiplies two 32bit integers into a 64 bit value, and
*   shifts the result to the right by 16 bits.  We provide a hand
*   optimized assembly version on x86 to avoid out of line calls.
*
*   This has the effect of multiplying two 16.16 fixed point numbers and
*   returning a 16.16 fixed point result.
*
* Arguments:
*
*     a - first 32bit integer to multiply
*     b - second 32bit integer to multiply
*
* History:
*   04/16/2000 asecchia   created it.
*
\**************************************************************************/

#ifdef _X86_

__inline INT
Int32x32Mod16(
        INT a,
        INT b
        )
{
    __asm
    {
        mov eax, b
        imul a
        shrd eax, edx, 16
    }
}

#else

__inline INT
Int32x32Mod16(
        INT a,
        INT b
        )
{
    return ((INT) Int64ShraMod32(Int32x32To64(a, b), 16));
}

#endif


/**************************************************************************\
*
* Function Description:
*
*   This function takes two input numbers treated as 16.16. They are multiplied
*   together to give an internal 32.32 fixed point representation. The 
*   fractional bits are then rounded to the nearest whole number and the
*   result is returned as a BYTE. 
*
*   This is particularly useful for color channel computation requiring 16 
*   bits of fractional precision.
*
* Arguments:
*
*     a - first 32bit integer to multiply
*     b - second 32bit integer to multiply
*
* History:
*   12/20/2000 asecchia   created it.
*
\**************************************************************************/

#ifdef _X86_

__inline BYTE
Fix16MulRoundToByte(DWORD a, DWORD b)
{
    __asm
    {
        mov eax, b
        mul a
        add eax, 0x80000000   // FIX32 half
        adc edx, 0            // carry
        mov eax, edx          // ret dl
    }
}

#else

__inline BYTE
Fix16MulRoundToByte(DWORD a, DWORD b)
{
    return (BYTE)GpFix16Round(Int32x32Mod16(a, b));
}

#endif



#endif // _FIX_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\debug.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*   Debugging routines
*
* Revision History:
*
*   09/07/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

namespace Globals
{
    DebugEventProc UserDebugEventProc = NULL;
};

#if DBG

// GpDebugLevel is used to control the amount/severity of debugging messages
// that are actually output.

INT GpDebugLevel = DBG_TERSE;

/**************************************************************************\
*
* Function Description:
*
*   Removes the path portion of a pathname
*
* Arguments:
*
*   [IN] str - pathname to strip
*
* Return Value:
*
*   A pointer to the filename portion of the pathname
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

const CHAR*
StripDirPrefix(
    const CHAR* str
    )

{
    const CHAR* p;

    p = strrchr(str, '\\');
    return p ? p+1 : str;
}

const int maxInputStringSize = 1024;

/**************************************************************************\
*
* Function Description:
*
*   Outputs to the debugger
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   Zero. This is to conform to NTDLL's definition of DbgPrint.
*
* Notes:
*
*   There will be no output if a debugger is not connected.
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

ULONG _cdecl
DbgPrint(
    CHAR* format,
    ...
    )

{
    va_list arglist;
    va_start(arglist, format);
    
    char buf[maxInputStringSize];
    
    _vsnprintf(buf, maxInputStringSize, format, arglist);
    buf[maxInputStringSize-1]=0;
        
    OutputDebugStringA(buf);
    
    va_end(arglist);
    return 0;
}

// If we can't allocate memory for the debug string, we'll use this buffer
// in desperation. It's not thread-safe. I *did* say 'desperation'.

static CHAR desperationBuffer[maxInputStringSize];

/**************************************************************************\
*
* Function Description:
*
*   Creates a new string, and sprintf's to it.
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   The probably-newly-allocated string result.
*
* Notes:
*
*   This function is not intended for general use. It guards against memory
*   failure by using a global buffer. So, while the caller is responsible
*   for freeing the memory, the caller must also check for that buffer.
*   i.e. we only want DbgEmitMessage to call this.
*
*   It's also only mostly thread-safe, because if we run out of memory,
*   we'll use that global buffer in a non-protected way.
*
*   This is the only solution I could find so that I could move most of the
*   implementation details out of the header file. The root cause is that
*   macros don't handle multiple arguments natively, so we have to pass
*   the printf arguments as a single macro argument (in parentheses).
*   Which means, the function that consumes those arguments can have no
*   other arguments.
*
* History:
*
*   02/01/2000 agodfrey
*       Created it. Finally, I've found a way to get debug implementation
*       details out of the headers.
*
\**************************************************************************/

CHAR * _cdecl
GpParseDebugString(
    CHAR* format,
    ...
    )
{
    va_list arglist;
    va_start(arglist, format);
    
    // Don't use GpMalloc here so that we can use ASSERT and WARNING in 
    // our memory allocation routines.

    char *newBuf = static_cast<char *>(LocalAlloc(LMEM_FIXED, maxInputStringSize));
    if (!newBuf)
    {
        newBuf = desperationBuffer;
    }
    
    _vsnprintf(newBuf, maxInputStringSize, format, arglist);
    
    // Nuke the last byte, because MSDN isn't clear on what _vsnprintf does
    // in that case.
    
    newBuf[maxInputStringSize-1]=0;
        
    va_end(arglist);
    return newBuf;
}

/**************************************************************************\
*
* Function Description:
*
*   Processes a debug event. Frees the message string.
*
* Arguments:
*
* level   - The debug level of the event 
* file    - Should be __FILE__
* line    - Should be __LINE__
* message - The debug message.
*
* Notes:
*
*   You don't want to call this directly. That would be error-prone. 
*   Use ASSERT, WARNING, etc.
*
*   Depending on the debug level, an identifying prefix will be output.
*
*   If the debug level is DBG_RIP, will suspend execution (e.g. by
*   hitting a breakpoint.)
*
* Note on the "debug event" callback:
*
*   We optionally pass WARNINGs and ASSERTs to a reporting function
*   provided by the user, instead of to the debugger.
*   (e.g. their function may pop up a dialog or throw an exception).
*   Lesser events will still be sent to the debugger.
*
* History:
*
*   02/01/2000 agodfrey
*       Created it.
*
\**************************************************************************/

VOID _cdecl 
GpLogDebugEvent(
    INT level, 
    CHAR *file, 
    UINT line,
    CHAR *message
    )
{
    // We may want to add things to the passed-in message. So we need
    // a temporary buffer
    
    const int maxOutputStringSize = maxInputStringSize + 100;
    CHAR tempBuffer[maxOutputStringSize+1];
    
    // MSDN's _vsnprintf doc isn't clear on this, so just in case:
    tempBuffer[maxOutputStringSize] = 0;

    INT callbackEventType = -1;
    
    CHAR *prefix = "";
    
    if (GpDebugLevel <= (level))
    {
        switch (level)
        {
        case DBG_WARNING:
            prefix = "WRN ";
            if (Globals::UserDebugEventProc)
            {
                callbackEventType = DebugEventLevelWarning;
            }    
            break;
            
        case DBG_RIP:
            prefix = "RIP ";
            if (Globals::UserDebugEventProc)
            {
                callbackEventType = DebugEventLevelFatal;
            }    
            break;
        }
        
        // The convention is that we append the trailing \n, not the caller.
        // Two reasons:
        // 1) Callers tend to forget it.
        // 2) More importantly, it encourages the caller to think of each
        //    call as a separate event. This is important in some cases - e.g.
        //    when the user's "debug event" callback produces a popup for 
        //    each event.

        _snprintf(
            tempBuffer, 
            maxOutputStringSize, 
            "%s%s(%d): %s\n",
            prefix,
            StripDirPrefix(file),
            line,
            message
            );
        
        if (callbackEventType >= 0)
        {
            // Wrap the following call in an exception handler in case the
            // initial component who set the debug event proc uninitializes
            // on another thread, resulting in UserDebugEventProc being set
            // to NULL.

            __try
            {
                Globals::UserDebugEventProc((DebugEventLevel) callbackEventType, tempBuffer);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                OutputDebugStringA(tempBuffer);
            }
        }
        else
        {
            OutputDebugStringA(tempBuffer);
        }
    }
    
    // Free the message buffer
    
    if (message != desperationBuffer)
    {
        LocalFree(message);
    }
    
    // Force a breakpoint, if it's warranted.
    
    if ((GpDebugLevel <= DBG_RIP) && (level == DBG_RIP) && (callbackEventType < 0))
    {
        DebugBreak();
    }
}
    
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\mem.h ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Memory management functions
*
* Abstract:
*
*   Wrapper functions for memory management.
*   This file is C-includable.
*
* Revision History:
*
*   07/08/1999 agodfrey
*       Created it.
*   09/07/1999 agodfrey
*       Moved the code into Runtime\mem.h
*
\**************************************************************************/

#ifndef _MEM_H
#define _MEM_H

#include <malloc.h>
#include "tags.h"

#define GpMemset    memset
#define GpMemcpy    memcpy
#define GpMemcmp    memcmp


// Enable memory allocation checking only on the DBG build
#if DBG
#define GPMEM_ALLOC_CHK 1
#define GPMEM_ALLOC_CHK_LIST 1   // List leaked blocks in debug output
#endif


#ifdef __cplusplus

#define GPMEMHEAPINITIAL 32768 // 32K initial heap size
#define GPMEMHEAPLIMIT       0 // No limit
#define GPMEMHEAPFLAGS       0 // Our common Heap API flags

//--------------------------------------------------------------------------
// Building for native DLL
//--------------------------------------------------------------------------

// Our memory allocation functions.
//
// This file (only) is made C-includable so that we can use it in
// dropped C code.

extern "C" {
#endif

#if GPMEM_ALLOC_CHK_LIST
    void * __stdcall GpMallocDebug(size_t size, char *filename, int line);
    #define GpMalloc(size) GpMallocDebug(size, __FILE__, __LINE__)
    #if DBG
        void * __stdcall GpMallocAPIDebug(size_t size, char *fileName, int lineNumber);
        #define GpMallocAPI(size) GpMallocAPIDebug(size, __FILE__, __LINE__)
    #endif
    void GpTagMalloc(void * mem, GpTag tag, int bApi);
#else
    void * __stdcall GpMalloc( size_t size );
    #if DBG
        // This is used to track API allocations on the debug build.
        void * __stdcall GpMallocAPI( size_t size );
    #endif
    #define GpTagMalloc(x,y,z)
#endif

void * __stdcall GpRealloc( void *memblock, size_t size );
void __stdcall GpFree( void *memblock );

#ifdef __cplusplus
}

// Hook new and delete

#pragma optimize ( "t", on)

// Don't ask me why we need 'static' here. But we do - otherwise
// it generates out-of-line versions which cause a link clash with Office.

static inline void* __cdecl operator new(size_t size)
{
    return GpMalloc(size);
}

static inline void __cdecl operator delete(void* p)
{
    GpFree(p);
}

static inline void* __cdecl operator new[](size_t size)
{
    return GpMalloc(size);
}

static inline void __cdecl operator delete[](void* p)
{
    GpFree(p);
}

static inline void* __cdecl operator new(size_t size, GpTag tag, int bApi)
{
#if GPMEM_ALLOC_CHK_LIST
    void * mem = GpMalloc(size);
    GpTagMalloc(mem, tag, bApi);
    return mem;
#else
    return GpMalloc(size);
#endif
}

static inline void* __cdecl operator new[](size_t size, GpTag tag, int bApi)
{
#if GPMEM_ALLOC_CHK_LIST
    void * mem = GpMalloc(size);
    GpTagMalloc(mem, tag, bApi);
    return mem;
#else
    return GpMalloc(size);
#endif
}


#pragma optimize ("", on)

// TODO:
//
// Imaging code needs to hook to GpMalloc, GpFree etc.

#endif

/*
 * Assert that we didn't leak any memory.
 * Can only be called during shutdown.
 */
extern void GpAssertShutdownNoMemoryLeaks();

extern void GpInitializeAllocFailures();
extern void GpDoneInitializeAllocFailureMode();
extern void GpStartInitializeAllocFailureMode();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\precomp.hpp ===
#if DBG
#include <stdio.h>
#endif

#include "runtime.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\osinfo.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   OS information
*
* Abstract:
*
*   Describes the OS that is running
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*   09/08/1999 agodfrey
*       Moved to Runtime\OSInfo.cpp
*
\**************************************************************************/

#include "precomp.hpp"

namespace GpRuntime {

DWORD OSInfo::VAllocChunk;
DWORD OSInfo::PageSize;
DWORD OSInfo::MajorVersion;
DWORD OSInfo::MinorVersion;
BOOL OSInfo::IsNT;
BOOL OSInfo::HasMMX;

BOOL DetectMMXProcessor();

}

#ifdef _X86_

/**************************************************************************\
*
* Function Description:
*
*   Detect whether the processor supports MMX
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   TRUE if the processor supports MMX
*   FALSE otherwise
*
\**************************************************************************/

BOOL
GpRuntime::DetectMMXProcessor()
{
    // NT 4.0 and up provide an API to check for MMX support; this handles
    // floating-point emulation as well. We cannot implicitly reference this
    // function because it's not exported by Windows 95 or NT < 4.0, so we
    // must use GetProcAddress. Windows 98 and up do export the function, but
    // it's stubbed, so we must also do an OS version check:

    typedef BOOL (WINAPI *ISPROCESSORFEATUREPRESENTFUNCTION)(DWORD);
    ISPROCESSORFEATUREPRESENTFUNCTION IsProcessorFeaturePresentFunction = NULL;
    
    if ((OSInfo::IsNT) && (OSInfo::MajorVersion >= 4))
    {
        // LoadLibrary is not required since we're implicitly dependent on
        // kernel32.dll, so just use GetModuleHandle:
        
        HMODULE kernel32Handle = GetModuleHandle(TEXT("kernel32.dll"));

        if (kernel32Handle != NULL)
        {
            IsProcessorFeaturePresentFunction =
                (ISPROCESSORFEATUREPRESENTFUNCTION) GetProcAddress(
                    kernel32Handle, "IsProcessorFeaturePresent");
        }
    }

    BOOL hasMMX;

    if (IsProcessorFeaturePresentFunction != NULL)
    {
        hasMMX =
            IsProcessorFeaturePresentFunction(PF_MMX_INSTRUCTIONS_AVAILABLE);
    }
    else
    {
        hasMMX = FALSE;

        // IsProcessorFeaturePresent is unsupported on this OS, so we'll use
        // CPUID to check for MMX support.
        //
        // If CPUID is unsupported on this processor, we'll take the
        // exception. This will happen on most processors < Pentium, however
        // some 486 processors support CPUID.
        
        WARNING(("Executing processor detection; "
                 "benign first-change exception possible."));
        
        __try
        {
            DWORD features;

            // Get processor features using CPUID function 1:
            
            __asm
            {
                push eax
                push ebx
                push ecx
                push edx

                mov eax, 1
                cpuid
                mov features, edx

                pop edx
                pop ecx
                pop ebx
                pop eax
            }

            // If bit 23 is set, MMX technology is supported by this
            // processor, otherwise MMX is unsupported:
            
            if (features & (1 << 23))
            {
                // Try executing an MMX instruction to make sure
                // floating-point emulation is not on:
            
                __asm emms

                // If we made it this far, then MMX is available:

                hasMMX = TRUE;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // We should only be here if (1) the processor does not support
            // CPUID or (2) CPUID is supported, but floating-point emulation
            // is enabled.
        }
    }
    
    return hasMMX;
}

#else // !_X86_

#define DetectMMXProcessor() FALSE

#endif // !_X86_

/**************************************************************************\
*
* Function Description:
*
*   Static initialization function for OSInfo class.
*   Called by GpRuntime::Initialize()
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRuntime::OSInfo::Initialize()
{
    // Get VM information

    SYSTEM_INFO sysinfo;
    GetSystemInfo(&sysinfo);

    VAllocChunk = sysinfo.dwAllocationGranularity;
    PageSize = sysinfo.dwPageSize;

    // Get operating system version information

    OSVERSIONINFOA osver;
    osver.dwOSVersionInfoSize = sizeof(osver);

    if (GetVersionExA(&osver))
    {
        IsNT = (osver.dwPlatformId == VER_PLATFORM_WIN32_NT);
        MajorVersion = osver.dwMajorVersion;
        MinorVersion = osver.dwMinorVersion;
    }

    // Check to see if MMX is available

    HasMMX = DetectMMXProcessor();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\osinfo.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   OS information
*
* Abstract:
*
*   Describes the OS that is running
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*   09/08/1999 agodfrey
*       Moved to Runtime\OSInfo.hpp
*
\**************************************************************************/

#ifndef _OSINFO_HPP
#define _OSINFO_HPP

namespace GpRuntime
{

//--------------------------------------------------------------------------
// Global OS-related information
// This is initialized in GpRuntime::Initialize()
//--------------------------------------------------------------------------

class OSInfo
{
public:
    static DWORD VAllocChunk;
    static DWORD PageSize;
    static BOOL IsNT;
    static DWORD MajorVersion;
    static DWORD MinorVersion;
    static BOOL HasMMX;
private:
    static void Initialize();
    
    friend BOOL GpRuntime::Initialize();
};

}

#endif // !_OSINFO_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\tags.h ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Tag enumerations
*
* Abstract:
*
*   This file is the central depot for the enumeration of all object tags.
*   This file is C-includable.
*
* Revision History:
*
*   08/21/2000 bhouse
*       Created it.
*
\**************************************************************************/

#ifndef _TAGSX_H
#define _TAGSX_H

#ifdef __cplusplus
extern "C" {
#endif

    typedef enum GpTag {
        GpPathTag           = 'gpth',
        GpIteratorTag       = 'iter'
    } GpTag;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\real.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Floating point arithmetic support.
*
* History:
*
*   09/22/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#if defined(DBG)

// We need the definition of Globals::IsNt, but we don't want to include
// the whole of the ..\common\globals.hpp file.

namespace Globals
{
    extern BOOL IsNt;                   // Are we running on any version of NT?
}

VOID
FPUStateSaver::AssertMode(
    VOID
    )
{
    if (SaveLevel <= 0)
    {
        ASSERTMSG(0, ("FPU mode not set via FPUStateSaver class"));
    }
    
    #if defined(_USE_X86_ASSEMBLY)

    UINT32 tempState;
    
    // Issue a FP barrier. Take all pending exceptions now.
    
    _asm fwait
    
    // get the control word

    _asm fnstcw  WORD PTR tempState
    
    // ASSERT that the control word is still set to our prefered
    // rounding mode and exception mask.
    // If we take this ASSERT, there was an unauthorized change of 
    // the FPU rounding mode or exception mask settings between
    // the FPUStateSaver constructor and destructor.
    
    if(Globals::IsNt)
    {
        ASSERTMSG( 
            (tempState & FP_CTRL_MASK) == FP_CTRL_STATE,
            ("FPUStateSaver: Incorrect FPU Control Word")
        );
    }
    else
    {
        // On Win9x, many print drivers clear various exception masks
        // and at least one video driver (ATI) changed the rounding control.
        // While this could potentially cause rounding errors resulting in
        // slightly different rasterization, and/or spurious exceptions, the 
        // change required to fix this (wrapping all calls to GDI) is too 
        // large to risk. Instead, we downgrade the ASSERT on win9x to a 
        // WARNING. We have not seen one of these exceptions or rounding 
        // errors causing an actual rasterization error yet and will fix 
        // those as they occur.
        
        if((tempState & FP_CTRL_MASK) != FP_CTRL_STATE)
        {
            WARNING(("FPUStateSaver: Incorrect FPU Control Word"));
        }
    }
    
    #endif
}

LONG FPUStateSaver::SaveLevel = 0;

#endif

/**************************************************************************\
*
* Function Description:
*
*   Internal definition of MSVCRT's pow()
*
* Arguments:
*
*   x - base
*   y - exponent
*
* Return Value:
*
*   x^y
*
* Notes:
*
*   I purposefully didn't make our code use Office's implementation when
*   we do the Office build. I want to avoid needing a separate build for
*   Office if I can.
*
* Created:
*
*   10/19/1999 agodfrey
*       Stole it from Office's code (mso\gel\gelfx86.cpp)
*
\**************************************************************************/

double
GpRuntime::Pow(
    double x, 
    double y
)
{

#if defined(_USE_X86_ASSEMBLY)
    
    static const double fphalf = 0.5;
    static const double fpone = 1.0;

    if ( x == 0.0 )
    {
        if ( y > 0.0 )
        {
            return 0.0;
        }

        if (y == 0.0)
        {
            WARNING(("call Pow(x, y) with x=0.0 and y=0.0"));
            return 1.0; // sic
        }

        if ( y < 0.0 )
        {
            WARNING(("call Pow(x, y) with x=0.0 and y < 0.0"));

            // return INF to comply with MSDN. Since we don't have INF defined
            // in our header files, we use DBL_MAX which should be
            // sufficient.
            // !!!Todo[minliu], figure out how to return INF

            return DBL_MAX;
        }
    }// x == 0.0

    if (y == 0.0)
    {
        return 1.0;
    }

    __asm FLD QWORD PTR [y];   // becomes ST(1)
    __asm FLD QWORD PTR [x];   // becomes ST
    __asm FYL2X;               // ST := ST(1) * log2(ST)
    __asm FST QWORD PTR [x];

    /* Do this in C++ just to avoid all the messing around with the condition
        flags, keep x in ST(0) while doing this. */
    if (fabs(x) < fpone)
    {
        /* The power is in the range which F2XM1 can handle. */
        __asm F2XM1;                  // ST := 2^ST - 1
        __asm FADD QWORD PTR [fpone]; // ST := 2^mantissa
    }
    else
    {
        /* The power needs to be handled as a separate fractional and whole
            number part, as F2XM1 only handles fractions.  Note that we don't
            care about the rounding mode here - we just need to split x
            into two parts one of which is <1.0. */
        __asm FLD ST;                 // Duplicate ST
        __asm FRNDINT;                // Integral value in ST
        //NB: doc bug in the x86 manual, the following does ST(1):=ST(1)-ST
        __asm FSUB ST(1), ST;         // Fractional value in ST(1)
        __asm FXCH;                   // Factional value in ST
        __asm F2XM1;                  // ST := 2^ST - 1
        __asm FADD QWORD PTR [fpone]; // ST := 2^frac
        __asm FSCALE;                 // ST := 2^frac * 2^integral
        __asm FSTP ST(1);             // FSCALE does not pop anything
    }

    __asm FSTP QWORD PTR [x];
    return x;

#else

// No choice at the moment - we have to use the CRT. We'll watch what
// Office does when they start caring about IA64.

#undef pow
    return pow(x,y);

#endif
}

/**************************************************************************\
*
* Function Description:
*
*   Out-of-line version of exp()
*
* Arguments:
*
*   x - input value
*
* Return Value:
*
*   e^x
*
* Notes:
*
*   Because we compile 'optimize for size', the compiler refuses to inline
*   calls to exp() - because its implementation is quite long. So, we
*   make an out-of-line version by setting the optimizations correctly
*   here, and generating an inline version. Yes, I agree completely.
*
* Created:
*
*   10/20/1999 agodfrey
*       Wrote it.
*
\**************************************************************************/

#pragma optimize("gt", on)

double
GpRuntime::Exp(
    double x
)
{
#undef exp
    return exp(x);
}
#pragma optimize("", on)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\real.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Contains macros for helping with floating point arithmetic.
*
* History:
*
*   07/08/1999 agodfrey
*       Remove MSVCRT dependency.
*   12/06/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#ifndef _REAL_HPP_
#define _REAL_HPP_

// The following stuff is taken from Office code

/*****************************************************************************
    Intrinsic functions - it is essential that these be used because there is
    no library implementation.  Note that the intrinsic forms often have
    restricted behavior, e.g. the argument to a trignometric function must be
    less than 2^63 radians.
******************************************************************* JohnBo **/
#pragma intrinsic(sin, cos, tan)
#pragma intrinsic(atan, atan2)
#pragma intrinsic(sqrt)
#pragma intrinsic(log, log10, exp)
#pragma intrinsic(fabs)
#pragma intrinsic(fmod)

namespace GpRuntime 
{
/*
    [JohnBo]
    These in-line functions are required to force direct use of the
    instructions - without this the CI versions are used unless g optimization
    is switched on, with g optimization on the in-line function calls will be
    removed completely.
*/
#pragma optimize("g", on)
    inline double InlineSin(double x) { return sin(x); }
    inline double InlineCos(double x) { return cos(x); }
    inline double InlineTan(double x) { return tan(x); }
    inline double InlineATan(double x) { return atan(x); }
    inline double InlineATan2(double y, double x) { return atan2(y, x); }
    inline double InlineSqrt(double x) { return sqrt(x); }
    inline double InlineLog(double x) { return log(x); }
    inline double InlineLog10(double x) { return log10(x); }
    inline double InlineExp(double x) { return exp(x); }
/* Restore default optimization. */
#pragma optimize("", on)

    // Out-of-line math functions
    // pow: We implemented it ourselves
    // exp: Because the inline version is so long, the compiler won't
    //      inline it unless the original caller has 'generate fast code'
    //      set. Instead, we use an out-of-line version.
    double Pow(double, double);
    double Exp(double);
    
/*// Trying something:
inline double FPX86InlineFmod(double x, double y) { return fmod(x,y); }
#define fmod(x,y) FPX86InlineFmod(x,y)
*/
};

/* Force use of the in-line functions. */

#define sin(x) GpRuntime::InlineSin(x)
#define cos(x) GpRuntime::InlineCos(x)
#define tan(x) GpRuntime::InlineTan(x)
#define atan(x) GpRuntime::InlineATan(x)
#define atan2(y,x) GpRuntime::InlineATan2(y,x)
#define sqrt(x) GpRuntime::InlineSqrt(x)
#define log(x) GpRuntime::InlineLog(x)
#define log10(x) GpRuntime::InlineLog10(x)
#define exp(x) GpRuntime::Exp(x)

#define pow(x,y) GpRuntime::Pow(x,y)

/* Integer interfaces */
#pragma intrinsic(abs, labs)

// End of Office code

// Our pixel positioning uses 28.4 fixed point arithmetic and therefore 
// anything below the threshold of 1/32 should be irrelevant.
// Our choice of PIXEL_EPSILON is 1/64 which should give us correct pixel
// comparisons even in the event of accumulated floating point error.
#define PIXEL_EPSILON   0.015625f     // 1/64

#ifndef REAL_EPSILON
#define REAL_EPSILON    FLT_EPSILON
#endif

// This is for computing the complexity of matrices. When you compose matrices
// or scale them up by large factors, it's really easy to hit the REAL_EPSILON
// limits without actually affecting the transform in any noticable way.
// e.g. a matrix with a rotation of 1e-5 degrees is, for all practical purposes,
// not a rotation.
#define CPLX_EPSILON    (REAL_EPSILON*5000.0f)

// This is a tolerance error for the difference of each real coordinates.
// This leaves some acurracy to calculate tangent or normal for the two points.
#define POINTF_EPSILON  (REAL_EPSILON*5000.0f)


#define REALFMOD        fmodf
#define REALSQRT        sqrtf
#ifndef REALABS
#define REALABS         fabsf
#endif
#define REALSIN         sinf
#define REALCOS         cosf
#define REALATAN2       atan2f

// #define REAL_EPSILON    DBL_EPSILON
// #define REALFMOD        fmod
// #define REALSQRT        sqrt
// #define REALABS         fabs
// #define REALSIN         sin
// #define REALCOS         cos
// #define REALATAN2       atan2

// convert from unknown FLOAT type => REAL
#define TOREAL(x)       (static_cast<REAL>(x))

// defined separately for possibly future optimization LONG to REAL
#define LTOF(x)         (static_cast<REAL>(x))

// Return the positive integer remainder of a/b. b should not be zero.
// note that a % b will return a negative number 
// for a<0 xor b<0 which is not suitable for texture mapping
// or brush tiling.
// This macro computes the remainder of a/b
// correctly adjusted for tiling negative coordinates.

#define RemainderI(a, b)\
    ((a) >= 0 ? (a) % (b) : \
    (b) - 1 - ((-(a) - 1) % (b)))


// This definition assumes y > 0
inline REAL GpModF(REAL x, REAL y)
{
    if(x > 0)
    {
        return static_cast<REAL> (x - ((INT) (x/y))*y);
    }
    else if(x < 0)
    {
        REAL z;
        x = - x;
        z = static_cast<REAL> (x - ((INT) (x/y))*y);
        if(z > 0)
            z = y - z;

        return z;
    }
    else    // x == 0
        return 0.0;

/*    
//  This assumes fmod(x, y) = - fmod(-x, y) when x < 0.

    REAL z = REALFMOD(x, y);

    if(z >= 0)
        return z;
    else
        return y + z;
*/
}

#if defined(_X86_) && !defined(_COMPLUS_GDI)

    #define _USE_X86_ASSEMBLY

#else

    #undef  _USE_X86_ASSEMBLY

#endif

#if defined(_USE_X86_ASSEMBLY)

    #define FPU_STATE()                     \
        UINT32 cwSave;                      \
        UINT32 cwTemp;

    #define FPU_GET_STATE()                 \
        UINT32 cwSave = this->cwSave;       \
        UINT32 cwTemp = this->cwTemp;

    #define FPU_SAVE_STATE()                \
        this->cwSave = cwSave;              \
        this->cwTemp = cwTemp;

    #define FPU_SAVE_MODE()                 \
        UINT32 cwSave;                      \
        UINT32 cwTemp;                      \
                                            \
        __asm {                             \
            _asm fnstcw  WORD PTR cwSave    \
            _asm mov     eax, cwSave        \
            _asm mov     cwTemp, eax        \
        }                                   \
        this->cwSave = 
    
    #define FPU_RESTORE_MODE()              \
        __asm {                             \
            _asm fldcw   WORD PTR cwSave    \
        }
    
    #define FPU_RESTORE_MODE_NO_EXCEPTIONS()\
        __asm {                             \
            _asm fnclex                     \
            _asm fldcw   WORD PTR cwSave    \
        }
    
    #define FPU_CHOP_ON()                    \
        __asm {                              \
            _asm mov    eax, cwTemp          \
            _asm or     eax, 0x0c00          \
            _asm mov    cwTemp, eax          \
            _asm fldcw  WORD PTR cwTemp      \
        }
    
    #define FPU_ROUND_ON()                   \
        __asm {                              \
            _asm mov    eax, cwTemp          \
            _asm and    eax,0xf3ff           \
            _asm mov    cwTemp, eax          \
            _asm fldcw  WORD PTR cwTemp      \
        }
    
    #define FPU_ROUND_ON_PREC_HI()           \
        __asm {                              \
            _asm mov    eax, cwTemp          \
            _asm and    eax,0xf0ff           \
            _asm or     eax,0x0200           \
            _asm mov    cwTemp, eax          \
            _asm fldcw  WORD PTR cwTemp      \
        }
    
    #define FPU_PREC_LOW()                   \
        __asm {                              \
            _asm mov    eax, cwTemp          \
            _asm and    eax, 0xfcff          \
            _asm mov    cwTemp, eax          \
            _asm fldcw  WORD PTR cwTemp      \
        }
    
    #define FPU_PREC_LOW_MASK_EXCEPTIONS()   \
        __asm {                              \
            _asm mov    eax, cwTemp          \
            _asm and    eax, 0xfcff          \
            _asm or     eax, 0x3f            \
            _asm mov    cwTemp, eax          \
            _asm fldcw  WORD PTR cwTemp      \
        }
    
    #define FPU_CHOP_ON_PREC_LOW()          \
        __asm {                             \
            _asm mov    eax, cwTemp         \
            _asm or     eax, 0x0c00         \
            _asm and    eax, 0xfcff         \
            _asm mov    cwTemp, eax         \
            _asm fldcw  WORD PTR cwTemp     \
        }
    
    #define FPU_CHOP_OFF_PREC_HI()          \
        __asm {                             \
            _asm mov    eax, cwTemp         \
            _asm mov    ah, 2               \
            _asm mov    cwTemp, eax         \
            _asm fldcw  WORD PTR cwTemp     \
        }
    
    #define CHOP_ROUND_ON()     
    #define CHOP_ROUND_OFF()
    
    #if DBG
    #define ASSERT_CHOP_ROUND()         \
        {                               \
            WORD cw;                    \
            __asm {                     \
                __asm fnstcw cw         \
            }                           \
            ASSERT((cw & 0xc00) == 0xc00, "Chop round must be on"); \
        }
    #else
    #define ASSERT_CHOP_ROUND()
    #endif

#else // _USE_X86_ASSEMBLY

    #define FLT_TO_FIX_SCALE(value_in, scale) \
        ((INT)((REAL)(value_in) * scale))
    #define FLT_TO_UCHAR_SCALE(value_in, scale) \
        ((UCHAR)((INT)((REAL)(value_in) * scale)))
    #define UNSAFE_FLT_TO_FIX(value_in) \
        FLT_TO_FIX(value_in)
    
    #define FPU_SAVE_MODE()
    #define FPU_RESTORE_MODE()
    #define FPU_RESTORE_MODE_NO_EXCEPTIONS()
    #define FPU_CHOP_ON()
    #define FPU_ROUND_ON()
    #define FPU_ROUND_ON_PREC_HI()
    #define FPU_PREC_LOW()
    #define FPU_PREC_LOW_MASK_EXCEPTIONS()
    #define FPU_CHOP_ON_PREC_LOW()
    #define FPU_CHOP_OFF_PREC_HI()
    #define CHOP_ROUND_ON()
    #define CHOP_ROUND_OFF()
    #define ASSERT_CHOP_ROUND()

#endif  //_USE_X86_ASSEMBLY

#if defined(_USE_X86_ASSEMBLY)

    __inline INT __fastcall FLOOR(
        REAL a)
    {
        INT i;
    
        _asm {
            fld     a
            fistp   i
        }
    
        return i;
    }
    
    // Can cause overflow exceptions
    __inline INT __fastcall UNSAFE_FLOOR(
        REAL a)
    {
        INT l;
    
        _asm {
            fld     a
            fistp   l
        }
    
        return l;
    }
    
#else
    
    #define FLOOR(a) ((INT) floor(a))
    #define UNSAFE_FLOOR(a) ((INT) floor(a))
    
#endif    

//--------------------------------------------------------------------------
// Class for invoking 'floor' mode, and restoring it afterwards
//--------------------------------------------------------------------------

// These define the bits in the FPU control word that we care about.
// The high byte 0x0c is the rounding control and the low byte
// 0x3F is the exception mask flags.

#define FP_CTRL_MASK                0x0c3F    

// Set the rounding control and mask PE. DE is no longer masked because
// taking the exception can be helpful in finding bugs. However, we should
// probably turn on DE masking when we ship.

// Round Down
#define FP_CTRL_ROUNDDOWN           0x0400

// Mask PE only.
// Use this define to track down nasty FP bugs.
// #define FP_CTRL_MASKEDEXCEPTIONS    0x0020

// Mask all FP exceptions.

#define FP_CTRL_MASKEDEXCEPTIONS    0x003F

#define FP_CTRL_STATE              (FP_CTRL_ROUNDDOWN | FP_CTRL_MASKEDEXCEPTIONS)

class FPUStateSaver
{
private:

    UINT32 SavedState;

#if defined(DBG)
    // For AssertMode, we use SaveLevel to keep track
    // of the nesting level of FPUState. This is not thread safe.
    // At worst, that could cause spurious asserts; more likely it could
    // fail to catch some errors. To prevent the spurious asserts,
    // used interlocked instructions to modify it. To fix it properly,
    // we'd need to use per-thread storage.
    
    static LONG SaveLevel;
#endif    

public:

    FPUStateSaver()
    {
        // Here we set our thread's round mode to 'round down', and
        // save the old mode.  'Round to nearest' is actually the
        // default state for a process, but applications can set it
        // to whatever they like, and we should also respect and save
        // their preferred mode.

        #if defined(_USE_X86_ASSEMBLY)
        
            UINT32 tempState;
            UINT32 savedState;
    
            // clear the current exception state.
            // fnclex is a non-wait version of fclex - which means it clears
            // the exceptions without taking any pending unmasked exceptions.
            // We issue a fclex so that any unmasked exceptions are 
            // triggered immediately. This indicates a bug in the caller
            // of the API.
        
            _asm fclex
            
            // Save control word:
    
            _asm fnstcw  WORD PTR savedState
    
            this->SavedState = savedState;
    
            // Floor mode on & set up our prefered exception masks
    
            _asm mov     eax, savedState
            _asm and     eax, ~FP_CTRL_MASK
            _asm or      eax, FP_CTRL_STATE
            _asm mov     tempState, eax        
            _asm fldcw   WORD PTR tempState    

        #endif
        
        #if defined(DBG)
            InterlockedIncrement(&SaveLevel);
        #endif    
    }

    ~FPUStateSaver()
    {
        AssertMode();
        
        #if defined(DBG)
            InterlockedDecrement(&SaveLevel);
        #endif
        
        #if defined(_USE_X86_ASSEMBLY)

            UINT32 savedState = this->SavedState;

            // Clear the exception state.
            // Note: We issue the fwait and then an fnclex - which is equivalent
            // to the fclex instruction (9B DB E2) which causes us to 
            // immediately take any unmasked pending exceptions.
            // Because we clear the exception state on the way in, hitting 
            // an exception on this line means we generated an exception
            // in our code (or a call out to other code between the 
            // FPUStateSaver constructor and destructor nesting) which was 
            // pending and not handled.
            
            _asm fclex
    
            // Restore control word (rounding mode and exception masks):
    
            _asm fldcw   WORD PTR savedState    

        #endif
    }

    // AssertMode.
    //
    // AssertMode does nothing in Free builds, unless the FREE_BUILD_FP_BARRIER
    // define is set to 1. Debug builds always have FP barriers.
    // If exceptions are unmasked and you're getting delayed FP exceptions, 
    // turn on the FP barriers and add FPUStateSaver::AssertMode() calls 
    // bracketing all your calls. This will allow you to isolate the FP 
    // exception generator.
    
    #define FREE_BUILD_FP_BARRIER 0
    
    #if defined(DBG)
        static VOID AssertMode();
    #else
        static VOID AssertMode() 
        {
            #if defined(_USE_X86_ASSEMBLY)
            #if FREE_BUILD_FP_BARRIER
            _asm fwait
            #endif
            #endif
        }
    #endif

    //--------------------------------------------------------------------------
    // The following conversion routines are MUCH faster than the standard
    // C routines, because they assume that the FPU floating point state is
    // properly set.  
    //
    // However, because they assume that the FPU floating point state has been 
    // properly set, they can only be used if an instance of the 
    // 'FPUStateSaver' class is in scope.
    //--------------------------------------------------------------------------
    
    static INT Floor(REAL x)
    {
        AssertMode();
        return((INT) FLOOR(x));
    }
    static INT Trunc(REAL x)
    {
        AssertMode();
        return (x>=0) ? FLOOR(x) : -FLOOR(-x);
    }
    static INT Ceiling(REAL x)
    {
        AssertMode();
        return((INT) -FLOOR(-x));
    }
    static INT Round(REAL x)
    {
        AssertMode();
        return((INT) FLOOR((x) + TOREAL(0.5)));
    }

    // Saturation versions of the above conversion routines. Don't test for
    // equality to INT_MAX because, when converted to floating-point for the
    // comparison, the value is (INT_MAX + 1):

    #define SATURATE(op)                                      \
        static INT op##Sat(REAL x)                            \
        {                                                     \
            return (x >= INT_MIN) ? ((x < INT_MAX) ? op(x)    \
                                                   : INT_MAX) \
                                  : INT_MIN;                  \
        }

    SATURATE(Floor);
    SATURATE(Trunc);
    SATURATE(Ceiling);
    SATURATE(Round);

    #undef SATURATE
};


// FPUStateSandbox
//
// This object is designed to sandbox FPU unsafe code.
// For example, many badly written printer drivers on win9x codebases
// manipulate the FPU state without restoring it on exit. In order to 
// prevent code like that from hosing us, we wrap calls to potentially
// unsafe code (like driver escapes) in an FPUStateSandbox.
// 
// This will guarantee that after calling the unsafe code, the FPU state
// (rounding mode and exceptions) are reset to our preferred state.
// Because we assume that we're restoring to our preferred state, we 
// ASSERT on our preferred state being set on entry. This means that
// the sandbox must be declared inside some top level FPUStateSaver block.
// This condition is not strictly necessary and if there is a requirement
// for an FPUStateSandbox not contained inside an FPUStateSaver, this
// ASSERT can be removed. The sandbox saves the current state and restores
// it on exit, so it can operate outside of our preferred state if required.
//
// So far we've found a number of printer drivers on win9x codebase that
// require sandboxing - e.g. HP4500c pcl.
//
// Couple of caveats: This code is designed to wrap simple calls out of 
// GDI+ to the printer driver, such as Escape. It's not intended to be
// nested or for use with GDI+ code. However, nesting will work. In 
// particular you should not call FPUStateSaver functions inside of 
// an FPUStateSandbox unless you've acquired another nested FPUStateSaver.
// The only anticipated need for this is for sandboxing a callback function
// that calls into our API again. In this case it's ok, because all the 
// GDI+ calls will be wrapped by a nested FPUStateSaver acquired at the 
// API.
//
// NOTE: The ASSERTs in GpRound will not catch the scenario when they're
// called inside of a sandbox and not properly surrounded by a FPUStateSaver.
// GpRound may work incorrectly inside of a sandbox because the unsafe code
// could change the rounding mode. It could also generate exceptions.

class FPUStateSandbox
{
private:

    UINT32 SavedState;

public:

    FPUStateSandbox()
    {
        // it is assumed that this call is issued inside of an 
        // FPUStateSaver block, so that the CTRL word is set to
        // our preferred state.
        
        // Lets not do this ASSERT - turns out that it gets called on the device
        // destructor durning InternalGdiplusShutdown and we don't want to wrap
        // that with an FPUStateSaver.
        
        // FPUStateSaver::AssertMode();
        
        #if defined(_USE_X86_ASSEMBLY)
        
        UINT32 savedState;
        
        // We must protect the sandboxed code from clearing the exception
        // masks and taking an exception generated by GDI+.
        // We do this by issuing fclex - which takes any unmasked exceptions
        // and clears all of the exceptions after that (masked and unmasked)
        // giving the sandboxed code a clean slate.
        
        _asm fclex
        
        // Save control word:
        
        _asm fnstcw  WORD PTR savedState
        this->SavedState = savedState;
        
        #endif
    }

    ~FPUStateSandbox()
    {
        #if defined(_USE_X86_ASSEMBLY)
        
        UINT32 savedState = this->SavedState;
    
        // clear the current exception state.
        // fnclex is a non-wait version of fclex - which means it clears
        // the exceptions without taking any pending unmasked exceptions.
        // We issue an fnclex so that any unmasked exceptions are ignored.
        // This is designed to prevent the sandboxed code from blowing 
        // up in code outside of the sandbox.
            
        _asm fnclex
        
        // Restore control word (rounding mode and exception masks):

        _asm fldcw   WORD PTR savedState    
        
        #endif
    }
};



//--------------------------------------------------------------------------
// The following are simply handy versions that require less typing to
// use (i.e., 'GpFloor(x)' instead of 'FPUStateSaver::Floor(x)').  
//
// These functions require that a version of 'FPUStateSaver' has been 
// instantiated already for the current thread.
//--------------------------------------------------------------------------

inline INT GpFloor(REAL x) { return(FPUStateSaver::Floor(x)); }

inline INT GpTrunc(REAL x) { return(FPUStateSaver::Trunc(x)); }

inline INT GpCeiling(REAL x) { return(FPUStateSaver::Ceiling(x)); }

inline INT GpRound(REAL x) { return(FPUStateSaver::Round(x)); }

inline INT GpFloorSat(REAL x) { return(FPUStateSaver::FloorSat(x)); }

inline INT GpTruncSat(REAL x) { return(FPUStateSaver::TruncSat(x)); }

inline INT GpCeilingSat(REAL x) { return(FPUStateSaver::CeilingSat(x)); }

inline INT GpRoundSat(REAL x) { return(FPUStateSaver::RoundSat(x)); }


/**************************************************************************\
*
* Function Description:
*
*   Return TRUE if two points are close. Close is defined as near enough
*   that the rounding to 32bit float precision could have resulted in the
*   difference. We define an arbitrary number of allowed rounding errors (10).
*   We divide by b to normalize the difference. It doesn't matter which point
*   we divide by - if they're significantly different, we'll return true, and
*   if they're really close, then a==b (almost).
*
* Arguments:
*
*   a, b - input numbers to compare.
*
* Return Value:
*
*   TRUE if the numbers are close enough.
*
* Created:
*
*   12/11/2000 asecchia 
*
\**************************************************************************/

inline BOOL IsCloseReal(const REAL a, const REAL b)
{
    // if b == 0.0f we don't want to divide by zero. If this happens
    // it's sufficient to use 1.0 as the divisor because REAL_EPSILON
    // should be good enough to test if a number is close enough to zero.
    
    // NOTE: if b << a, this could cause an FP overflow. Currently we mask
    // these exceptions, but if we unmask them, we should probably check
    // the divide.
    
    // We assume we can generate an overflow exception without taking down
    // the system. We will still get the right results based on the FPU
    // default handling of the overflow.
    
    #if !(FP_CTRL_STATE & 0x8)
    
    // Ensure that anyone clearing the overflow mask comes and revisits this
    // assumption.
    
    #error #O exception cleared. Go check FP_CTRL_MASKEDEXCEPTIONS.
    
    #endif
    
    FPUStateSaver::AssertMode();
    
    return( REALABS( (a-b) / ((b==0.0f)?1.0f:b) ) < 10.0f*REAL_EPSILON );
}

inline BOOL IsClosePointF(const PointF &pt1, const PointF &pt2)
{
    return (
        IsCloseReal(pt1.X, pt2.X) && 
        IsCloseReal(pt1.Y, pt2.Y)
    );
}



#endif // !_REAL_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\runtime.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   GDI+ runtime initialization
*
* Abstract:
*
*   Initialization and uninitialization functions for the GDI+ run-time.
*
* Revision History:
*
*   09/08/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

HINSTANCE DllInstance;

/**************************************************************************\
*
* Function Description:
*
*   GDI+ run-time initialization function.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   FALSE if failure
*
\**************************************************************************/

BOOL
GpRuntime::Initialize()
{
    OSInfo::Initialize();
    if (!DllInstance)
        DllInstance = GetModuleHandleA(0);

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   GDI+ run-time cleanup function.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRuntime::Uninitialize()
{
}

/**************************************************************************\
*
* Function Description:
*
*   raise to an integer power (up to 
*
* Arguments:
*
*   exp - an integer exponent
*
* Return Value:
*
*   2^exp.  If exp >= 31, then return 2^31.
*
\**************************************************************************/

UINT
GpRuntime::Gppow2 (UINT exp)
{
    UINT maxexp = (sizeof(UINT)*8) - 1;
    UINT rv = 1;

    if (exp >= maxexp)
    {
        return (rv << maxexp); 
    }
    else
    {
        while (exp--)
        {
            rv <<= 1;
        }
    }
    return rv;
}


/**************************************************************************\
*
* Function Description:
*
*   raise to an integer power (up to 
*
* Arguments:
*
*   x - an integer value
*
* Return Value:
*
*   floor of log base 2 of x.  If x = 0, return 0.
*
\**************************************************************************/

UINT
GpRuntime::Gplog2 (UINT x)
{
    UINT rv = 0;
    x >>= 1;
    while (x)
    {
        rv++;
        x >>= 1;
    }
    return rv;
}

/**************************************************************************\
*
* Function Description:
*
*   Moves a block of memory. Handles overlapping cases.
*
* Arguments:
*
*   dest  - The destination buffer
*   src   - The source buffer
*   count - The number of bytes to copy
*
* Return Value:
*
*   dest
*
* Revision History:
*
*   10/22/1999 AGodfrey
*       Wrote it.
*
\******************************************************************************/
void *
GpRuntime::GpMemmove( 
    void *dest,
    const void *src, 
    size_t count )
{
    const BYTE *s = static_cast<const BYTE *>(src);
    BYTE *d = static_cast<BYTE *>(dest);
    
    // Test for the overlapping case we care about - dest is within the source
    // buffer. The other case is handled by the normal loop.
    
    if ((d > s) && (d < s + count))
    {
        d += count;
        s += count;
        while (count)
        {
            *--d = *--s;
            count--;
        }
    }
    else
    {
        while (count)
        {
            *d++ = *s++;
            count--;
        }    
    }        
    
    return dest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\runtime.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   GDI+ runtime
*
* Abstract:
*
*   Definitions for GDI+ run-time library functions.
*   We're not allowed to use the C runtime library in free builds.
*   The GDI+ run-time library provides alternative definitions for the
*   functions we need.
*
*   Users of the GDI+ run-time library must be sure to call
*   GpRuntime::Initialize() and GpRuntime::Uninitialize() appropriately.
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*   09/07/1999 agodfrey
*       Moved to the Runtime directory.
*
\**************************************************************************/

#ifndef _RUNTIME_HPP
#define _RUNTIME_HPP

#include <windows.h>

// math.h is needed for prototypes of the intrinsic math functions
// float.h is needed for FLT_EPSILON

#include <math.h>
#include <float.h>
#include <limits.h>

// DllInstance is initialized by the DLL entry point, or failing that
// by GpRuntime::Initialize();

extern HINSTANCE DllInstance;

// Object tags are used, instead of a BOOL, to determine if the object is
// valid or not.  To be valid, the tag must be equal to the ObjectTag enum.
// For consistency, the Tag field should be the 1st field within the object.
// The last char of each tag must be a 1.  The 1 stands for Version 1.
// [We make it the last character so that it is less likely to be confused
//  with a pointer value (since most pointers are DWORD aligned).]
// This will (hopefully) enable us to distinguish between objects
// that were created by different versions of GDI+.  (Assuming of course
// that we remember to increment that number in the next release of GDI+).
// Please try to keep the object tags unique.
enum ObjectTag
{
    ObjectTagInvalid                = 'LIAF',   // Object in Invalid State

    // external objects
    ObjectTagBrush                  = 'urB1',
    ObjectTagPen                    = 'neP1',
    ObjectTagPath                   = 'htP1',
    ObjectTagRegion                 = 'ngR1',
    ObjectTagImage                  = 'gmI1',
    ObjectTagFont                   = 'tnF1',
    ObjectTagFontFamily             = 'aFF1',
    ObjectTagFontCollection         = 'oCF1',
    ObjectTagStringFormat           = 'rtS1',
    ObjectTagImageAttributes        = 'tAI1',
    ObjectTagCustomLineCap          = 'CLC1',
    ObjectCachedBitmap              = 'mBC1',
    ObjectTagGraphics               = 'arG1',
    ObjectTagMatrix                 = 'taM1',
    ObjectTagPathIterator           = 'IaP1',
    
    // internal objects
    ObjectTagDpBitmap               = 'mBd1',
    ObjectTagDpDriver               = 'rDd1',
    ObjectTagDpRegion               = 'gRd1',
    ObjectTagDpRegionBuilder        = 'BRd1',
    ObjectTagGpRectBuilder          = 'BRg1',
    ObjectTagGpYSpanBuilder         = 'BSg1',
    ObjectTagGpBezier               = 'zBg1',
    ObjectTagGpCubicBezierIterator  = 'IBC1',
    ObjectTagDevice                 = 'veD1',
    ObjectTagPathReconstructor      = 'cRP1',
    ObjectTagPathWidener            = 'dWP1',
    ObjectTagXPath                  = 'aPX1',
    ObjectTagXPathIterator          = 'IPX1',
    ObjectTagDecodedImage           = 'IeD1',
    ObjectTagK2_Tetrahedral         = 'T2K1',
    ObjectTagBitmapScaler           = 'cSB1',
    ObjectTagBmpDecoder             = 'DmB1',
    ObjectTagGifBuffer              = 'BfG1',
    ObjectTagGifOverflow            = 'OfG1',
    ObjectTagCmyk2Rgb               = 'R2C1',
    ObjectTagTiffCodec              = 'CfT1',
    ObjectTagConvertToGdi           = 'GvC1',
    ObjectTagOutputNativePostscript = 'sPO1',
    ObjectTagOutputGradientSpan     = 'SGO1',
    ObjectTagTriangleData           = 'DrT1',
    ObjectTagPaletteMap             = 'MaP1',
    ObjectTagScanBufferNative       = 'NBS1',
    ObjectTagAnsiStrFromUnicode     = 'UFA1',
    ObjectTagUnicodeStrFromAnsi     = 'AFU1',
    ObjectTagEmfPlusCommentStream   = 'SCE1',
    ObjectTagMetafileRecorder       = 'cRM1',
};

#if PROFILE_MEMORY_USAGE
#include "..\..\tools\memcounter\memcounter.h"
#endif

#include "mem.h"
#include "debug.h"

#include "..\..\sdkinc\GdiplusEnums.h"
#include "..\..\sdkinc\GdiplusTypes.h"
#include "..\..\sdkinc\GdiplusInit.h"
#include "..\..\sdkinc\GdiplusPixelFormats.h"
#include "..\..\sdkinc\GdiplusColor.h"
#include "..\..\sdkinc\GdiplusColorMatrix.h"
#include "..\..\sdkinc\GdiplusMetaHeader.h"
#include <objbase.h>
#include "..\..\sdkinc\GdiplusImaging.h"

#include "enums.hpp"

namespace GpRuntime {
    BOOL Initialize();
    void Uninitialize();
};

#include "BaseTypes.hpp"
#include "Lockable.hpp"
#include "Unicode.hpp"
#include "OSInfo.hpp"
#include "Real.hpp"
#include "fix.hpp"
#include "critsec.hpp"
#include "AutoPointers.hpp"

namespace GpRuntime {
    void *GpMemmove(void *dest, const void *src, size_t count);
    UINT Gppow2 (UINT exp);
    UINT Gplog2 (UINT x);
    extern HANDLE GpMemHeap;
};

// TODO: One day when each of our modules has
//       its own namespace, remove this using directive.

using namespace GpRuntime;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\office\mem.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   GDI+ memory allocation functions
*
* Abstract:
*
*   This module is the Office counterpart of runtime\standalone\mem.cpp which
*   provides GpMalloc, GpRealloc and GpFree.
*
*   We use it to provide the stubs for memory management debugging functions
*   that we don't use in office. These stubs prevent compilation errors and
*   serve to keep the header files cleaner.
*
* Notes:
*
*   Office provides their own versions of these functions, so they're not
*   included here.
*
* Created:
*
*   09/19/1999 asecchia
*
\**************************************************************************/

#include "precomp.hpp"

// these guys need to be defined, but they're going to be compiled away.
void GpInitializeAllocFailures() {}
void GpDoneInitializeAllocFailureMode() {}
void GpStartInitializeAllocFailureMode() {}
void GpAssertMemoryLeaks() {}



#if DBG

// We don't track anything if we're building for the office static lib.

#if GPMEM_ALLOC_CHK_LIST

#undef GpMalloc
extern "C" void *GpMalloc(size_t size);

extern "C" void *GpMallocAPIDebug(size_t size, unsigned int caddr, char *fileName, INT lineNumber)
{
    return GpMalloc(size);
}

extern "C" void *GpMallocDebug(size_t size, char *fileName, INT lineNumber)
{

    return GpMalloc(size);
}

#else

extern "C" void * GpMallocAPI( size_t size, unsigned int caddr )
{
    return GpMalloc(size);
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\unicode.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   Unicode strings
*
* Abstract:
*
*   Functions and classes which deal with Unicode strings
*
* Revision History:
*
*   02/22/1999 davidx
*       Created it.
*   09/08/1999 agodfrey
*       Moved to Runtime\unicode.hpp
*
\**************************************************************************/

#ifndef _UNICODE_HPP
#define _UNICODE_HPP

namespace GpRuntime
{
    
// These are replacements for some of the C runtime functions.

size_t  UnicodeStringLength(const WCHAR *str);
WCHAR * UnicodeStringDuplicate(const WCHAR *strSource);
INT     UnicodeStringCompare(const WCHAR *str1, const WCHAR *str2);
extern "C" INT     UnicodeStringCompareCI(const WCHAR *str1, const WCHAR *str2);
INT     UnicodeStringCompareCount(const WCHAR* str1, const WCHAR* str2, size_t count);
INT     UnicodeStringCompareCICount(const WCHAR* str1, const WCHAR* str2, size_t count);
void    UnicodeStringCopy(WCHAR *dest, const WCHAR *src);
void    UnicodeStringCopyCount(WCHAR *dest, const WCHAR *src, size_t count);
void    UnicodeStringToUpper(WCHAR* dest, WCHAR* src);
WCHAR * UnicodeStringConcat(WCHAR *dest, const WCHAR *src);
WCHAR * UnicodeStringReverseSearch(const WCHAR* str, WCHAR ch);
BOOL    UnicodeStringIIsEqual(
    const WCHAR* str1, 
    const WCHAR* str2u, 
    const WCHAR* str2l
    );

inline BOOL
UnicodeToAnsiStr(
    const WCHAR* unicodeStr,
    CHAR* ansiStr,
    INT ansiSize
    )
{
    return WideCharToMultiByte(
                CP_ACP,
                0,
                unicodeStr,
                -1,
                ansiStr,
                ansiSize,
                NULL,
                NULL) > 0;
}

class AnsiStrFromUnicode
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagAnsiStrFromUnicode : ObjectTagInvalid;
    }

public:

    AnsiStrFromUnicode(const WCHAR* unicodeStr)
    {
        if (unicodeStr == NULL)
        {
            SetValid(TRUE);
            ansiStr = NULL;
        }
        else
        {
            SetValid(UnicodeToAnsiStr(unicodeStr, buf, MAX_PATH));
            ansiStr = IsValid() ? buf : NULL;
        }
    }

    ~AnsiStrFromUnicode()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagAnsiStrFromUnicode) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid AnsiStrFromUnicode");
        }
    #endif

        return (Tag == ObjectTagAnsiStrFromUnicode);
    }

    operator CHAR*()
    {
        return ansiStr;
    }

private:

    CHAR* ansiStr;
    CHAR buf[MAX_PATH];
};

inline BOOL
AnsiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
    )
{
    return MultiByteToWideChar(
                CP_ACP,
                0,
                ansiStr,
                -1,
                unicodeStr,
                unicodeSize) > 0;
}

class UnicodeStrFromAnsi
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagUnicodeStrFromAnsi : ObjectTagInvalid;
    }

public:

    UnicodeStrFromAnsi(const CHAR* ansiStr)
    {
        if (ansiStr == NULL)
        {
            SetValid(TRUE);
            unicodeStr = NULL;
        }
        else
        {
            SetValid(AnsiToUnicodeStr(ansiStr, buf, MAX_PATH));
            unicodeStr = IsValid() ? buf : NULL;
        }
    }

    ~UnicodeStrFromAnsi()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagUnicodeStrFromAnsi) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid UnicodeStrFromAnsi");
        }
    #endif

        return (Tag == ObjectTagUnicodeStrFromAnsi);
    }

    operator WCHAR*()
    {
        return unicodeStr;
    }

private:

    WCHAR* unicodeStr;
    WCHAR buf[MAX_PATH];
};

//--------------------------------------------------------------------------
// Represent a simple immutable Unicode string object used internally
// by GDI+ implementation. A string is represented by pieces of
// information:
//  - pointer to the character buffer
//  - number of characters in the string
//
// [agodfrey] Ack! Yet another string class. I'm just moving it here
// to be with its mates. It came from BaseTypes.hpp.
//--------------------------------------------------------------------------

class GpString
{
public:

    // NOTE:
    //  We're not making a copy of the characters here. Instead,
    //  we simply remember the character pointer. We assume the
    //  caller will ensure the input pointer's lifetime is longer
    //  than that of the newly constructed GpString object.

    GpString(const WCHAR* str, UINT len)
    {
        Buf = str;
        Len = len;
    }

    GpString(const WCHAR* str)
    {
        Buf = str;
        Len = UnicodeStringLength(str);
    }

    BOOL IsNull() const
    {
        return Buf == NULL;
    }

    const WCHAR* GetBuf() const
    {
        return Buf;
    }

    UINT GetLen() const
    {
        return Len;
    }

    // Return a copy of the string as a NUL-terminated C string.
    // Caller should call GpFree on the returned pointer after
    // it finishes using the C string.

    WCHAR* GetCString() const;

protected:

    const WCHAR* Buf;
    UINT Len;
};

}


#endif // !_UNICODE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\staticlib\precomp.hpp ===
#include "..\Runtime\Runtime.hpp"
#include "..\Common\Common.hpp"
#include "..\Flat\gpverp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\unicode.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Unicode strings
*
* Abstract:
*
*   Functions and classes which deal with Unicode strings
*
* Revision History:
*
*   12/21/1998 davidx
*       Created it.
*   09/08/1999 agodfrey
*       Moved to Runtime\unicode.hpp, from Common\utils.cpp
*   10/20/1999 agodfrey
*       In order to remove MSVCRT dependencies, I cleaned this up. I
*       moved in Unicode functions that had appeared in Runtime.cpp,
*       then merged the many duplicates.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Returns the length of a Unicode string. A replacement for wcslen.
*
* Arguments:
*
*   str - The input string
*
* Return Value:
*
*   The length of the string.
*
* Revision History:
*
*   09/27/1999 DChinn
*       Wrote it.
*   10/20/1999 AGodfrey
*       Moved to Unicode.cpp
*
\******************************************************************************/
size_t
GpRuntime::UnicodeStringLength(
    const WCHAR *str
    )
{
    size_t strLength = 0;

    // calculate string length in characters
    while (*str++ != '\0')
    {
        strLength++;
    }
    return strLength;
}

/**************************************************************************\
*
* Function Description:
*
*   Appends a Unicode string. A replacement for wcscat.
*
* Arguments:
*
*   dest - Null-terminated destination string
*   src  - Null-terminated source string
*
* Notes:
* 
*   The function appends "src" to "dest" and terminates
*   the resulting string with a null character. The initial character of
*   "src" overwrites the terminating null character of "dest".
*   No overflow checking is performed when strings are copied or appended. The
*   behavior is undefined if the source and destination strings
*   overlap.
*
* Return Value:
*
*   The destination string (dest).
*
* Revision History:
*
*   10/14/1999 MinLiu
*       Wrote it.
*   10/20/1999 AGodfrey
*       Moved it to Unicode.cpp; merged it with the existing concatenation
*       functions.
*
\******************************************************************************/
WCHAR *
GpRuntime::UnicodeStringConcat(
    WCHAR* dest, 
    const WCHAR* src
    )
{
    //  Move to end of dest
    while (*dest != NULL)
        ++dest;
    
    while (*src != NULL)
        *dest++ = *src++;

    //  Terminate destination string
    *dest = NULL;
    
    return dest;
}

/**************************************************************************\
*
* Function Description:
*
*   Duplicates a Unicode string. A replacement for wcsdup.
*
* Arguments:
*
*   src - Null-terminated source string
*
* Notes:
* 
*   Beware - unlike the C wcsdup, this one uses GpMalloc to allocate
*   the memory. The caller must use GpFree to deallocate it.
*
* Return Value:
*
*   A pointer to newly-allocated memory containing a copy of the input
*   string. The caller is responsible for freeing the string (via GpFree.)
*
* Revision History:
*
*   09/27/1999 DChinn
*       Wrote it.
*   10/20/1999 AGodfrey
*       Moved to Unicode.cpp
*
\******************************************************************************/
WCHAR *
GpRuntime::UnicodeStringDuplicate (
    const WCHAR *src
    )
{
    DWORD byteSize;
    WCHAR *ret;

    if (src == NULL)
    {
        ret = NULL;
    }    
    else 
    {
        byteSize = sizeof(WCHAR) * (UnicodeStringLength (src) + 1);
        ret = static_cast<WCHAR *>(GpMalloc (byteSize));
        
        if (ret)
        {
            // do the string copy (src is assumed to be null-terminated)
            GpMemcpy (ret, src, byteSize);
        }
    }        

    return ret;
}

/**************************************************************************\
*
* Function Description:
*
*   Copies a Unicode string. A replacement for wcscpy.
*
* Arguments:
*
*   dest - The destination buffer
*   src  - Null-terminated source string
*
* Return Value:
*
*   None
*
* Revision History:
*
*   10/20/1999 AGodfrey
*       Moved to Unicode.cpp
*
\******************************************************************************/
void 
GpRuntime::UnicodeStringCopy(
    WCHAR* dest, 
    const WCHAR* src
    )
{
    while (*src != NULL)
        *dest++ = *src++;

    //  Terminate destination string
    *dest = NULL;
}


/**************************************************************************\
*
* Function Description:
*
*   Copies a specified number of characters of a Unicode string.
*   A replacement for wcsncpy.
*
* Arguments:
*
*   dest - The destination buffer
*   src  - Null-terminated source string
*   count - number of characters to copy
*
* Return Value:
*
*   None
*
* Revision History:
*
*   03/29/2000 DChinn
*       Wrote it.
*
\******************************************************************************/
void
GpRuntime::UnicodeStringCopyCount(
    WCHAR *dest,
    const WCHAR *src,
    size_t count)
{
    for (UINT i = 0; (i < count) && (*src != NULL); i++)
    {
        *dest++ = *src++;
    }
    // null-pad the remaining characters in dest
    for ( ; i < count; i++)
    {
        *dest++ = 0;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Converts a string to all upper case.
*
*   [dchinn]
*   NOTE: This is naively implemented. It compares a string of character
*         codes, not a string of Unicode characters. You can't rely on:
* 
*   1) Unicode equality. There are apparently different codes representing
*      identical characters; this function doesn't know about them.
*
* Arguments:
*
*   str1 - the first string (input)
*   str2 - the second string (output)
*   str1 and str2 may be the same pointer.
*
* Return Value:
*   none.
*
* Revision History:
*
*   03/24/2000 DChinn
*       Wrote it.
\**************************************************************************/

void 
GpRuntime::UnicodeStringToUpper(
    WCHAR* dest,
    WCHAR* src
    )
{
    WCHAR char1;
    ASSERT(dest && src);
    
    while (*src != NULL)
    {
        char1 = *src;

        // change lower case to uppercase before copying
        if ( (char1 >= L'a') && (char1 <= L'z') )
                char1 = char1 - L'a' + L'A';

        *dest = char1;

        dest++;
        src++;
    }
    //  Terminate destination string
    *dest = NULL;
}


/**************************************************************************\
*
* Function Description:
*
*   Hack reference so that C code can get at UnicodeStringCopy.
*
* Arguments:
*
*   dest - The destination buffer
*   src  - Null-terminated source string
*
* Notes:
* 
*   This is because, although we've standardized on C++, we still
*   have some legacy code. At time of writing, fondrv\tt\ttfd\fd_query.c
*   is the file that needs this.
*
* Revision History:
*
*   10/20/1999 AGodfrey
*       Wrote it.
*
\******************************************************************************/

extern "C" void __cdecl
HackUnicodeStringCopy(
    WCHAR* dest, 
    const WCHAR* src
    )
{
    UnicodeStringCopy(dest, src);
}

/**************************************************************************\
*
* Function Description:
*
*   Searches from the end of a Unicode string for a character.
*   A replacement for wcsrchr.
*
* Arguments:
*
*   str - The string
*   ch  - The character to find
*
* Return Value:
*
*   A pointer into the source string at the location of the character,
*   or NULL if not found. 
*
* Revision History:
*
*   10/22/1999 AGodfrey
*       Wrote it.
*
\******************************************************************************/
WCHAR *
GpRuntime::UnicodeStringReverseSearch(
    const WCHAR* str, 
    WCHAR ch
    )
{
    ASSERT(str);
    
    const WCHAR *result = NULL;
    
    while (*str)
    {
        if (*str == ch)
        {
            result = str;
        }
        str++;
    }
    return const_cast<WCHAR *>(result);
}

/**************************************************************************\
*
* Function Description:
*
*   Compares two wide character strings
*
*   [agodfrey]
*   NOTE: This is naively implemented. It compares a string of character
*         codes, not a string of Unicode characters. You can't rely on:
* 
*   1) Unicode ordering. Alphabetical ordering isn't guaranteed.
*   2) Unicode equality. There are apparently different codes representing
*      identical characters; this function doesn't know about them.
*
* Arguments:
*
*   str1 - the first string
*   str2 - the second string
*
* Return Value:
*   -1:    str1  < str2
*    0:    str1 == str2
*    1:    str1  > str2
*
* Revision History:
*
*   ??/??/???? ??????
*       Wrote it.
*   10/20/1999 AGodfrey
*       Added comment about how this isn't a real Unicode compare.
*
\**************************************************************************/

INT 
GpRuntime::UnicodeStringCompare(
    const WCHAR* str1, 
    const WCHAR* str2
    )
{

    ASSERT(str1 && str2);
    
    while (*str1 != NULL && *str2 != NULL)
    {
        if (*str1 < *str2)
            return -1;
        else if (*str1 > *str2)
            return 1;
        str1++;
        str2++;
    }

    if (*str2 != NULL)
        return -1;

    if (*str1 != NULL)
        return 1;

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Compares two wide character strings
*
*   [agodfrey]
*   NOTE: This is naively implemented. It compares a string of character
*         codes, not a string of Unicode characters. You can't rely on:
* 
*   1) Unicode ordering. Alphabetical ordering isn't guaranteed.
*   2) Unicode equality. There are apparently different codes representing
*      identical characters; this function doesn't know about them.
*
* Arguments:
*
*   str1 - the first string
*   str2 - the second string
*
* Return Value:
*   -1:    str1  < str2
*    0:    str1 == str2
*    1:    str1  > str2
*
* Revision History:
*
*   ??/??/???? ??????
*       Wrote it.
*   10/20/1999 AGodfrey
*       Added comment about how this isn't a real Unicode compare.
*
*   3/08/00 YungT  
*       Added for comparsion ignored case
\**************************************************************************/

INT 
GpRuntime::UnicodeStringCompareCI(
    const WCHAR* str1, 
    const WCHAR* str2
    )
{
    WCHAR char1, char2;
    ASSERT(str1 && str2);
    
    while (*str1 != NULL && *str2 != NULL)
    {
        char1 = *str1;
        char2 = *str2;

        /* change lower case to uppercase before doing the comparaison */
        if ( (char1 >= L'a') && (char1 <= L'z') )
                char1 = char1 - L'a' + L'A';

        if ( (char2 >= L'a') && (char2 <= L'z') )
                char2 = char2 - L'a' + L'A';

        if (char1 < char2)
            return -1;
        else if (char1 > char2)
            return 1;

        str1++;
        str2++;
    }

    if (*str2 != NULL)
        return -1;

    if (*str1 != NULL)
        return 1;

    return 0;
}


/**************************************************************************\
*
* Function Description:
*
*   Compares two wide character strings
*
*   [agodfrey]
*   NOTE: This is naively implemented. It compares a string of character
*         codes, not a string of Unicode characters. You can't rely on:
* 
*   1) Unicode ordering. Alphabetical ordering isn't guaranteed.
*   2) Unicode equality. There are apparently different codes representing
*      identical characters; this function doesn't know about them.
*
* Arguments:
*
*   str1 - the first string
*   str2 - the second string
*   count - Maximum number of characters to consider
*
* Return Value:
*   -1:    str1  < str2
*    0:    str1 == str2
*    1:    str1  > str2
*
* Revision History:
*
*   ??/??/???? ??????
*       Wrote it.
*   10/20/1999 AGodfrey
*       Added comment about how this isn't a real Unicode compare.
*
\**************************************************************************/

INT 
GpRuntime::UnicodeStringCompareCount(
    const WCHAR* str1, 
    const WCHAR* str2,
    size_t count 
    )
{
    ASSERT(str1 && str2);
    
    while (*str1 != NULL && *str2 != NULL  && count)
    {
        if (*str1 < *str2)
            return -1;
        else if (*str1 > *str2)
            return 1;
        str1++;
        str2++;
        count--;
    }

    if (!count)
    {
        return 0;
    }

    if (*str2 != NULL)
        return -1;

    if (*str1 != NULL)
        return 1;

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Compares two wide character strings, sort of case-insensitively for US English characters only
*
*   [agodfrey]
*   NOTE: This is naively implemented. It compares a string of character
*         codes, not a string of Unicode characters. You can't rely on:
* 
*   1) Unicode ordering. Alphabetical ordering isn't guaranteed.
*   2) Unicode equality. There are apparently different codes representing
*      identical characters; this function doesn't know about them.
*   [claudebe]
*   unicode string compare considering only count characters
*
* Arguments:
*
*   str1 - the first string
*   str2 - the second string
*   count - Maximum number of characters to consider
*
* Return Value:
*   -1:    str1  < str2
*    0:    str1 == str2
*    1:    str1  > str2
*
* Revision History:
*
*   ??/??/???? ??????
*       Wrote it.
*   10/20/1999 AGodfrey
*       Added comment about how this isn't a real Unicode compare.
*   01/11/2000 ClaudeBe
*       case insensitive comparison that deal only with Upper\Lower case
*
\**************************************************************************/

INT 
GpRuntime::UnicodeStringCompareCICount(
    const WCHAR* str1, 
    const WCHAR* str2,
    size_t count 
    )
{
    WCHAR char1, char2;
    ASSERT(str1 && str2);
    
    while (*str1 != NULL && *str2 != NULL  && count)
    {
        char1 = *str1;
        char2 = *str2;
        /* change lower case to uppercase before doing the comparaison */
        if ( (char1 >= L'a') && (char1 <= L'z') )
                char1 = char1 - L'a' + L'A';

        if ( (char2 >= L'a') && (char2 <= L'z') )
                char2 = char2 - L'a' + L'A';

        if (char1 < char2)
            return -1;
        else if (char1 > char2)
            return 1;
        str1++;
        str2++;
        count--;
    }

    if (!count)
    {
        return 0;
    }

    if (*str2 != NULL)
        return -1;

    if (*str1 != NULL)
        return 1;

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Hack: C version of strncmp for the font code.
*
* Arguments:
*
*   str1  - The first string
*   str2  - The second string
*   count - Maximum number of characters to consider
*
* Return Value:
*   -1:    str1  < str2
*    0:    str1 == str2
*    1:    str1  > str2
*
* Notes:
* 
*   At time of writing, fondrv\tt\ttfd\fdfon.c is the file that needs this.
*
* Revision History:
*
*   10/22/1999 AGodfrey
*       Wrote it.
*
\******************************************************************************/

extern "C" int __cdecl 
HackStrncmp( 
    const char *str1, 
    const char *str2, 
    size_t count 
    ) 
{
    ASSERT(str1 && str2);
    
    while (*str1 && *str2 && count)
    {
        if (*str1 < *str2)
        {
            return -1;
        }
        if (*str1 > *str2)
        {
            return 1;
        }
        str1++;
        str2++;
        count--;
    }
    if (!count)
    {
        return 0;
    }
    if (*str2)
    {
        return -1;
    }
    if (*str1)
    {
        return 1;
    }
    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Compares two wide character strings, case-insensitively. To avoid
*   Unicode case issues, you specify both the upper and lower-case versions
*   of the string you want to compare against.
*
* Arguments:
*
*   str1:  the first string
*   str2u: the second string, in upper case
*   str2l: the second string, in lower case
*
* Notes:
*   str2u and str2l must be the same length.
*
* Return Value:
*
*   TRUE if the strings are equal, FALSE otherwise.
*
* Revision History:
*
*   10/22/1999 AGodfrey
*       Wrote it.
*
\**************************************************************************/

BOOL 
GpRuntime::UnicodeStringIIsEqual(
    const WCHAR* str1, 
    const WCHAR* str2u, 
    const WCHAR* str2l
    )
{
    ASSERT(str1 && str2u && str2l);
    
    while (*str1 && *str2u)
    {
        ASSERT(*str2l);
        
        if ((*str1 != *str2u) &&
            (*str1 != *str2l))
        {
            return FALSE;
        }
        str1++;
        str2u++;
        str2l++;
    }

    if (*str1)
    {
        return FALSE;
    }
    
    if (*str2u)
    {
        return FALSE;
    }
    
    ASSERT(!*str2l);

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Return a copy of the string as a NUL-terminated C string.
*   Caller should call GpFree on the returned pointer after
*   it finishes using the C string.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   See above.
*
\**************************************************************************/

WCHAR*
GpRuntime::GpString::GetCString() const
{
    WCHAR* s;

    if (Buf == NULL)
        s = NULL;
    else if (s = (WCHAR*) GpMalloc((Len+1)*sizeof(WCHAR)))
    {
        GpMemcpy(s, Buf, Len*sizeof(WCHAR));
        s[Len] = L'\0';
    }
    else
    {
        WARNING(("Out of memory in GpString::GetCString()"));
    }

    return s;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\staticlib\staticflat.h ===
/**************************************************************************\
*
* Copyright (c) 2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   StaticFlat.h
*
* Abstract:
*
*   Flat GDI+ API wrappers for the static lib
*
* Revision History:
*
*   3/23/2000 dcurtis
*       Created it.
*
\**************************************************************************/

#ifndef _STATICFLAT_H
#define _STATICFLAT_H

#define WINGDIPAPI __stdcall

// currently, only C++ wrapper API's force const.

#ifdef _GDIPLUS_H
#define GDIPCONST const
#else
#define GDIPCONST
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
}
#endif

#endif // !_STATICFLAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\sources.inc ===
!include ..\..\..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\staticlib\staticflatapi.cpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   StaticFlatApi.cpp
*
* Abstract:
*
*   Flat GDI+ API wrappers for the static lib
*
* Revision History:
*
*   3/23/2000 dcurtis
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "StaticFlat.h"

#if DBG
#include <mmsystem.h>
#endif


// GillesK
// Forward declaration of GdipGetWinMetaFileBitsStub which is in
// gpmf3216
#ifdef __cplusplus
extern "C" {
#endif

//--------------------------------------------------------------------------
//  CheckParameter(p)
//
//     If p evaluates to FALSE, then we currently assert.  In future,
//     we can simply return an invalid parameter status which throws
//     an exception.
//
//  CheckObjectBusy(p)
//
//     Not implemented.  Bails out if object is currently being used.
//
//--------------------------------------------------------------------------
//
// !!!: Only include NULL & IsValid checks in checked builds?
//
// !!!: Instead of deleting object, call a Dispose() method, so far
//       only Bitmap supports this.
//
// !!!: Lock Matrix objects, what about color?

#define CheckParameter(cond) \
            if (! (cond)) \
                return InvalidParameter;

#define CheckParameterValid(obj) \
            if (!obj || !(obj->IsValid())) \
                return InvalidParameter;

#define CheckObjectBusy(obj) \
      GpLock lock##obj(obj->GetObjectLock()); \
      if (!(lock##obj).IsValid()) \
            return ObjectBusy;

#define CheckFontParameter(font) \
            if (!(font) || !((font)->IsValid())) \
                return InvalidParameter;


#ifdef __cplusplus
} // end of extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\runtime\standalone\mem.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   GDI+ memory allocation functions
*
* Abstract:
*
*   This module provides GpMalloc, GpRealloc and GpFree.
*
* Notes:
*
*   Office provides their own versions of these functions.
*
* Created:
*
*   07/08/1999 agodfrey
*
\**************************************************************************/

#include "precomp.hpp"



#if GPMEM_ALLOC_CHK

#include <time.h>
#include <stdlib.h>

// Size of the start and end memory guards (DWORDS)
// Probably should be QWORD aligned (even number).

const unsigned int GPMEM_GUARD_START = 0x10;
const unsigned int GPMEM_GUARD_END   = 0x10;
const unsigned int GPMEM_GS = GPMEM_GUARD_START*sizeof(DWORD);
const unsigned int GPMEM_GE = GPMEM_GUARD_END*sizeof(DWORD);

const unsigned char GPMEM_FILL_ALLOC = 0xbf;
const unsigned char GPMEM_FILL_GS    = 0xac;
const unsigned char GPMEM_FILL_GE    = 0xfe;
const unsigned char GPMEM_FILL_FREE  = 0x73;

#define GPMEM_ALLOC_TRACKING 1
#define GPMEM_ALLOC_FILL     1

enum AllocTrackHeaderFlags
{
    MemoryAllocated     = 0x00000001,
    MemoryFreed         = 0x00000002,     // useful in catching double frees
    APIAllocation       = 0x00000004
};
// Head of every tracked allocation.

struct AllocTrackHeader {
  struct AllocTrackHeader *flink;
  struct AllocTrackHeader *blink;
  DWORD  size;
  DWORD  caller_address;
  DWORD  flags;
#if GPMEM_ALLOC_CHK_LIST
  char  *callerFileName;
  INT    callerLineNumber;
#endif
};

#define GPMEM_OVERHEAD (GPMEM_GS + GPMEM_GE + sizeof(AllocTrackHeader))

// Head of double linked list of tracked memory allocations.

AllocTrackHeader *gpmemAllocList=NULL;

// An allocation fails if rand() < gpmemDefFailRate (gpmemInitFailRate for
// gdiplus initialization code.
// set to RAND_MAX/2 if you want 50% failure rate, 0 if you want no failures.
//
// The system starts off failing allocations at a rate specified by
// gpmemInitFailRate. Once GpDoneInitializeAllocFailureMode() is called,
// allocations are failed at the rate specified by gpmemDefFailRate().
// This is so that dll initialization code can have a different fail rate
// to regular code.

int gpmemInitFailRate = 0;
int gpmemDefFailRate = 0;

// This would give a failure rate of 25%
// int gpmemDefFailRate = (RAND_MAX/4)

BOOL gpmemDoneInitialization = FALSE;

// Some statistics
struct AllocTrackStats {
  // Totals over the entire run

  long CumulativeAllocations;   // The number of calls to GpMalloc or GpRealloc
  long CumulativeMemorySize;    // Cumulative total of allocated memory
  long CumulativeReallocs;      // The number of calls to GpRealloc
  long ForcedFailures;
  long AllocationFailures;

  // Current values

  long OutstandingAllocations;  // The number of allocation requests
  long OutstandingMemorySize;   // The amount of memory currently allocated

  // Maxima of the 'Outstanding' values

  long MaxAllocations;          // The maximum of OutstandingAllocations
  long MaxMemorySize;           // The maximum of OutstandingMemorySize

  void Allocated(long size)
  {
      size -= GPMEM_OVERHEAD;

      CumulativeMemorySize += size;
      OutstandingMemorySize += size;
      if (OutstandingMemorySize > MaxMemorySize)
      {
          MaxMemorySize = OutstandingMemorySize;
      }
      CumulativeAllocations++;
      OutstandingAllocations++;
      if (OutstandingAllocations > MaxAllocations)
      {
          MaxAllocations = OutstandingAllocations;
      }
  }

  void Freed(long size)
  {
      size -= GPMEM_OVERHEAD;

      OutstandingMemorySize -= size;
      OutstandingAllocations--;
  }
};

AllocTrackStats gpmemAllocTotal = {0};


// Hash Table for tracking memory allocations sorted by callsite.
// This table stores some total memory usage statistics for each
// callsite.
// Turn this on by setting GPMEM_DEBUG_SORT 1

#define GPMEM_DEBUG_SORT 0
#if GPMEM_DEBUG_SORT

struct HashMem {
  long callsite;
  long size;
  long count;
};

// It is very important that this hash size be larger than the number of
// possible callsites for GpMalloc.
//
// Set HASHSIZE to some big prime number.

#define HASHSIZE 1069
HashMem HashTable[HASHSIZE];

// Hashing algorithm.
long Hash(long cs) {
  long tmp = cs % HASHSIZE;
  long tmploop = tmp;
  while( (HashTable[tmp].callsite != 0) &&
         (HashTable[tmp].callsite != cs) ) {
    tmp++;
    if(tmp>=HASHSIZE) tmp=0;
    if(tmp==tmploop) return -1;
  }
  return tmp;
}
#endif

#endif



/**************************************************************************\
*
* Function Description:
*
*   Do we fail this memory allocation?
*
* Arguments: [NONE]
* Return Value: [NONE]
*
* History:
*
*   09/20/1999 asecchia
*       Created it.
*
\**************************************************************************/


#if GPMEM_ALLOC_CHK
BOOL GpFailMemoryAllocation() {
  int rndnum = rand();
  if(gpmemDoneInitialization)
  {
      if(rndnum<gpmemDefFailRate)
      {
          return TRUE;
      }
  }
  else
  {
    if(rndnum<gpmemInitFailRate)
    {
        return TRUE;
    }
  }
  return FALSE;
}
#endif

/**************************************************************************\
*
* Function Description:
*
*   Initializes the random seed.
*
* Arguments: [NONE]
* Return Value: [NONE]
*
* History:
*
*   09/20/1999 asecchia
*       Created it.
*
\**************************************************************************/

void GpInitializeAllocFailures() {
  #if GPMEM_ALLOC_CHK
  srand((unsigned)time(NULL));
  #endif
}


/**************************************************************************\
*
* Function Description:
*
*   Sets the flag indicating that we're done initialization code and
*   we're now into regular code. The memory failure mode changes based
*   on the value of this flag.
*
* Arguments: [NONE]
* Return Value: [NONE]
*
* History:
*
*   09/20/1999 asecchia
*       Created it.
*
\**************************************************************************/

void GpDoneInitializeAllocFailureMode() {
  #if GPMEM_ALLOC_CHK
  gpmemDoneInitialization=TRUE;
  #endif
}

void GpStartInitializeAllocFailureMode() {
  #if GPMEM_ALLOC_CHK
  gpmemDoneInitialization=FALSE;
  #endif
}




/**************************************************************************\
*
* Function Description:
*
*   Asserts that there are no memory leaks. Called just before process
*   termination, the list of allocated memory blocks should be NULL indicating
*   that all allocated memory was properly disposed. Any memory that relies on
*   process termination to clean up is leaked and provision should be made
*   for appropriate cleanup.
*
* Arguments: [NONE]
* Return Value: [NONE]
*
* History:
*
*   09/19/1999 asecchia
*       Created it.
*
\**************************************************************************/


#if GPMEM_ALLOC_CHK_LIST
char *skipGdiPlus(char *s) {
    // Quick hack to return pointer just beyond 'gdiplus'

    INT i = 0;
    while (    s[i] != 0
           &&  (    s[i] != 'g' &&  s[i] != 'G'
                ||  CompareStringA(
                        LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                        s+i, 7,
                        "gdiplus", 7) != CSTR_EQUAL))
    {
        i++;
    }
    if (    CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, s+i, 7, "gdiplus", 7) == CSTR_EQUAL
        &&  s[i+7] != 0)
    {
        return s + i + 8;   // Skip over 'gdiplus/'
    }
    else
    {
        return s; // Didn't find gdiplus so return the whole string
    }
}
#endif


void GpAssertMemoryLeaks() {
  #if GPMEM_ALLOC_CHK
  // If we're playing with the tracking headers, we need to be thread safe.
  GpMallocTrackingCriticalSection critsecobj;


  #if GPMEM_ALLOC_CHK_LIST

  // Report up to 100 leaked headers

  if (gpmemAllocList)
  {
      INT i=0; INT j=0;
      AllocTrackHeader *header = gpmemAllocList;
      while (header  && j < 100)
      {
          if (i % 20 == 0)  // Title every so often
          {
              WARNING(("Address- --Size-- API -Caller- -Line- File"));
          }

          // Drop everything up to 'gdiplus' off the filename string

          char str[200];
          lstrcpynA(str, skipGdiPlus(header->callerFileName), 200);

          WARNING((
              "%p %8d %-3.3s %p %6d %s",
              header,
              header->size,
              header->flags & APIAllocation ? "API" : "",
              header->caller_address,
              header->callerLineNumber,
              str
          ));
          header = header->flink;

          i++; j++;
      }
  }
  #endif


  ASSERTMSG(gpmemAllocList==NULL,
           ("Memory leaks detected. Use !gpexts.dmh 0x%p to dump header",
            gpmemAllocList));


  // Display the report stored in the Hash Table
  #if GPMEM_DEBUG_SORT
  for(int i=0; i<HASHSIZE; i++) {
    if(HashTable[i].callsite != 0) {
      WARNING(("%4d callsite %p size %8d count %8d", i, HashTable[i].callsite,
               HashTable[i].size, HashTable[i].count));
    }
  }
  #endif

  #endif
}




/**************************************************************************\
*
* Function Description:
*
*   Allocates a block of memory.
*
* Arguments:
*
*   [IN] size - number of bytes to allocate
*
* Return Value:
*
*   A pointer to the new block, or NULL on failure.
*
* History:
*
*   09/14/1999 asecchia
*       Added the checked build memory guard code.
*   07/08/1999 agodfrey
*       Created it.
*
\**************************************************************************/

/*
Here's the structure of the memory block allocated under GPMEM_ALLOC_CHK

|+AllocTrackHeader Two DWORDS - contains
|  |+flink
|  |  Pointer to the next memory allocation in the tracked allocation list
|  |+blink
|  |  Pointer to the previous memory allocation in the tracked allocation link
|
|+Guard Area
|  GPMEM_GUARD_START DWORDs filled with the gpmemGuardFill string.
|
|+Data Area
|  This is the location we return to the caller. It is pre-initialized to
|  the repeated DWORD value in gpmemAllocFillBlock (usually 0xbaadf00d)
|
|+Guard Area:
|  GPMEM_GUARD_END DWORDs filled with gpmemGuardFill string.

*/


#if GPMEM_ALLOC_CHK_LIST
extern "C" void *GpMallocDebug(size_t size, char *fileName, INT lineNumber)
#else
extern "C" void *GpMalloc(size_t size)
#endif
{

    #if GPMEM_ALLOC_CHK
        // If we're playing with the tracking headers, we need to be thread safe.
        GpMallocTrackingCriticalSection critsecobj;

        // Lets stash the caller address in the header block for future
        // reference.
        // this code needs to be at the beginning of the function so that
        // ebp hasn't been modified yet.
        DWORD calleraddr=0;
        #if defined(_X86_)
        _asm{
          mov eax, DWORD PTR [ebp+4]
          mov calleraddr, eax
        }
        #endif

        //
        // Memory? _Real_ programmers don't need memory!
        //
        if(GpFailMemoryAllocation()) {
            gpmemAllocTotal.AllocationFailures++;
            gpmemAllocTotal.ForcedFailures++;
            return NULL;
        }

        //
        // Make the allocation request a multiple of a QWORD
        //
        if(size & (sizeof(DWORD)*2-1))
        {
          size = (size & ~(sizeof(DWORD)*2-1)) + sizeof(DWORD)*2;
        }

        size_t origsize = size;

        //
        // Allocate space for the FLink and BLink
        //
        size += sizeof(AllocTrackHeader);

        if(GPMEM_GUARD_START)
        {
          size += GPMEM_GS;
        }

        if(GPMEM_GUARD_END)
        {
          size += GPMEM_GE;
        }

        void *tmpalloc = LocalAlloc(LMEM_FIXED, size);
        if(!tmpalloc)
        {
            gpmemAllocTotal.AllocationFailures++;
            return NULL;
        }

        ASSERTMSG(LocalSize(tmpalloc) >= size,
                  ("GpMalloc() allocated %d, but requested %d bytes",
                   LocalSize(tmpalloc), size));

        // Add the per-callsite allocation statistics
        #if GPMEM_DEBUG_SORT
        long hidx = Hash(calleraddr);
        if(hidx>=0) {
            HashTable[hidx].callsite = calleraddr;
            HashTable[hidx].size += size-GPMEM_OVERHEAD;
            HashTable[hidx].count ++;
        } else {
          WARNING(("Hash Table too small - increase HASHSIZE"));
        }
        #endif

        gpmemAllocTotal.Allocated(size);
    #else
        //
        // This is the only piece of code that's executed if
        // GPMEM_ALLOC_CHK is turned off.
        //
        return LocalAlloc(LMEM_FIXED, size);
    #endif


    #if GPMEM_ALLOC_CHK
        //
        // Fill up the entire allocation with the value
        // set in GPMEM_FILL_ALLOC
        //
        if(GPMEM_ALLOC_FILL)
        {
            GpMemset((unsigned char *)tmpalloc + sizeof(AllocTrackHeader) + GPMEM_GS,
                     GPMEM_FILL_ALLOC,
                     origsize);
        }

        //
        // Fill up the start guard area - if we have one.
        //
        if(GPMEM_GUARD_START)
        {
            unsigned char *p = (unsigned char *)tmpalloc+sizeof(AllocTrackHeader);
            GpMemset(p, GPMEM_FILL_GS, GPMEM_GS);
        }

        //
        // Fill up the end guard area - if we have one.
        //
        if(GPMEM_GUARD_END)
        {
            unsigned char *p = (unsigned char *)tmpalloc+size-GPMEM_GE;
            GpMemset(p, GPMEM_FILL_GE, GPMEM_GE);
        }

        //
        // setup the double linked-list to track all pool allocations.
        //
        AllocTrackHeader *hdr = (AllocTrackHeader *)tmpalloc;
        hdr->size = size;
        hdr->caller_address = calleraddr;
        hdr->flags = MemoryAllocated;

        #if GPMEM_ALLOC_CHK_LIST
        hdr->callerFileName = fileName;
        hdr->callerLineNumber = lineNumber;
        #endif

        if(GPMEM_ALLOC_TRACKING)
        {
            hdr->blink = NULL;
            hdr->flink = gpmemAllocList;
            if(gpmemAllocList)
            {
                gpmemAllocList->blink = (AllocTrackHeader *)tmpalloc;
            }
            gpmemAllocList = (AllocTrackHeader *)tmpalloc;
        }
        else
        {
            GpMemset(hdr, 0, sizeof(AllocTrackHeader));
        }

        //
        // Give them a pointer just after the guard bits.
        //
        return (char *)tmpalloc+sizeof(AllocTrackHeader)+GPMEM_GS;
    #endif
}

/**************************************************************************\
*
* Function Description:
*    Allocates memory for routines that allocate on behalf of someone else
*    Used on debug builds to set the correct caller address.
*
* Arguments:
*    [IN] size - size to pass to GpMalloc
*    [IN] caddr - address of the caller
*
* Return Value:
*    Returns the memory with the appropriately hacked up caller address
*
* History:
*
*   12/08/1999 asecchia
*       Created it.
*
\**************************************************************************/

#if GPMEM_ALLOC_CHK
extern "C" void *GpMallocC(size_t size, DWORD caddr)
{
    // If we're playing with the tracking headers, we need to be thread safe.
    GpMallocTrackingCriticalSection critsecobj;

    void *p = GpMalloc(size);
    if(p)
    {
        AllocTrackHeader *hdr = (AllocTrackHeader *)(
            (unsigned char *)p-(GPMEM_GS+sizeof(AllocTrackHeader)));
        hdr->caller_address = caddr;
    }
    return p;
}
#endif

/**************************************************************************\
*
* Function Description:
*    Allocates memory for APIs. Used to track the memory with a separate
*    identifying flag so that API allocations can be distinguished from
*    internal allocations.
*    Used on debug builds.
*
* Arguments:
*    [IN] size - size to pass to GpMalloc
*
* Return Value:
*    Returns the memory with the appropriately hacked up caller address
*
* History:
*
*   4/30/2000 asecchia
*       Created it.
*
\**************************************************************************/

#if DBG
#if GPMEM_ALLOC_CHK

#if GPMEM_ALLOC_CHK_LIST
extern "C" void * __stdcall GpMallocAPIDebug(size_t size, unsigned int caddr, char *fileName, INT lineNumber)
#else
extern "C" void *GpMallocAPI(size_t size, unsigned int caddr)
#endif
{
    // If we're playing with the tracking headers, we need to be thread safe.
    GpMallocTrackingCriticalSection critsecobj;

    #if GPMEM_ALLOC_CHK_LIST
    void *p = GpMallocDebug(size, fileName, lineNumber);
    #else
    void *p = GpMalloc(size);
    #endif

    if(p)
    {
        AllocTrackHeader *hdr = (AllocTrackHeader *)(
            (unsigned char *)p-(GPMEM_GS+sizeof(AllocTrackHeader)));
        hdr->flags |= APIAllocation;
        hdr->caller_address = caddr;
    }
    return p;
}

#else

extern "C" void *GpMallocAPI(size_t size, DWORD caddr)
{
    return GpMalloc(size);
}

#endif
#endif

/**************************************************************************\
*
* Function Description:
*
*   Computes the original size of a memory block allocated under GPMEM_ALLOC_CHK
*
* Arguments:
*
*   [IN] p - current memory block
*
* Return Value:
*
*   size of the original request for a memory block (i.e. excluding guard
*   areas, headers, etc). The size returned is the DWORD aligned size - so it
*   may differ slighly from the original size requested.
*
* Notes:
*
*   Returns a size of zero if called with NULL
*   Only compiled under GPMEM_ALLOC_CHK
*
* History:
*
*   09/14/1999 asecchia
*       Created it.
*
\**************************************************************************/

#if GPMEM_ALLOC_CHK
extern "C" size_t GpSizeBlock(void *p)
{
  if(p)
  {
      // Find the beginning of the allocated block header.
      p = (char *)p-(GPMEM_GS+sizeof(AllocTrackHeader));
      // Compute the size of the allocated block's data area.
      return (((AllocTrackHeader *)p)->size -
              (GPMEM_GS+GPMEM_GE+sizeof(AllocTrackHeader)));
  }
  else
  {
      return 0;
  }
}
#else
// Non-debug build, just call LocalSize
#define GpSizeBlock(p) LocalSize(p)
#endif


/**************************************************************************\
*
* Function Description:
*
*   Reallocates a memory block.
*
* Arguments:
*
*   [IN] memblock - current memory block
*   [IN] size - new allocation size
*
* Return Value:
*
*   A pointer to the new block, or NULL on failure.
*
* Notes:
*
*   If size is 0, frees the block.
*   If memblock is NULL, allocates a new block.
*   (If both, does nothing.)
*
*   LocalReAlloc only grows if it can expand the current allocation
*   - otherwise it fails.
*
* History:
*
*   09/14/1999 asecchia
*       Added the checked build memory guard code.
*   07/08/1999 agodfrey
*       Created it.
*
\**************************************************************************/

// Hack up GpMalloc for debug version of GpRealloc
#if GPMEM_ALLOC_CHK
    #define GpMallocForRealloc(a) GpMallocC(a, calleraddr)
#else
    #define GpMallocForRealloc(a) GpMalloc(a)
#endif

extern "C" void *GpRealloc(void *memblock, size_t size)
{
    #if GPMEM_ALLOC_CHK
    gpmemAllocTotal.CumulativeReallocs++;

    // Lets stash the caller address in the header block for future
    // reference.
    // this code needs to be at the beginning of the function so that
    // ebp hasn't been modified yet.
    DWORD calleraddr=0;
    #if defined(_X86_)
    _asm {
      mov eax, DWORD PTR [ebp+4]
      mov calleraddr, eax
    }
    #endif
    #endif

    if (!size)
    {
        GpFree(memblock);
        return NULL;
    }
    if (!memblock)
    {
        return GpMallocForRealloc(size);
    }
    VOID *  p = GpMallocForRealloc(size);
    if (p != NULL)
    {
        size_t oldSize = GpSizeBlock(memblock);

        if (oldSize > size)
        {
            oldSize = size;
        }
        GpMemcpy(p, memblock, oldSize);
        GpFree(memblock);
    }
    return p;
}

// UnHack GpMalloc
#undef GpMalloc
/**************************************************************************\
*
* Function Description:
*
*   Frees a block of memory.
*
* Arguments:
*
*   [IN] memblock - block to free
*
* Notes:
*
*   If memblock is NULL, does nothing.
*
* History:
*
*   09/14/1999 asecchia
*       Added the checked build memory guard code.
*   07/08/1999 agodfrey
*       Created it.
*
\**************************************************************************/

extern "C" void GpFree(void *memblock)
{
    #if GPMEM_ALLOC_CHK
        // If we're playing with the tracking headers, we need to be thread safe.
        GpMallocTrackingCriticalSection critsecobj;

        if(memblock)
        {
            memblock = (unsigned char *)memblock-(GPMEM_GS+sizeof(AllocTrackHeader));


            // Let's do the header stuff.

            AllocTrackHeader *hdr = (AllocTrackHeader *)memblock;
            DWORD size = hdr->size;
            gpmemAllocTotal.Freed(size);

            ASSERTMSG((hdr->flags & MemoryAllocated) &&
                      !(hdr->flags & MemoryFreed),
                      ("GpFree() already freed memory %p (freed by GpFree())",
                       memblock));

            hdr->flags &= ~MemoryAllocated;
            hdr->flags |= MemoryFreed;

            ASSERTMSG(LocalSize(memblock) >= hdr->size,
                      ("GpFree() already freed memory %p (freed somewhere else?)"
                       " local size=%d, size=%d",
                       memblock,
                       LocalSize(memblock),
                       hdr->size));

            if(GPMEM_ALLOC_TRACKING)
            {
                // Useful on checked Win2k builds because they fill guard
                // area with 0xFEEEFEEE

                ASSERTMSG((hdr->flink == NULL) ||
                          ((DWORD)((ULONG_PTR)(hdr->flink->blink) & 0xFFFFFFFF) != 0xFEEEFEEE),
                          ("GpFree() updating forward link to freed page, header %p",
                           memblock));

                ASSERTMSG((hdr->blink == NULL) ||
                          ((DWORD)((ULONG_PTR)(hdr->blink->flink) & 0xFFFFFFFF) != 0xFEEEFEEE),
                          ("GpFree() updating backward link to freed page, header %p",
                           memblock));

                if(hdr->flink) hdr->flink->blink = hdr->blink;
                if(hdr->blink) hdr->blink->flink = hdr->flink;
                if(gpmemAllocList==memblock) gpmemAllocList = hdr->flink;
            }
            else
            {
                ASSERTMSG(hdr->flink==NULL, ("GpFree() corrupt header %p", memblock));
                ASSERTMSG(hdr->blink==NULL, ("GpFree() corrupt header %p", memblock));
            }

            int i;
            unsigned char *p;

            // Check the start guard area

            if(GPMEM_GUARD_START)
            {
                p = (unsigned char *)memblock+sizeof(AllocTrackHeader);
                for(i=0; i<GPMEM_GS; i++)
                {
                    ASSERTMSG(*p==GPMEM_FILL_GS, ("GpFree() pre-guard area corrupt %p", memblock));
                    p++;
                }
            }

            // Check the end guard area

            if(GPMEM_GUARD_END)
            {
                p = (unsigned char *)memblock+size-GPMEM_GE;
                for(i=0; i<GPMEM_GE; i++)
                {
                    ASSERTMSG(*p==GPMEM_FILL_GE, ("GpFree() post-guard area corrupt %p", memblock));
                    p++;
                }
            }

            // Now lets fill the entire block with something to prevent
            // use of free data.

            GpMemset(memblock, GPMEM_FILL_FREE, size);
        }

    #endif

    // LocalFree handles memblock==NULL (according to MSDN.)

    HLOCAL ret = LocalFree(memblock);
    ASSERTMSG(ret == NULL, ("LocalFree() failed at %p, GetLastError()=%08x",
                            memblock,
                            GetLastError()));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\break.hpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   Character breaking classes
*
* Revision History:
*
*   03/14/2000  Worachai Chaoweeraprasit (wchao)
*       Created it.
*
\**************************************************************************/


#ifndef _BREAK_HPP_
#define _BREAK_HPP_




//  Character context type
enum BreakType
{
    BreakWord     = 0,
    BreakCluster  = 1
};



class Break
{
public:
    Break() :
        Attributes  (NULL)
    {}

    Break(
        SCRIPT_LOGATTR  *breakAttributes,
        INT             length
    )
    {
        Attributes = (SCRIPT_LOGATTR *)GpMalloc(sizeof(SCRIPT_LOGATTR) * length);

        if (Attributes)
        {
            GpMemcpy (Attributes, breakAttributes, sizeof(SCRIPT_LOGATTR) * length);
        }
    }

    ~Break()
    {
        if (Attributes)
        {
            GpFree(Attributes);
        }
    }


    //  Querying functions

    BOOL IsWordBreak (INT position)
    {
        return     (Attributes[position].fCharStop && Attributes[position].fWordStop)
                || Attributes[position].fWhiteSpace;
    }

    BOOL IsClusterBreak (INT position)
    {
        return     Attributes[position].fCharStop
                || Attributes[position].fWhiteSpace;
    }

private:
    SCRIPT_LOGATTR  *Attributes;    // Array of break attributes
};


#endif  // _BREAK_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\bidianalysis.cpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   Unicode Bidirectional character analysis
*
* Abstract:
*
*   Implements Unicode version 3.0 Bidirectional algorithm
*
* Notes:
*
*   - The only API that should be expored is UnicodeBidiAnalyze().
*     The rest are all helper functions.
*
* Revision History:
*
*   02/25/2000 Mohamed Sadek [msadek]
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#define EMBEDDING_LEVEL_INVALID     62
#define PARAGRAPH_TERMINATOR_LEVEL  0xFF
#define POSITION_INVALID            -1

#define IS_STRONG_CLASS(x)      (CharacterProperties[0][(x)])
#define IS_STRONG_OR_NUMBER(x)  (CharacterProperties[1][(x)])
#define IS_FIXED_CLASS(x)       (CharacterProperties[2][(x)])
#define IS_FINAL_CLASS(x)       (CharacterProperties[3][(x)])
#define IS_NUMBER_CLASS(x)      (CharacterProperties[4][(x)])
#define IS_VALID_INDEX_CLASS(x) (CharacterProperties[5][(x)])
#ifndef MAX
    #define MAX(x,y)            (((x) > (y)) ? (x) : (y))
#endif
#ifndef MIN
    #define MIN(x,y)            (((x) < (y)) ? (x) : (y))
#endif

#define LSHIFTU64(x,y)          (((UINT64)(x)) << (y))
#define SET_BIT(x,y)            (((UINT64)(x)) |= LSHIFTU64(1,y))
#define RESET_BIT(x,y)          (((UINT64)(x)) &= ~LSHIFTU64(1,y))
#define IS_BIT_SET(x,y)         (((UINT64)(x)) & LSHIFTU64(1,y))

#define F FALSE
#define T TRUE
BOOL CharacterProperties[][CLASS_MAX - 1] =
{
                     // L   R   AN  EN  AL  ES  CS  ET  NSM BN  N   B   LRE LRO RLE RLO PDF S   WS  ON
   /*STRONG*/           T,  T,  F,  F,  T,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,
   /*STRONG/NUMBER*/    T,  T,  T,  T,  T,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,
   /*FIXED*/            T,  T,  T,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,
   /*FINAL*/            T,  T,  T,  T,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,
   /*NUMBER*/           F,  F,  T,  T,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,
   /*VALID INDEX*/      T,  T,  T,  T,  T,  T,  T,  T,  T,  T,  T,  F,  F,  F,  F,  F,  F,  F,  F,  F,
};

// Paragraph base directionality

enum GpBaseLevel
{
    BaseLevelLeft = 0,
    BaseLevelRight = 1
};


// Bidirectional override classification

enum GpOverrideClass
{
    OverrideClassNeutral,
    OverrideClassLeft,
    OverrideClassRight
};

// Neutrals and Weeks finite state machine actions
// Note that action names are not so accurate as some of
// the actions are used in other contexts.

enum GpStateMachineAction
{
    ST_ST,      // Strong followed by strong
    ST_ET,      // ET followed by Strong
    ST_NUMSEP,  // Number followed by sperator follwed by strong
    ST_N,       // Neutral followed by strong
    SEP_ST,     // Strong followed by sperator
    CS_NUM,     // Number followed by CS
    SEP_ET,     // ET followed by sperator
    SEP_NUMSEP, // Number follwed by sperator follwed by number
    SEP_N,      // Neutral followed by sperator
    ES_AN,      // Arabic Number followed by European sperator
    ET_ET,      // European terminator follwed by a sperator
    ET_NUMSEP,  // Number followed by sperator followed by ET
    ET_EN,      // European number follwed by European terminator
    ET_N,       // Neutral followed by European Terminator
    NUM_NUMSEP, // Number followed by sperator followed by number
    NUM_NUM,    // Number followed by number
    EN_L,       // Left followed by EN
    EN_AL,      // AL followed by EN
    EN_ET,      // ET followed by EN
    EN_N,       // Neutral followed by EN
    BN_ST,      // ST followed by BN
    NSM_ST,     // ST followed by NSM
    NSM_ET,     // ET followed by NSM
    N_ST,       // ST followed by neutral
    N_ET,       // ET followed by neutral
};

// Neutrals and Weeks finite state machine states

enum GpStateMachineState
{
    S_L,        // Left character
    S_AL,       // Arabic letter
    S_R,        // Right character
    S_AN,       // Arabic number
    S_EN,       // European number
    S_ET,       // Europen terminator
    S_ANfCS,    // Arabic number followed by common sperator
    S_ENfCS,    // European number followed by common sperator
    S_N,        // Neutral character
};

GpStateMachineAction Action[][11] =
{
    //          L          R          AN          EN          AL         ES          CS          ET         NSM         BN        N
    /*S_L*/     ST_ST,     ST_ST,     ST_ST,      EN_L,       ST_ST,     SEP_ST,     SEP_ST,     CS_NUM,    NSM_ST,     BN_ST,    N_ST,
    /*S_AL*/    ST_ST,     ST_ST,     ST_ST,      EN_AL,      ST_ST,     SEP_ST,     SEP_ST,     CS_NUM,    NSM_ST,     BN_ST,    N_ST,
    /*S_R*/     ST_ST,     ST_ST,     ST_ST,      ST_ST,      ST_ST,     SEP_ST,     SEP_ST,     CS_NUM,    NSM_ST,     BN_ST,    N_ST,
    /*S_AN*/    ST_ST,     ST_ST,     ST_ST,      NUM_NUM,    ST_ST,     ES_AN,      CS_NUM,     CS_NUM,    NSM_ST,     BN_ST,    N_ST,
    /*S_EN*/    ST_ST,     ST_ST,     ST_ST,      NUM_NUM,    ST_ST,     CS_NUM,     CS_NUM,     ET_EN,     NSM_ST,     BN_ST,    N_ST,
    /*S_ET*/    ST_ET,     ST_ET,     ST_ET,      EN_ET,      ST_ET,     SEP_ET,     SEP_ET,     ET_ET,     NSM_ET,     BN_ST,    N_ET,
    /*S_ANfCS*/ ST_NUMSEP, ST_NUMSEP, NUM_NUMSEP, ST_NUMSEP,  ST_NUMSEP, SEP_NUMSEP, SEP_NUMSEP, ET_NUMSEP, SEP_NUMSEP, BN_ST,    N_ST,
    /*S_ENfCS*/ ST_NUMSEP, ST_NUMSEP, ST_NUMSEP,  NUM_NUMSEP, ST_NUMSEP, SEP_NUMSEP, SEP_NUMSEP, ET_NUMSEP, SEP_NUMSEP, BN_ST,    N_ST,
    /*S_N*/     ST_N,      ST_N,      ST_N,       EN_N,       ST_N,      SEP_N,      SEP_N,      ET_N,      NSM_ET,     BN_ST,    N_ET
};

GpStateMachineState NextState[][11] =
{
    //          L          R          AN          EN          AL         ES          CS          ET         NSM         BN       N
    /*S_L*/     S_L,       S_R,       S_AN,       S_EN,       S_AL,      S_N,        S_N,        S_ET,      S_L,        S_L,     S_N,
    /*S_AL*/    S_L,       S_R,       S_AN,       S_AN,       S_AL,      S_N,        S_N,        S_ET,      S_AL,       S_AL,    S_N,
    /*S_R*/     S_L,       S_R,       S_AN,       S_EN,       S_AL,      S_N,        S_N,        S_ET,      S_R,        S_R,     S_N,
    /*S_AN*/    S_L,       S_R,       S_AN,       S_EN,       S_AL,      S_N,        S_ANfCS,    S_ET,      S_AN,       S_AN,    S_N,
    /*S_EN*/    S_L,       S_R,       S_AN,       S_EN,       S_AL,      S_ENfCS,    S_ENfCS,    S_EN,      S_EN,       S_EN,    S_N,
    /*S_ET*/    S_L,       S_R,       S_AN,       S_EN,       S_AL,      S_N,        S_N,        S_ET,      S_ET,       S_ET,    S_N,
    /*S_ANfCS*/ S_L,       S_R,       S_AN,       S_EN,       S_AL,      S_N,        S_N,        S_ET,      S_N,        S_ANfCS, S_N,
    /*S_ENfCS*/ S_L,       S_R,       S_AN,       S_EN,       S_AL,      S_N,        S_N,        S_ET,      S_N,        S_ENfCS, S_N,
    /*S_N*/     S_L,       S_R,       S_AN,       S_EN,       S_AL,      S_N,        S_N,        S_ET,      S_N,        S_N,     S_N,
};

BYTE ImplictPush [][4] =
{
    //        L,  R,  AN, EN

    /*even*/  0,  1,  2,  2,
    /*odd*/   1,  0,  1,  1,

};

/**************************************************************************\
*
* Function Description:
*
*   GpBiDiStack::Init()
*
*   Initializes the stack with inital value
*
* Arguments:
*
*    [IN] initialStack :
*         Represntation of the initial stack as 64 bit array
*
* Return Value:
*
*   TRUE if successful, otherwize FALSE.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

BOOL
GpBiDiStack::Init (
    UINT64 initialStack                       // [IN]
    )
{
    BYTE    currentStackLevel = GetMaximumLevel(initialStack);
    BYTE    minimumStackLevel = GetMinimumLevel(initialStack);

    if((currentStackLevel >= EMBEDDING_LEVEL_INVALID) ||
      (minimumStackLevel < 0))
    {
        return FALSE;
    }
    m_Stack = initialStack;
    m_CurrentStackLevel = currentStackLevel;

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   GpBiDiStack::Push()
*
*   Pushs the stack with the new value which must be the current value
*   plus either one or two.
*
* Arguments:
*
*    [IN] pushToGreaterEven :
*         Specifies if the stack should be push to the next greater odd
*         or even level.
*
* Return Value:
*
*   FALSE if overflow occured, otherwize TRUE.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

BOOL
GpBiDiStack::Push(
    BOOL pushToGreaterEven                    // [IN]
    )
{
    BYTE newMaximumLevel = pushToGreaterEven ? GreaterEven(m_CurrentStackLevel) :
                           GreaterOdd(m_CurrentStackLevel);

    if(newMaximumLevel >= EMBEDDING_LEVEL_INVALID)
    {
        return FALSE;
    }
    SET_BIT(m_Stack, newMaximumLevel);
    m_CurrentStackLevel = newMaximumLevel;

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   GpBiDiStack::Pop()
*
*   Pushs the stack with the new value which must be the current value
*   plus either one or two.
*
* Arguments:
*
*    NONE
*
* Return Value:
*
*   FALSE if underflow occured, otherwize TRUE.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

BOOL
GpBiDiStack::Pop()
{
    BYTE newMaximumLevel;
    if(0 == m_CurrentStackLevel ||
        ((1 == m_CurrentStackLevel) && !(m_Stack & 1)))
    {
        return FALSE;
    }
    newMaximumLevel = IS_BIT_SET(m_Stack, (m_CurrentStackLevel -1)) ?
                      (BYTE)(m_CurrentStackLevel - 1) : (BYTE)(m_CurrentStackLevel - 2);

    RESET_BIT(m_Stack, m_CurrentStackLevel);
    m_CurrentStackLevel = newMaximumLevel;

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   GpBiDiStack::GetMaximumLevel()
*
*   Gets the stack maximum level.
*
* Arguments:
*
*    [IN] stack:
*         Represntation of the stack as 64 bit array.
*
* Return Value:
*
*   Stack maximum level.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

BYTE
GpBiDiStack::GetMaximumLevel(
    UINT64 stack                              // [IN]
    )
{
    BYTE maximumLevel = 0 ;

    for(INT counter = ((sizeof(UINT64) * 8) -1); counter >= 0; counter--)
    {
        if(IS_BIT_SET(stack, counter))
        {
            maximumLevel = (BYTE)counter;
            break;
        }
    }

    return maximumLevel;
}

/**************************************************************************\
*
* Function Description:
*
*   GpBiDiStack::GetMinimumLevel()
*
*   Gets the stack minimum level.
*
* Arguments:
*
*    [IN] stack:
*         Represntation of the stack as 64 bit array.
*
* Return Value:
*
*   Stack minimum level.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

BYTE
GpBiDiStack::GetMinimumLevel(
    UINT64 stack                              // [IN]
    )
{
    BYTE minimumLevel = 0xFF ;
    for (INT counter =0; counter < sizeof(UINT64); counter++)
    {
        if(IS_BIT_SET(stack, counter))
        {
            minimumLevel = (BYTE)counter;
            break;
        }
    }

    return minimumLevel;
}

/**************************************************************************\
*
* Function Description:
*
*   ResolveImplictLevels()
*
*   As the name describes.
*
* Arguments:
*
*    [IN] characterClass:
*         Array containing character classifications.
*
*    [IN] string:
*         Array containing character string.
*         used to get information about original classification
*
*    [IN] runLength:
*         Length of array passed.
*
*    [IN / OUT] levels:
*         Array containing character character levels.
*
* Return Value:
*
*    NONE.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/
VOID
ResolveImplictLevels(
    const GpCharacterClass *characterClass,   // [IN]
    const WCHAR            *string,           // [IN]
    INT                     runLength,        // [IN]
    BYTE                   *levels            // [IN / OUT]

)
{
    if((NULL == characterClass) || (0 == runLength) || (NULL == levels))
    {
        return;
    }

    BOOL PreviousIsSSorPS = FALSE;
    BOOL ResetLevel       = FALSE;
    DoubleWideCharMappedString dwchString(string, runLength);

    for (INT counter = runLength -1; counter >= 0; counter--)
    {
        // We should only be getting a final class here.
        // We should have catched this earlier but anyway...

        ASSERTMSG(IS_FINAL_CLASS(characterClass[counter]),
        ("Cannot have unresolved classes during implict levels resolution"));




        if((S == s_aDirClassFromCharClass[CharClassFromCh(dwchString[counter])]) ||
           (B == s_aDirClassFromCharClass[CharClassFromCh(dwchString[counter])]))
        {
            PreviousIsSSorPS = TRUE;
            ResetLevel = TRUE;
        }
        else if((WS == s_aDirClassFromCharClass[CharClassFromCh(dwchString[counter])]) &&
                PreviousIsSSorPS)
        {
            ResetLevel = TRUE;
        }
        else
        {
            PreviousIsSSorPS = FALSE;
            ResetLevel = FALSE;
        }

        if(IS_FINAL_CLASS(characterClass[counter]) && !ResetLevel)
        {
            levels[counter] = (BYTE)((ImplictPush[ODD(levels[counter])][characterClass[counter]]) + levels[counter]);
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   GetFirstStrongCharacter()
*
*   Finds the first character before the first paragraph terminator.
*   That is strong (L, R or AL)
*
* Arguments:
*
*    [IN] string:
*         Array containing characters to be searched.
*
*    [IN] runLength:
*         Length of array passed.
*
*    [OUT] strongClass:
*         Classification of the strong character found(if any).
*
* Return Value:
*
*    TRUE if successful, otherwize FALSE.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

BOOL
GetFirstStrongCharacter(
    const WCHAR      *string,                 // [IN]
    INT               stringLength,           // [IN]
    GpCharacterClass *strongClass             // [OUT]
    )
{
    GpCharacterClass currentClass = CLASS_INVALID;
    DoubleWideCharMappedString dwchString(string, stringLength);

    for(INT counter = 0; counter < stringLength; counter++)
    {
        currentClass = s_aDirClassFromCharClass[CharClassFromCh(dwchString[counter])];

        if(IS_STRONG_CLASS(currentClass) || (B == currentClass))
        {
            break;
        }
    }
    if(IS_STRONG_CLASS(currentClass))
    {
        *strongClass = currentClass;
        return TRUE;
    }
    return FALSE;
}

/**************************************************************************\
*
* Function Description:
*
*   ChangeType()
*
*   Changes the classification type of a string.
*
*
* Arguments:
*
*    [IN / OUT] characterClass:
*         Array containing character classifications.
*
*    [IN] count:
*         Length of array passed.
*
*    [IN] newClass:
*         New classification to change to.
*
* Return Value:
*
*    NONE.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

VOID
ChangeType(
    GpCharacterClass       *characterClass,   // [IN / OUT]
    INT                     count,            // [IN]
    GpCharacterClass        newClass          // [IN]
)
{
    if((NULL == characterClass) || (0 == count))
    {
        return;
    }

    for(INT counter = 0; counter < count; counter++)
    {
        // We should never be changing a fixed type here

        ASSERTMSG(!IS_FIXED_CLASS(characterClass[counter]),
                 ("Changing class of a fixed class"));
        characterClass[counter] = newClass;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   ResolveNeutrals()
*
*   As the name describes.
*
*
* Arguments:
*
*    [IN / OUT] characterClass:
*         Array containing character classifications.
*
*    [IN] count:
*         Length of array passed.
*
*    [IN] startClass:
*         Classification of the last strong character preceding
*         the neutrals run.
*
*    [IN] startClass:
*         Classification of the first strong character following
*         the neutrals run.
*
*    [IN] runLevel:
*         Current run level to be used in case of conflict.
*
* Return Value:
*
*    NONE.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

VOID
ResolveNeutrals(
    GpCharacterClass       *characterClass,   // [IN / OUT]
    INT                     count,            // [IN]
    GpCharacterClass        startClass,       // [IN]
    GpCharacterClass        endClass,         // [IN]
    BYTE                    runLevel          // [IN]
)
{
    GpCharacterClass        startType;
    GpCharacterClass        endType;
    GpCharacterClass        resolutionType;

    if((NULL == characterClass) || (0 == count))
    {
        return;
    }

    ASSERTMSG((IS_STRONG_OR_NUMBER(startClass)) || (AL == startClass),
             ("Cannot use non strong type to resolve neutrals"));

    ASSERTMSG(IS_STRONG_OR_NUMBER(endClass),
             ("Cannot use non strong type to resolve neutrals"));

    startType =  ((EN == startClass) || (AN == startClass) || (AL == startClass)) ? R : startClass;
    endType =  ((EN == endClass) || (AN == endClass) || (AL == endClass)) ? R : endClass;

    if(startType == endType)
    {
        resolutionType = startType;
    }
    else
    {
        resolutionType = ODD(runLevel) ? R : L;
    }

    for(INT counter = 0; counter < count; counter++)
    {
        // We should never be changing a fixed type here

        ASSERTMSG(!IS_FIXED_CLASS(characterClass[counter]),
                 ("Resolving fixed class as being neutral: %i",
                  characterClass[counter]));

        characterClass[counter] = resolutionType;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   ResolveNeutralAndWeak()
*
*   As the name describes.
*
*
* Arguments:
*
*    [IN / OUT] characterClass:
*         Array containing character classifications.
*
*    [IN] runLength:
*         Length of array passed.
*
*    [IN] sor:
*         Classification of the last strong character preceding
*         the neutrals run.
*
*    [IN] eor:
*         Classification of the first strong character following
*         the neutrals run.
*
*    [IN] runLevel:
*         Current run level.
*
*    [IN] ,[OPTIONAL] stateIn :
*         Provides state information when continuing from a previous call
*
*    [OUT] ,[OPTIONAL] stateOut :
*         A pointer to BiDiAnalysisState structure to save sate
*         information for a possible upcoming call
*
*    [IN] ,[OPTIONAL] previousStrongIsArabic :
*         Assume that we have an AL as the last strong character in the pervious run
*         Should affect only EN -> AN rule
*
* Return Value:
*
*    If 'incompleteRun', the length of the run minus the number of characters
*    at the end of the run that could not be resolved (as they requires a
*    look ahead. Otherwise, the length of array passed.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

INT
ResolveNeutralAndWeak(
    GpCharacterClass        *CharacterClass,        // [IN / OUT]
    INT                      runLength,             // [IN]
    GpCharacterClass         sor,                   // [IN]
    GpCharacterClass         eor,                   // [IN]
    BYTE                     runLevel,              // [IN]
    const BidiAnalysisState *stateIn,               // [IN], [OPTIONAL]
    BidiAnalysisState       *stateOut,              // [OUT], [OPTIONAL]
    BOOL                     previousStrongIsArabic // [IN], OPTIONAL
)
{
    INT                      startOfNeutrals = POSITION_INVALID;
    INT                      startOfDelayed = POSITION_INVALID;
    GpCharacterClass         lastClass = CLASS_INVALID;
    GpCharacterClass         lastStrongClass = CLASS_INVALID;
    GpCharacterClass         lastNumericClass = CLASS_INVALID;
    GpCharacterClass         startingClass = CLASS_INVALID;
    GpCharacterClass         currentClass = CLASS_INVALID;
    GpStateMachineState      state;
    BOOL                     previousClassIsArabic = FALSE;
    BOOL                     ArabicNumberAfterLeft = FALSE;
    INT                      lengthResolved = 0;

    if(NULL == CharacterClass || 0 == runLength)
    {
        return 0;
    }

    if(stateIn)
    {
        lastStrongClass = (GpCharacterClass)stateIn->LastFinalCharacterType;
        if(CLASS_INVALID != stateIn->LastNumericCharacterType)
        {
            lastNumericClass = startingClass =
                               lastClass =
                               (GpCharacterClass)stateIn->LastNumericCharacterType;
        }
        else
        {
            startingClass = lastClass = lastStrongClass;
        }

    }
    else if(previousStrongIsArabic)
    {
        startingClass = AL;
        lastClass = lastStrongClass = sor;
        previousClassIsArabic = TRUE;
    }
    else
    {
        startingClass = lastClass = lastStrongClass = sor;
    }
    switch(startingClass)
    {
    case R:
        state = S_R;
        break;

    case AL:
        state = S_AL;
        break;

    case EN:
        state = S_EN;
        break;

    case AN:
        state = S_AN;
        break;

    case L:
    default:
        state = S_L;
    }


    // We have two types of classes that needs delayed resolution:
    // Neutrals and other classes such as CS, ES, ET, BN, NSM that needs look ahead.
    // We keep a separate pointer for the start of neutrals and another pointer
    // for the those other classes (if needed since its resolution might be delayed).
    // Also, we need the last strong class for neutral resolution and the last
    // general class (that is not BN or MSM) for NSM resolution.

    // The simple idea of all actions is that we always resolve neutrals starting
    // from 'startOfNeutrals' and when we are sure about delayed weak type
    // resolution, we resolve it starting from 'startOfDelayed' else we point by
    // 'startOfNeutrals' as resolve it as neutral.

    for(INT counter = 0; counter < runLength; counter++)
    {
        currentClass = CharacterClass[counter];

        // We index action and next state table by class.
        // If we got a calss that should have been resolved already or a bogus
        // value, return what we were able to resolve so far.

        if(!IS_VALID_INDEX_CLASS(currentClass))
        {
            return lengthResolved;
        }
        GpStateMachineAction action = Action[state][currentClass];

        // Need to record last numeric type so that when
        // we continue from a previous call, we can correctly resolve something
        // like L AN at the end of the first call and EN at the start of the
        // next call.

        if(IS_NUMBER_CLASS(currentClass))
        {
            lastNumericClass = currentClass;
        }

        // If we have previousClassIsArabic flag set, we need its eefect to
        // last only till the first strong character in the run.

        if(IS_STRONG_CLASS(currentClass))
        {
            previousClassIsArabic = FALSE;
        }
        switch(action)
        {
        case ST_ST:
            ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                      ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            if(AL == currentClass)
            {
                CharacterClass[counter] = R;
            }
            if(POSITION_INVALID != startOfDelayed)
            {
                startOfNeutrals = startOfDelayed;
                ResolveNeutrals(CharacterClass + startOfNeutrals,
                                counter -  startOfNeutrals,
                                ArabicNumberAfterLeft ? AN : lastStrongClass,
                                CharacterClass[counter],
                                runLevel);
                startOfNeutrals = startOfDelayed = POSITION_INVALID;
            }
            if((AN != currentClass) || ((AN == currentClass) && (lastStrongClass == R)))
            {
                lastStrongClass = currentClass;
            }
            if((AN == currentClass) && (lastStrongClass == L))
            {
                ArabicNumberAfterLeft = TRUE;
            }
            else
            {
                ArabicNumberAfterLeft = FALSE;
            }
            lastClass = currentClass;
            break;

        case ST_ET:
            ASSERTMSG(POSITION_INVALID != startOfDelayed,
                     ("Must have delayed weak classes. State: %i, Class: %i",
                      state,currentClass));

            if(POSITION_INVALID == startOfNeutrals)
            {
               startOfNeutrals =  startOfDelayed;
            }
            if(AL == currentClass)
            {
                CharacterClass[counter] = R;
            }
            ResolveNeutrals(CharacterClass + startOfNeutrals,
                            counter -  startOfNeutrals,
                            ArabicNumberAfterLeft ? AN : lastStrongClass,
                            CharacterClass[counter],
                            runLevel);
            startOfNeutrals = startOfDelayed = POSITION_INVALID;

            if((AN != currentClass) || ((AN == currentClass) && (lastStrongClass == R)))
            {
                lastStrongClass = currentClass;
            }
            if((AN == currentClass) && (lastStrongClass == L))
            {
                ArabicNumberAfterLeft = TRUE;
            }
            else
            {
                ArabicNumberAfterLeft = FALSE;
            }
            lastClass = currentClass;
            break;

        case ST_NUMSEP:
            {
            ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            ASSERTMSG(POSITION_INVALID != startOfDelayed,
                     ("Must have delayed weak classes. State: %i, Class: %i",
                      state,currentClass));
            BOOL processed = FALSE;

            if(AL == currentClass)
            {
                CharacterClass[counter] = R;
            }
            if(((AL == lastStrongClass) || previousClassIsArabic) && ((EN == currentClass) || (AN == currentClass)))
            {
                CharacterClass[counter] = AN;
                BOOL commonSeparator = TRUE;
                INT  commonSeparatorCount = 0;

                for(int i = startOfDelayed; i < counter; i++)
                {
                    if((CS != *(CharacterClass + i)) && (BN != *(CharacterClass + i)))
                    {
                        commonSeparator=FALSE;
                        break;
                    }
                    if(CS == *(CharacterClass + i))
                    {
                        commonSeparatorCount++;
                    }

                }
                if(commonSeparator && (1 == commonSeparatorCount))
                {
                    ChangeType(CharacterClass + startOfDelayed,
                               counter -  startOfDelayed,
                               CharacterClass[counter]);
                    processed = TRUE;
                }
            }
            else if((L == lastStrongClass) && (EN == currentClass))
            {
                CharacterClass[counter] = L;
            }
            if(!processed)
            {
                startOfNeutrals =  startOfDelayed;

                ResolveNeutrals(CharacterClass + startOfNeutrals,
                                counter -  startOfNeutrals,
                                ArabicNumberAfterLeft ? AN : lastStrongClass,
                                CharacterClass[counter],
                                runLevel);
            }

            startOfNeutrals = startOfDelayed = POSITION_INVALID;

            if((AN != currentClass) || ((AN == currentClass) && (lastStrongClass == R)))
            {
                if(!(((L == lastStrongClass) || (AL == lastStrongClass)) && (EN == currentClass)))
                {
                    lastStrongClass = currentClass;
                }
            }
            if((AN == currentClass) && (lastStrongClass == L))
            {
                ArabicNumberAfterLeft = TRUE;
            }
            else
            {
                ArabicNumberAfterLeft = FALSE;
            }
            
            lastClass = currentClass;
            if (CharacterClass[counter] == AN)
            {
                currentClass = AN;
            }
            }

            break;

        case ST_N:
            ASSERTMSG(POSITION_INVALID != startOfNeutrals,
                     ("Must have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            if(AL == currentClass)
            {
                CharacterClass[counter] = R;
            }
            ResolveNeutrals(CharacterClass + startOfNeutrals,
                            counter -  startOfNeutrals,
                            ArabicNumberAfterLeft ? AN : lastStrongClass,
                            CharacterClass[counter],
                            runLevel);
            startOfNeutrals = startOfDelayed = POSITION_INVALID;

            if((AN != currentClass) || ((AN == currentClass) && (lastStrongClass == R)))
            {
                lastStrongClass = currentClass;
            }
            if((AN == currentClass) && (lastStrongClass == L))
            {
                ArabicNumberAfterLeft = TRUE;
            }
            else
            {
                ArabicNumberAfterLeft = FALSE;
            }
            lastClass = currentClass;


            break;

        case EN_N:
            ASSERTMSG(POSITION_INVALID != startOfNeutrals,
                     ("Must have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            if((AL == lastStrongClass) || previousClassIsArabic)
            {
                CharacterClass[counter] = AN;
                currentClass            = AN; 
            }
            else if(L == lastStrongClass)
            {
                CharacterClass[counter] = L;
            }
            ResolveNeutrals(CharacterClass + startOfNeutrals,
                            counter -  startOfNeutrals,
                            ArabicNumberAfterLeft ? AN : lastStrongClass,
                            CharacterClass[counter],
                            runLevel);
            startOfNeutrals = startOfDelayed = POSITION_INVALID;
            ArabicNumberAfterLeft = FALSE;

            lastClass = currentClass;
            break;

        case SEP_ST:
            ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            if(POSITION_INVALID != startOfDelayed)
            {
                startOfNeutrals = startOfDelayed;
                startOfDelayed = POSITION_INVALID;
            }
            else
            {
                startOfNeutrals = counter;
            }
            lastClass = currentClass;
            break;

        case CS_NUM:
            ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            if(POSITION_INVALID == startOfDelayed)
            {
                startOfDelayed = counter;
            }
            lastClass = currentClass;
            break;

        case SEP_ET:
            ASSERTMSG(POSITION_INVALID != startOfDelayed,
                     ("Must have delayed weak classes. State: %i, Class: %i",
                      state,currentClass));

            if(POSITION_INVALID == startOfNeutrals)
            {
                startOfNeutrals = startOfDelayed;
            }
            startOfDelayed = POSITION_INVALID;
            lastClass = N;
            break;

        case SEP_NUMSEP:
            ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            ASSERTMSG(POSITION_INVALID != startOfDelayed,
                     ("Must have delayed weak classes. State: %i, Class: %i",
                      state,currentClass));

            startOfNeutrals = startOfDelayed;
            startOfDelayed = POSITION_INVALID;
            lastClass = N;
            break;

        case SEP_N:
            ASSERTMSG(POSITION_INVALID != startOfNeutrals,
                     ("Must have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            startOfDelayed = POSITION_INVALID;
            break;

        case ES_AN:
            ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            if(POSITION_INVALID != startOfDelayed)
            {
                startOfNeutrals = startOfDelayed;
                startOfDelayed = POSITION_INVALID;
            }
            else
            {
                startOfNeutrals = counter;
            }
            lastClass = N;
            break;

        case ET_ET:
            ASSERTMSG(POSITION_INVALID != startOfDelayed,
                     ("Must have delayed weak classes. State: %i, Class: %i",
                      state,currentClass));
            ASSERTMSG(ET == lastClass,
                     ("Last class must be ET. State: %i, Class: %i",
                      state,currentClass));
            break;

        case ET_NUMSEP:
            ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            ASSERTMSG(POSITION_INVALID != startOfDelayed,
                     ("Must have delayed weak classes. State: %i, Class: %i",
                      state,currentClass));

            startOfNeutrals = startOfDelayed;
            startOfDelayed = counter;
            lastClass = currentClass;
            break;

        case ET_EN:
            if(POSITION_INVALID == startOfDelayed)
            {
                startOfDelayed = counter;
            }
            if(!((AL == lastStrongClass) || previousClassIsArabic))
            {
                if(L == lastStrongClass)
                {
                    CharacterClass[counter] = L;
                }
                else
                {
                    CharacterClass[counter] = EN;
                }
                ChangeType(CharacterClass + startOfDelayed,
                           counter -  startOfDelayed,
                           CharacterClass[counter]);
            startOfDelayed = POSITION_INVALID;
            }
            lastClass = EN;

            // According to the rules W4, W5, and W6 If we have a sequence EN ET ES EN 
            // we should treat ES as ON
            
            if ( counter<runLength-1        && 
                (CharacterClass[counter+1] == ES ||
                 CharacterClass[counter+1] == CS ))
            {
                CharacterClass[counter+1]  = N;
            }
            
            break;

        case ET_N:
            ASSERTMSG(POSITION_INVALID != startOfNeutrals,
                     ("Must have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            if(POSITION_INVALID == startOfDelayed)
            {
                startOfDelayed = counter;
            }
            lastClass = currentClass;
            break;

        case NUM_NUMSEP:
            ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            ASSERTMSG(POSITION_INVALID != startOfDelayed,
                     ("Must have delayed weak classes. State: %i, Class: %i",
                      state,currentClass));

            if((AL == lastStrongClass) || previousClassIsArabic || ArabicNumberAfterLeft)
            {
                CharacterClass[counter] = AN;
            }
            else if(L == lastStrongClass)
            {
                CharacterClass[counter] = L;
            }
            else
            {

                lastStrongClass = currentClass;
            }
            ChangeType(CharacterClass + startOfDelayed,
                        counter -  startOfDelayed,
                        CharacterClass[counter]);

            startOfDelayed = POSITION_INVALID;
            lastClass = currentClass;
            break;

       case EN_L:
           ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

           if(L == lastStrongClass)
           {
               CharacterClass[counter] = L;
           }
           if(POSITION_INVALID != startOfDelayed)
           {
               startOfNeutrals = startOfDelayed;
               ResolveNeutrals(CharacterClass + startOfNeutrals,
                               counter -  startOfNeutrals,
                               ArabicNumberAfterLeft ? AN : lastStrongClass,
                               CharacterClass[counter],
                               runLevel);
               startOfNeutrals = startOfDelayed = POSITION_INVALID;
           }
           lastClass = currentClass;

           break;

       case NUM_NUM:
           ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

           if((AL == lastStrongClass) || previousClassIsArabic)
           {
               CharacterClass[counter] = AN;
               currentClass            = AN;
           }
           else if(L == lastStrongClass)
           {
               CharacterClass[counter] = L;

           }

           if(POSITION_INVALID != startOfDelayed)
           {
               startOfNeutrals = startOfDelayed;
               ResolveNeutrals(CharacterClass + startOfNeutrals,
                               counter -  startOfNeutrals,
                               ArabicNumberAfterLeft ? AN : lastStrongClass,
                               CharacterClass[counter],
                               runLevel);
               startOfNeutrals = startOfDelayed = POSITION_INVALID;
           }

           if((AN == currentClass) && (lastStrongClass == L))
           {
               ArabicNumberAfterLeft = TRUE;
           }
           else
           {
               ArabicNumberAfterLeft = FALSE;
           }
           lastClass = currentClass;

           break;

       case EN_AL:
           ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

           CharacterClass[counter] = AN;
           if(POSITION_INVALID != startOfDelayed)
           {
               startOfNeutrals = startOfDelayed;
               ResolveNeutrals(CharacterClass + startOfNeutrals,
                               counter -  startOfNeutrals,
                               ArabicNumberAfterLeft ? AN : lastStrongClass,
                               CharacterClass[counter],
                               runLevel);
               startOfNeutrals = startOfDelayed = POSITION_INVALID;
           }
           lastClass = AN;
           break;

       case EN_ET:
           ASSERTMSG(POSITION_INVALID != startOfDelayed,
                     ("Must have delayed weak classes. State: %i, Class: %i",
                      state,currentClass));

           if((AL == lastStrongClass) || previousClassIsArabic)
           {
               CharacterClass[counter] = AN;
               currentClass = AN;

               if(POSITION_INVALID == startOfNeutrals)
               {
                   ResolveNeutrals(CharacterClass + startOfDelayed,
                                   counter -  startOfDelayed,
                                   ArabicNumberAfterLeft ? AN : lastStrongClass,
                                   CharacterClass[counter],
                                   runLevel);
               }
               else
               {
                   ResolveNeutrals(CharacterClass + startOfNeutrals,
                                   counter -  startOfNeutrals,
                                   ArabicNumberAfterLeft ? AN : lastStrongClass,
                                   CharacterClass[counter],
                                   runLevel);
               }
           }
           else if(L == lastStrongClass)
           {
               CharacterClass[counter] = L;

               ChangeType(CharacterClass + startOfDelayed,
                          counter -  startOfDelayed,
                          CharacterClass[counter]);

               if(POSITION_INVALID != startOfNeutrals)
               {
                   ResolveNeutrals(CharacterClass + startOfNeutrals,
                                   startOfDelayed -  startOfNeutrals,
                                   ArabicNumberAfterLeft ? AN : lastStrongClass,
                                   CharacterClass[counter],
                                   runLevel);
               }
               ArabicNumberAfterLeft = FALSE;
           }
           else
           {
               ChangeType(CharacterClass + startOfDelayed,
                          counter -  startOfDelayed,
                          EN);

               if(POSITION_INVALID != startOfNeutrals)
               {
                   ResolveNeutrals(CharacterClass + startOfNeutrals,
                                   startOfDelayed -  startOfNeutrals,
                                   ArabicNumberAfterLeft ? AN : lastStrongClass,
                                   currentClass,
                                   runLevel);
               }
           }
           startOfNeutrals = startOfDelayed = POSITION_INVALID;
           lastClass = currentClass;
           break;
       case BN_ST:
           if(POSITION_INVALID == startOfDelayed)
           {
               startOfDelayed = counter;
           }
           break;

       case NSM_ST:
           if(AL == lastStrongClass && POSITION_INVALID != startOfDelayed)
           {
               CharacterClass[counter] = lastClass;
           }
           else
           {
               if((AL == lastStrongClass))
               {
                   if(EN == lastClass)
                   {
                       CharacterClass[counter] = AN;
                   }
                   else if (AN != lastClass)
                   {
                       CharacterClass[counter] = R;
                   }
                   else
                   {
                       CharacterClass[counter] = ArabicNumberAfterLeft
                                                 || AN == lastClass ? AN : lastStrongClass;
                   }
               }
               else
               {
                   CharacterClass[counter] = ArabicNumberAfterLeft
                                             || AN == lastClass ? AN : EN == lastClass && lastStrongClass != L
                                              ? EN : lastStrongClass;
               }

               if(POSITION_INVALID != startOfDelayed)
               {
                   ChangeType(CharacterClass + startOfDelayed,
                              counter -  startOfDelayed,
                              CharacterClass[counter]);
                   startOfDelayed = POSITION_INVALID;

               }
           }           break;
       case NSM_ET:
           CharacterClass[counter] = lastClass;
           break;

       case N_ST:
           ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                    ("Cannot have unresolved neutrals. State: %i, Class: %i",
                     state,currentClass));

           if(POSITION_INVALID != startOfDelayed)
           {
               startOfNeutrals = startOfDelayed;
               startOfDelayed = POSITION_INVALID;
           }
           else
           {
               startOfNeutrals = counter;
           }
           lastClass = currentClass;
           break;

       case N_ET:

           // Note that this state is used for N_N as well.

           if(POSITION_INVALID == startOfNeutrals)
           {
               if(POSITION_INVALID != startOfDelayed)
               {
                   startOfNeutrals = startOfDelayed;
               }
           }
           startOfDelayed = POSITION_INVALID;
           lastClass = currentClass;
           break;
        };

        // Fetch next state.

        state = NextState[state][currentClass];
        lengthResolved = POSITION_INVALID == MAX(startOfNeutrals, startOfDelayed) ?
                         counter + 1 :
                         ((POSITION_INVALID == MIN(startOfNeutrals, startOfDelayed)) ?
                         (MAX(startOfNeutrals, startOfDelayed)) :
                         (MIN(startOfNeutrals, startOfDelayed)));
    }


    // If the caller flagged this run as incomplete
    // return the maximun that we could resolve so far and the last strong (fixed)
    // class saved

    if(stateOut)
    {
        stateOut->LastFinalCharacterType = (BYTE)lastStrongClass;
        stateOut->LastNumericCharacterType = (BYTE)lastNumericClass;
        return lengthResolved;
    }

    // Else, resolve remaining neutrals or delayed classes.
    // Resolve as neutrals based on eor.

    else
    {

        if(lengthResolved != counter)
        ResolveNeutrals(CharacterClass + lengthResolved,
                        counter -  lengthResolved,
                        ArabicNumberAfterLeft ? AN : lastStrongClass,
                        eor,
                        runLevel);
        return counter;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   UnicodeBidiAnalyze()
*
*   Performs Unicode Bidirectional text analyis
*   The main entry point function for the algorithm.
*
*
* Arguments:
*
*    [IN  string:
*         Character string to be analyzed.
*
*    [IN] stringLength:
*         Length of string passed.
*
*    [IN] flags:
*         Various flags to control anaylsis behavior
*         See description of 'BidiAnalysisFlags'.
*
*    [IN / OUT] , [OPTIONAL] state:
*         'BidiAnalysisState' structure to save analysis information for a
*          possible next call (when used as output parameter) or to continue
*          analysis from a previous call (when used as input parameter).
*
*    [IN] runLevel:
*         Current run level.
*
*    [OUT] levels:
*         ponter to an array to receive resolved levels
*         have a paragraph terminator following it.
*
*    [OUT] [OPTIONAL] lengthAnalyzed:
*         Conditionally optional pointer to integerto receive the number
*         of characters analyzed.
*
* Return Value:
*
*    Ok, if the analysis completed successfully. Otherwise, error status code.
*
*    Notes:
*         lengthAnalyzed: (optional) returns the number of characters that were
*         unambiguously resolved. This value may be less than the string
*         less if the BidiBufferNotComplete flag was passed, and for example
*         if the input string terminated on neutral (non-directed)
*         characters.
*         The lengthAnalyzed output parameter must be passed if the
*         BidiBufferNotComplete flag has been set.
*         If the BidiBufferNotComplete flag is not set, the whole string will
*         always be analyzed.
*
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

Status WINGDIPAPI
UnicodeBidiAnalyze(
    const WCHAR       *string,                // [IN]
    INT                stringLength,          // [IN]
    BidiAnalysisFlags  flags,                 // [IN]
    BidiAnalysisState *state,                 // [IN / OUT] , [OPTIONAL]
    BYTE              *levels,                // [OUT] [OPTIONAL]
    INT               *lengthAnalyzed         // [OUT]
    )
{

    
    GpCharacterClass  *characterClass;
    INT               *runLimits;
    INT                runCount = 0;
    Status             result = Ok;
    BidiAnalysisState *stateIn = NULL;
    BidiAnalysisState *stateOut = NULL;
    GpBiDiStack        levelsStack;
    UINT64             overrideStatus;
    GpOverrideClass    overrideClass;
    INT                stackOverflow;
    BYTE               baseLevel;
    BYTE               lastRunLevel;
    BYTE               lastNonBnLevel;
    INT                counter;
    INT                lengthUnresolved = 0;
    INT                codepoint;
    INT                controlStack = 0;

    // Verifying input parameters.

    if((NULL == string) || (0 >= stringLength) ||
        ((BidiContinueAnalysis <= flags) && (NULL == state)) ||
        (NULL == levels) ||
        ((flags & BidiBufferNotComplete) && (NULL == lengthAnalyzed)))
    {
        return InvalidParameter;
    }

    // If the last character in the string is a paragraph terminator,
    // we can analyze the whole string, No need to use state parameter
    // for output

    codepoint = string[stringLength -1];

    if((stringLength > 1) && ((string[stringLength -2] & 0xFC00 ) == 0xD800) && ((string[stringLength - 1] & 0xFC00) == 0xDC00))
    {
       codepoint = 0x10000 + (((string[stringLength -2] & 0x3ff) << 10) | (string[stringLength - 1] & 0x3ff));
    }

    if((flags & BidiBufferNotComplete) &&
        (B != s_aDirClassFromCharClass[CharClassFromCh(codepoint)]))
    {
        stateOut = state;

    }

    if(flags & BidiContinueAnalysis)
    {
        // We will use the 'state' parameter as output.
        // let's copy the content of it first
        if(stateOut)
        {
            stateIn = new BidiAnalysisState;
            if(!stateIn)
            {
                return OutOfMemory;
            }
            else
            {
                memcpy(stateIn, state, sizeof(BidiAnalysisState));
            }
        }

        // Else, simply make sateIn points to 'state" parameter.
        else
        {
            stateIn = state;
        }
    }

    characterClass = new GpCharacterClass[stringLength];
    if (characterClass == NULL)
    {
        return OutOfMemory;
    }

    DoubleWideCharMappedString dwchString(string, stringLength);

    // for the worst case of all paragraph terminators string.

    runLimits = new INT[stringLength];

    if (NULL == runLimits)
    {
        delete characterClass;
        return OutOfMemory;
    }

    if(stateIn)
    {
        if(!levelsStack.Init(stateIn->LevelsStack))
        {
            result = InvalidParameter;
            goto Cleanup;
        }
        baseLevel = levelsStack.GetStackBottom();
        stackOverflow = stateIn->StackOverflow;
        overrideStatus = stateIn->OverrideStatus;
        overrideClass = (IS_BIT_SET(overrideStatus, baseLevel)) ? (ODD(baseLevel) ?
                         OverrideClassRight : OverrideClassLeft): OverrideClassNeutral;
    }
    else
    {
        baseLevel = BaseLevelLeft;

        if(flags & BidiParagraphDirectionAsFirstStrong)
        {
            // Find strong character in the first paragraph
            // This might cause a complete pass over the input string
            // but we must get it before we start.

            GpCharacterClass firstStrong = CLASS_INVALID;

            if(GetFirstStrongCharacter(string, stringLength, &firstStrong))
            {
                if(L != firstStrong)
                {
                    baseLevel = BaseLevelRight;
                }
            }

        }
        else if(flags & BidiParagraphDirectioRightToLeft)
        {
            baseLevel = BaseLevelRight;
        }

        levelsStack.Init(baseLevel + 1);
        stackOverflow = 0;
        // Initialize to neutral
        overrideStatus = 0;
        overrideClass = OverrideClassNeutral;
    }

    // Get character classifications.
    // Resolve explicit embedding levels.
    // Record run limits (either due to a level change or due to new paragraph)

    lastNonBnLevel = baseLevel;
    for(counter = 0; counter < stringLength; counter++)
    {

        GpCharacterClass currentClass = characterClass[counter] = s_aDirClassFromCharClass[CharClassFromCh(dwchString[counter])];

        if (dwchString[counter] == WCH_IGNORABLE && counter > 0)
        {
            characterClass[counter] = characterClass[counter-1];
            levels[counter] = levels[counter - 1];
            continue;
        }

        levels[counter] = levelsStack.GetCurrentLevel();

        switch(currentClass)
        {
        case B:
            // mark output level array with a special mark
            // to seperate between paragraphs

            levels[counter] = PARAGRAPH_TERMINATOR_LEVEL;
            runLimits[runCount] = counter;
            if (counter != stringLength-1)
            {
                runCount++;
            }
            levelsStack.Init(baseLevel + 1);
            overrideStatus = 0;
            overrideClass =  OverrideClassNeutral;
            stackOverflow = 0;
            controlStack = 0;

            // Fall through

        // We keep our Unicode classification table stictly following Unicode
        // regarding neutral types (B, S, WS, ON), change all to generic N.

        case S:
        case WS:
        case ON:
            characterClass[counter] = N;
            
            if (counter>0 && characterClass[counter-1]==BN)
            {
                if (levels[counter-1] < levels[counter])
                {
                    levels[counter-1] = levels[counter];
                }
            }
            controlStack = 0;
            
            break;

        case LRE:
        case RLE:
            characterClass[counter] = BN;

            // If we overflowed the stack, keep track of this in order to know when you hit
            // a PDF if you should pop or not.

            if(!levelsStack.Push(currentClass == LRE ? TRUE : FALSE))
            {
              stackOverflow++;
            }
            else
            {
                runLimits[runCount] = counter;
                if (counter != stringLength-1)
                {
                    runCount++;
                }
                controlStack++;
            }
            overrideClass =  OverrideClassNeutral;

            levels[counter] = lastNonBnLevel;

            break;

        case LRO:
        case RLO:
            characterClass[counter] = BN;
            if(!levelsStack.Push(currentClass == LRO ? TRUE : FALSE))
            {
              stackOverflow++;
            }
            else
            {
                // Set the matching bit of 'overrideStatus' to one
                // in order to know when you pop if you're in override state or not.

                SET_BIT(overrideStatus, levelsStack.GetCurrentLevel());
                overrideClass = (currentClass == LRO) ? OverrideClassLeft :
                                                        OverrideClassRight;
                runLimits[runCount] = counter;
                if (counter != stringLength-1)
                {
                    runCount++;
                }
                controlStack++;
            }
            
            levels[counter] = lastNonBnLevel;
            break;

        case PDF:
            characterClass[counter] = BN;
            if(stackOverflow)
            {
                stackOverflow--;
            }
            else
            {
                if (levelsStack.Pop())
                {
                    INT newLevel = levelsStack.GetCurrentLevel();

                    // Override state being left or right is determined
                    // from the new level being even or odd.

                    overrideClass = (IS_BIT_SET(overrideStatus, newLevel)) ? (ODD(newLevel) ?
                                    OverrideClassRight : OverrideClassLeft): OverrideClassNeutral;

                    if (controlStack > 0)
                    {
                        ASSERT(runCount > 0);
                        runCount--;
                        controlStack--;
                    }
                    else
                    {
                        runLimits[runCount] = counter;
                        if (counter != stringLength-1)
                        {
                            runCount++;
                        }
                    }
                }
                
            }
            
            levels[counter] = lastNonBnLevel;
            
            break;

        default:
            controlStack = 0;
 
            if(OverrideClassNeutral != overrideClass)
            {
                characterClass[counter] = (OverrideClassLeft == overrideClass) ?
                                          L : R;
            }

            if (counter>0 && characterClass[counter-1]==BN)
            {
                if (levels[counter-1] < levels[counter])
                {
                    levels[counter-1] = levels[counter];
                }
            }
        }
        
        lastNonBnLevel = levels[counter];
    }

    runCount++;

    if(stateOut)
    {
        stateOut->LevelsStack = levelsStack.GetData();
        stateOut->OverrideStatus = overrideStatus;
        stateOut->StackOverflow = stackOverflow;
    }

    // Resolve neutral and weak types.
    // Resolve implict levels.


    // The lastRunLevel will hold the level of last processed run to be used
    // to determine the sor of the next run. we can't depend on the level array
    // because it can be changed in case of numerics. so level of the numerics
    // will be increased by one or two.
    
    lastRunLevel = baseLevel;

    for(counter = 0; counter < runCount; counter++)
    {
        GpCharacterClass   sor;
        GpCharacterClass   eor;

        INT runStart =  (0 == counter) ? 0 : runLimits[counter - 1] + 1;

        // If the level transition was due to a new paragraph
        // we don't want pass the paragraph terminator position.

        INT offset = (counter != (runCount - 1)) ?
                     ((levels[runLimits[counter]] == PARAGRAPH_TERMINATOR_LEVEL) ?
                     1 : 0) :
                     0;
        INT runLength = (counter == (runCount - 1)) ?
                        (stringLength - runStart) - offset:
                        (runLimits[counter] - runStart) + 1 - offset;

        // See if we need to provide state information from a previous call
        // or need to save it for a possible next call

        BOOL incompleteRun = ((runCount - 1) == counter) && (flags & BidiBufferNotComplete)
                             && stateOut;
        BOOL continuingAnalysis = (0 == counter) && (stateIn);

        INT runLengthResolved;

        // First run or a run after paragraph terminator.

        if ((0 == counter) ||
            (PARAGRAPH_TERMINATOR_LEVEL == levels[runLimits[counter -1]]))
        {
            sor = ODD(MAX(baseLevel, levels[runStart])) ? R : L;
        }
        else
        {
            sor = ODD(MAX(lastRunLevel, levels[runStart])) ?
                  R : L;
        }
        
        lastRunLevel = levels[runStart];

        // Last run or a run just before paragraph terminator.

        if( ((runCount - 1) == counter) ||
            (PARAGRAPH_TERMINATOR_LEVEL == levels[runLimits[counter]]))
        {
            eor = ODD(MAX(levels[runStart], baseLevel)) ? R : L;
        }
        else
        {
            // we will try to get first run which doesn't have just one  
            // control char like LRE,RLE,... and so on
            INT runNumber = counter+1;
            while ( runNumber<runCount - 1 &&
                    runLimits[runNumber]-runLimits[runNumber-1]==1 &&
                    characterClass[runLimits[runNumber]] == BN)
            {
                runNumber++;
            }
            
            eor = ODD(MAX(levels[runStart], levels[runLimits[runNumber-1] + 1])) ?
                  R : L;

        }

        // If it is a continuation from a previous call, set sor
        // to the last stron type saved in the input state parameter.

        runLengthResolved = ResolveNeutralAndWeak(characterClass + runStart,
                                                  runLength,
                                                  sor,
                                                  eor,
                                                  levels[runStart],
                                                  continuingAnalysis ? stateIn:
                                                  NULL,
                                                  incompleteRun ? stateOut:
                                                  NULL,
                                                  ((0 == counter) && !stateIn) ?
                                                  flags & BidiPreviousStrongIsArabic:
                                                  FALSE);
        if(!incompleteRun)
        {
            // If we in a complete run, we should be able to resolve everything
            // unless we passed a corrupted data

            ASSERTMSG(runLengthResolved == runLength,
                     ("Failed to resolve neutrals and weaks. Run#: %i,",
                      counter));
        }
        else
        {
            lengthUnresolved = runLength - runLengthResolved;
        }

        // Resolve implict levels.
        // Also, takes care of Rule L1 (segment separators, paragraph separator,
        // white spaces at the end of the line.

        ResolveImplictLevels(characterClass + runStart,
                             string + runStart,
                             runLength,
                             levels + runStart);

    }
Cleanup:
    if (stateOut && stateIn)
    {
        delete stateIn;
    }
    delete characterClass;
    delete runLimits;

    *lengthAnalyzed = stringLength - lengthUnresolved;
    return result;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\text\imager\cmap.cpp ===
////    CMAP - Truetype CMAP font table loader
//
//      Copyright(c) 1997 - 1999. Microsoft Corporation.
//



#include "precomp.hpp"




///     Interprets Truetype CMAP tables for platform 3 (Windows),
//      encodings 0 (symbol), 1 (unicode) and 10 (UTF-16).
//
//      Supports formats 4 (Segment mapping to delta values)
//      and 12 (Segmented coverage (32 bit)).




////    MapGlyph - Interpret Truetype CMAP type 4 range details
//
//      Implements format 4 of the TrueType cmap table - 'Segment
//      mapping to delta values' described in chapter 2 of the 'TrueType
//      1.0 Font Files Rev. 1.66' document.


__inline UINT16 MapGlyph(
    INT p,                  // Page      (Highbyte of character code)
    INT c,                  // Character (Low byte of unicode code)
    INT s,                  // Segment
    UINT16 *idRangeOffset,
    UINT16 *startCount,
    UINT16 *idDelta,
    void   *glyphTableLimit
)
{
    UINT16   g;
    UINT16  *pg;
    WORD    wc;

    wc = p<<8 | c;

    if (wc >= 0xffff) {

        // Don't map U+0FFFF as some fonts (Pristina) don't map it
        // correctly and cause an AV in a subsequent lookup.

        return 0;
    }


    if (idRangeOffset[s])
    {
        pg =    idRangeOffset[s]/2
             +  (wc - startCount[s])
             +  &idRangeOffset[s];

        if (pg > (UINT16*)glyphTableLimit)
        {
            //TRACEMSG(("Assertion failure: Invalid address generated in CMap table for U+%4x", wc));
            g = 0;
        }
        else
        {
            g = *pg;
        }


        if (g)
        {
            g += idDelta[s];
        }
    }
    else
    {
        g = wc + idDelta[s];
    }

    //TRACE(FONT, ("MapGlyph: idRangeOffset[s]/2 + &idRangeOffset[s]) + (wc-startCount[s] = %x",
    //              idRangeOffset[s]/2 + &idRangeOffset[s] + (wc-startCount[s])));
    //TRACE(FONT, ("........  Segment %d start %x range %x delta %x, wchar %x -> glyph %x",
    //             s, startCount[s], idRangeOffset[s], idDelta[s], wc, g));

    return g;
}


////    ReadCmap4
//
//      Builds a cmap IntMap from a type 4 cmap


struct Cmap4header {
    UINT16  format;
    UINT16  length;
    UINT16  version;
    UINT16  segCountX2;
    UINT16  searchRange;
    UINT16  entrySelector;
    UINT16  rangeShift;
};

static
GpStatus ReadCmap4(
    BYTE           *glyphTable,
    INT             glyphTableLength,
    IntMap<UINT16> *cmap
)
{
    GpStatus status = Ok;
    // Flip the entire glyph table - it's all 16 bit words

    FlipWords(glyphTable, glyphTableLength/2);


    // Extract tables pointers and control variables from header

    Cmap4header *header = (Cmap4header*) glyphTable;

    UINT16 segCount = header->segCountX2 / 2;

    UINT16 *endCount      = (UINT16*) (header+1);
    UINT16 *startCount    = endCount      + segCount + 1;
    UINT16 *idDelta       = startCount    + segCount;
    UINT16 *idRangeOffset = idDelta       + segCount;
    UINT16 *glyphIdArray  = idRangeOffset + segCount;


    // Loop through the segments mapping glyphs

    INT i,p,c;

    for (i=0; i<segCount; i++)
    {
        INT start = startCount[i];

        // The search algorithm defined in the TrueType font file
        // specification for format 4 says 'You search for the first endcode
        // that is greater than or equal to the character code you want to
        // map'. A side effect of this is that we need to ignore codepoints
        // from the StartCount up to and including the EndCount of the
        // previous segment. Although you might not expect the StartCount of
        // a sgement to be less than the EndCount of the previous segment,
        // it does happen (Arial Unicode MS), presumably to help in the
        // arithmetic of the lookup.

        if (i  &&  start < endCount[i-1])
        {
            start = endCount[i-1] + 1;
        }

        p = HIBYTE(start);     // First page in segment
        c = LOBYTE(start);     // First character in page

        while (p < endCount[i] >> 8)
        {
            while (c<256)
            {
                status = cmap->Insert((p<<8) + c, MapGlyph(p, c, i, idRangeOffset, startCount, idDelta, glyphTable+glyphTableLength));
                if (status != Ok)
                    return status;
                c++;
            }
            c = 0;
            p++;
        }

        // Last page in segment

        while (c <= (endCount[i] & 255))
        {
            status = cmap->Insert((p<<8) + c,