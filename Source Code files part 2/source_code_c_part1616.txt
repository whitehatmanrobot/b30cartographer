E_ROUTE(Route, TIMER_REF);
            }
        }

        return NO_ERROR;
    }

    return Status;
}


DWORD
WINAPI
RtmDeleteRouteToDest (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    OUT     PRTM_ROUTE_CHANGE_FLAGS         ChangeFlags
    )

/*++

Routine Description:

    Deletes a route from the route table, and updates the
    best route information on the corresponding dest.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteHandle       - Handle to the route to be deleted,

    ChangeFlags       - Flags whether the best route info changed.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO    AddrFamInfo;
    PENTITY_INFO     Entity;

    PDEST_INFO       Dest;
    PROUTE_INFO      BestRoute;
    PROUTE_INFO      CurrRoute;
    PROUTE_INFO      Route;

    BOOL             TableLocked;
    PLOOKUP_LINKAGE  DestData;

    PRTM_VIEW_ID     ViewIndices;
    RTM_VIEW_SET     ViewSet;
    RTM_VIEW_SET     WorseInViews;
    RTM_VIEW_SET     RouteCurBestInViews;
    ULONG            MaxHoldTime;

    PROUTE_TIMER     TimerContext;

    ULONG            NotifyToCNs;
    DWORD            ViewsForCT[RTM_NUM_CHANGE_TYPES];

    PLIST_ENTRY      p;
    UINT             i, j;
    DWORD            Status;
    BOOL             Success;


    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);
    
    AddrFamInfo = Entity->OwningAddrFamily;


    VALIDATE_ROUTE_HANDLE(RouteHandle, &Route);

    //
    // Only the owner has perms to delete the route
    //

    if (Route->RouteInfo.RouteOwner != RtmRegHandle)
    {
        return ERROR_ACCESS_DENIED;
    }

    Dest = DEST_FROM_HANDLE(Route->RouteInfo.DestHandle);

#if DBG_TRACE

    //
    // Print the route and the dest in the tracing
    //

    if (TRACING_ENABLED(ROUTE))
    {
        ULONG TempAddr, TempMask;
        
        RTM_IPV4_GET_ADDR_AND_MASK(TempAddr, TempMask, &Dest->DestAddress);
        Trace0(ROUTE, "Deleting Route with address: ");
        TracePrintAddress(ROUTE, TempAddr, TempMask);
        Trace2(ROUTE, "Dest = %p and Route = %p\n", Dest, Route);
    }

#endif

    //
    // We attempt to delete the route on the dest
    // without having to lock the entire table.
    // This is possible as long as the route is
    // not the only route on this destination.
    //

    TableLocked = FALSE;

    ACQUIRE_DEST_WRITE_LOCK(Dest);

    //
    // Check if this is the last route on dest,
    // there is no holddown already that would 
    // prevent the dest from getting deleted,
    // and this route isnt going into holddown
    //

    if ((Dest->NumRoutes == 1) && 
        (Dest->HoldRefCount == 0) &&
        ((Dest->ToHoldInViews & Route->RouteInfo.BelongsToViews) == 0))
    {
        if (Route->RouteInfo.State != RTM_ROUTE_STATE_DELETED)
        {
            // Mark the state of the route as 'deleting'

            Route->RouteInfo.State = RTM_ROUTE_STATE_DELETING;

            //
            // Re-grab dest lock after locking route table
            //

            RELEASE_DEST_WRITE_LOCK(Dest);


            TableLocked = TRUE;
        
            ACQUIRE_ROUTE_TABLE_WRITE_LOCK(AddrFamInfo);


            ACQUIRE_DEST_WRITE_LOCK(Dest);

            //
            // Was route updated while we re-acquired locks
            //

            if (Route->RouteInfo.State != RTM_ROUTE_STATE_DELETING)
            {
                RELEASE_ROUTE_TABLE_WRITE_LOCK(AddrFamInfo);

                RELEASE_DEST_WRITE_LOCK(Dest);

                return NO_ERROR;
            }
        }
    }

    //
    // Get out if this route is already deleted
    //

    if (Route->RouteInfo.State != RTM_ROUTE_STATE_DELETED)
    {
        ASSERT(!IsListEmpty(&Route->DestLE));

        //
        // Remove the route from the list of routes on dest
        //

        Route->RouteInfo.State = RTM_ROUTE_STATE_DELETED;

        RemoveEntryList(&Route->DestLE);

        Dest->NumRoutes--;

        *ChangeFlags = 0;

        if (TableLocked)
        {
            //
            // Have u removed all routes on dest  ? 
            // Do we have any routes in holddown  ?
            // Is current delete causing holddown ?
            //

            if ((Dest->NumRoutes == 0) &&
                (Dest->HoldRefCount == 0) &&
                ((Dest->ToHoldInViews & Route->RouteInfo.BelongsToViews) == 0))
            {
                Dest->State = DEST_STATE_DELETED;

                Status = DeleteFromTable(AddrFamInfo->RouteTable,
                                         Dest->DestAddress.NumBits,
                                         Dest->DestAddress.AddrBits,
                                         NULL,
                                         &DestData);

                ASSERT(SUCCESS(Status));

                AddrFamInfo->NumDests--;
            }
        
            //
            // You no longer need to keep a lock to the table
            // [ You have a lock on the destination however ]
            //

            RELEASE_ROUTE_TABLE_WRITE_LOCK(AddrFamInfo);
        }

        ViewIndices = AddrFamInfo->ViewIndexFromId;

        //
        // Update best route in views the route was present
        //

        ViewSet = Route->RouteInfo.BelongsToViews;

        //
        // See if you are best route in any of these views
        //

        RouteCurBestInViews = 0;

        for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
        {
            if (ViewSet & 0x01)
            {
                // Update dest information in view i
            
                // Get best route in current view
                BestRoute = Dest->ViewInfo[ViewIndices[i]].BestRoute;

                // Was this the best route in view ?
                if (BestRoute == Route)
                {
                    RouteCurBestInViews |= VIEW_MASK(i);
                }
            }
        
            ViewSet >>= 1;
        }

        //
        // In the views that you were the best, update best route
        //

        WorseInViews = RouteCurBestInViews;

        for (p = Dest->RouteList.Flink; 
                   (p != &Dest->RouteList) && WorseInViews; 
                                                  p = p->Flink)
        {
            CurrRoute = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

            ViewSet = CurrRoute->RouteInfo.BelongsToViews & WorseInViews;

            for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
            {
                if (ViewSet & 0x01)
                {
                    // Update best route in current view

                    Dest->ViewInfo[ViewIndices[i]].BestRoute = CurrRoute;
                }

                ViewSet >>= 1;
            }

            WorseInViews &= ~CurrRoute->RouteInfo.BelongsToViews;
        }

        //
        // For some views, we end up not having a best route
        //

        ViewSet = WorseInViews;

        MaxHoldTime = 0;

        for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
        {
            if (ViewSet & 0x01)
            {
                j = ViewIndices[i];

                ASSERT(Dest->ViewInfo[j].BestRoute == Route);

                Dest->ViewInfo[j].BestRoute = NULL;

                //
                // If dest is marked for holddown in this view,
                // store deleted route as the holddown route 
                // if there was no other held route before this
                //

                if (Dest->ViewInfo[j].HoldTime)
                {
                    if (Dest->ViewInfo[j].HoldRoute == NULL)
                    {
                        Dest->ViewInfo[j].HoldRoute = Route;

                        REFERENCE_ROUTE(Route, HOLD_REF);

                        if (MaxHoldTime < Dest->ViewInfo[j].HoldTime)
                        {
                            MaxHoldTime = Dest->ViewInfo[j].HoldTime;
                        }
                    }

                    Dest->ViewInfo[j].HoldTime = 0;
                }
            }
        
            ViewSet >>= 1;
        }

        Dest->BelongsToViews &= ~WorseInViews;

        Dest->ToHoldInViews  &= ~WorseInViews;

        //
        // Compute the views for each change type occurred
        //

        ViewsForCT[RTM_CHANGE_TYPE_ID_ALL] = Route->RouteInfo.BelongsToViews;

        ViewsForCT[RTM_CHANGE_TYPE_ID_BEST] = 
        ViewsForCT[RTM_CHANGE_TYPE_ID_FORWARDING] = RouteCurBestInViews;

        //
        // Update output flags if best route changed
        //

        if (ViewsForCT[RTM_CHANGE_TYPE_ID_BEST])
        {
            *ChangeFlags |= RTM_ROUTE_CHANGE_BEST;
        }

        //
        // Calculate the CNs that need to be notified
        //

        ACQUIRE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

        NotifyToCNs = ComputeCNsToBeNotified(AddrFamInfo,
                                             Dest->DestMarkedBits,
                                             ViewsForCT);

        //
        // Add to the global change list if required
        //
        
        if (NotifyToCNs)
        {
            AddToChangedDestLists(AddrFamInfo,
                                  Dest,
                                  NotifyToCNs);
        }

        RELEASE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

        //
        // Invalidate any outstanding timers on route
        //

        TimerContext = Route->TimerContext;

        Route->TimerContext = NULL;

        //
        // Did this route delete result in a holddown
        //

        if (MaxHoldTime)
        {
            //
            // We should not delete the destination
            // while we have its routes in holddown
            //

            Dest->HoldRefCount++;

            //
            // Create a timer to remove this hold
            //

            Route->TimerContext = AllocMemory(sizeof(ROUTE_TIMER));

            if (Route->TimerContext)
            {
                Route->TimerContext->Route = Route;

                Success = CreateTimerQueueTimer(&Route->TimerContext->Timer,
                                                AddrFamInfo->RouteTimerQueue,
                                                RouteHolddownTimeoutCallback,
                                                Route->TimerContext,
                                                MaxHoldTime,
                                                0,
                                                0);
                if (Success)
                {
                    REFERENCE_ROUTE(Route, TIMER_REF);
                }
                else
                {
                    Status = GetLastError();

                    FreeMemory(Route->TimerContext);

                    Route->TimerContext = NULL;
                }
            }
        }

        RELEASE_DEST_WRITE_LOCK(Dest);


        //
        // Cancel any outstanding timers on the route
        //

        if (TimerContext)
        {
            if (DeleteTimerQueueTimer(AddrFamInfo->RouteTimerQueue,
                                      TimerContext->Timer,
                                      (HANDLE) -1))
            {
                // Timer cancelled - delete the context

                FreeMemory(TimerContext);

                DEREFERENCE_ROUTE(Route, TIMER_REF);
            }
        }


        //
        // Remove appropriate references on route
        //

        InterlockedDecrement(&AddrFamInfo->NumRoutes);

        DEREFERENCE_ROUTE(Route, CREATION_REF);

        DEREFERENCE_ROUTE(Route, HANDLE_REF);

        return NO_ERROR;
    }
    else
    {
        //
        // This route has already been deleted
        //

        if (TableLocked)
        {
            RELEASE_ROUTE_TABLE_WRITE_LOCK(AddrFamInfo);
        }

        RELEASE_DEST_WRITE_LOCK(Dest);

        return ERROR_INVALID_HANDLE;
    }
}


DWORD
WINAPI
RtmHoldDestination (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      RTM_VIEW_SET                    TargetViews,
    IN      ULONG                           HoldTime
    )

/*++

Routine Description:

    Marks a destination to be put in the holddown state
    for a certain time once the last route in any view 
    gets deleted.

    When the last route in a view gets deleted, the old
    best route moved to the holddown route on the dest. 
    The holddown protocols continue to advertise this
    route until the hold expires, even if newer routes
    arrive in the meantime.

    To be perfectly right, we should have this hold time
    per view. But we trade off convergence time in favor
    of memory resources by holding on to the held routes 
    in all views for a single (the max) holddown time.

Arguments:

    RtmRegHandle - RTM registration handle for calling entity,

    DestHandle   - Handle to the dest that is being helddown,

    HoldTime     - Time for which dest is marked for holddown
                   (after the last route to this dest is gone).

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PDEST_INFO       Dest;
    PRTM_VIEW_ID     ViewIndices;
    RTM_VIEW_SET     ViewSet;
    UINT             i, j;
    DWORD            Status;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_DEST_HANDLE(DestHandle, &Dest);

    // Limit caller's interest to set of views supported
    TargetViews &= Entity->OwningAddrFamily->ViewsSupported;

    if (HoldTime == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    ACQUIRE_DEST_WRITE_LOCK(Dest);

    //
    // Add a hold if dest is not already deleted
    //

    if (Dest->State != DEST_STATE_DELETED)
    {
        ViewIndices = Entity->OwningAddrFamily->ViewIndexFromId;

        ViewSet = TargetViews;

        for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
        {
            if (ViewSet & 0x01)
            {
                j = ViewIndices[i];

                // Increase hold time in the view if needed

                if (Dest->ViewInfo[j].HoldTime < HoldTime)
                {
                    Dest->ViewInfo[j].HoldTime = HoldTime;
                }
            }
        
            ViewSet >>= 1;
        }

        Dest->ToHoldInViews |= TargetViews;

        Status = NO_ERROR;
    }
    else
    {
        Status = ERROR_INVALID_HANDLE;
    }

    RELEASE_DEST_WRITE_LOCK(Dest);

    return Status;
}


DWORD
WINAPI
RtmGetRoutePointer (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    OUT     PRTM_ROUTE_INFO                *RoutePointer
    )

/*++

Routine Description:

    Gets a direct pointer to the route for read/write by its owner.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteHandle       - Handle to the route whose pointer we want,

    RoutePointer      - A pointer to the route is returned for fast
                        direct access by the caller, only if the
                        caller is the owner of the route passed in.
                       
Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO      Entity;
    PROUTE_INFO       Route;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ROUTE_HANDLE(RouteHandle, &Route);

    //
    // Return a pointer only if caller owns the route
    //

    if (Route->RouteInfo.RouteOwner != RtmRegHandle)
    {
        return ERROR_ACCESS_DENIED;
    }

    *RoutePointer = &Route->RouteInfo;

    return NO_ERROR;
}


DWORD
WINAPI
RtmLockRoute(
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    IN      BOOL                            Exclusive,
    IN      BOOL                            LockRoute,
    OUT     PRTM_ROUTE_INFO                *RoutePointer OPTIONAL
    )

/*++

Routine Description:

    Locks/unlocks a route in the route table. This function is
    used to guard the route while it is being updated in place.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteHandle       - Handle to the route to be locked,

    Exclusive         - TRUE to lock in write mode, else read mode,

    LockRoute         - Flag that tells whether to lock or unlock.

    RoutePointer      - A pointer to the route is returned for fast
                        direct access by the owner of this route.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PDEST_INFO       Dest;
    PROUTE_INFO      Route;
    DWORD            Status;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ROUTE_HANDLE(RouteHandle, &Route);

    //
    // Only the owner has perms to lock the route
    //

    if (Route->RouteInfo.RouteOwner != RtmRegHandle)
    {
        return ERROR_ACCESS_DENIED;
    }

    // Return a direct pointer for use in update

    if (ARGUMENT_PRESENT(RoutePointer))
    {
        *RoutePointer = &Route->RouteInfo;
    }

    //
    // Lock or unlock the route as the case may be
    //

    Dest = DEST_FROM_HANDLE(Route->RouteInfo.DestHandle);

    Status = NO_ERROR;

    if (LockRoute)
    {
        if (Exclusive)
        {
            ACQUIRE_DEST_WRITE_LOCK(Dest);
        }
        else
        {
            ACQUIRE_DEST_READ_LOCK(Dest);
        }

        //
        // You are done if the route wasn't deleted
        //

        if (Route->RouteInfo.State == RTM_ROUTE_STATE_CREATED)
        {
            return NO_ERROR;
        }
        
        Status = ERROR_INVALID_HANDLE;
    }

    //
    // This is an unlock or a case of a failed lock
    //

    if (Exclusive)
    {
        RELEASE_DEST_WRITE_LOCK(Dest);
    }
    else
    {
        RELEASE_DEST_READ_LOCK(Dest);
    }

    return Status;
}


DWORD
WINAPI
RtmUpdateAndUnlockRoute(
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    IN      ULONG                           TimeToLive,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle OPTIONAL,
    IN      RTM_NOTIFY_FLAGS                ChangeType,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle    OPTIONAL,
    OUT     PRTM_ROUTE_CHANGE_FLAGS         ChangeFlags
    )

/*++

Routine Description:

    Updates the position of the route on the list of routes on
    the dest, and adjusts best route information on the dest.

    This function invocation is part of the following sequence,

        The caller calls RtmLockRoute to lock the route.
        [ Actually this locks the route's destination ]

        The caller uses a direct pointer to the route
        to update the route in place. Only ceratin set of
        route fields can be changed using this method.

        The caller then calls RtmUpdateAndUnlockRoute to 
        inform RTM of the change, which causes the dest to
        be updated by RTM to reflect the new route info.

        Finally the caller releases the locks taken in
        RtmLockRoute by calling RtmLockRoute with FALSE.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteHandle       - Route that has been changed in place,

    ChangeFlags       - "If the best route changed" is returned,

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO    AddrFamInfo;
    PENTITY_INFO     Entity;
    PROUTE_LIST      RouteList;

    PDEST_INFO       Dest;
    PROUTE_INFO      Route;
    PROUTE_INFO      CurrRoute;
    PROUTE_INFO      BestRoute;

    LONG             PrefChanged;
    PRTM_VIEW_ID     ViewIndices;
    RTM_VIEW_SET     BelongedToViews;
    RTM_VIEW_SET     ViewSet;
    RTM_VIEW_SET     WorseInViews;
    RTM_VIEW_SET     BetterInViews;
    RTM_VIEW_SET     RouteNewBestInViews;
    RTM_VIEW_SET     RouteCurBestInViews;

    PROUTE_TIMER     TimerContext;

    ULONG            NotifyToCNs;
    DWORD            ViewsForCT[RTM_NUM_CHANGE_TYPES];

    PLIST_ENTRY      p;
    UINT             i;
    DWORD            Status;
    BOOL             Success;

    UNREFERENCED_PARAMETER(ChangeType);
    UNREFERENCED_PARAMETER(NotifyHandle);

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;

    VALIDATE_ROUTE_HANDLE(RouteHandle, &Route);

    //
    // Only the owner has perms to update the route
    //

    if (Route->RouteInfo.RouteOwner != RtmRegHandle)
    {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Validate the updated route before re-adjusting
    //

    // We should be adding only to supported views

    Route->RouteInfo.BelongsToViews &= AddrFamInfo->ViewsSupported;

    Dest = DEST_FROM_HANDLE(Route->RouteInfo.DestHandle);

    // Print the route and the dest in the traces

#if DBG_TRACE

        //
        // Print the route and the dest in the tracing
        //

        if (TRACING_ENABLED(ROUTE))
        {
            ULONG TempAddr, TempMask;
            
            RTM_IPV4_GET_ADDR_AND_MASK(TempAddr, TempMask, &Dest->DestAddress);
            Trace0(ROUTE, "Updating Route with address: ");
            TracePrintAddress(ROUTE, TempAddr, TempMask);
            Trace2(ROUTE, "Dest = %p and Route = %p\n", Dest, Route);
        }
#endif

    //
    // Route has been updated in place and the route's
    // PrefInfo and BelongsToViews values have changed
    //

    *ChangeFlags = 0;

    //
    // Check if route's preference has gone up or down
    //

    PrefChanged = 0;

    if (PrefChanged == 0)
    {
        // Compare the pref with that of the prev route in list

        if (Route->DestLE.Blink != &Dest->RouteList)
        {
            CurrRoute = CONTAINING_RECORD(Route->DestLE.Blink, 
                                          ROUTE_INFO,
                                          DestLE);

            if (ComparePref(&CurrRoute->RouteInfo,
                            &Route->RouteInfo) < 0)
            {
                // Preference has gone up from prev value

                PrefChanged = +1;

                //
                // Re-Insert the route in sorted pref order
                //

                RemoveEntryList(&Route->DestLE);

                for (p = CurrRoute->DestLE.Blink; 
                                         p != &Dest->RouteList; 
                                                            p = p->Blink)
                {
                    CurrRoute = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

                    if (ComparePref(&CurrRoute->RouteInfo,
                                    &Route->RouteInfo) >= 0)
                    {
                        break;
                    }
                }        
                
                InsertHeadList(p, &Route->DestLE);
            }
        }
    }

    if (PrefChanged == 0)
    {
        // Compare the pref with that of the next route in list

        if (Route->DestLE.Flink != &Dest->RouteList)
        {
            CurrRoute = CONTAINING_RECORD(Route->DestLE.Flink, 
                                          ROUTE_INFO,
                                          DestLE);

            if (ComparePref(&CurrRoute->RouteInfo,
                            &Route->RouteInfo) > 0)
            {
                // Preference has gone down from prev value

                PrefChanged = -1;

                //
                // Re-Insert the route in sorted pref order
                //

                RemoveEntryList(&Route->DestLE);

                for (p = CurrRoute->DestLE.Flink; 
                                         p != &Dest->RouteList; 
                                                            p = p->Flink)
                {
                    CurrRoute = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

                    if (ComparePref(&CurrRoute->RouteInfo,
                                    &Route->RouteInfo) <= 0)
                    {
                        break;
                    }
                }        
                
                InsertTailList(p, &Route->DestLE);
            }
        }
    }

    //
    // Adjust the best route information in each view
    //

    ViewIndices = AddrFamInfo->ViewIndexFromId;

    BelongedToViews = Dest->BelongsToViews;

    //
    // We have 3 cases that this add / update can trigger,
    // In a particular view -
    // 1) Route was the view's best route but not anymore,
    // 2) Route was and is still the best route after add,
    // 3) Route has become this view's "new" best route.
    //
    // As we have no idea what changed in the case of (2),
    // we will trigger best route and forwarding changes.
    //

    RouteCurBestInViews = 0;
    RouteNewBestInViews = 0;

    //
    // Check if this route is best in any view
    //

    ViewSet = BelongedToViews;

    for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
    {
        if (ViewSet & 0x01)
        {
            // Update dest information in view i

            // Get best route in current view
            BestRoute = Dest->ViewInfo[ViewIndices[i]].BestRoute;

            // Was this the best route in view ?
            if (BestRoute == Route)
            {
                RouteCurBestInViews |= VIEW_MASK(i);
            }
        }
        
        ViewSet >>= 1;
    }

    //
    // Compute the views where route got worse
    //

    WorseInViews = RouteCurBestInViews;

    if (PrefChanged >= 0)
    {
        WorseInViews &= ~Route->RouteInfo.BelongsToViews;
    }

    //
    // In the views that you were the best, update best route
    //

    for (p = Dest->RouteList.Flink; 
                  WorseInViews && (p != &Dest->RouteList); 
                                                         p = p->Flink)
    {
        CurrRoute = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);
        
        ViewSet = CurrRoute->RouteInfo.BelongsToViews & WorseInViews;

        for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
        {
            if (ViewSet & 0x01)
            {
                // Get best route in current view
                BestRoute = Dest->ViewInfo[ViewIndices[i]].BestRoute;

                if (BestRoute != CurrRoute)
                {
                    Dest->ViewInfo[ViewIndices[i]].BestRoute = CurrRoute;
                }
            }

            ViewSet >>= 1;
        }

        WorseInViews &= ~CurrRoute->RouteInfo.BelongsToViews;
    }

    //
    // For some views, we end up not having a best route
    //

    ViewSet = WorseInViews;

    for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
    {
        if (ViewSet & 0x01)
        {
            Dest->ViewInfo[ViewIndices[i]].BestRoute = NULL;
        }
        
        ViewSet >>= 1;
    }

    Dest->BelongsToViews &= ~WorseInViews;


    //
    // Compute the views where route got better
    //

    BetterInViews = Route->RouteInfo.BelongsToViews;

    //
    // Check if route is best in any of its views
    //

    ViewSet = BetterInViews;
 
    for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
    {
        if (ViewSet & 0x01)
        {
            //
            // Update dest information in view i
            //

            // Get best route in current view
            BestRoute = Dest->ViewInfo[ViewIndices[i]].BestRoute;

            //
            // Is route most preferred now, while
            // it was not so before this update ?
            //
                
            if ((!BestRoute) || 
                     ((BestRoute != Route) &&
                            (ComparePref(&Route->RouteInfo,
                                         &BestRoute->RouteInfo) > 0)))
            {
                Dest->ViewInfo[ViewIndices[i]].BestRoute = Route;

                RouteNewBestInViews |= VIEW_MASK(i);
            }
        }
        
        ViewSet >>= 1;
    }

    Dest->BelongsToViews |= BetterInViews;


    //
    // Compute the views for each change type occurred
    //

    //
    // All views affected by this add are notified
    // -views route belonged to and now belongs to
    //

    ViewsForCT[RTM_CHANGE_TYPE_ID_ALL]  = 
        BelongedToViews | Route->RouteInfo.BelongsToViews;

    //
    // If the route was or is now the best route then
    // it is considered a best and forwarding change
    // as we cannot tell better what exactly changed
    //

    ViewsForCT[RTM_CHANGE_TYPE_ID_FORWARDING] = 
    ViewsForCT[RTM_CHANGE_TYPE_ID_BEST] = 
        RouteCurBestInViews | RouteNewBestInViews;

    //
    // Update output flags if best route changed
    //

    if (ViewsForCT[RTM_CHANGE_TYPE_ID_BEST])
    {
        *ChangeFlags |= RTM_ROUTE_CHANGE_BEST;
    }

    //
    // Calculate the CNs that need to be notified
    //

    ACQUIRE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

    NotifyToCNs = ComputeCNsToBeNotified(AddrFamInfo,
                                         Dest->DestMarkedBits,
                                         ViewsForCT);

    //
    // Add to the global change list if required
    //
        
    if (NotifyToCNs)
    {
        AddToChangedDestLists(AddrFamInfo,
                              Dest,
                              NotifyToCNs);
    }

    RELEASE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

    //
    // Remove from old route list, and put in the new one
    //

    // Check the route list handle for validity

    if (ARGUMENT_PRESENT(RouteListHandle))
    {
        RouteList = ROUTE_LIST_FROM_HANDLE(RouteListHandle);
    
        if (RouteList)
        {
            ACQUIRE_ROUTE_LISTS_WRITE_LOCK(Entity);
        
            if (!IsListEmpty(&Route->RouteListLE))
            {
                RemoveEntryList(&Route->RouteListLE);
            }
            else
            {
                REFERENCE_ROUTE(Route, LIST_REF);
            }

            InsertTailList(&RouteList->ListHead, &Route->RouteListLE);

            RELEASE_ROUTE_LISTS_WRITE_LOCK(Entity);
        }
    }

    //
    // Set a timer if we want to age out the route
    //

    TimerContext = Route->TimerContext;

    if (TimeToLive == INFINITE)
    {
        Route->TimerContext = NULL;
    }
    else
    {
        Route->TimerContext = AllocMemory(sizeof(ROUTE_TIMER));

        if (Route->TimerContext)
        {
            Route->TimerContext->Route = Route;

            Success = CreateTimerQueueTimer(&Route->TimerContext->Timer,
                                            AddrFamInfo->RouteTimerQueue,
                                            RouteExpiryTimeoutCallback,
                                            Route->TimerContext,
                                            TimeToLive,
                                            0,
                                            0);
            if (Success)
            {
                REFERENCE_ROUTE(Route, TIMER_REF);
            }
            else
            {
                Status = GetLastError();

                FreeMemory(Route->TimerContext);

                Route->TimerContext = NULL;
            }
        }
    }

    RELEASE_DEST_WRITE_LOCK(Dest);

    //
    // Cancel the timer that was attached to the route
    //

    if (TimerContext)
    {
        if (DeleteTimerQueueTimer(AddrFamInfo->RouteTimerQueue,
                                  TimerContext->Timer,
                                  (HANDLE) -1))
        {
            // Timer cancelled - delete the context

            FreeMemory(TimerContext);

            DEREFERENCE_ROUTE(Route, TIMER_REF);
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmtimer.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmtimer.c

Abstract:

    Contains timer callbacks for handling RTM
    functions like aging out routes etc.
    
Author:

    Chaitanya Kodeboyina (chaitk)   14-Sep-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


VOID 
NTAPI
RouteExpiryTimeoutCallback (
    IN      PVOID                           Context,
    IN      BOOLEAN                         TimeOut
    )

/*++

Routine Description:

    This routine is invoked when the expiry timer 
    associated with a route fires. At this time, 
    the route needs to be aged out.

Arguments:

    Context           - Context for this timer callback 

    TimeOut           - TRUE if the timer fired,
                        FALSE if wait satisfied.

Return Value:

    None

--*/

{
    PRTM_ENTITY_HANDLE EntityHandle;
    PRTM_ROUTE_HANDLE  RouteHandle;
    PADDRFAM_INFO      AddrFamInfo;
    PENTITY_INFO       Entity;
    PDEST_INFO         Dest;
    PROUTE_INFO        Route;
    DWORD              ChangeFlags;
    BOOL               Success;
    DWORD              Status;

    UNREFERENCED_PARAMETER(TimeOut);

    Route = (PROUTE_INFO) ((PROUTE_TIMER)Context)->Route;

    Dest = DEST_FROM_HANDLE(Route->RouteInfo.DestHandle);

    //
    // Has the timer has not been updated after it fired
    //

    ACQUIRE_DEST_WRITE_LOCK(Dest);

    if (Route->TimerContext != Context)
    {
        RELEASE_DEST_WRITE_LOCK(Dest);

        //
        // The timer has been updated after it fired,
        // This timer context is freed by the update
        //

        return;
    }

    //
    // The timer is still valid for this route,
    // Indicate to entity and free the context
    //
    
    Route->TimerContext = NULL;
    
    RELEASE_DEST_WRITE_LOCK(Dest);

    //
    // Inform the owner that the route has expired
    //

    EntityHandle = Route->RouteInfo.RouteOwner;

    Entity = ENTITY_FROM_HANDLE(EntityHandle);

    AddrFamInfo = Entity->OwningAddrFamily;

    RouteHandle = MAKE_HANDLE_FROM_POINTER(Route);

    REFERENCE_ROUTE(Route, HANDLE_REF);

    Status = ERROR_NOT_SUPPORTED;

    if (Entity->EventCallback)
    {
        //
        // This callback can turn back and post RTM calls,
        // so release locks before invoking this callback
        //

        Status = Entity->EventCallback(EntityHandle,
                                       RTM_ROUTE_EXPIRED,
                                       RouteHandle,
                                       &Route->RouteInfo);
    }

    if (Status == ERROR_NOT_SUPPORTED)
    {
        //
        // Delete the route as the owner does not care
        //

        Status = RtmDeleteRouteToDest(EntityHandle,
                                      RouteHandle,
                                      &ChangeFlags);

        //
        // The route could already have been deleted here
        //

        ASSERT((Status == NO_ERROR) || 
               (Status == ERROR_NOT_FOUND) ||
               (Status == ERROR_INVALID_HANDLE));
    }

    //
    // Free the context as we do not need it now
    //

    Success = DeleteTimerQueueTimer(AddrFamInfo->RouteTimerQueue,
                                    ((PROUTE_TIMER)Context)->Timer,
                                    NULL);
    // ASSERT(Success);

    FreeMemory(Context);

    DEREFERENCE_ROUTE(Route, TIMER_REF);

    return;
}


VOID 
NTAPI
RouteHolddownTimeoutCallback (
    IN      PVOID                           Context,
    IN      BOOLEAN                         TimeOut
    )

/*++

Routine Description:

    This routine is invoked when holddown timer 
    associated with a route fires. At this time, 
    the route needs to be taken out of holddown.

Arguments:

    Context           - Context for this timer callback 

    TimeOut           - TRUE if the timer fired,
                        FALSE if wait satisfied.

Return Value:

    None

--*/

{
    PADDRFAM_INFO    AddrFamInfo;
    PENTITY_INFO     Entity;
    PDEST_INFO       Dest;
    PROUTE_INFO      Route;
    PROUTE_INFO      HoldRoute;
    PLOOKUP_LINKAGE  DestData;
    ULONG            NotifyToCNs;
    DWORD            ViewsForCT[RTM_NUM_CHANGE_TYPES];
    UINT             i;
    BOOL             Success;
    DWORD            Status;

    UNREFERENCED_PARAMETER(TimeOut);

    Route = (PROUTE_INFO) ((PROUTE_TIMER)Context)->Route;

    Dest = DEST_FROM_HANDLE(Route->RouteInfo.DestHandle);

    Entity = ENTITY_FROM_HANDLE(Route->RouteInfo.RouteOwner);

    AddrFamInfo = Entity->OwningAddrFamily;

    //
    // The route must surely be in holddown by this time
    //

    ASSERT(Route->RouteInfo.State == RTM_ROUTE_STATE_DELETED);

    //
    // Has the timer has not been updated after it fired
    //

    ACQUIRE_DEST_WRITE_LOCK(Dest);

    if (Route->TimerContext != Context)
    {
        RELEASE_DEST_WRITE_LOCK(Dest);

        ASSERT(FALSE);

        //
        // The timer has been updated after it fired,
        // This timer context is freed by the update
        //

        return;
    }

    //
    // The timer is still valid for this route
    //

    //
    // Remove this holddown route from the dest
    //

    for (i = 0; i < AddrFamInfo->NumberOfViews; i++)
    {
        HoldRoute = Dest->ViewInfo[i].HoldRoute;

        if (HoldRoute == Route)
        {
            DEREFERENCE_ROUTE(HoldRoute, HOLD_REF); 

            Dest->ViewInfo[i].HoldRoute = NULL;
        }
    }

    //
    // We need to generate notifications for any
    // holddown protocols interesed in this dest
    //

    //
    // Calculate the CNs that need to be notified
    //

    ACQUIRE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

    for (i = 0; i < RTM_NUM_CHANGE_TYPES; i++)
    {
        ViewsForCT[i] = AddrFamInfo->ViewsSupported;
    }

    NotifyToCNs = ComputeCNsToBeNotified(AddrFamInfo,
                                         Dest->DestMarkedBits,
                                         ViewsForCT);

    //
    // Add to the global change list if required
    //
        
    if (NotifyToCNs)
    {
        AddToChangedDestLists(AddrFamInfo,
                              Dest,
                              NotifyToCNs);
    }

    RELEASE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);


    //
    // Reset the timer context and free it later
    //

    Route->TimerContext = NULL;

    //
    // Reduce hold ref so that dest can be deleted
    //

    ASSERT(Dest->HoldRefCount > 0);

    if (Dest->NumRoutes || (Dest->HoldRefCount > 1))
    {
        Dest->HoldRefCount--;
    }
    else
    {
        //
        // Removal of hold might result in dest deletion
        //

        RELEASE_DEST_WRITE_LOCK(Dest);

        ACQUIRE_ROUTE_TABLE_WRITE_LOCK(AddrFamInfo);

        ACQUIRE_DEST_WRITE_LOCK(Dest);

        Dest->HoldRefCount--;

        if ((Dest->NumRoutes == 0) && (Dest->HoldRefCount == 0))
        {
            Dest->State = DEST_STATE_DELETED;

            Status = DeleteFromTable(AddrFamInfo->RouteTable,
                                     Dest->DestAddress.NumBits,
                                     Dest->DestAddress.AddrBits,
                                     NULL,
                                     &DestData);
                
            ASSERT(SUCCESS(Status));

            AddrFamInfo->NumDests--;
        }

        RELEASE_ROUTE_TABLE_WRITE_LOCK(AddrFamInfo);
    }

    RELEASE_DEST_WRITE_LOCK(Dest);

    //
    // Free the context as we do not need it now
    //

    Success = DeleteTimerQueueTimer(AddrFamInfo->RouteTimerQueue,
                                    ((PROUTE_TIMER)Context)->Timer,
                                    NULL);
    // ASSERT(Success);

    FreeMemory(Context);

    DEREFERENCE_ROUTE(Route, TIMER_REF);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmtimer.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmtimer.h

Abstract:

    Contains definitions for timer callbacks for 
    handling functions like aging out routes etc.
    
Author:

    Chaitanya Kodeboyina (chaitk)   14-Sep-1998

Revision History:

--*/

#ifndef __ROUTING_RTMTIMER_H__
#define __ROUTING_RTMTIMER_H__

VOID 
NTAPI
RouteExpiryTimeoutCallback (
    IN      PVOID                           Context,
    IN      BOOLEAN                         TimeOut
    );

VOID 
NTAPI
RouteHolddownTimeoutCallback (
    IN      PVOID                           Context,
    IN      BOOLEAN                         TimeOut
    );

#endif //__ROUTING_RTMTIMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\upgrade\steelhead2nt5\dhcp.c ===
/*
    File    dhcp.c

    Implementation of the upgrade of dhcp relay agent from 
    nt 4.0 to nt 5.0 router.

    Paul Mayfield, 9/15/97


    Reference files:    routing\inc\ipbootp.h

    DHCP Relay Agent parameter mapping table:
    Relay Agent         per Interface           Global
    ===========         =============           ======
    "HopsThreshold"     Max Hop Count
    "SecsThreshold"     Min Secs Since Boot
    "LogMessages"                               Logging Level			
    "DHCPServers"                               Servers
*/

#include "upgrade.h"
#include <ipbootp.h>
#include <winsock2.h>
#include <routprot.h>

static WCHAR szTempKey[] = L"DeleteMe";
static HKEY hkRouter = NULL;
static HKEY hkTemp = NULL;

// Restore the registry from from backup 
// and make sure all global handles are opened
DWORD DhcpPrepareRegistry(
        IN PWCHAR BackupFileName) 
{
	DWORD dwErr, dwDisposition;

	// Get access to the router registry key
	dwErr = UtlAccessRouterKey(&hkRouter);
	if (dwErr != ERROR_SUCCESS) {
		PrintMessage(L"Unable to access router key.\n");
		return dwErr;
	}

	// Restore the Dhcp parameters from backup
	__try {
		// Open up the temporary key
		dwErr = RegCreateKeyEx(
		            hkRouter,
		            szTempKey,
		            0,
		            NULL,
		            0,
		            KEY_ALL_ACCESS,
		            NULL,
		            &hkTemp,
		            &dwDisposition);
		if (dwErr!=ERROR_SUCCESS)
			return dwErr;

		// Restore saved registry info to the temp key
		UtlSetupRestorePrivilege(TRUE);
		dwErr = RegRestoreKeyW(
		            hkTemp,
		            BackupFileName,
		            0);
		if (dwErr != ERROR_SUCCESS) 
			return dwErr;
	}
	__finally {
		UtlSetupRestorePrivilege(FALSE);
	}
	
	return NO_ERROR;
}

// Cleanup the work done in the registry
DWORD DhcpCleanupRegistry() {

	if (hkTemp) 
		RegCloseKey(hkTemp);
		
	if (hkRouter) {
		RegDeleteKey(hkRouter,szTempKey);
		RegCloseKey(hkRouter);
	}
	
    hkTemp = NULL;
    hkRouter = NULL;
    
	return NO_ERROR;
}

// Reads in the list of configured dhcp servers
DWORD DhcpReadServerList(
        IN LPBYTE * ppServerList, 
        HKEY hkParams) 
{
    DWORD dwErr, dwType, dwSize = 0;
    LPSTR szServerValName = "DHCPServers";

    if (!ppServerList)
        return ERROR_INVALID_PARAMETER;

    dwErr = RegQueryValueExA(
                hkParams,
                szServerValName,
                NULL,
                &dwType,
                NULL,
                &dwSize);
    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    if (dwSize == 0)
    {
        *ppServerList = NULL;
        return NO_ERROR;
    }

    *ppServerList = (LPBYTE) UtlAlloc(dwSize);
    if (! (*ppServerList))
        return ERROR_NOT_ENOUGH_MEMORY;

    dwErr = RegQueryValueExA(
                hkParams,
                szServerValName,
                NULL,
                &dwType,
                *ppServerList,
                &dwSize);
    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    return NO_ERROR;
}

// Frees the resources associated with a list of dhcp servers
DWORD DhcpFreeServerList(LPBYTE * ppServerList) {

    if ((ppServerList) && (*ppServerList))
        UtlFree(*ppServerList);
        
    return NO_ERROR;
}

// Gets the count of dhcp servers from this list read from 
// the registry
DWORD DhcpGetServerCount(
        IN LPBYTE pServerList, 
        LPDWORD lpdwSrvCount) 
{
    LPBYTE ptr = pServerList;

    if (!lpdwSrvCount)
        return ERROR_INVALID_PARAMETER;

    *lpdwSrvCount = 0;
    if (ptr) {
        while (*ptr) {
            (*lpdwSrvCount)++;
            ptr += strlen(ptr);
        }
    }

    return NO_ERROR;
}

// Converts a server string to a dword ip address
DWORD DhcpAnsiSrvToDwordSrv(
        IN LPSTR AnsiIpAddr, 
        OUT LPDWORD pAddr) 
{
    *pAddr = inet_addr(AnsiIpAddr);
    
    return NO_ERROR;
}

// Updates the Dhcp global information
DWORD DhcpUpgradeGlobalInfo(
        IN dwt * DhcpParams, 
        IN LPBYTE pServerList) 
{
    DWORD dwErr, dwSrvCount, dwVal, dwConfigSize, dwTransSize;
    DWORD dwNewSize;
    LPBYTE pSrvList = pServerList;
    LPDWORD pAddr;

    IPBOOTP_GLOBAL_CONFIG DhcpGlobalConfig = {
        IPBOOTP_LOGGING_ERROR,              // Logging level
        1024 * 1024,                        // Max recv-queue size
        0                                   // Server count
    };
    
    PIPBOOTP_GLOBAL_CONFIG pNewConfig = NULL;
    LPBYTE pTransInfo = NULL, pNewTransInfo = NULL;
    HANDLE hSvrConfig = NULL, hTransport = NULL;

    __try {
        // Initialize the parameters with what was read from previous config
        dwErr = dwtGetValue(DhcpParams, L"LogMessages", &dwVal);
        if (dwErr == NO_ERROR)
            DhcpGlobalConfig.GC_LoggingLevel = dwVal;
            
        dwErr = DhcpGetServerCount(pServerList, &dwSrvCount);
        if (dwErr != NO_ERROR)
            return dwErr;
        DhcpGlobalConfig.GC_ServerCount = dwSrvCount;

        // Prepare a global information variable length structure
        dwConfigSize = IPBOOTP_GLOBAL_CONFIG_SIZE(&DhcpGlobalConfig);
        pNewConfig = (PIPBOOTP_GLOBAL_CONFIG) UtlAlloc(dwConfigSize);
        if (!pNewConfig)
            return ERROR_NOT_ENOUGH_MEMORY;
        memset(pNewConfig, 0, dwConfigSize);
        memcpy(pNewConfig, &DhcpGlobalConfig, sizeof(IPBOOTP_GLOBAL_CONFIG));

        // Fill in the Dhcp Server Addresss
        pSrvList = pServerList;
        pAddr = (LPDWORD)
                    (((ULONG_PTR)pNewConfig) + sizeof(IPBOOTP_GLOBAL_CONFIG));
        while ((pSrvList) && (*pSrvList)) 
        {
            dwErr = DhcpAnsiSrvToDwordSrv(pSrvList, pAddr);
            if (dwErr != ERROR_SUCCESS)
                return dwErr;
            pSrvList += strlen(pSrvList);
            pAddr++;
        }
    
        // Set the new global configuration
        dwErr = MprConfigServerConnect(NULL, &hSvrConfig);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = MprConfigTransportGetHandle(hSvrConfig, PID_IP, &hTransport);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = MprConfigTransportGetInfo(
                    hSvrConfig,
                    hTransport,
                    &pTransInfo,
                    &dwTransSize,
                    NULL,
                    NULL,
                    NULL);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = UtlUpdateInfoBlock(
                    TRUE,
                    pTransInfo,
                    MS_IP_BOOTP,
                    dwConfigSize,
                    1,
                    (LPBYTE)pNewConfig,
                    &pNewTransInfo,
                    &dwNewSize);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = MprConfigTransportSetInfo(
                    hSvrConfig,
                    hTransport,
                    pNewTransInfo,
                    dwNewSize,
                    NULL,
                    0,
                    NULL);
        if (dwErr != NO_ERROR)
            return NO_ERROR;

    }
    __finally {
        if (pNewConfig) 
            UtlFree(pNewConfig);
        if (pTransInfo)
            MprConfigBufferFree(pTransInfo);
        if (pNewTransInfo)
            MprConfigBufferFree(pNewTransInfo);
        if (hSvrConfig)
            MprConfigServerDisconnect(hSvrConfig);
    }
    
    return NO_ERROR;
}

//
// Callback interface enumeration function that updates the if
// with a dhcp if configuration blob.
//
// Return TRUE to continue enumeration, FALSE to stop.
//
BOOL DhcpInstallInterface(
        IN HANDLE hConfig,
        IN MPR_INTERFACE_0 * pIf,
        IN HANDLE hUserData)
{
    IPBOOTP_IF_CONFIG * pConfig = (IPBOOTP_IF_CONFIG*)hUserData;
    LPBYTE pTransInfo = NULL, pNewTransInfo = NULL;
    HANDLE hTransport = NULL;
    DWORD dwErr, dwTransSize, dwNewSize; 
    
    // Is this a LAN or a WAN interface 
    if (pIf->dwIfType != ROUTER_IF_TYPE_DEDICATED   &&
        pIf->dwIfType != ROUTER_IF_TYPE_HOME_ROUTER &&
        pIf->dwIfType != ROUTER_IF_TYPE_FULL_ROUTER)
        return TRUE;

    // Get the handle to ip info
    dwErr = MprConfigInterfaceTransportGetHandle(
                hConfig,
                pIf->hInterface,
                PID_IP,
                &hTransport);
    if (dwErr != NO_ERROR)
        return TRUE;

    // Get the ip info
    dwErr = MprConfigInterfaceTransportGetInfo(
                hConfig,
                pIf->hInterface,
                hTransport,
                &pTransInfo,
                &dwTransSize);
    if (dwErr != NO_ERROR)
        return TRUE;

    do {
        // Update the DHCP info
        dwErr = UtlUpdateInfoBlock(
                    TRUE,
                    pTransInfo,
                    MS_IP_BOOTP,
                    sizeof(IPBOOTP_IF_CONFIG),
                    1,
                    (LPBYTE)pConfig,
                    &pNewTransInfo,
                    &dwNewSize);
        if (dwErr != NO_ERROR)
            break;
            
        // Commit the change
        dwErr = MprConfigInterfaceTransportSetInfo(
                    hConfig,
                    pIf->hInterface,
                    hTransport,
                    pNewTransInfo,
                    dwNewSize);
        if (dwErr != NO_ERROR)
            break;
            
    } while (FALSE);            

    // Cleanup
    {
        if (pTransInfo)
            MprConfigBufferFree(pTransInfo);
        if (pNewTransInfo)
            MprConfigBufferFree(pNewTransInfo);
    }

    return TRUE;
}


// Upgrade all of the interfaces to have dhcp information
DWORD DhcpUpgradeInterfaces(
        IN dwt * DhcpParams) 
{
    DWORD dwErr, dwVal;
    
    IPBOOTP_IF_CONFIG DhcpIfConfig = 
    {
        0,                          // State (read-only)
        IPBOOTP_RELAY_ENABLED,      // Relay-mode
        4,                          // Max hop-count
        4                           // Min seconds-since-boot
    };

    // Initialize the hops threshold
    dwErr = dwtGetValue(DhcpParams, L"HopsThreshold", &dwVal);
    if (dwErr == NO_ERROR)
        DhcpIfConfig.IC_MaxHopCount = dwVal;

    // Initialize the seconds threshold        
    dwErr = dwtGetValue(DhcpParams, L"SecsThreshold", &dwVal);
    if (dwErr == NO_ERROR)
        DhcpIfConfig.IC_MinSecondsSinceBoot = dwVal;

    // Loop through the interfaces, adding the dhcp blob as
    // appropriate
    dwErr = UtlEnumerateInterfaces(
                DhcpInstallInterface,
                (HANDLE)&DhcpIfConfig);

    return dwErr;
}

//
// Restores the Dhcp parameters that were saved before upgrade.
// assumes that the pre-upgrade parameters are being stored 
// temporarily in hkTemp
//
DWORD DhcpMigrateParams() 
{
	DWORD dwErr, dwVal;
	dwt DhcpParams;
    LPBYTE ServerList;

	__try {
    	// Load in the parameters that were set for Dhcp
		dwErr = dwtLoadRegistyTable(&DhcpParams, hkTemp);
		if (dwErr != NO_ERROR)
			return dwErr;

        // Load in the list of dhcp servers
        dwErr = DhcpReadServerList(&ServerList, hkTemp);
        if (dwErr != NO_ERROR)
            return dwErr;

        // Migrate the various types of paramters
        dwErr = DhcpUpgradeGlobalInfo(&DhcpParams, ServerList);
        if (dwErr != NO_ERROR)
            return dwErr;

        // Migrate the per-interface parameters
        dwErr = DhcpUpgradeInterfaces(&DhcpParams);
        if (dwErr != NO_ERROR)
            return dwErr;
    }
	__finally {
		dwtCleanup(&DhcpParams);
        DhcpFreeServerList(&ServerList);
	}

	return NO_ERROR;
}

//
// Upgrades Dhcp relay agent into nt 5.0 router
// 
DWORD DhcpToRouterUpgrade(
        IN PWCHAR FileName) 
{
	DWORD dwErr;

	__try {
		// Restore the registry from the backup file
		dwErr = DhcpPrepareRegistry(FileName);
		if (dwErr != NO_ERROR)
			return dwErr;

		// Migrate Dhcp's parameters to the appropriate 
		// new locations
		dwErr = DhcpMigrateParams();
		if (dwErr != NO_ERROR)
			return dwErr;

		// Mark the computer as having been configured
		//
        dwErr = UtlMarkRouterConfigured();
		if (dwErr != NO_ERROR) 
		{
			PrintMessage(L"Unable to mark router as configured.\n");
			return dwErr;
		}
			
	}
	__finally {
		DhcpCleanupRegistry();
	}

	return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\upgrade\steelhead2nt5\radius.c ===
/*
    File: radius.c

    Upgrades radius configuration from nt4 steelhead to win2k rras.

    Paul Mayfield, 2/8/99
*/

#include "upgrade.h"

// 
// Information describing a radius server
//
typedef struct _RAD_SERVER_NODE
{
    PWCHAR pszName;
    
    DWORD dwTimeout;
    DWORD dwAuthPort;
    DWORD dwAcctPort;
    DWORD dwScore;
    BOOL  bEnableAuth;
    BOOL  bEnableAcct;
    BOOL  bAccountingOnOff;
    
    struct _RAD_SERVER_NODE * pNext;
    
} RAD_SERVER_NODE;

//
// A radius server list
//
typedef struct _RAD_SERVER_LIST
{
    RAD_SERVER_NODE* pHead;
    DWORD dwCount;
    
} RAD_SERVER_LIST;

//
// Info used by routines that manipulate the nt5 radius registry hive
//
typedef struct _RAD_CONFIG_INFO
{
    HKEY hkAuthServers;
    HKEY hkAuthProviders;

    HKEY hkAcctServers;
    HKEY hkAcctProviders;
    
} RAD_CONFIG_INFO;

//
// Registry value names
//
// The all caps ones were taken from nt40 src.
//
static const WCHAR PSZTIMEOUT[]          = L"Timeout";
static const WCHAR PSZAUTHPORT[]         = L"AuthPort";
static const WCHAR PSZACCTPORT[]         = L"AcctPort";
static const WCHAR PSZENABLEACCT[]       = L"EnableAccounting";
static const WCHAR PSZENABLEACCTONOFF[]  = L"EnableAccountingOnOff";
static const WCHAR PSZENABLEAUTH[]       = L"EnableAuthentication";
static const WCHAR PSZSCORE[]            = L"Score";

static const WCHAR pszTempRegKey[]       = L"Temp";
static const WCHAR pszAccounting[]       = L"Accounting\\Providers";        
static const WCHAR pszAuthentication[]   = L"Authentication\\Providers";
static const WCHAR pszActiveProvider[]   = L"ActiveProvider";
static const WCHAR pszRadServersFmt[]    = L"%s\\Servers";
static const WCHAR pszServers[]          = L"Servers";

static const WCHAR pszGuidRadAuth[]      = 
    L"{1AA7F83F-C7F5-11D0-A376-00C04FC9DA04}";

static const WCHAR pszGuidRadAcct[]      = 
    L"{1AA7F840-C7F5-11D0-A376-00C04FC9DA04}";

    
// Defaults
//
#define DEFTIMEOUT                              5
#define DEFAUTHPORT                             1645
#define DEFACCTPORT                             1646
#define MAXSCORE                                30

RAD_SERVER_NODE g_DefaultRadNode = 
{
    NULL,

    DEFTIMEOUT,
    DEFAUTHPORT,
    DEFACCTPORT,
    MAXSCORE,
    TRUE,
    TRUE,
    TRUE,

    NULL
};

//
// Loads a radius server node's configuration from the registry
// (assumed nt4 format and that defaults are assigned to pNode)
//
DWORD
RadNodeLoad(
    IN  HKEY hKey,
    OUT RAD_SERVER_NODE* pNode)
{
    RTL_QUERY_REGISTRY_TABLE paramTable[8]; 
    BOOL bTrue = TRUE;
    DWORD i;

    // Initialize the table of parameters
    RtlZeroMemory(&paramTable[0], sizeof(paramTable));
    
    paramTable[0].Name = (PWCHAR)PSZTIMEOUT;
    paramTable[0].EntryContext = &(pNode->dwTimeout);
        
    paramTable[1].Name = (PWCHAR)PSZAUTHPORT;
    paramTable[1].EntryContext = &(pNode->dwAuthPort);

    paramTable[2].Name = (PWCHAR)PSZACCTPORT;
    paramTable[2].EntryContext = &(pNode->dwAcctPort);

    paramTable[3].Name = (PWCHAR)PSZENABLEAUTH;
    paramTable[3].EntryContext = &(pNode->bEnableAuth);

    paramTable[4].Name = (PWCHAR)PSZENABLEACCT;
    paramTable[4].EntryContext = &(pNode->bEnableAcct);

    paramTable[5].Name = (PWCHAR)PSZENABLEACCTONOFF;
    paramTable[5].EntryContext = &(pNode->bAccountingOnOff);

    paramTable[6].Name = (PWCHAR)PSZSCORE;
    paramTable[6].EntryContext = &(pNode->dwScore);

    // We're reading all dwords, set the types
    // accordingly
    //
    for (i = 0; i < (sizeof(paramTable) / sizeof(*paramTable)) - 1;  i++)
    {
        paramTable[i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[i].DefaultType = REG_DWORD;
        paramTable[i].DefaultLength = sizeof(DWORD);
        paramTable[i].DefaultData = paramTable[i].EntryContext;
    }

    // Read in the values
    //
    RtlQueryRegistryValues(
		 RTL_REGISTRY_HANDLE,
		 (PWSTR)hKey,
		 paramTable,
		 NULL,
		 NULL);

    return NO_ERROR;
}

// Add the authentication server node
//
DWORD
RadNodeSave(
    IN HKEY hKey,
    IN RAD_SERVER_NODE* pNode,
    IN BOOL bAuth)
{    
    DWORD dwErr = NO_ERROR;
    HKEY hkServer = NULL;

    do
    {
        // Create the server key in which to store the info
        //
        dwErr = RegCreateKeyExW(
                    hKey,
                    pNode->pszName,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hkServer,
                    NULL);
        if (dwErr != ERROR_SUCCESS)
        {
            break;
        }

        if (bAuth)
        {
            RegSetValueExW(
                hkServer,
                (PWCHAR)PSZAUTHPORT,
                0,
                REG_DWORD,
                (BYTE*)&pNode->dwAuthPort,
                sizeof(DWORD));

            RegSetValueExW(
                hkServer,
                (PWCHAR)PSZSCORE,
                0,
                REG_DWORD,
                (BYTE*)&pNode->dwScore,
                sizeof(DWORD));

            RegSetValueExW(
                hkServer,
                (PWCHAR)PSZTIMEOUT,
                0,
                REG_DWORD,
                (BYTE*)&pNode->dwTimeout,
                sizeof(DWORD));
        }
        else
        {
            RegSetValueExW(
                hkServer,
                (PWCHAR)PSZACCTPORT,
                0,
                REG_DWORD,
                (BYTE*)&pNode->dwAcctPort,
                sizeof(DWORD));

            RegSetValueExW(
                hkServer,
                (PWCHAR)PSZSCORE,
                0,
                REG_DWORD,
                (BYTE*)&pNode->dwScore,
                sizeof(DWORD));

            RegSetValueExW(
                hkServer,
                (PWCHAR)PSZTIMEOUT,
                0,
                REG_DWORD,
                (BYTE*)&pNode->dwTimeout,
                sizeof(DWORD));

            RegSetValueExW(
                hkServer,
                (PWCHAR)PSZENABLEACCTONOFF,
                0,
                REG_DWORD,
                (BYTE*)&pNode->bAccountingOnOff,
                sizeof(DWORD));
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkServer)
        {
            RegCloseKey(hkServer);
        }
    }

    return dwErr;
}

//
// Callback from registry key enumerator that adds the server at the given key
// to the list of radius servers.
//
DWORD 
RadSrvListAddNodeFromKey(
    IN PWCHAR pszName,          // sub key name
    IN HKEY hKey,               // sub key
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR;
    RAD_SERVER_LIST * pList = (RAD_SERVER_LIST*)hData;
    RAD_SERVER_NODE * pNode = NULL;
	
	do
	{
	    // Initialize the new node
	    //
	    pNode = (RAD_SERVER_NODE*) UtlAlloc(sizeof(RAD_SERVER_NODE));
	    if (pNode == NULL)
	    {
	        dwErr = ERROR_NOT_ENOUGH_MEMORY;
	        break;
	    }
        CopyMemory(pNode, &g_DefaultRadNode, sizeof(RAD_SERVER_NODE));

        // Initialize the name
        //
        pNode->pszName = UtlDupString(pszName);
	    if (pNode->pszName == NULL)
	    {
	        dwErr = ERROR_NOT_ENOUGH_MEMORY;
	        break;
	    }

	    // Load in the registry settings
	    //
	    dwErr = RadNodeLoad(hKey, pNode);
	    if (dwErr != NO_ERROR)
	    {
	        break;
	    }

	    // Add the node to the list
	    //
        pNode->pNext   = pList->pHead;
        pList->pHead   = pNode;
        pList->dwCount += 1;
		
	} while (FALSE); 

    // Cleanup
	{
	} 
		
	return dwErr;
} 

//
// Generates a RAD_SERVER_LIST based on the configuration (assumed
// nt4 format) in the given registry key
//
DWORD
RadSrvListGenerate(
    IN  HKEY hkSettings,
    OUT RAD_SERVER_LIST** ppList)
{
    RAD_SERVER_LIST* pList = NULL;
    DWORD dwErr = NO_ERROR;

    do 
    {
        // Alloc/Init the list
        pList = (RAD_SERVER_LIST*) UtlAlloc(sizeof(RAD_SERVER_LIST));
        if (pList == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        ZeroMemory(pList, sizeof(RAD_SERVER_LIST));

        // Build the list
        //
        dwErr = UtlEnumRegistrySubKeys(
                    hkSettings,
                    NULL,
                    RadSrvListAddNodeFromKey,
                    (HANDLE)pList);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Assign the return value
        //
        *ppList = pList;
        
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

//
// Cleans up a radius server list
//
DWORD
RadSrvListCleanup(
    IN RAD_SERVER_LIST* pList)
{
    RAD_SERVER_NODE* pNode = NULL;

    if (pList)
    {
        for (pNode = pList->pHead; pNode; pNode = pList->pHead)
        {
            if (pNode->pszName)
            {
                UtlFree(pNode->pszName);
            }
            pList->pHead = pNode->pNext;
            UtlFree(pNode);
        }
        UtlFree(pList);
    }

    return NO_ERROR;
}

//
// Opens the registry keys required by pNode
//
DWORD 
RadOpenRegKeys(
    IN     HKEY hkRouter,
    IN     RAD_SERVER_NODE* pNode,
    IN OUT RAD_CONFIG_INFO* pInfo)
{
    DWORD dwErr = NO_ERROR;
    WCHAR pszPath[MAX_PATH];

    do
    {
        // Open the authentication keys as needed
        //
        if (pNode->bEnableAuth)
        {
            if (pInfo->hkAuthProviders == NULL)
            {
                // Open the auth providers key
                //
                dwErr = RegOpenKeyExW(
                            hkRouter,
                            pszAuthentication,
                            0,
                            KEY_ALL_ACCESS,
                            &pInfo->hkAuthProviders);
                if (dwErr != NO_ERROR)
                {
                    break;
                }

                // Generate the servers key name
                //
                wsprintfW(pszPath, pszRadServersFmt, pszGuidRadAuth);
                
                // Open the auth servers key
                //
                dwErr = RegCreateKeyExW(
                            pInfo->hkAuthProviders,
                            pszPath,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &pInfo->hkAuthServers,
                            NULL);
                if (dwErr != NO_ERROR)
                {
                    break;
                }
            }
        }

        // Open the accounting keys
        //
        if (pNode->bEnableAcct)
        {
            if (pInfo->hkAcctProviders == NULL)
            {
                // Open the auth providers key
                //
                dwErr = RegOpenKeyExW(
                            hkRouter,
                            pszAccounting,
                            0,
                            KEY_ALL_ACCESS,
                            &pInfo->hkAcctProviders);
                if (dwErr != NO_ERROR)
                {
                    break;
                }

                // Generate the servers key name
                //
                wsprintfW(pszPath, pszRadServersFmt, pszGuidRadAcct);
                
                // Open the auth servers key
                //
                dwErr = RegCreateKeyExW(
                            pInfo->hkAcctProviders,
                            pszPath,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &pInfo->hkAcctServers,
                            NULL);
                if (dwErr != NO_ERROR)
                {
                    break;
                }
            }
        }

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

//
// Cleans up info from radius installation
//
DWORD
RadCloseRegKeys(
    IN RAD_CONFIG_INFO* pInfo)
{
    if (pInfo)
    {
        if (pInfo->hkAuthServers)
        {   
            RegCloseKey(pInfo->hkAuthServers);
            pInfo->hkAuthServers = NULL;
        }
        
        if (pInfo->hkAuthProviders)
        {
            RegCloseKey(pInfo->hkAuthProviders);
            pInfo->hkAuthProviders = NULL;
        }

        if (pInfo->hkAcctServers)
        {
            RegCloseKey(pInfo->hkAcctServers);
            pInfo->hkAcctServers = NULL;
        }
        
        if (pInfo->hkAcctProviders)
        {
            RegCloseKey(pInfo->hkAcctProviders);
            pInfo->hkAcctProviders = NULL;
        }
    }
    
    return NO_ERROR;
}

//
// Adds the given server to the win2k section of the registry
//
DWORD
RadInstallServer(
    IN     HKEY hkRouter,
    IN     RAD_SERVER_NODE* pNode,
    IN OUT RAD_CONFIG_INFO* pInfo)
{
    DWORD dwErr = NO_ERROR;

    do
    {
        // Based on the node, open or create any neccessary
        // registry keys.
        //
        dwErr = RadOpenRegKeys(hkRouter, pNode, pInfo);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        if (pNode->bEnableAuth)
        {
            // Add the authentication server node
            //
            dwErr = RadNodeSave(
                        pInfo->hkAuthServers,
                        pNode, 
                        TRUE);
            if (dwErr != NO_ERROR)
            {
                break;
            }

            // Set the active authentication provider
            //
            dwErr = RegSetValueExW(
                        pInfo->hkAuthProviders,
                        (PWCHAR)pszActiveProvider,
                        0,
                        REG_SZ,
                        (BYTE*)pszGuidRadAuth,
                        (wcslen(pszGuidRadAuth) + 1) * sizeof(WCHAR));
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }
                    
        if (pNode->bEnableAcct)
        {
            // Add the accounting server node
            //
            dwErr = RadNodeSave(
                        pInfo->hkAcctServers,
                        pNode,
                        FALSE);
            if (dwErr != NO_ERROR)
            {
                break;
            }

            // Set the active accounting provider
            //
            dwErr = RegSetValueExW(
                        pInfo->hkAcctProviders,
                        (PWCHAR)pszActiveProvider,
                        0,
                        REG_SZ,
                        (BYTE*)pszGuidRadAcct,
                        (wcslen(pszGuidRadAcct) + 1) * sizeof(WCHAR));
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

//
// Migrates radius settings from the settings key into the 
// router key.
//
DWORD
RadMigrateSettings(
    IN HKEY hkRouter, 
    IN HKEY hkSettings)
{
    DWORD dwErr = NO_ERROR;
    RAD_SERVER_LIST* pList = NULL;
    RAD_CONFIG_INFO* pInfo = NULL;
    RAD_SERVER_NODE* pNode = NULL;

    do
    {
        // Generate the list of servers based on 
        // the loaded settings
        dwErr = RadSrvListGenerate(hkSettings, &pList);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // If there were no servers, then there's nothing
        // to do
        //
        if (pList->pHead == NULL)
        {
            dwErr = NO_ERROR;
            break;
        }

        // Allocate and init the info blob that will be
        // used by the install funcs.
        //
        pInfo = (RAD_CONFIG_INFO*) UtlAlloc(sizeof(RAD_CONFIG_INFO));
        if (pInfo == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        ZeroMemory(pInfo, sizeof(RAD_CONFIG_INFO));

        // Install all of the servers
        //
        for (pNode = pList->pHead; pNode; pNode = pNode->pNext)
        {
            RadInstallServer(hkRouter, pNode, pInfo);
        }

    } while (FALSE);

    // Cleanup
    {
        if (pList)
        {
            RadSrvListCleanup(pList);
        }
        if (pInfo)
        {
            RadCloseRegKeys(pInfo);
            UtlFree(pInfo);
        }
    }

    return dwErr;
}

//
//  Performs the upgrade work
//
DWORD
RadiusToRouterUpgrade(
    IN PWCHAR pszFile) 
{
	DWORD dwErr = NO_ERROR;
	HKEY hkRouter = NULL, hkTemp = NULL, hkSettings = NULL;

	do
	{
        // Get the Router subkey
        //
        dwErr = UtlAccessRouterKey(&hkRouter);
        if (dwErr != NO_ERROR)
        {
            break;
        }
	
		// Load registry data that has been saved off
		//
		dwErr = UtlLoadSavedSettings(
		            hkRouter, 
		            (PWCHAR)pszTempRegKey, 
		            pszFile, 
		            &hkTemp);
		if (dwErr != NO_ERROR) 
		{
			PrintMessage(L"Unable to load radius settings.\n");
			break;
		}

		// Load the settings key
		//
		dwErr = RegOpenKeyExW(
                    hkTemp,
                    pszServers,
                    0,
                    KEY_ALL_ACCESS,
                    &hkSettings);
        if (dwErr != NO_ERROR)
        {
            break;
        }

		// Migrate radius information
		//
		dwErr = RadMigrateSettings(hkRouter, hkSettings);
		if (dwErr != NO_ERROR) 
		{
			PrintMessage(L"Unable to migrate radius settings.\n");
			break;
		}

	} while (FALSE);

	// Cleanup
	{
	    if (hkSettings)
	    {
	        RegCloseKey(hkSettings);
	    }
	    if (hkTemp)
	    {
	        UtlDeleteRegistryTree(hkTemp);
	        RegCloseKey(hkTemp);
	        RegDeleteKey(hkRouter, pszTempRegKey);
	    }
	    if (hkRouter)
	    {
	        RegCloseKey(hkRouter);
	    }
	}

	return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\upgrade\steelhead2nt5\sap.c ===
/*
	File:	sap.c

	Performs an upgrade of ipx sap to nt5 router 
	by munging registry values.

	Paul Mayfield, 9/3/97
*/

#include "upgrade.h"

// Structure for data passed to the enumeration 
// function.
typedef struct _SAP_ENUM_DATA {
    PSAP_IF_CONFIG pDefaults;
} SAP_ENUM_DATA;


// Globals
static WCHAR szIpxSapKey[] = 
    L"System\\CurrentControlSet\\Services\\RemoteAccess\\RouterManagers\\IPX\\RoutingProtocols\\IPXSAP\\Parameters";
static WCHAR szTempKey[] = L"DeleteMe";
static HKEY hkRouter = NULL;
static HKEY hkTemp = NULL;    
static HKEY hkIpxSap = NULL;
static PWCHAR IpxSapParams[] = 
{   
    L"SendTime", 
    L"EntryTimeout", 
    L"WANFilter", 
    L"WANUpdateTime", 
    L"MaxRecvBufferLookAhead", 
    L"RespondForInternalServers", 
    L"DelayRespondToGeneral", 
    L"DelayChangeBroadcast", 
    L"NameTableReservedHeapSize", 
    L"NameTableSortLatency", 
    L"MaxUnsortedNames", 
    L"TriggeredUpdateCheckInterval", 
    L"MaxTriggeredUpdateRequests", 
    L"ShutdownBroadcastTimeout", 
    L"RequestsPerInterface", 
    L"MinimumRequests" 
};


//
// Restore the registry from from backup and make sure 
// all global handles are opened
//
DWORD SapPrepareRegistry(
        IN PWCHAR BackupFileName) 
{
	DWORD dwErr, dwDisposition;

	// Get access to the router registry key
	dwErr = UtlAccessRouterKey(&hkRouter);
	if (dwErr != ERROR_SUCCESS) {
		PrintMessage(L"Unable to access router key.\n");
		return dwErr;
	}

	// Restore the router key from backup
	__try {
		// Open up the temporary key
		dwErr = RegCreateKeyEx(
		            hkRouter,
		            szTempKey,
		            0,
		            NULL,
		            0,
		            KEY_ALL_ACCESS,
		            NULL,
		            &hkTemp,
		            &dwDisposition);
		if (dwErr != ERROR_SUCCESS)
			return dwErr;

		// Restore the saved registry information 
		// to the temp key
		UtlSetupRestorePrivilege(TRUE);
		dwErr = RegRestoreKeyW(
		            hkTemp,
		            BackupFileName,
		            0);
		if (dwErr != ERROR_SUCCESS) 
			return dwErr;

		// Open up the ipx sap params key
		dwErr = RegCreateKeyEx(
		            HKEY_LOCAL_MACHINE,
		            szIpxSapKey,
		            0,
		            NULL,
		            0,
		            KEY_ALL_ACCESS,
		            NULL,
		            &hkIpxSap,
		            &dwDisposition);
		if (dwErr != ERROR_SUCCESS)
			return dwErr;
	}
	__finally {
		UtlSetupRestorePrivilege(FALSE);
	}
	
	return NO_ERROR;
}

//
// Cleanup the work done in the registry
//
DWORD SapCleanupRegistry() {
	if (hkIpxSap)
		RegCloseKey(hkIpxSap);
	if (hkTemp) 
		RegCloseKey(hkTemp);
	if (hkRouter) {
		RegDeleteKey(hkRouter,szTempKey);
		RegCloseKey(hkRouter);
	}
	
    hkIpxSap = NULL;
    hkTemp = NULL;
    hkRouter = NULL;
    
	return NO_ERROR;
}

//
// Restores the sap parameters that were saved before upgrade.  
// Assumes those parameters are being stored temporarily in hkTemp
//
DWORD SapRestoreParameters() {
	DWORD dwErr, dwVal;
	PWCHAR* IpxSapParamPtr = IpxSapParams;
	dwt NwSapParams;

	// Load in the parameters that were set for nwsap
	__try {
		dwErr = dwtLoadRegistyTable(&NwSapParams, hkTemp);
		if (dwErr != NO_ERROR)
			return dwErr;

		// Loop through the ipx params copying over any that applied 
		// to nwsap
		while (IpxSapParamPtr && *IpxSapParamPtr) {
		    dwErr = dwtGetValue(&NwSapParams, *IpxSapParamPtr, &dwVal);
			if (dwErr == NO_ERROR) {
				dwErr = RegSetValueEx(
				            hkIpxSap,
				            *IpxSapParamPtr,
				            0,
				            REG_DWORD,
				            (LPBYTE)&dwVal,
				            sizeof(DWORD));
				if (dwErr != ERROR_SUCCESS)
					return dwErr;
			}
			IpxSapParamPtr++;
		}
	}
	__finally {
		dwtCleanup(&NwSapParams);
	}

	return NO_ERROR;
}

//
// Installs sap in the router by initializing the 
// sap global info blob.
//
DWORD SapInstallTransportInfo(
        IN SAP_GLOBAL_INFO * pGlobal,
        IN SAP_IF_CONFIG * pIfDefaults) 
{
    LPBYTE pGlobalInfo = NULL, pDialinInfo = NULL;
    LPBYTE pNewGlobalInfo = NULL, pNewDialinInfo = NULL;
    HANDLE hConfig = NULL, hTrans = NULL;
    SAP_IF_CONFIG SapCfg, *pDialinCfg = &SapCfg;
    DWORD dwErr, dwGlobalInfoSize = 0, dwDialinInfoSize = 0;
    DWORD dwNewGlobSize = 0, dwNewDialSize = 0;

    do {
        // Connect to config server
        dwErr = MprConfigServerConnect(NULL, &hConfig);
        if (dwErr != NO_ERROR)
            break;

        // Get handle to global ipx tranport info
    	dwErr = MprConfigTransportGetHandle (
    				hConfig,
    				PID_IPX,
    				&hTrans);
        if (dwErr != NO_ERROR)
            break;

        // Get global ipx tranport info
        dwErr = MprConfigTransportGetInfo(
                    hConfig,
                    hTrans,
                    &pGlobalInfo,
                    &dwGlobalInfoSize,
                    &pDialinInfo,
                    &dwDialinInfoSize,
                    NULL);
        if (dwErr != NO_ERROR)
            break;

        // Initialize the global info blob
        dwErr = UtlUpdateInfoBlock(
                    FALSE,
                    pGlobalInfo,
                    IPX_PROTOCOL_SAP,
                    sizeof(SAP_GLOBAL_INFO),
                    1,
                    (LPBYTE)pGlobal,
                    &pNewGlobalInfo,
                    &dwNewGlobSize);
        if (dwErr != NO_ERROR) {
            if (dwErr != ERROR_ALREADY_EXISTS)
                break;
            pNewGlobalInfo = NULL;
            dwNewGlobSize = 0;
        }

        // Initialize the dialin info blob
        CopyMemory(pDialinCfg, pIfDefaults, sizeof(SAP_IF_CONFIG));
        pDialinCfg->SapIfInfo.UpdateMode = IPX_NO_UPDATE;
        dwErr = UtlUpdateInfoBlock(
                    FALSE,
                    pDialinInfo,
                    IPX_PROTOCOL_SAP,
                    sizeof(SAP_IF_CONFIG),
                    1,
                    (LPBYTE)pDialinCfg,
                    &pNewDialinInfo,
                    &dwNewDialSize);
        if (dwErr != NO_ERROR) {
            if (dwErr != ERROR_ALREADY_EXISTS)
                break;
            pNewDialinInfo = NULL;
            dwNewDialSize = 0;
        }
                            
        // Set global ipx tranport info
        dwErr = MprConfigTransportSetInfo(
                    hConfig,
                    hTrans,
                    pNewGlobalInfo,
                    dwNewGlobSize,
                    pNewDialinInfo,
                    dwNewDialSize,
                    NULL);
        if (dwErr != NO_ERROR)
            break;
        
    } while (FALSE);

    // Cleanup
    {
        if (hConfig)
            MprConfigServerDisconnect(hConfig);
        if (pGlobalInfo)
            MprConfigBufferFree(pGlobalInfo);
        if (pDialinInfo)
            MprConfigBufferFree(pDialinInfo);
        if (pNewDialinInfo)
            MprConfigBufferFree(pNewDialinInfo);
        if (pNewGlobalInfo)
            MprConfigBufferFree(pNewGlobalInfo);
    }
    
    return dwErr;
}

//
// Callback function takes an interface and updates
// its ipx sap configuration.
//
// Returns TRUE to continue the enumerate, FALSE to 
// stop it
//
DWORD SapUpgradeInterface(
        IN HANDLE hConfig,
        IN MPR_INTERFACE_0 * pIf,
        IN HANDLE hUserData)
{
    SAP_ENUM_DATA* pData = (SAP_ENUM_DATA*)hUserData;
    SAP_IF_CONFIG SapCfg, *pConfig = &SapCfg;
    LPBYTE pTransInfo=NULL, pNewTransInfo=NULL;
    HANDLE hTransport = NULL;
    DWORD dwErr, dwSize, dwNewSize = 0;

    // Validate input
    if ((hConfig == NULL) || 
        (pIf == NULL)     || 
        (pData == NULL))
    {
        return FALSE;
    }

    // Initalize the config blob
    CopyMemory(pConfig, pData->pDefaults, sizeof(SAP_IF_CONFIG));

    // Customize the update mode for the router interface
    // type
    switch (pIf->dwIfType) {
        case ROUTER_IF_TYPE_DEDICATED:
            pConfig->SapIfInfo.UpdateMode = IPX_STANDARD_UPDATE;
            break;
            
        case ROUTER_IF_TYPE_INTERNAL:
        case ROUTER_IF_TYPE_CLIENT:
            pConfig->SapIfInfo.UpdateMode = IPX_NO_UPDATE;
            break;
            
        case ROUTER_IF_TYPE_HOME_ROUTER:
        case ROUTER_IF_TYPE_FULL_ROUTER:
            pConfig->SapIfInfo.UpdateMode = IPX_AUTO_STATIC_UPDATE;
            break;
            
        case ROUTER_IF_TYPE_LOOPBACK:
        case ROUTER_IF_TYPE_TUNNEL1:
        default:
            return TRUE;
    }

    do {
        // Get the handle to ipx info associated with this if
        dwErr = MprConfigInterfaceTransportGetHandle(
                    hConfig,
                    pIf->hInterface,
                    PID_IPX,
                    &hTransport);
        if (dwErr != NO_ERROR)
            break;

        // Get the ipx info associated with this if
        dwErr = MprConfigInterfaceTransportGetInfo(
                    hConfig,
                    pIf->hInterface,
                    hTransport,
                    &pTransInfo,
                    &dwSize);
        if (dwErr != NO_ERROR)
            break;

        // Update the info block
        dwErr = UtlUpdateInfoBlock(
                    FALSE,
                    pTransInfo,
                    IPX_PROTOCOL_SAP,
                    dwSize,
                    1,
                    (LPBYTE)pConfig,
                    &pNewTransInfo,
                    &dwNewSize);
        if (dwErr != NO_ERROR) {
            if (dwErr != ERROR_ALREADY_EXISTS)
                break;
            pNewTransInfo = NULL;
            dwNewSize = 0;
        }
        
        // Commit the change
        dwErr = MprConfigInterfaceTransportSetInfo(
                    hConfig,
                    pIf->hInterface,
                    hTransport,
                    pNewTransInfo,
                    dwNewSize);
        if (dwErr != NO_ERROR)
            break;
    } while (FALSE);   

    // Cleanup
    {
        if (pNewTransInfo)
            MprConfigBufferFree(pNewTransInfo);
        if (pTransInfo)
            MprConfigBufferFree(pTransInfo);
    }

    return TRUE;
}

// 
// Installs ipx sap in the router registry tree.
//
DWORD SapInstallInRouter()
{
    DWORD dwErr;
    SAP_IF_CONFIG SapConfig, * pSap = &SapConfig;
    SAP_ENUM_DATA SapBlobs = 
    {
        pSap
    };
    SAP_GLOBAL_INFO SapGlobal = 
    {
        EVENTLOG_ERROR_TYPE         // event log mask
    };

    // Clear all structures
    ZeroMemory (pSap, sizeof(SAP_IF_CONFIG));

    // Default lan configuration
    pSap->SapIfInfo.AdminState             = ADMIN_STATE_ENABLED;
    pSap->SapIfInfo.UpdateMode             = IPX_STANDARD_UPDATE;
    pSap->SapIfInfo.PacketType             = IPX_STANDARD_PACKET_TYPE;
    pSap->SapIfInfo.Supply                 = ADMIN_STATE_ENABLED;
    pSap->SapIfInfo.Listen                 = ADMIN_STATE_ENABLED;
    pSap->SapIfInfo.GetNearestServerReply  = ADMIN_STATE_ENABLED;
    pSap->SapIfInfo.PeriodicUpdateInterval = 60;
    pSap->SapIfInfo.AgeIntervalMultiplier  = 3;
    pSap->SapIfFilters.SupplyFilterAction  = IPX_SERVICE_FILTER_DENY;
    pSap->SapIfFilters.SupplyFilterCount   = 0;
    pSap->SapIfFilters.ListenFilterAction  = IPX_SERVICE_FILTER_DENY;
    pSap->SapIfFilters.ListenFilterCount   = 0;

    // Install default sap global info
    dwErr = SapInstallTransportInfo(&SapGlobal, pSap);
    if (dwErr != NO_ERROR)
        return dwErr;

    // Enumerate the interfaces, updating each one with 
    // sap config as you go.
    dwErr = UtlEnumerateInterfaces(
                SapUpgradeInterface,
                &SapBlobs);
    if (dwErr != NO_ERROR)
        return dwErr;
        
    return NO_ERROR;
}


//
//	Performs all of the registry updating associated with an 
//  upgrade from ipx sap to router.
//
//	These are the steps:
//	1. Restore the parameters saved in FileName to szIpxSapKey.
//	2. Remove all parameters that ipx sap does not implement.
//
DWORD SapToRouterUpgrade(
        IN PWCHAR FileName) 
{
	DWORD dwErr;

	__try {
		// Restore the registry from the backup file
		dwErr = SapPrepareRegistry(FileName);
		if (dwErr != NO_ERROR)
			return dwErr;

		// Set the new registry parameters
		dwErr = SapRestoreParameters();
		if (dwErr != NO_ERROR)
			return dwErr;

	    // Install default sap global config and set default
	    // values in all router interfaces.
	    dwErr = SapInstallInRouter();
	    if (dwErr != NO_ERROR)
	        return dwErr;

		// Mark the computer as having been configured
		//
        dwErr = UtlMarkRouterConfigured();
		if (dwErr != NO_ERROR) 
		{
			PrintMessage(L"Unable to mark router as configured.\n");
			return dwErr;
		}
			
	}
	__finally {
		SapCleanupRegistry();
	}

	return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\upgrade\steelhead2nt5\rip.c ===
/*
    File:	Rip.c

    Performs an upgrade of ip rip to nt5 router by munging registry values.

    Paul Mayfield, 9/3/97


    The following steps are neccessary to upgrade rip:
        Params = HKLM/SYS/CCS/Services/IpRip/Parameters
    1. Get the global info block for IP w/ MprConfigTransportGetInfo
        - Add a IPRIP_GLOBAL_CONFIG (ipriprm.h) block 
          initialized as in routemon (rip.c, protocol.c)
        - Type is MS_IP_RIP as in sdk/inc/ipinfoid.h
        - Mappings
        	Params.LoggingLevel to this global config blob

    2. Get Interface info for each ras or lan ip interface
    - Add an IPRIP_IF_CONFIG (ipriprm.h) block (type MS_IP_RIP)
    - Initialize as per routemon
    - Mappings
    	Params.AcceptHostRoutes - IC_ProtocolFlags (0=disable,1=enable)
    	Params.UpdateFreq...=FullUpdateInterval
    	Params.*Timeouts=

    3. "SilentRip" param rules
    - If wks->srv, ignore this and set announce to disabled. accept=rip1
    - If srv->srv, map announce to this value. accept=rip1


    IP Rip Parameter Mapping
    ========================

    Rip Listener                IpRip in Router			        
    RIP_PARAMETERS              IPRIP_IF_CONFIG			        	
    ==============              ===============			        
    "SilentRIP"                 IC_AcceptMode,IC_AnnounceMode
    "AcceptHostRoutes"          IC_ProtocolFlags
    "AnnounceHostRoutes"        IC_ProtocolFlags	
    "AcceptDefaultRoutes"       IC_ProtocolFlags
    "AnnounceDefaultRoutes"     IC_ProtocolFlags
    "EnableSplitHorizon"        IC_ProtocolFlags
    "EnablePoisonedReverse"     IC_ProtocolFlags
    "RouteTimeout"              IC_RouteExpirationInterval
    "GarbageTimeout"            IC_RouteRemovalInterval
    "UpdateFrequency"           IC_FullUpdateInterval
    "EnableTriggeredUpdates"    IC_ProtocolFlags
    "MaxTriggeredUpdateFrequency"   NOT MIGRATED
    "OverwriteStaticRoutes"     IC_ProtocolFlags


    IpRip in Router
    IPRIP_GLOBAL_CONFIG
    ===============
    "LoggingLevel"              GC_LoggingLevel
    
    REGVAL_ACCEPT_HOST      "AcceptHostRoutes"
    REGVAL_ANNOUNCE_HOST    "AnnounceHostRoutes"
    REGVAL_ACCEPT_DEFAULT   "AcceptDefaultRoutes"
    REGVAL_ANNOUNCE_DEFAULT "AnnounceDefaultRoutes"
    REGVAL_SPLITHORIZON     "EnableSplitHorizon"
    REGVAL_POISONREVERSE    "EnablePoisonedReverse"
    REGVAL_LOGGINGLEVEL     "LoggingLevel"
    REGVAL_ROUTETIMEOUT     "RouteTimeout"
    REGVAL_GARBAGETIMEOUT   "GarbageTimeout"
    REGVAL_UPDATEFREQUENCY  "UpdateFrequency"
    REGVAL_TRIGGEREDUPDATES "EnableTriggeredUpdates"
    REGVAL_TRIGGERFREQUENCY "MaxTriggeredUpdateFrequency"
    REGVAL_OVERWRITESTATIC  "OverwriteStaticRoutes"
*/

#include "upgrade.h"
#include <ipriprm.h>
#include <routprot.h>
#include <mprapi.h>

// Definition of table that migrates rip parameters
typedef struct _PARAM_TO_FLAG {
    PWCHAR pszParam;
    DWORD dwFlag;
} PARAM_TO_FLAG;

// Definition of user data passed to interface enumeration 
// callback
typedef struct _RIP_IF_DATA {
    IPRIP_IF_CONFIG * pLanConfig;
    IPRIP_IF_CONFIG * pWanConfig;
} RIP_IF_DATA;    

// Types of upgrade
#define SRV_TO_SRV 0
#define WKS_TO_SRV 1

// Globals
static const WCHAR szTempKey[] = L"DeleteMe";
static HKEY hkRouter = NULL;
static HKEY hkTemp = NULL;

PARAM_TO_FLAG ParamFlagTable[] = 
{
    {L"AcceptHostRoutes",       IPRIP_FLAG_ACCEPT_HOST_ROUTES},
    {L"AnnounceHostRoutes",     IPRIP_FLAG_ANNOUNCE_HOST_ROUTES},
    {L"AcceptDefaultRoutes",    IPRIP_FLAG_ACCEPT_DEFAULT_ROUTES},
    {L"AnnounceDefaultRoutes",  IPRIP_FLAG_ANNOUNCE_DEFAULT_ROUTES},
    {L"EnableSplitHorizon",     IPRIP_FLAG_SPLIT_HORIZON},
    {L"EnablePoisonedReverse",  IPRIP_FLAG_POISON_REVERSE},
    {L"EnableTriggeredUpdates", IPRIP_FLAG_TRIGGERED_UPDATES},
    {L"OverwriteStaticRoutes",  IPRIP_FLAG_OVERWRITE_STATIC_ROUTES},
    {NULL,  0}
};

// Restore the registry from from 
// backup and make sure all global handles are opened
DWORD IpRipPrepareRegistry(
        IN PWCHAR BackupFileName) 
{
	DWORD dwErr,dwDisposition;

	// Get access to the router registry key
	dwErr = UtlAccessRouterKey(&hkRouter);
	if (dwErr != ERROR_SUCCESS) {
		PrintMessage(L"Unable to access router key.\n");
		return dwErr;
	}

	// Restore the rip parameters from backup
	__try {
		// Open up the temporary key
		dwErr = RegCreateKeyEx(
		            hkRouter,
		            szTempKey,
		            0,
		            NULL,
		            0,
		            KEY_ALL_ACCESS,
		            NULL,
		            &hkTemp,
		            &dwDisposition);
		if (dwErr!=ERROR_SUCCESS)
			return dwErr;

		// Restore the saved registry information to 
		// the temp key
		UtlSetupRestorePrivilege(TRUE);
		dwErr = RegRestoreKeyW(
		            hkTemp,
		            BackupFileName,
		            0);
		if (dwErr != ERROR_SUCCESS) 
			return dwErr;
	}
	__finally {
		UtlSetupRestorePrivilege(FALSE);
	}
	
	return NO_ERROR;
}

// Function initializes the rip global information based 
// on the parameters saved from the iprip service.
//
//	1. Get the global info block for IP w/ MprConfigTransportGetInfo
//		- Add a IPRIP_GLOBAL_CONFIG (ipriprm.h) 
//        block initialized as in routemon (rip.c, protocol.c)
//		- Type is MS_IP_RIP as in sdk/inc/ipinfoid.h
//		- Mappings
//			Params.LoggingLevel to this global config blob
DWORD IpRipUpgradeGlobalInfo(
        IN dwt * RipParams) 
{
    DWORD dwErr, dwTransSize, dwVal, dwNewSize = 0;
    LPBYTE lpTransInfo=NULL, lpNewTransInfo=NULL;
    HANDLE hSvrConfig=NULL, hTransport=NULL;
    
    // Create/initialize an IPRIP_GLOBAL_CONFIG block
    IPRIP_GLOBAL_CONFIG RipGlobalConfig = {
        IPRIP_LOGGING_ERROR,        // Logging level
        1024 * 1024,                // Max recv-queue size
        1024 * 1024,                // Max send-queue size
        5,                          // Minimum triggered-update interval
        IPRIP_FILTER_DISABLED,      // Peer-filter mode
        0                           // Peer-filter count
    };    

    // Reset any values read from the previous iprip configuration
    dwErr = dwtGetValue(
                RipParams, 
                L"LoggingLevel", 
                &dwVal);
    if (dwErr == NO_ERROR) 
        RipGlobalConfig.GC_LoggingLevel=dwVal;

    __try {
        // Add the rip global config to ip's global config
        dwErr = MprConfigServerConnect(
                    NULL, 
                    &hSvrConfig);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = MprConfigTransportGetHandle(
                    hSvrConfig,
                    PID_IP,
                    &hTransport);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = MprConfigTransportGetInfo(
                    hSvrConfig,
                    hTransport,
                    &lpTransInfo,
                    &dwTransSize,
                    NULL,
                    NULL,
                    NULL);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = UtlUpdateInfoBlock(
                    TRUE,
                    lpTransInfo,
                    MS_IP_RIP,
                    sizeof(IPRIP_GLOBAL_CONFIG),
                    1,
                    (LPBYTE)&RipGlobalConfig,
                    &lpNewTransInfo,
                    &dwNewSize);
        if (dwErr != NO_ERROR)
            return dwErr;

        // Commit the information
        dwErr = MprConfigTransportSetInfo(
                    hSvrConfig,
                    hTransport,
                    lpNewTransInfo,
                    dwNewSize,
                    NULL,
                    0,
                    NULL);
                
        if (dwErr != NO_ERROR)
            return NO_ERROR;
    }
    __finally {
        if (lpTransInfo)
            MprConfigBufferFree(lpTransInfo);
        if (lpNewTransInfo)
            MprConfigBufferFree(lpNewTransInfo);
        if (hSvrConfig)
            MprConfigServerDisconnect(hSvrConfig);
    }

    return NO_ERROR;
}

// Returns whether this is a wks->srv or srv->srv upgrade
DWORD IpRipGetUpgradeType() {
    return SRV_TO_SRV;
}

// Migrates the silent rip parameter.
//	3. "SilentRip" param rules
//		- If wks->srv, announce=disabled, accept=rip1
//		- If srv->srv, announce=SilentRip, accept=rip1
DWORD IpRipMigrateRipSilence(
        IN OUT IPRIP_IF_CONFIG * RipIfConfig, 
        IN DWORD dwSilence, 
        IN BOOL IsWan) 
{
    DWORD UpgradeType = IpRipGetUpgradeType();
    if (IsWan) {
        if (UpgradeType == WKS_TO_SRV) {
            RipIfConfig->IC_AcceptMode = IPRIP_ACCEPT_RIP1_COMPAT;
            RipIfConfig->IC_AnnounceMode = IPRIP_ACCEPT_DISABLED;
        }
        else if (UpgradeType == SRV_TO_SRV) {
            RipIfConfig->IC_AcceptMode = IPRIP_ACCEPT_RIP1_COMPAT;
            RipIfConfig->IC_AnnounceMode = dwSilence;
        }
    }
    else {
        if (UpgradeType == WKS_TO_SRV) {
            RipIfConfig->IC_AcceptMode = IPRIP_ACCEPT_RIP1;
            RipIfConfig->IC_AnnounceMode = IPRIP_ACCEPT_DISABLED;
        }
        else if (UpgradeType == SRV_TO_SRV) {
            RipIfConfig->IC_AcceptMode = IPRIP_ACCEPT_RIP1;
            RipIfConfig->IC_AnnounceMode = dwSilence;
        }
    }

    return NO_ERROR;
}

DWORD IpRipSetParamFlag(
        IN  dwt * RipParams, 
        IN  PWCHAR ValName, 
        IN  DWORD dwFlag, 
        OUT DWORD * dwParam) 
{
    DWORD dwVal, dwErr;

    dwErr = dwtGetValue(RipParams, ValName, &dwVal);
    if (dwErr == NO_ERROR) {
        if (dwVal)
            *dwParam |= dwFlag;
        else
            *dwParam &= ~dwFlag;
    }

    return NO_ERROR;
}

// Update the lan interface parameters from previous config
DWORD IpRipUpdateIfConfig(
        IN  dwt * RipParams, 
        OUT IPRIP_IF_CONFIG * RipIfConfig, 
        IN  BOOL IsWan) 
{
    DWORD dwErr, dwVal;
    PARAM_TO_FLAG * pCurFlag;

    // Loop through all the parameter mappings, 
    // setting the appripriate flag in the rip config
    pCurFlag = &(ParamFlagTable[0]);
    while (pCurFlag->pszParam) {
        // Set the flag as appropriate
        IpRipSetParamFlag(
            RipParams, 
            pCurFlag->pszParam, 
            pCurFlag->dwFlag, 
            &(RipIfConfig->IC_ProtocolFlags));

        // Increment the enumeration
        pCurFlag++;
    }

    // Set the parameters migrated as parameters
    dwErr = dwtGetValue(RipParams, L"UpdateFrequency", &dwVal);
    if (dwErr == NO_ERROR) 
        RipIfConfig->IC_FullUpdateInterval = dwVal;
        
    dwErr = dwtGetValue(RipParams, L"RouteTimeout", &dwVal);
    if (dwErr == NO_ERROR) 
        RipIfConfig->IC_RouteExpirationInterval = dwVal;
        
    dwErr = dwtGetValue(RipParams, L"GarbageTimeout", &dwVal);
    if (dwErr == NO_ERROR) 
        RipIfConfig->IC_RouteRemovalInterval = dwVal;

    // Upgrade the silence parameter
    dwErr = dwtGetValue(RipParams, L"SilentRIP", &dwVal);
    if (dwErr == NO_ERROR)
        IpRipMigrateRipSilence(RipIfConfig, dwVal, IsWan);

    return NO_ERROR;
}

//
// Callback function takes an interface and updates
// its rip configuration.
//
// Returns TRUE to continue the enumerate, FALSE to 
// stop it
//
DWORD IpRipUpgradeInterface(
        IN HANDLE hConfig,
        IN MPR_INTERFACE_0 * pIf,
        IN HANDLE hUserData)
{
    RIP_IF_DATA * pData = (RIP_IF_DATA*)hUserData;
    IPRIP_IF_CONFIG * pConfig;
    HANDLE hTransport = NULL;
    LPBYTE pTransInfo=NULL, pNewTransInfo=NULL;
    DWORD dwErr, dwIfSize, dwNewTransSize = 0;

    // Validate lan and wan interfaces
    if ((hConfig == NULL) || 
        (pIf == NULL)     || 
        (pData == NULL))
    {
        return FALSE;
    }

    // Is this a LAN or a WAN interface 
    if (pIf->dwIfType == ROUTER_IF_TYPE_DEDICATED)
        pConfig = pData->pLanConfig;
    else if (pIf->dwIfType == ROUTER_IF_TYPE_HOME_ROUTER ||
             pIf->dwIfType == ROUTER_IF_TYPE_FULL_ROUTER)
        pConfig = pData->pWanConfig;
    else
        return TRUE;

    do {
        // Get the handle to ip info associated with this if
        dwErr = MprConfigInterfaceTransportGetHandle(
                    hConfig,
                    pIf->hInterface,
                    PID_IP,
                    &hTransport);
        if (dwErr != NO_ERROR)
            break;

        // Get the ip info associated with this if
        dwErr = MprConfigInterfaceTransportGetInfo(
                    hConfig,
                    pIf->hInterface,
                    hTransport,
                    &pTransInfo,
                    &dwIfSize);
        if (dwErr != NO_ERROR)
            break;

        // Update the info block with the rip data
        dwErr = UtlUpdateInfoBlock (
                    TRUE,
                    pTransInfo,
                    MS_IP_RIP,
                    sizeof(IPRIP_IF_CONFIG),
                    1,
                    (LPBYTE)pConfig,
                    &pNewTransInfo,
                    &dwNewTransSize);
        if (dwErr != NO_ERROR)
            break;

        // Commit the change
        dwErr = MprConfigInterfaceTransportSetInfo(
                    hConfig,
                    pIf->hInterface,
                    hTransport,
                    pNewTransInfo,
                    dwNewTransSize);
        if (dwErr != NO_ERROR)
            break;
            
    } while (FALSE);   

    // Cleanup
    {
        if (pNewTransInfo)
            MprConfigBufferFree(pNewTransInfo);
        if (pTransInfo)
            MprConfigBufferFree(pTransInfo);
    }

    return TRUE;
}
        


// Initializes the rip per-interface information based on the 
// parameters saved from the iprip service.
//
//	2. Get Interface info for each ras or lan ip interface
//      - Add an IPRIP_IF_CONFIG (ipriprm.h) block (type MS_IP_RIP)
//      - Initialize as per routemon
//      - Mappings
//          Params.AcceptHostRoutes - IC_ProtocolFlags (0=disable,1=enable)
//          Params.UpdateFreq...=FullUpdateInterval
//          Params.*Timeouts=
DWORD IpRipUpgradeInterfaces(
        IN dwt * RipParams) 
{
    DWORD dwErr;
    
    // Create/initialize an rip info blocks
    IPRIP_IF_CONFIG RipLanConfig = {
        0,                                  // State (read-only)
        1,                                  // Metric
        IPRIP_UPDATE_PERIODIC,              // Update mode
        IPRIP_ACCEPT_RIP1,                  // Accept mode
        IPRIP_ANNOUNCE_RIP1,                // Announce mode
        IPRIP_FLAG_SPLIT_HORIZON |
        IPRIP_FLAG_POISON_REVERSE |
        IPRIP_FLAG_GRACEFUL_SHUTDOWN |
        IPRIP_FLAG_TRIGGERED_UPDATES,       // Protocol flags
        180,                                // Route-expiration interval
        120,                                // Route-removal interval
        30,                                 // Full-update interval
        IPRIP_AUTHTYPE_NONE,                // Authentication type
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},  // Authentication key
        0,                                  // Route tag
        IPRIP_PEER_DISABLED,                // Unicast-peer mode
        IPRIP_FILTER_DISABLED,              // Accept-filter mode
        IPRIP_FILTER_DISABLED,              // Announce-filter mode
        0,                                  // Unicast-peer count
        0,                                  // Accept-filter count
        0                                   // Announce-filter count
    };
    
    IPRIP_IF_CONFIG RipWanConfig = {
        0,
        1,
        IPRIP_UPDATE_DEMAND,                // Update mode for WAN
        IPRIP_ACCEPT_RIP1,
        IPRIP_ANNOUNCE_RIP1,
        IPRIP_FLAG_SPLIT_HORIZON |
        IPRIP_FLAG_POISON_REVERSE |
        IPRIP_FLAG_GRACEFUL_SHUTDOWN,
        180,
        120,
        30,
        IPRIP_AUTHTYPE_NONE,
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        0,
        IPRIP_PEER_DISABLED,
        IPRIP_FILTER_DISABLED,
        IPRIP_FILTER_DISABLED,
        0,
        0,
        0
    };

    RIP_IF_DATA RipBlobs = 
    {
        &RipLanConfig,
        &RipWanConfig
    };

    // Update the lan config blob with values from previous 
    // installation of rip service.
    dwErr = IpRipUpdateIfConfig(RipParams, RipBlobs.pLanConfig, FALSE);
    if (dwErr != NO_ERROR)
        return dwErr;
        
    // Update the wan config blob with values from previous 
    // installation of rip service.
    dwErr = IpRipUpdateIfConfig(RipParams, RipBlobs.pWanConfig, TRUE);
    if (dwErr != NO_ERROR)
        return dwErr;

    // Enumerate the interfaces, updating each one with 
    // rip config as you go.
    dwErr = UtlEnumerateInterfaces(
                IpRipUpgradeInterface,
                &RipBlobs);
    if (dwErr != NO_ERROR)
        return dwErr;
        
    return NO_ERROR;
}

// Restores the Rip parameters that were saved before upgrade.  
// This function assumes that those parameters are being stored 
// temporarily in hkTemp
DWORD IpRipMigrateParams() {
	DWORD dwErr, dwVal;
	dwt RipParams;

	__try {
    	// Load in the parameters that were set for Rip
		dwErr = dwtLoadRegistyTable(&RipParams, hkTemp);
		if (dwErr != NO_ERROR)
			return dwErr;

        // Migrate the various types of paramters
        dwErr = IpRipUpgradeGlobalInfo(&RipParams);
        if (dwErr != NO_ERROR)
            return dwErr;

        // Migrate the per-interface parameters
        dwErr = IpRipUpgradeInterfaces(&RipParams);
        if (dwErr != NO_ERROR)
            return dwErr;
    }
	__finally {
		dwtCleanup(&RipParams);
	}

	return NO_ERROR;
}

// Cleanup the work done in the registry
DWORD IpRipCleanupRegistry() {
	if (hkTemp) 
		RegCloseKey(hkTemp);
	if (hkRouter) {
		RegDeleteKey(hkRouter, szTempKey);
		RegCloseKey(hkRouter);
	}
    hkTemp = NULL;
    hkRouter = NULL;
	return NO_ERROR;
}

// Upgrades iprip to nt 5.0 router
DWORD IpRipToRouterUpgrade(
        IN PWCHAR FileName) 
{
	DWORD dwErr;

	__try {
		// Restore the registry from the backup file
		dwErr = IpRipPrepareRegistry(FileName);
		if (dwErr != NO_ERROR)
			return dwErr;

		// Migrate rip's parameters to the appropriate 
		// new locations
		dwErr = IpRipMigrateParams();
		if (dwErr != NO_ERROR)
			return dwErr;

		// Mark the computer as having been configured
		//
        dwErr = UtlMarkRouterConfigured();
		if (dwErr != NO_ERROR) 
		{
			PrintMessage(L"Unable to mark router as configured.\n");
			return dwErr;
		}
			
	}
	__finally {
		IpRipCleanupRegistry();
	}

	return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\upgrade\tools\b3rasace\dsrights.h ===
/*
    File    dsrights.h

    header for project that establishes a ras server 
    in a domain.

    Paul Mayfield, 4/20/98
*/    

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <crypt.h>
#define INC_OLE2
#include <windows.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <raserror.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <locale.h>
#include <tchar.h>
#define SECURITY_WIN32
#include <sspi.h>

#include <activeds.h>
#include <adsi.h>
#include <ntdsapi.h>
#include <dsrole.h>
#include <dsgetdc.h>
#include <accctrl.h>
#include <aclapi.h>

#ifdef __cplusplus
extern "C" {
#endif

DWORD DsrTraceInit();
DWORD DsrTraceCleanup();

DWORD DsrTraceEx (DWORD dwErr, LPSTR pszTrace, ...);

#define DSR_ERROR(e) ((HRESULT_FACILITY((e)) == FACILITY_WIN32) ? HRESULT_CODE((e)) : (e));
#define DSR_FREE(s) if ((s)) DsrFree ((s))
#define DSR_RELEASE(s) if ((s)) (s)->Release();
#define DSR_BREAK_ON_FAILED_HR(_hr) {if (FAILED((_hr))) break;}

//
// Typedefs
//
typedef struct _DSRINFO 
{
    PWCHAR pszMachineDN;
    PWCHAR pszGroupDN;    
} DSRINFO;

//
// Memory management routines
//
PVOID 
DsrAlloc (
        IN DWORD dwSize, 
        IN BOOL bZero);
        
DWORD 
DsrFree (
        IN PVOID pvBuf);

//
// Searches given domain for a computer account 
// with the given name and returns its ADsPath
// if found.
//
DWORD 
DsrFindDomainComputer (
        IN  PWCHAR  pszDomain,
        IN  PWCHAR  pszComputer,
        OUT PWCHAR* ppszADsPath);

//
// Searches given domain for the well known 
// "RAS and IAS Servers" group and returns 
// its ADsPath if found.
//
DWORD 
DsrFindRasServersGroup (
        IN  PWCHAR  pszDomain,
        OUT PWCHAR* ppszADsPath);
        
//
// Adds or removes a given object from a given group.
//
DWORD 
DsrGroupAddRemoveMember(
        IN PWCHAR pszGroupDN,
        IN PWCHAR pszNewMemberDN,
        IN BOOL bAdd);

//
// Returns whether the given object is a member of
// the given group.
//
DWORD 
DsrGroupIsMember(
        IN  PWCHAR pszGroupDN, 
        IN  PWCHAR pszObjectName, 
        OUT PBOOL  pbIsMember);

// 
// Sets the ACES in the given domain to enable nt4 servers
//
DWORD
DsrDomainSetAccess(
    IN PWCHAR pszDomain,
    IN DWORD dwAccessFlags);

//
// Discovers whether security is such that nt4 ras servers
// can authenticate.
//
DWORD
DsrDomainQueryAccess(
    IN  PWCHAR pszDomain, 
    OUT LPDWORD lpdwAccessFlags);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\upgrade\steelhead2nt5\upgrade.c ===
/*
	File	upgrade.c
	
	Implementation of functions to update the registry when an
	NT 4.0  to NT 5.0 upgrade takes place.

	Paul Mayfield, 8/11/97

	Copyright 1997 Microsoft.
*/

#include "upgrade.h"

static const WCHAR szSteelheadKey[] = L"PreUpgradeRouter";
static const WCHAR szSapKey[]       = L"Sap.Parameters";
static const WCHAR szIpRipKey[]     = L"IpRip.Parameters";
static const WCHAR szDhcpKey[]      = L"RelayAgent.Parameters";
static const WCHAR szRadiusKey[]    = L"Radius.Parameters";
static const WCHAR szIpxRipKey[]    = L"IpxRip";

// Dll entry
BOOL 
WINAPI 
RtrUpgradeDllEntry (
    IN HINSTANCE hInstDll,
    IN DWORD fdwReason,
    IN LPVOID pReserved) 
{
    switch (fdwReason) 
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hInstDll);
            break;
    }

    return TRUE;
}

//
// Performs the various router upgrade scenarios
//
DWORD 
DispatchSetupWork(
    IN PWCHAR szAnswerFileName, 
    IN PWCHAR szSectionName) 
{
	HINF hInf = NULL;
	BOOL DoUpgrade;
	WCHAR szBuf[1024];
	DWORD dwSize = 1024;
	DWORD dwErr, dwRet = NO_ERROR;

	// Open the answer file
	hInf = SetupOpenInfFileW(
	        szAnswerFileName, 
	        NULL, 
	        INF_STYLE_OLDNT, 
	        NULL);
	if (hInf == INVALID_HANDLE_VALUE)
	{
		return GetLastError();
    }

	// Perform a steelhead upgrade
	//
	dwSize = sizeof(szBuf) / sizeof(WCHAR);
	if (SetupGetLineTextW(
	        NULL,
	        hInf,
	        szSectionName,
	        szSteelheadKey,
	        szBuf,
	        dwSize,
	        &dwSize)) 
    {
		dwErr = SteelheadToNt5Upgrade(szBuf);
		if (dwErr != NO_ERROR)
		{
			dwRet = dwErr;
	    }
	}

	// Perform an ipx sap upgrade
	//
	dwSize = sizeof(szBuf) / sizeof(WCHAR);
	if (SetupGetLineTextW(
	        NULL,
	        hInf,
	        szSectionName,
	        szSapKey,
	        szBuf,
	        dwSize,
	        &dwSize)) 
    {
		dwErr = SapToRouterUpgrade(szBuf);
		if (dwErr != NO_ERROR)
		{
			dwRet = dwErr;
	    }

	}

	// Perform an ip rip upgrade
	//
	dwSize = sizeof(szBuf) / sizeof(WCHAR);
	if (SetupGetLineTextW(
	        NULL,
	        hInf,
	        szSectionName,
	        szIpRipKey,
	        szBuf,
	        dwSize,
	        &dwSize)) 
    {
		dwErr = IpRipToRouterUpgrade(szBuf);
		if (dwErr != NO_ERROR)
		{
			dwRet = dwErr;
	    }
	}

	// Perform a dhcp relay agent upgrade
	//
	dwSize = sizeof(szBuf) / sizeof(WCHAR);
	if (SetupGetLineTextW(
	        NULL,
	        hInf,
	        szSectionName,
	        szDhcpKey,
	        szBuf,
	        dwSize,
	        &dwSize)) 
    {
		dwErr = DhcpToRouterUpgrade(szBuf);
		if (dwErr != NO_ERROR)
		{
			dwRet = dwErr;
	    }
	}

	// Perform a radius upgrade
	//
	dwSize = sizeof(szBuf) / sizeof(WCHAR);
	if (SetupGetLineTextW(
	        NULL,
	        hInf,
	        szSectionName,
	        szRadiusKey,
	        szBuf,
	        dwSize,
	        &dwSize)) 
    {
		dwErr = RadiusToRouterUpgrade(szBuf);
		if (dwErr != NO_ERROR)
		{
			dwRet = dwErr;
	    }
	}

	SetupCloseInfFile(hInf);

	return dwRet;
}

//
//	This is the entry point to upgrade mpr v1 and steelhead to
//	NT 5.0.  
//
HRESULT 
WINAPI 
RouterUpgrade (
    IN DWORD dwUpgradeFlag,
    IN DWORD dwUpgradeFromBuildNumber,
    IN PWCHAR szAnswerFileName,
    IN PWCHAR szSectionName) 
{
	DWORD dwErr;
	
	dwErr = DispatchSetupWork(szAnswerFileName, szSectionName);
	if (dwErr == NO_ERROR)
	{
		return S_OK;
    }

	UtlPrintErr(dwErr);
    
	return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\upgrade\steelhead2nt5\steelhead.c ===
/*
	File	Steelhead.c
	
	Implementation of functions to update the registry when an
	NT 4.0 Steelhead to NT 5.0 upgrade takes place.

	Paul Mayfield, 8/11/97

	Copyright 1997 Microsoft.
*/

#include "upgrade.h"
#include <wchar.h>
#include <rtcfg.h>

// 
// Macro for convenience
//
#define BREAK_ON_ERROR(_err) if ((_err)) break

//
// Defines a function to get nt4.0 interface name from a
// guid.
//
typedef HRESULT (*GetGuidFromInterfaceNameProc)(PWCHAR,LPGUID);

//
// The following define what is needed to infer guids from 4.0 
// interface names.
//
WCHAR NetCfgLibName[]           = L"netshell.dll";
CHAR  GuidProcName[]            = "HrGetInstanceGuidOfPreNT5NetCardInstance";
static const WCHAR c_szwInternalAdapter []  = L"Internal";
static const WCHAR c_szwLoopbackAdapter []  = L"Loopback";

GetGuidFromInterfaceNameProc GetGuid = NULL;

//  Function uses the application defined parameter to initialize the 
//  system of mapping old interface names to new ones.
//
DWORD SeedInterfaceNameMapper(
        OUT PHANDLE phParam) 
{
	HINSTANCE hLibModule;

	// Load the library
	hLibModule = LoadLibraryW(NetCfgLibName);
	if (hLibModule == NULL) {
		PrintMessage(L"Unable to load NetCfgLibName\n");
		return GetLastError();
	}

	// Get the appropriate function pointers
	GetGuid = (GetGuidFromInterfaceNameProc) 
	                GetProcAddress(hLibModule, GuidProcName);
	if (GetGuid == NULL) {
		PrintMessage(L"Unable to get GuidProcName\n");
		return ERROR_CAN_NOT_COMPLETE;
	}

	// Assign the return value
	*phParam = (HANDLE)hLibModule;

	return NO_ERROR;
}

//
// Cleans up the interface name mapper.
//
DWORD CleanupInterfaceNameMapper(HANDLE hParam) {
	HINSTANCE hLibModule = (HINSTANCE)hParam;
	
	if (hLibModule) {
		if (! FreeLibrary(hLibModule))
			PrintMessage(L"Unable to free library\n");
	}

	return NO_ERROR;
}

//
// Determines whether the type of interface being examined 
// should have its name changed.
//
BOOL IfNeedsNameUpdate(
        IN MPR_INTERFACE_0 * If) 
{
	// Validate parameters
	if (!If) {
		PrintMessage(L"Null interface passed to IfNeedsNameUpdate.\n");
		return FALSE;
	}

	// Only lan interfaces can have their names updated
    if (If->dwIfType == ROUTER_IF_TYPE_DEDICATED)
        return TRUE;

	return FALSE;
}

//
// Returns a pointer to the packet name portion of the 
// interface name if it exists.
//
PWCHAR FindPacketName(
        IN PWCHAR IfName) 
{
	PWCHAR res;
	
	if ((res = wcsstr(IfName,L"/Ethernet_SNAP")) != NULL)
		return res;
		
	if ((res = wcsstr(IfName,L"/Ethernet_II")) != NULL)
		return res;
		
	if ((res = wcsstr(IfName,L"/Ethernet_802.2")) != NULL)
		return res;
		
	if ((res = wcsstr(IfName,L"/Ethernet_802.3")) != NULL)
		return res;

	return NULL;
}

//
// Upgrades a packet name from the 4.0 convention to 
// the nt5 convention.
//
PWCHAR UpgradePktName(
            IN PWCHAR PacketName) 
{
	PWCHAR res;
	
	if ((res = wcsstr(PacketName,L"/Ethernet_SNAP")) != NULL)
		return L"/SNAP";
		
	if ((res = wcsstr(PacketName,L"/Ethernet_II")) != NULL)
		return L"/EthII";
		
	if ((res = wcsstr(PacketName,L"/Ethernet_802.2")) != NULL)
		return L"/802.2";
		
	if ((res = wcsstr(PacketName,L"/Ethernet_802.3")) != NULL)
		return L"/802.3";

	return L"";
}


//
// Provides the mapping between old interface names and new guid
// interface names.
//
DWORD UpdateInterfaceName(
        IN PWCHAR IName) 
{
	HRESULT hResult;
	GUID Guid;
	PWCHAR GuidName=NULL;
	PWCHAR PacketName=NULL;
	WCHAR SavedPacketName[MAX_INTEFACE_NAME_LEN];
	WCHAR SavedIName[MAX_INTEFACE_NAME_LEN];
	PWCHAR ptr;

	// Validate parameters
	if (! IName) {
		PrintMessage(L"Invalid parameter to UpdateInterfaceName.\n");
		return ERROR_INVALID_PARAMETER;
	}

	// Save off the packet name if it exists and remove if from the 
	// interface name
	wcscpy(SavedIName, IName);
	PacketName = FindPacketName(SavedIName);
	if (PacketName) {
		wcscpy(SavedPacketName, PacketName);
		*PacketName = 0;
	}

	// Get the guid of the interface name
	hResult = (*GetGuid)(SavedIName,&Guid);
	if (hResult != S_OK) {
		PrintMessage(L"Unable to get guid function.\n");
		return ERROR_CAN_NOT_COMPLETE;
	}
	
	// Format the guid as a string
	if (UuidToStringW(&Guid, &GuidName) != RPC_S_OK) {
		PrintMessage(L"Not enough memory to create guid string.\n");
		return ERROR_NOT_ENOUGH_MEMORY;
	}
	
	// Capitalize the guid string (all letters are hexidecimal
	// string characters)
	ptr = GuidName;
	while (ptr && *ptr) {
		if ((*ptr <= L'z') && (*ptr >= L'a'))
			*ptr = towupper(*ptr);
		ptr++;
	}

	// Change the interface name according to the new mapping
	if (PacketName) {
        wsprintf(IName, L"{%s}%s", GuidName, UpgradePktName(SavedPacketName)); 
	}
	else
		wsprintfW(IName,L"{%s}", GuidName);

	// Cleanup
	if (GuidName)
		RpcStringFreeW(&GuidName);

	return NO_ERROR;
}

//
// Provides the mapping between old interface names and new guid
// interface names.
//
DWORD UpdateIpxAdapterName(PWCHAR AName) {
	HRESULT hResult;
	GUID Guid;
	PWCHAR GuidName = NULL;
	PWCHAR PacketName = NULL;
	WCHAR SavedAName[MAX_INTEFACE_NAME_LEN];
	PWCHAR ptr = NULL;

	// Validate parameters
	if (!AName) {
		PrintMessage(L"Invalid parameter to UpdateIpxAdapterName.\n");
		return ERROR_INVALID_PARAMETER;
	}

	// Adapter names do not have packet types associated with them
	if (FindPacketName(AName)) 
	    return ERROR_CAN_NOT_COMPLETE;

	// Get the guid of the interface name
	hResult = (*GetGuid)(AName,&Guid);
	if (hResult!=S_OK) {
		PrintMessage(L"GetGuid function returned failure.\n");
		return ERROR_CAN_NOT_COMPLETE;
	}
	
	// Format the guid as a string
	if (UuidToStringW(&Guid,&GuidName) != RPC_S_OK) {
		PrintMessage(L"Uuid to string failed.\n");
		return ERROR_NOT_ENOUGH_MEMORY;
	}
	// Capitalize the guid string
	ptr = GuidName;
	while (ptr && *ptr) {
		if ((*ptr <= L'z') && (*ptr >= L'a'))
			*ptr = towupper(*ptr);
		ptr++;
	}

	// Change the adapter name according to the new mapping
	wsprintfW(AName, L"{%s}", GuidName);

	// Cleanup
	if (GuidName)
		RpcStringFreeW(&GuidName);

	return NO_ERROR;
}

//
// Update the interface name stored in the adapter info blob
//
DWORD UpdateIpxAdapterInfo(
        IN  PIPX_ADAPTER_INFO AdapterInfop, 
        OUT PIPX_ADAPTER_INFO * NewAdapterInfop,
        OUT DWORD * NewSize) 
{
	DWORD dwErr;

	// Validate parameters
	if (! (AdapterInfop && NewAdapterInfop && NewSize)) {
		PrintMessage(L"Invalid params to UpdateIpxAdapterInfo.\n");
		return ERROR_INVALID_PARAMETER;
	}
	
	// Allocate a new adapter
	*NewAdapterInfop = (PIPX_ADAPTER_INFO) 
	                        UtlAlloc(sizeof(IPX_ADAPTER_INFO));
	if (! (*NewAdapterInfop)) {
		PrintMessage(L"Unable to allocate NewAdapterInfo.\n");
		return ERROR_NOT_ENOUGH_MEMORY;
	}
	
	// Copy into the new interface name
	(*NewAdapterInfop)->PacketType = AdapterInfop->PacketType;
	wcscpy(
	    (*NewAdapterInfop)->AdapterName, 
	    AdapterInfop->AdapterName);	

	// Update the interface name
	dwErr = UpdateIpxAdapterName((*NewAdapterInfop)->AdapterName);
	if (dwErr != NO_ERROR) {
		PrintMessage(L"UpdateIpxAdapterName failed.\n");
		return dwErr;
	}
	*NewSize = sizeof(IPX_ADAPTER_INFO);

	return NO_ERROR;
}

//
// Update all of the ipx related interface 
// information in the router configuration
//
DWORD UpdateIpxIfData(
        IN HANDLE hConfig,
        IN HANDLE hInterface)
{
	PIPX_ADAPTER_INFO AdapterInfop;
	PIPX_ADAPTER_INFO NewAdapterInfop;
	DWORD dwErr, dwCount, dwSize, dwNewSize, dwTransSize;
	HANDLE hTransport;
	LPBYTE pTransInfo = NULL, pNewInfo = NULL;

	// Validate parameters
	if (!hConfig || !hInterface) 
	{
		PrintMessage(L"Invalid params passed to UpdateIpxIfData.\n");
		return ERROR_INVALID_PARAMETER;
	}

    do {
        // Update the ipx interface info since this protocol
        // stores interface specific info in the transport
        // info blob (shame shame).
        dwErr = MprConfigInterfaceTransportGetHandle(
                    hConfig,
                    hInterface,
                    PID_IPX,
                    &hTransport);
        if (dwErr != NO_ERROR)
    	    break;
            
        // Update the adapter info blob
        dwErr = MprConfigInterfaceTransportGetInfo(
                    hConfig,
                    hInterface,
                    hTransport,
                    &pTransInfo,
                    &dwTransSize);
        if (dwErr != NO_ERROR) {
    	    PrintMessage(L"Unable to get transport info for ipx.\n");
    	    break;
        }

    	// Get the adapter info associated with this interface
    	dwErr = MprInfoBlockFind(
    	            pTransInfo,
    	            IPX_ADAPTER_INFO_TYPE,
    	            &dwSize,
    	            &dwCount,
    	            (LPBYTE*)&AdapterInfop);
        if (dwErr != NO_ERROR) {	            
    		PrintMessage(L"ERROR - null adapter information.\n");
    		break;
    	}

    	// Change the name of the referenced adapter
    	dwErr = UpdateIpxAdapterInfo(AdapterInfop, &NewAdapterInfop, &dwNewSize);
    	if (dwErr != NO_ERROR) {
    		PrintMessage(L"UpdateIpxAdapterInfo failed.\n");
    		break;
    	}
    	
    	dwErr = MprInfoBlockSet(
    	            pTransInfo,
    	            IPX_ADAPTER_INFO_TYPE,
    	            dwNewSize,
    	            1,
    	            (LPVOID)NewAdapterInfop,
    	            &pNewInfo);
    	            
    	if (dwErr != NO_ERROR) {
    		PrintMessage(L"MprInfoBlockSet failed.\n");
    		break;
    	}

        dwNewSize = ((PRTR_INFO_BLOCK_HEADER)pNewInfo)->Size;

        // Commit the change
        dwErr = MprConfigInterfaceTransportSetInfo(
                    hConfig,
                    hInterface,
                    hTransport,
                    pNewInfo,
                    dwNewSize);
        if (dwErr != NO_ERROR) {
    	    PrintMessage(L"Unable to set ipx transport info.\n");
    	    break;
        }
    } while (FALSE);

    // Cleanup
    {
        if (pTransInfo)
    	    MprConfigBufferFree(pTransInfo);
    	if (pNewInfo)
    	    MprConfigBufferFree(pNewInfo);
    }    	    

	return dwErr;
}

//
// Updates the ip interface info
//
DWORD
UpdateIpIfData(
        IN HANDLE hConfig,
        IN HANDLE hInterface)
{
    PMIB_IPFORWARDROW   pRoutes;
	DWORD dwErr, dwCount, dwSize, dwNewSize, dwTransSize, dwInd;
	HANDLE hTransport;
	LPBYTE pTransInfo = NULL, pNewInfo = NULL;

    pRoutes = NULL;

	// Validate parameters
	if (!hConfig || !hInterface) 
	{
		PrintMessage(L"Invalid params passed to UpdateIpIfData.\n");
		return ERROR_INVALID_PARAMETER;
	}

    do {
        // Update the ipx interface info since this protocol
        // stores interface specific info in the transport
        // info blob (shame shame).
        dwErr = MprConfigInterfaceTransportGetHandle(
                    hConfig,
                    hInterface,
                    PID_IP,
                    &hTransport);
        if (dwErr != NO_ERROR)
    	    break;
            
        // Update the adapter info blob
        dwErr = MprConfigInterfaceTransportGetInfo(
                    hConfig,
                    hInterface,
                    hTransport,
                    &pTransInfo,
                    &dwTransSize);
        if (dwErr != NO_ERROR) {
    	    PrintMessage(L"Unable to get transport info for ip.\n");
    	    break;
        }

    	// Get the adapter info associated with this interface
    	dwErr = MprInfoBlockFind(
    	            pTransInfo,
    	            IP_ROUTE_INFO,
    	            &dwSize,
    	            &dwCount,
    	            (LPBYTE*)&pRoutes);
        if (dwErr != NO_ERROR) {	            
    		PrintMessage(L"Unable to find ip route info.\n");
    		break;
    	}

        // Update the protocol id's
        for(dwInd = 0; dwInd < dwCount; dwInd++)
        {
            if((pRoutes[dwInd].dwForwardProto == MIB_IPPROTO_LOCAL) ||
               (pRoutes[dwInd].dwForwardProto == MIB_IPPROTO_NETMGMT))
            {
                pRoutes[dwInd].dwForwardProto = MIB_IPPROTO_NT_STATIC;
            }
        }

        // Commit the info
    	dwErr = MprInfoBlockSet(
    	            pTransInfo,
    	            IP_ROUTE_INFO,
    	            dwSize,
    	            dwCount,
    	            (LPVOID)pRoutes,
    	            &pNewInfo);
    	            
    	if (dwErr != NO_ERROR) {
    		PrintMessage(L"MprInfoBlockSet failed.\n");
    		break;
    	}

        dwNewSize = ((PRTR_INFO_BLOCK_HEADER)pNewInfo)->Size;

        // Commit the change
        dwErr = MprConfigInterfaceTransportSetInfo(
                    hConfig,
                    hInterface,
                    hTransport,
                    pNewInfo,
                    dwNewSize);
        if (dwErr != NO_ERROR) {
    	    PrintMessage(L"Unable to set ip transport info.\n");
    	    break;
        }
    } while (FALSE);

    // Cleanup
    {
        if (pTransInfo)
    	    MprConfigBufferFree(pTransInfo);
    	if (pNewInfo)
    	    MprConfigBufferFree(pNewInfo);
    }    	    

	return dwErr;
}

//
// Flushes the name in given interface name to the registry.
//
DWORD CommitInterfaceNameChange(
        IN MPR_INTERFACE_0 * If) 
{
	DWORD dwErr;
	WCHAR c_szInterfaceName[] = L"InterfaceName";
    INTERFACECB* pinterface;

	// Validate parameters
	if (!If) {
		PrintMessage(L"Invalid param to CommitInterfaceNameChange.\n");
		return ERROR_INVALID_PARAMETER;
	}
	
    // Set the name
    pinterface = (INTERFACECB*)If->hInterface;
    dwErr = RegSetValueExW(
                pinterface->hkey, 
                c_szInterfaceName, 
                0, 
                REG_SZ,
                (LPCSTR)(If->wszInterfaceName),
                (lstrlen(If->wszInterfaceName)+1)*sizeof(WCHAR)); 

	if (dwErr != ERROR_SUCCESS)
		PrintMessage(L"RegSetValueEx err in CommitIfNameChange.\n");

	if (dwErr == ERROR_SUCCESS)
		return NO_ERROR;

	return dwErr;
}

//
// Creates a default ip interface blob
//
DWORD 
IpCreateDefaultInterfaceInfo(
    OUT LPBYTE* ppInfo,
    OUT LPDWORD lpdwSize)
{
    PBYTE pInfo = NULL, pNewInfo = NULL;
    DWORD dwErr = NO_ERROR;
    //MIB_IPFORWARDROW RouteInfo;
    INTERFACE_STATUS_INFO StatusInfo;
    RTR_DISC_INFO DiscInfo;

    do
    {
        // Create the blob
        //
        dwErr = MprInfoCreate(RTR_INFO_BLOCK_VERSION, &pInfo);
        BREAK_ON_ERROR(dwErr);

        // Add an the route info 
        //
        //ZeroMemory(&RouteInfo, sizeof(RouteInfo));        
        //dwErr = MprInfoBlockAdd(
        //            pInfo,
        //            IP_ROUTE_INFO,
        //            sizeof(MIB_IPFORWARDROW),
        //            1,
        //            (LPBYTE)&RouteInfo,
        //            &pNewInfo);
        //MprConfigBufferFree(pInfo);
        //pInfo = pNewInfo;
        //pNewInfo = NULL;
        //BREAK_ON_ERROR(dwErr);
        
        // Add an the status info 
        //
        ZeroMemory(&StatusInfo, sizeof(StatusInfo));        
        StatusInfo.dwAdminStatus = MIB_IF_ADMIN_STATUS_UP;
        dwErr = MprInfoBlockAdd(
                    pInfo,
                    IP_INTERFACE_STATUS_INFO,
                    sizeof(INTERFACE_STATUS_INFO),
                    1,
                    (LPBYTE)&StatusInfo,
                    &pNewInfo);
        MprConfigBufferFree(pInfo);
        pInfo = pNewInfo;
        pNewInfo = NULL;
        BREAK_ON_ERROR(dwErr);
        
        // Add an the disc info 
        //
        ZeroMemory(&DiscInfo, sizeof(DiscInfo));        
        DiscInfo.bAdvertise        = FALSE;
        DiscInfo.wMaxAdvtInterval  = DEFAULT_MAX_ADVT_INTERVAL;
        DiscInfo.wMinAdvtInterval  = (WORD) 
            (DEFAULT_MIN_ADVT_INTERVAL_RATIO * DEFAULT_MAX_ADVT_INTERVAL);
        DiscInfo.wAdvtLifetime     = (WORD)
            (DEFAULT_ADVT_LIFETIME_RATIO * DEFAULT_MAX_ADVT_INTERVAL);
        DiscInfo.lPrefLevel        = DEFAULT_PREF_LEVEL;
        dwErr = MprInfoBlockAdd(
                    pInfo,
                    IP_ROUTER_DISC_INFO,
                    sizeof(PRTR_DISC_INFO),
                    1,
                    (LPBYTE)&DiscInfo,
                    &pNewInfo);
        MprConfigBufferFree(pInfo);
        pInfo = pNewInfo;
        pNewInfo = NULL;
        BREAK_ON_ERROR(dwErr);

        // Assign the return value
        //
        *ppInfo = pInfo;                    
        *lpdwSize = ((PRTR_INFO_BLOCK_HEADER)pInfo)->Size;

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

// 
// Adds an ip interface blob to the given interface
//
DWORD
IpAddDefaultInfoToInterface(
    IN HANDLE hConfig,
    IN HANDLE hIf)
{
    HANDLE hIfTrans = NULL;
    LPBYTE pInfo = NULL;
    DWORD dwErr = 0, dwSize = 0;

    do 
    {
        // If the transport blob already exists, there's
        // nothing to do.
        //
        dwErr = MprConfigInterfaceTransportGetHandle(
                    hConfig,
                    hIf,
                    PID_IP,
                    &hIfTrans);
        if ((dwErr == NO_ERROR) || (hIfTrans != NULL))
        {
            dwErr = NO_ERROR;
            break;
        }
    
        // Create the info blob
        //
        dwErr = IpCreateDefaultInterfaceInfo(&pInfo, &dwSize);
        BREAK_ON_ERROR(dwErr);

        // Add the ip transport to the interface
        //
        dwErr = MprConfigInterfaceTransportAdd(
                    hConfig,
                    hIf,
                    PID_IP,
                    NULL,
                    pInfo, 
                    dwSize,
                    &hIfTrans);
        BREAK_ON_ERROR(dwErr);                    

    } while (FALSE);

    // Cleanup
    {
        if (pInfo)
        {
            MprConfigBufferFree(pInfo);
        }
    }

    return dwErr;
}

//
// Function called to add the loopback and internal interfaces which
// are required if IP was installed and which wouldn't be installed
// in nt4.
//
DWORD
IpCreateLoopbackAndInternalIfs(
    IN HANDLE hConfig)
{
    DWORD dwErr = NO_ERROR;
    MPR_INTERFACE_0 If0, *pIf0 = &If0;
    HANDLE hIf = NULL;
    
    do
    {
        // If the loopback interface is not already installed,
        // go ahead and create it
        //
        dwErr = MprConfigInterfaceGetHandle(
                    hConfig,
                    (PWCHAR)c_szwLoopbackAdapter,
                    &hIf);
        if (dwErr != NO_ERROR)
        {
            // Initialize the loopback interface info
            //
            ZeroMemory(pIf0, sizeof(MPR_INTERFACE_0));
            wcscpy(pIf0->wszInterfaceName, c_szwLoopbackAdapter);
            pIf0->hInterface = INVALID_HANDLE_VALUE;
            pIf0->fEnabled = TRUE;
            pIf0->dwIfType = ROUTER_IF_TYPE_LOOPBACK;

            // Create the loopback interface        
            dwErr = MprConfigInterfaceCreate(hConfig, 0, (LPBYTE)pIf0, &hIf);
            BREAK_ON_ERROR(dwErr);
        }

        // Add an ip interface blob to the interface if not already there
        //
        dwErr = IpAddDefaultInfoToInterface(hConfig, hIf);   
        BREAK_ON_ERROR(dwErr);
        hIf = NULL;

        // Make sure internal interface gets installed
        // (will be there if IPX was installed)
        //
        dwErr = MprConfigInterfaceGetHandle(
                    hConfig,
                    (PWCHAR)c_szwInternalAdapter,
                    &hIf);
        if (dwErr != NO_ERROR)
        {
            // Initialize the internal interface info
            //
            ZeroMemory(pIf0, sizeof(MPR_INTERFACE_0));
            wcscpy(pIf0->wszInterfaceName, c_szwInternalAdapter);
            pIf0->hInterface = INVALID_HANDLE_VALUE;
            pIf0->fEnabled = TRUE;
            pIf0->dwIfType = ROUTER_IF_TYPE_INTERNAL;

            // Create the internal interface        
            dwErr = MprConfigInterfaceCreate(hConfig, 0, (LPBYTE)pIf0, &hIf);
            BREAK_ON_ERROR(dwErr);
        }

        // Add an ip interface blob to the interface if not already there
        //
        dwErr = IpAddDefaultInfoToInterface(hConfig, hIf);   
        BREAK_ON_ERROR(dwErr);
        
    } while (FALSE);        

    // Cleanup
    {
    }

    return dwErr;
}

//
// Callback to interface enumeration function that upgrades
// the interface names.
//
// Returns TRUE to continue the enumeration, FALSE to stop 
// it.
//
BOOL SteelHeadUpgradeInterface (
        IN HANDLE hConfig,          
        IN MPR_INTERFACE_0 * pIf,   
        IN HANDLE hUserData)
{
    DWORD dwErr;

    do {
        if (IfNeedsNameUpdate(pIf))
        {
    	    // Update the interface name
    	    dwErr = UpdateInterfaceName(pIf->wszInterfaceName);
    	    if (dwErr != NO_ERROR) {
    		    PrintMessage(L"UpdateIfName failed -- returning error.\n");
    		    UtlPrintErr(GetLastError());
    		    break;
    	    }

    	    // Commit the changed interface name
    	    dwErr = CommitInterfaceNameChange(pIf);  
    	    if (dwErr != NO_ERROR) {
    		    PrintMessage(L"CommitInterfaceNameChange failed.\n");
    		    break;
    	    }

    	    // Update the ipx data
    	    UpdateIpxIfData(
                hConfig,
                pIf->hInterface);
        }    	    

	    // Update the ip data
	    UpdateIpIfData(
            hConfig,
            pIf->hInterface);

    } while (FALSE);

    // Cleanup
    {
    }

    return TRUE;
}

//
//	Function	UpdateIpxInterfaces
//
//	Updates all of the interfaces as needed to 
//  upgrade the router from steelhead to nt5
//
DWORD UpdateInterfaces() {
    DWORD dwErr = NO_ERROR;
    HANDLE hConfig = NULL;

    do
    {
        // Enumerate the interfaces, upgrading the interface 
        // names, etc as we go.
        //
        dwErr = UtlEnumerateInterfaces(
                    SteelHeadUpgradeInterface,
                    NULL);
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }
        
        // If ip is installed, we need to add the loopback and
        // internal interface for ip.
        dwErr = MprConfigServerConnect(NULL, &hConfig);
        if (dwErr != NO_ERROR)
        {
            break;
        }
        
        dwErr = IpCreateLoopbackAndInternalIfs(hConfig);
        if (dwErr != NO_ERROR)
        {
            break;
        }
            
    } while (FALSE);        

    // Cleanup
    {
        if (hConfig)
        {
            MprConfigServerDisconnect(hConfig);
        }
    }

    return dwErr;
}

// Copy any values that are in hkSrc but not in hkDst into hkDst.
DWORD MergeRegistryValues(HKEY hkDst, HKEY hkSrc) {
    DWORD dwErr, dwCount, dwNameSize, dwDataSize;
    DWORD dwType, i, dwCurNameSize, dwCurValSize;
    PWCHAR pszNameBuf, pszDataBuf;
    
    // Find out how many values there are in the source
    dwErr = RegQueryInfoKey (hkSrc,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             &dwCount,
                             &dwNameSize,
                             &dwDataSize,
                             NULL,
                             NULL);
    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    dwNameSize++;
    dwDataSize++;

    __try {
        // Allocate the buffers
        pszNameBuf = (PWCHAR) UtlAlloc(dwNameSize * sizeof(WCHAR));
        pszDataBuf = (PWCHAR) UtlAlloc(dwDataSize * sizeof(WCHAR));
        if (!pszNameBuf || !pszDataBuf)
            return ERROR_NOT_ENOUGH_MEMORY;

        // Loop through the values
        for (i = 0; i < dwCount; i++) {
            dwCurNameSize = dwNameSize;
            dwCurValSize = dwDataSize;

            // Get the current source value 
            dwErr = RegEnumValueW(
                        hkSrc, 
                        i, 
                        pszNameBuf, 
                        &dwCurNameSize,
                        0,
                        &dwType,
                        (LPBYTE)pszDataBuf,
                        &dwCurValSize);
            if (dwErr != ERROR_SUCCESS)
                continue;

            // Find out if a value of the same name exists 
            // in the destination key. If it does, we don't 
            // overwrite it.
            dwErr = RegQueryValueExW(
                        hkDst, 
                        pszNameBuf, 
                        NULL, 
                        NULL, 
                        NULL, 
                        NULL);
            if (dwErr == ERROR_SUCCESS)
                continue;

            // Copy the value over
            RegSetValueExW(
                hkDst, 
                pszNameBuf, 
                0, 
                dwType, 
                (LPBYTE)pszDataBuf, 
                dwCurValSize);
        }
    }
    __finally {
        if (pszNameBuf)
            UtlFree(pszNameBuf);
        if (pszDataBuf)
            UtlFree(pszDataBuf);
    }

    return NO_ERROR;
}

// Recursively copies all of the subkeys of the given registry source to the
// given registry destination.
DWORD CopyRegistryKey(
        IN HKEY hkDst, 
        IN HKEY hkSrc, 
        IN PWCHAR pszSubKey, 
        IN LPSTR pszTempFile) 
{
    DWORD dwErr;
    HKEY hkSrcTemp;

    // Open the subkey in the source
    dwErr = RegOpenKeyExW(hkSrc, pszSubKey, 0, KEY_ALL_ACCESS, &hkSrcTemp);
    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    // Save off that subkey in a temporary file
    if ((dwErr = RegSaveKeyA(hkSrcTemp, pszTempFile, NULL)) != ERROR_SUCCESS)
        return dwErr;

    // Copy the saved information into the new key
    RegRestoreKeyA(hkDst, pszTempFile, 0);

    // Close off the temporary source key
    RegCloseKey(hkSrcTemp);

    // Delete the temp file
    DeleteFileA(pszTempFile);

    return NO_ERROR;
}

// Filters which subkeys in the router registry hive should be
// overwritten with saved off values during upgrade.
BOOL OverwriteThisSubkey(PWCHAR pszSubKey) {
    if (_wcsicmp(pszSubKey, L"Interfaces") == 0)
        return TRUE;
        
    if (_wcsicmp(pszSubKey, L"RouterManagers") == 0)
        return TRUE;
        
    return FALSE;
}

// Copy all keys that are in hkSrc but not in hkDst into hkDst.  
// By copy we mean all subkeys and values are propagated over.
DWORD MergeRegistryKeys(HKEY hkDst, HKEY hkSrc) {
    DWORD dwErr, dwCount, dwNameSize, dwType, i;
    DWORD dwCurNameSize, dwDisposition;
    char pszTempFile[512], pszTempPath[512];
    PWCHAR pszNameBuf;
    HKEY hkTemp;

    // Create the path to the temp file directory
    if (!GetTempPathA(512, pszTempPath))
        return GetLastError();

    // Create the temp file name
    if (!GetTempFileNameA(pszTempPath, "rtr", 0, pszTempFile))
        return GetLastError();

    // Delete the temp file created with GetTempFileName(...)
    DeleteFileA(pszTempFile);

    // Find out how many keys there are in the source
    dwErr = RegQueryInfoKey (
                hkSrc,
                NULL,
                NULL,
                NULL,
                &dwCount,
                &dwNameSize,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL);
    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    dwNameSize++;

    __try {
        // Allocate the buffers
        pszNameBuf = (PWCHAR) UtlAlloc(dwNameSize * sizeof(WCHAR));
        if (!pszNameBuf)
            return ERROR_NOT_ENOUGH_MEMORY;

        // Loop through the keys
        for (i = 0; i < dwCount; i++) {
            dwCurNameSize = dwNameSize;

            // Get the current source key 
            dwErr = RegEnumKeyExW(
                        hkSrc, 
                        i, 
                        pszNameBuf, 
                        &dwCurNameSize,
                        0,
                        NULL,
                        NULL,
                        NULL);
            if (dwErr != ERROR_SUCCESS)
                continue;

            // Create the new subkey in the destination
            dwErr = RegCreateKeyExW(
                        hkDst, 
                        pszNameBuf, 
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_ALL_ACCESS,
                        NULL,
                        &hkTemp, 
                        &dwDisposition);
            if (dwErr != ERROR_SUCCESS)
                continue;

            // If the subkey was created (not opened), 
            // copy over the key from hkSrc
            if (dwDisposition == REG_CREATED_NEW_KEY) {
                CopyRegistryKey(
                    hkTemp, 
                    hkSrc, 
                    pszNameBuf, 
                    pszTempFile);
            }                    
            
            // Otherwise, if this is one of the keys that we 
            // should overwrite, do so now.
            else {
                if (OverwriteThisSubkey(pszNameBuf)) {
                    CopyRegistryKey(
                        hkTemp, 
                        hkSrc, 
                        pszNameBuf, 
                        pszTempFile);
                }                        
            }

            // Close up the temporary handles
            RegCloseKey(hkTemp);
            hkTemp = NULL;
        }
    }
    __finally {
        if (pszNameBuf)
            UtlFree(pszNameBuf);
    }

    return NO_ERROR;
}

// Restore the registry from from backup
//
DWORD 
RestoreRegistrySteelhead(
    IN PWCHAR pszBackup) 
{
	HKEY hkRouter = NULL, hkRestore = NULL;
	DWORD dwErr = NO_ERROR, dwDisposition;
    PWCHAR pszRestore = L"Temp";

	// Merge the router key values and sub keys with the 
	// remote access key
	do
	{
	    // Get access to the router registry key
	    //
	    dwErr = UtlAccessRouterKey(&hkRouter);
	    if (dwErr != NO_ERROR) 
	    {
		    PrintMessage(L"Unable to access router key.\n");
		    break;
	    }

        // Load in the saved router settings
        //
        dwErr = UtlLoadSavedSettings(
                    hkRouter,
                    pszRestore,
                    pszBackup,
                    &hkRestore);
        if (dwErr != NO_ERROR)
        {   
            break;
        }

        // Merge all of the values in the restored key
        //
        dwErr = MergeRegistryValues(hkRouter, hkRestore);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Give yourself backup and restore privilege
        //
        UtlSetupBackupPrivelege (TRUE);
        UtlSetupRestorePrivilege(TRUE);

        // Merge all of the keys in the restored key
        //
        dwErr = MergeRegistryKeys(hkRouter, hkRestore);
        if (dwErr != NO_ERROR)
        {   
            break;
        }

	} while (FALSE);

    // Cleanup
	{
        if (hkRestore)
        {
            UtlDeleteRegistryTree(hkRestore);
            RegCloseKey(hkRestore);
            RegDeleteKey(hkRouter, pszRestore);
        }
        if (hkRouter)
        {
		    RegCloseKey(hkRouter);
		}
        UtlSetupBackupPrivelege (FALSE);
        UtlSetupRestorePrivilege(FALSE);
	}
	
	return NO_ERROR;
}

//
// Upgrades the remoteaccess registry with the router 
// configuration from nt4.
//
DWORD SteelheadToNt5Upgrade (PWCHAR BackupFileName) {
	DWORD dwErr = NO_ERROR;
	HANDLE hMapperParam;

	do
	{
		// Prepare the old interface name -> new if name mapper
		dwErr = SeedInterfaceNameMapper(&hMapperParam);
		if (dwErr != NO_ERROR) 
		{
			PrintMessage(L"Unable to seed if name mapper.\n");
		}
		else
		{
    		// Copy all of registry data that has been backed up.
    		dwErr = RestoreRegistrySteelhead(BackupFileName);
    		if (dwErr != NO_ERROR) 
    		{
    			PrintMessage(L"Unable to restore registry.\n");
    		}
    		else
    		{
        		// Update all of the interfaces accordingly
        		dwErr = UpdateInterfaces();
        		if (dwErr != NO_ERROR) 
        		{
        			PrintMessage(L"Unable to update interfaces.\n");
        		}
    		}
		}

		// Add 'router' usage to all ports
		//
		dwErr = MprPortSetUsage(MPRFLAG_PORT_Router);
		if (dwErr != NO_ERROR) 
		{
			PrintMessage(L"Unable to update interfaces.\n");
		}

		// Mark the computer as having been configured
		//
        dwErr = UtlMarkRouterConfigured();
		if (dwErr != NO_ERROR) 
		{
			PrintMessage(L"Unable to mark router as configured.\n");
		}

	} while (FALSE);

	// Cleanup
	{
		CleanupInterfaceNameMapper(hMapperParam);
	}

	return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\upgrade\steelhead2nt5\utils.h ===
/*
	File	uitls.h

	A set of utilities useful for upgrading mpr v1 to NT 5.0.

	Paul Mayfield, 9/11/97
*/

#ifndef _rtrupg_utils_h
#define _rtrupg_utils_h

// 
// Definitions for a DWORD table (dwt)
// 
typedef struct _tag_dwValueNode 
{
	PWCHAR Name;
	DWORD Value;
} dwValueNode;

typedef struct _tag_DWordTable 
{
	DWORD dwCount;
	DWORD dwSize;
	dwValueNode * pValues;
} dwt, *pdwt;

//
// Typedef for callback functions in interface enumeration.
// Return TRUE to continue the enumeration, FALSE to stop it.
//
typedef 
BOOL 
(*IfEnumFuncPtr)(
    IN HANDLE hConfig,          // MprConfig handle
    IN MPR_INTERFACE_0 * pIf,   // Interface reference
    IN HANDLE hUserData);       // User defined

//
// Typedef for callback functions for enumerating registry sub keys.
// Return NO_ERROR to continue, error code to stop.
//
typedef 
DWORD
(*RegKeyEnumFuncPtr)(
    IN PWCHAR pszName,          // sub key name
    IN HKEY hKey,               // sub key
    IN HANDLE hData);

//
// Functions that manipulate dword tables
//
DWORD 
dwtInitialize(
    IN dwt *This, 
    IN DWORD dwCount, 
    IN DWORD dwMaxSize);
    
DWORD 
dwtCleanup(
    IN dwt *This);
    
DWORD 
dwtPrint(IN dwt *This);

DWORD 
dwtGetValue(
    IN  dwt *This, 
    IN  PWCHAR ValName, 
    OUT LPDWORD pValue);
    
DWORD 
dwtLoadRegistyTable(
    IN dwt *This, 
    IN HKEY hkParams);

// 
// Enumerates interfaces from the registry
//
DWORD 
UtlEnumerateInterfaces (
    IN IfEnumFuncPtr pCallback,
    IN HANDLE hUserData);

DWORD
UtlEnumRegistrySubKeys(
    IN HKEY hkRoot,
    IN PWCHAR pszPath,
    IN RegKeyEnumFuncPtr pCallback,
    IN HANDLE hData);

//
// If the given info blob exists in the given toc header
// reset it with the given information, otherwise add
// it as an entry in the TOC.
//
DWORD 
UtlUpdateInfoBlock (
    IN  BOOL    bOverwrite,
    IN  LPVOID  pHeader,
    IN  DWORD   dwEntryId,
    IN  DWORD   dwSize,
    IN  DWORD   dwCount,
    IN  LPBYTE  pEntry,
    OUT LPVOID* ppNewHeader,
    OUT LPDWORD lpdwNewSize);

//
// Other handy definitions
//
#if DBG
	#define PrintMessage OutputDebugStringW
#else
	#define PrintMessage 
#endif

// Common allocation routine
PVOID 
UtlAlloc (
    IN DWORD dwSize);

// Common deallocation routine
VOID 
UtlFree (
    PVOID pvBuffer);

PWCHAR
UtlDupString(
    IN PWCHAR pszString);
    
// Error printing
void 
UtlPrintErr(
    DWORD err);

// Helper functions
DWORD 
UtlAccessRouterKey(
    HKEY* hkeyRouter);
    
DWORD 
UtlSetupBackupPrivelege(
    BOOL bEnable);
    
DWORD 
UtlSetupRestorePrivilege(
    BOOL bEnable);

DWORD 
UtlLoadSavedSettings(
    IN  HKEY   hkRoot,
    IN  PWCHAR pszTempKey,
    IN  PWCHAR pszFile,
    OUT PHKEY  phTemp);

DWORD 
UtlDeleteRegistryTree(
    IN HKEY hkRoot);

DWORD
UtlMarkRouterConfigured();

      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\upgrade\tools\b3rasace\main.c ===
/*
    File:   main.c, main.cpp

    Simple test shell.

    Paul Mayfield, 4/13/98
*/

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <mprapi.h>
#include <rtutils.h>

#define DWERR_BREAK(dwErr) {if (dwErr != NO_ERROR) break;}

DWORD
DsrDomainSetAccess(
    IN PWCHAR pszDomain,
    IN DWORD dwAccessFlags);

//
// Initializes the trace mechanism
//
DWORD 
DsrTraceInit()
{
    return NO_ERROR;
}

//
// Cleans up the trace mechansim
//
DWORD 
DsrTraceCleanup()
{
    return NO_ERROR;
}

//
// Sends debug trace and returns the given error
//
DWORD 
DsrTraceEx (
    IN DWORD dwErr, 
    IN LPSTR pszTrace, 
    IN ...) 
{
    va_list arglist;
    char szTemp[1024];

    va_start(arglist, pszTrace);
    vsprintf(szTemp, pszTrace, arglist);
    va_end(arglist);

    printf("%s\n", szTemp);

    return dwErr;
}

void
Usage(char* pszExe)
{
    printf("\n");
    printf("Tool for cleaning up ACEs added by Windows 2000 Beta3 and RC1 setup\n");
    printf("to grant user account access to legacy RAS servers.\n");
    printf("\n");
    printf("Usage\n");
    printf("\t%s -d <domain>\n", pszExe);
    printf("\n");
}

int __cdecl main(int argc, char** argv) 
{
    DWORD dwErr = NO_ERROR, iErr = 0;
    WCHAR pszDomain[512];
    int iSize = sizeof(pszDomain) / sizeof(WCHAR);

    if (argc != 3)
    {
        Usage(argv[0]);
        return 0;
    }

    if (strcmp(argv[1], "-d") != 0)
    {
        Usage(argv[0]);
        return 0;
    }
    
    // Parse out the domain
    //
    iErr = MultiByteToWideChar(CP_ACP, 0, argv[2], -1, pszDomain, iSize);
    if (iErr == 0)
    {
        printf("Unable to convert %s to unicode.\n", argv[2]);
        printf("Error: 0x%x\n", GetLastError());
        return 0;
    }

    // Set the access
    //
    DsrTraceInit();
    dwErr = DsrDomainSetAccess(pszDomain, 0);
    DsrTraceCleanup();

    // Display results
    //
    if (dwErr == NO_ERROR)
    {
        printf("Success.\n");
    }
    else
    {
        printf("Error.\n");
    }

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\upgrade\steelhead2nt5\utils.c ===
/*
	File	uitls.c

	A set of utilities useful for upgrading mpr v1 to NT 5.0.

	Paul Mayfield, 9/11/97
*/

#include "upgrade.h"
#include <rtcfg.h>
#include <mprapip.h>

CONST WCHAR c_szSystemCCSServices[] = L"System\\CurrentControlSet\\Services";
static const WCHAR c_szConfigurationFlags[] = L"ConfigurationFlags";
CONST WCHAR c_szRouter[] = L"RemoteAccess";

//
// Initializes a dword table with given initial count
// and maximum string size;
//
DWORD dwtInitialize(
        OUT dwt *This, 
        IN  DWORD dwCount, 
        IN  DWORD dwMaxSize) 
{
	DWORD i;
	
	if (!This)
		return ERROR_INVALID_PARAMETER;

    // Initialize the structure
    ZeroMemory(This, sizeof(dwt));
	This->dwCount = 0;
	This->dwSize = dwCount;

	// Allocate the table
	This->pValues = (dwValueNode *) UtlAlloc(
	                                dwCount * sizeof(dwValueNode));
	if (!This->pValues)
		return ERROR_NOT_ENOUGH_MEMORY;
	
	// Allocate all of the name strings
	for (i = 0; i < (DWORD)This->dwSize; i++) {
		This->pValues[i].Name = (PWCHAR) UtlAlloc(
		                                    dwMaxSize * sizeof(WCHAR));
		if (!This->pValues[i].Name)
		{
			return ERROR_NOT_ENOUGH_MEMORY;
	    }
	}

	return NO_ERROR;
}

//
// Free's resources held by the given dword table.
//
DWORD dwtCleanup(
        IN dwt * This) 
{
	DWORD i;
	
	if (!This)
	{
		return NO_ERROR;
    }

	for (i = 0; i < (DWORD)This->dwSize; i++) 
	{
		if (This->pValues[i].Name)
		{
			UtlFree(This->pValues[i].Name);
	    }
	}

	if (This->pValues)
	{
    	UtlFree(This->pValues);
    }
    
    return NO_ERROR;
}

// 
// Retrieves the given value from the table
//
DWORD dwtGetValue(
        IN  dwt * This, 
        IN  PWCHAR ValName, 
        OUT LPDWORD pValue) 
{
	DWORD i;

	if (!ValName || !pValue)
	{
		return ERROR_INVALID_PARAMETER;
    }

	for (i = 0; i < This->dwCount; i++) 
	{
		if (wcscmp(ValName,This->pValues[i].Name) == 0) 
		{
			*pValue = This->pValues[i].Value;
			return NO_ERROR;
		}
	}

	return ERROR_NOT_FOUND;
}

// 
// Loads all of the dword values of a given registry 
// key into a dword table.
//
DWORD dwtLoadRegistyTable(
        OUT dwt *This, 
        IN  HKEY hkParams) 
{
	DWORD dwErr, dwMaxSize, dwSize, dwCount, i;
	DWORD dwDataSize = sizeof(DWORD), dwType = REG_DWORD;

    if (!This)
        return ERROR_INVALID_PARAMETER;

    // Initialize the structure
    ZeroMemory(This, sizeof(dwt));

	// Find out how many parameters there are.
	dwErr = RegQueryInfoKey(
	            hkParams, 
	            NULL, 
	            NULL, 
	            NULL, 
	            NULL, 
	            NULL, 
	            NULL,
				&dwCount, 
				&dwMaxSize,
				NULL, 
				NULL, 
				NULL);
	if (dwErr != ERROR_SUCCESS)
		return dwErr;

	if (dwCount == 0) 
	{
		This->dwCount = This->dwSize = 0;
		return NO_ERROR;
	}
	dwMaxSize += 1;

    do 
    {
    	// Fill in the table
    	dwtInitialize(This, dwCount, dwMaxSize);
    	for (i = 0; i < dwCount; i++) 
    	{
    		dwSize = dwMaxSize;
    		dwErr = RegEnumValueW(
    		            hkParams,
    		             i,
    		             This->pValues[This->dwCount].Name,
    		             &dwSize,
    		             0,
    		             &dwType,
    		             NULL,
    		             NULL);
    		if (dwErr != ERROR_SUCCESS)
    		{
    			break;
    	    }
    	    if (dwType != REG_DWORD)
    	    {
    	        continue;
    	    }

    		dwErr = RegQueryValueExW(
    		            hkParams,
    		            This->pValues[This->dwCount].Name,
    		            0,
    		            &dwType,
    		            (LPBYTE)&(This->pValues[This->dwCount].Value),
    		            &dwDataSize);
    		if (dwErr != ERROR_SUCCESS)
    		{
    			break;
    	    }
    	    This->dwCount++;
        }    	    
        
	} while (FALSE);

	return dwErr;
}

DWORD dwtPrint(
        IN dwt *This) 
{
	DWORD i;

	if (!This)
		return ERROR_INVALID_PARAMETER;

	return NO_ERROR;
}

//
// Enumerates all of the subkeys of a given key
//
DWORD
UtlEnumRegistrySubKeys(
    IN HKEY hkRoot,
    IN PWCHAR pszPath,
    IN RegKeyEnumFuncPtr pCallback,
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR, i, dwNameSize = 0, dwCurSize = 0;
    DWORD dwCount = 0;
    HKEY hkKey = NULL, hkCurKey = NULL;
    PWCHAR pszName = NULL;
    BOOL bCloseKey = FALSE;

    do
    {
        if (pszPath)
        {
            bCloseKey = TRUE;
            // Open the key to enumerate
            //
            dwErr = RegOpenKeyExW(
                        hkRoot,
                        pszPath,
                        0,
                        KEY_ALL_ACCESS,
                        &hkKey);
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }     
        else
        {
            bCloseKey = FALSE;
            hkKey = hkRoot;
        }

        // Find out how many sub keys there are
        //
        dwErr = RegQueryInfoKeyW(
                    hkKey,
                    NULL,
                    NULL,
                    NULL,
                    &dwCount,
                    &dwNameSize,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL);
        if (dwErr != ERROR_SUCCESS)
        {
            return dwErr;
        }
        dwNameSize++;

        // Allocate the name buffer
        //
        pszName = (PWCHAR) UtlAlloc(dwNameSize * sizeof(WCHAR));
        if (pszName == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Loop through the keys
        //
        for (i = 0; i < dwCount; i++)
        {
            dwCurSize = dwNameSize;
            
            // Get the name of the current key
            //
            dwErr = RegEnumKeyExW(
                        hkKey, 
                        i, 
                        pszName, 
                        &dwCurSize, 
                        0, 
                        NULL, 
                        NULL, 
                        NULL);
            if (dwErr != ERROR_SUCCESS)
            {
                continue;
            }

            // Open the subkey
            //
            dwErr = RegOpenKeyExW(
                        hkKey,
                        pszName,
                        0,
                        KEY_ALL_ACCESS,
                        &hkCurKey);
            if (dwErr != ERROR_SUCCESS)
            {
                continue;
            }

            // Call the callback
            //
            dwErr = pCallback(pszName, hkCurKey, hData);
            RegCloseKey(hkCurKey);
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }            

    } while (FALSE);

    // Cleanup
    {
        if ((hkKey != NULL) && (bCloseKey))
        {
            RegCloseKey(hkKey);
        }
        if (pszName)
        {
            UtlFree(pszName);
        }
    }

    return dwErr;
}

// 
// Enumerates interfaces from the registry
//
DWORD UtlEnumerateInterfaces (
        IN IfEnumFuncPtr pCallback,
        IN HANDLE hUserData)
{
    DWORD dwErr, i, dwIfCount, dwIfTot, dwResume = 0;
    DWORD dwPrefBufSize = sizeof(MPR_INTERFACE_0) * 100; 
    MPR_INTERFACE_0 * pIfs = NULL;
    HANDLE hConfig;
    BOOL bContinue = TRUE;

    // Validate parameters
    if (pCallback == NULL)
        return ERROR_INVALID_PARAMETER;

    // Connect to the configuration server
    dwErr = MprConfigServerConnect(NULL, &hConfig);
    if (dwErr != NO_ERROR)
        return dwErr;

    // Get list of all interfaces
    dwErr = MprConfigInterfaceEnum(
                hConfig,
                0,
                (LPBYTE*)&pIfs,
                dwPrefBufSize,
                &dwIfCount,
                &dwIfTot,
                &dwResume);
    if (dwErr == ERROR_NO_MORE_ITEMS)
        return NO_ERROR;
    else if ((dwErr != NO_ERROR) && (dwErr != ERROR_MORE_DATA))
        return dwErr;

    // Loop through the interfaces
    do {
        // Call the callback for each interface as long
        // as we're instructed to continue
        for (i = 0; i < dwIfCount; i++) {
            if (bContinue) {
                bContinue = (*pCallback)(
                                hConfig, 
                                &(pIfs[i]), 
                                hUserData);
            }                                
        }
        if (bContinue == FALSE)
            break;
        
        // Free up the interface list buffer
	    if (pIfs)
		    MprConfigBufferFree(pIfs);
        pIfs = NULL;

        // Get list of all ip interfaces
        dwErr = MprConfigInterfaceEnum(
                    hConfig,
                    0,
                    (LPBYTE*)&pIfs,
                    dwPrefBufSize,
                    &dwIfCount,
                    &dwIfTot,
                    &dwResume);
                    
        if (dwErr == ERROR_NO_MORE_ITEMS) {
            dwErr = NO_ERROR;
            break;
        }
	    else if ((dwErr != NO_ERROR) && (dwErr != ERROR_MORE_DATA))
		    break;
		else
		    continue;
    } while (TRUE);        

    // Cleanup
    {
	    if (pIfs)
		    MprConfigBufferFree(pIfs);
        if (hConfig)
            MprConfigServerDisconnect(hConfig);
    }

    return dwErr;
}

//
// If the given info blob exists in the given toc header
// reset it with the given information, otherwise add
// it as an entry in the TOC.
//
DWORD UtlUpdateInfoBlock (
        IN  BOOL    bOverwrite,
        IN  LPVOID  pHeader,
        IN  DWORD   dwEntryId,
        IN  DWORD   dwSize,
        IN  DWORD   dwCount,
        IN  LPBYTE  pEntry,
        OUT LPVOID* ppNewHeader,
        OUT LPDWORD lpdwNewSize)
{
    PRTR_INFO_BLOCK_HEADER pNewHeader;
    DWORD dwErr;
    
    // Attempt to find the entry
    dwErr = MprInfoBlockFind(
                pHeader,
                dwEntryId,
                NULL,
                NULL,
                NULL);

    // If we find it, reset it
    if (dwErr == NO_ERROR) {
        if (bOverwrite) {
            dwErr = MprInfoBlockSet(
                        pHeader,
                        dwEntryId,
                        dwSize,
                        dwCount,
                        pEntry,
                        ppNewHeader);
            if (dwErr == NO_ERROR) {
                pNewHeader = (PRTR_INFO_BLOCK_HEADER)(*ppNewHeader);
                *lpdwNewSize = pNewHeader->Size;
            }
        }                        
        else {
            return ERROR_ALREADY_EXISTS;
        }
    }

    // Otherwise, create it
    else if (dwErr == ERROR_NOT_FOUND) {
        dwErr = MprInfoBlockAdd(
                    pHeader,
                    dwEntryId,
                    dwSize,
                    dwCount,
                    pEntry,
                    ppNewHeader);
        if (dwErr == NO_ERROR) {
            pNewHeader = (PRTR_INFO_BLOCK_HEADER)(*ppNewHeader);
            *lpdwNewSize = pNewHeader->Size;
        }
    }

    return dwErr;
}


// Common allocation routine
PVOID UtlAlloc (DWORD dwSize) {
    return RtlAllocateHeap (RtlProcessHeap (), 0, dwSize);
}

// Common deallocation routine
VOID UtlFree (PVOID pvBuffer) {
    RtlFreeHeap (RtlProcessHeap (), 0, pvBuffer);
}

// Copies a string
//
PWCHAR
UtlDupString(
    IN PWCHAR pszString)
{
    PWCHAR pszRet = NULL;

    if ((pszString == NULL) || (*pszString == L'\0'))
    {
        return NULL;
    }

    pszRet = (PWCHAR) UtlAlloc((wcslen(pszString) + 1) * sizeof(WCHAR));
    if (pszRet == NULL)
    {
        return NULL;
    }

    wcscpy(pszRet, pszString);
    
    return pszRet;
}

// Error reporting
void UtlPrintErr(DWORD err) {
	WCHAR buf[1024];
	FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,NULL,err,0,buf,1024,NULL);
	PrintMessage(buf);
	PrintMessage(L"\n");
}


//----------------------------------------------------------------------------
// Function:    UtlAccessRouterKey
//
// Creates/opens the Router key on HKEY_LOCAL_MACHINE.
//----------------------------------------------------------------------------
DWORD UtlAccessRouterKey(HKEY* hkeyRouter) {
    LPWSTR lpwsPath;
    DWORD dwErr, dwSize;

    if (!hkeyRouter) 
		return ERROR_INVALID_PARAMETER; 

    *hkeyRouter = NULL;

    //
    // compute the length of the string 
    //
    dwSize = lstrlen(c_szSystemCCSServices) + 1 + lstrlen(c_szRouter) + 1;

    //
    // allocate space for the path
    //
    lpwsPath = (LPWSTR)UtlAlloc(dwSize * sizeof(WCHAR));
    if (!lpwsPath) 
		return ERROR_NOT_ENOUGH_MEMORY;

    wsprintf(lpwsPath, L"%s\\%s", c_szSystemCCSServices, c_szRouter);

    //
    // open the router key
    //
    dwErr = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE, lpwsPath, 0, KEY_ALL_ACCESS, hkeyRouter
                );
	if (dwErr!=ERROR_SUCCESS) {
		PrintMessage(L"ERROR in UtlAccessRouterKey\n");
	}

    UtlFree(lpwsPath);
    return dwErr;
}

//----------------------------------------------------------------------------
// Function:    UtlSetupBackupPrivelege
//
// Enables/disables backup privilege for the current process.
//----------------------------------------------------------------------------
DWORD UtlEnablePrivilege(PWCHAR pszPrivilege, BOOL bEnable) {
    LUID luid;
    HANDLE hToken;
    TOKEN_PRIVILEGES tp;

    OpenProcessToken(
            GetCurrentProcess(), 
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
            &hToken);

    if (! LookupPrivilegeValueW(NULL, pszPrivilege, &luid))
    {
        return GetLastError();
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (! AdjustTokenPrivileges(
            hToken, 
            !bEnable, 
            &tp, 
            sizeof(TOKEN_PRIVILEGES), 
            NULL, 
            NULL)) 
    {
        return GetLastError();
    }

    return NO_ERROR;
}

DWORD UtlSetupBackupPrivelege(BOOL bEnable) {
    return UtlEnablePrivilege(SE_BACKUP_NAME, bEnable);
}

DWORD UtlSetupRestorePrivilege(BOOL bEnable) {
    return UtlEnablePrivilege(SE_RESTORE_NAME, bEnable);
}

// Loads the given saved off settings into a temporary key 
// and returns a handle to that key.
//
DWORD 
UtlLoadSavedSettings(
    IN  HKEY   hkRoot,
    IN  PWCHAR pszTempKey,
    IN  PWCHAR pszFile,
    OUT HKEY*  phkTemp) 
{
	HKEY hkRestore = NULL;
	DWORD dwErr = NO_ERROR, dwDisposition = 0;
    BOOL bBackup = FALSE, bRestore = FALSE;

	do
	{
        // Enable the backup and restore priveleges
        //
        bBackup  = (UtlSetupBackupPrivelege (TRUE) == NO_ERROR);
        bRestore = (UtlSetupRestorePrivilege(TRUE) == NO_ERROR);
        if (!bBackup || !bRestore)
        {
            return ERROR_CAN_NOT_COMPLETE;
        }

        // Create a temporary key into which the saved config
        // can be loaded.
        //
        if ((dwErr = RegCreateKeyExW(
                        hkRoot, 
                        pszTempKey, 
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS, 
                        NULL,
                        &hkRestore,
                        &dwDisposition)) != NO_ERROR) 
        {
            PrintMessage(L"Unable to create restore key.\n");
            break;
        }

        // Load the saved configuration
        //
        dwErr = RegRestoreKey(hkRestore, pszFile, 0);
        if (dwErr != ERROR_SUCCESS)
        {
             break;
        }

        // Assign the return value
        //
        *phkTemp = hkRestore;

	} while (FALSE);

    // Cleanup
	{
        if (bBackup)
        {
            UtlSetupBackupPrivelege(FALSE);
        }
        if (bRestore)
        {
            UtlSetupRestorePrivilege(FALSE);
        }
	}
	
	return NO_ERROR;
}

//
// Delete the tree of registry values starting at hkRoot
//
DWORD 
UtlDeleteRegistryTree(
    IN HKEY hkRoot) 
{
    DWORD dwErr, dwCount, dwNameSize, dwDisposition;
    DWORD i, dwCurNameSize;
    PWCHAR pszNameBuf;
    HKEY hkTemp;
    
    // Find out how many keys there are in the source
    dwErr = RegQueryInfoKey (
                hkRoot,
                NULL,
                NULL,
                NULL,
                &dwCount,
                &dwNameSize,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL);
    if (dwErr != ERROR_SUCCESS)
        return dwErr;
    
    dwNameSize++;

    __try {
        // Allocate the buffers
        pszNameBuf = (PWCHAR) 
                        UtlAlloc(dwNameSize * sizeof(WCHAR));
        if (!pszNameBuf)
            return ERROR_NOT_ENOUGH_MEMORY;

        // Loop through the keys -- deleting all subkey trees
        for (i = 0; i < dwCount; i++) {
            dwCurNameSize = dwNameSize;

            // Get the current source key 
            dwErr = RegEnumKeyExW(
                        hkRoot, 
                        i, 
                        pszNameBuf, 
                        &dwCurNameSize, 
                        0, 
                        NULL, 
                        NULL, 
                        NULL);
            if (dwErr != ERROR_SUCCESS)
                continue;

            // Open the subkey
            dwErr = RegCreateKeyExW(
                        hkRoot, 
                        pszNameBuf, 
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_ALL_ACCESS, 
                        NULL, 
                        &hkTemp, 
                        &dwDisposition);
            if (dwErr != ERROR_SUCCESS)
                continue;

            // Delete the subkey tree
            UtlDeleteRegistryTree(hkTemp);

            // Close the temp handle
            RegCloseKey(hkTemp);
        }

        // Loop through the keys -- deleting all subkeys themselves
        for (i = 0; i < dwCount; i++) 
        {
            dwCurNameSize = dwNameSize;

            // Get the current source key 
            dwErr = RegEnumKeyExW(
                        hkRoot, 
                        0, 
                        pszNameBuf, 
                        &dwCurNameSize, 
                        0, 
                        NULL, 
                        NULL, 
                        NULL);
            if (dwErr != ERROR_SUCCESS)
                continue;

            // Delete the subkey tree
            dwErr = RegDeleteKey(hkRoot, pszNameBuf);
        }
    }
    __finally {
        if (pszNameBuf)
            UtlFree(pszNameBuf);
    }

    return NO_ERROR;
}

DWORD
UtlMarkRouterConfigured()
{
    DWORD dwErr, dwVal;
	HKEY hkRouter = NULL;

    dwErr = UtlAccessRouterKey(&hkRouter);
    if (dwErr == NO_ERROR)
    {
        dwVal = 1;
        
        RegSetValueEx(
            hkRouter,
            c_szConfigurationFlags,
            0,
            REG_DWORD,
            (CONST BYTE*)&dwVal,
            sizeof(DWORD));
            
	    RegCloseKey(hkRouter);
    }
    
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\upgrade\tools\b3rasace\adsi.cpp ===
/*
	File	adsi.cpp

	Com interaction with adsi

	Paul Mayfield, 4/14/98
*/

#include "dsrights.h"
#include "sddl.h"
#include "mprapip.h"
#include "dsgetdc.h"

// Definition for convenience
//
#define DSR_ADS_RIGHT_GENERIC_READ (ADS_RIGHT_READ_CONTROL    | \
                                    ADS_RIGHT_DS_LIST_OBJECT  | \
                                    ADS_RIGHT_DS_READ_PROP    | \
                                    ADS_RIGHT_ACTRL_DS_LIST   )

#define DSR_ADS_ACE_INHERITED (ADS_ACEFLAG_INHERIT_ONLY_ACE   | \
                               ADS_ACEFLAG_INHERIT_ACE)


//
// Describes an Access control entry
//
typedef struct _DSR_ACE_DESCRIPTOR
{
    LONG   dwAccessMask;
    LONG   dwAceType;
    LONG   dwAceFlags;
    LONG   dwFlags;
    BSTR   bstrTrustee;
    BSTR   bstrObjectType;
    BSTR   bstrInheritedObjectType;
} DSR_ACE_DESCRIPTOR;

//
// Structure maps a domain object to the ACES that should be
// added or removed from it in order to enable/disable NT4
// ras servers in the domain
//
typedef struct _DSR_ACE_APPLICATION
{
    IADs* pObject;
    DSR_ACE_DESCRIPTOR Ace;

} DSR_ACE_APPLICATION;

//
// Parameters used to generate a DSR_ACE_APPLICATION
//
typedef struct _DSR_ACE_APPLICATION_DESC
{
    PWCHAR pszObjectCN;         // NULL means domain root
    PWCHAR pszObjectClass;
    DSR_ACE_DESCRIPTOR Ace;

} DSR_ACE_APPLICATION_DESC;

//
// Structure contains the information needed to have
// ACL's in the AD of a given domain adjusted such that 
// the various modes (MPR_DOMAIN_*) of access are granted.
//
typedef struct _DSR_DOMAIN_ACCESS_INFO
{
    // The name of a DC in the target domain
    //
    PWCHAR pszDC;

    // Aces derived from the default user SD
    // These are added in all modes but never removed.
    //
    DSR_ACE_APPLICATION* pAcesUser;
    DWORD dwAceCountUser;

    // Aces for MPRFLAG_DOMAIN_NT4_SERVERS mode
    //
    DSR_ACE_APPLICATION* pAcesNt4;
    DWORD dwAceCountNt4;

    // Aces for MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS mode
    //
    DSR_ACE_APPLICATION* pAcesW2k;
    DWORD dwAceCountW2k;

    // Stored here for convenience, pointers
    // to common ds objects
    //
    IADs* pDomain;      
    IADs* pRootDse;
    IADs* pUserClass;

} DSR_DOMAIN_ACCESS_INFO;

//
// Strings used in DS queries
//
static const WCHAR pszLdapPrefix[]           = L"LDAP://";
static const WCHAR pszLdap[]                 = L"LDAP:";
static const WCHAR pszCN[]                   = L"CN=";
static const WCHAR pszGCPrefix[]             = L"GC://";
static const WCHAR pszGC[]                   = L"GC:";
static const WCHAR pszRootDse[]              = L"RootDSE";
static const WCHAR pszSecurityDesc[]         = L"ntSecurityDescriptor";
static const WCHAR pszDefSecurityDesc[]      = L"defaultSecurityDescriptor";
static const WCHAR pszDn[]                   = L"distinguishedName";
static const WCHAR pszSid[]                  = L"objectSid";
static const WCHAR pszEveryone[]             = L"S-1-1-0";
static const WCHAR pszDefaultNamingContext[] = L"defaultNamingContext";
static const WCHAR pszSchemaNamingCtx[]      = L"schemaNamingContext";

static const WCHAR pszBecomeSchemaMaster[]  = L"becomeSchemaMaster";
static const WCHAR pszUpdateSchemaCache[]   = L"schemaUpdateNow";
static const WCHAR pszRegValSchemaLock[]    = L"Schema Update Allowed";
static const WCHAR pszRegKeySchemaLock[]
    = L"System\\CurrentControlSet\\Services\\NTDS\\Parameters";

static const WCHAR pszSystemClass[]          = L"Container";
static const WCHAR pszSystemCN[]             = L"CN=System";

static const WCHAR pszBuiltinClass[]         = L"builtinDomain";
static const WCHAR pszBuiltinCN[]            = L"CN=Builtin";

static const WCHAR pszSamSvrClass[]          = L"samServer";
static const WCHAR pszSamSvrCN[]             = L"CN=Server,CN=System";

static const WCHAR pszUserClass[]            = L"classSchema";
static const WCHAR pszUserCN[]               = L"CN=user";

static const WCHAR pszAccessChkClass[]       = L"Container";
static const WCHAR pszAccessChkCN[]          = 
    L"CN=RAS and IAS Servers Access Check,CN=System";

static const WCHAR pszGuidUserParms[]        =
    L"{BF967A6D-0DE6-11D0-A285-00AA003049E2}";

static const WCHAR pszGuidUserClass[]        =
    L"{BF967ABA-0DE6-11D0-A285-00aa003049E2}";

//
// This GUID is the property set of the following
// attributes needed for w2k level access.
//
// Token-Groups
// msNPAllowDialin
// msNPCallingStationID
// msRADIUSCallbackNumber
// msRADIUSFramedIPAddress
// msRADIUSFramedRoute
// msRADIUSServiceType
// 
static const WCHAR pszGuidRasPropSet1[]      =
    L"{037088F8-0AE1-11D2-B422-00A0C968F939}";

//
// This GUID is the property set of the following
// attributes needed for w2k level access
//
// User-Account-Control
// Account-Expires
//
static const WCHAR pszGuidRasPropSet2[]      =
    L"{4C164200-20C0-11D0-A768-00AA006E0529}";

//
// This GUID is the property of the following
// attribute needed for w2k level access
//
// Logon-Hours
//
static const WCHAR pszGuidLogonHours[]      =
    L"{BF9679AB-0DE6-11D0-A285-00AA003049E2}";

//
// This GUID is the value of the samAccountName 
// attribute needed for w2k level access.
//
// samAccountName
//
static const WCHAR pszGuidSamAccountName[]  =
    L"{3E0ABFD0-126A-11D0-A060-00AA006C33ED}";

// The optimal means for searching for a computer
// in a domain is to lookup its sam account name which
// is indexed.  The optimal means for searching for a
// group of a given sid is to lookup its SID which is indexed.
//
const WCHAR pszCompFilterFmt[]       = L"(samaccountname=%s$)";
const WCHAR pszGroupFilterFmt[]      = L"(objectSid=%s)";
const WCHAR pszUserClassFmt[]        =
                L"(&(objectClass=user)(!(objectClass=computer)))";

//
// The table of aces to be applied for MPRFLAG_DOMAIN_NT4_SERVERS
//
DSR_ACE_APPLICATION_DESC g_pAcesNt4[] =
{
    // Grant list options to everyone for the root domain
    // object
    //
    {
        NULL,                               // Object (NULL = root)
        NULL,                               // Object class
        {
            ADS_RIGHT_ACTRL_DS_LIST,        // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED,     // dwAceType
            0,                              // dwAceFlags
            0,                              // dwFlags
            (PWCHAR)pszEveryone,            // bstrTrustee
            NULL,                           // bstrObjectType
            NULL                            // bstrInheritedObjectType
        }
    },

    // Grant list contents to everyone for the builtin
    // object
    //
    {
        (PWCHAR)pszBuiltinCN,               // Object
        (PWCHAR)pszBuiltinClass,            // Object class
        {
            ADS_RIGHT_ACTRL_DS_LIST,        // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED,     // dwAceType
            0,                              // dwAceFlags
            0,                              // dwFlags
            (PWCHAR)pszEveryone,            // bstrTrustee
            NULL,                           // bstrObjectType
            NULL                            // bstrInheritedObjectType
        }
    },

    // Grant generic read to everyone on the sam server
    // object
    //
    {
        (PWCHAR)pszSamSvrCN,                // Object
        (PWCHAR)pszSamSvrClass,             // Object class
        {
            DSR_ADS_RIGHT_GENERIC_READ,     // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED,     // dwAceType
            0,                              // dwAceFlags
            0,                              // dwFlags
            (PWCHAR)pszEveryone,            // bstrTrustee
            NULL,                           // bstrObjectType
            NULL                            // bstrInheritedObjectType
        }
    },

    // Allow everyone to read the userparms property of the
    // user class by enabling this inheritable ACE to the
    // root domain object
    {
        NULL,                                       // Object (NULL = root)
        NULL,                                       // Object class
        {
            ADS_RIGHT_DS_READ_PROP,                 // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED_OBJECT,      // dwAceType
            DSR_ADS_ACE_INHERITED,                  // dwAceFlags
            ADS_FLAG_OBJECT_TYPE_PRESENT |
            ADS_FLAG_INHERITED_OBJECT_TYPE_PRESENT, // dwFlags
            (PWCHAR)pszEveryone,                    // bstrTrustee
            (PWCHAR)pszGuidUserParms,               // bstrObjectType
            (PWCHAR)pszGuidUserClass                // bstrInheritedObjectType
        }
    }

};

//
// The table of aces to be applied for 
// MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS
//
DSR_ACE_APPLICATION_DESC g_pAcesW2k[] =
{
    // Grant list contents to Everyone for the System
    // container
    //
    {
        (PWCHAR)pszSystemCN,                // Object
        (PWCHAR)pszSystemClass,             // Object class
        {
            ADS_RIGHT_ACTRL_DS_LIST,        // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED,     // dwAceType
            0,                              // dwAceFlags
            0,                              // dwFlags
            (PWCHAR)pszEveryone,            // bstrTrustee
            NULL,                           // bstrObjectType
            NULL                            // bstrInheritedObjectType
        }
    },

    // Grant generic read to Everyone for the 'RAS and IAS Servers
    // Access Check' container
    //
    {
        (PWCHAR)pszAccessChkCN,             // Object
        (PWCHAR)pszAccessChkClass,          // Object class
        {
            DSR_ADS_RIGHT_GENERIC_READ,     // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED,     // dwAceType
            0,                              // dwAceFlags
            0,                              // dwFlags
            (PWCHAR)pszEveryone,            // bstrTrustee
            NULL,                           // bstrObjectType
            NULL                            // bstrInheritedObjectType
        }
    },

    // Users should expose their RAS properties
    //
    {
        NULL,                                       // Object (NULL = root)
        NULL,                                       // Object class
        {
            ADS_RIGHT_DS_READ_PROP,                 // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED_OBJECT,      // dwAceType
            DSR_ADS_ACE_INHERITED,                  // dwAceFlags
            ADS_FLAG_OBJECT_TYPE_PRESENT |
            ADS_FLAG_INHERITED_OBJECT_TYPE_PRESENT, // dwFlags
            (PWCHAR)pszEveryone,                    // bstrTrustee
            (PWCHAR)pszGuidRasPropSet1,             // bstrObjectType
            (PWCHAR)pszGuidUserClass                // bstrInheritedObjectType
        }
    },

    // Users should expose their RAS properties
    //
    {
        NULL,                                       // Object (NULL = root)
        NULL,                                       // Object class
        {
            ADS_RIGHT_DS_READ_PROP,                 // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED_OBJECT,      // dwAceType
            DSR_ADS_ACE_INHERITED,                  // dwAceFlags
            ADS_FLAG_OBJECT_TYPE_PRESENT |
            ADS_FLAG_INHERITED_OBJECT_TYPE_PRESENT, // dwFlags
            (PWCHAR)pszEveryone,                    // bstrTrustee
            (PWCHAR)pszGuidRasPropSet2,             // bstrObjectType
            (PWCHAR)pszGuidUserClass                // bstrInheritedObjectType
        }
    },

    // Users should expose their logon hours property
    //
    {
        NULL,                                       // Object (NULL = root)
        NULL,                                       // Object class
        {
            ADS_RIGHT_DS_READ_PROP,                 // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED_OBJECT,      // dwAceType
            DSR_ADS_ACE_INHERITED,                  // dwAceFlags
            ADS_FLAG_OBJECT_TYPE_PRESENT |
            ADS_FLAG_INHERITED_OBJECT_TYPE_PRESENT, // dwFlags
            (PWCHAR)pszEveryone,                    // bstrTrustee
            (PWCHAR)pszGuidLogonHours,              // bstrObjectType
            (PWCHAR)pszGuidUserClass                // bstrInheritedObjectType
        }
    },

    // Grant list contents to everything in the domain.
    //
    //{
    //    NULL,                               // Object
    //    NULL,                               // Object class
    //    {
    //        ADS_RIGHT_ACTRL_DS_LIST,        // dwAccessMask
    //        ADS_ACETYPE_ACCESS_ALLOWED,     // dwAceType
    //        DSR_ADS_ACE_INHERITED,          // dwAceFlags
    //        0,                              // dwFlags
    //        (PWCHAR)pszEveryone,            // bstrTrustee
    //        NULL,                           // bstrObjectType
    //        NULL                            // bstrInheritedObjectType
    //    }
    //},


    // Users should expose their samAccountName
    //
    {
        NULL,                                       // Object (NULL = root)
        NULL,                                       // Object class
        {
            ADS_RIGHT_DS_READ_PROP,                 // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED_OBJECT,      // dwAceType
            DSR_ADS_ACE_INHERITED,                  // dwAceFlags
            ADS_FLAG_OBJECT_TYPE_PRESENT |
            ADS_FLAG_INHERITED_OBJECT_TYPE_PRESENT, // dwFlags
            (PWCHAR)pszEveryone,                    // bstrTrustee
            (PWCHAR)pszGuidSamAccountName,          // bstrObjectType
            (PWCHAR)pszGuidUserClass                // bstrInheritedObjectType
        }
    }
};

DWORD
DsrAccessInfoCleanup(
    IN DSR_DOMAIN_ACCESS_INFO* pSecurityInfo);

DWORD
DsrAceDescClear(
    IN DSR_ACE_DESCRIPTOR* pParams);

HRESULT
DsrAceDescCopy(
    OUT DSR_ACE_DESCRIPTOR* pDst,
    IN  DSR_ACE_DESCRIPTOR* pSrc);
    
VOID
DsrAceDescTrace(
    IN IADs* pIads,
    IN DSR_ACE_DESCRIPTOR* pA);
    
HRESULT
DsrAceAdd(
    IN  PWCHAR pszDC,
    IN  IADs* pIads,
    IN  DSR_ACE_DESCRIPTOR * pAceParams);
    
HRESULT
DsrAceCreate(
    IN  DSR_ACE_DESCRIPTOR * pAceParams,
    OUT IDispatch** ppAce);
    
HRESULT
DsrAceFind(
    IN  PWCHAR pszDC,
    IN  IADs* pObject,
    IN  DSR_ACE_DESCRIPTOR* pAceParams,
    OUT VARIANT* pVarSD,
    OUT IADsSecurityDescriptor** ppSD,
    OUT IADsAccessControlList** ppAcl,
    OUT IDispatch** ppAce);
    
HRESULT
DsrAceFindInAcl(
    IN  PWCHAR pszDC,
    IN  IADsAccessControlList* pAcl,
    IN  DSR_ACE_DESCRIPTOR* pAceDesc, 
    OUT IDispatch** ppAce);
    
HRESULT
DsrAceRemove(
    IN  PWCHAR pszDC,
    IN  IADs* pIads,
    IN  DSR_ACE_DESCRIPTOR * pAceParams);
    
HRESULT
DsrDomainQueryAccessEx(
    IN  PWCHAR pszDomain,
    OUT LPDWORD lpdwAccessFlags,
    OUT DSR_DOMAIN_ACCESS_INFO** ppInfo);

//
// Allocates memory for use with dsr functions
//
PVOID DsrAlloc(DWORD dwSize, BOOL bZero) {
    return GlobalAlloc (bZero ? GPTR : GMEM_FIXED, dwSize);
}

//
// Free memory used by dsr functions
//
DWORD DsrFree(PVOID pvBuf) {
    GlobalFree(pvBuf);
    return NO_ERROR;
}
    
//
// Compares to optional strings
//
INT
DsrStrCompare(
    IN BSTR bstrS1,
    IN BSTR bstrS2)
{
    if ((!!bstrS1) != (!!bstrS2))
    {
        return -1;
    }

    if (bstrS1 == NULL)
    {
        return 0;
    }

    return lstrcmpi(bstrS1, bstrS2);
}

//
// Adds or removes a substring from the given string
//
HRESULT
DsrStrAddRemoveSubstring(
    IN  BSTR bstrSrc,
    IN  PWCHAR pszSubString,
    IN  BOOL bAdd,
    OUT BSTR* pbstrResult)
{
    HRESULT hr = S_OK;
    PWCHAR pszBuffer = NULL, pszStart = NULL, pszEnd = NULL;
    PWCHAR pszSrc, pszDst;
    DWORD dwSize = 0, dwLen = 0;

    // Find out if the sub string is already in the
    // string
    pszStart = wcsstr(bstrSrc, pszSubString);

    // The substring already exists in the string
    //
    if (pszStart)
    {
        // No need to add it since it's already there.
        if (bAdd)
        {
            *pbstrResult = SysAllocString(bstrSrc);
        }

        // Remove the substring
        else
        {
            dwLen = wcslen(pszSubString);
            pszEnd = pszStart + dwLen;
            dwSize = (DWORD)(pszStart - bstrSrc) + wcslen(pszEnd) + 1;
            dwSize *= sizeof(WCHAR);

            pszBuffer = (PWCHAR) DsrAlloc(dwSize, FALSE);
            if (pszBuffer == NULL)
            {
                return E_OUTOFMEMORY;
            }

            // Copy everything up to the substring
            //
            for (pszSrc = bstrSrc, pszDst = pszBuffer;
                 pszSrc != pszStart;
                 pszSrc++, pszDst++)
            {
                *pszDst = *pszSrc;
            }

            // Copy everything after the substring
            for (pszSrc = pszEnd; *pszSrc; pszSrc++, pszDst++)
            {
                *pszDst = *pszSrc;
            }

            // Null terminate
            *pszDst = L'\0';

            *pbstrResult = SysAllocString(pszBuffer);
            DsrFree(pszBuffer);
        }
    }

    // The substring does not already exist in the
    // string
    else
    {
        // Append the string
        //
        if (bAdd)
        {
            dwSize = wcslen(bstrSrc) + wcslen(pszSubString) + 1;
            dwSize *= sizeof(WCHAR);

            pszBuffer = (PWCHAR) DsrAlloc(dwSize, FALSE);
            if (pszBuffer == NULL)
            {
                return E_OUTOFMEMORY;
            }

            wcscpy(pszBuffer, bstrSrc);
            wcscat(pszBuffer, pszSubString);
            *pbstrResult = SysAllocString(pszBuffer);
            DsrFree(pszBuffer);
        }

        // Or nothing to do since the substring was
        // already removed
        else
        {
            *pbstrResult = SysAllocString(bstrSrc);
        }
    }

    return (*pbstrResult) ? S_OK : E_OUTOFMEMORY;
}

//
// Converts a SID into a buffer
//
DWORD
DsrStrFromSID(
    IN  PSID pSid,
    OUT PWCHAR pszString,
    IN  DWORD dwSize)
{
    NTSTATUS nStatus = STATUS_SUCCESS;  
    UNICODE_STRING UnicodeString;

    // Initialize the unicode string
    //
    RtlInitUnicodeString(&UnicodeString, NULL);

    do
    {
        // Convert the string
        //
        nStatus = RtlConvertSidToUnicodeString(
                    &UnicodeString,
                    pSid,
                    TRUE);
        if (! NT_SUCCESS(nStatus))
        {
            break;
        }

        // Validate the result
        //
        if (UnicodeString.Buffer == NULL)
        {
            nStatus = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        if (UnicodeString.Length > dwSize)
        {
            nStatus = STATUS_BUFFER_OVERFLOW;
            break;
        }

        // Copy the result
        //
        wcscpy(pszString, UnicodeString.Buffer);
        nStatus = STATUS_SUCCESS;
        
    } while (FALSE);        

    // Cleanup
    {
        if (UnicodeString.Buffer != NULL)
        {
            RtlFreeUnicodeString(&UnicodeString);
        }            
    }

    return RtlNtStatusToDosError(nStatus);
}


//
// Generates an LDAP path based on a domain and a 
// distinguished name
//
// Form of value returned: LDAP://<domain or dc>/dn
HRESULT
DsrDomainGenLdapPath(
    IN  PWCHAR pszDomain, 
    IN  PWCHAR pszDN, 
    OUT PWCHAR* ppszObject)
{    
    DWORD dwSize;

    // Calculate the size needed
    //
    dwSize = (wcslen(pszLdapPrefix) + wcslen(pszDN) + 1) * sizeof(WCHAR);
    if (pszDomain)
    {
        dwSize += (wcslen(pszDomain) + 1) * sizeof(WCHAR); // +1 for '/'
    }

    // Allocate the return value
    //
    *ppszObject = (PWCHAR) DsrAlloc(dwSize, FALSE);
    if (*ppszObject == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Format the return value
    if (pszDomain == NULL)
    {
        wsprintfW(*ppszObject, L"%s%s", pszLdapPrefix, pszDN);
    }
    else
    {
        wsprintfW(*ppszObject, L"%s%s/%s", pszLdapPrefix, pszDomain, pszDN);
    }

    return S_OK;
}        

//
// Returns a reference to rootDse of the given
// domain
//
HRESULT
DsrDomainGetRootDse(
    IN  PWCHAR pszDomain,
    OUT IADs** ppRootDse)
{
    HRESULT hr = S_OK;
    PWCHAR pszPath = NULL;
    DWORD dwSize = 0;

    do
    {
        // Get the object path
        //
        hr = DsrDomainGenLdapPath(pszDomain, (PWCHAR)pszRootDse, &pszPath);
        DSR_BREAK_ON_FAILED_HR(hr);
    
        // Get RootDSE
        //
        hr = ADsGetObject(pszPath, IID_IADs, (VOID**)ppRootDse);
        DSR_BREAK_ON_FAILED_HR( hr );

    } while (FALSE);

    // Cleanup
    {
        DSR_FREE(pszPath);

        if (FAILED (hr))
        {
            DSR_RELEASE(*ppRootDse);
        }
    }

    return hr;
}

//
// Returns a reference to the root domain object
//
HRESULT
DsrDomainGetContainers(
    IN  PWCHAR pszDomain,
    OUT IADs** ppRootDse,
    OUT IADsContainer** ppDomain,
    OUT IADsContainer** ppSchema)
{
    PWCHAR pszDomainObj = NULL, pszSchemaObj = NULL;
    HRESULT hr = S_OK;
    DWORD dwSize = 0;
    VARIANT var;

    // Iniatialize
    //
    {
        *ppRootDse = NULL;
        *ppDomain = NULL;
        *ppSchema = NULL;
        VariantInit(&var);
    }

    do
    {
        // Get RootDSE
        //
        hr = DsrDomainGetRootDse(pszDomain, ppRootDse);
        DSR_BREAK_ON_FAILED_HR(hr);

        // Use RootDSE to figure out the name of the domain object
        // to query
        hr = (*ppRootDse)->Get((PWCHAR)pszDefaultNamingContext, &var);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Compute the distinguished name of the root domain object
        //
        hr = DsrDomainGenLdapPath(pszDomain, V_BSTR(&var), &pszDomainObj);
        DSR_BREAK_ON_FAILED_HR(hr);
        
        // Use RootDSE to figure out the name of the schema context
        //
        VariantClear(&var);
        hr = (*ppRootDse)->Get((PWCHAR)pszSchemaNamingCtx, &var);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Compute the distinguished name of the root schema object
        //
        hr = DsrDomainGenLdapPath(pszDomain, V_BSTR(&var), &pszSchemaObj);
        DSR_BREAK_ON_FAILED_HR(hr);

        // Get the objects
        //
        hr = ADsGetObject(pszDomainObj, IID_IADsContainer, (VOID**)ppDomain);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = ADsGetObject(pszSchemaObj, IID_IADsContainer, (VOID**)ppSchema);
        DSR_BREAK_ON_FAILED_HR( hr );

    } while (FALSE);

    // Cleanup
    //
    {
        if (FAILED( hr ))
        {
            DSR_RELEASE(*ppRootDse);
            DSR_RELEASE(*ppDomain);
            DSR_RELEASE(*ppSchema);
            *ppRootDse = NULL;
            *ppDomain = NULL;
            *ppSchema = NULL;
        }

        DSR_FREE(pszDomainObj);
        DSR_FREE(pszSchemaObj);
        VariantClear(&var);
    }

    return hr;
}

//
// Initializes COM
//
HRESULT
DsrComIntialize()
{
    HRESULT hr;

    hr = CoInitializeEx (NULL, COINIT_APARTMENTTHREADED);
    if (hr == RPC_E_CHANGED_MODE)
    {
        hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);
    }

    if ((hr != S_FALSE) && (FAILED(hr)))
    {
        return hr;
    }

    return NO_ERROR;
}

//
// Unitializes COM
//
VOID
DsrComUninitialize()
{
    CoUninitialize();
}

//
// Creates a SID based on the array of bytes
// stored in a variant.
//
DWORD
DsrSidInit (
    IN  VARIANT * pVar,
    OUT PBYTE* ppbSid)
{
    SAFEARRAY * pArray = V_ARRAY(pVar);
    DWORD dwSize, dwLow, dwHigh, i;
    HRESULT hr;
    BYTE* pbRet = NULL;
    VARIANT var;

    DsrTraceEx (0, "DsrSidInit: entered.");

    // Get the array of bytes
    i = 0;
    hr = SafeArrayGetElement(pArray, (LONG*)&i, (VOID*)&var);
    if (FAILED (hr))
        return hr;

    // Initialize the return buffer accordingly
    pArray = V_ARRAY(&var);
    dwSize = SafeArrayGetDim(pArray);
    hr = SafeArrayGetLBound(pArray, 1, (LONG*)&dwLow);
    if (FAILED (hr))
        return DsrTraceEx(hr, "DsrSidInit: %x unable to get lbound", hr);

    hr = SafeArrayGetUBound(pArray, 1, (LONG*)&dwHigh);
    if (FAILED (hr))
        return DsrTraceEx(hr, "DsrSidInit: %x unable to get ubound", hr);

    DsrTraceEx (
            0,
            "DsrSidInit: Dim=%d, Low=%d, High=%d",
            dwSize,
            dwLow,
            dwHigh);

    // Allocate the sid
    if ((pbRet = (BYTE*)DsrAlloc((dwHigh - dwLow) + 2, TRUE)) == NULL) {
        return DsrTraceEx (
                    ERROR_NOT_ENOUGH_MEMORY,
                    "DsrSidInit: Unable to alloc");
    }

    // Copy in the bytes of the SID
    i = dwLow;
    while (TRUE) {
        hr = SafeArrayGetElement(pArray, (LONG*)&i, (VOID*)(&(pbRet[i])));
        if (FAILED (hr))
            break;
        i++;
    }

    DsrTraceEx(0, "DsrSidInit: copied %d bytes", i);

    *ppbSid = pbRet;

    {
        PUCHAR puSA;

        DsrTraceEx (0, "DsrSidInit: Sid Length: %d", GetLengthSid(pbRet));

        puSA = GetSidSubAuthorityCount(pbRet);
        if (puSA)
            DsrTraceEx (0, "DsrSidInit: Sid SA Count: %d", *puSA);
    }

    return NO_ERROR;
}

//
// Generates the ascii equivalent (suitable for submission as part of
// a query against the DS) of a SID based on a base SID and a sub authority
// to be appeneded.
//
HRESULT
DsrSidInitAscii(
    IN  LPBYTE pBaseSid,
    IN  DWORD dwSubAuthority,
    OUT PWCHAR* ppszSid)
{
    DWORD dwLen, dwSidLen, i;
    WCHAR* pszRet = NULL;
    PUCHAR puCount;
    LPBYTE pByte;

    // Calculate the length of the returned buffer
    dwSidLen = GetLengthSid(pBaseSid);
    dwLen = (dwSidLen * 2) + sizeof(DWORD) + 1;
    dwLen *= sizeof (WCHAR);

    // we put '\' before each byte, so double the size
    dwLen *= 2;

    // Allocate the return buffer
    pszRet = (PWCHAR) DsrAlloc(dwLen, TRUE);
    if (pszRet == NULL)
        return E_OUTOFMEMORY;

    // Increment the sub authority count
    puCount = GetSidSubAuthorityCount(pBaseSid);
    *puCount = *puCount + 1;

    // Copy the bytes
    for (i = 0; i < dwSidLen; i++) {
        pszRet[i*3] = L'\\';
        wsprintfW(&(pszRet[i*3+1]), L"%02x", (DWORD)pBaseSid[i]);
    }

    // Append the bytes for the new sub authority
    pByte = (LPBYTE)&(dwSubAuthority);
    for (; i < dwSidLen + sizeof(DWORD); i++) {
        pszRet[i*3] = L'\\';
        wsprintfW(&(pszRet[i*3+1]), L"%02x", (DWORD)pByte[i-dwSidLen]);
    }

    // Decrement the sub authority count -- restoring the
    // base sid.
    *puCount = *puCount - 1;

    *ppszSid = pszRet;

    return NO_ERROR;
}

//
// Searches given domain for a computer account
// with the given name and returns its ADsPath
// if found.
//
DWORD
DsrFindDomainComputer (
        IN  PWCHAR  pszDomain,
        IN  PWCHAR  pszComputer,
        OUT PWCHAR* ppszADsPath)
{
    HRESULT hr = S_OK;
    DWORD dwLen, dwSrchAttribCount;
    IDirectorySearch * pSearch = NULL;
    PWCHAR pszDomainPath = NULL, pszFilter = NULL;
    PWCHAR pszBase, pszPrefix;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCH_COLUMN adsColumn;
    PWCHAR ppszSrchAttribs[] =
    {
        (PWCHAR)pszDn,
        NULL
    };
    BOOL bSearchGC = FALSE;

    do {
        // Validate parameters
        if (!pszDomain || !pszComputer || !ppszADsPath) {
            hr = ERROR_INVALID_PARAMETER;
            break;
        }

        // Decide whether to search the GC or the domain
        // object
        if (bSearchGC) {
            pszBase = (PWCHAR)pszGC;
            pszPrefix = (PWCHAR)pszGCPrefix;
        }
        else {
            pszBase = (PWCHAR)pszLdap;
            pszPrefix = (PWCHAR)pszLdapPrefix;
        }

        // Allocate the domain path
        dwLen = (pszDomain) ? wcslen(pszDomain) : 0;
        dwLen += wcslen(pszPrefix) + 1;
        dwLen *= sizeof(WCHAR);
        pszDomainPath = (PWCHAR) DsrAlloc(dwLen, FALSE);
        if (pszDomainPath == NULL) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Format the domain path
        if (pszDomain) {
            wcscpy(pszDomainPath, pszPrefix);
            wcscat(pszDomainPath, pszDomain);
        }
        else
            wcscpy(pszDomainPath, pszBase);

        // Get a reference to the object to search
        // (either domain object or GC)
    	hr = ADsGetObject (
    	        pszDomainPath,
    	        IID_IDirectorySearch,
    	        (VOID**)&pSearch);
        if (FAILED (hr))
            break;

        // Prepare the search filter
        //
        dwLen = wcslen(pszCompFilterFmt) + wcslen(pszComputer) + 1;
        dwLen *= sizeof(WCHAR);
        pszFilter = (PWCHAR) DsrAlloc(dwLen, FALSE);
        if (pszFilter == NULL) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        wsprintfW(pszFilter, pszCompFilterFmt, pszComputer);

        // Count the number of attributes we're searching
        // for
        if (ppszSrchAttribs == NULL)
            dwSrchAttribCount = (DWORD)-1;
        else {
            for (dwSrchAttribCount = 0;
                 ppszSrchAttribs[dwSrchAttribCount];
                 dwSrchAttribCount++);
        }

        // Search the DS
        hr = pSearch->ExecuteSearch(
                pszFilter,
                ppszSrchAttribs,
                dwSrchAttribCount,
                &hSearch);
        if (FAILED (hr))
            break;

        // Get the first result
        hr = pSearch->GetNextRow(hSearch);
        if (hr == S_ADS_NOMORE_ROWS) {
            hr = ERROR_NOT_FOUND;
            break;
        }

        // Get the attribute we're interested in
        hr = pSearch->GetColumn(hSearch, (PWCHAR)pszDn, &adsColumn);
        if (SUCCEEDED (hr)) {
            dwLen = wcslen(adsColumn.pADsValues[0].PrintableString) +
                    wcslen(pszLdapPrefix)                           +
                    1;
            dwLen *= 2;
            *ppszADsPath = (PWCHAR) DsrAlloc(dwLen, FALSE);
            if (*ppszADsPath == NULL)
            {
                pSearch->FreeColumn(&adsColumn);
                hr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            wcscpy(*ppszADsPath, pszLdapPrefix);
            wcscat(*ppszADsPath, adsColumn.pADsValues[0].PrintableString);
            pSearch->FreeColumn (&adsColumn);
            hr = NO_ERROR;
        }

    } while (FALSE);

    // Cleanup
    {
        if (hSearch)
            pSearch->CloseSearchHandle(hSearch);
        DSR_FREE (pszDomainPath);
        DSR_FREE (pszFilter);
        DSR_RELEASE (pSearch);
    }

    return DSR_ERROR(hr);
}

//
// Searches given domain for the well known
// "RAS and IAS Servers" group and returns
// its ADsPath if found.
//
DWORD
DsrFindRasServersGroup (
        IN  PWCHAR  pszDomain,
        OUT PWCHAR* ppszADsPath)
{
    HRESULT hr = S_OK;
    DWORD dwLen, dwSrchAttribCount, dwErr;
    IDirectorySearch * pSearch = NULL;
    IADs * pIads = NULL;
    PWCHAR pszDomainPath = NULL, pszFilter = NULL;
    PWCHAR pszBase, pszPrefix, pszGroupSid = NULL;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCH_COLUMN adsColumn;
    PWCHAR ppszSrchAttribs[] =
    {
        (PWCHAR)pszDn,
        NULL
    };
    BOOL bSearchGC = FALSE;
    VARIANT var;
    LPBYTE pDomainSid = NULL;
    BSTR bstrSid = NULL;

    do {
        // Validate parameters
        if (!pszDomain || !ppszADsPath) {
            hr = ERROR_INVALID_PARAMETER;
            break;
        }

        // Decide whether to search the GC or the domain
        // object
        if (bSearchGC) {
            pszBase = (PWCHAR)pszGC;
            pszPrefix = (PWCHAR)pszGCPrefix;
        }
        else {
            pszBase = (PWCHAR)pszLdap;
            pszPrefix = (PWCHAR)pszLdapPrefix;
        }

        // Allocate the domain path
        dwLen = wcslen(pszDomain) + wcslen(pszPrefix) + 1;
        dwLen *= sizeof(WCHAR);
        pszDomainPath = (PWCHAR) DsrAlloc(dwLen, FALSE);
        if (pszDomainPath == NULL) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Format the domain path
        wcscpy(pszDomainPath, pszPrefix);
        wcscat(pszDomainPath, pszDomain);

        // Get a reference to the object to search
        // (either domain object or GC)
    	hr = ADsGetObject (
    	        pszDomainPath,
    	        IID_IDirectorySearch,
    	        (VOID**)&pSearch);
        if (FAILED (hr))
            break;

        // Get IADs reference to domain object
        hr = pSearch->QueryInterface(IID_IADs, (VOID**)&pIads);
        if (FAILED (hr))
            break;

        // Get the SID of the domain object
        VariantInit(&var);
        bstrSid = SysAllocString(pszSid);
        if (bstrSid == NULL)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }            
        hr = pIads->GetEx(bstrSid, &var);
        if (FAILED (hr))
        {
            break;
        }
        dwErr = DsrSidInit(&var, &pDomainSid);
        if (dwErr != NO_ERROR) {
            hr = dwErr;
            break;
        }
        VariantClear(&var);

        // Prepare the ascii version of the "RAS and IAS Servers" SID
        // for use in querying the DC
        hr = DsrSidInitAscii(
                pDomainSid,
                DOMAIN_ALIAS_RID_RAS_SERVERS,
                &pszGroupSid);
        if (FAILED (hr))
            break;
        DsrTraceEx(0, "GroupSid = %ls", pszGroupSid);

        // Prepare the search filter
        //
        dwLen = (wcslen(pszGroupFilterFmt) + wcslen(pszGroupSid) + 1);
        dwLen *= sizeof(WCHAR);
        pszFilter = (PWCHAR) DsrAlloc(dwLen, FALSE);
        if (pszFilter == NULL) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        wsprintfW(pszFilter, pszGroupFilterFmt, pszGroupSid);

        // Count the number of attributes we're searching
        // for
        if (ppszSrchAttribs == NULL)
            dwSrchAttribCount = (DWORD)-1;
        else 
        {
            for (dwSrchAttribCount = 0;
                 ppszSrchAttribs[dwSrchAttribCount];
                 dwSrchAttribCount++);
        }

        // Search the DS
        hr = pSearch->ExecuteSearch(
                pszFilter,
                ppszSrchAttribs,
                dwSrchAttribCount,
                &hSearch);
        if (FAILED (hr))
            break;

        // Get the first result
        hr = pSearch->GetNextRow(hSearch);
        if (hr == S_ADS_NOMORE_ROWS) {
            hr = ERROR_NOT_FOUND;
            break;
        }

        // Get the attribute we're interested in
        hr = pSearch->GetColumn(hSearch, (PWCHAR)pszDn, &adsColumn);
        if (SUCCEEDED (hr)) 
        {
            dwLen = wcslen(adsColumn.pADsValues[0].PrintableString) +
                    wcslen(pszLdapPrefix)                           +
                    1;
            dwLen *= sizeof(WCHAR);
            *ppszADsPath = (PWCHAR) DsrAlloc(dwLen, FALSE);
            if (*ppszADsPath == NULL)
            {
                pSearch->FreeColumn(&adsColumn);
                hr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            wsprintfW(
                *ppszADsPath,
                L"%s%s",
                pszLdapPrefix,
                adsColumn.pADsValues[0].PrintableString);
            pSearch->FreeColumn(&adsColumn);
            hr = NO_ERROR;
        }

    } while (FALSE);

    // Cleanup
    {
        if (hSearch)
            pSearch->CloseSearchHandle(hSearch);
        DSR_FREE (pszDomainPath);
        DSR_FREE (pszFilter);
        DSR_FREE (pDomainSid);
        DSR_FREE (pszGroupSid);
        DSR_RELEASE (pSearch);
        DSR_RELEASE (pIads);
        if (bstrSid)
            SysFreeString(bstrSid);
    }

    return DSR_ERROR(hr);
}

//
// Adds or removes a given object from a given group.
//
DWORD 
DsrGroupAddRemoveMember(
    IN PWCHAR pszGroupDN,
    IN PWCHAR pszNewMemberDN,
    IN BOOL bAdd)
{
    VARIANT_BOOL vbIsMember = VARIANT_FALSE;
    IADsGroup* pGroup = NULL;
    HRESULT hr = S_OK;

    DsrTraceEx (
        0,
        "DsrGroupAddRemoveMember entered for [%S] [%S]",
        pszGroupDN,
        pszNewMemberDN);

    do
    {
        // Get a reference to the group
        hr = ADsGetObject (pszGroupDN, IID_IADsGroup, (VOID**)&pGroup);
        if (FAILED (hr)) 
        {
         	DsrTraceEx(
     	        hr,
     	        "DsrGroupAddRemoveMember: %x from ADsGetObject(%S)",
     	        hr,
     	        pszGroupDN);
     	    break;
        }         	
         	
        // Find out if the given new member is in the group
        hr = pGroup->IsMember (pszNewMemberDN, &vbIsMember);
        if (FAILED (hr)) 
        {
            DsrTraceEx (
                hr,
                "DsrGroupAddRemoveMember: %x from IsMember\n",
                hr);
            break;
        }

        // Add the object to the group and flush the cache
        if (bAdd) 
        {
            if (vbIsMember == VARIANT_FALSE)
            {
                hr = pGroup->Add (pszNewMemberDN);
            }
        }
        else 
        {
            if (vbIsMember == VARIANT_TRUE)
            {
                hr = pGroup->Remove (pszNewMemberDN);
            }
        }

        // If the new member is already in the group, the error code
        // is ERROR_DS_CONSTRAINT_VIOLATION.  I suspect this may change.
        //
        if (hr == ERROR_DS_CONSTRAINT_VIOLATION)
        {
            hr = ERROR_ALREADY_EXISTS;
            break;
        }

        if (FAILED (hr)) 
        {
         	DsrTraceEx(
 	            hr,
 	            "DsrGroupAddRemoveMember: %x from Add/Remove",
 	            hr);
            break; 	            
        }         	
        
    } while (FALSE);

    // Cleanup
    {
        DSR_RELEASE(pGroup);
    }

    return DSR_ERROR(hr);
}

//
// Returns whether the given object is a member of
// the given group.
//
DWORD 
DsrGroupIsMember(
    IN  PWCHAR pszGroupDN,
    IN  PWCHAR pszObjectDN,
    OUT PBOOL  pbIsMember)
{
    IADsGroup * pGroup = NULL;
    HRESULT hr = S_OK;
    VARIANT_BOOL vbIsMember = VARIANT_FALSE;

    DsrTraceEx (
        0,
        "DsrGroupIsMember: entered [%S] [%S].",
        pszGroupDN,
        pszObjectDN);

    do
    {
        // Get a reference to the group
        hr = ADsGetObject (pszGroupDN, IID_IADsGroup, (VOID**)&pGroup);
        if (FAILED (hr)) 
        {
            DsrTraceEx (
                hr,
                "DsrGroupIsMember: %x returned when opening %S", 
                hr, 
                pszGroupDN);
            *pbIsMember = FALSE;
            hr = NO_ERROR;
            break;
        }

        // Find out if the object is a member
        hr = pGroup->IsMember (pszObjectDN, &vbIsMember);
        if (FAILED (hr)) 
        {
            DsrTraceEx (hr, "DsrGroupIsMember: %x from IsMember\n", hr);
            break;
         }

        *pbIsMember = (vbIsMember == VARIANT_TRUE) ? TRUE : FALSE;
        
    } while (FALSE);

    // Cleanup
    {
        DSR_RELEASE(pGroup);
    }

    return DSR_ERROR(hr);
}

//
// Applies the aces in the given access settings to the 
// appropriate domain.
//
HRESULT
DsrAceAppAdd(
    IN  PWCHAR pszDC,
    IN  DSR_ACE_APPLICATION* pAces,
    IN  DWORD dwCount)
{    
    HRESULT hr = S_OK;
    DSR_ACE_APPLICATION* pAceApp = NULL;
    DWORD i;
    
    // Output the aces that we'll set
    //
    DsrTraceEx(0, "Adding %d aces...", dwCount);

    do
    {
        // Add the ACES to the domain objects
        //
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            hr = DsrAceAdd(
                    pszDC,
                    pAceApp->pObject,
                    &(pAceApp->Ace));
            DSR_BREAK_ON_FAILED_HR( hr );
        }
        DSR_BREAK_ON_FAILED_HR( hr );

        // Commit the ACE's to the domain objects.
        //
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            hr = pAceApp->pObject->SetInfo();
            DSR_BREAK_ON_FAILED_HR( hr );
        }
        DSR_BREAK_ON_FAILED_HR( hr );
        
    } while (FALSE);

    // Cleanup
    {
    }

    return hr;
}

// 
// Releases the resources held by an ace application
//
HRESULT
DsrAceAppCleanup(
    IN DSR_ACE_APPLICATION* pAces,
    IN DWORD dwCount)
{
    DSR_ACE_APPLICATION* pAceApp = NULL;
    DWORD i;

    if (pAces)
    {
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            DSR_RELEASE(pAceApp->pObject);
            DsrAceDescClear(&(pAceApp->Ace));
        }

        DSR_FREE(pAces);
    }        

    return NO_ERROR;
}

// 
// Generates a list of ace applications based on a list
// of ace application descriptions
//
HRESULT
DsrAceAppFromAppDesc(
    IN  DSR_ACE_APPLICATION_DESC* pDesc,
    IN  DWORD dwCount,
    IN  IADsContainer* pContainer,
    IN  IADs* pDefault,
    OUT DSR_ACE_APPLICATION** ppAceApp,
    OUT LPDWORD lpdwCount)
{
    DSR_ACE_APPLICATION* pAceApp = NULL, *pCurApp = NULL;
    DSR_ACE_APPLICATION_DESC* pAceAppDesc = NULL;
    IDispatch* pDispatch = NULL;
    HRESULT hr = S_OK;                
    DWORD i;

    do
    {
        // Allocate and zero the ACE list
        //
        pAceApp = (DSR_ACE_APPLICATION*) 
            DsrAlloc(sizeof(DSR_ACE_APPLICATION) * dwCount, TRUE);
        if (pAceApp == NULL)
        {
           DSR_BREAK_ON_FAILED_HR(hr = E_OUTOFMEMORY);
        }

        // Set up the ACE applications
        //
        for (i = 0, pAceAppDesc = pDesc, pCurApp = pAceApp;
             i < dwCount;
             i++, pAceAppDesc++, pCurApp++)
        {
            // Get the desired object in the DS
            //
            if (pAceAppDesc->pszObjectCN)
            {
                hr = pContainer->GetObject(
                        pAceAppDesc->pszObjectClass,
                        pAceAppDesc->pszObjectCN,
                        &pDispatch);
                DSR_BREAK_ON_FAILED_HR( hr );

                hr = pDispatch->QueryInterface(
                        IID_IADs,
                        (VOID**)&(pCurApp->pObject));
                DSR_BREAK_ON_FAILED_HR( hr );

                pDispatch->Release();
                pDispatch = NULL;
            }
            else
            {
                pCurApp->pObject = pDefault;
                pCurApp->pObject->AddRef();
            }

            // Copy over the ACE information
            hr = DsrAceDescCopy(
                    &(pCurApp->Ace),
                    &(pAceAppDesc->Ace));
            DSR_BREAK_ON_FAILED_HR( hr );
        }
        DSR_BREAK_ON_FAILED_HR( hr );

        // Assign the return values
        *ppAceApp = pAceApp;
        *lpdwCount = dwCount;
        
    } while (FALSE);        

    // Cleanup
    {
        if (FAILED(hr))
        {
            DsrAceAppCleanup(pAceApp, i);
        }
    }

    return hr;
}

// 
// Discovers whether a set of aces is present in the given 
// domain.
//
HRESULT
DsrAceAppQueryPresence(
    IN  PWCHAR pszDC,
    IN  DSR_ACE_APPLICATION* pAces,
    IN  DWORD dwCount,
    OUT PBOOL pbPresent)
{
    DSR_ACE_APPLICATION* pAceApp = NULL;
    IADsSecurityDescriptor* pSD = NULL;
    IADsAccessControlList* pAcl = NULL;
    IDispatch* pAce = NULL;
    VARIANT varSD;
    HRESULT hr = S_OK;
    BOOL bEnabled = FALSE, bOk = TRUE;
    DWORD i;

    do
    {
        // Initialize
        *pbPresent = FALSE;
        VariantInit(&varSD);

        // Find out if the ACES are set
        //
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            hr = DsrAceFind(
                    pszDC,
                    pAceApp->pObject,
                    &(pAceApp->Ace),
                    &varSD,
                    &pSD,
                    &pAcl,
                    &pAce);
            DSR_BREAK_ON_FAILED_HR( hr );

            // We're enabled so long as we don't find
            // a missing ACE
            //
            bOk = (pAce != NULL);

            // Cleanup
            //
            DSR_RELEASE( pAce );
            DSR_RELEASE( pAcl );
            DSR_RELEASE( pSD );
            VariantClear(&varSD);
            pAce = NULL;
            pAcl = NULL;
            pSD  = NULL;

            // Break if we find out we're not enabled
            //
            if (bOk == FALSE)
            {
                break;
            }
        }
        DSR_BREAK_ON_FAILED_HR( hr );

        *pbPresent = bOk;
        
    } while (FALSE);

    // Cleanup
    {
    }

    return hr;
}

//
// Applies the aces in the given access settings to the 
// appropriate domain.
//
HRESULT
DsrAceAppRemove(
    IN  PWCHAR pszDC,
    IN  DSR_ACE_APPLICATION* pAces,
    IN  DWORD dwCount)
{    
    HRESULT hr = S_OK;
    DSR_ACE_APPLICATION* pAceApp = NULL;
    DWORD i;
    
    // Output the aces that we'll set
    //
    DsrTraceEx(0, "Removing %d aces...", dwCount);

    do
    {
        // Add/Del the ACES to the domain objects
        //
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            hr = DsrAceRemove(
                    pszDC,
                    pAceApp->pObject,
                    &(pAceApp->Ace));
            DSR_BREAK_ON_FAILED_HR( hr );
        }
        DSR_BREAK_ON_FAILED_HR( hr );

        // Commit the ACE's to the domain objects.
        //
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            hr = pAceApp->pObject->SetInfo();
            DSR_BREAK_ON_FAILED_HR( hr );
        }
        DSR_BREAK_ON_FAILED_HR( hr );
        
    } while (FALSE);

    // Cleanup
    {
    }

    return hr;
}

//
// Clear the dsr ace parameters
//
DWORD
DsrAceDescClear(
    IN DSR_ACE_DESCRIPTOR* pParams)
{
    if (pParams)
    {
        if (pParams->bstrTrustee)
        {
            SysFreeString(pParams->bstrTrustee);
        }
        if (pParams->bstrObjectType)
        {
            SysFreeString(pParams->bstrObjectType);
        }
        if (pParams->bstrInheritedObjectType)
        {
            SysFreeString(pParams->bstrInheritedObjectType);
        }

        ZeroMemory(pParams, sizeof(DSR_ACE_DESCRIPTOR));
    }

    return NO_ERROR;
}

//
// Returns 0 if ACE descriptors are describing the same ACE.
// FALSE, otherwise.
//
HRESULT
DsrAceDescCompare(
    IN DSR_ACE_DESCRIPTOR* pAce1,
    IN DSR_ACE_DESCRIPTOR* pAce2)
{
    DWORD dw1, dw2;
    
    // Compare the non-string fields so that we can rule things
    // out w/o string compares if possible
    //
    if (
        (pAce1->dwAccessMask != pAce2->dwAccessMask) ||
        (pAce1->dwAceFlags   != pAce2->dwAceFlags)   ||
        (pAce1->dwAceType    != pAce2->dwAceType)    ||
        (pAce1->dwFlags      != pAce2->dwFlags)
       )
    {
        return 1;
    }

    // Compare the strings
    //
    if ((DsrStrCompare(pAce1->bstrTrustee, pAce2->bstrTrustee))       ||
        (DsrStrCompare(pAce1->bstrObjectType, pAce2->bstrObjectType)) ||
        (DsrStrCompare(pAce1->bstrInheritedObjectType,
                       pAce2->bstrInheritedObjectType))
       )
    {
        return 1;
    }

    // Return success
    //
    return 0;
}

//
// Copy over the ACE information
//
HRESULT
DsrAceDescCopy(
    OUT DSR_ACE_DESCRIPTOR* pDst,
    IN  DSR_ACE_DESCRIPTOR* pSrc)
{
    HRESULT hr = S_OK;

    do
    {
        // Initialize the ACE parameters
        *pDst = *pSrc;

        if (pSrc->bstrTrustee)
        {
            pDst->bstrTrustee =
                SysAllocString(pSrc->bstrTrustee);

            if (pDst->bstrTrustee == NULL)
            {
               DSR_BREAK_ON_FAILED_HR(hr = E_OUTOFMEMORY);
            }
        }

        if (pSrc->bstrObjectType)
        {
            pDst->bstrObjectType =
                SysAllocString(pSrc->bstrObjectType);

            if (pDst->bstrObjectType == NULL)
            {
               DSR_BREAK_ON_FAILED_HR(hr = E_OUTOFMEMORY);
            }
        }

        if (pSrc->bstrInheritedObjectType)
        {
            pDst->bstrInheritedObjectType =
                SysAllocString(pSrc->bstrInheritedObjectType);

            if (pDst->bstrInheritedObjectType == NULL)
            {
               DSR_BREAK_ON_FAILED_HR(hr = E_OUTOFMEMORY);
            }
        }

    } while (FALSE);

    // Cleanup
    {
        if (FAILED( hr ))
        {
            if (pDst->bstrTrustee)
            {
               SysFreeString(pDst->bstrTrustee);
            }
            if (pDst->bstrObjectType)
            {
               SysFreeString(pDst->bstrObjectType);
            }
            if (pDst->bstrInheritedObjectType)
            {
               SysFreeString(pDst->bstrInheritedObjectType);
            }
        }
    }

    return hr;
}

//
// Populates the given ACE descriptor with the values from
// the given ACE.
//
HRESULT
DsrAceDescFromIadsAce(
    IN PWCHAR pszDC,
    IN IADsAccessControlEntry* pAce,
    IN DSR_ACE_DESCRIPTOR* pAceParams)
{
    HRESULT hr = S_OK;
    BSTR bstrTrustee = NULL;
    WCHAR pszSid[1024], pszDomain[1024];
    BYTE pbSid[1024];
    DWORD dwSidSize, dwDomainSize;
    BOOL bOk;
    SID_NAME_USE SidNameUse;

    do
    {
        hr = pAce->get_AccessMask(&(pAceParams->dwAccessMask));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_AceType(&(pAceParams->dwAceType));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_AceFlags(&(pAceParams->dwAceFlags));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_Flags(&(pAceParams->dwFlags));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_ObjectType(&(pAceParams->bstrObjectType));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_InheritedObjectType(
                &(pAceParams->bstrInheritedObjectType));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_Trustee(&bstrTrustee);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get the SID of the trustee
        //
        dwSidSize = sizeof(pbSid);
        dwDomainSize = sizeof(pszDomain) / sizeof(WCHAR);
        bOk = LookupAccountName(
                    pszDC,
                    bstrTrustee,
                    (PSID)pbSid,
                    &dwSidSize,
                    pszDomain,
                    &dwDomainSize,
                    &SidNameUse);
        if (bOk == FALSE)
        {
            hr = GetLastError();
            break;
        }

        // Convert the sid to a string
        //
        hr = DsrStrFromSID((PSID)pbSid, pszSid, sizeof(pszSid));
        if (hr != NO_ERROR)
        {
            break;
        }

        // Create the trustee accordingly
        //
        pAceParams->bstrTrustee = SysAllocString(pszSid);
        if (pAceParams->bstrTrustee == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

    } while (FALSE);

    // Cleanup
    {
        if (bstrTrustee)
        {
            SysFreeString(bstrTrustee);
        }

        if (FAILED(hr))
        {
            DsrAceDescClear(pAceParams);
        }
    }

    return hr;
}
            
//
// Initialize an ace descriptor from a W2K Ace
//
HRESULT
DsrAceDescFromW2KAce(
    IN  PWCHAR pszDC,
    IN  PVOID pvAce,
    OUT DSR_ACE_DESCRIPTOR* pAceDesc)
{
    PACCESS_ALLOWED_ACE pAaAce = NULL;
    PACCESS_DENIED_ACE pAdAce = NULL;
    PACCESS_ALLOWED_OBJECT_ACE pAaoAce = NULL;
    PACCESS_DENIED_OBJECT_ACE pAdoAce = NULL;
    PSID pSID = NULL;
    DWORD dwFlags = 0, dwNameSize, dwDomainSize, dwAccessMask;
    BYTE bAceType, bAceFlags;
    SID_NAME_USE SidNameUse;
    WCHAR pszGuid[64], pszName[512], pszDomain[512], pszTrustee[1024];
    HRESULT hr = S_OK;
    GUID* pgObj = NULL, *pgInhObj = NULL;
    BOOL bOk = TRUE;

    // Read in the ace values
    //
    bAceType  = ((ACE_HEADER *)pvAce)->AceType;
    bAceFlags = ((ACE_HEADER *)pvAce)->AceFlags;
    switch (bAceType)
    {
        case ACCESS_ALLOWED_ACE_TYPE:
            pAaAce = (PACCESS_ALLOWED_ACE)pvAce;
            dwAccessMask = pAaAce->Mask;
            pSID = (PSID)&(pAaAce->SidStart);
            break;
            
        case ACCESS_DENIED_ACE_TYPE:
            pAdAce = (PACCESS_DENIED_ACE)pvAce;
            dwAccessMask = pAdAce->Mask;
            pSID = (PSID)&(pAdAce->SidStart);
            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            pAaoAce = (PACCESS_ALLOWED_OBJECT_ACE)pvAce;
            dwAccessMask = pAaoAce->Mask;
            dwFlags = pAaoAce->Flags;

            // Determine the location of the guids
            // and SIDs.  They are arranged such that they
            // take up as little memory as possible
            //
            if (dwFlags & ACE_OBJECT_TYPE_PRESENT)
            {
                pgObj = (GUID*)&(pAaoAce->ObjectType);
                pSID = (PSID)&(pAaoAce->InheritedObjectType);
                if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                {
                    pgInhObj = (GUID*)&(pAaoAce->InheritedObjectType);
                    pSID = (PSID)&(pAaoAce->SidStart);
                }
            }
            else 
            {
                pSID = (PSID)&(pAaoAce->ObjectType);
                if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                {
                    pgInhObj = (GUID*)&(pAaoAce->ObjectType);
                    pSID = (PSID)&(pAaoAce->InheritedObjectType);
                }
            }
            break;
            
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
            pAdoAce = (PACCESS_DENIED_OBJECT_ACE)pvAce;
            dwAccessMask = pAdoAce->Mask;
            dwFlags = pAdoAce->Flags;

            // Determine the location of the guids
            // and SIDs.  They are arranged such that they
            // take up as little memory as possible
            //
            if (dwFlags & ACE_OBJECT_TYPE_PRESENT)
            {
                pgObj = (GUID*)&(pAdoAce->ObjectType);
                pSID = (PSID)&(pAdoAce->InheritedObjectType);
                if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                {
                    pgInhObj = (GUID*)&(pAdoAce->InheritedObjectType);
                    pSID = (PSID)&(pAdoAce->SidStart);
                }
            }
            else 
            {
                pSID = (PSID)&(pAdoAce->ObjectType);
                if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                {
                    pgInhObj = (GUID*)&(pAdoAce->ObjectType);
                    pSID = (PSID)&(pAdoAce->InheritedObjectType);
                }
            }
            break;
            
        default:
            DsrTraceEx(0, "Unknown ACE TYPE %x", bAceType);
            bOk = FALSE;
            break;
    }
    if (bOk == FALSE)
    {
        return E_FAIL;
    }

    // Lookup the account name of the sid
    //
    hr = DsrStrFromSID(pSID, pszTrustee, sizeof(pszTrustee));
    if (hr != NO_ERROR)
    {
        return HRESULT_FROM_WIN32(hr);
    }

    // Fill in the ACE fields
    pAceDesc->dwAceType    = (LONG)bAceType;
    pAceDesc->dwAceFlags   = (LONG)bAceFlags;
    pAceDesc->dwAccessMask = (LONG)dwAccessMask;
    pAceDesc->dwFlags      = (LONG)dwFlags;
    pAceDesc->bstrTrustee  = SysAllocString(pszTrustee);
    if (pgObj)
    {
        StringFromGUID2(
            *pgObj, 
            pszGuid, 
            sizeof(pszGuid)/sizeof(WCHAR)); 
            
        pAceDesc->bstrObjectType = SysAllocString(pszGuid);
    }
    if (pgInhObj)
    {
        StringFromGUID2(
            *pgInhObj, 
            pszGuid, 
            sizeof(pszGuid)/sizeof(WCHAR)); 
            
        pAceDesc->bstrInheritedObjectType = SysAllocString(pszGuid);
    }

    return hr;
}

//
// Generates a list of ace descriptors based on a stringized
// SD
//
HRESULT 
DsrAceDescListFromString(
    IN  PWCHAR pszDC,
    IN  PWCHAR pszSD,
    OUT DSR_ACE_DESCRIPTOR** ppAceList, 
    OUT LPDWORD lpdwAceCount)
{
    BOOL bOk = TRUE, bPresent = FALSE, bDefaulted = FALSE;
    DSR_ACE_DESCRIPTOR* pAceList = NULL, *pCurAce = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    PVOID pvAce = NULL;
    ULONG ulSize = 0;
    PACL pDacl = NULL;
    HRESULT hr = S_OK;
    DWORD i;

    do 
    {
        // First, convert the stringized security descriptor to a 
        // plain old vanilla security descriptor.  ADSI doesn't 
        // support this for W2K, so we have to do it with SDDL 
        // api's
        //
        bOk = ConvertStringSecurityDescriptorToSecurityDescriptorW(
                    pszSD, 
                    SDDL_REVISION_1,
                    &pSD,
                    &ulSize);
        if (bOk == FALSE)
        {
            hr = E_FAIL;
            break;
        }

        // Get the DACL from the SD.
        //
        bOk = GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted);
        if (bOk == FALSE)
        {
            hr = E_FAIL;
            break;
        }

        // If there are no aces, then there's nothing to do
        // 
        if (pDacl->AceCount == 0)
        {
            break;
        }

        // Allocate the list that we'll return if everything goes well.
        //
        pAceList = (DSR_ACE_DESCRIPTOR*) 
            DsrAlloc(pDacl->AceCount * sizeof(DSR_ACE_DESCRIPTOR), TRUE);
        if (pAceList == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        
        // Initialize the list of aces
        // 
        for (i = 0, pCurAce = pAceList; i < pDacl->AceCount; i++, pCurAce++)
        {
            // Get a reference to the current
            // ACE
            //
            if (! GetAce(pDacl, i, &pvAce))
            {
                continue;
            }

            // Initialize the ACE descriptor accordingly
            //
            hr = DsrAceDescFromW2KAce(pszDC, pvAce, pCurAce);
            DSR_BREAK_ON_FAILED_HR(hr);

            //DsrAceDescTrace(pCurAce);
        }
        DSR_BREAK_ON_FAILED_HR(hr);

        // Set the return values. Clear pAceList so it doesn't
        // get cleaned up.
        //
        *ppAceList = pAceList;
        *lpdwAceCount = pDacl->AceCount;
        pAceList = NULL;

    } while (FALSE);                           

    // Cleanup
    {
        if (pSD)
        {
            LocalFree(pSD);
        }

        if (pAceList)
        {
            for (i = 0; i < pDacl->AceCount; i++)
            {
                DsrAceDescClear(&(pAceList[i]));
            }
            DsrFree(pAceList);
        }
    }
    
    return hr;
}

PWCHAR 
DsrAceAttrToString(
    IN PWCHAR pszObjectType)
{
    if (pszObjectType == NULL)
    {
        return L"All";
    }
    else if (lstrcmpi(pszObjectType, pszGuidUserParms) == 0)
    {
        return L"UserParms (BF967A6D-0DE6-11D0-A285-00AA003049E2)";
    }
    else if (lstrcmpi(pszObjectType, pszGuidRasPropSet1) == 0)
    {
        return L"Ras user properties (037088F8-0AE1-11D2-B422-00A0C968F939)";
    }
    else if (lstrcmpi(pszObjectType, pszGuidRasPropSet2) == 0)
    {
        return L"Misc user properties (4C164200-20C0-11D0-A768-00AA006E0529)";
    }
    else if (lstrcmpi(pszObjectType, pszGuidLogonHours) == 0)
    {
        return L"Logon-Hours (BF9679AB-0DE6-11D0-A285-00AA003049E2)";
    }
    else if (lstrcmpi(pszObjectType, pszGuidSamAccountName) == 0)
    {
        return L"Sam account name (3E0ABFD0-126A-11D0-A060-00AA006C33ED)";
    }

    return pszObjectType;
}

PWCHAR 
DsrAceApplyToString(
    IN PWCHAR pszApply)
{
    if (pszApply == NULL)
    {
        return L"This object";
    }
    else if (lstrcmpi(pszApply, pszGuidUserClass) == 0)
    {
        return L"User objects (BF967ABA-0DE6-11D0-A285-00aa003049E2)";
    }

    return pszApply;
} 

PWCHAR
DsrAceMaskToString(
    IN DWORD dwType,
    IN DWORD dwMask,
    IN PWCHAR pszBuf)
{
    WCHAR pszTemp[64];
    *pszBuf = L'\0';

    switch (dwType)
    {
        case ADS_ACETYPE_ACCESS_ALLOWED:
            wcscpy(pszBuf, L"Allow:       ");
            break;
            
    	case ADS_ACETYPE_ACCESS_DENIED:
            wcscpy(pszBuf, L"Deny:        ");
            break;
            
    	case ADS_ACETYPE_SYSTEM_AUDIT:
            wcscpy(pszBuf, L"Audit:       ");
            break;
            
    	case ADS_ACETYPE_ACCESS_ALLOWED_OBJECT:
            wcscpy(pszBuf, L"Allow obj:   ");
            break;
            
    	case ADS_ACETYPE_ACCESS_DENIED_OBJECT:
            wcscpy(pszBuf, L"Deny obj:    ");
            break;
            
    	case ADS_ACETYPE_SYSTEM_AUDIT_OBJECT:
            wcscpy(pszBuf, L"Audit obj:   ");
            break;
    }    	

    wsprintfW(pszTemp, L"(%x): ", dwMask);
    wcscat(pszBuf, pszTemp);

    if (dwMask == DSR_ADS_RIGHT_GENERIC_READ)
    {
        wcscat(pszBuf, L"Generic read");
    }
    else if (dwMask == 0xffffffff)
    {
        wcscat(pszBuf, L"Full control");
    }
    else
    {
    	if (dwMask & ADS_RIGHT_READ_CONTROL)
    	    wcscat(pszBuf, L"R ctrl, ");
    	if (dwMask & ADS_RIGHT_WRITE_DAC)
    	    wcscat(pszBuf, L"R/W dac, ");
    	if (dwMask & ADS_RIGHT_WRITE_OWNER)
    	    wcscat(pszBuf, L"W own, ");
    	if (dwMask & ADS_RIGHT_SYNCHRONIZE)
    	    wcscat(pszBuf, L"Sync, ");
    	if (dwMask & ADS_RIGHT_ACCESS_SYSTEM_SECURITY)
    	    wcscat(pszBuf, L"Sys, ");
    	if (dwMask & ADS_RIGHT_GENERIC_READ)
    	    wcscat(pszBuf, L"R (gen), ");
    	if (dwMask & ADS_RIGHT_GENERIC_WRITE)
    	    wcscat(pszBuf, L"W (gen), ");
    	if (dwMask & ADS_RIGHT_GENERIC_EXECUTE)
    	    wcscat(pszBuf, L"Ex, ");
    	if (dwMask & ADS_RIGHT_GENERIC_ALL)
    	    wcscat(pszBuf, L"All, ");
    	if (dwMask & ADS_RIGHT_DS_CREATE_CHILD)
    	    wcscat(pszBuf, L"Cr cld, ");
    	if (dwMask & ADS_RIGHT_DS_DELETE_CHILD)
    	    wcscat(pszBuf, L"Del cld, ");
    	if (dwMask & ADS_RIGHT_ACTRL_DS_LIST)
    	    wcscat(pszBuf, L"List, ");
    	if (dwMask & ADS_RIGHT_DS_SELF)
    	    wcscat(pszBuf, L"Self, ");
    	if (dwMask & ADS_RIGHT_DS_READ_PROP)
    	    wcscat(pszBuf, L"R prop, ");
    	if (dwMask & ADS_RIGHT_DS_WRITE_PROP)
    	    wcscat(pszBuf, L"W prop, ");
    	if (dwMask & ADS_RIGHT_DS_DELETE_TREE)
    	    wcscat(pszBuf, L"Del tree, ");
    	if (dwMask & ADS_RIGHT_DS_LIST_OBJECT)
    	    wcscat(pszBuf, L"List obj, ");
    	if (dwMask & ADS_RIGHT_DS_CONTROL_ACCESS)
    	    wcscat(pszBuf, L"Ctrl acc, ");
    }

    return pszBuf;
}

PWCHAR
DsrAceFlagsToString(
    IN DWORD dwAceFlags,
    IN PWCHAR pszBuf)
{   
    WCHAR pszTemp[64];
    *pszBuf = L'\0';

    switch (dwAceFlags)
    {
        case 0:
            wcscpy(pszBuf, L"This object only");
    	    break;
        
        case ADS_ACEFLAG_INHERIT_ACE:
            wcscpy(pszBuf, L"This object and children");
    	    break;
    	    
    	case ADS_ACEFLAG_NO_PROPAGATE_INHERIT_ACE:
            wcscpy(pszBuf, L"No-prop inherit");
    	    break;
    	    
    	case ADS_ACEFLAG_INHERIT_ONLY_ACE:
            wcscpy(pszBuf, L"Inherit-only");
    	    break;
    	    
    	case ADS_ACEFLAG_INHERITED_ACE:
    	    wcscpy(pszBuf, L"Inherited");
    	    break;
    	    
    	case ADS_ACEFLAG_VALID_INHERIT_FLAGS:
    	    wcscpy(pszBuf, L"Valid inherit flags");
    	    break;
    	    
    	case ADS_ACEFLAG_SUCCESSFUL_ACCESS:
    	    wcscpy(pszBuf, L"Successful access");
    	    break;
    	    
    	case ADS_ACEFLAG_FAILED_ACCESS:
    	    wcscpy(pszBuf, L"Failed access");
    	    break;
    }  

    wsprintfW(pszTemp, L" (%x)", dwAceFlags);
    wcscat(pszBuf, pszTemp);

    return pszBuf;
}   	

//
// Traces out the contents of an ACE
//
VOID
DsrAceDescTrace(
    IN IADs* pIads,
    IN DSR_ACE_DESCRIPTOR* pA)
{
    VARIANT var;
    BSTR bstrProp = SysAllocString(pszDn);
    HRESULT hr = S_OK;
    WCHAR pszBuf[1024];

    do
    {
        VariantInit(&var);

        if (bstrProp == NULL)
        {
            hr = E_FAIL;
            break;
        }

        hr = pIads->Get(bstrProp, &var);
        DSR_BREAK_ON_FAILED_HR( hr );

        DsrTraceEx(0, "%ls", V_BSTR(&var));
        DsrTraceEx(0, "%ls", 
            DsrAceMaskToString(pA->dwAceType, pA->dwAccessMask, pszBuf));
        DsrTraceEx(0, "To:          %ls", pA->bstrTrustee);
        DsrTraceEx(0, "Attribute:   %ls", 
            DsrAceAttrToString(pA->bstrObjectType));
        DsrTraceEx(0, "ApplyTo:     %ls", 
            DsrAceApplyToString(pA->bstrInheritedObjectType));
        DsrTraceEx(0, "Inheritance: %ls", 
            DsrAceFlagsToString(pA->dwAceFlags, pszBuf));
        DsrTraceEx(0, "Flags:       %x", pA->dwFlags);
        DsrTraceEx(0, " ");

    } while (FALSE);

    // Cleanup
    //
    {
        SysFreeString(bstrProp);
        VariantClear(&var);        
    }        

    if (FAILED(hr))
    {
        DsrTraceEx(
            0, 
            "{ %-8x %-2x %-2x %-2x %-40ls %ls %ls }",
            pA->dwAccessMask,
            pA->dwAceType,
            pA->dwAceFlags,
            pA->dwFlags,
            pA->bstrTrustee,
            pA->bstrObjectType,
            pA->bstrInheritedObjectType);
    }
}

//
// Adds the given ace to the given ds object
//
HRESULT
DsrAceAdd(
    IN  PWCHAR pszDC,
    IN  IADs* pIads,
    IN  DSR_ACE_DESCRIPTOR * pAceParams)
{
    IADsSecurityDescriptor* pSD = NULL;
    IADsAccessControlList* pAcl = NULL;
    IDispatch* pAce = NULL;
    IDispatch* pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT var;

    // Initialize
    VariantInit(&var);

    do
    {
        // Get the security descriptor
        //
        pIads->Get((PWCHAR)pszSecurityDesc, &var);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get the appropriate interface to the sd
        //
        V_DISPATCH(&var)->QueryInterface(
            IID_IADsSecurityDescriptor,
            (VOID**)&pSD);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get a reference to the discretionary acl
        //
        hr = pSD->get_DiscretionaryAcl(&pDispatch);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pDispatch->QueryInterface(
                IID_IADsAccessControlList,
                (VOID**)&pAcl);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Don't add the ACE if it's already there.
        //
        hr = DsrAceFindInAcl(
                pszDC,                
                pAcl,
                pAceParams,
                &pAce);
        if (SUCCEEDED(hr) && pAce)
        {
            hr = S_OK;
            break;
        }

        // Trace out the ACE
        DsrAceDescTrace(pIads, pAceParams);

        // Create the ACE
        hr = DsrAceCreate(pAceParams, &pAce);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Add the newly created ACE to the ACL
        //
        hr = pAcl->AddAce(pAce);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Now commit the result in the ACL
        //
        hr = pSD->put_DiscretionaryAcl(pDispatch);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Finally, commit the result in the ds object
        //
        hr = pIads->Put((PWCHAR)pszSecurityDesc, var);
        DSR_BREAK_ON_FAILED_HR( hr );

    } while (FALSE);

    // Cleanup
    {
        DSR_RELEASE( pAce );
        DSR_RELEASE( pAcl );
        DSR_RELEASE( pDispatch );
        DSR_RELEASE( pSD );

        VariantClear(&var);
    }

    return DSR_ERROR(hr);
}

//
// Creates a new ACE object from the given parameters
//
HRESULT
DsrAceCreate(
    IN  DSR_ACE_DESCRIPTOR * pAceParams,
    OUT IDispatch** ppAce)
{
    IADsAccessControlEntry* pAce = NULL;
    IDispatch* pRet = NULL;
    HRESULT hr = S_OK;

    do
    {
        // Create the new ACE
        //
        hr = CoCreateInstance(
                CLSID_AccessControlEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlEntry,
                (VOID**) &pAce);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Initialize the values
        //
        hr = pAce->put_Trustee(pAceParams->bstrTrustee);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_AceFlags(pAceParams->dwAceFlags);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_Flags(pAceParams->dwFlags);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_AceType(pAceParams->dwAceType);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_AccessMask(pAceParams->dwAccessMask);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_ObjectType(pAceParams->bstrObjectType);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_InheritedObjectType(
                        pAceParams->bstrInheritedObjectType);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Query the return value
        //
        hr = pAce->QueryInterface(IID_IDispatch, (VOID**)&pRet);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Assign the return value
        *ppAce = pRet;

    } while (FALSE);

    // Cleanup
    {
        if (FAILED (hr))
        {
            DSR_RELEASE(pRet);
        }
        DSR_RELEASE(pAce);
    }

    return hr;
}

//
// Finds the given ace in the given acl
//
HRESULT
DsrAceFind(
    IN  PWCHAR pszDC,
    IN  IADs* pObject,
    IN  DSR_ACE_DESCRIPTOR* pAceParams,
    OUT VARIANT* pVarSD,
    OUT IADsSecurityDescriptor** ppSD,
    OUT IADsAccessControlList** ppAcl,
    OUT IDispatch** ppAce)
{
    IDispatch* pAcl = NULL;
    HRESULT hr = S_OK;

    do
    {
        // Get the security descriptor
        //
        pObject->Get((PWCHAR)pszSecurityDesc, pVarSD);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get the appropriate interface to the sd
        //
        V_DISPATCH(pVarSD)->QueryInterface(
            IID_IADsSecurityDescriptor,
            (VOID**)ppSD);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get a reference to the discretionary acl
        //
        hr = (*ppSD)->get_DiscretionaryAcl(&pAcl);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAcl->QueryInterface(
                IID_IADsAccessControlList,
                (VOID**)ppAcl);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = DsrAceFindInAcl(
                pszDC,
                *ppAcl,
                pAceParams,
                ppAce);
        DSR_BREAK_ON_FAILED_HR(hr);                

    } while (FALSE);

    // Cleanup
    {
        DSR_RELEASE( pAcl );

        if (*ppAce == NULL)
        {
            VariantClear(pVarSD);
            DSR_RELEASE(*ppAcl);
            DSR_RELEASE(*ppSD);
            *ppAcl = NULL;
            *ppSD = NULL;
        }
    }

    return hr;
}

//
// Finds the given ACE in the given ACL
//
HRESULT
DsrAceFindInAcl(
    IN  PWCHAR pszDC,
    IN  IADsAccessControlList* pAcl,
    IN  DSR_ACE_DESCRIPTOR* pAceDesc, 
    OUT IDispatch** ppAce)
{    
    DSR_ACE_DESCRIPTOR CurAceParams, *pCurAceDesc = &CurAceParams;
    IADsAccessControlEntry* pCurAce = NULL;
    HRESULT hr = S_OK;
    IUnknown* pUnknown = NULL;
    IEnumVARIANT* pEnumVar = NULL;
    IDispatch* pRet = NULL;
    DWORD dwRetrieved;
    VARIANT var;

    do
    {
        // Get an enumerator of the aces
        //
        hr = pAcl->get__NewEnum(&pUnknown);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get the right interface to enumerate the aces
        //
        hr = pUnknown->QueryInterface(IID_IEnumVARIANT, (VOID**)&pEnumVar);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Enumerate
        //
        pEnumVar->Reset();
        VariantInit(&var);
        ZeroMemory(pCurAceDesc, sizeof(DSR_ACE_DESCRIPTOR));
        while ((pEnumVar->Next(1, &var, &dwRetrieved) == S_OK) &&
               (dwRetrieved == 1)
              )
        {
            // Get the reference to the ace
            //
            hr = V_DISPATCH(&var)->QueryInterface(
                    IID_IADsAccessControlEntry,
                    (VOID**)&pCurAce);

            if (SUCCEEDED (hr))
            {
                // Read the ACE parameters
                //
                hr = DsrAceDescFromIadsAce(pszDC, pCurAce, pCurAceDesc);
                if (SUCCEEDED (hr))
                {
                    // Assign the ace if we have a match
                    //
                    if (DsrAceDescCompare(pCurAceDesc, pAceDesc) == 0)
                    {
                        pRet = V_DISPATCH(&var);
                    }

                    DsrAceDescClear(pCurAceDesc);
                }
                pCurAce->Release();
            }

            if (pRet == NULL)
            {
                VariantClear(&var);
            }
            else
            {
                break;
            }
        }

        // Assign the return value
        //
        *ppAce = pRet;
        
    } while (FALSE);        

    // Cleanup
    {
        DSR_RELEASE( pEnumVar );
        DSR_RELEASE( pUnknown );
    }

    return hr;
}    

//
// Removes the given ace from the given ds object
//
HRESULT
DsrAceRemove(
    IN  PWCHAR pszDC,
    IN  IADs* pIads,
    IN  DSR_ACE_DESCRIPTOR * pAceParams)
{
    IADsSecurityDescriptor* pSD = NULL;
    IADsAccessControlList* pAcl = NULL;
    IADsAccessControlEntry* pIadsAce = NULL;
    IDispatch* pAce = NULL;
    DSR_ACE_DESCRIPTOR CurAceParams;
    HRESULT hr = S_OK;
    VARIANT varSD;

    do
    {
        VariantInit(&varSD);

        hr = DsrAceFind(pszDC, pIads, pAceParams, &varSD, &pSD, &pAcl, &pAce);
        DSR_BREAK_ON_FAILED_HR( hr );

        if (pAce)
        {
            // Make sure the ace is the same as we think
            //
            hr = pAce->QueryInterface(
                    IID_IADsAccessControlEntry, 
                    (VOID**)&pIadsAce);
            if (SUCCEEDED(hr))
            {
                DsrTraceEx(0, "ACE to be removed!");
                DsrAceDescFromIadsAce(pszDC, pIadsAce, &CurAceParams);
                DsrAceDescTrace(pIads, &CurAceParams);
                DsrAceDescClear(&CurAceParams);
            }
            else
            {
                DsrTraceEx(0, "Unable to trace ACE that will be removed!\n");
            }
        
            // Remove the ace found if any.
            //
            // Trace out the ACE
            hr = pAcl->RemoveAce(pAce);
            DSR_BREAK_ON_FAILED_HR( hr );

            // Now commit the result in the ACL
            //
            hr = pSD->put_DiscretionaryAcl(pAcl);
            DSR_BREAK_ON_FAILED_HR( hr );

            // Finally, commit the result in the ds object
            //
            hr = pIads->Put((PWCHAR)pszSecurityDesc, varSD);
            DSR_BREAK_ON_FAILED_HR( hr );
        }
        else
        {
            DsrTraceEx(0, "DsrAceRemove: unable to match ACE for removal:");
            DsrAceDescTrace(pIads, pAceParams);
        }

    } while (FALSE);

    // Cleanup
    {
        DSR_RELEASE( pAce );
        DSR_RELEASE( pIadsAce );
        DSR_RELEASE( pAcl );
        DSR_RELEASE( pSD );
        VariantClear(&varSD);
    }

    return DSR_ERROR(hr);
}

//
// Cleans up after DsrAccessInfoInit
//
DWORD
DsrAccessInfoCleanup(
    IN DSR_DOMAIN_ACCESS_INFO* pInfo)
{
    if (pInfo)
    {
        // Cleanup the name of the DC
        //
        if (pInfo->pszDC)
        {
            DsrFree(pInfo->pszDC);
        }
    
        // Cleanup the ace applications
        //
        DsrAceAppCleanup(pInfo->pAcesUser, pInfo->dwAceCountUser);
        DsrAceAppCleanup(pInfo->pAcesNt4, pInfo->dwAceCountNt4);
        DsrAceAppCleanup(pInfo->pAcesW2k, pInfo->dwAceCountW2k);

        // Release the hold on domain objects
        //
        DSR_RELEASE(pInfo->pUserClass);
        DSR_RELEASE(pInfo->pRootDse);
        DSR_RELEASE(pInfo->pDomain);

        DsrFree(pInfo);
    }

    return NO_ERROR;
}

// 
// Generates aces from the default user SD
//
HRESULT
DsrAccessInfoGenerateUserAces(
    IN OUT DSR_DOMAIN_ACCESS_INFO* pInfo)
{
    DSR_ACE_DESCRIPTOR* pAceSrc = NULL, *pAceList = NULL;
    DSR_ACE_APPLICATION* pAceApp = NULL;
    DWORD i, dwAceCount = 0;
    HRESULT hr = S_OK;
    VARIANT var;

    VariantInit(&var);

    do 
    {
        // Read in the default user SD
        //
        hr = pInfo->pUserClass->Get((PWCHAR)pszDefSecurityDesc, &var);
        DSR_BREAK_ON_FAILED_HR(hr);

        // Generate a list of ACE descriptors based on the
        // default user SD.
        //
        hr = DsrAceDescListFromString(
                pInfo->pszDC,
                V_BSTR(&var), 
                &pAceList, 
                &dwAceCount);
        DSR_BREAK_ON_FAILED_HR(hr);

        // Initialize a new array of ace applications big enough
        // to hold the hard coded ones plus the ones we just read
        // from the default SD of the user class.
        //
        pInfo->pAcesUser = (DSR_ACE_APPLICATION*)
            DsrAlloc((sizeof(DSR_ACE_APPLICATION) * dwAceCount), TRUE);
        if (pInfo->pAcesUser == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        // Add the ACEs we read from the default user SD
        //
        pAceApp = pInfo->pAcesUser;
        for (i = 0, pAceSrc = pAceList; 
             i < dwAceCount; 
             i++, pAceSrc++, pAceApp++)
        {   
            pAceApp->pObject = pInfo->pDomain;
            pAceApp->pObject->AddRef();
            CopyMemory(
                &(pAceApp->Ace), 
                pAceSrc,
                sizeof(DSR_ACE_DESCRIPTOR));
            pInfo->dwAceCountUser++;

            // As we append the aces, we need to modify them
            // so that they apply only to user objects in the 
            // domain.
            pAceApp->Ace.bstrInheritedObjectType = 
                SysAllocString(pszGuidUserClass);
            pAceApp->Ace.dwAceFlags = DSR_ADS_ACE_INHERITED;
            pAceApp->Ace.dwFlags |= ADS_FLAG_INHERITED_OBJECT_TYPE_PRESENT;
            if (pAceApp->Ace.dwAceType == ADS_ACETYPE_ACCESS_ALLOWED)
            {
                pAceApp->Ace.dwAceType = 
                    ADS_ACETYPE_ACCESS_ALLOWED_OBJECT;
            }
            else if (pAceApp->Ace.dwAceType == ADS_ACETYPE_ACCESS_DENIED)
            {
                pAceApp->Ace.dwAceType = 
                    ADS_ACETYPE_ACCESS_DENIED_OBJECT;
            }
        }
    
    } while (FALSE);

    // Cleanup
    {
        DSR_FREE(pAceList);
        VariantClear(&var);
    }

    return hr;
}

//
// Generates the information needed to enable nt4 ras
// servers in a domain
//
HRESULT
DsrAccessInfoInit(
    IN  PWCHAR pszDomain,
    OUT DSR_DOMAIN_ACCESS_INFO** ppInfo)
{
    DSR_DOMAIN_ACCESS_INFO* pInfo = NULL;
    IADsContainer* pDomContainer = NULL, *pSchemaContainer = NULL;
    IADs* pDomain = NULL;
    IDispatch* pDispatch = NULL;
    PDOMAIN_CONTROLLER_INFO pDomainInfo = NULL;
    HRESULT hr = S_OK;

    do
    {
        // Allocate and zero the return value
        //
        pInfo = (DSR_DOMAIN_ACCESS_INFO*)
                    DsrAlloc(sizeof(DSR_DOMAIN_ACCESS_INFO), TRUE);
        if (pInfo == NULL)
        {
           DSR_BREAK_ON_FAILED_HR(hr = E_OUTOFMEMORY);
        }

        // Get the name of a DC to query when needed
        //
        hr = DsGetDcNameW(
                NULL,
                pszDomain,
                NULL,
                NULL,
                DS_DIRECTORY_SERVICE_REQUIRED,
                &pDomainInfo);
        if (hr != NO_ERROR)
        {
            hr = HRESULT_FROM_WIN32(hr);
            break;
        }

        // Copy the string
        //
        pInfo->pszDC = (PWCHAR)
            DsrAlloc(
                (wcslen(pDomainInfo->DomainControllerName) + 1) * 
                sizeof(WCHAR),
                FALSE);
        if (pInfo->pszDC == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        wcscpy(pInfo->pszDC, pDomainInfo->DomainControllerName);

        // Get the well known domain containers
        //
        hr = DsrDomainGetContainers(
                pszDomain,
                &(pInfo->pRootDse),
                &pDomContainer,
                &pSchemaContainer);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get the interface to the domain object
        //
        hr = pDomContainer->QueryInterface(
                IID_IADs,
                (VOID**)&pDomain);
        DSR_BREAK_ON_FAILED_HR( hr );
        pInfo->pDomain = pDomain;
        pInfo->pDomain->AddRef();

        // Get the reference to the user class in the
        // schema
        hr = pSchemaContainer->GetObject(
                (PWCHAR)pszUserClass,
                (PWCHAR)pszUserCN,
                &pDispatch);
        DSR_BREAK_ON_FAILED_HR( hr );
        hr = pDispatch->QueryInterface(
                IID_IADs,
                (VOID**)&(pInfo->pUserClass));
        DSR_BREAK_ON_FAILED_HR( hr );

        // Generate the ACEs from the default user SD
        //
        hr = DsrAccessInfoGenerateUserAces(pInfo);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Create ace applications for all of the nt4
        // aces
        hr = DsrAceAppFromAppDesc(
                g_pAcesNt4,
                sizeof(g_pAcesNt4) / sizeof(*g_pAcesNt4),
                pDomContainer,
                pDomain,
                &(pInfo->pAcesNt4),
                &(pInfo->dwAceCountNt4));
        DSR_BREAK_ON_FAILED_HR( hr );

        // Create ace applications for all of the w2k
        // aces
        hr = DsrAceAppFromAppDesc(
                g_pAcesW2k,
                sizeof(g_pAcesW2k) / sizeof(*g_pAcesW2k),
                pDomContainer,
                pDomain,
                &(pInfo->pAcesW2k),
                &(pInfo->dwAceCountW2k));
        DSR_BREAK_ON_FAILED_HR( hr );

        // Assign the return value
        *ppInfo = pInfo;

    } while (FALSE);

    // Cleanup
    //
    {
        DSR_RELEASE(pDomain);
        DSR_RELEASE(pDomContainer);
        DSR_RELEASE(pSchemaContainer);
        DSR_RELEASE(pDispatch);
        if (FAILED (hr))
        {
            DsrAccessInfoCleanup(pInfo);
        }
        if (pDomainInfo)
        {
            NetApiBufferFree(pDomainInfo);
        }
    }

    return hr;
}

//
// Discovers the access mode of the domain currently.
//
// Assumes COM is initialized
//
HRESULT
DsrDomainQueryAccessEx(
    IN  PWCHAR pszDomain,
    OUT LPDWORD lpdwAccessFlags,
    OUT DSR_DOMAIN_ACCESS_INFO** ppInfo)
{
    DSR_DOMAIN_ACCESS_INFO* pInfo = NULL;
    HRESULT hr = S_OK;
    BOOL bOk = FALSE;

    if (lpdwAccessFlags == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    do
    {
        // Initialize
        //
        *lpdwAccessFlags = 0;
        
        // Read in the info that tells us what ACE's
        // need to be set.
        //
        hr = DsrAccessInfoInit(
                pszDomain, 
                &pInfo);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Check for nt4 level access
        //
        bOk = FALSE;
        hr = DsrAceAppQueryPresence(
                pInfo->pszDC,
                pInfo->pAcesNt4,
                pInfo->dwAceCountNt4,
                &bOk);
        DSR_BREAK_ON_FAILED_HR(hr);

        // If we don't have nt4 access, we have no access
        //
        if (bOk == FALSE)
        {
            *lpdwAccessFlags = 0;
            break;
        }
        *lpdwAccessFlags |= MPRFLAG_DOMAIN_NT4_SERVERS;

        // Check for w2k level access
        //
        bOk = FALSE;
        hr = DsrAceAppQueryPresence(
                pInfo->pszDC,
                pInfo->pAcesW2k,
                pInfo->dwAceCountW2k,
                &bOk);
        DSR_BREAK_ON_FAILED_HR(hr);

        // If we don't have w2k access, no need to proceed
        //
        if (bOk == FALSE)
        {
            break;
        }
        *lpdwAccessFlags |= MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS;

    } while (FALSE);

    // Cleanup
    {
        if (FAILED(hr))
        {
            if (pInfo)
            {
                DsrAccessInfoCleanup(pInfo);
            }
        }
        else
        {
            *ppInfo = pInfo;
        }
    }

    return hr;
}

//
// Returns the access level of the given domain
//
DWORD
DsrDomainQueryAccess(
    IN  PWCHAR pszDomain,
    OUT LPDWORD lpdwAccessFlags)
{
    DSR_DOMAIN_ACCESS_INFO* pInfo = NULL;
    HRESULT hr = S_OK;

    do
    {
        // Initialize
        hr = DsrComIntialize();
        DSR_BREAK_ON_FAILED_HR( hr );

        // Query the access
        hr = DsrDomainQueryAccessEx(
                pszDomain,
                lpdwAccessFlags,
                &pInfo);
        DSR_BREAK_ON_FAILED_HR(hr);
        
    } while (FALSE);

    // Cleanup
    {
        if (pInfo)
        {
            DsrAccessInfoCleanup(pInfo);
        }

        DsrComUninitialize();
    }

    return DSR_ERROR(hr);
}

//
// Sets the ACES in the given domain to enable nt4 servers
//
DWORD
DsrDomainSetAccess(
    IN PWCHAR pszDomain,
    IN DWORD dwAccessFlags)
{
    DSR_DOMAIN_ACCESS_INFO* pInfo = NULL;
    HRESULT hr = S_OK;
    BOOL bClean = TRUE;
    DWORD dwCurAccess = 0;

    do
    {
        // Initialize 
        hr = DsrComIntialize();
        DSR_BREAK_ON_FAILED_HR( hr );

        DsrTraceEx(
            0, 
            "DsrDomainSetAccess: Req: %x", 
            dwAccessFlags);
            
        // W2k mode always implies nt4 mode as well
        //
        if (dwAccessFlags & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS)
        {
            dwAccessFlags |= MPRFLAG_DOMAIN_NT4_SERVERS;
        }

        // Discover the current access on the domain and 
        // initialize the info we need
        //
        hr = DsrDomainQueryAccessEx(
                pszDomain,
                &dwCurAccess,
                &pInfo);
        DSR_BREAK_ON_FAILED_HR(hr);

        DsrTraceEx(
            0, 
            "DsrDomainSetAccess: Cur: %x", 
            dwCurAccess);

        // Remove all appropriate aces if the requested access
        // is none.
        if (dwAccessFlags == 0)
        {
            // Remove the nt4 mode aces if needed
            //
            if (dwCurAccess & MPRFLAG_DOMAIN_NT4_SERVERS)
            {
                hr = DsrAceAppRemove(
                        pInfo->pszDC,
                        pInfo->pAcesUser,
                        pInfo->dwAceCountUser);
                DSR_BREAK_ON_FAILED_HR(hr);
                
                hr = DsrAceAppRemove(
                        pInfo->pszDC,
                        pInfo->pAcesNt4,
                        pInfo->dwAceCountNt4);
                DSR_BREAK_ON_FAILED_HR(hr);
            }

            // Remove the w2k mode aces if needed
            //
            if (dwCurAccess & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS)
            {
                hr = DsrAceAppRemove(
                        pInfo->pszDC,
                        pInfo->pAcesW2k,
                        pInfo->dwAceCountW2k);
                DSR_BREAK_ON_FAILED_HR(hr);
            }
        }

        // Set nt4 mode if needed
        //
        if (dwAccessFlags & MPRFLAG_DOMAIN_NT4_SERVERS)
        {
            // Remove w2k level access if needed
            //
            if ((!(dwAccessFlags & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS)) &&
                (dwCurAccess & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS))
            {
                hr = DsrAceAppRemove(
                        pInfo->pszDC,
                        pInfo->pAcesW2k,
                        pInfo->dwAceCountW2k);
                DSR_BREAK_ON_FAILED_HR(hr);
            }

            // Add nt4 level access if needed
            //
            if (! (dwCurAccess & MPRFLAG_DOMAIN_NT4_SERVERS))
            {
                hr = DsrAceAppAdd(
                        pInfo->pszDC,
                        pInfo->pAcesUser,
                        pInfo->dwAceCountUser);
                DSR_BREAK_ON_FAILED_HR(hr);
            
                hr = DsrAceAppAdd(
                        pInfo->pszDC,
                        pInfo->pAcesNt4,
                        pInfo->dwAceCountNt4);
                DSR_BREAK_ON_FAILED_HR(hr);
            }
        }

        // Set w2k mode if needed
        //
        if (dwAccessFlags & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS)
        {
            if (!(dwCurAccess & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS))
            {
                hr = DsrAceAppAdd(
                        pInfo->pszDC,
                        pInfo->pAcesW2k,
                        pInfo->dwAceCountW2k);
                DSR_BREAK_ON_FAILED_HR(hr);
            }
        }
        
    } while (FALSE);

    // Cleanup
    {
        if (pInfo)
        {
            DsrAccessInfoCleanup(pInfo);
        }
        
        DsrComUninitialize();
    }

    return DSR_ERROR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\upgrade\steelhead2nt5\upgrade.h ===
/*
	File	upgrade.h
	
	Implementation of functions to update the registry when an
	NT 4.0 to NT 5.0 upgrade takes place.

	Paul Mayfield, 8/11/97

	Copyright 1997 Microsoft.
*/

#ifndef __Rtrupgrade_h
#define __Rtrupgrade_h

#define UNICODE
#define MPR50 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rtinfo.h>
#include <ipxrtdef.h>
#include <rpc.h>
#include <setupapi.h>
#include <mprapi.h>
#include <mprapip.h>
#include <routprot.h>
#include "utils.h"
#include <ipinfoid.h>
#include <iprtrmib.h>
#include <fltdefs.h>
#include <iprtinfo.h>

#define GUIDLENGTH 45
#define MAX_INTEFACE_NAME_LEN 256

//
// Entry point for doing router upgrades
//
HRESULT 
WINAPI 
RouterUpgrade (
    DWORD dwUpgradeFlag,
    DWORD dwUpgradeFromBuildNumber,
    PWCHAR szAnswerFileName,
    PWCHAR szSectionName);

//
// Functions that do the actual upgrading
//
DWORD 
SteelheadToNt5Upgrade (
    PWCHAR FileName);
    
DWORD 
IpRipToRouterUpgrade(
    PWCHAR FileName);
    
DWORD 
SapToRouterUpgrade(
    PWCHAR FileName);
    
DWORD 
DhcpToRouterUpgrade(
    PWCHAR FileName);

DWORD
RadiusToRouterUpgrade(
    IN PWCHAR pszFile);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\inc\events.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	events.h
//
// Description: Text and corresponding values of events are defined here.
//
// History: 	May 11,1992.	NarenG		Created original version.
//


// Don't change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define AFP_LOG_BASE			10000

#define AFPLOG_CANT_START		(AFP_LOG_BASE+1)
/*
 *Unable to start the File Server for Macintosh service.
 *A system specific error has occured.
 *The error code is in the data 
 */

#define AFPLOG_CANT_INIT_RPC		(AFP_LOG_BASE+2)
/*
 *The File Server for Macintosh service failed to start. Unable to setup
 *the server to accept Remote Procedure Calls.
 */

#define AFPLOG_CANT_CREATE_SECOBJ	(AFP_LOG_BASE+3)
/*
 *The File Server for Macintosh service failed to start. 
 * Security access checking of administrators could not be setup correctly.
 */

#define AFPLOG_CANT_OPEN_REGKEY		(AFP_LOG_BASE+4)
/*
 *The File Server for Macintosh service failed to start. 
 *The Registry could not be opened.
 */

#define AFPLOG_CANT_OPEN_FSD		(AFP_LOG_BASE+5)
/*
 *The File Server for Macintosh service failed to start. 
 *Unable to open the Appletalk Filing Protocol file system driver (SfmSrv.sys).
 */

#define AFPLOG_INVALID_SERVERNAME	(AFP_LOG_BASE+6)
/*
 *The Registry contains an invalid value for the server name parameter.
 *Verify the value of this parameter through the Computer Managerment Console 
 *and in the
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters Registry key.
 */

#define AFPLOG_INVALID_SRVOPTION	(AFP_LOG_BASE+7)
/*
 *The File Server for Macintosh service failed to start. 
 *The Registry contains an invalid value for the server options parameter.
 *Verify the value of this parameter through the Computer Managerment Console 
 *and in the
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters Registry key.
 */

#define AFPLOG_INVALID_MAXSESSIONS	(AFP_LOG_BASE+8)
/*
 *The File Server for Macintosh service failed to start. 
 *The Registry contains an invalid value for the maximum sessions parameter.
 *Verify the value of this parameter through the Computer Managerment Console 
 *and in the
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters Registry key.
 */

#define AFPLOG_INVALID_LOGINMSG		(AFP_LOG_BASE+9)
/*
 *The File Server for Macintosh service failed to start. 
 *The Registry contains an invalid value for the logon message parameter.
 *Verify the value of this parameter through the Computer Managerment Console 
 *and in the
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters Registry key.
 */

#define AFPLOG_INVALID_MAXPAGEDMEM	(AFP_LOG_BASE+10)
/*
 *Obsolete:
 *The File Server for Macintosh service failed to start. 
 *The Registry contains an invalid value for the maximum paged memory.
 *Change the value of this parameter in the
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters Registry key.
 */

#define AFPLOG_INVALID_MAXNONPAGEDMEM	(AFP_LOG_BASE+11)
/*
 *Obsolete:
 *The File Server for Macintosh service failed to start. 
 *The Registry contains an invalid value for the maximum non-paged memory
 *parameter.
 *Change the value of this parameter in the
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters Registry key.
 */

#define AFPLOG_CANT_INIT_SRVR_PARAMS    (AFP_LOG_BASE+12)
/*
 *The File Server for Macintosh service failed to start.
 *An error occurred while trying to initialize the AppleTalk Filing Protocol 
 *driver (SfmSrv.sys) with server parameters.
 */

#define AFPLOG_CANT_INIT_VOLUMES	(AFP_LOG_BASE+13)
/*
 *The File Server for Macintosh service failed to start.
 *An error occurred while trying to initialize Macintosh-Accessible volumes.
 *The error code is in the data.
 */

#define AFPLOG_CANT_ADD_VOL		(AFP_LOG_BASE+14)
/*
 *Failed to register volume "%1" with the File Server for Macintosh service.
 *This volume may be removed from the Registry by using the Server Manager or
 *File Manager tools.
 */

#define AFPLOG_CANT_INIT_ETCINFO	(AFP_LOG_BASE+15)
/*
 *The File Server for Macintosh service failed to start. 
 *An error occurred while trying to initialize the AppleTalk Filing 
 *Protocol driver (SfmSrv.sys) with the extension/creator/type associations.
 */

#define AFPLOG_CANT_INIT_ICONS		(AFP_LOG_BASE+16)
/*
 *The File Server for Macintosh service failed to start.
 *An error occurred while trying to initialize the AppleTalk Filing Protocol 
 *driver (SfmSrv.sys) with the server icons.
 */

#define AFPLOG_CANT_ADD_ICON		(AFP_LOG_BASE+17)
/*
 *Failed to register icon "%1" with the File Server for Macintosh service.
 *This icon can no longer be used by the service.
 */

#define AFPLOG_CANT_CREATE_SRVRHLPR	(AFP_LOG_BASE+18)
/*
 *A system resouce could not be allocated for the File Server for Macintosh service.
 *Unable to create a Server Helper thread.
 *The error code is in the data.
 */

#define AFPLOG_OPEN_FSD			(AFP_LOG_BASE+19)
/*
 *The File Server for Macintosh service was unable to open a handle to the 
 *AppleTalk Filing Protocol file system driver (Sfmsrv.sys).
 */

#define AFPLOG_OPEN_LSA			(AFP_LOG_BASE+20)
/*
 *The File Server for Macintosh service was unable to open a handle to the 
 *Local Security Authority.
 */

#define AFPLOG_CANT_GET_DOMAIN_INFO	(AFP_LOG_BASE+21)
/*
 *The File Server for Macintosh service was unable to contact a 
 *domain controller to obtain domain information.
 */

#define AFPLOG_CANT_INIT_DOMAIN_INFO	(AFP_LOG_BASE+22)
/*
 *The File Server for Macintosh service was unable to send domain information 
 *to the AppleTalk Filing Protocol file system driver.
 */

#define AFPLOG_CANT_CHECK_ACCESS        (AFP_LOG_BASE+23)
/*
 *An error occured while checking user's credentials.
 *Operation was not completed.
 */

#define AFPLOG_INVALID_EXTENSION	(AFP_LOG_BASE+24)
/*
 *A corrupt extension "%1" was detected in the Registry.
 *This value was ignored and processing was continued.
 *Change the value for this extension in the 
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters\Extensions Registry key.
 *Restart the service if the corrected extension is to be used.
 */

#define AFPLOG_CANT_STOP		(AFP_LOG_BASE+25)
/*
 *Unable to stop the File Server for Macintosh service.
 *A system specific error has occured.
 *The error code is in the data.
 */

#define AFPLOG_INVALID_CODEPAGE		(AFP_LOG_BASE+26)
/*
 *Not used
 *The Registry contains an invalid value for the path to the Macintosh
 *code-page file.
 */

#define AFPLOG_CANT_INIT_SRVRHLPR	(AFP_LOG_BASE+27)
/*
 *An error occurred while initializing the File Server for Macintosh service.
 *A Server Helper thread could not be initialized.
 *The specific error code is in the data.
 */

#define AFPLOG_CANT_LOAD_FSD		(AFP_LOG_BASE+28)
/*
 *The File Server for Macintosh service failed to start.
 *Unable to load the AppleTalk Filing Protocol file system driver.
 *The specific error code is in the data.
 */

#define AFPLOG_INVALID_VOL_REG		(AFP_LOG_BASE+29)
/*
 *The Registry contains invalid information for the volume "%1". 
 *The value was ignored and processing was continued.
 *Change the value for this volume in the
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters\Volumes Registry key.
 *Restart the service if the corrected information is to be used
 *for the volume.
 */

#define AFPLOG_CANT_LOAD_RESOURCE	(AFP_LOG_BASE+30)
/*
 *The File Server for Macintosh service was unable to load resource
 *strings.
 */

#define AFPLOG_INVALID_TYPE_CREATOR	(AFP_LOG_BASE+31)
/*
 *A corrupt Creator/Type pair with creator "%2" and type "%1" was detected
 *in the Registry. This value was ignored and processing was continued.
 *Change the value for this Creator/Type pair in the
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters\Type_Creators Registry key.
 *Restart the service if the corrected information is to be used
 *for the Creator/Type pair.
 */

#define AFPLOG_DOMAIN_INFO_RETRY	(AFP_LOG_BASE+32)
/*
 *The File Server for Macintosh service was unable to contact a domain controler.
 *The service will continue to retry periodically until it succeeds or
 *until the service is manually stopped.
 */

#define AFPLOG_SFM_STARTED_OK	(AFP_LOG_BASE+33)
/*
 *The File Server for Macintosh service started successfully.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\inc\uimsgs.h ===
/********************************************************************/
/**               Copyright(c) 1992 Microsoft Corporation.	       **/
/********************************************************************/
//Jameel: please check all these, especially those that have comments to you.
//***
//
// Filename:	srvmsg.h
//
// Description: Text and corresponding values of AFP Server events are
//              defined here.
//
// History: 	Nov 23,1992.	SueA		Created original version.
//				Jan 28,1993.	SueA		Logging now done from user mode
//											so %1 is no longer \Device\AfpSrv
//


// Don't change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define AFPMACFILE_MSG_BASE					6000

#define AFPMACFILEMSG_InvalidVolumeName		(AFPMACFILE_MSG_BASE+1)
/*
 * The Macintosh-Accessible volume name specified is invalid.
 * Specify a valid volume name without colons.
 */

#define AFPMACFILEMSG_InvalidId		(AFPMACFILE_MSG_BASE+2)
/*
 * A system resource could not be accessed for the current descriptor.
 * Try the operation again.
 */

#define AFPMACFILEMSG_InvalidParms		(AFPMACFILE_MSG_BASE+3)
/*
 * The parameter entered was invalid. 
 * Make the appropriate changes and retry the operation.
 */

#define AFPMACFILEMSG_CodePage		(AFPMACFILE_MSG_BASE+4)
/*
 * Error in accessing Macintosh Code Page.
 * Check if the Code Page file name specified in
 * SYSTEM\CurrentControlSet\Control\Nls\CodePage\MACCP is valid and exists.
 * Stop and restart the service if the code page information is modified.
 */

#define AFPMACFILEMSG_InvalidServerName		(AFPMACFILE_MSG_BASE+5)
/*
 * The server name specified is invalid.
 * Specify a valid server name without colons.
 */

#define AFPMACFILEMSG_DuplicateVolume		(AFPMACFILE_MSG_BASE+6)
/*
 * A volume with this name already exists.
 * Specify another name for the new volume.
 */

#define AFPMACFILEMSG_VolumeBusy		(AFPMACFILE_MSG_BASE+7)
/*
 * The selected Macintosh-Accessible volume is currently in use by Macintoshes.
 * The selected volume may be removed only when no Macintosh workstations are
 * connected to it.
 */

#define AFPMACFILEMSG_VolumeReadOnly		(AFPMACFILE_MSG_BASE+8)
/*
 * Not used
 * An internal error 6008 (VolumeReadOnly) occurred.
 */

#define AFPMACFILEMSG_DirectoryNotInVolume		(AFPMACFILE_MSG_BASE+9)
/*
 * The selected directory does not belong to a Macintosh-Accessible volume.
 * The Macintosh view of directory permissions is only available for
 * directories that are part of a Macintosh-Accessible volume.
 */

#define AFPMACFILEMSG_SecurityNotSupported		(AFPMACFILE_MSG_BASE+10)
/*
 * The Macintosh view of directory permissions is not available for directories
 * on CD-ROM disks.
 */

#define AFPMACFILEMSG_BufferSize		(AFPMACFILE_MSG_BASE+11)
/*
 * Insufficient memory resources to complete the operation.
 * Try the operation again.
 */

#define AFPMACFILEMSG_DuplicateExtension		(AFPMACFILE_MSG_BASE+12)
/*
 * This file extension is already associated with a Creator/Type item.
 */

#define AFPMACFILEMSG_UnsupportedFS		(AFPMACFILE_MSG_BASE+13)
/*
 * File Server for Macintosh service only supports NTFS partitions.
 * Choose a directory on an NTFS partition.
 */

#define AFPMACFILEMSG_InvalidSessionType		(AFPMACFILE_MSG_BASE+14)
/*
 * The message has been sent, but not all of the connected workstations have
 * received it. Some workstations are running an unsupported version of
 * system software.
 */

#define AFPMACFILEMSG_InvalidServerState		(AFPMACFILE_MSG_BASE+15)
/*
 * The File Server is in an invalid state for the operation being performed.
 * Check the status of the File Server for Macintosh service and retry the 
 * operation.
 */

#define AFPMACFILEMSG_NestedVolume		(AFPMACFILE_MSG_BASE+16)
/*
 * Cannot create a Macintosh-Accessible volume within another volume.
 * Choose a directory that is not within a volume.
 */

#define AFPMACFILEMSG_InvalidComputername		(AFPMACFILE_MSG_BASE+17)
/*
 * The target server is not setup to accept Remote Procedure Calls.
 */

#define AFPMACFILEMSG_DuplicateTypeCreator		(AFPMACFILE_MSG_BASE+18)
/*
 * The selected Creator/Type item already exists.
 */

#define AFPMACFILEMSG_TypeCreatorNotExistant		(AFPMACFILE_MSG_BASE+19)
/*
 * The selected Creator/Type item no longer exists.
 * This item may have been deleted by another administrator.
 */

#define AFPMACFILEMSG_CannotDeleteDefaultTC		(AFPMACFILE_MSG_BASE+20)
/*
 * The default Creator/Type item cannot be deleted.
 */

#define AFPMACFILEMSG_CannotEditDefaultTC		(AFPMACFILE_MSG_BASE+21)
/*
 * The default Creator/Type item may not be edited.
 */

#define AFPMACFILEMSG_InvalidTypeCreator		(AFPMACFILE_MSG_BASE+22)
/*
 * The Creator/Type item is invalid and will not be use by the File Server
 * for Macintosh service.
 * The invalid Creator/Type item is in the data.
 */

#define AFPMACFILEMSG_InvalidExtension		(AFPMACFILE_MSG_BASE+23)
/*
 * The file extension is invalid.
 * The invalid file extension is in the data.
 */

#define AFPMACFILEMSG_TooManyEtcMaps		(AFPMACFILE_MSG_BASE+24)
/*
 * Too many Extension/Type Creator mappings than the system can handle.
 * System limit is 2147483647 mappings.
 */

#define AFPMACFILEMSG_InvalidPassword		(AFPMACFILE_MSG_BASE+25)
/*
 * The password specified is invalid.
 * Specify a valid password less than 8 characters.
 */

#define AFPMACFILEMSG_VolumeNonExist		(AFPMACFILE_MSG_BASE+26)
/*
 * The selected Macintosh-Accessible volume no longer exists.
 * Another administrator may have removed the selected volume.
 */

#define AFPMACFILEMSG_NoSuchUserGroup		(AFPMACFILE_MSG_BASE+27)
/*
 * Neither the Owner nor the Primary Group account names are valid.
 * Specify valid account names for the Owner and Primary Group of
 * this directory.
 */

#define AFPMACFILEMSG_NoSuchUser		(AFPMACFILE_MSG_BASE+28)
/*
 * The Owner account name is invalid. 
 * Specify a valid account name or the Owner of this directory.
 */

#define AFPMACFILEMSG_NoSuchGroup		(AFPMACFILE_MSG_BASE+29)
/*
 * The Primary Group account name is invalid. 
 * Specify a valid account name for the Primary Group of this directory.
 */

#define AFPMACFILEMSG_InvalidParms_LoginMsg		(AFPMACFILE_MSG_BASE+30)
/*
 * The Logon Message entered for the File Server for Macintosh was invalid. 
 * Logon Message should not be greater than 199 characters.
 * Make the appropriate changes and retry the operation.
 */

#define AFPMACFILEMSG_InvalidParms_MaxVolUses	(AFPMACFILE_MSG_BASE+31)
/*
 * The User Limit entered for the Share Volume was invalid. 
 * Enter a number between 0 and 4294967295.
 * Make the appropriate changes and retry the operation.
 */

#define AFPMACFILEMSG_InvalidParms_MaxSessions	(AFPMACFILE_MSG_BASE+32)
/*
 * The Sessions Limit field entered for the File Server was invalid. 
 * Enter a number between 0 and 4294967295.
 * Make the appropriate changes and retry the operation.
 */

#define AFPMACFILEMSG_InvalidServerName_Length		(AFPMACFILE_MSG_BASE+33)
/*
 * The server name specified is not of valid length.
 * Specify a server name containing not more than 31 single-byte characters 
 * or not more than 15 double-byte characters.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\messages\makefile.inc ===
$(O)\afpmsg.mc: ..\inc\events.h ..\inc\srvmsg.h
    mapmsg AFP AFP_LOG_BASE ..\inc\events.h > $(O)\afpmsg.mc
    mapmsg -a $(O)\afpmsg.mc AFP AFPSRV_MSG_BASE ..\inc\srvmsg.h
    mapmsg -a $(O)\afpmsg.mc AFP AFPMACFILE_MSG_BASE ..\inc\uimsgs.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\inc\admin.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	admin.h

Abstract:

	This module contains admin interface for server service. All data
	strucutures anc constants shared between the AFP service and the
	AFP server service will be contained in this file.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr  1992 JameelH	Initial Version
	2  Sept 1992 NarenG		Added structure to pass security information
							between the service and the server.
	1  Feb  1993 SueA		Added structure to pass evenlog infomation
							from the server to the service.
--*/

#ifndef _ADMIN_
#define _ADMIN_

#include <lmcons.h>		// Need DNLEN and LM20_UNLEN
#include <crypt.h>		// Need LM_OWF_PASSWORD_LENGTH

#define	AFP_API_BASE	1000

#define AFP_CC(_request_, _Method_)		CTL_CODE(FILE_DEVICE_NETWORK, \
							_request_ + AFP_API_BASE,				  \
							_Method_, FILE_ANY_ACCESS)
		
#define	AFP_CC_BASE(ControlCode)	((((ControlCode) >> 2) - AFP_API_BASE) & 0xFF)
#define	AFP_CC_METHOD(ControlCode)	((ControlCode) & 0x03)
		
// Do not change this table without also changing the table in SERVER\FSD.C
#define	CC_BASE_SERVICE_START				0x01
#define	CC_BASE_SERVICE_STOP				0x02
#define	CC_BASE_SERVICE_PAUSE				0x03
#define	CC_BASE_SERVICE_CONTINUE			0x04
#define	CC_BASE_GET_STATISTICS				0x05
#define	CC_BASE_GET_STATISTICS_EX			0x06
#define	CC_BASE_CLEAR_STATISTICS			0x07
#define	CC_BASE_GET_PROF_COUNTERS			0x08
#define	CC_BASE_CLEAR_PROF_COUNTERS			0x09
#define	CC_BASE_SERVER_ADD_SID_OFFSETS		0x0A
#define	CC_BASE_SERVER_GET_INFO				0x0B
#define	CC_BASE_SERVER_SET_INFO				0x0C
#define	CC_BASE_SERVER_ADD_ETC				0x0D
#define	CC_BASE_SERVER_SET_ETC				0x0E
#define	CC_BASE_SERVER_DELETE_ETC			0x0F
#define	CC_BASE_SERVER_ADD_ICON				0x10
#define	CC_BASE_VOLUME_ADD					0x11
#define	CC_BASE_VOLUME_DELETE				0x12
#define CC_BASE_VOLUME_GET_INFO				0x13
#define	CC_BASE_VOLUME_SET_INFO				0x14
#define	CC_BASE_VOLUME_ENUM					0x15
#define	CC_BASE_SESSION_ENUM				0x16
#define	CC_BASE_SESSION_CLOSE				0x17
#define	CC_BASE_CONNECTION_ENUM				0x18
#define	CC_BASE_CONNECTION_CLOSE			0x19
#define	CC_BASE_DIRECTORY_GET_INFO			0x1A
#define	CC_BASE_DIRECTORY_SET_INFO			0x1B
#define	CC_BASE_FORK_ENUM					0x1C
#define	CC_BASE_FORK_CLOSE					0x1D
#define	CC_BASE_MESSAGE_SEND				0x1E
#define CC_BASE_FINDER_SET					0x1F
#define	CC_BASE_GET_FSD_COMMAND				0x20
#define	CC_BASE_MAX							0x21


#define OP_SERVICE_START			AFP_CC(CC_BASE_SERVICE_START, METHOD_BUFFERED)
#define OP_SERVICE_STOP				AFP_CC(CC_BASE_SERVICE_STOP, METHOD_BUFFERED)
#define OP_SERVICE_PAUSE			AFP_CC(CC_BASE_SERVICE_PAUSE, METHOD_BUFFERED)
#define OP_SERVICE_CONTINUE			AFP_CC(CC_BASE_SERVICE_CONTINUE,METHOD_BUFFERED)
#define OP_GET_STATISTICS			AFP_CC(CC_BASE_GET_STATISTICS,METHOD_IN_DIRECT)
#define OP_GET_STATISTICS_EX		AFP_CC(CC_BASE_GET_STATISTICS_EX,METHOD_IN_DIRECT)
#define OP_CLEAR_STATISTICS			AFP_CC(CC_BASE_CLEAR_STATISTICS,METHOD_BUFFERED)
#define OP_GET_PROF_COUNTERS		AFP_CC(CC_BASE_GET_PROF_COUNTERS,METHOD_IN_DIRECT)
#define OP_CLEAR_PROF_COUNTERS		AFP_CC(CC_BASE_CLEAR_PROF_COUNTERS,METHOD_BUFFERED)
#define OP_SERVER_ADD_SID_OFFSETS	AFP_CC(CC_BASE_SERVER_ADD_SID_OFFSETS,METHOD_BUFFERED)
#define OP_SERVER_GET_INFO			AFP_CC(CC_BASE_SERVER_GET_INFO,METHOD_IN_DIRECT)
#define OP_SERVER_SET_INFO			AFP_CC(CC_BASE_SERVER_SET_INFO,METHOD_BUFFERED)
#define OP_SERVER_ADD_ETC			AFP_CC(CC_BASE_SERVER_ADD_ETC,METHOD_BUFFERED)
#define OP_SERVER_SET_ETC			AFP_CC(CC_BASE_SERVER_SET_ETC,METHOD_BUFFERED)
#define OP_SERVER_DELETE_ETC		AFP_CC(CC_BASE_SERVER_DELETE_ETC,METHOD_BUFFERED)
#define	OP_SERVER_ADD_ICON			AFP_CC(CC_BASE_SERVER_ADD_ICON,METHOD_BUFFERED)
#define OP_VOLUME_ADD				AFP_CC(CC_BASE_VOLUME_ADD,METHOD_BUFFERED)
#define OP_VOLUME_DELETE			AFP_CC(CC_BASE_VOLUME_DELETE,METHOD_BUFFERED)
#define OP_VOLUME_GET_INFO			AFP_CC(CC_BASE_VOLUME_GET_INFO,METHOD_IN_DIRECT)
#define OP_VOLUME_SET_INFO			AFP_CC(CC_BASE_VOLUME_SET_INFO,METHOD_BUFFERED)
#define OP_VOLUME_ENUM				AFP_CC(CC_BASE_VOLUME_ENUM,METHOD_IN_DIRECT)
#define OP_SESSION_ENUM				AFP_CC(CC_BASE_SESSION_ENUM,METHOD_IN_DIRECT)
#define OP_SESSION_CLOSE			AFP_CC(CC_BASE_SESSION_CLOSE,METHOD_BUFFERED)
#define OP_CONNECTION_ENUM			AFP_CC(CC_BASE_CONNECTION_ENUM,METHOD_IN_DIRECT)
#define OP_CONNECTION_CLOSE			AFP_CC(CC_BASE_CONNECTION_CLOSE,METHOD_BUFFERED)
#define OP_DIRECTORY_GET_INFO		AFP_CC(CC_BASE_DIRECTORY_GET_INFO,METHOD_IN_DIRECT)
#define OP_DIRECTORY_SET_INFO		AFP_CC(CC_BASE_DIRECTORY_SET_INFO,METHOD_BUFFERED)
#define OP_FORK_ENUM				AFP_CC(CC_BASE_FORK_ENUM,METHOD_IN_DIRECT)
#define OP_FORK_CLOSE				AFP_CC(CC_BASE_FORK_CLOSE,METHOD_BUFFERED)
#define OP_MESSAGE_SEND				AFP_CC(CC_BASE_MESSAGE_SEND,METHOD_BUFFERED)
#define OP_FINDER_SET				AFP_CC(CC_BASE_FINDER_SET,METHOD_BUFFERED)
#define OP_GET_FSD_COMMAND			AFP_CC(CC_BASE_GET_FSD_COMMAND,METHOD_BUFFERED)

#define POINTER_TO_OFFSET(val,start)			   \
	(val) = ((val) == NULL) ? NULL : (PVOID)( (PCHAR)(val) - (ULONG_PTR)(start) )

#define OFFSET_TO_POINTER(val,start)			   \
	(val) = ((val) == NULL) ? NULL : (PVOID)( (PCHAR)(val) + (ULONG_PTR)(start) )

#define	AFPSERVER_DEVICE_NAME		TEXT("\\Device\\MacFile")
#define	AFPSERVER_REGISTRY_KEY		TEXT("\\Registry\\Machine\\System\\CurrentControlSet\\Services\\MacSrv")
#define	AFPSERVER_VOLUME_ICON_FILE	{ L'I', L'C', L'O', L'N', 0xF00D, 0000 }

// Number of wchars in above string, including terminating null
#define AFPSERVER_VOLUME_ICON_FILE_SIZE 6
#define AFPSERVER_RESOURCE_STREAM	L":AFP_Resource"

// The following data structures are used exclusively by the
// user-mode/kernel-mode interface.

typedef enum _AFP_SID_TYPE
{
	AFP_SID_TYPE_DOMAIN,
	AFP_SID_TYPE_PRIMARY_DOMAIN,
	AFP_SID_TYPE_WELL_KNOWN,
	AFP_SID_TYPE_LOGON

} AFP_SID_TYPE;

typedef struct _AFP_SID_OFFSET
{
	DWORD 				Offset;
	AFP_SID_TYPE		SidType;
	PBYTE 				pSid;			// Actually an Offset from the
										// beginning of this structure.
} AFP_SID_OFFSET, *PAFP_SID_OFFSET;

// Packet used to add the SID/OFFSET pairs
typedef struct _AFP_SID_OFFSET_DESC
{
	ULONG 				CountOfSidOffsets;	// Number of Sid-Offset pairs
	ULONG				QuadAlignDummy1;
	AFP_SID_OFFSET		SidOffsetPairs[1];
}AFP_SID_OFFSET_DESC, *PAFP_SID_OFFSET_DESC;

// Packet used by ServerEtcSet and ServerEtcDelete.
typedef struct _EtcMapInfo2
{
	UCHAR   etc_type[AFP_TYPE_LEN];
	UCHAR   etc_creator[AFP_CREATOR_LEN];
	WCHAR   etc_extension[AFP_EXTENSION_LEN+1];

} ETCMAPINFO2, *PETCMAPINFO2;

// once passed by Service, this is used by Server internally
typedef struct _EtcMapInfo
{
	UCHAR   etc_type[AFP_TYPE_LEN];
	UCHAR   etc_creator[AFP_CREATOR_LEN];
	UCHAR   etc_extension[AFP_EXTENSION_LEN+1];   // extension in ANSI

} ETCMAPINFO, *PETCMAPINFO;

typedef struct _SrvIconInfo
{
	UCHAR	icon_type[AFP_TYPE_LEN];		
	UCHAR	icon_creator[AFP_CREATOR_LEN];
	DWORD	icon_icontype;					
	DWORD	icon_length;					

	// Icon data follows
} SRVICONINFO, *PSRVICONINFO;

// Packet used by ServerEtcAdd.
typedef struct _ServerEtcPacket
{
	DWORD		retc_NumEtcMaps;	// Number of type creator mappings
	ETCMAPINFO2	retc_EtcMaps[1];	// List of Etc mappings

} SRVETCPKT, *PSRVETCPKT;


// The following is the generic enumerate request packet.
typedef struct _EnumRequestPacket
{
	DWORD	erqp_Index;				// Starting index from which the
						 			// enum should start. 0 => beginning
	DWORD   erqp_Filter;			// AFP_FILTER_ON_VOLUME_ID
									// or AFP_FILTER_ON_SESSION_ID
	DWORD   erqp_ID;				// Volume ID or sessions ID.

	DWORD   QuadAlignDummy;         // Quad Word Alignment enforcement

} ENUMREQPKT, *PENUMREQPKT;


// The following is the generic enumerate response packet.

typedef struct _EnumResponsePacket
{
	DWORD	ersp_cTotEnts;			// Total number of available entries
	DWORD	ersp_cInBuf;			// Number of entries in buffer union
	DWORD	ersp_hResume;			// Index of the first entry that will be
									// read on the subsequent call. Valid only
									// if the return code is AFPERR_MORE_DATA.

	DWORD   QuadAlignDummy;         // Quad Word Alignment enforcement

	// Will contain an array of AFP_FILE_INFO, AFP_SESSION_INFO,
	// AFP_CONNECTION_INFO or AFP_VOLUME_INFO structures.
} ENUMRESPPKT, *PENUMRESPPKT;

// The following is the generic set info. request packet.
typedef struct _SetInfoRequestPacket
{
	DWORD	sirqp_parmnum;			// Mask of bits representing fields
    DWORD   dwAlignDummy;           // For QWORD alignment

	// Will be followed by AFP_VOLUME_INFO or AFP_DIRECTORY_INFO structure
} SETINFOREQPKT, *PSETINFOREQPKT;

// The following data structures are used to send security information
// from the service down to the server; or to send eventlog information from
// the server up to the service.

#define MAX_FSD_CMD_SIZE				4096
#define NUM_SECURITY_UTILITY_THREADS	4

typedef enum _AFP_FSD_CMD_ID
{
	AFP_FSD_CMD_NAME_TO_SID,
	AFP_FSD_CMD_SID_TO_NAME,
	AFP_FSD_CMD_CHANGE_PASSWORD,
	AFP_FSD_CMD_LOG_EVENT,
	AFP_FSD_CMD_TERMINATE_THREAD
} AFP_FSD_CMD_ID;


// These used to live in afpconst.h, but now the service needs some of these
// to do the native AppleUam stuff
//
// UAMs strings and values
#define AFP_NUM_UAMS                6
#define NO_USER_AUTHENT             0
#define NO_USER_AUTHENT_NAME        "No User Authent"
#define CLEAR_TEXT_AUTHENT          1
#define CLEAR_TEXT_AUTHENT_NAME     "ClearTxt Passwrd"
#define CUSTOM_UAM_V1               2
#define CUSTOM_UAM_NAME_V1          "Microsoft V1.0"
#define CUSTOM_UAM_V2               3
#define CUSTOM_UAM_NAME_V2          "MS2.0"
#define RANDNUM_EXCHANGE            4
#define RANDNUM_EXCHANGE_NAME       "Randnum Exchange"
#define TWOWAY_EXCHANGE             5
#define TWOWAY_EXCHANGE_NAME        "2-Way Randnum exchange"

// how many bytes of response comes back
#define RANDNUM_RESP_LEN            8
#define TWOWAY_RESP_LEN             16

// this define stolen from ntsam.h
#define SAM_MAX_PASSWORD_LENGTH     (256)

typedef struct _AFP_PASSWORD_DESC
{
	BYTE    	AuthentMode;
	BYTE 		bPasswordLength;
	WCHAR		DomainName[DNLEN+1];
	WCHAR		UserName[LM20_UNLEN+1];
	BYTE		OldPassword[LM_OWF_PASSWORD_LENGTH+1];
	BYTE		NewPassword[(SAM_MAX_PASSWORD_LENGTH * 2) + 4];
} AFP_PASSWORD_DESC, *PAFP_PASSWORD_DESC;

typedef struct _AFP_EVENTLOG_DESC
{
	DWORD					MsgID;
	USHORT					EventType;
	USHORT					StringCount;
	DWORD					DumpDataLen;
	DWORD                   QuadAlignDummy; // Quad Word Alignment enforcement
	PVOID					pDumpData;
	LPWSTR *				ppStrings;
	// Pointer to an array of string pointers that will follow the DumpData.
} AFP_EVENTLOG_DESC, *PAFP_EVENTLOG_DESC;

typedef struct _AFP_FSD_CMD_HEADER
{
	AFP_FSD_CMD_ID			FsdCommand;
	ULONG 					ntStatus;
	DWORD 					dwId;
	DWORD                   QuadAlignDummy; // Quad Word Alignment enforcement
} AFP_FSD_CMD_HEADER, *PAFP_FSD_CMD_HEADER;

typedef struct _AFP_FSD_CMD_PKT
{
	AFP_FSD_CMD_HEADER			Header;

	union
	{
		BYTE				Sid[1];
		BYTE 				Name[1];
		AFP_PASSWORD_DESC   Password;
		AFP_EVENTLOG_DESC	Eventlog;
	} Data;
} AFP_FSD_CMD_PKT, *PAFP_FSD_CMD_PKT;


// The following definitions and macros are used both by the service as well as the
// server. DO NOT CHANGE THIS w/o LOOKING at both the uses.

// Directory Access Permissions
#define	DIR_ACCESS_SEARCH			0x01	// See Folders
#define	DIR_ACCESS_READ				0x02	// See Files
#define	DIR_ACCESS_WRITE			0x04	// Make Changes
#define	DIR_ACCESS_OWNER			0x80	// Only for user
											// if he has owner rights

#define	DIR_ACCESS_ALL				(DIR_ACCESS_READ	| \
									 DIR_ACCESS_SEARCH	| \
									 DIR_ACCESS_WRITE)

#define	OWNER_RIGHTS_SHIFT			0
#define	GROUP_RIGHTS_SHIFT			8
#define	WORLD_RIGHTS_SHIFT			16
#define	USER_RIGHTS_SHIFT			24

#define	AFP_READ_ACCESS		(READ_CONTROL		 |	\
							FILE_READ_ATTRIBUTES |	\
							FILE_TRAVERSE		 |	\
							FILE_LIST_DIRECTORY	 |	\
							FILE_READ_EA)

#define	AFP_WRITE_ACCESS	(FILE_ADD_FILE		 |	\
							FILE_ADD_SUBDIRECTORY|	\
							FILE_WRITE_ATTRIBUTES|	\
							FILE_WRITE_EA		 |	\
							DELETE)

#define	AFP_OWNER_ACCESS	(WRITE_DAC			  | \
							 WRITE_OWNER)

#define	AFP_MIN_ACCESS		(FILE_READ_ATTRIBUTES | \
							 READ_CONTROL)

#define	AfpAccessMaskToAfpPermissions(Rights, Mask, Type)					\
				if ((Type) == ACCESS_ALLOWED_ACE_TYPE)						\
				{															\
					if (((Mask) & AFP_READ_ACCESS) == AFP_READ_ACCESS)		\
						 (Rights) |= (DIR_ACCESS_READ | DIR_ACCESS_SEARCH);	\
					if (((Mask) & AFP_WRITE_ACCESS) == AFP_WRITE_ACCESS)	\
						(Rights) |= DIR_ACCESS_WRITE;						\
				}															\
				else														\
				{															\
					ASSERT((Type) == ACCESS_DENIED_ACE_TYPE);				\
					if ((Mask) & AFP_READ_ACCESS)							\
						(Rights) &= ~(DIR_ACCESS_READ | DIR_ACCESS_SEARCH); \
					if ((Mask) & AFP_WRITE_ACCESS)							\
						(Rights) &= ~DIR_ACCESS_WRITE;						\
				}

#endif	// _ADMIN_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\messages\dummy.c ===
void
DummyEntryPoint(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\inc\srvmsg.h ===
/********************************************************************/
/**               Copyright(c) 1992 Microsoft Corporation.	       **/
/********************************************************************/
//Jameel: please check all these, especially those that have comments to you.
//***
//
// Filename:	srvmsg.h
//
// Description: Text and corresponding values of AFP Server events are
//              defined here.
//
// History: 	Nov 23,1992.	SueA		Created original version.
//				Jan 28,1993.	SueA		Logging now done from user mode
//											so %1 is no longer \Device\AfpSrv
//


// Don't change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define AFPSRV_MSG_BASE					12000

#define AFPSRVMSG_DELETE_NWTRASH		(AFPSRV_MSG_BASE+1)
/*
 * Unable to delete the directory "Network Trash Folder" from volume "%1".
 */

#define AFPSRVMSG_CREATE_NWTRASH		(AFPSRV_MSG_BASE+2)
/*
 * Unable to create the directory "Network Trash Folder" on volume "%1".
 */

#define AFPSRVMSG_CANT_READ				(AFPSRV_MSG_BASE+3)
/*
 * Unable to read internal server information from file "%1".
 */

#define AFPSRVMSG_CANT_WRITE			(AFPSRV_MSG_BASE+4)
/*
 * Unable to write internal server information to file "%1".
 */

#define AFPSRVMSG_CANT_LOCK				(AFPSRV_MSG_BASE+5)
/*
 * Not used.
 * Unable to lock a range of bytes for "%1".
 */

#define AFPSRVMSG_CANT_UNLOCK			(AFPSRV_MSG_BASE+6)
/*
 * Unable to unlock a range of bytes for "%1".
 */

#define AFPSRVMSG_CANT_GET_FILESIZE		(AFPSRV_MSG_BASE+7)
/*
 * Unable to query the file size for "%1".
 */

#define AFPSRVMSG_CANT_SET_FILESIZE		(AFPSRV_MSG_BASE+8)
/*
 * Unable to set the file size for "%1".
 */

#define AFPSRVMSG_CANT_GET_TIMESNATTR	(AFPSRV_MSG_BASE+9)
/*
 * Unable to query time/date information for "%1".
 */

#define AFPSRVMSG_CANT_SET_TIMESNATTR	(AFPSRV_MSG_BASE+10)
/*
 * Unable to set time/date information for "%1".
 */

#define AFPSRVMSG_CANT_GET_STREAMS		(AFPSRV_MSG_BASE+11)
/*
 * Unable to query alternate data stream names for "%1".
 */

#define AFPSRVMSG_CANT_GET_FILENAME		(AFPSRV_MSG_BASE+12)
/*
 * Unable to query the short (MS-DOS compatible) filename for "%1".
 */

#define AFPSRVMSG_CANT_GET_ACCESS_INFO	(AFPSRV_MSG_BASE+13)
/*
 * Not used.
 * Unable to obtain security information.
 */

#define AFPSRVMSG_CANT_GET_FSNAME		(AFPSRV_MSG_BASE+16)
/*
 * Unable to query the file system type for directory "%1".
 */

#define AFPSRVMSG_READ_DESKTOP			(AFPSRV_MSG_BASE+17)
/*
 * Desktop database for volume "%1" could not be loaded. Reconstructing the database.
 */

#define AFPSRVMSG_MSV1_0				(AFPSRV_MSG_BASE+18)
/*
 * Not used.
 * Unable to load the MSV1_0 authentication package.
 */

#define AFPSRVMSG_MAC_CODEPAGE			(AFPSRV_MSG_BASE+19)
/*
 * Unable to load the Macintosh character set.
 */

#define AFPSRVMSG_REGISTER_NAME			(AFPSRV_MSG_BASE+20)
/*
 * Unable to register the server name with the network. Make sure no other server is using this name.
 */

#define AFPSRVMSG_POST_REQUEST			(AFPSRV_MSG_BASE+21)
/*
 * Not used.
 * An error occurred on the network.
 */

#define AFPSRVMSG_DFRD_REQUEST			(AFPSRV_MSG_BASE+22)
/*
 * Unable to process requests due to insufficient resources.
 */

#define AFPSRVMSG_SEND_ATTENTION		(AFPSRV_MSG_BASE+23)
/*
 * Unable to send attention to a connected user.
 */

#define AFPSRVMSG_ALLOC_IRP				(AFPSRV_MSG_BASE+24)
/*
 * Unable to allocate a system resource (IRP).
 * System may be low on memory.
 */

#define AFPSRVMSG_ALLOC_MDL				(AFPSRV_MSG_BASE+25)
/*
 * Unable to allocate a system resouces (Memory Descriptor List - MDL).
 * System may be low on memory.
 */

#define AFPSRVMSG_WAIT4SINGLE			(AFPSRV_MSG_BASE+26)
/*
 * An internal error occurred.
 * Error occured while waiting on single object to change state.
 */

#define AFPSRVMSG_CREATE_THREAD			(AFPSRV_MSG_BASE+27)
/*
 * Unable to create a new thread.
 */

#define AFPSRVMSG_CREATE_PROCESS		(AFPSRV_MSG_BASE+28)
/*
 * Not used.
 * Unable to create a process.
 */

#define AFPSRVMSG_ENUMERATE				(AFPSRV_MSG_BASE+29)
/*
 * Unable to query contents of directory "%1".
 */

#define AFPSRVMSG_CREATE_ATKADDR		(AFPSRV_MSG_BASE+30)
/*
 * Error in creating File object for current Appletalk address.
 */

#define AFPSRVMSG_CREATE_ATKCONN		(AFPSRV_MSG_BASE+31)
/*
 * Not used.
 * An error occured on the network.
 */

#define AFPSRVMSG_ASSOC_ADDR			(AFPSRV_MSG_BASE+32)
/*
 * Not used.
 * An error occurred on the network.
 */

#define AFPSRVMSG_SET_STATUS			(AFPSRV_MSG_BASE+33)
/*
 * An error occured while setting the File Server status block during initialization. The File Server was not started.
 */

 #define AFPSRVMSG_GET_SESSION			(AFPSRV_MSG_BASE+34)
/*
 * Not used.
 * An error occurred on the network.
 */

#define AFPSRVMSG_INIT_IDDB				(AFPSRV_MSG_BASE+35)
/*
 * Volume %1 is being reindexed.
 * The volume will be available for use after indexing is over.
 */

#define AFPSRVMSG_PROCESS_TOKEN			(AFPSRV_MSG_BASE+36)
/*
 * An error occured while creating the system-level process token during
 * the File Server driver initialization.
 * The File Server could not be started.
 */

#define AFPSRVMSG_LSA					(AFPSRV_MSG_BASE+37)
/*
 * Not used.
 * Unable to register with the Local Security Authority.
 */

#define AFPSRVMSG_CREATE_DEVICE			(AFPSRV_MSG_BASE+38)
/*
 * Not used.
 * Unable to create a device object.
 */

#define AFPSRVMSG_USER_GROUPS			(AFPSRV_MSG_BASE+39)
/*
 * Unable to query group membership for the user.
 */

#define AFPSRVMSG_MACANSI2UNICODE		(AFPSRV_MSG_BASE+40)
/*
 * Unable to translate Macintosh used ANSI characters into Unicode characters.
 * The specfic error is in the data.
 */

#define AFPSRVMSG_UNICODE2MACANSI		(AFPSRV_MSG_BASE+41)
/*
 * Unable to translate Unicode characters into Macintosh used ANSI characters.
 * The specfic error is in the data.
 */

#define AFPSRVMSG_AFPINFO				(AFPSRV_MSG_BASE+42)
/*
 * Internal server information for file "%1" was corrupted. Setting default information.
 */

#define AFPSRVMSG_WRITE_DESKTOP			(AFPSRV_MSG_BASE+43)
/*
 * Unable to update the Desktop database for volume "%1". There may not be enough disk space.
 */

#define AFPSRVMSG_IMPERSONATE			(AFPSRV_MSG_BASE+44)
/*
 * Not used.
 * Unable to impersonate a client.
 */

#define AFPSRVMSG_REVERTBACK			(AFPSRV_MSG_BASE+45)
/*
 * Not used.
 * Unable to revert from impersonating a client.
 */

#define AFPSRVMSG_PAGED_POOL			(AFPSRV_MSG_BASE+46)
/*
 * Unable to allocate paged memory resource.
 */

#define AFPSRVMSG_NONPAGED_POOL			(AFPSRV_MSG_BASE+47)
/*
 * Unable to allocate nonpaged memory resources.
 */

#define AFPSRVMSG_LSA_CHALLENGE			(AFPSRV_MSG_BASE+48)
/*
 * Not used.
 * Unable to authenticate user.
 */

#define AFPSRVMSG_LOGON					(AFPSRV_MSG_BASE+49)
/*
 * Unable to logon user "%1".
 */

#define AFPSRVMSG_MAX_DIRID				(AFPSRV_MSG_BASE+50)
/*
 * The maximum directory ID has been reached on volume "%1". No more files or directories can be created on this volume.
 */

#define AFPSRVMSG_WRITE_IDDB			(AFPSRV_MSG_BASE+51)
/*
 * Unable to update the index database for the Macintosh-Accessible volume "%1". There may not be enough disk space.
 */

#define AFPSRVMSG_MISSED_NOTIFY			(AFPSRV_MSG_BASE+52)
/*
 * A directory change notification was missed on volume "%1".
 */

#define AFPSRVMSG_DISCONNECT			(AFPSRV_MSG_BASE+53)
/*
 * Session from user "%2" was timed out and disconnected by the server.
 * The AppleTalk address of the Macintosh workstation is in the data.
 */

#define AFPSRVMSG_DISCONNECT_GUEST			(AFPSRV_MSG_BASE+54)
/*
 * Guest session was timed out and disconnected by the server.
 * The AppleTalk address of the Macintosh workstation is in the data.
 */

#define AFPSRVMSG_UPONMP			(AFPSRV_MSG_BASE+55)
/*
 * Not used.
 * A uniprocessor driver was loaded on a multiprocessor system. 
 * The driver could not load.
 */

#define AFPSRVMSG_UPDATE_DESKTOP_VERSION			(AFPSRV_MSG_BASE+56)
/*
 * Updating the Desktop database version for volume "%1".
 */

#define AFPSRVMSG_TOO_MANY_FOLDERS      (AFPSRV_MSG_BASE+57)
/*
 * Number of files and folders in volume "%1" is greater than 65535.
 * Older Macintosh clients may not function correctly in this situation due
 * to Macintosh volume limitation.
 */

#define AFPSRVMSG_START_VOLUME          (AFPSRV_MSG_BASE+58)
/*
 * Unable to activate the volume "%1"
 */

#define AFPSRVMSG_VOLUME_INIT_FAILED    (AFPSRV_MSG_BASE+59)
/*
 * Unable to activate volume "%1".  The available non-paged memory in the system * is not adequate to handle the large number of folders within this volume.  
 * Reducing the number of folders can help.
 */

#define AFPSRVMSG_VIRTMEM_ALLOC_FAILED    (AFPSRV_MSG_BASE+60)
/*
 * Unable to allocate virtual memory.  
 * Reducing the number of folders can help.
 */

#define AFPSRVMSG_DISCONNECT_TCPIP			(AFPSRV_MSG_BASE+61)
/*
 * Session from user "%2" was timed out and disconnected by the server.
 * The IP address of the Macintosh workstation is in the data.
 */

#define AFPSRVMSG_DISCONNECT_GUEST_TCPIP			(AFPSRV_MSG_BASE+62)
/*
 * Guest session was timed out and disconnected by the server.
 * The IP address of the Macintosh workstation is in the data.
 */
#define AFPSRVMSG_UPDATE_INDEX_VERSION      (AFPSRV_MSG_BASE+63)
/*
 * Index database for volume %1 is being updated because the server detected an older
 * version.  The volume will be visible on the network after indexing is complete.  For
 * very large volumes, this can take several minutes.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\access.c ===
//depot/Lab02_N/Net/sfm/afp/server/access.c#2 - edit change 2054 (text)
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	access.c

Abstract:

	This module contains the routines for handling access related stuff.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	20 Sep 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_ACCESS

#include <afp.h>
#include <fdparm.h>
#include <pathmap.h>
#define	_ACCESS_LOCALS
#include <access.h>
#include <client.h>
#include <secutil.h>
#include <seposix.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, afpIsUserMemberOfGroup)
#pragma alloc_text( PAGE, AfpGetUserAndPrimaryGroupSids)
#pragma alloc_text( PAGE, AfpMakeSecurityDescriptorForUser)
#pragma alloc_text( PAGE, AfpGetAfpPermissions)
#pragma alloc_text( PAGE, afpMoveAces)
#pragma alloc_text( PAGE, AfpSetAfpPermissions)
#pragma alloc_text( PAGE, afpPermissions2NtMask)
#pragma alloc_text( PAGE, afpAddAceToAcl)
#if DBG
#pragma alloc_text( PAGE, AfpDumpSid)
#pragma alloc_text( PAGE, AfpDumpSidnMask)
#endif
#endif

/***	afpIsUserMemberOfGroup
 *
 *	Determine if the User is member of the given group, if it is a group.
 */
LOCAL	BOOLEAN
afpIsUserMemberOfGroup(
	IN	PTOKEN_GROUPS	pGroups,
	IN	PSID			pSidGroup
)
{
	DWORD			i;
	BOOLEAN			IsAMember = False;

	PAGED_CODE( );

	ASSERT ((pGroups != NULL) && (pSidGroup != NULL));

	AfpDumpSid("afpIsUserMemberOfGroup: Checking", pSidGroup);
	DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
			("afpIsUserMemberOfGroup: # of groups is %d\n", pGroups->GroupCount));
	for (i = 0; i < pGroups->GroupCount; i++)
	{
		AfpDumpSid("afpIsUserMemberOfGroup: Checking with", pGroups->Groups[i].Sid);
		if (RtlEqualSid(pSidGroup, pGroups->Groups[i].Sid))
		{
			IsAMember = True;
			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("afpIsUserMemberOfGroup: Yes !!\n"));
			break;
		}
	}

	return IsAMember;
}


/***	AfpGetUserAndPrimaryGroupSids
 *
 *	Get the Sids corres. to the user and his primary group.
 */
NTSTATUS
AfpGetUserAndPrimaryGroupSids(
	IN	PSDA	pSda
)
{
	DWORD				i, j;
	NTSTATUS			Status = STATUS_SUCCESS;
	DWORD				SidLength, SizeNeeded, ExtraSpace, Offset;
	PSID_AND_ATTRIBUTES	pSidnAttr;
	PTOKEN_GROUPS		pGroups;
	BYTE				GrpsBuffer[1024];
	BYTE				Buffer[256];		// We should not need a buffer larger
											// than this for User SID_AND_ATTRIBUTES

	PAGED_CODE( );

	do
	{
		pGroups = (PTOKEN_GROUPS)GrpsBuffer;
		pSda->sda_pGroups = NULL;
		if (pSda->sda_ClientType == SDA_CLIENT_GUEST)
		{
			pSda->sda_UserSid = &AfpSidWorld;
			pSda->sda_GroupSid = &AfpSidWorld;	// Primary group of Guest is also 'World'
			break;
		}

		pSidnAttr = (PSID_AND_ATTRIBUTES)Buffer;

		// Get the Owner Sid out of the User token and copy it into the Sda
		Status = NtQueryInformationToken(pSda->sda_UserToken,
										 TokenOwner,
										 pSidnAttr,
										 sizeof(Buffer),
										 &SizeNeeded);

		ASSERT (NT_SUCCESS(Status));
		if (!NT_SUCCESS(Status))
		{
			break;
		}

		AfpDumpSid("AfpGetUserAndPrimaryGroupSids: LOGON Owner Sid", pSidnAttr->Sid);

		SidLength = RtlLengthSid(pSidnAttr->Sid);

		pSda->sda_UserSid = (PSID)ALLOC_ACCESS_MEM(SidLength);
		if (pSda->sda_UserSid == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}
		RtlCopyMemory(pSda->sda_UserSid, pSidnAttr->Sid, SidLength);

		// Get the primary group of this user
		Status = NtQueryInformationToken(pSda->sda_UserToken,
										 TokenPrimaryGroup,
										 pSidnAttr,
										 sizeof(Buffer),
										 &SizeNeeded);

		ASSERT (NT_SUCCESS(Status));
		if (!NT_SUCCESS(Status))
		{
			break;
		}

		AfpDumpSid("AfpGetUserAndPrimaryGroupSids: LOGON Group Sid", pSidnAttr->Sid);

		SidLength = RtlLengthSid(pSidnAttr->Sid);
		pSda->sda_GroupSid = (PSID)ALLOC_ACCESS_MEM(SidLength);
		if (pSda->sda_GroupSid == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}
		RtlCopyMemory(pSda->sda_GroupSid, pSidnAttr->Sid, SidLength);

		// Get the User Sid out of the User token. This will be added to the
		// list of groups that we query later, if this is different from
		// the Owner Sid (which is now in sda_UserSid).
		Status = NtQueryInformationToken(pSda->sda_UserToken,
										 TokenUser,
										 pSidnAttr,
										 sizeof(Buffer),
										 &SizeNeeded);

		ASSERT (NT_SUCCESS(Status));
		if (!NT_SUCCESS(Status))
		{
			break;
		}

		AfpDumpSid("AfpGetUserAndPrimaryGroupSids: LOGON User Sid", pSidnAttr->Sid);

		// Get the list of groups this user is member of
		SizeNeeded = sizeof(GrpsBuffer);
		do
		{
			if (Status != STATUS_SUCCESS)
			{
				if (pGroups != (PTOKEN_GROUPS)GrpsBuffer)
					AfpFreeMemory(pGroups);

				if ((pGroups = (PTOKEN_GROUPS)ALLOC_ACCESS_MEM(SizeNeeded)) == NULL)
				{
					Status = AFP_ERR_MISC;
					if (pSda->sda_ClientType == SDA_CLIENT_ADMIN)
					{
						Status = STATUS_INSUFFICIENT_RESOURCES;
					}
					break;
				}
			}
			Status = NtQueryInformationToken(pSda->sda_UserToken,
											 TokenGroups,
											 pGroups,
											 SizeNeeded,
											 &SizeNeeded);
		} while ((Status != STATUS_SUCCESS) &&
				 ((Status == STATUS_BUFFER_TOO_SMALL)	||
				  (Status == STATUS_BUFFER_OVERFLOW)	||
				  (Status == STATUS_MORE_ENTRIES)));

		if (!NT_SUCCESS(Status))
		{
			AFPLOG_ERROR(AFPSRVMSG_USER_GROUPS, Status, NULL, 0, NULL);
			break;
		}

		// Allocate enough memory to copy the group information in the sda. If
		// the User and Owner Sids in the user token are not the same then we
		// want to add the user sid to the list of groups. This is especially
		// the case where an ADMIN logs on but his Owner Sid is Administrators.
		// Also fix up the pointers appropriately !!!

		ExtraSpace = 0; Offset = 0; j = 0;
		if (!RtlEqualSid(pSidnAttr->Sid, pSda->sda_UserSid))
		{
			ExtraSpace = (RtlLengthSid(pSidnAttr->Sid) + sizeof(pSidnAttr->Attributes));
			Offset = sizeof(SID_AND_ATTRIBUTES);
			j = 1;
		}

		if ((pSda->sda_pGroups = (PTOKEN_GROUPS)AfpAllocPagedMemory(2*SizeNeeded+2*ExtraSpace)) == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		// If we are not copying the User Sid in sda_pGroups, then copy pGroups to sda_pGroups
		// directly and then fixup the individual pSid pointers. If we are then make the User
		// Sid as the first one in the list and copy the actual sid at the tail end of the
		// buffer.
        pSda->sda_pGroups->GroupCount = pGroups->GroupCount;
		RtlCopyMemory(&pSda->sda_pGroups->Groups[j],
					  &pGroups->Groups[0],
					  SizeNeeded - sizeof(DWORD));	// DWORD accounts for GroupCount
		if (ExtraSpace > 0)
		{
			pSda->sda_pGroups->Groups[0].Sid = (PSID)((PBYTE)(pSda->sda_pGroups) + SizeNeeded);
			RtlCopyMemory(pSda->sda_pGroups->Groups[0].Sid,
						  pSidnAttr->Sid,
						  RtlLengthSid(pSidnAttr->Sid));

			pSda->sda_pGroups->Groups[0].Attributes = pSidnAttr->Attributes;
			pSda->sda_pGroups->GroupCount ++;

			AfpDumpSid("AfpGetUserAndPrimaryGroupSids: Member of ",
						pSda->sda_pGroups->Groups[0].Sid);
		}
		for (i = 0; i < pGroups->GroupCount; i++, j++)
		{
			pSda->sda_pGroups->Groups[j].Sid = (PSID)((PBYTE)(pGroups->Groups[i].Sid) -
														(PBYTE)pGroups +
														(PBYTE)(pSda->sda_pGroups) +
														Offset);
			AfpDumpSid("AfpGetUserAndPrimaryGroupSids: Member of ",
						pSda->sda_pGroups->Groups[j].Sid);
			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpGetUserAndPrimaryGroupSids: Attributes %lx\n",
						pSda->sda_pGroups->Groups[j].Attributes));
		}
	} while (False);

	if (pGroups != (PTOKEN_GROUPS)GrpsBuffer)
		AfpFreeMemory(pGroups);

	return Status;
}



/***	AfpMakeSecurityDescriptorForUser
 *
 *	Create a security descriptor for a user. The security descriptor has the
 *	Owner Sid, Primary Group Sid and Aces for the User alone.
 */
AFPSTATUS
AfpMakeSecurityDescriptorForUser(
	IN	PSID					OwnerSid,
	IN	PSID					GroupSid,
	OUT	PISECURITY_DESCRIPTOR *	ppSecDesc
)
{
	AFPSTATUS				Status = AFP_ERR_MISC;
	PISECURITY_DESCRIPTOR	pSecDesc;
	int						DaclSize;
	PACCESS_ALLOWED_ACE		pAce;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
			("AfpMakeSecurityDescriptorForUser: Entered\n"));

	do
	{
		// Allocate a security descriptor
		pSecDesc = (PISECURITY_DESCRIPTOR)ALLOC_ACCESS_MEM(sizeof(SECURITY_DESCRIPTOR));

		*ppSecDesc = pSecDesc;
		if (pSecDesc == NULL)
			break;

		// Initialize the security descriptor
		RtlCreateSecurityDescriptor(pSecDesc, SECURITY_DESCRIPTOR_REVISION);

		pSecDesc->Control = SE_DACL_PRESENT;

		// Set the owner and group Ids in the descriptor
		pSecDesc->Owner = OwnerSid;
		pSecDesc->Group = GroupSid;

		// Determine the size of the Dacl needed. The sizeof(DWORD) offsets the
		// SidStart field in the ACE. There are 7 aces in this security descriptor:
		//
		// 2 for the owner (owner+inherit for owner)
		// 2 for Administrators (one inherit)
		// 2 for world (1 for world and 1 inherit for world).
		// 2 for system
		DaclSize = sizeof(ACL) + 2*(sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) +
									RtlLengthSid(OwnerSid)) +
								 2*(sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) +
									sizeof(AfpSidWorld)) +
								 2*(sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) +
									AfpSizeSidAdmins) +
								 2*(sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) +
									RtlLengthSid(&AfpSidSystem));

		if ((pSecDesc->Dacl = (PACL)ALLOC_ACCESS_MEM(DaclSize)) == NULL)
			break;

		// Initialize the ACL with one ACE corres. to Owner getting all the
		// privileges. Add another ace which is identical to the first ace but is
		// a inheritance ACE.
		// JH - Add another ace for world with minumum permissions and for administrators
		//		with FullControl
		RtlCreateAcl(pSecDesc->Dacl, DaclSize, ACL_REVISION);

        // we will be adding to this as we add aces, so set it to the min here
        pSecDesc->Dacl->AclSize = sizeof(ACL);

		pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pSecDesc->Dacl + sizeof(ACL));

		// Add the ALLOWED_ACE and the corres. inherit Ace for owner
		pAce = afpAddAceToAcl(pSecDesc->Dacl,
							  pAce,
							  (AFP_READ_ACCESS | AFP_WRITE_ACCESS | AFP_OWNER_ACCESS | FILE_DELETE_CHILD),
							  OwnerSid,
							  True);

		if (AfpSidAdmins != NULL)
		{
			// Add the ALLOWED_ACE and the corres. inherit Ace for 'Administrators'
			pAce = afpAddAceToAcl(pSecDesc->Dacl,
								  pAce,
								  (AFP_READ_ACCESS | AFP_WRITE_ACCESS | AFP_OWNER_ACCESS | FILE_DELETE_CHILD),
								  AfpSidAdmins,
								  True);
		}

		// Add a min. permission ace for world, but only if the owner is
		// not world already
		if (!RtlEqualSid(OwnerSid, &AfpSidWorld))
		{
			pAce = afpAddAceToAcl(pSecDesc->Dacl,
								  pAce,
								  (AFP_MIN_ACCESS),
								  &AfpSidWorld,
								  True);
		}

		// Now add Aces for System
		pAce = afpAddAceToAcl(pSecDesc->Dacl,
							  pAce,
							  AFP_READ_ACCESS | AFP_WRITE_ACCESS | AFP_OWNER_ACCESS,
							  &AfpSidSystem,
							  True);
		Status = AFP_ERR_NONE;
	} while (False);

	// Do any cleanup on error
	if (!NT_SUCCESS(Status) && (pSecDesc != NULL))
	{
		if (pSecDesc->Dacl != NULL)
			AfpFreeMemory(pSecDesc->Dacl);
		AfpFreeMemory(pSecDesc);
	}

	return Status;

}


/***	AfpGetAfpPermissions
 *
 *	Read the security descriptor for this directory and obtain the SIDs for
 *	Owner and Primary group. Determine if this user is a member of the directory
 *	primary group. Finally obtain Owner,Group and World permissions.
 *
 *	OwnerId, GroupId and permissions will always be valid if this call succeeds.
 */
NTSTATUS
AfpGetAfpPermissions(
	IN	PSDA			pSda,
	IN	HANDLE			DirHandle,
	IN OUT PFILEDIRPARM	pFDParm
)
{
	NTSTATUS				Status = STATUS_SUCCESS;
	DWORD					SizeNeeded;
	PISECURITY_DESCRIPTOR	pSecDesc = NULL;
	PBYTE                   pAbsSecDesc = NULL; // Used in conversion of
												// sec descriptor to 
												// absolute format
	BOOLEAN					SawOwnerAce = False,
							SawGroupAce = False,
							SawWorldAce = False,
							SawDenyAceForUser = False,
							CheckUserRights;
#ifdef	PROFILING
	TIME					TimeS, TimeE, TimeD;
#endif

	PAGED_CODE( );

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_GetPermsCount);
	AfpGetPerfCounter(&TimeS);
#endif

	// Read the security descriptor for this directory and determine the
	// rights for owner/group/world.We want to optimize on how much memory
	// we need to read this in. Its a pain to make a call just to get that.
	// So just make a guess. If that turns out to be short then do the exact
	// allocation.
	do
	{
		// 4096 has been emperically chosen
		SizeNeeded = 4096 - POOL_OVERHEAD;
		do
		{
			if (pSecDesc != NULL)
			{
				AfpFreeMemory(pSecDesc);
			}
			if ((pSecDesc = (PSECURITY_DESCRIPTOR)ALLOC_ACCESS_MEM(SizeNeeded)) == NULL)
			{
				Status = AFP_ERR_MISC;
				if (pSda->sda_ClientType == SDA_CLIENT_ADMIN)
				{
					Status = STATUS_INSUFFICIENT_RESOURCES;
				}
				break;
			}
			Status = NtQuerySecurityObject(DirHandle,
										OWNER_SECURITY_INFORMATION |
										GROUP_SECURITY_INFORMATION |
										DACL_SECURITY_INFORMATION,
										pSecDesc,
										SizeNeeded,
										&SizeNeeded);
		} while ((Status != STATUS_SUCCESS) &&
				 ((Status == STATUS_BUFFER_TOO_SMALL)	||
				  (Status == STATUS_BUFFER_OVERFLOW)	||
				  (Status == STATUS_MORE_ENTRIES)));

		if (!NT_SUCCESS(Status))
		{
			break;
		}

		// If the security descriptor is in self-relative form, convert to absolute

		pSecDesc = (PISECURITY_DESCRIPTOR)((PBYTE)pSecDesc);
		if (pSecDesc->Control & SE_SELF_RELATIVE)
		{

            DWORD AbsoluteSizeNeeded;

			// An absolute SD is not necessarily the same size as a relative
			// SD, so an in-place conversion may not be possible.
						
			AbsoluteSizeNeeded = SizeNeeded;            
            Status = RtlSelfRelativeToAbsoluteSD2(pSecDesc, &AbsoluteSizeNeeded);
			if (Status == STATUS_BUFFER_TOO_SMALL)
			{
					// Allocate a new buffer in which to store the absolute
					// security descriptor, copy the contents of the relative
					// descriptor in and try again

					pAbsSecDesc = (PBYTE)ALLOC_ACCESS_MEM(AbsoluteSizeNeeded);
					if (pAbsSecDesc == NULL)
					{
							Status = STATUS_NO_MEMORY;
							DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                				("AfpGetAfpPermissions: LocalAlloc error\n"));
					}
					else
					{
							RtlCopyMemory(pAbsSecDesc, pSecDesc, SizeNeeded);
							Status = RtlSelfRelativeToAbsoluteSD2 (pAbsSecDesc,
											&AbsoluteSizeNeeded);
							if (NT_SUCCESS(Status))
							{
									// We don't need relative form anymore, 
									// we will work with the Absolute form
									if (pSecDesc != NULL)
									{
										AfpFreeMemory(pSecDesc);
									}
									pSecDesc = (PISECURITY_DESCRIPTOR)pAbsSecDesc;
							}
							else
							{
									// We cannot use Absolute Form, throw it away
									AfpFreeMemory(pAbsSecDesc);
									pAbsSecDesc = NULL;
							}
					}

			}
            if (!NT_SUCCESS(Status))
            {
				DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                	("AfpGetAfpPermissions: RtlSelfRelativeToAbsoluteSD2: returned error %lx\n", Status));
                break;
            }
        }

		// Now determine if the user is a member of the directories primary group.
		pFDParm->_fdp_OwnerId = 0;
		pFDParm->_fdp_GroupId = 0;
		pFDParm->_fdp_UserIsOwner = False;
		pFDParm->_fdp_UserIsMemberOfDirGroup = False;

		if (pSecDesc->Owner != NULL)
		{
			AfpDumpSid("AfpGetAfpPermissions: OwnerSid", pSecDesc->Owner);

			pFDParm->_fdp_UserIsOwner =
								(RtlEqualSid(pSecDesc->Owner, pSda->sda_UserSid) ||
								 ((pSda->sda_ClientType != SDA_CLIENT_GUEST) &&
								  (pSda->sda_ClientType != SDA_CLIENT_ADMIN) &&
                                  afpIsUserMemberOfGroup(pSda->sda_pGroups,
														 pSecDesc->Owner)));
			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpGetAfpPermissions: User %s Owner\n",
					pFDParm->_fdp_UserIsOwner ? "is" : "isnt"));

			if (!NT_SUCCESS(Status = AfpSidToMacId(pSecDesc->Owner,
												   &pFDParm->_fdp_OwnerId)))
			{
				// If we cant map the Sid, return Id SE_NULL_POSIX_ID
				pFDParm->_fdp_OwnerId = SE_NULL_POSIX_ID;
				Status = AFP_ERR_NONE;
			}
		}

		if (pSecDesc->Group != NULL)
		{
			AfpDumpSid("AfpGetAfpPermissions: GroupSid", pSecDesc->Group);

			if (!pFDParm->_fdp_UserIsOwner)
				pFDParm->_fdp_UserIsMemberOfDirGroup =
								(RtlEqualSid(pSecDesc->Group, pSda->sda_UserSid) ||
								 ((pSda->sda_ClientType != SDA_CLIENT_GUEST) &&
								  (pSda->sda_ClientType != SDA_CLIENT_ADMIN) &&
								  afpIsUserMemberOfGroup(pSda->sda_pGroups,
														 pSecDesc->Group)));

			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpGetAfpPermissions: User %s member of PrimaryGroup\n",
					pFDParm->_fdp_UserIsMemberOfDirGroup ? "is" : "isnt"));

			if (!NT_SUCCESS(Status = AfpSidToMacId(pSecDesc->Group,
												   &pFDParm->_fdp_GroupId)))
			{
				// If we cant map the Sid, return Id SE_NULL_POSIX_ID
				pFDParm->_fdp_GroupId = SE_NULL_POSIX_ID;
				Status = AFP_ERR_NONE;
			}
		}

		// Walk through the ACL list and determine Owner/Group/World and User
		// permissions. For Owner/Group and User, if the specific ace's are
		// not present then they inherit the world permissions.
		//
		// A NULL Acl => All rights to everyone. An empty Acl on the other
		// hand => no access for anyone.

		pFDParm->_fdp_UserRights = 0;
		pFDParm->_fdp_WorldRights = 0;

		if ((pSecDesc->Control & SE_DACL_PRESENT) &&
			(pSecDesc->Dacl != NULL))
		{
			USHORT				i;
			PSID				pSid;
			PACL				pAcl;
			PACCESS_ALLOWED_ACE pAce;

			ASSERT (pSecDesc->Dacl != NULL);
			pAcl = pSecDesc->Dacl;
			pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAcl + sizeof(ACL));
			CheckUserRights =  ((pSda->sda_ClientType != SDA_CLIENT_GUEST) &&
								(pSda->sda_ClientType != SDA_CLIENT_ADMIN));
			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpGetAfpPermissions: # of aces %d\n", pSecDesc->Dacl->AceCount));
			for (i = 0; i < pSecDesc->Dacl->AceCount; i++)
			{
				pSid = (PSID)(&pAce->SidStart);

				// Ignore inherit aces, Aces for CreatorOwner, CreatorGroup & system
				if ((pAce->Header.AceFlags & INHERIT_ONLY_ACE)	||
					RtlEqualSid(pSid, &AfpSidSystem))
				{
					AfpDumpSidnMask("AfpGetAfpPermissions: Skipping",
										pSid,
										pAce->Mask,
										pAce->Header.AceType,
										pAce->Header.AceFlags);
				}
				else
				{
					AfpDumpSidnMask("AfpGetAfpPermissions: ACE",
										pSid,
										pAce->Mask,
										pAce->Header.AceType,
										pAce->Header.AceFlags);

					if (!SawOwnerAce &&
						(pSecDesc->Owner != NULL) &&
						RtlEqualSid(pSid, pSecDesc->Owner))
					{
						AfpAccessMask2AfpPermissions(pFDParm->_fdp_OwnerRights,
													  pAce->Mask,
													  pAce->Header.AceType);
						DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
								("%s Ace Mask %lx, Owner Permission: %x\n",
								(pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ?
														"Allow" : "Deny",
								 pAce->Mask, pFDParm->_fdp_OwnerRights));
						SawOwnerAce = True;
					}

					if (!SawGroupAce &&
						(pSecDesc->Group != NULL) &&
						RtlEqualSid(pSid, pSecDesc->Group))
					{
						AfpAccessMask2AfpPermissions(pFDParm->_fdp_GroupRights,
													  pAce->Mask,
													  pAce->Header.AceType);
						DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
								("%s Ace Mask %lx, Group Permission: %x\n",
								(pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ?
														"Allow" : "Deny",
								pAce->Mask, pFDParm->_fdp_GroupRights));
						SawGroupAce = True;
					}

					if (!SawWorldAce &&
						RtlEqualSid(pSid, (PSID)&AfpSidWorld))
					{
						AfpAccessMask2AfpPermissions(pFDParm->_fdp_WorldRights,
													  pAce->Mask,
													  pAce->Header.AceType);
						DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
								("%s Ace Mask %lx, World Permission: %x\n",
								(pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ?
														"Allow" : "Deny",
								pAce->Mask, pFDParm->_fdp_WorldRights));
						SawWorldAce = True;
					}

					if (CheckUserRights &&
						!SawDenyAceForUser &&
						(RtlEqualSid(pSid, pSda->sda_UserSid) ||
						 afpIsUserMemberOfGroup(pSda->sda_pGroups, pSid)))
					{
						BYTE	UserRights;

						UserRights = 0;
						AfpAccessMask2AfpPermissions(UserRights,
													  pAce->Mask,
													  ACCESS_ALLOWED_ACE_TYPE);

						DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
								("%s Ace Mask %lx, User Permission: %x\n",
								(pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ?
														"Allow" : "Deny",
									pAce->Mask, pFDParm->_fdp_WorldRights));

						if (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE)
						{
							pFDParm->_fdp_UserRights |= UserRights;
						}
						else
						{
							SawDenyAceForUser = True;
							pFDParm->_fdp_UserRights &= ~UserRights;
						}
					}
				}

				pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize);
			}
		}
		else	// Security descriptor not present, party time
		{
			pFDParm->_fdp_WorldRights = DIR_ACCESS_ALL;
			pFDParm->_fdp_UserRights = DIR_ACCESS_ALL | DIR_ACCESS_OWNER;
		}

		if (!SawGroupAce)
			pFDParm->_fdp_GroupRights = pFDParm->_fdp_WorldRights;

		// If this is a standalone server and the primary group of the
		// directory is MACHINE\None, do not return this information to
		// the caller.
		if (AfpServerIsStandalone		&&
			(pSecDesc->Group != NULL)	&&
			RtlEqualSid(pSecDesc->Group, AfpSidNone))
		{
			pFDParm->_fdp_GroupRights = 0;
			pFDParm->_fdp_GroupId = 0;
		}

		if (pSda->sda_ClientType == SDA_CLIENT_GUEST)
			pFDParm->_fdp_UserRights = pFDParm->_fdp_WorldRights;

		// Make sure we do not give a user anything if we saw a deny ace for him.
		if (!SawOwnerAce && !SawDenyAceForUser)
			pFDParm->_fdp_OwnerRights = pFDParm->_fdp_WorldRights;
	} while (False);

	if (pSecDesc != NULL)
		AfpFreeMemory(pSecDesc);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_GetPermsTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	return Status;
}



/***	afpMoveAces
 *
 *	Move a bunch of aces from the old security descriptor to the new security
 *	descriptor.
 */
LOCAL PACCESS_ALLOWED_ACE
afpMoveAces(
	IN	PACL				pOldDacl,
	IN	PACCESS_ALLOWED_ACE	pAceStart,
	IN	PSID				pSidOldOwner,
	IN	PSID				pSidNewOwner,
	IN	PSID				pSidOldGroup,
	IN	PSID				pSidNewGroup,
	IN	BOOLEAN				DenyAces,
	IN	OUT PACL			pNewDacl
)
{
	USHORT				i;
	PACCESS_ALLOWED_ACE	pAceOld;
	PSID				pSidAce;

	PAGED_CODE( );

	for (i = 0, pAceOld = (PACCESS_ALLOWED_ACE)((PBYTE)pOldDacl + sizeof(ACL));
		 i < pOldDacl->AceCount;
		 i++, pAceOld = (PACCESS_ALLOWED_ACE)((PBYTE)pAceOld + pAceOld->Header.AceSize))
	{
		// Note: All deny aces are ahead of the grant aces.
		if (DenyAces && (pAceOld->Header.AceType != ACCESS_DENIED_ACE_TYPE))
			break;

		if (!DenyAces && (pAceOld->Header.AceType == ACCESS_DENIED_ACE_TYPE))
			continue;

		pSidAce = (PSID)(&pAceOld->SidStart);
		if (!RtlEqualSid(pSidAce, &AfpSidWorld)		&&
			!RtlEqualSid(pSidAce, &AfpSidSystem)	&&
			(AfpSidAdmins != NULL)					&&
			!RtlEqualSid(pSidAce, AfpSidAdmins)		&&
			!RtlEqualSid(pSidAce, pSidOldOwner)		&&
			!RtlEqualSid(pSidAce, pSidNewOwner)		&&
			!RtlEqualSid(pSidAce, pSidOldGroup)		&&
			!RtlEqualSid(pSidAce, pSidNewGroup))
		{
			RtlCopyMemory(pAceStart, pAceOld, pAceOld->Header.AceSize);
            pNewDacl->AclSize += pAceOld->Header.AceSize;
			pNewDacl->AceCount ++;
			pAceStart = (PACCESS_ALLOWED_ACE)((PBYTE)pAceStart +
													pAceStart->Header.AceSize);
		}
	}
	return pAceStart;
}


/***	AfpSetAfpPermissions
 *
 *	Set the permissions on this directory. Also optionally set the owner and
 *	group ids. For setting the owner and group ids verify if the user has the
 *	needed access. This access is however not good enough. We check for this
 *	access but do the actual setting of the permissions in the special server
 *	context (RESTORE privilege is needed).
 */
AFPSTATUS
AfpSetAfpPermissions(
	IN	HANDLE			DirHandle,
	IN	DWORD			Bitmap,
	IN	PFILEDIRPARM	pFDParm
)
{
	AFPSTATUS				Status = STATUS_SUCCESS;
	DWORD					SizeNeeded;
	PISECURITY_DESCRIPTOR	pSecDesc;
	PBYTE                   pAbsSecDesc = NULL; // Used in conversion of
												// sec descriptor to 
												// absolute format
	SECURITY_INFORMATION	SecInfo = DACL_SECURITY_INFORMATION;
	PSID					pSidOwner = NULL, pSidGroup = NULL;
	PSID					pSidOldOwner, pSidOldGroup;
	BOOLEAN					SawOwnerAce = False, SawGroupAce = False;
	BOOLEAN					OwnerIsWorld = False, GroupIsWorld = False;
	BOOLEAN					fDir = IsDir(pFDParm);
	PACL					pDaclNew = NULL;
	PACCESS_ALLOWED_ACE		pAce;
	LONG					SizeNewDacl;
#ifdef	PROFILING
	TIME					TimeS, TimeE, TimeD;
#endif

	PAGED_CODE( );

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_SetPermsCount);
	AfpGetPerfCounter(&TimeS);
#endif
	do
	{
		// Read the security descriptor for this directory
		SizeNeeded = 4096 - POOL_OVERHEAD;
		pSecDesc = NULL;

		do
		{
			if (pSecDesc != NULL)
			{
				AfpFreeMemory(pSecDesc);
			}

			SizeNewDacl = SizeNeeded;
			if ((pSecDesc = (PSECURITY_DESCRIPTOR)ALLOC_ACCESS_MEM(SizeNeeded)) == NULL)
			{
				Status = AFP_ERR_MISC;
				break;
			}

			Status = NtQuerySecurityObject(DirHandle,
										OWNER_SECURITY_INFORMATION |
										GROUP_SECURITY_INFORMATION |
										DACL_SECURITY_INFORMATION,
										pSecDesc,
										SizeNeeded,
										&SizeNeeded);
		} while ((Status != STATUS_SUCCESS) &&
				 ((Status == STATUS_BUFFER_TOO_SMALL)	||
				  (Status == STATUS_BUFFER_OVERFLOW)	||
				  (Status == STATUS_MORE_ENTRIES)));

		if (!NT_SUCCESS(Status))
		{
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
			break;
		}


        pSecDesc = (PISECURITY_DESCRIPTOR)((PBYTE)pSecDesc);
		// If the security descriptor is in self-relative form, convert to absolute
		if (pSecDesc->Control & SE_SELF_RELATIVE)
		{
            DWORD AbsoluteSizeNeeded;

			// An absolute SD is not necessarily the same size as a relative
			// SD, so an in-place conversion may not be possible.
						
			AbsoluteSizeNeeded = SizeNeeded;            
            Status = RtlSelfRelativeToAbsoluteSD2(pSecDesc, &AbsoluteSizeNeeded);
			if (Status == STATUS_BUFFER_TOO_SMALL)
			{
					// Allocate a new buffer in which to store the absolute
					// security descriptor, copy the contents of the relative
					// descriptor in and try again

					pAbsSecDesc = (PBYTE)ALLOC_ACCESS_MEM(AbsoluteSizeNeeded);
					if (pAbsSecDesc == NULL)
					{
							Status = STATUS_NO_MEMORY;
							DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                				("AfpSetAfpPermissions: LocalAlloc error\n"));
					}
					else
					{
							RtlCopyMemory(pAbsSecDesc, pSecDesc, SizeNeeded);
							Status = RtlSelfRelativeToAbsoluteSD2 (pAbsSecDesc,
											&AbsoluteSizeNeeded);
							if (NT_SUCCESS(Status))
							{
									// We don't need relative form anymore, 
									// we will work with the Absolute form
									if (pSecDesc != NULL)
									{
										AfpFreeMemory(pSecDesc);
									}
									pSecDesc = (PISECURITY_DESCRIPTOR)pAbsSecDesc;
							}
							else
							{
									// We cannot use Absolute Form, throw it away
									AfpFreeMemory(pAbsSecDesc);
									pAbsSecDesc = NULL;
							}
					}
			}

            if (!NT_SUCCESS(Status))
            {
				DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                	("AfpSetAfpPermissions: RtlSelfRelativeToAbsoluteSD2: returned error %lx\n", Status));
                break;
            }
            SizeNeeded = AbsoluteSizeNeeded;
        }
        SizeNewDacl = SizeNeeded;

		// Save the old Owner and Group Sids
		pSidOldOwner = pSecDesc->Owner;
		pSidOldGroup = pSecDesc->Group;

		// Convert the owner/group ids, if any to be set to their corres. sids
		if (Bitmap & DIR_BITMAP_OWNERID)
		{
			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
				("AfpSetAfpPermissions: Setting Owner to ID %lx\n",
				pFDParm->_fdp_OwnerId));

			if (AfpMacIdToSid(pFDParm->_fdp_OwnerId, &pSidOwner) != STATUS_SUCCESS)
			{
				Status = AFP_ERR_MISC;
				break;
			}

			// Don't allow owner sid to be set as the NULL sid, or
			// to what it is presently set to
			if (!RtlEqualSid(pSecDesc->Owner, pSidOwner) &&
				!RtlEqualSid(&AfpSidNull, pSidOwner))
			{
				AfpDumpSid("AfpSetAfpPermissions: Setting Owner Sid to ", pSidOwner);
				pSecDesc->Owner = pSidOwner;
				SecInfo |= OWNER_SECURITY_INFORMATION;
			}
		}

		if (Bitmap & DIR_BITMAP_GROUPID)
		{
			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpSetAfpPermissions: Setting Group to ID %lx\n",
					pFDParm->_fdp_GroupId));

			if (AfpMacIdToSid(pFDParm->_fdp_GroupId, &pSidGroup) != STATUS_SUCCESS)
			{
				Status = AFP_ERR_MISC;
				break;
			}

			// Don't allow group sid to be set as the NULL or None sid, or
			// to what it is presently set to
			if (!RtlEqualSid(pSecDesc->Group, pSidGroup)	&&
				!RtlEqualSid(&AfpSidNull, pSidGroup)		&&
				(!AfpServerIsStandalone || !RtlEqualSid(AfpSidNone, pSidGroup)))
			{
				AfpDumpSid("AfpSetAfpPermissions: Setting Group Sid to ", pSidGroup);
				pSecDesc->Group = pSidGroup;
				SecInfo |= GROUP_SECURITY_INFORMATION;
			}

		}

		// If either the owner or group or both is 'EveryOne' then coalesce the
		// permissions
		if (RtlEqualSid(pSecDesc->Owner, pSecDesc->Group))
		{
			pFDParm->_fdp_OwnerRights |= pFDParm->_fdp_GroupRights;
			pFDParm->_fdp_GroupRights |= pFDParm->_fdp_OwnerRights;
		}

		if (RtlEqualSid(pSecDesc->Owner, &AfpSidWorld))
		{
			pFDParm->_fdp_WorldRights |= (pFDParm->_fdp_OwnerRights | DIR_ACCESS_OWNER);
			OwnerIsWorld = True;
		}

		if (RtlEqualSid(pSecDesc->Group, &AfpSidWorld))
		{
			pFDParm->_fdp_WorldRights |= pFDParm->_fdp_GroupRights;
			GroupIsWorld = True;
		}

		// Construct the new Dacl. This consists of Aces for World, Owner and Group
		// followed by Old Aces for everybody else, but with Aces for World, OldOwner
		// and OldGroup stripped out. First determine space for the new Dacl and
		// allocated space for the new Dacl. Lets be exteremely conservative. We
		// have two aces each for owner/group/world.
		//
		// JH - Add aces for DomainAdmins too.

		SizeNewDacl +=
				(RtlLengthSid(pSecDesc->Owner) + sizeof(ACCESS_ALLOWED_ACE) +
				 RtlLengthSid(pSecDesc->Group) + sizeof(ACCESS_ALLOWED_ACE) +
				 AfpSizeSidAdmins + sizeof(ACCESS_ALLOWED_ACE) +
				 sizeof(AfpSidSystem) + sizeof(ACCESS_ALLOWED_ACE) +
				 sizeof(AfpSidWorld) + sizeof(ACCESS_ALLOWED_ACE)) * 3;

		if ((pDaclNew = (PACL)ALLOC_ACCESS_MEM(SizeNewDacl)) == NULL)
		{
			Status = AFP_ERR_MISC;
			break;
		}

		RtlCreateAcl(pDaclNew, SizeNewDacl, ACL_REVISION);

        // we will be adding to this as we add aces, so set it to the min here
        pDaclNew->AclSize = sizeof(ACL);

		pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pDaclNew + sizeof(ACL));

		// At this time the Acl list is empty, i.e. no access for anybody
		// Start off by copying the Deny Aces from the original Dacl list
		// weeding out the Aces for World, old and new owner, new and old
		// group, creator owner and creator group
		if (pSecDesc->Dacl != NULL)
		{
			pAce = afpMoveAces(pSecDesc->Dacl,
							   pAce,
							   pSidOldOwner,
							   pSecDesc->Owner,
							   pSidOldGroup,
							   pSecDesc->Group,
							   True,
							   pDaclNew);

			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpSetAfpPermissions: Added %d Deny Aces\n",
					pDaclNew->AceCount));

			ASSERT(((PBYTE)pAce - (PBYTE)pDaclNew) < SizeNewDacl);
		}

		// Now add Aces for System, World, Admins, Group & Owner - in that order
		pAce = afpAddAceToAcl(pDaclNew,
							  pAce,
							  AFP_READ_ACCESS | AFP_WRITE_ACCESS | AFP_OWNER_ACCESS,
							  &AfpSidSystem,
							  fDir);

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
				("AfpSetAfpPermissions: Added Aces for System (%d)\n",
				pDaclNew->AceCount));

		ASSERT(((PBYTE)pAce - (PBYTE)pDaclNew) < SizeNewDacl);

		// Now add Ace for World
		pAce = afpAddAceToAcl(pDaclNew,
							  pAce,
							  afpPermissions2NtMask(pFDParm->_fdp_WorldRights),
							  &AfpSidWorld,
							  fDir);

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
				("AfpSetAfpPermissions: Added Aces for World (%d)\n",
				pDaclNew->AceCount));

		ASSERT(((PBYTE)pAce - (PBYTE)pDaclNew) < SizeNewDacl);

		if (AfpSidAdmins != NULL)
		{
			// Add the ALLOWED_ACE and the corres. inherit Ace for
			// 'Domain Admins' on PDC/BDC, or 'MACHINE\Administrators' for
			// standalone server
			pAce = afpAddAceToAcl(pDaclNew,
								  pAce,
								  (AFP_READ_ACCESS | AFP_WRITE_ACCESS | AFP_OWNER_ACCESS | FILE_DELETE_CHILD),
								  AfpSidAdmins,
								  fDir);
		}

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
				("AfpSetAfpPermissions: Added Aces for Admins (%d)\n",
				pDaclNew->AceCount));

		// Now add Ace for Group
		if (!GroupIsWorld &&
			!RtlEqualSid(pSecDesc->Group, &AfpSidNull) &&
			(!AfpServerIsStandalone || !RtlEqualSid(pSecDesc->Group, AfpSidNone)))
		{
			pAce = afpAddAceToAcl(pDaclNew,
					   pAce,
					   afpPermissions2NtMask(pFDParm->_fdp_GroupRights),
					   pSecDesc->Group,
					   fDir);

			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpSetAfpPermissions: Added Aces for World (%d)\n",
					pDaclNew->AceCount));

			ASSERT(((PBYTE)pAce - (PBYTE)pDaclNew) < SizeNewDacl);
		}

		if (!OwnerIsWorld && !RtlEqualSid(pSecDesc->Owner, &AfpSidNull))
		{
			pFDParm->_fdp_OwnerRights |= DIR_ACCESS_OWNER;
			pAce = afpAddAceToAcl(pDaclNew,
								  pAce,
								  afpPermissions2NtMask(pFDParm->_fdp_OwnerRights),
								  pSecDesc->Owner,
								  fDir);

			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpSetAfpPermissions: Added Aces for Group (%d)\n",
					pDaclNew->AceCount));

			ASSERT(((PBYTE)pAce - (PBYTE)pDaclNew) < SizeNewDacl);
		}

		// Now add in the Grant Aces from the original Dacl list weeding out
		// the Aces for World, old and new owner, new and old group, creator
		// owner and creator group
		if (pSecDesc->Dacl != NULL)
		{
			pAce = afpMoveAces(pSecDesc->Dacl,
							   pAce,
							   pSidOldOwner,
							   pSecDesc->Owner,
							   pSidOldGroup,
							   pSecDesc->Group,
							   False,
							   pDaclNew);

			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpSetAfpPermissions: Added old Grant Aces (%d)\n",
					pDaclNew->AceCount));

			ASSERT(((PBYTE)pAce - (PBYTE)pDaclNew) < SizeNewDacl);
		}

		// Now set the new security descriptor
		pSecDesc->Dacl = pDaclNew;

		// We need to impersonate the FspToken while we do this
		AfpImpersonateClient(NULL);
		Status = NtSetSecurityObject(DirHandle, SecInfo, pSecDesc);
		if (!NT_SUCCESS(Status))
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
		AfpRevertBack();
	} while (False);

	// Free the allocated buffers before we return
	if (pSecDesc != NULL)
		AfpFreeMemory(pSecDesc);
	if (pDaclNew != NULL)
		AfpFreeMemory(pDaclNew);


#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_SetPermsTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	return Status;
}


/***	afpPermissions2NtMask
 *
 *	Map Afp permissions to Nt access mask. FILE_DELETE_CHILD is added ONLY
 *	when all the Afp bits are set. This is in line with the FileManager
 *	which only sets this bit if "Full Control" is specified. Also under
 *	NT security model, FILE_DELETE_CHILD overrides any child access control
 * 	as far as the ability to delete that entity goes.
 */
LOCAL	ACCESS_MASK
afpPermissions2NtMask(
	IN  BYTE	AfpPermissions
)
{
	ACCESS_MASK	NtAccess = 0;

	PAGED_CODE( );

	if (AfpPermissions & DIR_ACCESS_OWNER)
		NtAccess |= AFP_OWNER_ACCESS;

	if ((AfpPermissions & DIR_ACCESS_ALL) == DIR_ACCESS_ALL)
		NtAccess |= AFP_READ_ACCESS | AFP_WRITE_ACCESS | FILE_DELETE_CHILD;
	else
	{
		if (AfpPermissions & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH))
			NtAccess |= AFP_READ_ACCESS;

		if (AfpPermissions & DIR_ACCESS_WRITE)
			NtAccess |= AFP_WRITE_ACCESS;
	}
	return NtAccess;
}


/***	afpAddAceToAcl
 *
 *	Build an Ace corres. to the Sid(s) and mask and add these to the Acl. It is
 *	assumed that the Acl has space for the Aces. If the mask is 0 i.e. no access
 *	we give AFP_MIN_ACCESS. This is so that the file/dir permissions can be
 *	queried and a belted icon is generated instead of nothing.
 */
LOCAL	PACCESS_ALLOWED_ACE
afpAddAceToAcl(
	IN  PACL				pAcl,
	IN  PACCESS_ALLOWED_ACE	pAce,
	IN  ACCESS_MASK			Mask,
	IN  PSID				pSid,
	IN	BOOLEAN				fInherit
)
{
	USHORT	SidLen;

	PAGED_CODE( );

	SidLen = (USHORT)RtlLengthSid(pSid);

	// Add a vanilla ace
	pAcl->AceCount ++;
	pAce->Mask = Mask | SYNCHRONIZE | AFP_MIN_ACCESS;
	pAce->Header.AceFlags = 0;
	pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
	pAce->Header.AceSize = (USHORT)(sizeof(ACE_HEADER) +
									sizeof(ACCESS_MASK) +
									SidLen);

	RtlCopyMemory((PSID)(&pAce->SidStart), pSid, SidLen);

    pAcl->AclSize += pAce->Header.AceSize;

	AfpDumpSidnMask("afpAddAceToAcl ",
					pSid,
					pAce->Mask,
					ACCESS_ALLOWED_ACE_TYPE,
					pAce->Header.AceFlags);

	// Now add an inherit ace
	if (fInherit)
	{
		pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize);
		pAcl->AceCount ++;
		pAce->Mask = Mask | SYNCHRONIZE | AFP_MIN_ACCESS;
		pAce->Header.AceFlags = CONTAINER_INHERIT_ACE |
								OBJECT_INHERIT_ACE |
								INHERIT_ONLY_ACE;
		pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
		pAce->Header.AceSize = (USHORT)(sizeof(ACE_HEADER) +
										sizeof(ACCESS_MASK) +
										SidLen);
		RtlCopyMemory((PSID)(&pAce->SidStart), pSid, SidLen);

        pAcl->AclSize += pAce->Header.AceSize;

		AfpDumpSidnMask("afpAddAceToAcl (Inherit) ",
						pSid,
						pAce->Mask,
						ACCESS_ALLOWED_ACE_TYPE,
						pAce->Header.AceFlags);
	}

	return ((PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize));
}


#if DBG

/***	AfpDumpSid
 *
 */
VOID
AfpDumpSid(
	IN	PBYTE	pString,
	IN	PISID	pSid
)
{
	WCHAR			Buffer[128];
	UNICODE_STRING	SidStr;

	PAGED_CODE( );

	AfpSetEmptyUnicodeString(&SidStr, sizeof(Buffer), Buffer);
	if ((AfpDebugComponent & DBG_COMP_SECURITY) && (DBG_LEVEL_INFO >= AfpDebugLevel))
	{
		RtlConvertSidToUnicodeString(&SidStr, pSid, False);

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("%s %ws\n", pString, SidStr.Buffer));
	}
}

/***	AfpDumpSidnMask
 *
 */
VOID
AfpDumpSidnMask(
	IN	PBYTE	pString,
	IN	PISID	pSid,
	IN	DWORD	Mask,
	IN	UCHAR	Type,
	IN	UCHAR	Flags
)
{
	WCHAR			Buffer[128];
	UNICODE_STRING	SidStr;

	PAGED_CODE( );

	AfpSetEmptyUnicodeString(&SidStr, sizeof(Buffer), Buffer);
	if ((AfpDebugComponent & DBG_COMP_SECURITY) && (DBG_LEVEL_INFO >= AfpDebugLevel))
	{
		RtlConvertSidToUnicodeString(&SidStr, pSid, False);

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("%s Sid %ws, Mask %lx, Type %x, Flags %x\n",
					pString, SidStr.Buffer, Mask, Type, Flags));
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\access.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	access.h

Abstract:

	This module contains prototypes for access related routines.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	20 Sep 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _ACCESS_
#define _ACCESS_

#define	AFP_READ_ACCESS		(READ_CONTROL		 |	\
							FILE_READ_ATTRIBUTES |	\
							FILE_TRAVERSE		 |	\
							FILE_LIST_DIRECTORY	 |	\
							FILE_READ_EA)

#define	AFP_WRITE_ACCESS	(FILE_ADD_FILE		 |	\
							FILE_ADD_SUBDIRECTORY|	\
							FILE_WRITE_ATTRIBUTES|	\
							FILE_WRITE_EA		 |	\
							DELETE)

#define	AFP_OWNER_ACCESS	(WRITE_DAC			  | \
							 WRITE_OWNER)

#define	AFP_MIN_ACCESS		(FILE_READ_ATTRIBUTES | \
							 READ_CONTROL)

#ifdef	i386
#pragma warning(disable:4010)
#endif

GLOBAL	SID		AfpSidWorld			EQU	\
			{ 1, 1, SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID };
GLOBAL	SID		AfpSidSystem		EQU	\
			{ 1, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID };
GLOBAL	SID		AfpSidNull			EQU	\
			{ 1, 1, SECURITY_NULL_SID_AUTHORITY, SECURITY_NULL_RID };

GLOBAL	SID		AfpSidBuiltIn		EQU \
			{ 1, 1, SECURITY_NT_AUTHORITY, SECURITY_BUILTIN_DOMAIN_RID };
GLOBAL	PSID	AfpSidAdmins		EQU NULL;
GLOBAL	LONG	AfpSizeSidAdmins	EQU	0;
GLOBAL  PSID	AfpSidNone			EQU NULL;
GLOBAL  LONG	AfpSizeSidNone		EQU 0;

#ifdef 	OPTIMIZE_GUEST_LOGONS

#ifdef	INHERIT_DIRECTORY_PERMS
GLOBAL	DWORD	AfpIdWorld			EQU 0;
#else
GLOBAL	PISECURITY_DESCRIPTOR		AfpGuestSecDesc EQU NULL;
#endif

#endif

#define	AfpAccessMask2AfpPermissions(Rights, Mask, Type)					\
				if ((Type) == ACCESS_ALLOWED_ACE_TYPE)						\
				{															\
					if (((Mask) & AFP_READ_ACCESS) == AFP_READ_ACCESS)		\
						 (Rights) |= (DIR_ACCESS_READ | DIR_ACCESS_SEARCH);	\
					if (((Mask) & AFP_WRITE_ACCESS) == AFP_WRITE_ACCESS)	\
						(Rights) |= DIR_ACCESS_WRITE;						\
					if (((Mask) & AFP_OWNER_ACCESS) == AFP_OWNER_ACCESS)	\
						(Rights) |= DIR_ACCESS_OWNER;						\
				}															\
				else														\
				{															\
					ASSERT((Type) == ACCESS_DENIED_ACE_TYPE);				\
					if ((Mask) & AFP_READ_ACCESS)							\
						(Rights) &= ~(DIR_ACCESS_READ | DIR_ACCESS_SEARCH); \
					if ((Mask) & AFP_WRITE_ACCESS)							\
						(Rights) &= ~DIR_ACCESS_WRITE;						\
					if ((Mask) & AFP_OWNER_ACCESS)							\
						(Rights) &= ~DIR_ACCESS_OWNER;						\
				}

extern
NTSTATUS
AfpGetUserAndPrimaryGroupSids(
	IN	PSDA						pSda
);


extern
AFPSTATUS
AfpMakeSecurityDescriptorForUser(
	IN	PSID					OwnerSid,
	IN	PSID					GroupSid,
	OUT	PISECURITY_DESCRIPTOR *	ppSecDesc
);


extern
AFPSTATUS
AfpGetAfpPermissions(
	IN	PSDA						pSda,
	IN	HANDLE						DirHandle,
	IN OUT struct _FileDirParms *	pFDParm
);


extern
AFPSTATUS
AfpSetAfpPermissions(
	IN	HANDLE						DirHandle,
	IN	DWORD						Bitmap,
	IN OUT struct _FileDirParms *	pFDParm
);

#if DBG

extern
VOID
AfpDumpSid(
	IN	PBYTE						pString,
	IN	PISID						pSid
);

extern
VOID
AfpDumpSidnMask(
	IN	PBYTE						pString,
	IN	PISID						pSid,
	IN	DWORD						Mask,
	IN	UCHAR						Type,
	IN	UCHAR						Flags
);

#else

#define	AfpDumpSid(pString, pSid)
#define	AfpDumpSidnMask(pString, pSid, Mask, Type, Flags)

#endif

#define	ALLOC_ACCESS_MEM(x)	AfpAllocNonPagedMemory(x)

#ifdef	_ACCESS_LOCALS

LOCAL	BOOLEAN
afpIsUserMemberOfGroup(
	IN	PTOKEN_GROUPS				pGroups,
	IN	PSID						pSidGroup
);


LOCAL	ACCESS_MASK
afpPermissions2NtMask(
	IN	BYTE						AfpPermissions
);

LOCAL	PACCESS_ALLOWED_ACE
afpAddAceToAcl(
	IN	PACL						pAcl,
	IN	PACCESS_ALLOWED_ACE			pAce,
	IN	ACCESS_MASK					Mask,
	IN	PSID						pSid,
	IN	BOOLEAN						fInherit
);

LOCAL PACCESS_ALLOWED_ACE
afpMoveAces(
	IN	PACL						pOldDacl,
	IN	PACCESS_ALLOWED_ACE			pAceStart,
	IN	PSID						pSidOldOwner,
	IN	PSID						pSidNewOwner,
	IN	PSID						pSidOldGroup,
	IN	PSID						pSidNewGroup,
	IN	BOOLEAN						DenyAces,
	IN	OUT PACL					pNewDacl
);

#endif	// _ACCESS_LOCALS

#endif	// _ACCESS_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\admin.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	admin.c

Abstract:

	This module implements the top level admin request routines. All
	routines within this module execute in the context of the server
	service (or equivalent calling user mode process).

	A routine that can complete an entire admin request
	in the caller's context will return an appropriate AFP error to
	the admin dispatch layer above.

	A routine that must queue a worker to the FSP Admin queue will return
	STATUS_PENDING to the admin dispatch layer above. This will indicate
	to the dispatch layer that it should queue up the appropriate request.
	In these cases, the routine's job is to merely validate any appropriate
	input and return the STATUS_PENDING error code.

Author:

	Sue Adams (microsoft!suea)

Revision History:
	25 Jun 1992		Initial Version

--*/

#define	FILENUM	FILE_ADMIN

#include <afp.h>
#include <afpadmin.h>
#include <secutil.h>
#include <fdparm.h>
#include <pathmap.h>
#include <afpinfo.h>
#include <access.h>
#include <secutil.h>
#include <gendisp.h>

// This is the duration that we sleep before rescanning for the enumerate apis
#define	AFP_SLEEP_TIMER_TICK	-(1*NUM_100ns_PER_SECOND/100)	// 10ms

LOCAL
NTSTATUS
afpConvertAdminPathToMacPath(
	IN	PVOLDESC		pVolDesc,
	IN	PUNICODE_STRING	AdminPath,
	OUT	PANSI_STRING	MacPath
);

LOCAL
PETCMAPINFO
afpGetNextFreeEtcMapEntry(
	IN OUT PLONG	StartIndex
);

LOCAL
VOID
afpEtcMapDelete(
	PETCMAPINFO	pEtcEntry
);

LOCAL
NTSTATUS
afpCopyMapInfo2ToMapInfo(
	OUT PETCMAPINFO		pEtcDest,
	IN	PETCMAPINFO2	pEtcSource
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpAdminDeInit)
#pragma alloc_text( PAGE, AfpSleepAWhile)
#pragma alloc_text( PAGE, AfpAdmServiceStart)
#pragma alloc_text( PAGE, AfpAdmServiceStop)
#pragma alloc_text( PAGE, AfpAdmServicePause)
#pragma alloc_text( PAGE, AfpAdmServiceContinue)
#pragma alloc_text( PAGE, AfpAdmServerGetInfo)
#pragma alloc_text( PAGE, AfpAdmClearProfCounters)
#pragma alloc_text( PAGE, AfpAdmServerSetParms)
#pragma alloc_text( PAGE, AfpAdmServerAddEtc)
#pragma alloc_text( PAGE, AfpAdmServerSetEtc)
#pragma alloc_text( PAGE, AfpAdmServerDeleteEtc)
#pragma alloc_text( PAGE, AfpAdmServerAddIcon)
#pragma alloc_text( PAGE, AfpAdmVolumeAdd)
#pragma alloc_text( PAGE, AfpAdmWDirectoryGetInfo)
#pragma alloc_text( PAGE, AfpAdmWDirectorySetInfo)
#pragma alloc_text( PAGE, AfpAdmWFinderSetInfo)
#pragma alloc_text( PAGE, AfpLookupEtcMapEntry)
#pragma alloc_text( PAGE, afpEtcMapDelete)
#pragma alloc_text( PAGE, afpGetNextFreeEtcMapEntry)
#pragma alloc_text( PAGE, afpConvertAdminPathToMacPath)
#pragma alloc_text( PAGE_AFP, AfpAdmGetStatistics)
#pragma alloc_text( PAGE_AFP, AfpAdmClearStatistics)
#pragma alloc_text( PAGE_AFP, AfpAdmGetProfCounters)
#pragma alloc_text( PAGE_AFP, AfpAdmVolumeGetInfo)
#pragma alloc_text( PAGE_AFP, AfpAdmVolumeSetInfo)
#pragma alloc_text( PAGE_AFP, AfpAdmVolumeEnum)
#pragma alloc_text( PAGE_AFP, AfpAdmSessionEnum)
#pragma alloc_text( PAGE_AFP, AfpAdmConnectionEnum)
#pragma alloc_text( PAGE_AFP, AfpAdmForkEnum)
#pragma alloc_text( PAGE_AFP, AfpAdmMessageSend)
#endif

//
// macro to ensure that the extension in a type/creator mapping is padded
// with nulls by the server service so we don't end up in la-la land on a
// lookup by extension
//
#define	afpIsValidExtension(ext)	(((ext)[AFP_EXTENSION_LEN] == '\0') && \
									 ((ext)[0] != '\0') )

//
// invalid entries in AfpEtcMaps table are denoted by a null extension field
//
#define afpIsValidEtcMapEntry(ext)	((ext)[0] != '\0')

#define afpCopyEtcMap(pdst,psrc)	(RtlCopyMemory(pdst,psrc,sizeof(ETCMAPINFO)))

#define afpIsServerIcon(picon)		((picon)->icon_icontype == 0)


/***	AfpAdminDeInit
 *
 *	De-initialize the data structures for admin APIs.
 */
VOID
AfpAdminDeInit(
	VOID
)
{
	PAGED_CODE( );

	// Free memory for server icon
	if (AfpServerIcon != NULL)
		AfpFreeMemory(AfpServerIcon);

	// Free memory used for global icons
	AfpFreeGlobalIconList();

	// Free memory used for ETC mappings
	if (AfpEtcMaps != NULL)
	{
		AfpFreeMemory(AfpEtcMaps);
	}

	// Free memory used for server name
	if (AfpServerName.Buffer != NULL)
	{
		AfpFreeMemory(AfpServerName.Buffer);
	}

	// Free any Server/Login Messages
	if (AfpServerMsg != NULL)
	{
		AfpFreeMemory(AfpServerMsg);
	}

	if (AfpLoginMsg.Buffer != NULL)
	{
		AfpFreeMemory(AfpLoginMsg.Buffer);
	}

	if (AfpLoginMsgU.Buffer != NULL)
	{
		AfpFreeMemory(AfpLoginMsgU.Buffer);
	}

	// Free the memory allocated for the admin sid
	if (AfpSidAdmins != NULL)
		AfpFreeMemory(AfpSidAdmins);

	// Free the memory allocated for the None sid (standalone only)
	if (AfpSidNone != NULL)
		AfpFreeMemory(AfpSidNone);
}



/***	AfpSleepAWhile
 *
 *	Sleep for a multiple of AFP_SLEEP_TIMER_TICK ticks.
 */
VOID
AfpSleepAWhile(
	IN	DWORD	SleepDuration
)
{
	KTIMER			SleepTimer;
	LARGE_INTEGER	TimerValue;

	PAGED_CODE( );

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	KeInitializeTimer(&SleepTimer);

	TimerValue.QuadPart = (SleepDuration * AFP_SLEEP_TIMER_TICK);
	KeSetTimer(&SleepTimer,
			   TimerValue,
			   NULL);

	AfpIoWait(&SleepTimer, NULL);
}



/***	AfpAdmServiceStart
 *
 *	This is the service start code. The following is done as part of the service
 *	startup.
 *
 *	Registration of NBP Name.
 *	Posting listens
 *	And finally the server status block is set.
 */
AFPSTATUS
AfpAdmServiceStart(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	AFPSTATUS	Status = AFP_ERR_NONE;

	DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
			("AfpAdmServiceStart entered\n"));

	do
	{
		// make sure serversetinfo has been called
		if ((AfpServerState != AFP_STATE_IDLE) ||
			(AfpServerName.Length == 0))
		{
			Status = AFPERR_InvalidServerState;
			break;
		}

		AfpServerState = AFP_STATE_START_PENDING;

        if (AfpServerBoundToAsp || AfpServerBoundToTcp)
        {
		    // Det the server status block
		    Status = AfpSetServerStatus();

		    if (!NT_SUCCESS(Status))
		    {
		        DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
					("AfpAdmServiceStart: AfpSetServerStatus returned %lx\n",Status));
    			AFPLOG_ERROR(AFPSRVMSG_SET_STATUS, Status, NULL, 0, NULL);
	    		break;
		    }

            if (AfpServerBoundToAsp)
            {
    		    // Register our name on this address
	    	    Status = AfpSpRegisterName(&AfpServerName, True);

		        if (!NT_SUCCESS(Status))
		        {
		            DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
					    ("AfpAdmServiceStart: AfpSpRegisterName returned %lx\n",Status));
			        break;
		        }
            }

    		// Enable listens now that we are ready for it.
	    	AfpSpEnableListens();

    		// Set the server start time
	    	AfpGetCurrentTimeInMacFormat((PAFPTIME)&AfpServerStatistics.stat_ServerStartTime);
        }

	    // server is ready to go
		AfpServerState = AFP_STATE_RUNNING;

	} while (False);

	if (!NT_SUCCESS(Status))
	{
		AfpServerState = AFP_STATE_IDLE;	// Set state back to idle so we can be stopped
	}
    else
    {
	    DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR, ("SFM Service started\n"));
    }

	return Status;
}


/***	AfpAdmServiceStop
 *
 *	This is the service stop code.
 */
AFPSTATUS
AfpAdmServiceStop(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	NTSTATUS			Status;
	AFP_SESSION_INFO	SessInfo;

	DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
			("AfpAdmServiceStop entered\n"));

	do
	{
		if ((AfpServerState != AFP_STATE_RUNNING) &&
			(AfpServerState != AFP_STATE_PAUSED)  &&
			(AfpServerState != AFP_STATE_IDLE))
		{
			Status = AFPERR_InvalidServerState;
			break;
		}

		AfpServerState = AFP_STATE_STOP_PENDING;

        if (AfpServerBoundToAsp)
        {
		    // First de-register our name from the network
		    DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
			    		("AfpAdmServiceStop: De-registering Name\n"));
		    AfpSpRegisterName(&AfpServerName, False);

            if (AfpTdiNotificationHandle)
            {
                Status = TdiDeregisterPnPHandlers(AfpTdiNotificationHandle);

                if (!NT_SUCCESS(Status))
                {
	                DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
			            ("AfpAdmServiceStop: TdiDeregisterNotificationHandler failed with %lx\n",Status));
                }

                AfpTdiNotificationHandle = NULL;
            }
            else
            {
	            DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
			        ("AfpAdmServiceStop: BoundToAsp but no Tdi handle!!\n"));
                ASSERT(0);
            }
        }

	    // Disable listens now that we are about to stop
	    AfpSpDisableListens();

		// De-register our shutdown notification
		IoUnregisterShutdownNotification(AfpDeviceObject);

		// Now walk the list of active sessions and kill them
		DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
					("AfpAdmServiceStop: Shutting down sessions\n"));

        KeClearEvent(&AfpStopConfirmEvent);

		SessInfo.afpsess_id = 0;	// Shutdown all sessions
		AfpAdmWSessionClose(&SessInfo, 0, NULL);

        Status = STATUS_TIMEOUT;

		// Wait for the sessions to complete, if there were active sessions
		if (AfpNumSessions > 0) do
		{
            if (AfpNumSessions == 0)
            {
                break;
            }

			Status = AfpIoWait(&AfpStopConfirmEvent, &FiveSecTimeOut);
			if (Status == STATUS_TIMEOUT)
			{
				DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
						("AfpAdmServiceStop: Timeout Waiting for %ld sessions to die, re-waiting\n",
						AfpNumSessions));
			}
		} while (Status == STATUS_TIMEOUT);

        // bring down the DSI-TCP interface
        DsiDestroyAdapter();

		DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
		    ("AfpAdmServiceStop: blocked, waiting for DsiDestroyAdapter to finish...\n"));

        // wait until DSI cleans up its interface with TCP
        AfpIoWait(&DsiShutdownEvent, NULL);

		DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
		    ("AfpAdmServiceStop: ..... DsiDestroyAdapter finished.\n"));

		DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
					("AfpAdmServiceStop: Stopping Volumes\n"));
                
        // Set flag to indicate "net stop macfile" occured
        // The volume will be re-indexed on startup
        fAfpAdminStop = TRUE;

		// Now tell each of the volume scavengers to shut-down
		AfpVolumeStopAllVolumes();

		DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
					("AfpAdmServiceStop: Stopping Security threads\n"));

		// Release all security utility threads.
		AfpTerminateSecurityUtility();

#ifdef	OPTIMIZE_GUEST_LOGONS
		// Close the 'cached' Guest token and security descriptor
		if (AfpGuestToken != NULL)
		{
			NtClose(AfpGuestToken);
			AfpGuestToken = NULL;
#ifndef	INHERIT_DIRECTORY_PERMS
			if (AfpGuestSecDesc->Dacl != NULL)
				AfpFreeMemory(AfpGuestSecDesc->Dacl);
			AfpFreeMemory(AfpGuestSecDesc);
			AfpGuestSecDesc = NULL;
#endif
		}
#endif	

		DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
					("AfpAdmServiceStop: All Done\n"));

		// Now shutdown the appletalk socket
		DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_INFO,
						("AfpAdmServerStop: Closing appletalk socket\n"));

        if (AfpServerBoundToAsp)
        {
		    AfpSpCloseAddress();
        }
        else
        {
		    DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_ERR,
						("AfpAdmServerStop: No binding, so didn't close appletalk socket\n"));
        }

		// Make sure we do not have resource leaks
		ASSERT(AfpServerStatistics.stat_CurrentFileLocks == 0);
		ASSERT(AfpServerStatistics.stat_CurrentFilesOpen == 0);
		ASSERT(AfpServerStatistics.stat_CurrentSessions == 0);
		ASSERT(AfpServerStatistics.stat_CurrentInternalOpens == 0);
#ifdef	PROFILING
		// Make sure we do not have resource leaks
		ASSERT(AfpServerProfile->perf_cAllocatedIrps == 0);
		ASSERT(AfpServerProfile->perf_cAllocatedMdls == 0);
#endif

        ASSERT(IsListEmpty(&AfpDebugDelAllocHead));
        ASSERT(AfpDbgMdlsAlloced == 0);
        ASSERT(AfpDbgIrpsAlloced == 0);

#if DBG
        if ((AfpReadCMAlloced != 0) || (AfpWriteCMAlloced != 0))
        {
			DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
				("WARNING: AfpReadCMAlloced = %ld, AfpWriteCMAlloced %ld\n",
                AfpReadCMAlloced, AfpWriteCMAlloced));
        }
#endif

		AfpServerState = AFP_STATE_STOPPED;
	} while (False);

	return STATUS_SUCCESS;
}


/***	AfpAdmServicePause
 *
 *	Pause the server. Disconnect all outstanding sessions.
 */
AFPSTATUS
AfpAdmServicePause(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
			("AfpAdmServicePause entered\n"));

	// make sure we are in the running state
	if (AfpServerState != AFP_STATE_RUNNING)
	{
		return AFPERR_InvalidServerState;
	}

	AfpServerState = AFP_STATE_PAUSE_PENDING;

    if (AfpServerBoundToAsp)
    {
	    // Deregister our name on this address. Should we do this at all ? What
	    // if we cannot re-register ourselves on CONTINUE ?
	    AfpSpRegisterName(&AfpServerName, False);
    }

	// Disable listens now that we are paused
	AfpSpDisableListens();

	AfpServerState = AFP_STATE_PAUSED;


	return STATUS_SUCCESS;
}


/*** 	AfpAdmServiceContinue
 *
 *	Continue (release pause) the server. Just re-post all the listens that were
 *	disconnected when the server was paused.
 */
AFPSTATUS
AfpAdmServiceContinue(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	AFPSTATUS	Status;

	DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
			("AfpAdmServiceContinue entered\n"));

	// make sure we are in the paused state
	if (AfpServerState != AFP_STATE_PAUSED)
	{
		return AFPERR_InvalidServerState;
	}

	AfpServerState = AFP_STATE_RUNNING;

	// Enable listens now that we are ready for it.
	AfpSpEnableListens();

    if (AfpServerBoundToAsp)
    {
	    // Reregister our name on this address
	    Status = AfpSpRegisterName(&AfpServerName, True);

	    if (!NT_SUCCESS(Status))
        {
	        DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
			    ("AfpAdmServiceContinue: AfpSpRegisterName fails %lx\n",Status));
    		return AFPERR_InvalidServerName;
        }
    }

	return STATUS_SUCCESS;
}


/***	AfpAdmServerGetInfo
 *
 *	Return the current setting of the server parameters.
 *
 *	NOTE: The following fields are not returned:
 *		PagedLimit
 *		NonPagedLimit
 *		CodePage
 */
AFPSTATUS
AfpAdmServerGetInfo(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	PAFP_SERVER_INFO	pSrvrInfo = (PAFP_SERVER_INFO)OutBuf;
	UNICODE_STRING		us;

	if ((DWORD)OutBufLen < (sizeof(AFP_SERVER_INFO) +
					 (AfpServerName.Length + 1)*sizeof(WCHAR) +
					 AfpLoginMsgU.MaximumLength))
		return AFPERR_BufferSize;

	pSrvrInfo->afpsrv_max_sessions = AfpServerMaxSessions;
	pSrvrInfo->afpsrv_options = AfpServerOptions;
	pSrvrInfo->afpsrv_name = NULL;
	pSrvrInfo->afpsrv_login_msg = NULL;

	if (AfpServerName.Length > 0)
	{
		pSrvrInfo->afpsrv_name = us.Buffer =
			(LPWSTR)((PBYTE)pSrvrInfo + sizeof(AFP_SERVER_INFO));
		us.MaximumLength = (AfpServerName.Length + 1) * sizeof(WCHAR);
		AfpConvertStringToUnicode(&AfpServerName, &us);
		POINTER_TO_OFFSET(pSrvrInfo->afpsrv_name, pSrvrInfo);
	}


	if ((AfpLoginMsgU.Length) > 0)
	{
		pSrvrInfo->afpsrv_login_msg = (PWCHAR)((PBYTE)pSrvrInfo + sizeof(AFP_SERVER_INFO) +
									((AfpServerName.Length + 1) * sizeof(WCHAR)));

		RtlCopyMemory(pSrvrInfo->afpsrv_login_msg,
					  AfpLoginMsgU.Buffer,
					  AfpLoginMsgU.Length);
		pSrvrInfo->afpsrv_login_msg[AfpLoginMsgU.Length/sizeof(WCHAR)] = UNICODE_NULL;
		POINTER_TO_OFFSET(pSrvrInfo->afpsrv_login_msg, pSrvrInfo);
	}

	return AFP_ERR_NONE;
}


/***	AfpAdmGetStatistics
 *
 *	Return a copy of the server global statistics (NT 3.1 only) in the output buffer
 *
 *	LOCKS:	AfpStatisticsLock (SPIN)
 */
AFPSTATUS
AfpAdmGetStatistics(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	KIRQL		OldIrql;
	NTSTATUS	Status = STATUS_SUCCESS;
	AFPTIME		TimeNow;

	InBuf;

	DBGPRINT(DBG_COMP_ADMINAPI_STAT, DBG_LEVEL_INFO,
			("AfpAdmGetStatistics entered\n"));

	if (OutBufLen >= sizeof(AFP_STATISTICS_INFO))
	{
		ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);
		RtlCopyMemory(OutBuf, &AfpServerStatistics, sizeof(AFP_STATISTICS_INFO));
		RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

		AfpGetCurrentTimeInMacFormat(&TimeNow);
		((PAFP_STATISTICS_INFO)OutBuf)->stat_ServerStartTime =
				TimeNow - ((PAFP_STATISTICS_INFO)OutBuf)->stat_ServerStartTime;
		((PAFP_STATISTICS_INFO)OutBuf)->stat_TimeStamp =
				TimeNow - ((PAFP_STATISTICS_INFO)OutBuf)->stat_TimeStamp;
	}
	else
	{
		Status = STATUS_BUFFER_TOO_SMALL;
	}
	return Status;
}


/***	AfpAdmGetStatisticsEx
 *
 *	Return a copy of the server global statistics in the output buffer
 *
 *	LOCKS:	AfpStatisticsLock (SPIN)
 */
AFPSTATUS
AfpAdmGetStatisticsEx(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	KIRQL		OldIrql;
	NTSTATUS	Status = STATUS_SUCCESS;
	AFPTIME		TimeNow;

	InBuf;

	DBGPRINT(DBG_COMP_ADMINAPI_STAT, DBG_LEVEL_INFO,
			("AfpAdmGetStatistics entered\n"));

	if (OutBufLen >= sizeof(AFP_STATISTICS_INFO_EX))
	{
		ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);
		RtlCopyMemory(OutBuf, &AfpServerStatistics, sizeof(AFP_STATISTICS_INFO_EX));

		RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

		AfpGetCurrentTimeInMacFormat(&TimeNow);
		((PAFP_STATISTICS_INFO_EX)OutBuf)->stat_ServerStartTime =
				TimeNow - ((PAFP_STATISTICS_INFO_EX)OutBuf)->stat_ServerStartTime;
		((PAFP_STATISTICS_INFO_EX)OutBuf)->stat_TimeStamp =
				TimeNow - ((PAFP_STATISTICS_INFO_EX)OutBuf)->stat_TimeStamp;
	}
	else
	{
		Status = STATUS_BUFFER_TOO_SMALL;
	}
	return Status;
}


/***	AfpAdmClearStatistics
 *
 *	Reset the server global statistics to their respective initial values
 */
AFPSTATUS
AfpAdmClearStatistics(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
    KIRQL   OldIrql;

	DBGPRINT(DBG_COMP_ADMINAPI_STAT, DBG_LEVEL_INFO,
			("AfpAdmClearStatistics entered\n"));

	ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);
	AfpServerStatistics.stat_Errors = 0;
	RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

	return STATUS_SUCCESS;
}


/***	AfpAdmGetProfCounters
 *
 *	Return a copy of the server profile counters.
 *
 *	LOCKS:	AfpStatisticsLock (SPIN)
 */
AFPSTATUS
AfpAdmGetProfCounters(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	NTSTATUS	Status = STATUS_SUCCESS;
#ifdef	PROFILING
	KIRQL		OldIrql;

	DBGPRINT(DBG_COMP_ADMINAPI_STAT, DBG_LEVEL_INFO,
			("AfpAdmGetProfCounters entered\n"));

	if (OutBufLen >= sizeof(AFP_PROFILE_INFO))
	{
		ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);
		RtlCopyMemory(OutBuf, AfpServerProfile, sizeof(AFP_PROFILE_INFO));
		RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);
	}
	else
	{
		Status = STATUS_BUFFER_TOO_SMALL;
	}
#else
	RtlZeroMemory(OutBuf, sizeof(AFP_PROFILE_INFO));
#endif
	return Status;
}


/***	AfpAdmClearProfCounters
 *
 *	Reset the server profile counters
 */
AFPSTATUS
AfpAdmClearProfCounters(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	InBuf;
	OutBufLen;
	OutBuf;

	// Currently a NOP
	PAGED_CODE( );

	DBGPRINT(DBG_COMP_ADMINAPI_STAT, DBG_LEVEL_INFO,
			("AfpAdmClearProfCounters entered\n"));

	return STATUS_SUCCESS;
}


/***	AfpAdmServerSetParms
 *
 *	This routine sets various server globals with data supplied by the admin.
 *	The following server globals are set by this routine:
 *
 *	- List of trusted domains and their Posix offsets.
 */
AFPSTATUS
AfpAdmServerSetParms(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	PAFP_SID_OFFSET_DESC	pSrvrParms = (PAFP_SID_OFFSET_DESC)InBuf;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
			("AfpAdmServerSetParms entered\n"));

	return (AfpInitSidOffsets(pSrvrParms->CountOfSidOffsets,
							  pSrvrParms->SidOffsetPairs));
}


/***	AfpAdmServerAddEtc
 *
 *	This routine adds a set of Extension/Type-Creator mappings to the global
 *	list. This list can be changed while the server is in any state. It is
 *	an error to add the default type creator mapping. The default mapping
 *	can only be modified with AfpAdmServerSetEtc, never added nor deleted.
 *	It is an error to try to add zero entries.
 *
 *	This routine will complete in the context of the caller, and not be queued
 *	to a worker thread.
 *
 *	LOCKS: AfpEtcMapLock (SWMR, Exclusive)
**/
AFPSTATUS
AfpAdmServerAddEtc(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	LONG			NumToAdd = ((PSRVETCPKT)InBuf)->retc_NumEtcMaps;
	PETCMAPINFO2	pEtcList = ((PSRVETCPKT)InBuf)->retc_EtcMaps;
	PETCMAPINFO		ptemptable,pnextfree;
	LONG			numfree, newtablesize, nextfreehint, i;
	UNICODE_STRING  udefaultext,ulookupext;
	AFPSTATUS		Status = AFPERR_InvalidParms;
	BOOLEAN			UnlockSwmr = False;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
			("AfpAdmServerAddEtc entered\n"));

	if (NumToAdd != 0) do
	{
		//
		// make sure all the entries passed have valid extensions. We want to
		// add all or nothing, so we have to validate all of the data first thing.
		//
		RtlInitUnicodeString(&udefaultext, AFP_DEF_EXTENSION_W);
		for (i = 0; i < NumToAdd; i++)
		{
			if (!afpIsValidExtension(pEtcList[i].etc_extension))
			{
				break;
			}
			RtlInitUnicodeString(&ulookupext,pEtcList[i].etc_extension);
			if (RtlEqualUnicodeString(&udefaultext, &ulookupext,True))
			{
				break;
			}
		}

		if (i != NumToAdd)
			break;

		AfpSwmrAcquireExclusive(&AfpEtcMapLock);
		UnlockSwmr = True;

		if ((NumToAdd + AfpEtcMapCount) > AFP_MAX_ETCMAP_ENTRIES)
		{
			Status = AFPERR_TooManyEtcMaps;
			break;
		}

		if ((numfree = AfpEtcMapsSize - AfpEtcMapCount) < NumToAdd)
		{
			ASSERT(numfree >= 0);
			//
			// we need to add some room to the table
			//
			newtablesize = AfpEtcMapsSize +
						   ((NumToAdd / AFP_MAX_FREE_ETCMAP_ENTRIES) + 1) * AFP_MAX_FREE_ETCMAP_ENTRIES;
			if ((ptemptable = (PETCMAPINFO)AfpAllocZeroedPagedMemory(newtablesize * sizeof(ETCMAPINFO))) == NULL)
			{
				Status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			if (AfpEtcMaps != NULL)
			{
				RtlCopyMemory(ptemptable, AfpEtcMaps, AfpEtcMapsSize * sizeof(ETCMAPINFO));
				AfpFreeMemory(AfpEtcMaps);
			}
			AfpEtcMaps = ptemptable;
			AfpEtcMapsSize = newtablesize;
		}

		nextfreehint = 0;
		for (i = 0; i < NumToAdd; i++)
		{
			pnextfree = afpGetNextFreeEtcMapEntry(&nextfreehint);
			ASSERT(pnextfree != NULL);
			afpCopyMapInfo2ToMapInfo(pnextfree, &pEtcList[i]);
			AfpEtcMapCount ++;
		}

		Status = STATUS_SUCCESS;

		DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
				("AfpAdmServerAddEtc successful\n"));
	} while (False);

	if (UnlockSwmr)
		AfpSwmrRelease(&AfpEtcMapLock);

	return Status;
}


/***	AfpAdmServerSetEtc
 *
 *	This routine changes an existing entry in the server global
 *	Extension/Type-Creator mapping list for a given file extension, or the
 *	default type/creator mapping.
 *	An entry can be changed while the server is in any state.
 *
 *	This routine will complete in the context of the caller, and not be queued
 *	to a worker thread.
 *
 *	LOCKS: AfpEtcMapLock (SWMR, Exclusive)
 */
AFPSTATUS
AfpAdmServerSetEtc(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	// ignore the parmnum field
	PETCMAPINFO2	pEtc = (PETCMAPINFO2)((PBYTE)InBuf+sizeof(SETINFOREQPKT));
	PETCMAPINFO		petcentry;
	ETCMAPINFO		TmpEtcEntry;
	AFPSTATUS		rc = STATUS_SUCCESS;
	BOOLEAN			setdefaultetc;
	UNICODE_STRING	ulookupext,udefaultext;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
			("AfpAdmServerSetEtc entered\n"));

	if (!afpIsValidExtension(pEtc->etc_extension))
	{
		return AFPERR_InvalidExtension;
	}

	RtlInitUnicodeString(&udefaultext,AFP_DEF_EXTENSION_W);
	RtlInitUnicodeString(&ulookupext,pEtc->etc_extension);
	setdefaultetc = RtlEqualUnicodeString(&udefaultext, &ulookupext,True);

	if (setdefaultetc)
	{
		petcentry = &AfpDefaultEtcMap;
	}

	AfpSwmrAcquireExclusive(&AfpEtcMapLock);

	afpCopyMapInfo2ToMapInfo(&TmpEtcEntry,pEtc);

	if (!setdefaultetc)
	{
		petcentry = AfpLookupEtcMapEntry(TmpEtcEntry.etc_extension);
		if (petcentry == NULL)
		{
			AfpSwmrRelease(&AfpEtcMapLock);
			return AFPERR_InvalidParms;
		}
	}

	RtlCopyMemory(petcentry, &TmpEtcEntry, sizeof(ETCMAPINFO));

	AfpSwmrRelease(&AfpEtcMapLock);

	return rc;
}


/***	AfpAdmServerDeleteEtc
 *
 *	This routine deletes the server global Extension/Type-Creator mapping entry
 *	for a given extension. The default type creator mapping can never be
 *	deleted (since it is not kept in the table).
 *
 *	This routine will complete in the context of the caller, and not be queued
 *	to a worker thread.
 *
 *	LOCKS: AfpEtcMapLock (SWMR, Exclusive)
 *
 */
AFPSTATUS
AfpAdmServerDeleteEtc(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	PETCMAPINFO2	petc = (PETCMAPINFO2)InBuf;
	PETCMAPINFO		petcentry;
	ETCMAPINFO		TmpEtcEntry;
	AFPSTATUS		rc = STATUS_SUCCESS;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
			("AfpAdmServerDeleteEtc entered\n"));

	if (!afpIsValidExtension(petc->etc_extension))
	{
		return AFPERR_InvalidParms;
	}

	AfpSwmrAcquireExclusive(&AfpEtcMapLock);

	afpCopyMapInfo2ToMapInfo(&TmpEtcEntry,petc);

	petcentry = AfpLookupEtcMapEntry(TmpEtcEntry.etc_extension);
	if (petcentry != NULL)
	{
		afpEtcMapDelete(petcentry);
	}
	else
	{
		rc = AFPERR_InvalidParms;
	}

	AfpSwmrRelease(&AfpEtcMapLock);

	return rc;
}


// Mapping icon types to their sizes
LOCAL	DWORD	afpIconSizeTable[MAX_ICONTYPE] =
	{
	ICONSIZE_ICN ,
	ICONSIZE_ICN ,
	ICONSIZE_ICN4,
	ICONSIZE_ICN8,
	ICONSIZE_ICS ,
	ICONSIZE_ICS4,
	ICONSIZE_ICS8
	};


/***	AfpAdmServerAddIcon
 *
 *	This routine adds an icon of a given type, creator and icon type to the server
 *	desktop. This supplements the volume desktop of every volume. An icon type
 *	of 0 special cases to the server icon.
 *
 *	This routine will complete in the context of the caller, and not be queued
 *	to a worker thread.
 *
 */
AFPSTATUS
AfpAdmServerAddIcon(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	DWORD			icontypeafp;
	PSRVICONINFO	pIcon = (PSRVICONINFO)InBuf;

	DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
			("AfpAdmServerAddIcon entered\n"));

	if (pIcon->icon_icontype > MAX_ICONTYPE ||
		afpIconSizeTable[pIcon->icon_icontype] != pIcon->icon_length)
	{
		return AFPERR_InvalidParms;
	}

	//
	// check for the server icon (type is zero)
	//
	if (afpIsServerIcon(pIcon))
	{
		// Allocate memory for server icon
		if ((AfpServerIcon == NULL) &&
			(AfpServerIcon = AfpAllocNonPagedMemory(ICONSIZE_ICN)) == NULL)
			return STATUS_INSUFFICIENT_RESOURCES;

		RtlCopyMemory(AfpServerIcon,
					  (PBYTE)pIcon+sizeof(SRVICONINFO),
					  ICONSIZE_ICN);
		return((AfpServerState != AFP_STATE_IDLE) ?
				AfpSetServerStatus() : STATUS_SUCCESS);
	}
	else
	{
		icontypeafp = 1 << (pIcon->icon_icontype-1);
		return(AfpAddIconToGlobalList(*(PDWORD)(&pIcon->icon_type),
									  *(PDWORD)(&pIcon->icon_creator),
									  icontypeafp,
									  pIcon->icon_length,
									  (PBYTE)pIcon+sizeof(SRVICONINFO)));
	}
}


/***	AfpAdmVolumeAdd
 *
 *	This routine adds a volume to the server global list of volumes headed by
 *	AfpVolumeList. The volume descriptor is created and initialized. The ID
 *	index is read in (or created). The same is true with the desktop.
 *
 *	It is assumed that all volume info fields are set in the input buffer
 *
 *	ADMIN	QUEUE WORKER: AfpAdmWVolumeAdd
 *
 */
AFPSTATUS
AfpAdmVolumeAdd(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	UNICODE_STRING	uname,upwd;
	ULONG			ansinamelen, ansipwdlen;
	PAFP_VOLUME_INFO pVolInfo = (PAFP_VOLUME_INFO)InBuf;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
			("AfpAdmVolumeAdd entered\n"));

	//
	// validate the input data
	//

	RtlInitUnicodeString(&uname, pVolInfo->afpvol_name);
	ansinamelen = RtlUnicodeStringToAnsiSize(&uname) - 1;

	//
	// check length of volume name and that no ":" exist in the name
	//
	if ((ansinamelen > AFP_VOLNAME_LEN) || (ansinamelen == 0) ||
		(wcschr(uname.Buffer, L':') != NULL))
	{
		return AFPERR_InvalidVolumeName;
	}

	if (pVolInfo->afpvol_props_mask & ~AFP_VOLUME_ALL)
		return AFPERR_InvalidParms;

	if ((pVolInfo->afpvol_max_uses == 0) ||
		(pVolInfo->afpvol_max_uses > AFP_VOLUME_UNLIMITED_USES))
	{
		return AFPERR_InvalidParms_MaxVolUses;
	}

	RtlInitUnicodeString(&upwd, pVolInfo->afpvol_password);
	ansipwdlen = RtlUnicodeStringToAnsiSize(&upwd) - 1;
	if (ansipwdlen > AFP_VOLPASS_LEN)
	{
		return AFPERR_InvalidPassword;
	}
	else if (ansipwdlen > 0)
	{
		pVolInfo->afpvol_props_mask |= AFP_VOLUME_HASPASSWORD;
	}

	//
	// Force this to be queued up to a worker thread.
	//
	return STATUS_PENDING;
}


/***	AfpAdmVolumeSetInfo
 *
 *	The volume parameters that can be changed by this call are the volume
 *	password, max_uses and volume properties mask.
 *
 *	LOCKS: AfpVolumeListLock (SPIN), vds_VolLock (SPIN)
 *	LOCK ORDER: vds_VolLock after AfpVolumeListLock
 *
 */
AFPSTATUS
AfpAdmVolumeSetInfo(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	WCHAR			upcasebuf[AFP_VOLNAME_LEN+1];
	UNICODE_STRING	upwd,uname, upcasename;
	BYTE			apwdbuf[AFP_VOLPASS_LEN+1];
	ANSI_STRING		apwd;
	PVOLDESC		pVolDesc;
	AFPSTATUS		status;
	KIRQL			OldIrql;
	DWORD			parmflags = ((PSETINFOREQPKT)InBuf)->sirqp_parmnum;
	PAFP_VOLUME_INFO pVolInfo = (PAFP_VOLUME_INFO)((PCHAR)InBuf+sizeof(SETINFOREQPKT));

	DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
			("AfpAdmVolumeSetInfo entered\n"));

	AfpSetEmptyAnsiString(&apwd, AFP_VOLPASS_LEN+1, apwdbuf);
	AfpSetEmptyUnicodeString(&upcasename, sizeof(upcasebuf), upcasebuf);
	if ((parmflags & ~AFP_VOL_PARMNUM_ALL) ||
		((parmflags & AFP_VOL_PARMNUM_PROPSMASK) &&
		 (pVolInfo->afpvol_props_mask & ~AFP_VOLUME_ALL)) ||
		((parmflags & AFP_VOL_PARMNUM_MAXUSES) &&
		 ((pVolInfo->afpvol_max_uses == 0) ||
		  (pVolInfo->afpvol_max_uses > AFP_VOLUME_UNLIMITED_USES))))
	{
		return AFPERR_InvalidParms;
	}

	if (parmflags & AFP_VOL_PARMNUM_PASSWORD)
	{
		RtlInitUnicodeString(&upwd,pVolInfo->afpvol_password);

		if ((!NT_SUCCESS(AfpConvertStringToAnsi(&upwd, &apwd))) ||
			(apwd.Length > AFP_VOLPASS_LEN))
		{
			return AFPERR_InvalidPassword;
		}
	}

	RtlInitUnicodeString(&uname, pVolInfo->afpvol_name);
	if (!NT_SUCCESS(RtlUpcaseUnicodeString(&upcasename, &uname, False)))
	{
		return AFPERR_InvalidVolumeName;
	}

	// Will reference the volume if successful
	if ((pVolDesc = AfpVolumeReferenceByUpCaseName(&upcasename)) == NULL)
	{
		return AFPERR_VolumeNonExist;
	}

	// Acquire the lock for the volume itself (we already have a reference)

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	do
	{
		status = STATUS_SUCCESS;

		if (parmflags & AFP_VOL_PARMNUM_PROPSMASK)
		{
			//
			// set or clear the desired volume property bits
			//
			pVolDesc->vds_Flags = (USHORT)((pVolDesc->vds_Flags & ~AFP_VOLUME_ALL) |
											(pVolInfo->afpvol_props_mask));
		}

		if (parmflags & AFP_VOL_PARMNUM_PASSWORD)
		{
			if (apwd.Length == 0)
			{
				pVolDesc->vds_MacPassword.Length = 0;
				pVolDesc->vds_Flags &= ~AFP_VOLUME_HASPASSWORD;
				pVolDesc->vds_MacPassword.Length = 0;
			}
			else
			{
				RtlZeroMemory(pVolDesc->vds_MacPassword.Buffer, AFP_VOLPASS_LEN);
				AfpCopyAnsiString(&pVolDesc->vds_MacPassword, &apwd);
				pVolDesc->vds_MacPassword.Length = AFP_VOLPASS_LEN;
				pVolDesc->vds_Flags |= AFP_VOLUME_HASPASSWORD;
			}
		}

		if (parmflags & AFP_VOL_PARMNUM_MAXUSES)
			pVolDesc->vds_MaxUses = pVolInfo->afpvol_max_uses;

	} while (False);
	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock,OldIrql);
	AfpVolumeDereference(pVolDesc);

	return status;
}


/***	AfpAdmVolumeGetInfo
 *
 *
 *	LOCKS: AfpVolumeListLock (SPIN), vds_VolLock (SPIN)
 *	LOCK ORDER: vds_VolLock after AfpVolumeListLock
 */
AFPSTATUS
AfpAdmVolumeGetInfo(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	PVOLDESC			pVolDesc;
	AFPSTATUS			Status;
	KIRQL				OldIrql;
	PCHAR				pCurStr;
	WCHAR				upcasebuf[AFP_VOLNAME_LEN+1];
	UNICODE_STRING		uvolpass, uname, upcasename;
	PAFP_VOLUME_INFO	pVolInfo = (PAFP_VOLUME_INFO)OutBuf;
	BOOLEAN				copypassword = False;
	ANSI_STRING			avolpass;
	CHAR				avolpassbuf[AFP_VOLPASS_LEN + 1];
	USHORT				extrabytes;

	DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
			("AfpAdmVolumeGetInfo entered\n"));

	AfpSetEmptyUnicodeString(&upcasename, sizeof(upcasebuf), upcasebuf);
	RtlInitUnicodeString(&uname, ((PAFP_VOLUME_INFO)InBuf)->afpvol_name);
	if (!NT_SUCCESS(RtlUpcaseUnicodeString(&upcasename, &uname, False)))
	{
		return AFPERR_InvalidVolumeName;
	}

	// Will reference the volume if successful
	if ((pVolDesc = AfpVolumeReferenceByUpCaseName(&upcasename)) == NULL)
	{
		return AFPERR_VolumeNonExist;
	}

	// Acquire the lock for the volume itself

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	do
	{
		if ((OutBufLen - sizeof(AFP_VOLUME_INFO)) <
				(pVolDesc->vds_Name.Length + sizeof(UNICODE_NULL) +
				 (pVolDesc->vds_MacPassword.Length + 1) * sizeof(WCHAR) +
				 pVolDesc->vds_Path.Length +
				 (extrabytes =
			(pVolDesc->vds_Path.Buffer[(pVolDesc->vds_Path.Length / sizeof(WCHAR)) - 2] == L':' ?
					sizeof(WCHAR) : 0)) + sizeof(UNICODE_NULL)))
		{
			Status = AFPERR_BufferSize;
			break;
		}

		Status = STATUS_SUCCESS;

		pVolInfo->afpvol_max_uses = pVolDesc->vds_MaxUses;
		pVolInfo->afpvol_props_mask = (pVolDesc->vds_Flags & AFP_VOLUME_ALL_DOWNLEVEL);
		pVolInfo->afpvol_id = pVolDesc->vds_VolId;
		pVolInfo->afpvol_curr_uses = pVolDesc->vds_UseCount;

		pCurStr = (PBYTE)OutBuf + sizeof(AFP_VOLUME_INFO);
		RtlCopyMemory(pCurStr, pVolDesc->vds_Name.Buffer,
												pVolDesc->vds_Name.Length);
		*(LPWSTR)(pCurStr + pVolDesc->vds_Name.Length) = UNICODE_NULL;
		pVolInfo->afpvol_name = (LPWSTR)pCurStr;
		POINTER_TO_OFFSET(pVolInfo->afpvol_name,pVolInfo);

		pCurStr += pVolDesc->vds_Name.Length + sizeof(WCHAR);
		RtlCopyMemory(pCurStr, pVolDesc->vds_Path.Buffer,
												pVolDesc->vds_Path.Length);
		// replace trailing backslash of path with a unicode null unless the
		// next to last char is ':', then keep it and add a trailing null
		*(LPWSTR)(pCurStr + pVolDesc->vds_Path.Length + extrabytes - sizeof(WCHAR)) = UNICODE_NULL;
		pVolInfo->afpvol_path = (LPWSTR)pCurStr;
		POINTER_TO_OFFSET(pVolInfo->afpvol_path,pVolInfo);

		pCurStr += pVolDesc->vds_Path.Length + extrabytes;
		copypassword = True;
		uvolpass.Buffer = (LPWSTR)pCurStr;
		uvolpass.MaximumLength = (pVolDesc->vds_MacPassword.Length + 1) * sizeof(WCHAR);
		AfpSetEmptyAnsiString(&avolpass, sizeof(avolpassbuf), avolpassbuf);
		AfpCopyAnsiString(&avolpass, &pVolDesc->vds_MacPassword);
	} while(False);

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock,OldIrql);

	AfpVolumeDereference(pVolDesc);

	if (copypassword == True)
	{
		AfpConvertStringToUnicode(&avolpass, &uvolpass);
		*(LPWSTR)(pCurStr + uvolpass.Length) = UNICODE_NULL;
		pVolInfo->afpvol_password = (LPWSTR)pCurStr;
		POINTER_TO_OFFSET(pVolInfo->afpvol_password,pVolInfo);
	}
	return Status;
}


/***	AfpAdmVolumeEnum
 *
 *	Enumerate the list of configured volumes.
 *
 *	LOCKS: AfpVolumeListLock (SPIN)
 *
 */
AFPSTATUS
AfpAdmVolumeEnum(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	LONG				startindex = (LONG)(((PENUMREQPKT)InBuf)->erqp_Index);
	PENUMRESPPKT		pErsp = (PENUMRESPPKT)OutBuf;
	PAFP_VOLUME_INFO	pnextvol = (PAFP_VOLUME_INFO)((PBYTE)OutBuf+sizeof(ENUMRESPPKT));
	PBYTE				pCurStr = (PBYTE)OutBuf+OutBufLen; // 1 past eob
	KIRQL				OldIrql;
	AFPSTATUS			status = STATUS_SUCCESS;
	PVOLDESC			pVolDesc;
	LONG				bytesleft, curvolindex, nextvollen, deadvolumes = 0, extrabytes;

	if (startindex == 0)
	{
		startindex ++;
	}
	else if (startindex < 0)
	{
		return AFPERR_InvalidParms;
	}

	pErsp->ersp_cInBuf = 0;
	pErsp->ersp_hResume = 1;

	ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

	if (startindex > afpLargestVolIdInUse)
	{
		RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);
		if (pErsp->ersp_cTotEnts != 0)
		{
			status = AFPERR_InvalidParms;
		}
		return status;
	}

	curvolindex = 1;
	for (pVolDesc = AfpVolumeList;
		 pVolDesc != NULL;
		 curvolindex++, pVolDesc = pVolDesc->vds_Next)
	{
		ASSERT(pVolDesc != NULL);

		ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);

		if (pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED | VOLUME_INTRANSITION))
		{
			deadvolumes ++;
			RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);
			continue;
		}

		if (curvolindex < startindex)
		{
			RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);
			continue;
		}

		bytesleft = (LONG)((PBYTE)pCurStr - (PBYTE)pnextvol);

		nextvollen = sizeof(AFP_VOLUME_INFO) +
					 pVolDesc->vds_Name.MaximumLength +
					 // replace trailing backslash with a null when copying
					 // unless the next to last char is ':', then keep it and
					 // add a trailing null
					 pVolDesc->vds_Path.Length + (extrabytes =
					(pVolDesc->vds_Path.Buffer[(pVolDesc->vds_Path.Length / sizeof(WCHAR)) - 2] == L':' ?
											sizeof(WCHAR) : 0));


		if (nextvollen > bytesleft)
		{
			if (pErsp->ersp_cInBuf == 0)
				status = AFPERR_BufferSize;
			RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);
			break;
		}

		pnextvol->afpvol_max_uses = pVolDesc->vds_MaxUses;
		pnextvol->afpvol_props_mask = (pVolDesc->vds_Flags & AFP_VOLUME_ALL_DOWNLEVEL);
		pnextvol->afpvol_id = pVolDesc->vds_VolId;
		pnextvol->afpvol_curr_uses = pVolDesc->vds_UseCount;

		pCurStr -= pVolDesc->vds_Path.Length + extrabytes;
		RtlCopyMemory(pCurStr,pVolDesc->vds_Path.Buffer,
						pVolDesc->vds_Path.Length);
		*(LPWSTR)(pCurStr + pVolDesc->vds_Path.Length + extrabytes - sizeof(WCHAR)) = L'\0';
		pnextvol->afpvol_path = (LPWSTR)pCurStr;
		POINTER_TO_OFFSET(pnextvol->afpvol_path,pnextvol);

		pnextvol->afpvol_password = NULL;

		pCurStr -= pVolDesc->vds_Name.MaximumLength;
		RtlCopyMemory(pCurStr,pVolDesc->vds_Name.Buffer,
						pVolDesc->vds_Name.MaximumLength);

		pnextvol->afpvol_name = (LPWSTR)pCurStr;
		POINTER_TO_OFFSET(pnextvol->afpvol_name,pnextvol);

		pnextvol++;
		pErsp->ersp_cInBuf++;
		RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);
	}

	pErsp->ersp_cTotEnts = AfpVolCount - deadvolumes;

	RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

	if (curvolindex <= (LONG)pErsp->ersp_cTotEnts)
	{
		status = STATUS_MORE_ENTRIES;
		pErsp->ersp_hResume = curvolindex;
	}
	else
		pErsp->ersp_hResume = 1;

	return status;
}


/***	AfpAdmSessionEnum
 *
 *	Enumerate the list of active sessions. This is a linear list rooted
 *	at AfpSessionList and protected by AfpSdaLock. This list is potentially
 *	pretty long (Unlimited # of sessions with the super ASP stuff).
 *
 *	The resume handle returned is the session id of the last session returned.
 *	Session Id of 0 implies restart scan.
 *
 *	The output buffer is constructed as follows.
 *
 *		+---------------------------+
 *		|	Session_Info_1			|
 *		+---------------------------+
 *		|	Session_Info_2			|
 *		+---------------------------+
 *		.							.
 *		.							.
 *		+---------------------------+
 *		|	Session_Info_n			|
 *		+---------------------------+
 *		.							.
 *		.							.
 *		+---------------------------+
 *		|							|
 *		|...........................|
 *		|			Strings			|
 *		|...........................|
 *		|							|
 *		|							|
 *		+---------------------------+
 *
 *	LOCKS:		AfpSdaLock (SPIN)
 */
AFPSTATUS
AfpAdmSessionEnum(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	PENUMRESPPKT		pErsp = (PENUMRESPPKT)OutBuf;
	PAFP_SESSION_INFO	pSessInfo = (PAFP_SESSION_INFO)((PBYTE)OutBuf+sizeof(ENUMRESPPKT));
	PSDA				pSda;
	PBYTE				pString = (PBYTE)OutBuf+OutBufLen; // 1 past eob
	DWORD				StartId = (LONG)(((PENUMREQPKT)InBuf)->erqp_Index);
	DWORD				DeadSessions = 0;
	KIRQL				OldIrql;
	AFPSTATUS			Status = AFP_ERR_NONE;

	DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
			("AfpAdmSessionEnum entered\n"));

	if (OutBufLen < (sizeof(ENUMRESPPKT) + sizeof(PAFP_SESSION_INFO)))
		return AFPERR_BufferSize;

	if (StartId == 0)
		StartId = MAXULONG;

	// Initialize the response packet header
	pErsp->ersp_cInBuf = 0;
	pErsp->ersp_hResume = 0;

	ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

	for (pSda = AfpSessionList; pSda != NULL; pSda = pSda->sda_Next)
	{
		LONG	BytesLeft;
		LONG	BytesNeeded;

		// Skip entries that are marked to die
		if ((pSda->sda_Flags & SDA_CLOSING) ||
			!(pSda->sda_Flags & SDA_USER_LOGGEDIN))
		{
			DeadSessions++;
			continue;
		}

		// Skip all entries we have looked at before
		if (pSda->sda_SessionId > StartId)
			continue;

		// If there is not enough space in the buffer, abort now and
		// initialize pErsp->ersp_hResume with the current session id
		BytesLeft = (LONG)((PBYTE)pString - (PBYTE)pSessInfo);
		BytesNeeded = sizeof(AFP_SESSION_INFO) +
					 pSda->sda_UserName.Length + sizeof(WCHAR) +
					 pSda->sda_WSName.Length + sizeof(WCHAR);

		if ((BytesLeft <= 0) || (BytesNeeded > BytesLeft))
		{
			pErsp->ersp_hResume = pSda->sda_SessionId;
			Status = STATUS_MORE_ENTRIES;
			break;
		}

		StartId = pSda->sda_SessionId;
		pSessInfo->afpsess_id = pSda->sda_SessionId;
		pSessInfo->afpsess_num_cons = pSda->sda_cOpenVolumes;
		pSessInfo->afpsess_num_opens = pSda->sda_cOpenForks;
		pSessInfo->afpsess_logon_type = pSda->sda_ClientType;
		AfpGetCurrentTimeInMacFormat(&pSessInfo->afpsess_time);
		pSessInfo->afpsess_time -= pSda->sda_TimeLoggedOn;

		// Copy the strings here
		pSessInfo->afpsess_username = NULL;
		pSessInfo->afpsess_ws_name = NULL;

		if (pSda->sda_UserName.Length > 0)
		{
			pString -= (pSda->sda_UserName.Length + sizeof(WCHAR));
			if (pSda->sda_UserName.Length > 0)
				RtlCopyMemory(pString, pSda->sda_UserName.Buffer, pSda->sda_UserName.Length);
			*(LPWSTR)(pString + pSda->sda_UserName.Length) = L'\0';
			pSessInfo->afpsess_username = (LPWSTR)pString;
			POINTER_TO_OFFSET(pSessInfo->afpsess_username, pSessInfo);
		}

		if ((pSda->sda_ClientType == SDA_CLIENT_MSUAM_V1) ||
            (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V2))
		{
			pString -= (pSda->sda_WSName.Length + sizeof(WCHAR));
			if (pSda->sda_WSName.Length > 0)
				RtlCopyMemory(pString, pSda->sda_WSName.Buffer, pSda->sda_WSName.Length);
			*(LPWSTR)(pString + pSda->sda_WSName.Length) = L'\0';
			pSessInfo->afpsess_ws_name = (LPWSTR)pString;
			POINTER_TO_OFFSET(pSessInfo->afpsess_ws_name, pSessInfo);
		}

		pSessInfo ++;
		pErsp->ersp_cInBuf ++;
	}

	// Fill up the response packet header
	pErsp->ersp_cTotEnts = (DWORD)AfpNumSessions - DeadSessions;

	RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

	return Status;
}


/***	AfpAdmConnectionEnum
 *
 *	Enumerate the list of active connections. This is a linear list rooted
 *	at AfpConnList and protected by AfpConnLock. This list is potentially
 *	pretty long (Unlimited # of sessions with the super ASP stuff).
 *
 *	For that reason	once every pass we check to see if we must forego the lock
 *	and restart	scan again. The assumption here is that the admin operation can
 *	take a hit.
 *
 *	The resume handle returned is the connection id of the last connection
 *	returned. connection Id of 0 implies restart scan.
 *
 *	The output buffer is constructed as follows.
 *
 *		+---------------------------+
 *		|	Connection_Info_1		|
 *		+---------------------------+
 *		|	Connection_Info_2		|
 *		+---------------------------+
 *		.							.
 *		.							.
 *		+---------------------------+
 *		|	Connection_Info_n		|
 *		+---------------------------+
 *		.							.
 *		.							.
 *		+---------------------------+
 *		|							|
 *		|...........................|
 *		|			Strings			|
 *		|...........................|
 *		|							|
 *		|							|
 *		+---------------------------+
 *
 *	The connections can be filtered based on either sessions or volumes.
 *
 *	LOCKS:		AfpConnLock (SPIN)
 */
AFPSTATUS
AfpAdmConnectionEnum(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	PENUMRESPPKT		pErsp = (PENUMRESPPKT)OutBuf;
	PENUMREQPKT			pErqp = (PENUMREQPKT)InBuf;
	PAFP_CONNECTION_INFO pConnInfo = (PAFP_CONNECTION_INFO)((PBYTE)OutBuf+sizeof(ENUMRESPPKT));
	PCONNDESC			pConnDesc;
	PBYTE				pString = (PBYTE)OutBuf+OutBufLen; // 1 past eob
	LONG				cTotal = 0;
	DWORD				DeadConns = 0;
	KIRQL				OldIrql;
	AFPSTATUS			Status = AFP_ERR_NONE;

	DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
			("AfpAdmConnectionEnum entered\n"));

	if ((((pErqp->erqp_Filter == AFP_FILTER_ON_SESSION_ID) ||
		  (pErqp->erqp_Filter == AFP_FILTER_ON_VOLUME_ID)) &&
		 (pErqp->erqp_ID == 0)) ||
		((pErqp->erqp_Filter != 0) &&
		 (pErqp->erqp_Filter != AFP_FILTER_ON_SESSION_ID) &&
		 (pErqp->erqp_Filter != AFP_FILTER_ON_VOLUME_ID)))
		return AFPERR_InvalidParms;

	if (OutBufLen < (sizeof(ENUMRESPPKT) + sizeof(PAFP_CONNECTION_INFO)))
		return AFPERR_BufferSize;

	if (pErqp->erqp_Index == 0)
		pErqp->erqp_Index = MAXULONG;

	// Initialize the response packet header
	pErsp->ersp_cInBuf = 0;
	pErsp->ersp_hResume = 0;

	ACQUIRE_SPIN_LOCK(&AfpConnLock, &OldIrql);

	for (pConnDesc = AfpConnList;
		 pConnDesc != NULL;
		 pConnDesc = pConnDesc->cds_NextGlobal)
	{
		PSDA		pSda;
		PVOLDESC	pVolDesc;
		LONG		BytesLeft;
		LONG		BytesNeeded;

		// We do not need to either lock or reference pSda and pVolDesc
		// since we have implicit references to them via the pConnDesc.

		pSda = pConnDesc->cds_pSda;
		ASSERT(pSda != NULL);

		pVolDesc = pConnDesc->cds_pVolDesc;
		ASSERT(pVolDesc != NULL);

		// If we are filtering, make sure we get the total count
		// Skip this entry, if any filtering is requested and this does not
		// match
		if (pErqp->erqp_Filter != 0)
		{
			if (pErqp->erqp_Filter == AFP_FILTER_ON_SESSION_ID)
			{
				if (pSda->sda_SessionId != pErqp->erqp_ID)
					continue;
				cTotal = pSda->sda_cOpenVolumes;
			}
			else // if (pErqp->erqp_Filter == AFP_FILTER_ON_VOLUME_ID)
			{
				if (pVolDesc->vds_VolId != (LONG)pErqp->erqp_ID)
					continue;
				cTotal = pVolDesc->vds_UseCount;
			}
		}
		else cTotal = AfpNumSessions;

		// Skip all entries that are marked for death
		if (pConnDesc->cds_Flags & CONN_CLOSING)
		{
			DeadConns++;
			continue;
		}

		// Skip all entries we have looked at before
		if (pConnDesc->cds_ConnId > pErqp->erqp_Index)
			continue;

		// If there is not enough space in the buffer, abort now and
		// initialize pErsp->ersp_hResume with the current connection id
		BytesLeft = (LONG)((PBYTE)pString - (PBYTE)pConnInfo);
		BytesNeeded = sizeof(AFP_CONNECTION_INFO) +
					 pSda->sda_UserName.Length + sizeof(WCHAR) +
					 pVolDesc->vds_Name.Length + sizeof(WCHAR);

		if ((BytesLeft <= 0) || (BytesNeeded > BytesLeft))
		{
			pErsp->ersp_hResume = pConnDesc->cds_ConnId;
			Status = STATUS_MORE_ENTRIES;
			break;
		}


		pErqp->erqp_Index = pConnDesc->cds_ConnId;
		pConnInfo->afpconn_id = pConnDesc->cds_ConnId;
		pConnInfo->afpconn_num_opens = pConnDesc->cds_cOpenForks;
		AfpGetCurrentTimeInMacFormat((PAFPTIME)&pConnInfo->afpconn_time);
		pConnInfo->afpconn_time -= pConnDesc->cds_TimeOpened;

		// Copy the username name string
		pConnInfo->afpconn_username = (LPWSTR)NULL;
		if (pSda->sda_UserName.Length > 0)
		{
			pString -= (pSda->sda_UserName.Length + sizeof(WCHAR));
			RtlCopyMemory(pString, pSda->sda_UserName.Buffer, pSda->sda_UserName.Length);
			*(LPWSTR)(pString + pSda->sda_UserName.Length) = L'\0';
			pConnInfo->afpconn_username = (LPWSTR)pString;
			POINTER_TO_OFFSET(pConnInfo->afpconn_username, pConnInfo);
		}

		// Copy the volume name string
		pString -= (pVolDesc->vds_Name.Length + sizeof(WCHAR));
		RtlCopyMemory(pString, pVolDesc->vds_Name.Buffer, pVolDesc->vds_Name.Length);
		*(LPWSTR)(pString + pVolDesc->vds_Name.Length) = L'\0';
		pConnInfo->afpconn_volumename = (LPWSTR)pString;
		POINTER_TO_OFFSET(pConnInfo->afpconn_volumename, pConnInfo);

		pConnInfo ++;
		pErsp->ersp_cInBuf ++;
	}

	// Fill up the response packet header
	pErsp->ersp_cTotEnts = (DWORD)cTotal - DeadConns;

	RELEASE_SPIN_LOCK(&AfpConnLock, OldIrql);

	return Status;
}


/***	AfpAdmForkEnum
 *
 *	Enumerate the list of open forks. This is a linear list rooted
 *	at AfpOpenForksList and protected by AfpForksLock. This list is potentially
 *	pretty long (Unlimited # of sessions with the super ASP stuff).
 *
 *	The resume handle returned is the connection id of the last connection
 *	returned. connection Id of 0 implies restart scan.
 *
 *	The output buffer is constructed as follows.
 *
 *		+---------------------------+
 *		|		File_Info_1			|
 *		+---------------------------+
 *		|		File_Info_2			|
 *		+---------------------------+
 *		.							.
 *		.							.
 *		+---------------------------+
 *		|		File_Info_n			|
 *		+---------------------------+
 *		.							.
 *		.							.
 *		+---------------------------+
 *		|							|
 *		|...........................|
 *		|			Strings			|
 *		|...........................|
 *		|							|
 *		|							|
 *		+---------------------------+
 *
 *	LOCKS:		AfpForksLock (SPIN)
 */
AFPSTATUS
AfpAdmForkEnum(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	PENUMRESPPKT	pErsp = (PENUMRESPPKT)OutBuf;
	PAFP_FILE_INFO	pFileInfo = (PAFP_FILE_INFO)((PBYTE)OutBuf+sizeof(ENUMRESPPKT));
	POPENFORKENTRY	pOpenForkEntry;
	POPENFORKDESC	pOpenForkDesc;
	PBYTE			pString = (PBYTE)OutBuf+OutBufLen; // 1 past eob
	DWORD			StartId = (LONG)(((PENUMREQPKT)InBuf)->erqp_Index);
	DWORD			DeadForks = 0;
	KIRQL			OldIrql;
	AFPSTATUS		Status = AFP_ERR_NONE;

	DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
			("AfpAdmForkEnum entered\n"));

	if (OutBufLen < (sizeof(ENUMRESPPKT) + sizeof(PAFP_FILE_INFO)))
		return AFPERR_BufferSize;

	if (StartId == 0)
		StartId = MAXULONG;

	// Initialize the response packet header
	pErsp->ersp_cInBuf = 0;
	pErsp->ersp_hResume = 0;

	ACQUIRE_SPIN_LOCK(&AfpForksLock, &OldIrql);

	for (pOpenForkEntry = AfpOpenForksList; pOpenForkEntry != NULL;
		 pOpenForkEntry = pOpenForkEntry->ofe_Next)
	{
		LONG		BytesLeft;
		LONG		BytesNeeded;
		PSDA		pSda;
		PVOLDESC	pVolDesc = pOpenForkEntry->ofe_pOpenForkDesc->ofd_pVolDesc;

		// Skip all entries that are marked for death
		if (pOpenForkEntry->ofe_Flags & OPEN_FORK_CLOSING)
		{
			DeadForks ++;
			continue;
		}

		// Skip all entries we have looked at before
		if (pOpenForkEntry->ofe_ForkId > StartId)
			continue;

		pSda = pOpenForkEntry->ofe_pSda;
		pOpenForkDesc = pOpenForkEntry->ofe_pOpenForkDesc;

		// If there is not enough space in the buffer, abort now and
		// initialize pErsp->ersp_hResume with the current session id
		BytesLeft = (LONG)((PBYTE)pString - (PBYTE)pFileInfo);
		BytesNeeded = sizeof(AFP_FILE_INFO) + pSda->sda_UserName.Length +
						sizeof(WCHAR) + /* NULL terminate username */
						pVolDesc->vds_Path.Length +
						pOpenForkDesc->ofd_FilePath.Length +
						sizeof(WCHAR); /* NULL terminate path */

		if ((BytesLeft <= 0) || (BytesNeeded > BytesLeft))
		{
			pErsp->ersp_hResume = pOpenForkEntry->ofe_ForkId;
			Status = STATUS_MORE_ENTRIES;
			break;
		}

		StartId = pOpenForkEntry->ofe_ForkId;
		pFileInfo->afpfile_id = pOpenForkEntry->ofe_ForkId;
		pFileInfo->afpfile_num_locks = pOpenForkEntry->ofe_cLocks;
		pFileInfo->afpfile_fork_type = RESCFORK(pOpenForkEntry);

#if AFP_OPEN_MODE_NONE != FORK_OPEN_NONE
#error	(AFP_OPEN_MODE_NONE != FORK_OPEN_NONE)
#endif
#if AFP_OPEN_MODE_READ != FORK_OPEN_READ
#error	(AFP_OPEN_MODE_READ != FORK_OPEN_READ)
#endif
#if AFP_OPEN_MODE_WRITE != FORK_OPEN_WRITE
#error	(AFP_OPEN_MODE_WRITE != FORK_OPEN_WRITE)
#endif
		pFileInfo->afpfile_open_mode = (DWORD)pOpenForkEntry->ofe_OpenMode;

		// Copy the strings here.
		pFileInfo->afpfile_username = NULL;
		pFileInfo->afpfile_path = NULL;

		if (pSda->sda_UserName.Length > 0)
		{
			pString -= (pSda->sda_UserName.Length + sizeof(WCHAR));
			RtlCopyMemory(pString, pSda->sda_UserName.Buffer, pSda->sda_UserName.Length);
			*(LPWSTR)(pString + pSda->sda_UserName.Length) = L'\0';
			pFileInfo->afpfile_username = (LPWSTR)pString;
			POINTER_TO_OFFSET(pFileInfo->afpfile_username, pFileInfo);
		}

		if (pOpenForkDesc->ofd_FilePath.Length > 0)
		{

			pString -= pVolDesc->vds_Path.Length +
					   pOpenForkDesc->ofd_FilePath.Length +
					   sizeof(WCHAR);
			pFileInfo->afpfile_path = (LPWSTR)pString;
			POINTER_TO_OFFSET(pFileInfo->afpfile_path, pFileInfo);

			RtlCopyMemory(pString, pVolDesc->vds_Path.Buffer,
						  pVolDesc->vds_Path.Length);
			RtlCopyMemory(pString + pVolDesc->vds_Path.Length,
						  pOpenForkDesc->ofd_FilePath.Buffer,
						  pOpenForkDesc->ofd_FilePath.Length);
			*(LPWSTR)(pString + pVolDesc->vds_Path.Length +
					  pOpenForkDesc->ofd_FilePath.Length) = L'\0';

		}

		pFileInfo ++;
		pErsp->ersp_cInBuf ++;
	}

	// Fill up the response packet header
	pErsp->ersp_cTotEnts = (DWORD)AfpNumOpenForks - DeadForks;

	RELEASE_SPIN_LOCK(&AfpForksLock, OldIrql);

	return Status;
}


/***	AfpAdmMessageSend
 *
 *	Send a message to a specific session, or broadcast to all sessions.
 *	If session id is 0, this indicates a broadcast, and the message is copied
 *	to AfpServerMsg.  Otherwise, the message is copied to the particular
 *	session's SDA.  A message can be a max of 199 chars.  It is an error to
 *	attempt to send a message of length 0. A message can only be sent to an
 *	AFP 2.1 client as a AFP 2.0 client has no capability to accept a message.
 *
 *	LOCKS:		AfpServerGlobalLock (SPIN)
 */
AFPSTATUS
AfpAdmMessageSend(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	PAFP_MESSAGE_INFO	pMsgInfo = (PAFP_MESSAGE_INFO)InBuf;
	PSDA				pSda;
	UNICODE_STRING		umsg;
	PANSI_STRING		amsg;
	USHORT				msglen;
	DWORD				SessId;
	KIRQL				OldIrql;
	AFPSTATUS			Status = AFP_ERR_NONE;

	DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
			("AfpAdmMessageSend entered\n"));

	SessId = pMsgInfo->afpmsg_session_id;
	RtlInitUnicodeString(&umsg, pMsgInfo->afpmsg_text);
	msglen = (USHORT)RtlUnicodeStringToAnsiSize(&umsg)-1;

	if ((msglen > AFP_MESSAGE_LEN) || (msglen == 0))
	{
		return AFPERR_InvalidParms;
	}

	if ((amsg =
		(PANSI_STRING)AfpAllocNonPagedMemory(msglen + 1 + sizeof(ANSI_STRING))) == NULL)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	amsg->Length = msglen;
	amsg->MaximumLength = msglen + 1;
	amsg->Buffer = (PBYTE)amsg + sizeof(ANSI_STRING);
	Status = RtlUnicodeStringToAnsiString(amsg, &umsg, False);
	if (!NT_SUCCESS(Status))
	{
		return AFPERR_InvalidParms;
	}
	else AfpConvertHostAnsiToMacAnsi(amsg);

	DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
			("AfpAdmMessageSend: session id is 0x%x, message <%s>\n",
			 pMsgInfo->afpmsg_session_id, amsg->Buffer));

	// If this is a broadcast message, initialize the global message
	if (SessId == 0)
	{
		ACQUIRE_SPIN_LOCK(&AfpServerGlobalLock, &OldIrql);
		// If there is a message there already, blow it
		if (AfpServerMsg != NULL)
			AfpFreeMemory(AfpServerMsg);
		AfpServerMsg = amsg;
		RELEASE_SPIN_LOCK(&AfpServerGlobalLock, OldIrql);

		// Walk the session list and send attention to all AFP 2.1 clients
		ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);
		for (pSda = AfpSessionList; pSda != NULL; pSda = pSda->sda_Next)
		{
			ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

			if ((pSda->sda_ClientVersion >= AFP_VER_21) &&
				((pSda->sda_Flags & (SDA_CLOSING | SDA_SESSION_CLOSED)) == 0))
			{
				// We are using the async version of AfpSpSendAttention since
				// we are calling with spin-lock held.
				AfpSpSendAttention(pSda, ATTN_SERVER_MESSAGE, False);
			}

			else if (pSda->sda_ClientVersion < AFP_VER_21)
			{
				Status = AFPERR_InvalidSessionType;
			}

			RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
		}
		RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);
	}
	else
	{
		// Find the session matching the session id and, if found and the client is AFP v2.1,
		// copy the message to the SDA and send an attention to the client.
		// Error if the session either does not exist or it is not an AFP 2.1

		Status = AFPERR_InvalidId;
		if ((pSda = AfpSdaReferenceSessionById(SessId)) != NULL)
		{
			Status = AFPERR_InvalidSessionType;
			if (pSda->sda_ClientVersion >= AFP_VER_21)
			{
				ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);
				if (pSda->sda_Message != NULL)
					AfpFreeMemory(pSda->sda_Message);
				pSda->sda_Message = amsg;
				AfpSpSendAttention(pSda, ATTN_SERVER_MESSAGE, False);
				RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);
				Status = AFP_ERR_NONE;
			}
			AfpSdaDereferenceSession(pSda);
		}
		if (Status != AFP_ERR_NONE)
		{
			AfpFreeMemory(amsg);
		}
	}

	return Status;
}


/***	AfpAdmWDirectoryGetInfo
 *
 *	Query a directory's permissions.
 */
AFPSTATUS
AfpAdmWDirectoryGetInfo(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	PAFP_DIRECTORY_INFO	pDirInfo = (PAFP_DIRECTORY_INFO)OutBuf;
	PSID				pSid = (PSID)((PBYTE)OutBuf + sizeof(AFP_DIRECTORY_INFO));
	UNICODE_STRING		VolumePath;
	ANSI_STRING			MacAnsiDirPath;
	SDA					Sda;
	CONNDESC			ConnDesc;
	PVOLDESC			pVolDesc;
	FILEDIRPARM			FDParm;
	PATHMAPENTITY		PME;
	AFPSTATUS			Status;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_ADMINAPI_DIR, DBG_LEVEL_INFO,
			("AfpAdmWDirectoryGetInfo entered for %ws\n",
			((PAFP_DIRECTORY_INFO)InBuf)->afpdir_path));

	// validate the output buffer length
	if (OutBufLen < sizeof(AFP_DIRECTORY_INFO))
		return AFPERR_BufferSize;

	MacAnsiDirPath.Length = 0;
	MacAnsiDirPath.MaximumLength = 0;
	MacAnsiDirPath.Buffer = NULL;

	OutBufLen -= sizeof(AFP_DIRECTORY_INFO);

	// First find the volume that this directory is path of
	RtlInitUnicodeString(&VolumePath, ((PAFP_DIRECTORY_INFO)InBuf)->afpdir_path);

	if (!NT_SUCCESS(Status = AfpVolumeReferenceByPath(&VolumePath, &pVolDesc)))
    {
        DBGPRINT(DBG_COMP_ADMINAPI_DIR, DBG_LEVEL_ERR,
                ("AfpAdmWDirectoryGetInfo: AfpVolumeReferenceByPath returned error %ld\n",
                Status));
		return Status;
    }

	// Now get the volume relative path of the directory.
	VolumePath.Buffer = (LPWSTR)((PBYTE)VolumePath.Buffer +
								pVolDesc->vds_Path.Length);
	VolumePath.Length -= pVolDesc->vds_Path.Length;
	VolumePath.MaximumLength -= pVolDesc->vds_Path.Length;
	if ((SHORT)(VolumePath.Length) < 0)
	{
		VolumePath.Length = 0;
		VolumePath.MaximumLength = sizeof(WCHAR);
	}

	do
	{
		AfpInitializePME(&PME, 0, NULL);
		if (!NT_SUCCESS(Status = afpConvertAdminPathToMacPath(pVolDesc,
															  &VolumePath,
															  &MacAnsiDirPath)))
		{
			Status = STATUS_OBJECT_PATH_NOT_FOUND;
			break;
		}

		// AfpMapAfpPathForLookup requires an Sda to figure out User's
		// permission. For this API, we do not really need the User's
		// permission, so kludge it up. Note that it is important to
		// set the client type to SDA_CLIENT_ADMIN to avoid references
		// to other sda fields. See access.c/fdparm.c/afpinfo.c for details.
		RtlZeroMemory(&Sda, sizeof(Sda));
#if DBG
		Sda.Signature = SDA_SIGNATURE;
#endif
		Sda.sda_ClientType = SDA_CLIENT_ADMIN;
		Sda.sda_UserSid = &AfpSidWorld;
		Sda.sda_GroupSid = &AfpSidWorld;

		// pathmap requires a ConnDesc to determine the VolDesc and Sda, so
		// kludge up a fake one here
		RtlZeroMemory(&ConnDesc, sizeof(ConnDesc));
#if DBG
		ConnDesc.Signature = CONNDESC_SIGNATURE;
#endif
		ConnDesc.cds_pSda = &Sda;
		ConnDesc.cds_pVolDesc = pVolDesc;

		AfpInitializeFDParms(&FDParm);

		Status = AfpMapAfpPathForLookup(&ConnDesc,
										AFP_ID_ROOT,
										&MacAnsiDirPath,
										AFP_LONGNAME,
										DFE_DIR,
										FD_INTERNAL_BITMAP_OPENACCESS_ADMINGET |
											DIR_BITMAP_ACCESSRIGHTS |
											FD_BITMAP_ATTR,
										&PME,
										&FDParm);
		if (!NT_SUCCESS(Status))
		{
			if (Status == AFP_ERR_ACCESS_DENIED)
			{
				Status = STATUS_ACCESS_DENIED;
			}
			else
			{
				Status = STATUS_OBJECT_PATH_NOT_FOUND;
			}

			break;
		}
	} while (False);

	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	if (MacAnsiDirPath.Buffer != NULL)
	{
		AfpFreeMemory(MacAnsiDirPath.Buffer);
	}

	AfpVolumeDereference(pVolDesc);

	// All is hunky-dory so far. Now convert the information we have so far
	// into the form accepted by the API
	if (NT_SUCCESS(Status))
	{
		PSID	pSidUG;			// Sid of user or group

		pDirInfo->afpdir_perms =
				((FDParm._fdp_OwnerRights & ~DIR_ACCESS_OWNER) << OWNER_RIGHTS_SHIFT) +
				((FDParm._fdp_GroupRights & ~DIR_ACCESS_OWNER) << GROUP_RIGHTS_SHIFT) +
				((FDParm._fdp_WorldRights & ~DIR_ACCESS_OWNER) << WORLD_RIGHTS_SHIFT);

		if ((FDParm._fdp_Attr &
			 (FD_BITMAP_ATTR_RENAMEINH | FD_BITMAP_ATTR_DELETEINH)) ==
						(FD_BITMAP_ATTR_RENAMEINH | FD_BITMAP_ATTR_DELETEINH))
			pDirInfo->afpdir_perms |= AFP_PERM_INHIBIT_MOVE_DELETE;

		DBGPRINT(DBG_COMP_ADMINAPI_DIR, DBG_LEVEL_INFO,
				("AfpAdmWDirectoryGetInfo: Perms %lx\n", pDirInfo->afpdir_perms));

		pDirInfo->afpdir_path = NULL;

		// Translate the owner and group ids to Sids. The name fields actually
		// get the sids and the user mode code is responsible to convert it
		// to names.
		pDirInfo->afpdir_owner = NULL;
		pDirInfo->afpdir_group = NULL;
		do
		{
			LONG	LengthSid;

			//
			// Convert the owner ID to SID
			//
			if (FDParm._fdp_OwnerId != 0)
			{
				Status = AfpMacIdToSid(FDParm._fdp_OwnerId, &pSidUG);
				if (!NT_SUCCESS(Status))
				{
					Status = STATUS_NONE_MAPPED;
					break;
				}
				AfpDumpSid("AfpAdmWDirectoryGetInfo: User Sid:", pSidUG);
	
				LengthSid = RtlLengthSid(pSidUG);
				if (OutBufLen < LengthSid)
					Status = AFPERR_BufferSize;
				else
				{
					RtlCopyMemory(pSid, pSidUG, LengthSid);
					pDirInfo->afpdir_owner = pSid;
					POINTER_TO_OFFSET(pDirInfo->afpdir_owner, pDirInfo);
					pSid = (PSID)((PBYTE)pSid + LengthSid);
					OutBufLen -= LengthSid;
				}

				if (!NT_SUCCESS(Status))
					break;
			}

			//
			// Convert the group ID to SID
			//
			if (FDParm._fdp_GroupId != 0)
			{
				Status = AfpMacIdToSid(FDParm._fdp_GroupId, &pSidUG);
				if (!NT_SUCCESS(Status))
				{
					Status = STATUS_NONE_MAPPED;
					break;
				}
				AfpDumpSid("AfpAdmWDirectoryGetInfo: Group Sid:", pSidUG);
	
				LengthSid = RtlLengthSid(pSidUG);
				if (OutBufLen < LengthSid)
					Status = AFPERR_BufferSize;
				else
				{
					RtlCopyMemory(pSid, pSidUG, LengthSid);
					pDirInfo->afpdir_group = pSid;
					POINTER_TO_OFFSET(pDirInfo->afpdir_group, pDirInfo);
					// pSid = (PSID)((PBYTE)pSid + LengthSid);
					// OutBufLen -= LengthSid;
				}
			}

		} while (False);
	}
	return Status;
}


/***	AfpAdmWDirectorySetInfo
 *
 *	Set a directory's permissions.
 */
AFPSTATUS
AfpAdmWDirectorySetInfo(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	PAFP_DIRECTORY_INFO	pDirInfo;
	DWORD				ParmNum, Bitmap = 0;
	UNICODE_STRING		VolumePath;
	SDA					Sda;
	CONNDESC			ConnDesc;
	PVOLDESC			pVolDesc;
	AFPSTATUS			Status;
	BYTE				ParmBlock[4 * sizeof(DWORD)];
	FILEDIRPARM			FDParm;

	PAGED_CODE( );

	ParmNum = ((PSETINFOREQPKT)InBuf)->sirqp_parmnum;
	pDirInfo = (PAFP_DIRECTORY_INFO)((PBYTE)InBuf + sizeof(SETINFOREQPKT));

	DBGPRINT(DBG_COMP_ADMINAPI_DIR, DBG_LEVEL_INFO,
			("AfpAdmWDirectorySetInfo entered for %ws (%lx)\n",
			pDirInfo->afpdir_path, ParmNum));

	// Convert the parmnum to a bitmap for use by AfpSetFileDirParms
	if (ParmNum & AFP_DIR_PARMNUM_PERMS)
		Bitmap |= (DIR_BITMAP_ACCESSRIGHTS | FD_BITMAP_ATTR);

	if (ParmNum & AFP_DIR_PARMNUM_OWNER)
	{
		if (pDirInfo->afpdir_owner == NULL)
			return STATUS_INVALID_PARAMETER;
		else
			Bitmap |= DIR_BITMAP_OWNERID;
	}

	if (ParmNum & AFP_DIR_PARMNUM_GROUP)
	{
		if (pDirInfo->afpdir_group == NULL)
			return STATUS_INVALID_PARAMETER;
		else
			Bitmap |= DIR_BITMAP_GROUPID;
	}

	// Find the volume that this directory is path of
	RtlInitUnicodeString(&VolumePath, pDirInfo->afpdir_path);

	if (!NT_SUCCESS(Status = AfpVolumeReferenceByPath(&VolumePath, &pVolDesc)))
		return Status;

	// Now get the volume relative path of the directory. Consume the leading
	// '\' character
	VolumePath.Buffer = (LPWSTR)((PBYTE)VolumePath.Buffer +
								pVolDesc->vds_Path.Length);
	VolumePath.Length -= pVolDesc->vds_Path.Length;
	VolumePath.MaximumLength -= pVolDesc->vds_Path.Length;
	if ((SHORT)(VolumePath.Length) < 0)
	{
		VolumePath.Length = 0;
		VolumePath.MaximumLength = sizeof(WCHAR);
	}


	RtlZeroMemory(&Sda, sizeof(Sda));

	if (Bitmap) do
	{
		if (!NT_SUCCESS(Status = afpConvertAdminPathToMacPath(pVolDesc,
															  &VolumePath,
															  &Sda.sda_Name1)))
		{
			Status = STATUS_OBJECT_PATH_NOT_FOUND;
			break;
		}

		// Kludge up a FILEDIRPARMS structure to call AfpPackFDParms with
		AfpInitializeFDParms(&FDParm);

		if (Bitmap & FD_BITMAP_ATTR)
		{
			FDParm._fdp_Attr =	FD_BITMAP_ATTR_RENAMEINH |
								FD_BITMAP_ATTR_DELETEINH;

			if (pDirInfo->afpdir_perms & AFP_PERM_INHIBIT_MOVE_DELETE)
			{
				FDParm._fdp_Attr |= FD_BITMAP_ATTR_SET;
			}

			DBGPRINT(DBG_COMP_ADMINAPI_DIR, DBG_LEVEL_INFO,
					("AfpAdmWDirectorySetInfo: Changing Attributes to %lx\n",
					FDParm._fdp_Attr));
		}

		if (Bitmap & DIR_BITMAP_ACCESSRIGHTS)
		{
			FDParm._fdp_OwnerRights = (BYTE)(pDirInfo->afpdir_perms >> OWNER_RIGHTS_SHIFT);
			FDParm._fdp_GroupRights = (BYTE)(pDirInfo->afpdir_perms >> GROUP_RIGHTS_SHIFT);
			FDParm._fdp_WorldRights = (BYTE)(pDirInfo->afpdir_perms >> WORLD_RIGHTS_SHIFT);

			DBGPRINT(DBG_COMP_ADMINAPI_DIR, DBG_LEVEL_INFO,
					("AfpAdmWDirectorySetInfo: Setting Permissions %x,%x,%x\n",
					FDParm._fdp_OwnerRights,
					FDParm._fdp_GroupRights,
					FDParm._fdp_WorldRights));
		}

		// See if we need to change owner and group ids
		if (Bitmap & DIR_BITMAP_OWNERID)
		{
			Status = AfpSidToMacId((PSID)(pDirInfo->afpdir_owner),
										  &FDParm._fdp_OwnerId);
			if (!NT_SUCCESS(Status))
			{
				Status = STATUS_NONE_MAPPED;
				break;
			}

			AfpDumpSid("AfpAdmWDirectorySetInfo: Changing Owner to:",
											(PSID)(pDirInfo->afpdir_owner));
		}

		if (Bitmap & DIR_BITMAP_GROUPID)
		{
			Status = AfpSidToMacId((PSID)(pDirInfo->afpdir_group),
										  &FDParm._fdp_GroupId);
			if (!NT_SUCCESS(Status))
			{
				Status = STATUS_NONE_MAPPED;
				break;
			}

			AfpDumpSid("AfpAdmWDirectorySetInfo: Changing Group to:",
											(PSID)(pDirInfo->afpdir_group));
		}
		FDParm._fdp_Flags = DFE_FLAGS_DIR;
		AfpPackFileDirParms(&FDParm, Bitmap, ParmBlock);

		// AfpQueryFileDirParms requires an Sda to figure out User's
		// permission. For this API, we do not really need the User's
		// permission, so kludge it up. Note that it is important to
		// set the client type to SDA_CLIENT_ADMIN to avoid references
		// to other sda fields. See access.c/fdparm.c/afpinfo.c for details.

		Sda.sda_ClientType = SDA_CLIENT_ADMIN;
		Sda.sda_UserSid = &AfpSidWorld;
		Sda.sda_GroupSid = &AfpSidWorld;

	    *((PULONG_PTR)Sda.sda_ReqBlock) = (ULONG_PTR)&ConnDesc;
        //if (sizeof (DWORD) != sizeof (ULONG_PTR))
#ifdef _WIN64
        // Create 64-bit space at start of buffer to hold ConnDesc pointer
            // 64-bit specifics
        	Sda.sda_ReqBlock[2] = AFP_ID_ROOT;
		    Sda.sda_ReqBlock[3] = Bitmap;
#else
        	Sda.sda_ReqBlock[1] = AFP_ID_ROOT;
		    Sda.sda_ReqBlock[2] = Bitmap;
#endif

		Sda.sda_PathType = AFP_LONGNAME;
		Sda.sda_Name2.Buffer = ParmBlock;
		Sda.sda_Name2.Length = Sda.sda_Name2.MaximumLength = sizeof(ParmBlock);

		// pathmap requires a ConnDesc to determine the VolDesc and Sda, so
		// kludge up a fake one here
		RtlZeroMemory(&ConnDesc, sizeof(ConnDesc));
#if DBG
		ConnDesc.Signature = CONNDESC_SIGNATURE;
		Sda.Signature = SDA_SIGNATURE;
#endif
		ConnDesc.cds_pSda = &Sda;
		ConnDesc.cds_pVolDesc = pVolDesc;

		if (!NT_SUCCESS(Status = AfpFspDispSetDirParms(&Sda)))
		{
			DBGPRINT(DBG_COMP_ADMINAPI_DIR, DBG_LEVEL_INFO,
					("AfpAdmWDirectorySetInfo: AfpFspDispSetDirParms failed 0x%lx\n",
					Status));

			if (Status == AFP_ERR_ACCESS_DENIED)
			{
				Status = STATUS_ACCESS_DENIED;
			}
			else
			{
				Status = STATUS_OBJECT_PATH_NOT_FOUND;
			}
		}

	} while (False);

	if (Sda.sda_Name1.Buffer != NULL)
	{
		AfpFreeMemory(Sda.sda_Name1.Buffer);
	}

	AfpVolumeDereference(pVolDesc);

	return Status;
}

/***	AfpAdmWFinderSetInfo
 *
 *  Set the type and/or creator of a file.
 *  (Note this routine can be expanded later to set other Finder info if
 *  needed)
 *
 *	LOCKS: vds_IdDbAccessLock (SWMR, Exclusive);
 */
AFPSTATUS
AfpAdmWFinderSetInfo(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	PAFP_FINDER_INFO	pAdmFDInfo;
	DWORD				ParmNum, Bitmap = 0;
	UNICODE_STRING		VolumePath, UTypeCreatorString;
	ANSI_STRING			MacAnsiFileDirPath, ATypeCreatorString;
	SDA					Sda;
	CONNDESC			ConnDesc;
	PVOLDESC			pVolDesc;
	AFPSTATUS			Status;
	FILEDIRPARM			FDParm;
	PATHMAPENTITY		PME;
	BYTE				Type[AFP_TYPE_LEN] = "    ";		// Pad with spaces
	BYTE				Creator[AFP_CREATOR_LEN] = "    ";  // Pad with spaces

	PAGED_CODE( );

	pAdmFDInfo = (PAFP_FINDER_INFO)((PBYTE)InBuf + sizeof(SETINFOREQPKT));
	ParmNum = ((PSETINFOREQPKT)InBuf)->sirqp_parmnum;

	DBGPRINT(DBG_COMP_ADMINAPI_DIR, DBG_LEVEL_INFO,
			("AfpAdmWFinderSetInfo entered for %ws (%lx)\n",
			pAdmFDInfo->afpfd_path, ParmNum));

	if ((ParmNum & ~AFP_FD_PARMNUM_ALL) || !ParmNum)
	{
		return AFPERR_InvalidParms;
	}

	// Convert the parmnum to a bitmap for use by pathmap to retrieve current
	// settings of FinderInfo, and convert type and creator to space padded
	// mac ansi
	if (ParmNum & AFP_FD_PARMNUM_TYPE)
	{
		Bitmap |= FD_BITMAP_FINDERINFO;
		RtlInitUnicodeString(&UTypeCreatorString, pAdmFDInfo->afpfd_type);
		if ((UTypeCreatorString.Length == 0) ||
			(UTypeCreatorString.Length/sizeof(WCHAR) > AFP_TYPE_LEN))
		{
			return AFPERR_InvalidParms;
		}
		ATypeCreatorString.Length = 0;
		ATypeCreatorString.MaximumLength = sizeof(Type);
		ATypeCreatorString.Buffer = Type;
		Status = AfpConvertStringToAnsi(&UTypeCreatorString,
										&ATypeCreatorString);
		if (!NT_SUCCESS(Status))
		{
			return STATUS_UNSUCCESSFUL;
		}
	}

	if (ParmNum & AFP_FD_PARMNUM_CREATOR)
	{
		Bitmap |= FD_BITMAP_FINDERINFO;
		RtlInitUnicodeString(&UTypeCreatorString, pAdmFDInfo->afpfd_creator);
		if ((UTypeCreatorString.Length == 0) ||
			(UTypeCreatorString.Length/sizeof(WCHAR) > AFP_CREATOR_LEN))
		{
			return AFPERR_InvalidParms;
		}
		ATypeCreatorString.Length = 0;
		ATypeCreatorString.MaximumLength = sizeof(Creator);
		ATypeCreatorString.Buffer = Creator;
		Status = AfpConvertStringToAnsi(&UTypeCreatorString,
										&ATypeCreatorString);
		if (!NT_SUCCESS(Status))
		{
			return STATUS_UNSUCCESSFUL;
		}
	}


	MacAnsiFileDirPath.Length = 0;
	MacAnsiFileDirPath.MaximumLength = 0;
	MacAnsiFileDirPath.Buffer = NULL;

	// First find the volume that this directory is path of
	RtlInitUnicodeString(&VolumePath, pAdmFDInfo->afpfd_path);

	if (!NT_SUCCESS(Status = AfpVolumeReferenceByPath(&VolumePath, &pVolDesc)))
		return Status;

	// Now get the volume relative path of the file/directory.
	VolumePath.Buffer = (LPWSTR)((PBYTE)VolumePath.Buffer +
								pVolDesc->vds_Path.Length);
	VolumePath.Length -= pVolDesc->vds_Path.Length;
	VolumePath.MaximumLength -= pVolDesc->vds_Path.Length;
	if ((SHORT)(VolumePath.Length) < 0)
	{
		VolumePath.Length = 0;
		VolumePath.MaximumLength = sizeof(WCHAR);
	}

	if (Bitmap) do
	{
		AfpInitializeFDParms(&FDParm);
		AfpInitializePME(&PME, 0, NULL);
		if (!NT_SUCCESS(Status = afpConvertAdminPathToMacPath(pVolDesc,
															  &VolumePath,
															  &MacAnsiFileDirPath)))
		{
			Status = STATUS_OBJECT_PATH_NOT_FOUND;
			break;
		}

		// pathmap requires a ConnDesc to determine the VolDesc and Sda, so
		// kludge up a fake one here
		RtlZeroMemory(&ConnDesc, sizeof(ConnDesc));
#if DBG
		ConnDesc.Signature = CONNDESC_SIGNATURE;
#endif
		Sda.sda_ClientType = SDA_CLIENT_ADMIN;
		ConnDesc.cds_pSda = &Sda;
		ConnDesc.cds_pVolDesc = pVolDesc;

		Status = AfpMapAfpPathForLookup(&ConnDesc, AFP_ID_ROOT,
										&MacAnsiFileDirPath,
										AFP_LONGNAME,
										DFE_ANY,
										FD_INTERNAL_BITMAP_OPENACCESS_ADMINGET |
										FD_BITMAP_LONGNAME | Bitmap,
										&PME,
										&FDParm);
		if (!NT_SUCCESS(Status))
		{
			if (Status == AFP_ERR_ACCESS_DENIED)
			{
				Status = STATUS_ACCESS_DENIED;
			}
			else
			{
				Status = STATUS_OBJECT_PATH_NOT_FOUND;
			}
			break;
		}

		// Copy the input Finder info into the FDParms structure
		if (ParmNum & AFP_FD_PARMNUM_TYPE)
			RtlCopyMemory(&FDParm._fdp_FinderInfo.fd_Type,
						  Type, AFP_TYPE_LEN);

		if (ParmNum & AFP_FD_PARMNUM_CREATOR)
			RtlCopyMemory(&FDParm._fdp_FinderInfo.fd_Creator,
						  Creator, AFP_CREATOR_LEN);

		// Set the AfpInfo
		AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
		Status = AfpSetAfpInfo(&PME.pme_Handle, Bitmap, &FDParm, pVolDesc, NULL);
		AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

	} while (False);

	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	if (MacAnsiFileDirPath.Buffer != NULL)
	{
		AfpFreeMemory(MacAnsiFileDirPath.Buffer);
	}

	AfpVolumeDereference(pVolDesc);

	return Status;
}

/***	AfpLookupEtcMapEntry
 *
 *	Lookup a type/creator mapping in the global table by comparing the
 *	extension to the desired extension.  Note the default type creator
 *	mapping is not kept in the table.
 *
 *	LOCKS_ASSUMED: AfpEtcMapLock (SWMR, Shared)
 */
PETCMAPINFO
AfpLookupEtcMapEntry(
	PUCHAR	pExt
)
{
	PETCMAPINFO petc = NULL;
	ANSI_STRING	alookupext, atableext;
	int	i;

	PAGED_CODE( );

	if (AfpEtcMapCount == 0)
	{
		return NULL;
	}

	ASSERT ((AfpEtcMapsSize > 0) && (AfpEtcMaps != NULL));

	RtlInitString(&alookupext,pExt);
	for (i=0;i<AfpEtcMapsSize;i++)
	{
		RtlInitString(&atableext,AfpEtcMaps[i].etc_extension);
		if (RtlEqualString(&atableext, &alookupext,True))
		{
			petc = &(AfpEtcMaps[i]);
			break;
		}
	}

	return petc;
}


/***	afpEtcMapDelete
 *
 *	Mark the extension/type/creator table entry as deleted by setting the
 *	extension field to null.  Decrement the count of valid entries.  If
 *	the number of free entries goes above a certain level, shrink the
 *	table down to a reasonable size.
 *
 *	LOCKS_ASSUMED: AfpEtcMapLock (SWMR, Exclusive)
 *
 */
VOID
afpEtcMapDelete(
	PETCMAPINFO	pEtcEntry
)
{
	PETCMAPINFO	ptemptable;
	LONG		newtablesize, nextnewentry, i;

	PAGED_CODE( );

	//
	// a null extension denotes an invalid ext/type/creator mapping table entry
	//
	pEtcEntry->etc_extension[0] = '\0';
	AfpEtcMapCount --;
	ASSERT (AfpEtcMapCount >= 0);

	if ((AfpEtcMapsSize - AfpEtcMapCount) > AFP_MAX_FREE_ETCMAP_ENTRIES)
	{
		//
		// shrink the type/creator table by AFP_MAX_FREE_ETCMAP_ENTRIES
		//
		newtablesize = (AfpEtcMapsSize - AFP_MAX_FREE_ETCMAP_ENTRIES);

		if ((ptemptable = (PETCMAPINFO)AfpAllocZeroedPagedMemory(newtablesize * sizeof(ETCMAPINFO))) == NULL)
		{
			return;
		}

		nextnewentry = 0;
		for (i=0;i<AfpEtcMapsSize;i++)
		{
			if (afpIsValidEtcMapEntry(AfpEtcMaps[i].etc_extension))
			{
				ASSERT(nextnewentry < AfpEtcMapCount);
				RtlCopyMemory(&ptemptable[nextnewentry++], &AfpEtcMaps[i], sizeof(ETCMAPINFO));
			}
		}
		AfpFreeMemory(AfpEtcMaps);
		AfpEtcMaps = ptemptable;
		AfpEtcMapsSize = newtablesize;
	}
}


/***	afpGetNextFreeEtcMapEntry
 *
 *	Look for an empty entry in the extension/type/creator table starting
 *	at the entry StartIndex.
 *
 *	LOCKS_ASSUMED: AfpEtcMapLock (SWMR, Exclusive)
 */
PETCMAPINFO
afpGetNextFreeEtcMapEntry(
	IN OUT PLONG	StartIndex
)
{
	PETCMAPINFO	tempptr = NULL;
	LONG		i;

	PAGED_CODE( );

	for (i = *StartIndex; i < AfpEtcMapsSize; i++)
	{
		if (!afpIsValidEtcMapEntry(AfpEtcMaps[i].etc_extension))
		{
			tempptr = &AfpEtcMaps[i];
			*StartIndex = i++;
			break;
		}
	}
	return tempptr;
}


/*** afpCopyMapInfo2ToMapInfo
 *
 *  Copy the etc info structure given to us by the Service into our structure, after
 *  converting the etc_extension field from Unicode to Ansi.
 *
 */
NTSTATUS
afpCopyMapInfo2ToMapInfo(
	OUT	PETCMAPINFO		pEtcDest,
	IN	PETCMAPINFO2	pEtcSource
)
{

	UCHAR			ext[AFP_EXTENSION_LEN+1];
	WCHAR			wext[AFP_EXTENSION_LEN+1];
	ANSI_STRING		aext;
	NTSTATUS		Status;
	UNICODE_STRING	uext;


	AfpSetEmptyAnsiString(&aext, sizeof(ext), ext);

	uext.Length = uext.MaximumLength = sizeof(pEtcSource->etc_extension);
	uext.Buffer = pEtcSource->etc_extension;
	Status = AfpConvertMungedUnicodeToAnsi(&uext, &aext);
	ASSERT(NT_SUCCESS(Status));

	RtlCopyMemory(pEtcDest->etc_extension, aext.Buffer, AFP_EXTENSION_LEN);
	pEtcDest->etc_extension[AFP_EXTENSION_LEN] = 0;

	// Copy the other two fields as-is

	RtlCopyMemory(pEtcDest->etc_type, pEtcSource->etc_type, AFP_TYPE_LEN);
	RtlCopyMemory(pEtcDest->etc_creator, pEtcSource->etc_creator, AFP_CREATOR_LEN);

	return STATUS_SUCCESS;
}

/*** afpConvertAdminPathToMacPath
 *
 *	Convert an admin volume relative NTFS path which may contain
 *  components > 31 chars, or may contain shortnames, to the
 *  equivalent mac path (in mac ANSI) so that the path may be sent thru the
 *  pathmap code.  Caller must free path buffer if success is returned.
 */
NTSTATUS
afpConvertAdminPathToMacPath(
	IN	PVOLDESC		pVolDesc,
	IN	PUNICODE_STRING	AdminPath,
	OUT	PANSI_STRING	MacPath
)
{
	USHORT			tempAdminPathlen = 0, numchars, numcomponents, i;
	WCHAR			wbuf[AFP_LONGNAME_LEN + 1];
	UNICODE_STRING	component, component2;
	UNICODE_STRING	pathSoFar, pathToParent;
	NTSTATUS		Status = STATUS_SUCCESS;
	CHAR			abuf[AFP_LONGNAME_LEN + 1];
	ANSI_STRING		macansiComponent;
	PWSTR			tempptr;
	FILESYSHANDLE	hComponent;
	BOOLEAN			NTFSShortname;

	PAGED_CODE( );

	// ASSERT(IS_VOLUME_NTFS(pVolDesc));

	// assert that the path does not begin with a backslash
	ASSERT((AdminPath->Length == 0) || (AdminPath->Buffer[0] != L'\\'));

	component2.Length = 0;
	component2.MaximumLength = sizeof(wbuf);
	component2.Buffer = wbuf;

	macansiComponent.Length = 0;
	macansiComponent.MaximumLength = sizeof(abuf);
	macansiComponent.Buffer = abuf;

	MacPath->Length = MacPath->MaximumLength = 0;
	MacPath->Buffer = NULL;

	// return success if no path components
	if (AdminPath->Length == 0)
	{
		return STATUS_SUCCESS;
	}

	numchars = AdminPath->Length / sizeof(WCHAR);
	// strip a trailing path separator if it exists
	if (AdminPath->Buffer[numchars - 1] == L'\\')
	{
		AdminPath->Length -= sizeof(WCHAR);
	}

	for (numcomponents = 1, i = 0; i < numchars; i++)
	{
		if (AdminPath->Buffer[i] == L'\\')
		{
			numcomponents++;
		}
	}

	// allocate a buffer to hold the mac (in mac ANSI) version of the path and
	// path separators
	MacPath->MaximumLength = numcomponents * AFP_LONGNAME_LEN + numcomponents;
	if ((MacPath->Buffer = (PCHAR)AfpAllocPagedMemory(MacPath->MaximumLength))
																		== NULL)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	pathSoFar = *AdminPath;
	pathSoFar.Length = 0;
	tempptr = AdminPath->Buffer;

	while (numcomponents)
	{
		hComponent.fsh_FileHandle = NULL;
		component.Buffer = tempptr;
		component2.Length = macansiComponent.Length = 0;
		NTFSShortname = False;
		numchars = 0;

		while (True)
		{
			if (tempptr[numchars] == L'~')
			{
				NTFSShortname = True;
			}

			if ((tempptr[numchars] == L'\\') ||
				((numcomponents == 1) &&
				 (pathSoFar.Length + numchars * sizeof(WCHAR)
											== AdminPath->Length)))
			{
				break;
			}
			numchars ++;
		}

		component.Length = component.MaximumLength = numchars * sizeof(WCHAR);
		pathToParent = pathSoFar;
		pathSoFar.Length += component.Length;
		tempptr += numchars + 1;


		if ((numchars > AFP_LONGNAME_LEN) || (NTFSShortname))
		{
			// open a handle to the directory so we can query the name;
			// to query the shortname we need a handle to the actual
			// directory; to query the longname, we need a handle to the
			// parent directory because of the way we have to
			// get the longname by enumerating the parent for one entry
			// with the name we are looking for
			if (NT_SUCCESS(Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
											  AFP_STREAM_DATA,
											  FILEIO_OPEN_DIR,
											  ((numchars <= AFP_LONGNAME_LEN) && NTFSShortname) ?
												&pathToParent : &pathSoFar,
											  FILEIO_ACCESS_NONE,
											  FILEIO_DENY_NONE,
											  False,
											  &hComponent)))
			{
				if (numchars > AFP_LONGNAME_LEN)
				{
					// query the shortname
					Status = AfpIoQueryShortName(&hComponent, &macansiComponent);
				}
				else
				{
					// we saw a tilde and are assuming it is the shortname,
					// and the path is 31 chars or less; query the longname
					if (NT_SUCCESS(Status = AfpIoQueryLongName(&hComponent,
															   &component,
															   &component2)))
					{
						Status = AfpConvertMungedUnicodeToAnsi(&component2,
															   &macansiComponent);
					}
				}
				AfpIoClose(&hComponent);
				if (!NT_SUCCESS(Status))
				{
					break;
				}
			}
			else
			{
				// open failed
				break;
			}
		}
		else
		{
			// use the component name as it was given by admin
			if (!NT_SUCCESS(Status = AfpConvertMungedUnicodeToAnsi(&component,
																   &macansiComponent)))
			{
				break;
			}
		}

		Status = RtlAppendStringToString(MacPath, &macansiComponent);
		ASSERT(NT_SUCCESS(Status));
		if (!NT_SUCCESS(Status))
		{
			break;
		}

		// include the path separator in the admin path seen so far
		pathSoFar.Length += sizeof(WCHAR);

		// add a path separator to the mac ansi path
		MacPath->Buffer[MacPath->Length++] = AFP_PATHSEP;
		ASSERT(MacPath->Length <= MacPath->MaximumLength);

		numcomponents --;
	} // while numcomponents

	if (!NT_SUCCESS(Status) && (MacPath->Buffer != NULL))
	{
		AfpFreeMemory(MacPath->Buffer);
		MacPath->Buffer = NULL;
	}

	return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\afpadmin.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	afpadmin.h

Abstract:

	This module contains definitions relating to the admin
	routines.

Author:

	Sue Adams

Revision History:
	25 Jun 1992             Initial Version

--*/

extern
VOID
AfpAdminDeInit(
	VOID
);

extern
AFPSTATUS
AfpAdmServiceStart(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServiceStop(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServicePause(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServiceContinue(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmGetStatistics(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmGetStatisticsEx(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmClearStatistics(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmGetProfCounters(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmClearProfCounters(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServerSetParms(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServerAddEtc(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServerSetEtc(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServerGetInfo(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServerDeleteEtc(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServerAddIcon(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmVolumeAdd(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmVolumeSetInfo(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmVolumeGetInfo(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmVolumeEnum(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmSessionEnum(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmConnectionEnum(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmWDirectoryGetInfo(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmWDirectorySetInfo(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmWFinderSetInfo(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmForkEnum(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmMessageSend(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmSystemShutdown(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
PETCMAPINFO
AfpLookupEtcMapEntry(
	PUCHAR	pExt
);

#ifdef	AFPADMIN_LOCALS

// Manifests for the FieldDesc
#define	DESC_NONE		0			// Don't bother with the validation
#define	DESC_STRING		1			// Its an offset to a string
#define	DESC_ETC		2			// Its the count of # of etc mappings
#define	DESC_ICON		3			// This field specifies the size of icon
#define	DESC_SID		4			// This field points to a Sid
#define	DESC_SPECIAL	5			// This needs special handling
#define	MAX_FIELDS		3			// Max. number of fields to validate

// Structure used for queueing admin requests to a worker thread
typedef	struct _AdminQRequest
{
	PIRP			aqr_pIrp;
	ADMINAPIWORKER	aqr_AdminApiWorker;
	WORK_ITEM		aqr_WorkItem;
} ADMQREQ, *PADMQREQ;

LOCAL NTSTATUS
afpFsdHandleAdminRequest(
	IN PIRP			pIrp
);


LOCAL NTSTATUS
afpFsdHandleShutdownRequest(
	IN PIRP			pIrp
);

LOCAL VOID FASTCALL
afpHandleQueuedAdminRequest(
	IN	PADMQREQ	pAdmQReq
);

LOCAL VOID
afpQueueAdminWorkItem(
	IN	PLIST_ENTRY	pAdmQListEntry
);

LOCAL NTSTATUS
afpFsdDispatchAdminRequest(
	IN	PDEVICE_OBJECT	pDeviceObject,
	IN	PIRP			pIrp
);

NTSTATUS
DriverEntry (
	IN PDRIVER_OBJECT	DriverObject,
	IN PUNICODE_STRING	RegistryPath
);

NTSTATUS
afpInitServer (
	VOID
);

LOCAL VOID
afpAdminThread(
	IN	PVOID			pContext
);

LOCAL VOID
afpFsdUnloadServer(
	IN	PDRIVER_OBJECT 	DeviceObject
);

LOCAL VOID
afpStartStopAdminRequest(
	IN	PIRP			pIrp,
	IN	BOOLEAN			Start
);

#define	afpStartAdminRequest(pIrp)	afpStartStopAdminRequest(pIrp, True)
#define	afpStopAdminRequest(pIrp)	afpStartStopAdminRequest(pIrp, False)

// This is the dispatch table for admin apis.
typedef struct
{
	BYTE	_FieldDesc;				// One of the above DESC_ values
	BYTE	_FieldOffset;			// Offset of the field
} DESCRIPTOR;

typedef	struct _AdminApiDispatchTable
{
	SHORT					_MinBufLen;
	BYTE					_OffToStruct;
	BOOLEAN					_CausesChange;
	DWORD					_OpCode;
	ADMINAPIWORKER			_AdminApiWorker;
	ADMINAPIWORKER			_AdminApiQueuedWorker;
	/*
	 * The following fields are used by the validation code. Since the
	 * structures have variable length fields in it, we need to make sure
	 * that
	 *		a, The offsets point within the buffer
	 *		b, The last unicode character in the buffer is a NULL
	 * This ensures that when the worker does a wstrlen, it does not
	 * access memory beyond the InputBuffer.
	 *
	 * We also deal with variable length data which is not a string.
	 * Fortunately there are only three APIs that use such a structure.
	 * We special-case these apis. The APIs are
	 *		a, ServerAddIcon
	 *			We need to make sure that the icon buffer and icon length are
	 *			kosher. The worker will do the rest of the validation.
	 *		b, ServerAddEtc
	 *			We need to make sure that the buffer is consistent with the
	 *			number of etc mappings specified.
	 */
	 DESCRIPTOR				_Fields[MAX_FIELDS];

} ADMIN_DISPATCH_TABLE, *PADMIN_DISPATCH_TABLE;

extern	ADMIN_DISPATCH_TABLE	AfpAdminDispatchTable[];

#endif	// AFPADMIN_LOCALS

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\afp.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	afp.h

Abstract:

	This file defines some server globals as well as include all relevant
	header files.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992             Initial Version

Notes:  Tab stop: 4
--*/


#ifndef _AFP_
#define _AFP_

#include <ntosp.h>
#include <zwapi.h>
#include <security.h>
#include <ntlmsp.h>

#include <string.h>
#include <wcstr.h>
#include <ntiologc.h>
#include <tdi.h>
#include <tdikrnl.h>

#if DBG
/* Disable FASTCALLs for checked builds */
#undef	FASTCALL
#define	FASTCALL
#define LOCAL
#else
#define LOCAL
#endif

#ifdef	_GLOBALS_
#define	GLOBAL
#define	EQU				=
#else
#define	GLOBAL			extern
#define	EQU				; / ## /
#endif

#include <atalktdi.h>
#include <afpconst.h>
#include <fwddecl.h>
#include <intrlckd.h>
#include <macansi.h>
#include <macfile.h>
#include <admin.h>
#include <swmr.h>
#include <fileio.h>
#include <server.h>
#include <forks.h>
#include <sda.h>
#include <afpinfo.h>
#include <idindex.h>
#include <desktop.h>
#include <atalkio.h>
#include <volume.h>
#include <afpmem.h>
#include <errorlog.h>
#include <srvmsg.h>
#include <time.h>
#include <lists.h>
#include <filenums.h>
#include <rasfmsub.h>
#include <tcp.h>

#endif  // _AFP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\afpapi.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	afpapi.c

Abstract:

	This module contains the AFP API Dispatcher.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/


#define	FILENUM	FILE_AFPAPI

#include <afp.h>
#include <gendisp.h>
#include <client.h>
#include <fdparm.h>
#include <forkio.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpStartApiProcessing)
#endif

/*
 *	The following array is indexed by the AFP opcode. The rationale behind this
 *	table is that the majority of codes are unused (> 200 out of 255). This
 *	scheme makes the actual dispatch table much smaller at the cost of an extra
 *	array look-up.
 */
LOCAL	BYTE	AfpOpCodeTable[256] =
{
/*00-02*/	_AFP_INVALID_OPCODE,	_AFP_BYTE_RANGE_LOCK,	_AFP_CLOSE_VOL,
/*03-05*/	_AFP_CLOSE_DIR,			_AFP_CLOSE_FORK,		_AFP_COPY_FILE,
/*06-08*/	_AFP_CREATE_DIR,		_AFP_CREATE_FILE,		_AFP_DELETE,
/*09-0B*/	_AFP_ENUMERATE,			_AFP_FLUSH,				_AFP_FLUSH_FORK,
/*0C-0E*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_GET_FORK_PARMS,
/*0F-11*/	_AFP_GET_SRVR_INFO,		_AFP_GET_SRVR_PARMS,	_AFP_GET_VOL_PARMS,
/*12-14*/	_AFP_LOGIN,				_AFP_LOGIN_CONT,		_AFP_LOGOUT,
/*15-17*/	_AFP_MAP_ID,			_AFP_MAP_NAME,			_AFP_MOVE_AND_RENAME,
/*18-1A*/	_AFP_OPEN_VOL,			_AFP_OPEN_DIR,			_AFP_OPEN_FORK,
/*1B-1D*/	_AFP_READ,				_AFP_RENAME,			_AFP_SET_DIR_PARMS,
/*1E-20*/	_AFP_SET_FILE_PARMS,	_AFP_SET_FORK_PARMS,	_AFP_SET_VOL_PARMS,
/*21-23*/	_AFP_WRITE,				_AFP_GET_FILE_DIR_PARMS,_AFP_SET_FILE_DIR_PARMS,
/*24-26*/	_AFP_CHANGE_PASSWORD,	_AFP_GET_USER_INFO,		_AFP_GET_SRVR_MSG,
/*27-29*/	_AFP_CREATE_ID,			_AFP_DELETE_ID,			_AFP_RESOLVE_ID,
/*2A-2C*/	_AFP_EXCHANGE_FILES,	_AFP_CAT_SEARCH,		_AFP_INVALID_OPCODE,
/*2D-2F*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*30-32*/	_AFP_OPEN_DT,			_AFP_CLOSE_DT,			_AFP_INVALID_OPCODE,
/*33-35*/	_AFP_GET_ICON,			_AFP_GET_ICON_INFO,		_AFP_ADD_APPL,
/*36-38*/	_AFP_REMOVE_APPL,		_AFP_GET_APPL,			_AFP_ADD_COMMENT,
/*39-3B*/	_AFP_REMOVE_COMMENT,	_AFP_GET_COMMENT,		_AFP_INVALID_OPCODE,
/*3C-3E*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*3F-41*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*42-44*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*45-47*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*48-4A*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*4B-4D*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*4E-50*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*51-53*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*54-56*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*57-59*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*5A-5C*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*5D-5F*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*60-62*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*63-65*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*66-68*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*69-6B*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*6C-6E*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*6F-71*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*72-74*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*75-77*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*78-7A*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*7B-7D*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*7E-80*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*81-83*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*84-86*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*87-89*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*8A-8C*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*8D-8F*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*90-92*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*93-95*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*96-98*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*99-9B*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*9C-9E*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*9F-A1*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*A2-A4*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*A5-A7*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*A8-AA*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*AB-AD*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*AE-B0*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*B1-B3*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*B4-B6*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*B7-B9*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*BA-BC*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*BD-BF*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*C0-C2*/	_AFP_ADD_ICON,			_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*C3-C5*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*C6-C8*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*C9-CB*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*CC-CE*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*CF-D1*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*D2-D4*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*D5-D7*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*D8-DA*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*DB-DD*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*DE-E0*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*E1-E3*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*E4-E6*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*E7-E9*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*EA-EC*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*ED-EF*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*F0-F2*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*F3-F5*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*F6-F8*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*F9-FB*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*FC-FE*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*FF*/		_AFP_GET_DOMAIN_LIST
};



#if DBG
PCHAR	afpApiNames[] =
	{	"AfpInvalidOpcode",
		"AfpUnsupportedOpcode",
		"AfpGetSrvrInfo",
		"AfpGetSrvrParms",
		"AfpChangePassword",
		"AfpLogin",
		"AfpLoginCont",
		"AfpLogout",
		"AfpMapId",
		"AfpMapName",
		"AfpGetUserInfo",
		"AfpGetSrvrMsg",
		"AfpGetDomainList",
		"AfpOpenVol",
		"AfpCloseVol",
		"AfpGetVolParms",
		"AfpSetVolParms",
		"AfpFlush",
		"AfpGetFileDirParms",
		"AfpSetFileDirParms",
		"AfpDelete",
		"AfpRename",
		"AfpMoveAndRename",
		"AfpOpenDir",
		"AfpCloseDir",
		"AfpCreateDir",
		"AfpEnumerate",
		"AfpSetDirParms",
		"AfpCreateFile",
		"AfpCopyFile",
		"AfpCreateId",
		"AfpDeleteId",
		"AfpResolveId",
		"AfpSetFileParms",
		"AfpExchangeFiles",
		"AfpOpenFork",
		"AfpCloseFork",
		"AfpFlushFork",
		"AfpRead",
		"AfpWrite",
		"AfpByteRangeLock",
		"AfpGetForkParms",
		"AfpSetForkParms",
		"AfpOpenDt",
		"AfpCloseDt",
		"AfpAddAppl",
		"AfpGetAppl",
		"AfpRemoveAppl",
		"AfpAddComment",
		"AfpGetComment",
		"AfpRemoveComment",
		"AfpAddIcon",
		"AfpGetIcon",
		"AfpGetIconInfo",
		"AfpCatSearch"
	};
#endif

/*
 *	The following structure is the API Dispatch table. The structure is indexed
 *	by the _AFP code. Each entry consists of the routine address that handles
 *	the request and/or dispatches to FSP, the fixed size of the request
 *	packet and optionally three variable size packets. The fixed size request
 *	packet is further split up into SEVEN fields. Each field is of the type
 *	FLD_BYTE, FLD_WORD or FLD_DWRD. A field of the type FLD_WORD and FLD_DWRD
 *	is converted from on-the-wire format to the internal format. An FLD_NONE
 *	entry stops the scan for the fixed part of the request.
 *	NamexType where x is 1,2,3 defines what type of variable size packets
 *	follow. A NONE on any of the fields stops the parsing. A type of BLOCK
 *	consumes the balance of the packet. Each of the variable size packets are
 *	copied to the sda_Namex field which is defined as ANSI_STRING. For the
 *	TYP_BLOCK field, the Length field of the ANSI_STRING defines the length
 *	of the block. The motivation for this structure is to conserve memory.
 *	Since a request packet is 578 bytes long and most APIs use only a small
 *	subset of that, the fixed portion of the packet is copied to the SDA
 *	and a smaller buffer is allocated for the variable packet.
 *	The orignal buffer cannot be accessed once we return back from this call.
 */

// DO NOT CHANGE THE MANIFESTS BELOW BEFORE YOU CHECK THE CODE IN
//	AfpUnmarshallReq

// Descriptor values for fixed data
#define	FLD_NONE		0x00			// Terminate
#define	FLD_BYTE		sizeof(BYTE)	// Byte field
#define	FLD_WORD		sizeof(USHORT)	// WORD field
#define	FLD_DWRD		sizeof(DWORD)	// DWORD field
#define	FLD_SIGNED		0x08			// The value is to be treated as a signed
#define	FLD_NON_ZERO	0x10			// The value cannot be zero
#define	FLD_CHECK_MASK	0x20			// Check against the mask in ReqPktMask
#define	FLD_NOCONV		0x40			// Skip conversion from on-the-wire to host
#define	FLD_NOPAD		0x80			// Do not EVEN align the next field
#define	FLD_PROP_MASK	(FLD_SIGNED		|	\
						 FLD_NON_ZERO	|	\
						 FLD_CHECK_MASK |	\
						 FLD_NOCONV		|	\
						 FLD_NOPAD)

// Descriptor values for variable data
#define	TYP_NONE		0x00		// Terminate
#define	TYP_PATH		0x01		// AFPPATH -> ANSI_STRING
#define	TYP_STRING		0x02		// PASCALSTR -> ANSI_STRING
#define	TYP_BLK16		0x03		// Block of 16 bytes
#define	TYP_BLOCK		0x04		// Block of bytes
#define	TYP_NON_NULL	0x20		// The variable data cannot be null
#define	TYP_OPTIONAL	0x40		// This field can be optinal
#define	TYP_NOPAD		0x80		// Do not even align the next field
#define	TYP_PROP_MASK	(TYP_NON_NULL | TYP_OPTIONAL | TYP_NOPAD)

#define	API_AFP21ONLY				0x01	// Valid only for AFP 2.1 clients
#define	API_SKIPLOGONVALIDATION		0x02	// Don't check if user is logged on
#define	API_NOSUBFUNCTION			0x04	// For the AfpLogin Function
#define	API_CHECK_VOLID				0x08	// This API reference volume
#define	API_CHECK_OFORKREFNUM		0x10	// This API reference open fork
#define	API_TYPE_WRITE				0x20	// This attempts a write
#define	API_QUEUE_IF_DPC			0x40	// This conditionally queues to worker only if at DPC
#define	API_MUST_BE_QUEUED			0x80	// The Api must be queued to the worker thread

#define	MAX_MASK_ENTRIES			4		// Max. bitmasks to validate

LOCAL	struct _DispatchTable
{
	AFPAPIWORKER	AfpWorkerRoutine;				// Worker routine to call/queue
	BYTE			AfpStatus;						// Status to return on error
													// This has to be added to the base
	BYTE			ApiOptions;						// API_xxx values
	BYTE			ReqPktDesc[MAX_REQ_ENTRIES];	// Fixed data desc
	BYTE			NameXType[MAX_VAR_ENTRIES];		// Variable data desc
	USHORT			ReqPktMask[MAX_MASK_ENTRIES];	// Valid values for bit-maps
} AfpDispatchTable[_AFP_MAX_ENTRIES] =
{

/* 0x00 */
	{
		AfpFsdDispInvalidFunc,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		0,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},

/* 0x01 */
	{
		AfpFsdDispUnsupportedFunc,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		0,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},

		/* SERVER APIs */

/* 0x02 */
	{
		AfpFsdDispInvalidFunc,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		0,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x03 */
	{
		AfpFsdDispGetSrvrParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_NOSUBFUNCTION,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x04 */
	{
		AfpFspDispChangePassword,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_SKIPLOGONVALIDATION+API_MUST_BE_QUEUED,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_STRING+TYP_NON_NULL,			// UAM Name
		TYP_STRING+TYP_NON_NULL,			// User Name
		TYP_BLOCK+TYP_NON_NULL				// UAM dependent info
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x05 */
	{
		AfpFspDispLogin,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_SKIPLOGONVALIDATION+API_NOSUBFUNCTION+API_MUST_BE_QUEUED,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_STRING+TYP_NOPAD+TYP_NON_NULL,		// AFP Version
		TYP_STRING+TYP_NOPAD+TYP_NON_NULL,		// UAM String
		TYP_BLOCK+TYP_NOPAD						// UAM dependent data
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x06 */
	{
		AfpFspDispLoginCont,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_SKIPLOGONVALIDATION+API_MUST_BE_QUEUED,
	  {
		FLD_DWRD+FLD_NOCONV,					//
		FLD_DWRD+FLD_NOCONV,					//
		FLD_DWRD+FLD_NOCONV,					// Response to Challenge
		FLD_DWRD+FLD_NOCONV,					//
		FLD_DWRD+FLD_NOCONV,					//
		FLD_DWRD+FLD_NOCONV,					//
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x07 */
	{
		AfpFspDispLogout,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_NOSUBFUNCTION+API_MUST_BE_QUEUED,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x08 */
	{
		AfpFspDispMapId,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_MUST_BE_QUEUED,
	  {
		FLD_DWRD,								// User or Group Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x09 */
	{
		AfpFspDispMapName,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_MUST_BE_QUEUED,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_STRING,								// User or Group Name
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x0A */
	{
		AfpFspDispGetUserInfo,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_MUST_BE_QUEUED,
	  {
		FLD_DWRD,								// User Id
		FLD_WORD,								// Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x0B */
	{
		AfpFsdDispGetSrvrMsg,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_AFP21ONLY,
	  {
		FLD_WORD,								// Message Type
		FLD_WORD,								// Mesage Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x0C */
	{
		AfpFsdDispInvalidFunc,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_SKIPLOGONVALIDATION+API_MUST_BE_QUEUED,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},

		/* VOLUMEAPIs */

/* 0x0D */
	{
		AfpFsdDispOpenVol,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		0,
	  {
		FLD_WORD+FLD_NON_ZERO+FLD_CHECK_MASK,	// Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_STRING+TYP_NON_NULL,				// Volume name
		TYP_BLOCK+TYP_OPTIONAL,					// Volume password
		TYP_NONE
	  },
	  {
		VOL_BITMAP_MASK,
		0,
		0,
		0
	  }
	},
/* 0x0E */
	{
		AfpFsdDispCloseVol,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x0F */
	{
		AfpFsdDispGetVolParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_WORD+FLD_NON_ZERO+FLD_CHECK_MASK,	// Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		VOL_BITMAP_MASK,
		0,
		0
	  }
	},
/* 0x10 */
	{
		AfpFsdDispSetVolParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_WORD+FLD_NON_ZERO+FLD_CHECK_MASK,	// Bitmap
		FLD_DWRD,								// Backup date
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		VOL_BITMAP_BACKUPTIME,
		0,
		0
	  }
	},
/* 0x11 */
	{
		AfpFsdDispFlush,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},

	/* FILE-DIRECTORY APIs */

/* 0x12 */
	{
		AfpFspDispGetFileDirParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_WORD+FLD_CHECK_MASK,				// File Bitmap
		FLD_WORD+FLD_CHECK_MASK,				// Directory Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH,								// Path
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		FILE_BITMAP_MASK,
		DIR_BITMAP_MASK
	  }
	},
/* 0x13 */
	{
		AfpFspDispSetFileDirParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_WORD+FLD_NON_ZERO+FLD_CHECK_MASK,	// File or Directory Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH,								// Path
		TYP_BLOCK+TYP_NON_NULL,					// Parameters (packed)
		TYP_NONE
	  },
	  {
		0,
		0,
		FD_VALID_SET_PARMS,
		0
	  }
	},
/* 0x14 */
	{
		AfpFspDispDelete,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH,								// Path
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x15 */
	{
		AfpFspDispRename,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NOPAD,						// Path
		TYP_PATH+TYP_NOPAD+TYP_NON_NULL,		// New Name
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x16 */
	{
		AfpFspDispMoveAndRename,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Src Directory Id
		FLD_DWRD+FLD_NON_ZERO,					// Dst Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NOPAD,						// Source path
		TYP_PATH+TYP_NOPAD,						// Destination path
		TYP_PATH+TYP_NOPAD						// New Name (optional)
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},

		/* DIRECTORY APIs */

/* 0x17 */
	{
		AfpFspDispOpenDir,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NON_NULL,					// Directory Name
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x18 */
	{
		AfpFspDispCloseDir,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x19 */
	{
		AfpFspDispCreateDir,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NON_NULL,					// Directory Name
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x1A */
	{
		AfpFspDispEnumerate,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_WORD+FLD_CHECK_MASK,				// File Bitmap
		FLD_WORD+FLD_CHECK_MASK,				// Directory Bitmap
		FLD_WORD+FLD_SIGNED+FLD_NON_ZERO,		// ReqCount
		FLD_WORD+FLD_SIGNED+FLD_NON_ZERO,		// Start Index
		FLD_WORD+FLD_SIGNED+FLD_NON_ZERO,		// ReplySize
	  },
	  {
		TYP_PATH,								// Path to directory
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		FILE_BITMAP_MASK,
		DIR_BITMAP_MASK
	  }
	},
/* 0x1B */
	{
		AfpFspDispSetDirParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_WORD+FLD_NON_ZERO+FLD_CHECK_MASK,	// Dir Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH,								// Path
		TYP_BLOCK+TYP_NON_NULL,					// Parameters (packed)
		TYP_NONE
	  },
	  {
		0,
		0,
		DIR_VALID_SET_PARMS,
		0
	  }
	},

	/* FILE APIs */

/* 0x1C */
		{
		AfpFspDispCreateFile,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NON_NULL,					// Path
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x1D */
	{
		AfpFspDispCopyFile,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Src Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Src Directory Id
		FLD_WORD+FLD_NON_ZERO,					// Dst Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Dst Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NOPAD+TYP_NON_NULL,		// Src Path
		TYP_PATH+TYP_NOPAD,
		TYP_PATH+TYP_NOPAD
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x1E */
	{
		AfpFspDispCreateId,
		(AFP_ERR_BASE - AFP_ERR_OBJECT_TYPE),
		API_AFP21ONLY+API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NON_NULL,					// Path
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x1F */
	{
		AfpFspDispDeleteId,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_AFP21ONLY+API_CHECK_VOLID+API_MUST_BE_QUEUED+API_TYPE_WRITE,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// File Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x20 */
	{
		AfpFspDispResolveId,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_AFP21ONLY+API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD,								// File Id
		FLD_WORD+FLD_CHECK_MASK,				// Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		FILE_BITMAP_MASK,
		0
	  }
	},
/* 0x21 */
	{
		AfpFspDispSetFileParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_WORD+FLD_NON_ZERO+FLD_CHECK_MASK,	// File Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NON_NULL,					// Path
		TYP_BLOCK+TYP_NON_NULL,					// Parameters (packed)
		TYP_NONE
	  },
	  {
		0,
		0,
		FILE_VALID_SET_PARMS,
		0
	  }
	},
/* 0x22 */
	{
		AfpFspDispExchangeFiles,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED+API_AFP21ONLY,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Srce. Directory Id
		FLD_DWRD+FLD_NON_ZERO,					// Dest. Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NOPAD+TYP_NON_NULL,					// Srce. Path
		TYP_PATH+TYP_NOPAD+TYP_NON_NULL,					// Dest. Path
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},

		/* FORK	APIs */

/* 0x23 */
	{
		AfpFspDispOpenFork,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_WORD+FLD_CHECK_MASK,				// Bitmap
		FLD_WORD,								// Access & Deny Modes
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NON_NULL,					// Path
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		FILE_BITMAP_MASK,
		0
	  }
	},
/* 0x24 */
	{
		AfpFspDispCloseFork,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_OFORKREFNUM+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Fork_Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x25 */
	{
		AfpFspDispFlushFork,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_OFORKREFNUM+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Fork_Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x26 */
	{
		AfpFspDispRead,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_OFORKREFNUM+API_QUEUE_IF_DPC+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Fork_Id
		FLD_DWRD,								// Offset
		FLD_DWRD,								// ReqCount
		FLD_BYTE+FLD_NOPAD,						// Newline Mask
		FLD_BYTE+FLD_NOPAD,						// Newline Char
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x27 */
	{
		AfpFspDispWrite,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_OFORKREFNUM+API_TYPE_WRITE+API_QUEUE_IF_DPC+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Fork_Id
		FLD_DWRD,								// Offset
		FLD_DWRD,								// Length
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x28 */
	{
		AfpFspDispByteRangeLock,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_OFORKREFNUM+API_QUEUE_IF_DPC+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Fork_Id
		FLD_DWRD,								// Offset
		FLD_DWRD,								// Length
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x29 */
	{
		AfpFspDispGetForkParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_OFORKREFNUM+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Fork_Id
		FLD_WORD+FLD_NON_ZERO+FLD_CHECK_MASK,	// Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		FILE_BITMAP_MASK,
		0,
		0
	  }
	},
/* 0x2A */
	{
		AfpFspDispSetForkParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_OFORKREFNUM+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Fork_Id
		FLD_WORD+FLD_NON_ZERO+FLD_CHECK_MASK,	// Bitmap
		FLD_DWRD,								// Fork Length
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		FILE_BITMAP_DATALEN+FILE_BITMAP_RESCLEN,
		0,
		0
	  }
	},

	/* DESKTOP APIs */

/* 0x2B */
	{
		AfpFsdDispOpenDT,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x2C */
	{
		AfpFsdDispCloseDT,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x2D */
	{
		AfpFspDispAddAppl,
		(AFP_ERR_BASE - AFP_ERR_OBJECT_TYPE),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_DWRD+FLD_NOCONV,					// Creator
		FLD_DWRD,								// Appl Tag
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NON_NULL,					// Path
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x2E */
	{
		AfpFspDispGetAppl,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NOCONV,					// Creator
		FLD_WORD,								// Appl Index
		FLD_WORD+FLD_CHECK_MASK,				// Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		FILE_BITMAP_MASK
	  }
	},
/* 0x2F */
	{
		AfpFspDispRemoveAppl,
		(AFP_ERR_BASE - AFP_ERR_ITEM_NOT_FOUND),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_DWRD+FLD_NOCONV,					// Creator
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NON_NULL,					// Path
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x30 */
	{
		AfpFspDispAddComment,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH,
		TYP_STRING,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x31 */
	{
		AfpFspDispGetComment,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x32 */
	{
		AfpFspDispRemoveComment,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x33 */
	{
		AfpFspDispAddIcon,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NOCONV,					// Creator
		FLD_DWRD+FLD_NOCONV,					// Type
		FLD_BYTE,								// IconType
		FLD_DWRD,								// IconTag
		FLD_WORD+FLD_SIGNED,					// Icon Size
		FLD_NONE,
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x34 */
	{
		AfpFspDispGetIcon,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NOCONV,					// Creator
		FLD_DWRD+FLD_NOCONV,					// Type
		FLD_BYTE,								// IconType
		FLD_WORD+FLD_SIGNED,					// Length
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x35 */
	{
		AfpFspDispGetIconInfo,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NOCONV,					// Creator
		FLD_WORD,								// IconIndex
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},

/* 0x36 */
	{
		AfpFspDispCatSearch,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED+API_AFP21ONLY,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Requested # of matches
		FLD_DWRD,								// Reserved
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_BLK16+TYP_NON_NULL,					// Catalog position
		TYP_BLOCK+TYP_NON_NULL,					// The rest of the stuff
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	}
};


/***	AfpFsdDispInvalidFunc
 *
 *	This handles invalid AFP functions.
 */
AFPSTATUS FASTCALL
AfpFsdDispInvalidFunc(
	IN	PSDA	pSda
)
{
	return AFP_ERR_PARAM;
}


/***	AfpFsdDispUnsupportedFunc
 *
 *	This handles un-supported AFP functions.
 */
AFPSTATUS FASTCALL
AfpFsdDispUnsupportedFunc(
	IN	PSDA	pSda
)
{
	return AFP_ERR_CALL_NOT_SUPPORTED;
}


/***	AfpUnmarshallReq
 *
 *	The request completion routine has determined the session that this
 *	request initiated from. Determine if this session is currently being
 *	serviced. If not, the request packet is then broken down as follows.
 *
 *	Afp function code	->  pSda->sda_AfpFunc
 *	Afp SubFunc code	->  pSda->sda_AfpSubFunc
 *	Fixed part of the
 *	Api request parms	->  pSda->sda_ReqBlock each field is converted to a
 *							dword from the on-the-wire format to the host
 *							format. Dictated by the table above.
 *	Variable part		->  pSda->sda_Name1-3 as appropriate. Dictated by the
 *							table above. AFPPATH, BLOCK and PASCALSTR are
 *							all converted to ANSI_STRING.
 *
 *	Buffers for sda_Namex is allocated out of NonPagedPool, if it cannot
 *	fit into sda_NameXSpace.
 *
 *	A whole lot of book keeping is also done here. API statistics are maintained
 *	here and when the reply is posted.
 *
 *	If there is no error, then the following possible error codes result:
 *		AFP_ERR_NONE		The dispatch level worker can be called
 *		AFP_ERR_QUEUE		The request must be queued
 *		AFP_ERR_DEFER		The request must be deferred
 *		AFP_ERR_xxxxx		Appropriate error code
 *
 *	NOTE: This is called within ReceiveCompletion and hence at DISPATCH_LEVEL.
 */
VOID FASTCALL
AfpUnmarshallReq(
	IN	PSDA		pSda
)
{
	LONG			StrSize, Offset, i;
	LONG			NameOff = 0, SpaceLeft;
	PREQUEST		pRequest;
	LONG			RequestSize;
	PBYTE			pRequestBuf;
	USHORT			WriteSize = 0;
	PBYTE			pWriteBuf = NULL;
	AFPSTATUS		Status;
	BYTE			ApiCode;
    LONG            BytesToCopy;
	struct _DispatchTable *pDispTab;
	struct _RequestPacket
	{
		BYTE	_Function;
		BYTE	_SubFunc;
		BYTE	_OtherParms;
	} *pRqPkt;
#ifdef	PROFILING
	static TIME		TimeLastRequest = { 0, 0 };
	TIME			TimeS, TimeD, TimeE;

	AfpGetPerfCounter(&TimeS);
#endif

	ASSERT (VALID_SDA(pSda));
	ASSERT (pSda->sda_Flags & SDA_REQUEST_IN_PROCESS);
	ASSERT (pSda->sda_Request != NULL);

	pRequest = pSda->sda_Request;
	RequestSize = pRequest->rq_RequestSize;
	pRequestBuf = pRequest->rq_RequestBuf;
	ASSERT (pRequestBuf != NULL);

	pRqPkt = (struct _RequestPacket *)pRequestBuf;

	if (pRequest->rq_WriteMdl != NULL)
	{
        // if Mdl (and the buffer) was allocated by us, find the buffer
        if (pRequest->rq_CacheMgrContext == NULL)
        {
		    pWriteBuf = MmGetSystemAddressForMdlSafe(
					            pRequest->rq_WriteMdl,
					            NormalPagePriority);

            if (pWriteBuf == NULL)
            {
			    Status = AFP_ERR_MISC;
                ASSERT(0);
                goto AfpUnmarshallReq_ErrExit;
            }
        }

		WriteSize = (USHORT)AfpMdlChainSize(pRequest->rq_WriteMdl);
	}
    else
    {
        ASSERT(pRequest->rq_CacheMgrContext == NULL);
    }

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

#ifdef	PROFILING
	ACQUIRE_SPIN_LOCK_AT_DPC(&AfpStatisticsLock);

	if (TimeLastRequest.QuadPart != 0)
	{
		TimeD.QuadPart = TimeS.QuadPart - TimeLastRequest.QuadPart;
		AfpServerProfile->perf_InterReqTime.QuadPart += TimeD.QuadPart;
		AfpServerProfile->perf_ReqCount ++;
	}

	TimeLastRequest.QuadPart = TimeS.QuadPart;

	RELEASE_SPIN_LOCK_FROM_DPC(&AfpStatisticsLock);
#endif

	do
	{
		Offset = FIELD_OFFSET(struct _RequestPacket, _OtherParms);

#ifdef	PROFILING
		AfpGetPerfCounter(&pSda->sda_ApiStartTime);
#endif
		INTERLOCKED_ADD_STATISTICS(&AfpServerStatistics.stat_DataIn,
								   RequestSize + WriteSize,
								   &AfpStatisticsLock);

		ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

		// Send a dummy reply if we are shutting down the server or the session
		// Also the request better be atleast the minimum size
		if ((pSda->sda_Flags & SDA_CLOSING)				||
			(AfpServerState & AFP_STATE_STOP_PENDING)	||
			(RequestSize < sizeof(pRqPkt->_Function)))
		{
			// Set a function code so that we know what statictics to update at
			// reply time
			pSda->sda_AfpFunc = _AFP_INVALID_OPCODE;
			RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
			Status = AFP_ERR_PARAM;
			break;
		}

		ApiCode = AfpOpCodeTable[pRqPkt->_Function];

		// Translate the function code to what we understand
		pDispTab = &AfpDispatchTable[ApiCode];

		DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
				("AfpUnmarshallRequest: <%s>\n", afpApiNames[ApiCode]));

		if (!(pSda->sda_Flags & SDA_USER_LOGGEDIN))
		{
			if (!(pDispTab->ApiOptions & API_SKIPLOGONVALIDATION))
			{
				Status = AFP_ERR_USER_NOT_AUTH;
				if (pSda->sda_Flags & SDA_LOGIN_FAILED)
					Status = AFP_ERR_PWD_NEEDS_CHANGE;
				RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
				break;
			}
		}

		ASSERT (pDispTab->AfpWorkerRoutine != NULL);

		// Initialize the worker routine
		pSda->sda_WorkerRoutine = pDispTab->AfpWorkerRoutine;

		// Check if this is an AFP 2.1 request and if we are in a position to honor it.
		if ((pDispTab->ApiOptions & API_AFP21ONLY) &&
			(pSda->sda_ClientVersion < AFP_VER_21))
		{
			RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
			Status = AFP_ERR_CALL_NOT_SUPPORTED;
			break;
		}

		Status = AFP_ERR_NONE;
		pSda->sda_AfpFunc = ApiCode;
        if (RequestSize >= FIELD_OFFSET(struct _RequestPacket, _SubFunc))
        {
		    pSda->sda_AfpSubFunc = pRqPkt->_SubFunc;
        }
		pSda->sda_PathType = 0;			// Invalid till we actually encounter one
		pSda->sda_IOBuf = pWriteBuf;
		pSda->sda_IOSize = WriteSize;

		if (pDispTab->ApiOptions & API_QUEUE_IF_DPC)
		{
			pSda->sda_Flags |= SDA_QUEUE_IF_DPC;
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

		// Get all the fields from the request buffer to the sda_ReqBlock structure.
        if (RequestSize >= FIELD_OFFSET(struct _RequestPacket, _OtherParms))
        {
		    pRequestBuf = &pRqPkt->_OtherParms;
        }

		// Do this for APIs which do not provide a sub-function or a pad.
		// Currently the only culprit is FPLogin
		if (pDispTab->ApiOptions & API_NOSUBFUNCTION)
		{
			pSda->sda_AfpSubFunc = 0;
			pRequestBuf --;
			Offset --;
		}

		// Account for the function and subfunction (if any) from the request packet
		RequestSize -= Offset;

        //
        // for the Apple native UAM's (Randnum Exchange, and 2-Way Randnum exchange),
        // we special case and 'unmarshal' the parms directly (the Afp function code
        // being the same for AfpLoginCont regardless of the UAM used, it would be a
        // major hack if we had to 'unmarshal' the parms the regular way)
        //
        if ((ApiCode == _AFP_LOGIN_CONT) &&
            ((pSda->sda_ClientType == SDA_CLIENT_RANDNUM) ||
             (pSda->sda_ClientType == SDA_CLIENT_TWOWAY)))
        {

            // 8 bytes of Response, 2 bytes of LogonId
            if (pSda->sda_ClientType == SDA_CLIENT_RANDNUM)
            {
                BytesToCopy = (RANDNUM_RESP_LEN+sizeof(USHORT));
            }
            // 8 bytes of Response, 8 bytes of Mac's challeng, 2 bytes of LogonId
            else
            {
                BytesToCopy = (TWOWAY_RESP_LEN+sizeof(USHORT));
            }

            if (RequestSize < BytesToCopy)
            {
                ASSERT(0);
                Status = AFP_ERR_PARAM;
                break;
            }

            RtlCopyMemory((PBYTE)&pSda->sda_ReqBlock[0],
                          pRequestBuf,
                          BytesToCopy);

            //
            // skip everything else, now that we got what we wanted
            //
            Status = AFP_ERR_QUEUE;
            break;
        }

		for (i = 0;
			 (i < MAX_REQ_ENTRIES) && (pDispTab->ReqPktDesc[i] != FLD_NONE);
			 i++)
		{
			// Check alignment
			if (((pDispTab->ReqPktDesc[i] & FLD_NOPAD) == 0) &&
				((Offset % 2) != 0))
			{
				Offset ++;
				RequestSize --;
				pRequestBuf ++;
			}

			if (RequestSize < (pDispTab->ReqPktDesc[i] & ~FLD_PROP_MASK))
			{
				Status = AFP_ERR_PARAM;
				break;
			}
			switch (pDispTab->ReqPktDesc[i] & ~FLD_PROP_MASK)
			{
				case FLD_BYTE:
					ASSERT ((pDispTab->ReqPktDesc[i] & FLD_NOCONV) == 0);
					GETBYTE2DWORD(&pSda->sda_ReqBlock[i], pRequestBuf);
					break;
				case FLD_WORD:
					ASSERT ((pDispTab->ReqPktDesc[i] & FLD_NOCONV) == 0);
					GETSHORT2DWORD(&pSda->sda_ReqBlock[i], pRequestBuf);
					if (pDispTab->ReqPktDesc[i] & FLD_SIGNED)
						pSda->sda_ReqBlock[i] = (LONG)((SHORT)pSda->sda_ReqBlock[i]);
					break;
				case FLD_DWRD:
					if (pDispTab->ReqPktDesc[i] & FLD_NOCONV)
					{
						 GETDWORD2DWORD_NOCONV(&pSda->sda_ReqBlock[i], pRequestBuf);
					}
					else
					{
						GETDWORD2DWORD(&pSda->sda_ReqBlock[i], pRequestBuf);
					}
					break;
				default:
					// How did we get here ?
					KeBugCheck(0);
					break;
			}

			if ((pDispTab->ReqPktDesc[i] & FLD_NON_ZERO) &&
				(pSda->sda_ReqBlock[i] == 0))
			{
				if (pDispTab->ReqPktDesc[i] & FLD_CHECK_MASK)
				{
					ASSERT ( i < MAX_MASK_ENTRIES);
					Status = AFP_ERR_BITMAP;
				}
				else
				{
					Status = AFP_ERR_PARAM;
				}
				break;
			}

			if ((pDispTab->ReqPktDesc[i] & FLD_CHECK_MASK) &&
				(((USHORT)(pSda->sda_ReqBlock[i]) & ~pDispTab->ReqPktMask[i]) != 0))
			{
				ASSERT (i < MAX_MASK_ENTRIES);
				Status = AFP_ERR_BITMAP;
				break;
			}

			pRequestBuf += (pDispTab->ReqPktDesc[i] & ~FLD_PROP_MASK);
			Offset += (pDispTab->ReqPktDesc[i] & ~FLD_PROP_MASK);
			RequestSize -= (pDispTab->ReqPktDesc[i] & ~FLD_PROP_MASK);
		}

		if (Status != AFP_ERR_NONE)
		{
			break;
		}

		// Before we go any further, check for volume/fork references and such
		//
		// NOTE: The VolId and OForkRefNum are always the first parameter and
		//		 hence referenced as such via the request packet structure
		if (pDispTab->ApiOptions & API_CHECK_VOLID)
		{
			PCONNDESC	pConnDesc;
			struct _RequestPacket
			{
				DWORD	_VolId;
			};
			struct _ModifiedPacket
			{
				ULONG_PTR	_VolId;
			};

			if ((pReqPkt->_VolId == 0) ||
				((pConnDesc = AfpConnectionReferenceAtDpc(pSda, (ULONG)(pReqPkt->_VolId))) == NULL))
			{
				Status = AFP_ERR_PARAM;
				break;
			}
			ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);
			pSda->sda_Flags |= SDA_DEREF_VOLUME;
			RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

            //if (sizeof(DWORD) != sizeof(ULONG_PTR))
#ifdef _WIN64
			// Create 64-bit space to hold VolDesc pointer
			// Push array 1 DWORD down
            {
     		    for (i = MAX_REQ_ENTRIES;
			        i > 0;
			        i--)
                {
                    pSda->sda_ReqBlock[i+1] = pSda->sda_ReqBlock[i];
                }
            }
#endif

   			pModPkt->_VolId = (ULONG_PTR)pConnDesc;

			if ((pDispTab->ApiOptions & API_TYPE_WRITE) &&
				 (pConnDesc->cds_pVolDesc->vds_Flags & AFP_VOLUME_READONLY))
			{
				DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_WARN,
						("AfpUnmarshallReq: Write operation on a RO volume\n"));
				Status = AFP_ERR_VOLUME_LOCKED;
				break;
			}
			if (pConnDesc->cds_pVolDesc->vds_Flags & VOLUME_CDFS_INVALID)
			{
				ASSERT(!IS_VOLUME_NTFS(pConnDesc->cds_pVolDesc));
				DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_WARN,
						("AfpUnmarshallReq: Access to a defunct CD-Volume\n"));
				Status = AFP_ERR_MISC;
				break;

			}

		}
		else if (pDispTab->ApiOptions & API_CHECK_OFORKREFNUM)
		{
			POPENFORKENTRY	pOpenForkEntry;
			struct _RequestPacket
			{
				DWORD   _OForkRefNum;
			};
			struct _ModifiedPacket
			{
				ULONG_PTR	_OForkRefNum;
			};

			if ((pReqPkt->_OForkRefNum == 0) ||
				((pOpenForkEntry = AfpForkReferenceByRefNum(pSda, (ULONG)(pReqPkt->_OForkRefNum))) == NULL))
			{
				Status = AFP_ERR_PARAM;
				break;
			}

			ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);
			pSda->sda_Flags |= SDA_DEREF_OFORK;
			RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

            //if (sizeof(DWORD) != sizeof(ULONG_PTR))
#ifdef _WIN64
			// Create 64-bit space to hold VolDesc pointer
			// Push array 1 DWORD down
            {
    		    for (i = MAX_REQ_ENTRIES;
			        i > 0;
			        i--)
                {
                    pSda->sda_ReqBlock[i+1] = pSda->sda_ReqBlock[i];
                }
            }
#endif

			pModPkt->_OForkRefNum = (ULONG_PTR)pOpenForkEntry;

			if ((pDispTab->ApiOptions & API_TYPE_WRITE) &&
				!(pOpenForkEntry->ofe_OpenMode & FORK_OPEN_WRITE))
			{
				DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_WARN,
						("AfpUnmarshallReq: AfpWrite on a Fork not opened for write\n"));
				Status = AFP_ERR_ACCESS_DENIED;
				break;
			}

		}

		// Now get the sda_NameX fields. Allocate one chunk of memory for
		// copying all the variable size data. Use sda_NameXSpace if it fits there
		if ((pDispTab->NameXType[0] != TYP_NONE) &&
			(RequestSize > 0))
		{
			SpaceLeft = RequestSize;
			ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

			pSda->sda_NameBuf = NULL;
			if ((RequestSize <= pSda->sda_SizeNameXSpace) &&
				((pSda->sda_Flags & SDA_NAMEXSPACE_IN_USE) == 0))
			{
				pSda->sda_NameBuf = pSda->sda_NameXSpace;
				pSda->sda_Flags |= SDA_NAMEXSPACE_IN_USE;
			}

			RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

			if ((pSda->sda_NameBuf == NULL) &&
				(pSda->sda_NameBuf = AfpAllocNonPagedMemory(RequestSize)) == NULL)
			{
				Status = AFP_ERR_MISC;
				break;
			}
		}

		for (i = 0;
			 (i < MAX_VAR_ENTRIES) && (pDispTab->NameXType[i] != TYP_NONE) && (RequestSize > 0);
			 i++)
		{
			if (((pDispTab->NameXType[i] & TYP_NOPAD) == 0) &&
				(RequestSize > 0) && ((Offset % 2) != 0))
			{
				Offset ++;
				RequestSize --;
				pRequestBuf ++;
			}

			switch (pDispTab->NameXType[i] & ~TYP_PROP_MASK)
			{
				case TYP_PATH:
					// TYP_PATH is almost like TYP_STRING except that there is a
					// leading PathType which should be valid. Just validate that
					// and fall through to the TYP_STRING case. Validate the size
					// to hold atleast the pathtype and the string length

					ASSERT (!(pDispTab->NameXType[i] & TYP_OPTIONAL));

					if ((RequestSize < 2*sizeof(BYTE)) ||
						 !VALIDPATHTYPE(*pRequestBuf)||
						 (VALIDPATHTYPE(pSda->sda_PathType) &&
						  (pSda->sda_PathType != *pRequestBuf)))
					{
						Status = AFP_ERR_PARAM;
						break;
					}
					// Save the PathType and account for it
					pSda->sda_PathType = *pRequestBuf++;
					Offset ++;
					RequestSize --;
				case TYP_STRING:
					// A TYP_STRING has a leading size byte and a string of that
					// size. A null string is then atleast one byte long.

					// Allow an optional string to be absent
					if ((pDispTab->NameXType[i] & TYP_OPTIONAL) &&
						(RequestSize == 0))
						continue;

					if ((RequestSize < sizeof(BYTE)) ||
						 ((StrSize = (LONG)pRequestBuf[0]) >
											(RequestSize - (LONG)sizeof(BYTE))))
					{
						Status = AFP_ERR_PARAM;
						break;
					}
					// Consume the string length
					pRequestBuf++;
					Offset ++;
					RequestSize --;
					break;
                case TYP_BLK16:
                    if (RequestSize < 16)
                    {
						Status = AFP_ERR_PARAM;
                        ASSERT(0);
						break;
                    }
					StrSize = 16;
					break;
				case TYP_BLOCK:
					StrSize = RequestSize;
					break;
				default:
					// How did we get here ?
					KeBugCheck(0);
					break;
			}

			if (Status != AFP_ERR_NONE)
			{
				break;
			}

			if (StrSize > 0)
			{
				ASSERT (StrSize <= SpaceLeft);
				pSda->sda_Name[i].Buffer = (pSda->sda_NameBuf + NameOff);
				SpaceLeft -= StrSize;
				NameOff += StrSize;

				pSda->sda_Name[i].Length =
				pSda->sda_Name[i].MaximumLength = (USHORT)StrSize;

				RtlCopyMemory(pSda->sda_Name[i].Buffer, pRequestBuf, StrSize);
				pRequestBuf += StrSize;
				Offset += StrSize;
				RequestSize -= StrSize;
			}

			if ((pDispTab->NameXType[i] & TYP_NON_NULL) &&
				(pSda->sda_Name[i].Length == 0))
				Status = (AFP_ERR_BASE - pDispTab->AfpStatus);
		}

		// Change the status if we have no worker at dispatch level
		if ((Status == AFP_ERR_NONE) && (pDispTab->ApiOptions & API_MUST_BE_QUEUED))
		{
			Status = AFP_ERR_QUEUE;
		}

		DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
				("AfpUnmarshallReq: <%s> returning Status %ld\n",
											afpApiNames[ApiCode], Status));
	} while (False);


AfpUnmarshallReq_ErrExit:

    //
	// Kill the write buffer Mdl since we do not need it anymore.  Of course,
    // if the Mdl belongs to cache mgr, don't touch it!
    //
	if ((pRequest->rq_WriteMdl != NULL) &&
        (pRequest->rq_CacheMgrContext == NULL))
	{
		AfpFreeMdl(pRequest->rq_WriteMdl);
		pRequest->rq_WriteMdl = NULL;
	}


	if ((Status != AFP_ERR_NONE) &&
		(Status != AFP_ERR_QUEUE))
	{
		if (pWriteBuf != NULL)
        {
			AfpIOFreeBuffer(pWriteBuf);
        }
		pSda->sda_IOBuf = NULL;
		pSda->sda_IOSize = 0;
	}

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);

	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_UnmarshallCount);
	INTERLOCKED_ADD_LARGE_INTGR_DPC(&AfpServerProfile->perf_UnmarshallTime,
									TimeD,
									&AfpStatisticsLock);
#endif
	AfpDisposeRequest(pSda, Status);
}



/***	AfpCompleteApiProcessing
 *
 *	Called in when the API processing is complete. Book-keeping is performed
 *	and a reply sent. If any buffers were allocated during un-marshalling,
 *	then they are freed up.
 *
 *	LOCKS:	sda_Lock (SPIN), AfpStatisticsLock (SPIN)
 *
 */
VOID FASTCALL
AfpCompleteApiProcessing(
	IN	PSDA		pSda,
	IN	AFPSTATUS	RetCode
)
{
	POPENFORKENTRY	pOpenForkEntry = NULL;
	PCONNDESC		pConnDesc = NULL;
	PDFRDREQQ		pDfrdReq = NULL;
	PLIST_ENTRY		pList;
	KIRQL			OldIrql;
	PMDL			ReplyMdl;
	PREQUEST		pRequest;
	struct _RequestPacket
	{
		union
		{
			PCONNDESC		_pConnDesc;
			POPENFORKENTRY	_pOpenForkEntry;
		};
	};

	DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
		("AfpCompleteApiProcessing: Completed <%s>\n", afpApiNames[pSda->sda_AfpFunc]));

	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

	// If there is a deferred request, dequeue it now while we have the lock
	if (!IsListEmpty(&pSda->sda_DeferredQueue))
	{
		pList = RemoveHeadList(&pSda->sda_DeferredQueue);
		pDfrdReq = CONTAINING_RECORD(pList, DFRDREQQ, drq_Link);
	}

	ASSERT (pSda->sda_Flags & SDA_REQUEST_IN_PROCESS);

	pSda->sda_Flags &= ~SDA_QUEUE_IF_DPC;
	if (pSda->sda_Flags & SDA_DEREF_VOLUME)
	{
		pConnDesc = pReqPkt->_pConnDesc;
		pReqPkt->_pConnDesc = NULL;

		ASSERT(VALID_CONNDESC(pConnDesc));

		pSda->sda_Flags &= ~SDA_DEREF_VOLUME;

		// If we have a enumerated directory context, free it up
		// but only if we are not in the middle of an enumerate
		// and we are not doing the periodic GetVolParms either
		if ((pConnDesc->cds_pEnumDir != NULL) &&
			(pSda->sda_AfpFunc != _AFP_ENUMERATE) &&
			(pSda->sda_AfpFunc != _AFP_GET_VOL_PARMS))
		{
			AfpFreeMemory(pConnDesc->cds_pEnumDir);
			pConnDesc->cds_pEnumDir = NULL;
		}
	}
	if (pSda->sda_Flags & SDA_DEREF_OFORK)
	{
		pOpenForkEntry = pReqPkt->_pOpenForkEntry;

		ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

		pSda->sda_Flags &= ~SDA_DEREF_OFORK;
	}

	if (pSda->sda_NameBuf != NULL)
	{
		if (pSda->sda_NameBuf != pSda->sda_NameXSpace)
		{
			AfpFreeMemory(pSda->sda_NameBuf);
		}
		else
		{
			pSda->sda_Flags &= ~SDA_NAMEXSPACE_IN_USE;
		}
	    pSda->sda_NameBuf = NULL;
	}

	// Clear these fields. We do not want left-overs from previous api lying around.
	ASSERT((FIELD_OFFSET(SDA, sda_Name) - FIELD_OFFSET(SDA, sda_ReqBlock)) ==
													sizeof(DWORD)*(MAX_REQ_ENTRIES_PLUS_1));
	RtlZeroMemory(&pSda->sda_ReqBlock[0],
				  (sizeof(ANSI_STRING)*MAX_VAR_ENTRIES) + (sizeof(DWORD)*(MAX_REQ_ENTRIES_PLUS_1)));

	pSda->sda_SecUtilResult = STATUS_SUCCESS;

	ASSERT(pSda->sda_AfpFunc < _AFP_MAX_ENTRIES);

#ifdef	PROFILING
	{
		TIME	ApiEndTime, FuncTime;

		ACQUIRE_SPIN_LOCK_AT_DPC(&AfpStatisticsLock);

		// Update profile info
		AfpGetPerfCounter(&ApiEndTime);
		FuncTime.QuadPart = ApiEndTime.QuadPart - pSda->sda_ApiStartTime.QuadPart;

		AfpServerProfile->perf_ApiCounts[pSda->sda_AfpFunc] ++;
		AfpServerProfile->perf_ApiCumTimes[pSda->sda_AfpFunc].QuadPart += FuncTime.QuadPart;

		// Do not make this completely useless by recording times
		// for apis that do not succeed. They detect an error early
		// and hence make the Best Time fairly bogus
		if (RetCode == AFP_ERR_NONE)
		{
			if ((FuncTime.QuadPart > AfpServerProfile->perf_ApiWorstTime[pSda->sda_AfpFunc].QuadPart) ||
				(AfpServerProfile->perf_ApiWorstTime[pSda->sda_AfpFunc].QuadPart == 0))
				AfpServerProfile->perf_ApiWorstTime[pSda->sda_AfpFunc].QuadPart = FuncTime.QuadPart;

			if ((FuncTime.QuadPart < AfpServerProfile->perf_ApiBestTime[pSda->sda_AfpFunc].QuadPart) ||
				(AfpServerProfile->perf_ApiBestTime[pSda->sda_AfpFunc].QuadPart == 0))
				AfpServerProfile->perf_ApiBestTime[pSda->sda_AfpFunc].QuadPart = FuncTime.QuadPart;
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&AfpStatisticsLock);
	}
#endif

	INTERLOCKED_ADD_STATISTICS(&AfpServerStatistics.stat_DataOut,
							   (LONG)pSda->sda_ReplySize + (LONG)sizeof(RetCode),
							   &AfpStatisticsLock);

	pRequest = pSda->sda_Request;

	// We are done with the request. Do not reset if we have a deferred request to process
	if (pDfrdReq == NULL)
	{
		pSda->sda_Flags &= ~SDA_REQUEST_IN_PROCESS;
	}
	else
	{
		pSda->sda_Request = pDfrdReq->drq_pRequest;
	}

	// We are done with the request. Setup for reply.
	pSda->sda_Flags |= SDA_REPLY_IN_PROCESS;
	ReplyMdl = NULL;

    //
    // if we got Read Mdl from cache mgr, we don't allocate a new Mdl
    //
    if (pRequest->rq_CacheMgrContext)
    {
        ASSERT(pSda->sda_ReplyBuf == NULL);

        ReplyMdl = ((PDELAYEDALLOC)(pRequest->rq_CacheMgrContext))->pMdl;
    }

    //
    // nope, we are using our own buffer (if any).  We must allocate our
    // Mdl too
    //
    else
    {
	    if (pSda->sda_ReplyBuf != NULL)
	    {
		    ASSERT ((pSda->sda_ReplySize > 0) && (pSda->sda_ReplySize <= pSda->sda_MaxWriteSize));

		    if ((ReplyMdl = AfpAllocMdl(
                                (pSda->sda_ReplyBuf - DSI_BACKFILL_OFFSET(pSda)),
                                (pSda->sda_ReplySize + DSI_BACKFILL_OFFSET(pSda)),
                                NULL)) == NULL)
		    {
			    RetCode = AFP_ERR_MISC;
                AfpFreeReplyBuf(pSda, TRUE);
		    }
	    }
    }

	pSda->sda_ReplyBuf = NULL;
	pSda->sda_ReplySize = 0;

	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);

	// Dereference the connection descriptor and the fork descriptor (from
	// above where we cannot call dereference as we are holding the SDA lock.
	if (pOpenForkEntry != NULL)
		AfpForkDereference(pOpenForkEntry);

	if (pConnDesc != NULL)
		AfpConnectionDereference(pConnDesc);

	pRequest->rq_ReplyMdl = ReplyMdl;

	AfpSpReplyClient(pRequest, RetCode, pSda->sda_XportTable);

	// Handle any deferred requests
	if (pDfrdReq != NULL)
	{
		KIRQL	OldIrql;

		// Note that AfpUnmarshallReq expects to be called at DISPATCH_LEVEL
		KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

#ifdef	PROFILING
		ACQUIRE_SPIN_LOCK_AT_DPC(&AfpStatisticsLock);
	
		AfpServerProfile->perf_CurDfrdReqCount --;
	
		RELEASE_SPIN_LOCK_FROM_DPC(&AfpStatisticsLock);
#endif

		AfpUnmarshallReq(pSda);
		KeLowerIrql(OldIrql);
	
		AfpFreeMemory(pDfrdReq);
	}
}



/***	AfpStartApiProcessing
 *
 *	This is called when an API is queued up to the worker thread. This calls
 *	the real worker and then adjusts the count of outstanding worker requests.
 */
VOID FASTCALL
AfpStartApiProcessing(
	IN	PSDA	pSda
)
{
	AFPSTATUS	RetCode;
#ifdef	PROFILING
	TIME		TimeE;
#endif

	ASSERT(VALID_SDA(pSda) && (pSda->sda_WorkerRoutine != NULL));

	DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
						("AfpStartApiProcessing: Calling Fsp Worker for <%s>\n",
						afpApiNames[pSda->sda_AfpFunc]));

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeE.QuadPart -= pSda->sda_QueueTime.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_QueueTime,
								 TimeE,
								 &AfpStatisticsLock);
#endif

	// Call the real worker
	RetCode = (*pSda->sda_WorkerRoutine)(pSda);

	DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
				("AfpStartApiProcessing: Fsp Worker returned %ld\n", RetCode));

	ASSERT ((RetCode != AFP_ERR_QUEUE) &&
			(RetCode != AFP_ERR_DEFER));

	if (RetCode != AFP_ERR_EXTENDED)
	{
		AfpCompleteApiProcessing(pSda, RetCode);
	}
}



/***	AfpDisposeRequest
 *
 *	The request has been un-marshalled. Determine what to do with it. The
 *	return code determines the possible course of action.
 */
VOID FASTCALL
AfpDisposeRequest(
	IN	PSDA		pSda,
	IN	AFPSTATUS	Status
)
{
	DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
			("AfpDisposeRequest: %ld\n", Status));

    if ((Status == AFP_ERR_NONE) || (Status == AFP_ERR_QUEUE))
    {
	    ASSERT(VALID_SDA(pSda) && (pSda->sda_WorkerRoutine != NULL));
    }
    else
    {
	    ASSERT(VALID_SDA(pSda));
    }

	ASSERT (Status != AFP_ERR_DEFER);

	// Now see if must call the worker or queue it or respond
	if (Status == AFP_ERR_NONE)
	{
		Status = (*pSda->sda_WorkerRoutine)(pSda);
		DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
				("AfpDisposeRequest: Fsd Worker returned %ld\n", Status));

		ASSERT (Status != AFP_ERR_DEFER);
	}

	if (Status == AFP_ERR_QUEUE)
	{
		if ((pSda->sda_Flags & SDA_QUEUE_IF_DPC) &&
			(KeGetCurrentIrql() != DISPATCH_LEVEL))
		{
			Status = (*pSda->sda_WorkerRoutine)(pSda);
			ASSERT ((Status != AFP_ERR_QUEUE) &&
					(Status != AFP_ERR_DEFER));

			if (Status != AFP_ERR_EXTENDED)
			{
				AfpCompleteApiProcessing(pSda, Status);
			}
		}
		else
		{
#ifdef	PROFILING
			AfpGetPerfCounter(&pSda->sda_QueueTime);
#endif
			AfpQueueWorkItem(&pSda->sda_WorkItem);
		}
	}

	else if ((Status != AFP_ERR_QUEUE) && (Status != AFP_ERR_EXTENDED))
	{
		AfpCompleteApiProcessing(pSda, Status);
	}
}



/***	afpQueueDeferredRequest
 *
 *	Queue a request in the deferred queue. The request is queued at the tail
 *	of the queue and dequeued at the head.
 *
 *	LOCKS_ASSUMED: sda_Lock (SPIN)
 */
VOID FASTCALL
afpQueueDeferredRequest(
	IN	PSDA		pSda,
	IN	PREQUEST	pRequest
)
{
	PDFRDREQQ		pDfrdReq;

	ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

	DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
			("afpQueueDeferredRequest: Deferring Request\n"));

#ifdef	PROFILING
	ACQUIRE_SPIN_LOCK_AT_DPC(&AfpStatisticsLock);

	AfpServerProfile->perf_CurDfrdReqCount ++;
	if (AfpServerProfile->perf_CurDfrdReqCount >
						AfpServerProfile->perf_MaxDfrdReqCount)
	AfpServerProfile->perf_MaxDfrdReqCount =
						AfpServerProfile->perf_CurDfrdReqCount;

	RELEASE_SPIN_LOCK_FROM_DPC(&AfpStatisticsLock);
#endif

	pDfrdReq = (PDFRDREQQ)AfpAllocNonPagedMemory(sizeof(DFRDREQQ) + pRequest->rq_RequestSize);
	if (pDfrdReq == NULL)
	{
		// Should we respond to this request ? How ? Should we drop this session ?
		AFPLOG_DDERROR(AFPSRVMSG_DFRD_REQUEST,
					   STATUS_INSUFFICIENT_RESOURCES,
					   NULL,
					   0,
					   NULL);
		DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
				("afpQueueDeferredRequest: Unable to allocate DfrdReq packet, dropping request\n"));
		DBGBRK(DBG_LEVEL_FATAL);
		return;
	}

	RtlCopyMemory((PBYTE)pDfrdReq + sizeof(DFRDREQQ),
				  pRequest->rq_RequestBuf,
				  pRequest->rq_RequestSize);

	pDfrdReq->drq_pRequest = pRequest;
	pDfrdReq->drq_pRequest->rq_RequestBuf = (PBYTE)pDfrdReq + sizeof(DFRDREQQ);

	InsertTailList(&pSda->sda_DeferredQueue, &pDfrdReq->drq_Link);
}



/***	AfpGetWriteBuffer
 *
 *	This is called directly by the appletalk stack when a WRITE command is encountered.
 *	The request is examined for either FpWrite or FpAddIcon. These are the only reqs
 *	which uses a write command. If a request other than this is specified or if the
 *	size specified is 0 or if we fail to allocate memory or MDl, then a NULL is returned
 *	for the Mdl else a valid Mdl is returned.
 */
NTSTATUS FASTCALL
AfpGetWriteBuffer(
	IN	PSDA	    pSda,
	IN	PREQUEST    pRequest
)
{
	PMDL	            pMdl = NULL;
	PBYTE	            pBuf;
	LONG	            BufSize = 0;
    DWORD               Offset;
	USHORT		        ReqLen;
    PDELAYEDALLOC       pDelAlloc;
    POPENFORKENTRY      pOpenForkEntry;
    DWORD               OForkRefNum;
    NTSTATUS            status=STATUS_SUCCESS;
    KIRQL               OldIrql;
    PFILE_OBJECT        pFileObject;
    PFAST_IO_DISPATCH   pFastIoDisp;

	struct _FuncHdr
	{
		BYTE	_Func;
		BYTE	_SubFunc;
	};
	union _ReqHdr
	{
		struct _WriteReq
		{
			struct _FuncHdr	_FuncHdr;
			BYTE			_ForkRefNum[2];
			BYTE			_Offset[4];
			BYTE			_Size[4];
		} WriteReq;
		struct _AddIconReq
		{
			struct _FuncHdr	_FuncHdr;
			BYTE			_DTRefNum[2];
			BYTE			_Creator[4];
			BYTE			_Type[4];
			BYTE			_IconType;
			BYTE			_Reserved;
			BYTE			_IconTag[4];
			BYTE			_BitmapSize[2];
		} AddIconReq;
	} *pReqHdr;


    ReqLen = (USHORT)pRequest->rq_RequestSize;
	pReqHdr = (union _ReqHdr *)(pRequest->rq_RequestBuf);

    ASSERT(pRequest->rq_WriteMdl == NULL);

    pRequest->rq_WriteMdl = NULL;

	if ((pReqHdr != NULL) && (ReqLen >= sizeof(struct _FuncHdr)))
	{
		if ((pReqHdr->WriteReq._FuncHdr._Func == AFP_WRITE) &&
			(ReqLen >= sizeof(struct _WriteReq)))
		{
			GETDWORD2DWORD(&BufSize, pReqHdr->WriteReq._Size);

			if (BufSize > (LONG)pSda->sda_MaxWriteSize)
            {
				BufSize = (LONG)pSda->sda_MaxWriteSize;
            }

            //
            // if the Write is big enough, get an Mdl directly from cache mgr
            //
            if (BufSize >= CACHEMGR_WRITE_THRESHOLD)
            {
                // get the fork number from the request
                GETSHORT2DWORD(&OForkRefNum, pReqHdr->WriteReq._ForkRefNum);

                // get the offset at which to write
                GETDWORD2DWORD(&Offset, pReqHdr->WriteReq._Offset);

                KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
                pOpenForkEntry = AfpForkReferenceByRefNum(pSda, OForkRefNum);
                KeLowerIrql(OldIrql);

                if (pOpenForkEntry == NULL)
                {
	                DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	                    ("AfpGetWriteBuffer: couldn't ref fork on %lx\n", pSda));
                    return(STATUS_CONNECTION_DISCONNECTED);
                }

                pFileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
                pFastIoDisp = pOpenForkEntry->ofe_pDeviceObject->DriverObject->FastIoDispatch;

                if ((pFileObject->Flags & FO_CACHE_SUPPORTED) &&
                    (pFastIoDisp->PrepareMdlWrite != NULL))
                {

                    pDelAlloc = AfpAllocDelAlloc();

                    if (pDelAlloc == NULL)
                    {
	                    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	                        ("AfpGetWriteBuffer: malloc for pDelAlloc failed\n"));

                        // remove the refcount we put before checking FO_CACHE_SUPPORTED
                        AfpForkDereference(pOpenForkEntry);
                        return(STATUS_INSUFFICIENT_RESOURCES);
                    }

                    // put DelayAlloc refcount
                    if (AfpSdaReferenceSessionByPointer(pSda) == NULL)
                    {
	                    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	                        ("AfpGetWriteBuffer: session closing, rejecting request\n"));

                        AfpFreeDelAlloc(pDelAlloc);

                        // remove the refcount we put before checking FO_CACHE_SUPPORTED
                        AfpForkDereference(pOpenForkEntry);
                        return(STATUS_CONNECTION_DISCONNECTED);
                    }

                    pRequest->rq_CacheMgrContext = pDelAlloc;

                    AfpInitializeWorkItem(&pDelAlloc->WorkItem,
                                          AfpAllocWriteMdl,
                                          pDelAlloc);

                    pDelAlloc->pSda = pSda;
                    pDelAlloc->pRequest = pRequest;
                    pDelAlloc->Offset.QuadPart = Offset;
                    pDelAlloc->BufSize = BufSize;
                    pDelAlloc->pOpenForkEntry = pOpenForkEntry;

// DELALLOCQUEUE: unrem the #if 0 part and delete the AfpQueueWorkItem line
#if 0
                    KeInsertQueue(&AfpDelAllocQueue, &(pDelAlloc->WorkItem.wi_List));
#endif
                    AfpQueueWorkItem(&pDelAlloc->WorkItem);

                    return(STATUS_PENDING);
                }
                else
                {
                    // remove the refcount we put before checking FO_CACHE_SUPPORTED
                    AfpForkDereference(pOpenForkEntry);
                }
            }
		}

		else if ((pReqHdr->AddIconReq._FuncHdr._Func == AFP_ADD_ICON) &&
				 (ReqLen >= sizeof(struct _AddIconReq)))
		{
			GETSHORT2DWORD(&BufSize, pReqHdr->AddIconReq._BitmapSize);
			if ((BufSize < 0) || (BufSize > (LONG)pSda->sda_MaxWriteSize))
			{
				BufSize = 0;
			}
		}

		if (BufSize > 0)
		{
			pBuf = AfpIOAllocBuffer(BufSize);
			if (pBuf != NULL)
			{
				pMdl = AfpAllocMdl(pBuf, BufSize, NULL);
				if (pMdl == NULL)
				{
					AfpIOFreeBuffer(pBuf);
                    status = STATUS_INSUFFICIENT_RESOURCES;
				}
			}
            else
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
		}
	}

    pRequest->rq_WriteMdl = pMdl;

	return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\afpinfo.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	afpinfo.h

Abstract:

	This module contains the AfpInfo stream definitions.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _AFPINFO_
#define _AFPINFO_

typedef struct _AfpInfo
{
	DWORD		afpi_Signature;			// Signature
	LONG		afpi_Version;			// Version
	DWORD		afpi_Id;				// AFP File or directory Id
	DWORD		afpi_BackupTime;		// Backup time for the file/dir
										// (Volume backup time is stored
										// in the AFP_IdIndex stream)

	FINDERINFO	afpi_FinderInfo;		// Finder Info (32 bytes)
	PRODOSINFO	afpi_ProDosInfo;		// ProDos Info (6 bytes)

	USHORT		afpi_Attributes;		// Attributes mask (maps ReadOnly)

	BYTE		afpi_AccessOwner;		// Access mask (SFI vs. SFO)
	BYTE		afpi_AccessGroup;		// Directories only
	BYTE		afpi_AccessWorld;
} AFPINFO, *PAFPINFO;

//
// Initialize a AFPINFO structure with default values
//
// VOID
// AfpInitAfpInfo(
//		IN	PAFPINFO	pAfpInfo,
//		IN	DWORD		AfpId OPTIONAL, // 0 if we don't yet know the AFP Id
//		IN	BOOLEAN		IsDir
// )
//
#define AfpInitAfpInfo(_pAfpInfo, _AfpId, _IsDir, _BackupTime)	\
{																\
	RtlZeroMemory(&(_pAfpInfo)->afpi_FinderInfo,				\
				  sizeof(FINDERINFO)+sizeof(PRODOSINFO)+sizeof(USHORT));	\
	(_pAfpInfo)->afpi_Signature = AFP_SERVER_SIGNATURE;			\
	(_pAfpInfo)->afpi_Version = AFP_SERVER_VERSION;				\
	(_pAfpInfo)->afpi_BackupTime = (_BackupTime);				\
	(_pAfpInfo)->afpi_Id = (_AfpId);							\
	if (_IsDir)													\
	{															\
		(_pAfpInfo)->afpi_AccessOwner =							\
		(_pAfpInfo)->afpi_AccessGroup =							\
		(_pAfpInfo)->afpi_AccessWorld = DIR_ACCESS_READ | DIR_ACCESS_SEARCH;	\
		(_pAfpInfo)->afpi_ProDosInfo.pd_FileType[0] = PRODOS_TYPE_DIR;\
		(_pAfpInfo)->afpi_ProDosInfo.pd_AuxType[1] = PRODOS_AUX_DIR;\
	}															\
	else														\
	{															\
		(_pAfpInfo)->afpi_ProDosInfo.pd_FileType[0] = PRODOS_TYPE_FILE; \
	}															\
}

//
// Open or Create the AFP_AfpInfo stream on a file or directory using a
// relative handle to the DataStream of the file/dir.
// If the stream does not yet exist, create an empty one, else open the
// existing one.
//
// NTSTATUS
// AfpCreateAfpInfo(
//		IN	PFILESYSHANDLE	phDataStream,	// handle to data stream of file/dir
//		OUT PFILESYSHANDLE	phAfpInfo,		// handle to AFP_AfpInfo stream
//		OUT	PDWORD			pInformation OPTIONAL // stream was opened/created
// );
//
#define AfpCreateAfpInfo(phDataStream, phAfpInfo,pInformation)	\
	AfpIoCreate(phDataStream,					\
				AFP_STREAM_INFO,				\
				&UNullString,					\
				FILEIO_ACCESS_READWRITE,		\
				FILEIO_DENY_NONE,				\
				FILEIO_OPEN_FILE,				\
				FILEIO_CREATE_INTERNAL,			\
				FILE_ATTRIBUTE_NORMAL,			\
				False,							\
				NULL,							\
				phAfpInfo,						\
				pInformation,					\
				NULL,							\
				NULL,							\
				NULL)

//
// Open or Create the AFP_AfpInfo stream on a file or directory using a
// relative handle to the parent directory, and the name of the file/dir.
// If the stream does not yet exist, create an empty one, else open the
// existing one.
//
// NTSTATUS
// AfpCreateAfpInfoWithNodeName(
//		IN	PFILESYSHANDLE	phRelative,				// handle to parent of file/dir
//		IN	PUNICODE_STRING pUEntityName,			// file/dir name of entity
//		IN	PVOLDESC		pVolDesc,				// Volume in question
//		OUT PFILESYSHANDLE	phAfpInfo,				// handle to AFP_AfpInfo stream
//		OUT	PDWORD			pInformation OPTIONAL	// stream was opened/created
// );
//
#define AfpCreateAfpInfoWithNodeName(phDataStream, pUEntityName, pNotifyPath, pVolDesc, phAfpInfo, pInformation) \
	AfpIoCreate(phDataStream,			\
				AFP_STREAM_INFO,		\
				pUEntityName,			\
				FILEIO_ACCESS_READWRITE,\
				FILEIO_DENY_NONE,		\
				FILEIO_OPEN_FILE,		\
				FILEIO_CREATE_INTERNAL,	\
				FILE_ATTRIBUTE_NORMAL,	\
				False,					\
				NULL,					\
				phAfpInfo,				\
				pInformation,			\
				pVolDesc,				\
				pNotifyPath,			\
				NULL)
//
// If we temporarily removed the ReadOnly attribute from a file or directory
// in order to write to the AFP_AfpInfo stream, set the attribute back on.
// (see AfpExamineAndClearROAttr)
//
// VOID
// AfpPutBackROAttr(
// 	IN	PFILESYSHANDLE 	pfshData,	// Handle to data stream of file/dir
//	IN	BOOLEAN			WriteBack	// Did we clear the RO bit to begin with?
// );
//
#define AfpPutBackROAttr(pfshData, WriteBack)	\
	if (WriteBack == True) 						\
	{											\
		AfpIoSetTimesnAttr(pfshData, NULL, NULL, FILE_ATTRIBUTE_READONLY, 0, NULL, NULL); \
	}

extern
NTSTATUS FASTCALL
AfpReadAfpInfo(
	IN	PFILESYSHANDLE	pfshAfpInfo,
	OUT PAFPINFO		pAfpInfo
);

//
//extern
//NTSTATUS
//AfpWriteAfpInfo(
//	IN	PFILESYSHANDLE			pfshAfpInfo,
//	IN	PAFPINFO				pAfpInfo
//);
//
#define AfpWriteAfpInfo(pfshAfpInfo,pAfpInfo) \
	AfpIoWrite(pfshAfpInfo, &LIZero, sizeof(AFPINFO), (PBYTE)pAfpInfo)

extern
VOID FASTCALL
AfpSetFinderInfoByExtension(
	IN	PUNICODE_STRING			pFileName,
	OUT	PFINDERINFO				pFinderInfo
);

extern
VOID FASTCALL
AfpProDosInfoFromFinderInfo(
	IN	PFINDERINFO				pFinderInfo,
	OUT PPRODOSINFO 			pProDosInfo
);

extern
VOID FASTCALL
AfpFinderInfoFromProDosInfo(
	IN	PPRODOSINFO				pProDosInfo,
	OUT PFINDERINFO				pFinderInfo
);

extern
NTSTATUS
AfpSlapOnAfpInfoStream(
	IN	struct _VolDesc *		pVolDesc OPTIONAL,
	IN	PUNICODE_STRING			pNotifyPath			OPTIONAL,
	IN	PFILESYSHANDLE			phDataStream,
	IN	PFILESYSHANDLE			pfshAfpInfoStream	OPTIONAL,
	IN	DWORD					AfpId,
	IN	BOOLEAN					IsDirectory,
	IN	PUNICODE_STRING			pName				OPTIONAL,	// only needed for files
	OUT PAFPINFO				pAfpInfo
);

extern
NTSTATUS
AfpCreateAfpInfoStream(
	IN	struct _VolDesc *		pVolDesc			OPTIONAL,
	IN	PFILESYSHANDLE			pfshData,
	IN	DWORD					AfpId,
	IN	BOOLEAN					IsDirectory,
	IN	PUNICODE_STRING			pName				OPTIONAL,	// only needed for files
	IN  PUNICODE_STRING			pNotifyPath,
	OUT PAFPINFO				pAfpInfo,
	OUT	PFILESYSHANDLE			pfshAfpInfo
);

extern
NTSTATUS FASTCALL
AfpExamineAndClearROAttr(
	IN	PFILESYSHANDLE			pfshData,
	OUT	PBOOLEAN				pWriteBackROAttr,
	IN	struct _VolDesc *		pVolDesc			OPTIONAL,
	IN	PUNICODE_STRING			pPath				OPTIONAL
);

extern
AFPSTATUS
AfpSetAfpInfo(
	IN	PFILESYSHANDLE			pfshData,			// handle to data stream of object
	IN	DWORD					Bitmap,
	IN	struct _FileDirParms *	pFDParm,
	IN	struct _VolDesc *		pVolDesc			OPTIONAL,
	IN	struct _DirFileEntry ** ppDFE				OPTIONAL
);

extern
AFPSTATUS FASTCALL
AfpQueryProDos(
	IN	PFILESYSHANDLE			pfshData,
	OUT	PPRODOSINFO				pProDosInfo
);

extern
AFPSTATUS FASTCALL
AfpUpdateIdInAfpInfo(
	IN	struct _VolDesc *		pVolDesc,
	IN	struct _DirFileEntry *	pDfEntry
);

#endif	// _AFPINFO_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\afpinfo.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	afpinfo.c

Abstract:

	This module contains the routines for manipulating the afpinfo stream.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4

--*/


#define	FILENUM	FILE_AFPINFO

#include <afp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <afpinfo.h>
#include <afpadmin.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpSetAfpInfo)
#pragma alloc_text( PAGE, AfpReadAfpInfo)
#pragma alloc_text( PAGE, AfpSetFinderInfoByExtension)
#pragma alloc_text( PAGE, AfpProDosInfoFromFinderInfo)
#pragma alloc_text( PAGE, AfpFinderInfoFromProDosInfo)
#pragma alloc_text( PAGE, AfpSlapOnAfpInfoStream)
#pragma alloc_text( PAGE, AfpCreateAfpInfoStream)
#pragma alloc_text( PAGE, AfpExamineAndClearROAttr)
#pragma alloc_text( PAGE, AfpQueryProDos)
#endif

/***	AfpSetAfpInfo
 *
 *	Sets the values specified by Bitmap in the AFP_AfpInfo stream of a file
 *	or directory.  If FinderInfo is specified without ProDosInfo, or
 *	vice-versa, the one not specified is deduced from the other and also set.
 *	If the file/dir is marked ReadOnly, we must clear the readonly bit in order
 *	to write to the Afp_AfpInfo stream, and then set the RO bit back again.
 *  If pVolDesc is specified, then also update the cached AfpInfo in the
 *  IdDb DFENTRY.
 *
  */
AFPSTATUS
AfpSetAfpInfo(
	IN	PFILESYSHANDLE	pfshData,				// handle to data stream of object
	IN	DWORD			Bitmap,
	IN	PFILEDIRPARM	pFDParms,
	IN	PVOLDESC		pVolDesc	OPTIONAL,	// if present, update cached afpinfo
	IN	PDFENTRY	*	ppDFE		OPTIONAL	// pVolDesc must also be specified
)
{
	NTSTATUS		Status;
	DWORD			crinfo, NTAttr = 0;
	AFPINFO			afpinfo;
	FILESYSHANDLE	fshAfpInfo;
	BOOLEAN			isdir, WriteBackROAttr = False, mapprodos = False;
	PDFENTRY		pDfEntry = NULL;

	PAGED_CODE( );

	fshAfpInfo.fsh_FileHandle = NULL;

	isdir = IsDir(pFDParms);

	if (ARGUMENT_PRESENT(pVolDesc))
	{
		ASSERT(AfpSwmrLockedExclusive(&pVolDesc->vds_IdDbAccessLock));
		pDfEntry = AfpFindDfEntryById(pVolDesc,
									  pFDParms->_fdp_AfpId,
									  isdir ? DFE_DIR : DFE_FILE);
		if (pDfEntry == NULL)
		{
			return AFP_ERR_OBJECT_NOT_FOUND;
		}
	}

	do
	{
		if (!NT_SUCCESS(Status = AfpCreateAfpInfo(pfshData, &fshAfpInfo, &crinfo)))
		{
			if (Status == STATUS_ACCESS_DENIED)
			{
				// We may have failed to open the AFP_Afpinfo stream because
				// the file/dir is marked ReadOnly.  Clear the ReadOnly bit
				// and try to open it again.
				Status = AfpExamineAndClearROAttr(pfshData,
												  &WriteBackROAttr,
												  NULL,
												  NULL);
				if (NT_SUCCESS(Status))
				{
					if (!NT_SUCCESS(Status = AfpCreateAfpInfo(pfshData, &fshAfpInfo, &crinfo)))
					{
						AfpPutBackROAttr(pfshData, WriteBackROAttr);
						Status = AfpIoConvertNTStatusToAfpStatus(Status);
						break;
					}
				}
				else
				{
					Status = AFP_ERR_MISC;
					break;
				}
			}
			else
			{
				Status = AfpIoConvertNTStatusToAfpStatus(Status);
				break;
			}
		}

		// If it was newly created or it existed but was corrupted, then initialize
		// it with default data.  Otherwise read in the current data
		if ((crinfo == FILE_CREATED) ||
			(!NT_SUCCESS(AfpReadAfpInfo(&fshAfpInfo, &afpinfo))))
		{
			UNICODE_STRING	UName;
			WCHAR			NameBuf[AFP_LONGNAME_LEN+1];

			if (crinfo != FILE_CREATED)
			{
				AFPLOG_HERROR(AFPSRVMSG_AFPINFO,
							  0,
							  NULL,
							  0,
							  pfshData->fsh_FileHandle);
			}

			if (!isdir)
			{
				AfpSetEmptyUnicodeString(&UName, sizeof(NameBuf), NameBuf);
				AfpConvertStringToMungedUnicode(&pFDParms->_fdp_LongName, &UName);
			}

			// All callers of this routine must have the FD_BITMAP_LONGNAME
			// bit forced in their bitmap to pathmap, so that in this case
			// where the afpinfo stream must be recreated for a *file*, we
			// will always have a valid _fdp_Longname set in FDParm and can
			// deduce the type/creator
			if (!NT_SUCCESS(AfpSlapOnAfpInfoStream(NULL,
												   NULL,
												   pfshData,
												   &fshAfpInfo,
												   pFDParms->_fdp_AfpId,
												   isdir,
												   isdir ? NULL : &UName,
												   &afpinfo)))
			{
				Status = AFP_ERR_MISC;
				break;
			}
			else if (pDfEntry != NULL)
				DFE_UPDATE_CACHED_AFPINFO(pDfEntry, &afpinfo);
		}

		if (Bitmap & FD_BITMAP_BACKUPTIME)
		{
			afpinfo.afpi_BackupTime = pFDParms->_fdp_BackupTime;
			if (pDfEntry != NULL)
				pDfEntry->dfe_BackupTime = afpinfo.afpi_BackupTime;
		}

		if (Bitmap & FD_BITMAP_FINDERINFO)
		{	// Only map new ProDOS info if there has been a change in the
			// type/creator, and FD_BITMAP_PRODOSINFO is not set (files only)
			if (!(Bitmap & FD_BITMAP_PRODOSINFO) &&
				!isdir &&
				((RtlCompareMemory(afpinfo.afpi_FinderInfo.fd_Type,
								   pFDParms->_fdp_FinderInfo.fd_Type,
								   AFP_TYPE_LEN) != AFP_TYPE_LEN) ||
				 (RtlCompareMemory(afpinfo.afpi_FinderInfo.fd_Creator,
								   pFDParms->_fdp_FinderInfo.fd_Creator,
								   AFP_CREATOR_LEN) != AFP_CREATOR_LEN)))
			{
				mapprodos = True;
			}

			afpinfo.afpi_FinderInfo = pFDParms->_fdp_FinderInfo;

			if (mapprodos)
			{
				AfpProDosInfoFromFinderInfo(&afpinfo.afpi_FinderInfo,
											&afpinfo.afpi_ProDosInfo);
			}

			if (pDfEntry != NULL)
				pDfEntry->dfe_FinderInfo = afpinfo.afpi_FinderInfo;
		}

		if (Bitmap & FD_BITMAP_PRODOSINFO)
		{
			if ((IsDir(pFDParms)) &&
				(pFDParms->_fdp_ProDosInfo.pd_FileType[0] != PRODOS_TYPE_DIR))
			{
				Status = AFP_ERR_ACCESS_DENIED;
				break;
			}

			afpinfo.afpi_ProDosInfo = pFDParms->_fdp_ProDosInfo;

			if (!(Bitmap & FD_BITMAP_FINDERINFO) && !isdir)
			{
				AfpFinderInfoFromProDosInfo(&afpinfo.afpi_ProDosInfo,
											&afpinfo.afpi_FinderInfo);
				if (pDfEntry != NULL)
					pDfEntry->dfe_FinderInfo = afpinfo.afpi_FinderInfo;
			}
		}

		if (Bitmap & FD_BITMAP_ATTR)
		{
			afpinfo.afpi_Attributes =
							pFDParms->_fdp_EffectiveAttr & ~FD_BITMAP_ATTR_SET;
			if (pDfEntry != NULL)
				pDfEntry->dfe_AfpAttr = afpinfo.afpi_Attributes;
		}

		if (Bitmap & DIR_BITMAP_ACCESSRIGHTS)
		{
			ASSERT(isdir == True);
			afpinfo.afpi_AccessOwner = pFDParms->_fdp_OwnerRights;
			afpinfo.afpi_AccessGroup = pFDParms->_fdp_GroupRights;
			afpinfo.afpi_AccessWorld = pFDParms->_fdp_WorldRights;

			if (pDfEntry != NULL)
			{
				DFE_OWNER_ACCESS(pDfEntry) = afpinfo.afpi_AccessOwner;
				DFE_GROUP_ACCESS(pDfEntry) = afpinfo.afpi_AccessGroup;
				DFE_WORLD_ACCESS(pDfEntry) = afpinfo.afpi_AccessWorld;
			}
		}

		// FILE_BITMAP_FILENUM can ONLY be set by the internal CopyFile code
		// and internal ExchangeFiles code
		if (Bitmap & FILE_BITMAP_FILENUM)
		{
			ASSERT(isdir == False);
			afpinfo.afpi_Id = pFDParms->_fdp_AfpId;
		}

		Status = AfpWriteAfpInfo(&fshAfpInfo, &afpinfo);
		if (!NT_SUCCESS(Status))
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
	} while (False);

	AfpPutBackROAttr(pfshData, WriteBackROAttr);
	if (fshAfpInfo.fsh_FileHandle != NULL)
		AfpIoClose(&fshAfpInfo);

	if (ARGUMENT_PRESENT(ppDFE))
	{
		ASSERT(ARGUMENT_PRESENT(pVolDesc));
		*ppDFE = pDfEntry;
	}

	return Status;
}

/***	AfpReadAfpInfo
 *
 *	When discovering a file/dir that has the AfpInfo stream, read it in
 *
 */
NTSTATUS FASTCALL
AfpReadAfpInfo(
	IN	PFILESYSHANDLE	pfshAfpInfo,
	OUT PAFPINFO		pAfpInfo
)
{
	NTSTATUS	Status;
	LONG		sizeRead;

	PAGED_CODE( );

	Status = AfpIoRead(pfshAfpInfo,
					   &LIZero,
					   sizeof(AFPINFO),
					   &sizeRead,
					   (PBYTE)pAfpInfo);

	if (!NT_SUCCESS(Status)									||
		(sizeRead != sizeof(AFPINFO))						||
		(pAfpInfo->afpi_Signature != AFP_SERVER_SIGNATURE)	||
		(pAfpInfo->afpi_Version != AFP_SERVER_VERSION))
	{
		if (NT_SUCCESS(Status) &&
			(sizeRead != 0)	   &&
			((pAfpInfo->afpi_Signature != AFP_SERVER_SIGNATURE)	||
			 (pAfpInfo->afpi_Version != AFP_SERVER_VERSION)))
		{
			AFPLOG_HERROR(AFPSRVMSG_AFPINFO,
						  Status,
						  NULL,
						  0,
						  pfshAfpInfo->fsh_FileHandle);
		}

		if ((sizeRead != sizeof(AFPINFO)) && (sizeRead != 0))
		{
			DBGPRINT(DBG_COMP_AFPINFO, DBG_LEVEL_ERR,
					 ("AfpReadAfpInfo: sizeRead (%d) != sizeof AFPINFO (%d)",
					 sizeRead, sizeof(AFPINFO)));
		}
		AfpIoSetSize(pfshAfpInfo, 0);
		Status = STATUS_UNSUCCESSFUL;
	}

	return Status;
}

/***	AfpSetFinderInfoByExtension
 *
 *	Set the finder info (type/creator) based on the file extension. Only long
 *	name is used for this mapping.
 *
 *	LOCKS: AfpEtcMapLock (SWMR, Shared)
 */
VOID FASTCALL
AfpSetFinderInfoByExtension(
	IN	PUNICODE_STRING	pFileName,
	OUT	PFINDERINFO		pFinderInfo
)
{
	PETCMAPINFO		pEtcMap = NULL;
	PWCHAR			pch;
	DWORD			len, i = AFP_EXTENSION_LEN;
	UCHAR			ext[AFP_EXTENSION_LEN+1];
	WCHAR			wext[AFP_EXTENSION_LEN+1];
	ANSI_STRING		aext;
	UNICODE_STRING	uext;

	PAGED_CODE( );

    RtlZeroMemory(ext, sizeof(ext));

	ASSERT(pFileName != NULL);

	// Find the last character of the filename
	pch = pFileName->Buffer + (pFileName->Length - sizeof(WCHAR))/sizeof(WCHAR);
	len = pFileName->Length/sizeof(WCHAR);

	AfpSwmrAcquireShared(&AfpEtcMapLock);

	while ((AFP_EXTENSION_LEN - i) < len)
	{
		if (*pch == L'.')
		{
			if (i < AFP_EXTENSION_LEN)
			{
				AfpSetEmptyAnsiString(&aext, sizeof(ext), ext);
				AfpInitUnicodeStringWithNonNullTerm(&uext,
													(USHORT)((AFP_EXTENSION_LEN - i)*sizeof(WCHAR)),
													&wext[i]);
				AfpConvertMungedUnicodeToAnsi(&uext, &aext);
				pEtcMap = AfpLookupEtcMapEntry(ext);
			}
			break;
		}
		if (i == 0)
			break;
		wext[--i] = *(pch--);
	}

	if (pEtcMap == NULL)
		pEtcMap = &AfpDefaultEtcMap;

	RtlCopyMemory(&pFinderInfo->fd_Type, &pEtcMap->etc_type, AFP_TYPE_LEN);
	RtlCopyMemory(&pFinderInfo->fd_Creator, &pEtcMap->etc_creator, AFP_CREATOR_LEN);
	AfpSwmrRelease(&AfpEtcMapLock);
}

/***	AfpProDosInfoFromFinderInfo
 *
 *	Given finder info, deduce the corresponding prodos info. It is up to the
 *	caller to decide whether or not FinderInfo type/creator is actually
 *	changing (if client is just resetting the same values or not), in which
 *	case the prodos info should be left untouched. (Inside Appletalk p. 13-19)
 *	NOTE: see layout of ProDOS info on p. 13-18 of Inside Appletalk, 2nd Ed.)
 */
VOID FASTCALL
AfpProDosInfoFromFinderInfo(
	IN	PFINDERINFO	pFinderInfo,
	OUT PPRODOSINFO pProDosInfo
)
{
	CHAR		buf[3];
	ULONG		filetype;
	NTSTATUS	Status;

	PAGED_CODE( );

	RtlZeroMemory(pProDosInfo, sizeof(PRODOSINFO));
	if (RtlCompareMemory(pFinderInfo->fd_Type, "TEXT", AFP_TYPE_LEN) == AFP_TYPE_LEN)
	{
		pProDosInfo->pd_FileType[0] = PRODOS_TYPE_FILE;
	}
	else if (RtlCompareMemory(pFinderInfo->fd_Creator,
							  "pdos",
							  AFP_CREATOR_LEN) == AFP_CREATOR_LEN)
	{
		if (RtlCompareMemory(pFinderInfo->fd_Type,
							 "PSYS",
							 AFP_TYPE_LEN) == AFP_TYPE_LEN)
		{
			pProDosInfo->pd_FileType[0] = PRODOS_FILETYPE_PSYS;
		}
		else if (RtlCompareMemory(pFinderInfo->fd_Type,
								  "PS16",
								  AFP_TYPE_LEN) == AFP_TYPE_LEN)
		{
			pProDosInfo->pd_FileType[0] = PRODOS_FILETYPE_PS16;
		}
		else if (pFinderInfo->fd_Type[0] == 'p')
		{
			pProDosInfo->pd_FileType[0] = pFinderInfo->fd_Type[1];
			pProDosInfo->pd_AuxType[0] = pFinderInfo->fd_Type[3];
			pProDosInfo->pd_AuxType[1] = pFinderInfo->fd_Type[2];
		}
		else if ((pFinderInfo->fd_Type[2] == ' ') &&
				 (pFinderInfo->fd_Type[3] == ' ') &&
				 (isxdigit(pFinderInfo->fd_Type[0])) &&
				 (isxdigit(pFinderInfo->fd_Type[1])))
		{
			buf[0] = pFinderInfo->fd_Type[0];
			buf[1] = pFinderInfo->fd_Type[1];
			buf[2] = 0;
			Status = RtlCharToInteger(buf, 16, &filetype);
			ASSERT(NT_SUCCESS(Status));
			pProDosInfo->pd_FileType[0] = (BYTE)filetype;
		}
	}
}

/***	AfpFinderInfoFromProDosInfo
 *
 *	Given the prodos info, deduce the corresponding finder info.
 */
VOID FASTCALL
AfpFinderInfoFromProDosInfo(
	IN	PPRODOSINFO	pProDosInfo,
	OUT PFINDERINFO	pFinderInfo
)
{
	PAGED_CODE( );

	RtlCopyMemory(pFinderInfo->fd_Creator,"pdos",AFP_CREATOR_LEN);
	if ((pProDosInfo->pd_FileType[0] == PRODOS_TYPE_FILE) &&
		(pProDosInfo->pd_AuxType[0] == 0) &&
		(pProDosInfo->pd_AuxType[1] == 0))
	{
		RtlCopyMemory(&pFinderInfo->fd_Type,"TEXT",AFP_TYPE_LEN);
	}
	else if (pProDosInfo->pd_FileType[0] == PRODOS_FILETYPE_PSYS)
	{
		RtlCopyMemory(&pFinderInfo->fd_Type,"PSYS",AFP_TYPE_LEN);
	}
	else if (pProDosInfo->pd_FileType[0] == PRODOS_FILETYPE_PS16)
	{
		RtlCopyMemory(&pFinderInfo->fd_Type,"PS16",AFP_TYPE_LEN);
	}
	else if (pProDosInfo->pd_FileType[0] == 0)
	{
		RtlCopyMemory(&pFinderInfo->fd_Type,"BINA",AFP_TYPE_LEN);
	}
	else
	{
		pFinderInfo->fd_Type[0] = 'p';
		pFinderInfo->fd_Type[1] = pProDosInfo->pd_FileType[0];
		pFinderInfo->fd_Type[2] = pProDosInfo->pd_AuxType[1];
		pFinderInfo->fd_Type[3] = pProDosInfo->pd_AuxType[0];
	}
}

/***	AfpSlapOnAfpInfoStream
 *
 *	When creating a file or directory, this is called to add the AFP_AfpInfo
 *	stream.  No client impersonation is done to open/read/write this stream.
 *	If pfshAfpInfoStream is supplied, that handle is used, else a handle is
 *	opened (and pfshData MUST be supplied);
 */
NTSTATUS
AfpSlapOnAfpInfoStream(
	IN	PVOLDESC	   	pVolDesc			OPTIONAL,	// only if catching
	IN	PUNICODE_STRING	pNotifyPath			OPTIONAL,	// changes to size of
	                                                    // Afpinfo stream
	IN	PFILESYSHANDLE	pfshData			OPTIONAL,
	IN	PFILESYSHANDLE	pfshAfpInfoStream	OPTIONAL,
	IN	DWORD			AfpId,
	IN	BOOLEAN			IsDirectory,
	IN	PUNICODE_STRING	pName				OPTIONAL,	// needed for files
	OUT PAFPINFO		pAfpInfo
)
{
	NTSTATUS		Status;
	FILESYSHANDLE	fshAfpInfo;
	BOOLEAN			WriteBackROAttr = False;

	PAGED_CODE( );

	ASSERT((pfshData != NULL) || (pfshAfpInfoStream != NULL));

	if (!ARGUMENT_PRESENT(pfshAfpInfoStream))
	{
		if (!NT_SUCCESS(Status = AfpCreateAfpInfo(pfshData, &fshAfpInfo, NULL)))
		{
			if (Status == STATUS_ACCESS_DENIED)
			{
				// We may have failed to open the AFP_Afpinfo stream because
				// the file/dir is marked ReadOnly.  Clear the ReadOnly bit
				// and try to open it again.
				Status = AfpExamineAndClearROAttr(pfshData,
												  &WriteBackROAttr,
												  pVolDesc,
												  pNotifyPath);
				if (NT_SUCCESS(Status))
				{
					if (!NT_SUCCESS(Status = AfpCreateAfpInfo(pfshData,
															  &fshAfpInfo,
															  NULL)))
					{
						AfpPutBackROAttr(pfshData, WriteBackROAttr);
					}
				}
			}
			if (!NT_SUCCESS(Status))
				return Status;
		}

	}
	else fshAfpInfo = *pfshAfpInfoStream;

	AfpInitAfpInfo(pAfpInfo, AfpId, IsDirectory, BEGINNING_OF_TIME);
	if (!IsDirectory)
	{
		ASSERT(pName != NULL);
		AfpSetFinderInfoByExtension(pName,
									&pAfpInfo->afpi_FinderInfo);
		AfpProDosInfoFromFinderInfo(&pAfpInfo->afpi_FinderInfo,
									&pAfpInfo->afpi_ProDosInfo);
	}

	AfpIoSetSize(&fshAfpInfo, 0);
	Status = AfpWriteAfpInfo(&fshAfpInfo, pAfpInfo);
	if (NT_SUCCESS(Status) &&
		ARGUMENT_PRESENT(pVolDesc) &&
		ARGUMENT_PRESENT(pNotifyPath))
	{
		// Do both FILE_ACTION_MODIFIED_STREAM and FILE_ACTION_MODIFIED in one go
		AfpQueueOurChange(pVolDesc,
				          FILE_ACTION_MODIFIED_STREAM,
						  pNotifyPath,
						  pNotifyPath);
	}

	if (!ARGUMENT_PRESENT(pfshAfpInfoStream))
	{
		AfpIoClose(&fshAfpInfo);
		AfpPutBackROAttr(pfshData, WriteBackROAttr);
	}

	return Status;
}


/***	AfpCreateAfpInfoStream
 *
 *	Similar to AfpSlapOnAfpInfoStream but tuned to Create file/directory case.
 */
NTSTATUS
AfpCreateAfpInfoStream(
	IN  PVOLDESC		pVolDesc,
	IN	PFILESYSHANDLE	pfshData,
	IN	DWORD			AfpId,
	IN	BOOLEAN			IsDirectory,
	IN	PUNICODE_STRING	pName			OPTIONAL,	// only needed for files
	IN	PUNICODE_STRING	pNotifyPath,
	OUT PAFPINFO		pAfpInfo,
	OUT	PFILESYSHANDLE	pfshAfpInfo
)
{
	NTSTATUS		Status;
	BOOLEAN			WriteBackROAttr = False;
	DWORD			crinfo;

	PAGED_CODE( );

	ASSERT((pfshData != NULL) && (pfshAfpInfo != NULL));

	do
	{
		if (!NT_SUCCESS(Status = AfpCreateAfpInfo(pfshData, pfshAfpInfo, &crinfo)))
		{
			if (Status == STATUS_ACCESS_DENIED)
			{
				// We may have failed to open the AFP_Afpinfo stream because
				// the file/dir is marked ReadOnly.  Clear the ReadOnly bit
				// and try to open it again.
				Status = AfpExamineAndClearROAttr(pfshData,
												  &WriteBackROAttr,
												  pVolDesc,
												  pNotifyPath);
				if (NT_SUCCESS(Status))
				{
					if (!NT_SUCCESS(Status = AfpCreateAfpInfo(pfshData,
															  pfshAfpInfo,
															  &crinfo)))
					{
						AfpPutBackROAttr(pfshData, WriteBackROAttr);
					}
				}
			}
			if (!NT_SUCCESS(Status))
				break;
		}

		AfpInitAfpInfo(pAfpInfo, AfpId, IsDirectory, BEGINNING_OF_TIME);
		if (!IsDirectory)
		{
			ASSERT(pName != NULL);
			AfpSetFinderInfoByExtension(pName,
										&pAfpInfo->afpi_FinderInfo);
			AfpProDosInfoFromFinderInfo(&pAfpInfo->afpi_FinderInfo,
										&pAfpInfo->afpi_ProDosInfo);
		}

		Status = AfpWriteAfpInfo(pfshAfpInfo, pAfpInfo);
		if (NT_SUCCESS(Status) && (crinfo == FILE_CREATED))
		{
			// Do both FILE_ACTION_MODIFIED_STREAM and FILE_ACTION_MODIFIED in one go
			AfpQueueOurChange(pVolDesc,
					          FILE_ACTION_MODIFIED_STREAM,
							  pNotifyPath,
							  pNotifyPath);
		}
		AfpPutBackROAttr(pfshData, WriteBackROAttr);
	} while (False);

	return Status;
}


/***	AfpExamineAndClearROAttr
 *
 *	If the ReadOnly attribute is set on a file or directory, clear it.
 *	pWriteBackROAttr is a boolean indicating whether or not the caller must
 *	subsequently reset the Readonly bit on the file/dir. (see AfpPutBackROAttr)
 */
NTSTATUS FASTCALL
AfpExamineAndClearROAttr(
	IN	PFILESYSHANDLE	pfshData,
	OUT	PBOOLEAN		pWriteBackROAttr,
	IN	PVOLDESC		pVolDesc		OPTIONAL,
	IN	PUNICODE_STRING	pPath			OPTIONAL
)
{
	NTSTATUS	Status;
	DWORD		NTAttr = 0;

	PAGED_CODE( );

	ASSERT(VALID_FSH(pfshData));

	*pWriteBackROAttr = False;
	if (NT_SUCCESS(Status = AfpIoQueryTimesnAttr(pfshData, NULL, NULL, &NTAttr)) &&
		(NTAttr & FILE_ATTRIBUTE_READONLY))
	{
		// We need to clear the readonly bit.
		if (NT_SUCCESS(Status = AfpIoSetTimesnAttr(pfshData,
												   NULL,
												   NULL,
												   0,
												   FILE_ATTRIBUTE_READONLY,
												   pVolDesc,
												   pPath)))
		{
			*pWriteBackROAttr = True;
		}
	}
	return Status;
}

/***	AfpQueryProDos
 *
 *	Open the afpinfo stream relative to the file's Data handle, and
 *  read the ProDOS info out of it.  If the AfpInfo stream does not
 *  exist, return an error.
 *
 */
AFPSTATUS FASTCALL
AfpQueryProDos(
	IN	PFILESYSHANDLE	pfshData,
	OUT	PPRODOSINFO		pProDosInfo
)
{
	AFPSTATUS		Status = AFP_ERR_NONE;
	FILESYSHANDLE	hAfpInfo;
	AFPINFO			afpinfo;

	Status = AfpIoOpen(pfshData,
					   AFP_STREAM_INFO,
					   FILEIO_OPEN_FILE,
					   &UNullString,
					   FILEIO_ACCESS_READ,
					   FILEIO_DENY_NONE,
					   False,
					   &hAfpInfo);
    if (NT_SUCCESS(Status))
	{
		if (NT_SUCCESS(AfpReadAfpInfo(&hAfpInfo, &afpinfo)))
		{
			*pProDosInfo = afpinfo.afpi_ProDosInfo;
		}
		else
		{
			Status = AFP_ERR_MISC;
		}

		AfpIoClose(&hAfpInfo);
	}
	else
		Status = AfpIoConvertNTStatusToAfpStatus(Status);

	return Status;
}


/***	AfpUpdateIdInAfpInfo
 *
 *	Update the afpid in the afpinfo stream.
 *
 */
AFPSTATUS FASTCALL
AfpUpdateIdInAfpInfo(
	IN	PVOLDESC		pVolDesc,
	IN	PDFENTRY		pDfEntry
)
{
	FILESYSHANDLE	fshAfpInfo;
	AFPINFO			AfpInfo;
	AFPSTATUS		Status;
	UNICODE_STRING	Path;

	AfpSetEmptyUnicodeString(&Path, 0, NULL);
    Status = AfpHostPathFromDFEntry(pDfEntry, 0, &Path);
	if (NT_SUCCESS(Status))
	{
		// Open the afpinfo stream
		Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
						   AFP_STREAM_INFO,
						   FILEIO_OPEN_FILE,
						   &Path,
						   FILEIO_ACCESS_READWRITE,
						   FILEIO_DENY_NONE,
						   False,
						   &fshAfpInfo);
		if (NT_SUCCESS(Status))
		{
			Status = AfpReadAfpInfo(&fshAfpInfo, &AfpInfo);
			if (NT_SUCCESS(Status))
			{
				AfpInfo.afpi_Id = pDfEntry->dfe_AfpId;
				AfpWriteAfpInfo(&fshAfpInfo, &AfpInfo);
			}
			AfpIoClose(&fshAfpInfo);
		}
	
		AfpFreeMemory(Path.Buffer);
	}

	return Status;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\afpconst.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	afpconst.h

Abstract:

	This module contains the Afp API function codes and error codes.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _AFPCONST_
#define _AFPCONST_

/* The real AFP Function codes */
#define	AFP_BYTE_RANGE_LOCK			0x01
#define	AFP_CLOSE_VOL				0x02
#define	AFP_CLOSE_DIR				0x03
#define	AFP_CLOSE_FORK				0x04
#define	AFP_COPY_FILE				0x05
#define	AFP_CREATE_DIR				0x06
#define	AFP_CREATE_FILE			 	0x07
#define	AFP_DELETE					0x08
#define	AFP_ENUMERATE				0x09
#define	AFP_FLUSH					0x0A
#define	AFP_FLUSH_FORK				0x0B
/*************		0C-0D ARE UNDEFINED	*************/
#define	AFP_GET_FORK_PARMS			0x0E
#define	AFP_GET_SRVR_INFO			0x0F
#define	AFP_GET_SRVR_PARMS			0x10
#define	AFP_GET_VOL_PARMS			0x11
#define	AFP_LOGIN					0x12
#define	AFP_LOGIN_CONT				0x13
#define	AFP_LOGOUT					0x14
#define	AFP_MAP_ID					0x15
#define	AFP_MAP_NAME				0x16
#define	AFP_MOVE_AND_RENAME		 	0x17
#define	AFP_OPEN_VOL				0x18
#define	AFP_OPEN_DIR				0x19
#define	AFP_OPEN_FORK				0x1A
#define	AFP_READ					0x1B
#define	AFP_RENAME					0x1C
#define	AFP_SET_DIR_PARMS			0x1D
#define	AFP_SET_FILE_PARMS			0x1E
#define	AFP_SET_FORK_PARMS			0x1F
#define	AFP_SET_VOL_PARMS			0x20
#define	AFP_WRITE					0x21
#define	AFP_GET_FILE_DIR_PARMS		0x22
#define	AFP_SET_FILE_DIR_PARMS		0x23
#define	AFP_CHANGE_PASSWORD		 	0x24
#define	AFP_GET_USER_INFO			0x25
#define	AFP_GET_SRVR_MSG			0x26
#define	AFP_CREATE_ID				0x27
#define	AFP_DELETE_ID				0x28
#define	AFP_RESOLVE_ID				0x29
#define	AFP_EXCHANGE_FILES			0x2A
#define	AFP_CAT_SEARCH				0x2B
/*************	2C-2F ARE UNDEFINED	*************/
#define	AFP_OPEN_DT				 	0x30
#define	AFP_CLOSE_DT				0x31
/*************	32 IS UNDEFINED	*************/
#define	AFP_GET_ICON				0x33
#define	AFP_GET_ICON_INFO			0x34
#define	AFP_ADD_APPL				0x35
#define	AFP_REMOVE_APPL			 	0x36
#define	AFP_GET_APPL				0x37
#define	AFP_ADD_COMMENT			 	0x38
#define	AFP_REMOVE_COMMENT			0x39
#define	AFP_GET_COMMENT			 	0x3A
/*************	3B-BF ARE UNDEFINED	*************/
#define	AFP_ADD_ICON				0xC0
/*************	C1-FE ARE UNDEFINED	*************/
#define	AFF_GET_DOMAIN_LIST			0xFF



/* AFP Error codes */

#define	AFP_ERR_NONE					0
#define	AFP_ERR_BASE				(-5000)
#define	AFP_ERR_ACCESS_DENIED		(AFP_ERR_BASE-0)
#define	AFP_ERR_AUTH_CONTINUE		(AFP_ERR_BASE-1)
#define	AFP_ERR_BAD_UAM				(AFP_ERR_BASE-2)
#define	AFP_ERR_BAD_VERSION			(AFP_ERR_BASE-3)
#define	AFP_ERR_BITMAP				(AFP_ERR_BASE-4)
#define	AFP_ERR_CANT_MOVE			(AFP_ERR_BASE-5)
#define	AFP_ERR_DENY_CONFLICT		(AFP_ERR_BASE-6)
#define	AFP_ERR_DIR_NOT_EMPTY		(AFP_ERR_BASE-7)
#define	AFP_ERR_DISK_FULL			(AFP_ERR_BASE-8)
#define	AFP_ERR_EOF					(AFP_ERR_BASE-9)
#define	AFP_ERR_FILE_BUSY			(AFP_ERR_BASE-10)
#define	AFP_ERR_FLAT_VOL			(AFP_ERR_BASE-11)
#define	AFP_ERR_ITEM_NOT_FOUND		(AFP_ERR_BASE-12)
#define	AFP_ERR_LOCK				(AFP_ERR_BASE-13)
#define	AFP_ERR_MISC				(AFP_ERR_BASE-14)
#define	AFP_ERR_NO_MORE_LOCKS		(AFP_ERR_BASE-15)
#define	AFP_ERR_NO_SERVER			(AFP_ERR_BASE-16)
#define	AFP_ERR_OBJECT_EXISTS		(AFP_ERR_BASE-17)
#define	AFP_ERR_OBJECT_NOT_FOUND	(AFP_ERR_BASE-18)
#define	AFP_ERR_PARAM				(AFP_ERR_BASE-19)
#define	AFP_ERR_RANGE_NOT_LOCKED	(AFP_ERR_BASE-20)
#define	AFP_ERR_RANGE_OVERLAP		(AFP_ERR_BASE-21)
#define	AFP_ERR_SESS_CLOSED			(AFP_ERR_BASE-22)
#define	AFP_ERR_USER_NOT_AUTH		(AFP_ERR_BASE-23)
#define	AFP_ERR_CALL_NOT_SUPPORTED	(AFP_ERR_BASE-24)
#define	AFP_ERR_OBJECT_TYPE			(AFP_ERR_BASE-25)
#define	AFP_ERR_TOO_MANY_FILES_OPEN	(AFP_ERR_BASE-26)
#define	AFP_ERR_SERVER_GOING_DOWN	(AFP_ERR_BASE-27)
#define	AFP_ERR_CANT_RENAME			(AFP_ERR_BASE-28)
#define	AFP_ERR_DIR_NOT_FOUND		(AFP_ERR_BASE-29)
#define	AFP_ERR_ICON_TYPE			(AFP_ERR_BASE-30)
#define	AFP_ERR_VOLUME_LOCKED		(AFP_ERR_BASE-31)
#define	AFP_ERR_OBJECT_LOCKED		(AFP_ERR_BASE-32)
/*************	-5033 IS Undefined	*************/
#define	AFP_ERR_ID_NOT_FOUND		(AFP_ERR_BASE-34)
#define	AFP_ERR_ID_EXISTS			(AFP_ERR_BASE-35)
#define	AFP_ERR_DIFF_VOL			(AFP_ERR_BASE-36)	// AfpExchangeFiles
#define	AFP_ERR_CATALOG_CHANGED		(AFP_ERR_BASE-37)	// AfpCatSearch
#define	AFP_ERR_SAME_OBJECT			(AFP_ERR_BASE-38)	// AfpExchangeFiles
#define	AFP_ERR_BAD_ID				(AFP_ERR_BASE-39)
#define	AFP_ERR_PWD_SAME			(AFP_ERR_BASE-40)
#define	AFP_ERR_PWD_TOO_SHORT		(AFP_ERR_BASE-41)
#define	AFP_ERR_PWD_EXPIRED			(AFP_ERR_BASE-42)
#define	AFP_ERR_INSIDE_SHARE		(AFP_ERR_BASE-43)	// Specific to AppleShare
#define	AFP_ERR_INSIDE_TRASH		(AFP_ERR_BASE-44)	// Specific to AppleShare
#define	AFP_ERR_PWD_NEEDS_CHANGE	(AFP_ERR_BASE-45)	// Specific to AppleShare

// The following error codes are used internally and never returned to the
// client.
#define	AFP_ERR_QUEUE				-7000
#define	AFP_ERR_DEFER				-7001
#define AFP_ERR_WRITE_LOCK_REQUIRED -7002
#define	AFP_ERR_EXTENDED			-7003
#define	AFP_ERR_REQUEUE				-7004


// The following codes are used with the custom UAM to indicate exact
// reasons for logon failures and change password failures
#define	AFP_ERR_EXTENDED_ERRORS			-13000
#define	AFP_ERR_ACCOUNT_DISABLED		-13002
#define	AFP_ERR_INVALID_WORKSTATION		-13003
#define	AFP_ERR_INVALID_LOGON_HOURS		-13004
#define	AFP_ERR_PASSWORD_EXPIRED		-13005
#define	AFP_ERR_PASSWORD_CANT_CHANGE	-13006
#define	AFP_ERR_PASSWORD_HIST_CONFLICT	-13007  	
#define	AFP_ERR_PASSWORD_TOO_SHORT		-13008
#define	AFP_ERR_PASSWORD_TOO_RECENT		-13009
#define	AFP_ERR_PASSWORD_RESTRICTED		-13010
#define	AFP_ERR_ACCOUNT_RESTRICTED		-13011

// The following error is returned from a logon when the LsaLogonUser
// call returns STATUS_LICENSE_QUOTA_EXCEEDED.  The mac will map this
// to the correct dialog no matter what UAM is used.
#define ASP_SERVER_BUSY					-1071


// This is GROSS but we need to do it. Else we get TONS of warnings
#define	True		(BOOLEAN)TRUE
#define	False		(BOOLEAN)FALSE

typedef	LONG			AFPSTATUS;
typedef	LONG			AFPTIME, *PAFPTIME;
typedef	LARGE_INTEGER	FORKOFFST, *PFORKOFFST;
typedef	LARGE_INTEGER	FORKSIZE, *PFORKSIZE;

#ifndef	DWORD
typedef	ULONG			DWORD;
typedef	DWORD			*PDWORD;
typedef	DWORD			*LPDWORD;
#endif
#ifndef	BYTE
typedef	UCHAR			BYTE;
typedef	BYTE			*PBYTE;
typedef	BYTE			*LPBYTE;
#endif

/*
 * The following macros deal with on-the-wire integer and long values
 *
 * On the wire format is big-endian i.e. a long value of 0x01020304 is
 * represented as 01 02 03 04. Similarly an int value of 0x0102 is
 * represented as 01 02.
 *
 * The host format is not assumed since it will vary from processor to
 * processor.
 */

// Get a byte from on-the-wire format to a short in the host format
#define GETBYTE2SHORT(DstPtr, SrcPtr)	\
		*(PUSHORT)(DstPtr) = (USHORT) (*(PBYTE)(SrcPtr))

// Get a byte from on-the-wire format to a short in the host format
#define GETBYTE2DWORD(DstPtr, SrcPtr)	\
		*(PDWORD)(DstPtr) = (DWORD) (*(PBYTE)(SrcPtr))

// Get a short from on-the-wire format to a dword in the host format
#define GETSHORT2DWORD(DstPtr, SrcPtr)	\
		*(PDWORD)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 8) +	\
							  (*((PBYTE)(SrcPtr)+1)		))

// Get a short from on-the-wire format to a dword in the host format
#define GETSHORT2SHORT(DstPtr, SrcPtr)	\
		*(PUSHORT)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 8) +	\
							  (*((PBYTE)(SrcPtr)+1)		))

// Get a dword from on-the-wire format to a dword in the host format
#define GETDWORD2DWORD(DstPtr, SrcPtr)   \
		*(PDWORD)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 24) + \
							  (*((PBYTE)(SrcPtr)+1) << 16) + \
							  (*((PBYTE)(SrcPtr)+2) << 8)  + \
							  (*((PBYTE)(SrcPtr)+3)	))

// Get a dword from on-the-wire format to a dword in the same format but
// also watch out for alignment
#define GETDWORD2DWORD_NOCONV(DstPtr, SrcPtr)   \
		*((PBYTE)(DstPtr)+0) = *((PBYTE)(SrcPtr)+0); \
		*((PBYTE)(DstPtr)+1) = *((PBYTE)(SrcPtr)+1); \
		*((PBYTE)(DstPtr)+2) = *((PBYTE)(SrcPtr)+2); \
		*((PBYTE)(DstPtr)+3) = *((PBYTE)(SrcPtr)+3);

// Put a dword from the host format to a short to on-the-wire format
#define PUTBYTE2BYTE(DstPtr, Src)   \
		*((PBYTE)(DstPtr)) = (BYTE)(Src)

// Put a dword from the host format to a short to on-the-wire format
#define PUTSHORT2BYTE(DstPtr, Src)   \
		*((PBYTE)(DstPtr)) = ((USHORT)(Src) % 256)

// Put a dword from the host format to a short to on-the-wire format
#define PUTSHORT2SHORT(DstPtr, Src)   \
		*((PBYTE)(DstPtr)+0) = (BYTE) ((USHORT)(Src) >> 8), \
		*((PBYTE)(DstPtr)+1) = (BYTE)(Src)

// Put a dword from the host format to a byte to on-the-wire format
#define PUTDWORD2BYTE(DstPtr, Src)   \
		*(PBYTE)(DstPtr) = (BYTE)(Src)

// Put a dword from the host format to a short to on-the-wire format
#define PUTDWORD2SHORT(DstPtr, Src)   \
		*((PBYTE)(DstPtr)+0) = (BYTE) ((DWORD)(Src) >> 8), \
		*((PBYTE)(DstPtr)+1) = (BYTE) (Src)

// Put a dword from the host format to a dword to on-the-wire format
#define PUTDWORD2DWORD(DstPtr, Src)   \
		*((PBYTE)(DstPtr)+0) = (BYTE) ((DWORD)(Src) >> 24), \
		*((PBYTE)(DstPtr)+1) = (BYTE) ((DWORD)(Src) >> 16), \
		*((PBYTE)(DstPtr)+2) = (BYTE) ((DWORD)(Src) >>  8), \
		*((PBYTE)(DstPtr)+3) = (BYTE) (Src)

// Put a BYTE[4] array into another BYTE4 array.
#define PUTBYTE42BYTE4(DstPtr, SrcPtr)   \
		*((PBYTE)(DstPtr)+0) = *((PBYTE)(SrcPtr)+0),	\
		*((PBYTE)(DstPtr)+1) = *((PBYTE)(SrcPtr)+1),	\
		*((PBYTE)(DstPtr)+2) = *((PBYTE)(SrcPtr)+2),	\
		*((PBYTE)(DstPtr)+3) = *((PBYTE)(SrcPtr)+3)

/* AFP Miscellaneous values */

#define	AFP_SHORTNAME				1
#define	AFP_LONGNAME				2
#define	VALIDPATHTYPE(PathType)	\
			(PathType == AFP_LONGNAME || PathType == AFP_SHORTNAME)

#define AFP_HARDCREATE_FLAG			0x80

#define	AFP_VOLUMES_MAX				255	// Count of volumes that fit in a byte
#define	AFP_FILENAME_LEN			31	// Maximum file name length
#define	AFP_SHORTNAME_LEN			12	// 8.3
#define	AFP_LONGNAME_LEN			31
#define	AFP_MAXCOMMENTSIZE			199
#define	AFP_MAXPWDSIZE				8	// Cleartext password length
#define	BEGINNING_OF_TIME 			0x80000000
#define	DAYS_FROM_1980_2000			7305L			// (20*365 + 5)
#define	SECONDS_PER_DAY				86400L			// 24*60*60
#define	SECONDS_FROM_1980_2000		SECONDS_PER_DAY * DAYS_FROM_1980_2000
#define	NUM_100ns_PER_SECOND		10000000L

#define	ASP_MAX_STATUS_BUF			512
#define	ASP_QUANTUM					4624

#define AFP_SERVER_SIGNATURE		*(PDWORD)"AFP"
#define AFP_SERVER_SIGNATURE_INITIDDB		*(PDWORD)"INI"
#define AFP_SERVER_SIGNATURE_MANUALSTOP		*(PDWORD)"MAN"
#define	AFP_SERVER_VERSION			0x00010000
#define	AFP_SERVER_VERSION2			0x00020000

// AFP Version strings and values
#define	AFP_NUM_VERSIONS			3
#define	AFP_VER_20					0
#define	AFP_VER_20_NAME				"AFPVersion 2.0"
#define	AFP_VER_21					1
#define	AFP_VER_21_NAME				"AFPVersion 2.1"
#define	AFP_VER_22					2
#define	AFP_VER_22_NAME				"AFP2.2"

// Name to use for the Logon Process
#define	AFP_LOGON_PROCESS_NAME		"MSAfpSrv"

#define	AFP_MACHINE_TYPE_STR		"Windows NT"
#define	AFP_MACHINE_TYPE_LEN		sizeof(AFP_MACHINE_TYPE_STR) - 1
#define	AFP_DEFAULT_WORKSTATION		L"Macintosh"
#define	AFP_DEFAULT_WORKSTATION_A	"Macintosh"

#define AFPSERVER_VOLUME_ICON_FILE_ANSI {'I','C','O','N', 0x0D}

#define AFP_ID_PARENT_OF_ROOT		1
#define AFP_ID_ROOT					2
#define AFP_ID_NETWORK_TRASH		3
#define AFP_FIRST_DIRID				4
#define AFP_MAX_DIRID				MAXULONG

// NTFS Stream names
#define AFP_IDDB_STREAM				L":AFP_IdIndex"
#define AFP_DT_STREAM				L":AFP_DeskTop"
#define	AFP_RESC_STREAM				L":AFP_Resource"
#define	AFP_INFO_STREAM				L":AFP_AfpInfo"
#define	AFP_COMM_STREAM				L":Comments"
#define	AFP_DATA_STREAM				L""
#define	AFP_MAX_STREAMNAME			sizeof(AFP_RESC_STREAM)/sizeof(WCHAR)
#define	BIG_PATH_LEN				(4*(AFP_FILENAME_LEN + 1))

#define FULL_DATA_STREAM_NAME		L"::$DATA"
#define FULL_COMMENT_STREAM_NAME	L":Comments:$DATA"
#define FULL_RESOURCE_STREAM_NAME	L":AFP_Resource:$DATA"
#define FULL_INFO_STREAM_NAME		L":AFP_AfpInfo:$DATA"


// Supported file system names
#define AFP_NTFS					L"NTFS"
#define AFP_CDFS					L"CDFS"
#define AFP_AHFS					L"AHFS"

// Length of unicode string Buffer to send when querying the FS name
#define AFP_FSNAME_BUFLEN			30

#if DBG
#define	POOL_OVERHEAD		(12+8)		// 12 for AfpAllocMemory() & 8 for ExAllocatePool()
#else
#define	POOL_OVERHEAD		(8+8)		// 8 for AfpAllocMemory() & 8 for ExAllocatePool()
#endif

// Length of buffer to use for enumeration of directories
#define AFP_ENUMBUF_SIZE			(16*1024)

// Prepended to full path of volume root in order to open the volume root dir
#define AFP_DOSDEVICES				L"\\DOSDEVICES\\"

// Name of the Macintosh System 7.x network trash directory
#define AFP_NWTRASH_NAME			L"Network Trash Folder"
#define AFP_NWTRASH_NAME_U			L"Network Trash Folder"
#define AFP_NWTRASH_NAME_A			"Network Trash Folder"

// Default Type/Creator and Extensions
#define	AFP_DEFAULT_ETC_EXT			"*  "
#define	AFP_DEFAULT_ETC_CREATOR		"LMAN"
#define	AFP_DEFAULT_ETC_TYPE		"TEXT"

#define	AFP_MAX_ETCMAP_ENTRIES		MAXLONG
#define AFP_MAX_FREE_ETCMAP_ENTRIES	16


#define	AFP_SERVER_TYPE				"AFPServer"
#define	AFP_SERVER_ZONE				"*"


typedef	struct _PascalString
{
	BYTE	ps_Length;
	BYTE	ps_String[1];
} *PASCALSTR;

#define	SIZE_PASCALSTR(Len)	((Len) + sizeof(struct _PascalString) - 1)

typedef struct _AfpPathString
{
	BYTE	aps_PathType;
	BYTE	aps_Length;
	BYTE	aps_Path[1];
} *AFPPATHSTR;


// Mac Finder Information layout

// see pg. 9-37 of Inside Macintosh vol. 6
#define	FINDER_FLAG_INVISIBLE		0x40		// fd_Attr1
#define	FINDER_FLAG_SET				0x01		// fd_Attr1
#define FINDER_FLAG_HAS_CUSTOM_ICON 0x04	    // fd_Attr1

#define FINDER_INFO_SIZE			32
typedef struct _FinderInfo
{
	// Force DWORD alignment
	union
	{
		BYTE	fd_Type[4];
		DWORD	fd_TypeD;
	};
	union
	{
		BYTE	fd_Creator[4];
		DWORD	fd_CreatorD;
	};
	BYTE	fd_Attr1;			// Bits 8-15
	BYTE	fd_Attr2;			// Bits 0-7
	BYTE	fd_Location[4];
	BYTE	fd_FDWindow[2];
	BYTE	fd_OtherStuff[16];
} FINDERINFO, *PFINDERINFO;

// Apple-II (ProDOS) information.

// default values for newly discovered items
#define	PRODOS_TYPE_FILE	0x04	// corresponds to finder fdType 'TEXT'
#define PRODOS_TYPE_DIR		0x0F
#define PRODOS_AUX_DIR		0x02	// actually 0x0200

// some other finder fdType to prodos FileType mapping values
#define PRODOS_FILETYPE_PSYS	0xFF
#define PRODOS_FILETYPE_PS16	0xB3

#define PRODOS_INFO_SIZE			6
typedef struct
{
	BYTE pd_FileType[2];
	BYTE pd_AuxType[4];
} PRODOSINFO, *PPRODOSINFO;

#endif	// _AFPCONST_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\atalkio.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atalkio.h

Abstract:

	This module contains interface specification to the appletalk stack.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATALKIO_
#define	_ATALKIO_

extern BOOLEAN  AfpServerBoundToAsp;
extern BOOLEAN  AfpServerBoundToTcp;

extern HANDLE   AfpTdiNotificationHandle;

extern
VOID
AfpTdiPnpHandler(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  pBindDeviceName,
    IN PWSTR            BindingList
);

extern
VOID FASTCALL
AfpPnPReconfigDisable(
    IN PVOID    Context
);

extern
VOID FASTCALL
AfpPnPReconfigEnable(
    IN PVOID    Context
);


extern
NTSTATUS
AfpTdiRegister(
    IN VOID
);

extern
VOID
AfpTdiBindCallback(
    IN PUNICODE_STRING pBindDeviceName
);

extern
VOID
AfpTdiUnbindCallback(
    IN PUNICODE_STRING pBindDeviceName
);

extern
NTSTATUS
AfpSpOpenAddress(
	VOID
);


extern
VOID
AfpSpCloseAddress(
	VOID
);


extern
NTSTATUS FASTCALL
AfpSpCloseSession(
	IN	PSDA				pSda
);


extern
AFPSTATUS
AfpSpRegisterName(
	IN	PANSI_STRING		ServerName,
	IN	BOOLEAN				Register
);


extern
VOID FASTCALL
AfpSpReplyClient(
	IN	PREQUEST			pRequest,
	IN	LONG				ReplyCode,
    IN  PASP_XPORT_ENTRIES  XportTable
);


extern
VOID FASTCALL
AfpSpSendAttention(
	IN	PSDA				pSda,
	IN	USHORT				AttnCode,
	IN	BOOLEAN				Synchronous
);

extern
VOID
AfpFreeReplyBuf(
    IN  PSDA    pSda,
    IN  BOOLEAN fLockHeld
);


#define DSI_BACKFILL_OFFSET(pSda) \
    ((pSda->sda_Flags & SDA_SESSION_OVER_TCP)? DSI_HEADER_SIZE : 0)

//
// when we go over TCP/IP, we want to allocate 16 more bytes for the
// DSI header for better performance.
//
#define AfpIOAllocBackFillBuffer(pSda)                              \
    {                                                               \
        DWORD   _ReplySize = pSda->sda_ReplySize;                   \
        DWORD   _Offset = 0;                                        \
        PBYTE   _pReplyBufStart;                                    \
                                                                    \
        if (pSda->sda_Flags & SDA_SESSION_OVER_TCP)                 \
        {                                                           \
            _ReplySize += DSI_HEADER_SIZE;                          \
            _Offset = DSI_HEADER_SIZE;                              \
        }                                                           \
                                                                    \
        _pReplyBufStart = AfpIOAllocBuffer(_ReplySize);             \
                                                                    \
        if (_pReplyBufStart != NULL)                                \
        {                                                           \
            pSda->sda_IOBuf = _pReplyBufStart+_Offset;              \
        }                                                           \
        else                                                        \
        {                                                           \
            pSda->sda_IOBuf = NULL;                                 \
        }                                                           \
    }


#define AfpPutGuardSignature(pSda)                                  \
    {                                                               \
        PBYTE   _pReplyBufStart = pSda->sda_IOBuf;                  \
        if (pSda->sda_Flags & SDA_SESSION_OVER_TCP)                 \
        {                                                           \
            _pReplyBufStart -= DSI_HEADER_SIZE;                     \
        }                                                           \
        *(DWORD *)_pReplyBufStart = 0x081294;                       \
    }

#define AfpIOFreeBackFillBuffer(pSda)                               \
    {                                                               \
        DWORD   _Offset = 0;                                        \
        PBYTE   _pReplyBufStart = pSda->sda_IOBuf;                  \
                                                                    \
        if (pSda->sda_IOBuf != NULL)                                \
        {                                                           \
            if (pSda->sda_Flags & SDA_SESSION_OVER_TCP)             \
            {                                                       \
                _pReplyBufStart -= DSI_HEADER_SIZE;                 \
            }                                                       \
                                                                    \
            AfpIOFreeBuffer(_pReplyBufStart);                       \
                                                                    \
            (pSda)->sda_IOBuf = NULL;                               \
            (pSda)->sda_IOSize = 0;                                 \
        }                                                           \
    }


#define	AfpFreeIOBuffer(pSda)			                            \
	if ((pSda)->sda_IOBuf != NULL)		                            \
	{									                            \
		AfpIOFreeBuffer((pSda)->sda_IOBuf);                         \
		(pSda)->sda_IOBuf = NULL;		                            \
		(pSda)->sda_IOSize = 0;			                            \
	}

// set the status on ASP
#define	AfpSpSetAspStatus(pStatusBuf, Size)                          \
	    (*(AfpAspEntries.asp_SetStatus))(AfpAspEntries.asp_AspCtxt,	 \
		    							 pStatusBuf,				 \
			    						 (USHORT)(Size));

// set the status on DSI
#define	AfpSpSetDsiStatus(pStatusBuf, Size)                          \
	    (*(AfpDsiEntries.asp_SetStatus))(AfpDsiEntries.asp_AspCtxt,	 \
		    							 pStatusBuf,				 \
			    						 (USHORT)(Size));

// set the Disable Listen on ASP only
#define	AfpSpDisableListensOnAsp()                                              \
{                                                                               \
    if (AfpServerBoundToAsp)                                                    \
    {                                                                           \
	    (*(AfpAspEntries.asp_ListenControl))(AfpAspEntries.asp_AspCtxt, False); \
    }                                                                           \
}

// set the Disable Listen on ASP as well as DSI interfaces!
#define	AfpSpDisableListens()                                                   \
{                                                                               \
    if (AfpServerBoundToAsp)                                                    \
    {                                                                           \
	    (*(AfpAspEntries.asp_ListenControl))(AfpAspEntries.asp_AspCtxt, False); \
    }                                                                           \
    if (AfpServerBoundToTcp)                                                    \
    {                                                                           \
	    (*(AfpDsiEntries.asp_ListenControl))(AfpDsiEntries.asp_AspCtxt, False); \
    }                                                                           \
}
							
// set the Enable Listen on ASP as well as DSI interfaces!
#define	AfpSpEnableListens()                                                    \
{                                                                               \
    if (AfpServerBoundToAsp)                                                    \
    {                                                                           \
	    (*(AfpAspEntries.asp_ListenControl))(AfpAspEntries.asp_AspCtxt, True);  \
    }                                                                           \
    if (AfpServerBoundToTcp)                                                    \
    {                                                                           \
	    (*(AfpDsiEntries.asp_ListenControl))(AfpDsiEntries.asp_AspCtxt, True);  \
    }                                                                           \
}
							

GLOBAL	ASP_XPORT_ENTRIES	AfpAspEntries EQU { 0 };
GLOBAL	ASP_XPORT_ENTRIES	AfpDsiEntries EQU { 0 };

#define	AFP_MAX_REQ_BUF				578

#define	afpInitializeActionHdr(p, Code)	\
		(p)->ActionHeader.TransportId = MATK;	\
		(p)->ActionHeader.ActionCode = (Code)

// This is the device handle to the stack.
extern BOOLEAN		        afpSpNameRegistered;
extern HANDLE				afpSpAddressHandle;
extern PDEVICE_OBJECT		afpSpAppleTalkDeviceObject;
extern PFILE_OBJECT		    afpSpAddressObject;
extern LONG				    afpSpNumOutstandingReplies;

LOCAL NTSTATUS FASTCALL
afpSpHandleRequest(
	IN	NTSTATUS			Status,
	IN	PSDA				pSda,
	IN	PREQUEST			pRequest
);

LOCAL VOID FASTCALL
afpSpReplyComplete(
	IN	NTSTATUS			Status,
	IN	PSDA				pSda,
	IN	PREQUEST	        pRequest
);

LOCAL VOID FASTCALL
afpSpCloseComplete(
	IN	NTSTATUS			Status,
	IN	PSDA				pSda
);

LOCAL NTSTATUS
afpSpGenericComplete(
	IN	PDEVICE_OBJECT		pDeviceObject,
	IN	PIRP				pIrp,
	IN	PKEVENT				pCmplEvent
);

LOCAL VOID FASTCALL
afpSpAttentionComplete(
	IN	PVOID				pContext
);

#endif	// _ATALKIO_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\afpmem.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	memory.h

Abstract:

	This module contains the memory allocation routines.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _AFPMEMORY_
#define _AFPMEMORY_

//
// NOTE: The tag values below are designed to allocate/detect on free memory allocated.
//		 Note that the callers free the memory simply via AfpFreeMemory and allocate
//		 via AfpAllocMemory.
//
//		 via one of the three possible ways:
//		 a, Non paged memory via ExAllocatePool
//		 b, Paged memory via ExAllocatePool
//		 c, Non paged memory via Io Pool
//
#define	AFP_TAG							*(PULONG)"Afp "	// For ExAllocatePoolWithTag()
#define	PGD_MEM_TAG						0x11
#define	PAGED_MEMORY_TAG				(PGD_MEM_TAG << 24)
#define	NPG_MEM_TAG						0x22
#define	NON_PAGED_MEMORY_TAG			(NPG_MEM_TAG << 24)
#define	IO_POOL_TAG						0x44
#define	IO_POOL_MEMORY_TAG				(IO_POOL_TAG << 24)
#define	ZEROED_MEM_TAG					0x88
#define	ZEROED_MEMORY_TAG				(ZEROED_MEM_TAG << 24)
#define	MEMORY_TAG_MASK					(PAGED_MEMORY_TAG		| \
										 NON_PAGED_MEMORY_TAG	| \
										 IO_POOL_MEMORY_TAG		| \
										 ZEROED_MEMORY_TAG)

extern
NTSTATUS
AfpMemoryInit(
	VOID
);

extern
VOID
AfpMemoryDeInit(
	VOID
);

#ifdef	TRACK_MEMORY_USAGE

#define	AfpAllocNonPagedMemory(_S)			\
				AfpAllocMemory((_S) | NON_PAGED_MEMORY_TAG, FILENUM | __LINE__)

#define	AfpAllocZeroedNonPagedMemory(_S)	\
				AfpAllocMemory((_S) | NON_PAGED_MEMORY_TAG | ZEROED_MEMORY_TAG, FILENUM | __LINE__)

#define	AfpAllocPANonPagedMemory(_S)		\
				AfpAllocPAMemory((_S) | NON_PAGED_MEMORY_TAG, FILENUM | __LINE__)

#define	AfpAllocPagedMemory(_S)				\
				AfpAllocMemory((_S) | PAGED_MEMORY_TAG, FILENUM | __LINE__)

#define	AfpAllocZeroedPagedMemory(_S)	\
				AfpAllocMemory((_S) | PAGED_MEMORY_TAG | ZEROED_MEMORY_TAG, FILENUM | __LINE__)

#define	AfpAllocPAPagedMemory(_S)			\
				AfpAllocPAMemory((_S) | PAGED_MEMORY_TAG, FILENUM | __LINE__)

extern
PBYTE FASTCALL
AfpAllocMemory(
	IN	LONG				Size,
	IN	DWORD				FileLine
);

extern
PBYTE FASTCALL
AfpAllocNonPagedLowPriority(
	IN	LONG	Size,
	IN	DWORD	FileLine
);

extern
PBYTE FASTCALL
AfpAllocPAMemory(
	IN	LONG				Size,
	IN	DWORD				FileLine
);

extern
VOID
AfpTrackMemoryUsage(
	IN	PVOID				pMem,
	IN	BOOLEAN				Alloc,
	IN	BOOLEAN				Paged,
	IN	DWORD				FileLine
);

#else

#define	AfpAllocNonPagedMemory(_S)			AfpAllocMemory((_S) | NON_PAGED_MEMORY_TAG)

#define	AfpAllocZeroedNonPagedMemory(_S)	AfpAllocMemory((_S) | NON_PAGED_MEMORY_TAG | ZEROED_MEMORY_TAG)

#define	AfpAllocPANonPagedMemory(_S)		AfpAllocPAMemory((_S) | NON_PAGED_MEMORY_TAG)

#define	AfpAllocPagedMemory(_S)				AfpAllocMemory((_S) | PAGED_MEMORY_TAG)

#define	AfpAllocZeroedPagedMemory(_S)		AfpAllocMemory((_S) | PAGED_MEMORY_TAG | ZEROED_MEMORY_TAG)

#define	AfpAllocPAPagedMemory(_S)			AfpAllocPAMemory((_S) | PAGED_MEMORY_TAG)

extern
PBYTE FASTCALL
AfpAllocMemory(
	IN	LONG				Size
);

extern
PBYTE FASTCALL
AfpAllocNonPagedLowPriority(
	IN	LONG	Size
);

extern
PBYTE FASTCALL
AfpAllocPAMemory(
	IN	LONG				Size
);

#endif

#define	AfpAllocIoMemory(Size)				AfpIoAllocBuffer(Size)

extern
VOID FASTCALL
AfpFreeMemory(
	IN	PVOID				pBuffer
);

#define	AfpFreePAPagedMemory(_pBuf, _S)		AfpFreePAMemory(_pBuf, (_S) | PAGED_MEMORY_TAG)

#define	AfpFreePANonPagedMemory(_pBuf, _S)	AfpFreePAMemory(_pBuf, (_S) | NON_PAGED_MEMORY_TAG)

extern
VOID FASTCALL
AfpFreePAMemory(
	IN	PVOID				pBuffer,
	IN	DWORD				Size
);

extern
PBYTE FASTCALL
AfpAllocateVirtualMemoryPage(
	IN	VOID
);

extern
VOID FASTCALL
AfpFreeVirtualMemoryPage(
	IN	PVOID				pBuffer
);

extern
AFPSTATUS FASTCALL
AfpAllocReplyBuf(
	IN	PSDA				pSda
);

extern
PBYTE FASTCALL
AfpAllocStatusBuf(
	IN	LONG				Size
);

extern
PIRP FASTCALL
AfpAllocIrp(
	IN	CCHAR				StackSize
);

extern
VOID FASTCALL
AfpFreeIrp(
	IN	PIRP				pIrp
);

extern
PMDL FASTCALL
AfpAllocMdl(
	IN	PVOID				pBuffer,
	IN	DWORD				Size,
	IN	PIRP				pIrp
);

extern
PMDL
AfpAllocMdlForPagedPool(
	IN	PVOID				pBuffer,
	IN	DWORD				Size,
	IN	PIRP				pIrp
);

extern
VOID FASTCALL
AfpFreeMdl(
	IN	PMDL				pMdl
);

extern
DWORD FASTCALL
AfpMdlChainSize(
	IN	PMDL                pMdl
);

extern
PVOID FASTCALL
AfpIOAllocBuffer(
	IN	DWORD				BufSize
);

extern
VOID FASTCALL
AfpIOFreeBuffer(
	IN	PVOID				pBuffer
);

#define	EQUAL_UNICODE_STRING(pUS1, pUS2, fIgnoreCase)	\
		(((pUS1)->Length == (pUS2)->Length) &&			\
		 RtlEqualUnicodeString(pUS1, pUS2, fIgnoreCase))

#define	EQUAL_STRING(pS1, pS2, fIgnoreCase)				\
		(((pS1)->Length == (pS2)->Length) &&			\
		 RtlEqualString(pS1, pS2, fIgnoreCase))

// case sensitive unicode string compare
#define	EQUAL_UNICODE_STRING_CS(pUS1, pUS2)	\
		(((pUS1)->Length == (pUS2)->Length) &&			\
		 (memcmp((pUS1)->Buffer, (pUS2)->Buffer, (pUS1)->Length) == 0))

//
// AfpSetEmptyUnicodeString and AfpSetEmptyAnsiString are used in
// situations where you have allocated your own pointer for the string
// Buffer, and now you want to initialize all the fields of a counted
// string, making it point to your buffer and setting its length fields
// appropriately for an 'empty' string.  Situations like this would
// include data structures where you have allocated a large chunk of
// memory that has included room for any required strings at the end of
// the chunk.  For example, the VolDesc structure includes several
// counted strings, and we can just point the string buffers to the
// end of the same chunk of memory that the VolDesc itself occupies.
//
// VOID
// AfpSetEmptyUnicodeString(
// 	OUT	PUNICODE_STRING pstring,
//	IN	USHORT			buflen,
//  IN	PWSTR			pbuf
//  );
//

#define AfpSetEmptyUnicodeString(pstring,buflen,pbuf)		\
{															\
  (pstring)->Length = 0;									\
  (pstring)->MaximumLength = (USHORT)buflen;				\
  (pstring)->Buffer = (PWSTR)(pbuf);						\
}

//
// VOID
// AfpSetEmptyAnsiString(
// 	OUT	PANSI_STRING	pstring,
//	IN	USHORT			buflen,
//  IN	PCHAR			pbuf
//  );
//

#define AfpSetEmptyAnsiString(pstring,buflen,pbuf)			\
{															\
  (pstring)->Length = 0;									\
  (pstring)->MaximumLength = (USHORT)buflen;				\
  (pstring)->Buffer = (PCHAR)(pbuf);						\
}

//
//	AfpInitUnicodeStringWithNonNullTerm initializes a unicode string with
//  a non-null terminated wide char string and its length.
//
//	VOID
//	AfpInitUnicodeStringWithNonNullTerm(
//   OUT PUNICODE_STRING	pstring,
//	 IN	 USHORT				buflen,
//	 IN	 PWCHAR				pbuf
//	);
//

#define AfpInitUnicodeStringWithNonNullTerm(pstring,buflen,pbuf) \
{															\
	(pstring)->Buffer = pbuf;								\
	(pstring)->Length = (USHORT)buflen; 					\
	(pstring)->MaximumLength = (USHORT)buflen;				\
}

//
//	AfpInitAnsiStringWithNonNullTerm initializes an Ansi string with
//  a non-null terminated char string and its length.
//
//	VOID
//	AfpInitAnsiStringWithNonNullTerm(
//   OUT PANSI_STRING		pstring,
//	 IN	 USHORT				buflen,
//	 IN	 PCHAR				pbuf
//	);
//

#define AfpInitAnsiStringWithNonNullTerm(pstring,buflen,pbuf) \
{															\
	(pstring)->Buffer = pbuf;								\
	(pstring)->Length = (USHORT)buflen; 					\
	(pstring)->MaximumLength = (USHORT)buflen;				\
}

#define AfpCopyUnicodeString(pDst, pSrc)					\
{															\
	ASSERT((pDst)->MaximumLength >= (pSrc)->Length);		\
	RtlCopyMemory((pDst)->Buffer,							\
				  (pSrc)->Buffer,							\
				  (pSrc)->Length);							\
	(pDst)->Length = (pSrc)->Length;						\
}

#define AfpCopyAnsiString(pDst, pSrc)						\
{															\
	ASSERT((pDst)->MaximumLength >= (pSrc)->Length);		\
	RtlCopyMemory((pDst)->Buffer,							\
				  (pSrc)->Buffer,							\
				  (pSrc)->Length);							\
	(pDst)->Length = (pSrc)->Length;						\
}

#endif	// _AFPMEMORY_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\atalkio.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atalkio.c

Abstract:

	This module contains the interfaces to the appletalk stack and the
	completion routines for the IO requests to the stack via the TDI.
	All the routines in this module can be called at DPC level.


Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	18 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_ATALKIO

#include <afp.h>
#include <scavengr.h>
#include <forkio.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpSpOpenAddress)
#pragma alloc_text( PAGE, AfpSpCloseAddress)
#pragma alloc_text( PAGE, AfpSpRegisterName)
#endif



/***	AfpTdiPnpHandler
 *
 *	Call the routine (AfpSpOpenAddress) to bind to Asp.  This used to be done earlier
 *  in the DriverEntry code.  With plug-n-play, we do it after TDI calls
 *  us to notify us of an available binding
 */
VOID
AfpTdiPnpHandler(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  pBindDeviceName,
    IN PWSTR            BindingList
)
{
	NTSTATUS			Status;
	UNICODE_STRING		OurDeviceName;
    WORKER              ReCfgRoutine;
    WORK_ITEM           ReCfgWorkItem;
    KEVENT              ReCfgEvent;


    //
    // now see what pnp event has occured and do the needful
    //
	RtlInitUnicodeString(&OurDeviceName, ATALKASPS_DEVICENAME);

    if ((AfpServerState == AFP_STATE_STOP_PENDING) ||
        (AfpServerState == AFP_STATE_STOPPED))
    {
	    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
	        ("AfpTdiPnpHandler: server stopped or stopping (%d), ignoring PnP event %d\n",
            AfpServerState,PnPOpcode));

        return;
    }

    switch (PnPOpcode)
    {
        case TDI_PNP_OP_ADD:

            if (AfpServerBoundToAsp)
            {
    	        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
		   	        ("AfpTdi..: We are already bound!! ignoring!\n"));
                return;
            }

            // it had better be our device!
            if (!RtlEqualUnicodeString(pBindDeviceName, &OurDeviceName, TRUE))
            {
	            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
		  	        ("AfpTdiPnpHandler: not our tranport: on %ws ignored\n",
                    pBindDeviceName->Buffer));

                ASSERT(0);

                return;
            }

	        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
    	   	    ("AfpTdi..: Found our binding: %ws\n",pBindDeviceName->Buffer));

            ReCfgRoutine = (WORKER)AfpPnPReconfigEnable;

            break;

        case TDI_PNP_OP_DEL:

        	DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
		   	    ("AfpTdiPnpHandler: got TDI_PNP_OP_DEL, default adapter going away!\n"));

            if (!AfpServerBoundToAsp)
            {
        	    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
		    	    ("AfpTdiPnpHandler: We are not bound!! ignoring!\n"));
                return;
            }

            // it had better be our device!
            if (!RtlEqualUnicodeString(pBindDeviceName, &OurDeviceName, TRUE))
            {
	            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
		  	        ("AfpTdiPnpHandler: not our tranport: on %ws ignored\n",
                    pBindDeviceName->Buffer));

                ASSERT(0);

                return;
            }

            ReCfgRoutine = (WORKER)AfpPnPReconfigDisable;

            break;

        default:

        	DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
		   	    ("AfpTdiPnpHandler: ignoring PnPOpcode %d on %ws\n",
                PnPOpcode,(pBindDeviceName)?pBindDeviceName->Buffer:L"Null Ptr"));

            return;
    }

    KeInitializeEvent(&ReCfgEvent,NotificationEvent, False);

    // file handle operation needs system context: use worker thread
    AfpInitializeWorkItem(&ReCfgWorkItem,
                          ReCfgRoutine,
                          &ReCfgEvent);

    AfpQueueWorkItem(&ReCfgWorkItem);

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
        ("AfpTdiPnpHandler: put request on Queue, waiting for ReConfigure to complete\n"));

    KeWaitForSingleObject(&ReCfgEvent,
                          UserRequest,
                          KernelMode,
                          False,
                          NULL);

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
        ("AfpTdiPnpHandler: Reconfigure completed, returning....\n"));


}


/***	AfpPnPReconfigDisable
 *
 *	When the stack gets a PnPReconfigure event, we get notified too.  We first
 *  get the TDI_PNP_OP_DEL msg.  What we need to do here is close all the
 *  sessions and close the handle.
 */
VOID FASTCALL
AfpPnPReconfigDisable(
    IN PVOID    Context
)
{
    PKEVENT             pReCfgEvent;


    pReCfgEvent = (PKEVENT)Context;

	// Deregister our name from the network
	// Since the stack is going away, explicitly set the flag to FALSE
	// There may be timing issues here, where stack may go away
	// before SpRegisterName is issued.
	// Flagging explicitly avoids re-registration problems during PnPEnable
	AfpSpRegisterName(&AfpServerName, False);
    afpSpNameRegistered = FALSE;

    // Disable listens on ASP
    AfpSpDisableListensOnAsp();

    // now go and kill all the appletalk sessions
    AfpKillSessionsOverProtocol(TRUE);

    AfpSpCloseAddress();

    // wake up the blocked pnp thread
    KeSetEvent(pReCfgEvent, IO_NETWORK_INCREMENT, False);
}


/***	AfpPnPReconfigEnable
 *
 *	When the stack gets a PnPReconfigure event, we get notified too.  We
 *  get the TDI_PNP_OP_ADD msg.  What we need to do here is open our handle to
 *  the stack, register names etc.
 */
VOID FASTCALL
AfpPnPReconfigEnable(
    IN PVOID    Context
)
{

    NTSTATUS    Status=STATUS_SUCCESS;
    PKEVENT     pReCfgEvent;
    ULONG       OldServerState;


    pReCfgEvent = (PKEVENT)Context;

    if (afpSpAddressHandle == NULL)
    {
        Status = AfpSpOpenAddress();

        if (!NT_SUCCESS(Status))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
	            ("AfpTdi..: AfpSpOpenAddress failed with status=%lx\n",Status));

            goto AfpPnPReconfigEnable_Exit;
        }
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("AfpPnPReconfigEnable: afp handle is already open!\n"));
        ASSERT(0);
        goto AfpPnPReconfigEnable_Exit;
    }

    if ((AfpServerState == AFP_STATE_START_PENDING) ||
        (AfpServerState == AFP_STATE_RUNNING))
    {
	    // Det the server status block
	    Status = AfpSetServerStatus();

	    if (!NT_SUCCESS(Status))
	    {
    	    AFPLOG_ERROR(AFPSRVMSG_SET_STATUS, Status, NULL, 0, NULL);
	        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
        	    ("AfpTdi..: AfpSetServerStatus failed with %lx\n",Status));
            goto AfpPnPReconfigEnable_Exit;
	    }

        // Register our name on this address
	    Status = AfpSpRegisterName(&AfpServerName, True);

	    if (!NT_SUCCESS(Status))
	    {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
	            ("AfpTdi...: AfpSpRegisterName failed with %lx\n",Status));

            goto AfpPnPReconfigEnable_Exit;
	    }

        // Enable listens now that we are ready for it.
	    AfpSpEnableListens();
    }


AfpPnPReconfigEnable_Exit:

    if (!NT_SUCCESS(Status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
	        ("AfpTdi...: Closing Asp because of failure %lx\n",Status));
        AfpSpCloseAddress();
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("AFP/Appletalk bound and ready\n"));
    }
    // wake up the blocked pnp thread
    KeSetEvent(pReCfgEvent, IO_NETWORK_INCREMENT, False);

}

/***	AfpTdiRegister
 *
 *	Register our handler with tdi
 */
NTSTATUS
AfpTdiRegister(
    IN VOID
)
{
    NTSTATUS    Status;

    UNICODE_STRING ClientName;
    TDI_CLIENT_INTERFACE_INFO ClientInterfaceInfo;

    RtlInitUnicodeString(&ClientName,L"MacSrv");

    ClientInterfaceInfo.MajorTdiVersion = 2;
    ClientInterfaceInfo.MinorTdiVersion = 0;

    ClientInterfaceInfo.Unused = 0;
    ClientInterfaceInfo.ClientName = &ClientName;

    ClientInterfaceInfo.BindingHandler = AfpTdiPnpHandler;
    ClientInterfaceInfo.AddAddressHandlerV2 = DsiIpAddressCameIn;
    ClientInterfaceInfo.DelAddressHandlerV2 = DsiIpAddressWentAway;
    ClientInterfaceInfo.PnPPowerHandler = NULL;

    Status = TdiRegisterPnPHandlers (
                 &ClientInterfaceInfo,
                 sizeof(ClientInterfaceInfo),
                 &AfpTdiNotificationHandle );

    if (!NT_SUCCESS(Status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
       	    ("AfpTdiRegister: TdiRegisterPnPHandlers failed (%lx)\n",Status));
    }

    return(Status);
}

/***	AfpSpOpenAddress
 *
 *	Create an address for the stack. This is called only once at initialization.
 *	Create a handle to the address and map it to the associated file object.
 *
 *	At this time, we do not know our server name. This is known only when the
 *	service calls us.
 */
AFPSTATUS
AfpSpOpenAddress(
	VOID
)
{
	NTSTATUS					Status;
	NTSTATUS					Status2;
	BYTE						EaBuffer[sizeof(FILE_FULL_EA_INFORMATION) +
										TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
										sizeof(TA_APPLETALK_ADDRESS)];
	PFILE_FULL_EA_INFORMATION	pEaBuf = (PFILE_FULL_EA_INFORMATION)EaBuffer;
	TA_APPLETALK_ADDRESS		Ta;
	OBJECT_ATTRIBUTES			ObjAttr;
	UNICODE_STRING				DeviceName;
	IO_STATUS_BLOCK				IoStsBlk;
	PASP_BIND_ACTION			pBind = NULL;
	KEVENT						Event;
	PIRP						pIrp = NULL;
	PMDL						pMdl = NULL;


    PAGED_CODE( );

	DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
			("AfpSpOpenAddress: Creating an address object\n"));

	RtlInitUnicodeString(&DeviceName, ATALKASPS_DEVICENAME);

	InitializeObjectAttributes(&ObjAttr, &DeviceName, 0, NULL, NULL);

	// Initialize the EA Buffer
	pEaBuf->NextEntryOffset = 0;
	pEaBuf->Flags = 0;
	pEaBuf->EaValueLength = sizeof(TA_APPLETALK_ADDRESS);
	pEaBuf->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
	RtlCopyMemory(pEaBuf->EaName, TdiTransportAddress,
											TDI_TRANSPORT_ADDRESS_LENGTH + 1);
	Ta.TAAddressCount = 1;
	Ta.Address[0].AddressType = TDI_ADDRESS_TYPE_APPLETALK;
	Ta.Address[0].AddressLength = sizeof(TDI_ADDRESS_APPLETALK);
	Ta.Address[0].Address[0].Socket = 0;
	// Ta.Address[0].Address[0].Network = 0;
	// Ta.Address[0].Address[0].Node = 0;
	RtlCopyMemory(&pEaBuf->EaName[TDI_TRANSPORT_ADDRESS_LENGTH + 1], &Ta, sizeof(Ta));

	do
	{
		// Create the address object.
		Status = NtCreateFile(
						&afpSpAddressHandle,
						0,									// Don't Care
						&ObjAttr,
						&IoStsBlk,
						NULL,								// Don't Care
						0,									// Don't Care
						0,									// Don't Care
						0,									// Don't Care
						FILE_GENERIC_READ + FILE_GENERIC_WRITE,
						&EaBuffer,
						sizeof(EaBuffer));

		if (!NT_SUCCESS(Status))
		{
			AFPLOG_DDERROR(AFPSRVMSG_CREATE_ATKADDR, Status, NULL, 0, NULL);
			break;
		}

		// Get the file object corres. to the address object.
		Status = ObReferenceObjectByHandle(
								afpSpAddressHandle,
								0,
								NULL,
								KernelMode,
								(PVOID *)&afpSpAddressObject,
								NULL);

		ASSERT (NT_SUCCESS(Status));
		if (!NT_SUCCESS(Status))
		{
			if (afpSpAddressHandle != NULL)
			{
				ASSERT(VALID_FSH((PFILESYSHANDLE)&afpSpAddressHandle)) ;
				Status2 = NtClose(afpSpAddressHandle);

				afpSpAddressHandle = NULL;
		
				ASSERT(NT_SUCCESS(Status2));
			}

			AFPLOG_DDERROR(AFPSRVMSG_CREATE_ATKADDR, Status, NULL, 0, NULL);
			break;
		}

		// Now get the device object to the appletalk stack
		afpSpAppleTalkDeviceObject = IoGetRelatedDeviceObject(afpSpAddressObject);

		ASSERT (afpSpAppleTalkDeviceObject != NULL);

		// Now 'bind' to the ASP layer of the stack. Basically exchange the entry points
		// Allocate an Irp and an Mdl to describe the bind request
		KeInitializeEvent(&Event, NotificationEvent, False);

		if (((pBind = (PASP_BIND_ACTION)AfpAllocNonPagedMemory(
									sizeof(ASP_BIND_ACTION))) == NULL) ||
			((pIrp = AfpAllocIrp(1)) == NULL) ||
			((pMdl = AfpAllocMdl(pBind, sizeof(ASP_BIND_ACTION), pIrp)) == NULL))
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		afpInitializeActionHdr(pBind, ACTION_ASP_BIND);

		// Initialize the client part of the bind request
		pBind->Params.ClientEntries.clt_SessionNotify = AfpSdaCreateNewSession;
		pBind->Params.ClientEntries.clt_RequestNotify = afpSpHandleRequest;
		pBind->Params.ClientEntries.clt_GetWriteBuffer = AfpGetWriteBuffer;
		pBind->Params.ClientEntries.clt_ReplyCompletion = afpSpReplyComplete;
        pBind->Params.ClientEntries.clt_AttnCompletion = afpSpAttentionComplete;
		pBind->Params.ClientEntries.clt_CloseCompletion = afpSpCloseComplete;
		pBind->Params.pXportEntries = &AfpAspEntries;

		TdiBuildAction(	pIrp,
						AfpDeviceObject,
						afpSpAddressObject,
						(PIO_COMPLETION_ROUTINE)afpSpGenericComplete,
						&Event,
						pMdl);

		IoCallDriver(afpSpAppleTalkDeviceObject, pIrp);

		// Assert this. We cannot block at DISPATCH_LEVEL
		ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

		AfpIoWait(&Event, NULL);
	} while (False);

	// Free the allocated resources
	if (pIrp != NULL)
		AfpFreeIrp(pIrp);
	if (pMdl != NULL)
		AfpFreeMdl(pMdl);
	if (pBind != NULL)
		AfpFreeMemory(pBind);

    if (NT_SUCCESS(Status))
    {
        AfpServerBoundToAsp = TRUE;

        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
	        ("AfpSpOpenAddress: net addr (net.node.socket) on def adapter = %x.%x.%x\n",
            AfpAspEntries.asp_AtalkAddr.Network,AfpAspEntries.asp_AtalkAddr.Node,AfpAspEntries.asp_AtalkAddr.Socket));
    }

	return Status;
}


/***	AfpSpCloseAddress
 *
 *	Close the socket address. This is called only once at driver unload.
 */
VOID
AfpSpCloseAddress(
	VOID
)
{
	NTSTATUS	Status;

	PAGED_CODE( );

	if (afpSpAddressHandle != NULL)
	{
		ObDereferenceObject(afpSpAddressObject);

		Status = NtClose(afpSpAddressHandle);

        afpSpAddressHandle = NULL;

		ASSERT(NT_SUCCESS(Status));
	}

    AfpServerBoundToAsp = FALSE;

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
	    ("AfpSpCloseAddress: closed Afp handle (%lx)\n",Status));
}


/***	AfpSpRegisterName
 *
 *	Call Nbp[De]Register to (de)register our name on the address that we
 *	already opened. This is called at server start/pause/continue. The server
 *	name is already validated and known to not contain any invalid characters.
 *	This call is synchronous to the caller, i.e. we wait for operation to
 *	complete and return an appropriate error.
 */
AFPSTATUS
AfpSpRegisterName(
	IN	PANSI_STRING	ServerName,
	IN	BOOLEAN			Register
)
{
	KEVENT					Event;
	PNBP_REGDEREG_ACTION	pNbp = NULL;
	PIRP					pIrp = NULL;
	PMDL					pMdl = NULL;
	AFPSTATUS				Status = AFP_ERR_NONE;
	USHORT					ActionCode;

	PAGED_CODE( );

	ASSERT(afpSpAddressHandle != NULL && afpSpAddressObject != NULL);

	if (Register ^ afpSpNameRegistered)
	{
		ASSERT(ServerName->Buffer != NULL);
		do
		{
			if (((pNbp = (PNBP_REGDEREG_ACTION)
						AfpAllocNonPagedMemory(sizeof(NBP_REGDEREG_ACTION))) == NULL) ||
				((pIrp = AfpAllocIrp(1)) == NULL) ||
				((pMdl = AfpAllocMdl(pNbp, sizeof(NBP_REGDEREG_ACTION), pIrp)) == NULL))
			{
				Status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			// Initialize the Action header and NBP Name. Note that the ServerName
			// is also NULL terminated apart from being a counted string.
			ActionCode = Register ?
						COMMON_ACTION_NBPREGISTER : COMMON_ACTION_NBPREMOVE;
			afpInitializeActionHdr(pNbp, ActionCode);

			pNbp->Params.RegisterTuple.NbpName.ObjectNameLen =
														(BYTE)(ServerName->Length);
			RtlCopyMemory(
				pNbp->Params.RegisterTuple.NbpName.ObjectName,
				ServerName->Buffer,
				ServerName->Length);

			pNbp->Params.RegisterTuple.NbpName.TypeNameLen =
													sizeof(AFP_SERVER_TYPE)-1;
			RtlCopyMemory(
				pNbp->Params.RegisterTuple.NbpName.TypeName,
				AFP_SERVER_TYPE,
				sizeof(AFP_SERVER_TYPE));

			pNbp->Params.RegisterTuple.NbpName.ZoneNameLen =
												sizeof(AFP_SERVER_ZONE)-1;
			RtlCopyMemory(
				pNbp->Params.RegisterTuple.NbpName.ZoneName,
				AFP_SERVER_ZONE,
				sizeof(AFP_SERVER_ZONE));

			KeInitializeEvent(&Event, NotificationEvent, False);

			// Build the Irp
			TdiBuildAction(	pIrp,
							AfpDeviceObject,
							afpSpAddressObject,
							(PIO_COMPLETION_ROUTINE)afpSpGenericComplete,
							&Event,
							pMdl);

			IoCallDriver(afpSpAppleTalkDeviceObject, pIrp);

			// Assert this. We cannot block at DISPATCH_LEVEL
			ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

			// Wait for completion.
			AfpIoWait(&Event, NULL);

			Status = pIrp->IoStatus.Status;
		} while (False);

		if (NT_SUCCESS(Status))
		{
			afpSpNameRegistered = Register;
		}
		else
		{
			AFPLOG_ERROR(AFPSRVMSG_REGISTER_NAME, Status, NULL, 0, NULL);
		}

		if (pNbp != NULL)
			AfpFreeMemory(pNbp);
		if (pIrp != NULL)
			AfpFreeIrp(pIrp);
		if (pMdl != NULL)
			AfpFreeMdl(pMdl);
	}
	return Status;
}


/***	AfpSpReplyClient
 *
 *	This is a wrapper over AspReply.
 *	The SDA is set up to accept another request when the reply completes.
 *	The sda_ReplyBuf is also freed up then.
 */
VOID FASTCALL
AfpSpReplyClient(
	IN	PREQUEST	        pRequest,
	IN	LONG		        ReplyCode,
    IN  PASP_XPORT_ENTRIES  XportTable
)
{
	LONG			Response;

	// Update count of outstanding replies
	INTERLOCKED_INCREMENT_LONG((PLONG)&afpSpNumOutstandingReplies);

	// Convert reply code to on-the-wire format
	PUTDWORD2DWORD(&Response, ReplyCode);

	(*(XportTable->asp_Reply))(pRequest,(PUCHAR)&Response);
}


/***	AfpSpSendAttention
 *
 *	Send a server attention to the client
 */
VOID FASTCALL
AfpSpSendAttention(
	IN	PSDA				pSda,
	IN	USHORT				AttnCode,
	IN	BOOLEAN				Synchronous
)
{
	KEVENT		Event;
	NTSTATUS	Status;

	if (Synchronous)
	{
		ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);
		KeInitializeEvent(&Event, NotificationEvent, False);
	
	}
	Status = (*(pSda->sda_XportTable->asp_SendAttention))((pSda)->sda_SessHandle,
												  AttnCode,
												  Synchronous ? &Event : NULL);

	if (NT_SUCCESS(Status) && Synchronous)
	{
		ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
		AfpIoWait(&Event, NULL);
	}
}


/***	AfpAllocReplyBuf
 *
 *	Allocate a reply buffer from non-paged memory. Initialize sda_ReplyBuf
 *	with the pointer. If the reply buffer is small enough, use it out of the
 *	sda itself.
 */
AFPSTATUS FASTCALL
AfpAllocReplyBuf(
	IN	PSDA	pSda
)
{
	KIRQL	OldIrql;
    PBYTE   pStartOfBuffer;
    DWORD   Offset;
    USHORT  ReplySize;


	ASSERT ((SHORT)(pSda->sda_ReplySize) >= 0);

	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

    ReplySize =  pSda->sda_ReplySize;
    Offset = 0;

    //
    // for a TCP connection, alloc space for the DSI header
    //
    if (pSda->sda_Flags & SDA_SESSION_OVER_TCP)
    {
        ReplySize += DSI_HEADER_SIZE;
        Offset = DSI_HEADER_SIZE;
    }

	if (((pSda->sda_Flags & SDA_NAMEXSPACE_IN_USE) == 0) &&
		(ReplySize <= pSda->sda_SizeNameXSpace))
	{
		pStartOfBuffer = pSda->sda_NameXSpace;
		pSda->sda_Flags |= SDA_NAMEXSPACE_IN_USE;
	}
	else
	{
		pStartOfBuffer = AfpAllocNonPagedMemory(ReplySize);
	}

	if (pStartOfBuffer != NULL)
	{
        pSda->sda_ReplyBuf = (pStartOfBuffer + Offset);
	}
    else
    {
		pSda->sda_ReplySize = 0;
        pSda->sda_ReplyBuf = NULL;
    }


#if DBG
    if (pStartOfBuffer != NULL)
    {
        *(DWORD *)pStartOfBuffer = 0x081294;
    }
#endif

	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);

	return ((pSda->sda_ReplyBuf == NULL) ? AFP_ERR_MISC : AFP_ERR_NONE);
}


/***	AfpSpCloseSession
 *
 *	Shutdown an existing session
 */
NTSTATUS FASTCALL
AfpSpCloseSession(
	IN	PSDA				pSda
)
{
    PASP_XPORT_ENTRIES  XportTable;

    XportTable = pSda->sda_XportTable;

	DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
			("AfpSpCloseSession: Closing session %lx\n", pSda->sda_SessHandle));

	(*(XportTable->asp_CloseConn))(pSda->sda_SessHandle);

	return STATUS_PENDING;
}


/***	afpSpHandleRequest
 *
 *	Handle an incoming request.
 *
 *	LOCKS:		afpSpDeferralQLock (SPIN)
 */
NTSTATUS FASTCALL
afpSpHandleRequest(
	IN	NTSTATUS			Status,
	IN	PSDA				pSda,
	IN	PREQUEST			pRequest
)
{
    NTSTATUS        RetStatus=STATUS_SUCCESS;
	PBYTE	        pWriteBuf;
    PDELAYEDALLOC   pDelAlloc;


	ASSERT(VALID_SDA(pSda));

	// Get the status code and determine what happened.
	if (NT_SUCCESS(Status))
	{
		ASSERT(VALID_SDA(pSda));
		ASSERT(pSda->sda_RefCount != 0);
		ASSERT(pSda->sda_SessionId != 0);

		ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

        if (pSda->sda_Flags & (SDA_CLOSING | SDA_SESSION_CLOSED | SDA_CLIENT_CLOSE))
        {
		    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
				("afpSpHandleRequest: got request on a closing connection!\n"));
		    RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

		    // If this was a write request and we have allocated a write Mdl, free that
		    if (pRequest->rq_WriteMdl != NULL)
		    {
                //
                // did we get this Mdl from cache mgr?  if so, treat it separately
                //
                if ((pDelAlloc = pRequest->rq_CacheMgrContext) != NULL)
                {
                    pDelAlloc->Flags |= AFP_CACHEMDL_DEADSESSION;

                    ASSERT(pRequest->rq_WriteMdl == pDelAlloc->pMdl);
                    ASSERT(!(pDelAlloc->Flags & AFP_CACHEMDL_ALLOC_ERROR));

                    pRequest->rq_CacheMgrContext = NULL;

                    AfpReturnWriteMdlToCM(pDelAlloc);
                }
                else
                {
			        pWriteBuf = MmGetSystemAddressForMdlSafe(
							pRequest->rq_WriteMdl,
							NormalPagePriority);
					if (pWriteBuf != NULL)
					{
						AfpIOFreeBuffer(pWriteBuf);
					}
			        AfpFreeMdl(pRequest->rq_WriteMdl);
                }

                pRequest->rq_WriteMdl = NULL;
		    }

            return(STATUS_LOCAL_DISCONNECT);
        }

		pSda->sda_RefCount ++;

        //
        // should we queue this request up?
        //
		if ((pSda->sda_Flags & SDA_REQUEST_IN_PROCESS)	||
			(!IsListEmpty(&pSda->sda_DeferredQueue)))
		{
			afpQueueDeferredRequest(pSda, pRequest);
		    RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
		}

        //
        // nope, let's do it now!
        //
		else
		{
			pSda->sda_Request = pRequest;
			pSda->sda_Flags |= SDA_REQUEST_IN_PROCESS;

			ASSERT ((pSda->sda_ReplyBuf == NULL) &&
					(pSda->sda_ReplySize == 0));

		    RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

			// Call AfpUnmarshallReq now. It will do the needful.
			AfpUnmarshallReq(pSda);
		}
	}
	else
	{
		KIRQL	OldIrql;

		DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
				("afpSpHandleRequest: Error %lx\n", Status));

		// if we nuked this session from the session maintenance timer the
		// status will be STATUS_LOCAL_DISCONNECT else STATUS_REMOTE_DISCONNECT
		// in the former case, log an error.
		if (Status == STATUS_LOCAL_DISCONNECT)
		{
			// The appletalk address of the client is encoded in the length
			if (pSda->sda_ClientType == SDA_CLIENT_GUEST)
			{
				if (pSda->sda_Flags & SDA_SESSION_OVER_TCP) {
					AFPLOG_DDERROR(AFPSRVMSG_DISCONNECT_GUEST_TCPIP,
							Status,
							&pRequest->rq_RequestSize,
							sizeof(LONG),
							NULL);
				} else {
					AFPLOG_DDERROR(AFPSRVMSG_DISCONNECT_GUEST,
							Status,
							&pRequest->rq_RequestSize,
							sizeof(LONG),
							NULL);
				}
			}
			else
			{
				if (pSda->sda_Flags & SDA_SESSION_OVER_TCP) {
					AFPLOG_DDERROR(AFPSRVMSG_DISCONNECT_TCPIP,
							Status,
							&pRequest->rq_RequestSize,
							sizeof(LONG),
							&pSda->sda_UserName);
				} else {
					AFPLOG_DDERROR(AFPSRVMSG_DISCONNECT,
							Status,
							&pRequest->rq_RequestSize,
							sizeof(LONG),
							&pSda->sda_UserName);
				}
			}
		}

		// Close down this session, but only if it isn't already closing
		// Its important to do this ahead of posting any new sessions since
		// we must take into account the ACTUAL number of sessions there are
		ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

		pSda->sda_Flags |= SDA_CLIENT_CLOSE;
		if ((pSda->sda_Flags & SDA_SESSION_CLOSED) == 0)
		{
			DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
					("afpSpHandleRequest: Closing session handle\n"));
	
			pSda->sda_Flags |= SDA_SESSION_CLOSED;
			RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);
			AfpSpCloseSession(pSda);
		}
		else
		{
			RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);
		}

		// If this was a write request and we have allocated a write Mdl, free that
		if (pRequest->rq_WriteMdl != NULL)
		{
            //
            // did we get this Mdl from cache mgr?  if so, treat it separately
            //
            if ((pDelAlloc = pRequest->rq_CacheMgrContext) != NULL)
            {
                pDelAlloc->Flags |= AFP_CACHEMDL_DEADSESSION;

                ASSERT(pRequest->rq_WriteMdl == pDelAlloc->pMdl);
                ASSERT(!(pDelAlloc->Flags & AFP_CACHEMDL_ALLOC_ERROR));

                pRequest->rq_CacheMgrContext = NULL;

                AfpReturnWriteMdlToCM(pDelAlloc);
            }
            else
            {
			    pWriteBuf = MmGetSystemAddressForMdlSafe(
						pRequest->rq_WriteMdl,
						NormalPagePriority);
				if (pWriteBuf != NULL)
				{
					AfpIOFreeBuffer(pWriteBuf);
				}
			    AfpFreeMdl(pRequest->rq_WriteMdl);
            }

            pRequest->rq_WriteMdl = NULL;
		}
	}

    return(RetStatus);
}


/***	afpSpGenericComplete
 *
 *	Generic completion for an asynchronous request to the appletalk stack.
 *	Just clear the event and we are done.
 */
LOCAL NTSTATUS
afpSpGenericComplete(
	IN	PDEVICE_OBJECT	pDeviceObject,
	IN	PIRP			pIrp,
	IN	PKEVENT			pCmplEvent
)
{
	KeSetEvent(pCmplEvent, IO_NETWORK_INCREMENT, False);

	// Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
	// will stop working on the IRP.

	return STATUS_MORE_PROCESSING_REQUIRED;
}


/***	afpSpReplyComplete
 *
 *	This is the completion routine for AfpSpReplyClient(). The reply buffer is freed
 *	up and the Sda dereferenced.
 */
VOID FASTCALL
afpSpReplyComplete(
	IN	NTSTATUS	Status,
	IN	PSDA		pSda,
	IN	PREQUEST	pRequest
)
{
	KIRQL           OldIrql;
	DWORD           Flags = SDA_REPLY_IN_PROCESS;
	PMDL	        pMdl;
    PDELAYEDALLOC   pDelAlloc;


	ASSERT(VALID_SDA(pSda));

	// Update the afpSpNumOutstandingReplies
	ASSERT (afpSpNumOutstandingReplies != 0);

	DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
			("afpSpReplyComplete: %ld\n", Status));

	INTERLOCKED_DECREMENT_LONG((PLONG)&afpSpNumOutstandingReplies);

    pMdl = pRequest->rq_ReplyMdl;

    if ((pDelAlloc = pRequest->rq_CacheMgrContext) != NULL)
    {
        pRequest->rq_CacheMgrContext = NULL;

        ASSERT((pMdl != NULL) && (pMdl == pDelAlloc->pMdl));

        AfpReturnReadMdlToCM(pDelAlloc);
    }
    else
    {
	    if (pMdl != NULL)
	    {
		    PBYTE	pReplyBuf;

		    pReplyBuf = MmGetSystemAddressForMdlSafe(
					pMdl,
					NormalPagePriority);
		    ASSERT (pReplyBuf != NULL);

		    if ((pReplyBuf != pSda->sda_NameXSpace) &&
					(pReplyBuf != NULL))
            {
			     AfpFreeMemory(pReplyBuf);
            }
		    else
            {
                Flags |= SDA_NAMEXSPACE_IN_USE;
            }

		    AfpFreeMdl(pMdl);
	    }
    }

	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);
	pSda->sda_Flags &= ~Flags;
	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);

	AfpSdaDereferenceSession(pSda);
}


/***	afpSpAttentionComplete
 *
 *	Completion routine for AfpSpSendAttention. Just signal the event and unblock caller.
 */
VOID FASTCALL
afpSpAttentionComplete(
	IN	PVOID				pEvent
)
{
	if (pEvent != NULL)
		KeSetEvent((PKEVENT)pEvent, IO_NETWORK_INCREMENT, False);
}


/***	afpSpCloseComplete
 *
 *	Completion routine for AfpSpCloseSession. Remove the creation reference
 *	from the sda.
 */
VOID FASTCALL
afpSpCloseComplete(
	IN	NTSTATUS			Status,
	IN	PSDA				pSda
)
{
	AfpInterlockedSetDword(&pSda->sda_Flags,
							SDA_SESSION_CLOSE_COMP,
							&pSda->sda_Lock);
	AfpScavengerScheduleEvent(AfpSdaCloseSession,
							  pSda,
							  0,
							  True);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\cachemdl.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	cachemdl.c

Abstract:

	This module contains the routines for to get Mdl for Reads and Writes
    directly from the Cache Mgr, which helps avoid one data copy and reduces
    our non-paged memory consumption (significantly!)

Author:

	Shirish Koti


Revision History:
	June 12, 1998		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_CACHEMDL

#include <afp.h>
#include <forkio.h>
#include <gendisp.h>

VOID FASTCALL
AfpAllocWriteMdl(
    IN PDELAYEDALLOC    pDelAlloc
)
{
	PREQUEST        pRequest;
    POPENFORKENTRY  pOpenForkEntry;
    NTSTATUS        status=STATUS_SUCCESS;


    ASSERT(KeGetCurrentIrql() == LOW_LEVEL);
    ASSERT(VALID_SDA(pDelAlloc->pSda));
    ASSERT(pDelAlloc->BufSize >= CACHEMGR_WRITE_THRESHOLD);

    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_WRITE_MDL);

    pRequest = pDelAlloc->pRequest;
    pOpenForkEntry = pDelAlloc->pOpenForkEntry;

    ASSERT((VALID_OPENFORKENTRY(pOpenForkEntry)) || (pOpenForkEntry == NULL));

    // assume for now that cache mgr will fail to return the mdl
    status = STATUS_UNSUCCESSFUL;
    pRequest->rq_WriteMdl = NULL;

    if (pOpenForkEntry)
    {
        status = AfpBorrowWriteMdlFromCM(pDelAlloc, &pRequest->rq_WriteMdl);
    }

    if (status != STATUS_PENDING)
    {
        AfpAllocWriteMdlCompletion(NULL, NULL, pDelAlloc);
    }
}


NTSTATUS FASTCALL
AfpBorrowWriteMdlFromCM(
    IN  PDELAYEDALLOC   pDelAlloc,
    OUT PMDL           *ppReturnMdl
)
{

    IO_STATUS_BLOCK     IoStsBlk;
    PIRP                pIrp;
    PIO_STACK_LOCATION  pIrpSp;
    PFAST_IO_DISPATCH   pFastIoDisp;
    LARGE_INTEGER       LargeOffset;
    BOOLEAN             fGetMdlWorked;
	PSDA	            pSda;
    POPENFORKENTRY      pOpenForkEntry;
    PFILE_OBJECT        pFileObject;



    pSda = pDelAlloc->pSda;
    pOpenForkEntry = pDelAlloc->pOpenForkEntry;

    ASSERT(VALID_SDA(pSda));
    ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

    pFastIoDisp = pOpenForkEntry->ofe_pDeviceObject->DriverObject->FastIoDispatch;

    pFileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);

    ASSERT(pFileObject->Flags & FO_CACHE_SUPPORTED);

    ASSERT(pFastIoDisp->PrepareMdlWrite != NULL);

    LargeOffset = pDelAlloc->Offset;

    fGetMdlWorked = pFastIoDisp->PrepareMdlWrite(
                            pFileObject,
                            &LargeOffset,
                            pDelAlloc->BufSize,      // how big is the Write
                            pSda->sda_SessionId,
                            ppReturnMdl,
                            &IoStsBlk,
                            pOpenForkEntry->ofe_pDeviceObject);

    if (fGetMdlWorked && (*ppReturnMdl != NULL))
    {
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
	        ("AfpBorrowWriteMdlFromCM: fast path workd, Mdl = %lx\n",*ppReturnMdl));

        pDelAlloc->pMdl = *ppReturnMdl;

        return(STATUS_SUCCESS);
    }


    //
    // fast path didn't work (or worked only partially).  We must give an irp down
    // to get the (rest of the) mdl
    //

	// Allocate and initialize the IRP for this operation.
	pIrp = AfpAllocIrp(pOpenForkEntry->ofe_pDeviceObject->StackSize);

    // yikes, how messy can it get!
	if (pIrp == NULL)
	{
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpBorrowWriteMdlFromCM: irp alloc failed!\n"));

        // if cache mgr returned a partial mdl, give it back!
        if (*ppReturnMdl)
        {
	        DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	            ("AfpBorrowWriteMdlFromCM: giving back partial Mdl\n"));

            pDelAlloc->pMdl = *ppReturnMdl;
            pDelAlloc->Flags |= AFP_CACHEMDL_ALLOC_ERROR;

            pDelAlloc->pRequest->rq_CacheMgrContext = NULL;

            AfpReturnWriteMdlToCM(pDelAlloc);
        }
        return(STATUS_INSUFFICIENT_RESOURCES);
	}

	// Set up the completion routine.
	IoSetCompletionRoutine(
            pIrp,
			(PIO_COMPLETION_ROUTINE)AfpAllocWriteMdlCompletion,
			pDelAlloc,
			True,
			True,
			True);

	pIrpSp = IoGetNextIrpStackLocation(pIrp);

	pIrp->Tail.Overlay.OriginalFileObject =
                        AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
	pIrp->Tail.Overlay.Thread = AfpThread;
	pIrp->RequestorMode = KernelMode;

    pIrp->Flags = IRP_SYNCHRONOUS_API;

	pIrpSp->MajorFunction = IRP_MJ_WRITE;
	pIrpSp->MinorFunction = IRP_MN_MDL;
	pIrpSp->FileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
	pIrpSp->DeviceObject = pOpenForkEntry->ofe_pDeviceObject;

	pIrpSp->Parameters.Write.Length = pDelAlloc->BufSize;
	pIrpSp->Parameters.Write.Key = pSda->sda_SessionId;
	pIrpSp->Parameters.Write.ByteOffset = LargeOffset;

    //
    // *ppReturnMdl could potentially be non-null if the fast-path returned
    // a partial mdl
    //
    pIrp->MdlAddress = *ppReturnMdl;

    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_REQUESTED);
    AFP_DBG_SET_DELALLOC_IRP(pDelAlloc,pIrp);

	IoCallDriver(pOpenForkEntry->ofe_pDeviceObject, pIrp);

    return(STATUS_PENDING);
}



NTSTATUS
AfpAllocWriteMdlCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
)
{
	PSDA	            pSda;
	PBYTE	            pBuf;
	PREQUEST            pRequest;
    PDELAYEDALLOC       pDelAlloc;
    PMDL                pMdl=NULL;
    NTSTATUS            status=STATUS_SUCCESS;
    POPENFORKENTRY      pOpenForkEntry;


    pDelAlloc = (PDELAYEDALLOC)Context;

    pSda = pDelAlloc->pSda;
    pRequest = pDelAlloc->pRequest;
    pOpenForkEntry = pDelAlloc->pOpenForkEntry;


    ASSERT(VALID_SDA(pSda));
    ASSERT(pDelAlloc->BufSize >= CACHEMGR_WRITE_THRESHOLD);
    ASSERT((VALID_OPENFORKENTRY(pOpenForkEntry)) || (pOpenForkEntry == NULL));

    if (pIrp)
    {
        status = pIrp->IoStatus.Status;

        //
        // mark the fact that this mdl belongs to the cache mgr
        //
        if (NT_SUCCESS(status))
        {
            pRequest->rq_WriteMdl = pIrp->MdlAddress;
            ASSERT(pRequest->rq_WriteMdl != NULL);

            pDelAlloc->pMdl = pRequest->rq_WriteMdl;
        }
        else
        {
	        DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	            ("AfpAllocWriteMdlCompletion: irp %lx failed %lx\n",pIrp,status));

            ASSERT(pRequest->rq_WriteMdl == NULL);
            pRequest->rq_WriteMdl = NULL;
        }

        AfpFreeIrp(pIrp);

        AFP_DBG_SET_DELALLOC_IRP(pDelAlloc, NULL);
    }


    //
    // if we didn't get Mdl from cache mgr, fall back to the old, traditional
    // way of allocating!
    //
    if (pRequest->rq_WriteMdl == NULL)
    {
	    pBuf = AfpIOAllocBuffer(pDelAlloc->BufSize);

	    if (pBuf != NULL)
	    {
		    pMdl = AfpAllocMdl(pBuf, pDelAlloc->BufSize, NULL);
		    if (pMdl == NULL)
		    {
			    AfpIOFreeBuffer(pBuf);
		    }
	    }

        pRequest->rq_WriteMdl = pMdl;

        //
        // for whatever reason, we didn't get Mdl from cache mgr.  Undo the
        // things we had done in preparation (NOTE: if we do get the Mdl from
        // cache mgr, we leave the refcount etc. in tact until the Mdl is actually
        // returned to cache mgr)
        //

        pRequest->rq_CacheMgrContext = NULL;

        // make sure we aren't forgetting cache mgr's mdl
        ASSERT(pDelAlloc->pMdl == NULL);

        // don't need that memory no more
        AfpFreeDelAlloc(pDelAlloc);

        AfpSdaDereferenceSession(pSda);

        if (pOpenForkEntry)
        {
            AfpForkDereference(pOpenForkEntry);
        }
    }
    else
    {
        AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_IN_USE);
        AFP_DBG_INC_DELALLOC_BYTECOUNT(AfpWriteCMAlloced, pDelAlloc->BufSize);
    }

    //
    // tell the transport below to continue with the write
    //
    (*(pSda->sda_XportTable->asp_WriteContinue))(pRequest);

    return(STATUS_MORE_PROCESSING_REQUIRED);
}




VOID FASTCALL
AfpReturnWriteMdlToCM(
    IN  PDELAYEDALLOC   pDelAlloc
)
{
    PDEVICE_OBJECT      pDeviceObject;
    PFAST_IO_DISPATCH   pFastIoDisp;
    PIRP                pIrp;
    PIO_STACK_LOCATION  pIrpSp;
    LARGE_INTEGER       LargeOffset;
	PFILE_OBJECT        pFileObject;
    PSDA                pSda;
    POPENFORKENTRY      pOpenForkEntry;
    PMDL                pMdl;
    PVOID               Context;


    ASSERT(pDelAlloc != NULL);
    ASSERT(pDelAlloc->pMdl != NULL);

    //
    // are we at DPC? if so, can't do this now
    //
    if (KeGetCurrentIrql() == DISPATCH_LEVEL)
    {
        AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_PROC_QUEUED);

        AfpInitializeWorkItem(&pDelAlloc->WorkItem,
                              AfpReturnWriteMdlToCM,
                              pDelAlloc);

        AfpQueueWorkItem(&pDelAlloc->WorkItem);
        return;
    }

    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_PROC_IN_PROGRESS);

    pSda = pDelAlloc->pSda;
    pMdl = pDelAlloc->pMdl;
    pOpenForkEntry = pDelAlloc->pOpenForkEntry;

    ASSERT(VALID_SDA(pSda));
    ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

    pFileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject),
    pDeviceObject = pOpenForkEntry->ofe_pDeviceObject;

    LargeOffset = pDelAlloc->Offset;

    pFastIoDisp = pDeviceObject->DriverObject->FastIoDispatch;

    Context = pDelAlloc;

    //
    // if we came here because the cache mdl alloc failed but had partially
    // succeeded, then we don't want the completion routine to free up things
    // prematurely: in this case, pass NULL context
    //
    if (pDelAlloc->Flags & AFP_CACHEMDL_ALLOC_ERROR)
    {
        Context = NULL;
    }

    if (pFastIoDisp->MdlWriteComplete)
    {
        if (pFastIoDisp->MdlWriteComplete(
                pFileObject,
                &LargeOffset,
                pMdl,
                pDeviceObject) == TRUE)
        {
            AfpReturnWriteMdlToCMCompletion(NULL, NULL, Context);
            return;
        }
    }


	// Allocate and initialize the IRP for this operation.
	pIrp = AfpAllocIrp(pDeviceObject->StackSize);

    // yikes, how messy can it get!
	if (pIrp == NULL)
	{
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpReturnWriteMdlToCM: irp alloc failed!\n"));

        // log an event here - that's all we can do here!
        AFPLOG_ERROR(AFPSRVMSG_ALLOC_IRP, STATUS_INSUFFICIENT_RESOURCES,
						                     NULL, 0, NULL);
    
		AfpReturnWriteMdlToCMCompletion(NULL, NULL, Context);

        ASSERT(0);
        return;
	}

	// Set up the completion routine.
	IoSetCompletionRoutine(
            pIrp,
			(PIO_COMPLETION_ROUTINE)AfpReturnWriteMdlToCMCompletion,
			Context,
			True,
			True,
			True);

	pIrpSp = IoGetNextIrpStackLocation(pIrp);

	pIrp->Tail.Overlay.OriginalFileObject = AfpGetRealFileObject(pFileObject);
	pIrp->Tail.Overlay.Thread = AfpThread;
	pIrp->RequestorMode = KernelMode;

    pIrp->Flags = IRP_SYNCHRONOUS_API;

	pIrpSp->MajorFunction = IRP_MJ_WRITE;
	pIrpSp->MinorFunction = IRP_MN_MDL | IRP_MN_COMPLETE;
	pIrpSp->FileObject = AfpGetRealFileObject(pFileObject);
	pIrpSp->DeviceObject = pDeviceObject;

	pIrpSp->Parameters.Write.Length = pDelAlloc->BufSize;

	pIrpSp->Parameters.Write.ByteOffset = LargeOffset;

    pIrp->MdlAddress = pMdl;

    AFP_DBG_SET_DELALLOC_IRP(pDelAlloc, pIrp);
    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_RETURN_IN_PROGRESS);

	IoCallDriver(pDeviceObject, pIrp);

}


NTSTATUS
AfpReturnWriteMdlToCMCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
)
{
    PSDA            pSda;
    PDELAYEDALLOC   pDelAlloc;
    POPENFORKENTRY  pOpenForkEntry;
    NTSTATUS        status;
    AFPSTATUS       AfpStatus=AFP_ERR_NONE;

	struct _ResponsePacket
	{
		BYTE	__RealOffset[4];
	};


    pDelAlloc = (PDELAYEDALLOC)Context;

    if (pIrp)
    {
        status = pIrp->IoStatus.Status;

        //
        // mark the fact that this mdl belongs to the cache mgr
        //
        if (NT_SUCCESS(status))
        {

            AfpStatus = AFP_ERR_NONE;
        }
        else
        {
	        DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	            ("AfpReturnWriteMdlToCMCompletion: irp failed %lx\n",status));

            ASSERT(0);
            AfpStatus = AFP_ERR_MISC;
        }

        AfpFreeIrp(pIrp);
    }

    //
    // if pDelAlloc is NULL, then some error occured while borrowing CM's mdl.  We
    // We already finished up with the API at the time of the failure, so done here
    //
    if (pDelAlloc == NULL)
    {
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }


    pSda = pDelAlloc->pSda;
    pOpenForkEntry = pDelAlloc->pOpenForkEntry;

	if (AfpStatus == AFP_ERR_NONE)
	{
	    pSda->sda_ReplySize = SIZE_RESPPKT;
	    if ((AfpStatus = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
	    {
		    PUTDWORD2DWORD(pRspPkt->__RealOffset,
                           (pDelAlloc->Offset.LowPart + pDelAlloc->BufSize));
	    }
	}
    else
    {
        pSda->sda_ReplySize = 0;
    }

    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_RETURN_COMPLETED);
    AFP_DBG_DEC_DELALLOC_BYTECOUNT(AfpWriteCMAlloced, pDelAlloc->BufSize);

    //
    // call the completion routine only if everything is ok (we don't want
    // to call completion if session went dead)
    //
    if (!(pDelAlloc->Flags & AFP_CACHEMDL_DEADSESSION))
    {
        AfpCompleteApiProcessing(pSda, AfpStatus);
    }

    // remove the refcount when we referenced this
    AfpForkDereference(pOpenForkEntry);

    // remove the DelAlloc refcount
    AfpSdaDereferenceSession(pSda);

    // don't need that memory no more
    AfpFreeDelAlloc(pDelAlloc);

    return(STATUS_MORE_PROCESSING_REQUIRED);

}



NTSTATUS FASTCALL
AfpBorrowReadMdlFromCM(
    IN PSDA             pSda
)
{

    IO_STATUS_BLOCK     IoStsBlk;
    PIRP                pIrp;
    PIO_STACK_LOCATION  pIrpSp;
    PFAST_IO_DISPATCH   pFastIoDisp;
    PMDL                pReturnMdl=NULL;
    KIRQL               OldIrql;
    PREQUEST            pRequest;
    PDELAYEDALLOC       pDelAlloc;
    POPENFORKENTRY      pOpenForkEntry;
    PFILE_OBJECT        pFileObject;
    LARGE_INTEGER       Offset;
    LARGE_INTEGER       ReadSize;
    BOOLEAN             fGetMdlWorked;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
		LONG			_Offset;
		LONG			_Size;
		DWORD			_NlMask;
		DWORD			_NlChar;
	};


    ASSERT(VALID_SDA(pSda));

	Offset.QuadPart = pReqPkt->_Offset;
	ReadSize.QuadPart = pReqPkt->_Size;

    pOpenForkEntry = pReqPkt->_pOpenForkEntry;

    pFileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);

    ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

    pFastIoDisp = pOpenForkEntry->ofe_pDeviceObject->DriverObject->FastIoDispatch;

    if (!(pFileObject->Flags & FO_CACHE_SUPPORTED))
    {
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpBorrowReadMdlFromCM: FO_CACHE_SUPPORTED not set\n"));

        return(STATUS_UNSUCCESSFUL);
    }

    if (pFastIoDisp->MdlRead == NULL)
    {
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpBorrowReadMdlFromCM: PrepareMdl is NULL\n"));

        return(STATUS_UNSUCCESSFUL);
    }

    pDelAlloc = AfpAllocDelAlloc();

    if (pDelAlloc == NULL)
    {
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpBorrowReadMdlFromCM: malloc for pDelAlloc failed\n"));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_READ_MDL);

    // put DelAlloc refcount on pSda
    if (AfpSdaReferenceSessionByPointer(pSda) == NULL)
    {
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpBorrowReadMdlFromCM: couldn't reference pSda %lx\n",pSda));

        AfpFreeDelAlloc(pDelAlloc);
        return(STATUS_UNSUCCESSFUL);
    }

    // put DelAlloc refcount on pOpenForkEntry
    if (AfpForkReferenceByPointer(pOpenForkEntry) == NULL)
    {
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpBorrowReadMdlFromCM: couldn't reference %lx\n",pOpenForkEntry));

        // remove DelAlloc refcount
        AfpSdaDereferenceSession(pSda);
        AfpFreeDelAlloc(pDelAlloc);
        return(STATUS_UNSUCCESSFUL);
    }

    pRequest = pSda->sda_Request;

    ASSERT(pRequest->rq_ReplyMdl == NULL);

    pRequest->rq_CacheMgrContext = pDelAlloc;

    pDelAlloc->pSda = pSda;
    pDelAlloc->pRequest = pRequest;
    pDelAlloc->pOpenForkEntry = pOpenForkEntry;
    pDelAlloc->Offset = Offset;
    pDelAlloc->BufSize = ReadSize.LowPart;

    fGetMdlWorked = pFastIoDisp->MdlRead(
                            pFileObject,
                            &Offset,
                            ReadSize.LowPart,
                            pSda->sda_SessionId,
                            &pReturnMdl,
                            &IoStsBlk,
                            pOpenForkEntry->ofe_pDeviceObject);

    if (fGetMdlWorked && (pReturnMdl != NULL))
    {
        pDelAlloc->pMdl = pReturnMdl;

        // call the completion routine, so the read can complete
        AfpBorrowReadMdlFromCMCompletion(NULL, NULL, pDelAlloc);

        return(STATUS_PENDING);
    }


    //
    // fast path didn't work (or worked only partially).  We must give an irp down
    // to get the (rest of the) mdl
    //

	// Allocate and initialize the IRP for this operation.
	pIrp = AfpAllocIrp(pOpenForkEntry->ofe_pDeviceObject->StackSize);

    // yikes, how messy can it get!
	if (pIrp == NULL)
	{
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpBorrowReadMdlFromCM: irp alloc failed!\n"));

        // if cache mgr returned a partial mdl, give it back!
        if (pReturnMdl)
        {
	        DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	            ("AfpBorrowReadMdlFromCM: giving back partial Mdl\n"));

            pDelAlloc->pMdl = pReturnMdl;
            pRequest->rq_CacheMgrContext = NULL;

            AfpReturnReadMdlToCM(pDelAlloc);
        }
        return(STATUS_INSUFFICIENT_RESOURCES);
	}

	// Set up the completion routine.
	IoSetCompletionRoutine(
            pIrp,
			(PIO_COMPLETION_ROUTINE)AfpBorrowReadMdlFromCMCompletion,
			pDelAlloc,
			True,
			True,
			True);

	pIrpSp = IoGetNextIrpStackLocation(pIrp);

	pIrp->Tail.Overlay.OriginalFileObject =
                        AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
	pIrp->Tail.Overlay.Thread = AfpThread;
	pIrp->RequestorMode = KernelMode;

    pIrp->Flags = IRP_SYNCHRONOUS_API;

	pIrpSp->MajorFunction = IRP_MJ_READ;
	pIrpSp->MinorFunction = IRP_MN_MDL;
	pIrpSp->FileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
	pIrpSp->DeviceObject = pOpenForkEntry->ofe_pDeviceObject;

	pIrpSp->Parameters.Write.Length = ReadSize.LowPart;
	pIrpSp->Parameters.Write.Key = pSda->sda_SessionId;
	pIrpSp->Parameters.Write.ByteOffset = Offset;

    //
    // pReturnMdl could potentially be non-null if the fast-path returned
    // a partial mdl
    //
    pIrp->MdlAddress = pReturnMdl;

    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_REQUESTED);
    AFP_DBG_SET_DELALLOC_IRP(pDelAlloc,pIrp);

	IoCallDriver(pOpenForkEntry->ofe_pDeviceObject, pIrp);

    return(STATUS_PENDING);
}


NTSTATUS
AfpBorrowReadMdlFromCMCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
)
{

	PSDA	            pSda;
	PREQUEST            pRequest;
    PDELAYEDALLOC       pDelAlloc;
    PMDL                pMdl=NULL;
    NTSTATUS            status=STATUS_SUCCESS;
    AFPSTATUS           AfpStatus=AFP_ERR_NONE;
    PMDL                pCurrMdl;
    DWORD               CurrMdlSize;
    POPENFORKENTRY      pOpenForkEntry;
    PBYTE               pBuf;
    LONG                iLoc;
    LONG                i, Size;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
		LONG			_Offset;
		LONG			_Size;
		DWORD			_NlMask;
		DWORD			_NlChar;
	};


    pDelAlloc = (PDELAYEDALLOC)Context;

    pSda = pDelAlloc->pSda;
    pOpenForkEntry = pDelAlloc->pOpenForkEntry;
    pRequest = pDelAlloc->pRequest;

    ASSERT(VALID_SDA(pSda));
    ASSERT(pDelAlloc->BufSize >= CACHEMGR_READ_THRESHOLD);
    ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));


    if (pIrp)
    {
        status = pIrp->IoStatus.Status;

        //
        // mark the fact that this mdl belongs to the cache mgr
        //
        if (NT_SUCCESS(status))
        {
            pDelAlloc->pMdl = pIrp->MdlAddress;

            ASSERT(pDelAlloc->pMdl != NULL);
        }
        else
        {
	        DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_WARN,
	            ("AfpBorrowReadMdlFromCMCompletion: irp %lx failed %lx\n",pIrp,status));

            ASSERT(pDelAlloc->pMdl == NULL);
            pDelAlloc->pMdl = NULL;

            AfpStatus = AFP_ERR_MISC;
        }

        AfpFreeIrp(pIrp);

        AFP_DBG_SET_DELALLOC_IRP(pDelAlloc, NULL);
    }

    pRequest->rq_ReplyMdl = pDelAlloc->pMdl;

    // did we get Mdl from the cache mgr?  If so, we need to compute the reply size
    if (pRequest->rq_ReplyMdl != NULL)
    {
        Size = AfpMdlChainSize(pRequest->rq_ReplyMdl);

        if (Size == 0)
        {
            AfpStatus = AFP_ERR_EOF;
        }
		else if (pReqPkt->_NlMask != 0)
		{
            AfpStatus = AFP_ERR_NONE;

            pCurrMdl = pRequest->rq_ReplyMdl;

            CurrMdlSize = MmGetMdlByteCount(pCurrMdl);
            pBuf = MmGetSystemAddressForMdlSafe(
					pCurrMdl,
					NormalPagePriority);

			if (pBuf == NULL) {
				AfpStatus = AFP_ERR_MISC;
				goto error_end;
			}

			for (i=0, iLoc=0; i < Size; iLoc++, i++, pBuf++)
			{
                // move to the next Mdl if we exhausted this one
                if (iLoc >= (LONG)CurrMdlSize)
                {
                    ASSERT(i < Size);

                    pCurrMdl = pCurrMdl->Next;
                    ASSERT(pCurrMdl != NULL);

                    CurrMdlSize = MmGetMdlByteCount(pCurrMdl);
                    pBuf = MmGetSystemAddressForMdlSafe(
							pCurrMdl,
							NormalPagePriority);
					if (pBuf == NULL) {
						AfpStatus = AFP_ERR_MISC;
						goto error_end;
					}

                    iLoc = 0;
                }

			    if ((*pBuf & (BYTE)(pReqPkt->_NlMask)) == (BYTE)(pReqPkt->_NlChar))
				{
					Size = ++i;
					break;
				}
			}
		}

		pSda->sda_ReplySize = (USHORT)Size;

        AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_IN_USE);
        AFP_DBG_INC_DELALLOC_BYTECOUNT(AfpReadCMAlloced, pDelAlloc->BufSize);
    }

    //
    // we didn't get Mdl from cache mgr, fall back to the old, traditional
    // way of allocating and reading the file
    //
    else
    {
        // make sure we aren't forgetting cache mgr's mdl
        ASSERT(pDelAlloc->pMdl == NULL);

        pRequest->rq_CacheMgrContext = NULL;

        AfpForkDereference(pOpenForkEntry);

        AfpSdaDereferenceSession(pSda);

        // don't need that memory no more
        AfpFreeDelAlloc(pDelAlloc);

        AfpStatus = AfpFspDispReadContinue(pSda);
    }

error_end:
    if (AfpStatus != AFP_ERR_EXTENDED)
    {
        AfpCompleteApiProcessing(pSda, AfpStatus);
    }

    return(STATUS_MORE_PROCESSING_REQUIRED);

}


VOID FASTCALL
AfpReturnReadMdlToCM(
    IN  PDELAYEDALLOC   pDelAlloc
)
{
    PDEVICE_OBJECT      pDeviceObject;
    PFAST_IO_DISPATCH   pFastIoDisp;
    PIRP                pIrp;
    PIO_STACK_LOCATION  pIrpSp;
    LARGE_INTEGER       LargeOffset;
    DWORD               ReadSize;
	PFILE_OBJECT        pFileObject;
    PSDA                pSda;
    PMDL                pMdl;
    POPENFORKENTRY      pOpenForkEntry;


    ASSERT(pDelAlloc != NULL);
    ASSERT(pDelAlloc->pMdl != NULL);


    //
    // are we at DPC? if so, can't do this now
    //
    if (KeGetCurrentIrql() == DISPATCH_LEVEL)
    {
        AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_PROC_QUEUED);

        AfpInitializeWorkItem(&pDelAlloc->WorkItem,
                              AfpReturnReadMdlToCM,
                              pDelAlloc);
        AfpQueueWorkItem(&pDelAlloc->WorkItem);
        return;
    }

    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_PROC_IN_PROGRESS);

    pSda = pDelAlloc->pSda;
    pOpenForkEntry = pDelAlloc->pOpenForkEntry;

    pMdl = pDelAlloc->pMdl;

    ASSERT(VALID_SDA(pSda));
    ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

    pFileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject),
    pDeviceObject = pOpenForkEntry->ofe_pDeviceObject;

    LargeOffset = pDelAlloc->Offset;
    ReadSize = pDelAlloc->BufSize;

    pFastIoDisp = pDeviceObject->DriverObject->FastIoDispatch;

    //
    // try the fast path to return the Mdl to cache mgr
    //
    if (pFastIoDisp->MdlReadComplete)
    {
        if (pFastIoDisp->MdlReadComplete(pFileObject,pMdl,pDeviceObject) == TRUE)
        {
            AfpReturnReadMdlToCMCompletion(NULL, NULL, pDelAlloc);
            return;
        }
    }

    //
    // hmmm: fast path didn't work, got to post an irp!
    //

	// Allocate and initialize the IRP for this operation.
	pIrp = AfpAllocIrp(pDeviceObject->StackSize);

    // yikes, how messy can it get!
	if (pIrp == NULL)
	{
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpReturnReadMdlToCM: irp alloc failed!\n"));

        // log an event here - that's all we can do here!
        AFPLOG_ERROR(AFPSRVMSG_ALLOC_IRP, STATUS_INSUFFICIENT_RESOURCES,
						                     NULL, 0, NULL);

		AfpReturnReadMdlToCMCompletion(NULL, NULL, pDelAlloc);

    	ASSERT(0);
        return;
	}

	// Set up the completion routine.
	IoSetCompletionRoutine(
            pIrp,
			(PIO_COMPLETION_ROUTINE)AfpReturnReadMdlToCMCompletion,
			pDelAlloc,
			True,
			True,
			True);

	pIrpSp = IoGetNextIrpStackLocation(pIrp);

	pIrp->Tail.Overlay.OriginalFileObject = AfpGetRealFileObject(pFileObject);
	pIrp->Tail.Overlay.Thread = AfpThread;
	pIrp->RequestorMode = KernelMode;

    pIrp->Flags = IRP_SYNCHRONOUS_API;

	pIrpSp->MajorFunction = IRP_MJ_READ;
	pIrpSp->MinorFunction = IRP_MN_MDL | IRP_MN_COMPLETE;
	pIrpSp->FileObject = AfpGetRealFileObject(pFileObject);
	pIrpSp->DeviceObject = pDeviceObject;

    pIrpSp->Parameters.Read.ByteOffset = LargeOffset;
    pIrpSp->Parameters.Read.Length = ReadSize;

    pIrp->MdlAddress = pMdl;

    AFP_DBG_SET_DELALLOC_IRP(pDelAlloc, pIrp);
    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_RETURN_IN_PROGRESS);

	IoCallDriver(pDeviceObject, pIrp);

}



NTSTATUS
AfpReturnReadMdlToCMCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
)
{
    PDELAYEDALLOC       pDelAlloc;
    PSDA                pSda;
    POPENFORKENTRY      pOpenForkEntry;
    NTSTATUS            status;


    pDelAlloc = (PDELAYEDALLOC)Context;

    ASSERT(pDelAlloc != NULL);

    pSda = pDelAlloc->pSda;
    pOpenForkEntry = pDelAlloc->pOpenForkEntry;

    ASSERT(VALID_SDA(pSda));
    ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

    if (pIrp)
    {
        status = pIrp->IoStatus.Status;

        if (!NT_SUCCESS(status))
        {
	        DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	            ("AfpReturnReadMdlToCMCompletion: irp failed %lx\n",status));

            ASSERT(0);
        }

        AfpFreeIrp(pIrp);
    }

    AfpForkDereference(pOpenForkEntry);

    AfpSdaDereferenceSession(pSda);

    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_RETURN_COMPLETED);
    AFP_DBG_DEC_DELALLOC_BYTECOUNT(AfpReadCMAlloced, pDelAlloc->BufSize);

    // don't need that memory no more
    AfpFreeDelAlloc(pDelAlloc);

    return(STATUS_MORE_PROCESSING_REQUIRED);

}


PDELAYEDALLOC FASTCALL
AfpAllocDelAlloc(
    IN VOID
)
{
    PDELAYEDALLOC   pDelAlloc;
    KIRQL           OldIrql;

    pDelAlloc = (PDELAYEDALLOC) AfpAllocZeroedNonPagedMemory(sizeof(DELAYEDALLOC));

#if DBG
    if (pDelAlloc)
    {
        pDelAlloc->Signature = AFP_DELALLOC_SIGNATURE;
        pDelAlloc->State = AFP_DBG_MDL_INIT;

        ACQUIRE_SPIN_LOCK(&AfpDebugSpinLock, &OldIrql);
        InsertTailList(&AfpDebugDelAllocHead, &pDelAlloc->Linkage);
        RELEASE_SPIN_LOCK(&AfpDebugSpinLock, OldIrql);
    }
#endif

    return(pDelAlloc);
}


VOID FASTCALL
AfpFreeDelAlloc(
    IN PDELAYEDALLOC    pDelAlloc
)
{
    KIRQL   OldIrql;

#if DBG

    ASSERT(pDelAlloc->Signature == AFP_DELALLOC_SIGNATURE);

    pDelAlloc->State |= AFP_DBG_MDL_END;

    ACQUIRE_SPIN_LOCK(&AfpDebugSpinLock, &OldIrql);
    RemoveEntryList(&pDelAlloc->Linkage);

    pDelAlloc->Linkage.Flink = (PLIST_ENTRY)0x11111111;
    pDelAlloc->Linkage.Blink = (PLIST_ENTRY)0x33333333;
    RELEASE_SPIN_LOCK(&AfpDebugSpinLock, OldIrql);
#endif

    AfpFreeMemory(pDelAlloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\client.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	client.h

Abstract:

	This module contains prototypes for client impersonation and Lsa support
	routines.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	08 Jul 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_CLIENT_
#define	_CLIENT_

extern
VOID
AfpImpersonateClient(
	IN	PSDA	pSda	OPTIONAL
);


extern
VOID
AfpRevertBack(
	VOID
);


extern
AFPSTATUS
AfpLogonUser(
	IN	PSDA			pSda,
	IN	PANSI_STRING	UserPasswd
);


extern
PBYTE
AfpGetChallenge(
	IN	VOID
);

#endif	// _CLIENT_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\client.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	client.c

Abstract:

	This module contains the client impersonation code.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	16 Jun 1992	 Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_CLIENT

#include <afp.h>
#include <client.h>
#include <access.h>
#include <secutil.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpImpersonateClient)
#pragma alloc_text( PAGE, AfpRevertBack)
#pragma alloc_text( PAGE, AfpGetChallenge)
#pragma alloc_text( PAGE, AfpLogonUser)
#endif



/***	AfpImpersonateClient
 *
 *  Impersonates the remote client. The token representing the remote client
 *  is available in the SDA. If the SDA is NULL (i.e. server context) then
 *  impersonate the token that we have created for ourselves.
 */
VOID
AfpImpersonateClient(
	IN	PSDA	pSda	OPTIONAL
)
{
	NTSTATUS	Status = STATUS_SUCCESS;
	HANDLE		Token;

	PAGED_CODE( );

	if (pSda != NULL)
	{
		Token = pSda->sda_UserToken;
	}
	else Token = AfpFspToken;

	ASSERT(Token != NULL);

	Status = NtSetInformationThread(NtCurrentThread(),
									ThreadImpersonationToken,
									(PVOID)&Token,
									sizeof(Token));
	ASSERT(NT_SUCCESS(Status));
}


/***	AfpRevertBack
 *
 *  Revert back to the default thread context.
 */
VOID
AfpRevertBack(
	VOID
)
{
	NTSTATUS	Status = STATUS_SUCCESS;
	HANDLE		Handle = NULL;

	PAGED_CODE( );

	Status = NtSetInformationThread(NtCurrentThread(),
									ThreadImpersonationToken,
									(PVOID)&Handle,
									sizeof(Handle));
	ASSERT(NT_SUCCESS(Status));
}


/***	AfpGetChallenge
 *
 *  Obtain a challenge token from the MSV1_0 package. This token is used by
 *  AfpLogin call.
 *
 *  The following function modified so that we generate the challenge ourselves
 *  instead of making a call.  This routine borrowed almost verbatim from
 *  the LM server code.
 */
PBYTE
AfpGetChallenge(
	IN	VOID
)
{
	PMSV1_0_LM20_CHALLENGE_REQUEST  ChallengeRequest;
	PMSV1_0_LM20_CHALLENGE_RESPONSE ChallengeResponse;
	ULONG							Length;
    PBYTE                           pRetBuf;
	NTSTATUS						Status, StatusX;
	union
	{
		LARGE_INTEGER	time;
		UCHAR	 		bytes[8];
	} u;

	ULONG seed;
	ULONG challenge[2];
	ULONG result3;

	PAGED_CODE( );

	ChallengeRequest = NULL;

	//
	// Create a pseudo-random 8-byte number by munging the system time
	// for use as a random number seed.
	//
	// Start by getting the system time.
	//

	ASSERT( MSV1_0_CHALLENGE_LENGTH == 2 * sizeof(ULONG) );

	KeQuerySystemTime( &u.time );

	//
	// To ensure that we don't use the same system time twice, add in the
	// count of the number of times this routine has been called.  Then
	// increment the counter.
	//
	// *** Since we don't use the low byte of the system time (it doesn't
	//     take on enough different values, because of the timer
	//     resolution), we increment the counter by 0x100.
	//
	// *** We don't interlock the counter because we don't really care
	//     if it's not 100% accurate.
	//

	u.time.LowPart += EncryptionKeyCount;

	EncryptionKeyCount += 0x100;

	//
	// Now use parts of the system time as a seed for the random
	// number generator.
	//
	// *** Because the middle two bytes of the low part of the system
	//     time change most rapidly, we use those in forming the seed.
	//

	seed = ((u.bytes[1] + 1) <<  0)	 |
			((u.bytes[2] + 0) <<  8) |
			((u.bytes[2] - 1) << 16) |
			((u.bytes[1] + 0) << 24);

	//
	// Now get two random numbers.  RtlRandom does not return negative
	// numbers, so we pseudo-randomly negate them.
	//

	challenge[0] = RtlRandom( &seed );
	challenge[1] = RtlRandom( &seed );
	result3 = RtlRandom( &seed );

	if ( (result3 & 0x1) != 0 )
	{
		challenge[0] |= 0x80000000;
	}
	if ( (result3 & 0x2) != 0 )
	{
		challenge[1] |= 0x80000000;
	}

	// Allocate a buffer to hold the challenge and copy it in
	if ((pRetBuf = AfpAllocNonPagedMemory(MSV1_0_CHALLENGE_LENGTH)) != NULL)
	{
		RtlCopyMemory(pRetBuf, challenge, MSV1_0_CHALLENGE_LENGTH);
	}

	return (pRetBuf);
}



/***	AfpLogonUser
 *
 *  Attempt to login the user. The password is either encrypted or cleartext
 *	based on the UAM used. The UserName and domain is extracted out of the Sda.
 *
 *  LOCKS:  AfpStatisticsLock (SPIN)
 */
AFPSTATUS
AfpLogonUser(
	IN	PSDA		pSda,
	IN	PANSI_STRING	UserPasswd
)
{
	NTSTATUS					Status, SubStatus;
	PUNICODE_STRING				WSName;
	ULONG						ulUnused;
	ULONG						NtlmInTokenSize;
	PNTLM_AUTHENTICATE_MESSAGE	NtlmInToken = NULL;
	PAUTHENTICATE_MESSAGE	  	InToken = NULL;
	ULONG					    InTokenSize;
	PNTLM_ACCEPT_RESPONSE		OutToken = NULL;
	ULONG						OutTokenSize;
	SIZE_T						AllocateSize;
	SecBufferDesc				InputToken;
	SecBuffer					InputBuffers[2];
	SecBufferDesc				OutputToken;
	SecBuffer					OutputBuffer;
	CtxtHandle					hNewContext;
	TimeStamp					Expiry;
	ULONG						BufferOffset;
	PCHAR						pTmp;
    PRAS_SUBAUTH_INFO           pRasSubAuthInfo;
    PARAP_SUBAUTH_REQ           pSfmSubAuthInfo;
    PARAP_SUBAUTH_RESP          pSfmResp;
    DWORD                       ResponseHigh;
    DWORD                       ResponseLow;
    DWORD                       dwTmpLen;


	PAGED_CODE( );

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

#ifdef OPTIMIZE_GUEST_LOGONS
	 // 11/28/94 SueA: Now that there is a License Service to track the number
	 // of sessions via LsaLogonUser, we can no longer fake the guest tokens.

	 // Optimization for subsequent guest logons
	 // After the first guest logon, we save the token and do not free it till the
	 // server stops. All subsequent guest logons 'share' that token.
	if (pSda->sda_ClientType == SDA_CLIENT_GUEST)
	{
		AfpSwmrAcquireExclusive(&AfpEtcMapLock);

		if (AfpGuestToken != NULL)
		{
		    pSda->sda_UserToken = AfpGuestToken;
		    pSda->sda_UserSid = &AfpSidWorld;
		    pSda->sda_GroupSid = &AfpSidWorld;	// Primary group of Guest is also 'World'
#ifdef	INHERIT_DIRECTORY_PERMS
		    pSda->sda_UID = AfpIdWorld;
		    pSda->sda_GID = AfpIdWorld;
#else
		    ASSERT (AfpGuestSecDesc != NULL);
		    pSda->sda_pSecDesc = AfpGuestSecDesc;
#endif
		    AfpSwmrRelease(&AfpEtcMapLock);
		    return AFP_ERR_NONE;
		}
		else
		{
		    AfpSwmrRelease(&AfpEtcMapLock);
		}
	}

#endif	// OPTIMIZE_GUEST_LOGONS


	WSName = &AfpDefaultWksta;
	if (pSda->sda_WSName.Length != 0)
		WSName = &pSda->sda_WSName;


	//
	// Figure out how big a buffer we need.  We put all the messages
	// in one buffer for efficiency's sake.
	//

	NtlmInTokenSize = sizeof(NTLM_AUTHENTICATE_MESSAGE);

    // alignment needs to be correct based on 32/64 bit addressing!!!
	NtlmInTokenSize = (NtlmInTokenSize + 7) & 0xfffffff8;

	InTokenSize = sizeof(AUTHENTICATE_MESSAGE) +
		          pSda->sda_UserName.Length +
		          WSName->Length +
                  (sizeof(RAS_SUBAUTH_INFO) + sizeof(ARAP_SUBAUTH_REQ)) +
		          pSda->sda_DomainName.Length +
		          UserPasswd->Length +
		          24;                    // extra for byte aligning

	InTokenSize = (InTokenSize + 7) & 0xfffffff8;

	OutTokenSize = sizeof(NTLM_ACCEPT_RESPONSE);
	OutTokenSize = (OutTokenSize + 7) & 0xfffffff8;

	//
	// Round this up to 8 byte boundary becaus the out token needs to be
	// quad word aligned for the LARGE_INTEGER.
	//
	AllocateSize = ((NtlmInTokenSize + InTokenSize + 7) & 0xfffffff8) + OutTokenSize;


	Status = NtAllocateVirtualMemory(NtCurrentProcess(),
									 &InToken,
									 0L,
									 &AllocateSize,
									 MEM_COMMIT,
									 PAGE_READWRITE);

	if (!NT_SUCCESS(Status))
	{
		AFPLOG_ERROR(AFPSRVMSG_PAGED_POOL, Status, &AllocateSize,sizeof(AllocateSize), NULL);
#if DBG
        DbgBreakPoint();
#endif
		return(AFP_ERR_MISC);
	}

	NtlmInToken = (PNTLM_AUTHENTICATE_MESSAGE) ((PUCHAR) InToken + InTokenSize);
    OutToken = (PNTLM_ACCEPT_RESPONSE) ((PUCHAR)NtlmInToken + ((NtlmInTokenSize + 7) & 0xfffffff8));

	RtlZeroMemory(InToken, InTokenSize + NtlmInTokenSize);

	//
	// set up the NtlmInToken first
	//

	if (pSda->sda_Challenge)
	{
		RtlCopyMemory(NtlmInToken->ChallengeToClient,
					  pSda->sda_Challenge,
					  MSV1_0_CHALLENGE_LENGTH );
	}

    if ((pSda->sda_ClientType == SDA_CLIENT_RANDNUM) ||
        (pSda->sda_ClientType == SDA_CLIENT_TWOWAY))
    {
	    NtlmInToken->ParameterControl = (MSV1_0_SUBAUTHENTICATION_DLL_RAS << 24);
    }
    else
    {
	    NtlmInToken->ParameterControl = 0;
    }

	//
	// Okay, now for the tought part - marshalling the AUTHENTICATE_MESSAGE
	//

	RtlCopyMemory(InToken->Signature,
				  NTLMSSP_SIGNATURE,
				  sizeof(NTLMSSP_SIGNATURE) );

	InToken->MessageType = NtLmAuthenticate;

	BufferOffset = sizeof(AUTHENTICATE_MESSAGE);

	//
	// LM password - case insensitive
	//

	pTmp = (PBYTE)InToken + BufferOffset;
	*(LPWSTR)pTmp = L'\0';

	InToken->LmChallengeResponse.Buffer = BufferOffset;
	InToken->LmChallengeResponse.Length = 1;
	InToken->LmChallengeResponse.MaximumLength = sizeof(WCHAR);

	InToken->NtChallengeResponse.Buffer = BufferOffset;
	InToken->NtChallengeResponse.Length = 0;
	InToken->NtChallengeResponse.MaximumLength = sizeof(WCHAR);

	InToken->DomainName.Buffer = BufferOffset;
	InToken->DomainName.Length = 0;
	InToken->DomainName.MaximumLength = sizeof(WCHAR);

	InToken->Workstation.Buffer = BufferOffset;
	InToken->Workstation.Length = 0;
	InToken->Workstation.MaximumLength = sizeof(WCHAR);

	InToken->UserName.Buffer = BufferOffset;
	InToken->UserName.Length = 0;
	InToken->UserName.MaximumLength = sizeof(WCHAR);


	if (pSda->sda_UserName.Length != 0)
	{

		if (pSda->sda_DomainName.Length != 0)
		{

			InToken->DomainName.Length = pSda->sda_DomainName.Length;
			InToken->DomainName.MaximumLength = pSda->sda_DomainName.MaximumLength;

			InToken->DomainName.Buffer = BufferOffset;
			RtlCopyMemory((PBYTE)InToken + BufferOffset,
			              (PBYTE)pSda->sda_DomainName.Buffer,
			              pSda->sda_DomainName.Length);
			BufferOffset += pSda->sda_DomainName.Length;
			BufferOffset = (BufferOffset + 3) & 0xfffffffc;	// dword align it
		}


		InToken->LmChallengeResponse.Buffer = BufferOffset;

        //
        // is he using native Apple UAM? setup buffers differently!
        //
        if ((pSda->sda_ClientType == SDA_CLIENT_RANDNUM) ||
            (pSda->sda_ClientType == SDA_CLIENT_TWOWAY))
        {
            pRasSubAuthInfo =
                (PRAS_SUBAUTH_INFO)((PBYTE)InToken + BufferOffset);

            pRasSubAuthInfo->ProtocolType = RAS_SUBAUTH_PROTO_ARAP;
            pRasSubAuthInfo->DataSize = sizeof(ARAP_SUBAUTH_REQ);

            pSfmSubAuthInfo = (PARAP_SUBAUTH_REQ)&pRasSubAuthInfo->Data[0];

            if (pSda->sda_ClientType == SDA_CLIENT_RANDNUM)
            {
                pSfmSubAuthInfo->PacketType = SFM_SUBAUTH_LOGON_PKT;
            }
            else
            {
                pSfmSubAuthInfo->PacketType = SFM_2WAY_SUBAUTH_LOGON_PKT;
            }

            pSfmSubAuthInfo->Logon.fGuestLogon = FALSE;

	        ASSERT(pSda->sda_Challenge != NULL);

            // put the 2 dwords of challenge that we gave the Mac
            pTmp = pSda->sda_Challenge;
            GETDWORD2DWORD_NOCONV((PBYTE)&pSfmSubAuthInfo->Logon.NTChallenge1,pTmp);

            pTmp += sizeof(DWORD);
            GETDWORD2DWORD_NOCONV((PBYTE)&pSfmSubAuthInfo->Logon.NTChallenge2,pTmp);

            // put the 2 dwords of response that the Mac gave us
            pTmp = UserPasswd->Buffer;
            GETDWORD2DWORD_NOCONV((PBYTE)&pSfmSubAuthInfo->Logon.MacResponse1,pTmp);

            pTmp += sizeof(DWORD);
            GETDWORD2DWORD_NOCONV((PBYTE)&pSfmSubAuthInfo->Logon.MacResponse2,pTmp);

            // 2-way guy sends his own challenge: doesn't trust us!
            if (pSda->sda_ClientType == SDA_CLIENT_TWOWAY)
            {
                pTmp += sizeof(DWORD);
                GETDWORD2DWORD_NOCONV((PBYTE)&pSfmSubAuthInfo->Logon.MacChallenge1,pTmp);

                pTmp += sizeof(DWORD);
                GETDWORD2DWORD_NOCONV((PBYTE)&pSfmSubAuthInfo->Logon.MacChallenge2,pTmp);
            }

            dwTmpLen = (sizeof(RAS_SUBAUTH_INFO) + sizeof(ARAP_SUBAUTH_REQ));
		    InToken->LmChallengeResponse.Length = (USHORT)dwTmpLen;
		    InToken->LmChallengeResponse.MaximumLength = (USHORT)dwTmpLen;

            BufferOffset += dwTmpLen;
        }

        //
        // this client is using MS-UAM or Apple's cleartext
        //
        else
        {
		    InToken->LmChallengeResponse.Length = UserPasswd->Length;
		    InToken->LmChallengeResponse.MaximumLength = UserPasswd->MaximumLength;

		    RtlCopyMemory( (PBYTE)InToken + BufferOffset,
                            UserPasswd->Buffer,
                            UserPasswd->Length );

		    BufferOffset += UserPasswd->Length;
        }


		BufferOffset = (BufferOffset + 3) & 0xfffffffc;		// dword align it

		//
		// Workstation Name
		//

		InToken->Workstation.Buffer = BufferOffset;
		InToken->Workstation.Length = WSName->Length;
		InToken->Workstation.MaximumLength = WSName->MaximumLength;

		RtlCopyMemory((PBYTE)InToken + BufferOffset,
					  WSName->Buffer,
					  WSName->Length);

		BufferOffset += WSName->Length;
		BufferOffset = (BufferOffset + 3) & 0xfffffffc;		// dword align it

		//
		// User Name
		//

		InToken->UserName.Buffer = BufferOffset;
		InToken->UserName.Length = pSda->sda_UserName.Length;
		InToken->UserName.MaximumLength = pSda->sda_UserName.MaximumLength;

		RtlCopyMemory((PBYTE)InToken + BufferOffset,
					  pSda->sda_UserName.Buffer,
					  pSda->sda_UserName.Length);

		BufferOffset += pSda->sda_UserName.Length;
	}


	InputToken.pBuffers = InputBuffers;
	InputToken.cBuffers = 2;
	InputToken.ulVersion = 0;
	InputBuffers[0].pvBuffer = InToken;
	InputBuffers[0].cbBuffer = InTokenSize;
	InputBuffers[0].BufferType = SECBUFFER_TOKEN;
	InputBuffers[1].pvBuffer = NtlmInToken;
	InputBuffers[1].cbBuffer = NtlmInTokenSize;
	InputBuffers[1].BufferType = SECBUFFER_TOKEN;

	OutputToken.pBuffers = &OutputBuffer;
	OutputToken.cBuffers = 1;
	OutputToken.ulVersion = 0;
	OutputBuffer.pvBuffer = OutToken;
	OutputBuffer.cbBuffer = OutTokenSize;
	OutputBuffer.BufferType = SECBUFFER_TOKEN;

	Status = AcceptSecurityContext(&AfpSecHandle,
								   NULL,
								   &InputToken,
								   ASC_REQ_LICENSING,
								   SECURITY_NATIVE_DREP,
								   &hNewContext,
								   &OutputToken,
								   &ulUnused,
								   &Expiry );

	if (NT_SUCCESS(Status))
	{
		AFPTIME	    CurrentTime;
        NTSTATUS    SecStatus;

		if (pSda->sda_ClientType != SDA_CLIENT_GUEST)
		{
            SecPkgContext_PasswordExpiry PasswordExpires;


			// Get the kickoff time from the profile buffer. Round this to
			// even # of SESSION_CHECK_TIME units

            SecStatus = QueryContextAttributes(
                                &hNewContext,
                                SECPKG_ATTR_PASSWORD_EXPIRY,
                                &PasswordExpires
                                );

            if( SecStatus == NO_ERROR )
            {
			    AfpGetCurrentTimeInMacFormat(&CurrentTime);

			    pSda->sda_tTillKickOff = (DWORD)
                        ( AfpConvertTimeToMacFormat(&PasswordExpires.tsPasswordExpires) -
                          CurrentTime );

			    pSda->sda_tTillKickOff -= pSda->sda_tTillKickOff % SESSION_CHECK_TIME;
            }
            else
            {
                DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
	                ("AfpLogonUser: QueryContextAttributes failed %lx\n",SecStatus));
            }
		}

        // return stuff from subauth
        pSfmResp = (PARAP_SUBAUTH_RESP)&OutToken->UserSessionKey[0];

        ResponseHigh = pSfmResp->Response.high;
        ResponseLow  = pSfmResp->Response.low;

		SubStatus = NtFreeVirtualMemory(NtCurrentProcess( ),
										(PVOID *)&InToken,
										&AllocateSize,
										MEM_RELEASE);
		ASSERT(NT_SUCCESS(SubStatus));

        //
        // 2-Way authentication? client expects us to send a response to
        // the challenge that it sent
        //
        if (pSda->sda_ClientType == SDA_CLIENT_TWOWAY)
        {
			pSda->sda_ReplySize = RANDNUM_RESP_LEN;

			if (AfpAllocReplyBuf(pSda) != AFP_ERR_NONE)
            {
                return(AFP_ERR_USER_NOT_AUTH);
            }

            pTmp = pSda->sda_ReplyBuf;
            PUTBYTE42BYTE4(pTmp, (PBYTE)&ResponseHigh);

            pTmp += sizeof(DWORD);
            PUTBYTE42BYTE4(pTmp, (PBYTE)&ResponseLow);
        }

        else if (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V2)
        {
			pSda->sda_ReplySize = sizeof(DWORD);

			if (AfpAllocReplyBuf(pSda) != AFP_ERR_NONE)
            {
                return(AFP_ERR_USER_NOT_AUTH);
            }

            pTmp = pSda->sda_ReplyBuf;
            PUTBYTE42BYTE4(pTmp, (PBYTE)&pSda->sda_tTillKickOff);
        }

	}

	else  // if (NT_SUCCESS(Status) != NO_ERROR)
	{
		NTSTATUS	ExtErrCode = Status;

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
				 ("AfpLogonUser: AcceptSecurityContext() failed with %X\n", Status));

		SubStatus = NtFreeVirtualMemory(NtCurrentProcess(),
										(PVOID *)&InToken,
										&AllocateSize,
										MEM_RELEASE );
		ASSERT(NT_SUCCESS(SubStatus));

		// Set extended error codes here if using custom UAM or AFP 2.1
		Status = AFP_ERR_USER_NOT_AUTH;	// default

		// The mac will map this to a session error dialog for each UAM.
		// The dialog may be a little different for different versions of
		// the mac OS and each UAM, but will always have something to do
		// with getting the message across about no more sessions available.

		if (ExtErrCode == STATUS_LICENSE_QUOTA_EXCEEDED)
		{
		    DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
				 ("AfpLogonUser: License Quota Exceeded: returning ASP_SERVER_BUSY\n"));
			return (ASP_SERVER_BUSY);
		}

		if ((pSda->sda_ClientVersion >= AFP_VER_21) &&
			(pSda->sda_ClientType != SDA_CLIENT_MSUAM_V2) &&
            (pSda->sda_ClientType != SDA_CLIENT_MSUAM_V2))
		{
			if ((ExtErrCode == STATUS_PASSWORD_EXPIRED) ||
				(ExtErrCode == STATUS_PASSWORD_MUST_CHANGE))
				Status = AFP_ERR_PWD_EXPIRED;
		}
		else if ((pSda->sda_ClientType == SDA_CLIENT_MSUAM_V1) ||
                 (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V2))
		{
			if ((ExtErrCode == STATUS_PASSWORD_EXPIRED) ||
				(ExtErrCode == STATUS_PASSWORD_MUST_CHANGE))
				Status = AFP_ERR_PASSWORD_EXPIRED;
			else if ((ExtErrCode == STATUS_ACCOUNT_DISABLED) ||
					 (ExtErrCode == STATUS_ACCOUNT_LOCKED_OUT))
				Status = AFP_ERR_ACCOUNT_DISABLED;
			else if (ExtErrCode == STATUS_INVALID_LOGON_HOURS)
				Status = AFP_ERR_INVALID_LOGON_HOURS;
			else if (ExtErrCode == STATUS_INVALID_WORKSTATION)
				Status = AFP_ERR_INVALID_WORKSTATION;
		}

		return( Status );
	}

	//
	// get the token out using the context
	//
	Status = QuerySecurityContextToken( &hNewContext, &pSda->sda_UserToken );
	if (!NT_SUCCESS(Status))
	{
		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
				 ("AfpLogonUser: QuerySecurityContextToken() failed with %X\n", Status));
		pSda->sda_UserToken = NULL;			 // just paranoia
		return(Status);
	}

	Status = DeleteSecurityContext( &hNewContext );
	if (!NT_SUCCESS(Status))
	{
		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
				("AfpLogonUser: DeleteSecurityContext() failed with %X\n", Status));
	}

	Status = AfpGetUserAndPrimaryGroupSids(pSda);
	if (!NT_SUCCESS(Status))
	{
		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
				("AfpLogonUser: AfpGetUserAndPrimaryGroupSids() failed with %X\n", Status));
		AFPLOG_ERROR(AFPSRVMSG_LOGON, Status, NULL, 0, NULL);
		return( Status );
	}

#ifdef	INHERIT_DIRECTORY_PERMS
	// Convert the user and group sids to IDs
	AfpSidToMacId(pSda->sda_UserSid, &pSda->sda_UID);

	AfpSidToMacId(pSda->sda_GroupSid, &pSda->sda_GID);
#else
	// Make a security descriptor for user
	Status = AfpMakeSecurityDescriptorForUser(pSda->sda_UserSid,
											  pSda->sda_GroupSid,
											  &pSda->sda_pSecDesc);
#endif

#ifdef	OPTIMIZE_GUEST_LOGONS
	if (pSda->sda_ClientType == SDA_CLIENT_GUEST)
	{
		// Save the guest login token and security descriptor
		AfpSwmrAcquireExclusive(&AfpEtcMapLock);
		AfpGuestToken = pSda->sda_UserToken;

#ifdef	INHERIT_DIRECTORY_PERMS
		AfpSidToMacId(&AfpSidWorld, &AfpIdWorld);
#else
		AfpGuestSecDesc = pSda->sda_pSecDesc;
#endif
		AfpSwmrRelease(&AfpEtcMapLock);
	}
#endif	// OPTIMIZE_GUEST_LOGONS

	return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\desktop.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	desktop.h

Abstract:

	This module contains the desktop database structures.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _DESKTOP_
#define _DESKTOP_

#define AFP_DESKTOP_VERSION1	0x00010000
#define AFP_DESKTOP_VERSION2	0x00020000
#define AFP_DESKTOP_VERSION		AFP_DESKTOP_VERSION2

typedef struct _ApplInfo
{
	struct _ApplInfo * appl_Next;		// link to next entry for this hash
	DWORD	appl_Creator;				// Creator
	DWORD	appl_FileNum;				// File Number of the application file
	DWORD	appl_Tag;					// APPL Tag
} APPLINFO, *PAPPLINFO;

// NOTE: the first 4 fields of _ApplInfo2 must be exactly the same as
// _ApplInfo so that version 1 desktop APPLs can be read into the version 2
// structure.
typedef struct _ApplInfo2
{
	struct _ApplInfo2 * appl_Next;		// link to next entry for this hash
	DWORD	appl_Creator;				// Creator
	DWORD	appl_FileNum;				// File Number of the application file
	DWORD	appl_Tag;					// APPL Tag
	DWORD	appl_ParentID;				// DirId of parent of the app file
} APPLINFO2, *PAPPLINFO2;

typedef struct _IconInfo
{
	struct _IconInfo * icon_Next;		// Link to Next entry for this hash
	DWORD	icon_Creator;				// Creator
	DWORD	icon_Type;					// Finder Type
	DWORD	icon_Tag;					// ICON Tag
	USHORT	icon_IconType;				// Icon type
	SHORT	icon_Size;					// Size of Icon
	// Icon bitmap follows the structure
} ICONINFO, *PICONINFO;


typedef struct _Desktop
{
	DWORD		dtp_Signature;				// Signature
	DWORD		dtp_Version;				// Version number
	LONG		dtp_cApplEnts;				// Number of APPL entries
	PAPPLINFO	dtp_pApplInfo;				// Pointer to 1st APPL entry
											// Used only on disk
	LONG		dtp_cIconEnts;				// Number of ICON entries
	PICONINFO	dtp_pIconInfo;				// Pointer to 1st ICON entry
											// Used only on disk
} DESKTOP, *PDESKTOP;

#define	DESKTOPIO_BUFSIZE			8180	// 8192 - 12
#define	HASH_ICON(Creator)			((Creator) % ICON_BUCKETS)
#define	HASH_APPL(Creator)			((Creator) % APPL_BUCKETS)


GLOBAL	SWMR					AfpIconListLock EQU { 0 };
GLOBAL	PICONINFO				AfpGlobalIconList EQU NULL;

extern
NTSTATUS
AfpDesktopInit(
	VOID
);

extern
AFPSTATUS
AfpAddIcon(
	IN	struct _VolDesc *		pVolDesc,
	IN	DWORD					Creator,
	IN	DWORD					Type,
	IN	DWORD					Tag,
	IN	LONG					IconSize,
	IN	DWORD					IconType,
	IN	PBYTE					pIconBitmap
);

extern
AFPSTATUS
AfpLookupIcon(
	IN	struct _VolDesc *		pVolDesc,
	IN	DWORD					Creator,
	IN	DWORD					Type,
	IN	LONG					Length,
	IN	DWORD					IconType,
    OUT PLONG                   pActualLength,
	OUT PBYTE					pIconBitMap
);

extern
AFPSTATUS
AfpLookupIconInfo(
	IN	struct _VolDesc *		pVolDesc,
	IN	DWORD					Creator,
	IN	LONG					Index,
	OUT PDWORD					pType,
	OUT PDWORD	 				pIconType,
	OUT PDWORD					pTag,
	OUT PLONG					pSize
);

extern
AFPSTATUS
AfpAddAppl(
	IN	struct _VolDesc *		pVolDesc,
	IN	DWORD					Creator,
	IN	DWORD					ApplTag,
	IN	DWORD					FileNum,
	IN	BOOLEAN					Internal,
	IN	DWORD					ParentID
);

extern
AFPSTATUS
AfpLookupAppl(
	IN	struct _VolDesc *		pVolDesc,
	IN	DWORD					Creator,
	IN	LONG					Index,
	OUT PDWORD					pApplTag,
	OUT PDWORD					pFileNum,
	OUT	PDWORD					pParentID
);

extern
AFPSTATUS
AfpRemoveAppl(
	IN	struct _VolDesc *		pVolDesc,
	IN	DWORD					Creator,
	IN	DWORD					FileNum
);

extern
AFPSTATUS
AfpAddComment(
	IN	PSDA					pSda,
	IN	struct _VolDesc *		pVolDesc,
	IN	PANSI_STRING			Comment,
	IN	struct _PathMapEntity *	PME,
	IN	BOOLEAN					Directory,
	IN	DWORD					AfpId
);

extern
AFPSTATUS
AfpGetComment(
	IN	PSDA					pSda,
	IN	struct _VolDesc *		pVolDesc,
	IN	struct _PathMapEntity *	PME,
	IN	BOOLEAN					Directory
);

extern
AFPSTATUS
AfpRemoveComment(
	IN	PSDA					pSda,
	IN	struct _VolDesc *		pVolDesc,
	IN	struct _PathMapEntity *	PME,
	IN	BOOLEAN					Directory,
	IN	DWORD					AfpId
);

extern
AFPSTATUS
AfpAddIconToGlobalList(
	IN	DWORD					Type,
	IN	DWORD					Creator,
	IN	DWORD					IconType,
	IN	LONG					IconSize,
	IN	PBYTE					pIconBitMap
);

extern
VOID
AfpFreeGlobalIconList(
	VOID
);

extern
AFPSTATUS
AfpInitDesktop(
	IN	struct _VolDesc *		pVolDesc,
    OUT BOOLEAN         *       pfNewVolume
);


extern
VOID
AfpUpdateDesktop(
	IN	struct _VolDesc *		pVolDesc
);

extern
VOID
AfpFreeDesktopTables(
	IN	struct _VolDesc *		pVolDesc
);


#ifdef	DESKTOP_LOCALS

#define	ALLOC_ICONINFO(IconLen)	(PICONINFO)AfpAllocPagedMemory((IconLen) + sizeof(ICONINFO))

#define	ALLOC_APPLINFO()		(PAPPLINFO2)AfpAllocPagedMemory(sizeof(APPLINFO2))

LOCAL AFPSTATUS
afpGetGlobalIconInfo(
	IN	DWORD					Creator,
	OUT PDWORD					pType,
	OUT PDWORD					pIconType,
	OUT PDWORD					pTag,
	OUT PLONG					pSize
);

LOCAL AFPSTATUS
afpLookupIconInGlobalList(
	IN	DWORD					Creator,
	IN	DWORD					Type,
	IN	DWORD					IconType,
	IN	PLONG					pSize,
	OUT PBYTE					pBitMap
);

LOCAL NTSTATUS
afpReadDesktopFromDisk(
	IN	struct _VolDesc *			pVolDesc,
	IN	struct _FileSysHandle *		pfshDesktop
);

#endif	// DESKTOP_LOCALS

#endif	// _DESKTOP_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\desktop.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	desktop.c

Abstract:

	This module contains the routines for manipulating the desktop database.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_DESKTOP
#define	DESKTOP_LOCALS

#include <afp.h>
#include <scavengr.h>
#include <fdparm.h>
#include <pathmap.h>
#include <client.h>


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfpDesktopInit)
#pragma alloc_text( PAGE, AfpAddIcon)
#pragma alloc_text( PAGE, AfpLookupIcon)
#pragma alloc_text( PAGE, AfpLookupIconInfo)
#pragma alloc_text( PAGE, AfpAddAppl)
#pragma alloc_text( PAGE, AfpLookupAppl)
#pragma alloc_text( PAGE, AfpRemoveAppl)
#pragma alloc_text( PAGE, AfpAddComment)
#pragma alloc_text( PAGE, AfpGetComment)
#pragma alloc_text( PAGE, AfpRemoveComment)
#pragma alloc_text( PAGE, AfpAddIconToGlobalList)
#pragma alloc_text( PAGE, afpLookupIconInGlobalList)
#pragma alloc_text( PAGE, AfpFreeGlobalIconList)
#pragma alloc_text( PAGE, afpGetGlobalIconInfo)
#pragma alloc_text( PAGE, afpReadDesktopFromDisk)
#pragma alloc_text( PAGE, AfpInitDesktop)
#pragma alloc_text( PAGE, AfpUpdateDesktop)
#pragma alloc_text( PAGE, AfpFreeDesktopTables)
#endif

/***	AfpDesktopInit
 *
 *	Initialize locks for global icons.
 */
NTSTATUS
AfpDesktopInit(
	VOID
)
{
	AfpSwmrInitSwmr(&AfpIconListLock);

	return STATUS_SUCCESS;
}


/***	AfpAddIcon
 *
 * Add an icon to the desktop database. The icon is added in such a way that
 * the list is maintained in a sorted fashion - sorted by Creator, Type and
 * IconType
 *
 *	LOCKS:	vds_DtAccessLock (SWMR, Exclusive);
 */
AFPSTATUS
AfpAddIcon(
	IN  PVOLDESC	pVolDesc,		// Volume descriptor of referenced desktop
	IN	DWORD		Creator,
	IN	DWORD		Type,
	IN	DWORD		Tag,
	IN	LONG		IconSize,
	IN	DWORD		IconType,
	IN  PBYTE		pIcon			// The icon bitmap
)
{
	PICONINFO	pIconInfo;
	PICONINFO *	ppIconInfo;
	BOOLEAN		Found = False;
	AFPSTATUS	Status = AFP_ERR_NONE;

	PAGED_CODE( );

	AfpSwmrAcquireExclusive(&pVolDesc->vds_DtAccessLock);
	ppIconInfo = &pVolDesc->vds_pIconBuckets[HASH_ICON(Creator)];
	do
	{
		// Find the right slot
		for (;(pIconInfo = *ppIconInfo) != NULL;
			  ppIconInfo = &pIconInfo->icon_Next)
		{
			if (pIconInfo->icon_Creator < Creator)
				continue;
			if (pIconInfo->icon_Creator > Creator)
				break;
			if (pIconInfo->icon_Type < Type)
				continue;
			if (pIconInfo->icon_Type > Type)
				break;
			if (pIconInfo->icon_IconType < (USHORT)IconType)
				continue;
			if (pIconInfo->icon_IconType > (USHORT)IconType)
				break;
			/*
			 * If we come this far, we have hit the bulls eye
			 * Make sure the size matches, before we commit
			 */
			if (pIconInfo->icon_Size != IconSize)
			{
				Status = AFP_ERR_ICON_TYPE;
				break;
			}
			Found = True;
			break;
		}

		if (!Found && (Status == AFP_ERR_NONE))
		{
			// ppIconInfo now points to the right place
			if ((pIconInfo = ALLOC_ICONINFO(IconSize)) != NULL)
			{
				pIconInfo->icon_Next = *ppIconInfo;
				*ppIconInfo = pIconInfo;
				pIconInfo->icon_Creator = Creator;
				pIconInfo->icon_Type = Type;
				pIconInfo->icon_IconType = (USHORT)IconType;
				pIconInfo->icon_Size = (SHORT)IconSize;
				pIconInfo->icon_Tag = Tag;
				pVolDesc->vds_cIconEnts ++;
				Found = True;
			}
			else Status = AFP_ERR_MISC;
		}
		if (Found && (Status == AFP_ERR_NONE))
		{
			RtlCopyMemory((PBYTE)pIconInfo + sizeof(ICONINFO), pIcon, IconSize);
		}
	} while (False);
	AfpSwmrRelease(&pVolDesc->vds_DtAccessLock);
	return Status;
}


/***	AfpLookupIcon
 *
 * Search the desktop for an icon matching the given search parameters.
 *
 *	LOCKS:	vds_DtAccessLock (SWMR, Shared), AfpIconListLock (SWMR, Shared)
 */
AFPSTATUS
AfpLookupIcon(
	IN  PVOLDESC	pVolDesc,		// Volume descriptor of referenced desktop
	IN	DWORD		Creator,
	IN	DWORD		Type,
	IN	LONG		Length,
	IN	DWORD		IconType,
    OUT PLONG       pActualLength,
	OUT PBYTE		pIconBitMap	// Buffer for icon bit map
)
{
	PICONINFO	pIconInfo;
    LONG        LengthToCopy;
	AFPSTATUS	Status = AFP_ERR_NONE;

	PAGED_CODE( );

    LengthToCopy = Length;

	AfpSwmrAcquireShared(&pVolDesc->vds_DtAccessLock);
	pIconInfo = pVolDesc->vds_pIconBuckets[HASH_ICON(Creator)];

	// Scan the list looking for the entry
	for (;pIconInfo != NULL; pIconInfo = pIconInfo->icon_Next)
	{
		if (pIconInfo->icon_Creator < Creator)
			continue;
		if (pIconInfo->icon_Creator > Creator)
		{
			pIconInfo = NULL;
			break;
		}
		if (pIconInfo->icon_Type < Type)
			continue;
		if (pIconInfo->icon_Type > Type)
		{
			pIconInfo = NULL;
			break;
		}
		if (pIconInfo->icon_IconType < (USHORT)IconType)
			continue;
		if (pIconInfo->icon_IconType > (USHORT)IconType)
		{
			pIconInfo = NULL;
			break;
		}
		break;
	}
	// If we did not find it, try the global list
	if (pIconInfo == NULL)
	{
		Status = afpLookupIconInGlobalList(Creator,
										   Type,
										   IconType,
										   &LengthToCopy,
										   pIconBitMap);
	}
	else if (Length > 0)
	{
        if ((LONG)(pIconInfo->icon_Size) < Length)
        {
            LengthToCopy = (LONG)(pIconInfo->icon_Size);
        }
        else
        {
            LengthToCopy = Length;
        }
		RtlCopyMemory(pIconBitMap, (PBYTE)pIconInfo + sizeof(ICONINFO), LengthToCopy);
	}

	AfpSwmrRelease(&pVolDesc->vds_DtAccessLock);

    *pActualLength = LengthToCopy;
	return Status;
}


/***	AfpLookupIconInfo
 *
 *	Search the desktop for an icon matching the given Creator. In case of
 *	multiple icons corresponding to the same creator, get the nth where n
 *	is the index.
 *
 *	LOCKS:	vds_DtAccessLock (SWMR, Shared), AfpIconListLock (SWMR, Shared)
 */
AFPSTATUS
AfpLookupIconInfo(
	IN  PVOLDESC	pVolDesc,	// Volume descriptor of referenced desktop
	IN	DWORD		Creator,	// Creator associated with the icon
	IN  LONG		Index,		// Index number of Icon
	OUT PDWORD		pType,		// Place where Type is returned
	OUT PDWORD	 	pIconType,	// Icon type e.g. ICN#
	OUT PDWORD		pTag,		// Arbitrary tag
	OUT PLONG		pSize		// Size of the icon
)
{
	PICONINFO	pIconInfo;
	LONG		i;
	AFPSTATUS	Status = AFP_ERR_ITEM_NOT_FOUND;

	PAGED_CODE( );

	AfpSwmrAcquireShared(&pVolDesc->vds_DtAccessLock);
	pIconInfo = pVolDesc->vds_pIconBuckets[HASH_ICON(Creator)];

	// Scan the list looking for the first entry
	for (;pIconInfo != NULL; pIconInfo = pIconInfo->icon_Next)
	{
		if (pIconInfo->icon_Creator == Creator)
			break;				// Found the first one
		if (pIconInfo->icon_Creator > Creator)
		{
			pIconInfo = NULL;
			break;
		}
	}

	/*
	 * We are now either pointing to the first entry or there are none. In the
	 * latter case, we just fall through
	 */
	for (i = 1; pIconInfo != NULL; pIconInfo = pIconInfo->icon_Next)
	{
		if ((pIconInfo->icon_Creator > Creator) || (i > Index))
		{
			pIconInfo = NULL;
			break;
		}

		if (i == Index)
			break;				// Found the right entry
		i++;
	}

	// If we did find it, extract the information
	if (pIconInfo != NULL)
	{
		*pSize = pIconInfo->icon_Size;
		*pType = pIconInfo->icon_Type;
		*pTag = pIconInfo->icon_Tag;
		*pIconType = pIconInfo->icon_IconType;
		Status = AFP_ERR_NONE;
	}

	// If we did not find it, try the global list, but only for the first one
	else if (Index == 1)
	{
		Status = afpGetGlobalIconInfo(Creator, pType, pIconType, pTag, pSize);
	}
	else Status = AFP_ERR_ITEM_NOT_FOUND;

	AfpSwmrRelease(&pVolDesc->vds_DtAccessLock);
	return Status;
}


/***	AfpAddAppl
 *
 *	Add an APPL mapping to the desktop database. Is added in such a way that
 *	the list is maintained in a sorted fashion - sorted by Creator. It is
 *	already determined that the application file exists and that the user has
 *	appropriate access to it.
 *
 *	LOCKS:	vds_DtAccessLock (SWMR, Exclusive);
 */
AFPSTATUS
AfpAddAppl(
	IN  PVOLDESC	pVolDesc,	// Volume descriptor of referenced desktop
	IN	DWORD		Creator,
	IN	DWORD		ApplTag,
	IN  DWORD		FileNum,	// File number of the associated file
	IN	BOOLEAN		Internal,	// Is the server adding the APPL itself?
	IN	DWORD		ParentID	// DirId of parent dir of the application file
)
{
	PAPPLINFO2	pApplInfo, *ppApplInfo;
	BOOLEAN		ApplReplace = False, UpdateDT = True;
	AFPSTATUS	Status = AFP_ERR_NONE;


	PAGED_CODE( );

	ASSERT(FileNum != 0);

	AfpSwmrAcquireExclusive(&pVolDesc->vds_DtAccessLock);

	ppApplInfo = &pVolDesc->vds_pApplBuckets[HASH_APPL(Creator)];

	// Find the right slot
	for (;(pApplInfo = *ppApplInfo) != NULL; ppApplInfo = &pApplInfo->appl_Next)
	{
		if (pApplInfo->appl_Creator >= Creator)
			break;
	}

	/*
	 * If there is already an entry for this creator, make sure it is not for
	 * the same file, if it is replace it.
	 */
	for ( ; pApplInfo != NULL && pApplInfo->appl_Creator == Creator;
			pApplInfo = pApplInfo->appl_Next)
	{
		if (pApplInfo->appl_FileNum == FileNum)
		{
			if (!Internal)
			{
				pApplInfo->appl_Tag = ApplTag;
			}
			else	
			{
				if (pApplInfo->appl_ParentID == ParentID)
					UpdateDT = False;
			}

			pApplInfo->appl_ParentID = ParentID;
			ApplReplace = True;
		}
	}

	if (!ApplReplace)
	{
		// ppApplInfo now points to the right place
		if ((pApplInfo = ALLOC_APPLINFO()) != NULL)
		{
			pApplInfo->appl_Next = *ppApplInfo;
			*ppApplInfo = pApplInfo;
			pApplInfo->appl_Creator = Creator;
			pApplInfo->appl_Tag = ApplTag;
			pApplInfo->appl_FileNum = FileNum;
			pApplInfo->appl_ParentID = ParentID;
			pVolDesc->vds_cApplEnts ++;
		}
		else Status = AFP_ERR_MISC;
	}

	AfpSwmrRelease(&pVolDesc->vds_DtAccessLock);

	return Status;
}


/***	AfpLookupAppl
 *
 *	Search the desktop for an appl entry matching the given Creator. In
 *	case of multiple appl entries corresponding to the same creator, get
 *	the nth where n is the index.
 *
 *	LOCKS:	vds_DtAccessLock (SWMR, Shared);
 */
AFPSTATUS
AfpLookupAppl(
	IN  PVOLDESC 	pVolDesc,	// Volume descriptor of referenced desktop
	IN	DWORD		Creator,
	IN	LONG		Index,
	OUT PDWORD 		pApplTag,	// Place holder for Tag
	OUT PDWORD		pFileNum, 	// Place holder for file number
	OUT	PDWORD		pParentID	
)
{
	PAPPLINFO2	pApplInfo;
	AFPSTATUS	Status = AFP_ERR_NONE;
	LONG		i;

	PAGED_CODE( );

	AfpSwmrAcquireShared(&pVolDesc->vds_DtAccessLock);
	pApplInfo = pVolDesc->vds_pApplBuckets[HASH_ICON(Creator)];

	// Scan the list looking for the entry
	for (;pApplInfo != NULL; pApplInfo = pApplInfo->appl_Next)
	{
		if (pApplInfo->appl_Creator == Creator)
			break;
		if (pApplInfo->appl_Creator > Creator) {
			pApplInfo = NULL;
			break;
		}
	}
	/*
	 * We are now either pointing to the first entry or there are none. In the
	 * latter case, we just fall through
	 */
	if (Index != 0)
	{
		for (i = 1; pApplInfo!=NULL; i++, pApplInfo = pApplInfo->appl_Next)
		{
			if ((i > Index)	|| (pApplInfo->appl_Creator != Creator))
			{
				pApplInfo = NULL;
				break;
			}
			if (i == Index)
				break;				// Found the right entry
		}
	}
	if (pApplInfo == NULL)
		Status = AFP_ERR_ITEM_NOT_FOUND;
	else
	{
		*pFileNum = pApplInfo->appl_FileNum;
		*pApplTag = pApplInfo->appl_Tag;
		*pParentID = pApplInfo->appl_ParentID;
	}
	AfpSwmrRelease(&pVolDesc->vds_DtAccessLock);
	return Status;
}


/***	AfpRemoveAppl
 *
 *	The entries corresponding to the given Creator in the specified directory
 *	is removed from the desktop database. It is already determined that the
 *	application file exists and that the user has appropriate access to it.
 *
 *	LOCKS:	vds_DtAccessLock (SWMR, Exclusive);
 */
AFPSTATUS
AfpRemoveAppl(
	IN  PVOLDESC 	pVolDesc,		// Open Volume descriptor of ref desktop
	IN	DWORD		Creator,
	IN  DWORD		FileNum			// File number of the associated file
)
{
	PAPPLINFO2	pApplInfo, *ppApplInfo;
	AFPSTATUS	Status = AFP_ERR_NONE;
	BOOLEAN		Found = False;

	PAGED_CODE( );

	AfpSwmrAcquireExclusive(&pVolDesc->vds_DtAccessLock);
	ppApplInfo = &pVolDesc->vds_pApplBuckets[HASH_APPL(Creator)];

	// Find the APPL entry in the desktop
	for (;(pApplInfo = *ppApplInfo) != NULL; ppApplInfo = &pApplInfo->appl_Next)
	{
		if (pApplInfo->appl_Creator < Creator)
			continue;
		if (pApplInfo->appl_Creator > Creator)
			break;
		/*
		 * Check if the File number matches, if it does delete.
		 */
		if (pApplInfo->appl_FileNum == FileNum)
		{
			Found = True;
			*ppApplInfo = pApplInfo->appl_Next;
			AfpFreeMemory(pApplInfo);
			pVolDesc->vds_cApplEnts --;
			break;
		}
	}
	if (!Found)
		Status = AFP_ERR_ITEM_NOT_FOUND;

	AfpSwmrRelease(&pVolDesc->vds_DtAccessLock);
	return Status;
}


/***	AfpAddComment
 *
 *	Add the comment to the file or directory in question. Create the comment
 *	stream on the entity in question (if it does not already exist), convert
 *	the comment to unicode and write it. Update the flag in the DFEntry.
 */
AFPSTATUS
AfpAddComment(
	IN  PSDA		 	pSda,		// Session Data Area
	IN  PVOLDESC		pVolDesc,	// Volume descriptor of referenced desktop
	IN  PANSI_STRING	Comment,	// Comment to associate with the file/dir
	IN  PPATHMAPENTITY	pPME,		// Handle to the entity or its Host Id
	IN	BOOLEAN			Directory,	// True if directory
	IN	DWORD			AfpId
)
{
	UNICODE_STRING	UComment;
	WCHAR			CommentBuf[AFP_MAXCOMMENTSIZE+1];
	FILESYSHANDLE	HandleCommentStream;
	DWORD			CreateInfo;
	NTSTATUS		Status = AFP_ERR_MISC;
	PDFENTRY		pDFE = NULL;
    BOOLEAN         RestoreModTime = FALSE;
    AFPTIME         aModTime;
    TIME            ModTime;

	PAGED_CODE( );

	ASSERT (IS_VOLUME_NTFS(pVolDesc));

	if (Comment->Length == 0)
	{
		AfpRemoveComment(pSda, pVolDesc, pPME, Directory, AfpId);
		return AFP_ERR_NONE;
	}

	if (Comment->Length > AFP_MAXCOMMENTSIZE)
	{
		// Truncate comment if necessary
		Comment->Length = AFP_MAXCOMMENTSIZE;
	}

	UComment.Buffer = CommentBuf;
	UComment.MaximumLength = (USHORT)(RtlAnsiStringToUnicodeSize(Comment) + sizeof(WCHAR));
	UComment.Length = 0;

	AfpConvertStringToUnicode(Comment, &UComment);

	do
	{
		AfpImpersonateClient(pSda);

        // Get the last modified time from the file so we can reset it.

        Status = AfpIoQueryTimesnAttr( &pPME->pme_Handle,
                                       NULL,
                                       &ModTime,
                                       NULL );

		if (NT_SUCCESS(Status))
        {
		    RestoreModTime = TRUE;
            aModTime = AfpConvertTimeToMacFormat(&ModTime);
        }

		// Open the comment stream on the target entity.
		Status = AfpIoCreate(&pPME->pme_Handle,
							AFP_STREAM_COMM,
							&UNullString,
							FILEIO_ACCESS_WRITE,
							FILEIO_DENY_NONE,
							FILEIO_OPEN_FILE,
							FILEIO_CREATE_HARD,
							FILE_ATTRIBUTE_NORMAL,
							True,
							NULL,
							&HandleCommentStream,
							&CreateInfo,
							NULL,
							NULL,
							NULL);

		AfpRevertBack();

		if (Status != AFP_ERR_NONE) {
			if ((Status = AfpIoConvertNTStatusToAfpStatus(Status)) != AFP_ERR_ACCESS_DENIED)
				Status = AFP_ERR_MISC;
			break;
		}

		Status = AfpIoWrite(&HandleCommentStream,
							&LIZero,
							(LONG)UComment.Length,
							(PBYTE)UComment.Buffer);

		AfpIoClose(&HandleCommentStream);

        if( RestoreModTime )
        {
            AfpIoSetTimesnAttr( &pPME->pme_Handle,
                                NULL,
                                &aModTime,
                                0,
                                0,
                                NULL,
                                NULL );
        }

		if (NT_SUCCESS(Status))
		{
			AfpVolumeSetModifiedTime(pVolDesc);

			AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
			if ((pDFE = AfpFindDfEntryById(pVolDesc,
											AfpId,
											DFE_ANY)) != NULL)
            {
				pDFE->dfe_Flags |= DFE_FLAGS_HAS_COMMENT;
			}
			else
			{
				Status = AFP_ERR_MISC;
			}
			AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
		}
	} while (False);

	return Status;
}


/***	AfpGetComment
 *
 *	Extract the comment from the file or directory in question. The comment is
 *	copied to the ReplyBuf.
 */
AFPSTATUS
AfpGetComment(
	IN  PSDA			pSda,			// Session Data Area
	IN  PVOLDESC		pVolDesc,		// Volume descriptor of referenced desktop
	IN  PPATHMAPENTITY	pPME,			// Handle to the entity or its Host Id
	IN	BOOLEAN			Directory		// True if directory
)
{
	NTSTATUS		Status = AFP_ERR_MISC;
	LONG			SizeRead;
	UNICODE_STRING	UComment;
	WCHAR			CommentBuf[AFP_MAXCOMMENTSIZE+1];
	ANSI_STRING		AComment;
	FILESYSHANDLE	HandleCommentStream;

	PAGED_CODE( );

	// ASSERT (IS_VOLUME_NTFS(pVolDesc));

	// Initialize AComment
	AComment.Buffer = pSda->sda_ReplyBuf + 1;	// For size of string
	AComment.MaximumLength = AFP_MAXCOMMENTSIZE;
	AComment.Length = 0;

	UComment.MaximumLength = (AFP_MAXCOMMENTSIZE + 1) * sizeof(WCHAR);
	UComment.Buffer = CommentBuf;

	do
	{
		AfpImpersonateClient(pSda);

		// Open the comment stream on the target entity.
		Status = AfpIoOpen(&pPME->pme_Handle,
							AFP_STREAM_COMM,
							FILEIO_OPEN_FILE,
							&UNullString,
							FILEIO_ACCESS_READ,
							FILEIO_DENY_NONE,
							True,
							&HandleCommentStream);

		AfpRevertBack();

		if (Status != AFP_ERR_NONE)
		{
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
			if (Status == AFP_ERR_OBJECT_NOT_FOUND)
				Status = AFP_ERR_ITEM_NOT_FOUND;
			else if (Status != AFP_ERR_ACCESS_DENIED)
				Status = AFP_ERR_OBJECT_NOT_FOUND;
			break;
		}

		Status = AfpIoRead(&HandleCommentStream,
						   &LIZero,
						   (LONG)UComment.MaximumLength,
						   &SizeRead,
						   (PBYTE)UComment.Buffer);

		AfpIoClose(&HandleCommentStream);

		if (Status == AFP_ERR_NONE)
		{
			UComment.Length = (USHORT) SizeRead;
			AfpConvertStringToAnsi(&UComment, &AComment);
			pSda->sda_ReplyBuf[0] = (BYTE)AComment.Length;
			pSda->sda_ReplySize = AComment.Length + 1;
		}
	} while (False);

	return Status;
}


/***	AfpRemoveComment
 *
 *	Remove the comment from the file or directory in question. Essentially
 *	open the comment stream and set the length to 0.
 */
AFPSTATUS
AfpRemoveComment(
	IN  PSDA			pSda,		// Session Data Area
	IN  PVOLDESC		pVolDesc,	// Volume descriptor of referenced desktop
	IN  PPATHMAPENTITY	pPME,		// Handle to the entity or its Host Id
	IN	BOOLEAN			Directory,	// True if directory
	IN	DWORD			AfpId
)
{
	FILESYSHANDLE	HandleCommentStream;
	NTSTATUS		Status = AFP_ERR_MISC;
	PDFENTRY		pDFE = NULL;

	PAGED_CODE( );

	ASSERT (IS_VOLUME_NTFS(pVolDesc));

	do
	{
		AfpImpersonateClient(pSda);

		// Open the comment stream on the target entity.
		Status = AfpIoOpen(&pPME->pme_Handle,
							AFP_STREAM_COMM,
							FILEIO_OPEN_FILE,
							&UNullString,
							FILEIO_ACCESS_DELETE,
							FILEIO_DENY_NONE,
							True,
							&HandleCommentStream);

		AfpRevertBack();

		if (Status != AFP_ERR_NONE)
		{
			if ((Status = AfpIoConvertNTStatusToAfpStatus(Status)) != AFP_ERR_ACCESS_DENIED)
				Status = AFP_ERR_ITEM_NOT_FOUND;
			break;
		}
		Status = AfpIoMarkFileForDelete(&HandleCommentStream, NULL, NULL, NULL);

		AfpIoClose(&HandleCommentStream);

		if (NT_SUCCESS(Status))
		{
			AfpVolumeSetModifiedTime(pVolDesc);

			AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
			if ((pDFE = AfpFindDfEntryById(pVolDesc,
											AfpId,
											DFE_ANY)) != NULL)
            {
				pDFE->dfe_Flags &= ~DFE_FLAGS_HAS_COMMENT;
			}
			else
			{
				Status = AFP_ERR_MISC;
			}
			AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
		}
	} while (False);

	return Status;
}


/***	AfpAddIconToGlobalList
 *
 *	The global list of icons is a server maintained list updated by the service.
 *	This adds an icon to the list. If an icon exists for the given type and
 *	creator, it is replaced. This list is maintained via the AfpIconAdd() admin
 *	api.
 *
 *	LOCKS:	AfpIconListLock (SWMR, Exclusive);
 */
AFPSTATUS
AfpAddIconToGlobalList(
	IN  DWORD	Type,
	IN  DWORD	Creator,
	IN  DWORD	IconType,
	IN  LONG	IconSize,
	IN  PBYTE	pIconBitMap
)
{
	PICONINFO	pIconInfo,
				pIconInfoNew,
				*ppIconInfo;
	AFPSTATUS	Status = AFP_ERR_NONE;

	PAGED_CODE( );

	// Pre-allocate memory for the new icon, delete if necessary later
	if ((pIconInfoNew = ALLOC_ICONINFO(IconSize)) == NULL)
		return AFP_ERR_MISC;

	AfpSwmrAcquireExclusive(&AfpIconListLock);
	ppIconInfo = &AfpGlobalIconList;
	for (; (pIconInfo = *ppIconInfo) != NULL; ppIconInfo = &pIconInfo->icon_Next)
	{
		if ((pIconInfo->icon_Type == Type) &&
			(pIconInfo->icon_Creator == Creator))
			break;
	}
	if (pIconInfo == NULL)
	{
		if (IconSize > 0)
			RtlCopyMemory((PBYTE)pIconInfoNew + sizeof(ICONINFO), pIconBitMap, IconSize);
		pIconInfoNew->icon_Creator = Creator;
		pIconInfoNew->icon_Type = Type;
		pIconInfoNew->icon_IconType = (USHORT)IconType;
		pIconInfoNew->icon_Size = (SHORT)IconSize;
		pIconInfoNew->icon_Tag = 0;
		pIconInfoNew->icon_Next = NULL;
		*ppIconInfo = pIconInfoNew;
	}
	else
	{
		// We do not need the memory any more, release it
		AfpFreeMemory(pIconInfoNew);
		if (pIconInfo->icon_IconType != (USHORT)IconType)
			Status = AFPERR_InvalidParms;
		else if (IconSize > 0)
			RtlCopyMemory((PBYTE)pIconInfo + sizeof(ICONINFO), pIconBitMap, IconSize);
	}
	AfpSwmrRelease(&AfpIconListLock);
	return AFP_ERR_NONE;
}


/***	afpLookupIconInGlobalList
 *
 *	The global list of icons is a server maintained list updates by the service.
 *	This is called by AfpLookupIcon() when the specified icon is not found in
 *	the volume desktop.
 *
 *	LOCKS:	AfpIconListLock (SWMR, Shared);
 */
LOCAL AFPSTATUS
afpLookupIconInGlobalList(
	IN  DWORD	Creator,
	IN  DWORD	Type,
	IN  DWORD	IconType,
	IN  PLONG	pSize,
	OUT PBYTE	pBitMap
)
{
	PICONINFO	pIconInfo;
	AFPSTATUS	Status = AFP_ERR_NONE;

	PAGED_CODE( );

	AfpSwmrAcquireShared(&AfpIconListLock);
	pIconInfo = AfpGlobalIconList;
	for (pIconInfo = AfpGlobalIconList;
		 pIconInfo != NULL;
		 pIconInfo = pIconInfo->icon_Next)
	{
		if ((pIconInfo->icon_Type == Type) &&
			(pIconInfo->icon_Creator == Creator) &&
			(pIconInfo->icon_IconType == (USHORT)IconType))
			break;
	}
	if (pIconInfo == NULL)
		Status = AFP_ERR_ITEM_NOT_FOUND;
	else
	{
		if (*pSize > pIconInfo->icon_Size)
			*pSize = pIconInfo->icon_Size;
		if (*pSize > 0)
			RtlCopyMemory(pBitMap, (PBYTE)pIconInfo + sizeof(ICONINFO), *pSize);
	}
	AfpSwmrRelease(&AfpIconListLock);
	return Status;
}


/***	AfpFreeGlobalIconList
 *
 *	Called at server stop time to free the memory allocated for the global
 *	icons.
 *
 *	LOCKS:	AfpIconListLock (SWMR, Exclusive);
 */
VOID
AfpFreeGlobalIconList(
	VOID
)
{
	PICONINFO	pIconInfo;

	PAGED_CODE( );

	AfpSwmrAcquireExclusive(&AfpIconListLock);

	for (pIconInfo = AfpGlobalIconList; pIconInfo != NULL; )
	{
		PICONINFO	pFree;

		pFree = pIconInfo;
		pIconInfo = pIconInfo->icon_Next;
		AfpFreeMemory (pFree);
	}

	AfpSwmrRelease(&AfpIconListLock);
}


/***	afpGetGlobalIconInfo
 *
 *	The global list of icons is a server maintained list updates by the service.
 *	This is called by AfpLookupIconInfo() when the specified icon is not found
 *	in the volume desktop.
 *
 *	LOCKS:	AfpIconListLock (SWMR, Shared)
 */
LOCAL AFPSTATUS
afpGetGlobalIconInfo(
	IN  DWORD	Creator,
	OUT PDWORD	pType,
	OUT PDWORD	pIconType,
	OUT PDWORD	pTag,
	OUT PLONG	pSize
)
{
	PICONINFO	pIconInfo;
	AFPSTATUS	Status = AFP_ERR_NONE;

	PAGED_CODE( );

	AfpSwmrAcquireExclusive(&AfpIconListLock);
	pIconInfo = AfpGlobalIconList;
	for (pIconInfo = AfpGlobalIconList;
		 pIconInfo != NULL;
		 pIconInfo = pIconInfo->icon_Next)
	{
		if (pIconInfo->icon_Creator == Creator)
			break;
	}
	if (pIconInfo == NULL)
		Status = AFP_ERR_ITEM_NOT_FOUND;
	else
	{
		*pType = pIconInfo->icon_Type;
		*pIconType = pIconInfo->icon_IconType;
		*pTag = pIconInfo->icon_Tag;
		*pSize = pIconInfo->icon_Size;
	}
	AfpSwmrRelease(&AfpIconListLock);
	return Status;
}


/*** afpReadDesktopFromDisk
 *
 *	Read the desktop database from the desktop stream. No locks are required
 *	for this routine since it only operates on volume descriptors which are
 *	newly created and not yet linked into the global volume list.
 */
LOCAL NTSTATUS
afpReadDesktopFromDisk(
	IN	PVOLDESC		pVolDesc,
	IN	PFILESYSHANDLE	pfshDesktop
)
{
	DESKTOP		Desktop;
	PAPPLINFO2	*ppApplInfo;
	PICONINFO	*ppIconInfo;
	NTSTATUS	Status;
	DWORD		DskOffst;
	FORKOFFST	ForkOffset;
	PBYTE		pBuffer;
	LONG		i, SizeRead, BufOffst = 0;
	LONG		PrevHash, applSize;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_INFO,
			 ("\tReading Desktop from disk....\n") );

	// Work with one page of memory and do multiple I/Os to the disk.
	if ((pBuffer = AfpAllocNonPagedMemory(DESKTOPIO_BUFSIZE)) == NULL)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	ForkOffset.QuadPart = DskOffst = 0;

	// Read in the desktop header and validate it
	Status = AfpIoRead(pfshDesktop,
					   &ForkOffset,
					   sizeof(DESKTOP),
					   &SizeRead,
					   (PBYTE)&Desktop);

	if (!NT_SUCCESS(Status) ||

		(SizeRead != sizeof(DESKTOP)) ||

		(Desktop.dtp_Signature != AFP_SERVER_SIGNATURE)	||

		((Desktop.dtp_Version != AFP_DESKTOP_VERSION1) &&
		 (Desktop.dtp_Version != AFP_DESKTOP_VERSION2))	||

		((Desktop.dtp_cApplEnts > 0) &&
		 ((ULONG_PTR)(Desktop.dtp_pApplInfo) != sizeof(DESKTOP))) ||

		((Desktop.dtp_cIconEnts > 0) &&
		 ((ULONG_PTR)(Desktop.dtp_pIconInfo) != sizeof(DESKTOP) +
						(Desktop.dtp_cApplEnts *
						((Desktop.dtp_Version == AFP_DESKTOP_VERSION1) ?
							sizeof(APPLINFO) : sizeof(APPLINFO2))) ))  )
	{
		AFPLOG_ERROR(AFPSRVMSG_READ_DESKTOP, Status, NULL, 0,
					 &pVolDesc->vds_Name);
		goto desktop_corrupt;
	}

	switch (Desktop.dtp_Version)
	{
		case AFP_DESKTOP_VERSION1:
		{
			AFPLOG_INFO(AFPSRVMSG_UPDATE_DESKTOP_VERSION,
						 STATUS_SUCCESS,
						 NULL,
						 0,
						 &pVolDesc->vds_Name);

			applSize = sizeof(APPLINFO);

			break;
		}
		case AFP_DESKTOP_VERSION2:
        {
			applSize = sizeof(APPLINFO2);
			break;
		}
		default:
        {
			// This should never happen since it was checked above
			DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_WARN,
				 ("afpReadDesktopFromDisk: Unexpected DT version 0x%lx\n", Desktop.dtp_Version) );
			ASSERTMSG("afpReadDesktopFromDisk: Unexpected DT Version", 0);
			goto desktop_corrupt;
		}
	}

	// Initialize the desktop header.  Even though we may be reading a
	// downlevel version database, set the in-memory desktop database
	// version to current version since we are building it with the
	// current appl version structure.
	AfpDtHdrToVolDesc(&Desktop, pVolDesc);

	ForkOffset.QuadPart = DskOffst = sizeof(DESKTOP);
	SizeRead = 0;

	// Now read in the APPL entries, if any
	for (i = 0, PrevHash = -1;
		(Status == AFP_ERR_NONE) && (i < Desktop.dtp_cApplEnts);
		i++)
	{
		PAPPLINFO2	pApplInfo;

		if ((SizeRead - BufOffst) < applSize)
		{
			// We have a partial APPLINFO.  Backup and read the whole thing
			DskOffst -= ((DWORD)SizeRead - (DWORD)BufOffst);
            ForkOffset.QuadPart = DskOffst;
			Status = AfpIoRead(pfshDesktop,
								&ForkOffset,
								DESKTOPIO_BUFSIZE,
								&SizeRead,
								pBuffer);
			if ((Status != AFP_ERR_NONE) || (SizeRead < applSize))
			{
				AFPLOG_ERROR(AFPSRVMSG_READ_DESKTOP, Status, &SizeRead,
							 sizeof(SizeRead), &pVolDesc->vds_Name);
				Status = STATUS_UNEXPECTED_IO_ERROR;
				break;
			}
			DskOffst += SizeRead;
			ForkOffset.QuadPart = DskOffst;
			BufOffst = 0;
		}

		if ((pApplInfo = ALLOC_APPLINFO()) == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			AFPLOG_ERROR(AFPSRVMSG_READ_DESKTOP, Status, NULL, 0,
						 &pVolDesc->vds_Name);
			break;
		}
		pApplInfo->appl_ParentID = 0;
		// If we are reading downlevel appl structures, they will
		// get read into the first part of the current appl structures.
		// These fields should be identical!  If this is the case, the
		// appl_ParentId field will be 0 and the volume marked as needing
		// its appls rebuilt.
		RtlCopyMemory(pApplInfo, pBuffer + BufOffst, applSize);
		pApplInfo->appl_Next = NULL;
		BufOffst += applSize;
		if (PrevHash != (LONG)HASH_APPL(pApplInfo->appl_Creator))
		{
			PrevHash = (LONG)HASH_APPL(pApplInfo->appl_Creator);
			ppApplInfo = &pVolDesc->vds_pApplBuckets[PrevHash];
		}
		*ppApplInfo = pApplInfo;
		ppApplInfo = &pApplInfo->appl_Next;
	}


	// Now read in the ICON entries, if any

	for (i = 0, PrevHash = -1;
		(Status == AFP_ERR_NONE) && (i < Desktop.dtp_cIconEnts);
		i++)
	{
		PICONINFO	pIconInfo;

		if ((SizeRead - BufOffst) < sizeof(ICONINFO))
		{
			// We have a partial ICONINFO.  Backup and read the whole thing
			DskOffst -= ((DWORD)SizeRead - (DWORD)BufOffst);
			ForkOffset.QuadPart = DskOffst;
			Status = AfpIoRead(pfshDesktop,
								&ForkOffset,
								DESKTOPIO_BUFSIZE,
								&SizeRead,
								pBuffer);
			if ((Status != AFP_ERR_NONE) || (SizeRead < sizeof(ICONINFO)))
			{
				AFPLOG_ERROR(AFPSRVMSG_READ_DESKTOP, Status, &SizeRead,
							 sizeof(SizeRead), &pVolDesc->vds_Name);
				Status = STATUS_UNEXPECTED_IO_ERROR;
				break;
			}
			DskOffst += SizeRead;
			ForkOffset.QuadPart = DskOffst;
			BufOffst = 0;
		}

		// Validate icon size
		if ((((PICONINFO)(pBuffer + BufOffst))->icon_Size > ICONSIZE_ICN8) ||
			(((PICONINFO)(pBuffer + BufOffst))->icon_Size < ICONSIZE_ICS))
		{
			Status = STATUS_UNEXPECTED_IO_ERROR;
			AFPLOG_ERROR(AFPSRVMSG_READ_DESKTOP, Status,
						 &((PICONINFO)(pBuffer + BufOffst))->icon_Size,
						 sizeof(((PICONINFO)(0))->icon_Size),
						 &pVolDesc->vds_Name);
			break;
		}

		if ((pIconInfo = ALLOC_ICONINFO(((PICONINFO)(pBuffer + BufOffst))->icon_Size)) == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			AFPLOG_ERROR(AFPSRVMSG_READ_DESKTOP, Status, NULL, 0,
						 &pVolDesc->vds_Name);
			break;
		}

		// First copy the icon header and then link the icon into the hash table
		RtlCopyMemory(pIconInfo, pBuffer + BufOffst, sizeof(ICONINFO));

		pIconInfo->icon_Next = NULL;
		if (PrevHash != (LONG)HASH_ICON(pIconInfo->icon_Creator))
		{
			PrevHash = (LONG)HASH_ICON(pIconInfo->icon_Creator);
			ppIconInfo = &pVolDesc->vds_pIconBuckets[PrevHash];
		}
		*ppIconInfo = pIconInfo;
		ppIconInfo = &pIconInfo->icon_Next;

		// Now check if there is sufficient stuff here to get the icon
		BufOffst += sizeof(ICONINFO);
		if ((SizeRead - BufOffst) < pIconInfo->icon_Size)
		{
			LONG	Size2Copy;

			Size2Copy = SizeRead - BufOffst;

			// Copy what we can first
			RtlCopyMemory((PBYTE)pIconInfo + sizeof(ICONINFO),
						   pBuffer + BufOffst, Size2Copy);

			Status = AfpIoRead(pfshDesktop,
								&ForkOffset,
								DESKTOPIO_BUFSIZE,
								&SizeRead,
								pBuffer);
			if ((Status != AFP_ERR_NONE) ||
				(SizeRead < (pIconInfo->icon_Size - Size2Copy)))
			{
				AFPLOG_ERROR(AFPSRVMSG_READ_DESKTOP, Status, &SizeRead,
							 sizeof(SizeRead), &pVolDesc->vds_Name);
				Status = STATUS_UNEXPECTED_IO_ERROR;
				break;
			}
			DskOffst += SizeRead;
			ForkOffset.QuadPart = DskOffst;

			// Now copy the rest of the icon
			RtlCopyMemory((PBYTE)pIconInfo + sizeof(ICONINFO) + Size2Copy,
						   pBuffer,
						   pIconInfo->icon_Size - Size2Copy);

			BufOffst = pIconInfo->icon_Size - Size2Copy;
		}
		else
		{
			RtlCopyMemory((PBYTE)pIconInfo + sizeof(ICONINFO),
							pBuffer + BufOffst,
							pIconInfo->icon_Size);

			BufOffst += pIconInfo->icon_Size;
		}
	}

	if (Status != AFP_ERR_NONE)
	{
		AfpFreeDesktopTables(pVolDesc);
desktop_corrupt:
		// We have essentially ignored the existing data in the stream
		// Initialize the header
		pVolDesc->vds_cApplEnts = 0;
		pVolDesc->vds_cIconEnts = 0;

		AfpVolDescToDtHdr(pVolDesc, &Desktop);
		Desktop.dtp_pIconInfo = NULL;
		Desktop.dtp_pApplInfo = NULL;
		AfpIoWrite(pfshDesktop,
					&LIZero,
					sizeof(DESKTOP),
					(PBYTE)&Desktop);

		// Truncate the stream at this point
		AfpIoSetSize(pfshDesktop, sizeof(DESKTOP));
		Status = STATUS_SUCCESS;
	}

	if (pBuffer != NULL)
		AfpFreeMemory(pBuffer);

	return Status;
}



/***	AfpInitDesktop
 *
 *	This routine initializes the memory image (and all related volume
 *	descriptor fields) of the desktop for a newly added volume.  If a desktop
 *	stream already exists on the disk for the volume root directory, that
 *	stream is read in.  If this is a newly created volume, the desktop
 *	stream is created on the root of the volume.  If this is a CD-ROM volume,
 *	only the memory image is initialized.
 *
 *	No locks are necessary since this routine only operates on volume
 *	descriptors which are newly allocated, but not yet linked into the global
 *	volume list.
 */
AFPSTATUS
AfpInitDesktop(
	IN	PVOLDESC	pVolDesc,
    OUT BOOLEAN    *pfNewVolume
)
{
	BOOLEAN				InitHeader = True;
	NTSTATUS			Status = STATUS_SUCCESS;
	FILESYSHANDLE		fshDesktop;

	PAGED_CODE( );

    // for now
    *pfNewVolume = FALSE;

	DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_INFO, ("\tInitializing Desktop...\n") );
	AfpSwmrInitSwmr(&(pVolDesc->vds_DtAccessLock));

	// if this is an NTFS volume, attempt to create the desktop stream.
	// If it already exists, open it and read it in.
	if (IS_VOLUME_NTFS(pVolDesc))
	{
		ULONG	CreateInfo;

        InitHeader = False;

		Status = AfpIoCreate(&pVolDesc->vds_hRootDir,
						AFP_STREAM_DT,
						&UNullString,
						FILEIO_ACCESS_READWRITE,
						FILEIO_DENY_WRITE,
						FILEIO_OPEN_FILE,
						FILEIO_CREATE_INTERNAL,
						FILE_ATTRIBUTE_NORMAL,
						False,
						NULL,
						&fshDesktop,
						&CreateInfo,
						NULL,
						NULL,
						NULL);

		if (NT_SUCCESS(Status))
		{
			if (CreateInfo == FILE_OPENED)
			{
				Status = afpReadDesktopFromDisk(pVolDesc, &fshDesktop);
				AfpIoClose(&fshDesktop);
			}
			else if (CreateInfo != FILE_CREATED)
			{
				DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_ERR,
				 ("AfpInitDesktop: Unexpected create action 0x%lx\n", CreateInfo) );
				ASSERT(0); // this should never happen
				Status = STATUS_UNSUCCESSFUL;
			}
            else
            {
                DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
                    ("AfpInitDesktop: volume %Z is new\n",&pVolDesc->vds_Name));

                InitHeader = True;
                *pfNewVolume = TRUE;
            }
		}
		else
		{
			DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_ERR,
				 ("AfpInitDesktop: AfpIoCreate failed %lx\n", Status));
			Status = STATUS_UNSUCCESSFUL;
		}
	}

	if (InitHeader)
	{
		DESKTOP	Desktop;

		// Initialize the header
		pVolDesc->vds_cApplEnts = 0;
		pVolDesc->vds_cIconEnts = 0;

		if (IS_VOLUME_NTFS(pVolDesc))
		{
			AfpVolDescToDtHdr(pVolDesc, &Desktop);
			Desktop.dtp_pIconInfo = NULL;
			Desktop.dtp_pApplInfo = NULL;
			AfpIoWrite(&fshDesktop,
						&LIZero,
						sizeof(DESKTOP),
						(PBYTE)&Desktop);
			AfpIoClose(&fshDesktop);
		}
	}
	return Status;
}


/***	AfpUpdateDesktop
 *
 *	Update the desktop database on the volume root. The swmr access is held
 *	for read (by the caller) while the update is in progress. It is already
 *	determined by the caller that the volume desktop needs to be updated.
 *
 *	LOCKS: vds_DtAccessLock (SWMR, Shared)
 */
VOID
AfpUpdateDesktop(
	IN  PVOLDESC pVolDesc		// Volume Descriptor of the open volume
)
{
	AFPSTATUS		Status;
	PBYTE			pBuffer;
	DWORD			Offset = 0, Size;
	LONG			i;
	DESKTOP			Desktop;
	FORKOFFST		ForkOffset;
	FILESYSHANDLE	fshDesktop;
	ULONG			CreateInfo;
#ifdef	PROFILING
	TIME			TimeS, TimeE, TimeD;

	PAGED_CODE( );

	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_DesktopUpdCount);
	AfpGetPerfCounter(&TimeS);
#endif

	// Take the swmr so that nobody can initiate changes to the desktop
	AfpSwmrAcquireShared(&pVolDesc->vds_DtAccessLock);

	DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_INFO,
			 ("\tWriting Desktop to disk....\n") );

	do
	{
		fshDesktop.fsh_FileHandle = NULL;
		// Work with one page of memory and do multiple I/Os to the disk.
		if ((pBuffer = AfpAllocPagedMemory(DESKTOPIO_BUFSIZE)) == NULL)
		{
			AFPLOG_ERROR(AFPSRVMSG_WRITE_DESKTOP, STATUS_NO_MEMORY, NULL, 0,
						 &pVolDesc->vds_Name);
			break;
		}

		// Open a handle to the desktop stream, denying others read/write
		// access (i.e. backup/restore)
		Status = AfpIoCreate(&pVolDesc->vds_hRootDir,
							 AFP_STREAM_DT,
							 &UNullString,
							 FILEIO_ACCESS_WRITE,
							 FILEIO_DENY_ALL,
							 FILEIO_OPEN_FILE,
							 FILEIO_CREATE_INTERNAL,
							 FILE_ATTRIBUTE_NORMAL,
							 False,
							 NULL,
							 &fshDesktop,
							 &CreateInfo,
							 NULL,
							 NULL,
							 NULL);

		if (NT_SUCCESS(Status))
		{
			if ((CreateInfo != FILE_OPENED) && (CreateInfo != FILE_CREATED))
			{
				// This should never happen!
				DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_WARN,
				 ("AfpUpdateDesktop: Unexpected create action 0x%lx\n", CreateInfo) );
				ASSERTMSG("AfpUpdateDesktop: Unexpected create action", 0);
				break;
			}
		}
		else
		{
			AFPLOG_ERROR(AFPSRVMSG_WRITE_DESKTOP, Status, NULL, 0,
						 &pVolDesc->vds_Name);
			break;
		}

		// Snapshot the header and write it with an invalid signature. We write
		// the header again later with a valid signature. This protects us from
		// incomplete writes (server crash etc.)
		AfpVolDescToDtHdr(pVolDesc, &Desktop);
		Desktop.dtp_Signature = 0;

		(ULONG_PTR)(Desktop.dtp_pApplInfo) = 0;
		if (Desktop.dtp_cApplEnts > 0)
			(ULONG_PTR)(Desktop.dtp_pApplInfo) = sizeof(DESKTOP);

		(ULONG_PTR)(Desktop.dtp_pIconInfo) = 0;
		if (Desktop.dtp_cIconEnts > 0)
			(ULONG_PTR)(Desktop.dtp_pIconInfo) = sizeof(DESKTOP) +
										 sizeof(APPLINFO2)*Desktop.dtp_cApplEnts;

		// Write out the header with invalid signature
		Status = AfpIoWrite(&fshDesktop,
							&LIZero,
							sizeof(DESKTOP),
							(PBYTE)&Desktop);

		Offset = sizeof(DESKTOP);
		Size = 0;

		// First write the APPL Entries
		for (i = 0; (Status == AFP_ERR_NONE) && (i < APPL_BUCKETS); i++)
		{
			PAPPLINFO2		pApplInfo;

			for (pApplInfo = pVolDesc->vds_pApplBuckets[i];
				 (Status == AFP_ERR_NONE) && (pApplInfo != NULL);
				 pApplInfo = pApplInfo->appl_Next)
			{
				if ((DESKTOPIO_BUFSIZE - Size) < sizeof(APPLINFO2))
				{
					DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_INFO,
						("afpUpdateDesktop: Writing Appl %ld at %ld\n", Size, Offset));

					ForkOffset.QuadPart = Offset;
					Status = AfpIoWrite(&fshDesktop,
										&ForkOffset,
										Size,
										pBuffer);
					Size = 0;
					Offset += Size;
				}
				*(PAPPLINFO2)(pBuffer + Size) = *pApplInfo;
				Size += sizeof(APPLINFO2);
			}
		}

		// And now the ICON entries
		for (i = 0; (Status == AFP_ERR_NONE) && (i < ICON_BUCKETS); i++)
		{
			PICONINFO		pIconInfo;

			for (pIconInfo = pVolDesc->vds_pIconBuckets[i];
				 (Status == AFP_ERR_NONE) && (pIconInfo != NULL);
				 pIconInfo = pIconInfo->icon_Next)
			{
				if ((DESKTOPIO_BUFSIZE - Size) < (sizeof(ICONINFO) + pIconInfo->icon_Size))
				{
					DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_INFO,
						("afpUpdateDesktop: Writing icons %ld at %ld\n", Size, Offset));

					ForkOffset.QuadPart = Offset;
					Status = AfpIoWrite(&fshDesktop,
										&ForkOffset,
										Size,
										pBuffer);
					Offset += Size;
					Size = 0;
				}
				RtlCopyMemory(pBuffer + Size,
							  (PBYTE)pIconInfo,
							  sizeof(ICONINFO) + pIconInfo->icon_Size);
				Size += sizeof(ICONINFO) + pIconInfo->icon_Size;
			}
		}

		while (Status == AFP_ERR_NONE)
		{
			if (Size > 0)
			{
				DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_INFO,
						("afpUpdateDesktop: Writing at end %ld at %ld\n", Size, Offset));

				ForkOffset.QuadPart = Offset;
				Status = AfpIoWrite(&fshDesktop,
									&ForkOffset,
									Size,
									pBuffer);
				if (Status != AFP_ERR_NONE)
					break;
			}

			DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_INFO,
					("afpUpdateDesktop: Setting desktop stream size @ %ld\n", Size + Offset));
			// Chop off the stream at this offset.
			Status = AfpIoSetSize(&fshDesktop, Offset + Size);

			ASSERT (Status == AFP_ERR_NONE);

			// Write the correct signature back
			Desktop.dtp_Signature = AFP_SERVER_SIGNATURE;

			Status = AfpIoWrite(&fshDesktop,
								&LIZero,
								sizeof(DESKTOP),
								(PBYTE)&Desktop);

			// Update the count of changes: vds_cChangesDt is protected by the
			// swmr, the scavenger can set this with READ access.  All others
			// MUST hold the swmr for WRITE access to increment the cChangesDt.
			// Scavenger is the only consumer of vds_cScvgrDt, so no lock is
			// really needed for it.
			pVolDesc->vds_cScvgrDt = 0;
			break;
		}

		if (Status != AFP_ERR_NONE)
		{
			AFPLOG_ERROR(AFPSRVMSG_WRITE_DESKTOP, Status, NULL, 0,
						 &pVolDesc->vds_Name);
		}

	} while (False);

	if (pBuffer != NULL)
	{
		AfpFreeMemory(pBuffer);
		if (fshDesktop.fsh_FileHandle != NULL)
			AfpIoClose(&fshDesktop);
	}
#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_DesktopUpdTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	AfpSwmrRelease(&pVolDesc->vds_DtAccessLock);
}


/***	AfpFreeDesktopTables
 *
 *	Free the allocated memory for the volume desktop tables. The volume is
 *	about to be deleted. Ensure that either the volume is non-NTFS or it is
 *	clean i.e. the scavenger threads have written it back. No locks are needed
 *	as this structure is all by itself.
 */
VOID
AfpFreeDesktopTables(
	IN	PVOLDESC	pVolDesc
)
{
	LONG		i;

	PAGED_CODE( );

	// This should never happen
	ASSERT (!IS_VOLUME_NTFS(pVolDesc) ||
			 (pVolDesc->vds_pOpenForkDesc == NULL));

	// First tackle the ICON list. Traverse each of the hash indices.
	// Note that the icon is allocated as part of the IconInfo structure
	// so free in together.
	for (i = 0; i < ICON_BUCKETS; i++)
	{
		PICONINFO	pIconInfo, pFree;

		for (pIconInfo = pVolDesc->vds_pIconBuckets[i]; pIconInfo != NULL; )
		{
			pFree = pIconInfo;
			pIconInfo = pIconInfo->icon_Next;
			AfpFreeMemory(pFree);
		}
		// In case we ever try to free the table again
		pVolDesc->vds_pIconBuckets[i] = NULL;
	}

	// Now tackle the APPL list. Traverse each of the hash indices.
	for (i = 0; i < APPL_BUCKETS; i++)
	{
		PAPPLINFO2	pApplInfo, pFree;

		for (pApplInfo = pVolDesc->vds_pApplBuckets[i]; pApplInfo != NULL; )
		{
			pFree = pApplInfo;
			pApplInfo = pApplInfo->appl_Next;
			AfpFreeMemory(pFree);
		}
		// In case we ever try to free the table again
		pVolDesc->vds_pApplBuckets[i] = NULL;
	}
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\chgntfy.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	chgntfy.c

Abstract:

	This module contains the code for processing change notifies.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	15 Jun 1995 JameelH	Seperated the change notify code from idindex.c

Notes:		Tab stop: 4

--*/

#define IDINDEX_LOCALS
#define	FILENUM	FILE_CHGNTFY

#include <afp.h>
#include <scavengr.h>
#include <fdparm.h>
#include <pathmap.h>
#include <afpinfo.h>
#include <access.h>	// for AfpWorldId

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, afpVerifyDFE)
#pragma alloc_text(PAGE, afpAddDfEntryAndCacheInfo)
#pragma alloc_text(PAGE, afpReadIdDb)
#pragma alloc_text(PAGE, AfpProcessChangeNotify)
#pragma alloc_text(PAGE, afpProcessPrivateNotify)
#pragma alloc_text(PAGE, AfpQueuePrivateChangeNotify)
#pragma alloc_text(PAGE, AfpCacheDirectoryTree)
#pragma alloc_text(PAGE, AfpQueueOurChange)
#endif

/***	afpVerifyDFE
 *
 *	Check if our view of this item in our data-base matches whats on disk. If not
 *  update our view with whats on disk.
 */
VOID
afpVerifyDFE(
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDfeParent,
	IN	PUNICODE_STRING				pUName,			// munged unicode name
	IN	PFILESYSHANDLE				pfshParentDir,	// open handle to parent directory
	IN	PFILE_BOTH_DIR_INFORMATION	pFBDInfo,		// from enumerate
	IN	PUNICODE_STRING				pNotifyPath,	// to filter out our own AFP_AfpInfo change notifies
	IN	PDFENTRY	*				ppDfEntry
)
{
	PDFENTRY	pDfEntry = *ppDfEntry;

	if (pFBDInfo->LastWriteTime.QuadPart > pDfEntry->dfe_LastModTime.QuadPart)
	{
		FILESYSHANDLE	fshAfpInfo, fshData;
		AFPINFO			AfpInfo;
        DWORD			crinfo, openoptions = 0;
		BOOLEAN			SeenComment, WriteBackROAttr = False;
        PSTREAM_INFO	pStreams = NULL, pCurStream;
		NTSTATUS		Status = STATUS_SUCCESS;
		BOOLEAN			IsDir;

		// Our view is stale, update it
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("afpVerifyDFE: Updating stale database with fresh info\n\t%Z\n", pNotifyPath));

		IsDir = (pFBDInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? True : False;

		ASSERT (IS_VOLUME_NTFS(pVolDesc));

		ASSERT (!(DFE_IS_DIRECTORY(pDfEntry) ^ IsDir));

		// Update DFE from FBDInfo first
		pDfEntry->dfe_CreateTime = AfpConvertTimeToMacFormat(&pFBDInfo->CreationTime);
		pDfEntry->dfe_LastModTime = pFBDInfo->LastWriteTime;
		pDfEntry->dfe_NtAttr = (USHORT)(pFBDInfo->FileAttributes & FILE_ATTRIBUTE_VALID_FLAGS);
		if (!IsDir)
		{
			pDfEntry->dfe_DataLen = pFBDInfo->EndOfFile.LowPart;
		}

		// Open/Create the AfpInfo stream
		fshAfpInfo.fsh_FileHandle = NULL;
		fshData.fsh_FileHandle	= NULL;

		do
		{
			// open or create the AfpInfo stream
			if (!NT_SUCCESS(AfpCreateAfpInfoWithNodeName(pfshParentDir,
														 pUName,
														 pNotifyPath,
														 pVolDesc,
														 &fshAfpInfo,
														 &crinfo)))
			{
				if (!(pFBDInfo->FileAttributes & FILE_ATTRIBUTE_READONLY))
				{
					// What other reason is there that we could not open
					// this stream except that this file/dir is readonly?
					Status = STATUS_UNSUCCESSFUL;
					break;
				}

				openoptions = IsDir ? FILEIO_OPEN_DIR : FILEIO_OPEN_FILE;
				Status = STATUS_UNSUCCESSFUL;	// Assume failure
				if (NT_SUCCESS(AfpIoOpen(pfshParentDir,
										 AFP_STREAM_DATA,
										 openoptions,
										 pUName,
										 FILEIO_ACCESS_NONE,
										 FILEIO_DENY_NONE,
										 False,
										 &fshData)))
				{
					if (NT_SUCCESS(AfpExamineAndClearROAttr(&fshData,
															&WriteBackROAttr,
															pVolDesc,
															pNotifyPath)))
					{
						if (NT_SUCCESS(AfpCreateAfpInfo(&fshData,
														&fshAfpInfo,
														&crinfo)))
						{
							Status = STATUS_SUCCESS;
						}
					}
				}

				if (!NT_SUCCESS(Status))
				{
					// Skip this entry if you cannot get to the AfpInfo, cannot
					// clear the RO attribute or whatever.
					break;
				}
			}

			// We successfully opened or created the AfpInfo stream.  If
			// it existed, then validate the ID, otherwise create all new
			// Afpinfo for this file/dir.
			if ((crinfo == FILE_OPENED) &&
				(NT_SUCCESS(AfpReadAfpInfo(&fshAfpInfo, &AfpInfo))))
			{
				BOOLEAN	fSuccess;

				if ((AfpInfo.afpi_Id != pDfEntry->dfe_AfpId) &&
					(pDfEntry->dfe_AfpId != AFP_ID_ROOT))
				{
					PDFENTRY	pDFE;

					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
							("afpVerifyDFE: IdDb Id does not match the AfpInfo Id!!!\n"));

					// Unlink it from the hash-bucket since we have the wrong id.
					AfpUnlinkDouble(pDfEntry, dfe_NextOverflow, dfe_PrevOverflow);

					// If some other entity has this id, then assign a new one. Else
					// use the one from the AfpInfo stream.
					pDFE = AfpFindDfEntryById(pVolDesc, AfpInfo.afpi_Id, DFE_ANY);
					if (pDFE != NULL)
					{
						pDfEntry->dfe_AfpId = afpGetNextId(pVolDesc);
					}
					else
					{
						pDfEntry->dfe_AfpId = AfpInfo.afpi_Id;
					}

					// Re-insert it with the new id
                    afpInsertDFEInHashBucket(pVolDesc, pDfEntry, IsDir, &fSuccess);
				}

				// NOTE: should we set the finder invisible bit if the
				// hidden attribute is set so system 6 will obey the
				// hiddenness in finder?
				pDfEntry->dfe_FinderInfo = AfpInfo.afpi_FinderInfo;
				pDfEntry->dfe_BackupTime = AfpInfo.afpi_BackupTime;
				pDfEntry->dfe_AfpAttr = AfpInfo.afpi_Attributes;
			}
			else
			{
				// AfpInfo stream was newly created, or we could not read
				// the existing one because it was corrupt.  Create new
				// info for this file/dir. Trust the version from the IdDb
				AfpInitAfpInfo(&AfpInfo, pDfEntry->dfe_AfpId, IsDir, pDfEntry->dfe_BackupTime);
				AfpInfo.afpi_FinderInfo = pDfEntry->dfe_FinderInfo;
				AfpInfo.afpi_Attributes = pDfEntry->dfe_AfpAttr;
				if (IsDir)
				{
					// Keep track of see files vs. see folders
					AfpInfo.afpi_AccessOwner = DFE_OWNER_ACCESS(pDfEntry);
					AfpInfo.afpi_AccessGroup = DFE_GROUP_ACCESS(pDfEntry);
					AfpInfo.afpi_AccessWorld = DFE_WORLD_ACCESS(pDfEntry);
				}
				else
				{
					AfpProDosInfoFromFinderInfo(&AfpInfo.afpi_FinderInfo,
												&AfpInfo.afpi_ProDosInfo);
					pDfEntry->dfe_RescLen = 0;	// Assume no resource fork

					// if this is a Mac application, make sure there is an APPL
					// mapping for it.
					if (AfpInfo.afpi_FinderInfo.fd_TypeD == *(PDWORD)"APPL")
					{
						AfpAddAppl(pVolDesc,
								   pDfEntry->dfe_FinderInfo.fd_CreatorD,
								   0,
								   pDfEntry->dfe_AfpId,
								   True,
								   pDfEntry->dfe_Parent->dfe_AfpId);
					}
				}

				Status = AfpWriteAfpInfo(&fshAfpInfo, &AfpInfo);
				if (!NT_SUCCESS(Status))
				{
					// We failed to write the AfpInfo stream;
					Status = STATUS_UNSUCCESSFUL;
					break;
				}
			}

			// Check for comment and resource stream
			pStreams = AfpIoQueryStreams(&fshAfpInfo);
			if (pStreams == NULL)
			{
				Status = STATUS_NO_MEMORY;
				break;
			}

			for (pCurStream = pStreams, SeenComment = False;
				 pCurStream->si_StreamName.Buffer != NULL;
				 pCurStream++)
			{
				if (IS_COMMENT_STREAM(&pCurStream->si_StreamName))
				{
					DFE_SET_COMMENT(pDfEntry);
					SeenComment = True;
					if (IsDir)
						break;	// Scan no further for directories
				}
				else if (!IsDir && IS_RESOURCE_STREAM(&pCurStream->si_StreamName))
				{
					pDfEntry->dfe_RescLen = pCurStream->si_StreamSize.LowPart;
					if (SeenComment)
						break;	// We have all we need to
				}
			}

		} while (False);

		if (fshData.fsh_FileHandle != NULL)
		{
			AfpPutBackROAttr(&fshData, WriteBackROAttr);
			AfpIoClose(&fshData);
		}

		if (fshAfpInfo.fsh_FileHandle != NULL)
			AfpIoClose(&fshAfpInfo);

		if (pStreams != NULL)
			AfpFreeMemory(pStreams);

		if (!NT_SUCCESS(Status))
		{
			*ppDfEntry = NULL;
		}
		else
		{
			// If this is the root directory, make sure we do not blow away the
			// AFP_VOLUME_HAS_CUSTOM_ICON bit for NTFS Volume.
			if (DFE_IS_ROOT(pDfEntry) &&
				(pVolDesc->vds_Flags & AFP_VOLUME_HAS_CUSTOM_ICON))
			{
				// Don't bother writing back to disk since we do not
				// try to keep this in sync in the permanent afpinfo
				// stream with the actual existence of the icon<0d> file.
				pDfEntry->dfe_FinderInfo.fd_Attr1 |= FINDER_FLAG_HAS_CUSTOM_ICON;
			}
		}
	}
}


/***	afpAddDfEntryAndCacheInfo
 *
 *	During the initial sync with disk on volume startup, add each entry
 *  we see during enumerate to the id index database.
 */
VOID
afpAddDfEntryAndCacheInfo(
	IN	PVOLDESC					pVolDesc,
	IN	PDFENTRY					pParentDfe,
	IN	PUNICODE_STRING 			pUName,			// munged unicode name
	IN  PFILESYSHANDLE				pfshEnumDir,	// open handle to parent directory
    IN	PFILE_BOTH_DIR_INFORMATION	pFBDInfo,		// from enumerate
	IN	PUNICODE_STRING				pNotifyPath, 	// For Afpinfo Stream
	IN	PDFENTRY	*				ppDfEntry,
	IN	BOOLEAN						CheckDuplicate
)
{
	BOOLEAN			IsDir, SeenComment, WriteBackROAttr = False;
	NTSTATUS		Status = STATUS_SUCCESS;
	FILESYSHANDLE		fshAfpInfo, fshData;
	DWORD			crinfo, openoptions = 0;
	PDFENTRY		pDfEntry;
	AFPINFO			AfpInfo;
	FINDERINFO		FinderInfo;
	PSTREAM_INFO	pStreams = NULL, pCurStream;
    UNICODE_STRING  EmptyString;
    DWORD           NTAttr = 0;
    TIME            ModTime;
    DWORD           ModMacTime;


	PAGED_CODE();

	fshAfpInfo.fsh_FileHandle = NULL;
	fshData.fsh_FileHandle	= NULL;

	IsDir = (pFBDInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? True : False;

	do
	{
		if (IS_VOLUME_NTFS(pVolDesc))
		{
			if (IsDir || CheckDuplicate)
			{
				// Make sure we don't already have this item in our database.
				// Multiple notifies for the same item could possibly occur if
				// the PC is renaming or moving items around on the disk, or
				// copying trees while we are trying to cache it, since we are
				// also queueing up private notifies for directories.

				afpFindDFEByUnicodeNameInSiblingList_CS(pVolDesc,
														pParentDfe,
														pUName,
														&pDfEntry,
														IsDir ? DFE_DIR : DFE_FILE);
				if (pDfEntry != NULL)
				{
					Status = AFP_ERR_OBJECT_EXISTS;
					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_WARN,
						("afpAddDfEntryAndCacheInfo: Attempt to add a duplicate entry: %Z\n", pUName));
					break;
				}
			}

			openoptions = IsDir ? FILEIO_OPEN_DIR : FILEIO_OPEN_FILE;
			if (NT_SUCCESS(AfpIoOpen(pfshEnumDir,
									 AFP_STREAM_DATA,
									 openoptions,
									 pUName,
									 FILEIO_ACCESS_NONE,
									 FILEIO_DENY_NONE,
									 False,
									 &fshData)))
			{
                // save the LastModify time on the data stream of the file: we need to restore it
                AfpIoQueryTimesnAttr(&fshData,
                                     NULL,
                                     &ModTime,
                                     &NTAttr);

                ModMacTime = AfpConvertTimeToMacFormat(&ModTime);
            }
            else
            {
                // if we can't open the data file, just skip this entry!
                Status = STATUS_UNSUCCESSFUL;
	            DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
	                ("Couldn't open data stream for %Z\n", pUName));
                break;
            }


            AfpSetEmptyUnicodeString(&EmptyString, 0, NULL);

			// open or create the AfpInfo stream
			if (!NT_SUCCESS(AfpCreateAfpInfoWithNodeName(&fshData,
														 &EmptyString,
														 pNotifyPath,
														 pVolDesc,
														 &fshAfpInfo,
														 &crinfo)))
			{
				if (!(pFBDInfo->FileAttributes & FILE_ATTRIBUTE_READONLY))
				{
					// What other reason is there that we could not open
					// this stream except that this file/dir is readonly?
					Status = STATUS_UNSUCCESSFUL;
					break;
				}

				Status = STATUS_UNSUCCESSFUL;	// Assume failure
				if (NT_SUCCESS(AfpExamineAndClearROAttr(&fshData,
														&WriteBackROAttr,
														pVolDesc,
														pNotifyPath)))
				{
					if (NT_SUCCESS(AfpCreateAfpInfo(&fshData,
													&fshAfpInfo,
													&crinfo)))
					{
						Status = STATUS_SUCCESS;
					}
				}

				if (!NT_SUCCESS(Status))
				{
					// Skip this entry if you cannot get to the AfpInfo, cannot
					// clear the RO attribute or whatever.
					break;
				}
			}

			// We successfully opened or created the AfpInfo stream.  If
			// it existed, then validate the ID, otherwise create all new
			// Afpinfo for this file/dir.
			if ((crinfo == FILE_OPENED) &&
				(NT_SUCCESS(AfpReadAfpInfo(&fshAfpInfo, &AfpInfo))))
			{
				// the file/dir had an AfpInfo stream on it
				afpCheckDfEntry(pVolDesc,
								AfpInfo.afpi_Id,
								pUName,
								IsDir,
								pParentDfe,
								&pDfEntry);

				if (pDfEntry == NULL)
				{
					Status = STATUS_UNSUCCESSFUL;
					break;
				}

				if (pDfEntry->dfe_AfpId != AfpInfo.afpi_Id)
				{
					// Write out the AFP_AfpInfo with the new AfpId
					// and uninitialized icon coordinates
					AfpInfo.afpi_Id = pDfEntry->dfe_AfpId;
					AfpInfo.afpi_FinderInfo.fd_Location[0] =
					AfpInfo.afpi_FinderInfo.fd_Location[1] =
					AfpInfo.afpi_FinderInfo.fd_Location[2] =
					AfpInfo.afpi_FinderInfo.fd_Location[3] = 0xFF;
					AfpInfo.afpi_FinderInfo.fd_Attr1 &= ~FINDER_FLAG_SET;

					if (!NT_SUCCESS(AfpWriteAfpInfo(&fshAfpInfo, &AfpInfo)))
					{
						// We failed to write the AfpInfo stream;
						// delete the thing from the database
						AfpDeleteDfEntry(pVolDesc, pDfEntry);
						Status = STATUS_UNSUCCESSFUL;
						break;
					}
				}

				// NOTE: should we set the finder invisible bit if the
				// hidden attribute is set so system 6 will obey the
				// hiddenness in finder?
				pDfEntry->dfe_FinderInfo = AfpInfo.afpi_FinderInfo;
				pDfEntry->dfe_BackupTime = AfpInfo.afpi_BackupTime;
				pDfEntry->dfe_AfpAttr = AfpInfo.afpi_Attributes;
			}
			else
			{
				// AfpInfo stream was newly created, or we could not read
				// the existing one because it was corrupt.  Create new
				// info for this file/dir
				pDfEntry = AfpAddDfEntry(pVolDesc,
										pParentDfe,
										pUName,
										IsDir,
										0);
				if (pDfEntry == NULL)
				{
					Status = STATUS_UNSUCCESSFUL;
					break;
				}

				if (NT_SUCCESS(AfpSlapOnAfpInfoStream(pVolDesc,
													  pNotifyPath,
													  NULL,
													  &fshAfpInfo,
													  pDfEntry->dfe_AfpId,
													  IsDir,
													  pUName,
													  &AfpInfo)))
				{
					// NOTE: should we set the finder invisible bit if the
					// hidden attribute is set so system 6 will obey the
					// hiddenness in finder?
					pDfEntry->dfe_FinderInfo = AfpInfo.afpi_FinderInfo;
					pDfEntry->dfe_BackupTime = AfpInfo.afpi_BackupTime;
					pDfEntry->dfe_AfpAttr = AfpInfo.afpi_Attributes;
				}
				else
				{
					// We failed to write the AfpInfo stream;
					// delete the thing from the database
					AfpDeleteDfEntry(pVolDesc, pDfEntry);
					Status = STATUS_UNSUCCESSFUL;
					break;
				}
			}

			ASSERT(pDfEntry != NULL);

			if (IsDir)
			{
				// Keep track of see files vs. see folders
				DFE_OWNER_ACCESS(pDfEntry) = AfpInfo.afpi_AccessOwner;
				DFE_GROUP_ACCESS(pDfEntry) = AfpInfo.afpi_AccessGroup;
				DFE_WORLD_ACCESS(pDfEntry) = AfpInfo.afpi_AccessWorld;
			}
			else
			{
				// it's a file

				pDfEntry->dfe_RescLen = 0;	// Assume no resource fork

				// if this is a Mac application, make sure there is an APPL
				// mapping for it.
				if (AfpInfo.afpi_FinderInfo.fd_TypeD == *(PDWORD)"APPL")
				{
					AfpAddAppl(pVolDesc,
							   AfpInfo.afpi_FinderInfo.fd_CreatorD,
							   0,
							   pDfEntry->dfe_AfpId,
							   True,
							   pDfEntry->dfe_Parent->dfe_AfpId);
				}
			}

			// Check for comment and resource stream
			pStreams = AfpIoQueryStreams(&fshAfpInfo);
			if (pStreams == NULL)
			{
				Status = STATUS_NO_MEMORY;
				break;
			}

			for (pCurStream = pStreams, SeenComment = False;
				 pCurStream->si_StreamName.Buffer != NULL;
				 pCurStream++)
			{
				if (IS_COMMENT_STREAM(&pCurStream->si_StreamName))
				{
					DFE_SET_COMMENT(pDfEntry);
					SeenComment = True;
					if (IsDir)
						break;	// Scan no further for directories
				}
				else if (!IsDir && IS_RESOURCE_STREAM(&pCurStream->si_StreamName))
				{
					pDfEntry->dfe_RescLen = pCurStream->si_StreamSize.LowPart;
					if (SeenComment)
						break;	// We have all we need to
				}
			}
			AfpFreeMemory(pStreams);
		}
		else // CDFS
		{
			pDfEntry = AfpAddDfEntry(pVolDesc,
									 pParentDfe,
									 pUName,
									 IsDir,
									 0);

            if (pDfEntry == NULL)
            {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            RtlZeroMemory(&FinderInfo, sizeof(FINDERINFO));
            RtlZeroMemory(&pDfEntry->dfe_FinderInfo, sizeof(FINDERINFO));
			pDfEntry->dfe_BackupTime = BEGINNING_OF_TIME;
			pDfEntry->dfe_AfpAttr = 0;

			if (IsDir)
			{
				DFE_OWNER_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);
				DFE_GROUP_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);
				DFE_WORLD_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);
			}

			if (IS_VOLUME_CD_HFS(pVolDesc))
			{
    		    Status = AfpIoOpen(pfshEnumDir,
				            AFP_STREAM_DATA,
				            openoptions,
				            pUName,
				            FILEIO_ACCESS_NONE,
				            FILEIO_DENY_NONE,
				            False,
				            &fshData);
			    if (!NT_SUCCESS(Status))
			    {
				    DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
				      ("afpAddDfEntryAndCacheInfo: AfpIoOpen on %Z failed (%lx) for CD_HFS\n", pUName,Status));
			        break;
			    }

			    pDfEntry->dfe_RescLen = 0;

			    // if it's a file...

                if (!IsDir)
                {
    		        // if this is a Mac application, make sure there is an APPL
    			    // mapping for it.
    			    if (FinderInfo.fd_TypeD == *(PDWORD)"APPL")
			        {
    			        AfpAddAppl( pVolDesc,
				    	            FinderInfo.fd_CreatorD,
				                    0,
    				                pDfEntry->dfe_AfpId,
	    			                True,
		    		                pDfEntry->dfe_Parent->dfe_AfpId);
			        }

			        // Check for resource stream
			        pStreams = AfpIoQueryStreams(&fshData);
			        if (pStreams == NULL)
			        {
        			    Status = STATUS_NO_MEMORY;
			            break;
			        }

    			    for (pCurStream = pStreams;
        			    pCurStream->si_StreamName.Buffer != NULL;
		    	        pCurStream++)
			        {
    			        if (IS_RESOURCE_STREAM(&pCurStream->si_StreamName))
			            {
    			            pDfEntry->dfe_RescLen = pCurStream->si_StreamSize.LowPart;
				            break;
			            }
			        }

			        AfpFreeMemory(pStreams);
                }
			}
			// NOTE: if CdHfs doesn't have finder info, should we check for
			// that and set it ourselves using AfpSetFinderInfoByExtension?

			else
			{
    		    AfpSetFinderInfoByExtension(pUName, &pDfEntry->dfe_FinderInfo);
			    pDfEntry->dfe_RescLen = 0;
			}
			
		}

		// Record common NTFS & CDFS information
		pDfEntry->dfe_CreateTime = AfpConvertTimeToMacFormat(&pFBDInfo->CreationTime);
		pDfEntry->dfe_LastModTime = pFBDInfo->LastWriteTime;
		pDfEntry->dfe_NtAttr = (USHORT)pFBDInfo->FileAttributes & FILE_ATTRIBUTE_VALID_FLAGS;


        // if this is an HFS volume, check if Finder says file should be invisible
		if (IS_VOLUME_CD_HFS(pVolDesc))
        {
            if (pDfEntry->dfe_FinderInfo.fd_Attr1 & FINDER_FLAG_INVISIBLE)
            {
		        pDfEntry->dfe_NtAttr |= FILE_ATTRIBUTE_HIDDEN;
            }
        }

		if (!IsDir)
		{
			pDfEntry->dfe_DataLen = pFBDInfo->EndOfFile.LowPart;
		}

		ASSERT(pDfEntry != NULL);
	} while (False); // error handling loop

	if (fshAfpInfo.fsh_FileHandle != NULL)
    {
		AfpIoClose(&fshAfpInfo);

        // NTFS will set the LastModify time to current time on file since we modified the
        // AfpInfo stream: restore the original time
		if (!IsDir)
        {
            // force ntfs to "flush" any pending time updates before we reset the time
            AfpIoChangeNTModTime(&fshData,
                                 &ModTime);

            AfpIoSetTimesnAttr(&fshData,
                               NULL,
                               &ModMacTime,
                               0,
                               0,
                               NULL,
                               NULL);
        }
    }

	if (fshData.fsh_FileHandle != NULL)
	{
		if (IS_VOLUME_NTFS(pVolDesc))
		{
		    AfpPutBackROAttr(&fshData, WriteBackROAttr);
		}
		AfpIoClose(&fshData);
	}


	if (!NT_SUCCESS(Status))
	{
		pDfEntry = NULL;
	}

	*ppDfEntry = pDfEntry;
}


/***	afpReadIdDb
 *
 *	This is called when a volume is added, if an existing Afp_IdIndex stream
 *	is found on the root of the volume.  The stream is is read in, the
 *	VolDesc is initialized with the header image on disk, and the
 *	IdDb sibling tree/hash tables are created from the data on disk.
 *
**/
LOCAL NTSTATUS FASTCALL
afpReadIdDb(
	IN	PVOLDESC		pVolDesc,
	IN	PFILESYSHANDLE	pfshIdDb,
	OUT	BOOLEAN *       pfVerifyIndex
)
{
	PBYTE					pReadBuf;
	PIDDBHDR				pIdDbHdr;
	NTSTATUS				Status;
	LONG					SizeRead = 0, Count;
	FORKOFFST				ForkOffst;
	UNICODE_STRING			uName;
	UNALIGNED DISKENTRY	*	pCurDiskEnt = NULL;
	DWORD					NameLen, CurEntSize, SizeLeft;
	LONG					i, NumRead = 0;
	PDFENTRY				pParentDfe = NULL, pCurDfe = NULL;
    struct _DirFileEntry ** DfeDirBucketStart;
	BOOLEAN					LastBuf = False, ReadDb = False;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
			("afpReadIdDb: Reading existing Id Database header stream...\n") );

	do
	{
		if ((pReadBuf = AfpAllocPANonPagedMemory(IDDB_UPDATE_BUFLEN)) == NULL)
		{
			Status=STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		pIdDbHdr = (PIDDBHDR)pReadBuf;

		// read in the header
		Status = AfpIoRead(pfshIdDb,
						   &LIZero,
						   IDDB_UPDATE_BUFLEN,
						   &SizeRead,
						   (PBYTE)pIdDbHdr);

		if (!NT_SUCCESS(Status)									||
			(SizeRead < sizeof(IDDBHDR))						||
			(pIdDbHdr->idh_Signature == AFP_SERVER_SIGNATURE_INITIDDB)	||
			(pIdDbHdr->idh_LastId < AFP_ID_NETWORK_TRASH))
		{
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
				("Index database corrupted for volume %Z, rebuilding database\n",
                &pVolDesc->vds_Name) );

            DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
                    ("Read sign = %lx, True sign = %lx\n", 
                     pIdDbHdr->idh_Signature, AFP_SERVER_SIGNATURE));

			// just recreate the stream
			Status = AFP_ERR_BAD_VERSION;
			AfpIoSetSize(pfshIdDb, 0);
		}
		else
		{
			if (pIdDbHdr->idh_Version == AFP_IDDBHDR_VERSION)
			{
                if ((pIdDbHdr->idh_Signature != AFP_SERVER_SIGNATURE) &&
                    (pIdDbHdr->idh_Signature != AFP_SERVER_SIGNATURE_MANUALSTOP))
                {
                    DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
                            ("afpreadiddb: Totally corrupt sign = (%lx), required sign = (%lx)\n", 
                             pIdDbHdr->idh_Signature, AFP_SERVER_SIGNATURE));

                    // just recreate the stream
                    Status = AFP_ERR_BAD_VERSION;
                    AfpIoSetSize(pfshIdDb, 0);
                }
                else
                {
			        if (pIdDbHdr->idh_Signature == AFP_SERVER_SIGNATURE_MANUALSTOP)	
                    {
				        DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
					        ("afpreadIdDb: **** Need to verify index after reading it\n"));
                        *pfVerifyIndex = True;
                    }

                    AfpIdDbHdrToVolDesc(pIdDbHdr, pVolDesc);
    		        if (SizeRead < (sizeof(IDDBHDR) + sizeof(DWORD)))
			        {
				        DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
						        ("afpreadIdDb: Size incorrect\n"));
				        Count = 0;
				        Status = STATUS_END_OF_FILE;
			        }
			        else
			        {
				        Count = *(PDWORD)(pReadBuf + sizeof(IDDBHDR));
				        if (Count != 0)
                           {
					        ReadDb = True;
                           }
				        else
				        {
					        Status = STATUS_END_OF_FILE;
					        DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							        ("afpreadIdDb: Count incorrect\n"));
				        }
			        }
                }
                    
			}
			else if ((pIdDbHdr->idh_Version != AFP_IDDBHDR_VERSION1) &&
					 (pIdDbHdr->idh_Version != AFP_IDDBHDR_VERSION2) &&
					 (pIdDbHdr->idh_Version != AFP_IDDBHDR_VERSION3) &&
					 (pIdDbHdr->idh_Version != AFP_IDDBHDR_VERSION4))
			{
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
					("afpreadIdDb: Bad Version (expected %x, actual %x)\n",
                    AFP_IDDBHDR_VERSION,pIdDbHdr->idh_Version));

				// just recreate the stream
				AfpIoSetSize(pfshIdDb, 0);
				Status = AFP_ERR_BAD_VERSION;
			}
			else
			{
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
                    ("afpreadIdDb: Downlevel Version, re-index volume\n"));

				Status = STATUS_END_OF_FILE;

				AfpIdDbHdrToVolDesc(pIdDbHdr, pVolDesc);

				// Dont blow away the header
				AfpIoSetSize(pfshIdDb, sizeof(IDDBHDR));

                AFPLOG_INFO(AFPSRVMSG_UPDATE_INDEX_VERSION,
                            STATUS_SUCCESS,
                            NULL,
                            0,
                            &pVolDesc->vds_Name);

			}
		}

		if (!NT_SUCCESS(Status) || !ReadDb || (Count == 0))
		{
			break;
		}

		// read the count of entries from the stream
		ForkOffst.QuadPart = SizeRead;
		SizeLeft = SizeRead - (sizeof(IDDBHDR) + sizeof(DWORD));
		pCurDiskEnt = (UNALIGNED DISKENTRY *)(pReadBuf + (sizeof(IDDBHDR) + sizeof(DWORD)));

		// Start the database with the PARENT_OF_ROOT
		// At this point there is only the ParentOfRoot DFE in the volume.
		// Just access it rather can calling AfpFindDfEntryById

        DfeDirBucketStart = pVolDesc->vds_pDfeDirBucketStart;
		pParentDfe = DfeDirBucketStart[AFP_ID_PARENT_OF_ROOT];

		ASSERT (pParentDfe != NULL);
		ASSERT (pParentDfe->dfe_AfpId == AFP_ID_PARENT_OF_ROOT);

		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("afpreadIdDb: Number of entries %d\n", Count));

		while ((NumRead < Count) &&
			   ((pVolDesc->vds_Flags & (VOLUME_STOPPED | VOLUME_DELETED)) == 0))
		{
			//
			// get the next entry
			//

			// We ensure that there are no partial entries. If an entry does not fit at
			// the end, we write an invalid entry (AfpId == 0) and skip to the next
			// buffer.
			if ((SizeLeft < (sizeof(DISKENTRY)))  || (pCurDiskEnt->dsk_AfpId == 0))
			{
				if (LastBuf) // we have already read to the end of file
				{
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							("afpreadIdDb: Reached EOF\n"));
					Status = STATUS_UNSUCCESSFUL;
					break;
				}

				// Skip to the next page and continue with the next entry
				Status = AfpIoRead(pfshIdDb,
								   &ForkOffst,
								   IDDB_UPDATE_BUFLEN,
								   &SizeRead,
								   pReadBuf);

				if (!NT_SUCCESS(Status))
				{
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							("afpreadIdDb: Read Eror %lx\n", Status));
					break;
				}

				ForkOffst.QuadPart += SizeRead;
				// if we read less than we asked for, then we reached EOF
				LastBuf = (SizeRead < IDDB_UPDATE_BUFLEN) ? True : False;
				SizeLeft = SizeRead;
				pCurDiskEnt = (UNALIGNED DISKENTRY *)pReadBuf;
				continue;
			}

			//
			// check dsk_Signature for signature, just to be sure you are
			// still aligned on a structure and not off in la-la land
			//
			if (pCurDiskEnt->dsk_Signature != AFP_DISKENTRY_SIGNATURE)
			{
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
						("afpreadIdDb: Signature mismatch\n"));
				Status = STATUS_DATATYPE_MISALIGNMENT;
				break;
			}

			ASSERT(pCurDiskEnt->dsk_AfpId != AFP_ID_NETWORK_TRASH);

			// add current entry to database
			if (pCurDiskEnt->dsk_AfpId != AFP_ID_ROOT)
			{
				AfpInitUnicodeStringWithNonNullTerm(&uName,
													(pCurDiskEnt->dsk_Flags & DFE_FLAGS_NAMELENBITS) * sizeof(WCHAR),
													(PWSTR)(pCurDiskEnt->dsk_Name));
			}
			else
			{
				// In case someone has reused a directory with an existing
				// AFP_IdIndex stream for a different volume name
				uName = pVolDesc->vds_Name;
			}

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
					("afpReadIdDb: Read %d: %Z\n", 
					 pCurDiskEnt->dsk_AfpId,
					&uName));

			if ((pCurDfe = AfpAddDfEntry(pVolDesc,
										 pParentDfe,
										 &uName,
										 (BOOLEAN)((pCurDiskEnt->dsk_Flags & DFE_FLAGS_DIR) == DFE_FLAGS_DIR),
										 pCurDiskEnt->dsk_AfpId)) == NULL)
			{
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
						("afpreadIdDb: AfpAddDfEntry failed for %Z (ParentId %x)\n",
						 &uName, pParentDfe->dfe_AfpId));
				Status = STATUS_UNSUCCESSFUL;
				break;
			}

			// Initialize pointer to root.
			if (DFE_IS_ROOT(pCurDfe))
			{
				pVolDesc->vds_pDfeRoot = pCurDfe;
			}

			afpUpdateDfeWithSavedData(pCurDfe, pCurDiskEnt);

			NameLen = (DWORD)((pCurDiskEnt->dsk_Flags & DFE_FLAGS_NAMELENBITS)*sizeof(WCHAR));
			CurEntSize = DWLEN(FIELD_OFFSET(DISKENTRY, dsk_Name) + NameLen);

			NumRead ++;
			SizeLeft -= CurEntSize;
			pCurDiskEnt = (UNALIGNED DISKENTRY *)((PBYTE)pCurDiskEnt + CurEntSize);

			// figure out who the next parent should be
			if (pCurDfe->dfe_Flags & DFE_FLAGS_HAS_CHILD)
			{
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
						("afpreadIdDb: Moving down %Z\n", &pCurDfe->dfe_UnicodeName));
				pParentDfe = pCurDfe;
			}
			else if (!(pCurDfe->dfe_Flags & DFE_FLAGS_HAS_SIBLING))
			{
				if (DFE_IS_PARENT_OF_ROOT(pParentDfe))
				{
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
							("afpreadIdDb: Done, NumRead %d, Count %d\n", NumRead, Count));
					ASSERT(NumRead == Count);
					break;
				}
				while (!(pParentDfe->dfe_Flags & DFE_FLAGS_HAS_SIBLING))
				{
					if (DFE_IS_ROOT(pParentDfe))
					{
						break;
					}
					pParentDfe = pParentDfe->dfe_Parent;
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
							("afpreadIdDb: Moving up\n"));
				}
				pParentDfe = pParentDfe->dfe_Parent;
				if (DFE_IS_PARENT_OF_ROOT(pParentDfe))
				{
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
							("afpreadIdDb: Reached Id 1\n"));
					ASSERT(NumRead == Count);
					break;
				}
			}
		} // while

		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("Indexing: Read %ld entries (%lx)\n", NumRead,Status) );

		if (!NT_SUCCESS(Status))
		{
		
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
				("afpReadIdDb: Indexing: Starting all over\n"));

			// Free everything and start over
			AfpFreeIdIndexTables(pVolDesc);
			afpInitializeIdDb(pVolDesc);
		}

	} while (False);

	if (pReadBuf != NULL)
		AfpFreePANonPagedMemory(pReadBuf, IDDB_UPDATE_BUFLEN);

	return Status;
}


VOID
AfpGetDirFileHashSizes(
	IN	PVOLDESC			pVolDesc,
    OUT PDWORD              pdwDirHashSz,
    OUT PDWORD              pdwFileHashSz
)
{

    FILESYSHANDLE   fshIdDb;
    ULONG           CreateInfo;
    PBYTE           pReadBuf=NULL;
    PIDDBHDR        pIdDbHdr;
    DWORD           dwDirFileCount=0;
    DWORD           dwTemp;
    DWORD           dwDirHshTblLen, dwFileHshTblLen;
    LONG            SizeRead=0;
    NTSTATUS        Status;
    BOOLEAN         fFileOpened=FALSE;


    // in case we bail out..
    *pdwDirHashSz = IDINDEX_BUCKETS_DIR_INIT;
    *pdwFileHashSz = IDINDEX_BUCKETS_FILE_INIT;

    if (!IS_VOLUME_NTFS(pVolDesc))
    {
        goto AfpGetDirFileCount_Exit;
    }

    if ((pReadBuf = AfpAllocNonPagedMemory(1024)) == NULL)
    {
        goto AfpGetDirFileCount_Exit;
    }

	Status = AfpIoCreate(&pVolDesc->vds_hRootDir,
						AFP_STREAM_IDDB,
						&UNullString,
						FILEIO_ACCESS_READWRITE,
						FILEIO_DENY_WRITE,
						FILEIO_OPEN_FILE_SEQ,
						FILEIO_CREATE_INTERNAL,
						FILE_ATTRIBUTE_NORMAL,
						False,
						NULL,
						&fshIdDb,
						&CreateInfo,
						NULL,
						NULL,
						NULL);

	if (!NT_SUCCESS(Status))
	{
        DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
            ("AfpGetDirFileHashSizes: AfpIoCreate failed %lx for %Z\n",Status,&pVolDesc->vds_Name));
        goto AfpGetDirFileCount_Exit;
	}

    fFileOpened = TRUE;

    // if the file just got created, it didn't exist before!
    if (CreateInfo != FILE_OPENED)
    {
        DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
            ("AfpGetDirFileHashSizes: file created, not opened %d for %Z\n",CreateInfo,&pVolDesc->vds_Name));
        goto AfpGetDirFileCount_Exit;
    }

    //
    // if we reached here, it means that the file existed before, which means
    // we made an effort earlier to index this volume.  We are going to read the
    // dwDirFileCount and calcualte the hash table sizes, but for now let's
    // initiliaze this to a high value
    //
    *pdwDirHashSz = IDINDEX_BUCKETS_32K;
    *pdwFileHashSz = IDINDEX_BUCKETS_32K;

	// read in the header
	Status = AfpIoRead(&fshIdDb,
					   &LIZero,
					   1024,
					   &SizeRead,
					   pReadBuf);

    pIdDbHdr = (PIDDBHDR)pReadBuf;

	if (!NT_SUCCESS(Status)									||
		(SizeRead < (sizeof(IDDBHDR) + sizeof(DWORD)))		||
		((pIdDbHdr->idh_Signature != AFP_SERVER_SIGNATURE)  &&
		(pIdDbHdr->idh_Signature != AFP_SERVER_SIGNATURE_MANUALSTOP)))
	{
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
			("Reading DirFileCount: database corrupted for volume %Z!\n",
            &pVolDesc->vds_Name) );

        goto AfpGetDirFileCount_Exit;
	}
	else if (pIdDbHdr->idh_Version == AFP_IDDBHDR_VERSION)
	{
		dwDirFileCount = *(PDWORD)(pReadBuf + sizeof(IDDBHDR));

        DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
   	        ("Reading DirFileCount = %d!\n",dwDirFileCount));
	}


AfpGetDirFileCount_Exit:

    if (fFileOpened)
    {
        AfpIoClose(&fshIdDb);
    }

    if (pReadBuf)
    {
        AfpFreeMemory(pReadBuf);
    }

    if (dwDirFileCount == 0)
    {
        return;
    }

    //
    // first calculate the size of hashtable for Dirs
    // We assume here that 10% of the (files+directories) are directories
    // We want to try and keep no more than 20 nodes per hash bucket
    //
    dwDirHshTblLen = (dwDirFileCount / 10);
    dwDirHshTblLen = (dwDirHshTblLen / 20);

    if (dwDirHshTblLen <= IDINDEX_BUCKETS_DIR_MIN)
    {
        dwDirHshTblLen = IDINDEX_BUCKETS_DIR_MIN;
    }
    else if (dwDirHshTblLen >= IDINDEX_BUCKETS_MAX)
    {
        dwDirHshTblLen = IDINDEX_BUCKETS_MAX;
    }
    else
    {
        // find the smallest power of 2 that's bigger than dwDirHshTblLen
        dwTemp = IDINDEX_BUCKETS_MAX;
        while (dwDirHshTblLen < dwTemp)
        {
            dwTemp /= 2;
        }

        dwDirHshTblLen = 2*dwTemp;
    }

    //
    // now, calculate the size of hashtable for Files
    // (even though we should take 90% as number of files, we keep it that way!)
    // We want to try and keep no more than 20 nodes per hash bucket
    //
    dwFileHshTblLen = (dwDirFileCount / 20);

    if (dwFileHshTblLen <= IDINDEX_BUCKETS_FILE_MIN)
    {
        dwFileHshTblLen = IDINDEX_BUCKETS_FILE_MIN;
    }
    else if (dwFileHshTblLen >= IDINDEX_BUCKETS_MAX)
    {
        dwFileHshTblLen = IDINDEX_BUCKETS_MAX;
    }
    else
    {
        // find the smallest power of 2 that's bigger than dwFileHshTblLen
        dwTemp = IDINDEX_BUCKETS_MAX;

        while (dwFileHshTblLen < dwTemp)
        {
            dwTemp /= 2;
        }

        dwFileHshTblLen = 2*dwTemp;
    }

    *pdwDirHashSz = dwDirHshTblLen;
    *pdwFileHashSz = dwFileHshTblLen;
}

/***	AfpFlushIdDb
 *
 *	Initiated by the scavenger thread. If it is determined that the Afp_IdIndex
 *	stream for this volume is to be flushed to disk, then this is called to
 *	do the job. The swmr access is locked for read while the update is in
 *	progress. The vds_cScvgrIdDb and vds_cChangesIdDb are reset if there is
 *	no error writing the entire database.  An initial count of zero is written
 *	to the database before it is updated, just in case an error occurs that
 *	prevents us from writing the entire database.  When the entire thing is
 *	written, then the actual count of entries is written to disk.  The
 *	parent-of-root entry is never saved on disk, nor is the network trash
 *	subtree of the database. The iddb header is written whether it is dirty
 *	or not.
 *
 *	LOCKS:			vds_VolLock (SPIN)
 *	LOCKS_ASSUMED:	vds_idDbAccessLock (SWMR, Shared)
 *	LOCK_ORDER:		vds_VolLock after vds_IdDbAccessLock
 */
VOID FASTCALL
AfpFlushIdDb(
	IN	PVOLDESC			pVolDesc,
	IN	PFILESYSHANDLE		phIdDb
)
{
	PBYTE					pWriteBuf;
	NTSTATUS				Status;
	BOOLEAN					WriteEntireHdr = False;
	PDFENTRY				pCurDfe;
	DWORD					SizeLeft;	// the number of free bytes left in the writebuffer
	DWORD					CurEntSize, NumWritten = 0;
	FORKOFFST				ForkOffst;
	UNALIGNED DISKENTRY	*	pCurDiskEnt = NULL;
	PIDDBHDR				pIdDbHdr;
	BOOLEAN					HdrDirty = False;
	KIRQL					OldIrql;
	DWORD					fbi = 0, CreateInfo;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;

	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_IdIndexUpdCount);
	AfpGetPerfCounter(&TimeS);
#endif

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,("\tWriting out IdDb...\n") );
	ASSERT(VALID_VOLDESC(pVolDesc));


	// Take the Swmr so that nobody can initiate changes to the IdDb
	AfpSwmrAcquireShared(&pVolDesc->vds_IdDbAccessLock);

	do
	{
		if ((pWriteBuf = AfpAllocPANonPagedMemory(IDDB_UPDATE_BUFLEN)) == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		pIdDbHdr = (PIDDBHDR)pWriteBuf;

		// Snapshot the IdDbHdr and dirty bit
		ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

		AfpVolDescToIdDbHdr(pVolDesc, pIdDbHdr);
        if (!fAfpServerShutdownEvent)
        {
            DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
                        ("AfpFlushIdDb: Corrupting signature during scavenger run\n"));

            // If server going down due to admin stop, indicate it
            // with a unique signature

            if (fAfpAdminStop)
            {
            	pIdDbHdr->idh_Signature = AFP_SERVER_SIGNATURE_MANUALSTOP;
            }
            else
            {
            	pIdDbHdr->idh_Signature = AFP_SERVER_SIGNATURE_INITIDDB;
            }
        }

		if (pVolDesc->vds_Flags & VOLUME_IDDBHDR_DIRTY)
		{
			HdrDirty = True;
			// Clear the dirty bit
			pVolDesc->vds_Flags &= ~VOLUME_IDDBHDR_DIRTY;
		}

		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

		// Set the count of entries to zero. Once we are done, we'll then
		// overwrite it with the right value
		*(PDWORD)(pWriteBuf + sizeof(IDDBHDR)) = 0;

   		// Set the pointer to the first entry we'll write past the header and
		// the count of entries. Adjust space remaining.
		pCurDiskEnt = (UNALIGNED DISKENTRY *)(pWriteBuf + sizeof(IDDBHDR) + sizeof(DWORD));
		SizeLeft = IDDB_UPDATE_BUFLEN - (sizeof(IDDBHDR) + sizeof(DWORD));
		ForkOffst.QuadPart = 0;

		// start with the root (don't write out the parent of root)
		pCurDfe = pVolDesc->vds_pDfeRoot;
		ASSERT(pCurDfe != NULL);

		Status = STATUS_SUCCESS;

        DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
            ("AfpFlushIdDb: writing index file for vol %Z started..\n",&pVolDesc->vds_Name));
		do
		{
			ASSERT(!DFE_IS_NWTRASH(pCurDfe));

			// The size of the current entry is:
			//	DISKENTRY structure + namelen padded to 4*N
			CurEntSize = DWLEN(FIELD_OFFSET(DISKENTRY, dsk_Name) + pCurDfe->dfe_UnicodeName.Length);
			if (CurEntSize > SizeLeft)
			{
				// If there is atleast a DWORD left, write a ZERO there to
				// indicate that the rest of the buffer is to be skipped.
				// ZERO is an invalid AfpId.
				// NOTE: dsk_AfpId NEEDS TO BE THE FIRST FIELD IN THE STRUCT
				ASSERT(FIELD_OFFSET(DISKENTRY, dsk_AfpId) == 0);

				if (SizeLeft > 0)
				{
					RtlZeroMemory(pWriteBuf + IDDB_UPDATE_BUFLEN - SizeLeft,
								  SizeLeft);
				}

				// write out the buffer and start at the beginning of buffer
				Status = AfpIoWrite(phIdDb,
									&ForkOffst,
									IDDB_UPDATE_BUFLEN,
									pWriteBuf);
				if (!NT_SUCCESS(Status))
				{
					// Reset the dirty bit if need be
					if (HdrDirty && (ForkOffst.QuadPart == 0))
					{
						AfpInterlockedSetDword(&pVolDesc->vds_Flags,
												VOLUME_IDDBHDR_DIRTY,
												&pVolDesc->vds_VolLock);
					}
					break;
				}
				ForkOffst.QuadPart += IDDB_UPDATE_BUFLEN;
				SizeLeft = IDDB_UPDATE_BUFLEN;
				pCurDiskEnt = (UNALIGNED DISKENTRY *)pWriteBuf;
			}

			NumWritten ++;
			afpSaveDfeData(pCurDfe, pCurDiskEnt);

			if (DFE_IS_DIRECTORY(pCurDfe))
			{
				PDIRENTRY	pDirEntry = pCurDfe->dfe_pDirEntry;

				pCurDiskEnt->dsk_RescLen = 0;

				pCurDiskEnt->dsk_Access = *(PDWORD)(&pDirEntry->de_Access);
				ASSERT (pCurDfe->dfe_pDirEntry != NULL);

				if ((pCurDfe->dfe_FileOffspring > 0)	||
					(pCurDfe->dfe_DirOffspring > 1)		||
					 ((pCurDfe->dfe_DirOffspring > 0) &&
					 !DFE_IS_NWTRASH(pDirEntry->de_ChildDir)))
				{
					pCurDiskEnt->dsk_Flags |= DFE_FLAGS_HAS_CHILD;
				}

				if (pCurDfe->dfe_NextSibling != NULL)
				{
					// Make sure we ignore the nwtrash folder
					if (!DFE_IS_NWTRASH(pCurDfe->dfe_NextSibling) ||
						(pCurDfe->dfe_NextSibling->dfe_NextSibling != NULL))
					{
						pCurDiskEnt->dsk_Flags |= DFE_FLAGS_HAS_SIBLING;
					}
				}
			}
			else
			{
				BOOLEAN	fHasSibling;

				pCurDiskEnt->dsk_RescLen = pCurDfe->dfe_RescLen;
				pCurDiskEnt->dsk_DataLen = pCurDfe->dfe_DataLen;
				DFE_FILE_HAS_SIBLING(pCurDfe, fbi, &fHasSibling);
				if (fHasSibling)
				{
					pCurDiskEnt->dsk_Flags |= DFE_FLAGS_HAS_SIBLING;
				}
			}

			// stick the current entry into the write buffer
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
					("AfpFlushIdDb: Writing %s %d: %Z, flags %x\n",
					DFE_IS_DIRECTORY(pCurDfe) ? "Dir" : "File", pCurDfe->dfe_AfpId,
					&pCurDfe->dfe_UnicodeName, pCurDiskEnt->dsk_Flags));

			SizeLeft -= CurEntSize;
			pCurDiskEnt = (UNALIGNED DISKENTRY *)((PBYTE)pCurDiskEnt + CurEntSize);

			/*
			 * Get to the next DFE. The entire tree under the network-trash
			 * folder is ignored. The Next DFE is:
			 *
			 * if (the current DFE is a file)
			 * {
			 *		if (there is another file sibling)
			 *		{
			 *			CurDfe = file Sibling;
			 *		}
			 *		else if (there is dir sibling)
			 *		{
			 *			CurDfe = dir Sibling;
			 *		}
			 *		else
			 *		{
			 *			CurDfe = Parent's next sibling directory;
			 * 		}
			 * }
			 * else
			 * {
			 *		if (dir has any file children)
			 *		{
			 *			CurDfe = First file child;
			 *		}
			 *		else if (dir has any dir children)
			 *		{
			 *			CurDfe = First dir child;
			 *		}
			 *		if (there is a sibling)
			 *		{
			 *			CurDfe = dir Sibling;
			 *		}
			 *		else
			 *		{
			 *			CurDfe = Parent's next sibling directory;
			 * 		}
			 * }
			 * When we hit the root, we are done
			 *
			 */
			if (DFE_IS_FILE(pCurDfe))
			{
				if (pCurDfe->dfe_NextSibling != NULL)
				{
					pCurDfe = pCurDfe->dfe_NextSibling;
				}
				else
				{
					PDIRENTRY	pDirEntry;

					pDirEntry = pCurDfe->dfe_Parent->dfe_pDirEntry;

					fbi++;
					while ((fbi < MAX_CHILD_HASH_BUCKETS) &&
						   (pDirEntry->de_ChildFile[fbi] == NULL))
					{
						fbi++;
					}

					if (fbi < MAX_CHILD_HASH_BUCKETS)
					{
						pCurDfe = pDirEntry->de_ChildFile[fbi];
						continue;
					}

					// There are no more files from this parent. Try its children
					// next. Ignore the NWTRASH folder.
					fbi = 0;
					if (pDirEntry->de_ChildDir != NULL)
					{
	                    if (!DFE_IS_NWTRASH(pDirEntry->de_ChildDir))
						{
							pCurDfe = pDirEntry->de_ChildDir;
							continue;
						}

						if (pDirEntry->de_ChildDir->dfe_NextSibling != NULL)
						{
							pCurDfe = pDirEntry->de_ChildDir->dfe_NextSibling;
							continue;
						}
					}

					// No more 'dir' siblings, move on up.
					if (!DFE_IS_ROOT(pCurDfe))
					{
						goto move_up;
					}
					else
					{
						// we've reached the root: we're done: get out of the loop
						pCurDfe = NULL;
					}
				}
			}
			else
			{
				PDIRENTRY	pDirEntry;

				// Reset ChildFileBucket index. First check for and handle
				// all file children of this directory and then move on to
				// its children or siblings
				fbi = 0;
				pDirEntry = pCurDfe->dfe_pDirEntry;
				while ((fbi < MAX_CHILD_HASH_BUCKETS) &&
					   (pDirEntry->de_ChildFile[fbi] == NULL))
				{
					fbi++;
				}
				if (fbi < MAX_CHILD_HASH_BUCKETS)
				{
					pCurDfe = pDirEntry->de_ChildFile[fbi];
					continue;
				}

				if (pDirEntry->de_ChildDir != NULL)
				{
					pCurDfe = pDirEntry->de_ChildDir;

					// don't bother writing out the network trash tree
					if (DFE_IS_NWTRASH(pCurDfe))
					{
						// could be null, if so, we're done
						pCurDfe = pCurDfe->dfe_NextSibling;
					}
				}
				else if (pCurDfe->dfe_NextSibling != NULL)
				{
					pCurDfe = pCurDfe->dfe_NextSibling;
					// don't bother writing out the network trash tree
					if (DFE_IS_NWTRASH(pCurDfe))
					{
						// could be null, if so, we're done
						pCurDfe = pCurDfe->dfe_NextSibling;
					}
				}
				else if (!DFE_IS_ROOT(pCurDfe))
				{
				  move_up:
					while (pCurDfe->dfe_Parent->dfe_NextSibling == NULL)
					{
						if (DFE_IS_ROOT(pCurDfe->dfe_Parent))
						{
							break;
						}
						pCurDfe = pCurDfe->dfe_Parent;
					}

                    // if ROOT then you get NULL
					pCurDfe = pCurDfe->dfe_Parent->dfe_NextSibling; // if ROOT then you get NULL

					// Make sure we ignore the nwtrash folder
					if ((pCurDfe != NULL) && DFE_IS_NWTRASH(pCurDfe))
					{
						pCurDfe = pCurDfe->dfe_NextSibling; // Could be null
					}
				}
				else break;
			}
		} while ((pCurDfe != NULL) && NT_SUCCESS(Status));

		if (NT_SUCCESS(Status))
		{
			DWORD	LastWriteSize, SizeRead;

			LastWriteSize = (DWORD)ROUND_TO_PAGES(IDDB_UPDATE_BUFLEN - SizeLeft);
			if (SizeLeft != IDDB_UPDATE_BUFLEN)
			{
				// write out the last bunch of the entries. Zero out unused space
				RtlZeroMemory(pWriteBuf + IDDB_UPDATE_BUFLEN - SizeLeft,
							  LastWriteSize - (IDDB_UPDATE_BUFLEN - SizeLeft));
				Status = AfpIoWrite(phIdDb,
									&ForkOffst,
									LastWriteSize,
									pWriteBuf);
				if (!NT_SUCCESS(Status))
				{
					// Reset the dirty bit if need be
					if (HdrDirty && (ForkOffst.QuadPart == 0))
					{
						AfpInterlockedSetDword(&pVolDesc->vds_Flags,
												VOLUME_IDDBHDR_DIRTY,
												&pVolDesc->vds_VolLock);
					}
					break;
				}
			}

			// set the file length to IdDb plus count plus header
			Status = AfpIoSetSize(phIdDb,
								  ForkOffst.LowPart + LastWriteSize);
			ASSERT(Status == AFP_ERR_NONE);

			// write out the count of entries written to the file. Do a read-modify-write
			// of the first page
			ForkOffst.QuadPart = 0;
			Status = AfpIoRead(phIdDb,
							   &ForkOffst,
							   PAGE_SIZE,
							   &SizeRead,
							   pWriteBuf);
			ASSERT (NT_SUCCESS(Status) && (SizeRead == PAGE_SIZE));
			if (!NT_SUCCESS(Status))
			{
				// set the file length to header plus count of zero entries
				AfpIoSetSize(phIdDb,
							 sizeof(IDDBHDR)+sizeof(DWORD));
				break;
			}

			*(PDWORD)(pWriteBuf + sizeof(IDDBHDR)) = NumWritten;
			Status = AfpIoWrite(phIdDb,
								&ForkOffst,
								PAGE_SIZE,
								pWriteBuf);
			if (!NT_SUCCESS(Status))
			{
				// set the file length to header plus count of zero entries
				AfpIoSetSize(phIdDb,
							 sizeof(IDDBHDR)+sizeof(NumWritten));
				break;
			}

			// not protected since scavenger is the only consumer of this field
			pVolDesc->vds_cScvgrIdDb = 0;

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
					("Wrote %ld entries on volume %Z\n",NumWritten,&pVolDesc->vds_Name) );

			ASSERT(Status == AFP_ERR_NONE);
		}
	} while (False);

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

	if (!NT_SUCCESS(Status))
	{
        DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
            ("AfpFlushIdDb: writing index file for vol %Z failed (%lx)\n",
            &pVolDesc->vds_Name,Status));

		AFPLOG_ERROR(AFPSRVMSG_WRITE_IDDB,
					 Status,
					 NULL,
					 0,
					 &pVolDesc->vds_Name);
	}
    else
    {
        DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
            ("AfpFlushIdDb: writing index file for vol %Z finished.\n",&pVolDesc->vds_Name));
    }

	if (pWriteBuf != NULL)
	{
		AfpFreePANonPagedMemory(pWriteBuf, IDDB_UPDATE_BUFLEN);
	}
#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_IdIndexUpdTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
}


/***	AfpChangeNotifyThread
 *
 *	Handle change notify requests queued by the notify completion routine.
 */
VOID
AfpChangeNotifyThread(
	IN	PVOID	pContext
)
{
	PKQUEUE		NotifyQueue;
	PLIST_ENTRY	pTimerList, pList, pNotifyList, pNext, pVirtualNotifyList;
	LIST_ENTRY	TransitionList;
	PVOL_NOTIFY	pVolNotify;
	PVOLDESC	pVolDesc;
	PVOLDESC	pCurrVolDesc=NULL;
	ULONG		BasePriority;
	PLONG		pNotifyQueueCount;
	KIRQL		OldIrql;
	NTSTATUS	Status;
    DWORD       ThisVolItems=0;
    BOOLEAN     fSwmrLocked=False;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;
#endif
	LONG ShutdownPriority = LOW_REALTIME_PRIORITY; // Priority higher than file server

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("AfpChangeNotifyThread: Starting %ld\n", pContext));

    IoSetThreadHardErrorMode( FALSE );

	// Boost our priority to just below low realtime.
	// The idea is get the work done fast and get out of the way.
	BasePriority = LOW_REALTIME_PRIORITY;
	Status = NtSetInformationThread(NtCurrentThread(),
									ThreadBasePriority,
									&BasePriority,
									sizeof(BasePriority));
	ASSERT(NT_SUCCESS(Status));

	pNotifyList = &AfpVolumeNotifyList[(LONG_PTR)pContext];
	pVirtualNotifyList = &AfpVirtualMemVolumeNotifyList[(LONG_PTR)pContext];
	NotifyQueue = &AfpVolumeNotifyQueue[(LONG_PTR)pContext];
	pNotifyQueueCount = &AfpNotifyQueueCount[(LONG_PTR)pContext];
	AfpThreadPtrsW[(LONG_PTR)pContext] = PsGetCurrentThread();

	do
	{
		AFPTIME		CurrentTime;

		ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);



		if (!IsListEmpty(pVirtualNotifyList))
		{
			AfpSwmrAcquireExclusive(&AfpVolumeListSwmr);
			pList = RemoveHeadList(pVirtualNotifyList);
			AfpSwmrRelease(&AfpVolumeListSwmr);
		}
		else
		{
			// Wait for a change notify request to process or timeout
			//pList = KeRemoveQueue(NotifyQueue, KernelMode, &TwoSecTimeOut);
			pList = KeRemoveQueue(NotifyQueue, KernelMode, &OneSecTimeOut);
		}

		// We either have something to process or we timed out. In the latter case
		// see if it is time to move some stuff from the list to the queue.
		if ((NTSTATUS)((ULONG_PTR)pList) != STATUS_TIMEOUT)
		{
			pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);

			if (pVolNotify == &AfpTerminateNotifyThread)
			{
				DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
					("ChangeNotifyThread Got AfpTerminateNotifyEvent Thread = %ld\n", (LONG_PTR)pContext));

                if (pCurrVolDesc)
                {
		            AfpSwmrRelease(&pCurrVolDesc->vds_IdDbAccessLock);

                    // remove that ref we put before grabbing the swmr lock
                    AfpVolumeDereference(pCurrVolDesc);
                    pCurrVolDesc = NULL;
                }

				// If these assertions fail, then there will be extra ref
				// counts on some volumes due to unprocessed notifies,
				// and the volumes will never go away.
				ASSERT((*pNotifyQueueCount == 0)	&&
						(AfpNotifyListCount[(LONG_PTR)pContext] == 0) &&
						IsListEmpty(pNotifyList));
				break;			// Asked to quit, so do so.
			}

#ifdef	PROFILING
			AfpGetPerfCounter(&TimeS);
#endif
			pVolDesc = pVolNotify->vn_pVolDesc;

            //
            // if we just moved to the next volume, release the lock for the
            // previous volume, and also, grab the lock for the this volume
            //
            if (pVolDesc != pCurrVolDesc)
            {
                if ((pCurrVolDesc) && (fSwmrLocked))
                {
				    AfpSwmrRelease(&pCurrVolDesc->vds_IdDbAccessLock);

                    // remove that ref we put before grabbing the swmr lock
                    AfpVolumeDereference(pCurrVolDesc);
                }
                pCurrVolDesc = pVolDesc;
                ThisVolItems = 0;

                // reference the volume, and deref when we release this swmr lock
                if (AfpVolumeReference(pVolDesc))
                {
                    AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
                    fSwmrLocked = True;
                }
                else
                {
		            DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
			            ("AfpChangeNotifyThread: couldn't reference volume %Z!!\n",
                        &pVolDesc->vds_Name));

                    fSwmrLocked = False;

					// Remove all private notifies which follow this one
					AfpVolumeStopIndexing(pVolDesc, pVolNotify);

           		}

            }
            else
            {
                //
                // if someone's waiting for the lock, release it and reacuire it
                // to give him a chance
                //
                if ( (SWMR_SOMEONE_WAITING(&pVolDesc->vds_IdDbAccessLock)) &&
                     (ThisVolItems % 50 == 0) )
                {
                    ASSERT(fSwmrLocked);

                    AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
                    AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
                }
            }

            ThisVolItems++;

			if (!(((PFILE_NOTIFY_INFORMATION)(pVolNotify + 1))->Action & AFP_ACTION_PRIVATE))
			{
				(*pNotifyQueueCount) --;
			}

			ASSERT(VALID_VOLDESC(pVolDesc));


			// The volume is already referenced for the notification processing.
			// Dereference after finishing processing.
			if ((pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED)) == 0)
			{
#ifndef BLOCK_MACS_DURING_NOTIFYPROC
				AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
#endif
				(*pVolNotify->vn_Processor)(pVolNotify);
#ifndef BLOCK_MACS_DURING_NOTIFYPROC
				AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
#endif
			}

			AfpVolumeDereference(pVolDesc);

		 	// was this a private notify?
			if (((PFILE_NOTIFY_INFORMATION)(pVolNotify + 1))->Action & AFP_ACTION_PRIVATE)
			{
				// Free	virtual memory
				afpFreeNotify(pVolNotify);
			}
			else
			{
				// Free	non-paged memory
				AfpFreeMemory(pVolNotify);
			}

#ifdef	PROFILING
			AfpGetPerfCounter(&TimeE);
			TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
			INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_ChangeNotifyTime,
										 TimeD,
										 &AfpStatisticsLock);
			INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_ChangeNotifyCount);
#endif

			if (*pNotifyQueueCount > 0)
				continue;
		}

        //
        // release the lock for the volume we just finished
        //
        if ((pCurrVolDesc) && (fSwmrLocked))
        {
		    AfpSwmrRelease(&pCurrVolDesc->vds_IdDbAccessLock);

            // remove that ref we put before grabbing the swmr lock
            AfpVolumeDereference(pCurrVolDesc);
        }

		// If we timed out because there was nothing in the queue, or we
		// just processed the last thing in the queue, then see if there are
		// more things that can be moved into the queue.
		InitializeListHead(&TransitionList);

		// Look at the list to see if some stuff should move to the
		// Queue now i.e. if the delta has elapsed since we were notified of this change
		AfpGetCurrentTimeInMacFormat(&CurrentTime);

		ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

		while (!IsListEmpty(pNotifyList))
		{
			pList = RemoveHeadList(pNotifyList);
			pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);
			pVolDesc = pVolNotify->vn_pVolDesc;

			if ((pVolNotify->vn_TimeStamp == AFP_QUEUE_NOTIFY_IMMEDIATELY) ||
				((CurrentTime - pVolNotify->vn_TimeStamp) >= VOLUME_NTFY_DELAY) ||
				(pVolDesc->vds_Flags & (VOLUME_STOPPED | VOLUME_DELETED)))
			{
				AfpNotifyListCount[(LONG_PTR)pContext] --;
				(*pNotifyQueueCount) ++;
				// Build up a list of items to queue up outside the spinlock
				// since we will want to take the IdDb swmr for any volume
				// which has notifies that we are about to process.
				// Make sure you add things so they are processed in the
				// order they came in with!!
				InsertTailList(&TransitionList, pList);
			}
			else
			{
				// Put it back where we we took it from - its time has not come yet
				// And we are done now since the list is ordered in time.
				InsertHeadList(pNotifyList, pList);
				break;
			}
		}

		RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

		while (!IsListEmpty(&TransitionList))
		{
            pList = TransitionList.Flink;
			pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);
			pCurrVolDesc = pVolNotify->vn_pVolDesc;

            //
            // walk the entire list and collect all the items that belong to the
            // same VolDesc and put them on the list.  This way we take the swmr
            // lock only for the volume we are working on
            //
            while (pList != &TransitionList)
            {
			    pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);
			    pVolDesc = pVolNotify->vn_pVolDesc;
                pNext = pList->Flink;
                if (pVolDesc == pCurrVolDesc)
                {
                    RemoveEntryList(pList);
					AfpVolumeQueueChangeNotify (pVolNotify, NotifyQueue);	
					//InsertTailList(pVirtualNotifyList, pList);
                }
                pList = pNext;
            }
		}

        pCurrVolDesc = NULL;

	} while (True);

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("AfpChangeNotifyThread: Quitting %ld\n", pContext));

	// Raise the priority of the current thread, so that this thread
	// completes before any other thread interrupts it
	NtSetInformationThread (
					NtCurrentThread( ),
					ThreadBasePriority,
					&ShutdownPriority,
					sizeof(ShutdownPriority)
				);

	AfpThreadPtrsW[(LONG_PTR)pContext] = NULL;
	KeSetEvent(&AfpStopConfirmEvent, IO_NETWORK_INCREMENT, False);
	Status = PsTerminateSystemThread (STATUS_SUCCESS);
	ASSERT (NT_SUCCESS(Status));
}


/***	AfpProcessChangeNotify
 *
 * A change item has been dequeued by one of the notify processing threads.
 *
 *	LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Exclusive)
 */
VOID FASTCALL
AfpProcessChangeNotify(
	IN	PVOL_NOTIFY			pVolNotify
)
{
	PVOLDESC					pVolDesc;
	UNICODE_STRING				UName, UParent, UTail;
	PFILE_NOTIFY_INFORMATION	pFNInfo;
	BOOLEAN						CleanupHandle;
	PLIST_ENTRY					pList;
	NTSTATUS					status;
	PDFENTRY					pDfEntry;
	FILESYSHANDLE				handle;
	DWORD						afpChangeAction;
	DWORD						StreamId;
	PFILE_BOTH_DIR_INFORMATION	pFBDInfo = NULL;
	LONG						infobuflen;
        LONGLONG                        infobuf[(sizeof(FILE_BOTH_DIR_INFORMATION) + (AFP_LONGNAME_LEN + 1) * sizeof(WCHAR))/sizeof(LONGLONG) + 1];
#if DBG
	static PBYTE	Action[] = { "",
								 "ADDED",
								 "REMOVED",
								 "MODIFIED",
								 "RENAMED OLD",
								 "RENAMED NEW",
								 "STREAM ADDED",
								 "STREAM REMOVED",
								 "STREAM MODIFIED"};
#endif

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
			("AfpProcessChangeNotify: entered...\n"));

	pFNInfo = (PFILE_NOTIFY_INFORMATION)(pVolNotify + 1);

	ASSERT((pFNInfo->Action & AFP_ACTION_PRIVATE) == 0);

    pVolDesc = pVolNotify->vn_pVolDesc;
	ASSERT (VALID_VOLDESC(pVolDesc));

	INTERLOCKED_DECREMENT_LONG(&pVolDesc->vds_cOutstandingNotifies);

	StreamId = pVolNotify->vn_StreamId;

	if ( (pFNInfo->Action == FILE_ACTION_REMOVED) ||
		 (pFNInfo->Action == FILE_ACTION_RENAMED_OLD_NAME) )
	{
		ASSERT(!IsListEmpty(&pVolDesc->vds_ChangeNotifyLookAhead));

		DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
				("AfpProcessChangeNotify: removing %s LookAhead change\n",
				Action[pFNInfo->Action]));

		pList = ExInterlockedRemoveHeadList(&pVolDesc->vds_ChangeNotifyLookAhead,
											&(pVolDesc->vds_VolLock.SpinLock));

		ASSERT(pList == &(pVolNotify->vn_DelRenLink));
	}

	// Process each of the entries in the list for this volume
	while (True)
	{
		CleanupHandle = False;
		status = STATUS_SUCCESS;

		AfpInitUnicodeStringWithNonNullTerm(&UName,
											(USHORT)pFNInfo->FileNameLength,
											pFNInfo->FileName);
		UName.MaximumLength += (AFP_LONGNAME_LEN+1)*sizeof(WCHAR);

		ASSERT(IS_VOLUME_NTFS(pVolDesc) && !EXCLUSIVE_VOLUME(pVolDesc));

		DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
				("AfpProcessChangeNotify: Action: %s Name: %Z\n",
				Action[pFNInfo->Action], &UName));

		do
		{
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
					 ("AfpProcessChangeNotify: !!!!Processing Change!!!!\n"));

			// We have the idindex write lock, look up the entry by path,
			// open a handle to the item, query the appropriate info,
			// cache the info in the DFE.  Where necessary, open a handle
			// to the parent directory and update its cached ModTime.

		  Lookup_Entry:
			pDfEntry = afpFindEntryByNtPath(pVolDesc,
											pFNInfo->Action,
											&UName,
											&UParent,
											&UTail);
			if (pDfEntry != NULL)
			{
				// Open a handle to parent or entity relative to the volume root handle
				CleanupHandle = True;
				status = AfpIoOpen(&pVolDesc->vds_hRootDir,
								   StreamId,
								   FILEIO_OPEN_EITHER,
								   ((pFNInfo->Action == FILE_ACTION_ADDED) ||
									(pFNInfo->Action == FILE_ACTION_REMOVED) ||
									(pFNInfo->Action == FILE_ACTION_RENAMED_OLD_NAME)) ?
										&UParent : &UName,
								   FILEIO_ACCESS_NONE,
								   FILEIO_DENY_NONE,
								   False,
								   &handle);
				if (!NT_SUCCESS(status))
				{
					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
							("AfpProcessChangeNotify: Failed to open (0x%lx) for %Z\n", status, &UName));

					if (pFNInfo->Action == FILE_ACTION_ADDED) {

						// Add the full-pathname of file relative to volume root
						// to the DelayedNotifyList for the current VolumeDesc
						// We assume here that the filename relative to the
						// volume path will not be greater than 512
						// characters (unicode)

						status = AddToDelayedNotifyList(pVolDesc, &UName);
						if (!NT_SUCCESS(status)) {
							DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
									("AfpProcessChangeNotify: Error in addToDelayedList (0x%lx)\n", status));
							break;
						}
					}

					CleanupHandle = False;
					break;
				}

				switch (pFNInfo->Action)
				{
					case FILE_ACTION_ADDED:
					{
						UNICODE_STRING	UEntity;
						UNICODE_STRING	UTemp;
						PDFENTRY		pDfeNew;
						FILESYSHANDLE	fshEnumDir;
						BOOLEAN			firstEnum = True;
						ULONG			fileLength;

						// Update timestamp of parent dir.
						AfpIoQueryTimesnAttr(&handle,
											 NULL,
											 &pDfEntry->dfe_LastModTime,
											 NULL);

						// enumerate parent handle for this entity to get
						// the file/dir info, then add entry to the IDDB
						/*
						if ((UTail.Length/sizeof(WCHAR)) <= AFP_LONGNAME_LEN)
						*/
						// Bug 311023
						fileLength = RtlUnicodeStringToAnsiSize(&UTail)-1;
						if (fileLength <= AFP_LONGNAME_LEN)
						{
							pFBDInfo = (PFILE_BOTH_DIR_INFORMATION)infobuf;
							infobuflen = sizeof(infobuf);
						}
						else
						{
							infobuflen = sizeof(FILE_BOTH_DIR_INFORMATION) +
											  (MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR));
							if ((pFBDInfo = (PFILE_BOTH_DIR_INFORMATION)
											AfpAllocNonPagedMemory(infobuflen)) == NULL)
							{
								status = STATUS_NO_MEMORY;
								break; // out of case FILE_ACTION_ADDED
							}
						}

						do
						{
							status = AfpIoQueryDirectoryFile(&handle,
															 pFBDInfo,
															 infobuflen,
															 FileBothDirectoryInformation,
															 True,
															 True,
															 firstEnum ? &UTail : NULL);
							if ((status == STATUS_BUFFER_TOO_SMALL) ||
								(status == STATUS_BUFFER_OVERFLOW))
							{
								// Since we queue our own ACTION_ADDED for directories when
								// caching a tree, we may have the case where we queued it
								// by shortname because it actually had a name > 31 chars.
								// Note that a 2nd call to QueryDirectoryFile after a buffer
								// Overflow must send a null filename, since if the name is
								// not null, it will override the restartscan parameter
								// which means the scan will not restart from the beginning
								// and we will not find the file name we are looking for.

								ASSERT((PBYTE)pFBDInfo == (PBYTE)infobuf);

								// This should never happen, but if it does...
								if ((PBYTE)pFBDInfo != (PBYTE)infobuf)
								{
									status = STATUS_UNSUCCESSFUL;
									break;
								}

								firstEnum = False;

								infobuflen = sizeof(FILE_BOTH_DIR_INFORMATION) +
													(MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR));

								if ((pFBDInfo = (PFILE_BOTH_DIR_INFORMATION)
													AfpAllocNonPagedMemory(infobuflen)) == NULL)
									status = STATUS_NO_MEMORY;
							}
						} while ((status == STATUS_BUFFER_TOO_SMALL) ||
								 (status == STATUS_BUFFER_OVERFLOW));

						if (status == STATUS_SUCCESS)
						{
							// If this file was created in a directory that has
							// not been looked at by a mac, just ignore it.
							// If this was not a FILE_ACTION_ADDED we would not
							// have found it in the database at all if it was
							// a file and the parent has not had its file
							// children cached in, so we will ignore those
							// notifies by default anyway since the DFE would
							// come back as NULL from afpFindEntryByNtPath.
							// We *do* want to process changes for directories
							// even if the parent has not had its
							// file children brought in since directories
							// are only cached in once at volume startup.
							if (((pFBDInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
								!DFE_CHILDREN_ARE_PRESENT(pDfEntry))
							{
								break;
							}

							// figure out which name to use
							// If NT name > AFP_LONGNAME_LEN, use the NT shortname for
							// Mac longname on NTFS, any other file system the shortname
							// will be null, so ignore the file
							// Bug 311023
							AfpInitUnicodeStringWithNonNullTerm(&UTemp,
									(USHORT)pFBDInfo->FileNameLength,
									pFBDInfo->FileName);
							fileLength=RtlUnicodeStringToAnsiSize(&UTemp)-1;
							if (fileLength <= AFP_LONGNAME_LEN)
							{
								AfpInitUnicodeStringWithNonNullTerm(&UEntity,
																	(USHORT)pFBDInfo->FileNameLength,
																	pFBDInfo->FileName);
							}
							else if (pFBDInfo->ShortNameLength > 0)
							{
								AfpInitUnicodeStringWithNonNullTerm(&UEntity,
																	(USHORT)pFBDInfo->ShortNameLength,
																	pFBDInfo->ShortName);
							}
							else
							{
								DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
										("AfpProcessChangeNotify: Name is > 31 with no short name ?\n") );
								status = STATUS_UNSUCCESSFUL;
							}

							if (NT_SUCCESS(status))
							{
								// add the entry
								afpAddDfEntryAndCacheInfo(pVolDesc,
														  pDfEntry,
														  &UEntity,
														  &handle,
														  pFBDInfo,
														  &UName,
														  &pDfeNew,
														  True);

								if (pDfeNew == NULL)
								{
									DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_WARN,
										("AfpProcessChangeNotify: Could not add DFE for %Z\n", &UName));
								}
								else if (DFE_IS_DIRECTORY(pDfeNew))
								{
									// if a directory was added, we must see if it has
									// children that we must cache as well
									if (NT_SUCCESS(status = AfpIoOpen(&pVolDesc->vds_hRootDir,
																	  AFP_STREAM_DATA,
																	  FILEIO_OPEN_DIR,
																	  &UName,
																	  FILEIO_ACCESS_NONE,
																	  FILEIO_DENY_NONE,
																	  False,
																	  &fshEnumDir)))
									{
										status = AfpCacheDirectoryTree(pVolDesc,
																	   pDfeNew,
																	   GETENTIRETREE | REENUMERATE,
																	   &fshEnumDir,
																	   &UName);
										AfpIoClose(&fshEnumDir);
										if (!NT_SUCCESS(status))
										{
											DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
													("AfpProcessChangeNotify: Could not cache dir tree for %Z\n",
													&UName) );
										}
									}
									else
									{
										DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
												("AfpProcessChangeNotify: Added dir %Z but couldn't open it for enumerating\n", &UName) );
									}
								}
							}
						}

						if (((PBYTE)pFBDInfo != NULL) &&
							((PBYTE)pFBDInfo != (PBYTE)infobuf))
						{
							AfpFreeMemory(pFBDInfo);
							pFBDInfo = NULL;
						}
					}
					break;

					case FILE_ACTION_REMOVED:
					{
						// Remove entries from DelayedNotifyList for the
						// volume belonging to the directory which is
						// being removed since they need not be added to
						// the IDDB after this
						status = RemoveFromDelayedNotifyList(
										pVolDesc,
										&UName,
										pFNInfo
										);
						if (!NT_SUCCESS(status)) {
							DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
								("Error in RemoveFromDelayedNotifyList 0x%lx\n", status));
						}

						// update timestamp of parent dir.
						AfpIoQueryTimesnAttr(&handle,
											 NULL,
											 &pDfEntry->dfe_Parent->dfe_LastModTime,
											 NULL);
						// remove entry from IDDb.
						AfpDeleteDfEntry(pVolDesc, pDfEntry);
					}
					break;

					case FILE_ACTION_MODIFIED:
					{
						FORKSIZE forklen;
						DWORD	 NtAttr;

						// NOTE: if a file is SUPERSEDED or OVERWRITTEN,
						// you will only get a MODIFIED notification.  Is
						// there a way to check the creation date against
						// what we have cached in order to figure out if
						// this is what happened?

						// query for times and attributes.  If its a file,
						// also query for the data fork length.
						if (NT_SUCCESS(AfpIoQueryTimesnAttr(&handle,
															&pDfEntry->dfe_CreateTime,
															&pDfEntry->dfe_LastModTime,
															&NtAttr)))
						{
							pDfEntry->dfe_NtAttr = (USHORT)NtAttr &
														 FILE_ATTRIBUTE_VALID_FLAGS;
						}
						if (DFE_IS_FILE(pDfEntry) &&
							NT_SUCCESS(AfpIoQuerySize(&handle, &forklen)))
						{
							pDfEntry->dfe_DataLen = forklen.LowPart;
						}
					}
					break;

					case FILE_ACTION_RENAMED_OLD_NAME:
					{
						UNICODE_STRING				UNewname;
						PFILE_NOTIFY_INFORMATION	pFNInfo2;
						ULONG						fileLength;
						BOOLEAN						checkIfDirectory=False;

						status = STATUS_SUCCESS;

						// The next item in the change buffer better be the
						// new name -- consume this entry so we don't find
						// it next time thru the loop.  If there is none,
						// then throw the whole thing out and assume the
						// rename aborted in NTFS
						if (pFNInfo->NextEntryOffset == 0)
							break; // from switch

						// If the next change in the buffer is not the
						// new name, we don't want to advance over it,
						// we want it to be processed next time thru
						// the loop. Note we are assuming it is valid.
						(PBYTE)pFNInfo2 = (PBYTE)pFNInfo + pFNInfo->NextEntryOffset;
						ASSERT(pFNInfo2->Action == FILE_ACTION_RENAMED_NEW_NAME);
						if (pFNInfo2->Action != FILE_ACTION_RENAMED_NEW_NAME)
						{
							DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
									("AfpProcessChangeNotify: Rename did not come with new name!!!\n"));
							break; // from switch
						}

						pFNInfo = pFNInfo2;

						// update timestamp of parent dir.
						AfpIoQueryTimesnAttr(&handle,
											 NULL,
											 &pDfEntry->dfe_Parent->dfe_LastModTime,
											 NULL);

						// get the entity name from the path (subtract the
						// parent path length from total length), if it is
						// > 31 chars, we have to get the shortname by
						// enumerating the parent for this item, since we
						// already have a handle to the parent
						AfpInitUnicodeStringWithNonNullTerm(&UNewname,
															(USHORT)pFNInfo->FileNameLength,
															pFNInfo->FileName);

						if (DFE_IS_DIRECTORY(pDfEntry))
						{
							checkIfDirectory = True;
						}


						if (UParent.Length > 0)
						{
							// if the rename is not in the volume root,
							// get rid of the path separator before the name
							UNewname.Length -= UParent.Length + sizeof(WCHAR);
							UNewname.Buffer = (PWCHAR)((PBYTE)UNewname.Buffer + UParent.Length + sizeof(WCHAR));
						}

						// Bug 311023
						fileLength = RtlUnicodeStringToAnsiSize(&UNewname)-1;
						if (fileLength > AFP_LONGNAME_LEN)
						{
							infobuflen = sizeof(FILE_BOTH_DIR_INFORMATION) +
									  (MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR));
							if ((pFBDInfo = (PFILE_BOTH_DIR_INFORMATION)
									AfpAllocNonPagedMemory(infobuflen)) == NULL)
							{
								status = STATUS_NO_MEMORY;
								break; // out of case FILE_ACTION_RENAMED
							}

							status = AfpIoQueryDirectoryFile(&handle,
															 pFBDInfo,
															 infobuflen,
															 FileBothDirectoryInformation,
															 True,
															 True,
															 &UNewname);
							if (status == STATUS_SUCCESS)
							{
								// figure out which name to use
								// If NT name > AFP_LONGNAME_LEN, use the NT shortname for
								// Mac longname on NTFS, any other file system the shortname
								// will be null, so ignore the file
								// Bug 311023
								AfpInitUnicodeStringWithNonNullTerm(
										&UNewname,
										(USHORT)
										pFBDInfo->FileNameLength,
										pFBDInfo->FileName);
								fileLength=RtlUnicodeStringToAnsiSize(&UNewname)-1;
								if (fileLength <= AFP_LONGNAME_LEN)
								{
									AfpInitUnicodeStringWithNonNullTerm(&UNewname,
																		(USHORT)pFBDInfo->FileNameLength,
																		pFBDInfo->FileName);
								}
								else if (pFBDInfo->ShortNameLength > 0)
								{
									AfpInitUnicodeStringWithNonNullTerm(&UNewname,
																		(USHORT)pFBDInfo->ShortNameLength,
																		pFBDInfo->ShortName);
								}
								else
								{
									DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
											("AfpProcessChangeNotify: Name is > 31 with no short name ?\n") );
									status = STATUS_UNSUCCESSFUL;
								}
							}
						}

						// rename the entry
						if (NT_SUCCESS(status))
						{
							AfpRenameDfEntry(pVolDesc, pDfEntry, &UNewname);
						}

						// Check if a directory is being renamed
						// If yes, check if there are any files/directories
						// which were not added to the IDDB due to ChangeNotify
						// requests getting delayed
						if (checkIfDirectory) {

							status = CheckAndProcessDelayedNotify (
									pVolDesc,
									&UName,
									&UNewname,
									&UParent
									);
						
							if (!NT_SUCCESS(status))
							{
								DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
										("Error in CheckAndProcessDelayedNotify 0x%lx\n", status));
							}

						}

						if ((PBYTE)pFBDInfo != NULL)
						{
							AfpFreeMemory(pFBDInfo);
							pFBDInfo = NULL;
						}
					}
					break;

					case FILE_ACTION_MODIFIED_STREAM:
					{
						FORKSIZE forklen;

						// If it is the AFP_Resource stream on a file,
						// cache the resource fork length.
						if ((StreamId == AFP_STREAM_RESC) &&
							DFE_IS_FILE(pDfEntry) &&
							NT_SUCCESS(AfpIoQuerySize(&handle, &forklen)))
						{
							pDfEntry->dfe_RescLen = forklen.LowPart;
						}
						else if (StreamId == AFP_STREAM_INFO)
						{
							AFPINFO		afpinfo;
							FILEDIRPARM fdparms;

							// Read the afpinfo stream.  If the file ID in
							// the DfEntry does not match the one in the
							// stream, write back the ID we know it by.
							// Update our cached FinderInfo.
							if (NT_SUCCESS(AfpReadAfpInfo(&handle, &afpinfo)))
							{
								pDfEntry->dfe_FinderInfo = afpinfo.afpi_FinderInfo;
								pDfEntry->dfe_BackupTime = afpinfo.afpi_BackupTime;

								if (pDfEntry->dfe_AfpId != afpinfo.afpi_Id)
								{
									// munge up a fake FILEDIRPARMS structure
                                    AfpInitializeFDParms(&fdparms);
									fdparms._fdp_Flags = pDfEntry->dfe_Flags;
									fdparms._fdp_AfpId = pDfEntry->dfe_AfpId;
									AfpConvertMungedUnicodeToAnsi(&pDfEntry->dfe_UnicodeName,
																  &fdparms._fdp_LongName);

									// NOTE: can we open a handle to afpinfo
									// relative to a afpinfo handle??
									AfpSetAfpInfo(&handle,
												  FILE_BITMAP_FILENUM,
												  &fdparms,
												  NULL,
												  NULL);
								}
							}
						}
					}
					break; // from switch

					default:
						ASSERTMSG("AfpProcessChangeNotify: Unexpected Action\n", False);
						break;
				} // switch
			}
			else
			{
				PFILE_NOTIFY_INFORMATION	pFNInfo2;

				DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_WARN,
						("AfpProcessChangeNotify: Could not find DFE for %Z\n", &UName));

				// This item may have been deleted, renamed or moved
				// by someone else in the interim, ignore this change
				// if it was not a rename.  If it was a rename, then
				// try to add the item using the new name.
				if ((pFNInfo->Action == FILE_ACTION_RENAMED_OLD_NAME) &&
					(pFNInfo->NextEntryOffset != 0))
				{
					// If the next change in the buffer is not the
					// new name, we don't want to advance over it,
					// we want it to be processed next time thru
					// the loop. Note we are assuming it is valid.
					(PBYTE)pFNInfo2 = (PBYTE)pFNInfo + pFNInfo->NextEntryOffset;
					ASSERT(pFNInfo2->Action == FILE_ACTION_RENAMED_NEW_NAME);
					if (pFNInfo2->Action != FILE_ACTION_RENAMED_NEW_NAME)
					{
						DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
								("AfpProcessChangeNotify: Rename did not come with new name!!! (no-DFE case)\n"));
						break; // from error loop
					}

					pFNInfo = pFNInfo2;

					pFNInfo->Action = FILE_ACTION_ADDED;

					AfpInitUnicodeStringWithNonNullTerm(&UName,
														(USHORT)pFNInfo->FileNameLength,
														pFNInfo->FileName);

					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
							("AfpProcessChangeNotify: Converting RENAME into Action: %s for Name: %Z\n",
							Action[pFNInfo->Action], &UName));

					goto Lookup_Entry;
				}
			}
		} while (False);

		if (CleanupHandle)
			AfpIoClose(&handle);

		// Advance to the next entry in the change buffer
		if (pFNInfo->NextEntryOffset == 0)
		{
			break;
		}
		(PBYTE)pFNInfo += pFNInfo->NextEntryOffset;
		DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_WARN,
				("More than one entry in notify ?\n"));
	}

	// Get new values for Free space on disk and update volume time
	AfpUpdateVolFreeSpaceAndModTime(pVolDesc, TRUE);
}

/***	AddToDelayedNotifyList
 *
 *  Add Pathname of delayed notify for added file to DelayedNotifyList of the
 *  corresponding volume
 *
 *	LOCKS_ASSUMED: none
 */
NTSTATUS FASTCALL
AddToDelayedNotifyList(
	IN PVOLDESC         pVolDesc,
	IN PUNICODE_STRING  pUName
)
{
	KIRQL		OldIrql;
	PDELAYED_NOTIFY pDelayedNotify;
	NTSTATUS status = STATUS_SUCCESS;

	pDelayedNotify = (PDELAYED_NOTIFY)AfpAllocNonPagedMemory (sizeof(DELAYED_NOTIFY));
	if (pDelayedNotify == NULL)
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
		return status;
	}

	pDelayedNotify->filename.Length = 0;
	pDelayedNotify->filename.MaximumLength = pUName->MaximumLength;
	pDelayedNotify->filename.Buffer = (PWSTR)AfpAllocNonPagedMemory(pUName->MaximumLength);
	if (pDelayedNotify->filename.Buffer == NULL)
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
        AfpFreeMemory(pDelayedNotify);
		return status;
	}

	RtlCopyUnicodeString(&pDelayedNotify->filename, pUName);

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);
	InsertHeadList (&pVolDesc->vds_DelayedNotifyList, &pDelayedNotify->dn_List);
	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

	return status;
}


/***	RemoveFromDelayedNotifyList
 *
 *  Remove entry from DelayedNotifyList for files which are within the
 *  directory that was deleted
 *
 *	LOCKS_ASSUMED: none
 */
NTSTATUS
RemoveFromDelayedNotifyList (
	IN PVOLDESC pVolDesc,
	IN PUNICODE_STRING pUName,
	IN PFILE_NOTIFY_INFORMATION    pFNInfo
)
{
	PLIST_ENTRY 		pList, pNext;
	PDELAYED_NOTIFY 	pDelayedNotify;
	KIRQL				OldIrql;	
	NTSTATUS			status=STATUS_SUCCESS;


    AfpInitUnicodeStringWithNonNullTerm(pUName,
			(USHORT)pFNInfo->FileNameLength,
			pFNInfo->FileName);

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
			("AfpProcessChangeNotify: Going to remove %Z \n", pUName));
	
	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	if (!IsListEmpty(&pVolDesc->vds_DelayedNotifyList)) {

		pList = pVolDesc->vds_DelayedNotifyList.Flink;

		while (pList != &pVolDesc->vds_DelayedNotifyList)
		{
		
			pDelayedNotify = CONTAINING_RECORD (pList, DELAYED_NOTIFY, dn_List);
			pNext = pList->Flink;

			if (pDelayedNotify->filename.Length >= pUName->Length)
			{
				if (RtlCompareMemory ((PVOID)pUName->Buffer, (PVOID)pDelayedNotify->filename.Buffer, pUName->Length) == pUName->Length) {
					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR, ("AfpProcessChangeNotify: Correction no longer to be done for %Z\n", &pDelayedNotify->filename));
					RemoveEntryList(pList);
					AfpFreeMemory(pDelayedNotify->filename.Buffer);
					AfpFreeMemory(pDelayedNotify);
				}
			}

			pList = pNext;
		}
	}

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
	return status;
}
							
/***	CheckAndProcessDelayedNotify
 *
 *  Check if the directory being renamed had entries that were not added to
 *  the IDDB. Rename the entries and issue new FILE_ACTION_ADDED ChangeNotify
 *  requests as if the NTFS filesystem has made the requests
 *
 *	LOCKS_ASSUMED: none
 */
NTSTATUS
CheckAndProcessDelayedNotify (
	IN PVOLDESC			pVolDesc,
	IN PUNICODE_STRING	pUName,
	IN PUNICODE_STRING	pUNewname,
	IN PUNICODE_STRING	pUParent
)
{
	PLIST_ENTRY                 pList;
	PDELAYED_NOTIFY             pDelayedNotify;
	KIRQL			            OldIrql;
	NTSTATUS		            status = STATUS_SUCCESS;
    PFILE_NOTIFY_INFORMATION    pFNInfo;
	PDFENTRY                    pParentDfEntry;
	UNICODE_STRING              newNotifyName;
	PVOL_NOTIFY	                pVolNotify;
										

    ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

    pList = pVolDesc->vds_DelayedNotifyList.Flink;

    while (1)
    {
        // finished the list?
        if (pList == &pVolDesc->vds_DelayedNotifyList)
        {
            RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
            break;
        }

		pDelayedNotify = CONTAINING_RECORD (pList, DELAYED_NOTIFY, dn_List);

        pList = pList->Flink;

		if (pDelayedNotify->filename.Length < pUName->Length)
		{
            continue;
		}

		if (RtlCompareMemory ((PVOID)pUName->Buffer,
                              (PVOID)pDelayedNotify->filename.Buffer,
                              pUName->Length) == pUName->Length)
        {

			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
                ("AfpProcessChangeNotify: Correction required to be done for %Z\n", &pDelayedNotify->filename));

			RemoveEntryList(&pDelayedNotify->dn_List);
            RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

			if ((newNotifyName.Buffer = (PWSTR)AfpAllocNonPagedMemory(1024)) == NULL)
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
                AfpFreeMemory(pDelayedNotify->filename.Buffer);
                AfpFreeMemory(pDelayedNotify);
				return status;
			};

			newNotifyName.Length = 0;
			newNotifyName.MaximumLength = 1024;
										
			if (pUParent->Length > 0)
			{
				RtlCopyUnicodeString (&newNotifyName, pUName);
					
				// Copy the Parent name and the "/" separator and then the new name
				RtlCopyMemory (newNotifyName.Buffer + pUParent->Length/2 + 1,
						pUNewname->Buffer, pUNewname->Length);
				newNotifyName.Length = pUParent->Length + pUNewname->Length + 2;
			}
			else
			{
				RtlCopyUnicodeString (&newNotifyName, pUNewname);
			}	

			RtlAppendUnicodeToString (&newNotifyName,
					pDelayedNotify->filename.Buffer + pUName->Length/2);

			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
                ("AfpProcessChangeNotify: After correction, name = %Z, Old=%Z, New=%Z, chgto=%Z\n",
                &pDelayedNotify->filename, pUName, pUNewname, &newNotifyName));

			pVolNotify = (PVOL_NOTIFY)AfpAllocNonPagedMemory(
                                                sizeof(VOL_NOTIFY) +
                                                (ULONG)(newNotifyName.Length) +
                                                sizeof(FILE_NOTIFY_INFORMATION) +
                                                (AFP_LONGNAME_LEN + 1)*sizeof(WCHAR));

		    if (pVolNotify != NULL)
			{
				AfpGetCurrentTimeInMacFormat(&pVolNotify->vn_TimeStamp);
				pVolNotify->vn_pVolDesc = pVolDesc;
				pVolNotify->vn_Processor = AfpProcessChangeNotify;
				pVolNotify->vn_StreamId = AFP_STREAM_DATA;
				pVolNotify->vn_TailLength = newNotifyName.Length;
				pFNInfo = (PFILE_NOTIFY_INFORMATION)(pVolNotify + 1);
				pFNInfo->Action = FILE_ACTION_ADDED;
				pFNInfo->NextEntryOffset = 0;
				pFNInfo->FileNameLength = newNotifyName.Length;

				RtlCopyMemory((PVOID)&pFNInfo->FileName,
							(PVOID)newNotifyName.Buffer,
							newNotifyName.Length);

				if (AfpVolumeReference(pVolDesc))
				{
					AfpVolumeInsertChangeNotifyList(pVolNotify, pVolDesc);
				}
			}
			else
			{
				DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,("Out of memory!!\n"));
				ASSERT(0);
				status = STATUS_INSUFFICIENT_RESOURCES;
				AfpFreeMemory(newNotifyName.Buffer);
                AfpFreeMemory(pDelayedNotify->filename.Buffer);
                AfpFreeMemory(pDelayedNotify);
				return status;
			}

			AfpFreeMemory(pDelayedNotify->filename.Buffer);
            AfpFreeMemory(pDelayedNotify);
			AfpFreeMemory(newNotifyName.Buffer);

            ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);
            pList = pVolDesc->vds_DelayedNotifyList.Flink;   // start from the head again

		}
	}
	
	return status;
}

/***	afpProcessPrivateNotify
 *
 *	Similar to AfpProcessChangeNotify but optimized/special-cased for private notifies.
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 */
VOID FASTCALL
afpProcessPrivateNotify(
	IN	PVOL_NOTIFY			pVolNotify
)
{
	PVOLDESC					pVolDesc;
	UNICODE_STRING				UName;
	PFILE_NOTIFY_INFORMATION	pFNInfo;
	NTSTATUS					status;
	PDFENTRY					pParentDFE;
	BOOLEAN						CloseParentHandle = False, Verify = True;
    BOOLEAN                     DirModified=TRUE;
    BOOLEAN                     fNewVolume=FALSE;
	PFILE_BOTH_DIR_INFORMATION	pFBDInfo;
    LONGLONG                    infobuf[(sizeof(FILE_BOTH_DIR_INFORMATION) +
                (AFP_LONGNAME_LEN + 1) * sizeof(WCHAR))/sizeof(LONGLONG) + 1];
    LONG                        infobuflen;
    BOOLEAN                     fMemAlloced=FALSE;


	PAGED_CODE( );

	pFNInfo = (PFILE_NOTIFY_INFORMATION)(pVolNotify + 1);
	ASSERT (pFNInfo->Action & AFP_ACTION_PRIVATE);

	pVolDesc = pVolNotify->vn_pVolDesc;
	ASSERT (VALID_VOLDESC(pVolDesc));

	INTERLOCKED_DECREMENT_LONG(&pVolDesc->vds_cPrivateNotifies);

    if (pVolDesc->vds_Flags & VOLUME_NEW_FIRST_PASS)
    {
        fNewVolume = TRUE;
    }

	pFBDInfo = (PFILE_BOTH_DIR_INFORMATION)infobuf;
	AfpInitUnicodeStringWithNonNullTerm(&UName,
										(USHORT)pFNInfo->FileNameLength,
										pFNInfo->FileName);
	// We always allocate extra space for notifies
	UName.MaximumLength += (AFP_LONGNAME_LEN+1)*sizeof(WCHAR);

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
			("ParentId %d, Path: %Z\n",pVolNotify->vn_ParentId, &UName));

	// Lookup the parent DFE using the AfpId stored in the notify
	// structure, and setup the UParent and UTail appropriately
	pParentDFE = AfpFindDfEntryById(pVolDesc,
									pVolNotify->vn_ParentId,
									DFE_DIR);
	if (pParentDFE != NULL)
	{
		FILESYSHANDLE	ParentHandle, DirHandle;

		status = STATUS_SUCCESS;

		// Open a handle to the directory relative to the volume root handle
		// Special case volume root
		ASSERT((UName.Length != 0) || (pVolNotify->vn_ParentId == AFP_ID_ROOT));

		do
		{
			PDFENTRY		pDfeNew;
			UNICODE_STRING	UParent, UTail;

			if (pVolNotify->vn_ParentId == AFP_ID_ROOT)
			{
				AfpSetEmptyUnicodeString(&UParent, 0, NULL);
				UTail = UName;
			}
			else
			{
				UParent.MaximumLength =
				UParent.Length = UName.Length - (USHORT)pVolNotify->vn_TailLength - sizeof(WCHAR);
				UParent.Buffer = UName.Buffer;

				UTail.MaximumLength =
				UTail.Length = (USHORT)pVolNotify->vn_TailLength;
				UTail.Buffer = (PWCHAR)((PBYTE)UName.Buffer + UParent.Length + sizeof(WCHAR));
			}

			if (UName.Length != 0)
			{
				// Open a handle to parent relative to the volume root handle
				status = AfpIoOpen(&pVolDesc->vds_hRootDir,
								   AFP_STREAM_DATA,
								   FILEIO_OPEN_DIR,
								   &UParent,
								   FILEIO_ACCESS_NONE,
								   FILEIO_DENY_NONE,
								   False,
								   &ParentHandle);
				if (!NT_SUCCESS(status))
				{
					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
							("afpProcessPrivateNotify: Failed to open parent: %Z (0x%lx)\n",
							&UParent, status));
					break;
				}

				CloseParentHandle = True;


				status = AfpIoQueryDirectoryFile(&ParentHandle,
												 pFBDInfo,
												 sizeof(infobuf),
												 FileBothDirectoryInformation,
												 True,
												 True,
												 &UTail);

                //
                // dir name longer than 31 char? Then we must allocate a buffer
                //
                if ((status == STATUS_BUFFER_OVERFLOW) ||
                    (status == STATUS_BUFFER_TOO_SMALL))
                {
                    infobuflen = sizeof(FILE_BOTH_DIR_INFORMATION) +
                                    (MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR));

                    pFBDInfo = (PFILE_BOTH_DIR_INFORMATION)
                                    AfpAllocNonPagedMemory(infobuflen);

                    if (pFBDInfo == NULL)
                    {
                        status = STATUS_NO_MEMORY;
                        break;
                    }

                    fMemAlloced = TRUE;

				    status = AfpIoQueryDirectoryFile(&ParentHandle,
					        						 pFBDInfo,
							        				 infobuflen,
									        		 FileBothDirectoryInformation,
											         True,
											         True,
											         &UTail);

                }

                if (!NT_SUCCESS(status))
                {
					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
							("afpProcessPrivateNotify: AfpIoQueryDirectoryFile failed: %d %Z at %Z(0x%lx)\n",
							sizeof(infobuf),&UTail, &UParent,status));
					break;
				}

				// Lookup this entry in the data-base. If not there then we need to add
				// it. If its there, we need to verify it.
				// NOTE: Use DFE_ANY here and not DFE_DIR !!!
				pDfeNew = AfpFindEntryByUnicodeName(pVolDesc,
													&UTail,
													AFP_LONGNAME,
													pParentDFE,
													DFE_ANY);
				if (pDfeNew == NULL)
                {
					Verify = False;
                }
			}
			else
			{
				FILE_BASIC_INFORMATION	FBasInfo;


				status = AfpIoQueryBasicInfo(&pVolDesc->vds_hRootDir,
											 &FBasInfo);
				if (!NT_SUCCESS(status))
				{
					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
							("afpProcessPrivateNotify: Could not get basic information for root\n"));
					status = STATUS_UNSUCCESSFUL;
					break;
				}

				afpConvertBasicToBothDirInfo(&FBasInfo, pFBDInfo);
				pDfeNew = pParentDFE;
				ParentHandle = pVolDesc->vds_hRootDir;

				// Root directory needs special casing. The reason here is that we have
				// no parent directory. Also we need to handle the AFP_HAS_CUSTOM_ICON
				// bit in the volume descriptor since the finderinfo on the root volume
				// doesn't have this bit saved.
				if (pVolDesc->vds_Flags & AFP_VOLUME_HAS_CUSTOM_ICON)
				{
					pDfeNew->dfe_FinderInfo.fd_Attr1 |= FINDER_FLAG_HAS_CUSTOM_ICON;
				}
			}

			if (!Verify)
			{
				ASSERT(pDfeNew == NULL);
				afpAddDfEntryAndCacheInfo(pVolDesc,
										  pParentDFE,
										  &UTail,
										  &ParentHandle,
										  pFBDInfo,
										  &UName,
										  &pDfeNew,
										  False);
			}
			else if (pFBDInfo->LastWriteTime.QuadPart > pDfeNew->dfe_LastModTime.QuadPart)
			{
                pDfeNew->dfe_Flags &= ~DFE_FLAGS_INIT_COMPLETED;
				afpVerifyDFE(pVolDesc,
							 pParentDFE,
							 &UTail,
							 &ParentHandle,
							 pFBDInfo,
							 &UName,
							 &pDfeNew);

                DirModified = TRUE;
			}
            else
            {
                DirModified = FALSE;
            }

			if (pDfeNew == NULL)
			{
				DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
						("afpProcessPrivateNotify: Could not add DFE for %Z\n", &UName));
				status = STATUS_UNSUCCESSFUL;
				break;
			}

			pParentDFE = pDfeNew;

			//
			// Now open the directory itself so that it can be enumerated
			// Open the directory relative to its parent since we already
			// have the parent handle open.
			//
			if (Verify && !DirModified && (pVolNotify->vn_ParentId != AFP_ID_ROOT))
			{
			}
			else
			{
				status = AfpIoOpen(&ParentHandle,
							   AFP_STREAM_DATA,
							   FILEIO_OPEN_DIR,
							   &UTail,
							   FILEIO_ACCESS_NONE,
							   FILEIO_DENY_NONE,
							   False,
							   &DirHandle);

				if (!NT_SUCCESS(status))
				{
					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
						("afpProcessPrivateNotify: AfpIoOpen failed: %Z (0x%lx)\n",
						 &UTail, status));
					break;
				}
			}
		} while (False);

        if (fMemAlloced)
        {
            ASSERT(pFBDInfo != ((PFILE_BOTH_DIR_INFORMATION)(infobuf)));

	        AfpFreeMemory(pFBDInfo);
        }

		if (CloseParentHandle)
		{
			AfpIoClose(&ParentHandle);
		}

		if (NT_SUCCESS(status))
		{
			DWORD	Method;

			// Always get the root level files

			if (Verify && !DirModified && (pVolNotify->vn_ParentId != AFP_ID_ROOT))
            {
                Method = GETDIRSKELETON;
            }
            else
            {
                Method = (GETENTIRETREE | REENUMERATE);
            }

			status = AfpCacheDirectoryTree(pVolDesc,
										   pParentDFE,
										   Method,
										   &DirHandle,
										   &UName);
			if (!NT_SUCCESS(status))
			{
				DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
						("afpProcessPrivateNotify: CacheDir failed %lx tree for %Z\n", status,&UName));
			}
			if (Method != GETDIRSKELETON)
			{
				AfpIoClose(&DirHandle);
			}
		}
	}


	afpActivateVolume(pVolDesc);
}


/***	afpActivateVolume
 *
 *	If we just finished caching in the directory structure, activate the volume now.
 *	This is keyed off the AFP_INITIAL_CACHE bit in the volume flags.
 */
VOID FASTCALL
afpActivateVolume(
	IN	PVOLDESC			pVolDesc
)
{
	BOOLEAN	        fCdfs;
	KIRQL	        OldIrql;
	NTSTATUS	    Status = STATUS_SUCCESS;
	UNICODE_STRING	RootName;
    PVOLDESC        pWalkVolDesc;
    IDDBHDR         IdDbHdr;
    BOOLEAN         fPostIrp;
    BOOLEAN         fRetry=TRUE;
	LARGE_INTEGER	ActivationTime;
	ULONG			HighPart;
	ULONG			LowPart;


	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

    // if we have more notifies queued up, we aren't done yet
	if (pVolDesc->vds_cPrivateNotifies != 0)
	{
		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
        return;
	}


    //
    // ok, we're here because the scan of the volume completed
    //

    //
    // if this was a newly created volume and if this was its first pass, we must
    // post the change-notify irp and restart the scan
    //
	if (pVolDesc->vds_Flags & VOLUME_NEW_FIRST_PASS)
	{
        pVolDesc->vds_Flags &= ~VOLUME_NEW_FIRST_PASS;

        // we post a change notify irp if this volume is not an exclusive volume
		fPostIrp = (!EXCLUSIVE_VOLUME(pVolDesc));

		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

		if (fPostIrp)
		{
			// Begin monitoring changes to the tree. Even though we may
			// start processing PC changes before we have finished
			// enumerating the tree, if we get notified of part of the
			// tree we have yet to cache (and therefore can't find it's
			// path in our database its ok, since we will end up
			// picking up the change when we enumerate that branch.  Also,
			// by posting this before starting to cache the tree instead
			// of after, we will pick up any changes that are made to parts
			// of the tree we have already seen, otherwise we would miss
			// those.

			// Explicitly reference this volume for ChangeNotifies and post it
			ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

		    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
				("AfpAdmWVolumeAdd: posting chg-notify irp on volume %Z in second pass\n",
                    &pVolDesc->vds_Name));

			if (AfpVolumeReference(pVolDesc))
            {
			    pVolDesc->vds_RequiredNotifyBufLen = AFP_VOLUME_NOTIFY_STARTING_BUFSIZE;

			    Status = AfpVolumePostChangeNotify(pVolDesc);
			    if (NT_SUCCESS(Status))
			    {
    		        // scan the entire directory tree and sync disk with iddb, now that
                    // we are in the second pass for this (not-so) newly created volume
		            AfpSetEmptyUnicodeString(&RootName, 0, NULL);
		            AfpQueuePrivateChangeNotify(pVolDesc,
			            						&RootName,
				            					&RootName,
					            				AFP_ID_ROOT);
			    }
                else
                {
                    AFPLOG_ERROR(AFPSRVMSG_START_VOLUME,
                                 Status,
                                 NULL,
                                 0,
                                &pVolDesc->vds_Name);

		            DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
				        ("AfpAdmWVolumeAdd: posting chg-notify failed (%lx)!!\n",Status));

                    AfpVolumeDereference(pVolDesc);
                    ASSERT(0);
                }
            }
            else
            {
		        DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
			        ("AfpAdmWVolumeAdd: couldn't reference volume %Z!!\n",&pVolDesc->vds_Name));
            }

		}
    }

    //
    // ok, we are through with all the passes and the scan is successful:
    // mark the volume as 'officially' available to the clients
    //
	else if (pVolDesc->vds_Flags & VOLUME_INITIAL_CACHE)
	{
		pVolDesc->vds_Flags |=  VOLUME_SCAVENGER_RUNNING;
		pVolDesc->vds_Flags &= ~VOLUME_INITIAL_CACHE;


		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

        // Set the type of the ICON<0d> file to 0's so that
		// mac apps will not list it in their file-open dialogs
		fCdfs = !IS_VOLUME_NTFS(pVolDesc);
		if (!fCdfs)
		{
			PDFENTRY		pdfetmp;
			UNICODE_STRING	iconstr;
			WCHAR			iconname[5] = AFPSERVER_VOLUME_ICON_FILE_ANSI;

			AfpInitUnicodeStringWithNonNullTerm(&iconstr,
												sizeof(iconname),
												iconname);

			if ((pdfetmp = AfpFindEntryByUnicodeName(pVolDesc,
													 &iconstr,
													 AFP_LONGNAME,
													 pVolDesc->vds_pDfeRoot,
													 DFE_FILE)) != NULL)
			{
				pdfetmp->dfe_FinderInfo.fd_TypeD = 0;
			}

			// Kick off the OurChange scavenger scheduled routine
			// Explicitly reference this for the scavenger routine
			if (AfpVolumeReference(pVolDesc))
            {
			    // Schedule the scavenger to run periodically. This scavenger
			    // is queued since it acquires a SWMR.
			    AfpScavengerScheduleEvent(AfpOurChangeScavenger,
				    					  pVolDesc,
					    				  VOLUME_OURCHANGE_AGE,
						    			  False);
            }
            else
            {
		        DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
			        ("afpActivateVolume: couldn't reference volume %Z!!\n",
                    &pVolDesc->vds_Name));
            }

		}

		Status = AfpIoQueryTimesnAttr(&pVolDesc->vds_hRootDir,
								      &pVolDesc->vds_pDfeRoot->dfe_CreateTime,
								      &pVolDesc->vds_pDfeRoot->dfe_LastModTime,
								      NULL);

        pVolDesc->vds_CreateTime = pVolDesc->vds_pDfeRoot->dfe_CreateTime;

        if (NT_SUCCESS(Status))
        {
            pVolDesc->vds_ModifiedTime =
                AfpConvertTimeToMacFormat(&pVolDesc->vds_pDfeRoot->dfe_LastModTime);
        }
        else
        {
            pVolDesc->vds_ModifiedTime = pVolDesc->vds_pDfeRoot->dfe_CreateTime;
        }

		// Kick off the scavenger thread scheduled routine
		// Explicitly reference this for the scavenger routine
		if (AfpVolumeReference(pVolDesc))
        {
            //
            // let's save the index file the way we know it now
            // (setting vds_cScvgrIdDb to 1 will trigger it via scavenger thread)
            //
            if (IS_VOLUME_NTFS(pVolDesc))
            {
                ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);
                pVolDesc->vds_cScvgrIdDb = 1;
                RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
            }


		    // Schedule the scavenger to run periodically. Always make the
		    // scavenger use the worker thread for CD-ROM volumes since we
		    // 'nudge' it every invocation to see if the CD is in the drive
		    AfpScavengerScheduleEvent(AfpVolumeScavenger,
			    					  pVolDesc,
				    				  fCdfs ?
					    				VOLUME_CDFS_SCAVENGER_INTERVAL :
						    			VOLUME_NTFS_SCAVENGER_INTERVAL,
							    	  fCdfs);

            //
            // another workaround for an Apple bug.  If creation date on two
            // volumes is identical, the alias manager gets all confused and points
            // alias for one guy to another!
            // See if this volume's creation date is the same as any of the other
            // volume's creation date: if so, add 1 second
            //
            while (fRetry)
            {
                fRetry = FALSE;

                ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

                for (pWalkVolDesc = AfpVolumeList;
                     pWalkVolDesc != NULL;
                     pWalkVolDesc = pWalkVolDesc->vds_Next)
                {
                    if (pWalkVolDesc == pVolDesc)
                    {
                        continue;
                    }

                    if (pWalkVolDesc->vds_CreateTime == pVolDesc->vds_CreateTime)
                    {
	                    DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
			                ("Vol creation date conflict: %Z and %Z.  Hack-o-rama at work\n",
                            &pVolDesc->vds_Name,&pWalkVolDesc->vds_Name));

                        pVolDesc->vds_CreateTime += 1;
                        fRetry = TRUE;
                        break;
                    }
                }

                RELEASE_SPIN_LOCK(&AfpVolumeListLock,OldIrql);
            }

			KeQuerySystemTime (&ActivationTime);

	        DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
			    ("afpActivateVolume: volume %Z activated %s at %8lx%08lx , max notifies=%ld\n", 
						 &pVolDesc->vds_Name,
                        (pVolDesc->vds_Flags & AFP_VOLUME_SUPPORTS_CATSRCH) ?
                        " " : "(CatSearch disabled)", 
						0xffffffff*ActivationTime.HighPart,
						0xffffffff*ActivationTime.LowPart,
						pVolDesc->vds_maxPrivateNotifies
						));
			if ((int)(pVolDesc->vds_IndxStTime.LowPart-ActivationTime.LowPart) >= 0)
			{
				LowPart = pVolDesc->vds_IndxStTime.LowPart-ActivationTime.LowPart;
				HighPart = pVolDesc->vds_IndxStTime.HighPart-ActivationTime.HighPart;
			}
			else
			{
				LowPart = 0xffffffff - ActivationTime.LowPart + 1 + pVolDesc->vds_IndxStTime.LowPart;
				HighPart = pVolDesc->vds_IndxStTime.HighPart-ActivationTime.HighPart -1;
			}
	        DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
					("Time taken for indexing = %8lx%08lx\n",
					 0xffffffff*(pVolDesc->vds_IndxStTime.HighPart-ActivationTime.HighPart),
					 0xffffffff*(pVolDesc->vds_IndxStTime.LowPart-ActivationTime.LowPart)
					 ));
        }
        else
        {
	        DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
			    ("afpActivateVolume: couldn't reference volume %Z\n",&pVolDesc->vds_Name));
        }
	}
    else
    {
		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
    }
}

/***	AfpShouldWeIgnoreThisNotification
 *
 *	Check to see if this notification should be ignored. The following events are
 *	ignored.
 *
 *		(((Action == FILE_ACTION_MODIFIED_STREAM) &&
 *		  (Stream != AFP_RESC_STREAM)			  &&
 *		  (Stream != AFP_INFO_STREAM))				||
 *		 (Its one of our own changes))
 *
 *	LOCKS:	vds_VolLock (SPIN)
 */
BOOLEAN FASTCALL
AfpShouldWeIgnoreThisNotification(
	IN	PVOL_NOTIFY		pVolNotify
)
{
	PFILE_NOTIFY_INFORMATION pFNInfo;
	PVOLDESC				 pVolDesc;
	UNICODE_STRING			 UName;
	BOOLEAN					 ignore = False;

	pFNInfo = (PFILE_NOTIFY_INFORMATION)(pVolNotify + 1);
	pVolDesc = pVolNotify->vn_pVolDesc;
	AfpInitUnicodeStringWithNonNullTerm(&UName,
										(USHORT)pFNInfo->FileNameLength,
										pFNInfo->FileName);

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
			("AfpShouldWeIgnoreThisNotification: Action: %d Name: %Z\n", pFNInfo->Action, &UName));

	pVolNotify->vn_StreamId = AFP_STREAM_DATA;
	if (pFNInfo->Action == FILE_ACTION_MODIFIED_STREAM)
	{
		UNICODE_STRING	UStream;

		ignore = True;
		UStream.Length = UStream.MaximumLength = AfpInfoStream.Length;
		UStream.Buffer = (PWCHAR)((PBYTE)UName.Buffer +
								  UName.Length - AfpInfoStream.Length);

		if (EQUAL_UNICODE_STRING(&UStream, &AfpInfoStream, False))
		{
			pVolNotify->vn_StreamId = AFP_STREAM_INFO;
			pFNInfo->FileNameLength -= AfpInfoStream.Length;
			UName.Length -= AfpInfoStream.Length;
			ignore = False;
		}
		else
		{
			UStream.Length = UStream.MaximumLength = AfpResourceStream.Length;
			UStream.Buffer = (PWCHAR)((PBYTE)UName.Buffer +
									  UName.Length - AfpResourceStream.Length);

			if (EQUAL_UNICODE_STRING(&UStream, &AfpResourceStream, False))
			{
				pVolNotify->vn_StreamId = AFP_STREAM_RESC;
				pFNInfo->FileNameLength -= AfpResourceStream.Length;
				UName.Length -= AfpResourceStream.Length;
				ignore = False;
			}
		}
	}

	if (!ignore)
	{
		PLIST_ENTRY		pList, pListHead;
		POUR_CHANGE		pChange;
		DWORD			afpChangeAction;
		KIRQL			OldIrql;

		afpChangeAction = AFP_CHANGE_ACTION(pFNInfo->Action);

		ASSERT(afpChangeAction <= AFP_CHANGE_ACTION_MAX);

		ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

		// point to the head of the appropriate change action list
		pListHead = &pVolDesc->vds_OurChangeList[afpChangeAction];

		for (pList = pListHead->Flink;
			 pList != pListHead;
			 pList = pList->Flink)
		{
			pChange = CONTAINING_RECORD(pList, OUR_CHANGE, oc_Link);

			// do a case *sensitive* unicode string compare
			if (EQUAL_UNICODE_STRING_CS(&UName, &pChange->oc_Path))
			{
				RemoveEntryList(&pChange->oc_Link);
				AfpFreeMemory(pChange);

				// We were notified of our own change
				ignore = True;

				if (pFNInfo->Action == FILE_ACTION_RENAMED_OLD_NAME)
				{
					// consume the RENAMED_NEW_NAME if it exists
					if (pFNInfo->NextEntryOffset != 0)
					{
						PFILE_NOTIFY_INFORMATION	pFNInfo2;

						(PBYTE)pFNInfo2 = (PBYTE)pFNInfo + pFNInfo->NextEntryOffset;
						if (pFNInfo2->Action == FILE_ACTION_RENAMED_NEW_NAME)
						{
							ASSERT(pFNInfo2->NextEntryOffset == 0);
						}
						else
						{
							DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
									("AfpShouldWeIgnoreThisNotification: Our Rename did not come with new name!!!\n"));
						}
					}
					else
					{
						DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
								("AfpShouldWeIgnoreThisNotification: Our Rename did not come with new name!!!\n"));

					}
				} // if rename
				else
				{
					// We are ignoring this notify. Make sure its not a multiple
					ASSERT(pFNInfo->NextEntryOffset == 0);
				}

				break;
			}
		} // while there are more of our changes to look thru

		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
	}
	else
	{
		// We are ignoring this notify. Make sure its not a multiple
		ASSERT(pFNInfo ->NextEntryOffset == 0);
	}

	if (!ignore)
	{
		INTERLOCKED_INCREMENT_LONG(&pVolDesc->vds_cOutstandingNotifies);
		DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
				("ShouldWe: Action: %d Name: \t\t\t\t\t\n%Z\n", pFNInfo->Action, &UName));
	}

	return ignore;
}


/***	AfpCacheDirectoryTree
 *
 *	Scan a directory tree and build the idindex database from this information.
 *	Do a breadth-first search. On volume start, this will cache the tree
 *	beginning at the root directory. For Directory ADDED notifications, this
 *	will cache the subtree beginning at the added directory, since a PC user can
 *  potentially move an entire subtree into a mac volume, but we will only
 *  be notified of the one directory addition.
 *
 *	Only the first level is actually handled here. Sub-directories are queued up
 *	as faked notifies and handled that way.
 *
 *  Method:
 *  REENUMERATE:		In case we need to reenumerate just
 *						this level in the tree in order to
 *						get rid of any dead wood that a PC
 *						removed by its 'other' name
 *
 *	GETDIRSKELETON:		When we want to bring in only the skeleton
 *						of the tree by adding directories only
 *
 *	GETFILES:			When we need to fill in the files for this
 *						level of the tree because a mac has accessed
 *						a dir for the first time.
 *
 *  GetDirSkeletonAndFiles:
 *						A Combination of the above two.
 *						When we want to bring in both files and directories.
 *						This is used when adding a volume, and we want the
 *						files in the root directory cached in, but no others.
 *						Also this will be used if we are rebuilding the
 *						Desktop database APPLs while caching the disk tree.
 *						The private ChangeNotifies we queue up for ADDED dirs
 *						will also read in the files if the volume is marked
 *						for rebuilding of the desktop.
 *
 *	GETENTIRETREE:		When we want to cache in the entire tree
 *
 *	GetEntireTreeAndReEnumerate:
 *						Combines GETENTIRETREE and REENUMERATE
 *
 *  LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Exclusive)
 */
NTSTATUS
AfpCacheDirectoryTree(
	IN	PVOLDESC			pVolDesc,
	IN	PDFENTRY			pDFETreeRoot,		// DFE of the tree root directory
	IN	DWORD				Method,				// See explanation in procedure comment
	IN	PFILESYSHANDLE		phRootDir OPTIONAL, // open handle to tree root directory
	IN	PUNICODE_STRING		pDirPath  OPTIONAL
)
{
	UNICODE_STRING				UName, Path, ParentPath;
    UNICODE_STRING              RootName;
	PDFENTRY					pDFE;
	PDFENTRY					pChainDFE;
	PDFENTRY					pCurrDfe;
	NTSTATUS					Status = STATUS_SUCCESS;
	PBYTE						enumbuf = NULL;
	PFILE_BOTH_DIR_INFORMATION	pNextEntry;
	FILESYSHANDLE				fshEnumDir;
	USHORT						SavedPathLength;
    BOOLEAN                     fQueueThisSubDir=FALSE;
    BOOLEAN                     fOneSubDirAlreadyQueued=FALSE;
    BOOLEAN                     fAllSubDirsVisited=TRUE;
    BOOLEAN                     fExitLoop=FALSE;
#ifdef	PROFILING
	TIME						TimeS, TimeE, TimeD;
	DWORD						NumScanned = 0;

	AfpGetPerfCounter(&TimeS);
#endif

	PAGED_CODE( );

	ASSERT (VALID_DFE(pDFETreeRoot));
	ASSERT (DFE_IS_DIRECTORY(pDFETreeRoot));

	ASSERT((Method != GETFILES) || !DFE_CHILDREN_ARE_PRESENT(pDFETreeRoot));

	// allocate the buffer that will hold enumerated files and dirs
	if ((pVolDesc->vds_EnumBuffer == NULL) &&
		((pVolDesc->vds_EnumBuffer = (PBYTE)AfpAllocPANonPagedMemory(AFP_ENUMBUF_SIZE)) == NULL))
	{
		return STATUS_NO_MEMORY;
	}

	do
	{
		fshEnumDir.fsh_FileHandle = NULL;
		enumbuf = pVolDesc->vds_EnumBuffer;

		// Get the volume root relative path to the directory tree being scanned
		// Get extra space for one more entry to tag on for queuing notifies.
		// In case we already have the path corres. to directory we are attempting
		// to cache, get it from there. Note that in this case we are always
		// guaranteed that extra space is available
		if (ARGUMENT_PRESENT(pDirPath))
		{
			Path = *pDirPath;
		}
		else
		{
			AfpSetEmptyUnicodeString(&Path, 0, NULL);
			Status = AfpHostPathFromDFEntry(pDFETreeRoot,
											(AFP_LONGNAME_LEN+1)*sizeof(WCHAR),
											&Path);

			if (!NT_SUCCESS(Status))
			{
				break;
			}
		}

		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("AfpCacheDirectoryTree: ParentId %d, Path %Z\n",
				 pDFETreeRoot->dfe_AfpId, &Path));

		if (Method != GETDIRSKELETON)
		{
		if (!ARGUMENT_PRESENT(phRootDir))
		{
			// Need to open a handle to the directory in order to enumerate
			if (NT_SUCCESS(Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
											  AFP_STREAM_DATA,
											  FILEIO_OPEN_DIR,
											  &Path,
											  FILEIO_ACCESS_NONE,
											  FILEIO_DENY_NONE,
											  False,
											  &fshEnumDir)))
			{
				phRootDir = &fshEnumDir;
			}
			else
			{
				break;
			}
		}
		}

		SavedPathLength = Path.Length;

		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("AfpCacheDirectoryTree: Scanning Tree: %Z\n", &Path));

		if (Method & REENUMERATE)
		{
			afpMarkAllChildrenUnseen(pDFETreeRoot);
		}

		if (Method != GETDIRSKELETON)
		{

		while (True)
		{
			// keep enumerating till we get all the entries
			Status = AfpIoQueryDirectoryFile(phRootDir,
											 (PFILE_BOTH_DIR_INFORMATION)enumbuf,
											 AFP_ENUMBUF_SIZE,
											 FileBothDirectoryInformation,
											 False, // return multiple entries
											 False, // don't restart scan
											 NULL);

			ASSERT(Status != STATUS_PENDING);

			if (Status != STATUS_SUCCESS)
			{
				if ((Status == STATUS_NO_MORE_FILES) ||
					(Status == STATUS_NO_SUCH_FILE))
				{
					Status = STATUS_SUCCESS;
					break; // that's it, we've seen everything there is
				}
				else
				{
					AFPLOG_HERROR(AFPSRVMSG_ENUMERATE,
								  Status,
								  NULL,
								  0,
								  phRootDir->fsh_FileHandle);
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							("AfpCacheDirectoryTree: dir enum failed %lx\n", Status));
					break;	// enumerate failed, bail out
				}
			}

			// process the enumerated files and dirs in the current enumbuf
			pNextEntry = (PFILE_BOTH_DIR_INFORMATION)enumbuf;

			while (True)
			{
				BOOLEAN						IsDir, WriteBackROAttr, FixIt;
				WCHAR						wc;
				PFILE_BOTH_DIR_INFORMATION	pCurrEntry;

                fQueueThisSubDir = FALSE;

				if (pNextEntry == NULL)
				{
					Status = STATUS_NO_MORE_ENTRIES;
					break;
				}
				WriteBackROAttr = False;
				IsDir = False;

				// Move the structure to the next entry or NULL if we hit the end
				pCurrEntry = pNextEntry;
				(PBYTE)pNextEntry += pCurrEntry->NextEntryOffset;
				if (pCurrEntry->NextEntryOffset == 0)
				{
					pNextEntry = NULL;
				}

				if (pCurrEntry->FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					// Ignore dirs if we are only getting files for this level
					if (Method == GETFILES)
					{
						continue;
					}
					IsDir = True;
				}
				else if (Method == GETDIRSKELETON)
				{
					// Ignore files if we are only getting the dir skeleton
					continue;
				}

				// If NT name > AFP_LONGNAME_LEN, use the NT shortname for
				// Mac longname on NTFS, any other file system the shortname
				// will be null, so ignore the file
				//if (pCurrEntry->FileNameLength <= (AFP_LONGNAME_LEN*sizeof(WCHAR)))
					
				AfpInitUnicodeStringWithNonNullTerm(&UName,
						(USHORT)pCurrEntry->FileNameLength,
						pCurrEntry->FileName);
				if ((RtlUnicodeStringToAnsiSize(&UName)-1) <= AFP_LONGNAME_LEN)
				{
					AfpInitUnicodeStringWithNonNullTerm(&UName,
														(USHORT)pCurrEntry->FileNameLength,
														pCurrEntry->FileName);
				}
				else if (pCurrEntry->ShortNameLength > 0)
				{
					AfpInitUnicodeStringWithNonNullTerm(&UName,
														(USHORT)pCurrEntry->ShortNameLength,
														pCurrEntry->ShortName);
				}
				else
				{
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							("AfpCacheDirectoryTree: Name is > 31 with no short name ?\n"));
					continue;
				}

				if (IsDir &&
					(EQUAL_UNICODE_STRING_CS(&Dot, &UName) ||
					 EQUAL_UNICODE_STRING_CS(&DotDot, &UName)))
				{
					continue;
				}

				// Check if this entry is an invalid win32 name i.e. it has either
				// a period or a space at end, if so convert it to the new format.
				// NOTE: can we construct a path to use to catch our own changes ?
				wc = UName.Buffer[(UName.Length - 1)/sizeof(WCHAR)];
				if ((wc == UNICODE_SPACE) || (wc == UNICODE_PERIOD))
				{
                    // NOTE: MacCD driver should fix this??
                    if (IS_VOLUME_NTFS(pVolDesc))
                    {
                        afpRenameInvalidWin32Name(phRootDir, IsDir, &UName);
                    }
				}

#ifdef	PROFILING
				NumScanned++;
#endif
				pDFE = NULL;
				FixIt = False;
				if (Method & REENUMERATE)
				{
					// If we have this item in our DB, just mark it as seen.
					// Use DFE_ANY here since a mismatch is fatal.
					afpFindDFEByUnicodeNameInSiblingList(pVolDesc,
														 pDFETreeRoot,
														 &UName,
														 &pDFE,
														 DFE_ANY);
					if (pDFE != NULL)
					{
						// If we have a wrong type, fix it.
						if (IsDir ^ DFE_IS_DIRECTORY(pDFE))
						{
							AfpDeleteDfEntry(pVolDesc, pDFE);
							pDFE = NULL;
							FixIt = True;
						}
						else
						{
							DFE_MARK_AS_SEEN(pDFE);
						}
					}
				}

				if ((Method != REENUMERATE) || FixIt) 
				{
					// add this entry to the idindex database, and cache all the required
					// information, but only for files since the directories are queued
					// back and added at that time.
					if (!IsDir)
					{
						// Construct a full path to the file in order to filter our
						// own changes to AFP_AfpInfo stream when adding the file
						if (Path.Length > 0)
						{
							// Append a path separator
							Path.Buffer[Path.Length / sizeof(WCHAR)] = L'\\';
							Path.Length += sizeof(WCHAR);
						}
						ASSERT(Path.Length + UName.Length <= Path.MaximumLength);
						RtlAppendUnicodeStringToString(&Path, &UName);

						if (pDFE == NULL)
						{
							afpAddDfEntryAndCacheInfo(pVolDesc,
													  pDFETreeRoot,
													  &UName,
													  phRootDir,
													  pCurrEntry,
													  &Path,
													  &pDFE,
													  True);
						}
						else if (pCurrEntry->LastWriteTime.QuadPart > pDFE->dfe_LastModTime.QuadPart)
						{
							afpVerifyDFE(pVolDesc,
										 pDFETreeRoot,
										 &UName,
										 phRootDir,
										 pCurrEntry,
										 &Path,
										 &pDFE);
						}


						// Restore the original length of the path to enum dir
						Path.Length = SavedPathLength;


						if (pDFE == NULL)
						{
							// one reason this could fail is if we encounter pagefile.sys
							// if our volume is rooted at the drive root
							DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
									("AfpCacheDirectoryTree: AddDfEntry failed %Z at %Z\n",&UName,&Path));
							continue;
						}
						else if (Method == (GETENTIRETREE | REENUMERATE))
						{
							DFE_MARK_AS_SEEN(pDFE);
						}
					}
					else
					{
						ASSERT(IsDir);
						ASSERT ((Method != GETFILES) &&
								(Method != REENUMERATE));

						// queue this directory as a simulated Notify of a directory add.
                        // If we have too much stuff on the queue already, then queue
                        // only one subdirectory so that we are guaranteed to eventually
                        // visit all the subdirs.  Also, on a huge volume, we want to limit
                        // how many directories enque per level of the tree
                        //

                        fQueueThisSubDir = TRUE;

						// We dont use this flag DFE_FLAGS_INIT_COMPLETED
						// anymore. So, reducing one lookup
#if 0
				        pCurrDfe = AfpFindEntryByUnicodeName(pVolDesc,
													         &UName,
													         AFP_LONGNAME,
													         pDFETreeRoot,
													         DFE_ANY);

                        //
                        // if this subdir is already complete, skip it
                        //
				        if ((pCurrDfe != NULL) &&
                            (pCurrDfe->dfe_Flags & DFE_FLAGS_INIT_COMPLETED))
                        {
                            fQueueThisSubDir = FALSE;
                        }
#endif

                        if (fQueueThisSubDir)
                        {
						    AfpQueuePrivateChangeNotify(pVolDesc,
							    						&UName,
								    					&Path,
									    				pDFETreeRoot->dfe_AfpId);
                        }
					}
				}

                if (fExitLoop)
                {
                    break;
                }

			} // while more entries in the enumbuf

			if ((!NT_SUCCESS(Status) && (Status != STATUS_NO_MORE_ENTRIES)) ||
                (fExitLoop))
			{
				break;
			}

		} // while there are more files to enumerate


		if (NT_SUCCESS(Status))
		{
			if (Method & REENUMERATE)
			{
				afpPruneUnseenChildren(pVolDesc, pDFETreeRoot);
			}

			DFE_MARK_CHILDREN_PRESENT(pDFETreeRoot);
		}
        else
		{
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
					("AfpCacheDirectoryTree: Status %lx\n", Status));
		}

		} /* if Method != GETDIRSKELETON */
		else if (Method == GETDIRSKELETON)
		{
			PDFENTRY 	pcurrDfEntry;
			PDFENTRY	pDfEntry;	
		
			pcurrDfEntry = (pDFETreeRoot)->dfe_pDirEntry->de_ChildDir;				
			do														
			{														
				for (NOTHING;										
						pcurrDfEntry != NULL;								
						pcurrDfEntry = pcurrDfEntry->dfe_NextSibling)
				{													
#if 0
					if (((*(_ppDfEntry))->dfe_NameHash == NameHash)	&&	
							EQUAL_UNICODE_STRING(&((*(_ppDfEntry))->dfe_UnicodeName), 
									_pName,				
									True))					
					{													
						afpUpdateDfeAccessTime(_pVolDesc, *(_ppDfEntry));
						Found = True;									
						break;										
					}											
#endif
						    
					AfpQueuePrivateChangeNotify(pVolDesc,
							&(pcurrDfEntry->dfe_UnicodeName),
							&Path,
							pDFETreeRoot->dfe_AfpId);

				}											

				Status = STATUS_SUCCESS;

			} while (False);								

		} /* if Method == GETDIRSKELETON */
		
	} while (False);


	ASSERT (enumbuf != NULL);
	if ((pVolDesc->vds_cPrivateNotifies == 0) &&
		(pVolDesc->vds_cOutstandingNotifies == 0))
	{
		if (enumbuf != NULL)
		{
			AfpFreePANonPagedMemory(enumbuf, AFP_ENUMBUF_SIZE);
		}
		pVolDesc->vds_EnumBuffer = NULL;
	}


	ASSERT (Path.Buffer != NULL);
	if (!ARGUMENT_PRESENT(pDirPath) && (Path.Buffer != NULL))
	{
		AfpFreeMemory(Path.Buffer);
	}

	if (fshEnumDir.fsh_FileHandle != NULL)
	{
		AfpIoClose(&fshEnumDir);
	}

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_ULONG(&AfpServerProfile->perf_ScanTreeCount,
						  NumScanned,
						  &AfpStatisticsLock);
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_ScanTreeTime,
								TimeD,
								&AfpStatisticsLock);
#endif

	return Status;
}


BOOLEAN FASTCALL
AfpVolumeAbortIndexing(
    IN  PVOLDESC    pVolDesc
)
{

    KIRQL           OldIrql;
    PKQUEUE         pNotifyQueue;
    PLIST_ENTRY     pNotifyList;
    PLIST_ENTRY     pPrivateNotifyList;
    LIST_ENTRY      TransitionList;
    PLIST_ENTRY     pList, pNext;
    LARGE_INTEGER   Immediate;
    PVOL_NOTIFY     pVolNotify;
    LONG            index;
    DWORD           DerefCount=0;
    DWORD           PvtNotifyCount=0;
    BOOLEAN         fResult=TRUE;
    BOOLEAN         fNewVolume=FALSE;
    BOOLEAN         fCancelNotify=FALSE;

	
    DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR, 
			("AbortIndexing: Aborting Index for Volume\n"));

    ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

    fNewVolume = (pVolDesc->vds_Flags & VOLUME_NEW_FIRST_PASS) ? TRUE : FALSE;

    pVolDesc->vds_Flags |= VOLUME_DELETED;

    // set this so we don't reset the Indexing global flag again!
    pVolDesc->vds_Flags |= VOLUME_INTRANSITION;

    if (pVolDesc->vds_Flags & VOLUME_NOTIFY_POSTED)
    {
        ASSERT(pVolDesc->vds_pIrp != NULL);
        fCancelNotify = TRUE;
    }

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

    if (fCancelNotify)
    {
        IoCancelIrp(pVolDesc->vds_pIrp);
    }

    InitializeListHead(&TransitionList);

    index = pVolDesc->vds_VolId % NUM_NOTIFY_QUEUES;

    pNotifyQueue = &AfpVolumeNotifyQueue[index];
    pNotifyList = &AfpVolumeNotifyList[index];
    pPrivateNotifyList = &AfpVirtualMemVolumeNotifyList[index];
    Immediate.HighPart = Immediate.LowPart = 0;

    while (1)
    {
        pList = KeRemoveQueue(pNotifyQueue, KernelMode, &Immediate);

        //
        // finished the list?
        //
        if ((NTSTATUS)((ULONG_PTR)pList) == STATUS_TIMEOUT)
        {
            break;
        }

        pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);

        //
        // some other notifications?  keep them on temp list for now
        //
        if ((pVolNotify->vn_pVolDesc != pVolDesc) ||
            (pVolNotify == &AfpTerminateNotifyThread))
        {
            InsertTailList(&TransitionList, pList);
        }

        //
        // notification for this volume: get rid of it
        //
        else
        {
            ASSERT(pVolNotify->vn_pVolDesc == pVolDesc);
            ASSERT((pVolNotify->vn_TimeStamp == AFP_QUEUE_NOTIFY_IMMEDIATELY) ||
                   (!fNewVolume));

            // was this a private notify?
            if (((PFILE_NOTIFY_INFORMATION)(pVolNotify + 1))->Action & AFP_ACTION_PRIVATE)
            {
                INTERLOCKED_DECREMENT_LONG(&pVolDesc->vds_cPrivateNotifies);
            }
            AfpFreeMemory(pVolNotify);
            AfpVolumeDereference(pVolDesc);
            AfpNotifyQueueCount[index]--;
        }
    }

    ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);
    pList = pNotifyList->Flink;
    while (pList != pNotifyList)
    {
        pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);
        pNext = pList->Flink;
        if (pVolNotify->vn_pVolDesc == pVolDesc)
        {
            RemoveEntryList(pList);

            // was this a private notify?
            if (((PFILE_NOTIFY_INFORMATION)(pVolNotify + 1))->Action & AFP_ACTION_PRIVATE)
            {
                PvtNotifyCount++;
            }

            DerefCount++;
            AfpFreeMemory(pVolNotify);
            AfpNotifyListCount[index]--;
        }

        pList = pNext;
    }
    RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    AfpSwmrAcquireExclusive(&AfpVolumeListSwmr);
    pList = pPrivateNotifyList->Flink;
    while (pList != pPrivateNotifyList)
    {
        pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);
        pNext = pList->Flink;
        if (pVolNotify->vn_pVolDesc == pVolDesc)
        {
            RemoveEntryList(pList);
			afpFreeNotify(pVolNotify);

            AfpVolumeDereference(pVolDesc);

            //AfpNotifyListCount[index]--;
        }

        pList = pNext;
    }
    AfpSwmrRelease(&AfpVolumeListSwmr);

    if (DerefCount > 0)
    {
	    ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

        ASSERT(pVolDesc->vds_RefCount >= DerefCount);
        ASSERT(pVolDesc->vds_cPrivateNotifies >= (LONG)PvtNotifyCount);

        pVolDesc->vds_RefCount -= (DerefCount - 1);
        pVolDesc->vds_cPrivateNotifies -= PvtNotifyCount;

        RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

        AfpVolumeDereference(pVolDesc);
    }

    //
    // if there were any other notifications, put them back on the queue
    //
    while (!IsListEmpty(&TransitionList))
    {
        pList = TransitionList.Flink;
        pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);

        ASSERT(pVolNotify->vn_pVolDesc != pVolDesc);
        RemoveEntryList(pList);
        AfpVolumeQueueChangeNotify(pVolNotify, pNotifyQueue);
    }


    return(fResult);
}

BOOLEAN FASTCALL
AfpVolumeStopIndexing(
	IN  PVOLDESC   	   pVolDesc,
    IN  PVOL_NOTIFY    pInVolNotify
)
{

    PKQUEUE         pNotifyQueue;
    PLIST_ENTRY     pNotifyList;
    PLIST_ENTRY     pPrivateNotifyList;
    PLIST_ENTRY     pList, pNext;
    LARGE_INTEGER   Immediate;
    PVOL_NOTIFY     pVolNotify;
    LONG            index;
    BOOLEAN         fResult=TRUE;

    DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR, 
			("StopIndexing: Stopping Index for Volume\n"));

    index = pVolDesc->vds_VolId % NUM_NOTIFY_QUEUES;

    pNotifyQueue = &AfpVolumeNotifyQueue[index];
    pNotifyList = &AfpVolumeNotifyList[index];
    pPrivateNotifyList = &AfpVirtualMemVolumeNotifyList[index];
    Immediate.HighPart = Immediate.LowPart = 0;

    AfpSwmrAcquireExclusive(&AfpVolumeListSwmr);
    pList = pPrivateNotifyList->Flink;
    while (pList != pPrivateNotifyList)
    {
        pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);
        pNext = pList->Flink;
        if ((pVolNotify->vn_pVolDesc == pVolDesc) && 
						(pVolNotify != pInVolNotify))
        {
            RemoveEntryList(pList);
			afpFreeNotify(pVolNotify);

            AfpVolumeDereference(pVolDesc);

            //AfpNotifyListCount[index]--;
        }

        pList = pNext;
    }
    AfpSwmrRelease(&AfpVolumeListSwmr);


    return(fResult);
}


/***	AfpQueuePrivateChangeNotify
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 */
VOID
AfpQueuePrivateChangeNotify(
	IN	PVOLDESC			pVolDesc,
	IN	PUNICODE_STRING		pName,
	IN	PUNICODE_STRING		pPath,
	IN	DWORD				ParentId
)
{

    DWORD       dwSize;
	LONG		Index;
	PLIST_ENTRY	pVirtualNotifyList;

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
			("PvtNotify: ParentId %d, Path %Z, Name %Z\n",
			ParentId, pPath, pName));

	pVirtualNotifyList = &AfpVirtualMemVolumeNotifyList[pVolDesc->vds_VolId % NUM_NOTIFY_QUEUES];

	// Reference the volume for Notify processing
	if (AfpVolumeReference(pVolDesc))
	{
		PVOL_NOTIFY					pVolNotify;
		PFILE_NOTIFY_INFORMATION	pNotifyInfo;

		DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
				("AfpQueuePrivateChangeNotify: Queuing directory %Z\\%Z\n", pPath, pName));

		// Allocate an extra component worths
		dwSize = sizeof(VOL_NOTIFY) +
				 sizeof(FILE_NOTIFY_INFORMATION) +
				 pPath->Length +
				 pName->Length +
				 (AFP_LONGNAME_LEN+1)*sizeof(WCHAR)+
				 sizeof(WCHAR);

		Index = NOTIFY_USIZE_TO_INDEX(pPath->Length+pName->Length+sizeof(WCHAR));
		pVolNotify = afpAllocNotify (Index, TRUE);

		if (pVolNotify != NULL)
		{
			LONG	Offset = 0;

			INTERLOCKED_INCREMENT_LONG(&pVolDesc->vds_cPrivateNotifies);
			if (pVolDesc->vds_cPrivateNotifies > pVolDesc->vds_maxPrivateNotifies)
			{
				pVolDesc->vds_maxPrivateNotifies = pVolDesc->vds_cPrivateNotifies;
			}

			pVolNotify->vn_VariableLength = pPath->Length+pName->Length+sizeof(WCHAR);
			pVolNotify->vn_pVolDesc = pVolDesc;
			pVolNotify->vn_Processor = afpProcessPrivateNotify;
			pVolNotify->vn_TimeStamp = AFP_QUEUE_NOTIFY_IMMEDIATELY;
			pVolNotify->vn_ParentId = ParentId;
			pVolNotify->vn_TailLength = pName->Length;
			pVolNotify->vn_StreamId = AFP_STREAM_DATA;
			pNotifyInfo = (PFILE_NOTIFY_INFORMATION)((PBYTE)pVolNotify + sizeof(VOL_NOTIFY));
			pNotifyInfo->NextEntryOffset = 0;
			pNotifyInfo->Action = FILE_ACTION_ADDED | AFP_ACTION_PRIVATE;
			pNotifyInfo->FileNameLength = pName->Length + pPath->Length;
			if (pPath->Length > 0)
			{
				RtlCopyMemory(pNotifyInfo->FileName,
							  pPath->Buffer,
							  pPath->Length);

				pNotifyInfo->FileName[pPath->Length/sizeof(WCHAR)] = L'\\';
				pNotifyInfo->FileNameLength += sizeof(WCHAR);
				Offset = pPath->Length + sizeof(WCHAR);
			}
			if (pName->Length > 0)
			{
				RtlCopyMemory((PBYTE)pNotifyInfo->FileName + Offset,
							  pName->Buffer,
							  pName->Length);
			}

			AfpSwmrAcquireExclusive(&AfpVolumeListSwmr);
			InsertTailList(pVirtualNotifyList, &pVolNotify->vn_List);
			AfpSwmrRelease(&AfpVolumeListSwmr);

		}
		else
		{
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
					("AfpQueuePrivateChangeNotify: Queuing of notify for directory %Z\\%Z failed\n",
					pPath, pName));

            AFPLOG_ERROR(AFPSRVMSG_VOLUME_INIT_FAILED,
                         STATUS_INSUFFICIENT_RESOURCES,
                         NULL,
                         0,
                         &pVolDesc->vds_Name);

            //
            // this will remove all the entries that have been queued so far
            //
            AfpVolumeAbortIndexing(pVolDesc);

            // remove the refcount put above when vol referenced
			AfpVolumeDereference(pVolDesc);

            // remove the creation refcount
			AfpVolumeDereference(pVolDesc);
		}
	}
	else 
	{
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
					("AfpQueuePrivateChangeNotify: Queuing of notify for directory %Z\\%Z failed as Reference not possible\n",
					pPath, pName));
	}
}


/***	AfpQueueOurChange
 *
 * 	LOCKS:	vds_VolLock (SPIN)
 */
VOID
AfpQueueOurChange(
	IN PVOLDESC				pVolDesc,
	IN DWORD				Action,		// NT FILE_ACTION_XXX (ntioapi.h)
	IN PUNICODE_STRING		pPath,
	IN PUNICODE_STRING		pParentPath	OPTIONAL // queues a ACTION_MODIFIED
)
{
	POUR_CHANGE pchange = NULL;
	KIRQL		OldIrql;
#if DBG
	static PBYTE	ActionStrings[] =
					{	"",
						"ADDED",
						"REMOVED",
						"MODIFIED",
						"RENAMED OLD",
						"RENAMED NEW",
						"STREAM ADDED",
						"STREAM REMOVED",
						"STREAM MODIFIED"
					};
#endif

	PAGED_CODE( );
	ASSERT(IS_VOLUME_NTFS(pVolDesc) && !EXCLUSIVE_VOLUME(pVolDesc));

    //
    // if the volume is being built, we don't have change-notify posted.
    // Don't queue this change: we are never going to get a change-notify!
    //
    if (pVolDesc->vds_Flags & VOLUME_NEW_FIRST_PASS)
    {
        ASSERT(!(pVolDesc->vds_Flags & VOLUME_NOTIFY_POSTED));
        return;
    }

	pchange = (POUR_CHANGE)AfpAllocNonPagedMemory(sizeof(OUR_CHANGE) + pPath->Length);

	if (pchange != NULL)
	{
		DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
				 ("AfpQueueOurChange: Queueing a %s for %Z\n", ActionStrings[Action], pPath));
		AfpGetCurrentTimeInMacFormat(&pchange->oc_Time);
		AfpInitUnicodeStringWithNonNullTerm(&pchange->oc_Path,
											pPath->Length,
											(PWCHAR)((PBYTE)pchange + sizeof(OUR_CHANGE)));
		RtlCopyMemory(pchange->oc_Path.Buffer,
					  pPath->Buffer,
					  pPath->Length);

		ExInterlockedInsertTailList(&pVolDesc->vds_OurChangeList[AFP_CHANGE_ACTION(Action)],
								    &pchange->oc_Link,
									&(pVolDesc->vds_VolLock.SpinLock));
	}

	if (ARGUMENT_PRESENT(pParentPath))
	{
		pchange = (POUR_CHANGE)AfpAllocNonPagedMemory(sizeof(OUR_CHANGE) + pParentPath->Length);

		if (pchange != NULL)
		{
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
					 ("AfpQueueOurChange: Queueing (parent) %s for %Z\n",
					 ActionStrings[FILE_ACTION_MODIFIED], pParentPath));
			AfpGetCurrentTimeInMacFormat(&pchange->oc_Time);
			AfpInitUnicodeStringWithNonNullTerm(&pchange->oc_Path,
												pParentPath->Length,
												(PWCHAR)((PBYTE)pchange + sizeof(OUR_CHANGE)));
			RtlCopyMemory(pchange->oc_Path.Buffer,
						  pParentPath->Buffer,
						  pParentPath->Length);

			ExInterlockedInsertTailList(&pVolDesc->vds_OurChangeList[AFP_CHANGE_ACTION(FILE_ACTION_MODIFIED)],
										&pchange->oc_Link,
										&(pVolDesc->vds_VolLock.SpinLock));
		}
	}
}


/***	AfpDequeueOurChange
 *
 * 	LOCKS: LOCKS:	vds_VolLock (SPIN)
 */
VOID
AfpDequeueOurChange(
	IN PVOLDESC				pVolDesc,
	IN DWORD				Action,				// NT FILE_ACTION_XXX (ntioapi.h)
	IN PUNICODE_STRING		pPath,
	IN PUNICODE_STRING		pParentPath	OPTIONAL// queues a ACTION_MODIFIED
)
{
	POUR_CHANGE pChange;
	PLIST_ENTRY	pList, pListHead;
	KIRQL		OldIrql;
#if DBG
	static PBYTE	ActionStrings[] =
					{	"",
						"ADDED",
						"REMOVED",
						"MODIFIED",
						"RENAMED OLD",
						"RENAMED NEW",
						"STREAM ADDED",
						"STREAM REMOVED",
						"STREAM MODIFIED"
					};
#endif

	ASSERT(IS_VOLUME_NTFS(pVolDesc) && !EXCLUSIVE_VOLUME(pVolDesc));

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	// point to the head of the appropriate change action list
	pListHead = &pVolDesc->vds_OurChangeList[AFP_CHANGE_ACTION(Action)];

	for (pList = pListHead->Flink;
		 pList != pListHead;
		 pList = pList->Flink)
	{
		pChange = CONTAINING_RECORD(pList, OUR_CHANGE, oc_Link);

		// do a case *sensitive* unicode string compare
		if (EQUAL_UNICODE_STRING_CS(pPath, &pChange->oc_Path))
		{
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
					 ("AfpDequeueOurChange: Dequeueing a %s for %Z\n",
					 ActionStrings[Action], pPath));

			RemoveEntryList(&pChange->oc_Link);
			AfpFreeMemory(pChange);
			break;
		}
	}

	if (ARGUMENT_PRESENT(pParentPath))
	{
		// point to the head of the appropriate change action list
		pListHead = &pVolDesc->vds_OurChangeList[FILE_ACTION_MODIFIED];
	
		for (pList = pListHead->Flink;
			 pList != pListHead;
			 pList = pList->Flink)
		{
			pChange = CONTAINING_RECORD(pList, OUR_CHANGE, oc_Link);
	
			// do a case *sensitive* unicode string compare
			if (EQUAL_UNICODE_STRING_CS(pParentPath, &pChange->oc_Path))
			{
				DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
						 ("AfpDequeueOurChange: Dequeueing (parent) %s for %Z\n",
						 ActionStrings[FILE_ACTION_MODIFIED], pParentPath));

				RemoveEntryList(&pChange->oc_Link);
				AfpFreeMemory(pChange);
				break;
			}
		}
	}
	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
}

/***	AfpOurChangeScavenger
 *
 *  This runs in a worker thread context since it takes an swmr.
 *
 *  LOCKS:	vds_VolLock (SPIN)
 */
AFPSTATUS FASTCALL
AfpOurChangeScavenger(
	IN PVOLDESC pVolDesc
)
{
	AFPTIME		Now;
	KIRQL		OldIrql;
	int 		i;
	BOOLEAN		DerefVol = False;
#if DBG
	static PBYTE	Action[] = { "",
								 "ADDED",
								 "REMOVED",
								 "MODIFIED",
								 "RENAMED OLD",
								 "RENAMED NEW",
								 "STREAM ADDED",
								 "STREAM REMOVED",
								 "STREAM MODIFIED"};
#endif

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
			("AfpOurChangeScavenger: OurChange scavenger for volume %Z entered...\n",
			 &pVolDesc->vds_Name));

	// If this volume is going away, do not requeue this scavenger routine
	// We don't take the volume lock to check these flags since they are
	// one-way, i.e. once set they are never cleared.
	if (pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED))
	{
		DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
				("AfpOurChangeScavenger: OurChange scavenger for volume %Z: Final run\n",
				 &pVolDesc->vds_Name));
		DerefVol = True;
	}

  CleanTurds:

	AfpGetCurrentTimeInMacFormat(&Now);

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	for (i = 0; i < NUM_AFP_CHANGE_ACTION_LISTS; i++)
	{
		PLIST_ENTRY	pList, pHead;
		POUR_CHANGE	pChange;

		pHead = &pVolDesc->vds_OurChangeList[i];
		while (!IsListEmpty(pHead))
		{
			pList = pHead->Flink;
			pChange = CONTAINING_RECORD(pList, OUR_CHANGE, oc_Link);

			if (((Now - pChange->oc_Time) > OURCHANGE_AGE) || DerefVol)
			{
				RemoveHeadList(pHead);

				DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_WARN,
						("AfpOurChangeScavenger: freeing %Z (%s)\n",
						&pChange->oc_Path, &Action[i]));
				AfpFreeMemory(pChange);
			}
			else
			{
				// All subsequent items in list will have later times so
				// don't bother checking them
				break;
			}
		}
	}

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

	// Check again if this volume is going away and if so do not requeue this
	// scavenger routine.  Note that while we were running, the volume may
	// have been deleted but this scavenger event could not be killed because
	// it wasn't found on the list. We don't want to requeue this routine again
	// because it will take AFP_OURCHANGE_AGE minutes for the volume to go
	// away otherwise. This closes the window more, but does not totally
	// eliminate it from happening.
	if (!DerefVol)
	{
		if (pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED))
		{
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
					("AfpOurChangeScavenger: OurChanges scavenger for volume %Z: Final Run\n",
					 &pVolDesc->vds_Name));
			DerefVol = True;
			goto CleanTurds;
		}
	}
	else
	{
		AfpVolumeDereference(pVolDesc);
		return AFP_ERR_NONE;
	}

	return AFP_ERR_REQUEUE;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\errorlog.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	errorlog.h

Abstract:

	This module contains the manifests and macros used for error logging
	in the Afp server.

	!!! This module must be nonpageable.

Author:

	Jameel Hyder (microsoft!jameelh)

Revision History:
	10 Jun 1992		Initial Version

--*/


#ifndef	_ERRORLOG_
#define	_ERRORLOG_

//
//	Debug levels used with DBGPRINT and DBGBRK
//

#define	DBG_LEVEL_INFO			0x0000
#define	DBG_LEVEL_WARN			0x1000
#define	DBG_LEVEL_ERR			0x2000
#define	DBG_LEVEL_FATAL			0x3000

//
//	Component types used with DBGPRINT
//
#define	DBG_COMP_INIT			0x00000001
#define	DBG_COMP_MEMORY			0x00000002
#define	DBG_COMP_FILEIO	   		0x00000004
#define	DBG_COMP_SCVGR 	   		0x00000008
#define	DBG_COMP_LOCKS 	   		0x00000010
#define	DBG_COMP_CHGNOTIFY 		0x00000020
#define	DBG_COMP_SDA   	   		0x00000040
#define	DBG_COMP_FORKS 	   		0x00000080
#define	DBG_COMP_DESKTOP   		0x00000100
#define	DBG_COMP_VOLUME	   		0x00000200
#define	DBG_COMP_AFPINFO		0x00000400
#define	DBG_COMP_IDINDEX		0x00000800
#define	DBG_COMP_STACKIF		0x00001000
#define	DBG_COMP_SECURITY		0x00002000

#define	DBG_COMP_ADMINAPI		0x00004000
#define	DBG_COMP_ADMINAPI_SC	0x00008000
#define	DBG_COMP_ADMINAPI_STAT	0x00010000
#define	DBG_COMP_ADMINAPI_SRV	0x00020000
#define	DBG_COMP_ADMINAPI_VOL	0x00040000
#define	DBG_COMP_ADMINAPI_SESS	0x00080000
#define	DBG_COMP_ADMINAPI_CONN	0x00100000
#define	DBG_COMP_ADMINAPI_FORK	0x00200000
#define	DBG_COMP_ADMINAPI_DIR	0x00400000
#define	DBG_COMP_ADMINAPI_ALL	0x007FC000

#define	DBG_COMP_AFPAPI			0x00800000
#define	DBG_COMP_AFPAPI_DTP		0x01000000
#define	DBG_COMP_AFPAPI_FORK	0x02000000
#define	DBG_COMP_AFPAPI_FILE	0x04000000
#define	DBG_COMP_AFPAPI_DIR		0x08000000
#define	DBG_COMP_AFPAPI_FD		0x10000000
#define	DBG_COMP_AFPAPI_VOL		0x20000000
#define	DBG_COMP_AFPAPI_SRV		0x40000000
#define	DBG_COMP_AFPAPI_ALL		0x7F800000

#define	DBG_COMP_NOHEADER		0x80000000

#define	DBG_COMP_ALL			0x7FFFFFFF


// Change this to level of debugging desired. This can also be changed on the
// fly via the kernel debugger

#if DBG

GLOBAL	LONG		AfpDebugLevel EQU DBG_LEVEL_ERR;
GLOBAL	LONG		AfpDebugComponent EQU DBG_COMP_ALL;
GLOBAL  LONG        AfpDebugRefcount  EQU 0;

#define	DBGPRINT(Component, Level, Fmt)	\
		if ((Level >= AfpDebugLevel) && (AfpDebugComponent & Component)) \
		{												\
			if (!(Component & DBG_COMP_NOHEADER))		\
				DbgPrint("***AFPSRV*** ");				\
			DbgPrint Fmt;								\
		}

#define	DBGBRK(Level)				\
		if (Level >= AfpDebugLevel)	\
			DbgBreakPoint()

#define DBGREFCOUNT(Fmt)                    \
        if (AfpDebugRefcount)               \
        {                                   \
            DbgPrint("***AFPSRV*** ");      \
            DbgPrint Fmt;                   \
        }

#else
#define	DBGPRINT(Component, Level, Fmt)
#define	DBGBRK(Level)
#define DBGREFCOUNT(Fmt)
#endif


//
// The types of events that can be logged.
// (cut-n-pasted from ntelfapi.h, after the "use ntsrv.h, not ntos.h" changes)
//

#define EVENTLOG_ERROR_TYPE             0x0001
#define EVENTLOG_INFORMATION_TYPE       0x0004

// This method of logging will end up calling the IoWriteErrorlogEntry. It
// should be used in places where for some reason do not want to queue up
// the errorlog to be logged from the usermode service.  It takes ONE insertion
// string max. pInsertionString is a PUNICODE_STRING.  An example of where this
// should be used is in the AllocNonPagedMem routines, because if we were
// to call the AfpLogEvent routine from there, it would again turn around and
// call the alloc mem routine.  Also any routines that are called during
// server initialization/deinitialization should use this logging method since
// the usermode utility worker component is not guaranteed to be up accepting
// error log requests!
#define AFPLOG_DDERROR(ErrMsgNum, NtStatus, RawData, RawDataLen, pInsertionString)	\
	DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_WARN, ("AFP_ERRORLOG: %s (%d) Status %lx\n",	\
			__FILE__, __LINE__, NtStatus));	\
	AfpWriteErrorLogEntry(ErrMsgNum, FILENUM + __LINE__, NtStatus,			\
						   RawData, RawDataLen,								\
						   pInsertionString)

// This is the most basic method of logging; takes ONE insertion string max.
// pInsertionString is a PUNICODE_STRING.  This will cause the errorlog to
// be sent up to the usermode service to be logged.
#define AFPLOG_ERROR(ErrMsgNum, NtStatus, RawData, RawDataLen, pInsertionString) \
	DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_WARN, ("AFP_ERRORLOG: %s (%d) Status %lx\n",	\
			__FILE__, __LINE__, NtStatus));	\
	AfpLogEvent(EVENTLOG_ERROR_TYPE, ErrMsgNum, FILENUM + __LINE__, NtStatus,			\
				(PBYTE)RawData, RawDataLen, 0,								\
				(pInsertionString == NULL) ? 0 : ((PUNICODE_STRING)(pInsertionString))->Length, \
				(pInsertionString == NULL) ? NULL : ((PUNICODE_STRING)(pInsertionString))->Buffer);

// This method of errorlogging takes a file handle and extracts the
// corresponding filename to use as the *first* insertion string.
#define AFPLOG_HERROR(ErrMsgNum, NtStatus, RawData, RawDataLen, Handle) \
	DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR, ("AFP_ERRORLOG: %s (%d) Status %lx\n", \
			__FILE__, __LINE__, NtStatus));	\
	AfpLogEvent(EVENTLOG_ERROR_TYPE, ErrMsgNum, FILENUM + __LINE__, NtStatus, \
				(PBYTE)RawData, RawDataLen, Handle, 0, NULL)

// This is the most basic method of logging; takes ONE insertion string max.
// pInsertionString is a PUNICODE_STRING.  This will cause the eventlog to
// be sent up to the usermode service to be logged.
#define AFPLOG_INFO(ErrMsgNum, NtStatus, RawData, RawDataLen, pInsertionString) \
	DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_INFO, ("AFP_EVENTLOG: %s (%d) Status %lx\n",	\
			__FILE__, __LINE__, NtStatus));	\
	AfpLogEvent(EVENTLOG_INFORMATION_TYPE, ErrMsgNum, FILENUM + __LINE__, NtStatus,			\
				(PBYTE)RawData, RawDataLen, 0,								\
				(pInsertionString == NULL) ? 0 : ((PUNICODE_STRING)(pInsertionString))->Length, \
				(pInsertionString == NULL) ? NULL : ((PUNICODE_STRING)(pInsertionString))->Buffer);


//
// Error levels used with AfpWriteErrorLogEntry
//

#define ERROR_LEVEL_EXPECTED    0
#define ERROR_LEVEL_UNEXPECTED  1
#define ERROR_LEVEL_IMPOSSIBLE  2
#define ERROR_LEVEL_FATAL       3

extern
VOID
AfpWriteErrorLogEntry(
	IN ULONG			EventCode,
	IN LONG				UniqueErrorCode OPTIONAL,
	IN NTSTATUS			NtStatusCode,
	IN PVOID			RawDataBuf OPTIONAL,
	IN LONG				RawDataLen,
	IN PUNICODE_STRING	pInsertionString OPTIONAL
);

// This routine is implemented in secutil.c
extern
VOID
AfpLogEvent(
	IN USHORT		EventType, 			
	IN ULONG		MsgId,
	IN DWORD		File_Line  OPTIONAL,
	IN NTSTATUS		Status 	   OPTIONAL,
	IN PBYTE RawDataBuf OPTIONAL,
	IN LONG			RawDataLen,
	IN HANDLE FileHandle OPTIONAL,
	IN LONG			String1Len,
	IN PWSTR String1    OPTIONAL
);

#endif	// _ERRORLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\fdparm.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fdparm.c

Abstract:

	This module contains the routines for handling file parameters.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	_FDPARM_LOCALS
#define	FILENUM	FILE_FDPARM

#include <seposix.h>
#include <afp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <afpinfo.h>
#include <client.h>
#include <access.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpGetFileDirParmsReplyLength)
#pragma alloc_text( PAGE, AfpPackFileDirParms)
#pragma alloc_text( PAGE, AfpUnpackFileDirParms)
#pragma alloc_text( PAGE, AfpUnpackCatSearchSpecs)
#pragma alloc_text( PAGE, AfpSetFileDirParms)
#pragma alloc_text( PAGE, AfpQuerySecurityIdsAndRights)
#pragma alloc_text( PAGE, AfpConvertNTAttrToAfpAttr)
#pragma alloc_text( PAGE, AfpConvertAfpAttrToNTAttr)
#pragma alloc_text( PAGE, AfpNormalizeAfpAttr)
#pragma alloc_text( PAGE, AfpMapFDBitmapOpenAccess)
#pragma alloc_text( PAGE, AfpCheckForInhibit)
#pragma alloc_text( PAGE, AfpIsCatSearchMatch)
#endif


/***	AfpGetFileDirParmsReplyLength
 *
 *	Compute the size of buffer required to copy the file parameters based
 *	on the bitmap.
 */
USHORT
AfpGetFileDirParmsReplyLength(
	IN	PFILEDIRPARM	pFDParm,
	IN	DWORD			Bitmap
)
{
	LONG	i;
	USHORT	Size = 0;
	static	BYTE	Bitmap2Size[14] =
				{
					sizeof(USHORT),		// Attributes
					sizeof(DWORD),		// Parent DirId
					sizeof(DWORD),		// Create Date
					sizeof(DWORD),		// Mod. Date
					sizeof(DWORD),		// Backup Date
					sizeof(FINDERINFO),
					sizeof(USHORT) + sizeof(BYTE),	// Long Name
					sizeof(USHORT) + sizeof(BYTE),	// Short Name
					sizeof(DWORD),		// DirId/FileNum
					sizeof(DWORD),		// DataForkLength/Offspring Count
					sizeof(DWORD),		// RescForkLength/Owner Id
					sizeof(DWORD),		// Group Id
					sizeof(DWORD),		// Access Rights
					sizeof(PRODOSINFO)	// ProDos Info
				};

	PAGED_CODE( );

	ASSERT ((Bitmap & ~DIR_BITMAP_MASK) == 0);

	if (Bitmap & FD_BITMAP_LONGNAME)
		Size += pFDParm->_fdp_LongName.Length;

	if (Bitmap & FD_BITMAP_SHORTNAME)
		Size += pFDParm->_fdp_ShortName.Length;

	if (IsDir(pFDParm) && (Bitmap & DIR_BITMAP_OFFSPRINGS))
		Size -= sizeof(USHORT);

	for (i = 0; Bitmap; i++)
	{
		if (Bitmap & 1)
			Size += (USHORT)Bitmap2Size[i];
		Bitmap >>= 1;
	}
	return Size;
}



/***	AfpPackFileDirParms
 *
 *	Pack file or directory parameters into the reply buffer in on-the-wire
 *	format.
 */
VOID
AfpPackFileDirParms(
	IN	PFILEDIRPARM	pFDParm,
	IN	DWORD			Bitmap,
	IN	PBYTE			pReplyBuf
)
{
	LONG	Offset = 0;
	LONG	LongNameOff, ShortNameOff;

	PAGED_CODE( );

	if (Bitmap & FD_BITMAP_ATTR)
	{
		PUTSHORT2SHORT(pReplyBuf + Offset, pFDParm->_fdp_Attr);
		Offset += sizeof(USHORT);
	}
	if (Bitmap & FD_BITMAP_PARENT_DIRID)
	{
		PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_ParentId);
		Offset += sizeof(DWORD);
	}
	if (Bitmap & FD_BITMAP_CREATETIME)
	{
		PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_CreateTime);
		Offset += sizeof(DWORD);
	}
	if (Bitmap & FD_BITMAP_MODIFIEDTIME)
	{
		PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_ModifiedTime);
		Offset += sizeof(DWORD);
	}
	if (Bitmap & FD_BITMAP_BACKUPTIME)
	{
		PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_BackupTime);
		Offset += sizeof(DWORD);
	}
	if (Bitmap & FD_BITMAP_FINDERINFO)
	{
		if ((Bitmap & FD_BITMAP_ATTR) && (pFDParm->_fdp_Attr & FD_BITMAP_ATTR_INVISIBLE))
			pFDParm->_fdp_FinderInfo.fd_Attr1 |= FINDER_FLAG_INVISIBLE;

		RtlCopyMemory(pReplyBuf + Offset, (PBYTE)&pFDParm->_fdp_FinderInfo,
													sizeof(FINDERINFO));
		Offset += sizeof(FINDERINFO);
	}

	// Note the offset where the pointers to names will go. We'll have to
	// Fill it up later.
	if (Bitmap & FD_BITMAP_LONGNAME)
	{
		LongNameOff = Offset;
		Offset += sizeof(USHORT);
	}
	if (Bitmap & FD_BITMAP_SHORTNAME)
	{
		ShortNameOff = Offset;
		Offset += sizeof(USHORT);
	}

	// FileNum for files and DirId for Directories are in the same place
	if (Bitmap & FILE_BITMAP_FILENUM)
	{
		PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_AfpId);
		Offset += sizeof(DWORD);
	}

	if (IsDir(pFDParm))
	{
		// Directory parameters
		if (Bitmap & DIR_BITMAP_OFFSPRINGS)
		{
			DWORD	OffSpring;
	
			OffSpring = pFDParm->_fdp_FileCount + pFDParm->_fdp_DirCount;
			PUTDWORD2SHORT(pReplyBuf + Offset, OffSpring);
			Offset += sizeof(USHORT);
		}

		if (Bitmap & DIR_BITMAP_OWNERID)
		{
			PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_OwnerId);
			Offset += sizeof(DWORD);
		}
	
		if (Bitmap & DIR_BITMAP_GROUPID)
		{
			PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_GroupId);
			Offset += sizeof(DWORD);
		}

		if (Bitmap & DIR_BITMAP_ACCESSRIGHTS)
		{
			DWORD	AccessInfo;
	
			AccessInfo = (pFDParm->_fdp_OwnerRights << OWNER_RIGHTS_SHIFT) +
						 (pFDParm->_fdp_GroupRights << GROUP_RIGHTS_SHIFT) +
						 (pFDParm->_fdp_WorldRights << WORLD_RIGHTS_SHIFT) +
						 (pFDParm->_fdp_UserRights  << USER_RIGHTS_SHIFT);
	
			PUTDWORD2DWORD(pReplyBuf + Offset, AccessInfo & ~OWNER_BITS_ALL);
			Offset += sizeof(DWORD);
		}
	}
	else
	{
		if (Bitmap & FILE_BITMAP_DATALEN)
		{
			PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_DataForkLen);
			Offset += sizeof(DWORD);
		}

		// Resc Length for files and Owner Id for Directories are in the same place
		if (Bitmap & FILE_BITMAP_RESCLEN)
		{
			PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_RescForkLen);
			Offset += sizeof(DWORD);
		}
	}

	if (Bitmap & FD_BITMAP_PRODOSINFO)
	{
		RtlCopyMemory(pReplyBuf + Offset, (PBYTE)&pFDParm->_fdp_ProDosInfo,
													sizeof(PRODOSINFO));
		Offset += sizeof(PRODOSINFO);
	}
	if (Bitmap & FD_BITMAP_LONGNAME)
	{
		ASSERT(pFDParm->_fdp_LongName.Length <= AFP_LONGNAME_LEN);

		PUTDWORD2SHORT(pReplyBuf + LongNameOff, Offset);
		PUTSHORT2BYTE(pReplyBuf + Offset, pFDParm->_fdp_LongName.Length);
		RtlCopyMemory(pReplyBuf + Offset + sizeof(BYTE),
					  pFDParm->_fdp_LongName.Buffer,
					  pFDParm->_fdp_LongName.Length);

		Offset += pFDParm->_fdp_LongName.Length + sizeof(BYTE);
	}
	if (Bitmap & FD_BITMAP_SHORTNAME)
	{
		ASSERT(pFDParm->_fdp_ShortName.Length <= AFP_SHORTNAME_LEN);

		PUTDWORD2SHORT(pReplyBuf + ShortNameOff, Offset);
		PUTSHORT2BYTE(pReplyBuf + Offset, pFDParm->_fdp_ShortName.Length);
		RtlCopyMemory(pReplyBuf + Offset + sizeof(BYTE),
					  pFDParm->_fdp_ShortName.Buffer,
					  pFDParm->_fdp_ShortName.Length);
		Offset += pFDParm->_fdp_ShortName.Length + sizeof(BYTE);
	}
	if (Offset & 1)
		*(pReplyBuf + Offset) = 0;
}



/***	AfpUnpackFileDirParms
 *
 *	Unpack the information from the on-the-wire format to the FileDirParm
 *	structure. Only the fields that can be set are looked at. The bitmaps
 *	are validated by the caller.
 *
 *	OPTIMIZATION:	The finder is notorious for setting things needlessly.
 *					We figure out if what is being set is same as what it
 *					is currently and if it is just clear that bit.
 */
AFPSTATUS
AfpUnpackFileDirParms(
	IN	PBYTE			pBuffer,
	IN	LONG			Length,
	IN	PDWORD			pBitmap,
	OUT	PFILEDIRPARM	pFDParm
)
{
	DWORD		Bitmap = *pBitmap;
	AFPTIME		ModTime;
	USHORT		Offset = 0;
	BOOLEAN		SetModTime = False;
	AFPSTATUS	Status = AFP_ERR_NONE;

	PAGED_CODE( );

	do
	{
		if ((LONG)AfpGetFileDirParmsReplyLength(pFDParm, *pBitmap) > Length)
		{
			DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_FATAL,
				("UnpackFileDirParms: Buffer not large enough!\n"));
	        DBGBRK(DBG_LEVEL_FATAL);
			Status = AFP_ERR_PARAM;
			break;
		}

		if (Bitmap & FD_BITMAP_ATTR)
		{
			USHORT	OldAttr, NewAttr;
			USHORT	Set;

			GETSHORT2SHORT(&NewAttr, pBuffer+Offset);
			// keep track of if client wants to set bits or clear bits
			Set = (NewAttr & FD_BITMAP_ATTR_SET);
			// take off the 'set' bit to isolate the requested bits
			NewAttr &= ~FD_BITMAP_ATTR_SET;
			// the current effective settings of attributes
			OldAttr = (pFDParm->_fdp_Attr & ~FD_BITMAP_ATTR_SET);

			if ((NewAttr != 0) &&
				(((Set != 0) && ((OldAttr ^ NewAttr) != 0)) ||
				 ((Set == 0) && ((OldAttr & NewAttr) != 0))))
			{
				// becomes the new resultant AFP attributes after setting
				pFDParm->_fdp_EffectiveAttr = (Set != 0) ?
													(pFDParm->_fdp_Attr | NewAttr) :
													(pFDParm->_fdp_Attr & ~NewAttr);

				// changing a directory's inhibit and invisible attributes from
				// their current settings can only be done by the dir owner
				if (IsDir(pFDParm) &&
					((pFDParm->_fdp_EffectiveAttr & DIR_BITMAP_ATTR_CHG_X_OWNER_ONLY) ^
					 (pFDParm->_fdp_Attr & DIR_BITMAP_ATTR_CHG_X_OWNER_ONLY)) &&
					!(pFDParm->_fdp_UserRights & DIR_ACCESS_OWNER))
                {
					Status = AFP_ERR_ACCESS_DENIED;
					break;
				}

				// becomes attribute bits requested to be set/cleared
				pFDParm->_fdp_Attr = (NewAttr | Set);
			}
			else *pBitmap &= ~FD_BITMAP_ATTR;
			Offset += sizeof(USHORT);
		}
		if (Bitmap & FD_BITMAP_CREATETIME)
		{
			AFPTIME	CreateTime;

			GETDWORD2DWORD(&CreateTime, pBuffer+Offset);
			if (CreateTime == pFDParm->_fdp_CreateTime)
				*pBitmap &= ~FD_BITMAP_CREATETIME;
			else pFDParm->_fdp_CreateTime = CreateTime;
			Offset += sizeof(DWORD);
		}
		if (Bitmap & FD_BITMAP_MODIFIEDTIME)
		{
			GETDWORD2DWORD(&ModTime, pBuffer+Offset);
			if (ModTime == pFDParm->_fdp_ModifiedTime)
			{
				*pBitmap &= ~FD_BITMAP_MODIFIEDTIME;
				SetModTime = True;
			}
			else
			{
				pFDParm->_fdp_ModifiedTime = ModTime;
			}
			Offset += sizeof(DWORD);
		}
		if (Bitmap & FD_BITMAP_BACKUPTIME)
		{
			AFPTIME	BackupTime;

			GETDWORD2DWORD(&BackupTime, pBuffer+Offset);
			if (BackupTime == pFDParm->_fdp_BackupTime)
				*pBitmap &= ~FD_BITMAP_BACKUPTIME;
			else pFDParm->_fdp_BackupTime = BackupTime;
			Offset += sizeof(DWORD);
		}
		if (Bitmap & FD_BITMAP_FINDERINFO)
		{
			int		i, rlo = -1, rhi = -1;	// Range of bytes that are different
			PBYTE	pSrc, pDst;

			pSrc = pBuffer + Offset;
			pDst = (PBYTE)(&pFDParm->_fdp_FinderInfo);
			for (i = 0; i < sizeof(FINDERINFO); i++)
			{
				if (*pSrc++ != *pDst++)
				{
					if (rlo == -1)
						rlo = i;
					else rhi = i;
				}
			}

			if ((rlo != -1) && (rhi == -1))
				rhi = rlo;

			// Optimization: if nothing has changed, avoid a copy
			if (rlo == -1)
			{
				*pBitmap &= ~FD_BITMAP_FINDERINFO;
			}
			else
			{
				RtlCopyMemory((PBYTE)&pFDParm->_fdp_FinderInfo,
							  pBuffer+Offset,
							  sizeof(FINDERINFO));
			}
			Offset += sizeof(FINDERINFO);
		}

		if (IsDir(pFDParm) &&
			(Bitmap & (DIR_BITMAP_OWNERID |
					   DIR_BITMAP_GROUPID |
					   DIR_BITMAP_ACCESSRIGHTS)))
		{
			if (Bitmap & DIR_BITMAP_OWNERID)
			{
				DWORD	OwnerId;

				GETDWORD2DWORD(&OwnerId, pBuffer+Offset);
				if (pFDParm->_fdp_OwnerId == OwnerId)
					Bitmap &= ~DIR_BITMAP_OWNERID;
				else pFDParm->_fdp_OwnerId = OwnerId;
				Offset += sizeof(DWORD);
			}
			if (Bitmap & DIR_BITMAP_GROUPID)
			{
				DWORD	GroupId;

				GETDWORD2DWORD(&GroupId, pBuffer+Offset);
				if (pFDParm->_fdp_GroupId == GroupId)
					Bitmap &= ~DIR_BITMAP_GROUPID;
				else pFDParm->_fdp_GroupId = GroupId;
				Offset += sizeof(DWORD);
			}
			if (Bitmap & DIR_BITMAP_ACCESSRIGHTS)
			{
				DWORD	AccessInfo;

				GETDWORD2DWORD(&AccessInfo, pBuffer+Offset);

				pFDParm->_fdp_OwnerRights  =
						(BYTE)((AccessInfo >> OWNER_RIGHTS_SHIFT) & DIR_ACCESS_ALL);
				pFDParm->_fdp_GroupRights =
						(BYTE)((AccessInfo >> GROUP_RIGHTS_SHIFT) & DIR_ACCESS_ALL);
				pFDParm->_fdp_WorldRights =
						(BYTE)((AccessInfo >> WORLD_RIGHTS_SHIFT) & DIR_ACCESS_ALL);
				Offset += sizeof(DWORD);
			}
			if (Bitmap & (DIR_BITMAP_OWNERID | DIR_BITMAP_GROUPID))
				Bitmap |= DIR_BITMAP_ACCESSRIGHTS;
		}

		if (Bitmap & FD_BITMAP_PRODOSINFO)
		{
			int		i;
			PBYTE	pSrc, pDst;

			pSrc = pBuffer + Offset;
			pDst = (PBYTE)(&pFDParm->_fdp_ProDosInfo);
			for (i = 0; i < sizeof(PRODOSINFO); i++)
				if (*pSrc++ != *pDst++)
					break;
			if (i == sizeof(PRODOSINFO))
				*pBitmap &= ~FD_BITMAP_PRODOSINFO;
			else RtlCopyMemory((PBYTE)&pFDParm->_fdp_ProDosInfo,
								pBuffer+Offset,
								sizeof(PRODOSINFO));
			// Offset += sizeof(PRODOSINFO);
		}
	} while (False);

	// If anything is being set and modified time was dropped because it was identical
	// to what is already on, set the bitmap so that it is restored after the change.
	if (SetModTime && *pBitmap)
	{
		*pBitmap |= FD_BITMAP_MODIFIEDTIME;
	}

	return Status;
}


/***	AfpSetFileDirParms
 *
 *	This is the worker for AfpGetFileDirParms/AfpSetFileParms/AfpSetDirParms.
 *	This is callable only in the worker's context.
 *
 *  LOCKS: vds_IdDbAccessLock (SWMR, Exclusive);
 */
AFPSTATUS
AfpSetFileDirParms(
	IN  PVOLDESC		pVolDesc,
	IN  PPATHMAPENTITY	pPME,
	IN  DWORD			Bitmap,
	IN	PFILEDIRPARM	pFDParm
)
{
	AFPSTATUS		Status = AFP_ERR_NONE;
	BOOLEAN			CleanupLock = False, SetROAttr = False;
	PDFENTRY		pDfEntry = NULL;

	PAGED_CODE( );

	do
	{
        ASSERT(IS_VOLUME_NTFS(pVolDesc));

		// NOTE: should we take the SWMR while we set permissions?
		if (IsDir(pFDParm))
		{
			if (Bitmap & (DIR_BITMAP_OWNERID |
						  DIR_BITMAP_GROUPID |
						  DIR_BITMAP_ACCESSRIGHTS))
			{

				Status = AfpSetAfpPermissions(pPME->pme_Handle.fsh_FileHandle,
											  Bitmap,
											  pFDParm);
				if (!NT_SUCCESS(Status))
					break;
			}
		}

		if (Bitmap & (FD_BITMAP_FINDERINFO |
					  FD_BITMAP_PRODOSINFO |
					  FD_BITMAP_ATTR |
					  FD_BITMAP_BACKUPTIME |
					  DIR_BITMAP_ACCESSRIGHTS |
					  DIR_BITMAP_OWNERID   |
					  DIR_BITMAP_GROUPID   |
					  FD_BITMAP_CREATETIME |
					  FD_BITMAP_MODIFIEDTIME |
					  FD_BITMAP_ATTR))
		{
			AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
			CleanupLock = True;
		}

		if (Bitmap & (FD_BITMAP_FINDERINFO |
					  FD_BITMAP_PRODOSINFO |
					  FD_BITMAP_ATTR |
					  FD_BITMAP_BACKUPTIME |
					  DIR_BITMAP_ACCESSRIGHTS))
		{

			// Will update the cached AfpInfo as well as the stream
			Status = AfpSetAfpInfo(&pPME->pme_Handle,
								   Bitmap,
								   pFDParm,
								   pVolDesc,
								   &pDfEntry);

			if (Status != AFP_ERR_NONE)
				break;
		}

		if (Bitmap & (FD_BITMAP_CREATETIME |
					  FD_BITMAP_MODIFIEDTIME |
					  FD_BITMAP_ATTR |
					  DIR_BITMAP_ACCESSRIGHTS |
					  DIR_BITMAP_OWNERID |
					  DIR_BITMAP_GROUPID))
		{
			DWORD	SetNtAttr = 0, ClrNtAttr = 0;

			// need to update the cached times too.  If we didn't get the
			// pDfEntry back from setting some other AfpInfo, look it up now
			if (pDfEntry == NULL)
			{
				pDfEntry = AfpFindDfEntryById(pVolDesc,
											   pFDParm->_fdp_AfpId,
											   IsDir(pFDParm) ? DFE_DIR : DFE_FILE);
				if (pDfEntry == NULL)
				{
					Status = AFP_ERR_OBJECT_NOT_FOUND;
					break;
				}
			}

			if (Bitmap & FD_BITMAP_ATTR)
			{
				if (pFDParm->_fdp_Attr & FD_BITMAP_ATTR_SET)
					SetNtAttr = AfpConvertAfpAttrToNTAttr(pFDParm->_fdp_Attr);
				else
					ClrNtAttr = AfpConvertAfpAttrToNTAttr(pFDParm->_fdp_Attr);

                if (pFDParm->_fdp_Attr & (FD_BITMAP_ATTR_RENAMEINH |
										  FD_BITMAP_ATTR_DELETEINH))
				{
					SetROAttr = True;
				}

				if ((SetNtAttr == 0) && (ClrNtAttr == 0))
				{
					// Since there is no attribute being set/cleared that
					// corresponds to any NT attribute, we can clear the
					// ATTR bitmap since we've already set the Mac specific
					// stuff in the DFE and Afpinfo.
					Bitmap &= ~FD_BITMAP_ATTR;
				}
			}

			if (Bitmap & (FD_BITMAP_CREATETIME |
						  FD_BITMAP_MODIFIEDTIME |
						  FD_BITMAP_ATTR))
			{
				ASSERT(pPME->pme_FullPath.Buffer != NULL);
				Status = AfpIoSetTimesnAttr(&pPME->pme_Handle,
						((Bitmap & FD_BITMAP_CREATETIME) != 0) ?
									(PAFPTIME)&pFDParm->_fdp_CreateTime : NULL,
						(((Bitmap & FD_BITMAP_MODIFIEDTIME) != 0) || (SetROAttr)) ?
									(PAFPTIME)&pFDParm->_fdp_ModifiedTime : NULL,
						SetNtAttr, ClrNtAttr,
						pVolDesc,
						&pPME->pme_FullPath);
			}


			if (!NT_SUCCESS(Status))
				break;

			if (Bitmap & FD_BITMAP_CREATETIME)
			{
				pDfEntry->dfe_CreateTime =
								(AFPTIME)pFDParm->_fdp_CreateTime;
			}

			if (Bitmap & FD_BITMAP_MODIFIEDTIME)
			{
				AfpConvertTimeFromMacFormat(pFDParm->_fdp_ModifiedTime,
											&pDfEntry->dfe_LastModTime);
			}
			else if (IsDir(pFDParm) &&
					 ((Bitmap & (DIR_BITMAP_OWNERID |
						 	     DIR_BITMAP_GROUPID |
							     DIR_BITMAP_ACCESSRIGHTS)) ||
					   SetROAttr))
			{
				ASSERT(VALID_DFE(pDfEntry));
				// Setting permissions on a dir or changing its RO attribute
				// should update the modified time on the dir (as observed
				// on Appleshare 4.0)
				AfpIoChangeNTModTime(&pPME->pme_Handle,
									 &pDfEntry->dfe_LastModTime);
			}

			if (Bitmap & FD_BITMAP_ATTR)
			{
				if (pFDParm->_fdp_Attr & FD_BITMAP_ATTR_SET)
					 pDfEntry->dfe_NtAttr |= (USHORT)SetNtAttr;
				else pDfEntry->dfe_NtAttr &= ~((USHORT)ClrNtAttr);

			}

		}

		AfpVolumeSetModifiedTime(pVolDesc);
	} while (False);

	if (CleanupLock)
	{
		AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
	}

	return Status;
}


/***	AfpQuerySecurityIdsAndRights
 *
 *	Find the owner id and primary group id for this entity. Map the corres.
 *	SIDs to their posix ids. Determine also the access rights for owner,
 *	group, world and this user. The access rights are divided into the
 *	following:
 *
 *	Owner's rights
 *	Primary group's rights
 *	World rights
 *	This user's rights
 *
 *	The handle to the directory should be opened with READ_CONTROL
 *	See Files vs. See Folders resolution for Owner/Group/World is already done.
 */
LOCAL AFPSTATUS
AfpQuerySecurityIdsAndRights(
	IN	PSDA			pSda,
	IN	PFILESYSHANDLE	pFSHandle,
	IN	DWORD			Bitmap,
	IN OUT PFILEDIRPARM	pFDParm
)
{
	NTSTATUS	Status;
	BYTE		ORights, GRights, WRights;

	PAGED_CODE( );

	// Save contents of the AfpInfo stream access bits
	ORights = pFDParm->_fdp_OwnerRights | DIR_ACCESS_WRITE;
	GRights = pFDParm->_fdp_GroupRights | DIR_ACCESS_WRITE;
	WRights = pFDParm->_fdp_WorldRights | DIR_ACCESS_WRITE;

	// Initialize to no rights for everybody
	pFDParm->_fdp_Rights = 0;

	// Get the OwnerId and GroupId for this directory.
	// Determine the Owner/Group and World rights for this directory
	// Determine if this user is a member of the directory's group
	Status = AfpGetAfpPermissions(pSda,
								  pFSHandle->fsh_FileHandle,
								  pFDParm);
	if (!NT_SUCCESS(Status))
		return Status;

	// Modify owner/group/world rights for the SeeFiles/SeeFolder weirdness
	// Also if the ACLs say we have READ & SEARCH access but AfpInfo stream
	// says we don't, then ignore AfpInfo stream
	if ((pFDParm->_fdp_OwnerRights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH)) &&
		!(ORights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH)))
		ORights |= (DIR_ACCESS_READ | DIR_ACCESS_SEARCH);
	pFDParm->_fdp_OwnerRights &= ORights;

	if ((pFDParm->_fdp_GroupRights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH)) &&
		!(GRights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH)))
		GRights |= (DIR_ACCESS_READ | DIR_ACCESS_SEARCH);
	pFDParm->_fdp_GroupRights &= GRights;

	if ((pFDParm->_fdp_WorldRights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH)) &&
		!(WRights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH)))
		WRights |= (DIR_ACCESS_READ | DIR_ACCESS_SEARCH);
	pFDParm->_fdp_WorldRights &= WRights;

	// One last bit of munging. Owner & Group can be the same and they both
	// could be everyone !! Coalese that.
	if (pFDParm->_fdp_OwnerId == SE_WORLD_POSIX_ID)
	{
		pFDParm->_fdp_WorldRights |= (pFDParm->_fdp_OwnerRights & ~DIR_ACCESS_OWNER);
		pFDParm->_fdp_OwnerRights |= pFDParm->_fdp_WorldRights;
	}

	if (pFDParm->_fdp_GroupId == SE_WORLD_POSIX_ID)
	{
		pFDParm->_fdp_WorldRights |= pFDParm->_fdp_GroupRights;
		pFDParm->_fdp_GroupRights |= pFDParm->_fdp_WorldRights;
	}

	if (pFDParm->_fdp_GroupId == pFDParm->_fdp_OwnerId)
	{
		pFDParm->_fdp_OwnerRights |= pFDParm->_fdp_GroupRights;
		pFDParm->_fdp_GroupRights |= (pFDParm->_fdp_OwnerRights & ~DIR_ACCESS_OWNER);
	}

	// Modify User rights for the SeeFiles/SeeFolder weirdness by determining
	// if the user is owner/group or world
	if (pFDParm->_fdp_UserRights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH))
	{
		BYTE	URights = (pFDParm->_fdp_UserRights & (DIR_ACCESS_WRITE | DIR_ACCESS_OWNER));

		if ((pFDParm->_fdp_WorldRights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH))
									!= (DIR_ACCESS_READ | DIR_ACCESS_SEARCH))
		{
			pFDParm->_fdp_UserRights = pFDParm->_fdp_WorldRights;
			if (pFDParm->_fdp_UserIsOwner)
			{
				pFDParm->_fdp_UserRights |= pFDParm->_fdp_OwnerRights;
			}
			if (pFDParm->_fdp_UserIsMemberOfDirGroup)
			{
				pFDParm->_fdp_UserRights |= pFDParm->_fdp_GroupRights;
			}
			if ((pFDParm->_fdp_UserRights & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH)) == 0)
				pFDParm->_fdp_UserRights |= (DIR_ACCESS_READ | DIR_ACCESS_SEARCH);
			pFDParm->_fdp_UserRights &= ~DIR_ACCESS_WRITE;
			pFDParm->_fdp_UserRights |= URights;
		}
	}

	return Status;
}


/***	AfpConvertNTAttrToAfpAttr
 *
 *	Map NT Attributes to the AFP equivalents.
 */
USHORT
AfpConvertNTAttrToAfpAttr(
	IN	DWORD	Attr
)
{
	USHORT	AfpAttr = FD_BITMAP_ATTR_SET;

	PAGED_CODE( );

	if (Attr & FILE_ATTRIBUTE_READONLY)
	{
		AfpAttr |= FD_BITMAP_ATTR_RENAMEINH | FD_BITMAP_ATTR_DELETEINH;
		if (!(Attr & FILE_ATTRIBUTE_DIRECTORY))
			AfpAttr |= FILE_BITMAP_ATTR_WRITEINH;
	}

	if (Attr & FILE_ATTRIBUTE_HIDDEN)
		AfpAttr |= FD_BITMAP_ATTR_INVISIBLE;

	if (Attr & FILE_ATTRIBUTE_SYSTEM)
		AfpAttr |= FD_BITMAP_ATTR_SYSTEM;

	if (Attr & FILE_ATTRIBUTE_ARCHIVE)
	{
		AfpAttr |= FD_BITMAP_ATTR_BACKUPNEED;
	}

	return AfpAttr;
}


/***	AfpConvertAfpAttrToNTAttr
 *
 *	Map AFP Attributes to the NT equivalents.
 */
DWORD
AfpConvertAfpAttrToNTAttr(
	IN	USHORT	Attr
)
{
	DWORD	NtAttr = 0;

	PAGED_CODE( );

	if (Attr & (FD_BITMAP_ATTR_RENAMEINH |
				FD_BITMAP_ATTR_DELETEINH |
				FILE_BITMAP_ATTR_WRITEINH))
		NtAttr |= FILE_ATTRIBUTE_READONLY;

	if (Attr & FD_BITMAP_ATTR_INVISIBLE)
		NtAttr |= FILE_ATTRIBUTE_HIDDEN;

	if (Attr & FD_BITMAP_ATTR_SYSTEM)
		NtAttr |= FILE_ATTRIBUTE_SYSTEM;

	if (Attr & FD_BITMAP_ATTR_BACKUPNEED)
	{
		NtAttr |= FILE_ATTRIBUTE_ARCHIVE;
	}

	return NtAttr;
}


/***	AfpNormalizeAfpAttr
 *
 *	Normalize the various inhibit bits in afp attributes vs. the RO bit on the
 *	disk.
 */
VOID
AfpNormalizeAfpAttr(
	IN OUT	PFILEDIRPARM	pFDParm,
	IN		DWORD			NtAttr
)
{
	USHORT	AfpAttr;

	PAGED_CODE( );

	AfpAttr = AfpConvertNTAttrToAfpAttr(NtAttr);

	/*
	 *	The Attributes fall into two classes, the ones that are on
	 *	on the filesystem and the others maintained in the AfpInfo
	 *	stream. We need to coalesce these two sets. The RO bit on
	 *	the disk corres. to the three inhibit bits. Fine grain
	 *	control is possible.
	 *
	 *	The other set of bits that are in the exclusive realm of
	 *	the AfpInfo stream are the RAlreadyOpen and DAlreadyOpen
	 *	bits and the multi-user bit.
	 */
	if (((pFDParm->_fdp_Attr & FD_BITMAP_ATTR_NT_RO) == 0) ^
		((AfpAttr & FD_BITMAP_ATTR_NT_RO) == 0))
	{
		if ((AfpAttr & FD_BITMAP_ATTR_NT_RO) == 0)
			 pFDParm->_fdp_Attr &= ~FD_BITMAP_ATTR_NT_RO;
		else pFDParm->_fdp_Attr |= FD_BITMAP_ATTR_NT_RO;
	}

	pFDParm->_fdp_Attr &= (AfpAttr |
							(FILE_BITMAP_ATTR_MULTIUSER |
							 FILE_BITMAP_ATTR_DATAOPEN  |
							 FILE_BITMAP_ATTR_RESCOPEN  |
							 FD_BITMAP_ATTR_SET));
	pFDParm->_fdp_Attr |= (AfpAttr & (FD_BITMAP_ATTR_BACKUPNEED |
									  FD_BITMAP_ATTR_SYSTEM |
									  FD_BITMAP_ATTR_INVISIBLE));

}


/***AfpMapFDBitmapOpenAccess
 *
 *	Map the FD_INTERNAL_BITMAP_OPENACCESS_xxx bits to the appropriate
 *  FILEIO_ACCESS_xxx values.  The returned OpenAccess is used by the
 *  pathmap code to open the data stream of a file/dir (under impersonation
 *  for NTFS) for use in the AFP APIs.
 *
 */
DWORD
AfpMapFDBitmapOpenAccess(
	IN	DWORD	Bitmap,
	IN	BOOLEAN IsDir
)
{
	DWORD	OpenAccess = FILEIO_ACCESS_NONE;

	PAGED_CODE( );

	do
	{
		if (!(Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_ALL))
		{
			break;
		}
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_READCTRL)
		{
			// For GetFileDirParms we don't know if it was a file or dir they
			// are asking for, so we had to OR the file and dir bitmaps together
			// before pathmapping.
			if (IsDir)
				OpenAccess = (FILEIO_ACCESS_NONE |
							  READ_CONTROL |
							  SYNCHRONIZE);
			break;
		}
		// Used by AfpAdmwDirectoryGetInfo
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_ADMINGET)
		{
			OpenAccess = (FILE_READ_ATTRIBUTES |
						  READ_CONTROL |
						  SYNCHRONIZE);
			break;
		}
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_ADMINSET)
		{
			OpenAccess = (FILE_READ_ATTRIBUTES |
						  READ_CONTROL |
						  SYNCHRONIZE |
						  FILE_WRITE_ATTRIBUTES |
						  WRITE_DAC |
						  WRITE_OWNER);
			break;
		}
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_RW_ATTR)
		{
			OpenAccess |= (FILEIO_ACCESS_NONE | FILE_WRITE_ATTRIBUTES);
		}
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_RWCTRL)
		{
			OpenAccess |= (FILEIO_ACCESS_NONE |
						   READ_CONTROL |
						   WRITE_DAC |
						   WRITE_OWNER |
						   SYNCHRONIZE);
			break;
		}
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_READ)
		{
			OpenAccess |= FILEIO_ACCESS_READ;
		}
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_WRITE)
		{
			OpenAccess |= FILEIO_ACCESS_WRITE;
		}
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_DELETE)
		{
			OpenAccess |= FILEIO_ACCESS_DELETE;
		}
	} while (False);

	return OpenAccess;
}


/*** AfpCheckForInhibit
 *
 *  This routine checks for the setting of the Afp RenameInhibit, DeleteInhibit
 *  or WriteInhibit attributes.  It first queries for the host File/Dir
 *  attributes to find out the setting of the ReadOnly attribute, then checks
 *  that against the Afp InhibitBit of interest.  AFP_ERR_NONE is returned if
 *  the InhibitBit is not set, else AFP_ERR_OBJECT_LOCKED is returned.
 *  The input handle must be a handle to the $DATA stream of the file/dir open
 *  in server's context.  The host attributes are returned in pNTAttr if the
 *  error code is not AFP_ERR_MISC.
 *
 */
AFPSTATUS
AfpCheckForInhibit(
	IN	PFILESYSHANDLE	hData,		// handle to DATA stream in server context
	IN	DWORD			InhibitBit,
	IN	DWORD			AfpAttr,
	OUT PDWORD			pNTAttr
)
{
	AFPSTATUS	Status = STATUS_SUCCESS;

	PAGED_CODE();

	do
	{
		if (!NT_SUCCESS(AfpIoQueryTimesnAttr(hData, NULL, NULL, pNTAttr)))
		{
			Status = AFP_ERR_MISC;
			break;
		}

		if (!(*pNTAttr & FILE_ATTRIBUTE_READONLY))
		{
	        Status = AFP_ERR_NONE;
			break;
		}
		if (!(AfpAttr & FD_BITMAP_ATTR_NT_RO) || (AfpAttr & InhibitBit))
		{
			// The file/dir is ReadOnly, but NONE of the AFP Inhibit bits are
			// set, so we assume the PC has set the RO bit; or, the requested
			// inhibit bit IS set.
			Status = AFP_ERR_OBJECT_LOCKED;
			break;
		}
	} while (False);

	return Status;
}

/***	AfpUnpackCatSearchSpecs
 *
 *	Unpack the information from the on-the-wire format to the FileDirParm
 *	structures for Specification 1 and 2.  Specification 1 contains the
 *  CatSearch criteria for lower bounds and values.  Specification 2
 *  contains the CatSearch criteria for upper bounds and masks.  The parameters
 *  are packed in the same order that the bits are set in the request bitmap.
 *  These are read into FILEDIRPARM structures.
 *
 *	The fields in Specification 1 and Specification 2 have different uses:
 *
 *	- In the name field, Specification 1 holds the target string and
 *    Specification 2 must always have a nil name field.
 *
 *	- In all date and length fields, Specification 1 holds the lowest value
 *    in the target range and Specification 2 holds the highest value in the
 *    target range.
 *
 *	- In file attributes and Finder Info fields, Specification 1 holds the
 *    target value, and Specification 2 holds the bitwise mask that specifies
 *    which bits in that field in Specification 1 are relevant to the current
 *    search.
 *
 */
AFPSTATUS
AfpUnpackCatSearchSpecs(
	IN	PBYTE			pBuffer,		// Pointer to beginning of Spec data
	IN	USHORT			BufLength,		// Length of Spec1 + Spec2 data
	IN	DWORD			Bitmap,
	OUT	PFILEDIRPARM	pFDParm1,
	OUT PFILEDIRPARM	pFDParm2,
	OUT PUNICODE_STRING	pMatchString
)
{
	PCATSEARCHSPEC	pSpec1, pSpec2;
	PBYTE			pBuffer1, pBuffer2, pEndOfBuffer;
	USHORT			Offset = 0, MinSpecLength1, MinSpecLength2;
	AFPSTATUS		Status = AFP_ERR_NONE;
	BOOLEAN			NoNullString = False;

	PAGED_CODE( );

	pSpec1 = (PCATSEARCHSPEC) pBuffer;
	pSpec2 = (PCATSEARCHSPEC) ((PBYTE)pBuffer + sizeof(CATSEARCHSPEC) +
			  pSpec1->__StructLength);

	// Point to data after the specification length and filler byte

	pBuffer1 = (PBYTE)pSpec1 + sizeof(CATSEARCHSPEC);
	pBuffer2 = (PBYTE)pSpec2 + sizeof(CATSEARCHSPEC);

	do
	{
		//
        // Make sure pSpec2 is at least pointing into the buffer we have, and
		// that its length is within the buffer as well.
		//
		pEndOfBuffer = pBuffer + BufLength;

		if (((PBYTE)pSpec2 >= pEndOfBuffer) ||
			((PBYTE)pSpec2+pSpec2->__StructLength+sizeof(CATSEARCHSPEC)
			  > pEndOfBuffer))
		{
			DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_ERR,
				("UnpackCatSearchParms: Buffer not large enough!\n"));
			Status = AFP_ERR_PARAM;
			break;
		}

		//
		// Validate that input buffer is long enough to hold all the info the
		// bitmap says it does.  Note we cannot yet account for the length of
		// a longname string's characters if there was one specified.
		//
		MinSpecLength1 = MinSpecLength2 = sizeof(CATSEARCHSPEC) +
						AfpGetFileDirParmsReplyLength(pFDParm1, Bitmap);

        //
		// HACK: In order to support LLPT, if the catsearch is
		// asking to match filename, we should allow the Spec2 name to
		// be missing from the buffer (as opposed to being the null string),
		// but still expect the offset to the name.
		//
		// We also need to support system 7.1 who sends a zero length spec2
		// if the Bitmap == FD_BITMAP_LONGNAME.
		//
		// Real Appleshare handles both these cases with no error.
		//

		if (Bitmap & FD_BITMAP_LONGNAME)
		{
			if (pSpec2->__StructLength == (MinSpecLength2-sizeof(CATSEARCHSPEC)-sizeof(BYTE)) )
			{
				MinSpecLength2 -= sizeof(BYTE);
				NoNullString = True;
			}
			else if ((Bitmap == FD_BITMAP_LONGNAME) && (pSpec2->__StructLength == 0))
			{
				MinSpecLength2 -= sizeof(USHORT) + sizeof(BYTE);
				NoNullString = True;
			}
		}

		if ( ((MinSpecLength1 + MinSpecLength2) > BufLength) ||
			 (pSpec1->__StructLength < (MinSpecLength1-sizeof(CATSEARCHSPEC))) ||
			 (pSpec2->__StructLength < (MinSpecLength2-sizeof(CATSEARCHSPEC))) )
		{
			DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_ERR,
				("UnpackCatSearchParms: Buffer not large enough!\n"));
			Status = AFP_ERR_PARAM;
			break;
		}

		if (Bitmap & FD_BITMAP_ATTR)
		{

			GETSHORT2SHORT(&pFDParm1->_fdp_Attr, pBuffer1+Offset);
			GETSHORT2SHORT(&pFDParm2->_fdp_Attr, pBuffer2+Offset);
			if ((pFDParm2->_fdp_Attr & ~FD_BITMAP_ATTR_NT_RO) ||
				(pFDParm2->_fdp_Attr == 0))
			{
				Status = AFP_ERR_PARAM;
				break;
			}
			Offset += sizeof(USHORT);
		}
		if (Bitmap & FD_BITMAP_PARENT_DIRID)
		{
			GETDWORD2DWORD(&pFDParm1->_fdp_ParentId, pBuffer1+Offset);
			GETDWORD2DWORD(&pFDParm2->_fdp_ParentId, pBuffer2+Offset);
			if (pFDParm1->_fdp_ParentId < AFP_ID_ROOT)
			{
				Status = AFP_ERR_PARAM;
				break;
			}
			Offset += sizeof(DWORD);
		}
		if (Bitmap & FD_BITMAP_CREATETIME)
		{
			GETDWORD2DWORD(&pFDParm1->_fdp_CreateTime, pBuffer1+Offset);
			GETDWORD2DWORD(&pFDParm2->_fdp_CreateTime, pBuffer2+Offset);
			Offset += sizeof(DWORD);
		}
		if (Bitmap & FD_BITMAP_MODIFIEDTIME)
		{
			GETDWORD2DWORD(&pFDParm1->_fdp_ModifiedTime, pBuffer1+Offset);
			GETDWORD2DWORD(&pFDParm2->_fdp_ModifiedTime, pBuffer2+Offset);
			Offset += sizeof(DWORD);
		}
		if (Bitmap & FD_BITMAP_BACKUPTIME)
		{
			GETDWORD2DWORD(&pFDParm1->_fdp_BackupTime, pBuffer1+Offset);
			GETDWORD2DWORD(&pFDParm2->_fdp_BackupTime, pBuffer2+Offset);
			Offset += sizeof(DWORD);
		}
		if (Bitmap & FD_BITMAP_FINDERINFO)
		{
			RtlCopyMemory((PBYTE)&pFDParm1->_fdp_FinderInfo,
						  pBuffer1+Offset,
						  sizeof(FINDERINFO));

			RtlCopyMemory((PBYTE)&pFDParm2->_fdp_FinderInfo,
						  pBuffer2+Offset,
						  sizeof(FINDERINFO));

			Offset += sizeof(FINDERINFO);
		}
		if (Bitmap & FD_BITMAP_LONGNAME)
		{
			DWORD	NameOffset1, NameOffset2;

			//
			// Get the parm relative offset to the start of the pascal string
			//

			GETSHORT2DWORD(&NameOffset1, pBuffer1+Offset);
			if ((Bitmap == FD_BITMAP_LONGNAME) && (pSpec2->__StructLength == 0))
			{
				// HACK for system 7.1
				NameOffset2 = NameOffset1;
				pBuffer2 = NULL;
			}
			else
				GETSHORT2DWORD(&NameOffset2, pBuffer2+Offset);

			if ((NameOffset1 != NameOffset2) ||
				(pBuffer1 + NameOffset1 >= (PBYTE)pSpec2) ||
				(pBuffer2 + NameOffset2 > pEndOfBuffer))
			{
				Status = AFP_ERR_PARAM;
				break;
			}
			Offset += sizeof(USHORT);

			//
			// Get the pascal string length
			//

			GETBYTE2SHORT(&pFDParm1->_fdp_LongName.Length, pBuffer1+NameOffset1);

			// HACK: In order to support LLPT and system 7.1, if the catsearch is
			// asking to match filename, we should allow the Spec2 name to
			// be missing from the buffer (as opposed to being the null string).
			// Real Appleshare handles this case with no error.
			if (NoNullString)
				pFDParm2->_fdp_LongName.Length = 0;
			else
				GETBYTE2SHORT(&pFDParm2->_fdp_LongName.Length, pBuffer2+NameOffset1);

			if ((pFDParm1->_fdp_LongName.Length > AFP_LONGNAME_LEN) ||
				(pFDParm2->_fdp_LongName.Length != 0) ||
				(pBuffer1+NameOffset1+sizeof(BYTE)+pFDParm1->_fdp_LongName.Length > (PBYTE)pSpec2))
			{
				// Specification 2 must always have a nil name field.  Also
				// ensure that Specification 1 does not have a bogus string
				// length.
				Status = AFP_ERR_PARAM;
				break;
			}
			RtlCopyMemory(pFDParm1->_fdp_LongName.Buffer,
						  pBuffer1+NameOffset1+sizeof(BYTE),
						  pFDParm1->_fdp_LongName.Length);
            AfpConvertStringToMungedUnicode(&pFDParm1->_fdp_LongName, pMatchString);
		}
		// OFFSPRINGS bit for directories, DATALEN bit for files are the same
		if (Bitmap & DIR_BITMAP_OFFSPRINGS)
		{
			ASSERT(pFDParm1->_fdp_Flags != (DFE_FLAGS_FILE_WITH_ID | DFE_FLAGS_DIR));
			if (IsDir(pFDParm1))
			{
				// We have to combine total offspring count into the
				// FileCount field here since the API does not separate
				// them into separate file and dir offspring counts
				GETSHORT2DWORD(&pFDParm1->_fdp_FileCount, pBuffer1+Offset);
				GETSHORT2DWORD(&pFDParm2->_fdp_FileCount, pBuffer2+Offset);
				Offset += sizeof(USHORT);
			}
			else
			{
				GETDWORD2DWORD(&pFDParm1->_fdp_DataForkLen, pBuffer1+Offset);
				GETDWORD2DWORD(&pFDParm2->_fdp_DataForkLen, pBuffer2+Offset);
				Offset += sizeof(DWORD);
			}
		}
		if (Bitmap & FILE_BITMAP_RESCLEN)
		{
			ASSERT(pFDParm1->_fdp_Flags == DFE_FLAGS_FILE_WITH_ID);
			GETDWORD2DWORD(&pFDParm1->_fdp_RescForkLen, pBuffer1+Offset);
			GETDWORD2DWORD(&pFDParm2->_fdp_RescForkLen, pBuffer2+Offset);
			Offset += sizeof(DWORD);
		}

	} while (False);

	return Status;
}

/***	AfpIsCatSearchMatch
 *
 *	Given a DFE and a set of search criteria, see if this item should be
 *  returned as a match in the catalog search.
 *
 *
 *	LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Exclusive)
 */
SHORT
AfpIsCatSearchMatch(
	IN	PDFENTRY		pDFE,
	IN	DWORD			Bitmap,			// Search criteria
	IN	DWORD			ReplyBitmap,	// Info to return
	IN	PFILEDIRPARM	pFDParm1,
	IN	PFILEDIRPARM	pFDParm2,
	IN	PUNICODE_STRING	pMatchName OPTIONAL	
)
{
	BOOLEAN		IsMatch = True;
	SHORT		Length = 0;

	PAGED_CODE();

	do
	{

		if (Bitmap & FD_BITMAP_ATTR)
		{
			FILEDIRPARM	fdp;

			fdp._fdp_Attr = pDFE->dfe_AfpAttr;
			AfpNormalizeAfpAttr(&fdp, pDFE->dfe_NtAttr);

			if ((fdp._fdp_Attr & pFDParm2->_fdp_Attr) != pFDParm1->_fdp_Attr)

			{
				IsMatch = False;
				break;
			}
		}
		if (Bitmap & FD_BITMAP_PARENT_DIRID)
		{
			if ((pDFE->dfe_Parent->dfe_AfpId < pFDParm1->_fdp_ParentId) ||
				(pDFE->dfe_Parent->dfe_AfpId > pFDParm2->_fdp_ParentId))
			{
				IsMatch = False;
				break;
			}
		}
		if (Bitmap & FD_BITMAP_CREATETIME)
		{
			if (((AFPTIME)pDFE->dfe_CreateTime < (AFPTIME)pFDParm1->_fdp_CreateTime) ||
				((AFPTIME)pDFE->dfe_CreateTime > (AFPTIME)pFDParm2->_fdp_CreateTime))
			{
				IsMatch = False;
				break;
			}
		}
		if (Bitmap & FD_BITMAP_MODIFIEDTIME)
		{
			AFPTIME	ModTime;

			ModTime = AfpConvertTimeToMacFormat(&pDFE->dfe_LastModTime);
			if ((ModTime < pFDParm1->_fdp_ModifiedTime) ||
				(ModTime > pFDParm2->_fdp_ModifiedTime))
			{
				IsMatch = False;
				break;
			}
		}
		if (Bitmap & FD_BITMAP_BACKUPTIME)
		{
			if ((pDFE->dfe_BackupTime < pFDParm1->_fdp_BackupTime) ||
				(pDFE->dfe_BackupTime > pFDParm2->_fdp_BackupTime))
			{
				IsMatch = False;
				break;
			}
		}
		if (Bitmap & FD_BITMAP_FINDERINFO)
		{
			int			i;
			PBYTE		pF, p1, p2;
			FINDERINFO 	FinderInfo;

			// NOTE: why doesn't dfe_FinderInfo.Attr1 correctly reflect the
			// Nt Hidden attribute in the first place?
			FinderInfo = pDFE->dfe_FinderInfo;
			if (pDFE->dfe_NtAttr & FILE_ATTRIBUTE_HIDDEN)
				FinderInfo.fd_Attr1 |= FINDER_FLAG_INVISIBLE;

			pF = (PBYTE) &FinderInfo;
			p1 = (PBYTE) &pFDParm1->_fdp_FinderInfo;
			p2 = (PBYTE) &pFDParm2->_fdp_FinderInfo;

			for (i = 0; i < sizeof(FINDERINFO); i++)
			{
				if ((*pF++ & *p2++) != *p1++)
				{
					IsMatch = False;
					break;	// out of for loop
				}
			}

			if (IsMatch == False)
				break;	// out of while loop
		}
		if (Bitmap & FD_BITMAP_LONGNAME)
		{
			ASSERT(ARGUMENT_PRESENT(pMatchName));

			if (pFDParm2->_fdp_fPartialName)
			{
				// Name must contain substring
				if (!AfpIsProperSubstring(&pDFE->dfe_UnicodeName, pMatchName))
				{
					IsMatch = False;
					break;
				}
			}
			else if (!EQUAL_UNICODE_STRING(&pDFE->dfe_UnicodeName, pMatchName, True))
			{
				// Whole name must match
				IsMatch = False;
				break;
			}
		}
		if (Bitmap & FILE_BITMAP_DATALEN)
		{
			// This bit is also used as DIR_BITMAP_OFFSPRINGS for directories
			if (IsDir(pFDParm1))
			{
				DWORD count;

				ASSERT(DFE_IS_DIRECTORY(pDFE) && DFE_CHILDREN_ARE_PRESENT(pDFE));

				count = pDFE->dfe_DirOffspring + pDFE->dfe_FileOffspring;

				// In this case, _fdp_FileCount holds total # of files and dirs
				if ((count < pFDParm1->_fdp_FileCount) ||
					(count > pFDParm2->_fdp_FileCount))
				{
					IsMatch = False;
					break;
				}
			}
			else
			{
				ASSERT(DFE_IS_FILE(pDFE));

				if ((pDFE->dfe_DataLen < pFDParm1->_fdp_DataForkLen) ||
					(pDFE->dfe_DataLen > pFDParm2->_fdp_DataForkLen))
				{
					IsMatch = False;
					break;
				}
			}
	
		}
		if (Bitmap & FILE_BITMAP_RESCLEN)
		{
			ASSERT(DFE_IS_FILE(pDFE));

			if ((pDFE->dfe_RescLen < pFDParm1->_fdp_RescForkLen) ||
				(pDFE->dfe_RescLen > pFDParm2->_fdp_RescForkLen))
			{
				IsMatch = False;
				break;
			}
		}
	
	} while (False);

	if (IsMatch)
	{
		Length = 2 * sizeof(BYTE);	// Struct Length plus File/Dir Flag
		if (ReplyBitmap & FD_BITMAP_PARENT_DIRID)
		{
			Length += sizeof(DWORD);
		}
		if (ReplyBitmap & FD_BITMAP_LONGNAME)
		{
			// Offset to string + pascal string length + characters
#ifdef DBCS
// FiX #11992 SFM: As a result of search, I get incorrect file information.
// 1996.09.26 V-HIDEKK
			{
			ANSI_STRING	AName;
			BYTE		NameBuf[AFP_LONGNAME_LEN+1];

			AfpInitAnsiStringWithNonNullTerm(&AName, sizeof(NameBuf), NameBuf);
			AfpConvertMungedUnicodeToAnsi(&pDFE->dfe_UnicodeName, &AName);
			Length += sizeof(USHORT) + sizeof(BYTE) + AName.Length;
			}
#else
			Length += sizeof(USHORT) + sizeof(BYTE) + pDFE->dfe_UnicodeName.Length/sizeof(WCHAR);
#endif
		}
		Length = EVENALIGN(Length);
	}

	return Length;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\dsi.c ===
/*

Copyright (c) 1998  Microsoft Corporation

Module Name:

	dsi.c

Abstract:

	This module contains the routines that implement the Data Stream Interface
    (DSI) for AFP/TCP.


Author:

	Shirish Koti


Revision History:
	22 Jan 1998		Initial Version

--*/

#define	FILENUM	FILE_TCPDSI

#include <afp.h>



/***	DsiAfpSetStatus
 *
 *	This routine is a direct call-in from AFP.
 *  It frees up the earlier status buffer, if any, and stores the new status as
 *  given by AFP into a new buffer
 *
 *  Parm IN:  Context - unused (Appletalk interface compatibility)
 *            pStatusBuf - the buffer containing new status
 *            StsBufSize - size of this buffer
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiAfpSetStatus(
    IN  PVOID   Context,
    IN  PUCHAR  pStatusBuf,
    IN  USHORT  StsBufSize
)
{
    PBYTE       pBuffer;
    PBYTE       pOldBuffer;
    KIRQL       OldIrql;


    pBuffer = AfpAllocNonPagedMemory(StsBufSize);
    if (pBuffer == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAfpSetStatus: malloc failed\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(pBuffer, pStatusBuf, StsBufSize);

    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);

    pOldBuffer = DsiStatusBuffer;
    DsiStatusBuffer = pBuffer;
    DsiStatusBufferSize = StsBufSize;

    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    if (pOldBuffer)
    {
        AfpFreeMemory(pOldBuffer);
    }

    return(STATUS_SUCCESS);
}



/***	DsiAfpCloseConn
 *
 *	This routine is a direct call-in from AFP.
 *  It honors AFP's request to close the session down
 *
 *  Parm IN:  pTcpConn - the connection context to close
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiAfpCloseConn(
    IN  PTCPCONN    pTcpConn
)
{
    KIRQL       OldIrql;
    NTSTATUS    status=STATUS_SUCCESS;
    BOOLEAN     fAlreadyDown=TRUE;


    ASSERT(VALID_TCPCONN(pTcpConn));

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);
    if (pTcpConn->con_State & TCPCONN_STATE_NOTIFY_AFP)
    {
        fAlreadyDown = FALSE;
        pTcpConn->con_State &= ~TCPCONN_STATE_NOTIFY_AFP;
        pTcpConn->con_State |= TCPCONN_STATE_TICKLES_STOPPED;
    }
    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    if (!fAlreadyDown)
    {
        status = DsiSendDsiRequest(pTcpConn, 0, 0, NULL,DSI_COMMAND_CLOSESESSION);
    }

    return(status);
}


/***	DsiAfpFreeConn
 *
 *	This routine is a direct call-in from AFP.
 *  With this call, AFP tells DSI that its connection is being freed.  We can
 *  now remove the refcount on pTcpConn that we had put to protect AFP's context
 *
 *  Parm IN:  pTcpConn - the connection context to close
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiAfpFreeConn(
    IN  PTCPCONN    pTcpConn
)
{
    ASSERT(VALID_TCPCONN(pTcpConn));

    // remove AFP refcount
    DsiDereferenceConnection(pTcpConn);

    DBGREFCOUNT(("DsiAfpFreeConn: AFP dec %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    return(STATUS_SUCCESS);
}


/***	DsiAfpListenControl
 *
 *	This routine is a direct call-in from AFP.
 *  It honors AFP's request to either enable or disable "listens".  We don't do
 *  anything fancy here: simply toggle a global variable.
 *
 *  Parm IN:  Context - unused (Appletalk interface compatibility)
 *            Enable - enable or disable?
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS FASTCALL
DsiAfpListenControl(
    IN  PVOID       Context,
    IN  BOOLEAN     Enable
)
{
    KIRQL       OldIrql;

    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);
    DsiTcpEnabled = Enable;
    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    // update the status buffer, since listen is now enabled or disabled
    DsiScheduleWorkerEvent(DsiUpdateAfpStatus, NULL);

    return(STATUS_SUCCESS);
}


/***	DsiAfpWriteContinue
 *
 *	This routine is a direct call-in from AFP.
 *  AFP calls this routine to tell that a previous request to allocate
 *  Mdl (and buffer) has completed and that whatever action was postponed can
 *  now continue
 *
 *  Parm IN:  pRequest - pointer to the request structure
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS FASTCALL
DsiAfpWriteContinue(
    IN  PREQUEST    pRequest
)
{
    KIRQL               OldIrql;
    NTSTATUS            status=STATUS_SUCCESS;
    PDSIREQ             pDsiReq;
    PTCPCONN            pTcpConn;
    PDEVICE_OBJECT      pDeviceObject;
    PIRP                pIrp;
    BOOLEAN             fAbortConnection=FALSE;


    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
        ("DsiAfpWriteContinue: entered with pRequest = %lx\n",pRequest));

    pDsiReq = CONTAINING_RECORD(pRequest, DSIREQ, dsi_AfpRequest);

    ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

    pTcpConn = pDsiReq->dsi_pTcpConn;

    ASSERT(VALID_TCPCONN(pTcpConn));


    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    ASSERT(pTcpConn->con_RcvState == DSI_AWAITING_WRITE_MDL);
    ASSERT(pDsiReq == pTcpConn->con_pDsiReq);
    ASSERT(!(pTcpConn->con_State & TCPCONN_STATE_TCP_HAS_IRP));

    pTcpConn->con_RcvState = DSI_PARTIAL_WRITE;

    //
    // if connection is closing or if Mdl alloc failed, not much we can do but
    // to abort the connection!
    //
    if ((pTcpConn->con_State & TCPCONN_STATE_CLOSING) ||
        (pRequest->rq_WriteMdl == NULL))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAfpWriteContinue: aborting conn! %lx\n",pRequest));
        fAbortConnection = TRUE;
    }

    else
    {
        ASSERT(AfpMdlChainSize(pRequest->rq_WriteMdl) == pDsiReq->dsi_WriteLen);

        pIrp = DsiGetIrpForTcp(pTcpConn, NULL, pRequest->rq_WriteMdl, pDsiReq->dsi_WriteLen);

        if (pIrp == NULL)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiAfpWriteContinue: irp alloc failed, aborting connection\n"));
            fAbortConnection = TRUE;
        }
    }

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    if (fAbortConnection)
    {
        DsiAbortConnection(pTcpConn);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pDeviceObject = IoGetRelatedDeviceObject(pTcpConn->con_pFileObject);

    // since we are calling IoCallDriver, undo what was done to this irp!
    IoSkipCurrentIrpStackLocation(pIrp)

    //
    // hand over the irp to tell TCP to fill our buffer
    //
    IoCallDriver(pDeviceObject,pIrp);

    return(status);
}


/***	DsiAfpReply
 *
 *	This routine is a direct call-in from AFP.
 *  It honors AFP's request to send a reply to the client.  When TCP completes
 *  our send (that contains AFP's reply), then we complete this reply for AFP
 *  (i.e. call AFP's completion routine)
 *
 *  Parm IN:  pRequest - pointer to the request structure
 *            pResultCode - error code (ErrorCode field of DSI header)
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS FASTCALL
DsiAfpReply(
    IN  PREQUEST    pRequest,
    IN  PBYTE       pResultCode
)
{
    NTSTATUS    status;
    PDSIREQ     pDsiReq;
    KIRQL       OldIrql;
    PBYTE       pPacket;
    PTCPCONN    pTcpConn;
    PMDL        pMdl;
    DWORD       DataLen;
    DWORD       SendLen;
    BOOLEAN     fWeAllocated=FALSE;


    pDsiReq = CONTAINING_RECORD(pRequest, DSIREQ, dsi_AfpRequest);

    ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

    pTcpConn = pDsiReq->dsi_pTcpConn;

    ASSERT(VALID_TCPCONN(pTcpConn));

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);
    if (pTcpConn->con_State & TCPCONN_STATE_CLOSING)
    {
        RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);
        DsiAfpReplyCompletion(NULL, NULL, pDsiReq);
        return(STATUS_SUCCESS);
    }
    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    //
    // we need to append our own Mdl (for DSI header) if the outgoing data
    // is part of cache mgr's Mdl
    //
    if (pRequest->rq_CacheMgrContext)
    {
        pPacket = &pDsiReq->dsi_RespHeader[0];

        if (pDsiReq->dsi_AfpRequest.rq_ReplyMdl)
        {
            DataLen = AfpMdlChainSize(pDsiReq->dsi_AfpRequest.rq_ReplyMdl);
        }
        else
        {
            DataLen = 0;
        }

        SendLen = DataLen + DSI_HEADER_SIZE;

        pMdl = AfpAllocMdl(pPacket, DSI_HEADER_SIZE, NULL);
        if (pMdl == NULL)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiAfpReply: mdl alloc failed!\n"));

            DsiAfpReplyCompletion(NULL, NULL, pDsiReq);
            DsiAbortConnection(pTcpConn);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        // link in Afp's mdl
        pMdl->Next = pDsiReq->dsi_AfpRequest.rq_ReplyMdl;

        pDsiReq->dsi_pDsiAllocedMdl = pMdl;
        fWeAllocated = TRUE;
    }
    else
    {
        pMdl = pDsiReq->dsi_AfpRequest.rq_ReplyMdl;

        if (pMdl)
        {
            //
            // get the total length of the send, which include the DSI header size
            //
            SendLen = AfpMdlChainSize(pMdl);

            ASSERT(SendLen >= DSI_HEADER_SIZE);
            DataLen = SendLen - DSI_HEADER_SIZE;

            pPacket = MmGetSystemAddressForMdlSafe(
					        pMdl,
					        NormalPagePriority);
			if (pPacket == NULL)
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
				goto error_end;
			}

#if DBG
            // make sure we allocated room for the DSI header!
            ASSERT(*(DWORD *)pPacket == 0x081294);
#endif

        }
        else
        {
            pPacket = &pDsiReq->dsi_RespHeader[0];
            SendLen = DSI_HEADER_SIZE;
            DataLen = 0;

            pMdl = AfpAllocMdl(pPacket, SendLen, NULL);
            if (pMdl == NULL)
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiAfpReply: mdl alloc failed!\n"));

                DsiAfpReplyCompletion(NULL, NULL, pDsiReq);
                DsiAbortConnection(pTcpConn);
                return(STATUS_INSUFFICIENT_RESOURCES);
            }

            pDsiReq->dsi_pDsiAllocedMdl = pMdl;
            fWeAllocated = TRUE;
        }
    }

    //
    // form the DSI header
    //

    pPacket[DSI_OFFSET_FLAGS] = DSI_REPLY;
    pPacket[DSI_OFFSET_COMMAND] = pDsiReq->dsi_Command;

    PUTSHORT2SHORT(&pPacket[DSI_OFFSET_REQUESTID], pDsiReq->dsi_RequestID);

    *(DWORD *)&pPacket[DSI_OFFSET_DATAOFFSET] = *(DWORD *)pResultCode;

    PUTDWORD2DWORD(&pPacket[DSI_OFFSET_DATALEN], DataLen);

    PUTDWORD2DWORD(&pPacket[DSI_OFFSET_RESERVED], 0);

    status = DsiTdiSend(pTcpConn,
                        pMdl,
                        SendLen,
                        DsiAfpReplyCompletion,
                        pDsiReq);

error_end:

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAfpReply: DsiTdiSend failed %lx\n",status));

        if (fWeAllocated)
        {
            pMdl->Next = NULL;
            AfpFreeMdl(pMdl);
        }
        DsiAfpReplyCompletion(NULL, NULL, pDsiReq);
        status = STATUS_PENDING;
    }

    return(status);
}



/***	DsiAfpSendAttention
 *
 *	This routine is a direct call-in from AFP.
 *  It honors AFP's request to send attention to the client.
 *
 *  Parm IN:  pTcpConn - the connection context to close
 *            AttentionWord - attention word to send
 *            pContext - context, to be supplied at completion time
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiAfpSendAttention(
    IN  PTCPCONN    pTcpConn,
    IN  USHORT      AttentionWord,
    IN  PVOID       pContext
)
{

    NTSTATUS        status;


    ASSERT(VALID_TCPCONN(pTcpConn));

    status = DsiSendDsiRequest(pTcpConn,
                               sizeof(USHORT),
                               AttentionWord,
                               pContext,
                               DSI_COMMAND_ATTENTION);
    return(status);
}


/***	DsiAcceptConnection
 *
 *	This routine accepts (or rejects) an incoming tcp connection request.
 *  Basically, after making a few checks, a (pre-allocated) connection object
 *  is dequeued and returned as our context to TCP.
 *
 *  Parm IN:  pTcpAdptr - adapter
 *            MacIpAddr - ipaddr of the Mac that's connecting
 *
 *  Parm OUT: ppRetTcpCon - connection object we are returning as context
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiAcceptConnection(
    IN  PTCPADPTR       pTcpAdptr,
    IN  IPADDRESS       MacIpAddr,
    OUT PTCPCONN       *ppRetTcpConn
)
{

    NTSTATUS        status=STATUS_SUCCESS;
    KIRQL           OldIrql;
    PTCPCONN        pTcpConn;
    PLIST_ENTRY     pList;
    DWORD           dwReplCount=0;
    DWORD           i;
    BOOLEAN         fReplenish=FALSE;


    *ppRetTcpConn = NULL;

    // if the server is disabled, don't accept this connection
    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);
    if (!DsiTcpEnabled)
    {
        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAcceptConnection: Server is disabled\n"));

        return(STATUS_DATA_NOT_ACCEPTED);
    }
    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);


    ACQUIRE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, &OldIrql);

    //
    // if the adapter is closing, don't accept this connection
    //
    if (pTcpAdptr->adp_State & TCPADPTR_STATE_CLOSING)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAcceptConnection: %lx is closing, rejecting connection\n",pTcpAdptr));

        goto DsiAcceptConnection_ErrExit;
    }

    //
    // do we have a connection object available in the free list?
    //
    if (IsListEmpty(&pTcpAdptr->adp_FreeConnHead))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAcceptConnection: FreeConnHead empty, rejecting connection\n"));

        goto DsiAcceptConnection_ErrExit;
    }

    pList = RemoveHeadList(&pTcpAdptr->adp_FreeConnHead);

    ASSERT(pTcpAdptr->adp_NumFreeConnections > 0);

    pTcpAdptr->adp_NumFreeConnections--;

    pTcpConn = CONTAINING_RECORD(pList, TCPCONN, con_Linkage);

    ACQUIRE_SPIN_LOCK_AT_DPC(&pTcpConn->con_SpinLock);

    // put TCP CLIENT-FIN refcount, removed after TCP tells us it got client's FIN
    pTcpConn->con_RefCount++;

    DBGREFCOUNT(("DsiAcceptConnection: CLIENT-FIN inc %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    // put TCP SRVR-FIN refcount, removed after TCP tells us it sent out FIN
    pTcpConn->con_RefCount++;

    DBGREFCOUNT(("DsiAcceptConnection: SRVR-FIN inc %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    // put ACCEPT refcount, removed after TCP calls our accept completion
    pTcpConn->con_RefCount++;

    DBGREFCOUNT(("DsiAcceptConnection: ACCEPT inc %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    pTcpConn->con_State |= (TCPCONN_STATE_CONNECTED | TCPCONN_STATE_NOTIFY_TCP);

    pTcpConn->con_DestIpAddr = MacIpAddr;

    //
    // put this connection on the active list (though this isn't fully active yet)
    //
    InsertTailList(&pTcpAdptr->adp_ActiveConnHead, &pTcpConn->con_Linkage);

    RELEASE_SPIN_LOCK_FROM_DPC(&pTcpConn->con_SpinLock);

    if (pTcpAdptr->adp_NumFreeConnections < DSI_INIT_FREECONNLIST_SIZE)
    {
        //
        // we are going to create a new connection in the free list to replenish
        // the one we just used up: make sure adapter stays around when that
        // delayed event fires!
        //
        pTcpAdptr->adp_RefCount++;
        fReplenish = TRUE;
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAcceptConnection: at or above limit (%d): NOT replenishing\n",
            pTcpAdptr->adp_NumFreeConnections));
    }

    RELEASE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, OldIrql);

    if (fReplenish)
    {
        //
        // now schedule that event to replenish the connection...
        //
        DsiScheduleWorkerEvent(DsiCreateTcpConn, pTcpAdptr);
    }


    *ppRetTcpConn = pTcpConn;

    ACQUIRE_SPIN_LOCK(&DsiResourceLock, &OldIrql);
    DsiNumTcpConnections++;
    RELEASE_SPIN_LOCK(&DsiResourceLock, OldIrql);

    return(STATUS_SUCCESS);


    //
    // Error case
    //
DsiAcceptConnection_ErrExit:

    if (pTcpAdptr->adp_NumFreeConnections < DSI_INIT_FREECONNLIST_SIZE)
    {
        dwReplCount = (DSI_INIT_FREECONNLIST_SIZE - pTcpAdptr->adp_NumFreeConnections);

        pTcpAdptr->adp_RefCount += dwReplCount;
        fReplenish = TRUE;

        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAcceptConnection: below limit (%d): replenishing %d times\n",
            pTcpAdptr->adp_NumFreeConnections,dwReplCount));
    }

    RELEASE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, OldIrql);

    if (fReplenish)
    {
        for (i=0; i<dwReplCount; i++)
        {
            DsiScheduleWorkerEvent(DsiCreateTcpConn, pTcpAdptr);
        }
    }

    return(STATUS_DATA_NOT_ACCEPTED);

}


/***	DsiProcessData
 *
 *	This routine is the main data processing state machine.  Since TCP is a
 *  streaming protocol, there is no guarantee that whatever the client sent
 *  can come in in one piece.  That's why the states.  Here's what they mean:
 *
 *  DSI_NEW_REQUEST      : init state, waiting for a new request from client
 *  DSI_PARTIAL_HEADER   : we have received only some of the 16 bytes of hdr
 *  DSI_HDR_COMPLETE     : we have the complete header (received all 16 bytes)
 *  DSI_PARTIAL_COMMAND  : we have recvd only some of the request bytes
 *  DSI_COMMAND_COMPLETE : we have recvd all of the request bytes
 *  DSI_PARTIAL_WRITE    : we have recvd some of the Write bytes
 *  DSI_WRITE_COMPLETE   : we have recvd all of the Write bytes
 *
 *  Parm IN:  pTcpConn - the connection object in question
 *            BytesIndicated - bytes indicated
 *            BytesAvailable - bytes available (usually same as indicated)
 *            pBufferFromTcp - pointer to the DSI data
 *
 *  Parm OUT: pBytesAccepted - pointer to how many bytes we consumed
 *            ppIrp - pointer to an irp pointer, if necessary
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiProcessData(
    IN  PTCPCONN    pTcpConn,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    IN  PBYTE       pBufferFromTcp,
    OUT PULONG      pBytesAccepted,
    OUT PIRP       *ppRetIrp
)
{

    KIRQL           OldIrql;
    NTSTATUS        status=STATUS_SUCCESS;
    DWORD           BytesConsumed=0;
    DWORD           UnProcessedBytes;
    DWORD           BytesNeeded;
    DWORD           BytesActuallyCopied;
    PBYTE           pStreamPtr;
    PBYTE           pDestBuffer;
    PBYTE           pHdrBuf=NULL;
    DWORD           RequestLen;
    PDSIREQ         pDsiReq=NULL;
    PMDL            pMdl;
    PIRP            pIrp;
    BOOLEAN         fSomeMoreProcessing=TRUE;
    BOOLEAN         fTCPHasMore=FALSE;



    *ppRetIrp = NULL;

    UnProcessedBytes = BytesIndicated;

    pStreamPtr = pBufferFromTcp;


    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    // if we are closing, throw away these bytes
    if (pTcpConn->con_State & TCPCONN_STATE_CLOSING)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiProcessData: dropping data, conn %lx closing\n",pTcpConn));

        RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);
        *pBytesAccepted = BytesIndicated;
        return(STATUS_SUCCESS);
    }

    //
    // this can happen if we are just submitting an irp down, and before the irp
    // gets down to TCP, an indicate comes in.  Reject this data since our irp is
    // on its way.
    //
    if (pTcpConn->con_State & TCPCONN_STATE_TCP_HAS_IRP)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
            ("DsiProcessData: TCP has irp, so rejecting indication\n"));

        *pBytesAccepted = 0;
        pTcpConn->con_BytesWithTcp += BytesAvailable;

        RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // if we already know TCP has unconsumed bytes, or if TCP is indicating less
    // than what's available, mark the fact that TCP has more stuff with it
    //
    if (BytesAvailable > BytesIndicated)
    {
        fTCPHasMore = TRUE;
    }


    while (fSomeMoreProcessing)
    {
        fSomeMoreProcessing = FALSE;

        switch (pTcpConn->con_RcvState)
        {
            //
            // most common case.  We are ready to deal with a new request.
            //
            case DSI_NEW_REQUEST:

                ASSERT(!(pTcpConn->con_State & TCPCONN_STATE_PARTIAL_DATA));

                pDsiReq = DsiGetRequest();

                if (pDsiReq == NULL)
                {
                    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                        ("DsiProcessData: DsiGetRequest failed, killing %lx\n",pTcpConn));

                    goto DsiProcessData_ErrorExit;
                }

                pDsiReq->dsi_pTcpConn = pTcpConn;

                pTcpConn->con_pDsiReq = pDsiReq;

                // put a REQUEST refcount - remove when the request is done
                pTcpConn->con_RefCount++;

                DBGREFCOUNT(("DsiProcessData: REQUEST inc %lx (%d  %d,%d)\n",
                    pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

                //
                // do we have the complete header?
                //
                if (UnProcessedBytes >= DSI_HEADER_SIZE)
                {
                    //
                    // get info out of the header
                    //
                    DSI_PARSE_HEADER(pDsiReq, pStreamPtr);

                    //
                    // hack!  Mac client 3.7 has a bug where if a 0-byte Write is
                    // sent to us, the DataOffset field is 0, but Total Data Length
                    // field is 0xC (or whatever the request length is)
                    // Put in a workaround!
                    //
                    if ((pDsiReq->dsi_Command == DSI_COMMAND_WRITE) &&
                        (pDsiReq->dsi_RequestLen == 0))
                    {
                        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                            ("DsiProcessData: 0-byte Write hack to workaround Mac's bug\n"));

                        pDsiReq->dsi_RequestLen = pDsiReq->dsi_WriteLen;
                        pDsiReq->dsi_WriteLen = 0;
                    }

                    // update all the counters and buffers
                    BytesConsumed += DSI_HEADER_SIZE;
                    pStreamPtr += DSI_HEADER_SIZE;
                    UnProcessedBytes -= DSI_HEADER_SIZE;

                    ASSERT(pStreamPtr <= pBufferFromTcp+BytesIndicated);

                    pTcpConn->con_RcvState = DSI_HDR_COMPLETE;

                    // make sure we visit case DSI_HDR_COMPLETE: before leaving
                    fSomeMoreProcessing = TRUE;
                }

                //
                // yikes, only part of the header has come in
                // just set the state and let the parsing loop continue..
                //
                else
                {
                    pTcpConn->con_State |= TCPCONN_STATE_PARTIAL_DATA;
                    pTcpConn->con_RcvState = DSI_PARTIAL_HEADER;
                    pTcpConn->con_pDsiReq->dsi_RequestLen = DSI_HEADER_SIZE;
                }

                break;  // case DSI_NEW_REQUEST:


            //
            // PartialHeader case is extremely unlikely to occur, given how small
            // the header is (16 bytes).  But given that we have a streaming
            // protocol (TCP) below us, anything is possible.
            // PartialCommand is also unlikely for the same reason.  However, in
            // case of a Write command, we always force PartialCommand state
            // since it's very unlikely the whole Write can come in in one packet.
            //
            case DSI_PARTIAL_HEADER:
            case DSI_PARTIAL_COMMAND:

                pDsiReq = pTcpConn->con_pDsiReq;

                ASSERT(pDsiReq != NULL);
                ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

                ASSERT(pTcpConn->con_State & TCPCONN_STATE_PARTIAL_DATA);

                //
                // if we haven't started copying any bytes in yet then we need
                // to get storage room (use built-in buffer if possible)
                //
                if (pDsiReq->dsi_PartialBufSize == 0)
                {
                    ASSERT(pDsiReq->dsi_PartialBuf == NULL);

                    if (pDsiReq->dsi_RequestLen <= DSI_BUFF_SIZE)
                    {
                        pDsiReq->dsi_PartialBuf = &pDsiReq->dsi_RespHeader[0];
                    }
                    //
                    // allocate a buffer to hold this partial header.
                    //
                    else
                    {
                        pDsiReq->dsi_PartialBuf =
                                    DsiGetReqBuffer(pDsiReq->dsi_RequestLen);

                        if (pDsiReq->dsi_PartialBuf == NULL)
                        {
                            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                                ("DsiProcessData: Buffer alloc failed, killing %lx\n",pTcpConn));

                            goto DsiProcessData_ErrorExit;
                        }
                    }
                }

                //
                // how many more bytes do we need to complete this hdr/command
                //
                BytesNeeded = (pDsiReq->dsi_RequestLen - pDsiReq->dsi_PartialBufSize);

                //
                // if we don't have enough bytes to satisfy this Command (or Hdr),
                // don't copy anything but give an irp back to TCP
                //
                if (UnProcessedBytes < BytesNeeded)
                {
                    pIrp = DsiGetIrpForTcp(
                                pTcpConn,
                                (pDsiReq->dsi_PartialBuf + pDsiReq->dsi_PartialBufSize),
                                NULL,
                                BytesNeeded);

                    if (pIrp == NULL)
                    {
                        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                            ("DsiProcessData: couldn't alloc RcvIrp, killing %lx\n",pTcpConn));

                        goto DsiProcessData_ErrorExit;
                    }

                    pDsiReq->dsi_pDsiAllocedMdl = pIrp->MdlAddress;

                    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
                        ("DsiProcessData: A irp %lx to TCP for %d bytes (%lx)\n",
                        pIrp,BytesNeeded,pTcpConn));


                    *ppRetIrp = pIrp;

                    *pBytesAccepted = BytesConsumed;

                    // did TCP call us?  then update byte count
                    if (BytesIndicated)
                    {
                        pTcpConn->con_BytesWithTcp += (BytesAvailable - BytesConsumed);
                    }

                    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);
                    return(STATUS_MORE_PROCESSING_REQUIRED);
                }


                //
                // if the bytes we need are available, copy them in.  Then decide
                // what to do next (same if we already have the bytes)
                //
                else if ((UnProcessedBytes > 0) || (BytesNeeded == 0))
                {
                    if (BytesNeeded > 0)
                    {
                        ASSERT(pDsiReq->dsi_PartialBufSize == 0);

                        RtlCopyMemory(
                            (pDsiReq->dsi_PartialBuf + pDsiReq->dsi_PartialBufSize),
                            pStreamPtr,
                            BytesNeeded);


                        //
                        // update all the counters and buffers
                        //
                        pDsiReq->dsi_PartialBufSize += BytesNeeded;

                        BytesConsumed += BytesNeeded;
                        pStreamPtr += BytesNeeded;
                        UnProcessedBytes -= BytesNeeded;
                        ASSERT(pStreamPtr <= pBufferFromTcp+BytesIndicated);

                    }

                    // we should have all the bytes we need now
                    ASSERT(pDsiReq->dsi_PartialBufSize == pDsiReq->dsi_RequestLen);

                    //
                    // find out what the next rcv state should be
                    //
                    if (pTcpConn->con_RcvState == DSI_PARTIAL_HEADER)
                    {
                        //
                        // get info out of the header
                        //
                        DSI_PARSE_HEADER(pDsiReq, pDsiReq->dsi_PartialBuf);

                        //
                        // hack!  Mac client 3.7 has a bug where if a 0-byte Write is
                        // sent to us, the DataOffset field is 0, but Total Data Length
                        // field is 0xC (or whatever the request length is)
                        // Put in a workaround!
                        //
                        if ((pDsiReq->dsi_Command == DSI_COMMAND_WRITE) &&
                            (pDsiReq->dsi_RequestLen == 0))
                        {
                            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                                ("DsiProcessData: 0-byte Write hack to workaround Mac's bug\n"));

                            pDsiReq->dsi_RequestLen = pDsiReq->dsi_WriteLen;
                            pDsiReq->dsi_WriteLen = 0;
                        }

                        pTcpConn->con_RcvState = DSI_HDR_COMPLETE;
                    }

                    //
                    // no, we were in DSI_PARTIAL_COMMAND, so we will now move
                    // to DSI_PARTIAL_WRITE if this is a Write command, otherwise
                    // to DSI_COMMAND_COMPLETE
                    //
                    else
                    {
                        if (pDsiReq->dsi_Command == DSI_COMMAND_WRITE)
                        {
                            pDsiReq->dsi_AfpRequest.rq_RequestBuf =
                                                        pDsiReq->dsi_PartialBuf;

                            pDsiReq->dsi_AfpRequest.rq_RequestSize =
                                                    pDsiReq->dsi_PartialBufSize;

                            //
                            // for now, assume that AfpCB_GetWriteBuffer will
                            // return pending and set the state in anticipation
                            //
                            pTcpConn->con_RcvState = DSI_AWAITING_WRITE_MDL;

                            pDsiReq->dsi_PartialWriteSize = 0;

                            RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

                            //
                            // allocate the write mdl before we move to
                            // DSI_PARTIAL_WRITE state
                            //
                            status = AfpCB_GetWriteBuffer(pTcpConn->con_pSda,
                                                          &pDsiReq->dsi_AfpRequest);

                            ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

                            //
                            // most common case: file server will pend it so it can
                            // go to cache mgr
                            //
                            if (status == STATUS_PENDING)
                            {
                                // if TCP has any unconsumed bytes, update our count

                                if (BytesIndicated > 0)
                                {
                                    pTcpConn->con_BytesWithTcp +=
                                        (BytesAvailable - BytesConsumed);
                                }

                                RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

                                *pBytesAccepted = BytesConsumed;

                                status = (BytesConsumed)?
                                         STATUS_SUCCESS : STATUS_DATA_NOT_ACCEPTED;

                                return(status);
                            }
                            else if (status != STATUS_SUCCESS)
                            {
                                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                                    ("DsiProcessData: GetWriteBuffer failed\n"));

                                pTcpConn->con_RcvState = DSI_PARTIAL_WRITE;
                                goto DsiProcessData_ErrorExit;
                            }

                            //
                            // AfpCB_GetWriteBuffer succeeded synchronously: set
                            // the state to partial-write
                            //
                            pTcpConn->con_RcvState = DSI_PARTIAL_WRITE;

                            ASSERT((pDsiReq->dsi_AfpRequest.rq_WriteMdl != NULL) ||
                                   (pDsiReq->dsi_WriteLen == 0));

                            if (pDsiReq->dsi_WriteLen == 0)
                            {
                                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                                    ("DsiProcessData: 0-len write on %lx\n",pDsiReq));
                            }
                        }

                        //
                        // it's not a Write, but a Command
                        //
                        else
                        {
                            ASSERT(pDsiReq->dsi_Command == DSI_COMMAND_COMMAND);

                            pTcpConn->con_RcvState = DSI_COMMAND_COMPLETE;
                        }
                    }

                    // make sure we visit case DSI_HDR_COMPLETE: before leaving
                    fSomeMoreProcessing = TRUE;
                }

                break;  // case DSI_PARTIAL_HEADER: case DSI_PARTIAL_COMMAND:


            //
            // we have the full header:  see what we must do next
            //
            case DSI_HDR_COMPLETE:

                pDsiReq = pTcpConn->con_pDsiReq;

                ASSERT(pDsiReq != NULL);
                ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

                if (pTcpConn->con_State & TCPCONN_STATE_PARTIAL_DATA)
                {
                    ASSERT(pDsiReq->dsi_PartialBuf != NULL);
                    ASSERT(pDsiReq->dsi_PartialBufSize > 0);

                    if (pDsiReq->dsi_PartialBuf != &pDsiReq->dsi_RespHeader[0])
                    {
                        DsiFreeReqBuffer(pDsiReq->dsi_PartialBuf);
                    }
                    pDsiReq->dsi_PartialBuf = NULL;
                    pDsiReq->dsi_PartialBufSize = 0;
                }

                pTcpConn->con_State &= ~TCPCONN_STATE_PARTIAL_DATA;

                if (!DsiValidateHeader(pTcpConn, pDsiReq))
                {
                    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                        ("DsiProcessData: packet invalid, killing %lx\n",pTcpConn));

                    goto DsiProcessData_ErrorExit;
                }
                //
                // if this is a Write command, we need to get mdl from AFP
                //
                if (pDsiReq->dsi_Command == DSI_COMMAND_WRITE)
                {
                    // we need to copy the request bytes
                    pTcpConn->con_RcvState = DSI_PARTIAL_COMMAND;
                    pTcpConn->con_State |= TCPCONN_STATE_PARTIAL_DATA;
                }

                //
                // do we have all the bytes needed to complete the request?
                //
                else if (UnProcessedBytes >= pDsiReq->dsi_RequestLen)
                {
                    pTcpConn->con_RcvState = DSI_COMMAND_COMPLETE;

                    // make sure we visit case DSI_HDR_COMPLETE: before leaving
                    fSomeMoreProcessing = TRUE;
                }
                else
                {
                    pTcpConn->con_RcvState = DSI_PARTIAL_COMMAND;
                    pTcpConn->con_State |= TCPCONN_STATE_PARTIAL_DATA;
                }

                break;


            //
            // we are waiting for Afp to give us an mdl (and buffer), but TCP tells
            // us data has arrived: just note the fact, and go back
            //
            case DSI_AWAITING_WRITE_MDL:

                // did TCP call us?  then update byte count
                if (BytesIndicated)
                {
                    pTcpConn->con_BytesWithTcp += (BytesAvailable - BytesConsumed);
                }

                RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

                *pBytesAccepted = BytesConsumed;

                status = (BytesConsumed)? STATUS_SUCCESS : STATUS_DATA_NOT_ACCEPTED;

                return(status);

            //
            // we are in the middle of a Write command: copy the remaining bytes
            // needed to complete the Write, or whatever bytes that have come in
            // as the case may be
            //
            case DSI_PARTIAL_WRITE:

                pDsiReq = pTcpConn->con_pDsiReq;

                ASSERT(pDsiReq != NULL);
                ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

                BytesNeeded = (pDsiReq->dsi_WriteLen - pDsiReq->dsi_PartialWriteSize);

                //
                // if we don't have enough bytes to satisfy this Write, give irp to
                // TCP: TCP will come back when the irp completes
                //
                if (UnProcessedBytes < BytesNeeded)
                {
                    ASSERT(pDsiReq->dsi_AfpRequest.rq_WriteMdl != NULL);

                    pIrp = DsiGetIrpForTcp(
                                pTcpConn,
                                NULL,
                                pDsiReq->dsi_AfpRequest.rq_WriteMdl,
                                BytesNeeded);

                    if (pIrp == NULL)
                    {
                        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                            ("DsiProcessData: B couldn't alloc RcvIrp, killing %lx\n",pTcpConn));

                        goto DsiProcessData_ErrorExit;
                    }

                    ASSERT(pDsiReq->dsi_pDsiAllocedMdl == NULL);
                    ASSERT(pIrp->MdlAddress == pDsiReq->dsi_AfpRequest.rq_WriteMdl);

                    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
                        ("DsiProcessData: B irp for %d bytes,Rem=%d (%lx)\n",
                        BytesNeeded,pTcpConn->con_BytesWithTcp,pTcpConn));

                    *ppRetIrp = pIrp;
                    *pBytesAccepted = BytesConsumed;

                    // did TCP call us?  then update byte count
                    if (BytesIndicated)
                    {
                        pTcpConn->con_BytesWithTcp += (BytesAvailable - BytesConsumed);
                    }

                    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);
                    return(STATUS_MORE_PROCESSING_REQUIRED);
                }


                //
                // if the bytes we need are available, copy them in.  Then decide
                // what to do next (same if we already have the bytes)
                //
                else if ((UnProcessedBytes > 0) || (BytesNeeded == 0))
                {
                    ASSERT(BytesNeeded <= UnProcessedBytes);

                    if (BytesNeeded > 0)
                    {
                        ASSERT(pDsiReq->dsi_PartialWriteSize == 0);

                        TdiCopyBufferToMdl(pStreamPtr,
                                           0,
                                           BytesNeeded,
                                           pDsiReq->dsi_AfpRequest.rq_WriteMdl,
                                           pDsiReq->dsi_PartialWriteSize,
                                          &BytesActuallyCopied);

                        if (BytesActuallyCopied != BytesNeeded)
                        {
                            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                                ("DsiProcessData: Tdi copied %ld instead of %ld\n",
                                BytesActuallyCopied,BytesNeeded));

                            goto DsiProcessData_ErrorExit;
                        }

                        pDsiReq->dsi_PartialWriteSize += BytesNeeded;

                        BytesConsumed += BytesActuallyCopied;
                        pStreamPtr += BytesActuallyCopied;
                        UnProcessedBytes -= BytesActuallyCopied;
                    }

                    // at this point, all the bytes needed to satisfy the Write should be in
                    ASSERT(pDsiReq->dsi_PartialWriteSize == pDsiReq->dsi_WriteLen);

                    pTcpConn->con_RcvState = DSI_WRITE_COMPLETE;

                    // make sure we visit case DSI_WRITE_COMPLETE: before leaving
                    fSomeMoreProcessing = TRUE;
                }

                ASSERT(pStreamPtr <= pBufferFromTcp+BytesIndicated);

                break;  // case DSI_PARTIAL_WRITE:


            case DSI_COMMAND_COMPLETE:
            case DSI_WRITE_COMPLETE:

                pDsiReq = pTcpConn->con_pDsiReq;

                ASSERT(pDsiReq != NULL);
                ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

                //
                // setup the AfpRequest according whether we buffered the
                // request or whether we are using TCP's buffer
                //

                if (pTcpConn->con_State & TCPCONN_STATE_PARTIAL_DATA)
                {
                    ASSERT(pDsiReq->dsi_PartialBufSize != 0);
                    ASSERT(pDsiReq->dsi_PartialBuf != NULL);
                    ASSERT(pDsiReq->dsi_PartialBufSize == pDsiReq->dsi_RequestLen);

                    pDsiReq->dsi_AfpRequest.rq_RequestBuf = pDsiReq->dsi_PartialBuf;
                }
                else
                {
                    pDsiReq->dsi_AfpRequest.rq_RequestBuf = pStreamPtr;
                }

                pDsiReq->dsi_AfpRequest.rq_RequestSize = pDsiReq->dsi_RequestLen;

                InsertTailList(&pTcpConn->con_PendingReqs, &pDsiReq->dsi_Linkage);

                pTcpConn->con_pDsiReq = NULL;

                RequestLen = pDsiReq->dsi_RequestLen;

                RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

                //
                // call the routine to take appropriate action, based on what
                // DSI command it is
                // Once we are back from this routine, there is no telling what
                // would have happened to pDsiReq!  So don't touch it!
                //
                status = DsiExecuteCommand(pTcpConn, pDsiReq);

                if (!NT_SUCCESS(status))
                {
                    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                        ("DsiProcessData: fatal error %lx, killing %lx\n",status,pTcpConn));

                    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);
                    RemoveEntryList(&pDsiReq->dsi_Linkage);
                    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

                    if (pDsiReq->dsi_AfpRequest.rq_WriteMdl != NULL)
                    {
                        pDsiReq->dsi_AfpRequest.rq_RequestSize =
                            (LONG)pTcpConn->con_DestIpAddr;

                        ASSERT(pTcpConn->con_pSda != NULL);
                        AfpCB_RequestNotify(STATUS_REMOTE_DISCONNECT,
                                            pTcpConn->con_pSda,
                                            &pDsiReq->dsi_AfpRequest);
                    }

                    DsiAbortConnection(pTcpConn);
                    DsiFreeRequest(pDsiReq);

                    // remove the REQUEST refcount
                    DsiDereferenceConnection(pTcpConn);
                    DBGREFCOUNT(("DsiProcessData: REQUEST dec %lx (%d  %d,%d)\n",
                        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
                    *pBytesAccepted = BytesIndicated;
                    return(STATUS_SUCCESS);
                }

                ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

                //
                // were we using our own buffer to buffer data that came in pieces?
                //
                if (pTcpConn->con_State & TCPCONN_STATE_PARTIAL_DATA)
                {
                    pTcpConn->con_State &= ~TCPCONN_STATE_PARTIAL_DATA;
                }
                //
                // we weren't buffering, but using TCP's buffer: update counters
                //
                else
                {
                    BytesConsumed += RequestLen;
                    pStreamPtr += RequestLen;
                    UnProcessedBytes -= RequestLen;
                }

                pTcpConn->con_RcvState = DSI_NEW_REQUEST;

                ASSERT(pStreamPtr <= pBufferFromTcp+BytesIndicated);

                break;  // case DSI_HDR_COMPLETE:


            default:

                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiProcessData: and what state is this??\n"));

                ASSERT(0);

                break;

        }  // switch (pTcpConn->con_RcvState)


        //
        // If there are more bytes yet to be processed, or if TCP has more
        // bytes that we need to retrieve, we go back into the loop
        //
        if ((UnProcessedBytes > 0) || (fTCPHasMore))
        {
            fSomeMoreProcessing = TRUE;
        }

    } // while (fSomeMoreProcessing)

    //
    // if no bytes were indicated (if we came here not via TCP) then, we shouldn't
    // have consumed anything!
    //
    if (BytesIndicated == 0)
    {
        ASSERT(BytesConsumed == 0);
    }

    // did TCP call us?  then update byte count
    if (BytesIndicated)
    {
        pTcpConn->con_BytesWithTcp += (BytesAvailable - BytesConsumed);
    }

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    ASSERT( UnProcessedBytes == 0 );
    ASSERT( BytesConsumed == BytesIndicated );

    *pBytesAccepted = BytesConsumed;

    return(status);


DsiProcessData_ErrorExit:

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
        ("DsiProcessData: executing Error path, aborting connection %lx\n",pTcpConn));

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);
    DsiAbortConnection(pTcpConn);
    *pBytesAccepted = BytesIndicated;

    return(STATUS_SUCCESS);

}



/***	DsiTcpRcvIrpCompletion
 *
 *	This routine is called into by TCP when it has finished copying all the data
 *  into the irp we supplied.
 *
 *  Parm IN:  Unused - well, unused!
 *            pIrp - the irp that we had passed
 *            pContext - our context (i.e. pTcpConn)
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiTcpRcvIrpCompletion(
    IN  PDEVICE_OBJECT  Unused,
    IN  PIRP            pIrp,
    IN  PVOID           pContext
)
{
    PDEVICE_OBJECT      pDeviceObject;
    PTCPCONN            pTcpConn;
    PDSIREQ             pDsiReq=NULL;
    KIRQL               OldIrql;
    PMDL                pMdl;
    PMDL                pOrgMdl;
    PMDL                pPrevPartialMdl;
    PMDL                pNewPartialMdl;
    NTSTATUS            status;
    DWORD               BytesTaken;
    DWORD               BytesThisTime;
    DWORD               BytesAvailable;
    PIRP                pIrpToPost=NULL;
    DWORD               BytesNeeded;
    DWORD               BytesSoFar;


    pTcpConn = (PTCPCONN)pContext;

    ASSERT(VALID_TCPCONN(pTcpConn));

    ASSERT(pIrp == pTcpConn->con_pRcvIrp);

    pMdl = pIrp->MdlAddress;

    pPrevPartialMdl = (pMdl->MdlFlags & MDL_PARTIAL) ? pMdl : NULL;

    status = pIrp->IoStatus.Status;

    // if the receive failed, not much can be done with this connection!
    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTcpRcvIrpCompletion: irp %lx failed %lx on %lx!\n",pIrp,status,pTcpConn));

        goto DsiTcpRcvIrp_Completed;
    }


    pDeviceObject = IoGetRelatedDeviceObject(pTcpConn->con_pFileObject);

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    if (pTcpConn->con_State & (TCPCONN_STATE_CLOSING | TCPCONN_STATE_CLEANED_UP))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTcpRcvIrpCompletion: conn %lx going away, ignoring date\n",pTcpConn));

        RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);
        goto DsiTcpRcvIrp_Completed;
    }

    ASSERT(pTcpConn->con_State & TCPCONN_STATE_TCP_HAS_IRP);

    BytesThisTime = (DWORD)(pIrp->IoStatus.Information);

    pDsiReq = pTcpConn->con_pDsiReq;

    ASSERT(pDsiReq != NULL);
    ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

    switch (pTcpConn->con_RcvState)
    {
        case DSI_PARTIAL_COMMAND:
        case DSI_PARTIAL_HEADER:

            pDsiReq->dsi_PartialBufSize += BytesThisTime;
            BytesSoFar = pDsiReq->dsi_PartialBufSize;

            ASSERT(BytesSoFar <= pDsiReq->dsi_RequestLen);
            BytesNeeded = (pDsiReq->dsi_RequestLen - BytesSoFar);

            pOrgMdl = pDsiReq->dsi_pDsiAllocedMdl;

            break;

        case DSI_PARTIAL_WRITE:

            pDsiReq->dsi_PartialWriteSize += BytesThisTime;
            BytesSoFar = pDsiReq->dsi_PartialWriteSize;

            ASSERT(BytesSoFar <= pDsiReq->dsi_WriteLen);
            BytesNeeded = (pDsiReq->dsi_WriteLen - BytesSoFar);

            pOrgMdl = pDsiReq->dsi_AfpRequest.rq_WriteMdl;

            break;

        default:

            ASSERT(0);
            break;
    }

    ASSERT((BytesSoFar+BytesNeeded) == AfpMdlChainSize(pOrgMdl));

    if (pPrevPartialMdl == pOrgMdl)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTcpRcvIrpCompletion: PrevPartial same as Org Mdl = %lx\n",pOrgMdl));

        pPrevPartialMdl = NULL;
    }


    //
    // update the count of how many bytes TCP has that we still need to retrieve.
    // It's possible for TCP to return more bytes in this irp (BytesThisTime) than
    // what we thought TCP had with it, because more stuff could have come on the wire
    //
    if (BytesThisTime > pTcpConn->con_BytesWithTcp)
    {
        pTcpConn->con_BytesWithTcp  = 0;
    }
    else
    {
        pTcpConn->con_BytesWithTcp -= BytesThisTime;
    }

    BytesAvailable = pTcpConn->con_BytesWithTcp;


    //
    // if we still need more bytes to satisfy this request, we need to pass the irp
    // back to TCP.  We must first get a partial Mdl describing the new offset though
    //
    if (BytesNeeded > 0)
    {
        RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

        // free up previously allocated partial mdl, if any
        if (pPrevPartialMdl)
        {
            ASSERT(pPrevPartialMdl != pOrgMdl);

            IoFreeMdl(pPrevPartialMdl);

            AFP_DBG_DEC_COUNT(AfpDbgMdlsAlloced);
            pNewPartialMdl = NULL;
        }

        pNewPartialMdl = DsiMakePartialMdl(pOrgMdl, BytesSoFar);

        if (pNewPartialMdl == NULL)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiTcpRcvIrpCompletion: couldn't get partial mdl\n"));

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto DsiTcpRcvIrp_Completed;
        }

        TdiBuildReceive(pIrp,
                        pDeviceObject,
                        pTcpConn->con_pFileObject,
                        DsiTcpRcvIrpCompletion,
                        (PVOID)pTcpConn,
                        pNewPartialMdl,
                        TDI_RECEIVE_NORMAL,
                        BytesNeeded);

        IoCallDriver(pDeviceObject,pIrp);

        return(STATUS_MORE_PROCESSING_REQUIRED);
    }


    pTcpConn->con_State &= ~TCPCONN_STATE_TCP_HAS_IRP;

    pTcpConn->con_pRcvIrp = NULL;

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    status = STATUS_SUCCESS;


DsiTcpRcvIrp_Completed:

    // free up previously allocated partial mdl, if any
    if (pPrevPartialMdl)
    {
        ASSERT(pPrevPartialMdl != pOrgMdl);
        IoFreeMdl(pPrevPartialMdl);

        AFP_DBG_DEC_COUNT(AfpDbgMdlsAlloced);
    }

    // if DSI had allocated Mdl, free it here
    if (pDsiReq && pDsiReq->dsi_pDsiAllocedMdl)
    {
        AfpFreeMdl(pDsiReq->dsi_pDsiAllocedMdl);
        pDsiReq->dsi_pDsiAllocedMdl = NULL;
    }

    // and, say good bye to that irp
    AfpFreeIrp(pIrp);

    //
    // if the irp completed normally (most common case) then we need to call
    // our processing loop so state is updated, Afp is informed (if needed) etc.
    // also, if there are more bytes with TCP, we need to post an irp to get them
    //
    if (NT_SUCCESS(status))
    {
        status = DsiProcessData(pTcpConn,
                                0,
                                BytesAvailable,
                                NULL,
                                &BytesTaken,
                                &pIrpToPost);

        //
        // does TCP have more data? then we have an irp to post to TCP
        //
        if (status == STATUS_MORE_PROCESSING_REQUIRED)
        {
            ASSERT(pIrpToPost != NULL);

            IoSkipCurrentIrpStackLocation(pIrpToPost);

            IoCallDriver(pDeviceObject,pIrpToPost);

            //
            // remove the TcpIRP refcount since the original irp, pIrp completed
            // The newer irp, pIrpToPost, will have upped refcount and will decrement
            // when it completes
            //
            DsiDereferenceConnection(pTcpConn);

            DBGREFCOUNT(("DsiTcpRcvIrpCompletion: TcpIRP dec %lx (%d  %d,%d)\n",
                pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

            return(STATUS_MORE_PROCESSING_REQUIRED);
        }

        //
        // if DsiProcessData returns this errorcode, it's to tell TCP that it will
        // give an irp later.  It's not an error, so change it to success
        //
        else if (status == STATUS_DATA_NOT_ACCEPTED)
        {
            status = STATUS_SUCCESS;
        }
    }


    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTcpRcvIrpCompletion: aborting %lx because status = %lx!\n",
            pTcpConn, status));

        DsiAbortConnection(pTcpConn);
    }

    // remove the TcpIRP refcount now that the irp completed
    DsiDereferenceConnection(pTcpConn);

    DBGREFCOUNT(("DsiTcpRcvIrpCompletion: TcpIRP dec %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    return(STATUS_MORE_PROCESSING_REQUIRED);
}


/***	DsiExecuteCommand
 *
 *	This routine looks at what DSI command has come from the client, and takes
 *  appropriate.  If adequate data is not yet available to take action, it
 *  marks the state appropritely and returns.
 *
 *  Parm IN:  pTcpConn - the connection object
 *            pDsiReq - the DSI request object
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiExecuteCommand(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq
)
{

    NTSTATUS        status=STATUS_SUCCESS;
    KIRQL           OldIrql;
    BOOLEAN         fWeIniatedClose=FALSE;



    ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

    // we don't need to hold a lock here: it's not essential to be accurate
    if (pDsiReq->dsi_Command != DSI_COMMAND_TICKLE)
    {
        pTcpConn->con_LastHeard = AfpSecondsSinceEpoch;
    }

    //
    // see what command it is, and do the needful
    //

    switch (pDsiReq->dsi_Command)
    {
        case DSI_COMMAND_COMMAND:
        case DSI_COMMAND_WRITE:

            //
            // make sure the guy has opened AFP session before we hand this over..
            //
            ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);
            if (!(pTcpConn->con_State & TCPCONN_STATE_NOTIFY_AFP))
            {
                RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiExecuteCommand: must do OpenSession first! Disconnecting..\n"));
                status = STATUS_UNSUCCESSFUL;
                break;
            }
            RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

            // ok, hand over the request to AFP (AfpUnmarshall.. expects DPC)
		    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

            status = AfpCB_RequestNotify(STATUS_SUCCESS,
                                        pTcpConn->con_pSda,
                                        &pDsiReq->dsi_AfpRequest);

		    KeLowerIrql(OldIrql);

            if (!NT_SUCCESS(status))
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiExecuteCommand: AfpCB_RequestNotify failed %lx\n",status));
            }

            break;

        case DSI_COMMAND_GETSTATUS:

            status = DsiSendStatus(pTcpConn, pDsiReq);

            if (!NT_SUCCESS(status))
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiExecuteCommand: DsiSendStatus failed %lx\n",status));
            }

            break;

        case DSI_COMMAND_CLOSESESSION:

            ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

            fWeIniatedClose = (pDsiReq->dsi_Flags == DSI_REPLY);

            pTcpConn->con_State |= TCPCONN_STATE_CLOSING;
            pTcpConn->con_State |= TCPCONN_STATE_RCVD_REMOTE_CLOSE;

            if (fWeIniatedClose)
            {
                RemoveEntryList(&pDsiReq->dsi_Linkage);
                InitializeListHead(&pDsiReq->dsi_Linkage);
            }
            RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

            //
            // if we initiated the CloseSession, then what we just got is the
            // client's reponse. Done here: go ahead and terminate the connection.
            //
            if (fWeIniatedClose)
            {
                DsiFreeRequest(pDsiReq);

                // remove the REQUEST refcount
                DsiDereferenceConnection(pTcpConn);

                DBGREFCOUNT(("DsiExecuteCommand: REQUEST dec %lx (%d  %d,%d)\n",
                    pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
                DsiTerminateConnection(pTcpConn);
            }

            //
            // remote client initiated the CloseSession.  Tell AFP that the
            // session is going away, and then send CloseSession response
            //
            else
            {
                DsiDisconnectWithAfp(pTcpConn, STATUS_REMOTE_DISCONNECT);

                status = DsiSendDsiReply(pTcpConn, pDsiReq, STATUS_SUCCESS);

                if (!NT_SUCCESS(status))
                {
                    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                        ("DsiExecuteCommand: send on CloseSess failed %lx\n",status));
                }
            }

            break;

        case DSI_COMMAND_OPENSESSION:

            // see if AFP will accept this session request
            status = DsiOpenSession(pTcpConn, pDsiReq);

            if (!NT_SUCCESS(status))
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiExecuteCommand: DsiOpenSession failed %lx\n",status));
            }

            DsiSendDsiReply(pTcpConn, pDsiReq, status);

            status = STATUS_SUCCESS;

            break;

        //
        // we got a tickle, or a response to our Attention.
        // Just free up this request.
        // If we get an unrecognized command, we just tear the connection down!
        //
        case DSI_COMMAND_TICKLE:
        case DSI_COMMAND_ATTENTION:

            ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);
            RemoveEntryList(&pDsiReq->dsi_Linkage);
            InitializeListHead(&pDsiReq->dsi_Linkage);
            RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

            DsiFreeRequest(pDsiReq);

            // remove the REQUEST refcount
            DsiDereferenceConnection(pTcpConn);

            DBGREFCOUNT(("DsiExecuteCommand: REQUEST dec %lx (%d  %d,%d)\n",
                pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

            break;

        default:

            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiExecuteCommand: unknown command %d\n",pDsiReq->dsi_Command));
            status = STATUS_UNSUCCESSFUL;

            break;
    }

    return(status);

}



/***	DsiOpenSession
 *
 *	This routine responds to an OpenSession request from the client, after
 *  notifying AFP and making sure that AFP wants to accept this connection
 *
 *  Parm IN:  pTcpConn - the connection object
 *            pDsiReq - the DSI request object
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiOpenSession(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq
)
{

    KIRQL       OldIrql;
    PSDA        pSda;
    PBYTE       pOptions;


    ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

    pSda = AfpCB_SessionNotify(pTcpConn, TRUE);

    if (pSda == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiOpenSession: AfpCB_SessionNotify failed!\n"));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    pTcpConn->con_pSda = pSda;

    pTcpConn->con_State |= TCPCONN_STATE_AFP_ATTACHED;

    // from here on, if we disconnect, we must tell AFP
    pTcpConn->con_State |= TCPCONN_STATE_NOTIFY_AFP;

    // put AFP refcount, to be removed when AFP closes the session
    pTcpConn->con_RefCount++;

    DBGREFCOUNT(("DsiOpenSession: AFP inc %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    //
    // parse any options that might have arrived with the OpenSession command
    // Currently, the only option that we can get from the client is the largest
    // attention packet it can receive from us.
    //

    if (pDsiReq->dsi_RequestLen > 0)
    {
        // currently, this can only be 6 bytes
        ASSERT(pDsiReq->dsi_RequestLen == 6);

        pOptions = pDsiReq->dsi_AfpRequest.rq_RequestBuf;

        ASSERT(pOptions[0] == 0x01);
        ASSERT(pOptions[1] == 4);

        GETDWORD2DWORD(&pTcpConn->con_MaxAttnPktSize, &pOptions[2]);
    }

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    return(STATUS_SUCCESS);

}




/***	DsiSendDsiRequest
 *
 *	This routine sends a request to the client.  The only requests that originate
 *  from the server are CloseSession, Tickle and Attention
 *
 *  Parm IN:  pTcpConn - the connection object
 *            SendLen - how many bytes we are sending
 *            AttentionWord - if this is Attention request, the 2 bytes
 *            AttentionContext - context, if this is Attention request
 *            Command - which one is it: Close, Tickle or Attention
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiSendDsiRequest(
    IN  PTCPCONN    pTcpConn,
    IN  DWORD       DataLen,
    IN  USHORT      AttentionWord,
    IN  PVOID       AttentionContext,
    IN  BYTE        Command
)
{
    NTSTATUS        status;
    KIRQL           OldIrql;
    PDSIREQ         pDsiReq=NULL;
    DWORD           SendLen;
    PBYTE           pPacket;
    PMDL            pMdl;


    pDsiReq = DsiGetRequest();
    if (pDsiReq == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAfpSendAttention: DsiGetRequest failed\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pPacket = &pDsiReq->dsi_RespHeader[0];

    SendLen = DataLen + DSI_HEADER_SIZE;

    pMdl = AfpAllocMdl(pPacket, SendLen, NULL);
    if (pMdl == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAfpSendAttention: alloc mdl failed\n"));
        DsiFreeRequest(pDsiReq);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    pDsiReq->dsi_RequestID = pTcpConn->con_OutgoingReqId++;
    InsertTailList(&pTcpConn->con_PendingReqs, &pDsiReq->dsi_Linkage);

    // put a REQUEST refcount
    pTcpConn->con_RefCount++;

    DBGREFCOUNT(("DsiSendDsiRequest: REQUEST inc %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    pDsiReq->dsi_Signature = DSI_REQUEST_SIGNATURE;
    pDsiReq->dsi_pTcpConn = pTcpConn;
    pDsiReq->dsi_Command = Command;
    pDsiReq->dsi_Flags = DSI_REQUEST;
    pDsiReq->dsi_pDsiAllocedMdl = pMdl;

    //
    // form the DSI header
    //

    pPacket[DSI_OFFSET_FLAGS] = DSI_REQUEST;
    pPacket[DSI_OFFSET_COMMAND] = Command;

    PUTSHORT2SHORT(&pPacket[DSI_OFFSET_REQUESTID], pDsiReq->dsi_RequestID);

    *(DWORD *)&pPacket[DSI_OFFSET_DATAOFFSET] = 0;

    PUTDWORD2DWORD(&pPacket[DSI_OFFSET_DATALEN], DataLen);

    PUTDWORD2DWORD(&pPacket[DSI_OFFSET_RESERVED], 0);

    if (Command == DSI_COMMAND_ATTENTION)
    {
        PUTSHORT2SHORT(&pPacket[DSI_HEADER_SIZE], AttentionWord);
        pDsiReq->dsi_AttnContext = AttentionContext;
    }

    status = DsiTdiSend(pTcpConn,
                        pMdl,
                        SendLen,
                        DsiSendCompletion,
                        pDsiReq);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiSendDsiRequest: DsiTdiSend failed %lx\n",status));

        AfpFreeMdl(pMdl);
        pDsiReq->dsi_pDsiAllocedMdl = NULL;
        DsiSendCompletion(NULL, NULL, pDsiReq);
        status = STATUS_PENDING;
    }

    return(status);
}



/***	DsiSendDsiReply
 *
 *	This routine sends a reply to the client, in response to the client's
 *  DSI-level request (OpenSession, CloseSession, or Tickle)
 *
 *  Parm IN:  pTcpConn - the connection object
 *            pDsiReq - the DIS request (from client's)
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiSendDsiReply(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq,
    IN  NTSTATUS    OpStatus
)
{
    PBYTE       pPacket;
    PBYTE       pOption;
    PMDL        pMdl;
    DWORD       OptionLen;
    DWORD       TotalLen;
    NTSTATUS    status=STATUS_SUCCESS;


    ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

    if (pDsiReq->dsi_Command == DSI_COMMAND_OPENSESSION)
    {
        OptionLen = DSI_OPENSESS_OPTION_LEN + DSI_OPTION_FIXED_LEN;
        TotalLen = DSI_HEADER_SIZE + OptionLen;
    }
    else
    {
        ASSERT((pDsiReq->dsi_Command == DSI_COMMAND_CLOSESESSION) ||
               (pDsiReq->dsi_Command == DSI_COMMAND_TICKLE));

        TotalLen = DSI_HEADER_SIZE;
        OptionLen = 0;
    }

    pPacket = &pDsiReq->dsi_RespHeader[0];

    RtlZeroMemory(pPacket, TotalLen);

    pPacket[DSI_OFFSET_FLAGS] = DSI_REPLY;
    pPacket[DSI_OFFSET_COMMAND] = pDsiReq->dsi_Command;

    PUTSHORT2SHORT(&pPacket[DSI_OFFSET_REQUESTID], pDsiReq->dsi_RequestID);

    PUTDWORD2DWORD(&pPacket[DSI_OFFSET_DATALEN], OptionLen);

    //
    // if this is an OpenSession packet, setup the optional fields
    //
    if (pDsiReq->dsi_Command == DSI_COMMAND_OPENSESSION)
    {
        pOption = &pPacket[DSI_HEADER_SIZE];

        pOption[DSI_OFFSET_OPTION_TYPE] = DSI_OPTION_SRVREQ_QUANTUM;
        pOption[DSI_OFFSET_OPTION_LENGTH] = DSI_OPENSESS_OPTION_LEN;

        PUTDWORD2DWORD(&pOption[DSI_OFFSET_OPTION_OPTION],
                       DSI_SERVER_REQUEST_QUANTUM);

        // if open session didn't go well, tell client the whole store
        if (OpStatus == STATUS_INSUFFICIENT_RESOURCES)
        {
            PUTDWORD2DWORD(&pPacket[DSI_OFFSET_ERROROFFSET], ASP_SERVER_BUSY);
        }
    }

    //
    // allocate an mdl
    //
    pMdl = AfpAllocMdl(pPacket, TotalLen, NULL);
    if (pMdl == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiSendDsiReply: malloc failed!\n"));

        status = STATUS_INSUFFICIENT_RESOURCES;
    }


    if (NT_SUCCESS(status))
    {
        status = DsiTdiSend(pTcpConn,
                            pMdl,
                            TotalLen,
                            DsiSendCompletion,
                            pDsiReq);

        if (!NT_SUCCESS(status))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiSendDsiReply: DsiTdiSend failed %lx\n",status));
        }
    }

    if (!NT_SUCCESS(status))
    {
        if (pMdl)
        {
            AfpFreeMdl(pMdl);
        }
        DsiSendCompletion(NULL, NULL, pDsiReq);
    }

    return(status);
}


/***	DsiSendStatus
 *
 *	This routine responds to the GetStatus requst from the client.
 *  Basically, we simply copy the status buffer here and send it.
 *
 *  Parm IN:  pTcpConn - the connection object
 *            pDsiReq - the DIS request (from client's)
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiSendStatus(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq
)
{
    NTSTATUS        status=STATUS_SUCCESS;
    PBYTE           pPacket;
    PMDL            pMdl=NULL;
    KIRQL           OldIrql;
    DWORD           TotalLen;


    ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);

    if (DsiStatusBuffer != NULL)
    {
        TotalLen = DsiStatusBufferSize + DSI_HEADER_SIZE;

        pPacket = AfpAllocNonPagedMemory(TotalLen);
        if (pPacket != NULL)
        {
            //
            // form the DSI header
            //
            pPacket[DSI_OFFSET_FLAGS] = DSI_REPLY;
            pPacket[DSI_OFFSET_COMMAND] = pDsiReq->dsi_Command;
            PUTSHORT2SHORT(&pPacket[DSI_OFFSET_REQUESTID], pDsiReq->dsi_RequestID);
            *(DWORD *)&pPacket[DSI_OFFSET_DATAOFFSET] = 0;
            PUTDWORD2DWORD(&pPacket[DSI_OFFSET_DATALEN], DsiStatusBufferSize);
            PUTDWORD2DWORD(&pPacket[DSI_OFFSET_RESERVED], 0);

            //
            // copy the status buffer
            //
            RtlCopyMemory(pPacket + DSI_HEADER_SIZE,
                          DsiStatusBuffer,
                          DsiStatusBufferSize);

            pMdl = AfpAllocMdl(pPacket, TotalLen, NULL);
            if (pMdl == NULL)
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiSendStatus: mdl alloc failed\n"));
                AfpFreeMemory(pPacket);
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiSendStatus: malloc for GetStatus failed\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiSendStatus: DsiStatusBuffer is null, server didn't SetStatus?\n"));
        status = STATUS_UNSUCCESSFUL;
    }

    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    if (NT_SUCCESS(status))
    {
        status = DsiTdiSend(pTcpConn,
                            pMdl,
                            TotalLen,
                            DsiSendCompletion,
                            pDsiReq);
    }

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiSendStatus: DsiTdiSend failed %lx\n",status));

        if (pMdl)
        {
            AfpFreeMdl(pMdl);
        }
        DsiSendCompletion(NULL, NULL, pDsiReq);
        status = STATUS_PENDING;
    }

    return(status);
}



/***	DsiSendTickles
 *
 *	This routine sends out a tickle from our end to every client that we haven't
 *  heard from in the last 30 seconds
 *
 *  Parm IN:  nothing
 *
 *  Returns:  status of operation
 *
 */
AFPSTATUS FASTCALL
DsiSendTickles(
    IN  PVOID pUnUsed
)
{
    KIRQL               OldIrql;
    PLIST_ENTRY         pList;
    PTCPCONN            pTcpConn;
    AFPSTATUS           status;


    ASSERT(AfpServerBoundToTcp);

    ASSERT(DsiTcpAdapter != NULL);

    ACQUIRE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, &OldIrql);

    // if adapter is shutting down, go back (and don't requeue)
    if (DsiTcpAdapter->adp_State & TCPADPTR_STATE_CLOSING)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiSendTickles: adapter closing, so just returned\n"));

        RELEASE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, OldIrql);
        return(AFP_ERR_NONE);
    }

    // put TickleTimer refcount: don't want it to go away till we're done here
    DsiTcpAdapter->adp_RefCount++;

    pList = DsiTcpAdapter->adp_ActiveConnHead.Flink;

    while (pList != &DsiTcpAdapter->adp_ActiveConnHead) 
    {
        pTcpConn = CONTAINING_RECORD(pList, TCPCONN, con_Linkage);

        pList = pList->Flink;

        ACQUIRE_SPIN_LOCK_AT_DPC(&pTcpConn->con_SpinLock);

        // connection closing or tickles stopped on this connection?  skip it
        if (pTcpConn->con_State & (TCPCONN_STATE_CLOSING |
                                   TCPCONN_STATE_TICKLES_STOPPED))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
                ("DsiSendTickles: %lx closing or tickles stopped: skipping\n",pTcpConn));

            RELEASE_SPIN_LOCK_FROM_DPC(&pTcpConn->con_SpinLock);
            continue;
        }

        if (!(pTcpConn->con_State & TCPCONN_STATE_AFP_ATTACHED))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiSendTickles: %lx *** RACE CONDITION *** conn not setup yet\n",pTcpConn));

            RELEASE_SPIN_LOCK_FROM_DPC(&pTcpConn->con_SpinLock);
            continue;
        }


        // have we heard from the client recently for this puppy?  if so, skip it
        if ((AfpSecondsSinceEpoch - pTcpConn->con_LastHeard) < DSI_TICKLE_TIME_LIMIT)
        {
            RELEASE_SPIN_LOCK_FROM_DPC(&pTcpConn->con_SpinLock);
            continue;
        }

        // reset this, so we don't keep sending
        pTcpConn->con_LastHeard = AfpSecondsSinceEpoch;

        // Put TICKLE refcount: make sure connection stays around till we're done!
        pTcpConn->con_RefCount++;

        DBGREFCOUNT(("DsiSendTickles: TICKLE inc %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

        RELEASE_SPIN_LOCK_FROM_DPC(&pTcpConn->con_SpinLock);

        RELEASE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, OldIrql);

        DsiSendDsiRequest(pTcpConn, 0, 0, NULL, DSI_COMMAND_TICKLE);

        ACQUIRE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, &OldIrql);

        // since we released the lock, things could have changed: start over
        pList = DsiTcpAdapter->adp_ActiveConnHead.Flink;
    }

    status = AFP_ERR_REQUEUE;

    if (DsiTcpAdapter->adp_State & TCPADPTR_STATE_CLOSING)
    {
        status = AFP_ERR_NONE;
    }

    RELEASE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, OldIrql);

    // remove the TickleTimer refcount
    DsiDereferenceAdapter(DsiTcpAdapter);

    return(status);
}


/***	DsiValidateHeader
 *
 *	This routine makes sure that the packet we just received looks good.
 *  i.e. whether the request id matches what we expect to receive, whether
 *  the command is valid, whether the Write length (if applicable) is what we
 *  negotiated (or less) etc.
 *
 *  Parm IN:  pTcpConn - the connection object
 *            pDsiReq - the DIS request (from client's)
 *
 *  Returns:  TRUE if the packet header is acceptable, FALSE otherwise
 *
 *  NOTE: pTcpConn spinlock is held on entry
 */
BOOLEAN
DsiValidateHeader(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq
)
{

    BOOLEAN     fCheckIncomingReqId = TRUE;

    //
    // if this is the first packet we are receiving on this connection, note
    // down what the client's starting request id is
    //
    if ((pDsiReq->dsi_Command == DSI_COMMAND_GETSTATUS) ||
        (pDsiReq->dsi_Command == DSI_COMMAND_OPENSESSION))
    {
        if (pTcpConn->con_State & TCPCONN_STATE_AFP_ATTACHED)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiValidateHeader: session already going!\n"));
            return(FALSE);
        }

        pTcpConn->con_NextReqIdToRcv =
            (pDsiReq->dsi_RequestID == 0xFFFF)? 0 : (pDsiReq->dsi_RequestID+1);

        fCheckIncomingReqId = FALSE;
    }
    else
    {
        if (!(pTcpConn->con_State & TCPCONN_STATE_AFP_ATTACHED))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiValidateHeader: command %d rcvd, but session not setup!\n",
                pDsiReq->dsi_Command));
        }
    }

    if (pDsiReq->dsi_Flags != DSI_REQUEST)
    {
        if (pDsiReq->dsi_Flags != DSI_REPLY)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiValidateHeader: Flags=%d, neither Request, nor reply\n",
                pDsiReq->dsi_Flags));
            return(FALSE);
        }

        //
        // we expect REPLY from client only for two commands: anything else is bad
        //
        if ((pDsiReq->dsi_Command != DSI_COMMAND_CLOSESESSION) &&
            (pDsiReq->dsi_Command != DSI_COMMAND_ATTENTION))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiValidateHeader: Flags=Reply, but cmd=%d\n",pDsiReq->dsi_Command));
            return(FALSE);
        }
        fCheckIncomingReqId = FALSE;
    }


    //
    // for all requests (except the first one), the RequestId must match what
    // we expect.  Otherwise, we just kill the connection!
    //
    if (fCheckIncomingReqId)
    {
        if (pDsiReq->dsi_RequestID != pTcpConn->con_NextReqIdToRcv)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiValidateHeader: ReqId mismatch (%ld vs. %ld)\n",
                pDsiReq->dsi_RequestID,pTcpConn->con_NextReqIdToRcv));
            return(FALSE);
        }

        if (pTcpConn->con_NextReqIdToRcv == 0xFFFF)
        {
            pTcpConn->con_NextReqIdToRcv = 0;
        }
        else
        {
            pTcpConn->con_NextReqIdToRcv++;
        }
    }

    if (pDsiReq->dsi_RequestLen > DSI_SERVER_REQUEST_QUANTUM)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiValidateHeader: RequestLen too big %ld\n",pDsiReq->dsi_RequestLen));
        return(FALSE);
    }

    if (pDsiReq->dsi_Command == DSI_COMMAND_WRITE)
    {
        if (pDsiReq->dsi_WriteLen > DSI_SERVER_REQUEST_QUANTUM)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiValidateHeader: WriteLen too big %ld\n",pDsiReq->dsi_WriteLen));
            return(FALSE);
        }
    }

    return(TRUE);
}



/***	DsiAfpReplyCompletion
 *
 *	When AFP sends a reply to the client, DSI sends it out.  When TCP completes
 *  that send, this routine gets called.  We complete AFP's send at this point,
 *  and do other cleanup like releasing resources (if necessary)
 *
 *  Parm IN:  DeviceObject - not used
 *            pIrp - the irp that we sent out
 *            pContext - the DIS request (pDsiReq)
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiAfpReplyCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
)
{
    PDSIREQ     pDsiReq;
    KIRQL       OldIrql;
    PMDL        pMdl=NULL;
    PTCPCONN    pTcpConn;
    PBYTE       pPacket=NULL;
    NTSTATUS    status=STATUS_SUCCESS;


    pDsiReq = (PDSIREQ)pContext;

    ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

    pTcpConn = pDsiReq->dsi_pTcpConn;

    ASSERT(VALID_TCPCONN(pTcpConn));

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    RemoveEntryList(&pDsiReq->dsi_Linkage);

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    if (pIrp)
    {
        status = pIrp->IoStatus.Status;

        pMdl = pIrp->MdlAddress;

#if DBG
        if (pMdl)
        {
            // put in a signature to say completion routine has runn on this puppy
            pPacket = MmGetSystemAddressForMdlSafe(
					pMdl,
					NormalPagePriority);
			if (pPacket != NULL)
			{
				*(DWORD *)pPacket = 0x11223344;
			}
			else
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
			}
        }
#endif
        // if this mdl was allocated by DSI, free it here
        if (pDsiReq->dsi_pDsiAllocedMdl != NULL)
        {
            ASSERT(pDsiReq->dsi_pDsiAllocedMdl == pMdl);
            ASSERT(pDsiReq->dsi_pDsiAllocedMdl->Next == pDsiReq->dsi_AfpRequest.rq_ReplyMdl);

            pDsiReq->dsi_pDsiAllocedMdl->Next = NULL;

            AfpFreeMdl(pDsiReq->dsi_pDsiAllocedMdl);

            pDsiReq->dsi_pDsiAllocedMdl = NULL;
        }

        pIrp->MdlAddress = NULL;

        AfpFreeIrp(pIrp);
    }
    else
    {
        status = STATUS_UNSUCCESSFUL;
    }

    AfpCB_ReplyCompletion(status, pTcpConn->con_pSda, &pDsiReq->dsi_AfpRequest);

    DsiFreeRequest(pDsiReq);

    // remove the REQUEST refcount
    DsiDereferenceConnection(pTcpConn);

    DBGREFCOUNT(("DsiAfpReplyCompletion: REQUEST dec %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    return(STATUS_MORE_PROCESSING_REQUIRED);

}

/***	DsiSendCompletion
 *
 *	When DSI sends a request (tickle, close session, attention) or reply
 *  (CloseSession, OpenSession) and when TCP completes that send, this routine
 *  gets called.
 *
 *  Parm IN:  DeviceObject - not used
 *            pIrp - the irp that we sent out
 *            pContext - the DIS request (pDsiReq)
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiSendCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
)
{
    PDSIREQ     pDsiReq;
    KIRQL       OldIrql;
    PBYTE       pPacket=NULL;
    PBYTE       pOption;
    PMDL        pMdl=NULL;
    PTCPCONN    pTcpConn;
    NTSTATUS    status=STATUS_SUCCESS;
    BOOLEAN     fMacHasAlreadySentClose=FALSE;
    BOOLEAN     fAfpIsAttached=TRUE;


    pDsiReq = (PDSIREQ)pContext;

    pTcpConn = pDsiReq->dsi_pTcpConn;

    ASSERT(VALID_TCPCONN(pTcpConn));

    if (pIrp)
    {
        status = pIrp->IoStatus.Status;

        pMdl = pIrp->MdlAddress;

        ASSERT(pMdl != NULL);
        pPacket = MmGetSystemAddressForMdlSafe(
				pMdl,
				NormalPagePriority);
		if (pPacket != NULL) {
			if (pPacket != &pDsiReq->dsi_RespHeader[0])
			{
				AfpFreeMemory(pPacket);
			}
		}

        AfpFreeMdl(pMdl);
        pDsiReq->dsi_pDsiAllocedMdl = NULL;

        AfpFreeIrp(pIrp);
    }
    else
    {
        status = STATUS_UNSUCCESSFUL;
    }

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    if (pTcpConn->con_State & TCPCONN_STATE_RCVD_REMOTE_CLOSE)
    {
        fMacHasAlreadySentClose = TRUE;
    }

    if (!(pTcpConn->con_State & TCPCONN_STATE_AFP_ATTACHED))
    {
        fAfpIsAttached = FALSE;
    }

    RemoveEntryList(&pDsiReq->dsi_Linkage);

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    //
    // was this an Attention? call afp's completion to say Attention was sent
    //
    if (pDsiReq->dsi_Command == DSI_COMMAND_ATTENTION)
    {
        AfpCB_AttnCompletion(pDsiReq->dsi_AttnContext);
    }

    // if this was a OpenSession reply and if it didn't go well, terminate the conn
    else if ((pDsiReq->dsi_Command == DSI_COMMAND_OPENSESSION) && (!fAfpIsAttached))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiSendCompletion: terminating conn since OpenSess didn't succeed %lx\n",pTcpConn));

        DsiTerminateConnection(pTcpConn);
    }

    //
    // if this was a CloseSession request and we have already received Mac's
    // close, or if this was a GetStatus request, terminate the connection
    //
    else if (((pDsiReq->dsi_Command == DSI_COMMAND_CLOSESESSION) &&
              (fMacHasAlreadySentClose)) ||
             (pDsiReq->dsi_Command == DSI_COMMAND_GETSTATUS))
    {
        DsiTerminateConnection(pTcpConn);
    }

    //
    // if this was a Tickle, remove that TICKLE refcount we had put before send
    //
    else if (pDsiReq->dsi_Command == DSI_COMMAND_TICKLE)
    {
        DsiDereferenceConnection(pTcpConn);
        DBGREFCOUNT(("DsiSendCompletion: TICKLE dec %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
    }

    //
    // send failed?  might as well abort!
    //
    if (!NT_SUCCESS(status))
    {
        if (!(pTcpConn->con_State & TCPCONN_STATE_CLEANED_UP))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiSendCompletion: send failed %lx, so killing conection %lx\n",
                status,pTcpConn));
        }

        DsiAbortConnection(pTcpConn);
    }


    // remove the REQUEST refcount
    DsiDereferenceConnection(pTcpConn);

    DBGREFCOUNT(("DsiSendCompletion: REQUEST dec %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    DsiFreeRequest(pDsiReq);

    return(STATUS_MORE_PROCESSING_REQUIRED);
}



/***	DsiAcceptConnectionCompletion
 *
 *	When TCP completes the accept, this routine is called
 *
 *  Parm IN:  DeviceObject - unused
 *            pIrp - our irp that completed
 *            Context - our context (pTcpConn)
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiAcceptConnectionCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            Context
)
{
    NTSTATUS        status;
    PTCPCONN        pTcpConn;
    KIRQL           OldIrql;
    BOOLEAN         fMustDeref=FALSE;


    pTcpConn = (PTCPCONN)Context;

    ASSERT(VALID_TCPCONN(pTcpConn));

    status = pIrp->IoStatus.Status;

    // if the incoming connection failed to be setup right, go cleanup!
    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAcceptConnectionCompletion: connection failed %lx\n",status));

        DsiAbortConnection(pTcpConn);
    }

    // this is our irp: free it
    AfpFreeIrp(pIrp);

    // remove the ACCEPT refcount
    DsiDereferenceConnection(pTcpConn);

    DBGREFCOUNT(("DsiAcceptConnectionCompletion: ACCEPT dec %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    return(STATUS_MORE_PROCESSING_REQUIRED);
}


/***	DsiDisconnectWithTcp
 *
 *	This routine passes an irp down to tcp, asking it to disconnect the connection
 *
 *  Parm IN:  pTcpConn - the connection object in question
 *            DiscFlag - how should the disconnect be, graceful or abortive
 *
 *  Returns:  result of operation
 *
 */
NTSTATUS
DsiDisconnectWithTcp(
    IN  PTCPCONN    pTcpConn,
    IN DWORD        DiscFlag
)
{
    PDEVICE_OBJECT      pDeviceObject;
    KIRQL               OldIrql;
    PIRP                pIrp;
    NTSTATUS            status;
    BOOLEAN             fTcpAlreadyKnows=FALSE;


    //
    // find out if TCP still thinks the connection is up (basically watch out
    // for a timing window where we send an irp down and tcp calls our disconnect
    // handler: we want to deref only once in this case!)
    //
    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    if (pTcpConn->con_State & TCPCONN_STATE_NOTIFY_TCP)
    {
        fTcpAlreadyKnows = FALSE;
        pTcpConn->con_State &= ~TCPCONN_STATE_NOTIFY_TCP;

        // put a DISCONNECT refcount, since we'll be sending an irp down
        pTcpConn->con_RefCount++;

        // mark that we initiated an abortive disconnect (we use this flag to avoid
        // a race condition where we are doing a graceful close but the remote guy
        // resets our connection)
        if (DiscFlag == TDI_DISCONNECT_ABORT)
        {
            pTcpConn->con_State |= TCPCONN_STATE_ABORTIVE_DISCONNECT;
        }

        DBGREFCOUNT(("DsiDisconnectWithTcp: DISCONNECT inc %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
    }
    else
    {
        fTcpAlreadyKnows = TRUE;
    }

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    if (fTcpAlreadyKnows)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
            ("DsiDisconnectWithTcp: TCP already disconnected, no irp posted\n"));

        return(STATUS_SUCCESS);
    }


    pDeviceObject = IoGetRelatedDeviceObject(pTcpConn->con_pFileObject);

    if ((pIrp = AfpAllocIrp(pDeviceObject->StackSize)) == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiDisconnectWithTcp: AllocIrp failed\n"));

        // remove that DISCONNECT refcount
        DsiDereferenceConnection(pTcpConn);

        DBGREFCOUNT(("DsiDisconnectWithTcp: DISCONNECT dec %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pIrp->CancelRoutine = NULL;

    TdiBuildDisconnect(
        pIrp,
        pDeviceObject,
        pTcpConn->con_pFileObject,
        DsiTcpDisconnectCompletion,
        pTcpConn,
        0,
        DiscFlag,
        NULL,
        NULL);

    pIrp->MdlAddress = NULL;

    status = IoCallDriver(pDeviceObject,pIrp);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiDisconnectWithTcp: IoCallDriver failed %lx\n",status));
    }

    // if we are doing an abortive disconnect, tcp will not inform us anymore!
    if (DiscFlag == TDI_DISCONNECT_ABORT)
    {
        // remove the TCP CLIENT-FIN refcount
        DsiDereferenceConnection(pTcpConn);
        DBGREFCOUNT(("DsiDisconnectWithTcp: CLIENT-FIN dec %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
    }

    return(STATUS_PENDING);
}



/***	DsiDisconnectWithAfp
 *
 *	This routine tells AFP that the connection is going away
 *
 *  Parm IN:  pTcpConn - the connection object in question
 *            Reason - why is the connection going away
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiDisconnectWithAfp(
    IN  PTCPCONN    pTcpConn,
    IN  NTSTATUS    Reason
)
{

    KIRQL       OldIrql;
    REQUEST     Request;
    BOOLEAN     fAfpAlreadyKnows=FALSE;


    RtlZeroMemory(&Request, sizeof(REQUEST));

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    if (pTcpConn->con_State & TCPCONN_STATE_NOTIFY_AFP)
    {
        fAfpAlreadyKnows = FALSE;
        pTcpConn->con_State &= ~TCPCONN_STATE_NOTIFY_AFP;
    }
    else
    {
        fAfpAlreadyKnows = TRUE;
    }

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    if (fAfpAlreadyKnows)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
            ("DsiDisconnectWithAfp: AFP need not be told (again)\n"));

        return(STATUS_SUCCESS);
    }

    //
    // notify AFP that the connection is going away
    //
    Request.rq_RequestSize = (LONG)pTcpConn->con_DestIpAddr;

    AfpCB_RequestNotify(Reason, pTcpConn->con_pSda, &Request);

    return(STATUS_SUCCESS);

}

/***	DsiTcpDisconnectCompletion
 *
 *	This routine is the completion routine when tcp completes our disconnect request
 *
 *  Parm IN:  DeviceObject - unused
 *            pIrp - our irp, to be freed
 *            Context - pTcpConn, our connection object
 *
 *  Returns:  result of operation
 *
 */
NTSTATUS
DsiTcpDisconnectCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            Context
)
{

    PTCPCONN    pTcpConn;
    KIRQL       OldIrql;
    NTSTATUS    status=STATUS_SUCCESS;


    pTcpConn = (PTCPCONN)Context;

    ASSERT(VALID_TCPCONN(pTcpConn));

    //
    // tell AFP that the close completed
    //
    if (pTcpConn->con_pSda)
    {
        AfpCB_CloseCompletion(STATUS_SUCCESS, pTcpConn->con_pSda);
    }

    ACQUIRE_SPIN_LOCK(&DsiResourceLock, &OldIrql);
    ASSERT(DsiNumTcpConnections > 0);
    DsiNumTcpConnections--;
    RELEASE_SPIN_LOCK(&DsiResourceLock, OldIrql);

    // TCP is telling us it sent our FIN: remove the TCP SRVR-FIN refcount
    DsiDereferenceConnection(pTcpConn);

    DBGREFCOUNT(("DsiTcpDisconnectCompletion: SRVR-FIN dec %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    if (pIrp != NULL)
    {
        status = pIrp->IoStatus.Status;

        if (!NT_SUCCESS(status))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiTcpDisconnectCompletion: status = %lx\n",status));
        }

        // remove the DISCONNECT refcount for completion of the irp
        DsiDereferenceConnection(pTcpConn);

        DBGREFCOUNT(("DsiTcpDisconnectCompletion: DISCONNECT dec %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

        // it's ours: free it
        AfpFreeIrp(pIrp);
    }

    return(STATUS_MORE_PROCESSING_REQUIRED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\errorlog.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	errorlog.c

Abstract:

	This module implements the error logging in the server.

	!!! This module must be nonpageable.

Author:

	Jameel Hyder (microsoft!jameelh)

Revision History:
	10 Jun 1992		Initial Version

--*/

#define	FILENUM	FILE_ERRORLOG
#include <afp.h>

VOID
AfpWriteErrorLogEntry(
	IN ULONG			EventCode,				// message number
	IN LONG				UniqueErrorCode OPTIONAL,
	IN NTSTATUS			NtStatusCode,
	IN PVOID			RawDataBuf OPTIONAL,
	IN LONG				RawDataLen,
	IN PUNICODE_STRING	pInsertionString OPTIONAL
)
{

	PIO_ERROR_LOG_PACKET	ErrorLogEntry;
	LONG					InsertionStringLength = 0;

#ifdef	STOP_ON_ERRORS
	DBGBRK(DBG_LEVEL_ERR);
#endif

	if (ARGUMENT_PRESENT(pInsertionString))
	{
		InsertionStringLength = pInsertionString->Length;
	}

	ErrorLogEntry =
		(PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(AfpDeviceObject,
		(UCHAR)(sizeof(IO_ERROR_LOG_PACKET) + RawDataLen + InsertionStringLength));

	if (ErrorLogEntry != NULL)
	{
		// Fill in the Error log entry

		ErrorLogEntry->ErrorCode = EventCode;
		ErrorLogEntry->MajorFunctionCode = 0;
		ErrorLogEntry->RetryCount = 0;
		ErrorLogEntry->UniqueErrorValue = (ULONG)UniqueErrorCode;
		ErrorLogEntry->FinalStatus = NtStatusCode;
		ErrorLogEntry->IoControlCode = 0;
		ErrorLogEntry->DeviceOffset.LowPart = 0;
		ErrorLogEntry->DeviceOffset.HighPart = 0;
		ErrorLogEntry->DumpDataSize = (USHORT)RawDataLen;
		ErrorLogEntry->StringOffset =
			(USHORT)(FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData) + RawDataLen);
		ErrorLogEntry->NumberOfStrings = (ARGUMENT_PRESENT(pInsertionString)) ? 1 : 0;
		ErrorLogEntry->SequenceNumber = 0;

		if (ARGUMENT_PRESENT(RawDataBuf))
		{
			RtlCopyMemory(ErrorLogEntry->DumpData, RawDataBuf, RawDataLen);
		}

		if (ARGUMENT_PRESENT(pInsertionString))
		{
			RtlCopyMemory((PCHAR)ErrorLogEntry->DumpData + RawDataLen,
						  pInsertionString->Buffer,
					      pInsertionString->Length);
		}

		// Write the entry
		IoWriteErrorLogEntry(ErrorLogEntry);
	}

	INTERLOCKED_INCREMENT_LONG( &AfpServerStatistics.stat_Errors );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\filenums.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	filenums.h

Abstract:

	This file defines some constant identifiiers for each file for use by
	the errorlogging system.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	10 Jan 1993             Initial Version

Notes:  Tab stop: 4
--*/


#ifndef _FILENUMS_
#define _FILENUMS_

#define	FILE_ACCESS		0x010000
#define FILE_ADMIN		0x020000
#define FILE_AFPAPI		0x030000
#define FILE_AFPINFO	0x040000
#define FILE_ATALKIO	0x050000
#define FILE_CLIENT		0x060000
#define FILE_DESKTOP	0x070000
#define FILE_ERRORLOG	0x080000
#define FILE_FDPARM		0x090000
#define FILE_FILEIO		0x0A0000
#define FILE_FORKIO		0x0B0000
#define FILE_FORKS		0x0C0000
#define FILE_FSD		0x0D0000
#define FILE_FSD_DTP	0x0E0000
#define FILE_FSD_FORK	0x0F0000
#define FILE_FSD_SRV	0x100000
#define FILE_FSD_VOL	0x110000
#define FILE_FSP_DIR	0x120000
#define FILE_FSP_DTP	0x130000
#define FILE_FSP_FD		0x140000
#define FILE_FSP_FILE	0x150000
#define FILE_FSP_FORK	0x160000
#define FILE_FSP_SRV	0x170000
#define FILE_FSP_VOL	0x180000
#define FILE_IDINDEX	0x190000
#define FILE_INTRLCKD	0x1A0000
#define FILE_MACANSI	0x1B0000
#define FILE_MEMORY		0x1C0000
#define FILE_NWTRASH	0x1D0000
#define FILE_PATHMAP	0x1E0000
#define FILE_SCAVENGR	0x1F0000
#define FILE_SDA		0x100000
#define FILE_SECUTIL	0x200000
#define FILE_SERVER		0x210000
#define FILE_SWMR		0x220000
#define FILE_TIME		0x230000
#define FILE_VOLUME		0x240000
#define FILE_CHGNTFY	0x250000
#define FILE_TCPTDI     0x260000
#define FILE_TCPUTIL    0x270000
#define FILE_TCPDSI     0x280000
#define	FILE_CACHEMDL   0x290000

#endif	// _FILENUMS_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\fileio.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fileio.c

Abstract:

	This module contains the routines for performing file system functions.
	No other part of the server should be calling filesystem NtXXX routines
	directly

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	18 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILEIO_LOCALS
#define	FILENUM	FILE_FILEIO

#include <afp.h>
#include <client.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpFileIoInit)
#pragma alloc_text( PAGE, AfpIoOpen)
#pragma alloc_text( PAGE, AfpIoCreate)
#pragma alloc_text( PAGE, AfpIoRead)
#pragma alloc_text( PAGE, AfpIoWrite)
#pragma alloc_text( PAGE, AfpIoQuerySize)
#pragma alloc_text( PAGE, AfpIoSetSize)
#pragma alloc_text( PAGE, AfpIoChangeNTModTime)
#pragma alloc_text( PAGE, AfpIoQueryTimesnAttr)
#pragma alloc_text( PAGE, AfpIoSetTimesnAttr)
#pragma alloc_text( PAGE, AfpIoQueryLongName)
#pragma alloc_text( PAGE, AfpIoQueryShortName)
#pragma alloc_text( PAGE, AfpIoQueryStreams)
#pragma alloc_text( PAGE, AfpIoMarkFileForDelete)
#pragma alloc_text( PAGE, AfpIoQueryDirectoryFile)
#pragma alloc_text( PAGE, AfpIoQueryBasicInfo)
#pragma alloc_text( PAGE, AfpIoClose)
#pragma alloc_text( PAGE, AfpIoQueryVolumeSize)
#pragma alloc_text( PAGE, AfpIoMoveAndOrRename)
#pragma alloc_text( PAGE, AfpIoCopyFile1)
#pragma alloc_text( PAGE, AfpIoCopyFile2)
#pragma alloc_text( PAGE, AfpIoWait)
#pragma alloc_text( PAGE, AfpIoConvertNTStatusToAfpStatus)
#pragma alloc_text( PAGE, AfpQueryPath)
#pragma alloc_text( PAGE, AfpIoIsSupportedDevice)
#endif

/***	AfpFileIoInit
 *
 *	Initialize various strings that we use for stream names etc.
 */
NTSTATUS
AfpFileIoInit(
	VOID
)
{

	// NTFS Stream names
	RtlInitUnicodeString(&AfpIdDbStream, AFP_IDDB_STREAM);
	RtlInitUnicodeString(&AfpDesktopStream, AFP_DT_STREAM);
	RtlInitUnicodeString(&AfpResourceStream, AFP_RESC_STREAM);
	RtlInitUnicodeString(&AfpInfoStream, AFP_INFO_STREAM);
	RtlInitUnicodeString(&AfpCommentStream, AFP_COMM_STREAM);
	RtlInitUnicodeString(&AfpDataStream, L"");

	// Directory enumeration names to ignore
	RtlInitUnicodeString(&Dot,L".");
	RtlInitUnicodeString(&DotDot,L"..");

	// Supported file systems
	RtlInitUnicodeString(&afpNTFSName, AFP_NTFS);
	RtlInitUnicodeString(&afpCDFSName, AFP_CDFS);
	RtlInitUnicodeString(&afpAHFSName, AFP_AHFS);

	// Prepended to full path names originating at drive letter
	RtlInitUnicodeString(&DosDevices, AFP_DOSDEVICES);

	// CopyFile stream not to create
	RtlInitUnicodeString(&DataStreamName, FULL_DATA_STREAM_NAME);

	RtlInitUnicodeString(&FullCommentStreamName, FULL_COMMENT_STREAM_NAME);
	RtlInitUnicodeString(&FullResourceStreamName, FULL_RESOURCE_STREAM_NAME);
	RtlInitUnicodeString(&FullInfoStreamName, FULL_INFO_STREAM_NAME);

	// ExchangeFiles temporary filename
	RtlInitUnicodeString(&AfpExchangeName, AFP_TEMP_EXCHANGE_NAME);


	return STATUS_SUCCESS;
}


/***	AfpIoOpen
 *
 *	Perform a file/stream open. The stream is specified by a manifest rather
 *	than a name.  The entity can only be opened by name (Not by ID).
 *	If a stream other than the DATA stream is to be opened, then
 *	the phRelative handle MUST be that of the unnamed (that is, DATA) stream
 *	of the file/dir	itself.
 */
NTSTATUS
AfpIoOpen(
	IN	PFILESYSHANDLE	phRelative				OPTIONAL,
	IN	DWORD			StreamId,
	IN	DWORD			OpenOptions,
	IN	PUNICODE_STRING	pObject,
	IN	DWORD			AfpAccess,				// FILEIO_ACCESS_XXX desired access
	IN	DWORD			AfpDenyMode,			// FILIEO_DENY_XXX
	IN	BOOLEAN			CheckAccess,
	OUT	PFILESYSHANDLE	pNewHandle
)
{
	OBJECT_ATTRIBUTES	ObjAttr;
	IO_STATUS_BLOCK		IoStsBlk;
	NTSTATUS			Status;
	NTSTATUS			Status2;
	UNICODE_STRING		UName;
	HANDLE				hRelative = NULL;
	BOOLEAN				FreeBuf = False;
#ifdef	PROFILING
	TIME				TimeS, TimeE, TimeD;

	AfpGetPerfCounter(&TimeS);
#endif

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoOpen entered\n"));

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

#if DBG
	pNewHandle->Signature = FSH_SIGNATURE;
#endif

	// Assume Failure
	pNewHandle->fsh_FileHandle = NULL;

	if (phRelative != NULL)
	{
		ASSERT(VALID_FSH(phRelative));
		hRelative = phRelative->fsh_FileHandle;
	}


	ASSERT (StreamId < AFP_STREAM_MAX);
	ASSERT ((pObject->Length > 0) || (phRelative != NULL));

	if (StreamId != AFP_STREAM_DATA)
	{
		if (pObject->Length > 0)
		{
			UName.Length =
			UName.MaximumLength = pObject->Length + AFP_MAX_STREAMNAME*sizeof(WCHAR);
			UName.Buffer = (LPWSTR)AfpAllocNonPagedMemory(UName.Length);
			if (UName.Buffer == NULL)
			{
				return STATUS_NO_MEMORY;
			}
			AfpCopyUnicodeString(&UName, pObject);
			RtlAppendUnicodeStringToString(&UName, &AfpStreams[StreamId]);
			pObject = &UName;
			FreeBuf = True;
		}
		else
		{
			pObject = &AfpStreams[StreamId];
		}
	}

	InitializeObjectAttributes(&ObjAttr,
								pObject,
								OBJ_CASE_INSENSITIVE,
								hRelative,
								NULL);		// no security descriptor

	ObjAttr.SecurityQualityOfService = &AfpSecurityQOS;

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
								("AfpIoOpen: about to call NtOpenFile\n"));

	// If we are opening for RWCTRL, then specify to use privilege.
	if (AfpAccess & (WRITE_DAC | WRITE_OWNER))
	{
		OpenOptions |= FILE_OPEN_FOR_BACKUP_INTENT;
	}

	Status = IoCreateFile(&pNewHandle->fsh_FileHandle,
						  AfpAccess,
						  &ObjAttr,
						  &IoStsBlk,
						  NULL,
						  0,
						  AfpDenyMode,
						  FILE_OPEN,
						  OpenOptions,
						  (PVOID)NULL,
						  0L,
						  CreateFileTypeNone,
						  (PVOID)NULL,
						  CheckAccess ? IO_FORCE_ACCESS_CHECK : 0);

	if (Status != 0)
		DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
			("AfpIoOpen: IoCreateFile returned 0x%lx, %Z\n",Status,
			 ObjAttr.ObjectName));

	if (FreeBuf)
		AfpFreeMemory(UName.Buffer);

	if (NT_SUCCESS(Status))
	{
		Status = ObReferenceObjectByHandle(pNewHandle->fsh_FileHandle,
										   AfpAccess,
										   NULL,
										   KernelMode,
										   (PVOID *)(&pNewHandle->fsh_FileObject),
										   NULL);

		if (!NT_SUCCESS(Status)) {
			ASSERT(VALID_FSH((PFILESYSHANDLE)&pNewHandle->fsh_FileHandle)) ;
	
			Status2 = NtClose(pNewHandle->fsh_FileHandle);
			pNewHandle->fsh_FileHandle = NULL;

			ASSERT(NT_SUCCESS(Status2));
		}
		else
		{
		pNewHandle->fsh_DeviceObject = IoGetRelatedDeviceObject(pNewHandle->fsh_FileObject);
		(ULONG_PTR)(pNewHandle->fsh_FileObject) |= 1;
		ASSERT(NT_SUCCESS(Status));
		afpUpdateOpenFiles(True, True);

#ifdef	PROFILING
		AfpGetPerfCounter(&TimeE);

		TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
		if (OpenOptions == FILEIO_OPEN_DIR)
		{
			INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_OpenCountDR);
			INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_OpenTimeDR,
									 TimeD,
									 &AfpStatisticsLock);
		}
		else
		{
			if ((AfpAccess & FILEIO_ACCESS_DELETE) == FILEIO_ACCESS_DELETE)
			{
				INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_OpenCountDL);
				INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_OpenTimeDL,
										 TimeD,
										 &AfpStatisticsLock);
			}
			else if (((AfpAccess & FILEIO_ACCESS_READWRITE) == FILEIO_ACCESS_READ) ||
					 ((AfpAccess & FILEIO_ACCESS_READWRITE) == FILEIO_ACCESS_WRITE) ||
					 ((AfpAccess & FILEIO_ACCESS_READWRITE) == FILEIO_ACCESS_READWRITE))
			{
				INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_OpenCountRW);
				INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_OpenTimeRW,
										 TimeD,
										 &AfpStatisticsLock);
			}
			else if (AfpAccess & (WRITE_DAC | WRITE_OWNER))
			{
				INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_OpenCountWC);
				INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_OpenTimeWC,
										 TimeD,
										 &AfpStatisticsLock);
			}
			else if (AfpAccess & READ_CONTROL)
			{
				INTERLOCKED_INCREMENT_LONG( &AfpServerProfile->perf_OpenCountRC);
				INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_OpenTimeRC,
										 TimeD,
										 &AfpStatisticsLock);
			}
			else	// Ought to be read-attributes or write-attributes
			{
				ASSERT ((AfpAccess == FILEIO_ACCESS_NONE) ||
						(AfpAccess == (FILEIO_ACCESS_NONE | FILE_WRITE_ATTRIBUTES)));
				INTERLOCKED_INCREMENT_LONG( &AfpServerProfile->perf_OpenCountRA);
				INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_OpenTimeRA,
										 TimeD,
										 &AfpStatisticsLock);
			}
		}
#endif
		}
	}

	return Status;
}


/***	AfpIoCreate
 *
 *	Perform a file/stream create. The stream is specified by a manifest rather
 *	than a name.  If a stream other than the DATA stream is to be created, then
 *	the phRelative handle MUST be that of either the Parent directory, or the
 *	unnamed (that is, DATA) stream of the file/dir itself because we only use
 *	a buffer large enough for a AFP filename plus the maximum stream name
 *	length.
 */
NTSTATUS
AfpIoCreate(
	IN	PFILESYSHANDLE		phRelative,				// create relative to this
	IN	DWORD				StreamId,				// Id of stream to create
	IN	PUNICODE_STRING		pObject,				// Name of file
	IN	DWORD				AfpAccess,				// FILEIO_ACCESS_XXX desired access
	IN	DWORD				AfpDenyMode,			// FILEIO_DENY_XXX
	IN	DWORD				CreateOptions,			// File/Directory etc.
	IN	DWORD				Disposition,			// Soft or hard create
	IN	DWORD				Attributes,				// hidden, archive, normal, etc.
	IN	BOOLEAN				CheckAccess,    		// If TRUE, enforce security
	IN	PSECURITY_DESCRIPTOR pSecDesc			OPTIONAL, // Security descriptor to slap on
	OUT	PFILESYSHANDLE		pNewHandle,				// Place holder for the handle
	OUT	PDWORD				pInformation		OPTIONAL, // file opened, created, etc.
	IN  PVOLDESC			pVolDesc			OPTIONAL, // only if NotifyPath
	IN  PUNICODE_STRING		pNotifyPath			OPTIONAL,
	IN  PUNICODE_STRING		pNotifyParentPath	OPTIONAL
)
{
	NTSTATUS			Status;
	NTSTATUS			Status2;
	OBJECT_ATTRIBUTES	ObjAttr;
	UNICODE_STRING		RealName;
	IO_STATUS_BLOCK		IoStsBlk;
	HANDLE				hRelative;
	WCHAR				NameBuffer[AFP_FILENAME_LEN + 1 + AFP_MAX_STREAMNAME];
	BOOLEAN				Queue = False;
#ifdef	PROFILING
	TIME				TimeS, TimeE, TimeD;

	AfpGetPerfCounter(&TimeS);
#endif


	PAGED_CODE( );

	ASSERT(pObject != NULL && phRelative != NULL && StreamId < AFP_STREAM_MAX);

	ASSERT(VALID_FSH(phRelative) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

#if DBG
	pNewHandle->Signature = FSH_SIGNATURE;
#endif
	hRelative = phRelative->fsh_FileHandle;

	// Assume Failure
	pNewHandle->fsh_FileHandle = NULL;

	if (StreamId != AFP_STREAM_DATA)
	{
		ASSERT(pObject->Length <= (AFP_FILENAME_LEN*sizeof(WCHAR)));

		// Construct the name to pass to NtCreateFile
		AfpSetEmptyUnicodeString(&RealName, sizeof(NameBuffer), NameBuffer);
		AfpCopyUnicodeString(&RealName, pObject);
		RtlAppendUnicodeStringToString(&RealName, &AfpStreams[StreamId]);
		pObject = &RealName;
	}

	InitializeObjectAttributes(&ObjAttr,
							   pObject,
							   OBJ_CASE_INSENSITIVE,
							   hRelative,
							   pSecDesc);

	ObjAttr.SecurityQualityOfService = &AfpSecurityQOS;

	// Do not queue our changes for exclusive volumes since no notifies are posted
	if (ARGUMENT_PRESENT(pNotifyPath)	&&
		!EXCLUSIVE_VOLUME(pVolDesc)		&&
		(StreamId == AFP_STREAM_DATA))
	{
		ASSERT(VALID_VOLDESC(pVolDesc));
		ASSERT((Disposition == FILEIO_CREATE_HARD) ||
			   (Disposition == FILEIO_CREATE_SOFT));
		Queue = True;

		// Queue a change for both cases.
		AfpQueueOurChange(pVolDesc,
						  FILE_ACTION_ADDED,
						  pNotifyPath,
						  pNotifyParentPath);
		AfpQueueOurChange(pVolDesc,
						  FILE_ACTION_MODIFIED,
						  pNotifyPath,
						  NULL);
	}

	Status = IoCreateFile(&pNewHandle->fsh_FileHandle,
						  AfpAccess,
						  &ObjAttr,
						  &IoStsBlk,
						  NULL,
						  Attributes,
						  AfpDenyMode,
						  Disposition,
						  CreateOptions,
						  NULL,
						  0,
						  CreateFileTypeNone,
						  (PVOID)NULL,
						  CheckAccess ? IO_FORCE_ACCESS_CHECK : 0);

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoCreate: IoCreateFile returned 0x%lx\n", Status) );

	if (Queue)
	{
		if (NT_SUCCESS(Status))
		{
			ASSERT((IoStsBlk.Information == FILE_CREATED) ||
				   (IoStsBlk.Information == FILE_SUPERSEDED));

			// Dequeue the extra change that was queued
			AfpDequeueOurChange(pVolDesc,
								(IoStsBlk.Information == FILE_CREATED) ?
								FILE_ACTION_MODIFIED : FILE_ACTION_ADDED,
								pNotifyPath,
								NULL);
		}
		else
		{
			AfpDequeueOurChange(pVolDesc,
								FILE_ACTION_ADDED,
								pNotifyPath,
								pNotifyParentPath);
			AfpDequeueOurChange(pVolDesc,
								FILE_ACTION_MODIFIED,
								pNotifyPath,
								NULL);
		}
	}

	if (NT_SUCCESS(Status))
	{
		if (ARGUMENT_PRESENT(pInformation))
		{
			*pInformation = (ULONG)(IoStsBlk.Information);
		}

		Status = ObReferenceObjectByHandle(pNewHandle->fsh_FileHandle,
										   AfpAccess,
										   NULL,
										   KernelMode,
										   (PVOID *)(&pNewHandle->fsh_FileObject),
										   NULL);
		if (!NT_SUCCESS(Status)) 
		{
			ASSERT(VALID_FSH((PFILESYSHANDLE)&pNewHandle->fsh_FileHandle)) ;
	
			Status2 = NtClose(pNewHandle->fsh_FileHandle);
			pNewHandle->fsh_FileHandle = NULL;

			ASSERT(NT_SUCCESS(Status2));
		}
		else
		{
		ASSERT(NT_SUCCESS(Status));

		pNewHandle->fsh_DeviceObject = IoGetRelatedDeviceObject(pNewHandle->fsh_FileObject);
		(ULONG_PTR)(pNewHandle->fsh_FileObject) |= 1;
		afpUpdateOpenFiles(True, True);

#ifdef	PROFILING
		AfpGetPerfCounter(&TimeE);

		TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
		if (StreamId == AFP_STREAM_DATA)
		{
			if (CreateOptions == FILEIO_OPEN_FILE)
			{
				INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_CreateCountFIL);
				INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_CreateTimeFIL,
											 TimeD,
											 &AfpStatisticsLock);
			}
			else
			{
				INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_CreateCountDIR);
				INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_CreateTimeDIR,
											 TimeD,
											 &AfpStatisticsLock);
			}
		}
		else
		{
			INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_CreateCountSTR);
			INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_CreateTimeSTR,
										 TimeD,
										 &AfpStatisticsLock);
		}
#endif
		}
	}

	return Status;
}



/***	AfpIoRead
 *
 *	Perform file read. Just a wrapper over NtReadFile.
 */
AFPSTATUS
AfpIoRead(
	IN	PFILESYSHANDLE	pFileHandle,
	IN	PFORKOFFST		pForkOffset,
	IN	LONG			SizeReq,
	OUT	PLONG			pSizeRead,
	OUT	PBYTE			pBuffer
)
{
	NTSTATUS		Status;
	DWORD			Key = 0;
	IO_STATUS_BLOCK	IoStsBlk;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
			("AfpIoRead Entered, Size %lx, Key %lx\n",
			SizeReq, Key));

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() == LOW_LEVEL));

	ASSERT (INTERNAL_HANDLE(pFileHandle));

	*pSizeRead = 0;
	Status = NtReadFile(pFileHandle->fsh_FileHandle,
						NULL,
						NULL,
						NULL,
						&IoStsBlk,
						pBuffer,
						(DWORD)SizeReq,
						pForkOffset,
						&Key);

	if (NT_SUCCESS(Status))
	{
		*pSizeRead = (LONG)IoStsBlk.Information;
		INTERLOCKED_ADD_STATISTICS(&AfpServerStatistics.stat_DataReadInternal,
								   (ULONG)(IoStsBlk.Information),
								   &AfpStatisticsLock);
	}
	else
	{
		if (Status == STATUS_FILE_LOCK_CONFLICT)
			Status = AFP_ERR_LOCK;
		else if (Status == STATUS_END_OF_FILE)
			Status = AFP_ERR_EOF;
		else
		{
			AFPLOG_HERROR(AFPSRVMSG_CANT_READ,
						  Status,
						  NULL,
						  0,
						  pFileHandle->fsh_FileHandle);

			Status = AFP_ERR_MISC;
		}
	}
	return Status;
}


/***	AfpIoWrite
 *
 *	Perform file write. Just a wrapper over NtWriteFile.
 */
AFPSTATUS
AfpIoWrite(
	IN	PFILESYSHANDLE	pFileHandle,
	IN	PFORKOFFST		pForkOffset,
	IN	LONG			SizeWrite,
	OUT	PBYTE			pBuffer
)
{
	NTSTATUS		Status;
	DWORD			Key = 0;
	IO_STATUS_BLOCK	IoStsBlk;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoWrite Entered, Size %lx, Key %lx\n",
			SizeWrite, Key));

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() == LOW_LEVEL));

	ASSERT (INTERNAL_HANDLE(pFileHandle));

	Status = NtWriteFile(pFileHandle->fsh_FileHandle,
						 NULL,
						 NULL,
						 NULL,
						 &IoStsBlk,
						 pBuffer,
						 (DWORD)SizeWrite,
						 pForkOffset,
						 &Key);

	if (NT_SUCCESS(Status))
	{
		INTERLOCKED_ADD_STATISTICS(&AfpServerStatistics.stat_DataWrittenInternal,
								   SizeWrite,
								   &AfpStatisticsLock);
	}

	else
	{
	    DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
		    ("AfpIoWrite: NtWriteFile returned 0x%lx\n",Status));

		if (Status == STATUS_FILE_LOCK_CONFLICT)
			Status = AFP_ERR_LOCK;
		else
		{
			AFPLOG_HERROR(AFPSRVMSG_CANT_WRITE,
						  Status,
						  NULL,
						  0,
						  pFileHandle->fsh_FileHandle);
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
		}
	}
	return Status;
}


/***	AfpIoQuerySize
 *
 *	Get the current size of the fork.
 */
AFPSTATUS FASTCALL
AfpIoQuerySize(
	IN	PFILESYSHANDLE		pFileHandle,
	OUT	PFORKSIZE			pForkLength
)
{
	FILE_STANDARD_INFORMATION		FStdInfo;
	NTSTATUS						Status;
	IO_STATUS_BLOCK					IoStsBlk;
	PFAST_IO_DISPATCH				fastIoDispatch;

	PAGED_CODE( );

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	fastIoDispatch = pFileHandle->fsh_DeviceObject->DriverObject->FastIoDispatch;

	if (fastIoDispatch &&
		fastIoDispatch->FastIoQueryStandardInfo &&
		fastIoDispatch->FastIoQueryStandardInfo(AfpGetRealFileObject(pFileHandle->fsh_FileObject),
												True,
												&FStdInfo,
												&IoStsBlk,
												pFileHandle->fsh_DeviceObject))
	{
		Status = IoStsBlk.Status;

#ifdef	PROFILING
		// The fast I/O path worked. Update statistics
		INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoSucceeded));
#endif

	}
	else
	{

#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoFailed));
#endif

		Status = NtQueryInformationFile(pFileHandle->fsh_FileHandle,
										&IoStsBlk,
										&FStdInfo,
										sizeof(FStdInfo),
										FileStandardInformation);

	}

	if (!NT_SUCCESS((NTSTATUS)Status))
	{
		AFPLOG_HERROR(AFPSRVMSG_CANT_GET_FILESIZE,
					  Status,
					  NULL,
					  0,
					  pFileHandle->fsh_FileHandle);
		return AFP_ERR_MISC;	// What else can we do
	}
	*pForkLength = FStdInfo.EndOfFile;
	return AFP_ERR_NONE;
}


/***	AfpIoSetSize
 *
 *	Set the size of the open fork to the value specified.
 *
 *	ISSUE:
 *	We can check the locks and resolve any lock conflicts before we go
 *	to the filesystem. The issue that needs to be resolved here is:
 *	Is it OK to truncate the file such that our own locks cause
 *	conflict ?
 */
AFPSTATUS FASTCALL
AfpIoSetSize(
	IN	PFILESYSHANDLE		pFileHandle,
	IN	LONG				ForkLength
)
{
	NTSTATUS						Status;
	FILE_END_OF_FILE_INFORMATION	FEofInfo;
	IO_STATUS_BLOCK					IoStsBlk;

	PAGED_CODE( );

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	FEofInfo.EndOfFile.QuadPart = ForkLength;
	Status = NtSetInformationFile(pFileHandle->fsh_FileHandle,
								  &IoStsBlk,
								  &FEofInfo,
								  sizeof(FEofInfo),
								  FileEndOfFileInformation);

	if (!NT_SUCCESS(Status))
	{
	    DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
		    ("AfpIoSetSize: NtSetInformationFile returned 0x%lx\n",Status));

		if (Status != STATUS_FILE_LOCK_CONFLICT)
			AFPLOG_HERROR(AFPSRVMSG_CANT_SET_FILESIZE,
						  Status,
						  &ForkLength,
						  sizeof(ForkLength),
						  pFileHandle->fsh_FileHandle);

		if (Status == STATUS_DISK_FULL)
        {
	        DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,("AfpIoSetSize: DISK_FULL error\n"));
            ASSERT(0);
			Status = AFP_ERR_DISK_FULL;
        }

		else if (Status == STATUS_FILE_LOCK_CONFLICT)
			Status = AFP_ERR_LOCK;
		// Default error code. What else can it be ?
		else Status = AFP_ERR_MISC;
	}

	return Status;
}

/***	AfpIoChangeNTModTime
 *
 *	Get the NTFS ChangeTime of a file/dir.  If it is larger than the
 *  NTFS LastWriteTime, set NTFS LastWriteTime to this time.
 *  Return the resultant LastWriteTime in pModTime (whether changed or not).
 *  This is used to update the modified time when the resource fork is changed
 *  or when some other attribute changes that should cause the timestamp on
 *  the file to change as viewed by mac.
 *
 */
AFPSTATUS
AfpIoChangeNTModTime(
	IN	PFILESYSHANDLE		pFileHandle,
	OUT	PTIME				pModTime
)
{
	FILE_BASIC_INFORMATION	FBasicInfo;
	NTSTATUS				Status;
	IO_STATUS_BLOCK			IoStsBlk;
	PFAST_IO_DISPATCH		fastIoDispatch;

	PAGED_CODE( );

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() == LOW_LEVEL));


	// Set all times/attr to Zero (this will cause NTFS to update LastModTime
    // if there are any writes pending)

    RtlZeroMemory(&FBasicInfo, sizeof(FBasicInfo));

	Status = NtSetInformationFile(pFileHandle->fsh_FileHandle,
								  &IoStsBlk,
								  (PVOID)&FBasicInfo,
								  sizeof(FBasicInfo),
								  FileBasicInformation);

    if (!NT_SUCCESS(Status))
    {
	    DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
			("AfpIoChangeNTModTime: NtSetInformationFile failed with 0x%lx\n",Status));

		AFPLOG_HERROR(AFPSRVMSG_CANT_SET_TIMESNATTR,
					  Status,
					  NULL,
					  0,
					  pFileHandle->fsh_FileHandle);

		return AFP_ERR_MISC;
    }

    // now, go and query for the updated times

    Status = AfpIoQueryTimesnAttr( pFileHandle,
                                   NULL,
                                   pModTime,
                                   NULL );
    if (!NT_SUCCESS(Status))
    {
	    DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
			("AfpIoChangeNTModTime: AfpIoQueryTimesnAttr returned 0x%lx\n",Status));
    }

	return Status;
}

/***	AfpIoQueryTimesnAttr
 *
 *	Get the times associated with the file.
 */
AFPSTATUS
AfpIoQueryTimesnAttr(
	IN	PFILESYSHANDLE		pFileHandle,
	OUT	PDWORD				pCreatTime	OPTIONAL,
	OUT	PTIME				pModTime	OPTIONAL,
	OUT	PDWORD				pAttr		OPTIONAL
)
{
	FILE_BASIC_INFORMATION	FBasicInfo;
	NTSTATUS				Status;
	IO_STATUS_BLOCK			IoStsBlk;
	PFAST_IO_DISPATCH		fastIoDispatch;

#ifdef	PROFILING
	TIME					TimeS, TimeE, TimeD;

	AfpGetPerfCounter(&TimeS);
#endif

	PAGED_CODE( );

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	// Atleast something should be queried.
	ASSERT((pCreatTime != NULL) || (pModTime != NULL) || (pAttr != NULL));

	fastIoDispatch = pFileHandle->fsh_DeviceObject->DriverObject->FastIoDispatch;

	if (fastIoDispatch &&
		fastIoDispatch->FastIoQueryBasicInfo &&
		fastIoDispatch->FastIoQueryBasicInfo(AfpGetRealFileObject(pFileHandle->fsh_FileObject),
											 True,
											 &FBasicInfo,
											 &IoStsBlk,
											 pFileHandle->fsh_DeviceObject))
	{
		Status = IoStsBlk.Status;

#ifdef	PROFILING
		// The fast I/O path worked. Update statistics
		INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoSucceeded));
#endif

	}
	else
	{

#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoFailed));
#endif

		Status = NtQueryInformationFile(pFileHandle->fsh_FileHandle,
							&IoStsBlk, &FBasicInfo, sizeof(FBasicInfo),
							FileBasicInformation);
	}

	if (NT_SUCCESS((NTSTATUS)Status))
	{
		if (pModTime != NULL)
			*pModTime = FBasicInfo.LastWriteTime;
		if (pCreatTime != NULL)
			*pCreatTime = AfpConvertTimeToMacFormat(&FBasicInfo.CreationTime);
		if (pAttr != NULL)
			*pAttr = FBasicInfo.FileAttributes;
#ifdef	PROFILING
		AfpGetPerfCounter(&TimeE);
		TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_GetInfoCount);
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_GetInfoTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	}
	else
	{
		AFPLOG_HERROR(AFPSRVMSG_CANT_GET_TIMESNATTR,
					  Status,
					  NULL,
					  0,
					  pFileHandle->fsh_FileHandle);
		Status = AFP_ERR_MISC;	// What else can we do
	}

	return Status;
}

/***	AfpIoSetTimesnAttr
 *
 *	Set the times and attributes associated with the file.
 */
AFPSTATUS
AfpIoSetTimesnAttr(
	IN PFILESYSHANDLE		pFileHandle,
	IN AFPTIME		*		pCreateTime	OPTIONAL,
	IN AFPTIME		*		pModTime	OPTIONAL,
	IN DWORD				AttrSet,
	IN DWORD				AttrClear,
	IN PVOLDESC				pVolDesc	OPTIONAL,	// only if NotifyPath
	IN PUNICODE_STRING		pNotifyPath	OPTIONAL
)
{
	NTSTATUS				Status;
	FILE_BASIC_INFORMATION	FBasicInfo;
	IO_STATUS_BLOCK			IoStsBlk;
	PFAST_IO_DISPATCH		fastIoDispatch;
	BOOLEAN					Queue = False;
#ifdef	PROFILING
	TIME					TimeS, TimeE, TimeD;
#endif

	PAGED_CODE( );

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeS);
#endif

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
									("AfpIoSetTimesnAttr entered\n"));

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	// At least something should be set
	ASSERT((pCreateTime != NULL) || (pModTime != NULL) || (AttrSet != 0) || (AttrClear != 0));

	// First query the information
	fastIoDispatch = pFileHandle->fsh_DeviceObject->DriverObject->FastIoDispatch;

	if (fastIoDispatch &&
		fastIoDispatch->FastIoQueryBasicInfo &&
		fastIoDispatch->FastIoQueryBasicInfo(AfpGetRealFileObject(pFileHandle->fsh_FileObject),
											 True,
											 &FBasicInfo,
											 &IoStsBlk,
											 pFileHandle->fsh_DeviceObject))
	{
		Status = IoStsBlk.Status;

#ifdef	PROFILING
		// The fast I/O path worked. Update statistics
		INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoSucceeded));
#endif

	}
	else
	{

#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoFailed));
#endif

		Status = NtQueryInformationFile(pFileHandle->fsh_FileHandle,
										&IoStsBlk,
										&FBasicInfo,
										sizeof(FBasicInfo),
										FileBasicInformation);
	}

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoSetTimesnAttr: NtQueryInformationFile returned 0x%lx\n",Status));

	if (!NT_SUCCESS((NTSTATUS)Status))
	{
		AFPLOG_HERROR(AFPSRVMSG_CANT_GET_TIMESNATTR,
					  Status,
					  NULL,
					  0,
					  pFileHandle->fsh_FileHandle);
		return AFP_ERR_MISC;	// What else can we do
	}

	// Set all times to Zero. This will not change it. Then set the times that are to
	// change
	FBasicInfo.CreationTime = LIZero;
	FBasicInfo.ChangeTime = LIZero;
	FBasicInfo.LastWriteTime = LIZero;
	FBasicInfo.LastAccessTime = LIZero;

	if (pCreateTime != NULL)
		AfpConvertTimeFromMacFormat(*pCreateTime, &FBasicInfo.CreationTime);

	if (pModTime != NULL)
	{
		AfpConvertTimeFromMacFormat(*pModTime, &FBasicInfo.LastWriteTime);
		FBasicInfo.ChangeTime = FBasicInfo.LastWriteTime;
	}

	// NTFS is not returning FILE_ATTRIBUTE_NORMAL if it is a file,
	// therefore we may end up trying to set attributes of 0 when we
	// want to clear all attributes. 0 is taken to mean you do not want
	// to set any attributes, so it is ignored all together by NTFS.  In
	// this case, just tack on the normal bit so that our request is not
	// ignored.

	if (!(FBasicInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY))
	{
		FBasicInfo.FileAttributes |= FILE_ATTRIBUTE_NORMAL;
	}

	FBasicInfo.FileAttributes |= AttrSet;
	FBasicInfo.FileAttributes &= ~AttrClear;

	// Do not queue our changes for exclusive volumes since no notifies are posted
	if (ARGUMENT_PRESENT(pNotifyPath) &&
		!EXCLUSIVE_VOLUME(pVolDesc))
	{
		ASSERT(VALID_VOLDESC(pVolDesc));
		Queue = True;
		AfpQueueOurChange(pVolDesc,
						  FILE_ACTION_MODIFIED,
						  pNotifyPath,
						  NULL);
	}

	Status = NtSetInformationFile(pFileHandle->fsh_FileHandle,
								  &IoStsBlk,
								  (PVOID)&FBasicInfo,
								  sizeof(FBasicInfo),
								  FileBasicInformation);

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoSetTimesnAttr: NtSetInformationFile returned 0x%lx\n",Status));


	if (!NT_SUCCESS(Status))
	{
		if (Queue)
		{
			AfpDequeueOurChange(pVolDesc,
								FILE_ACTION_MODIFIED,
								pNotifyPath,
								NULL);
		}

		AFPLOG_HERROR(AFPSRVMSG_CANT_SET_TIMESNATTR,
					  Status,
					  NULL,
					  0,
					  pFileHandle->fsh_FileHandle);
		return AFP_ERR_MISC;
	}
	else
	{
#ifdef	PROFILING
		AfpGetPerfCounter(&TimeE);
		TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_SetInfoCount);
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_SetInfoTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	}

	return AFP_ERR_NONE;

}


/***	AfpIoRestoreTimeStamp
 *
 *	When we don't want to change the modification timestamp, we call this function
 *  in 2 steps: first time, it queries the original Mod time; second time, it sets it
 */
AFPSTATUS
AfpIoRestoreTimeStamp(
	IN PFILESYSHANDLE		pFileHandle,
    IN OUT PTIME            pOriginalModTime,
    IN DWORD                dwFlag
)
{
    NTSTATUS                Status;
    DWORD                   NTAttr = 0;
	FILE_BASIC_INFORMATION	FBasicInfo;
	IO_STATUS_BLOCK			IoStsBlk;
	PFAST_IO_DISPATCH		fastIoDispatch;


    // if we are asked to retrieve the original timestamp, do that and return
    if (dwFlag == AFP_RETRIEVE_MODTIME)
    {
        Status = AfpIoQueryTimesnAttr(pFileHandle, NULL, pOriginalModTime, &NTAttr);
        return(Status);
    }

    //
    // we've been asked to restore the timestamp: let's do that!
    //

    ASSERT(dwFlag == AFP_RESTORE_MODTIME);

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

    // this will cause file system to flush any timestamps
    RtlZeroMemory(&FBasicInfo, sizeof(FBasicInfo));

    Status = NtSetInformationFile(pFileHandle->fsh_FileHandle,
                                  &IoStsBlk,
                                  (PVOID)&FBasicInfo,
                                  sizeof(FBasicInfo),
                                  FileBasicInformation);

    if (!NT_SUCCESS(Status))
    {
        DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
            ("AfpIoRestoreTimeStamp: NtSetInformationFile failed with 0x%lx\n",Status));
    }

	// First query the information
	fastIoDispatch = pFileHandle->fsh_DeviceObject->DriverObject->FastIoDispatch;

	if (fastIoDispatch &&
		fastIoDispatch->FastIoQueryBasicInfo &&
		fastIoDispatch->FastIoQueryBasicInfo(AfpGetRealFileObject(pFileHandle->fsh_FileObject),
											 True,
											 &FBasicInfo,
											 &IoStsBlk,
											 pFileHandle->fsh_DeviceObject))
	{
		Status = IoStsBlk.Status;
	}
	else
	{
		Status = NtQueryInformationFile(pFileHandle->fsh_FileHandle,
										&IoStsBlk,
										&FBasicInfo,
										sizeof(FBasicInfo),
										FileBasicInformation);
	}

	if (!NT_SUCCESS((NTSTATUS)Status))
	{
	    DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
			("AfpIoRestoreTimeStamp: NtQueryInformationFile returned 0x%lx\n",Status));
		return AFP_ERR_MISC;	// What else can we do
	}

    //
	// Set times to Zero for the ones we don't want to restore, so that those don't change
	//
	FBasicInfo.CreationTime = LIZero;
	FBasicInfo.LastAccessTime = LIZero;

    FBasicInfo.LastWriteTime = *pOriginalModTime;
	FBasicInfo.ChangeTime = *pOriginalModTime;

	// see AfpIoSetTimesnAttr()
	if (!(FBasicInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY))
	{
		FBasicInfo.FileAttributes |= FILE_ATTRIBUTE_NORMAL;
	}

	Status = NtSetInformationFile(pFileHandle->fsh_FileHandle,
								  &IoStsBlk,
								  (PVOID)&FBasicInfo,
								  sizeof(FBasicInfo),
								  FileBasicInformation);

	if (!NT_SUCCESS(Status))
	{
		return AFP_ERR_MISC;
	}

	return AFP_ERR_NONE;

}

/***	AfpIoQueryLongName
 *
 *	Get the long name associated with a file. Caller makes sure that
 *	the buffer is big enough to handle the long name.  The only caller of this
 *	should be the AfpFindEntryByName routine when looking up a name by
 *	SHORTNAME.  If it dosn't find it in the database by shortname (i.e.
 *	shortname == longname), then it queries for the longname so it can look
 *	in the database by longname (since all database entries are stored with
 *	longname only).
 *	The Admin Get/SetDirectoryInfo calls may also call this if they find a
 *	~ in a path component, then it will assume that it got a shortname.
 */
NTSTATUS
AfpIoQueryLongName(
	IN	PFILESYSHANDLE		pFileHandle,
	IN	PUNICODE_STRING		pShortname,
	OUT	PUNICODE_STRING		pLongName
)
{
        LONGLONG   Infobuf[(sizeof(FILE_BOTH_DIR_INFORMATION) + MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR))/sizeof(LONGLONG) + 1];
	NTSTATUS				Status;
	IO_STATUS_BLOCK			IoStsBlk;
	UNICODE_STRING			uName;
	PFILE_BOTH_DIR_INFORMATION	pFBDInfo = (PFILE_BOTH_DIR_INFORMATION)Infobuf;

	PAGED_CODE( );

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	Status = NtQueryDirectoryFile(pFileHandle->fsh_FileHandle,
							  NULL,NULL,NULL,
							  &IoStsBlk,
							  Infobuf,
							  sizeof(Infobuf),
							  FileBothDirectoryInformation,
							  True,
							  pShortname,
							  False);
	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
								("NtQueryDirectoryFile returned 0x%lx\n",Status) );
	// Do not errorlog if an error occurs (usually STATUS_NO_SUCH_FILE) because
	// this normally happens when someone is creating a file/dir by SHORTNAME
	// and it does not yet exist.  This would not be an error.
	if (NT_SUCCESS(Status))
	{
			uName.Length =
			uName.MaximumLength = (USHORT)pFBDInfo->FileNameLength;
			uName.Buffer = pFBDInfo->FileName;
		//if (pFBDInfo->FileNameLength/sizeof(WCHAR) > AFP_FILENAME_LEN)
		if ((RtlUnicodeStringToAnsiSize(&uName)-1) > AFP_FILENAME_LEN)
		{
			// NTFS name is longer than 31 chars, use the shortname
			uName.Length =
			uName.MaximumLength = (USHORT)pFBDInfo->ShortNameLength;
			uName.Buffer = pFBDInfo->ShortName;
		}
		else
		{
			uName.Length =
			uName.MaximumLength = (USHORT)pFBDInfo->FileNameLength;
			uName.Buffer = pFBDInfo->FileName;
		}
		AfpCopyUnicodeString(pLongName, &uName);
		ASSERT(pLongName->Length == uName.Length);
	}
	return Status;
}


/***	AfpIoQueryShortName
 *
 *	Get the short name associated with a file. Caller makes sure that
 *	the buffer is big enough to handle the short name.
 */
AFPSTATUS FASTCALL
AfpIoQueryShortName(
	IN	PFILESYSHANDLE		pFileHandle,
	OUT	PANSI_STRING		pName
)
{
	LONGLONG       ShortNameBuf[(sizeof(FILE_NAME_INFORMATION) + AFP_SHORTNAME_LEN * sizeof(WCHAR))/sizeof(LONGLONG) + 1];
	NTSTATUS				Status;
	IO_STATUS_BLOCK			IoStsBlk;
	UNICODE_STRING			uName;

	PAGED_CODE( );

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	// Query for the alternate name
	Status = NtQueryInformationFile(pFileHandle->fsh_FileHandle,
				&IoStsBlk, ShortNameBuf, sizeof(ShortNameBuf),
				FileAlternateNameInformation);

	if (!NT_SUCCESS(Status))
	{
		AFPLOG_ERROR(AFPSRVMSG_CANT_GET_FILENAME,
					 Status,
					 NULL,
					 0,
					 NULL);
		Status = AFP_ERR_MISC;	// What else can we do
	}
	else
	{
		uName.Length =
		uName.MaximumLength = (USHORT)(((PFILE_NAME_INFORMATION)ShortNameBuf)->FileNameLength);
		uName.Buffer = ((PFILE_NAME_INFORMATION)ShortNameBuf)->FileName;

		if (!NT_SUCCESS(AfpConvertMungedUnicodeToAnsi(&uName, pName)))
			Status = AFP_ERR_MISC;	// What else can we do
	}

	return Status;
}


/***	AfpIoQueryStreams
 *
 *	Get the names of all the streams that a file has. Memory is allocated out
 *	of non-paged pool to hold the stream names. These have to be freed by the
 *	caller.
 */
PSTREAM_INFO FASTCALL
AfpIoQueryStreams(
	IN	PFILESYSHANDLE		pFileHandle

)
{
	PFILE_STREAM_INFORMATION	pStreamBuf;
	PBYTE						pBuffer;
	NTSTATUS					Status = STATUS_SUCCESS;
	IO_STATUS_BLOCK				IoStsBlk;
	DWORD						BufferSize;
	LONGLONG					Buffer[512/sizeof(LONGLONG) + 1];
	PSTREAM_INFO				pStreams = NULL;

	PAGED_CODE( );

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	pBuffer = (PBYTE)Buffer;
	BufferSize = sizeof(Buffer);
	do
	{
		if (Status != STATUS_SUCCESS)
		{
			if (pBuffer != (PBYTE)Buffer)
				AfpFreeMemory(pBuffer);

			BufferSize *= 2;
			if ((pBuffer = AfpAllocNonPagedMemory(BufferSize)) == NULL)
			{
				Status = STATUS_NO_MEMORY;
				break;
			}
		}

		// Query for the stream information
		Status = NtQueryInformationFile(pFileHandle->fsh_FileHandle,
										&IoStsBlk,
										pBuffer,
										BufferSize,
										FileStreamInformation);

	} while ((Status != STATUS_SUCCESS) &&
			 ((Status == STATUS_BUFFER_OVERFLOW) ||
			  (Status == STATUS_MORE_ENTRIES)));

	if (NT_SUCCESS(Status)) do
	{
		USHORT	i, NumStreams = 1;
		USHORT	TotalBufferSize = 0;
		PBYTE	NamePtr;

		// Make a pass thru the buffer and figure out the # of streams and then
		// allocate memory to hold the information
		pStreamBuf = (PFILE_STREAM_INFORMATION)pBuffer;
		if (IoStsBlk.Information != 0)
		{
			pStreamBuf = (PFILE_STREAM_INFORMATION)pBuffer;
			for (NumStreams = 1,
				 TotalBufferSize = (USHORT)(pStreamBuf->StreamNameLength + sizeof(WCHAR));
				 NOTHING; NumStreams++)
			{
				if (pStreamBuf->NextEntryOffset == 0)
					break;

				pStreamBuf = (PFILE_STREAM_INFORMATION)((PBYTE)pStreamBuf +
												pStreamBuf->NextEntryOffset);
				TotalBufferSize += (USHORT)(pStreamBuf->StreamNameLength + sizeof(WCHAR));
			}
			NumStreams ++;
		}

		// Now allocate space for the streams
		if ((pStreams = (PSTREAM_INFO)AfpAllocNonPagedMemory(TotalBufferSize +
									(NumStreams * sizeof(STREAM_INFO)))) == NULL)
		{
			Status = AFP_ERR_MISC;
			break;
		}

		// The end is marked by an empty string
		pStreams[NumStreams-1].si_StreamName.Buffer = NULL;
		pStreams[NumStreams-1].si_StreamName.Length =
		pStreams[NumStreams-1].si_StreamName.MaximumLength = 0;
		pStreams[NumStreams-1].si_StreamSize.QuadPart = 0;

		// Now initialize the array
		NamePtr = (PBYTE)pStreams + (NumStreams * sizeof(STREAM_INFO));
		pStreamBuf = (PFILE_STREAM_INFORMATION)pBuffer;
		for (i = 0; NumStreams-1 != 0; i++)
		{
			PUNICODE_STRING	pStream;

			pStream = &pStreams[i].si_StreamName;

			pStream->Buffer = (LPWSTR)NamePtr;
			pStream->Length = (USHORT)(pStreamBuf->StreamNameLength);
			pStream->MaximumLength = pStream->Length + sizeof(WCHAR);
			pStreams[i].si_StreamSize = pStreamBuf->StreamSize;
			RtlCopyMemory(NamePtr,
						  pStreamBuf->StreamName,
						  pStreamBuf->StreamNameLength);

			NamePtr += pStream->MaximumLength;

			if (pStreamBuf->NextEntryOffset == 0)
				break;

			pStreamBuf = (PFILE_STREAM_INFORMATION)((PBYTE)pStreamBuf +
												pStreamBuf->NextEntryOffset);
		}
	} while (False);

	if (!NT_SUCCESS(Status))
	{
		DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
				("AfpIoQueryStreams: Failed %lx\n", Status));

		// Free up any memory that has been allocated
		if (pStreams != NULL)
			AfpFreeMemory(pStreams);

		// We get the following error for non-NTFS volumes, if this case simply assume it to be
		// CDFS and return the data stream.
		if (Status == STATUS_INVALID_PARAMETER)
		{
			if ((pStreams = (PSTREAM_INFO)AfpAllocNonPagedMemory((2*sizeof(STREAM_INFO)) +
														DataStreamName.MaximumLength)) != NULL)
			{
				pStreams[0].si_StreamName.Buffer = (PWCHAR)((PBYTE)pStreams + 2*sizeof(STREAM_INFO));
				pStreams[0].si_StreamName.Length = DataStreamName.Length;
				pStreams[0].si_StreamName.MaximumLength = DataStreamName.MaximumLength;
				RtlCopyMemory(pStreams[0].si_StreamName.Buffer,
							  DataStreamName.Buffer,
							  DataStreamName.MaximumLength);
				AfpIoQuerySize(pFileHandle, &pStreams[0].si_StreamSize);
				pStreams[1].si_StreamName.Length =
				pStreams[1].si_StreamName.MaximumLength = 0;
				pStreams[1].si_StreamName.Buffer = NULL;
			}
		}
		else
		{
			AFPLOG_HERROR(AFPSRVMSG_CANT_GET_STREAMS,
						  Status,
						  NULL,
						  0,
						  pFileHandle->fsh_FileHandle);
		}
	}

	if ((pBuffer != NULL) && (pBuffer != (PBYTE)Buffer))
		AfpFreeMemory(pBuffer);

	return pStreams;
}


/***	AfpIoMarkFileForDelete
 *
 *	Mark an open file as deleted.  Returns NTSTATUS, not AFPSTATUS.
 */
NTSTATUS
AfpIoMarkFileForDelete(
	IN	PFILESYSHANDLE	pFileHandle,
	IN	PVOLDESC		pVolDesc			OPTIONAL, // only if pNotifyPath
	IN	PUNICODE_STRING pNotifyPath 		OPTIONAL,
	IN	PUNICODE_STRING pNotifyParentPath 	OPTIONAL
)
{
	NTSTATUS						rc;
	IO_STATUS_BLOCK					IoStsBlk;
	FILE_DISPOSITION_INFORMATION	fdispinfo;
#ifdef	PROFILING
	TIME							TimeS, TimeE, TimeD;

	AfpGetPerfCounter(&TimeS);
#endif

	PAGED_CODE( );

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	fdispinfo.DeleteFile = True;
	rc = NtSetInformationFile(pFileHandle->fsh_FileHandle,
							  &IoStsBlk,
							  &fdispinfo,
							  sizeof(fdispinfo),
							  FileDispositionInformation);
	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoMarkFileForDelete: NtSetInfoFile returned 0x%lx\n",rc) );

	if (ARGUMENT_PRESENT(pNotifyPath) &&
		!EXCLUSIVE_VOLUME(pVolDesc))
	{
		ASSERT(VALID_VOLDESC(pVolDesc));
		// Do not queue for exclusive volumes
		if (NT_SUCCESS(rc))
		{
			AfpQueueOurChange(pVolDesc,
							  FILE_ACTION_REMOVED,
							  pNotifyPath,
							  pNotifyParentPath);
		}
	}

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_DeleteCount);
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_DeleteTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	return rc;
}

/***	AfpIoQueryDirectoryFile
 *
 *	Enumerate a directory.
 *	Note this must return NTSTATUS in order for the caller to know when to
 *	stop enumerating.
 */
NTSTATUS
AfpIoQueryDirectoryFile(
	IN	PFILESYSHANDLE	pFileHandle,
	OUT	PVOID			Enumbuf,	// type depends on FileInfoClass
	IN	ULONG			Enumbuflen,
	IN	ULONG			FileInfoClass,
	IN	BOOLEAN			ReturnSingleEntry,
	IN	BOOLEAN			RestartScan,
	IN	PUNICODE_STRING pString			OPTIONAL
)
{
	NTSTATUS		rc;
	IO_STATUS_BLOCK	IoStsBlk;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoQueryDirectoryFile entered\n"));

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	rc = NtQueryDirectoryFile(pFileHandle->fsh_FileHandle,
							  NULL,
							  NULL,
							  NULL,
							  &IoStsBlk,
							  Enumbuf,
							  Enumbuflen,
							  FileInfoClass,
							  ReturnSingleEntry,
							  pString,
							  RestartScan);
	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("NtQueryDirectoryFile returned 0x%lx\n",rc) );

	return rc;
}


/***	AfpIoQueryBasicInfo
 *
 *	Query FILE_BASIC_INFO for a handle.
 */
NTSTATUS
AfpIoQueryBasicInfo(
	IN	PFILESYSHANDLE	pFileHandle,
	OUT	PVOID			BasicInfobuf
)
{
	NTSTATUS		rc;
	IO_STATUS_BLOCK	IoStsBlk;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoQueryBasicInfo entered\n"));

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	rc = NtQueryInformationFile(pFileHandle->fsh_FileHandle,
								&IoStsBlk,
								BasicInfobuf,
								sizeof(FILE_BASIC_INFORMATION),
								FileBasicInformation);
	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoQuerybasicInfo: NtQueryInformationFile returned 0x%lx\n",rc) );

	return rc;
}


/***	AfpIoClose
 *
 *	Close the File/Fork/Directory.
 */
AFPSTATUS FASTCALL
AfpIoClose(
	IN	PFILESYSHANDLE		pFileHandle
)
{
	NTSTATUS		Status;
	BOOLEAN			Internal;
#ifdef	PROFILING
	TIME			TimeS, TimeE, TimeD;

	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_CloseCount);
	AfpGetPerfCounter(&TimeS);
#endif

	PAGED_CODE ();

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoClose entered\n"));

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	Internal = INTERNAL_HANDLE(pFileHandle);
	afpUpdateOpenFiles(Internal, False);

	ObDereferenceObject(AfpGetRealFileObject(pFileHandle->fsh_FileObject));

	Status = NtClose(pFileHandle->fsh_FileHandle);
	pFileHandle->fsh_FileHandle = NULL;

	ASSERT(NT_SUCCESS(Status));

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_CloseTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	return AFP_ERR_NONE;
}


/***	AfpIoQueryVolumeSize
 *
 *	Get the volume size and free space.
 *
 *	Called by Admin thread and Scavenger thread
 */
AFPSTATUS
AfpIoQueryVolumeSize(
	IN	PVOLDESC		pVolDesc,
	OUT LARGE_INTEGER  *pFreeBytes,
	OUT	LARGE_INTEGER  *pVolumeSize OPTIONAL
)
{
	FILE_FS_SIZE_INFORMATION	fssizeinfo;
	IO_STATUS_BLOCK				IoStsBlk;
	NTSTATUS					rc;
	LONG						BytesPerAllocationUnit;
	LARGE_INTEGER				FreeBytes, VolumeSize;


	PAGED_CODE( );

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoQueryVolumeSize entered\n"));

	ASSERT(VALID_VOLDESC(pVolDesc) && VALID_FSH(&pVolDesc->vds_hRootDir) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	rc = NtQueryVolumeInformationFile(pVolDesc->vds_hRootDir.fsh_FileHandle,
									  &IoStsBlk,
									  (PVOID)&fssizeinfo,
									  sizeof(fssizeinfo),
									  FileFsSizeInformation);

	if (!NT_SUCCESS(rc))
	{
	        DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
			("AfpIoQueryVolumeSize: NtQueryVolInfoFile returned 0x%lx\n",rc));

		return rc;
	}

	BytesPerAllocationUnit =
		(LONG)(fssizeinfo.BytesPerSector * fssizeinfo.SectorsPerAllocationUnit);

	if (ARGUMENT_PRESENT(pVolumeSize))
	{
		VolumeSize = RtlExtendedIntegerMultiply(fssizeinfo.TotalAllocationUnits,
								BytesPerAllocationUnit);

		*pVolumeSize = VolumeSize;
	}

	FreeBytes  = RtlExtendedIntegerMultiply(fssizeinfo.AvailableAllocationUnits,
											BytesPerAllocationUnit);

	*pFreeBytes = FreeBytes;

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
				("AfpIoQueryVolumeSize: volume size=%lu, freebytes=%lu\n",
				VolumeSize.LowPart, FreeBytes.LowPart));

    pVolDesc->vds_AllocationBlockSize = BytesPerAllocationUnit;

	return STATUS_SUCCESS;
}


/***	AfpIoMoveAndOrRename
 *
 *	Calls NtSetInformationFile with name information in order to rename, move,
 *	or move AND rename a file or directory.  pNewName must be a node name.
 *	The pfshNewDir parameter is required for a Move operation, and is
 *	an open handle to the target parent directory of the item to be moved.
 *
 *	Retain the last change/modified time in this case.
 */
AFPSTATUS
AfpIoMoveAndOrRename(
	IN PFILESYSHANDLE	pfshFile,
	IN PFILESYSHANDLE	pfshNewParent		OPTIONAL,	// Supply for Move operation
	IN PUNICODE_STRING	pNewName,
	IN PVOLDESC			pVolDesc			OPTIONAL,	// only if NotifyPath
	IN PUNICODE_STRING	pNotifyPath1		OPTIONAL,	// REMOVE or RENAME action
	IN PUNICODE_STRING	pNotifyParentPath1	OPTIONAL,
	IN PUNICODE_STRING	pNotifyPath2		OPTIONAL,	// ADDED action
	IN PUNICODE_STRING	pNotifyParentPath2	OPTIONAL
)
{
	NTSTATUS					Status;
	IO_STATUS_BLOCK				iosb;
	BOOLEAN						Queue = False;
	PFILE_RENAME_INFORMATION	pFRenameInfo;
	// this has to be at least as big as AfpExchangeName
	BYTE buffer[sizeof(FILE_RENAME_INFORMATION) + 42 * sizeof(WCHAR)];

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoMoveAndOrRename entered\n"));

	ASSERT(VALID_FSH(pfshFile) && (KeGetCurrentIrql() < DISPATCH_LEVEL));
	pFRenameInfo = (PFILE_RENAME_INFORMATION)buffer;

	pFRenameInfo->RootDirectory = NULL;
	if (ARGUMENT_PRESENT(pfshNewParent))
	{
		// its a move operation
		ASSERT(VALID_FSH(pfshNewParent));
		pFRenameInfo->RootDirectory = pfshNewParent->fsh_FileHandle;
	}

	pFRenameInfo->FileNameLength = pNewName->Length;
	RtlCopyMemory(pFRenameInfo->FileName, pNewName->Buffer, pNewName->Length);
	pFRenameInfo->ReplaceIfExists = False;

	// Do not queue for exclusive volumes
	if (ARGUMENT_PRESENT(pNotifyPath1) &&
		!EXCLUSIVE_VOLUME(pVolDesc))
	{
		ASSERT(VALID_VOLDESC(pVolDesc));

		Queue = True;
		if (ARGUMENT_PRESENT(pNotifyPath2))
		{
			// move operation
			ASSERT(ARGUMENT_PRESENT(pfshNewParent));
			AfpQueueOurChange(pVolDesc,
							  FILE_ACTION_REMOVED,
							  pNotifyPath1,
							  pNotifyParentPath1);
			AfpQueueOurChange(pVolDesc,
							  FILE_ACTION_ADDED,
							  pNotifyPath2,
							  pNotifyParentPath2);
		}
		else
		{
			// rename operation
			ASSERT(!ARGUMENT_PRESENT(pfshNewParent));
			AfpQueueOurChange(pVolDesc,
							  FILE_ACTION_RENAMED_OLD_NAME,
							  pNotifyPath1,
							  pNotifyParentPath1);
		}
	}

	Status = NtSetInformationFile(pfshFile->fsh_FileHandle,
								  &iosb,
								  pFRenameInfo,
								  sizeof(*pFRenameInfo) + pFRenameInfo->FileNameLength,
								  FileRenameInformation);

    if (!NT_SUCCESS(Status))
    {
	    DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoMoveAndOrRename: NtSetInfoFile returned 0x%lx\n",Status));
    }

	if (Queue)
	{
		// Undo on failure
		if (!NT_SUCCESS(Status))
		{
			if (ARGUMENT_PRESENT(pNotifyPath2))
			{
				// move operation
				ASSERT(ARGUMENT_PRESENT(pfshNewParent));
				AfpDequeueOurChange(pVolDesc,
									FILE_ACTION_REMOVED,
									pNotifyPath1,
									pNotifyParentPath1);
				AfpDequeueOurChange(pVolDesc,
									FILE_ACTION_ADDED,
									pNotifyPath2,
									pNotifyParentPath2);
			}
			else
			{
				// rename operation
				ASSERT(!ARGUMENT_PRESENT(pfshNewParent));
				AfpDequeueOurChange(pVolDesc,
									FILE_ACTION_RENAMED_OLD_NAME,
									pNotifyPath1,
									pNotifyParentPath1);
			}
		}
	}

	if (!NT_SUCCESS(Status))
		Status = AfpIoConvertNTStatusToAfpStatus(Status);

	return Status;
}


/***	AfpIoCopyFile1
 *
 *	Copy phSrcFile to phDstDir directory with the name of pNewName.  Returns
 *	the handles to the streams on the newly created file (open with DELETE access.
 *	Caller must close all the handles after copying the data.
 */
AFPSTATUS
AfpIoCopyFile1(
	IN	PFILESYSHANDLE		phSrcFile,
	IN	PFILESYSHANDLE		phDstDir,
	IN	PUNICODE_STRING		pNewName,
	IN	PVOLDESC			pVolDesc			OPTIONAL,	// only if pNotifyPath
	IN	PUNICODE_STRING		pNotifyPath			OPTIONAL,
	IN	PUNICODE_STRING		pNotifyParentPath	OPTIONAL,
	OUT	PCOPY_FILE_INFO		pCopyFileInfo
)
{
	NTSTATUS		Status = STATUS_SUCCESS;
	PUNICODE_STRING	pStreamName;
	PSTREAM_INFO	pStreams = NULL, pCurStream;
	DWORD			CreateTime = 0, ModTime = 0;
	FILESYSHANDLE	hDstFile;
	LONG			NumStreams, i;
	IO_STATUS_BLOCK	IoStsBlk;

	PAGED_CODE( );

	ASSERT(VALID_FSH(phDstDir) && VALID_FSH(phSrcFile));

	do
	{
		hDstFile.fsh_FileHandle = NULL;

		// Create (soft) the destination file
		Status = AfpIoCreate(phDstDir,
							 AFP_STREAM_DATA,
							 pNewName,
							 FILEIO_ACCESS_WRITE | FILEIO_ACCESS_DELETE,
							 FILEIO_DENY_NONE,
							 FILEIO_OPEN_FILE,
							 FILEIO_CREATE_SOFT,
							 FILE_ATTRIBUTE_ARCHIVE,
							 True,
							 NULL,
							 &hDstFile,
							 NULL,
							 pVolDesc,
							 pNotifyPath,
							 pNotifyParentPath);

		if (!NT_SUCCESS(Status))
		{
			break;
		}

		// Get a list of all stream names of the source file
		if ((pStreams = AfpIoQueryStreams(phSrcFile)) != NULL)
		{
			for (pCurStream = pStreams, NumStreams = 0;
				 pCurStream->si_StreamName.Buffer != NULL;
				 pCurStream++, NumStreams ++)
				 NOTHING;

			// Allocate an array of handles for storing stream handles as we create them
			if (((pCopyFileInfo->cfi_SrcStreamHandle = (PFILESYSHANDLE)
							AfpAllocNonPagedMemory(sizeof(FILESYSHANDLE)*NumStreams)) == NULL) ||
				((pCopyFileInfo->cfi_DstStreamHandle = (PFILESYSHANDLE)
							AfpAllocNonPagedMemory(sizeof(FILESYSHANDLE)*NumStreams)) == NULL))
			{
				if (pCopyFileInfo->cfi_SrcStreamHandle != NULL)
				{
					AfpFreeMemory(pCopyFileInfo->cfi_SrcStreamHandle);
                    pCopyFileInfo->cfi_SrcStreamHandle = NULL;
				}
				Status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}
			else
			{
				RtlZeroMemory(pCopyFileInfo->cfi_SrcStreamHandle, sizeof(FILESYSHANDLE)*NumStreams);
				RtlZeroMemory(pCopyFileInfo->cfi_DstStreamHandle, sizeof(FILESYSHANDLE)*NumStreams);
				pCopyFileInfo->cfi_SrcStreamHandle[0] = *phSrcFile;
				pCopyFileInfo->cfi_DstStreamHandle[0] = hDstFile;
				pCopyFileInfo->cfi_NumStreams = 1;
			}
		}
		else
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
				break;
		}

		for (pCurStream = pStreams, i = 1;	// Start index
			 NT_SUCCESS(Status) &&
			 ((pStreamName = &pCurStream->si_StreamName)->Buffer != NULL);
			 pCurStream++)
		{
			PFILESYSHANDLE	phdst;

			// For each stream, create it on the destination, open it on src,
			// set the size and lock the range. We already have the data forks
			// open, ignore Afp_AfpInfo streams since we are going to re-create
			// it again soon. Also ignore streams of 0 size.
			if (IS_INFO_STREAM(pStreamName) ||
				(pCurStream->si_StreamSize.QuadPart == 0))
			{
				continue;
			}
			if (!IS_DATA_STREAM(pStreamName))
			{
				Status = AfpIoOpen(	phSrcFile,
									AFP_STREAM_DATA,
									FILEIO_OPEN_FILE,
									pStreamName,
									FILEIO_ACCESS_READ,
									FILEIO_DENY_READ | FILEIO_DENY_WRITE,
									True,
									&pCopyFileInfo->cfi_SrcStreamHandle[i]);
				if (!NT_SUCCESS(Status))
				{
					break;
				}

				Status = AfpIoCreate(&hDstFile,
									 AFP_STREAM_DATA,
									 pStreamName,
									 FILEIO_ACCESS_WRITE,
									 FILEIO_DENY_READ | FILEIO_DENY_WRITE,
									 FILEIO_OPEN_FILE,
									 FILEIO_CREATE_SOFT,
									 0,
									 True,
									 NULL,
									 &pCopyFileInfo->cfi_DstStreamHandle[i],
									 NULL,
									 NULL,
									 NULL,
									 NULL);
				if (!NT_SUCCESS(Status))
				{
					break;
				}
				phdst = &pCopyFileInfo->cfi_DstStreamHandle[i];
				pCopyFileInfo->cfi_NumStreams ++;
				i ++;		// Onto the next stream
			}
			else	// IS_DATA_STREAM(pStreamName)
			{
				phdst = &hDstFile;
			}

			// Set the size of the new stream and lock it down
			Status = AfpIoSetSize(phdst, pCurStream->si_StreamSize.LowPart);
			if (!NT_SUCCESS(Status))
			{
				break;
			}

			NtLockFile(phdst,
					   NULL,
					   NULL,
					   NULL,
					   &IoStsBlk,
					   &LIZero,
					   &pCurStream->si_StreamSize,
					   0,
					   True,
					   True);
		}

		// We failed to create/open a stream
		if (!NT_SUCCESS(Status))
		{
			// Delete the new file we just created. The handle is closed below.
			AfpIoMarkFileForDelete(&hDstFile,
								   pVolDesc,
								   pNotifyPath,
								   pNotifyParentPath);

			// Close all the handles, Free the handle space.
			// DO NOT FREE THE SRC FILE HANDLE IN THE ERROR CASE.
			// The Destination has already been deleted above.
			for (i = 1; i < NumStreams; i++)
			{
				if (pCopyFileInfo->cfi_SrcStreamHandle[i].fsh_FileHandle != NULL)
				{
					AfpIoClose(&pCopyFileInfo->cfi_SrcStreamHandle[i]);
				}
				if (pCopyFileInfo->cfi_DstStreamHandle[i].fsh_FileHandle != NULL)
				{
					AfpIoClose(&pCopyFileInfo->cfi_DstStreamHandle[i]);
				}
			}

			if (pCopyFileInfo->cfi_SrcStreamHandle != NULL)
				AfpFreeMemory(pCopyFileInfo->cfi_SrcStreamHandle);
			if (pCopyFileInfo->cfi_DstStreamHandle)
				AfpFreeMemory(pCopyFileInfo->cfi_DstStreamHandle);

			RtlZeroMemory(pCopyFileInfo, sizeof(COPY_FILE_INFO));
		}
	} while (False);

	if (pStreams != NULL)
		AfpFreeMemory(pStreams);

	if (!NT_SUCCESS(Status) && (hDstFile.fsh_FileHandle != NULL))
	{
		AfpIoClose(&hDstFile);
	}

	if (!NT_SUCCESS(Status))
		Status = AfpIoConvertNTStatusToAfpStatus(Status);

	return Status;
}


/***	AfpIoCopyFile2
 *
 *	Phase 2 of the copy file. See AfpIoCopyFile1( above.
 *	The physical data is copied here.
 *	The relevant streams have been already created and locked.
 *  Destination file acquires the CreateTime and ModTime of the source file.
 */
AFPSTATUS
AfpIoCopyFile2(
	IN	PCOPY_FILE_INFO		pCopyFileInfo,
	IN	PVOLDESC			pVolDesc			OPTIONAL,	// only if pNotifyPath
	IN	PUNICODE_STRING		pNotifyPath			OPTIONAL,
	IN	PUNICODE_STRING		pNotifyParentPath	OPTIONAL
)
{
	NTSTATUS		Status = STATUS_SUCCESS;
	PBYTE			RWbuf;
	DWORD			CreateTime = 0;
	TIME			ModTime;
	LONG			i;
#define	RWBUFSIZE	1500		// So we can use secondary buffer from IO Pool.

	PAGED_CODE( );

	do
	{
		if ((RWbuf = AfpIOAllocBuffer(RWBUFSIZE)) == NULL)
		{
			Status = STATUS_NO_MEMORY;
			break;
		}

		for (i = 0; i < pCopyFileInfo->cfi_NumStreams; i++)
		{
			while (NT_SUCCESS(Status))
			{
				LONG	bytesRead;

				bytesRead = 0;

				// Read from src, write to dst
				Status = AfpIoRead(&pCopyFileInfo->cfi_SrcStreamHandle[i],
									NULL,
									RWBUFSIZE,
									&bytesRead,
									RWbuf);
				if (Status == AFP_ERR_EOF)
				{
					Status = STATUS_SUCCESS;
					break;
				}
				else if (NT_SUCCESS(Status))
				{
					Status = AfpIoWrite(&pCopyFileInfo->cfi_DstStreamHandle[i],
										NULL,
										bytesRead,
										RWbuf);
				}
			}
		}

		if (!NT_SUCCESS(Status))
		{
			// We failed to read/write a stream
			// Delete the new file we just created
			AfpIoMarkFileForDelete(&pCopyFileInfo->cfi_DstStreamHandle[0],
								   pVolDesc,
								   pNotifyPath,
								   pNotifyParentPath);
		}
	} while (False);

	if (RWbuf != NULL)
		AfpIOFreeBuffer(RWbuf);

	if (!NT_SUCCESS(Status))
		Status = AfpIoConvertNTStatusToAfpStatus(Status);

	return Status;
}


/***	AfpIoWait
 *
 *	Wait on a single object. This is a wrapper over	KeWaitForSingleObject.
 */
NTSTATUS FASTCALL
AfpIoWait(
	IN	PVOID			pObject,
	IN	PLARGE_INTEGER	pTimeOut	OPTIONAL
)
{
	NTSTATUS	Status;

	PAGED_CODE( );

	Status = KeWaitForSingleObject( pObject,
									UserRequest,
									KernelMode,
									False,
									pTimeOut);
	if (!NT_SUCCESS(Status))
	{
		AFPLOG_DDERROR(AFPSRVMSG_WAIT4SINGLE,
					   Status,
					   NULL,
					   0,
					   NULL);
	}

	return Status;
}


/***	AfpUpgradeHandle
 *
 *	Change a handles type from internal to client.
 */
VOID FASTCALL
AfpUpgradeHandle(
	IN	PFILESYSHANDLE	pFileHandle
)
{
	KIRQL	OldIrql;

	UPGRADE_HANDLE(pFileHandle);
	ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);

	AfpServerStatistics.stat_CurrentFilesOpen ++;
	AfpServerStatistics.stat_TotalFilesOpened ++;
	if (AfpServerStatistics.stat_CurrentFilesOpen >
							AfpServerStatistics.stat_MaxFilesOpened)
		AfpServerStatistics.stat_MaxFilesOpened =
							AfpServerStatistics.stat_CurrentFilesOpen;
	AfpServerStatistics.stat_CurrentInternalOpens --;

	RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);
}


/***	afpUpdateOpenFiles
 *
 *	Update statistics to indicate number of open files.
 */
LOCAL VOID FASTCALL
afpUpdateOpenFiles(
	IN	BOOLEAN	Internal,		// True for internal handles
	IN	BOOLEAN	Open			// True for open, False for close
)
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);
	if (Open)
	{
		if (!Internal)
		{
			AfpServerStatistics.stat_CurrentFilesOpen ++;
			AfpServerStatistics.stat_TotalFilesOpened ++;
			if (AfpServerStatistics.stat_CurrentFilesOpen >
									AfpServerStatistics.stat_MaxFilesOpened)
				AfpServerStatistics.stat_MaxFilesOpened =
									AfpServerStatistics.stat_CurrentFilesOpen;
		}
		else
		{
			AfpServerStatistics.stat_CurrentInternalOpens ++;
			AfpServerStatistics.stat_TotalInternalOpens ++;
			if (AfpServerStatistics.stat_CurrentInternalOpens >
									AfpServerStatistics.stat_MaxInternalOpens)
				AfpServerStatistics.stat_MaxInternalOpens =
									AfpServerStatistics.stat_CurrentInternalOpens;
		}
	}
	else
	{
		if (!Internal)
			 AfpServerStatistics.stat_CurrentFilesOpen --;
		else AfpServerStatistics.stat_CurrentInternalOpens --;
	}
	RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);
}



/***	AfpIoConvertNTStatusToAfpStatus
 *
 *	Map NT Status code to the closest AFP equivalents. Currently it only handles
 *	error codes from NtOpenFile and NtCreateFile.
 */
AFPSTATUS FASTCALL
AfpIoConvertNTStatusToAfpStatus(
	IN	NTSTATUS	Status
)
{
	AFPSTATUS	RetCode;

	PAGED_CODE( );

	ASSERT (!NT_SUCCESS(Status));

	if ((Status >= AFP_ERR_PWD_NEEDS_CHANGE) &&
		(Status <= AFP_ERR_ACCESS_DENIED))
	{
		// Status is already in mac format
		DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
			("AfpIoConvertNTStatusToAfpStatus: Status (%d) already in mac format!!\n", Status));

		return Status;
	}

	switch (Status)
	{
		case STATUS_OBJECT_PATH_INVALID:
		case STATUS_OBJECT_NAME_INVALID:
			RetCode = AFP_ERR_PARAM;
			break;

		case STATUS_OBJECT_PATH_NOT_FOUND:
		case STATUS_OBJECT_NAME_NOT_FOUND:
			RetCode = AFP_ERR_OBJECT_NOT_FOUND;
			break;

		case STATUS_OBJECT_NAME_COLLISION:
		case STATUS_OBJECT_NAME_EXISTS:
			RetCode = AFP_ERR_OBJECT_EXISTS;
			break;

		case STATUS_ACCESS_DENIED:
			RetCode = AFP_ERR_ACCESS_DENIED;
			break;

        case STATUS_QUOTA_EXCEEDED:
        case STATUS_DISK_FULL:
			RetCode = AFP_ERR_DISK_FULL;
			break;

		case STATUS_DIRECTORY_NOT_EMPTY:
			RetCode = AFP_ERR_DIR_NOT_EMPTY;
			break;

		case STATUS_SHARING_VIOLATION:
			RetCode = AFP_ERR_DENY_CONFLICT;
			break;

		default:
			RetCode = AFP_ERR_MISC;
			break;
	}
	return RetCode;
}

/***	AfpQueryPath
 *
 *	Given a file handle, get the full pathname of the file/dir. If the
 *	name is longer than MaximumBuf, then forget it and return an error.
 *	Caller must free the pPath.Buffer.
 */
NTSTATUS
AfpQueryPath(
	IN	HANDLE			FileHandle,
	IN	PUNICODE_STRING	pPath,
	IN	ULONG			MaximumBuf
)
{
	PFILE_NAME_INFORMATION	pNameinfo;
	IO_STATUS_BLOCK			iosb;
	NTSTATUS				Status;

	PAGED_CODE( );

	do
	{
		if ((pNameinfo = (PFILE_NAME_INFORMATION)AfpAllocNonPagedMemory(MaximumBuf)) == NULL)
		{
			Status = STATUS_NO_MEMORY;
			break;
		}

		Status = NtQueryInformationFile(FileHandle,
										&iosb,
										pNameinfo,
										MaximumBuf,
										FileNameInformation);
		if (!NT_SUCCESS(Status))
		{
			AfpFreeMemory(pNameinfo);
			break;
		}

		pPath->Length = pPath->MaximumLength = (USHORT) pNameinfo->FileNameLength;
		// Shift the name to the front of the buffer
		RtlMoveMemory(pNameinfo, &pNameinfo->FileName[0], pNameinfo->FileNameLength);
		pPath->Buffer = (PWCHAR)pNameinfo;
	} while (False);

	return Status;
}

/***	AfpIoIsSupportedDevice
 *
 *	AFP volumes can only be created on local disk or cdrom devices.
 *	(i.e. not network, virtual, etc. devices
 */
BOOLEAN FASTCALL
AfpIoIsSupportedDevice(
	IN	PFILESYSHANDLE	pFileHandle,
	OUT	PDWORD			pFlags
)
{
	IO_STATUS_BLOCK					IoStsBlk;
	FILE_FS_DEVICE_INFORMATION		DevInfo;
	PFILE_FS_ATTRIBUTE_INFORMATION	pFSAttrInfo;
	LONGLONG		        Buffer[(sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + AFP_FSNAME_BUFLEN)/sizeof(LONGLONG) + 1];
	UNICODE_STRING					uFsName;
	NTSTATUS						Status;
	BOOLEAN							RetCode = False;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			 ("AfpIoIsSupportedDevice entered\n"));

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	do
	{
		Status = NtQueryVolumeInformationFile(pFileHandle->fsh_FileHandle,
											  &IoStsBlk,
											  (PVOID)&DevInfo,
											  sizeof(DevInfo),
											  FileFsDeviceInformation);

		DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
				("AfpIoIsSupportedDevice: NtQueryVolInfFile returned 0x%lx\n", Status));

		if (!NT_SUCCESS(Status) ||
			((DevInfo.DeviceType != FILE_DEVICE_DISK) &&
			 (DevInfo.DeviceType != FILE_DEVICE_CD_ROM)))
		{
			break;
		}

		// need to check if this is NTFS, CDFS or unsupported FS
		pFSAttrInfo = (PFILE_FS_ATTRIBUTE_INFORMATION)Buffer;

		Status = NtQueryVolumeInformationFile(pFileHandle->fsh_FileHandle,
											  &IoStsBlk,
											  (PVOID)pFSAttrInfo,
											  sizeof(Buffer),
											  FileFsAttributeInformation);

		DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
				("AfpIoIsSupportedDevice: NtQueryVolInfFile returned 0x%lx\n", Status));

		if (!NT_SUCCESS(Status))
		{
			break;
		}

        if (pFSAttrInfo->FileSystemAttributes & FILE_VOLUME_QUOTAS)
        {
			*pFlags |= VOLUME_DISKQUOTA_ENABLED;
        }

		// convert returned non-null terminated file system name to counted unicode
		AfpInitUnicodeStringWithNonNullTerm(&uFsName,
										   (USHORT)pFSAttrInfo->FileSystemNameLength,
										   pFSAttrInfo->FileSystemName);
		if (EQUAL_UNICODE_STRING(&afpNTFSName, &uFsName, True))
		{
			// its an NTFS volume
			*pFlags |= VOLUME_NTFS;
			RetCode = True;
		}
		else if (EQUAL_UNICODE_STRING(&afpCDFSName, &uFsName, True))
		{
			// its a CDFS volume
			*pFlags |= AFP_VOLUME_READONLY;
			RetCode = True;
		}
		else if (EQUAL_UNICODE_STRING(&afpAHFSName, &uFsName, True))
		{
			// its a volume on CD with HFS support
			*pFlags |= (AFP_VOLUME_READONLY | VOLUME_CD_HFS);
			RetCode = True;
		}
		else
		{
			// an unsupported file system
			DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
					("AfpIoIsSupportedDevice: unsupported file system: name=%Z, CDString=%Z\n", &uFsName, &afpCDFSName));
			break;
		}
	} while (False);

	if (!NT_SUCCESS(Status))
	{
		AFPLOG_HERROR(AFPSRVMSG_CANT_GET_FSNAME,
					  Status,
					  NULL,
					  0,
					  pFileHandle->fsh_FileHandle);
	}

	return RetCode;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\fileio.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fileio.h

Abstract:

	This file defines the file I/O prototypes

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	18 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_FILEIO_
#define	_FILEIO_

#define	FILEIO_OPEN_FILE					(FILE_NON_DIRECTORY_FILE		|\
											 FILE_RANDOM_ACCESS				|\
											 FILE_SYNCHRONOUS_IO_NONALERT)

#define	FILEIO_OPEN_FILE_SEQ				(FILE_NON_DIRECTORY_FILE		|\
											 FILE_SEQUENTIAL_ONLY			|\
											 FILE_NO_INTERMEDIATE_BUFFERING	|\
											 FILE_SYNCHRONOUS_IO_NONALERT)

#define	FILEIO_OPEN_DIR						(FILE_DIRECTORY_FILE			|\
											 FILE_SYNCHRONOUS_IO_NONALERT)

#define FILEIO_OPEN_EITHER					(FILE_SYNCHRONOUS_IO_NONALERT)

#define FILEIO_ACCESS_NONE					(FILE_READ_ATTRIBUTES			|\
											 SYNCHRONIZE)
#define FILEIO_ACCESS_READ					(GENERIC_READ					|\
											 SYNCHRONIZE)
#define FILEIO_ACCESS_WRITE					(GENERIC_WRITE					|\
											 SYNCHRONIZE)
#define FILEIO_ACCESS_READWRITE				(FILEIO_ACCESS_READ				|\
											 FILEIO_ACCESS_WRITE)
#define	FILEIO_ACCESS_DELETE				(DELETE							|\
											 SYNCHRONIZE)
#define	FILEIO_ACCESS_MAX					4

// Note that READ and WRITE share modes are enforced on a per-stream
// basis, whereas DELETE share mode is still per-file.  We must include
// SHARE_DELETE even for deny-all since things like cmd.exe will open
// a directory for DELETE when cd-ing into that directory.  If we were to
// then try to open the AFP_AfpInfo stream with no share delete access it
// would fail.  Since mac has no concept of share delete this is acceptible.
// In addition, mac must open for delete in order to rename/move a file/dir.
//
// The sharing modes are strictly per-stream except for the following
// exceptions:
//
// To delete the entire file, the caller must open the unnamed data
// stream (file) or the directory for delete access.
//
// If an open of any stream does not permit delete access to that stream
// then no one may open the file for for delete access.  Conversely if
// the file is already opened for delete access then any open of a
// stream which denies delete access will fail with a sharing violation.
//
// The reasoning is that if someone wants to prevent a stream from being
// deleted then they must prevent anyone from opening the file for
// delete.

#define	FILEIO_DENY_NONE					(FILE_SHARE_READ				|\
											 FILE_SHARE_WRITE				|\
											 FILE_SHARE_DELETE)
#define	FILEIO_DENY_READ					(FILE_SHARE_WRITE				|\
											 FILE_SHARE_DELETE)
#define	FILEIO_DENY_WRITE					(FILE_SHARE_READ				|\
											 FILE_SHARE_DELETE)
#define	FILEIO_DENY_ALL						FILE_SHARE_DELETE
#define	FILEIO_DENY_MAX						4

#define FILEIO_CREATE_SOFT					FILE_CREATE
#define FILEIO_CREATE_HARD					FILE_SUPERSEDE
#define	FILEIO_CREATE_INTERNAL				FILE_OPEN_IF
#define FILEIO_CREATE_MAX					2

// do NOT change the order of these unless you also change the code in
// afpVolumeCloseHandleAndFreeDesc for deleting streams from volume root.
#define	AFP_STREAM_DATA						0
#define	AFP_STREAM_RESC						1
#define	AFP_STREAM_IDDB						2
#define	AFP_STREAM_DT						3
#define	AFP_STREAM_INFO						4
#define	AFP_STREAM_COMM						5
#define	AFP_STREAM_MAX						6

// directories to ignore when enumerating
GLOBAL	UNICODE_STRING 		Dot EQU {0, 0, NULL};
GLOBAL	UNICODE_STRING 		DotDot EQU {0, 0, NULL};

// stream not to create during CopyFile
GLOBAL	UNICODE_STRING		DataStreamName EQU {0, 0, NULL};
#define IS_DATA_STREAM(pUnicodeStreamName) \
		EQUAL_UNICODE_STRING(pUnicodeStreamName, &DataStreamName, False)

GLOBAL	UNICODE_STRING		FullCommentStreamName EQU {0, 0, NULL};
#define IS_COMMENT_STREAM(pUnicodeStreamName) \
		EQUAL_UNICODE_STRING(pUnicodeStreamName, &FullCommentStreamName, False)

GLOBAL	UNICODE_STRING		FullResourceStreamName EQU {0, 0, NULL};
#define IS_RESOURCE_STREAM(pUnicodeStreamName) \
		EQUAL_UNICODE_STRING(pUnicodeStreamName, &FullResourceStreamName, True)

GLOBAL	UNICODE_STRING		FullInfoStreamName EQU {0, 0, NULL};
#define IS_INFO_STREAM(pUnicodeStreamName) \
		EQUAL_UNICODE_STRING(pUnicodeStreamName, &FullInfoStreamName, True)

// temporary filename when renaming files for FpExchangeFiles
// the name is composed of 40 spaces
#define AFP_TEMP_EXCHANGE_NAME	L"                                        "
GLOBAL 	UNICODE_STRING		AfpExchangeName EQU {0, 0, NULL};

GLOBAL	UNICODE_STRING		DosDevices EQU {0, 0, NULL};

GLOBAL	UNICODE_STRING		AfpStreams[AFP_STREAM_MAX] EQU { 0 };

#define	AfpIdDbStream						AfpStreams[AFP_STREAM_IDDB]
#define	AfpDesktopStream					AfpStreams[AFP_STREAM_DT]
#define	AfpResourceStream					AfpStreams[AFP_STREAM_RESC]
#define	AfpInfoStream						AfpStreams[AFP_STREAM_INFO]
#define	AfpCommentStream					AfpStreams[AFP_STREAM_COMM]
#define	AfpDataStream						AfpStreams[AFP_STREAM_DATA]

#pragma warning(disable:4010)

#if 0
GLOBAL	DWORD	AfpAccessModes[FILEIO_ACCESS_MAX] EQU		\
{															\
	FILEIO_ACCESS_NONE,										\
	FILEIO_ACCESS_READ,										\
	FILEIO_ACCESS_WRITE,									\
	FILEIO_ACCESS_READWRITE									\
};
#endif

GLOBAL	DWORD	AfpDenyModes[FILEIO_DENY_MAX] EQU			\
{															\
	FILEIO_DENY_NONE,										\
	FILEIO_DENY_READ,										\
	FILEIO_DENY_WRITE,										\
	FILEIO_DENY_ALL											\
};

GLOBAL	DWORD	AfpCreateDispositions[FILEIO_CREATE_MAX] EQU\
{															\
	FILEIO_CREATE_SOFT,										\
	FILEIO_CREATE_HARD										\
};

// This structure is used by file-system interface code

#if DBG
#define	FSH_SIGNATURE		*(DWORD *)"FSH"
#define	VALID_FSH(pFSH)		(((pFSH) != NULL) && \
							 ((pFSH)->fsh_FileHandle != NULL) && \
							 ((pFSH)->fsh_FileObject != NULL) && \
							 ((pFSH)->Signature == FSH_SIGNATURE))
#else
#define	VALID_FSH(pFSH)		(((pFSH)->fsh_FileHandle != NULL) && \
							 ((pFSH)->fsh_FileObject != NULL))
#endif

// NOTE: We overload the FileObject pointer to keep track of internal/client
//		 handles. We always mask off this while actually accessing it. The
//		 assumption here is that this pointer will never be odd.
//
#define	FSH_INTERNAL_MASK	1
#define	AfpGetRealFileObject(pFileObject)	(PFILE_OBJECT)((ULONG_PTR)(pFileObject) & ~FSH_INTERNAL_MASK)
typedef struct _FileSysHandle
{
#if	DBG
	DWORD			Signature;
#endif
	HANDLE			fsh_FileHandle;			// Host file handle
	PFILE_OBJECT	fsh_FileObject;			// File Object corres. to the file handle
	PDEVICE_OBJECT	fsh_DeviceObject;		// Device Object corres. to the file handle
} FILESYSHANDLE, *PFILESYSHANDLE;

#define	INTERNAL_HANDLE(pFSHandle)	((ULONG_PTR)((pFSHandle)->fsh_FileObject) & FSH_INTERNAL_MASK) ? True : False
#define	UPGRADE_HANDLE(pFSHandle)	((ULONG_PTR)((pFSHandle)->fsh_FileObject) &= ~FSH_INTERNAL_MASK)

typedef	struct _StreamsInfo
{
	UNICODE_STRING	si_StreamName;
	LARGE_INTEGER	si_StreamSize;
} STREAM_INFO, *PSTREAM_INFO;

typedef	struct _CopyFileInfo
{
	LONG			cfi_NumStreams;
	PFILESYSHANDLE	cfi_SrcStreamHandle;
	PFILESYSHANDLE	cfi_DstStreamHandle;
} COPY_FILE_INFO, *PCOPY_FILE_INFO;


#define AFP_RETRIEVE_MODTIME    1
#define AFP_RESTORE_MODTIME     2

extern
NTSTATUS
AfpFileIoInit(
	VOID
);


extern
VOID
AfpFileIoDeInit(
	VOID
);


extern
AFPSTATUS
AfpIoOpen(
	IN	PFILESYSHANDLE		hRelative,
	IN	DWORD				StreamId,
	IN	DWORD				Options,
	IN	PUNICODE_STRING		pObject,
	IN	DWORD				AfpAccess,
	IN	DWORD				AfpDenyMode,
	IN	BOOLEAN				CheckAccess,
	OUT	PFILESYSHANDLE		pFileSysHandle
);


extern
AFPSTATUS
AfpIoCreate(
	IN	PFILESYSHANDLE		hRelative,						// create relative to this
	IN	DWORD				StreamId,   					// Id of stream to create
	IN	PUNICODE_STRING		pObject,						// Name of file
	IN	DWORD				AfpAccess,						// FILEIO_ACCESS_XXX desired access
	IN	DWORD				AfpDenyMode,					// FILEIO_DENY_XXX
	IN	DWORD				CreateOptions,					// File/Directory etc.
	IN	DWORD				Disposition,					// Soft or hard create
	IN	DWORD				Attributes,						// hidden, archive, normal, etc.
	IN	BOOLEAN				CheckAccess,                	// If TRUE, enforce security
	IN	PSECURITY_DESCRIPTOR pSecDesc			OPTIONAL, 	// Security descriptor to slap on
	OUT	PFILESYSHANDLE		pFileSysHandle,             	// Place holder for the handle
	OUT PDWORD				pInformation		OPTIONAL,	// file opened, created, etc.
 	IN	struct _VolDesc *	pVolDesc			OPTIONAL,	// only if NotifyPath
	IN	PUNICODE_STRING		pNotifyPath			OPTIONAL,
	IN	PUNICODE_STRING		pNotifyParentPath	OPTIONAL
);


extern
AFPSTATUS
AfpIoRead(
	IN	PFILESYSHANDLE		pFileSysHandle,
	IN	PFORKOFFST			pForkOffset,
	IN	LONG				SizeReq,
	OUT	PLONG				pSizeRead,
	OUT	PBYTE				pBuffer
);


extern
AFPSTATUS
AfpIoWrite(
	IN	PFILESYSHANDLE		pFileSysHandle,
	IN	PFORKOFFST			pForkOffset,
	IN	LONG				SizeReq,
	OUT	PBYTE				pBuffer
);

extern
AFPSTATUS FASTCALL
AfpIoQuerySize(
	IN	PFILESYSHANDLE		pFileSysHandle,
	OUT	PFORKSIZE			pForkLength
);


extern
AFPSTATUS FASTCALL
AfpIoSetSize(
	IN	PFILESYSHANDLE		pFileSysHandle,
	IN	LONG				ForkLength
);

extern
AFPSTATUS
AfpIoChangeNTModTime(
	IN	PFILESYSHANDLE		pFileHandle,
	OUT	PTIME				pModTime
);

extern
AFPSTATUS
AfpIoQueryTimesnAttr(
	IN	PFILESYSHANDLE		pFileHandle,
	OUT	PDWORD				pCreatTime	OPTIONAL,
	OUT	PTIME				pModTime	OPTIONAL,
	OUT	PDWORD				pAttr		OPTIONAL
);

extern
AFPSTATUS
AfpIoSetTimesnAttr(
	IN PFILESYSHANDLE		pFileSysHandle,
	IN PAFPTIME				pCreateTime		OPTIONAL,
	IN PAFPTIME				pModTime		OPTIONAL,
	IN DWORD				AttrSet,
	IN DWORD				AttrClear,
	IN struct _VolDesc *	pVolDesc	OPTIONAL,	// only if NotifyPath
	IN PUNICODE_STRING		pNotifyPath	OPTIONAL
);


extern
AFPSTATUS
AfpIoRestoreTimeStamp(
	IN PFILESYSHANDLE		pFileSysHandle,
    IN OUT PTIME            pOriginalModTime,
    IN DWORD                dwFlag
);

extern
AFPSTATUS FASTCALL
AfpIoQueryShortName(
 	IN	PFILESYSHANDLE		pFileSysHandle,
	OUT	PANSI_STRING		pName
);

extern
NTSTATUS
AfpIoQueryLongName(
	IN	PFILESYSHANDLE		pFileHandle,
	IN	PUNICODE_STRING		pShortname,
	OUT	PUNICODE_STRING		pLongName
);

extern
PSTREAM_INFO FASTCALL
AfpIoQueryStreams(
	IN	PFILESYSHANDLE		pFileHandle

);

extern
NTSTATUS
AfpIoMarkFileForDelete(
	IN	PFILESYSHANDLE	pFileSysHandle,
	IN	struct _VolDesc *	pVolDesc	OPTIONAL, // only if pNotifyPath
	IN	PUNICODE_STRING pNotifyPath OPTIONAL,
	IN	PUNICODE_STRING pNotifyParentPath OPTIONAL
);

extern
NTSTATUS
AfpIoQueryDirectoryFile(
	IN	PFILESYSHANDLE		pFileSysHandle,
	OUT	PVOID				Enumbuf,
	IN	ULONG				Enumbuflen,
	IN	ULONG				FileInfoClass,
	IN	BOOLEAN				ReturnSingleEntry,
	IN	BOOLEAN 			RestartScan,
	IN	PUNICODE_STRING 	pString OPTIONAL
);


NTSTATUS
AfpIoQueryBasicInfo(
	IN	PFILESYSHANDLE		pFileHandle,
	OUT	PVOID				BasicInfoBuf
);

extern
AFPSTATUS FASTCALL
AfpIoClose(
 	IN	PFILESYSHANDLE		pFileSysHandle
);

extern
AFPSTATUS
AfpIoQueryVolumeSize(
	IN	struct _VolDesc *	pVolDesc,
	OUT LARGE_INTEGER   *   pFreeBytes,
	OUT	LARGE_INTEGER   *   pVolumeSize OPTIONAL
);

extern
AFPSTATUS
AfpIoMoveAndOrRename(
	IN	PFILESYSHANDLE		pfshFile,
	IN	PFILESYSHANDLE		pfshNewParent 		OPTIONAL,// Supply for Move operation
	IN	PUNICODE_STRING		pNewName,
	IN struct _VolDesc *	pVolDesc			OPTIONAL,// only if NotifyPath
	IN PUNICODE_STRING		pNotifyPath1		OPTIONAL,// REMOVE or RENAME action
	IN PUNICODE_STRING		pNotifyParentPath1	OPTIONAL,
	IN PUNICODE_STRING		pNotifyPath2		OPTIONAL,// ADDED action
	IN PUNICODE_STRING		pNotifyParentPath2	OPTIONAL
);

extern
AFPSTATUS
AfpIoCopyFile1(
	IN	PFILESYSHANDLE		phSrcFile,
	IN	PFILESYSHANDLE		phDstDir,
	IN	PUNICODE_STRING		pNewName,
	IN	struct _VolDesc *	pVolDesc			OPTIONAL,	// only if pNotifyPath
	IN	PUNICODE_STRING		pNotifyPath			OPTIONAL,
	IN	PUNICODE_STRING		pNotifyParentPath	OPTIONAL,
	OUT	PCOPY_FILE_INFO		pCopyFileInfo
);

extern
AFPSTATUS
AfpIoCopyFile2(
	IN	PCOPY_FILE_INFO		pCopyFileInfo,
	IN	struct _VolDesc *	pVolDesc			OPTIONAL,	// only if pNotifyPath
	IN	PUNICODE_STRING		pNotifyPath			OPTIONAL,
	IN	PUNICODE_STRING		pNotifyParentPath	OPTIONAL
);

extern
AFPSTATUS FASTCALL
AfpIoConvertNTStatusToAfpStatus(
	IN	NTSTATUS			Status
);

extern
VOID FASTCALL
AfpUpgradeHandle(
	IN	PFILESYSHANDLE		pFileHandle
);

extern
NTSTATUS FASTCALL
AfpIoWait(
	IN	PVOID				pObject,
	IN	PLARGE_INTEGER		pTimeOut			OPTIONAL
);

extern
NTSTATUS
AfpQueryPath(
	IN	HANDLE				FileHandle,
	IN	PUNICODE_STRING		pPath,
	IN	ULONG				MaximumBuf
);

extern
BOOLEAN FASTCALL
AfpIoIsSupportedDevice(
	IN	PFILESYSHANDLE 		pFileHandle,
	OUT	PDWORD				pFlags
);


#ifdef	FILEIO_LOCALS

LOCAL	UNICODE_STRING afpNTFSName = { 0 };
LOCAL	UNICODE_STRING afpCDFSName = { 0 };

LOCAL	UNICODE_STRING afpAHFSName = { 0 };

LOCAL VOID FASTCALL
afpUpdateOpenFiles(
	IN	BOOLEAN				Internal,		// True for internal handles
	IN	BOOLEAN				Open			// True for open, False for close
);

LOCAL VOID FASTCALL
afpUpdateFastIoStat(
	IN	BOOLEAN				Success
);

#endif	// FILEIO_LOCALS

#endif	// _FILEIO_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\forkio.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	forkio.h

Abstract:

	This file defines the fork I/O prototypes which are callable at DISPATCH
	level.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	15 Jan 1993		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_FORKIO_
#define	_FORKIO_


#define AFP_DELALLOC_SIGNATURE  0x15263748

typedef struct _DelayedAlloc
{
#if DBG
    LIST_ENTRY          Linkage;
    DWORD               Signature;
    PIRP                pIrp;
    DWORD               State;
#endif
    WORK_ITEM           WorkItem;
    PSDA                pSda;
    PREQUEST            pRequest;
    LARGE_INTEGER       Offset;
    DWORD               BufSize;
    POPENFORKENTRY      pOpenForkEntry;
    PMDL                pMdl;
    DWORD               Flags;

} DELAYEDALLOC, *PDELAYEDALLOC;


#define AFP_CACHEMDL_DEADSESSION    0x1
#define AFP_CACHEMDL_ALLOC_ERROR    0x2

#define AFP_DBG_MDL_INIT                0x00000001
#define AFP_DBG_MDL_REQUESTED           0x00000002
#define AFP_DBG_MDL_IN_USE              0x00000004
#define AFP_DBG_MDL_RETURN_IN_PROGRESS  0x00000008
#define AFP_DBG_MDL_RETURN_COMPLETED    0x00000010
#define AFP_DBG_MDL_PROC_QUEUED         0x00000020
#define AFP_DBG_MDL_PROC_IN_PROGRESS    0x00000040
#define AFP_DBG_WRITE_MDL               0x10000000
#define AFP_DBG_READ_MDL                0x40000000
#define AFP_DBG_MDL_END                 0x80000000

#if DBG
#define AFP_DBG_SET_DELALLOC_STATE(_pDelA, _flag) (_pDelA->State |= _flag)
#define AFP_DBG_SET_DELALLOC_IRP(_pDelA, _pIrp)   (_pDelA->pIrp = (PIRP)_pIrp)
#define AFP_DBG_INC_DELALLOC_BYTECOUNT(_Counter, _ByteCount)    \
{                                                               \
    KIRQL   _OldIrql;                                           \
    ACQUIRE_SPIN_LOCK(&AfpDebugSpinLock, &_OldIrql);            \
    _Counter += _ByteCount;                                     \
    RELEASE_SPIN_LOCK(&AfpDebugSpinLock, _OldIrql);             \
}

#define AFP_DBG_DEC_DELALLOC_BYTECOUNT(_Counter, _ByteCount)    \
{                                                               \
    KIRQL   _OldIrql;                                           \
    ACQUIRE_SPIN_LOCK(&AfpDebugSpinLock, &_OldIrql);            \
    _Counter -= _ByteCount;                                     \
    RELEASE_SPIN_LOCK(&AfpDebugSpinLock, _OldIrql);             \
}

#else
#define AFP_DBG_SET_DELALLOC_STATE(_pDelA, _flag)
#define AFP_DBG_SET_DELALLOC_IRP(_pDelA, _pIrp)
#define AFP_DBG_INC_DELALLOC_BYTECOUNT(_Counter, _ByteCount)
#define AFP_DBG_DEC_DELALLOC_BYTECOUNT(_Counter, _ByteCount)
#endif


extern
AFPSTATUS
AfpIoForkRead(
	IN	PSDA			pSda,			// The session requesting read
	IN	POPENFORKENTRY	pOpenForkEntry,	// The open fork in question
	IN	PFORKOFFST		pOffset,		// Pointer to fork offset
	IN	LONG			ReqCount,		// Size of read request
	IN	BYTE			NlMask,
	IN	BYTE			NlChar
);

extern
AFPSTATUS
AfpIoForkWrite(
	IN	PSDA			pSda,			// The session requesting read
	IN	POPENFORKENTRY	pOpenForkEntry,	// The open fork in question
	IN	PFORKOFFST		pOffset,		// Pointer to fork offset
	IN	LONG			ReqCount		// Size of read request
);

extern
AFPSTATUS
AfpIoForkLockUnlock(
	IN	PSDA			pSda,
	IN	PFORKLOCK		pForkLock,
	IN	PFORKOFFST		pForkOffset,
	IN	PFORKSIZE		pLockSize,
	IN	BYTE			Func			
);

extern
VOID FASTCALL
AfpAllocWriteMdl(
    IN PDELAYEDALLOC    pDelAlloc
);

extern
NTSTATUS
AfpAllocWriteMdlCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
);

extern
NTSTATUS FASTCALL
AfpBorrowWriteMdlFromCM(
    IN  PDELAYEDALLOC   pDelAlloc,
    OUT PMDL           *ppReturnMdl
);

extern
VOID FASTCALL
AfpReturnWriteMdlToCM(
    IN  PDELAYEDALLOC   pDelAlloc
);

extern
NTSTATUS
AfpReturnWriteMdlToCMCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
);

extern
NTSTATUS FASTCALL
AfpBorrowReadMdlFromCM(
    IN PSDA             pSda
);

extern
NTSTATUS
AfpBorrowReadMdlFromCMCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
);


extern
VOID FASTCALL
AfpReturnReadMdlToCM(
    IN  PDELAYEDALLOC   pDelAlloc
);


extern
NTSTATUS
AfpReturnReadMdlToCMCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
);


extern
PDELAYEDALLOC FASTCALL
AfpAllocDelAlloc(
    IN VOID
);


extern
VOID FASTCALL
AfpFreeDelAlloc(
    IN PDELAYEDALLOC    pDelAlloc
);


// defined in fsp_fork.c, but we will put the prototype here
extern
AFPSTATUS FASTCALL
AfpFspDispReadContinue(
	IN	PSDA	pSda
);


#define	FUNC_READ		0x01
#define	FUNC_WRITE		0x02
#define	FUNC_LOCK		0x03
#define	FUNC_UNLOCK		0x04
#define	FUNC_NOTIFY		0x05

// if the Write size is below this, it's probably more efficient to avoid going to cache mgr
#define CACHEMGR_WRITE_THRESHOLD    8192

// if the Read size is below this, it's probably more efficient to avoid going to cache mgr
#define CACHEMGR_READ_THRESHOLD     8192

#ifdef	FORKIO_LOCALS

// The following structure is used as a context in the Irp. The completion
// routines uses this to handle responding to the original request.

#if DBG
#define	CTX_SIGNATURE			*(DWORD *)"FCTX"
#define	VALID_CTX(pCmplCtxt)	(((pCmplCtxt) != NULL) && \
								 ((pCmplCtxt)->Signature == CTX_SIGNATURE))
#else
#define	VALID_CTX(pCmplCtxt)	((pCmplCtxt) != NULL)
#endif

typedef	struct _CompletionContext
{
#if	DBG
	DWORD				Signature;
#endif
	PSDA				cc_pSda;		// The session context (valid except unlock)
	PFORKLOCK			cc_pForkLock;	// Valid only during a LOCK
	AFPSTATUS			cc_SavedStatus;	// Used by READ
	LONG				cc_Offst;		// Offset of Write request
	LONG				cc_ReqCount;	// The request count for read/write
	BYTE				cc_Func;		// READ/WRITE/LOCK/UNLOCK/NOTIFY
	BYTE				cc_NlMask;		// For read only
	BYTE				cc_NlChar;		// For read only
} CMPLCTXT, *PCMPLCTXT;


#if	DBG
#define	afpInitializeCmplCtxt(pCtxt, Func, SavedStatus, pSda, pForkLock, ReqCount, Offst)	\
		(pCtxt)->Signature = CTX_SIGNATURE;		\
		(pCtxt)->cc_Func	= Func;				\
		(pCtxt)->cc_pSda	= pSda;				\
		(pCtxt)->cc_pForkLock = pForkLock;		\
		(pCtxt)->cc_SavedStatus = SavedStatus;	\
		(pCtxt)->cc_ReqCount= ReqCount;			\
		(pCtxt)->cc_Offst = Offst;
#else
#define	afpInitializeCmplCtxt(pCtxt, Func, SavedStatus, pSda, pForkLock, ReqCount, Offst)	\
		(pCtxt)->cc_Func	= Func;				\
		(pCtxt)->cc_pSda	= pSda;				\
		(pCtxt)->cc_pForkLock = pForkLock;		\
		(pCtxt)->cc_SavedStatus = SavedStatus;	\
		(pCtxt)->cc_ReqCount= ReqCount;			\
		(pCtxt)->cc_Offst = Offst;
#endif

extern
PCMPLCTXT
AfpAllocCmplCtxtBuf(
	IN	PSDA	pSda
);

VOID
AfpFreeCmplCtxtBuf(
	IN	PCMPLCTXT   pCmplCtxt
);

#endif	// FORKIO_LOCALS

#endif	// _FORKIO_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\fdparm.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fdparm.h

Abstract:

	This file defines file-dir parameter handling data structure and prototypes.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/


#ifndef	_FDPARM_
#define	_FDPARM_


#define	EVENALIGN(n)	(((n) + 1) & ~1)

// Common File and Directory bitmap definitions
#define	FD_BITMAP_ATTR				0x0001
#define	FD_BITMAP_PARENT_DIRID		0x0002
#define	FD_BITMAP_CREATETIME		0x0004
#define	FD_BITMAP_MODIFIEDTIME		0x0008
#define	FD_BITMAP_BACKUPTIME		0x0010
#define	FD_BITMAP_FINDERINFO		0x0020
#define	FD_BITMAP_LONGNAME			0x0040
#define	FD_BITMAP_SHORTNAME			0x0080
#define	FD_BITMAP_PRODOSINFO		0x2000

// File Specific bitmap definitions
#define	FILE_BITMAP_FILENUM			0x0100
#define	FILE_BITMAP_DATALEN			0x0200
#define	FILE_BITMAP_RESCLEN			0x0400
#define	FILE_BITMAP_MASK			0x27FF

// Directory bitmap definitions
#define	DIR_BITMAP_DIRID			FILE_BITMAP_FILENUM
#define	DIR_BITMAP_OFFSPRINGS		FILE_BITMAP_DATALEN
#define	DIR_BITMAP_OWNERID			FILE_BITMAP_RESCLEN
#define	DIR_BITMAP_GROUPID			0x0800
#define	DIR_BITMAP_ACCESSRIGHTS		0x1000
#define	DIR_BITMAP_MASK				0x3FFF

#define	FD_VALID_SET_PARMS			(FD_BITMAP_ATTR			|	\
									 FD_BITMAP_FINDERINFO	|	\
									 FD_BITMAP_PRODOSINFO	|	\
									 FD_BITMAP_CREATETIME	|	\
									 FD_BITMAP_BACKUPTIME	|	\
									 FD_BITMAP_MODIFIEDTIME)

#define	DIR_VALID_SET_PARMS			(FD_VALID_SET_PARMS		|	\
									 DIR_BITMAP_OWNERID		|	\
									 DIR_BITMAP_GROUPID		|	\
									 DIR_BITMAP_ACCESSRIGHTS)

#define	FILE_VALID_SET_PARMS		(FD_VALID_SET_PARMS)

// We have no way of knowing what the ASP buffer size on the client end is,
// from trial and error it appears to be less than 578
#define MAX_CATSEARCH_REPLY			512
// Valid Request (search criteria) bitmaps for AfpCatSearch
#define FD_VALID_SEARCH_CRITERIA	(FD_BITMAP_PARENT_DIRID	|	\
									 FD_BITMAP_CREATETIME	|	\
									 FD_BITMAP_MODIFIEDTIME |	\
									 FD_BITMAP_BACKUPTIME	|	\
									 FD_BITMAP_FINDERINFO	|	\
									 FD_BITMAP_LONGNAME)

#define FILE_VALID_SEARCH_CRITERIA	(FD_VALID_SEARCH_CRITERIA 	|	\
									 FD_BITMAP_ATTR		   		|	\
									 FILE_BITMAP_DATALEN		|	\
									 FILE_BITMAP_RESCLEN)	

#define DIR_VALID_SEARCH_CRITERIA	(FD_VALID_SEARCH_CRITERIA	|	\
									 FD_BITMAP_ATTR				|	\
									 DIR_BITMAP_OFFSPRINGS)

// The only valid information that can be requested as a result of a
// AfpCatSearch is the parent dirid and the longname of the file/dir found.
#define FD_VALID_SEARCH_RESULT		(FD_BITMAP_PARENT_DIRID |	\
									 FD_BITMAP_LONGNAME)

// Common File and Directory attribute definitions
#define	FD_BITMAP_ATTR_INVISIBLE	0x0001
#define	FD_BITMAP_ATTR_SYSTEM		0x0004
#define	FD_BITMAP_ATTR_BACKUPNEED	0x0040
#define	FD_BITMAP_ATTR_RENAMEINH	0x0080
#define	FD_BITMAP_ATTR_DELETEINH	0x0100
#define	FD_BITMAP_ATTR_SET			0x8000

// File specific attribute definitions
#define	FILE_BITMAP_ATTR_MULTIUSER	0x0002
#define	FILE_BITMAP_ATTR_DATAOPEN	0x0008
#define	FILE_BITMAP_ATTR_RESCOPEN	0x0010
#define	FILE_BITMAP_ATTR_WRITEINH	0x0020
#define	FILE_BITMAP_ATTR_COPYPROT	0x0400

#define	FD_VALID_ATTR				(FD_BITMAP_ATTR_SET			|	\
									 FD_BITMAP_ATTR_DELETEINH	|	\
									 FILE_BITMAP_ATTR_WRITEINH	|	\
									 FD_BITMAP_ATTR_RENAMEINH	|	\
									 FD_BITMAP_ATTR_BACKUPNEED	|	\
									 FD_BITMAP_ATTR_INVISIBLE	|	\
									 FD_BITMAP_ATTR_SYSTEM)

// File/Dir Attributes that map onto the NT ReadOnly attribute
#define	FD_BITMAP_ATTR_NT_RO		(FD_BITMAP_ATTR_RENAMEINH	|	\
									 FD_BITMAP_ATTR_DELETEINH	| 	\
									 FILE_BITMAP_ATTR_WRITEINH)

// This is the set of attributes that are part DfeEntry
#define	AFP_FORK_ATTRIBUTES			(FILE_BITMAP_ATTR_DATAOPEN	|	\
									 FILE_BITMAP_ATTR_RESCOPEN)

// Dir Attributes that can only be changed *from their current settings*
// by the owner of the directory
#define DIR_BITMAP_ATTR_CHG_X_OWNER_ONLY (FD_BITMAP_ATTR_RENAMEINH | \
										  FD_BITMAP_ATTR_DELETEINH | \
										  FD_BITMAP_ATTR_INVISIBLE | \
										  FILE_BITMAP_ATTR_WRITEINH)

// These are the OpenAccess bits that encode the FILEIO_ACCESS_XXX values
// into the Bitmap parameter so that the pathmap code can open the file/dir
// (under impersonation) with the appropriate access for each AFP API.
// We also encode the access needed by the AdminDirectory Get/Set apis for
// when admin calls into pathmap.

#define	FD_INTERNAL_BITMAP_SKIP_IMPERSONATION	0x00200000
#define	FD_INTERNAL_BITMAP_OPENFORK_RESC		0x00400000

// Tells pathmap code whether it should return the paths in the
// PATHMAPENTITY structure for APIs which will cause disk changes that will
// cause a change notify to complete.
#define FD_INTERNAL_BITMAP_RETURN_PMEPATHS		0x00800000

// AdminDirectoryGetInfo: FILE_READ_ATTRIBUTES | READ_CONTROL | SYNCHRONIZE
#define FD_INTERNAL_BITMAP_OPENACCESS_ADMINGET	0x01000000	

// AdminDirectorySetInfo: same as ADMINGET plus the following:
// FILE_WRITE_ATTRIBUTES | WRITE_DAC | WRITE_OWNER
#define FD_INTERNAL_BITMAP_OPENACCESS_ADMINSET	0x02000000	

#define FD_INTERNAL_BITMAP_OPENACCESS_READCTRL	0x04000000	//READ_CONTROL+FILEIO_ACCESS_NONE
#define FD_INTERNAL_BITMAP_OPENACCESS_RWCTRL	0x08000000	//READ_CONTROL+WRITE_CONTROL+FILEIO_ACCESS_NONE
#define FD_INTERNAL_BITMAP_OPENACCESS_READ		0x10000000	//FILEIO_ACCESS_READ
#define FD_INTERNAL_BITMAP_OPENACCESS_WRITE		0x20000000	//FILEIO_ACCESS_WRITE
#define FD_INTERNAL_BITMAP_OPENACCESS_RW_ATTR	0x40000000	//FILE_WRITE_ATTRIBUTES+FILEIO_ACCESS_NONE
#define FD_INTERNAL_BITMAP_OPENACCESS_DELETE	0x80000000	//FILEIO_ACCESS_DELETE

#define FD_INTERNAL_BITMAP_OPENACCESS_READWRITE ( \
							FD_INTERNAL_BITMAP_OPENACCESS_READ		| \
							FD_INTERNAL_BITMAP_OPENACCESS_WRITE)

#define FD_INTERNAL_BITMAP_OPENACCESS_ALL	( \
							FD_INTERNAL_BITMAP_OPENACCESS_ADMINGET	| \
							FD_INTERNAL_BITMAP_OPENACCESS_ADMINSET	| \
							FD_INTERNAL_BITMAP_OPENACCESS_READCTRL	| \
							FD_INTERNAL_BITMAP_OPENACCESS_RWCTRL	| \
							FD_INTERNAL_BITMAP_OPENACCESS_READ		| \
							FD_INTERNAL_BITMAP_OPENACCESS_WRITE		| \
							FD_INTERNAL_BITMAP_OPENACCESS_RW_ATTR	| \
							FD_INTERNAL_BITMAP_OPENACCESS_DELETE)

// These are the DenyMode bits that encode the FILEIO_DENY_XXX values
// into the Bitmap parameter so that the pathmap code can open the fork
// with the appropriate deny modes when mac is calling FpOpenFork.  Pathmap
// will shift these bits right by FD_INTERNAL_BITMAP_DENYMODE_SHIFT and use
// the value as an index into the AfpDenyModes array to come up with the
// correct deny mode to open the fork with.  Note how these bit values
// correspond to the FORK_DENY_xxx bits in forks.h

#define FD_INTERNAL_BITMAP_DENYMODE_READ		0x00010000	//FILEIO_DENY_READ
#define FD_INTERNAL_BITMAP_DENYMODE_WRITE		0x00020000	//FILEIO_DENY_WRITE

#define FD_INTERNAL_BITMAP_DENYMODE_ALL		( \
							FD_INTERNAL_BITMAP_DENYMODE_READ		| \
							FD_INTERNAL_BITMAP_DENYMODE_WRITE)

// Number of bits to shift right in order to get the correct index into the
// AfpDenyModes array
#define FD_INTERNAL_BITMAP_DENYMODE_SHIFT	16


// This gets returned as part of GetFileDirParms
#define	FILEDIR_FLAG_DIR			0x80
#define	FILEDIR_FLAG_FILE			0x00

// Directory Access Permissions
#define	DIR_ACCESS_SEARCH			0x01	// See Folders
#define	DIR_ACCESS_READ				0x02	// See Files
#define	DIR_ACCESS_WRITE			0x04	// Make Changes
#define	DIR_ACCESS_OWNER			0x80	// Only for user
											// if he has owner rights
#define	OWNER_BITS_ALL				0x00808080
											// Mask used to clear owner bit for
											// Owner/Group/World. We are only
											// required to report this bit for
											// 'ThisUser'

#define	DIR_ACCESS_ALL				(DIR_ACCESS_READ	| \
									 DIR_ACCESS_SEARCH	| \
									 DIR_ACCESS_WRITE)

#define	OWNER_RIGHTS_SHIFT			0
#define	GROUP_RIGHTS_SHIFT			8
#define	WORLD_RIGHTS_SHIFT			16
#define	USER_RIGHTS_SHIFT			24

typedef	struct _FileDirParms
{
	DWORD		_fdp_AfpId;
	DWORD		_fdp_ParentId;
	DWORD		_fdp_Flags;				// one of DFE_FLAGS_DFBITS
	USHORT		_fdp_Attr;
	USHORT		_fdp_EffectiveAttr;		// After any additions/subtractions
	AFPTIME		_fdp_CreateTime;
	AFPTIME		_fdp_ModifiedTime;
	AFPTIME		_fdp_BackupTime;

	union
	{
	  struct
	  {
		 DWORD	_fdp_DataForkLen;
		 DWORD	_fdp_RescForkLen;
	  };
	  struct
	  {
		 DWORD	_fdp_FileCount;
		 DWORD	_fdp_DirCount;
		 DWORD	_fdp_OwnerId;
		 DWORD	_fdp_GroupId;
	  };
	};

	FINDERINFO	_fdp_FinderInfo;
	ANSI_STRING	_fdp_LongName;			// Name of the entity (Not fully qualified)
	ANSI_STRING	_fdp_ShortName;
	PRODOSINFO	_fdp_ProDosInfo;

	BOOLEAN		_fdp_UserIsMemberOfDirGroup;
	BOOLEAN		_fdp_UserIsOwner;

	union
	{
	  struct
	  {
	  	BYTE	_fdp_OwnerRights;		// The Rights bytes must be in the order
	  	BYTE	_fdp_GroupRights;   	// of Owner,Group,World,User
	  	BYTE	_fdp_WorldRights;
	  	BYTE	_fdp_UserRights;
	  };
	  DWORD		_fdp_Rights;			// All rights accessed as a single entity
	};

	BOOLEAN		_fdp_fPartialName;		// For FpCatSearch partial name flag

	BYTE		_fdp_LongNameBuf [AFP_LONGNAME_LEN+1];
	BYTE		_fdp_ShortNameBuf[AFP_SHORTNAME_LEN+1];
} FILEDIRPARM, *PFILEDIRPARM;

#define	IsDir(pFDParm)	(BOOLEAN)(((pFDParm)->_fdp_Flags & DFE_FLAGS_DIR) == DFE_FLAGS_DIR)
#define	AfpInitializeFDParms(pFDParms)	\
			(pFDParms)->_fdp_LongName.MaximumLength = AFP_LONGNAME_LEN+1;	\
			(pFDParms)->_fdp_LongName.Length = 0;							\
			(pFDParms)->_fdp_LongName.Buffer = (pFDParms)->_fdp_LongNameBuf;\
			(pFDParms)->_fdp_ShortName.MaximumLength = AFP_SHORTNAME_LEN+1;	\
			(pFDParms)->_fdp_ShortName.Length = 0;							\
			(pFDParms)->_fdp_ShortName.Buffer = (pFDParms)->_fdp_ShortNameBuf;

extern
USHORT
AfpGetFileDirParmsReplyLength(
	IN	PFILEDIRPARM			pFDParm,
	IN	DWORD					Bitmap
);

extern
VOID
AfpPackFileDirParms(
	IN	PFILEDIRPARM			pFileDirParm,
	IN	DWORD					Bitmap,
	OUT	PBYTE					pBuffer
);

extern
AFPSTATUS
AfpUnpackFileDirParms(
	IN	PBYTE					pBuffer,
	IN	LONG					Length,
	IN	PDWORD					pBitmap,
	OUT	PFILEDIRPARM			pFileDirParm
);

extern
AFPSTATUS
AfpSetFileDirParms(
	IN	PVOLDESC				pVolDesc,
	IN	struct _PathMapEntity *	pPME,
	IN	DWORD					Bitmap,
	IN	PFILEDIRPARM			pFDParm
);

extern
USHORT
AfpConvertNTAttrToAfpAttr(
	IN	DWORD					Attr
);

extern
DWORD
AfpConvertAfpAttrToNTAttr(
	IN	USHORT					Attr
);

extern
VOID
AfpNormalizeAfpAttr(
	IN OUT	PFILEDIRPARM		pFDParm,
	IN		DWORD				NtAttr
);

extern
DWORD
AfpMapFDBitmapOpenAccess(
	IN	DWORD	Bitmap,
	IN	BOOLEAN IsDir
);

extern
AFPSTATUS
AfpQuerySecurityIdsAndRights(
	IN	PSDA					pSda,
	IN	PFILESYSHANDLE			FSHandle,
	IN	DWORD					Bitmap,
	IN OUT PFILEDIRPARM			pFDParm
);

extern
AFPSTATUS	
AfpCheckForInhibit(
	IN	PFILESYSHANDLE			hData,
	IN	DWORD					InhibitBit,
	IN	DWORD					AfpAttr,
	OUT PDWORD					pNTAttr
);

extern
AFPSTATUS
AfpUnpackCatSearchSpecs(
	IN	PBYTE					pBuffer,		// Pointer to beginning of Spec data
	IN	USHORT					BufLength,		// Length of Spec1 + Spec2 data
	IN	DWORD					Bitmap,
	OUT	PFILEDIRPARM			pFDParm1,
	OUT PFILEDIRPARM			pFDParm2,
	OUT PUNICODE_STRING			pMatchString
);

extern
SHORT
AfpIsCatSearchMatch(
	IN	PDFENTRY				pDFE,
	IN	DWORD					Bitmap,			// Search criteria
	IN	DWORD					ReplyBitmap,	// Info to return
	IN	PFILEDIRPARM			pFDParm1,
	IN	PFILEDIRPARM			pFDParm2,
	IN	PUNICODE_STRING			pMatchName OPTIONAL	
);


#endif	// _FDPARM


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\forkio.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	forkio.c

Abstract:

	This module contains the routines for performing fork reads and writes
	directly by building IRPs and not using NtReadFile/NtWriteFile. This
	should be used only by the FpRead and FpWrite Apis.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	15 Jan 1993		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FORKIO

#define	FORKIO_LOCALS
#include <afp.h>
#include <forkio.h>
#include <gendisp.h>

#if DBG
PCHAR	AfpIoForkFunc[] =
	{
		"",
		"READ",
		"WRITE",
		"LOCK",
		"UNLOCK"
	};
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpIoForkRead)
#pragma alloc_text( PAGE, AfpIoForkWrite)
#pragma alloc_text( PAGE, AfpIoForkLockUnlock)
#endif

/***	afpIoGenericComplete
 *
 *	This is the generic completion routine for a posted io request.
 */
NTSTATUS
afpIoGenericComplete(
	IN	PDEVICE_OBJECT	pDeviceObject,
	IN	PIRP			pIrp,
	IN	PCMPLCTXT		pCmplCtxt
)
{
	PSDA		pSda;			// Not valid for Unlock
	struct _ResponsePacket	// For lock/unlock request
	{
		union
		{
			BYTE	__RangeStart[4];
			BYTE	__LastWritten[4];
		};
	};

	ASSERT(VALID_CTX(pCmplCtxt));

	if (pCmplCtxt->cc_Func != FUNC_UNLOCK)
	{
		pSda = (PSDA)(pCmplCtxt->cc_pSda);
		ASSERT(VALID_SDA(pSda));

        if (pCmplCtxt->cc_Func == FUNC_WRITE)
        {
			AfpFreeIOBuffer(pSda);
        }
        else if (!NT_SUCCESS(pIrp->IoStatus.Status) &&
                (pCmplCtxt->cc_Func == FUNC_READ))
        {
            AfpIOFreeBackFillBuffer(pSda);
        }
	}

	if (!NT_SUCCESS(pIrp->IoStatus.Status))
	{
		DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_WARN,
				("afpIoGenericComplete: %s ERROR %lx\n",
				AfpIoForkFunc[pCmplCtxt->cc_Func], pIrp->IoStatus.Status));

		if (pCmplCtxt->cc_Func != FUNC_UNLOCK)
		{
			if (pIrp->IoStatus.Status == STATUS_FILE_LOCK_CONFLICT)
				pCmplCtxt->cc_SavedStatus = AFP_ERR_LOCK;
			else if (pIrp->IoStatus.Status == STATUS_END_OF_FILE)
			{
				pCmplCtxt->cc_SavedStatus = AFP_ERR_NONE;
				if (pIrp->IoStatus.Information == 0)
					 pCmplCtxt->cc_SavedStatus = AFP_ERR_EOF;
			}
			else if (pIrp->IoStatus.Status == STATUS_DISK_FULL)
				 pCmplCtxt->cc_SavedStatus = AFP_ERR_DISK_FULL;
			else pCmplCtxt->cc_SavedStatus = AFP_ERR_MISC;
		}
		else
		{
			AFPLOG_ERROR(AFPSRVMSG_CANT_UNLOCK,
						 pIrp->IoStatus.Status,
						 NULL,
						 0,
						 NULL);
		}

		if (pCmplCtxt->cc_Func == FUNC_LOCK)
		{
			DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_ERR,
					("afpIoGenericComplete: ForkLock failed %lx, aborting for range %ld,%ld\n",
					pIrp->IoStatus.Status,
					pCmplCtxt->cc_pForkLock->flo_Offset,
					pCmplCtxt->cc_pForkLock->flo_Offset+pCmplCtxt->cc_pForkLock->flo_Size-1));
			AfpForkLockUnlink(pCmplCtxt->cc_pForkLock);
		}
	}

	else switch (pCmplCtxt->cc_Func)
	{
	  case FUNC_WRITE:
		INTERLOCKED_ADD_STATISTICS(&AfpServerStatistics.stat_DataWritten,
								   pCmplCtxt->cc_Offst,
								   &AfpStatisticsLock);
		pSda->sda_ReplySize = SIZE_RESPPKT;
		if (AfpAllocReplyBuf(pSda) == AFP_ERR_NONE)
		{
			PUTDWORD2DWORD(pRspPkt->__LastWritten,
						pCmplCtxt->cc_Offst + pCmplCtxt->cc_ReqCount);
		}
		else pCmplCtxt->cc_SavedStatus = AFP_ERR_MISC;
		break;

	  case FUNC_READ:
		{
			LONG	i, Size;
			PBYTE	pBuf;
			BYTE	NlChar = pCmplCtxt->cc_NlChar;
			BYTE	NlMask = pCmplCtxt->cc_NlMask;

			INTERLOCKED_ADD_STATISTICS(&AfpServerStatistics.stat_DataRead,
									   (ULONG)pIrp->IoStatus.Information,
									   &AfpStatisticsLock);

			Size = (LONG)pIrp->IoStatus.Information;
#if 0
			// The following code does the right thing as per the spec but
			// the finder seems to think otherwise.
			if (Size < pCmplCtxt->cc_ReqCount)
				pCmplCtxt->cc_SavedStatus = AFP_ERR_EOF;
#endif
			if (Size == 0)
			{
				pCmplCtxt->cc_SavedStatus = AFP_ERR_EOF;
                AfpIOFreeBackFillBuffer(pSda);
			}
			else if (pCmplCtxt->cc_NlMask != 0)
			{
				for (i = 0, pBuf = pSda->sda_ReplyBuf; i < Size; i++, pBuf++)
				{
					if ((*pBuf & NlMask) == NlChar)
					{
						Size = ++i;
						pCmplCtxt->cc_SavedStatus = AFP_ERR_NONE;
						break;
					}
				}
			}
			pSda->sda_ReplySize = (USHORT)Size;
		}
		ASSERT((pCmplCtxt->cc_SavedStatus != AFP_ERR_EOF) ||
				(pSda->sda_ReplySize == 0));
		break;

	  case FUNC_LOCK:
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_CurrentFileLocks,
							  1,
							  &AfpStatisticsLock);
		pSda->sda_ReplySize = SIZE_RESPPKT;
		if (AfpAllocReplyBuf(pSda) == AFP_ERR_NONE)
			PUTDWORD2DWORD(pRspPkt->__RangeStart, pCmplCtxt->cc_pForkLock->flo_Offset);
		else pCmplCtxt->cc_SavedStatus = AFP_ERR_MISC;
		break;

	  case FUNC_UNLOCK:
		INTERLOCKED_ADD_ULONG(
					&AfpServerStatistics.stat_CurrentFileLocks,
					(ULONG)-1,
					&AfpStatisticsLock);
		break;

	  default:
		ASSERTMSG(0, "afpIoGenericComplete: Invalid function\n");
		KeBugCheck(0);
		break;
	}

	if (pIrp->MdlAddress != NULL)
		AfpFreeMdl(pIrp->MdlAddress);

	AfpFreeIrp(pIrp);

	if (pCmplCtxt->cc_Func != FUNC_UNLOCK)
	{
		DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
				("afpIoGenericComplete: %s Returning %ld\n",
				AfpIoForkFunc[pCmplCtxt->cc_Func], pCmplCtxt->cc_SavedStatus));
		AfpCompleteApiProcessing(pSda, pCmplCtxt->cc_SavedStatus);
	}

    AfpFreeCmplCtxtBuf(pCmplCtxt);

	// Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
	// will stop working on the IRP.

	return STATUS_MORE_PROCESSING_REQUIRED;
}



/***	AfpIoForkRead
 *
 *	Read a chunk of data from the open fork. The read buffer is always the
 *	the reply buffer in the sda (sda_ReplyBuf).
 */
AFPSTATUS
AfpIoForkRead(
	IN	PSDA			pSda,			// The session requesting read
	IN	POPENFORKENTRY	pOpenForkEntry,	// The open fork in question
	IN	PFORKOFFST		pOffset,		// Pointer to fork offset
	IN	LONG			ReqCount,		// Size of read request
	IN	BYTE			NlMask,
	IN	BYTE			NlChar
)
{
	PIRP				pIrp = NULL;
	PIO_STACK_LOCATION	pIrpSp;
	NTSTATUS			Status;
	PMDL				pMdl = NULL;
	PCMPLCTXT			pCmplCtxt;

	PAGED_CODE( );

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpIoForkRead: Session %ld, Offset %ld, Size %ld, Fork %ld\n",
			pSda->sda_SessionId, pOffset->LowPart, ReqCount, pOpenForkEntry->ofe_ForkId));

	do
	{

		// Allocate and initialize the completion context

		pCmplCtxt = AfpAllocCmplCtxtBuf(pSda);
        if (pCmplCtxt == NULL)
        {
			AfpFreeIOBuffer(pSda);
			Status = AFP_ERR_MISC;
			break;
        }

		afpInitializeCmplCtxt(pCmplCtxt,
							  FUNC_READ,
							  pSda->sda_ReadStatus,
							  pSda,
							  NULL,
							  ReqCount,
							  pOffset->LowPart);
		pCmplCtxt->cc_NlChar  = NlChar;
		pCmplCtxt->cc_NlMask  = NlMask;

		// Allocate and initialize the IRP for this operation.
		if ((pIrp = AfpAllocIrp(pOpenForkEntry->ofe_pDeviceObject->StackSize)) == NULL)
		{
			AfpFreeIOBuffer(pSda);
			Status = AFP_ERR_MISC;
			break;
		}

		if ((pOpenForkEntry->ofe_pDeviceObject->Flags & DO_BUFFERED_IO) == 0)
		{
			// Allocate an Mdl to describe the read buffer
			if ((pMdl = AfpAllocMdl(pSda->sda_ReplyBuf, ReqCount, pIrp)) == NULL)
			{
				Status = AFP_ERR_MISC;
				break;
			}
		}

		// Set up the completion routine.
		IoSetCompletionRoutine( pIrp,
								(PIO_COMPLETION_ROUTINE)afpIoGenericComplete,
								pCmplCtxt,
								True,
								True,
								True);

		pIrpSp = IoGetNextIrpStackLocation(pIrp);

		pIrp->Tail.Overlay.OriginalFileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
		pIrp->Tail.Overlay.Thread = AfpThread;
		pIrp->RequestorMode = KernelMode;

		// Get a pointer to the stack location for the first driver.
		// This will be used to pass the original function codes and
		// parameters.

		pIrpSp->MajorFunction = IRP_MJ_READ;
		pIrpSp->MinorFunction = IRP_MN_NORMAL;
		pIrpSp->FileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
		pIrpSp->DeviceObject = pOpenForkEntry->ofe_pDeviceObject;

		// Copy the caller's parameters to the service-specific portion of the
		// IRP.

		pIrpSp->Parameters.Read.Length = ReqCount;
		pIrpSp->Parameters.Read.Key = pSda->sda_SessionId;
		pIrpSp->Parameters.Read.ByteOffset = *pOffset;

		if ((pOpenForkEntry->ofe_pDeviceObject->Flags & DO_BUFFERED_IO) != 0)
		{
			pIrp->AssociatedIrp.SystemBuffer = pSda->sda_ReplyBuf;
			pIrp->Flags = IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
		}
		else if ((pOpenForkEntry->ofe_pDeviceObject->Flags & DO_DIRECT_IO) != 0)
		{
			pIrp->MdlAddress = pMdl;
		}
		else
		{
			pIrp->UserBuffer = pSda->sda_ReplyBuf;
			pIrp->MdlAddress = pMdl;
		}

		// Now simply invoke the driver at its dispatch entry with the IRP.
		IoCallDriver(pOpenForkEntry->ofe_pDeviceObject, pIrp);

		Status = AFP_ERR_EXTENDED;	// This makes the caller do nothing and
	} while (False);				// the completion routine handles everything

	if (Status != AFP_ERR_EXTENDED)
	{
		if (pIrp != NULL)
			AfpFreeIrp(pIrp);

		if (pMdl != NULL)
			AfpFreeMdl(pMdl);

        if (pCmplCtxt)
        {
            AfpFreeCmplCtxtBuf(pCmplCtxt);
        }
	}

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpIoForkRead: Returning %ld\n", Status));

	return Status;
}


/***	AfpIoForkWrite
 *
 *	Write a chunk of data to the open fork. The write buffer is always the
 *	the write buffer in the sda (sda_IOBuf).
 */
AFPSTATUS
AfpIoForkWrite(
	IN	PSDA			pSda,			// The session requesting read
	IN	POPENFORKENTRY	pOpenForkEntry,	// The open fork in question
	IN	PFORKOFFST		pOffset,		// Pointer to fork offset
	IN	LONG			ReqCount		// Size of write request
)
{
	PIRP				pIrp = NULL;
	PIO_STACK_LOCATION	pIrpSp;
	NTSTATUS			Status;
	PMDL				pMdl = NULL;
	PCMPLCTXT			pCmplCtxt;

	PAGED_CODE( );

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpIoForkWrite: Session %ld, Offset %ld, Size %ld, Fork %ld\n",
			pSda->sda_SessionId, pOffset->LowPart, ReqCount, pOpenForkEntry->ofe_ForkId));

	do
	{
		// Allocate and initialize the completion context
		pCmplCtxt = AfpAllocCmplCtxtBuf(pSda);
        if (pCmplCtxt == NULL)
        {
			Status = AFP_ERR_MISC;
			break;
        }

		afpInitializeCmplCtxt(pCmplCtxt,
							  FUNC_WRITE,
							  AFP_ERR_NONE,
							  pSda,
							  NULL,
							  ReqCount,
							  pOffset->LowPart);

		// Allocate and initialize the IRP for this operation.
		if ((pIrp = AfpAllocIrp(pOpenForkEntry->ofe_pDeviceObject->StackSize)) == NULL)
		{
			Status = AFP_ERR_MISC;
			break;
		}

		if ((pOpenForkEntry->ofe_pDeviceObject->Flags & DO_BUFFERED_IO) == 0)
		{
			// Allocate an Mdl to describe the write buffer
			if ((pMdl = AfpAllocMdl(pSda->sda_IOBuf, ReqCount, pIrp)) == NULL)
			{
				Status = AFP_ERR_MISC;
				break;
			}
		}

		// Set up the completion routine.
		IoSetCompletionRoutine( pIrp,
								(PIO_COMPLETION_ROUTINE)afpIoGenericComplete,
								pCmplCtxt,
								True,
								True,
								True);

		pIrpSp = IoGetNextIrpStackLocation(pIrp);

		pIrp->Tail.Overlay.OriginalFileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
		pIrp->Tail.Overlay.Thread = AfpThread;
		pIrp->RequestorMode = KernelMode;

		// Get a pointer to the stack location for the first driver.
		// This will be used to pass the original function codes and
		// parameters.

		pIrpSp->MajorFunction = IRP_MJ_WRITE;
		pIrpSp->MinorFunction = IRP_MN_NORMAL;
		pIrpSp->FileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
		pIrpSp->DeviceObject = pOpenForkEntry->ofe_pDeviceObject;

		// Copy the caller's parameters to the service-specific portion of the
		// IRP.

		pIrpSp->Parameters.Write.Length = ReqCount;
		pIrpSp->Parameters.Write.Key = pSda->sda_SessionId;
		pIrpSp->Parameters.Write.ByteOffset = *pOffset;

		if ((pOpenForkEntry->ofe_pDeviceObject->Flags & DO_BUFFERED_IO) != 0)
		{
			pIrp->AssociatedIrp.SystemBuffer = pSda->sda_IOBuf;
			pIrp->Flags = IRP_BUFFERED_IO;
		}
		else if ((pOpenForkEntry->ofe_pDeviceObject->Flags & DO_DIRECT_IO) != 0)
		{
			pIrp->MdlAddress = pMdl;
		}
		else
		{
			pIrp->UserBuffer = pSda->sda_IOBuf;
			pIrp->MdlAddress = pMdl;
		}

		// Now simply invoke the driver at its dispatch entry with the IRP.
		IoCallDriver(pOpenForkEntry->ofe_pDeviceObject, pIrp);

		Status = AFP_ERR_EXTENDED;	// This makes the caller do nothing and
	} while (False);				// the completion routine handles everything

	if (Status != AFP_ERR_EXTENDED)
	{
		if (pIrp != NULL)
			AfpFreeIrp(pIrp);

		if (pMdl != NULL)
			AfpFreeMdl(pMdl);

        if (pCmplCtxt)
        {
            AfpFreeCmplCtxtBuf(pCmplCtxt);
        }
	}

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpIoForkWrite: Returning %ld\n", Status));

	return Status;
}



/***	AfpIoForkLock
 *
 *	Lock/Unlock a section of the open fork.
 */
AFPSTATUS
AfpIoForkLockUnlock(
	IN	PSDA				pSda,
	IN	PFORKLOCK			pForkLock,
	IN	PFORKOFFST			pForkOffset,
	IN	PFORKSIZE			pLockSize,
	IN	BYTE				Func
)
{
	PIRP				pIrp = NULL;
	PIO_STACK_LOCATION	pIrpSp;
	POPENFORKENTRY		pOpenForkEntry = pForkLock->flo_pOpenForkEntry;
	NTSTATUS			Status;
	PCMPLCTXT			pCmplCtxt;

	PAGED_CODE( );

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpIoForkLockUnlock: %sLOCK Session %ld, Offset %ld, Size %ld, Fork %ld\n",
			(Func == FUNC_LOCK) ? "" : "UN", pSda->sda_SessionId,
			pForkOffset->LowPart, pLockSize->LowPart, pOpenForkEntry->ofe_ForkId));

	do
	{
		// Allocate and initialize the completion context
		pCmplCtxt = AfpAllocCmplCtxtBuf(pSda);
        if (pCmplCtxt == NULL)
        {
			Status = AFP_ERR_MISC;
			break;
        }

		afpInitializeCmplCtxt(pCmplCtxt,
							  Func,
							  AFP_ERR_NONE,
							  pSda,
							  pForkLock,
							  pForkOffset->LowPart,
							  pLockSize->LowPart);

		// Allocate and initialize the IRP for this operation.
		if ((pIrp = AfpAllocIrp(pOpenForkEntry->ofe_pDeviceObject->StackSize)) == NULL)
		{
			Status = AFP_ERR_MISC;
			break;
		}

		// Set up the completion routine.
		IoSetCompletionRoutine( pIrp,
								(PIO_COMPLETION_ROUTINE)afpIoGenericComplete,
								pCmplCtxt,
								True,
								True,
								True);

		pIrpSp = IoGetNextIrpStackLocation(pIrp);

		pIrp->Tail.Overlay.OriginalFileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
		pIrp->Tail.Overlay.Thread = AfpThread;
		pIrp->RequestorMode = KernelMode;

		// Get a pointer to the stack location for the first driver.
		// This will be used to pass the original function codes and parameters.

		pIrpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
		pIrpSp->MinorFunction = (Func == FUNC_LOCK) ? IRP_MN_LOCK : IRP_MN_UNLOCK_SINGLE;
		pIrpSp->FileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
		pIrpSp->DeviceObject = pOpenForkEntry->ofe_pDeviceObject;

		// Copy the caller's parameters to the service-specific portion of the IRP.

		pIrpSp->Parameters.LockControl.Length = pLockSize;
		pIrpSp->Parameters.LockControl.Key = pSda->sda_SessionId;
		pIrpSp->Parameters.LockControl.ByteOffset = *pForkOffset;

		pIrp->MdlAddress = NULL;
		pIrpSp->Flags = SL_FAIL_IMMEDIATELY | SL_EXCLUSIVE_LOCK;

		// Now simply invoke the driver at its dispatch entry with the IRP.
		IoCallDriver(pOpenForkEntry->ofe_pDeviceObject, pIrp);

		// For lock operation this makes the caller do nothing
		// and the completion routine handles everything
		// For unlock operation we complete the request here.
		Status = (Func == FUNC_LOCK) ? AFP_ERR_EXTENDED : AFP_ERR_NONE;
		} while (False);


    if ((Status != AFP_ERR_EXTENDED) && (Status != AFP_ERR_NONE))
    {
		if (pIrp != NULL)
			AfpFreeIrp(pIrp);

        if (pCmplCtxt)
        {
            AfpFreeCmplCtxtBuf(pCmplCtxt);
        }
    }
	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpIoForkLock: Returning %ld\n", Status));

	return Status;
}



PCMPLCTXT
AfpAllocCmplCtxtBuf(
	IN	PSDA	pSda
)
{
	KIRQL	OldIrql;
    PBYTE   pRetBuffer;


	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

	ASSERT (sizeof(CMPLCTXT) <= pSda->sda_SizeNameXSpace);

	if (((pSda->sda_Flags & SDA_NAMEXSPACE_IN_USE) == 0) &&
		(sizeof(CMPLCTXT) <= pSda->sda_SizeNameXSpace))
	{
		pRetBuffer = pSda->sda_NameXSpace;
		pSda->sda_Flags |= SDA_NAMEXSPACE_IN_USE;
	}
	else
	{
		pRetBuffer = AfpAllocNonPagedMemory(sizeof(CMPLCTXT));
	}

	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);

	return ((PCMPLCTXT)(pRetBuffer));
}


VOID
AfpFreeCmplCtxtBuf(
	IN	PCMPLCTXT   pCmplCtxt
)
{
	KIRQL	OldIrql;
    PSDA    pSda;


    ASSERT(VALID_CTX(pCmplCtxt));

    pSda = pCmplCtxt->cc_pSda;

    ASSERT(VALID_SDA(pSda));

	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

#if DBG
    pCmplCtxt->Signature = 0x12341234;
    pCmplCtxt->cc_Func = 0xff;
    pCmplCtxt->cc_pSda = (PSDA)0x12341234;
    pCmplCtxt->cc_pForkLock = (PFORKLOCK)0x12341234;
    pCmplCtxt->cc_SavedStatus = 0x12341234;
    pCmplCtxt->cc_ReqCount = 0x12341234;
    pCmplCtxt->cc_Offst = 0x12341234;
#endif

	if (((PBYTE)pCmplCtxt) == pSda->sda_NameXSpace)
	{
        ASSERT(pSda->sda_Flags & SDA_NAMEXSPACE_IN_USE);

		pSda->sda_Flags &= ~SDA_NAMEXSPACE_IN_USE;
	}
	else
	{
		AfpFreeMemory((PBYTE)(pCmplCtxt));
	}

	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\forks.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	forks.c

Abstract:

	This module contains the routines for manipulating the open forks.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FORK_LOCALS
#define	FORKIO_LOCALS
#define	FILENUM	FILE_FORKS

#include <afp.h>
#include <client.h>
#include <fdparm.h>
#include <pathmap.h>
#include <scavengr.h>
#include <afpinfo.h>
#include <forkio.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfpForksInit)
#pragma alloc_text( PAGE, afpForkConvertToAbsOffSize)
#pragma alloc_text( PAGE_AFP, AfpAdmWForkClose)
#pragma alloc_text( PAGE_AFP, AfpForkReferenceById)
#endif

/***	AfpForksInit
 *
 *	Initialize locks for forks.
 */
NTSTATUS
AfpForksInit(
	VOID
)
{
	INITIALIZE_SPIN_LOCK(&AfpForksLock);
	return STATUS_SUCCESS;
}


/***	AfpForkReferenceByRefNum
 *
 *	Map a OForkRefNum to an open fork entry for the session and reference it.
 *
 *	LOCKS:	ofe_Lock
 *
 *	CALLABLE at DISPATCH_LEVEL ONLY !!!
 */
POPENFORKENTRY FASTCALL
AfpForkReferenceByRefNum(
	IN	PSDA	pSda,
	IN	DWORD	OForkRefNum
)
{
	POPENFORKSESS	pOpenForkSess;
	POPENFORKENTRY	pOpenForkEntry;
	POPENFORKENTRY	pOFEntry = NULL;

	ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);
	ASSERT (VALID_SDA(pSda));

    if (OForkRefNum == 0)
    {
	    DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_ERR,
			("AfpForkReferenceByRefNum: client sent 0 for ForkRefNumFork\n"));
        return(NULL);
    }

	pOpenForkSess = &pSda->sda_OpenForkSess;
	while (OForkRefNum > FORK_OPEN_CHUNKS)
	{
		OForkRefNum -= FORK_OPEN_CHUNKS;
		pOpenForkSess = pOpenForkSess->ofs_Link;
		if (pOpenForkSess == NULL)
			return NULL;
	}
	pOpenForkEntry = pOpenForkSess->ofs_pOpenForkEntry[OForkRefNum-1];

	// If this has been marked closed, then return NULL

	if (pOpenForkEntry != NULL)
	{
		ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

		ACQUIRE_SPIN_LOCK_AT_DPC(&pOpenForkEntry->ofe_Lock);

		if (!(pOpenForkEntry->ofe_Flags & OPEN_FORK_CLOSING))
		{
			pOpenForkEntry->ofe_RefCount ++;
			pOFEntry = pOpenForkEntry;
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&pOpenForkEntry->ofe_Lock);
	}

	return pOFEntry;
}


/***	AfpForkReferenceByPointer
 *
 *	Reference the Open Fork Entry. This is used by the admin APIs.
 *
 *	LOCKS:	ofe_Lock
 */
POPENFORKENTRY FASTCALL
AfpForkReferenceByPointer(
	IN	POPENFORKENTRY	pOpenForkEntry
)
{
	POPENFORKENTRY	pOFEntry = NULL;
	KIRQL			OldIrql;

	ASSERT (VALID_OPENFORKENTRY(pOpenForkEntry));

	ACQUIRE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock, &OldIrql);

	if (!(pOpenForkEntry->ofe_Flags & OPEN_FORK_CLOSING))
	{
		pOpenForkEntry->ofe_RefCount ++;
		pOFEntry = pOpenForkEntry;
	}

	RELEASE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock, OldIrql);

	return pOFEntry;
}


/***	AfpForkReferenceById
 *
 *	Reference the Open Fork Entry. This is used by the admin APIs.
 *
 *	LOCKS:		ofe_Lock, AfpForksLock
 *	LOCK_ORDER:	ofe_Lock after AfpForksLock
 */
POPENFORKENTRY FASTCALL
AfpForkReferenceById(
	IN	DWORD	ForkId
)
{
	POPENFORKENTRY	pOpenForkEntry;
	POPENFORKENTRY	pOFEntry = NULL;
	KIRQL			OldIrql;

	ASSERT (ForkId != 0);

	ACQUIRE_SPIN_LOCK(&AfpForksLock, &OldIrql);

	for (pOpenForkEntry = AfpOpenForksList;
		 (pOpenForkEntry != NULL) && (pOpenForkEntry->ofe_ForkId >= ForkId);
		 pOpenForkEntry = pOpenForkEntry->ofe_Next)
	{
		if (pOpenForkEntry->ofe_ForkId == ForkId)
		{
			ACQUIRE_SPIN_LOCK_AT_DPC(&pOpenForkEntry->ofe_Lock);

			if (!(pOpenForkEntry->ofe_Flags & OPEN_FORK_CLOSING))
			{
				pOFEntry = pOpenForkEntry;
				pOpenForkEntry->ofe_RefCount ++;
			}

			RELEASE_SPIN_LOCK_FROM_DPC(&pOpenForkEntry->ofe_Lock);
			break;
		}
	}

	RELEASE_SPIN_LOCK(&AfpForksLock, OldIrql);

	return pOFEntry;
}


/***	AfpForkClose
 *
 *	Close an open fork. Simply set the close flag on the open fork and update
 *	connection counts, if any.
 *
 *	LOCKS: ofd_EntryLock, cds_ConnLock
 */
VOID
AfpForkClose(
	IN	POPENFORKENTRY	pOpenForkEntry
)
{
	PCONNDESC		pConnDesc;
	PVOLDESC		pVolDesc = pOpenForkEntry->ofe_pOpenForkDesc->ofd_pVolDesc;
	KIRQL			OldIrql;
    BOOLEAN         fAlreadyClosing=FALSE;


	ASSERT(VALID_CONNDESC(pOpenForkEntry->ofe_pConnDesc));

    pConnDesc = pOpenForkEntry->ofe_pConnDesc;

	if ((pConnDesc != NULL) &&
        (AfpConnectionReferenceByPointer(pConnDesc) != NULL))
	{
		ASSERT (pConnDesc->cds_pVolDesc == pVolDesc);
		INTERLOCKED_DECREMENT_LONG(&pConnDesc->cds_cOpenForks);

		// update the disk quota for this user
		if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
		{
            // reference again: afpUpdateDiskQuotaInfo will remove this refcount
			if (AfpConnectionReferenceByPointer(pConnDesc) != NULL)
			{
				afpUpdateDiskQuotaInfo(pConnDesc);
			}
		}

		AfpConnectionDereference(pConnDesc);
	}

	ACQUIRE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock, &OldIrql);

    if (!(pOpenForkEntry->ofe_Flags & OPEN_FORK_CLOSING))
    {
	    pOpenForkEntry->ofe_Flags |= OPEN_FORK_CLOSING;
    }
    else
    {
        fAlreadyClosing = TRUE;
    }

	RELEASE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock, OldIrql);

    if (!fAlreadyClosing)
    {
	    // Take away the creation reference
	    AfpForkDereference(pOpenForkEntry);
    }
}


/***	AfpForkDereference
 *
 *	Dereference an open fork entry. If it is marked for deletion and this is
 *	the last reference, then it is cleaned up.
 *
 *	LOCKS:		AfpForksLock (SPIN), vds_VolLock (SPIN), ofd_Lock (SPIN),
 *	LOCKS:		ofe_Lock (SPIN), AfpStatisticsLock (SPIN), sda_Lock (SPIN)
 *
 *	LOCK_ORDER: AfpStatisticsLock after ofd_Lock after vds_VolLock
 *
 */
VOID FASTCALL
AfpForkDereference(
	IN	POPENFORKENTRY	pOpenForkEntry
)
{
	POPENFORKSESS	pOpenForkSess;
	POPENFORKDESC	pOpenForkDesc;
	PVOLDESC		pVolDesc;
	PFORKLOCK		pForkLock, *ppForkLock;
	DWORD			OForkRefNum, FileNum, NumLocks;
	PSDA			pSda;
	KIRQL			OldIrql;
	BOOLEAN			Resource, LastClose = False;
	BOOLEAN			Cleanup;
	PDFENTRY		pDfEntry = NULL;
	FORKSIZE 		forklen;
	DWORD	 		Status;

	ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

	ACQUIRE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock, &OldIrql);

	pOpenForkEntry->ofe_RefCount --;

        ASSERT(pOpenForkEntry->ofe_RefCount >= 0);

	Cleanup =  (pOpenForkEntry->ofe_RefCount == 0);

	RELEASE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock, OldIrql);

	if (!Cleanup)
		return;

	// Unlink this from the global list
	ACQUIRE_SPIN_LOCK(&AfpForksLock, &OldIrql);

	AfpUnlinkDouble(pOpenForkEntry, ofe_Next, ofe_Prev);
	AfpNumOpenForks --;

	RELEASE_SPIN_LOCK(&AfpForksLock, OldIrql);

	// Clean up the rest
	pOpenForkDesc = pOpenForkEntry->ofe_pOpenForkDesc;
	pVolDesc = pOpenForkDesc->ofd_pVolDesc;

	ASSERT(VALID_CONNDESC(pOpenForkEntry->ofe_pConnDesc));
	pSda = pOpenForkEntry->ofe_pSda;

	ASSERT(VALID_OPENFORKDESC(pOpenForkDesc));

	DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
			("AfpForkDereference: Closing Fork %ld for Session %ld\n",
			pOpenForkEntry->ofe_ForkId, pSda->sda_SessionId));

	// Save OForkRefNum for clearing up the Sda entry later on
	OForkRefNum = pOpenForkEntry->ofe_OForkRefNum;
	Resource = RESCFORK(pOpenForkEntry);

	// We are not relying on
	// change notifies to update our cached DFE Fork lengths and
	// modified times from Writes and SetForkParms, so we must do it
	// ourselves at the time when the fork handle is closed by mac.
	// Note the order that the locks are taken here and for
	// FpExchangeFiles/AfpExchangeForkAfpIds to prevent a FileId stored
	// in the OpenForkDesc from changing out from under us due to
	// an FpExchangeFiles call.

	AfpSwmrAcquireExclusive(&pVolDesc->vds_ExchangeFilesLock);

	// Save file number so we can clear the ALREADY_OPEN flag in the DFEntry.
	FileNum = pOpenForkDesc->ofd_FileNumber;

	// Get rid of locks for this fork entry and reduce the use count
	// We do not actually have to unlock the ranges as the close will
	// get rid of them for us. If use count goes to zero, also unlink
	// this fork desc from the volume list.

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);
	ACQUIRE_SPIN_LOCK_AT_DPC(&pOpenForkDesc->ofd_Lock);

	pOpenForkDesc->ofd_UseCount --;

	for (NumLocks = 0, ppForkLock = &pOpenForkDesc->ofd_pForkLock;
		 (pForkLock = *ppForkLock) != NULL;
		 NOTHING)
	{
		if (pForkLock->flo_pOpenForkEntry == pOpenForkEntry)
		{
			ASSERT(pOpenForkDesc->ofd_NumLocks > 0);
			pOpenForkDesc->ofd_NumLocks --;
			ASSERT(pOpenForkEntry->ofe_cLocks > 0);
#if DBG
			pOpenForkEntry->ofe_cLocks --;
#endif
			NumLocks ++;
			*ppForkLock = pForkLock->flo_Next;
			DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
					("AfpForkDereference: Freeing lock %lx\n", pForkLock));
			AfpIOFreeBuffer(pForkLock);
		}
		else ppForkLock = &pForkLock->flo_Next;
	}

	INTERLOCKED_ADD_ULONG_DPC(&AfpServerStatistics.stat_CurrentFileLocks,
							  (ULONG)(-(LONG)NumLocks),
							  &(AfpStatisticsLock.SpinLock));

	ASSERT (pOpenForkEntry->ofe_cLocks == 0);

	if (pOpenForkDesc->ofd_UseCount == 0)
	{
		ASSERT (pOpenForkDesc->ofd_NumLocks == 0);
		ASSERT (pOpenForkDesc->ofd_cOpenR <= FORK_OPEN_READ);
		ASSERT (pOpenForkDesc->ofd_cOpenW <= FORK_OPEN_WRITE);
		ASSERT (pOpenForkDesc->ofd_cDenyR <= FORK_DENY_READ);
		ASSERT (pOpenForkDesc->ofd_cDenyW <= FORK_DENY_WRITE);

		LastClose = True;

		// Unlink the OpenForkDesc from the Volume Descriptor
		AfpUnlinkDouble(pOpenForkDesc, ofd_Next, ofd_Prev);

		RELEASE_SPIN_LOCK_FROM_DPC(&pOpenForkDesc->ofd_Lock);
		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

		// Free the memory for the OpenFork descriptor and path buffer
		if (pOpenForkDesc->ofd_FilePath.Length > 0)
		{
			AfpFreeMemory(pOpenForkDesc->ofd_FilePath.Buffer);
			DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
					("AfpForkDereference: Freeing path to file %lx\n",
                    pOpenForkDesc->ofd_FilePath.Buffer));
		}

		// Dereference the volume descriptor now
		AfpVolumeDereference(pVolDesc);

		// Finally free the open fork descriptor
		AfpFreeMemory(pOpenForkDesc);
	}
	else
	{
		// Update the open & deny modes
		pOpenForkDesc->ofd_cOpenR -= (pOpenForkEntry->ofe_OpenMode & FORK_OPEN_READ);
		pOpenForkDesc->ofd_cOpenW -= (pOpenForkEntry->ofe_OpenMode & FORK_OPEN_WRITE);
		pOpenForkDesc->ofd_cDenyR -= (pOpenForkEntry->ofe_DenyMode & FORK_OPEN_READ);
		pOpenForkDesc->ofd_cDenyW -= (pOpenForkEntry->ofe_DenyMode & FORK_OPEN_WRITE);

		RELEASE_SPIN_LOCK_FROM_DPC(&pOpenForkDesc->ofd_Lock);
		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
	}

	// Lookup the DFE entry by ID, query for the fork length and
	// for the appropriate time (LastWriteTime for DATA$ fork,
	// ChangeTime for Resource) and set the LastWriteTime
	// to last ChangeTime if its resource fork.  If its the last close
	// for this fork, since we already have the DFE pointer and hold
	// the IdDb SWMR, update the DFE_FLAGS_x_ALREADYOPEN flag.  Then
	// release the SWMR.

	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	pDfEntry = AfpFindDfEntryById(pVolDesc,
							       FileNum,
								   DFE_FILE);

	Status = AfpIoQuerySize(&pOpenForkEntry->ofe_FileSysHandle,
							&forklen);

	if (NT_SUCCESS(Status) && (pDfEntry != NULL))
	{
        if (IS_VOLUME_NTFS(pVolDesc))
        {
		    AfpIoChangeNTModTime(&pOpenForkEntry->ofe_FileSysHandle,
								 &pDfEntry->dfe_LastModTime);
        }

		if (Resource)
		{
			pDfEntry->dfe_RescLen = forklen.LowPart;
			if (LastClose)
			{
				pDfEntry->dfe_Flags &= ~DFE_FLAGS_R_ALREADYOPEN;
#ifdef	AGE_DFES
				if (IS_VOLUME_AGING_DFES(pVolDesc))
				{
					pDfEntry->dfe_Parent->dfe_pDirEntry->de_ChildForkOpenCount --;
				}
#endif
			}
		}
		else
		{
			pDfEntry->dfe_DataLen = forklen.LowPart;
			if (LastClose)
			{
				pDfEntry->dfe_Flags &= ~DFE_FLAGS_D_ALREADYOPEN;
#ifdef	AGE_DFES
				if (IS_VOLUME_AGING_DFES(pVolDesc))
				{
					pDfEntry->dfe_Parent->dfe_pDirEntry->de_ChildForkOpenCount --;
				}
#endif
			}
		}
	}

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
	AfpSwmrRelease(&pVolDesc->vds_ExchangeFilesLock);

	// Now clear up the entry in the Sda
	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

	pSda->sda_cOpenForks--;
	pOpenForkSess = &pSda->sda_OpenForkSess;
	while (OForkRefNum > FORK_OPEN_CHUNKS)
	{
		OForkRefNum -= FORK_OPEN_CHUNKS;
		pOpenForkSess = pOpenForkSess->ofs_Link;
		ASSERT (pOpenForkSess != NULL);
	}

	ASSERT (pOpenForkEntry == pOpenForkSess->ofs_pOpenForkEntry[OForkRefNum-1]);
	pOpenForkSess->ofs_pOpenForkEntry[OForkRefNum-1] = NULL;

	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);

	AfpSdaDereferenceSession(pSda);		// Remove the reference for this fork here

    ASSERT(VALID_CONNDESC(pOpenForkEntry->ofe_pConnDesc));
    AfpConnectionDereference(pOpenForkEntry->ofe_pConnDesc);

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	// All done, close the fork handle and free the OFE
	if (pOpenForkEntry->ofe_ForkHandle != NULL)
	{
		AfpIoClose(&pOpenForkEntry->ofe_FileSysHandle);
	}

	DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
			("AfpForkDereference: Fork %ld is history\n", pOpenForkEntry->ofe_ForkId));

	AfpFreeMemory(pOpenForkEntry);
}


/***	AfpCheckDenyConflict
 *
 *	Check if the requested Open & Deny Modes clash with current open & deny modes.
 *
 *	LOCKS:			ofd_Lock, vds_VolLock (SPIN) IFF ppOpenForkDesc is NULL ELSE
 *	LOCKS_ASSUMED: vds_VolLock (SPIN)
 *
 *	LOCK_ORDER:  ofd_Lock after vds_VolLock
 */
AFPSTATUS
AfpCheckDenyConflict(
	IN	PVOLDESC				pVolDesc,
	IN	DWORD					AfpId,
	IN	BOOLEAN					Resource,
	IN	BYTE					OpenMode,
	IN	BYTE					DenyMode,
	IN	POPENFORKDESC *			ppOpenForkDesc	OPTIONAL
)
{
	KIRQL			OldIrql;
	POPENFORKDESC	pOpenForkDesc;
	AFPSTATUS		Status = AFP_ERR_NONE;
	BOOLEAN			Foundit = False;

	if (ARGUMENT_PRESENT(ppOpenForkDesc))
		 *ppOpenForkDesc = NULL;
	else ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	// check the list of open forks in this volume for any deny conflicts
	for (pOpenForkDesc = pVolDesc->vds_pOpenForkDesc;
		 pOpenForkDesc != NULL;
		 pOpenForkDesc = pOpenForkDesc->ofd_Next)
	{
		BOOLEAN	DescRes;

		// Take the DescLock before looking at AfpId since FpExchangeFiles
		// can change the ID
		ACQUIRE_SPIN_LOCK_AT_DPC(&pOpenForkDesc->ofd_Lock);

		DescRes = (pOpenForkDesc->ofd_Flags & OPEN_FORK_RESOURCE) ? True : False;
		if ((pOpenForkDesc->ofd_FileNumber == AfpId) &&
			!(DescRes ^ Resource))
		{
			Foundit = True;
			// Check that the open & deny modes do not clash with existing
			// settings
			if (((OpenMode & FORK_OPEN_READ)  && (pOpenForkDesc->ofd_cDenyR > 0)) ||
				((OpenMode & FORK_OPEN_WRITE) && (pOpenForkDesc->ofd_cDenyW > 0)) ||
				((DenyMode & FORK_DENY_READ)  && (pOpenForkDesc->ofd_cOpenR > 0)) ||
				((DenyMode & FORK_DENY_WRITE) && (pOpenForkDesc->ofd_cOpenW > 0)))
			{
				Status = AFP_ERR_DENY_CONFLICT;
			}
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&pOpenForkDesc->ofd_Lock);
		if (Foundit)
		{
			break;
        }
	}

	if (ARGUMENT_PRESENT(ppOpenForkDesc))
		 *ppOpenForkDesc = pOpenForkDesc;
	else RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

	return Status;
}


/***	AfpForkOpen
 *
 *	This is called after the fork has been successfully opened. Deny-mode conflicts are
 *	checked and if no conflicts are found, appropriate data structures are created and
 *	linked. If a deny conflict results, return NULL for pOpenForkEntry.
 *
 *	LOCKS:			AfpForksLock (SPIN), vds_VolLock (SPIN), cds_VolLock (SPIN), ofd_Lock (SPIN), ofe_Lock (SPIN)
 *	LOCK_ORDER:		vds_ExchangeFilesLock, then ofd_Lock after vds_VolLock
 *  LOCKS_ASSUMED:	vds_ExchangeFilesLock
 */
AFPSTATUS
AfpForkOpen(
	IN	PSDA				pSda,
	IN	PCONNDESC			pConnDesc,
	IN	PPATHMAPENTITY		pPME,
	IN	PFILEDIRPARM		pFDParm,
	IN	DWORD				AccessMode,
	IN	BOOLEAN				Resource,
	OUT	POPENFORKENTRY *	ppOpenForkEntry,
	OUT	PBOOLEAN			pCleanupExchgLock
)
{

	POPENFORKENTRY	pOpenForkEntry;
	POPENFORKDESC	pOpenForkDesc;
	PVOLDESC		pVolDesc;
	AFPSTATUS		Status = AFP_ERR_NONE;
	KIRQL			OldIrql;
	BYTE			OpenMode, DenyMode;
	BOOLEAN			NewForkDesc = False;

	ASSERT(VALID_CONNDESC(pConnDesc));

	pVolDesc = pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));

	OpenMode = (BYTE)(AccessMode & FORK_OPEN_MASK);
	DenyMode = (BYTE)((AccessMode >> FORK_DENY_SHIFT) & FORK_DENY_MASK);
	*ppOpenForkEntry = NULL;

	if ((pOpenForkEntry = (POPENFORKENTRY)AfpAllocZeroedNonPagedMemory(sizeof(OPENFORKENTRY))) == NULL)
		return AFP_ERR_MISC;

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	Status = AfpCheckDenyConflict(pVolDesc,
								  pFDParm->_fdp_AfpId,
								  Resource,
								  OpenMode,
								  DenyMode,
								  &pOpenForkDesc);

	if (pOpenForkDesc == NULL)
	{
		// This fork has not been opened. We can party.
		if ((pOpenForkDesc = (POPENFORKDESC)AfpAllocZeroedNonPagedMemory(sizeof(OPENFORKDESC))) == NULL)
			Status = AFP_ERR_MISC;
		else
		{
			NewForkDesc = True;
			INITIALIZE_SPIN_LOCK(&pOpenForkDesc->ofd_Lock);
#if DBG
			pOpenForkDesc->Signature = OPENFORKDESC_SIGNATURE;
#endif
			pOpenForkDesc->ofd_pVolDesc = pVolDesc;

			pOpenForkDesc->ofd_FileNumber = pFDParm->_fdp_AfpId;
			pOpenForkDesc->ofd_Flags = Resource ?
								OPEN_FORK_RESOURCE : OPEN_FORK_DATA;
		}
	}

	if ((pOpenForkDesc != NULL) && (Status == AFP_ERR_NONE))
	{
		// A lock is not needed if this is a new fork desc
		if (!NewForkDesc)
		{
			ACQUIRE_SPIN_LOCK_AT_DPC(&pOpenForkDesc->ofd_Lock);
		}

		pOpenForkDesc->ofd_UseCount ++;
		pOpenForkDesc->ofd_cOpenR += (OpenMode & FORK_OPEN_READ);
		pOpenForkDesc->ofd_cOpenW += (OpenMode & FORK_OPEN_WRITE);
		pOpenForkDesc->ofd_cDenyR += (DenyMode & FORK_DENY_READ);
		pOpenForkDesc->ofd_cDenyW += (DenyMode & FORK_DENY_WRITE);

		if (NewForkDesc)
		{
			// Now link this into the volume descriptor but only if it is a
			// new forkdesc. Explicitly reference the volume descriptor. We
			// cannot call AfpVolumeReference here since we already own the
			// volume lock Moreover since the connection is owning it, the
			// volume is OK. Initialize the volume relative path of the file
			// being opened from the PME.
            pOpenForkDesc->ofd_FilePath = pPME->pme_FullPath;
            pOpenForkDesc->ofd_FileName = pPME->pme_UTail;

			// Set the pme_FullPath to NULL so that it does not get freed up
            pPME->pme_FullPath.Buffer = NULL;

			DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
					("AfpForksOpen: Initializing forkdesc with path %Z(%lx), name %Z(%lx)\n",
					&pOpenForkDesc->ofd_FilePath, pOpenForkDesc->ofd_FilePath.Buffer,
					&pOpenForkDesc->ofd_FileName, pOpenForkDesc->ofd_FileName.Buffer));

			pVolDesc->vds_RefCount ++;
			AfpLinkDoubleAtHead(pVolDesc->vds_pOpenForkDesc,
								pOpenForkDesc,
								ofd_Next,
								ofd_Prev);
		}
		else
		{
			RELEASE_SPIN_LOCK_FROM_DPC(&pOpenForkDesc->ofd_Lock);
		}
	}

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

	if ((pOpenForkDesc == NULL) || (Status != AFP_ERR_NONE))
	{
		AfpFreeMemory(pOpenForkEntry);
		return Status;
	}

	ASSERT (Status == AFP_ERR_NONE);

	// All seems to be fine, so far. We'll go ahead and create the appropriate
	// data structures and link them in. In case of errors we'll back out.
	do
	{
#if DBG
		pOpenForkEntry->Signature = OPENFORKENTRY_SIGNATURE;
#endif
		INITIALIZE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock);
        pOpenForkEntry->ofe_pSda = pSda;

        if (AfpConnectionReferenceByPointer(pConnDesc) == NULL)
        {
	        DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_ERR,
                ("AfpForkOpen: couldn't reference pConnDesc\n"));
		    AfpFreeMemory(pOpenForkEntry);
			return AFP_ERR_MISC;
        }
		pOpenForkEntry->ofe_pConnDesc = pConnDesc;
		pOpenForkEntry->ofe_pOpenForkDesc = pOpenForkDesc;
		pOpenForkEntry->ofe_OpenMode = OpenMode;
		pOpenForkEntry->ofe_DenyMode = DenyMode;
		pOpenForkEntry->ofe_FileSysHandle = pPME->pme_Handle;
		pOpenForkEntry->ofe_Flags = Resource ?
										OPEN_FORK_RESOURCE : OPEN_FORK_DATA;
		// One reference for creation and the other for the api to dereference.
		pOpenForkEntry->ofe_RefCount = 2;
		if (!afpForkGetNewForkRefNumAndLinkInSda(pSda, pOpenForkEntry))
        {
		    AfpFreeMemory(pOpenForkEntry);
            AfpConnectionDereference(pConnDesc);
	            DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_ERR,("AfpForkOpen: ...LinkInSda failed\n"));
			return AFP_ERR_MISC;
        }

		// Now link this in global list
		ACQUIRE_SPIN_LOCK(&AfpForksLock, &OldIrql);

        ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);
        pSda->sda_cOpenForks++;
        RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

		pOpenForkEntry->ofe_ForkId = afpNextForkId ++;
		AfpLinkDoubleAtHead(AfpOpenForksList,
							pOpenForkEntry,
							ofe_Next,
							ofe_Prev);
		AfpNumOpenForks ++;

		RELEASE_SPIN_LOCK(&AfpForksLock, OldIrql);

		if (NewForkDesc)
		{
			ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

			if ((Status = AfpSetDFFileFlags(pVolDesc,
											pFDParm->_fdp_AfpId,
											Resource ?
												DFE_FLAGS_R_ALREADYOPEN :
												DFE_FLAGS_D_ALREADYOPEN,
											False,
											False)) != AFP_ERR_NONE)
			{
				break;
			}
		}

		if (NT_SUCCESS(Status))
		{
			*ppOpenForkEntry = pOpenForkEntry;
			Status = AFP_ERR_NONE;
		}
		else
		{
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
		}
	} while (False);

	// Perform cleanup here, if we failed for any reason
	if (Status != AFP_ERR_NONE)
	{
		ASSERT (pOpenForkEntry != NULL);
		ACQUIRE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock, &OldIrql);

		pOpenForkEntry->ofe_Flags |= OPEN_FORK_CLOSING;

		RELEASE_SPIN_LOCK(&pOpenForkEntry->ofe_Lock, OldIrql);

		// We must free this lock on behalf of AfpFspDispOpenFork because
		// the act of dereferencing it will end up calling ForkClose which
		// also must take this lock.  Indicate to caller that he should not
		// attempt to release this lock again.
		AfpSwmrRelease(&pVolDesc->vds_ExchangeFilesLock);
		*pCleanupExchgLock = False;

        // remove the refcount for the api (which won't see this pOpenForkEntry)
		AfpForkDereference(pOpenForkEntry);

        // remove the creation refcount
		AfpForkDereference(pOpenForkEntry);
                
        //
        //  Dereferencing the open fork entry will close the handle passed
        //  to us.  NULL out the callers handle value so the caller does
        //  not try to close it again.
        //

        pPME->pme_Handle.fsh_FileHandle = NULL;
	}

	return Status;
}


/***	AfpForkLockOperation
 *
 *	Called for both ByteRangeLock/Unlock as well as Read/Write.
 *	For Lock, a check is made to ensure the requested range does not
 *	overlap an existing range FROM ANY OPEN FORK.
 *	For Unlock, the requested range MUST MATCH exactly with an existing
 *	locked range.
 *	For IO, return the effective range where IO is possible - could be
 *	potentially be an empty range. Note in this case that the start of
 *	the range must be free to get a non-empty range. For an empty range
 *	AFP_ERR_LOCK is returned. For a non-empty range AFP_ERR_NONE.
 *
 *	Locks are maintained in a sorted (descending) order from the OpenForkDesc.
 *	The search can be abandoned if the start of the requested range is
 *	larger than the end of the encountered range.
 *
 *	LOCKS:	ofd_Lock (SPIN)
 */
AFPSTATUS
AfpForkLockOperation(
	IN		PSDA			pSda,
	IN		POPENFORKENTRY	pOpenForkEntry,
	IN OUT	PFORKOFFST		pOffset,
	IN OUT	PFORKSIZE       pSize,
	IN		LOCKOP			Operation,	// LOCK, UNLOCK or IOCHECK
	IN		BOOLEAN			EndFlag		// If True range is from end, else start
)
{
	POPENFORKDESC		pOpenForkDesc;
	PFORKLOCK			pForkLock, pForkLockNew, *ppForkLock;
	IO_STATUS_BLOCK		IoStsBlk;
	PFAST_IO_DISPATCH	pFastIoDisp;
	KIRQL				OldIrql;
	AFPSTATUS			Status;
	LONG				Offset, Size;
	DWORD				EndOff;
	BOOLEAN				UnlockForkDesc = True;

	DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
			("AfpForkLockOperation: (%s) - (%ld,%ld,%ld,%ld)\n",
			(Operation == LOCK) ? "Lock" : ((Operation == UNLOCK) ? "Unlock" : "Io"),
			pOffset->LowPart, pSize->LowPart,
			pOpenForkEntry->ofe_ForkId, pSda->sda_SessionId));

	if (EndFlag)
	{
		LONG	Off;

		Size = pSize->LowPart;
		if (pSize->QuadPart < 0)
		{
			FORKSIZE	FSize;

			FSize.QuadPart = -(pSize->QuadPart);
			Size = -(LONG)(FSize.LowPart);
		}
		Off = pOffset->LowPart;
		if (pOffset->QuadPart < 0)
		{
			FORKSIZE	FOffset;

			FOffset.QuadPart = -(pOffset->QuadPart);
			Off = -(LONG)(FOffset.LowPart);
		}

		if ((Status = afpForkConvertToAbsOffSize(pOpenForkEntry,
												 Off,
												 &Size,
												 pOffset)) != AFP_ERR_NONE)
			return Status;
		pSize->QuadPart = Size;

		DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
				("AfpForkLockOperation: Effective (%s) - (%ld,%ld,%ld,%ld)\n",
				(Operation == LOCK) ? "Lock" : ((Operation == UNLOCK) ? "Unlock" : "Io"),
				pOffset->LowPart, Size,
				pOpenForkEntry->ofe_ForkId,
				pSda->sda_SessionId));
	}

	Offset = pOffset->LowPart;
	Size = pSize->LowPart;

	// Walk down the list and check. If the option is to lock, then no locks
	// should conflict. If the option is to unlock, then the lock should
	// exist and owned. If the option is to check for Io, then either the
	// overlapped range be 'owned' or the start of the range must not overap
	// OPTIMIZATION - if there is only one instance of this fork open, then
	// all locks belong to this fork and hence there can be no conflicts.
	pOpenForkDesc = pOpenForkEntry->ofe_pOpenForkDesc;

	ASSERT (pOpenForkDesc->ofd_UseCount > 0);

	if ((Operation == IOCHECK) &&
		(pOpenForkDesc->ofd_UseCount == 1))
	{
		DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
				("AfpForkLockOperation: Skipping for IOCHECK - UseCount %ld ,Locks %ld\n",
				pOpenForkDesc->ofd_UseCount, pOpenForkDesc->ofd_NumLocks));
		return AFP_ERR_NONE;
	}

	// Set default error code.
	Status = (Operation == UNLOCK) ? AFP_ERR_RANGE_NOT_LOCKED : AFP_ERR_NONE;

	EndOff = (DWORD)Offset + (DWORD)Size - 1;

	ACQUIRE_SPIN_LOCK(&pOpenForkDesc->ofd_Lock, &OldIrql);

	for (ppForkLock = &pOpenForkDesc->ofd_pForkLock;
		 (pForkLock = *ppForkLock) != NULL;
		 ppForkLock = &pForkLock->flo_Next)
	{
		DWORD	LEndOff;

		// There are 4 possible ways locks can overlap
		//
		//		1					2
		//	+-----------+		+-----------+
		//	|			|		|			|
		//			|				|
		//			+-- LockRange --+
		//			|				|
		//				|	3	|
		//				+-------+
		//		|			4			|
		//		+-----------------------+

		DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
				("AfpForkLockOperation: (%s) - Found (%ld,%ld,%ld,%ld)\n",
				(Operation == LOCK) ? "Lock" : ((Operation == UNLOCK) ? "Unlock" : "Io"),
				pForkLock->flo_Offset, pForkLock->flo_Size,
				pForkLock->flo_pOpenForkEntry->ofe_ForkId,
				pForkLock->flo_Key));

		// Calculate the end point of the current locked range
		LEndOff = (DWORD)(pForkLock->flo_Offset) + (DWORD)(pForkLock->flo_Size) - 1;

		// The list is ordered by descending flo_Offset. We can stop scanning
		// if the start of the requested range is more than the end of the
		// current locked range.
		if ((DWORD)Offset > LEndOff)
		{
			DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
					("AfpForkLockOperation: %s Request (%ld, %ld) - Current (%ld,%ld), %s\n",
					(Operation == LOCK) ? "Lock" : ((Operation == UNLOCK) ? "Unlock" : "Io"),
					Offset, Size, pForkLock->flo_Offset, pForkLock->flo_Size,
					(Operation == UNLOCK) ?  "failing" : "success"));
			break;
		}

		// The end of the requested range is beyond the locked range ?
		// continue scanning.
		if (EndOff < (DWORD)(pForkLock->flo_Offset))
		{
			DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
					("AfpForkLockOperation: %s Request (%ld, %ld) - Current (%ld,%ld), skipping\n",
					(Operation == LOCK) ? "Lock" : ((Operation == UNLOCK) ? "Unlock" : "Io"),
					Offset, Size, pForkLock->flo_Offset,
					pForkLock->flo_Size,
					(Operation == UNLOCK) ?  "failing" : "success"));
			continue;
		}

		// We have either a match or an overlap.
		if (Operation == LOCK)
		{
			// For a lock request it is a failure.
			DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_WARN,
					("AfpForkLockOperation: Lock Request (%ld, %ld) - Current (%ld,%ld), failing\n",
					Offset, Size, pForkLock->flo_Offset, pForkLock->flo_Size));
			Status = (pForkLock->flo_pOpenForkEntry == pOpenForkEntry) ?
							  AFP_ERR_RANGE_OVERLAP : AFP_ERR_LOCK;
		}
		else if (Operation == UNLOCK)
		{
			// For an unlock request, we must have an exact match. Also the session key
			// and the OpenForkEntry must match
			if ((Offset == pForkLock->flo_Offset) &&
				(Size == pForkLock->flo_Size) &&
				(pForkLock->flo_Key == pSda->sda_SessionId) &&
				(pForkLock->flo_pOpenForkEntry == pOpenForkEntry))
			{
				// Unlink this lock from the list
				*ppForkLock = pForkLock->flo_Next;
				pOpenForkDesc->ofd_NumLocks --;
				pOpenForkEntry->ofe_cLocks --;
				RELEASE_SPIN_LOCK(&pOpenForkDesc->ofd_Lock, OldIrql);
                UnlockForkDesc = False;
				DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
						("AfpForkLockOperation: (Unlock) Deleting Range,Key (%ld,%ld,%ld,%ld)\n",
						Offset, Size, pOpenForkEntry->ofe_ForkId, pSda->sda_SessionId));

				// Try the fast I/O path first.  If that fails, call AfpIoForkUnlock
				// to use the normal build-an-IRP path.
				pFastIoDisp = pOpenForkEntry->ofe_pDeviceObject->DriverObject->FastIoDispatch;
				if ((pFastIoDisp != NULL) &&
					(pFastIoDisp->FastIoUnlockSingle != NULL) &&
					pFastIoDisp->FastIoUnlockSingle(AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject),
											pOffset,
											pSize,
											AfpProcessObject,
											pSda->sda_SessionId,
											&IoStsBlk,
											pOpenForkEntry->ofe_pDeviceObject))
				{
					DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
							("AfpForkLockOperation: Fast Unlock Succeeded\n"));
#ifdef			PROFILING
					// The fast I/O path worked. Update profile
					INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoSucceeded));
#endif  		
					INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_CurrentFileLocks,
										  (ULONG)-1,
										  &AfpStatisticsLock);
					Status = AFP_ERR_NONE;
				}
				else
				{
#ifdef	PROFILING
					INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoFailed));
#endif
					Status = AfpIoForkLockUnlock(pSda, pForkLock, pOffset, pSize, FUNC_UNLOCK);
				}
				AfpIOFreeBuffer(pForkLock);
			}
			else
			{
				DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_WARN,
						("AfpForkLockOperation: UnLock Request (%ld, %ld) - Current (%ld,%ld), failing\n",
						Offset, Size, pForkLock->flo_Offset, pForkLock->flo_Size));
			}
		}
		else
		{
			ASSERT (Operation == IOCHECK);

			// Check if this is a conflict
			if (pForkLock->flo_Key != pSda->sda_SessionId)
			{
				if ((Offset < pForkLock->flo_Offset) &&
					(EndOff >= (DWORD)(pForkLock->flo_Offset)))
				{
					pSize->LowPart = (pForkLock->flo_Offset - Offset);
				}
				else Status =  AFP_ERR_LOCK;
				DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
						("AfpForkLockOperation: Conflict found\n"));
			}
			else
			{
				DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
						("AfpForkLockOperation: Our own lock found, ignoring\n"));
			}
		}
		break;
	}

	// We have the right status code. Do the needful
	if (Operation == LOCK)
	{
		if (Status == AFP_ERR_NONE)
		{
			Status = AFP_ERR_MISC;
			// Allocate the locks out of the pool.
			if ((pForkLockNew = (PFORKLOCK)AfpIOAllocBuffer(sizeof(FORKLOCK))) != NULL)
			{
#if DBG
				pForkLockNew->Signature = FORKLOCK_SIGNATURE;
#endif
				// Link this in such that the list is sorted in ascending order.
				// ppForkLock points to the place where the new lock will be
				// added, pForkLock is the next in the list.
				pForkLockNew->flo_Next = pForkLock;
				*ppForkLock = pForkLockNew;

				pForkLockNew->flo_Key = pSda->sda_SessionId;
				pForkLockNew->flo_pOpenForkEntry = pOpenForkEntry;
				pForkLockNew->flo_Offset = Offset;
				pForkLockNew->flo_Size = Size;
				pOpenForkDesc->ofd_NumLocks ++;
				pOpenForkEntry->ofe_cLocks ++;
				RELEASE_SPIN_LOCK(&pOpenForkDesc->ofd_Lock, OldIrql);
                UnlockForkDesc = False;

				DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
						("AfpForkLockOperation: Adding Range,Key (%ld,%ld,%ld,%ld)\n",
						Offset, Size,
						pOpenForkEntry->ofe_ForkId, pSda->sda_SessionId));

				// Try the fast I/O path first.  If that fails, fall through to the
				// normal build-an-IRP path.
				pFastIoDisp = pOpenForkEntry->ofe_pDeviceObject->DriverObject->FastIoDispatch;
				if ((pFastIoDisp != NULL) &&
					(pFastIoDisp->FastIoLock != NULL) &&
					pFastIoDisp->FastIoLock(AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject),
											pOffset,
											pSize,
											AfpProcessObject,
											pSda->sda_SessionId,
											True,		// Fail immediately
											True,		// Exclusive
											&IoStsBlk,
											pOpenForkEntry->ofe_pDeviceObject))
				{
					if (NT_SUCCESS(IoStsBlk.Status) ||
						(IoStsBlk.Status == STATUS_LOCK_NOT_GRANTED))
					{
						DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
								("AfpIoForkLock: Fast Lock Succeeded\n"));
		
#ifdef	PROFILING
						// The fast I/O path worked. Update profile
						INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoSucceeded));
#endif
						if (IoStsBlk.Status == STATUS_LOCK_NOT_GRANTED)
						{
							Status = AFP_ERR_LOCK;
						}
						else
						{
							Status = AFP_ERR_NONE;
							INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_CurrentFileLocks,
												  1,
												  &AfpStatisticsLock);
						}
					}
				}
				else
				{
#ifdef	PROFILING
					INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoFailed));
#endif

					Status = AfpIoForkLockUnlock(pSda, pForkLockNew, pOffset, pSize, FUNC_LOCK);
				}

				if ((Status != AFP_ERR_NONE) &&
					(Status != AFP_ERR_EXTENDED) &&
					(Status != AFP_ERR_QUEUE))
				{
					// Undo the above work
					DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_ERR,
							("AfpForkLockOperation: AfpIoForkLock failed %lx, aborting for range %ld,%ld\n",
							Status, Offset, EndOff));
					AfpForkLockUnlink(pForkLockNew);
				}
			}
		}
	}
	if (UnlockForkDesc)
		RELEASE_SPIN_LOCK(&pOpenForkDesc->ofd_Lock, OldIrql);

	return Status;
}


/***	AfpForkLockUnlink
 *
 *	Unlink this lock from its open file descriptor and free it.
 */
VOID
AfpForkLockUnlink(
	IN	PFORKLOCK		pForkLock
)
{
	POPENFORKDESC	pOpenForkDesc = pForkLock->flo_pOpenForkEntry->ofe_pOpenForkDesc;
	PFORKLOCK *		ppForkLock;
	PFORKLOCK 		pTmpForkLock;
	KIRQL			OldIrql;

	ACQUIRE_SPIN_LOCK(&pOpenForkDesc->ofd_Lock, &OldIrql);

	pOpenForkDesc->ofd_NumLocks --;
	pForkLock->flo_pOpenForkEntry->ofe_cLocks --;
	
	for (ppForkLock = &pOpenForkDesc->ofd_pForkLock;
		 (pTmpForkLock = *ppForkLock) != NULL;
		 ppForkLock = &pTmpForkLock->flo_Next)
	{
		if (*ppForkLock == pForkLock)
		{
			*ppForkLock = pForkLock->flo_Next;
			break;
		}
	}
	RELEASE_SPIN_LOCK(&pOpenForkDesc->ofd_Lock, OldIrql);
	AfpIOFreeBuffer(pForkLock);
}


/***	afpForkConvertToAbsOffSize
 *
 *	Convert the offset,size pair as supplied by the client to their absolute
 *	values.
 */
LOCAL	AFPSTATUS
afpForkConvertToAbsOffSize(
	IN	POPENFORKENTRY	pOpenForkEntry,
	IN	LONG			Offset,
	IN OUT	PLONG		pSize,
	OUT	PFORKOFFST		pAbsOffset
)
{
	AFPSTATUS	Status;

	PAGED_CODE ();

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
		("afpForkConvertToAbsOffSize: Converting %ld, %ld\n", Offset, *pSize));

	// We are relative to the end, then convert it to absolute
	if ((Status = AfpIoQuerySize(&pOpenForkEntry->ofe_FileSysHandle,
								 pAbsOffset)) == AFP_ERR_NONE)
	{
		FORKOFFST	EndRange, MaxOffset;

		MaxOffset.QuadPart = Offset;
		pAbsOffset->QuadPart += MaxOffset.QuadPart;
		MaxOffset.QuadPart = MAXLONG;

		// Now we have the *pAbsOffset and Size. Normalize the size.
		// if the *pAbsOffset is > MAXLONG, refuse this.
		if ((pAbsOffset->QuadPart > MaxOffset.QuadPart) ||
			(pAbsOffset->QuadPart < 0))
			Status = AFP_ERR_PARAM;

		else
		{
			EndRange.QuadPart = pAbsOffset->QuadPart + *pSize;
			if (EndRange.QuadPart >= MaxOffset.QuadPart)
				*pSize = (MAXLONG - pAbsOffset->LowPart);

			DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
					("afpForkConvertToAbsOffSize: Converted to %ld, %ld\n",
					pAbsOffset->LowPart, *pSize));
            Status = AFP_ERR_NONE;
		}
	}

	return Status;
}


/***	AfpAdmWForkClose
 *
 *	Close a fork forcibly. This is an admin operation and must be queued
 *	up since this can potentially cause filesystem operations that are valid
 *	only in the system process context.
 */
AFPSTATUS
AfpAdmWForkClose(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	PAFP_FILE_INFO	pFileInfo = (PAFP_FILE_INFO)InBuf;
	POPENFORKENTRY	pOpenForkEntry;
	DWORD			ForkId;
	AFPSTATUS		Status = AFPERR_InvalidId;

	if ((ForkId = pFileInfo->afpfile_id) != 0)
	{
		if ((pOpenForkEntry = AfpForkReferenceById(ForkId)) != NULL)
		{
			AfpForkClose(pOpenForkEntry);

			AfpForkDereference(pOpenForkEntry);

			Status = AFP_ERR_NONE;
		}
	}
	else
	{
		BOOLEAN			Shoot;
		DWORD			ForkId = MAXULONG;
		KIRQL			OldIrql;

		Status = AFP_ERR_NONE;
		while (True)
		{
			ACQUIRE_SPIN_LOCK(&AfpForksLock, &OldIrql);

			for (pOpenForkEntry = AfpOpenForksList;
				 pOpenForkEntry != NULL;
				 pOpenForkEntry = pOpenForkEntry->ofe_Next)
			{
				if (pOpenForkEntry->ofe_ForkId > ForkId)
					continue;

				ForkId = pOpenForkEntry->ofe_ForkId;

				Shoot = False;

				ACQUIRE_SPIN_LOCK_AT_DPC(&pOpenForkEntry->ofe_Lock);

				if (!(pOpenForkEntry->ofe_Flags & OPEN_FORK_CLOSING))
				{
					pOpenForkEntry->ofe_RefCount ++;
					Shoot = True;
				}

				RELEASE_SPIN_LOCK_FROM_DPC(&pOpenForkEntry->ofe_Lock);

				if (Shoot)
				{
					RELEASE_SPIN_LOCK(&AfpForksLock, OldIrql);

					AfpForkClose(pOpenForkEntry);

					AfpForkDereference(pOpenForkEntry);

					break;
				}
			}
			if (pOpenForkEntry == NULL)
			{
				RELEASE_SPIN_LOCK(&AfpForksLock, OldIrql);
				break;
			}
		}
	}
	return Status;
}


/***	afpForkGetNewForkRefNumAndLinkInSda
 *
 *	Assign a new OForkRefNum to a fork that is being opened. The smallest one
 *	is always allocated. Make the right entry in the SDA point to the
 *	OpenForkEntry.
 *
 *	LOCKS: sda_Lock (SPIN)
 */
LOCAL BOOLEAN
afpForkGetNewForkRefNumAndLinkInSda(
	IN	PSDA			pSda,
	IN	POPENFORKENTRY	pOpenForkEntry
)
{
	POPENFORKSESS	pOpenForkSess;
	KIRQL			OldIrql;
	USHORT			i;
	USHORT			OForkRefNum = 1;
	BOOLEAN			Found = False;

	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

	pOpenForkSess = &pSda->sda_OpenForkSess;
	pOpenForkEntry->ofe_OForkRefNum = 0;
	while (!Found)
	{
		for (i = 0; i < FORK_OPEN_CHUNKS; i++, OForkRefNum++)
		{
			if (pOpenForkSess->ofs_pOpenForkEntry[i] == NULL)
			{
				pOpenForkSess->ofs_pOpenForkEntry[i] = pOpenForkEntry;
				pOpenForkEntry->ofe_OForkRefNum = OForkRefNum;
				Found = True;
				break;
			}
		}
		if (!Found)
		{
			if (pOpenForkSess->ofs_Link != NULL)
			{
				pOpenForkSess = pOpenForkSess->ofs_Link;
				continue;
			}
			if ((pOpenForkSess->ofs_Link = (POPENFORKSESS)AfpAllocZeroedNonPagedMemory(sizeof(OPENFORKSESS))) != NULL)
			{
				pOpenForkSess->ofs_Link->ofs_pOpenForkEntry[0] = pOpenForkEntry;
				pOpenForkEntry->ofe_OForkRefNum = OForkRefNum;
				Found = True;
			}
			break;
		}
	}

	if (Found)
	{
		// Reference sda for this fork and up the MaxOForkRefNum, if needed
		pSda->sda_RefCount ++;
		if (OForkRefNum > pSda->sda_MaxOForkRefNum)
	        pSda->sda_MaxOForkRefNum = OForkRefNum;
	}

	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);
	return Found;
}

/***	AfpExchangeForkAfpIds
 *
 *	When an FpExchangeFiles occurs, if the data or resource fork of either
 *  of the 2 files being exchanged is open, we must fix up the AfpId kept
 *  in the OpenForkDesc structure.  This is because when the final close
 *  is done on the fork, the cleanup code must clear the DFE_X_ALREADYOPEN
 *  flag in the corresponding DFEntry of the Idindex database.
 *
 *	LOCKS:			ofd_Lock (SPIN), vds_VolLock (SPIN)
 *  LOCK_ORDER: 	ofd_Lock after vds_VolLock
 *  LOCKS_ASSUMED:	vds_IdDbAccessLock (SWMR, Exclusive)
 */
VOID
AfpExchangeForkAfpIds(
	IN	PVOLDESC	pVolDesc,
	IN	DWORD		AfpId1,
	IN	DWORD		AfpId2
)
{
	KIRQL			OldIrql;
	POPENFORKDESC	pOpenForkDesc;
	AFPSTATUS		Status = AFP_ERR_NONE;

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	// check the list of open forks in this volume for the IDs specified
	for (pOpenForkDesc = pVolDesc->vds_pOpenForkDesc;
		 pOpenForkDesc != NULL;
		 pOpenForkDesc = pOpenForkDesc->ofd_Next)
	{
		ACQUIRE_SPIN_LOCK_AT_DPC(&pOpenForkDesc->ofd_Lock);
		if (pOpenForkDesc->ofd_FileNumber == AfpId1)
		{
			pOpenForkDesc->ofd_FileNumber = AfpId2;
		}
		else if (pOpenForkDesc->ofd_FileNumber == AfpId2)
		{
			pOpenForkDesc->ofd_FileNumber = AfpId1;
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&pOpenForkDesc->ofd_Lock);

	}

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\forks.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	forks.h

Abstract:

	This module contains the data structures to handle open forks.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _FORKS_
#define _FORKS_

// Afp Open modes
#define	FORK_OPEN_NONE		0x00
#define	FORK_OPEN_READ		0x01
#define	FORK_OPEN_WRITE		0x02
#define	FORK_OPEN_READWRITE	0x03
#define	FORK_OPEN_MASK		0x03

// The Deny mode values are shifted left 2 bits and or'd with the open modes
// in AfpOpenFork() API.
#define	FORK_DENY_SHIFT		4

#define	FORK_DENY_NONE		0x00
#define	FORK_DENY_READ		0x01
#define	FORK_DENY_WRITE		0x02
#define	FORK_DENY_ALL		0x03
#define	FORK_DENY_MASK		0x03

// AfpOpenFork SubFunction values
#define	FORK_DATA			0
#define	FORK_RSRC			0x80

#define	AFP_UNLOCK_FLAG		1
#define	AFP_END_FLAG		0x80

/*
 * A ForkLock describes a lock on the fork. The locks are anchored at the
 * OpenForkDesc structure. The list describes all locks for this fork by
 * all sessions and all OForkRefNums. flo_key and flo_OForkRefNum identifies
 * the lock uniquely.
 */
#if DBG
#define	FORKLOCK_SIGNATURE			*(DWORD *)"FLO"
#define	VALID_FORKLOCK				(((pForkLock) != NULL) && \
									 ((pForkLock)->Signature == FORKLOCK_SIGNATURE))
#else
#define	VALID_FORKLOCK				((pForkLock) != NULL)
#endif

// Forward reference for the ForkLock structure
struct	_OpenForkEntry;

typedef struct _ForkLock
{
#if	DBG
	DWORD					Signature;
	DWORD					QuadAlign1;
#endif
	struct _ForkLock *		flo_Next;		// ForkDesc links
	struct _OpenForkEntry * flo_pOpenForkEntry;
	DWORD					QuadAlign2;
											// The owning OFE for this lock
	LONG					flo_Offset;		// Beginning of lock
	LONG					flo_Size;		// Size of lock
	DWORD					flo_Key;		// Key for this lock, essentially the
											// SessionId from the SDA
} FORKLOCK, *PFORKLOCK;

/*
 * An OpenForkDesc represents an open-fork. The list is anchored at the volume
 * Descriptor. There is exactly one entry per file/fork. Multiple instances of
 * open just ups the reference count. The list of locks originating here is for
 * all instances. A back link to the Volume descriptor exists for comfort.
 */
#if	DBG
#define	OPENFORKDESC_SIGNATURE		*(DWORD *)"OFD"
#define	VALID_OPENFORKDESC(pOpenForkDesc)	(((pOpenForkDesc) != NULL) && \
						((pOpenForkDesc)->Signature == OPENFORKDESC_SIGNATURE))
#else
#define	VALID_OPENFORKDESC(pOpenForkDesc)	((pOpenForkDesc) != NULL)
#endif

typedef struct _OpenForkDesc
{
#if	DBG
	DWORD					Signature;
	DWORD					QuadAlign1;
#endif
	struct _OpenForkDesc *	ofd_Next;			// Volume links
	struct _OpenForkDesc **	ofd_Prev;			// Volume links

	struct _VolDesc *		ofd_pVolDesc;		// Pointer to the volume descriptor
	PFORKLOCK				ofd_pForkLock;		// List of file locks
	DWORD					ofd_FileNumber;		// File number of the open file
	LONG					ofd_UseCount;		// Number of OpenForkEntry refs.
	USHORT					ofd_cOpenR;			// # of instances of open for read
	USHORT					ofd_cOpenW;			// # of instances of open for write
	USHORT					ofd_cDenyR;			// # of instances of deny read
	USHORT					ofd_cDenyW;			// # of instances of deny write
	USHORT					ofd_NumLocks;		// Number of file locks
	USHORT					ofd_Flags;			// OPEN_FORK_xxx bits
	AFP_SPIN_LOCK				ofd_Lock;			// Lock for this descriptor
	UNICODE_STRING			ofd_FileName;		// Name of the file (w/o the stream)
	UNICODE_STRING			ofd_FilePath;		// Volume relative path to the file
} OPENFORKDESC, *POPENFORKDESC;


#define	OPEN_FORK_RESOURCE			True
#define	OPEN_FORK_DATA				False
#define	OPEN_FORK_CLOSING			0x8000
// To determine whether FlushFork of resource should really take the current
// ChangeTime to be the LastWriteTime
#define OPEN_FORK_WRITTEN			0x0100

/*
 * An OpenForkEntry represents an OForkRefNum. Every instance of an open
 * fork has an entry here. This list is anchored in the SDA. A global open
 * fork list used by the admin APIs is also linked to this.
 */
#if DBG
#define	OPENFORKENTRY_SIGNATURE		*(DWORD *)"OFE"
#define	VALID_OPENFORKENTRY(pOpenForkEntry)	\
						(((pOpenForkEntry) != NULL) && \
						 ((pOpenForkEntry)->Signature == OPENFORKENTRY_SIGNATURE))
#else
#define	VALID_OPENFORKENTRY(pOpenForkEntry) ((pOpenForkEntry) != NULL)
#endif

typedef struct _OpenForkEntry
{
#if	DBG
	DWORD					Signature;
#endif

	struct _OpenForkEntry *	ofe_Next;			// Global links
	struct _OpenForkEntry **ofe_Prev;			// Global links

	struct _OpenForkDesc *	ofe_pOpenForkDesc;	// Pointer to the descriptor
    struct _SessDataArea *  ofe_pSda;           // Identifies the owning session
	struct _ConnDesc *	    ofe_pConnDesc;	    // Identifies the owning connection
	
	FILESYSHANDLE			ofe_FileSysHandle;	// The file system handles
#define	ofe_ForkHandle		ofe_FileSysHandle.fsh_FileHandle
#define	ofe_pFileObject		ofe_FileSysHandle.fsh_FileObject
#define	ofe_pDeviceObject	ofe_FileSysHandle.fsh_DeviceObject

	DWORD					ofe_OForkRefNum;	// Open Fork reference number
	DWORD					ofe_ForkId;			// Unique file id used by admin.
												// Not re-cycled
	BYTE					ofe_OpenMode;		// Open modes - AFP
	BYTE					ofe_DenyMode;		// Deny modes - AFP
	USHORT					ofe_Flags;			// Flag bits defined above
	LONG					ofe_RefCount;		// Count of references to this entry
	LONG					ofe_cLocks;			// Number of locks on this fork
	AFP_SPIN_LOCK				ofe_Lock;			// Lock for manipulating locks etc.
} OPENFORKENTRY, *POPENFORKENTRY;



#define	RESCFORK(pOpenForkEntry)	\
		(((pOpenForkEntry)->ofe_Flags & OPEN_FORK_RESOURCE) ? True : False)

#define	DATAFORK(pOpenForkEntry)	(!RESCFORK(pOpenForkEntry))

#define	FORK_OPEN_CHUNKS	7
typedef struct _OpenForkSession
{
	POPENFORKENTRY	ofs_pOpenForkEntry[FORK_OPEN_CHUNKS];
										// Pointer to actual entry
	struct _OpenForkSession *ofs_Link;	// Link to next cluster
} OPENFORKSESS, *POPENFORKSESS;

// Used by AfpForkLockOperation call.
typedef	enum
{
	LOCK = 1,
	UNLOCK,
	IOCHECK,
} LOCKOP;

GLOBAL	POPENFORKENTRY	AfpOpenForksList EQU NULL; // List of open forks
GLOBAL	DWORD			AfpNumOpenForks EQU 0;	// Total # of open forks
GLOBAL	AFP_SPIN_LOCK		AfpForksLock EQU { 0 };	// Lock for AfpOpenForksList,
												// and AfpNumOpenForks
extern
NTSTATUS
AfpForksInit(
	VOID
);

extern
POPENFORKENTRY FASTCALL
AfpForkReferenceByRefNum(
	IN	struct _SessDataArea *	pSda,
 	IN	DWORD					OForkRefNum
);

extern
POPENFORKENTRY FASTCALL
AfpForkReferenceByPointer(
	IN	POPENFORKENTRY			pOpenForkEntry
);

extern
POPENFORKENTRY FASTCALL
AfpForkReferenceById(
	IN	DWORD					ForkId
);

extern
VOID FASTCALL
AfpForkDereference(
	IN	POPENFORKENTRY			pOpenForkEntry
);

extern
AFPSTATUS
AfpForkOpen(
	IN	struct _SessDataArea *	pSda,
	IN	struct _ConnDesc *		pConnDesc,
	IN	struct _PathMapEntity *	pPME,
	IN	struct _FileDirParms *	pFDParm,
	IN	DWORD					AccessMode,
	IN	BOOLEAN					Resource,
	OUT	POPENFORKENTRY *		ppOpenForkEntry,
	OUT	PBOOLEAN				pCleanupExchgLock
);

extern
VOID
AfpForkClose(
	IN	POPENFORKENTRY			pOpenForkEntry
);

extern
AFPSTATUS
AfpCheckDenyConflict(
	IN	struct _VolDesc	*		pVolDesc,
	IN	DWORD					AfpId,
	IN	BOOLEAN					Resource,
	IN	BYTE					OpenMode,
	IN	BYTE					DenyMode,
	IN	POPENFORKDESC *			ppOpenForkDesc	OPTIONAL
);

extern
AFPSTATUS
AfpForkLockOperation(
	IN	struct _SessDataArea *	pSda,
	IN	POPENFORKENTRY			pOpenForkEntry,
	IN OUT	PFORKOFFST      	pOffset,
	IN OUT	PFORKSIZE       	pSize,
	IN	LOCKOP					Operation,	// LOCK, UNLOCK or IOCHECK
	IN	BOOLEAN					EndFlag		// If True range is from end, else start
);

extern
VOID
AfpForkLockUnlink(
	IN	PFORKLOCK				pForkLock
);

extern
AFPSTATUS
AfpAdmWForkClose(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
);

extern
VOID
AfpExchangeForkAfpIds(
	IN	struct _VolDesc	*		pVolDesc,
	IN	DWORD		AfpId1,
	IN	DWORD		AfpId2
);

#ifdef FORK_LOCALS

LOCAL	DWORD	afpNextForkId = 1;	// Id to be assigned to an open fork

LOCAL BOOLEAN
afpForkGetNewForkRefNumAndLinkInSda(
	IN	struct _SessDataArea *	pSda,
	IN	POPENFORKENTRY			pOpenForkEntry
);

LOCAL
AFPSTATUS
afpForkConvertToAbsOffSize(
	IN	POPENFORKENTRY			pOpenForkEntry,
	IN	LONG					Offset,
	IN OUT	PLONG				pSize,
	OUT	PFORKOFFST				pAbsOffset
);

#endif	// FORK_LOCALS
#endif	// _FORKS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\fsd_vol.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsd_vol.c

Abstract:

	This module contains the entry points for the AFP volume APIs. The API
	dispatcher calls these. These are all callable from FSD.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FSD_VOL

#include <afp.h>
#include <gendisp.h>


/***	AfpFsdDispOpenVol
 *
 *	This routine implements the AfpOpenVol API. This completes here i.e. it is
 *	not queued up to the Fsp.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	DWORD		Bitmap
 *	sda_Name1		ANSI_STRING	VolName
 *	sda_Name2		ANSI_STRING	VolPassword		OPTIONAL
 */
AFPSTATUS FASTCALL
AfpFsdDispOpenVol(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status;
	struct _RequestPacket
	{
		DWORD	_Bitmap;
	};

	DBGPRINT(DBG_COMP_AFPAPI_VOL, DBG_LEVEL_INFO,
			("AfpFsdDispOpenVol: Entered\n"));

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	if (pSda->sda_Name1.Length > AFP_VOLNAME_LEN)
	{
		return AFP_ERR_PARAM;
	}

	pSda->sda_ReplySize = AfpVolumeGetParmsReplyLength(pReqPkt->_Bitmap,
													pSda->sda_Name1.Length);

	if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
	{
		if (((Status = AfpConnectionOpen(pSda,
										 &pSda->sda_Name1,
										 &pSda->sda_Name2,
										 pReqPkt->_Bitmap,
										 pSda->sda_ReplyBuf)) != AFP_ERR_NONE) &&
			(Status != AFP_ERR_QUEUE))
		{
			AfpFreeReplyBuf(pSda, FALSE);
		}
	}

	// Change the worker routine if we need this to be queued.
	if (Status == AFP_ERR_QUEUE)
		pSda->sda_WorkerRoutine = AfpFspDispOpenVol;

	return Status;
}


/***	AfpFsdDispCloseVol
 *
 *	This routine implements the AfpCloseVol API. This completes here i.e. it is
 *	not queued up to the Fsp.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 */
AFPSTATUS FASTCALL
AfpFsdDispCloseVol(
	IN	PSDA pSda
)
{
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
	};

	DBGPRINT(DBG_COMP_AFPAPI_VOL, DBG_LEVEL_INFO,
			("AfpFsdDispCloseVol: Entered\n"));

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	AfpConnectionClose(pReqPkt->_pConnDesc);

	return AFP_ERR_NONE;
}


/***	AfpFsdDispGetVolParms
 *
 *	This routine implements the AfpGetVolParms API. This completes here i.e.
 *	it is not queued up to the Fsp.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	DWORD		VolId
 *	sda_ReqBlock	DWORD		Bitmap
 */
AFPSTATUS FASTCALL
AfpFsdDispGetVolParms(
	IN	PSDA	pSda
)
{
	AFPSTATUS	Status = AFP_ERR_PARAM;
    PVOLDESC    pVolDesc;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_Bitmap;
	};


	DBGPRINT(DBG_COMP_AFPAPI_VOL, DBG_LEVEL_INFO,
			("AfpFsdDispGetVolParms: Entered\n"));

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

    pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

    //
    // we need to update the diskquota for this user, if diskquota is enabled:
    // we are dpc here, so just queue this request
    //
    if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
    {
        pSda->sda_WorkerRoutine = AfpFspDispGetVolParms;
        return(AFP_ERR_QUEUE);
    }

	pSda->sda_ReplySize = AfpVolumeGetParmsReplyLength(pReqPkt->_Bitmap,
							pReqPkt->_pConnDesc->cds_pVolDesc->vds_MacName.Length);

	if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
	{
		AfpVolumePackParms(pSda, pVolDesc, pReqPkt->_Bitmap, pSda->sda_ReplyBuf);
	}

	return Status;
}


/***	AfpFsdDispSetVolParms
 *
 *	This routine implements the AfpSetVolParms API. This completes here i.e.
 *	it is not queued up to the Fsp.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Bitmap
 *	sda_ReqBlock	DWORD		BackupTime
 */
AFPSTATUS FASTCALL
AfpFsdDispSetVolParms(
	IN	PSDA	pSda
)
{
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_Bitmap;
		DWORD		_BackupTime;
	};
	PVOLDESC	pVolDesc;

	DBGPRINT(DBG_COMP_AFPAPI_VOL, DBG_LEVEL_INFO,
			("AfpFsdDispSetVolParms: Entered\n"));

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc) & !IS_VOLUME_RO(pVolDesc));

	ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);
	pVolDesc->vds_BackupTime = pReqPkt->_BackupTime;
	pVolDesc->vds_Flags |= VOLUME_IDDBHDR_DIRTY;
	RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);

	return AFP_ERR_NONE;
}


/***	AfpFsdDispFlush
 *
 *	This routine implements the AfpFlush API. The only thing done here is
 *	validation of the Volume Id. The call completes here i.e. it is not
 *	queued up to the FSP.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	DWORD		VolId
 */
AFPSTATUS FASTCALL
AfpFsdDispFlush(
	IN	PSDA	pSda
)
{
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
	};

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
	DBGPRINT(DBG_COMP_AFPAPI_VOL, DBG_LEVEL_INFO,
			("AfpFsdDispFlush: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	return AFP_ERR_NONE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\fsd_dtp.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsd_dtp.c

Abstract:

	This module contains the entry points for the AFP desktop APIs. The API
	dispatcher calls these. These are all callable from FSD. All of the APIs
	complete in the DPC context. The ones which are completed in the FSP are
	directly queued to the workers in fsp_dtp.c

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FSD_DTP

#include <afp.h>
#include <gendisp.h>


/***	AfpFsdDispOpenDT
 *
 *	This routine implements the AfpOpenDT API. This completes here i.e. it is
 *	not queued to the FSP.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 */
AFPSTATUS FASTCALL
AfpFsdDispOpenDT(
	IN	PSDA	pSda
)
{
	AFPSTATUS	Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
	};
	struct _ResponsePacket
	{
		BYTE	__DTRefNum[2];
	};

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
											("AfpFsdDispOpenDT: Entered\n"));

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	if (AfpVolumeMarkDt(pSda, pReqPkt->_pConnDesc, True))
	{
		pSda->sda_ReplySize = SIZE_RESPPKT;
		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
			PUTDWORD2SHORT(pRspPkt->__DTRefNum,
						   pReqPkt->_pConnDesc->cds_pVolDesc->vds_VolId);
	}
	return Status;
}


/***	AfpFsdDispCloseDT
 *
 *	This routine implements the AfpCloseDT API. This completes here i.e. it is
 *	not queued to the FSP.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 */
AFPSTATUS FASTCALL
AfpFsdDispCloseDT(
	IN	PSDA	pSda
)
{
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
	};

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFsdDispCloseDT: Entered\n"));

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	return (AfpVolumeMarkDt(pSda, pReqPkt->_pConnDesc, False) ?
							AFP_ERR_NONE : AFP_ERR_PARAM);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\fsddata.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	fsd.c

Abstract:

	This module implements the File System pageable data. It is here because of
	the restrictions on pageable code and data in a single module.

Author:

	Jameel Hyder (microsoft!jameelh)

Revision History:
	10 Nov 1993		Initial Version

--*/

#define	FILENUM	FILE_FSDDATA

#define	SERVER_LOCALS
#include <afp.h>
#define	AFPADMIN_LOCALS
#include <afpadmin.h>
#include <scavengr.h>
#include <access.h>
#include <secutil.h>

#ifdef	ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

INIT_SYSTEMS	AfpInitSubSystems[NUM_INIT_SYSTEMS] =
		{
			{	AfpMacAnsiInit,		AfpMacAnsiDeInit,
#if DBG
				False,				False
				,"AfpMacAnsiInit",	"AfpMacAnsiDeInit"
#endif
			},
			{	AfpFileIoInit,		NULL,
#if DBG
				False,				False
				,"AfpFileIoInit",	NULL
#endif
			},
			{	AfpSdaInit,			NULL,
#if DBG
				False, 				False
				,"AfpSdaInit",		NULL
#endif
			},
			{	AfpVolumeInit,		NULL,
#if DBG
				False,				False
				,"AfpVolumeInit",	NULL,
#endif
			},
			{	AfpForksInit,		NULL,
#if DBG
				False,				False
				,"AfpForksInit",	NULL,
#endif
			},
			{	AfpDesktopInit,		NULL,
#if DBG
				False,				False
				,"AfpDesktopInit",	NULL,
#endif
			},
			{	AfpScavengerInit,	AfpScavengerDeInit,
#if DBG
				False,				False
				,"AfpScavengerInit","AfpScavengerDeInit"
#endif
			},
			{	AfpSecUtilInit,		AfpSecUtilDeInit,
#if DBG
				False,				False
				,"AfpInitSecUtil",	"AfpSecUtilDeInit"
#endif
			},

			// The following should happen after the scavenger is initialized
			{	AfpMemoryInit,		AfpMemoryDeInit,
#if DBG
				False,				False
				,"AfpMemoryDeInit",	"AfpMemoryDeInit"
#endif
			},
			{	NULL,				AfpAdminDeInit,
#if DBG
				False, 				False
				,NULL,				"AfpAdminDeInit"
#endif
			},
			{	AfpDfeInit,			AfpDfeDeInit,
#if DBG
				False, 				False
				,"AfpDfeInit",		"AfpDfeDeInit"
#endif
			}
	};

// This table is tightly linked to the opcode definitions in H\ADMIN.H
ADMIN_DISPATCH_TABLE AfpAdminDispatchTable[CC_BASE_MAX] =
{
	{
	  0,							0,
	  True,							OP_SERVICE_START,
	  NULL,							AfpAdmServiceStart,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  0,							0,
	  True,							OP_SERVICE_STOP,
	  NULL,							AfpAdmServiceStop,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  0,							0,
	  True,							OP_SERVICE_PAUSE,
	  NULL,							AfpAdmServicePause,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  0,							0,
	  True,							OP_SERVICE_CONTINUE,
	  NULL,							AfpAdmServiceContinue,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_STATISTICS_INFO),	0,
	  False,						OP_GET_STATISTICS,
	  AfpAdmGetStatistics,			NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_STATISTICS_INFO_EX),	0,
	  False,						OP_GET_STATISTICS_EX,
	  AfpAdmGetStatisticsEx,		NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  0,							0,
	  False,						OP_CLEAR_STATISTICS,
	  AfpAdmClearStatistics,		NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_PROFILE_INFO),		0,
	  False,						OP_GET_PROF_COUNTERS,
	  AfpAdmGetProfCounters,		NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  0,							0,
	  False,						OP_CLEAR_PROF_COUNTERS,
	  AfpAdmClearProfCounters,		NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_SID_OFFSET_DESC),	0,
	  True,							OP_SERVER_ADD_SID_OFFSETS,
	  AfpAdmServerSetParms,			NULL,
	  {
		{ DESC_SPECIAL, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  0,							0,
	  False,						OP_SERVER_GET_INFO,
	  AfpAdmServerGetInfo,			NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_SERVER_INFO),		sizeof(SETINFOREQPKT),
	  True,							OP_SERVER_SET_INFO,
	  NULL, 						AfpAdmWServerSetInfo,
	  {
		{ DESC_STRING, sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_SERVER_INFO, afpsrv_name) },
		{ DESC_STRING, sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_SERVER_INFO, afpsrv_login_msg) },
		{ DESC_STRING, sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_SERVER_INFO, afpsrv_codepage) },
	  }
	},
	{
	  sizeof(SRVETCPKT),			0,
	  True,							OP_SERVER_ADD_ETC,
	  AfpAdmServerAddEtc,			NULL,
	  {
		{ DESC_ETC, FIELD_OFFSET(SRVETCPKT, retc_NumEtcMaps) },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(ETCMAPINFO),			sizeof(SETINFOREQPKT),
	  True,							OP_SERVER_SET_ETC,
	  AfpAdmServerSetEtc,			NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(ETCMAPINFO),			0,
	  True,							OP_SERVER_DELETE_ETC,
	  AfpAdmServerDeleteEtc,		NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(SRVICONINFO),			0,
	  True,							OP_SERVER_ADD_ICON,
	  AfpAdmServerAddIcon,			NULL,
	  {
		{ DESC_ICON, FIELD_OFFSET(SRVICONINFO, icon_length) },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_VOLUME_INFO),		0,
	  True,							OP_VOLUME_ADD,
	  AfpAdmVolumeAdd,				AfpAdmWVolumeAdd,
	  {
		{ DESC_STRING, FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_name) },
		{ DESC_STRING, FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_password) },
		{ DESC_STRING, FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_path) }
	  }
	},
	{
	  sizeof(AFP_VOLUME_INFO),		0,
	  True,							OP_VOLUME_DELETE,
	  NULL,							AfpAdmWVolumeDelete,
	  {
		{ DESC_STRING, FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_name) },
		{ DESC_STRING, FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_password) },
		{ DESC_STRING, FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_path) }
	  }
	},
	{
	  sizeof(AFP_VOLUME_INFO),		0,
	  False,						OP_VOLUME_GET_INFO,
	  AfpAdmVolumeGetInfo,			NULL,
	  {
		{ DESC_STRING, FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_name) },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(SETINFOREQPKT) + sizeof(AFP_VOLUME_INFO),	sizeof(SETINFOREQPKT),
	  True,							OP_VOLUME_SET_INFO,
	  AfpAdmVolumeSetInfo,			NULL,
	  {
		{ DESC_STRING, sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_name) },
		{ DESC_STRING, sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_password) },
		{ DESC_STRING, sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_VOLUME_INFO, afpvol_path) }
	  }
	},
	{
	  sizeof(ENUMREQPKT),			0,
	  False,						OP_VOLUME_ENUM,
	  AfpAdmVolumeEnum,				NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(ENUMREQPKT),			0,
	  False,						OP_SESSION_ENUM,
	  AfpAdmSessionEnum,			NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_SESSION_INFO),		0,
	  True,							OP_SESSION_CLOSE,
	  NULL,							AfpAdmWSessionClose,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(ENUMREQPKT),			0,
	  False,						OP_CONNECTION_ENUM,
	  AfpAdmConnectionEnum,			NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(ENUMREQPKT),			0,
	  True,							OP_CONNECTION_CLOSE,
	  NULL,							AfpAdmWConnectionClose,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_DIRECTORY_INFO),	0,
	  False,						OP_DIRECTORY_GET_INFO,
	  NULL,							AfpAdmWDirectoryGetInfo,
	  {
		{ DESC_STRING, FIELD_OFFSET(AFP_DIRECTORY_INFO, afpdir_path) },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(SETINFOREQPKT) + sizeof(AFP_DIRECTORY_INFO),	sizeof(SETINFOREQPKT),
	  True,							OP_DIRECTORY_SET_INFO,
	  NULL,							AfpAdmWDirectorySetInfo,
	  { { DESC_STRING,	sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_DIRECTORY_INFO, afpdir_path)  },
		{ DESC_SID,		sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_DIRECTORY_INFO, afpdir_owner) },
		{ DESC_SID,		sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_DIRECTORY_INFO, afpdir_group) } }
	},
	{
	  sizeof(ENUMREQPKT),			0,
	  False,						OP_FORK_ENUM,
	  AfpAdmForkEnum,				NULL,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_FILE_INFO),		0,
	  True,							OP_FORK_CLOSE,
	  NULL,							AfpAdmWForkClose,
	  {
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
	  sizeof(AFP_MESSAGE_INFO),		0,
	  True,							OP_MESSAGE_SEND,
	  AfpAdmMessageSend,			NULL,
	  {
		{ DESC_STRING,  FIELD_OFFSET(AFP_MESSAGE_INFO, afpmsg_text) },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	},
	{
      sizeof(SETINFOREQPKT) + sizeof(AFP_FINDER_INFO), sizeof(SETINFOREQPKT),
	  True,						OP_FINDER_SET,
	  NULL,						AfpAdmWFinderSetInfo,
	  {
        { DESC_STRING, 	sizeof(SETINFOREQPKT) + FIELD_OFFSET(AFP_FINDER_INFO, afpfd_path) },
		{ DESC_NONE, 0 },
		{ DESC_NONE, 0 }
	  }
	}
};

#ifdef	ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\fsd_srv.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsd_srv.c

Abstract:

	This module contains the entry points for the AFP server APIs. The API
	dispatcher calls these. These are all callable from FSD. All of the APIs
	complete in the DPC context. The ones which are completed in the FSP are
	directly queued to the workers in fsp_srv.c

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FSD_SRV

#include <afp.h>
#include <gendisp.h>


/***	AfpFsdDispGetSrvrParms
 *
 *	This routine implements the AfpGetSrvrParms API. This completes here i.e.
 *	it is not queued up to the Fsp.
 *
 *	There is no request packet for this API.
 *
 *	Locks are acquired for both the volume list and individual volume descs.
 *
 *	LOCKS: vds_VolLock (SPIN), AfpVolumeListLock (SPIN)
 *
 *	LOCK_ORDER: vds_VolLock (SPIN) after AfpVolumeListLock (SPIN)
 */
AFPSTATUS FASTCALL
AfpFsdDispGetSrvrParms(
	IN	PSDA	pSda
)
{
	PBYTE		pTemp;				// Roving pointer
	PVOLDESC	pVolDesc;
	LONG		VolCount;
	AFPTIME		MacTime;
	BOOLEAN		MoreSpace = True;
	struct _ResponsePacket
	{
		BYTE	__ServerTime[4];
		BYTE	__NumVols;
	};

	DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
										("AfpFsdDispGetSrvrParms: Entered\n"));

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
	/*
	 *	Estimate the size of reply buffer needed. We need one big enough to
	 *	either accomodate all volumes or the maximum size buffer whichever
	 *	is less.
	 *
	 *	The reply consists of the server time, count of volumes and a list of
	 *	volumes and flags to indicate if this volume has a password.
	 *
	 *	NOTE: If we decide to do private volumes, then the following code
	 *		  has to change. Specifically AfpVolCount will have to be computed
	 *		  based on how many private volumes exist and if there is one
	 *		  for this user.
	 */

	ACQUIRE_SPIN_LOCK_AT_DPC(&AfpVolumeListLock);

	/*
	 * Each volume entry takes a byte for flags, a byte for length and the
	 * size of the volume name string. We estimate based on maximum size of
	 * the volume name. On an average it will be less. For every volume, apart
	 * from the volume name, we need a byte for volume flags and a byte for
	 * the volume name length.
	 */
	if ((pSda->sda_ReplySize = (USHORT)(SIZE_RESPPKT + AfpVolCount *
				(SIZE_PASCALSTR(AFP_VOLNAME_LEN+1) + sizeof(BYTE)))) > pSda->sda_MaxWriteSize)
		pSda->sda_ReplySize = (USHORT)pSda->sda_MaxWriteSize;

	if (AfpAllocReplyBuf(pSda) != AFP_ERR_NONE)
	{
		RELEASE_SPIN_LOCK_FROM_DPC(&AfpVolumeListLock);
		return AFP_ERR_MISC;
	}

	// Point pTemp past the response header
	pTemp = pSda->sda_ReplyBuf + SIZE_RESPPKT;

	for (VolCount = 0, pVolDesc = AfpVolumeList;
		 (pVolDesc != NULL) && MoreSpace;
		 pVolDesc = pVolDesc->vds_Next)
	{
		ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);
		do
		{
			// Ignore volumes that have not been added completely
			if (pVolDesc->vds_Flags & (VOLUME_INTRANSITION | VOLUME_DELETED | VOLUME_INITIAL_CACHE))
				break;

			// Ignore volumes that do not have guest access and the client
			// is guest
			if (!(pVolDesc->vds_Flags & AFP_VOLUME_GUESTACCESS) &&
				(pSda->sda_ClientType == SDA_CLIENT_GUEST))
				break;

			// See if we are likely to cross bounds. For each volume we need a
			// byte for the PASCALSTR name and a flag byte. Note that we do not
			// add any pads.
			if ((pTemp + SIZE_PASCALSTR(pVolDesc->vds_MacName.Length) +
					sizeof(BYTE)) >= (pSda->sda_ReplyBuf + pSda->sda_ReplySize))
			{
				DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
						("AfpFsdDispGetSrvrParms: Out of space\n"));
				MoreSpace = False;
				break;
			}

			// Check for volume password. We never carry the HasConfigInfo bit !!
			*pTemp++ = (pVolDesc->vds_Flags & AFP_VOLUME_HASPASSWORD) 	?
										SRVRPARMS_VOLUMEHASPASS : 0;

			*pTemp++ = (BYTE)pVolDesc->vds_MacName.Length;
			RtlCopyMemory(pTemp, pVolDesc->vds_MacName.Buffer,
									pVolDesc->vds_MacName.Length);

			pTemp += pVolDesc->vds_MacName.Length;
			VolCount ++;
		} while (False);
		RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);
	}
	RELEASE_SPIN_LOCK_FROM_DPC(&AfpVolumeListLock);

	pSda->sda_ReplySize = (USHORT)(pTemp - pSda->sda_ReplyBuf);

	ASSERT (VolCount <= AfpVolCount);
	AfpGetCurrentTimeInMacFormat(&MacTime);
	PUTDWORD2DWORD(pRspPkt->__ServerTime, MacTime);
	PUTDWORD2BYTE(&pRspPkt->__NumVols, VolCount);

	return AFP_ERR_NONE;
}


/***	AfpFsdDispGetSrvrMsg
 *
 *	This routine implements the AfpGetSrvrMsg API. This completes here i.e.
 *	it is not queued up to the Fsp.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	DWORD	MsgType
 *	sda_ReqBlock	DWORD	Bitmap
 *
 *	LOCKS:		AfpServerGlobalLock (SPIN), sda_Lock (SPIN)
 *	LOCK_ORDER:	sda_Lock after AfpServerGlobalLock
 */
AFPSTATUS FASTCALL
AfpFsdDispGetSrvrMsg(
	IN	PSDA	pSda
)
{
	DWORD		MsgType,
				Bitmap;
	AFPSTATUS	Status = AFP_ERR_NONE;
	ANSI_STRING	Message;

	struct _RequestPacket
	{
		DWORD	_MsgType,
				_Bitmap;
	};
	struct _ResponsePacket
	{
		BYTE	__MsgType[2],
				__Bitmap[2],
				__Message[1];
	};

	DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
			("AfpFsdDispGetSrvrMsg: Entered\n"));

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	// Note: Should we be doing this ? Why not give it to him since he asked.
	if (pSda->sda_ClientVersion < AFP_VER_21)
		return AFP_ERR_CALL_NOT_SUPPORTED;

	MsgType = pReqPkt->_MsgType;
	Bitmap = pReqPkt->_Bitmap;

	do
	{
		if (Bitmap & ~SRVRMSG_BITMAP_MESSAGE)
		{
			Status = AFP_ERR_BITMAP;
			break;
		}

		if ((MsgType != SRVRMSG_LOGIN) &&
			(MsgType != SRVRMSG_SERVER))
		{
			Status = AFP_ERR_PARAM;
			break;
		}

		// Allocate a reply buffer for a maximum size message. We cannot hold the
		// SDA lock and call the AllocBuf routine since it calls AfpInterlocked...
		pSda->sda_ReplySize = SIZE_RESPPKT + AFP_MAXCOMMENTSIZE;
		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
		{
			ACQUIRE_SPIN_LOCK_AT_DPC(&AfpServerGlobalLock);
			ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

			switch (MsgType)
			{
			  case SRVRMSG_LOGIN:
				Message = AfpLoginMsg;
				break;
			  case SRVRMSG_SERVER:
				if (pSda->sda_Message != NULL)
					Message = *(pSda->sda_Message);
				else if (AfpServerMsg != NULL)
					Message = *AfpServerMsg;
				else		// Setup a default of No message.
					AfpSetEmptyAnsiString(&Message, 0, NULL);
				break;
			}

			pSda->sda_ReplySize = SIZE_RESPPKT + Message.Length;

			PUTSHORT2SHORT(pRspPkt->__MsgType, MsgType);
			PUTSHORT2SHORT(pRspPkt->__Bitmap, Bitmap);
			pRspPkt->__Message[0] = (BYTE) Message.Length;
			if (Message.Length > 0)
			{
				RtlCopyMemory( &pRspPkt->__Message[1],
								Message.Buffer,
								Message.Length);
			}
			// If this is not a broadcast message, then get rid of the
			// Sda message memory as it is consuming non-paged resources
			if ((MsgType == SRVRMSG_SERVER) &&
				(pSda->sda_Message != NULL))
			{
				AfpFreeMemory(pSda->sda_Message);
				pSda->sda_Message = NULL;
			}

			RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
			RELEASE_SPIN_LOCK_FROM_DPC(&AfpServerGlobalLock);
		}

		if (Status == AFP_ERR_NONE)
			INTERLOCKED_INCREMENT_LONG(&AfpServerStatistics.stat_NumMessagesSent);
	} while (False);

	return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\fsp_dir.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsp_dir.c

Abstract:

	This module contains the entry points for the AFP directory APIs. The API
	dispatcher calls these. These are all callable from FSD. All of the APIs
	complete in the DPC context. The ones which are completed in the FSP are
	directly queued to the workers in fsp_dir.c

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FSP_DIR

#include <afp.h>
#include <gendisp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <client.h>
#include <afpinfo.h>
#include <access.h>

#define	DEF_ID_CNT		128
#define	max(a,b)	(((a) > (b)) ? (a) : (b))

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpFspDispOpenDir)
#pragma alloc_text( PAGE, AfpFspDispCloseDir)
#pragma alloc_text( PAGE, AfpFspDispCreateDir)
#pragma alloc_text( PAGE, AfpFspDispEnumerate)
#pragma alloc_text( PAGE, AfpFspDispSetDirParms)
#endif

/***	AfpFspDispOpenDir
 *
 *	This is the worker routine for the AfpOpenDir API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_Name1		ANSI_STRING	DirName
 */
AFPSTATUS FASTCALL
AfpFspDispOpenDir(
	IN	PSDA	pSda
)
{
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
	};
	struct _ResponsePacket
	{
		BYTE		__DirId[4];
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_INFO,
										("AfpFspDispOpenDir: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	AfpInitializePME(&PME, 0, NULL);
	if ((Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										 pReqPkt->_ParentId,
										 &pSda->sda_Name1,
										 pSda->sda_PathType,
										 DFE_DIR,
										 DIR_BITMAP_DIRID,
										 &PME,
										 &FDParm)) == AFP_ERR_NONE)
		AfpIoClose(&PME.pme_Handle);	// Close the handle

	if (Status == AFP_ERR_NONE)
	{
		pSda->sda_ReplySize = SIZE_RESPPKT;
		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
			PUTDWORD2DWORD(pRspPkt->__DirId, FDParm._fdp_AfpId);
	}

	return Status;
}


/***	AfpFspDispCloseDir
 *
 *	This routine implements the AfpCloseDir API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		DirId
 */
AFPSTATUS FASTCALL
AfpFspDispCloseDir(
	IN	PSDA	pSda
)
{
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	AFPSTATUS		Status;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_DirId;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_INFO,
										("AfpFspDispCloseDir: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	AfpInitializeFDParms(&FDParm);

	AfpInitializePME(&PME, 0, NULL);
	Status = AfpMapAfpIdForLookup(pReqPkt->_pConnDesc,
								  pReqPkt->_DirId,
								  DFE_DIR,
								  0,
								  &PME,
								  &FDParm);
	if (Status == AFP_ERR_NONE)
	{
		AfpIoClose(&PME.pme_Handle);
	}
	else Status = AFP_ERR_PARAM;

	return Status;
}


/***	AfpFspDispCreateDir
 *
 *	This is the worker routine for the AfpCreateDir API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_Name1		ANSI_STRING	DirName
 */
AFPSTATUS FASTCALL
AfpFspDispCreateDir(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status = AFP_ERR_PARAM, PostStatus;
	PATHMAPENTITY	PME;
	PDFENTRY		pNewDfe;
	FILESYSHANDLE	hNewDir, hAfpInfo;
	AFPINFO			afpinfo;
	PVOLDESC		pVolDesc;		// For post-create processing
	BYTE			PathType;		// -- ditto --
	WCHAR			PathBuf[BIG_PATH_LEN];
	BOOLEAN			InRoot;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
	};
	struct _ResponsePacket
	{
		BYTE		__DirId[4];
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_INFO,
										("AfpFspDispCreateDir: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));

	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	do
	{
		hNewDir.fsh_FileHandle = NULL;
		hAfpInfo.fsh_FileHandle = NULL;
		AfpInitializePME(&PME, sizeof(PathBuf), PathBuf);
		if (!NT_SUCCESS(Status = AfpMapAfpPath(pReqPkt->_pConnDesc,
											   pReqPkt->_ParentId,
											   &pSda->sda_Name1,
											   PathType = pSda->sda_PathType,
											   SoftCreate,
											   DFE_DIR,
											   0,
											   &PME,
											   NULL)))
		{
			break;
		}

		AfpImpersonateClient(pSda);

		InRoot = (PME.pme_ParentPath.Length == 0) ? True : False;
		Status = AfpIoCreate(&pVolDesc->vds_hRootDir,
							AFP_STREAM_DATA,
							&PME.pme_FullPath,
							FILEIO_ACCESS_NONE | FILEIO_ACCESS_DELETE | AFP_OWNER_ACCESS,
							FILEIO_DENY_NONE,
							FILEIO_OPEN_DIR,
							FILEIO_CREATE_SOFT,
							FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_ARCHIVE,
							True,
#ifdef	INHERIT_DIRECTORY_PERMS
							NULL,
#else
							pSda->sda_pSecDesc,
#endif
							&hNewDir,
							NULL,
							pVolDesc,
							&PME.pme_FullPath,
							// we don't get notified of parent mod time changing if
							// there is no handle open for the parent dir at the time
							// of create, which we cannot predict here.
							&PME.pme_ParentPath);

		AfpRevertBack();

		if (!NT_SUCCESS(Status))
		{
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
			break;
		}

#ifdef	INHERIT_DIRECTORY_PERMS
		{
			PFILEDIRPARM pFdParm;

			if ((pFdParm = (PFILEDIRPARM)AfpAllocNonPagedMemory(sizeof(FILEDIRPARM))) != NULL)
			{
				pFdParm->_fdp_OwnerId = pSda->sda_UID;
				pFdParm->_fdp_GroupId = pSda->sda_GID;
				pFdParm->_fdp_OwnerRights = DIR_ACCESS_ALL | DIR_ACCESS_OWNER;
				pFdParm->_fdp_GroupRights = 0;
				pFdParm->_fdp_WorldRights = 0;
				pFdParm->_fdp_Flags = DFE_FLAGS_DIR;

				// Now set the owner and group permissions on this folder
				Status = AfpSetAfpPermissions(hNewDir.fsh_FileHandle,
											  DIR_BITMAP_OWNERID	|
												DIR_BITMAP_GROUPID	|
												DIR_BITMAP_ACCESSRIGHTS,
											  pFdParm);
				AfpFreeMemory(pFdParm);
			}
			else
			{
				Status = AFP_ERR_MISC;
			}

			if (!NT_SUCCESS(Status))
			{
				AfpIoMarkFileForDelete(&hNewDir,
									   pVolDesc,
									   &PME.pme_FullPath,
									   InRoot ? NULL : &PME.pme_ParentPath);
				break;
			}
		}
#endif

		// Add this entry to the IdDb
		pNewDfe = AfpAddDfEntry(pVolDesc,
								PME.pme_pDfeParent,
								&PME.pme_UTail,
								True,
								0);
		if (pNewDfe != NULL)
		{
			// If mac creates a dir we want it to show up as already
			// enumerated in the ID database since new things can only
			// be added after this.
			DFE_MARK_CHILDREN_PRESENT(pNewDfe);
			afpinfo.afpi_Id = pNewDfe->dfe_AfpId;

			// !!!HACK ALERT!!!
			// At this point we are pretty much done i.e. the create has succeeded
			// and we can return doing the rest of the work post-reply. Any errors
			// from now on SHOULD BE IGNORED. Also NO REFERENCE SHOULD BE MADE TO
			// the PSda & pConnDesc. Status should not be changed either. Also
			// reference the Volume for good measure. It cannot fail !!!
			AfpVolumeReference(pVolDesc);

			pSda->sda_ReplySize = SIZE_RESPPKT;
			if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
				PUTDWORD2DWORD(pRspPkt->__DirId, pNewDfe->dfe_AfpId);

			AfpCompleteApiProcessing(pSda, Status);
			Status = AFP_ERR_EXTENDED;

			// Create the AfpInfo stream and cache the afpinfo
			if (!NT_SUCCESS(AfpCreateAfpInfoStream(pVolDesc,
												   &hNewDir,
												   afpinfo.afpi_Id,
												   True,
												   NULL,
												   &PME.pme_FullPath,
												   &afpinfo,
												   &hAfpInfo)))
			{
				// If we fail to add the AFP_AfpInfo stream, we must
				// rewind back to the original state.  i.e. delete
				// the directory we just created, and remove it from
				// the Id database.
				AfpIoMarkFileForDelete(&hNewDir,
									   pVolDesc,
									   &PME.pme_FullPath,
									   InRoot ? NULL : &PME.pme_ParentPath);
				AfpDeleteDfEntry(pVolDesc, pNewDfe);
			}
			else
			{
				DWORD			Attr;

				// Get the rest of the File info, and cache it
				PostStatus = AfpIoQueryTimesnAttr(&hNewDir,
												  &pNewDfe->dfe_CreateTime,
												  &pNewDfe->dfe_LastModTime,
												  &Attr);

				ASSERT(NT_SUCCESS(PostStatus));
				if (NT_SUCCESS(PostStatus))
				{
					pNewDfe->dfe_NtAttr = (USHORT)Attr & FILE_ATTRIBUTE_VALID_FLAGS;
					DFE_UPDATE_CACHED_AFPINFO(pNewDfe, &afpinfo);
					AfpVolumeSetModifiedTime(pVolDesc);

					AfpCacheParentModTime(pVolDesc, NULL,
										  &PME.pme_ParentPath,
										  pNewDfe->dfe_Parent,
										  0);
				}
				else
				{
					AfpIoMarkFileForDelete(&hNewDir,
										   pVolDesc,
										   &PME.pme_FullPath,
										   InRoot ? NULL : &PME.pme_ParentPath);
					AfpDeleteDfEntry(pVolDesc, pNewDfe);
				}
			}
		}

		AfpVolumeDereference(pVolDesc);
	} while (False);

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

	if (hNewDir.fsh_FileHandle != NULL)
		AfpIoClose(&hNewDir);

	if (hAfpInfo.fsh_FileHandle != NULL)
		AfpIoClose(&hAfpInfo);

	if ((PME.pme_FullPath.Buffer != NULL) &&
		(PME.pme_FullPath.Buffer != PathBuf))
		AfpFreeMemory(PME.pme_FullPath.Buffer);

	return Status;
}


/***	AfpFspDispEnumerate
 *
 *	This is the worker routine for the AfpEnumerate API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_ReqBlock	DWORD		File Bitmap
 *	sda_ReqBlock	DWORD		Dir Bitmap
 *	sda_ReqBlock	LONG		Request Count
 *	sda_ReqBlock	LONG		Start Index
 *	sda_ReqBlock	LONG		Max Reply Size
 *	sda_Name1		ANSI_STRING	DirName
 */
AFPSTATUS FASTCALL
AfpFspDispEnumerate(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status = AFP_ERR_PARAM;
	PATHMAPENTITY	PME;
	PVOLDESC		pVolDesc;
	FILEDIRPARM		FDParm;
	DWORD			BitmapF, BitmapD, BitmapI = 0;
	LONG			i = 0, ActCount = 0, ReqCnt = 0;
	PENUMDIR		pEnumDir;
	PEIT			pEit;
	SHORT			CleanupFlags = 0;
	SHORT			BaseLenD = 0, BaseLenF = 0;
	USHORT			SizeUsed;
	BOOLEAN			FreeReplyBuf = False;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
		DWORD		_FileBitmap;
		DWORD		_DirBitmap;
		LONG		_ReqCnt;
		LONG		_Index;
		LONG		_ReplySize;
	};
	struct _ResponsePacket
	{
		BYTE		__FileBitmap[2];
		BYTE		__DirBitmap[2];
		BYTE		__EnumCount[2];
	};
	typedef struct _EnumEntityPkt
	{
		BYTE		__Length;
		BYTE		__FileDirFlag;
		// The real parameters follow
	} EEP, *PEEP;
	PEEP		pEep;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_INFO,
			("AfpFspDispEnumerate: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));

	if ((pReqPkt->_ReqCnt <= 0)		||
		(pReqPkt->_Index <= 0)	    ||
		(pReqPkt->_ReplySize <= 0))
	{
		return AFP_ERR_PARAM;
	}

	BitmapF = pReqPkt->_FileBitmap;
	BitmapD = pReqPkt->_DirBitmap;

	if ((BitmapF == 0) && (BitmapD == 0))
	{
		return AFP_ERR_BITMAP;
	}

	if (BitmapD & DIR_BITMAP_ACCESSRIGHTS)
	{
		BitmapI = FD_INTERNAL_BITMAP_OPENACCESS_READCTRL;
	}

	do
	{
		AfpInitializeFDParms(&FDParm);
		AfpInitializePME(&PME, 0, NULL);

		// This is the size of the buffer needed (plus the name) for enumerating
		// one entity. We do not want to do this many times.
		FDParm._fdp_Flags = DFE_FLAGS_DIR;
		if (BitmapD != 0)
			BaseLenD = ((SHORT)AfpGetFileDirParmsReplyLength(&FDParm, BitmapD) +
																	sizeof(EEP));

		FDParm._fdp_Flags = 0;
		if (BitmapF != 0)
			BaseLenF = ((SHORT)AfpGetFileDirParmsReplyLength(&FDParm, BitmapF) +
																	sizeof(EEP));

		if ((Status = AfpEnumerate(pReqPkt->_pConnDesc,
								   pReqPkt->_ParentId,
								   &pSda->sda_Name1,
								   BitmapF,
								   BitmapD,
								   pSda->sda_PathType,
								   0,
								   &pEnumDir)) != AFP_ERR_NONE)
			break;

		if (pEnumDir->ed_ChildCount < pReqPkt->_Index)
		{
			Status = AFP_ERR_OBJECT_NOT_FOUND;
			break;
		}

		ReqCnt = (DWORD)pReqPkt->_ReqCnt;
		if (ReqCnt > (pEnumDir->ed_ChildCount - pEnumDir->ed_BadCount - pReqPkt->_Index + 1))
			ReqCnt = (pEnumDir->ed_ChildCount - pEnumDir->ed_BadCount - pReqPkt->_Index + 1);

		// We have enumerated the directory and now have afp ids of all the
		// children. Allocate the reply buffer
		pSda->sda_ReplySize = (USHORT)pReqPkt->_ReplySize;

        AfpIOAllocBackFillBuffer(pSda);
		if (pSda->sda_ReplyBuf == NULL)
		{
			pSda->sda_ReplySize = 0;
			Status = AFP_ERR_MISC;
			break;
		}

#if DBG
        AfpPutGuardSignature(pSda);
#endif

		FreeReplyBuf = True;
		pEep = (PEEP)(pSda->sda_ReplyBuf + SIZE_RESPPKT);

		// For each of the enumerated entities, get the requested parameters
		// and pack it in the replybuf.
		// We also do not want to impersonate the user here. A Mac user expects
		// to see belted items as opposed to invisible ones.
		SizeUsed = SIZE_RESPPKT;
		pEit = &pEnumDir->ed_pEit[pReqPkt->_Index + pEnumDir->ed_BadCount - 1];
		for (i = 0, ActCount = 0; (i < ReqCnt); i++, pEit++)
		{
			SHORT	Len;
			DWORD	Bitmap;
			BOOLEAN	NeedHandle = False;

			Bitmap = BitmapF;
			Len = BaseLenF;

			if (pEit->eit_Flags & DFE_DIR)
			{
				Bitmap = BitmapD | BitmapI;
				Len = BaseLenD;
				if (IS_VOLUME_NTFS(pVolDesc) &&
					(Bitmap & (DIR_BITMAP_ACCESSRIGHTS |
							  DIR_BITMAP_OWNERID |
							  DIR_BITMAP_GROUPID)))
				{
					NeedHandle = True;
				}
			}

			FDParm._fdp_LongName.Length = FDParm._fdp_ShortName.Length = 0;

			Status = AfpMapAfpIdForLookup(pReqPkt->_pConnDesc,
										  pEit->eit_Id,
										  pEit->eit_Flags,
										  Bitmap |
											FD_BITMAP_ATTR |
											FD_INTERNAL_BITMAP_SKIP_IMPERSONATION,
										  NeedHandle ? &PME : NULL,
										  &FDParm);

			// This can fail if the enitity gets deleted in the interim or if the
			// user has no access to this entity.
			// An error here should not be treated as such.
			// Reset the Status to none since we do not want to fall out
			// with this error code
			if (!NT_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_ERR,
						("AfpFspDispEnumerate: Dropping id %ld\n", pEit->eit_Id));
				pEnumDir->ed_BadCount ++;
				Status = AFP_ERR_NONE;
				continue;
			}

			if (NeedHandle)
			{
				AfpIoClose(&PME.pme_Handle);	// Close the handle to the entity
			}

			Bitmap &= ~BitmapI;

			if (Bitmap & FD_BITMAP_LONGNAME)
				Len += FDParm._fdp_LongName.Length;
			if (Bitmap & FD_BITMAP_SHORTNAME)
				Len += FDParm._fdp_ShortName.Length;
			Len = EVENALIGN(Len);

			if (Len > (pSda->sda_ReplySize - SizeUsed))
			{
				if (SizeUsed == SIZE_RESPPKT)
				{
					Status = AFP_ERR_PARAM;
				}
				break;
			}

			PUTSHORT2BYTE(&pEep->__Length, Len);
			pEep->__FileDirFlag = IsDir(&FDParm) ?
									FILEDIR_FLAG_DIR : FILEDIR_FLAG_FILE;

			AfpPackFileDirParms(&FDParm, Bitmap, (PBYTE)pEep + sizeof(EEP));

			pEep = (PEEP)((PBYTE)pEep + Len);
			SizeUsed += Len;
			ActCount ++;
		}

		if (Status == AFP_ERR_NONE)
			FreeReplyBuf = False;
	} while (False);

	if (FreeReplyBuf || (ActCount == 0))
	{
        AfpIOFreeBackFillBuffer(pSda);
	}

	if (Status == AFP_ERR_NONE)
	{
		if (ActCount > 0)
		{
			PUTSHORT2SHORT(&pRspPkt->__FileBitmap, BitmapF);
			PUTSHORT2SHORT(&pRspPkt->__DirBitmap,  BitmapD);
			PUTSHORT2SHORT(&pRspPkt->__EnumCount,  ActCount);
			pSda->sda_ReplySize = SizeUsed;
		}
		else Status = AFP_ERR_OBJECT_NOT_FOUND;
	}

	if (Status != AFP_ERR_NONE)
	{
		if (pReqPkt->_pConnDesc->cds_pEnumDir != NULL)
		{
			AfpFreeMemory(pReqPkt->_pConnDesc->cds_pEnumDir);
			pReqPkt->_pConnDesc->cds_pEnumDir = NULL;
		}
	}
	return Status;
}



/***	AfpFspDispSetDirParms
 *
 *	This is the worker routine for the AfpSetDirParms API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_ReqBlock	DWORD		Dir Bitmap
 *	sda_Name1		ANSI_STRING	Path
 *	sda_Name2		BLOCK		Dir Parameters
 */
AFPSTATUS FASTCALL
AfpFspDispSetDirParms(
	IN	PSDA	pSda
)
{
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME, PMEfile;
	PVOLDESC		pVolDesc;
	WCHAR			PathBuf[BIG_PATH_LEN];
	DWORD			Bitmap,
					BitmapI = FD_INTERNAL_BITMAP_RETURN_PMEPATHS |
							  FD_INTERNAL_BITMAP_OPENACCESS_RW_ATTR;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
		DWORD		_Bitmap;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_INFO,
										("AfpFspDispSetDirParms: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));

	Bitmap = pReqPkt->_Bitmap;

	AfpInitializeFDParms(&FDParm);
	AfpInitializePME(&PME, sizeof(PathBuf), PathBuf);

	do
	{
		if (Bitmap & (DIR_BITMAP_OWNERID |
					  DIR_BITMAP_GROUPID |
					  DIR_BITMAP_ACCESSRIGHTS |
					  FD_BITMAP_ATTR))
		{
			BitmapI |= (pSda->sda_ClientType == SDA_CLIENT_ADMIN) ?

						(FD_INTERNAL_BITMAP_OPENACCESS_ADMINSET |
						 DIR_BITMAP_OFFSPRINGS |
						 FD_INTERNAL_BITMAP_RETURN_PMEPATHS) :

						(FD_INTERNAL_BITMAP_OPENACCESS_RWCTRL |
						 FD_INTERNAL_BITMAP_RETURN_PMEPATHS |
						 DIR_BITMAP_OFFSPRINGS |
						 DIR_BITMAP_DIRID |
						 DIR_BITMAP_ACCESSRIGHTS |
						 DIR_BITMAP_OWNERID |
						 DIR_BITMAP_GROUPID);
		}

		Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										pReqPkt->_ParentId,
										&pSda->sda_Name1,
										pSda->sda_PathType,
										DFE_DIR,
										Bitmap | BitmapI,
										&PME,
										&FDParm);

		if (!NT_SUCCESS(Status))
		{
			PME.pme_Handle.fsh_FileHandle = NULL;
			break;
		}

		// Check for Network Trash Folder and do not change its permissions
		if ((FDParm._fdp_AfpId == AFP_ID_NETWORK_TRASH) &&
			(Bitmap & (DIR_BITMAP_OWNERID |
						DIR_BITMAP_GROUPID |
						DIR_BITMAP_ACCESSRIGHTS)))
		{
			Bitmap &= ~(DIR_BITMAP_OWNERID |
						DIR_BITMAP_GROUPID |
						DIR_BITMAP_ACCESSRIGHTS);
			if (Bitmap == 0)
			{
				// We are not setting anything else, return success
				Status = STATUS_SUCCESS;
				break;
			}
		}

		// Make sure user has the necessary rights to change any of this
		if (pSda->sda_ClientType == SDA_CLIENT_ADMIN)
		{
			FDParm._fdp_UserRights = DIR_ACCESS_ALL | DIR_ACCESS_OWNER;
		}
		// If attributes are to be set, the check for access is done during unpacking
		else if	((Bitmap & (DIR_BITMAP_OWNERID |
							DIR_BITMAP_GROUPID |
							DIR_BITMAP_ACCESSRIGHTS)) &&
				 !(FDParm._fdp_UserRights & DIR_ACCESS_OWNER))
		{
			Status = AFP_ERR_ACCESS_DENIED;
			break;
		}

		if ((Status = AfpUnpackFileDirParms(pSda->sda_Name2.Buffer,
										    (LONG)pSda->sda_Name2.Length,
										    &Bitmap,
										    &FDParm)) != AFP_ERR_NONE)
			break;

		if (Bitmap != 0)
		{
			if ((Bitmap & FD_BITMAP_ATTR) &&
				(FDParm._fdp_Attr & (FILE_BITMAP_ATTR_MULTIUSER |
									 FILE_BITMAP_ATTR_DATAOPEN	|
									 FILE_BITMAP_ATTR_RESCOPEN	|
									 FILE_BITMAP_ATTR_COPYPROT)))
			{
				Status = AFP_ERR_PARAM;
				break;
			}

			Status = AfpSetFileDirParms(pVolDesc,
										&PME,
										Bitmap,
										&FDParm);
			if (!NT_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_INFO,
						("AfpFspDispSetDirParms: AfpSetFileDirParms returned %ld\n", Status));
				break;
			}

			// Close the directory handle
			AfpIoClose(&PME.pme_Handle);

			// If any permissions are being changed, then apply them to all files within
			// this directory. Start off by enumerating the files in the directory and
			// then walk the list applying to each individual file.
			if ((Bitmap & (DIR_BITMAP_OWNERID |
						   DIR_BITMAP_GROUPID |
						   DIR_BITMAP_ACCESSRIGHTS)) &&
				(FDParm._fdp_FileCount != 0))
			{
				PENUMDIR		pEnumDir;
				PEIT			pEit;
				FILEDIRPARM		FileParm;
				ANSI_STRING		DummyName;
				LONG			i;

				// Do not treat any of the following as errors from now on.
				// Quitely terminate
				AfpInitializeFDParms(&FileParm);

				AfpSetEmptyAnsiString(&DummyName, 1, "");
				if (AfpEnumerate(pReqPkt->_pConnDesc,
								 FDParm._fdp_AfpId,
								 &DummyName,
								 1,				// Some non-zero value
								 0,
								 AFP_LONGNAME,
								 DFE_FILE,
								 &pEnumDir) != AFP_ERR_NONE)
					break;

				FDParm._fdp_Flags &= ~DFE_FLAGS_DIR;
				AfpInitializePME(&PMEfile, 0, NULL);
				for (i = 0, pEit = &pEnumDir->ed_pEit[0];
					 i < pEnumDir->ed_ChildCount; i++, pEit++)
				{
					AFPSTATUS		Rc;

					Rc = AfpMapAfpIdForLookup(pReqPkt->_pConnDesc,
											pEit->eit_Id,
											DFE_FILE,
											FD_INTERNAL_BITMAP_OPENACCESS_RWCTRL |
															FD_BITMAP_LONGNAME,
											&PMEfile,
											&FileParm);

					DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_INFO,
							("AfpFspDispSetDirParms: AfpMapAfpIdForLookup returned %ld\n", Rc));

					if (Rc != AFP_ERR_NONE)
						continue;

					AfpSetAfpPermissions(PMEfile.pme_Handle.fsh_FileHandle,
										 Bitmap,
										 &FDParm);

					AfpIoClose(&PMEfile.pme_Handle);

					DBGPRINT(DBG_COMP_AFPAPI_DIR, DBG_LEVEL_INFO,
							("AfpFspDispSetDirParms: AfpSetAfpPermissions returned %ld\n", Rc));
				}
				if (pReqPkt->_pConnDesc->cds_pEnumDir != NULL)
				{
					AfpFreeMemory(pReqPkt->_pConnDesc->cds_pEnumDir);
					pReqPkt->_pConnDesc->cds_pEnumDir = NULL;
				}
			}
		}
	} while (False);

	// NOTE: This is also called by the admin side so do not try the early reply trick
	//		 here. If it does get important to do it, then check for client type.
	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	if ((PME.pme_FullPath.Buffer != NULL) &&
		(PME.pme_FullPath.Buffer != PathBuf))
	{
		AfpFreeMemory(PME.pme_FullPath.Buffer);
	}

	return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\fsd.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	fsd.c

Abstract:

	This module implements the File System Driver for the AFP Server. All of
	the initialization, admin request handler etc. is here.

Author:

	Jameel Hyder (microsoft!jameelh)

Revision History:
	01 Jun 1992		Initial Version

--*/

#define	FILENUM	FILE_FSD

#include <afp.h>
#define	AFPADMIN_LOCALS
#include <afpadmin.h>
#include <client.h>
#include <scavengr.h>
#include <secutil.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry)
#pragma alloc_text( INIT, afpInitServer)
#pragma alloc_text( PAGE, afpFsdDispatchAdminRequest)
#pragma alloc_text( PAGE, afpFsdHandleAdminRequest)
#pragma alloc_text( PAGE, afpHandleQueuedAdminRequest)
#pragma alloc_text( PAGE, afpFsdUnloadServer)
#pragma alloc_text( PAGE, afpAdminThread)
#pragma alloc_text( PAGE, afpFsdHandleShutdownRequest)
#endif

/***	afpFsdDispatchAdminRequest
 *
 *	This is the driver entry point. This is for the sole use by the server
 *	service which opens the driver for EXCLUSIVE use. The admin request is
 *	received here as a request packet defined in admin.h.
 */
LOCAL NTSTATUS
afpFsdDispatchAdminRequest(
	IN	PDEVICE_OBJECT	pDeviceObject,
	IN	PIRP			pIrp
)
{
	PIO_STACK_LOCATION	pIrpSp;
	NTSTATUS			Status;
	BOOLEAN				LockDown = True;
	static	DWORD		afpOpenCount = 0;

	pDeviceObject;		// prevent compiler warnings

	PAGED_CODE( );

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	pIrp->IoStatus.Information = 0;

	if ((pIrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL)	||
		(pIrpSp->MajorFunction == IRP_MJ_CREATE)				||
		(pIrpSp->MajorFunction == IRP_MJ_CLOSE))
	{
		LockDown = False;
	}
	else
	{
		afpStartAdminRequest(pIrp);		// Lock admin code
	}

	switch (pIrpSp->MajorFunction)
	{
	  case IRP_MJ_CREATE:
		DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_INFO,
				("afpFsdDispatchAdminRequest: Open Handle\n"));

		INTERLOCKED_INCREMENT_LONG(&afpOpenCount);
		// Fall through

	  case IRP_MJ_CLOSE:
		Status = STATUS_SUCCESS;
		break;

	  case IRP_MJ_DEVICE_CONTROL:
		Status =  afpFsdHandleAdminRequest(pIrp);
		break;

	  case IRP_MJ_FILE_SYSTEM_CONTROL:
		Status = AfpSecurityUtilityWorker(pIrp, pIrpSp);
		break;

	  case IRP_MJ_CLEANUP:
		Status = STATUS_SUCCESS;
		DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_INFO,
				("afpFsdDispatchAdminRequest: Close Handle\n"));
		INTERLOCKED_DECREMENT_LONG(&afpOpenCount);

#if 0
		// If the service is closing its handle. Force a service stop
		if ((afpOpenCount == 0) &&
			(AfpServerState != AFP_STATE_STOPPED))
			AfpAdmServiceStop(NULL, 0, NULL);
#endif
		break;

	  case IRP_MJ_SHUTDOWN:
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
				("afpFsdDispatchAdminRequest: Received shutdown notification !!\n"));
		Status = afpFsdHandleShutdownRequest(pIrp);
		break;

	  default:
		Status = STATUS_NOT_IMPLEMENTED;
		break;
	}

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	if (Status != STATUS_PENDING)
	{
		pIrp->IoStatus.Status = Status;
		if (LockDown)
		{
			afpStopAdminRequest(pIrp);	// Unlock admin code (and complete request)
		}
		else
		{
			IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
		}
	}

	return Status;
}


/***	afpFsdHandleAdminRequest
 *
 *	This is the admin request handler. The list of admin requests are defined
 *	in admin.h. The admin requests must happen in a pre-defined order. The
 *	service start must happen after atleast the following.
 *
 *		ServerSetInfo
 *
 *	Preferably all VolumeAdds should also happen before server start. This is
 *	not enforced, obviously since the server can start w/o any volumes defined.
 *
 */
LOCAL NTSTATUS
afpFsdHandleAdminRequest(
	IN PIRP		pIrp
)
{
	NTSTATUS				Status = STATUS_PENDING;
	USHORT					FuncCode;
	USHORT					Method;
	PVOID					pBufIn;
	PVOID					pBufOut;
	LONG					i, Off, iBufLen, oBufLen;
    LONG                    NumEntries;
	PADMQREQ				pAdmQReq;
	IN PIO_STACK_LOCATION	pIrpSp;
	struct	_AdminApiDispatchTable *pDispTab;


	PAGED_CODE( );

	// Initialize the I/O Status block
	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	iBufLen = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
	pBufIn = pIrp->AssociatedIrp.SystemBuffer;

	FuncCode = (USHORT)AFP_CC_BASE(pIrpSp->Parameters.DeviceIoControl.IoControlCode);
	Method = (USHORT)AFP_CC_METHOD(pIrpSp->Parameters.DeviceIoControl.IoControlCode);

	if (Method == METHOD_BUFFERED)
	{
		// Get the output buffer and its length. Input and Output buffers are
		// both pointed to by the SystemBuffer
		pBufOut = pBufIn;
		oBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
	}
	else if ((Method == METHOD_IN_DIRECT) && (pIrp->MdlAddress != NULL))
	{
		pBufOut = MmGetSystemAddressForMdlSafe(
				pIrp->MdlAddress,
				NormalPagePriority);

        if (pBufOut == NULL)
        {
            ASSERT(0);
		    return STATUS_INSUFFICIENT_RESOURCES;
        }
		oBufLen = MmGetMdlByteCount(pIrp->MdlAddress);
	}
	else
	{
		DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_ERR,
				("afpFsdHandleAdminRequest: Invalid Request %d/%d\n", FuncCode, Method));
		return STATUS_INVALID_PARAMETER;
	}

	DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_INFO,
			("afpFsdHandleAdminRequest Entered, Function %d\n", FuncCode));

	// Validate the function code
	if (FuncCode == 0 || FuncCode >= CC_BASE_MAX)
		return STATUS_INVALID_PARAMETER;

	pDispTab = &AfpAdminDispatchTable[FuncCode - 1];
	if ((pDispTab->_MinBufLen > (SHORT)iBufLen) ||
		(pDispTab->_OpCode != pIrpSp->Parameters.DeviceIoControl.IoControlCode))
	{
		return STATUS_INVALID_PARAMETER;
	}

	INTERLOCKED_INCREMENT_LONG( &AfpServerStatistics.stat_NumAdminReqs );

	if (pDispTab->_CausesChange)
		INTERLOCKED_INCREMENT_LONG( &AfpServerStatistics.stat_NumAdminChanges );
							

	// Now validate the DESCRIPTOR of the input buffer
	for (i = 0; i < MAX_FIELDS; i++)
	{
		if (pDispTab->_Fields[i]._FieldDesc == DESC_NONE)
			break;

		Off = pDispTab->_Fields[i]._FieldOffset;
		switch (pDispTab->_Fields[i]._FieldDesc)
		{
		  case DESC_STRING:
		    ASSERT(pBufIn != NULL);

		    // Make Sure that the string is pointing to somewhere within
		    // the buffer and also the end of the buffer is a UNICODE_NULL
			if ((*(PLONG)((PBYTE)pBufIn + Off) > iBufLen) ||
				(*(LPWSTR)((PBYTE)pBufIn + iBufLen - sizeof(WCHAR)) != UNICODE_NULL))
		    {
				return STATUS_INVALID_PARAMETER;
		    }
		    // Convert the offset to a pointer
		    OFFSET_TO_POINTER(*(PBYTE *)((PBYTE)pBufIn + Off),
							  (PBYTE)pBufIn + pDispTab->_OffToStruct);
		    break;

		  case DESC_ETC:
		    ASSERT(pBufIn != NULL);

		    // Make Sure that there are as many etc mappings as the
		    // structure claims
            NumEntries = *(PLONG)((PBYTE)pBufIn + Off);
		    if ((LONG)(NumEntries * sizeof(ETCMAPINFO) + sizeof(DWORD)) > iBufLen)
		    {
		    	return STATUS_INVALID_PARAMETER;
		    }

            if (NumEntries > (LONG)((iBufLen/sizeof(ETCMAPINFO)) + 1))
            {
		    	return STATUS_INVALID_PARAMETER;
            }
		    break;

		  case DESC_ICON:
		    // Validate that the buffer is atleast big enough to hold the
		    // icon that this purports to.
		    ASSERT(pBufIn != NULL);

		    if ((LONG)((*(PLONG)((PBYTE)pBufIn + Off) +
		    			 sizeof(SRVICONINFO))) > iBufLen)
		    {
		    	return STATUS_INVALID_PARAMETER;
		    }
		    break;

		  case DESC_SID:
		    // Validate that the buffer is big enough to hold the Sid
		    ASSERT(pBufIn != NULL);
		    {
		    	LONG	Offst, SidSize;

		    	Offst = *(PLONG)((PBYTE)pBufIn + Off);
				// If no SID is being sent then we're done
				if (Offst == 0)
				{
					break;
				}

		    	if ((Offst > iBufLen) ||
		    		(Offst < (LONG)(sizeof(AFP_DIRECTORY_INFO))) ||
		    		((Offst + (LONG)sizeof(SID)) > iBufLen))
		    	{
		    		return STATUS_INVALID_PARAMETER;
		    	}

		    	// Convert the offset to a pointer
		    	OFFSET_TO_POINTER(*(PBYTE *)((PBYTE)pBufIn + Off),
		    				(PBYTE)pBufIn + pDispTab->_OffToStruct);

		    	// Finally check if the buffer is big enough for the real
		    	// sid
		    	SidSize = RtlLengthSid(*((PSID *)((PBYTE)pBufIn + Off)));
		    	if ((Off + SidSize) > iBufLen)
		    	{
		    		return STATUS_INVALID_PARAMETER;
		    	}
		    }
		    break;

		  case DESC_SPECIAL:
		    // Validate that the buffer is big enough to hold all the
		    // information. The information consists of limits on non-paged
		    // and paged memory and a list of domain sids and their corres.
		    // posix offsets
		    ASSERT(pBufIn != NULL);
		    {
		    	LONG			i;
		    	LONG			SizeRemaining;
		    	PAFP_SID_OFFSET	pSidOff;

		    	SizeRemaining = iBufLen - (sizeof(AFP_SID_OFFSET_DESC) -
		    										sizeof(AFP_SID_OFFSET));
		    	for (i = 0;
		    		 i < (LONG)(((PAFP_SID_OFFSET_DESC)pBufIn)->CountOfSidOffsets);
		    		 i++, pSidOff++)
		    	{
		    		pSidOff = &((PAFP_SID_OFFSET_DESC)pBufIn)->SidOffsetPairs[i];
		    		if (SizeRemaining < (sizeof(AFP_SID_OFFSET) + sizeof(SID)))
		    			return STATUS_INVALID_PARAMETER;
		    		OFFSET_TO_POINTER(pSidOff->pSid, pSidOff);

		    		if ((LONG)(((PBYTE)(pSidOff->pSid) - (PBYTE)pBufIn +
		    					RtlLengthSid(pSidOff->pSid))) > iBufLen)
		    			return STATUS_INVALID_PARAMETER;
		    		SizeRemaining -= (RtlLengthSid(pSidOff->pSid) +
		    						  sizeof(AFP_SID_OFFSET));
		    	}
		    }
		    break;
		}
	}

	// Can this request be handled/validated at this level
	if (pDispTab->_AdminApiWorker != NULL)
	{
		Status = (*pDispTab->_AdminApiWorker)(pBufIn, oBufLen, pBufOut);

		if (NT_SUCCESS(Status))
		{
			if (Method != METHOD_BUFFERED)
				pIrp->IoStatus.Information = oBufLen;
		}
	}

	if (Status == STATUS_PENDING)
	{
		ASSERT (pDispTab->_AdminApiQueuedWorker != NULL);

		// Mark this as a pending Irp as we are about to queue it up
		IoMarkIrpPending(pIrp);

		if ((pAdmQReq =
			(PADMQREQ)AfpAllocNonPagedMemory(sizeof(ADMQREQ))) == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
		}
		else
		{
			PWORK_ITEM	pWI = &pAdmQReq->aqr_WorkItem;

			DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_INFO,
					("afpFsdHandleAdminRequest: Queuing to worker\n"));

			AfpInitializeWorkItem(pWI,
								 afpHandleQueuedAdminRequest,
								 pAdmQReq);

			pAdmQReq->aqr_AdminApiWorker = pDispTab->_AdminApiQueuedWorker;
			pAdmQReq->aqr_pIrp = pIrp;

			// Insert item in admin queue
			INTERLOCKED_ADD_ULONG(&AfpWorkerRequests, 1, &AfpServerGlobalLock);
			KeInsertQueue(&AfpAdminQueue, &pAdmQReq->aqr_WorkItem.wi_List);
		}
	}

	return Status;
}

/***	afpHandleQueuedAdminRequest
 *
 *	This handles queued admin requests. It is called in the context of the
 *	worker thread.
 */
LOCAL VOID FASTCALL
afpHandleQueuedAdminRequest(
	IN	PADMQREQ	pAdmQReq
)
{
	PIRP				pIrp;
	PIO_STACK_LOCATION	pIrpSp;
	PVOID				pBufOut = NULL;
	LONG				oBufLen = 0;
	USHORT				Method;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_INFO,
			("afpHandleQueuedAdminRequest Entered\n"));

	// Get the IRP and the IRP Stack location out of the request
	pIrp = pAdmQReq->aqr_pIrp;
	ASSERT (pIrp != NULL);

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	ASSERT (pIrpSp != NULL);

	Method = (USHORT)AFP_CC_METHOD(pIrpSp->Parameters.DeviceIoControl.IoControlCode);

	if (Method == METHOD_BUFFERED)
	{
		// Get the output buffer and its length. Input and Output buffers are
		// both pointed to by the SystemBuffer
		oBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
		pBufOut = pIrp->AssociatedIrp.SystemBuffer;
	}
	else if ((Method == METHOD_IN_DIRECT) && (pIrp->MdlAddress != NULL))
	{
		pBufOut = MmGetSystemAddressForMdlSafe(
				        pIrp->MdlAddress,
				        NormalPagePriority);

        if (pBufOut == NULL)
        {
            ASSERT(0);

            pAdmQReq->aqr_pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoCompleteRequest(pAdmQReq->aqr_pIrp, IO_NETWORK_INCREMENT);
            AfpFreeMemory(pAdmQReq);

            return;
        }
		oBufLen = MmGetMdlByteCount(pIrp->MdlAddress);
	}
	else ASSERTMSG(0, "afpHandleQueuedAdminRequest: Invalid method\n");

		
	// Call the worker and complete the IoRequest
	pIrp->IoStatus.Status = (*pAdmQReq->aqr_AdminApiWorker)(pIrp->AssociatedIrp.SystemBuffer,
														    oBufLen,
															pBufOut);
	if (NT_SUCCESS(pIrp->IoStatus.Status))
	{
		if (Method != METHOD_BUFFERED)
			pIrp->IoStatus.Information = oBufLen;
	}

	ASSERT(pIrp->IoStatus.Status != STATUS_PENDING);

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	afpStopAdminRequest(pIrp);		// Unlock admin code and complete request

	AfpFreeMemory(pAdmQReq);
}



/***	afpFsdUnloadServer
 *
 *	This is the unload routine for the Afp Server. The server can ONLY be
 *	unloaded in its passive state i.e. either before recieving a ServiceStart
 *	or after recieving a ServiceStop. This is ensured by making the service
 *	dependent on the server. Also the IO system ensures that there are no open
 *	handles to our device when this happens.
 */
LOCAL VOID
afpFsdUnloadServer(
	IN	PDRIVER_OBJECT DeviceObject
)
{
	NTSTATUS		Status;
	LONG			i;
	LONG			LastThreadCount = 0;
	PETHREAD		pLastThrdPtr;

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("afpFsdUnloadServer Entered\n"));

	ASSERT((AfpServerState == AFP_STATE_STOPPED) || (AfpServerState == AFP_STATE_IDLE));

	// Stop our threads before unloading
	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("afpFsdUnloadServer: Stopping worker threads\n"));

	//
    // tell TDI we don't care to know if the stack is going away
	//
    if (AfpTdiNotificationHandle)
    {
        Status = TdiDeregisterPnPHandlers(AfpTdiNotificationHandle);

        if (!NT_SUCCESS(Status))
        {
	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			    ("afpFsdUnloadServer: TdiDeregisterNotificationHandler failed with %lx\n",Status));
        }

        AfpTdiNotificationHandle = NULL;
    }

    DsiShutdown();

	// Stop the scavenger. This also happens during server stop but we can get here
	// another way as well
	AfpScavengerFlushAndStop();

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("afpFsdUnloadServer: Stopping admin thread\n"));

	if (AfpNumAdminThreads > 0)
	{
		KeClearEvent(&AfpStopConfirmEvent);

		KeInsertQueue(&AfpAdminQueue, &AfpTerminateThreadWI.wi_List);

		do
		{
			Status = AfpIoWait(&AfpStopConfirmEvent, &FiveSecTimeOut);
			if (Status == STATUS_TIMEOUT)
			{
				DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
						("afpFsdUnloadServer: Timeout Waiting for admin thread, re-waiting\n"));
			}
		} while (Status == STATUS_TIMEOUT);
	}

	KeRundownQueue(&AfpAdminQueue);

	if (AfpNumNotifyThreads > 0)
	{
		for (i = 0; i < NUM_NOTIFY_QUEUES; i++)
		{
			KeClearEvent(&AfpStopConfirmEvent);
	
			KeInsertQueue(&AfpVolumeNotifyQueue[i], &AfpTerminateNotifyThread.vn_List);
	
			do
			{
				Status = AfpIoWait(&AfpStopConfirmEvent, &FiveSecTimeOut);
				if (Status == STATUS_TIMEOUT)
				{
					DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
							("afpFsdUnloadServer: Timeout Waiting for Notify Thread %d, re-waiting\n", i));
				}
			} while (Status == STATUS_TIMEOUT);
			KeRundownQueue(&AfpVolumeNotifyQueue[i]);
		}
	}

    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    // Cleanup virtual memory used by volumes for private notifies
    afpFreeNotifyBlockMemory();

	// Stop worker threads
	if (AfpNumThreads > 0)
	{
		KeClearEvent(&AfpStopConfirmEvent);

		KeInsertQueue(&AfpWorkerQueue, &AfpTerminateThreadWI.wi_List);

		do
		{
			Status = AfpIoWait(&AfpStopConfirmEvent, &FiveSecTimeOut);
			if (Status == STATUS_TIMEOUT)
			{
				DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
						("afpFsdUnloadServer: Timeout Waiting for worker threads, re-waiting\n"));
			}
		} while (Status == STATUS_TIMEOUT);
	}

    // See how many threads are around
    // Loop around until we have exactly one thread left or if no worker
    // thread was started
    do 
    {
	    pLastThrdPtr = NULL;
        LastThreadCount = 0;

	    for (i=0; i<AFP_MAX_THREADS; i++)
	    {
	        if (AfpThreadPtrsW[i] != NULL)
	        {
		        pLastThrdPtr = AfpThreadPtrsW[i];
		        LastThreadCount++;

		        if (LastThreadCount > 1)
		        {
		            Status = AfpIoWait(pLastThrdPtr, &FiveSecTimeOut);
                    break;
		        }
    
	        }
        }

        if ((LastThreadCount == 1) || (LastThreadCount == 0))
        {
            break;
        }
	} while (TRUE);

	// wait on the last thread pointer.  When that thread quits, we are signaled.  This
	// is the surest way of knowing that the thread has really really died
	if (pLastThrdPtr)
	{
	    do
	    {
		Status = AfpIoWait(pLastThrdPtr, &FiveSecTimeOut);
		if (Status == STATUS_TIMEOUT)
		{
			DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
					("afpFsdUnloadServer: Timeout Waiting for last threads, re-waiting\n"));
		}
	    } while (Status == STATUS_TIMEOUT);

	    ObDereferenceObject(pLastThrdPtr);
	}

	KeRundownQueue(&AfpDelAllocQueue);

	KeRundownQueue(&AfpWorkerQueue);

	// Close the cloned process token
	if (AfpFspToken != NULL)
		NtClose(AfpFspToken);

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("afpFsdUnloadServer: De-initializing sub-systems\n"));

	// De-initialize all sub-systems now
	AfpDeinitializeSubsystems();

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("afpFsdUnloadServer: Deleting device\n"));

	// Destroy the DeviceObject for our device
	IoDeleteDevice(AfpDeviceObject);

#ifdef	PROFILING
	ASSERT(AfpServerProfile->perf_cAllocatedIrps == 0);
	ASSERT(AfpServerProfile->perf_cAllocatedMdls == 0);
	ExFreePool(AfpServerProfile);
#endif

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO, ("Current Sessions = %ld\n NonPaged usage = %ld\n CurrPagedUsage = %ld \n CurrentFileLocks = %ld \n CurrentFileOpen = %ld \n CurrentInternalOpens = %ld, NotifyBlockCount = %ld, NotifyCount = %d \n", 
	AfpServerStatistics.stat_CurrentSessions,
	AfpServerStatistics.stat_CurrNonPagedUsage, 
	AfpServerStatistics.stat_CurrPagedUsage,
	AfpServerStatistics.stat_CurrentFileLocks,
	AfpServerStatistics.stat_CurrentFilesOpen,
	AfpServerStatistics.stat_CurrentInternalOpens,
    	afpNotifyBlockAllocCount,
    	afpNotifyAllocCount
    	));

	// Make sure we do not have resource leaks
	ASSERT(AfpServerStatistics.stat_CurrentSessions == 0);
	ASSERT(AfpServerStatistics.stat_CurrNonPagedUsage == 0);
	ASSERT(AfpServerStatistics.stat_CurrPagedUsage == 0);
	ASSERT(AfpServerStatistics.stat_CurrentFileLocks == 0);
	ASSERT(AfpServerStatistics.stat_CurrentFilesOpen == 0);
	ASSERT(AfpServerStatistics.stat_CurrentInternalOpens == 0);

	ASSERT (AfpLockCount == 0);

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO, ("afpFsdUnloadServer Done\n"));

	// Give the worker threads a chance to really, really die
	AfpSleepAWhile(1000);

}


/***	afpAdminThread
 *
 *	This thread is used to do all the work of the queued admin threads.
 *
 *	LOCKS:	AfpServerGlobalLock (SPIN)
 */
LOCAL VOID
afpAdminThread(
	IN	PVOID	pContext
)
{
	PLIST_ENTRY			pList;
	PWORK_ITEM			pWI;
	ULONG				BasePriority;
	NTSTATUS			Status;

	AfpThread = PsGetCurrentThread();

    IoSetThreadHardErrorMode( FALSE );

	// Boost our priority to just below low realtime.
	// The idea is get the work done fast and get out of the way.
	BasePriority = LOW_REALTIME_PRIORITY;
	Status = NtSetInformationThread(NtCurrentThread(),
									ThreadBasePriority,
									&BasePriority,
									sizeof(BasePriority));
	ASSERT(NT_SUCCESS(Status));

	do
	{
		// Wait for admin request to process.
		pList = KeRemoveQueue(&AfpAdminQueue,
							  KernelMode,		// Do not let the kernel stack be paged
							  NULL);
		ASSERT(Status == STATUS_SUCCESS);

		ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

		pWI = CONTAINING_RECORD(pList, WORK_ITEM, wi_List);

		if (pWI == &AfpTerminateThreadWI)
		{
			break;
		}

		(*pWI->wi_Worker)(pWI->wi_Context);
		INTERLOCKED_ADD_ULONG(&AfpWorkerRequests, (ULONG)-1, &AfpServerGlobalLock);

		ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);
	} while (True);

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO, ("afpAdminThread: Quitting\n"));

	KeSetEvent(&AfpStopConfirmEvent, IO_NETWORK_INCREMENT, False);
}


/***	afpStartStopAdminRequest
 *
 *	Called whenever an admin request is started/stopped. The admin code is locked
 *	or unlocked accordingly.
 */
LOCAL VOID
afpStartStopAdminRequest(
	IN	PIRP			pIrp,
	IN	BOOLEAN			Start
)
{

	// EnterCriticalSection
	AfpIoWait(&AfpPgLkMutex, NULL);

	ASSERT (AfpLockHandle != NULL);

	if (Start)
	{
		if (AfpLockCount == 0)
		{
			MmLockPagableSectionByHandle(AfpLockHandle);
		}
		AfpLockCount ++;
		pIrp->IoStatus.Status = STATUS_PENDING;
	}
	else
	{
		ASSERT (AfpLockCount > 0);

		AfpLockCount --;
		if (AfpLockCount == 0)
		{
			MmUnlockPagableImageSection(AfpLockHandle);
		}
	}

	// LeaveCriticalSection
	KeReleaseMutex(&AfpPgLkMutex, False);

	if (!Start)
		IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
}


/***	afpFsdHandleShutdownRequest
 *
 *	This is the shutdown request handler. All sessions are shutdown and volumes
 *	flushed.
 */
LOCAL NTSTATUS
afpFsdHandleShutdownRequest(
	IN PIRP			pIrp
)
{
	PADMQREQ			pAdmQReq;
	NTSTATUS			Status;

	if ((pAdmQReq =
		(PADMQREQ)AfpAllocNonPagedMemory(sizeof(ADMQREQ))) == NULL)
	{
		Status = STATUS_INSUFFICIENT_RESOURCES;
	}
	else
	{
		PWORK_ITEM	pWI = &pAdmQReq->aqr_WorkItem;

		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
				("afpFsdHandleShutdownRequest: Queuing to worker\n"));

		AfpInitializeWorkItem(&pAdmQReq->aqr_WorkItem,
							 afpHandleQueuedAdminRequest,
							 pAdmQReq);

		pAdmQReq->aqr_AdminApiWorker = AfpAdmSystemShutdown;
		pAdmQReq->aqr_pIrp = pIrp;

		// Insert item in admin queue
		KeInsertQueue(&AfpAdminQueue, &pAdmQReq->aqr_WorkItem.wi_List);
		Status = STATUS_PENDING;
	}

	return Status;
}


/***	DriverEntry
 *
 *  This is the initialization routine for the AFP server file
 *  system driver.  This routine creates the device object for the
 *  AfpServer device and performs all other driver initialization.
 */

NTSTATUS
DriverEntry (
	IN PDRIVER_OBJECT	DriverObject,
	IN PUNICODE_STRING	RegistryPath
)
{
	UNICODE_STRING	DeviceName;
	LONG			i;
	NTSTATUS		Status;

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("AFP Server Fsd initialization started\n"));

	//
	// Initialize global data event log insertion strings
	//


	KeInitializeQueue(&AfpDelAllocQueue, 0);
	KeInitializeQueue(&AfpWorkerQueue, 0);
    KeInitializeQueue(&AfpAdminQueue, 0);

	AfpProcessObject = IoGetCurrentProcess();

	Status = AfpInitializeDataAndSubsystems();

	if (!NT_SUCCESS(Status))
	{
		return Status;
	}

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("AFP Server Fsd Data initialized %lx\n", Status));

	// Create the device object.  (IoCreateDevice zeroes the memory
	// occupied by the object.)
	//
	// Should we apply an ACL to the device object ?

	RtlInitUnicodeString(&DeviceName, AFPSERVER_DEVICE_NAME);

	Status = IoCreateDevice(DriverObject,			// DriverObject
							0,						// DeviceExtension
							&DeviceName,			// DeviceName
							FILE_DEVICE_NETWORK,	// DeviceType
							FILE_DEVICE_SECURE_OPEN, // DeviceCharacteristics
							False,					// Exclusive
							&AfpDeviceObject);		// DeviceObject

	if (!NT_SUCCESS(Status))
	{
		// Do not errorlog here since logging uses the device object
		AfpDeinitializeSubsystems();
		return Status;
	}

	do
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("DriverEntry: Creating Admin Thread\n"));

		// Create the Admin thread. This handles all queued operations

		Status = AfpCreateNewThread(afpAdminThread, 0);
		if (!NT_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_FATAL,
					("afpInitServer: Admin Thread creation failed %lx\n", Status));
			break;
		}
		AfpNumAdminThreads = 1;

		for (i = 0; i < NUM_NOTIFY_QUEUES; i++)
		{
			// Initialize volume change notify queue
			KeInitializeQueue(&AfpVolumeNotifyQueue[i], 0);

			// Start a thread to process change notifies
			Status = AfpCreateNewThread(AfpChangeNotifyThread, i);
			if (!NT_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_FATAL,
						("afpInitServer: Notify Thread %d, creation failed %lx\n", i+1, Status));
				break;
			}
		}
		if (!NT_SUCCESS(Status))
		{
			for (--i; i >= 0; i--)
			{
				KeClearEvent(&AfpStopConfirmEvent);
				KeInsertQueue(&AfpVolumeNotifyQueue[i], &AfpTerminateNotifyThread.vn_List);
				AfpIoWait(&AfpStopConfirmEvent, NULL);
			}
			break;
		}

		AfpNumNotifyThreads = NUM_NOTIFY_QUEUES;

		for (i = 0; i < AFP_MIN_THREADS; i++)
		{
			AfpThreadState[i] = AFP_THREAD_STARTED;
			Status = AfpCreateNewThread(AfpWorkerThread, i);
			if (!NT_SUCCESS(Status))
			{
				AfpThreadState[i] = AFP_THREAD_DEAD;
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_FATAL,
						("afpInitServer: Thread creation failed %d\n", i+1));
				if (i > 0)
				{
					KeClearEvent(&AfpStopConfirmEvent);
					KeInsertQueue(&AfpWorkerQueue, &AfpTerminateThreadWI.wi_List);
					AfpIoWait(&AfpStopConfirmEvent, NULL);
				}
				break;
			}
#if DBG
			AfpSleepAWhile(50);		// Make it so threads do not time out together
									// Helps with debugging
#endif
		}
		AfpNumThreads = AFP_MIN_THREADS;

		if (!NT_SUCCESS(Status))
			break;

		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("AFP Server Fsd initialization completed %lx\n", Status));


        // initialize DSI specific things
        DsiInit();

        Status = AfpTdiRegister();

	    if (!NT_SUCCESS(Status))
	    {
	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			    ("TdiRegisterNotificationHandler failed %lx\n", Status));
		    break;
	    }

		Status = afpInitServer();

		if (NT_SUCCESS(Status))
		{
			// Initialize the driver object for this file system driver.
			DriverObject->DriverUnload = afpFsdUnloadServer;
			for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
			{
				DriverObject->MajorFunction[i] = afpFsdDispatchAdminRequest;
			}

			// Register for shutdown notification.  We don't care if this fails.
			Status = IoRegisterShutdownNotification(AfpDeviceObject);
			if (!NT_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("Afp Server Fsd: IoRegisterShutdownNotification failed %lx\n", Status));
			}
			Status = STATUS_SUCCESS;
		}
	} while (False);

	if (!NT_SUCCESS(Status))
	{
		afpFsdUnloadServer(DriverObject);
		Status = STATUS_UNSUCCESSFUL;
	}

	KeClearEvent(&AfpStopConfirmEvent);

	return Status;
}





/***	afpInitServer
 *
 *	Initialize the AFP Server. This happens on FSD initialization.
 *	The initialization consists of the following steps.
 *
 *	- Create a socket on the appletalk stack.
 *	- Create a token for ourselves.
 *	- Initialize security
 *	- Open the Authentication pacakage
 *
 * Note: Any errorlogging done from here must use AFPLOG_DDERROR since we
 *    will not have a usermode thread to do our errorlogging if anything
 *    goes wrong here.
 */
NTSTATUS
afpInitServer(
	VOID
)
{
	NTSTATUS			Status;
	ANSI_STRING			LogonProcessName;
	ULONG				OldSize;
	HANDLE				ProcessToken;
	TOKEN_PRIVILEGES	ProcessPrivileges, PreviousPrivilege;
	OBJECT_ATTRIBUTES	ObjectAttr;
	UNICODE_STRING	    PackageName;
	WCHAR				PkgBuf[5];
	TimeStamp			Expiry;       // unused on the server side (i.e. us)


	InitSecurityInterface();

	do
	{
		// Open our socket on the ASP Device. Implicitly checks out the
		// Appletalk stack

		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("afpInitServer: Initializing Atalk\n"));

		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("afpInitServer: Creating token\n"));

		// Clone the system process token and add the required privilges that
		// we need. This token will be used to impersonate when we set permissions
		Status = NtOpenProcessToken(NtCurrentProcess(),
									TOKEN_ALL_ACCESS,
									&ProcessToken);
		if (!NT_SUCCESS(Status))
		{
			AFPLOG_DDERROR(AFPSRVMSG_PROCESS_TOKEN, Status, NULL, 0, NULL);
			break;
		}

		InitializeObjectAttributes(&ObjectAttr, NULL, 0, NULL, NULL);
		ObjectAttr.SecurityQualityOfService = &AfpSecurityQOS;

		Status = NtDuplicateToken(ProcessToken,
								  TOKEN_ALL_ACCESS,
								  &ObjectAttr,
								  False,
								  TokenImpersonation,
								  &AfpFspToken);

		NtClose(ProcessToken);

		if (!NT_SUCCESS(Status))
		{
			AFPLOG_DDERROR(AFPSRVMSG_PROCESS_TOKEN, Status, NULL, 0, NULL);
			break;
		}

		ProcessPrivileges.PrivilegeCount = 1L;
		ProcessPrivileges.Privileges[0].Attributes =
								SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_USED_FOR_ACCESS;
		ProcessPrivileges.Privileges[0].Luid = RtlConvertLongToLuid(SE_RESTORE_PRIVILEGE);

		Status = NtAdjustPrivilegesToken(AfpFspToken,
										 False,
										 &ProcessPrivileges,
										 sizeof(TOKEN_PRIVILEGES),
										 &PreviousPrivilege,
										 &OldSize);

		if (!NT_SUCCESS(Status))
		{
			AFPLOG_DDERROR(AFPSRVMSG_PROCESS_TOKEN, Status, NULL, 0, NULL);
			break;
		}

		PackageName.Length = 8;
		PackageName.Buffer = (LPWSTR)PkgBuf;
		RtlCopyMemory( PackageName.Buffer, NTLMSP_NAME, 8);

		Status = AcquireCredentialsHandle(NULL,		// Default principal
										  (PSECURITY_STRING)&PackageName,
										  SECPKG_CRED_INBOUND,
										  NULL,
										  NULL,
										  NULL,
										  (PVOID) NULL,
										  &AfpSecHandle,
										  &Expiry);
		if(!NT_SUCCESS(Status))
		{
		    DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
			   ("AfpInitServer: AcquireCredentialsHandle() failed with %X\n", Status));
		    ASSERT(0);

		    if (AfpFspToken != NULL)
		    {
				NtClose(AfpFspToken);
				AfpFspToken = NULL;
		    }

		    break;
		}

		// Finally obtain a handle to our conditionally locked section
		AfpLockHandle = MmLockPagableCodeSection((PVOID)AfpAdmWServerSetInfo);
		MmUnlockPagableImageSection(AfpLockHandle);

	} while (False);

	return Status;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\fsp_dtp.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsp_dtp.c

Abstract:

	This module contains the entry points for the AFP desktop APIs queued to
	the FSP. These are all callable from FSP Only.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FSP_DTP

#include <afp.h>
#include <gendisp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <client.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpFspDispAddIcon)
#pragma alloc_text( PAGE, AfpFspDispGetIcon)
#pragma alloc_text( PAGE, AfpFspDispGetIconInfo)
#pragma alloc_text( PAGE, AfpFspDispAddAppl)
#pragma alloc_text( PAGE, AfpFspDispGetAppl)
#pragma alloc_text( PAGE, AfpFspDispRemoveAppl)
#pragma alloc_text( PAGE, AfpFspDispAddComment)
#pragma alloc_text( PAGE, AfpFspDispGetComment)
#pragma alloc_text( PAGE, AfpFspDispRemoveComment)
#endif

/***	AfpFspDispAddIcon
 *
 *	This is the worker routine for the AfpAddIcon API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Creator
 *	sda_ReqBlock	DWORD		Type
 *	sda_ReqBlock	DWORD		IconType
 *	sda_ReqBlock	DWORD		IconTag
 *	sda_ReqBlock	LONG		BitmapSize
 *	sda_ReplyBuf	BYTE[]		IconBuffer
 */
AFPSTATUS FASTCALL
AfpFspDispAddIcon(
	IN	PSDA	pSda
)
{
	AFPSTATUS	Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_Creator;
		DWORD		_Type;
		DWORD		_IconType;
		DWORD		_IconTag;
		LONG		_Size;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispAddIcon: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	ASSERT(VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));


	if (pSda->sda_IOSize > 0)
	{
		ASSERT(pSda->sda_IOBuf != NULL);

		Status = AfpAddIcon(pReqPkt->_pConnDesc->cds_pVolDesc,
							pReqPkt->_Creator,
							pReqPkt->_Type,
							pReqPkt->_IconTag,
							pReqPkt->_Size,
							pReqPkt->_IconType,
							pSda->sda_IOBuf);
		AfpFreeIOBuffer(pSda);
	}

	return Status;
}


/***	AfpFspDispGetIcon
 *
 *	This is the worker routine for the AfpGetIcon API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Creator
 *	sda_ReqBlock	DWORD		Type
 *	sda_ReqBlock	DWORD		IconType
 *	sda_ReqBlock	LONG		Length of buffer
 */
AFPSTATUS FASTCALL
AfpFspDispGetIcon(
	IN	PSDA	pSda
)
{
	AFPSTATUS	Status = AFP_ERR_PARAM;
    LONG        ActualLength;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_Creator;
		DWORD		_Type;
		DWORD		_IconType;
		LONG		_Length;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispGetIcon: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	if (pReqPkt->_Length >= 0)
	{
		pSda->sda_ReplySize = (USHORT)pReqPkt->_Length;
		if (pReqPkt->_Length > (LONG)pSda->sda_MaxWriteSize)
			pSda->sda_ReplySize = (USHORT)pSda->sda_MaxWriteSize;

		if ((pSda->sda_ReplySize == 0) ||
			((pSda->sda_ReplySize > 0) &&
			 (Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE))
		{
			if ((Status = AfpLookupIcon(pReqPkt->_pConnDesc->cds_pVolDesc,
										pReqPkt->_Creator,
										pReqPkt->_Type,
										pReqPkt->_Length,
										pReqPkt->_IconType,
                                        &ActualLength,
										pSda->sda_ReplyBuf)) != AFP_ERR_NONE)
			{
				Status = AFP_ERR_ITEM_NOT_FOUND;
			}
            else
            {
                pSda->sda_ReplySize = (USHORT)ActualLength;
            }
		}
	}

	return Status;
}


/***	AfpFspDispGetIconInfo
 *
 *	This is the worker routine for the AfpGetIconInfo API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Creator
 *	sda_ReqBlock	LONG		Icon index
 */
AFPSTATUS FASTCALL
AfpFspDispGetIconInfo(
	IN	PSDA	pSda
)
{
	LONG		Size;
	DWORD		Type,
				Tag;
	DWORD		IconType;
	AFPSTATUS	Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_Creator;
		DWORD		_Index;
	};
	struct _ResponsePacket
	{
		BYTE		__IconTag[4];
		BYTE		__Type[4];
		BYTE		__IconType;
		BYTE		__Pad;
		BYTE		__Size[2];
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispGetIconInfo: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	if ((Status = AfpLookupIconInfo(pReqPkt->_pConnDesc->cds_pVolDesc,
									pReqPkt->_Creator,
									pReqPkt->_Index,
									&Type,
									&IconType,
									&Tag,
									&Size)) == AFP_ERR_NONE)
	{
		pSda->sda_ReplySize = SIZE_RESPPKT;
		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
		{
			PUTDWORD2DWORD(&pRspPkt->__IconTag, Tag);
			RtlCopyMemory(&pRspPkt->__Type, (PBYTE)&Type, sizeof(DWORD));
			PUTSHORT2BYTE(&pRspPkt->__IconType, IconType);
			PUTDWORD2SHORT(&pRspPkt->__Size, Size);
		}
	}

	return Status;
}


/***	AfpFspDispAddAppl
 *
 *	This is the worker routine for the AfpAddAppl API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Directory Id
 *	sda_ReqBlock	DWORD		Creator
 *	sda_ReqBlock	DWORD		APPL Tag
 *	sda_Name1		ANSI_STRING	PathName
 */
AFPSTATUS FASTCALL
AfpFspDispAddAppl(
	IN	PSDA	pSda
)
{
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_DirId;
		DWORD		_Creator;
		DWORD		_ApplTag;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispAddAppl: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	AfpInitializePME(&PME, 0, NULL);
	if ((Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										 pReqPkt->_DirId,
										 &pSda->sda_Name1,
										 pSda->sda_PathType,
										 DFE_FILE,
										 FILE_BITMAP_FILENUM |
										 FD_INTERNAL_BITMAP_OPENACCESS_WRITE,
										 &PME,
										 &FDParm)) == AFP_ERR_NONE)
	{
		AfpIoClose(&PME.pme_Handle); // only needed to check for RW access

		Status = AfpAddAppl(pReqPkt->_pConnDesc->cds_pVolDesc,
							pReqPkt->_Creator,
							pReqPkt->_ApplTag,
							FDParm._fdp_AfpId,
							False,
							FDParm._fdp_ParentId);
	}

	return Status;
}


/***	AfpFspDispGetAPPL
 *
 *	This is the worker routine for the AfpGetAppl API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Creator
 *	sda_ReqBlock	DWORD		APPL Index
 *	sda_ReqBlock	DWORD		Bitmap
 */
AFPSTATUS FASTCALL
AfpFspDispGetAppl(
	IN	PSDA	pSda
)
{
	DWORD			ApplTag;
	DWORD			Bitmap,			// Need to copy this as it goes into the resp
					FileNum, ParentID;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_Creator;
		DWORD		_Index;
		DWORD		_Bitmap;
	};
	struct _ResponsePacket
	{
		BYTE		__Bitmap[2];
		BYTE		__ApplTag[4];
		// Followed by the File Parameters. These cannot be represented as a
		// structure since it depends on the bitmap
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispGetAppl: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	Bitmap = pReqPkt->_Bitmap;
	AfpInitializePME(&PME, 0, NULL);

	do
	{
		if ((Status = AfpLookupAppl(pReqPkt->_pConnDesc->cds_pVolDesc,
									pReqPkt->_Creator,
									pReqPkt->_Index,
									&ApplTag, &FileNum, &ParentID)) != AFP_ERR_NONE)
			break;

		AfpInitializeFDParms(&FDParm);

		// Call AfpMapAfpPathForLookup on the parent ID first to make sure
		// its files are cached in.
		if (ParentID != 0)
		{
			ANSI_STRING nullname = {0, 0, NULL};

			if ((Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										 ParentID,
										 &nullname,
										 AFP_LONGNAME,
										 DFE_DIR,
										 0,		// Bitmap
										 NULL,
										 NULL)) != AFP_ERR_NONE)
		    {
				break;
			}
		}

		if ((Status = AfpMapAfpIdForLookup(pReqPkt->_pConnDesc,
								FileNum,
								DFE_FILE,
								Bitmap | FD_INTERNAL_BITMAP_OPENACCESS_READ,
								&PME,	// open a handle to check access
								&FDParm)) != AFP_ERR_NONE)
			break;

		pSda->sda_ReplySize = SIZE_RESPPKT +
						EVENALIGN(AfpGetFileDirParmsReplyLength(&FDParm, Bitmap));

		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
		{
			AfpPackFileDirParms(&FDParm, Bitmap,
								pSda->sda_ReplyBuf + SIZE_RESPPKT);
			PUTDWORD2SHORT(pRspPkt->__Bitmap, Bitmap);
			PUTDWORD2DWORD(pRspPkt->__ApplTag, ApplTag);
		}

	} while (False);

	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	return Status;
}


/***	AfpFspDispRemoveAppl
 *
 *	This is the worker routine for the AfpRemoveAppl API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Directory Id
 *	sda_ReqBlock	DWORD		Creator
 *	sda_Name1		ANSI_STRING	PathName
 */
AFPSTATUS FASTCALL
AfpFspDispRemoveAppl(
	IN	PSDA	pSda
)
{
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_DirId;
		DWORD		_Creator;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispRemoveAppl: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	AfpInitializePME(&PME, 0, NULL);
	if ((Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										 pReqPkt->_DirId,
										 &pSda->sda_Name1,
										 pSda->sda_PathType,
										 DFE_FILE,
										 FILE_BITMAP_FILENUM |
											FD_INTERNAL_BITMAP_OPENACCESS_READWRITE,
										&PME,
										&FDParm)) == AFP_ERR_NONE)
	{
		AfpIoClose(&PME.pme_Handle); // only needed to check access

		Status = AfpRemoveAppl(pReqPkt->_pConnDesc->cds_pVolDesc,
							   pReqPkt->_Creator,
							   FDParm._fdp_AfpId);
	}

	return Status;
}


/***	AfpFspDispAddComment
 *
 *	This is the worker routine for the AfpAddComment API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Directory Id
 *	sda_Name1		ANSI_STRING	PathName
 *	sda_Name2		ANSI_STRING	Comment
 */
AFPSTATUS FASTCALL
AfpFspDispAddComment(
	IN	PSDA	pSda
)
{
	PATHMAPENTITY	PME;
	FILEDIRPARM		FDParm;
	AFPSTATUS		Status;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_DirId;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispAddComment: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	AfpInitializePME(&PME, 0, NULL);
	if ((Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										 pReqPkt->_DirId,
										 &pSda->sda_Name1,
										 pSda->sda_PathType,
										 DFE_ANY,
										 0,
										 &PME,
										 &FDParm)) == AFP_ERR_NONE)
	{
		Status = AFP_ERR_VOLUME_LOCKED;
		if (IS_CONN_NTFS(pReqPkt->_pConnDesc))
			Status = AfpAddComment(pSda,
								   pReqPkt->_pConnDesc->cds_pVolDesc,
								   &pSda->sda_Name2,
								   &PME,
								   IsDir(&FDParm),
								   FDParm._fdp_AfpId);
		AfpIoClose(&PME.pme_Handle);
	}
	return Status;
}


/***	AfpFspDispGetComment
 *
 *	This is the worker routine for the AfpGetComment API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Directory Id
 *	sda_Name1		ANSI_STRING	PathName
 */
AFPSTATUS FASTCALL
AfpFspDispGetComment(
	IN	PSDA	pSda
)
{
	PATHMAPENTITY	PME;
	FILEDIRPARM		FDParm;
	AFPSTATUS		Status;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_DirId;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispGetComment: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	AfpInitializePME(&PME, 0, NULL);
	if ((Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										 pReqPkt->_DirId,
										 &pSda->sda_Name1,
										 pSda->sda_PathType,
										 DFE_ANY,
										 0,
										 &PME,
										 &FDParm)) == AFP_ERR_NONE)
	{
		// Assume no comment to start with
		Status = AFP_ERR_ITEM_NOT_FOUND;

		if (IS_CONN_NTFS(pReqPkt->_pConnDesc) &&
			(FDParm._fdp_Flags & DFE_FLAGS_HAS_COMMENT))
		{
			pSda->sda_ReplySize = AFP_MAXCOMMENTSIZE + 1;

			if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
			{
				if ((Status = AfpGetComment(pSda,
											pReqPkt->_pConnDesc->cds_pVolDesc,
											&PME,
											IsDir(&FDParm))) != AFP_ERR_NONE)
				{
					AfpFreeReplyBuf(pSda, FALSE);
				}
			}
		}
		AfpIoClose(&PME.pme_Handle);
	}

	return Status;
}


/***	AfpFspDispRemoveComment
 *
 *	This is the worker routine for the AfpRemoveComment API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Directory Id
 *	sda_Name1		ANSI_STRING	PathName
 */
AFPSTATUS FASTCALL
AfpFspDispRemoveComment(
	IN	PSDA	pSda
)
{
	PATHMAPENTITY	PME;
	FILEDIRPARM		FDParm;
	AFPSTATUS		Status = AFP_ERR_ITEM_NOT_FOUND;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_DirId;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_DTP, DBG_LEVEL_INFO,
										("AfpFspDispRemoveComment: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	AfpInitializePME(&PME, 0, NULL);
	if (IS_CONN_NTFS(pReqPkt->_pConnDesc) &&
		(Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										 pReqPkt->_DirId,
										 &pSda->sda_Name1,
										 pSda->sda_PathType,
										 DFE_ANY,
										 0,
										 &PME,
										 &FDParm)) == AFP_ERR_NONE)
	{
		Status = AFP_ERR_ITEM_NOT_FOUND;
		if (IS_CONN_NTFS(pReqPkt->_pConnDesc) &&
			(FDParm._fdp_Flags & DFE_FLAGS_HAS_COMMENT))
			Status = AfpRemoveComment(pSda,
									  pReqPkt->_pConnDesc->cds_pVolDesc,
									  &PME,
									  IsDir(&FDParm),
									  FDParm._fdp_AfpId);
		AfpIoClose(&PME.pme_Handle);
	}

	return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\fsp_fd.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsp_fd.c

Abstract:

	This module contains the entry points for the AFP file-dir APIs queued to
	the FSP. These are all callable from FSP Only.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FSP_FD

#include <afp.h>
#include <gendisp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <client.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpFspDispGetFileDirParms)
#pragma alloc_text( PAGE, AfpFspDispSetFileDirParms)
#pragma alloc_text( PAGE, AfpFspDispDelete)
#pragma alloc_text( PAGE, AfpFspDispRename)
#pragma alloc_text( PAGE, AfpFspDispMoveAndRename)
#pragma alloc_text( PAGE, AfpFspDispCatSearch)
#endif

/***	AfpFspDispGetFileDirParms
 *
 *	This is the worker routine for the AfpGetFileDirParms API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_ReqBlock	DWORD		File Bitmap
 *	sda_ReqBlock	DWORD		Dir Bitmap
 *	sda_Name1		ANSI_STRING	Path
 */
AFPSTATUS FASTCALL
AfpFspDispGetFileDirParms(
	IN	PSDA	pSda
)
{
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	BOOLEAN			NeedHandle = False;
	PVOLDESC		pVolDesc;
	DWORD			BitmapF, BitmapD, BitmapI = 0;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
		DWORD		_FileBitmap;
		DWORD		_DirBitmap;
	};
	struct _ResponsePacket
	{
		BYTE	__FileBitmap[2];
		BYTE	__DirBitmap[2];
		BYTE	__FileDirFlag;
		BYTE	__Pad;
	};

	PAGED_CODE();

	DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_INFO,
			("AfpFspDispGetFileDirParms: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));
	
	BitmapF = pReqPkt->_FileBitmap;
	BitmapD = pReqPkt->_DirBitmap;

	do
	{
		AfpInitializeFDParms(&FDParm);
		AfpInitializePME(&PME, 0, NULL);
		if (IS_VOLUME_NTFS(pVolDesc) &&
			(BitmapD & (DIR_BITMAP_ACCESSRIGHTS |
					    DIR_BITMAP_OWNERID |
					    DIR_BITMAP_GROUPID)))
		{
			NeedHandle = True;
		}

		if (BitmapD & DIR_BITMAP_ACCESSRIGHTS)
		{
			BitmapI = FD_INTERNAL_BITMAP_OPENACCESS_READCTRL;
		}


		if ((Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
											 pReqPkt->_ParentId,
											 &pSda->sda_Name1,
											 pSda->sda_PathType,
											 DFE_ANY,
											 BitmapF | BitmapD | BitmapI,
											 NeedHandle ? &PME : NULL,
											 &FDParm)) != AFP_ERR_NONE)
		{
			PME.pme_Handle.fsh_FileHandle = NULL;
			break;
		}

		pSda->sda_ReplySize = SIZE_RESPPKT +
					  EVENALIGN(AfpGetFileDirParmsReplyLength(&FDParm,
									IsDir(&FDParm) ? BitmapD : BitmapF));
	
		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
		{
			AfpPackFileDirParms(&FDParm,
								IsDir(&FDParm) ? BitmapD : BitmapF,
								pSda->sda_ReplyBuf + SIZE_RESPPKT);
			PUTDWORD2SHORT(&pRspPkt->__FileBitmap, BitmapF);
			PUTDWORD2SHORT(&pRspPkt->__DirBitmap, BitmapD);
			pRspPkt->__FileDirFlag = IsDir(&FDParm) ?
										FILEDIR_FLAG_DIR : FILEDIR_FLAG_FILE;
			pRspPkt->__Pad = 0;
		}
	} while (False);
	
	// Return before we close thus saving some time
	AfpCompleteApiProcessing(pSda, Status);

	if (NeedHandle && (PME.pme_Handle.fsh_FileHandle != NULL))
		AfpIoClose(&PME.pme_Handle);	// Close the handle to the entity

	return AFP_ERR_EXTENDED;
}



/***	AfpFspDispSetFileDirParms
 *
 *	This is the worker routine for the AfpSetFileDirParms API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_ReqBlock	DWORD		File or Directory Bitmap
 *	sda_Name1		ANSI_STRING	Path
 *	sda_Name2		BLOCK		File or Directory parameters
 */
AFPSTATUS FASTCALL
AfpFspDispSetFileDirParms(
	IN	PSDA	pSda
)
{
	PATHMAPENTITY	PME;
	PVOLDESC		pVolDesc;
	FILEDIRPARM		FDParm;
	DWORD			Bitmap, BitmapI;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	WCHAR			PathBuf[BIG_PATH_LEN];
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
		DWORD		_Bitmap;
	};

	PAGED_CODE();

	DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_INFO,
			("AfpFspDispSetFileDirParms: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));
	
	Bitmap = pReqPkt->_Bitmap;

	// Force the FD_BITMAP_LONGNAME in case a *file* is missing the afpinfo
	// stream we will be able to generate the correct type/creator in
	// AfpSetAfpInfo
	BitmapI = FD_INTERNAL_BITMAP_OPENACCESS_RW_ATTR |
			  FD_BITMAP_LONGNAME |
			  FD_INTERNAL_BITMAP_RETURN_PMEPATHS;

	// For a directory only the owner can change certain attributes like the
	// various inhibit bits. Check for access if an attempt is made to modify
	// any of these bits. We do not know at this point whether any of these
	// attributes are being set/cleared yet !!!
	if (Bitmap & FD_BITMAP_ATTR)
		BitmapI = FD_INTERNAL_BITMAP_OPENACCESS_READCTRL|
				  FD_BITMAP_LONGNAME 					|
				  DIR_BITMAP_OWNERID 					|
				  DIR_BITMAP_GROUPID 					|
				  DIR_BITMAP_ACCESSRIGHTS				|
				  FD_INTERNAL_BITMAP_RETURN_PMEPATHS;

	AfpInitializeFDParms(&FDParm);
	AfpInitializePME(&PME, sizeof(PathBuf), PathBuf);

	do
	{
		Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										pReqPkt->_ParentId,
										&pSda->sda_Name1,
										pSda->sda_PathType,
										DFE_ANY,
										Bitmap | BitmapI,
										&PME,
										&FDParm);

		if (!NT_SUCCESS(Status))
		{
			PME.pme_Handle.fsh_FileHandle = NULL;
			break;
		}

		if ((Status = AfpUnpackFileDirParms(pSda->sda_Name2.Buffer,
										   (LONG)pSda->sda_Name2.Length,
										   &Bitmap,
										   &FDParm)) != AFP_ERR_NONE)
			break;

		if (Bitmap != 0)
		{
			// Make sure they are not trying to set/clear any attributes
			// that are not common to both files and directories
			if ((Bitmap & FD_BITMAP_ATTR) &&
				(FDParm._fdp_Attr & ~(FD_BITMAP_ATTR_SET		|
									  FD_BITMAP_ATTR_INVISIBLE	|
									  FD_BITMAP_ATTR_DELETEINH	|
									  FILE_BITMAP_ATTR_WRITEINH	|
									  FD_BITMAP_ATTR_RENAMEINH	|
									  FD_BITMAP_ATTR_SYSTEM)))
			{
				Status = AFP_ERR_PARAM;
				break;
			}
			Status = AfpSetFileDirParms(pVolDesc,
										&PME,
										Bitmap,
										&FDParm);
		}
	} while (False);
	
	// Return before we close thus saving some time
	AfpCompleteApiProcessing(pSda, Status);

	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	if ((PME.pme_FullPath.Buffer != NULL) &&
		(PME.pme_FullPath.Buffer != PathBuf))
	{
		AfpFreeMemory(PME.pme_FullPath.Buffer);
	}

	return AFP_ERR_EXTENDED;
}



/***	AfpFspDispDelete
 *
 *	This is the worker routine for the AfpDelete API.  Deleting an open file
 *  or a directory that is not empty is not permitted under AFP.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_Name1		ANSI_STRING	Path
 */
AFPSTATUS FASTCALL
AfpFspDispDelete(
	IN	PSDA	pSda
)
{
	PATHMAPENTITY	PME;
	PVOLDESC		pVolDesc;
    PCONNDESC       pConnDesc;
	FILEDIRPARM		FDParm;
	DWORD			Bitmap, NTAttr;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	FILESYSHANDLE	hParent;
	WCHAR			PathBuf[BIG_PATH_LEN];
	BOOLEAN			InRoot;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
	};

	PAGED_CODE();

	DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_INFO,
										("AfpFspDispDelete: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));
    pConnDesc = pReqPkt->_pConnDesc;

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));
	
	AfpInitializeFDParms(&FDParm);
	AfpInitializePME(&PME, sizeof(PathBuf), PathBuf);
	Bitmap = FD_BITMAP_ATTR | FD_INTERNAL_BITMAP_OPENACCESS_DELETE;

	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	do
	{
		hParent.fsh_FileHandle = NULL;
		if (!NT_SUCCESS(Status = AfpMapAfpPath(pReqPkt->_pConnDesc,
											   pReqPkt->_ParentId,
											   &pSda->sda_Name1,
											   pSda->sda_PathType,
											   Lookup,
											   DFE_ANY,
											   Bitmap,
											   &PME,
											   &FDParm)))
		{
			PME.pme_Handle.fsh_FileHandle = NULL;
			break;
		}

		if ((FDParm._fdp_AfpId == AFP_ID_ROOT) ||
			(FDParm._fdp_AfpId == AFP_ID_NETWORK_TRASH))
		{
			Status = AFP_ERR_ACCESS_DENIED;
			break;
		}

		if (FDParm._fdp_Attr & (FILE_BITMAP_ATTR_DATAOPEN | FILE_BITMAP_ATTR_RESCOPEN))
		{
			ASSERT(!(FDParm._fdp_Flags & DFE_FLAGS_DIR));
			Status = AFP_ERR_FILE_BUSY;	// Cannot delete an open file
			break;
		}

		if (!NT_SUCCESS(Status = AfpCheckForInhibit(&PME.pme_Handle,
													FD_BITMAP_ATTR_DELETEINH,
													FDParm._fdp_Attr,
													&NTAttr)))
		{
			break;
		}

		// Check for SeeFiles or SeeFolders on the parent dir
		if (!NT_SUCCESS(Status = AfpCheckParentPermissions(pReqPkt->_pConnDesc,
														   FDParm._fdp_ParentId,
														   &PME.pme_ParentPath,
														   (FDParm._fdp_Flags & DFE_FLAGS_DIR) ?
														   		DIR_ACCESS_SEARCH : DIR_ACCESS_READ,
														   &hParent,
														   NULL)))
		{
			break;
		}

		if (NTAttr & FILE_ATTRIBUTE_READONLY)
		{
			// We must remove the ReadOnly attribute to delete the file/dir
			Status = AfpIoSetTimesnAttr(&PME.pme_Handle,
										NULL,
										NULL,
										0,
										FILE_ATTRIBUTE_READONLY,
										pVolDesc,
										&PME.pme_FullPath);
		}

		if (NT_SUCCESS(Status))
		{
			InRoot = (PME.pme_ParentPath.Length == 0) ? True : False;
			Status = AfpIoMarkFileForDelete(&PME.pme_Handle,
											pVolDesc,
											&PME.pme_FullPath,
											InRoot ? NULL : &PME.pme_ParentPath);

			if (!NT_SUCCESS(Status))
			{
				Status = AfpIoConvertNTStatusToAfpStatus(Status);
			}

			// !!! HACK ALERT !!!
			// At this point we are pretty much done i.e. the delete has either
			// succeeded or failed and we can return doing the rest of the work
			// post-reply. Any errors from now on SHOULD BE IGNORED. Also NO
			// REFERENCE SHOULD BE MADE TO the pSda & pConnDesc. Status should
			// not be changed either. Also reference the Volume for good measure.
			// It cannot fail !!!
			AfpVolumeReference(pVolDesc);

			AfpCompleteApiProcessing(pSda, Status);

			if (NT_SUCCESS(Status)) // Delete succeeded
			{
				ASSERT(VALID_DFE(PME.pme_pDfEntry));
				ASSERT(PME.pme_pDfEntry->dfe_AfpId == FDParm._fdp_AfpId);
				AfpDeleteDfEntry(pVolDesc, PME.pme_pDfEntry);
				AfpIoClose(&PME.pme_Handle);
				AfpCacheParentModTime(pVolDesc,
									  &hParent,
									  NULL,
									  NULL,
									  FDParm._fdp_ParentId);
			}
			else if (NTAttr & FILE_ATTRIBUTE_READONLY) // Delete failed
			{
				// Set the ReadOnly attribute back on the file/dir if need be
				Status = AfpIoSetTimesnAttr(&PME.pme_Handle,
											NULL,
											NULL,
											FILE_ATTRIBUTE_READONLY,
											0,
											pVolDesc,
											&PME.pme_FullPath);
				ASSERT(NT_SUCCESS(Status));
			}
			Status = AFP_ERR_EXTENDED;
		}
		ASSERT (Status == AFP_ERR_EXTENDED);
		AfpVolumeDereference(pVolDesc);
	} while (False);

	// Close file handle so file really gets deleted before mac can come
	// back in with another request using same filename (like create)
	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);
	
	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

	if (hParent.fsh_FileHandle != NULL)
		AfpIoClose(&hParent);

	if ((PME.pme_FullPath.Buffer != NULL) &&
		(PME.pme_FullPath.Buffer != PathBuf))
	{
		AfpFreeMemory(PME.pme_FullPath.Buffer);
	}

	return Status;
}



/***	AfpFspDispRename
 *
 *	This is the worker routine for the AfpRename API.  Renaming a file does
 *  NOT provoke a new Extension-Type/Creator mapping.  Renaming an open file
 *  is permitted under AFP.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_Name1		ANSI_STRING	Path
 *	sda_Name2		ANSI_STRING	New name
 */
AFPSTATUS FASTCALL
AfpFspDispRename(
	IN	PSDA	pSda
)
{
	PATHMAPENTITY	PME;
	PVOLDESC		pVolDesc;
	FILEDIRPARM		FDParm;
	DWORD			Bitmap, NTAttr;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	UNICODE_STRING	uNewName;
	WCHAR			wcbuf[AFP_FILENAME_LEN+1];
	WCHAR			PathBuf[BIG_PATH_LEN];
	PDFENTRY		pDfEntry;
	FILESYSHANDLE 	hParent;
	BOOLEAN			InRoot;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
	};

	PAGED_CODE();

	DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_INFO,
			("AfpFspDispRename: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));
	
	AfpInitializeFDParms(&FDParm);
	AfpInitializePME(&PME, sizeof(PathBuf), PathBuf);
	AfpSetEmptyUnicodeString(&uNewName, sizeof(wcbuf), wcbuf);

	Bitmap = FD_BITMAP_ATTR | FD_INTERNAL_BITMAP_OPENACCESS_DELETE;
	hParent.fsh_FileHandle = NULL;
		
	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	do
	{
		// Make sure the new name is not a null string or too long
		if ((pSda->sda_Name2.Length == 0) ||
			(pSda->sda_Name2.Length > AFP_FILENAME_LEN) ||
			((pSda->sda_PathType == AFP_SHORTNAME) &&
			 !AfpIsLegalShortname(&pSda->sda_Name2)) ||
			(!NT_SUCCESS(AfpConvertStringToMungedUnicode(&pSda->sda_Name2,
														 &uNewName))))
			break;

		if (!NT_SUCCESS(Status = AfpMapAfpPath(pReqPkt->_pConnDesc,
											   pReqPkt->_ParentId,
											   &pSda->sda_Name1,
											   pSda->sda_PathType,
											   Lookup,
											   DFE_ANY,
											   Bitmap,
											   &PME,
											   &FDParm)))
		{
			PME.pme_Handle.fsh_FileHandle = NULL;
			break;
		}

		if ((FDParm._fdp_AfpId == AFP_ID_ROOT) ||
			(FDParm._fdp_AfpId == AFP_ID_NETWORK_TRASH))
		{
			Status = AFP_ERR_CANT_RENAME;
			break;
		}

		// Check if the RO bit is on & retain the mod time
		if (!NT_SUCCESS(Status = AfpCheckForInhibit(&PME.pme_Handle,
													FD_BITMAP_ATTR_RENAMEINH,
													FDParm._fdp_Attr,
													&NTAttr)))
		{
			break;
		}

		// Check for SeeFiles or SeeFolders on the parent dir
		if (!NT_SUCCESS(Status = AfpCheckParentPermissions(pReqPkt->_pConnDesc,
														   FDParm._fdp_ParentId,
														   &PME.pme_ParentPath,
														   (FDParm._fdp_Flags & DFE_FLAGS_DIR) ?
														   DIR_ACCESS_SEARCH : DIR_ACCESS_READ,
														   &hParent,
														   NULL)))
		{
			break;
		}

		if (NTAttr & FILE_ATTRIBUTE_READONLY)
		{
			// We must temporarily remove the ReadOnly attribute so that
			// we can rename the file/dir
			Status = AfpIoSetTimesnAttr(&PME.pme_Handle,
										NULL,
										NULL,
										0,
										FILE_ATTRIBUTE_READONLY,
										pVolDesc,
										&PME.pme_FullPath);
		}

		if (NT_SUCCESS(Status))
		{
			// We must impersonate to do the rename since it is name based
			AfpImpersonateClient(pSda);

			InRoot = (PME.pme_ParentPath.Length == 0) ? True : False;
			Status = AfpIoMoveAndOrRename(&PME.pme_Handle,
										  NULL,
										  &uNewName,
										  pVolDesc,
										  &PME.pme_FullPath,
										  InRoot ? NULL : &PME.pme_ParentPath,
										  NULL,
										  NULL);

			AfpRevertBack();

			if (NT_SUCCESS(Status))	// Rename succeeded
			{
				if ((pDfEntry = AfpFindDfEntryById(pVolDesc,
												   FDParm._fdp_AfpId,
												   DFE_ANY)) != NULL)
				{
					ASSERT(((pDfEntry->dfe_Flags & DFE_FLAGS_DFBITS) &
							FDParm._fdp_Flags) != 0);
					pDfEntry = AfpRenameDfEntry(pVolDesc,
												pDfEntry,
												&uNewName);
					if (pDfEntry == NULL)
					{
						// We could not rename the id entry, so
						// just delete it, and hope the parent dir
						// gets enumerated again
						// NOTE: How will the parent directory
						//	 get re-enumerated now ?
						ASSERT(VALID_DFE(PME.pme_pDfEntry));
						ASSERT(PME.pme_pDfEntry->dfe_AfpId == FDParm._fdp_AfpId);
						AfpDeleteDfEntry(pVolDesc, PME.pme_pDfEntry);
						Status = AFP_ERR_MISC;	// Out of memory
					}
					else
					{
						AfpCacheParentModTime(pVolDesc,
											  &hParent,
											  NULL,
											  pDfEntry->dfe_Parent,
											  0);
					}
				}
			}
		}
		else
		{
			Status = AFP_ERR_MISC;	// Could not delete ReadOnly attribute
			break;
		}

		// Set the ReadOnly attribute back on the file/dir if need be.
		if (NTAttr & FILE_ATTRIBUTE_READONLY)
			AfpIoSetTimesnAttr(&PME.pme_Handle,
								NULL,
								NULL,
								FILE_ATTRIBUTE_READONLY,
								0,
								pVolDesc,
								&PME.pme_FullPath);
	} while (False);

	// Return before we close thus saving some time
	AfpCompleteApiProcessing(pSda, Status);

	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	if (hParent.fsh_FileHandle != NULL)
	{
		AfpIoClose(&hParent);
	}

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

	if ((PME.pme_FullPath.Buffer != NULL) &&
		(PME.pme_FullPath.Buffer != PathBuf))
	{
		AfpFreeMemory(PME.pme_FullPath.Buffer);
	}

	return AFP_ERR_EXTENDED;
}



/***	AfpFspDispMoveAndRename
 *
 *	This is the worker routine for the AfpMoveAndRename API.  Note that
 *  in AFP 2.x, a FILE (not a dir) CAN BE MOVED when its RenameInhibit bit
 *  is set if it is NOT BEING RENAMED.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Source ParentId
 *	sda_ReqBlock	DWORD		Dest ParentId
 *	sda_Name1		ANSI_STRING	Source Path
 *	sda_Name2		ANSI_STRING	Dest Path
 *	sda_Name3		ANSI_STRING	New Name
 */
AFPSTATUS FASTCALL
AfpFspDispMoveAndRename(
	IN	PSDA	pSda
)
{
	PATHMAPENTITY	PMEsrc, PMEdst;
	PVOLDESC		pVolDesc;
	FILEDIRPARM		FDParmsrc, FDParmdst;
	DWORD			Bitmap, NTAttr;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	UNICODE_STRING	uNewName;
	WCHAR			wcbuf[AFP_FILENAME_LEN+1];
	BOOLEAN			Rename = True, Move = True, SrcInRoot, DstInRoot;
	PDFENTRY		pDfesrc, pDfedst, pDfeParentsrc;
	FILESYSHANDLE	hSrcParent;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_SrcParentId;
		DWORD		_DstParentId;
	};

	PAGED_CODE();

	DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_INFO,
										("AfpFspDispMoveAndRename: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));
	
	AfpInitializeFDParms(&FDParmsrc);
	AfpInitializeFDParms(&FDParmdst);
	AfpInitializePME(&PMEsrc, 0, NULL);
	AfpInitializePME(&PMEdst, 0, NULL);

	Bitmap = FD_BITMAP_ATTR | FD_BITMAP_LONGNAME | FD_INTERNAL_BITMAP_OPENACCESS_DELETE;
	AfpSetEmptyUnicodeString(&uNewName, sizeof(wcbuf), wcbuf);
	hSrcParent.fsh_FileHandle = NULL;

	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	do
	{
		// Make sure the new name is not too long
		if ((pSda->sda_Name3.Length > 0) &&
			((pSda->sda_Name3.Length > AFP_FILENAME_LEN) ||
			((pSda->sda_PathType == AFP_SHORTNAME) &&
			 !AfpIsLegalShortname(&pSda->sda_Name3)) ||
			(!NT_SUCCESS(AfpConvertStringToMungedUnicode(&pSda->sda_Name3,
														 &uNewName)))))
			break;

		// Map source path for lookup (could be file or dir).
		// We ask for the finderinfo in case the user is moving an
		// application file to another directory, we can update its
		// parent dirid in the APPL desktop database
		if (!NT_SUCCESS(Status = AfpMapAfpPath(pReqPkt->_pConnDesc,
											   pReqPkt->_SrcParentId,
											   &pSda->sda_Name1,
											   pSda->sda_PathType,
											   Lookup,
											   DFE_ANY,
											   Bitmap | FD_BITMAP_FINDERINFO,
											   &PMEsrc,
											   &FDParmsrc)))
		{
			PMEsrc.pme_Handle.fsh_FileHandle = NULL;
			break;
		}

		// Map the destination parent directory path for lookup
		if (!NT_SUCCESS(Status = AfpMapAfpPath(pReqPkt->_pConnDesc,
											   pReqPkt->_DstParentId,
											   &pSda->sda_Name2,
											   pSda->sda_PathType,
											   Lookup,
											   DFE_DIR,
											   0,
											   &PMEdst,
											   &FDParmdst)))
		{
			PMEdst.pme_Handle.fsh_FileHandle = NULL;
			break;
		}

		if ((FDParmsrc._fdp_AfpId == AFP_ID_ROOT) ||
			(FDParmsrc._fdp_AfpId == AFP_ID_NETWORK_TRASH))
		{
			Status = AFP_ERR_CANT_MOVE;
			break;
		}

		if (!NT_SUCCESS(Status = AfpCheckForInhibit(&PMEsrc.pme_Handle,
													FD_BITMAP_ATTR_RENAMEINH,
													FDParmsrc._fdp_Attr,
													&NTAttr)))
		{
			// Files (not dirs) marked RenameInhibit that are NOT being
			// renamed are allowed to be moved in AFP 2.x
			if (!((Status == AFP_ERR_OBJECT_LOCKED) &&
				 (!IsDir(&FDParmsrc)) &&
				 (pSda->sda_Name3.Length == 0)))
			{
				break;
			}
		}

		if (FDParmsrc._fdp_ParentId == FDParmdst._fdp_AfpId)
		{
			// if the parent directories are the same, we are not
			// moving anything to a new directory, so the change
			// notify we expect will be a rename in the source dir.
			Move = False;

			//
			// Trying to move a file onto itself.  Just return success.
			// (some apps move files onto
			// themselves for who knows what reason)
			//
			if ((pSda->sda_Name3.Length == 0) ||
				 RtlEqualString(&pSda->sda_Name3,
								&FDParmsrc._fdp_LongName,
								False))
			{
				Status = AFP_ERR_NONE;
				break;
			}

		}

		// Check for SeeFiles or SeeFolders on the source parent dir
		if (!NT_SUCCESS(Status = AfpCheckParentPermissions(pReqPkt->_pConnDesc,
														   FDParmsrc._fdp_ParentId,
														   &PMEsrc.pme_ParentPath,
														   (FDParmsrc._fdp_Flags & DFE_FLAGS_DIR) ?
																DIR_ACCESS_SEARCH : DIR_ACCESS_READ,
														   &hSrcParent,
														   NULL)))
		{
			break;
		}

		if (NTAttr & FILE_ATTRIBUTE_READONLY)
		{
			// We must temporarily remove the ReadOnly attribute so that
			// we can move the file/dir
			Status = AfpIoSetTimesnAttr(&PMEsrc.pme_Handle,
										NULL,
										NULL,
										0,
										FILE_ATTRIBUTE_READONLY,
										pVolDesc,
										&PMEsrc.pme_FullPath);
		}

		if (NT_SUCCESS(Status))
		{
			// If no new name was supplied, we need to use the
			// current name
			if (pSda->sda_Name3.Length == 0)
			{
				Rename = False;
				uNewName = PMEsrc.pme_UTail;
			}
			
			// We must impersonate to do the move since it is name based
			AfpImpersonateClient(pSda);

            if (Move)
			{
				// if we are moving, we will also get an ADDED notification
				// for the destination directory.  Since we have the path
				// of the parent dir, but we really want the name of the
				// thing we are about to move and/or rename, munge the
				// destination paths to reflect the new name of the thing
				// we are moving/renaming

				PMEdst.pme_ParentPath = PMEdst.pme_FullPath;
				if (PMEdst.pme_FullPath.Length > 0)
				{
					PMEdst.pme_FullPath.Buffer[PMEdst.pme_FullPath.Length / sizeof(WCHAR)] = L'\\';
					PMEdst.pme_FullPath.Length += sizeof(WCHAR);
				}
				Status = RtlAppendUnicodeStringToString(&PMEdst.pme_FullPath,
														&uNewName);
				ASSERT(NT_SUCCESS(Status));
			}

			SrcInRoot = (PMEsrc.pme_ParentPath.Length == 0) ? True : False;
			DstInRoot = (PMEdst.pme_ParentPath.Length == 0) ? True : False;
			Status = AfpIoMoveAndOrRename(&PMEsrc.pme_Handle,
										  Move ? &PMEdst.pme_Handle : NULL,
										  &uNewName,
										  pVolDesc,
										  &PMEsrc.pme_FullPath,
										  SrcInRoot ? NULL : &PMEsrc.pme_ParentPath,
										  Move ? &PMEdst.pme_FullPath : NULL,
										  (Move && !DstInRoot) ? &PMEdst.pme_ParentPath : NULL);
			AfpRevertBack();

			if (NT_SUCCESS(Status))	// Move succeeded
			{
				if (((pDfesrc = AfpFindDfEntryById(pVolDesc,
												   FDParmsrc._fdp_AfpId,
												   DFE_ANY)) != NULL) &&
					((pDfedst = AfpFindDfEntryById(pVolDesc,
												   FDParmdst._fdp_AfpId,
												   DFE_DIR)) != NULL))

				{
					ASSERT(((pDfesrc->dfe_Flags & DFE_FLAGS_DFBITS) &
							FDParmsrc._fdp_Flags) != 0);
					pDfeParentsrc = pDfesrc->dfe_Parent;
					pDfesrc = AfpMoveDfEntry(pVolDesc,
											 pDfesrc,
											 pDfedst,
											 Rename ? &uNewName : NULL);
					if (pDfesrc == NULL)
					{
						// We could not move the id entry, so
						// just delete it.
						ASSERT(VALID_DFE(PMEsrc.pme_pDfEntry));
						ASSERT(PMEsrc.pme_pDfEntry->dfe_AfpId == FDParmsrc._fdp_AfpId);
						AfpDeleteDfEntry(pVolDesc, PMEsrc.pme_pDfEntry);
						Status = AFP_ERR_MISC;	// Out of memory
					}

					// update cached mod time of source parent directory
					AfpCacheParentModTime(pVolDesc,
										  &hSrcParent,
										  NULL,
										  pDfeParentsrc,
										  0);
					if (Move)
					{
						// update cached mod time of destination directory
						AfpCacheParentModTime(pVolDesc,
											  &PMEdst.pme_Handle,
											  NULL,
											  pDfedst,
											  0);
						//
						// if we just moved an application program, update
						// the parentID in the corresponding APPL mapping.
						//
						if ((!IsDir(&FDParmsrc)) &&
							(FDParmsrc._fdp_FinderInfo.fd_TypeD == *(PDWORD)"APPL"))
						{
							AfpAddAppl(pVolDesc,
									   FDParmsrc._fdp_FinderInfo.fd_CreatorD,
									   0,
									   FDParmsrc._fdp_AfpId,
									   True,
									   FDParmdst._fdp_AfpId);
						}
					}
				}
			}
		}
		else
		{
			Status = AFP_ERR_MISC;	// Could not delete ReadOnly attribute
			break;
		}

		// Set the ReadOnly attribute back on the file/dir if need be
		if (NTAttr & FILE_ATTRIBUTE_READONLY)
			AfpIoSetTimesnAttr(&PMEsrc.pme_Handle,
								NULL,
								NULL,
								FILE_ATTRIBUTE_READONLY,
								0,
								pVolDesc,
								&PMEsrc.pme_FullPath);
	} while (False);

	// Return before we close thus saving some time
	AfpCompleteApiProcessing(pSda, Status);

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

	if (PMEsrc.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PMEsrc.pme_Handle);

	if (PMEdst.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PMEdst.pme_Handle);

	if (hSrcParent.fsh_FileHandle != NULL)
		AfpIoClose(&hSrcParent);

	if (PMEsrc.pme_FullPath.Buffer != NULL)
		AfpFreeMemory(PMEsrc.pme_FullPath.Buffer);

	if (PMEdst.pme_FullPath.Buffer != NULL)
		AfpFreeMemory(PMEdst.pme_FullPath.Buffer);

	return AFP_ERR_EXTENDED;
}


/***	AfpFspDispCatSearch
 *
 *	This is the worker routine for the AfpCatSearch API.
 *
 *	The request packet is represented below
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		RequestedMatches
 *	sda_Name1		ANSI_STRING	Catalog Position - 16 bytes
 *	sda_Name2		ANSI_STRING	Everything else - needs unmarshalling
 *
 *	The reason we could not unmarshall all the parameters is because this
 *  API's parameters do not conform to the common way all the other APIs'
 *  parameters do, and therefore we cannot use the common code and table
 *  structures in afpapi.c.
 */
AFPSTATUS FASTCALL
AfpFspDispCatSearch(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status = AFP_ERR_PARAM;
	PBYTE			pEndOfBuffer;
	USHORT			Flags;
	SHORT			SizeLeft = 0;
	PVOLDESC		pVolDesc;
	DWORD			FileResultBitmap;
	DWORD			DirResultBitmap;
	DWORD			RequestBitmap;
	DWORD			Count;
	BOOLEAN			fPartialName = False, FreeReplyBuf = False;
    FILEDIRPARM		FDPLowerAndValue, FDPUpperAndMask;
	PCATSEARCHSPEC	pSpec1, pSpec2;
	UNICODE_STRING	MatchString;
	WCHAR			strbuf[AFP_LONGNAME_LEN+1];

	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_RequestedMatches;
	};

	// The part of the request buffer that could not be unmarshalled into
	// fields in the Sda because they don't conform to any of the other APIs.
	// These will be unmarshalled here into local variables, the sda_Name2
	// can be cast to this structure for easy access.
	struct _RestOfRawRequest
	{
		USHORT	_FileResultBitmap;
		USHORT	_DirResultBitmap;
		BYTE	_fPartialName;
		BYTE	_Pad1;
		USHORT	_RequestBitmap;
		// Spec1 and Spec2 follow
	};

#define pRawPkt	((struct _RestOfRawRequest *)(pSda->sda_Name2.Buffer))

	struct _ResponsePacket
	{
		 BYTE		__CatPosition[16];
		 BYTE		__FileBitmap[2];
		 BYTE		__DirBitmap[2];
		 BYTE		__ActualCount[4];
	};

	PAGED_CODE();

	DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_INFO,
										("AfpFspDispCatSearch: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	do
	{
		if (pSda->sda_Name2.Length < (sizeof(struct _RestOfRawRequest) +
									  (2 * sizeof(CATSEARCHSPEC))))
		{
			// The request buffer must be at least as big as the rest of the
			// parameters that weren't yet unmarshalled, plus 2 Spec structs
			break;
		}
		
		GETSHORT2DWORD(&FileResultBitmap, &pRawPkt->_FileResultBitmap);
		GETSHORT2DWORD(&DirResultBitmap, &pRawPkt->_DirResultBitmap);
		GETSHORT2DWORD(&RequestBitmap, &pRawPkt->_RequestBitmap);
	
		if ( (pRawPkt->_fPartialName & 0x80) != 0 )
		{
			fPartialName = True;
		}

		//
		// Validate the bitmaps
		//
		if (((FileResultBitmap | DirResultBitmap) == 0) ||
			((FileResultBitmap | DirResultBitmap) & ~FD_VALID_SEARCH_RESULT) ||
			(RequestBitmap == 0))
		{
			Status = AFP_ERR_BITMAP;
			break;
		}

		// make sure CatSearch is enabled: if it's disabled, reject the call
		if (!(pReqPkt->_pConnDesc->cds_pVolDesc->vds_Flags & AFP_VOLUME_SUPPORTS_CATSRCH))
		{
			DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_ERR,
					("AfpFspDispCatSearch: CATSRCH not supported by volume\n"));

			Status = AFP_ERR_CALL_NOT_SUPPORTED;
			break;
		}

		AfpInitializeFDParms(&FDPLowerAndValue);
		AfpInitializeFDParms(&FDPUpperAndMask);

		if (DirResultBitmap == 0)
		{
			FDPLowerAndValue._fdp_Flags = FDPUpperAndMask._fdp_Flags = DFE_FLAGS_FILE_WITH_ID;
			if (RequestBitmap & ~FILE_VALID_SEARCH_CRITERIA)
			{
				Status = AFP_ERR_BITMAP;
				break;
			}
		}
		else if (FileResultBitmap == 0)
		{
			FDPLowerAndValue._fdp_Flags = FDPUpperAndMask._fdp_Flags = DFE_FLAGS_DIR;
			if (RequestBitmap & ~DIR_VALID_SEARCH_CRITERIA)
			{
				Status = AFP_ERR_BITMAP;
				break;
			}
		}
		else
		{
			FDPLowerAndValue._fdp_Flags = FDPUpperAndMask._fdp_Flags = DFE_FLAGS_FILE_WITH_ID | DFE_FLAGS_DIR;
			if (RequestBitmap & ~FD_VALID_SEARCH_CRITERIA)
			{
				Status = AFP_ERR_BITMAP;
				break;
			}
		}

		Flags = ((PCATALOGPOSITION)pSda->sda_Name1.Buffer)->cp_Flags;
		// The caller should not muck with the catalog position at all
		if ((Flags & ~CATFLAGS_VALID) ||
			// Writelock should only be required if we were about to search files
			((Flags & CATFLAGS_WRITELOCK_REQUIRED) && !(Flags & CATFLAGS_SEARCHING_FILES)))
			// NOTE: also should make sure ONLY ONE of the SEARCHING bits is on
			break;

		//
		// Now unpack the search criteria
		//
		MatchString.Length = 0;
		MatchString.MaximumLength = sizeof(strbuf);
		MatchString.Buffer = strbuf;

        Status = AfpUnpackCatSearchSpecs((PBYTE)pSda->sda_Name2.Buffer + sizeof(struct _RestOfRawRequest),
										 (USHORT)(pSda->sda_Name2.Length - sizeof(struct _RestOfRawRequest)),
										 RequestBitmap,
										 &FDPLowerAndValue,
										 &FDPUpperAndMask,
										 &MatchString);
		if (!NT_SUCCESS(Status))
		{
			break;
		}

		//
		// Allocate the reply buffer.  Estimate the required size by using
		// the maximum possible filename length plus potential pad bytes for
		// even alignment of each entry plus the length of the parent dirid.
		//
		pSda->sda_ReplySize = (USHORT)(SIZE_RESPPKT + (pReqPkt->_RequestedMatches *
				((2 * sizeof(BYTE)) + sizeof(DWORD) + sizeof(USHORT) + sizeof(BYTE) + AFP_LONGNAME_LEN + 1)));

		if (pSda->sda_ReplySize > MAX_CATSEARCH_REPLY)
		{
			pSda->sda_ReplySize = MAX_CATSEARCH_REPLY;
		}

        AfpIOAllocBackFillBuffer(pSda);

		if (pSda->sda_ReplyBuf == NULL)
		{
			pSda->sda_ReplySize = 0;
			Status = AFP_ERR_MISC;
			break;
		}

#if DBG
        AfpPutGuardSignature(pSda);
#endif

		FreeReplyBuf = True;

		//
		// Perform the search
		//

		FDPUpperAndMask._fdp_fPartialName = fPartialName;

		Count = pReqPkt->_RequestedMatches;
		Status = AfpCatSearch(pReqPkt->_pConnDesc,
						      (PCATALOGPOSITION)pSda->sda_Name1.Buffer, // CatalogPosition
						      RequestBitmap,
							  FileResultBitmap,
							  DirResultBitmap,
							  &FDPLowerAndValue,
							  &FDPUpperAndMask,
							  &MatchString,
							  &Count,					// IN OUT
							  (SHORT)(pSda->sda_ReplySize - SIZE_RESPPKT),
							  &SizeLeft,
							  pSda->sda_ReplyBuf + SIZE_RESPPKT,
							  (PCATALOGPOSITION)pSda->sda_ReplyBuf);

         if (!NT_SUCCESS(Status) && ((Status != AFP_ERR_EOF) &&
									 (Status != AFP_ERR_CATALOG_CHANGED)))
		 {
			 break;
		 }

		 PUTSHORT2SHORT(&pRspPkt->__FileBitmap, FileResultBitmap);
		 PUTSHORT2SHORT(&pRspPkt->__DirBitmap, DirResultBitmap);
		 PUTDWORD2DWORD(&pRspPkt->__ActualCount, Count);
		 pSda->sda_ReplySize -= SizeLeft;
		 ASSERT(pSda->sda_ReplySize <= MAX_CATSEARCH_REPLY);
		 FreeReplyBuf = False;



	} while (False);

	if (FreeReplyBuf)
	{
        AfpIOFreeBackFillBuffer(pSda);
	}

	return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\fsp_srv.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsp_srv.c

Abstract:

	This module contains the entry points for the AFP server APIs queued to
	the FSP. These are all callable from FSP Only.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FSP_SRV

#include <afp.h>
#include <gendisp.h>
#include <client.h>
#include <scavengr.h>
#include <secutil.h>

LOCAL BOOLEAN
afpGetUserNameAndPwdOrWSName(
	IN	PANSI_STRING	Block,
	IN	BOOLEAN			Password,
	OUT	PUNICODE_STRING	pUserName,
	OUT	PUNICODE_STRING	pDomainName,
	OUT	PVOID			pParm
);


LOCAL BOOLEAN
afpGetNameAndDomain(
	IN	PANSI_STRING	pDomainNUser,
	OUT	PUNICODE_STRING	pUserName,
	OUT	PUNICODE_STRING	pDomainName
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpFspDispLogin)
#pragma alloc_text( PAGE, AfpFspDispLoginCont)
#pragma alloc_text( PAGE, AfpFspDispLogout)
#pragma alloc_text( PAGE, AfpFspDispChangePassword)
#pragma alloc_text( PAGE, AfpFspDispMapName)
#pragma alloc_text( PAGE, AfpFspDispMapId)
#pragma alloc_text( PAGE, AfpFspDispGetUserInfo)
#pragma alloc_text( PAGE, afpGetUserNameAndPwdOrWSName)
#pragma alloc_text( PAGE, afpGetNameAndDomain)
#endif

/***	AfpFspDispLogin
 *
 *	This is the worker routine for the AfpLogin API.
 *
 *	The request packet is represented below.
 *
 *	sda_Name1	ANSI_STRING	AFP Version
 *	sda_Name2	ANSI_STRING	UAM String
 *	sda_Name3	BLOCK		Depends on the UAM used
 *							NO_USER_AUTHENT		Not used
 *							CLEAR_TEXT_AUTHENT	User Name & Password string
 *							CUSTOM_UAM			User Name & Machine Name
 *	Both the ClearText and the Custom UAM case are treated identically
 *	except for validation.
 *
 *	LOCKS:	sda_Lock (SPIN)
 */
AFPSTATUS FASTCALL
AfpFspDispLogin(
	IN	PSDA	pSda
)
{
	LONG			i;
	ANSI_STRING		UserPasswd;
	AFPSTATUS		Status = AFP_ERR_NONE;
    IPADDRESS       IpAddress;

	struct _AppleUamRespPacket
	{
        BYTE    _LogonId[2];
		BYTE	_ChallengeToClient[1];
	};
    struct _AppleUamRespPacket *pAppleUamRespPacket;

	struct _ResponsePacket
	{
		BYTE	_ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
		BYTE	_TranslationTable[1];
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
			("AfpFspDispLogin: Entered\n"));

	UserPasswd.Length = 0;
	UserPasswd.MaximumLength = 0;
	UserPasswd.Buffer = NULL;

	AfpSetEmptyAnsiString(&UserPasswd, 0, NULL);

	do
	{
		// First validate whether the call is allowed at this time. If a user
		// is either already logged on OR if we are awaiting a response after
		// a challenge has already been given, then this goes no further.
		if ((pSda->sda_Flags & SDA_LOGIN_MASK) != SDA_USER_NOT_LOGGEDIN)
		{
			Status = AFP_ERR_MISC;
			break;
		}

		// Validate the AFP Version
		for (i = 0; i < AFP_NUM_VERSIONS; i++)
		{
			if (RtlEqualString(&pSda->sda_Name1, &AfpVersions[i], True))
			{
				pSda->sda_ClientVersion = (BYTE)i;
				break;
			}

		}
		if (i == AFP_NUM_VERSIONS)
		{
			Status = AFP_ERR_BAD_VERSION;
			break;
		}


#if DBG
        if (pSda->sda_Flags & SDA_SESSION_OVER_TCP)
        {
            PTCPCONN    pTcpConn;
            pTcpConn = (PTCPCONN)(pSda->sda_SessHandle);
            IpAddress = pTcpConn->con_DestIpAddr;

	        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
                ("AFP/TCP: Mac client version 2.%d (%d.%d.%d.%d) connected (%lx)\n",
                pTcpConn->con_pSda->sda_ClientVersion,(IpAddress>>24)&0xFF,
                (IpAddress>>16)&0xFF,(IpAddress>>8)&0xFF,IpAddress&0xFF,pTcpConn));
        }
        else if (pSda->sda_ClientVersion >= AFP_VER_22)
        {
	        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
                ("AFP/Appletalk: Mac client version 2.%d connected\n",
                pSda->sda_ClientVersion));
        }
#endif

		// Validate the UAM string
		for (i = 0; i < AFP_NUM_UAMS; i++)
		{
			if (RtlEqualString(&pSda->sda_Name2, &AfpUamStrings[i], True))
			{
				pSda->sda_ClientType = (BYTE)i;
				break;
			}

		}

		if (i == AFP_NUM_UAMS)
		{
	        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("AfpFspDispLogin: unknown UAM, ignoring!\n"));

			Status = AFP_ERR_BAD_UAM;
			break;
		}


		// All seems OK so far. Handle the simple GUEST logon case first.
		pSda->sda_DomainName.Length = 0;
		pSda->sda_DomainName.Buffer = NULL;
		if (pSda->sda_ClientType == SDA_CLIENT_GUEST)
		{
			if (!(AfpServerOptions & AFP_SRVROPT_GUESTLOGONALLOWED))
			{
				Status = AFP_ERR_BAD_UAM;
				break;
			}

            // Lookup the current Guest account name

            if (1)
            {
                ULONG64 	    TempBuffer[16];
                PSID    	    GuestSid;
                ULONG   	    NameSize;
                ULONG           DomainSize;
                UNICODE_STRING  Name;
                SID_NAME_USE    NameUse;
                WCHAR           NameString[UNLEN+1];
                SID_IDENTIFIER_AUTHORITY    NtAuthority =  SECURITY_NT_AUTHORITY;
                NTSTATUS        TempStatus = STATUS_SUCCESS;

                GuestSid    = (PSID)TempBuffer;

                RtlInitializeSid (
                                    GuestSid,
                                    &NtAuthority,
                                    2
                                    );
                *(RtlSubAuthoritySid (GuestSid, 0)) = SECURITY_BUILTIN_DOMAIN_RID;
                *(RtlSubAuthoritySid (GuestSid, 1)) = DOMAIN_USER_RID_GUEST;

                Name.Buffer = NameString;
                Name.Length = sizeof (NameString);
                Name.MaximumLength = Name.Length;

                TempStatus = SecLookupAccountSid (
                                                GuestSid,
                                                &NameSize,
                                                &Name,
                                                &DomainSize,
                                                NULL,
                                                &NameUse
                                                );

                if (TempStatus != STATUS_SUCCESS)
                {
                    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                        ("AfpFspDispLogin: SecLookupAccountSid failed with error %ld\n", 
                        TempStatus));
                    Status = AFP_ERR_MISC;
                    break;
                }


                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("AfpFspDispLogin: SecLookupAccountSid returned GuestName = %Z, Guestname Size = %d\n", 
                     &Name, Name.Length));


                if ((pSda->sda_UserName.Buffer =
                            (PWSTR)AfpAllocNonPagedMemory(Name.Length)) == NULL)
                {
                    Status = AFP_ERR_MISC;
                    break;
                }

			    memcpy ((BYTE *)(pSda->sda_UserName.Buffer), (BYTE *)Name.Buffer,
                        Name.Length);
                pSda->sda_UserName.Length = Name.Length;
                pSda->sda_UserName.MaximumLength = Name.Length;

            }

            // Consider the guest as a cleartext client from this point on
            // with NULL password

            pSda->sda_ClientType = SDA_CLIENT_CLEARTEXT;
			Status = AfpLogonUser(pSda, &UserPasswd);
			break;
		}

		// Take apart the sda_Name3 block. The block looks as follows. We have
		// already eliminated the possibility of a GUEST login.
		//	1.	ClearText/Custom UAM	PASCALSTR - UserName (+DomainName)
		//	2.	ClearText				PASCALSTR - Password
		//		Custom UAM				PASCALSTR - MachineName

		if (pSda->sda_ClientType == SDA_CLIENT_CLEARTEXT)
		{
			if (!(AfpServerOptions & AFP_SRVROPT_CLEARTEXTLOGONALLOWED))
			{
				Status = AFP_ERR_BAD_UAM;
				break;
			}
		}

		if (!afpGetUserNameAndPwdOrWSName(&pSda->sda_Name3,
						(BOOLEAN)(pSda->sda_ClientType == SDA_CLIENT_CLEARTEXT),
						&pSda->sda_UserName,
						&pSda->sda_DomainName,
						(pSda->sda_ClientType == SDA_CLIENT_CLEARTEXT) ?
						(PVOID)&UserPasswd : (PVOID)&pSda->sda_WSName))
		{
            DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                 ("AfpFspDispLogin: afpGetUserNameAndPwdOrWSName failed\n"));

			Status = AFP_ERR_USER_NOT_AUTH;
			break;
		}

		// Attempt to logon user for Cleartext case
		if (pSda->sda_ClientType == SDA_CLIENT_CLEARTEXT)
		{
			// The user password as we have it is potentially padded with nulls
			// if it is less than 8 chars. Get the length right
			UserPasswd.Length = strlen(UserPasswd.Buffer) + 1;
			Status = AfpLogonUser(pSda, &UserPasswd);

			// Free the buffer for the password
			AfpFreeMemory(UserPasswd.Buffer);
			break;
		}
		else
		{
			// Using the custom UAM, ship the challenge token
			pSda->sda_ReplySize = MSV1_0_CHALLENGE_LENGTH;

            // is this MS-UAM client?  if so, need room for translation table
            if ((pSda->sda_ClientType == SDA_CLIENT_MSUAM_V1) ||
                (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V2))
            {
			    pSda->sda_ReplySize += AFP_XLAT_TABLE_SIZE;
            }
            else
            {
			    pSda->sda_ReplySize += sizeof(USHORT);    // space for LogonId
            }

            if (AfpAllocReplyBuf(pSda) != AFP_ERR_NONE)
            {
                DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                     ("AfpFspDispLogin: AfpAllocReplyBuf failed\n"));
				Status = AFP_ERR_USER_NOT_AUTH;
				break;
            }

			if ((pSda->sda_Challenge = AfpGetChallenge()) == NULL)
			{
                DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                     ("AfpFspDispLogin: AfpGetChallenge failed\n"));
				Status = AFP_ERR_USER_NOT_AUTH;
				AfpFreeReplyBuf(pSda, FALSE);
				break;
			}

			Status = AFP_ERR_AUTH_CONTINUE;

            // MS-UAM client?  copy challenge and translation table
            if ((pSda->sda_ClientType == SDA_CLIENT_MSUAM_V1) ||
                (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V2))
            {
			    RtlCopyMemory(pRspPkt->_ChallengeToClient, pSda->sda_Challenge,
												MSV1_0_CHALLENGE_LENGTH);
			    RtlCopyMemory(pRspPkt->_TranslationTable,
						  AfpTranslationTable+AFP_XLAT_TABLE_SIZE,
						  AFP_XLAT_TABLE_SIZE);
            }
            else
            {
                pAppleUamRespPacket = (struct _AppleUamRespPacket *)(pSda->sda_ReplyBuf);


                // copy the LogonId (make one up, using the sda pointer itself!)
                //*(USHORT *)(&pAppleUamRespPacket->_LogonId[0]) = (USHORT)pSda;
                pAppleUamRespPacket->_LogonId[0] = 0;
                pAppleUamRespPacket->_LogonId[1] = 0;

                // copy the challenge
			    RtlCopyMemory(&pAppleUamRespPacket->_ChallengeToClient[0],
                              pSda->sda_Challenge,
							  MSV1_0_CHALLENGE_LENGTH);
            }
		}
	} while (False);

	// Set the SDA in the right state
	if (Status == AFP_ERR_NONE)
	{
		AfpInterlockedSetNClearDword(&pSda->sda_Flags,
									 SDA_USER_LOGGEDIN,
									 SDA_LOGIN_FAILED,
									 &pSda->sda_Lock);
		pSda->sda_WSName.Length = 0;
		pSda->sda_WSName.MaximumLength = 0;
		pSda->sda_WSName.Buffer = NULL;
		if (pSda->sda_tTillKickOff < MAXLONG)
			AfpScavengerScheduleEvent(
						AfpSdaCheckSession,
						(PVOID)((ULONG_PTR)(pSda->sda_SessionId)),
						(pSda->sda_tTillKickOff > SESSION_WARN_TIME) ?
							 (pSda->sda_tTillKickOff - SESSION_WARN_TIME) :
							 SESSION_CHECK_TIME,
						True);
	}
	else if (Status == AFP_ERR_AUTH_CONTINUE)
	{
		// Login is half-way done. Set to receive a FPLoginCont call
		AfpInterlockedSetDword(&pSda->sda_Flags,
								SDA_USER_LOGIN_PARTIAL,
								&pSda->sda_Lock);
	}
	else if (Status == AFP_ERR_PWD_EXPIRED)
	{
		AfpInterlockedSetDword(&pSda->sda_Flags,
								SDA_LOGIN_FAILED,
								&pSda->sda_Lock);
		Status = AFP_ERR_NONE;
	}
	return Status;
}


/***	AfpFspDispLoginCont
 *
 *	This is the worker routine for the AfpLoginCont API.
 *
 *	The request packet is represented below.
 *
 *	sda_Name1		BLOCK		Response to challenge (24 bytes)
 */
AFPSTATUS FASTCALL
AfpFspDispLoginCont(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status = AFP_ERR_NONE;
	ANSI_STRING		Passwd;
    struct _AppleUamReqPkt
    {
        BYTE    _LogonId[2];
		BYTE	_ChallengeResponse[1];
    };
    struct _AppleUamReqPkt *pAppleUamReqPkt;

	struct _RequestPacket
	{
		DWORD	_ChallengeResponse[1];
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
			("AfpFspDispLoginCont: Entered\n"));

	if ((pSda->sda_Flags & SDA_LOGIN_MASK) != SDA_USER_LOGIN_PARTIAL)
	{
		Status = AFP_ERR_USER_NOT_AUTH;
	}

	else
	{
        if ((pSda->sda_ClientType == SDA_CLIENT_MSUAM_V1) ||
            (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V2))
        {
		    Passwd.Length = Passwd.MaximumLength = LM_RESPONSE_LENGTH;
		    Passwd.Buffer = (PBYTE)&pReqPkt->_ChallengeResponse[0];
        }
        else
        {
            pAppleUamReqPkt = (struct _AppleUamReqPkt *)(pSda->sda_ReqBlock);
		    Passwd.Buffer = (PBYTE)&pAppleUamReqPkt->_ChallengeResponse[0];

            if (pSda->sda_ClientType == SDA_CLIENT_RANDNUM)
            {
		        Passwd.Length = Passwd.MaximumLength = RANDNUM_RESP_LEN;
            }
            else
            {
		        Passwd.Length = Passwd.MaximumLength = TWOWAY_RESP_LEN;
            }
        }

		ASSERT (pSda->sda_Challenge != NULL);

		Status = AfpLogonUser(pSda, &Passwd);
		AfpFreeMemory(pSda->sda_Challenge);
		pSda->sda_Challenge = NULL;
	}

	// Set the SDA in the right state
	if (Status == AFP_ERR_NONE)
	{
		AfpInterlockedSetNClearDword(&pSda->sda_Flags,
									 SDA_USER_LOGGEDIN,
									 SDA_USER_LOGIN_PARTIAL,
									 &pSda->sda_Lock);
		if (pSda->sda_tTillKickOff < MAXLONG)
			AfpScavengerScheduleEvent(
						AfpSdaCheckSession,
						(PVOID)((ULONG_PTR)(pSda->sda_SessionId)),
						(pSda->sda_tTillKickOff > SESSION_WARN_TIME) ?
							 (pSda->sda_tTillKickOff - SESSION_WARN_TIME) :
							 SESSION_CHECK_TIME,
						True);
	}

	return Status;
}


/***	AfpFspDispLogout
 *
 *	This is the worker routine for the AfpLogout API.
 *
 *	There is no request packet for this API.
 */
AFPSTATUS FASTCALL
AfpFspDispLogout(
	IN	PSDA	pSda
)
{
	AFP_SESSION_INFO	SessInfo;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
			("AfpFspDispLogout: Entered\n"));

	AfpInterlockedClearDword(&pSda->sda_Flags, SDA_LOGIN_MASK, &pSda->sda_Lock);

	return AFP_ERR_NONE;
}


/***	AfpFspDispChangePassword
 *
 *	This is the worker routine for the AfpChangePassword API.
 *
 *	The request packet is represented below.
 *
 *	sda_AfpSubFunc	BYTE			New password length - UAM
 *	sda_Name1		ANSI_STRING		UAM String
 *	sda_Name2		ANSI_STRING		User Name [and domain]
 *	sda_Name3		BLOCK			Old and New passwords
 *									Format depends on the UAM
 *						ClearText	Old Password (8 bytes, 0 padded)
 *									New Password (8 bytes, 0 padded)
 *						Encrypted	Old Password LM_OWF_PASSWORD (16)
 *									New Password LM_OWF_PASSWORD (16)
 *
 *	All we do here is package the user name, domain name, old and new password
 *	and give it up to user mode to attempt the password change since we cannot
 *	do it in kernel mode.
 */
AFPSTATUS FASTCALL
AfpFspDispChangePassword(
	IN	PSDA	pSda
)
{
	AFPSTATUS			Status;
	PAFP_PASSWORD_DESC	pPwdDesc=NULL;
	ANSI_STRING			NewPwd;
	UNICODE_STRING		UserName;
	UNICODE_STRING		DomainName;
	BYTE				Method;
	struct _ResponsePacket
	{
		BYTE	__ExtendedErrorCode[4];
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
			("AfpFspDispChangePassword: Entered\n"));

	if ((pPwdDesc =
        (PAFP_PASSWORD_DESC)AfpAllocPagedMemory(sizeof(AFP_PASSWORD_DESC))) == NULL)
	{
	    return AFP_ERR_MISC;
	}

	AfpSetEmptyUnicodeString(&DomainName,
							 sizeof(pPwdDesc->DomainName),
							 pPwdDesc->DomainName);
	AfpSetEmptyUnicodeString(&UserName,
							 sizeof(pPwdDesc->UserName),
							 pPwdDesc->UserName);

	do
	{
		Status = AFP_ERR_BAD_UAM;	// Default
		// Validate the UAM string, cannot be 'No User Authent'
		for (Method = CLEAR_TEXT_AUTHENT; Method < AFP_NUM_UAMS; Method++)
		{
			if (RtlEqualString(&pSda->sda_Name1,
							   &AfpUamStrings[Method],
							   True))
			{
				if (pSda->sda_Flags & SDA_USER_LOGGEDIN)
				{
                    // if the client is logged in using TWOWAY_EXCHANGE, the
                    // UAM specified in password change is still RANDNUM_EXCHANGE
                    // so, hack it, so rest of our logic works!
                    //
                    if ((Method == RANDNUM_EXCHANGE) &&
                        (pSda->sda_ClientType == TWOWAY_EXCHANGE))
                    {
                        Method = TWOWAY_EXCHANGE;
                    }

					if (pSda->sda_ClientType == Method)
					{
						Status = AFP_ERR_NONE;
					}
					else
					{
						Status = AFP_ERR_PARAM;
					}
				}
				else
				{
					pSda->sda_ClientType = Method;
					Status = AFP_ERR_NONE;
				}
				break;
			}

		}

		if ((Status != AFP_ERR_NONE) ||
			((Method == CLEAR_TEXT_AUTHENT) &&
				!(AfpServerOptions & AFP_SRVROPT_CLEARTEXTLOGONALLOWED)))
		{
			break;
		}

		Status = AFP_ERR_PARAM;		// Assume failure
		RtlZeroMemory(pPwdDesc, sizeof(AFP_PASSWORD_DESC));

		// Validate and Convert user name to unicode. If the user is already
		// logged in, make sure the user name matches what we already know
		if (!afpGetNameAndDomain(&pSda->sda_Name2,
								 &UserName,
								 &DomainName) ||
			!RtlEqualUnicodeString(&UserName,
								   &pSda->sda_UserName,
								   True)	||
			!RtlEqualUnicodeString(&DomainName,
								   &pSda->sda_DomainName,
								   True))
		{
		    DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_ERR,
				("AfpFspDispChangePassword: afpGetNameAndDomain failed\n"));
				
			break;
		}

		pPwdDesc->AuthentMode = Method;

		if (Method == CLEAR_TEXT_AUTHENT)
		{
			ANSI_STRING			OldPwd;

			// Make sure the old and new passwords are atleast the min. size
			if (pSda->sda_Name3.Length < (2 * sizeof(AFP_MAXPWDSIZE)))
				break;

			// Translate both passwords to host ansi (upper case)
			OldPwd.Buffer = pPwdDesc->OldPassword;
			OldPwd.Length = sizeof(pPwdDesc->OldPassword);
			OldPwd.MaximumLength = sizeof(pPwdDesc->OldPassword);
			RtlCopyMemory(pPwdDesc->OldPassword,
						  pSda->sda_Name3.Buffer,
						  AFP_MAXPWDSIZE);
			if (AfpConvertMacAnsiToHostAnsi(&OldPwd) != AFP_ERR_NONE)
			{
				break;
			}

			NewPwd.Buffer = pPwdDesc->NewPassword;
			NewPwd.Length = sizeof(pPwdDesc->NewPassword);
			NewPwd.MaximumLength = sizeof(pPwdDesc->NewPassword);
			RtlCopyMemory(pPwdDesc->NewPassword,
						  pSda->sda_Name3.Buffer+AFP_MAXPWDSIZE,
						  AFP_MAXPWDSIZE);
			if (AfpConvertMacAnsiToHostAnsi(&NewPwd) != AFP_ERR_NONE)
			{
				break;
			}
		}


        //
        // if this is a client using Apple's native UAM, parms are different!
        //
        else if ((Method == RANDNUM_EXCHANGE) ||
                 (Method == TWOWAY_EXCHANGE))
        {
			// Make sure the old and new passwords are atleast the min. size
			if (pSda->sda_Name3.Length < (2 * MAX_MAC_PWD_LEN))
            {
                ASSERT(0);
				break;
            }

			RtlCopyMemory(pPwdDesc->OldPassword,
						  pSda->sda_Name3.Buffer,
						  MAX_MAC_PWD_LEN);
			RtlCopyMemory(pPwdDesc->NewPassword,
						  pSda->sda_Name3.Buffer + RANDNUM_RESP_LEN,
						  MAX_MAC_PWD_LEN);
        }

        else if (Method == SDA_CLIENT_MSUAM_V1)
		{
			// Make sure the old and new passwords are atleast the min. size
			if (pSda->sda_Name3.Length < (2 * LM_OWF_PASSWORD_LENGTH))
            {
				break;
            }

			pPwdDesc->bPasswordLength = pSda->sda_AfpSubFunc;
			RtlCopyMemory(pPwdDesc->OldPassword,
						  pSda->sda_Name3.Buffer,
						  LM_OWF_PASSWORD_LENGTH);
			RtlCopyMemory(pPwdDesc->NewPassword,
						  pSda->sda_Name3.Buffer + LM_OWF_PASSWORD_LENGTH,
						  LM_OWF_PASSWORD_LENGTH);
		}
        else if (Method == SDA_CLIENT_MSUAM_V2)
        {
            // the data expected here is large (532 bytes) here
            try {

			    RtlCopyMemory(pPwdDesc->OldPassword,
				    		  pSda->sda_Name3.Buffer,
					    	  LM_OWF_PASSWORD_LENGTH);
			    RtlCopyMemory(pPwdDesc->NewPassword,
				    		  pSda->sda_Name3.Buffer + LM_OWF_PASSWORD_LENGTH,
					    	  (SAM_MAX_PASSWORD_LENGTH * 2) + 4);
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                ASSERT(0);
                break;
            }
        }
        else
        {
		    DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_ERR,
				("AfpFspDispChangePassword: unknown method %d\n",Method));
            ASSERT(0);
        }

		Status = AfpChangePassword(pSda, pPwdDesc);

		DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_ERR,
				("AfpFspDispChangePassword: AfpChangePassword returned %lx\n",
				Status));
	} while (False);

	if (NT_SUCCESS(Status))
	{
		// Check if we are here because the login returned password expired.
		// If this is Afp 2.1 chooser, we also need to logon this fella
		if (pSda->sda_Flags & SDA_LOGIN_FAILED)
		{
			AfpInterlockedClearDword(&pSda->sda_Flags,
									  SDA_LOGIN_FAILED,
									  &pSda->sda_Lock);

			// The user password as we have it is potentially padded with nulls
			// if it is less than 8 chars. Get the length right
			NewPwd.Length = strlen(NewPwd.Buffer) + 1;
			Status = AfpLogonUser(pSda, &NewPwd);
			if (Status == AFP_ERR_NONE)
			{
				AfpInterlockedSetDword(&pSda->sda_Flags,
										SDA_USER_LOGGEDIN,
										&pSda->sda_Lock);
				pSda->sda_WSName.Length = 0;
				pSda->sda_WSName.MaximumLength = 0;
				pSda->sda_WSName.Buffer = NULL;
				if (pSda->sda_tTillKickOff < MAXLONG)
					AfpScavengerScheduleEvent(
							AfpSdaCheckSession,
							(PVOID)((ULONG_PTR)(pSda->sda_SessionId)),
							(pSda->sda_tTillKickOff > SESSION_WARN_TIME) ?
								(pSda->sda_tTillKickOff - SESSION_WARN_TIME) :
								SESSION_CHECK_TIME,
						     True);
			}
		}
	}
	else		// Failure - convert to right status code
	{
		if ((pSda->sda_ClientType == SDA_CLIENT_MSUAM_V1) ||
            (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V2))
		{
			if (Status == STATUS_PASSWORD_EXPIRED)
				Status = AFP_ERR_PASSWORD_EXPIRED;
			else if (Status == STATUS_ACCOUNT_DISABLED)
				Status = AFP_ERR_ACCOUNT_DISABLED;
			else if (Status == STATUS_INVALID_LOGON_HOURS)
				Status = AFP_ERR_INVALID_LOGON_HOURS;
			else if (Status == STATUS_INVALID_WORKSTATION)
				Status = AFP_ERR_INVALID_WORKSTATION;
			else if (Status == STATUS_PASSWORD_RESTRICTION)
				Status = AFP_ERR_PASSWORD_RESTRICTED;
			else if (Status == STATUS_PWD_TOO_SHORT)
				Status = AFP_ERR_PASSWORD_TOO_SHORT;
			else if (Status == STATUS_ACCOUNT_RESTRICTION)
				Status = AFP_ERR_ACCOUNT_RESTRICTED;
			else if (Status == STATUS_ACCESS_DENIED)
				Status = AFP_ERR_PASSWORD_CANT_CHANGE;
			else if ((Status != AFP_ERR_BAD_UAM) &&
					 (Status != AFP_ERR_PARAM))
				Status = AFP_ERR_MISC;
		}
		else
		{
			if (Status == STATUS_WRONG_PASSWORD)
				Status = AFP_ERR_USER_NOT_AUTH;

			else if ((Status == STATUS_PASSWORD_RESTRICTION) ||
					 (Status == STATUS_ACCOUNT_DISABLED))
				Status = AFP_ERR_ACCESS_DENIED;

			else if (Status == STATUS_PWD_TOO_SHORT)
			{
				if ((pSda->sda_Flags & SDA_USER_LOGGEDIN) &&
					(pSda->sda_ClientVersion >= AFP_VER_21))
				{
					Status = AFP_ERR_PWD_TOO_SHORT;
				}
				else
					Status = AFP_ERR_ACCESS_DENIED;
			}

			else if ((Status == STATUS_NONE_MAPPED) ||
					 (Status == STATUS_NO_SUCH_USER))
				Status = AFP_ERR_PARAM;
			else if ((Status != AFP_ERR_BAD_UAM) &&
					 (Status != AFP_ERR_PARAM))
				Status = AFP_ERR_MISC;
		}
	}

    if (pPwdDesc)
    {
        AfpFreeMemory(pPwdDesc);
    }

	return Status;
}


/***	AfpFspDispMapName
 *
 *	This is the worker routine for the AfpMapName API.
 *
 *	The request packet is represented below.
 *
 *	sda_SubFunc	BYTE		User/Group Flag
 *	sda_Name1	ANSI_STRING	Name of user/group
 */
AFPSTATUS FASTCALL
AfpFspDispMapName(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status = AFP_ERR_NONE;
	UNICODE_STRING	Us;
	DWORD			UserOrGroupId = 0;
	struct _ResponsePacket
	{
		BYTE	__UserOrGroupId[4];
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
			("AfpFspDispMapName: Entered\n"));

	if ((pSda->sda_AfpSubFunc != MAP_USER_NAME) &&
		(pSda->sda_AfpSubFunc != MAP_GROUP_NAME))
		return AFP_ERR_PARAM;

	AfpSetEmptyUnicodeString(&Us, 0, NULL);
	// If this is the first time we are asking for the name to be translated.
	if ((pSda->sda_Name1.Length != 0) &&
		(pSda->sda_SecUtilSid == NULL) &&
		(NT_SUCCESS(pSda->sda_SecUtilResult)))
	{
		Us.MaximumLength = (pSda->sda_Name1.Length + 1) * sizeof(WCHAR);
		if ((Us.Buffer = (LPWSTR)AfpAllocPagedMemory(Us.MaximumLength)) == NULL)
		{
			return AFP_ERR_MISC;
		}

		if (!NT_SUCCESS(Status = AfpConvertStringToUnicode(&pSda->sda_Name1, &Us)))
		{
			AfpFreeMemory(Us.Buffer);
			return AFP_ERR_MISC;
		}

		Status = AfpNameToSid( pSda, &Us );

		AfpFreeMemory(Us.Buffer);

		if (!NT_SUCCESS(Status))
		{
			if (Status != AFP_ERR_EXTENDED)
				Status = AFP_ERR_MISC;
		}

		return Status;
	}

	// If we have successfully translated the name
	if (pSda->sda_Name1.Length != 0)
	{
		if ((pSda->sda_SecUtilSid != NULL) &&
			(NT_SUCCESS( pSda->sda_SecUtilResult)))
			Status = AfpSidToMacId(pSda->sda_SecUtilSid, &UserOrGroupId);
		else Status = AFP_ERR_ITEM_NOT_FOUND;
	}

	if (NT_SUCCESS(Status))
	{
		pSda->sda_ReplySize = SIZE_RESPPKT;
		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
		{
			PUTDWORD2DWORD(pRspPkt->__UserOrGroupId, UserOrGroupId);
		}
	}

	if (pSda->sda_SecUtilSid != NULL)
	{
		AfpFreeMemory(pSda->sda_SecUtilSid);
		pSda->sda_SecUtilSid = NULL;
	}

	return Status;
}


/***	AfpFspDispMapId
 *
 *	This is the worker routine for the AfpMapId API.
 *
 *	The request packet is represented below.
 *
 *	sda_SubFunc		BYTE	User/Group Flag
 *	sda_ReqBlock	DWORD	UserId
 *
 *	We do not use the UserId field since it is invalid anyway !!
 */
AFPSTATUS FASTCALL
AfpFspDispMapId(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status = AFP_ERR_NONE;
	 PAFP_SID_NAME	pSidName = NULL;
	PSID			pSid;			// Sid of user or group
	struct _RequestPacket
	{
		DWORD	_UserOrGroupId;
	};
	struct _ResponsePacket
	{
		BYTE	__NameLength[1];
		BYTE	__Name[1];
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
			("AfpFspDispMapId: Entered\n"));

	if ((pSda->sda_AfpSubFunc != MAP_USER_ID) &&
		(pSda->sda_AfpSubFunc != MAP_GROUP_ID))
		return AFP_ERR_PARAM;

	Status = AFP_ERR_ITEM_NOT_FOUND;	// Assume failure

	if (NT_SUCCESS(pSda->sda_SecUtilResult)) do
	{
		ANSI_STRING	As;

		As.Length = 0;
		As.MaximumLength = 1;
		As.Buffer = "";

		if (pReqPkt->_UserOrGroupId != 0)
		{
			Status = AfpMacIdToSid(pReqPkt->_UserOrGroupId, &pSid);
			if (!NT_SUCCESS(Status))
			{
				Status = AFP_ERR_ITEM_NOT_FOUND;
				break;
			}

			Status = AfpSidToName(pSda, pSid, &pSidName);

			if (!NT_SUCCESS(Status))
			{
				if (Status != AFP_ERR_EXTENDED)
					Status = AFP_ERR_MISC;
				break;
			}

/* MSKK hideyukn, Unicode char length not eqaul to ansi byte length in DBCS, 08/07/95 */
#ifdef DBCS
			pSda->sda_ReplySize = pSidName->Name.Length + SIZE_RESPPKT;
#else
			pSda->sda_ReplySize = pSidName->Name.Length/sizeof(WCHAR) + SIZE_RESPPKT;
#endif // DBCS
		}
		else pSda->sda_ReplySize = SIZE_RESPPKT;		// For an id of 0

		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
		{
			if (pSidName != NULL)
			{
				As.MaximumLength = pSda->sda_ReplySize - 1;
				As.Buffer = pRspPkt->__Name;
				if ((Status = AfpConvertStringToAnsi(&pSidName->Name, &As)) != AFP_ERR_NONE)
				{
					AfpFreeReplyBuf(pSda, FALSE);
				}
				PUTBYTE2BYTE(pRspPkt->__NameLength, As.Length);
			}
			else PUTBYTE2BYTE(pRspPkt->__NameLength, 0);
		}
	} while (False);

	return Status;
}


/***	AfpFspDispGetUserInfo
 *
 *	This routine implements the AfpGetUserInfo API.
 *
 *	The request packet is represented below.
 *
 *	sda_AfpSubFunc	BYTE	ThisUser flag
 *	sda_ReqBlock	DWORD	UserId
 *	sda_ReqBlock	DWORD	Bitmap
 *
 *	We do not use the UserId field since it is invalid anyway !!
 */
AFPSTATUS FASTCALL
AfpFspDispGetUserInfo(
	IN	PSDA	pSda
)
{
	DWORD		Bitmap;
	PBYTE		pTemp;
	AFPSTATUS	Status = AFP_ERR_PARAM;
	DWORD		Uid, Gid;
	struct _RequestPacket
	{
		DWORD	_UserId;
		DWORD	_Bitmap;
	};
	struct _ResponsePacket
	{
		BYTE	__Bitmap[2];
		BYTE	__Id1[4];
		BYTE	__Id2[4];
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_INFO,
			("AfpFspDispGetUserInfo: Entered\n"));

	do
	{
		if (!(pSda->sda_AfpSubFunc & USERINFO_THISUSER))
			break;

		Bitmap =  pReqPkt->_Bitmap;
		if (Bitmap & ~(USERINFO_BITMAP_USERID | USERINFO_BITMAP_PRIGID))
		{
			Status = AFP_ERR_BITMAP;
			break;
		}

		if (Bitmap & USERINFO_BITMAP_USERID)
		{
			if (!NT_SUCCESS(Status = AfpSidToMacId(pSda->sda_UserSid, &Uid)))
			{
				Status = AFP_ERR_MISC;
				break;
			}
		}

		if (Bitmap & USERINFO_BITMAP_PRIGID)
		{
			if (!NT_SUCCESS(Status = AfpSidToMacId(pSda->sda_GroupSid, &Gid)))
			{
				Status = AFP_ERR_MISC;
				break;
			}
		}

		pSda->sda_ReplySize = SIZE_RESPPKT;
		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
		{
			PUTSHORT2SHORT(pRspPkt->__Bitmap, Bitmap);
			pTemp = pRspPkt->__Id1;
			if (Bitmap & USERINFO_BITMAP_USERID)
			{
				PUTDWORD2DWORD(pTemp, Uid);
				pTemp = pRspPkt->__Id2;
			}
			else pSda->sda_ReplySize -= sizeof(DWORD);

			if (Bitmap & USERINFO_BITMAP_PRIGID)
			{
				PUTDWORD2DWORD(pTemp, Gid);
			}
			else pSda->sda_ReplySize -= sizeof(DWORD);
		}
	} while (False);
	return Status;
}


/***	afpGetUserNameAndPwdOrWSName
 *
 *	Unmarshall the block containing UserName and either password or WS Name
 *	into unicode/ansi strings. Allocate memory for the output strings.
 *
 *	The layout of the Buffer is as follows:
 *	User Name and an optional pad
 *	Workstation name or user password depending on the UAM.
 *
 *	The optional pad is not directly determined since this buffer has been
 *	copied and we do not know at this point whether this started at an odd
 *	or an even boundary. We get to it indirectly from the size.
 */
LOCAL BOOLEAN
afpGetUserNameAndPwdOrWSName(
	IN	PANSI_STRING	Block,
    IN  BYTE            ClientType,
	OUT	PUNICODE_STRING	pUserName,
	OUT	PUNICODE_STRING	pDomainName,
	OUT	PVOID			pParm			// Either password or WSName
)
{
	ANSI_STRING		UserName;
#define	pPwd	((PANSI_STRING)pParm)
#define	pWS		((PUNICODE_STRING)pParm)
	PBYTE			pTmp;
	BOOLEAN			RetCode = False;

	PAGED_CODE( );

	do
	{
		pPwd->Buffer = NULL;
		pPwd->Length = 0;
		pUserName->Buffer = NULL;

        if (Block->Buffer == NULL)
        {
            ASSERT(0);
            return(False);
        }

		pTmp = Block->Buffer;
		UserName.Length = (USHORT)*pTmp;
		UserName.Buffer = ++pTmp;

		// Sanity check
		if ((USHORT)(UserName.Length + 1) > Block->Length)
			break;

		pTmp += UserName.Length;

        // make sure we are within bounds!
        if (pTmp <= (Block->Buffer + Block->Length))
        {
		    // If there is a NULL pad, go past it.
		    if (*pTmp == '\0')
			    pTmp++;
        }

		pUserName->Buffer = NULL;	// Force allocation
		pDomainName->Buffer = NULL;	// Force allocation
		if (!afpGetNameAndDomain(&UserName, pUserName, pDomainName))
			break;

		// Make sure we do not have a name of the form "DOMAIN\" i.e. a
		// valid domain name and a NULL user name, disallow that explicitly
		// so that we don't logon such users with a NULL session
		if (pUserName->Length == 0)
		{
			if (pUserName->Buffer != NULL)
			{
				AfpFreeMemory(pUserName->Buffer);
				pUserName->Buffer = NULL;
			}
			if (pDomainName->Buffer != NULL)
			{
				AfpFreeMemory(pDomainName->Buffer);
				pDomainName->Buffer = NULL;
			}
			return False;
		}

		// The balance of the buffer is the block, if it is a password. Else
		// it is the machine name string which is a PASCALSTR.
		pPwd->MaximumLength = (USHORT)(Block->Length - (pTmp - Block->Buffer) + 1);
		if (ClientType != SDA_CLIENT_CLEARTEXT)
		{
            // in case of Apple UAM (scrambled or 2-way), machine name won't
            // be present, so check only for MS-UAM
            //
		    if ((ClientType == SDA_CLIENT_MSUAM_V1) ||
                (ClientType == SDA_CLIENT_MSUAM_V2))
            {
			    pWS->MaximumLength = (USHORT)((*pTmp + 1) * sizeof(WCHAR));

			    if (pWS->MaximumLength < (USHORT)((Block->Length -
								(pTmp - Block->Buffer + 1)) *sizeof(WCHAR)))
                {
				    return False;
                }
            }
            else
            {
			    pWS->MaximumLength = ((sizeof(AFP_DEFAULT_WORKSTATION_A) + 1) *
                                     sizeof(WCHAR));
            }
		}

		if ((pPwd->Buffer = AfpAllocNonPagedMemory(pPwd->MaximumLength)) == NULL)
			break;

		if (ClientType == SDA_CLIENT_CLEARTEXT)
		{
			// We are dealing with a clear text password
            pPwd->Length = pPwd->MaximumLength - 1;
			RtlCopyMemory(pPwd->Buffer, pTmp, pPwd->Length);
			if (AfpConvertMacAnsiToHostAnsi(pPwd) != AFP_ERR_NONE)
				break;
			pPwd->Buffer[pPwd->Length] = 0;
		}
		else
		{
			ANSI_STRING	AS;

            if ((ClientType == SDA_CLIENT_MSUAM_V1) ||
                (ClientType == SDA_CLIENT_MSUAM_V2))
            {
			    AS.Buffer = ++pTmp;
			    AS.MaximumLength = pWS->MaximumLength/sizeof(WCHAR);
			    AS.Length = AS.MaximumLength - 1;
            }
            //
            // for scrambled and 2-way exchange, use default wksta name since
            // we don't know what it is
            //
            else
            {
			    AS.Buffer = AFP_DEFAULT_WORKSTATION_A;
			    AS.MaximumLength = pWS->MaximumLength/sizeof(WCHAR);
			    AS.Length = AS.MaximumLength - 1;
            }

			// We have potentially a workstation name here. Since this is a
			// pascal string, adjust the length etc.
			AfpConvertStringToUnicode(&AS, pWS);
			pWS->Buffer[pWS->Length/sizeof(WCHAR)] = L'\0';
		}

		RetCode = True;
	} while (False);

	if (!RetCode)
	{
		if (pUserName->Buffer != NULL)
        {
			AfpFreeMemory(pUserName->Buffer);
            pUserName->Buffer = NULL;
        }
		if (pPwd->Buffer != NULL)
        {
			AfpFreeMemory(pPwd->Buffer);
            pPwd->Buffer = NULL;
        }
		if (pDomainName->Buffer != NULL)
        {
			AfpFreeMemory(pDomainName->Buffer);
            pDomainName->Buffer = NULL;
        }
	}

	return RetCode;
}



/***	afpGetNameAndDomain
 *
 *	Extract the name and domain from a string formed as DOMAIN\NAME.
 */
BOOLEAN
afpGetNameAndDomain(
	IN	PANSI_STRING	pDomainNUser,
	OUT	PUNICODE_STRING	pUserName,
	OUT	PUNICODE_STRING	pDomainName
)
{
	BYTE			c;
	ANSI_STRING		User, Domain;
    BOOLEAN         fDomainBuffAlloc=FALSE;

	// Check if the user name has a '\' character in it. If it does,
	// seperate the domain name from user name. The Username string is
	// not ASCIIZ. Before we search for a '\', make it ASCIIZ w/o trashing
	// whatever is there.

	PAGED_CODE( );

	User.Buffer = AfpStrChr(pDomainNUser->Buffer, pDomainNUser->Length, '\\');

	if (User.Buffer != NULL)
	{
		(User.Buffer) ++;			// Past the '\'
		Domain.Buffer = pDomainNUser->Buffer;

		Domain.Length = (USHORT)(User.Buffer - Domain.Buffer - 1);
		User.Length = pDomainNUser->Length - Domain.Length - 1;

        if (Domain.Length > DNLEN)
        {
	        DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_ERR,
			    ("afpGetNameAndDomain: domain name too long (%d vs. max %d): rejecting\n",
                Domain.Length, DNLEN));
            return(False);
        }

		Domain.MaximumLength = Domain.Length + 1;
		pDomainName->MaximumLength = Domain.MaximumLength * sizeof(WCHAR);

		if (pDomainName->Buffer == NULL)
        {
		    if ((pDomainName->Buffer =
				(PWSTR)AfpAllocNonPagedMemory(pDomainName->MaximumLength)) == NULL)
            {
			    return False;
            }
            fDomainBuffAlloc = TRUE;
        }
		AfpConvertStringToUnicode(&Domain, pDomainName);
	}
	else User = *pDomainNUser;

    if (User.Length > LM20_UNLEN)
    {
	    DBGPRINT(DBG_COMP_AFPAPI_SRV, DBG_LEVEL_ERR,
			("afpGetNameAndDomain: user name too long (%d vs. max %d): rejecting\n",
            User.Length,LM20_UNLEN));
        return(False);
    }

	User.MaximumLength = User.Length + 1;
	pUserName->MaximumLength = User.MaximumLength * sizeof(WCHAR);

	if ((pUserName->Buffer == NULL) &&
		(pUserName->Buffer =
			(PWSTR)AfpAllocNonPagedMemory(pUserName->MaximumLength)) == NULL)
    {
        if (fDomainBuffAlloc)
        {
            AfpFreeMemory(pDomainName->Buffer);
            pDomainName->Buffer = NULL;
        }
		return False;
    }

	AfpConvertStringToUnicode(&User, pUserName);

	return True;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\fsp_vol.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsp_vol.c

Abstract:

	This module contains the entry points for the AFP volume APIs. The API
	dispatcher calls these. These are all callable from FSP.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	10 Dec 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FSP_VOL

#include <afp.h>
#include <gendisp.h>


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpFspDispOpenVol)
#endif

/***	AfpFspDispOpenVol
 *
 *	This routine implements the AfpOpenVol API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	DWORD		Bitmap
 *	sda_Name1		ANSI_STRING	VolName
 *	sda_Name2		ANSI_STRING	VolPassword		OPTIONAL
 */
AFPSTATUS FASTCALL
AfpFspDispOpenVol(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status;
	struct _RequestPacket
	{
		DWORD	_Bitmap;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_VOL, DBG_LEVEL_INFO,
										("AfpFspDispOpenVol: Entered\n"));

	ASSERT (pSda->sda_ReplyBuf != NULL);

	if ((Status = AfpConnectionOpen(pSda, &pSda->sda_Name1, &pSda->sda_Name2,
						pReqPkt->_Bitmap, pSda->sda_ReplyBuf)) != AFP_ERR_NONE)
	{
		AfpFreeReplyBuf(pSda, FALSE);
	}
	return Status;
}


/***	AfpFspDispGetVolParms
 *
 *	This routine implements the AfpGetVolParms API, at task level.  We need to
 *  come to this routine if DiskQuota is enabled on the volume because we have
 *  to be at task level to query quota info
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	DWORD		VolId
 *	sda_ReqBlock	DWORD		Bitmap
 */
AFPSTATUS FASTCALL
AfpFspDispGetVolParms(
	IN	PSDA	pSda
)
{
	AFPSTATUS	Status = AFP_ERR_PARAM;
    PVOLDESC    pVolDesc;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_Bitmap;
	};


	DBGPRINT(DBG_COMP_AFPAPI_VOL, DBG_LEVEL_INFO,
			("AfpFspDispGetVolParms: Entered\n"));

	ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

    pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

    ASSERT(pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED);

	pSda->sda_ReplySize = AfpVolumeGetParmsReplyLength(
                                pReqPkt->_Bitmap,
							    pVolDesc->vds_MacName.Length);


	if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
	{
        if (AfpConnectionReferenceByPointer(pReqPkt->_pConnDesc) != NULL)
        {
            afpUpdateDiskQuotaInfo(pReqPkt->_pConnDesc);
        }

		AfpVolumePackParms(pSda, pVolDesc, pReqPkt->_Bitmap, pSda->sda_ReplyBuf);
	}

	return Status;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\fsp_fork.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsp_fork.c

Abstract:

	This module contains the entry points for the AFP fork APIs queued to
	the FSP. These are all callable from FSP Only.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_FSP_FORK

#include <afp.h>
#include <gendisp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <forkio.h>

#ifdef ALLOC_PRAGMA
// #pragma alloc_text( PAGE, AfpFspDispOpenFork)		// Do not page this out for perf.
// #pragma alloc_text( PAGE, AfpFspDispCloseFork)		// Do not page this out for perf.
#pragma alloc_text( PAGE, AfpFspDispGetForkParms)
#pragma alloc_text( PAGE, AfpFspDispSetForkParms)
// #pragma alloc_text( PAGE, AfpFspDispRead)			// Do not page this out for perf.
// #pragma alloc_text( PAGE, AfpFspDispWrite)           // Do not page this out for perf.
#pragma alloc_text( PAGE, AfpFspDispByteRangeLock)
#pragma alloc_text( PAGE, AfpFspDispFlushFork)
#endif

/***	AfpFspDispOpenFork
 *
 *	This is the worker routine for the AfpOpenFork API.
 *
 *	The request packet is represented below.
 *
 *	sda_AfpSubFunc	BYTE		Resource/Data Flag
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentDirId
 *	sda_ReqBlock	DWORD		Bitmap
 *	sda_ReqBlock	DWORD		AccessMode
 *	sda_Name1		ANSI_STRING	Path
 */
AFPSTATUS FASTCALL
AfpFspDispOpenFork(
	IN	PSDA	pSda
)
{
	DWORD			Bitmap, BitmapI;
	AFPSTATUS		RetCode = AFP_ERR_NONE, Status = AFP_ERR_PARAM;
	FILEDIRPARM		FDParm;
	PVOLDESC		pVolDesc;
	PATHMAPENTITY	PME;
	PCONNDESC		pConnDesc;
	POPENFORKENTRY	pOpenForkEntry = NULL;
	BOOLEAN			Resource, CleanupLock = False;
	BYTE			OpenMode = 0;
	UNICODE_STRING	ParentPath;
	struct _RequestPacket
	{
		 PCONNDESC	_pConnDesc;
		 DWORD		_ParentDirId;
		 DWORD		_Bitmap;
		 DWORD		_AccessMode;
	};
	struct _ResponsePacket
	{
		BYTE		__Bitmap[2];
		BYTE		__OForkRefNum[2];
	};
#if DBG
	static PBYTE	OpenDeny[] = { "None", "Read", "Write", "ReadWrite" };
#endif

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispOpenFork: Entered - Session %ld\n", pSda->sda_SessionId));

	pConnDesc = pReqPkt->_pConnDesc;

	ASSERT(VALID_CONNDESC(pConnDesc));

	pVolDesc = pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));

	Bitmap = pReqPkt->_Bitmap;

	Resource = ((pSda->sda_AfpSubFunc & FORK_RSRC) == FORK_RSRC) ? True : False;

	if ((Resource && (Bitmap & FILE_BITMAP_DATALEN))  ||
		(!Resource && (Bitmap & FILE_BITMAP_RESCLEN)))
	{
		return AFP_ERR_BITMAP;
	}

	do
	{
		AfpInitializeFDParms(&FDParm);
		AfpInitializePME(&PME, 0, NULL);

		// We will use the PME.pme_Handle for open fork handle
		OpenMode = (BYTE)(pReqPkt->_AccessMode & FORK_OPEN_MASK);

		// Validate volume type and open modes
		if (!IS_CONN_NTFS(pConnDesc) && !IS_CONN_CD_HFS(pConnDesc))
		{
			// Resource fork only supported on NTFS and CD-HFS
			if (Resource)
			{
				Status = AFP_ERR_OBJECT_NOT_FOUND;
				break;
			}
			if (OpenMode & FORK_OPEN_WRITE)
			{
				Status = AFP_ERR_VOLUME_LOCKED;
				break;
			}
		}
		else if ((OpenMode & FORK_OPEN_WRITE) && IS_VOLUME_RO(pVolDesc))
		{
			Status = AFP_ERR_VOLUME_LOCKED;
			break;
		}

		BitmapI = FILE_BITMAP_FILENUM		|
				  FD_BITMAP_PARENT_DIRID	|
				  FD_INTERNAL_BITMAP_RETURN_PMEPATHS;

		// Encode the open access into the bitmap for pathmap
		// to use when opening the fork.
		if (Resource)
		{
			BitmapI |= FD_INTERNAL_BITMAP_OPENFORK_RESC;
		}
		if (OpenMode & FORK_OPEN_READ)
		{
			BitmapI |= FD_INTERNAL_BITMAP_OPENACCESS_READ;
		}
		if (OpenMode & FORK_OPEN_WRITE)
		{
			BitmapI |= FD_INTERNAL_BITMAP_OPENACCESS_WRITE;
		}

		// Encode the deny mode into the bitmap for pathmap
		// to use when opening the fork.
		BitmapI |= ((pReqPkt->_AccessMode >> FORK_DENY_SHIFT) &
					FORK_DENY_MASK) <<
					FD_INTERNAL_BITMAP_DENYMODE_SHIFT;

		DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
				("AfpFspDispOpenFork: OpenMode %s, DenyMode %s\n",
				OpenDeny[(pReqPkt->_AccessMode & FORK_OPEN_MASK)],
				OpenDeny[(pReqPkt->_AccessMode >> FORK_DENY_SHIFT) & FORK_DENY_MASK]));

		//
		// Don't allow an FpExchangeFiles to occur while we are referencing
		// the DFE FileId -- we want to make sure we put the right ID into
		// the OpenForkDesc!!
		//
		AfpSwmrAcquireExclusive(&pVolDesc->vds_ExchangeFilesLock);
		CleanupLock = True;
		if ((Status = AfpMapAfpPathForLookup(pConnDesc,
											 pReqPkt->_ParentDirId,
											 &pSda->sda_Name1,
											 pSda->sda_PathType,
											 DFE_FILE,
											 Bitmap | BitmapI |
											 // Need these for drop folder
											 // checking
											 FILE_BITMAP_DATALEN | FILE_BITMAP_RESCLEN,
											 &PME,
											 &FDParm)) != AFP_ERR_NONE)
		{
			DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
				("AfpFspDispOpenFork: AfpMapAfpPathForLookup %lx\n", Status));

			// If we got a DENY_CONFLICT error, then we still need the parameters
			// Do an open for nothing with no deny modes to get the parameters.
			PME.pme_Handle.fsh_FileHandle = NULL;
			if (Status == AFP_ERR_DENY_CONFLICT)
			{
				AFPSTATUS	xxStatus;

				// Free up any path-buffer allocated
				if (PME.pme_FullPath.Buffer != NULL)
				{
					DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
							("AfpFspDispOpenFork: (DenyConflict) Freeing path buffer %lx\n",
							PME.pme_FullPath.Buffer));
					AfpFreeMemory(PME.pme_FullPath.Buffer);
				}
				AfpInitializePME(&PME, 0, NULL);

				BitmapI = FILE_BITMAP_FILENUM		|
							FD_BITMAP_PARENT_DIRID	|
							FD_INTERNAL_BITMAP_RETURN_PMEPATHS;
				if (Resource)
				{
					BitmapI |= FD_INTERNAL_BITMAP_OPENFORK_RESC;
				}
				xxStatus = AfpMapAfpPathForLookup(pConnDesc,
												 pReqPkt->_ParentDirId,
												 &pSda->sda_Name1,
												 pSda->sda_PathType,
												 DFE_FILE,
												 Bitmap | BitmapI,
												 &PME,
												 &FDParm);
				if (!NT_SUCCESS(xxStatus))
				{
					PME.pme_Handle.fsh_FileHandle = NULL;
					Status = xxStatus;
					break;
				}
			}
			else break;
		}

		if (Status == AFP_ERR_NONE)
		{
			Status = AfpForkOpen(pSda,
								 pConnDesc,
								 &PME,
								 &FDParm,
								 pReqPkt->_AccessMode,
								 Resource,
								 &pOpenForkEntry,
								 &CleanupLock);
		}

		// At this point we have either successfully opened the fork,
		// encountered a DENY_CONFLICT or some other error.
		if ((Status != AFP_ERR_NONE) &&
			(Status != AFP_ERR_DENY_CONFLICT))
			break;

		// Do drop folder sanity check if someone tries to open for Write only
		if ((Status == AFP_ERR_NONE) &&
			(OpenMode == FORK_OPEN_WRITE) &&
			((FDParm._fdp_RescForkLen != 0) ||
			 (FDParm._fdp_DataForkLen != 0)))
		{
			ASSERT (VALID_OPENFORKENTRY(pOpenForkEntry));

			// If either fork is not empty, and one of them is being
			// opened for write, the user must also have READ access
			// to the parent directory.
			ParentPath = pOpenForkEntry->ofe_pOpenForkDesc->ofd_FilePath;
			// adjust the length to not include the filename
			ParentPath.Length -= pOpenForkEntry->ofe_pOpenForkDesc->ofd_FileName.Length;
			if (ParentPath.Length > 0)
			{
				ParentPath.Length -= sizeof(WCHAR);
			}

			AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
			Status = AfpCheckParentPermissions(pConnDesc,
								               FDParm._fdp_ParentId,
											   &ParentPath,
											   DIR_ACCESS_READ,
											   NULL,
											   NULL);
			AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
			//
			// We are no longer referencing the FileId or path kept
			// in the OpenForkDesc.  Ok for FpExchangeFiles to resume.
			//
			AfpSwmrRelease(&pVolDesc->vds_ExchangeFilesLock);
			CleanupLock = False;

			if (Status != AFP_ERR_NONE)
			{
				AfpForkClose(pOpenForkEntry);
				AfpForkDereference(pOpenForkEntry);

				// set this to null so it wont be upgraded/deref'd
				// in cleanup below
				pOpenForkEntry = NULL;

				// Set handle to null since it was closed in AfpForkClose
				// and we wont want it to be closed in cleanup below
				PME.pme_Handle.fsh_FileHandle = NULL;
				break;
			}
		}
		else
		{
			AfpSwmrRelease(&pVolDesc->vds_ExchangeFilesLock);
			CleanupLock = False;
		}

		if (RetCode == AFP_ERR_NONE)
		{
			pSda->sda_ReplySize = SIZE_RESPPKT +
						EVENALIGN(AfpGetFileDirParmsReplyLength(&FDParm, Bitmap));

			if ((RetCode = AfpAllocReplyBuf(pSda)) != AFP_ERR_NONE)
			{
				if (pOpenForkEntry != NULL)
					AfpForkClose(pOpenForkEntry);
				break;
			}
			AfpPackFileDirParms(&FDParm,
								Bitmap,
								pSda->sda_ReplyBuf + SIZE_RESPPKT);
			PUTDWORD2SHORT(pRspPkt->__Bitmap, Bitmap);
			PUTDWORD2SHORT(pRspPkt->__OForkRefNum, (pOpenForkEntry == NULL) ?
									0 : pOpenForkEntry->ofe_OForkRefNum);
			if (Status == AFP_ERR_NONE)
			{
				INTERLOCKED_INCREMENT_LONG(&pConnDesc->cds_cOpenForks);
			}
		}
		else Status = RetCode;
	} while (False);


	if (CleanupLock)
	{
		AfpSwmrRelease(&pVolDesc->vds_ExchangeFilesLock);
	}

    // update the disk quota for this user
    if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
    {
        if (AfpConnectionReferenceByPointer(pConnDesc) != NULL)
        {
            afpUpdateDiskQuotaInfo(pConnDesc);
        }
    }

	if (pOpenForkEntry != NULL)
	{
		if (Status == AFP_ERR_NONE)
			AfpUpgradeHandle(&pOpenForkEntry->ofe_FileSysHandle);
		AfpForkDereference(pOpenForkEntry);
	}

	if (!NT_SUCCESS(Status))
	{
		if (PME.pme_Handle.fsh_FileHandle != NULL)
			AfpIoClose(&PME.pme_Handle);
	}

	if (PME.pme_FullPath.Buffer != NULL)
	{
		DBGPRINT(DBG_COMP_FORKS, DBG_LEVEL_INFO,
				("AfpFspDispOpenFork: Freeing path buffer %lx\n",
				PME.pme_FullPath.Buffer));
		AfpFreeMemory(PME.pme_FullPath.Buffer);
	}

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispOpenFork: Returning %ld\n", Status));

	return Status;
}



/***	AfpFspDispCloseFork
 *
 *	This is the worker routine for the AfpCloseFork API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	POPENFORKENTRY	pOpenForkEntry
 */
AFPSTATUS FASTCALL
AfpFspDispCloseFork(
	IN	PSDA	pSda
)
{
	struct _RequestPacket
	{
		 POPENFORKENTRY	_pOpenForkEntry;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispCloseFork: Entered - Session %ld, Fork %ld\n",
			pSda->sda_SessionId, pReqPkt->_pOpenForkEntry->ofe_ForkId));

	ASSERT(VALID_OPENFORKENTRY(pReqPkt->_pOpenForkEntry));

	AfpForkClose(pReqPkt->_pOpenForkEntry);

	return AFP_ERR_NONE;
}



/***	AfpFspDispGetForkParms
 *
 *	This is the worker routine for the AfpGetForkParms API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	POPENFORKENTRY	pOpenForkEntry
 *	sda_ReqBlock	DWORD			Bitmap
 */
AFPSTATUS FASTCALL
AfpFspDispGetForkParms(
	IN	PSDA	pSda
)
{
	FILEDIRPARM		FDParm;
	DWORD			Bitmap;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
		DWORD  			_Bitmap;
	};
	struct _ResponsePacket
	{
		BYTE	__Bitmap[2];
	};

	PAGED_CODE( );

	ASSERT(VALID_OPENFORKENTRY(pReqPkt->_pOpenForkEntry));

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispGetForkParms: Entered Session %ld, Fork %ld\n",
			pSda->sda_SessionId, pReqPkt->_pOpenForkEntry->ofe_ForkId));

	Bitmap = pReqPkt->_Bitmap;

	do
	{
		if ((RESCFORK(pReqPkt->_pOpenForkEntry) && (Bitmap & FILE_BITMAP_DATALEN)) ||
			(DATAFORK(pReqPkt->_pOpenForkEntry) && (Bitmap & FILE_BITMAP_RESCLEN)))
		{
			Status = AFP_ERR_BITMAP;
			break;
		}

		AfpInitializeFDParms(&FDParm);

		// Optimize for the most common case.
		if ((Bitmap & (FILE_BITMAP_DATALEN | FILE_BITMAP_RESCLEN)) != 0)
		{
			FORKOFFST	ForkLength;

			Status = AfpIoQuerySize(&pReqPkt->_pOpenForkEntry->ofe_FileSysHandle,
									&ForkLength);

			ASSERT(NT_SUCCESS(Status));

			if (Bitmap & FILE_BITMAP_DATALEN)
				 FDParm._fdp_DataForkLen = ForkLength.LowPart;
			else FDParm._fdp_RescForkLen = ForkLength.LowPart;
			FDParm._fdp_Flags = 0;		// Take out the directory flag
		}

		// If we need more stuff, go get it
		if (Bitmap & ~(FILE_BITMAP_DATALEN | FILE_BITMAP_RESCLEN))
		{
			CONNDESC		ConnDesc;
			POPENFORKDESC	pOpenForkDesc = pReqPkt->_pOpenForkEntry->ofe_pOpenForkDesc;

			// Since the following call requires a pConnDesc and we do not
			// really have one, manufacture it
			ConnDesc.cds_pSda = pSda;
			ConnDesc.cds_pVolDesc = pOpenForkDesc->ofd_pVolDesc;

			// Don't let FpExchangeFiles come in while we are accessing
			// the stored FileId and its corresponding DFE
			AfpSwmrAcquireExclusive(&ConnDesc.cds_pVolDesc->vds_ExchangeFilesLock);

			Status = AfpMapAfpIdForLookup(&ConnDesc,
										  pOpenForkDesc->ofd_FileNumber,
										  DFE_FILE,
										  Bitmap & ~(FILE_BITMAP_DATALEN | FILE_BITMAP_RESCLEN),
										  NULL,
										  &FDParm);
            AfpSwmrRelease(&ConnDesc.cds_pVolDesc->vds_ExchangeFilesLock);
			if (Status != AFP_ERR_NONE)
			{
				break;
			}
		}

		if (Status == AFP_ERR_NONE)
		{
			pSda->sda_ReplySize = SIZE_RESPPKT +
					EVENALIGN(AfpGetFileDirParmsReplyLength(&FDParm, Bitmap));

			if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
			{
				AfpPackFileDirParms(&FDParm, Bitmap, pSda->sda_ReplyBuf + SIZE_RESPPKT);
				PUTDWORD2SHORT(&pRspPkt->__Bitmap, Bitmap);
			}
		}
	}  while (False);

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispGetForkParms: Returning %ld\n", Status));

	return Status;
}



/***	AfpFspDispSetForkParms
 *
 *	This is the worker routine for the AfpSetForkParms API.
 *  Only thing that can be set with this API is the fork length.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	POPENFORKENTRY	pOpenForkEntry
 *	sda_ReqBlock	DWORD			Bitmap
 *	sda_ReqBlock	LONG			ForkLength
 *
 *  LOCKS: vds_IdDbAccessLock (SWMR, Exclusive)
 */
AFPSTATUS FASTCALL
AfpFspDispSetForkParms(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status;
	DWORD			Bitmap;
	BOOLEAN			SetSize = False;
    PVOLDESC        pVolDesc;
    PCONNDESC       pConnDesc;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
		DWORD  			_Bitmap;
		LONG			_ForkLength;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispSetForkParms: Entered Session %ld Fork %ld, Length %ld\n",
			pSda->sda_SessionId, pReqPkt->_pOpenForkEntry->ofe_ForkId,
			pReqPkt->_ForkLength));

	ASSERT(VALID_OPENFORKENTRY(pReqPkt->_pOpenForkEntry));

	Bitmap = pReqPkt->_Bitmap;

	do
	{
		if ((RESCFORK(pReqPkt->_pOpenForkEntry) &&
				(pReqPkt->_Bitmap & FILE_BITMAP_DATALEN)) ||
			(DATAFORK(pReqPkt->_pOpenForkEntry) &&
				(pReqPkt->_Bitmap & FILE_BITMAP_RESCLEN)))
		{
			Status = AFP_ERR_BITMAP;
			break;
		}

		if (!(pReqPkt->_pOpenForkEntry->ofe_OpenMode & FORK_OPEN_WRITE))
		{
			Status = AFP_ERR_ACCESS_DENIED;
			break;
		}
		else if (pReqPkt->_ForkLength >= 0)
		{
			FORKSIZE	OldSize;

			// We don't try to catch our own changes for setting
			// forksize because we don't know how many times the mac
			// will set the size before closing the handle.  Since
			// a notification will only come in once the handle is
			// closed, we may pile up a whole bunch of our changes
			// in the list, but only one of them will get satisfied.
			//
			// We also do not want to attempt a change if the current length
			// is same as what it is being set to (this happens a lot,
			// unfortunately). Catch this red-handed.

			Status = AfpIoQuerySize(&pReqPkt->_pOpenForkEntry->ofe_FileSysHandle,
								   &OldSize);
			ASSERT (NT_SUCCESS(Status));
			if (!(((LONG)(OldSize.LowPart) == pReqPkt->_ForkLength) &&
				  (OldSize.HighPart == 0)))
			{
				SetSize = True;
				Status = AfpIoSetSize(&pReqPkt->_pOpenForkEntry->ofe_FileSysHandle,
								      pReqPkt->_ForkLength);

                // update the disk quota for this user
                pVolDesc = pReqPkt->_pOpenForkEntry->ofe_pConnDesc->cds_pVolDesc;

                if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
                {
                    pConnDesc = pReqPkt->_pOpenForkEntry->ofe_pConnDesc;
                    if (AfpConnectionReferenceByPointer(pConnDesc) != NULL)
                    {
                        afpUpdateDiskQuotaInfo(pConnDesc);
                    }
                }
			}

			// Update the Dfe view of the fork length.  Don't update the cached
			// modified time even though it does change on NTFS immediately
			// (LastWriteTime for setting length of data fork, ChangeTime for
			// setting length of resource fork).  We will let the
			// change notify update the modified time when the handle is closed.
			// Appleshare 3.0 and 4.0 do not reflect a changed modified time for
			// changing fork length until the fork is closed (or flushed).
			if (NT_SUCCESS(Status) && SetSize)
			{
				PVOLDESC		pVolDesc;
				PDFENTRY		pDfEntry;
				POPENFORKDESC	pOpenForkDesc;

				pOpenForkDesc = pReqPkt->_pOpenForkEntry->ofe_pOpenForkDesc;
				pVolDesc = pOpenForkDesc->ofd_pVolDesc;

				// Don't let FpExchangeFiles come in while we are accessing
				// the stored FileId and its corresponding DFE
				AfpSwmrAcquireExclusive(&pVolDesc->vds_ExchangeFilesLock);

				AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

				if ((pDfEntry = AfpFindDfEntryById(pVolDesc,
												   pOpenForkDesc->ofd_FileNumber,
												   DFE_FILE)) != NULL)
				{
				    ASSERT (VALID_DFE(pDfEntry));

					if (RESCFORK(pReqPkt->_pOpenForkEntry))
					{
						// If a FlushFork occurs on resource fork, it should
						// update the modified time to the ChangeTime
						pReqPkt->_pOpenForkEntry->ofe_Flags |= OPEN_FORK_WRITTEN;

						pDfEntry->dfe_RescLen = pReqPkt->_ForkLength;
					}
					else
				    {
						pDfEntry->dfe_DataLen = pReqPkt->_ForkLength;
                    }
				}

				AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
				AfpSwmrRelease(&pVolDesc->vds_ExchangeFilesLock);
			}

		}
		else Status = AFP_ERR_PARAM;
	} while (False);

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispSetForkParms: Returning %ld\n", Status));

	return Status;
}


/***	AfpFspDispRead
 *
 *	This routine implements the AfpRead API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	POPENFORKENTRY	pOpenForkEntry
 *	sda_ReqBlock	LONG			Offset
 *	sda_ReqBlock	LONG			Size
 *	sda_ReqBlock	DWORD			NewLine Mask
 *	sda_ReqBlock	DWORD			NewLine Char
 */
AFPSTATUS FASTCALL
AfpFspDispRead(
	IN	PSDA	pSda
)
{
	AFPSTATUS			Status=AFP_ERR_MISC;
	FORKOFFST			LOffset;
	FORKSIZE			LSize;
	PFAST_IO_DISPATCH	pFastIoDisp;
	IO_STATUS_BLOCK		IoStsBlk;
    NTSTATUS            NtStatus;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
		LONG			_Offset;
		LONG			_Size;
		DWORD			_NlMask;
		DWORD			_NlChar;
	};

	PAGED_CODE( );

	ASSERT(VALID_OPENFORKENTRY(pReqPkt->_pOpenForkEntry));

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispRead: Entered, Session %ld Fork %ld, Offset %ld, Size %ld\n",
			pSda->sda_SessionId, pReqPkt->_pOpenForkEntry->ofe_ForkId,
			pReqPkt->_Offset, pReqPkt->_Size));

	if ((pReqPkt->_Size < 0) ||
		(pReqPkt->_Offset < 0))
		return AFP_ERR_PARAM;

	if (!(pReqPkt->_pOpenForkEntry->ofe_OpenMode & FORK_OPEN_READ))
	{
		DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_WARN,
				("AfpFspDispRead: AfpRead on a Fork not opened for read\n"));
		return AFP_ERR_ACCESS_DENIED;
	}

	if (pReqPkt->_Size >= 0)
	{
		if (pReqPkt->_Size > (LONG)pSda->sda_MaxWriteSize)
			pReqPkt->_Size = (LONG)pSda->sda_MaxWriteSize;

		Status = AFP_ERR_NONE;

		if (pReqPkt->_Size > 0)
		{
			pSda->sda_ReadStatus = AFP_ERR_NONE;
			LOffset.QuadPart = pReqPkt->_Offset;
			LSize.QuadPart = pReqPkt->_Size;

			if ((pReqPkt->_pOpenForkEntry->ofe_pOpenForkDesc->ofd_UseCount == 1) ||
				(Status = AfpForkLockOperation( pSda,
												pReqPkt->_pOpenForkEntry,
												&LOffset,
												&LSize,
												IOCHECK,
												False)) == AFP_ERR_NONE)
			{
				ASSERT (LSize.HighPart == 0);
				ASSERT ((LONG)(LOffset.LowPart) == pReqPkt->_Offset);
				if ((LONG)(LSize.LowPart) != pReqPkt->_Size)
					pSda->sda_ReadStatus = AFP_ERR_LOCK;

				Status = AFP_ERR_MISC;

                pSda->sda_ReplySize = (USHORT)LSize.LowPart;

                NtStatus = STATUS_UNSUCCESSFUL;

                //
                // if Read is large enough to justify going to the cache mgr, do it
                //
                if (pSda->sda_ReplySize >= CACHEMGR_READ_THRESHOLD)
                {
                    NtStatus = AfpBorrowReadMdlFromCM(pSda);
                }

                //
                // if we didn't go to the cache mgr, or if we did but cache mgr
                // couldn't satisfy our request, continue with the read
                //
                if (NtStatus != STATUS_PENDING)
                {
                    Status = AfpFspDispReadContinue(pSda);
                }

                //
                // our attempt to get CacheMgr's mdl is pending.  Return this
                // error code so we don't complete the api as yet
                //
                else
                {
                    Status = AFP_ERR_EXTENDED;
                }

			}
		}
	}

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispRead: Returning %ld\n", Status));

	return Status;
}



/***	AfpFspDispReadContinue
 *
 *	This routine implements the AfpRead API if our attempt to get ReadMdl directly
 *  from the cache mgr fails.
 *
 */
AFPSTATUS FASTCALL
AfpFspDispReadContinue(
	IN	PSDA	pSda
)
{
	AFPSTATUS			Status=AFP_ERR_MISC;
	FORKOFFST			LOffset;
	FORKSIZE			LSize;
	PFAST_IO_DISPATCH	pFastIoDisp;
	IO_STATUS_BLOCK		IoStsBlk;
    NTSTATUS            NtStatus;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
		LONG			_Offset;
		LONG			_Size;
		DWORD			_NlMask;
		DWORD			_NlChar;
	};

	PAGED_CODE( );

    // allocate buffer for the read
    AfpIOAllocBackFillBuffer(pSda);

	if (pSda->sda_IOBuf != NULL)
    {
#if DBG
        AfpPutGuardSignature(pSda);
#endif

		LOffset.QuadPart = pReqPkt->_Offset;
		LSize.QuadPart = pReqPkt->_Size;

		// Try the fast I/O path first.  If that fails, call AfpIoForkRead
		// to use the normal build-an-IRP path.
		pFastIoDisp = pReqPkt->_pOpenForkEntry->ofe_pDeviceObject->DriverObject->FastIoDispatch;
		if ((pFastIoDisp != NULL) &&
			(pFastIoDisp->FastIoRead != NULL) &&
			pFastIoDisp->FastIoRead(AfpGetRealFileObject(pReqPkt->_pOpenForkEntry->ofe_pFileObject),
									&LOffset,
									LSize.LowPart,
									True,
									pSda->sda_SessionId,
									pSda->sda_ReplyBuf,
									&IoStsBlk,
									pReqPkt->_pOpenForkEntry->ofe_pDeviceObject))
		{
			LONG	i, Size;
			PBYTE	pBuf;
		
			DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
				("AfpFspDispRead: Fast Read Succeeded\n"));

#ifdef	PROFILING
			// The fast I/O path worked. Update statistics
			INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoSucceeded));
#endif  	
			INTERLOCKED_ADD_STATISTICS(&AfpServerStatistics.stat_DataRead,
									   (ULONG)IoStsBlk.Information,
									   &AfpStatisticsLock);
			Status = pSda->sda_ReadStatus;
			Size = (LONG)IoStsBlk.Information;
#if 0   	
			// The following code does the right thing as per the spec but
			// the finder seems to think otherwise.
			if (Size < LSize.LowPart)
            {
				pSda->sda_ReadStatus = AFP_ERR_EOF;
            }
#endif  	
			if (Size == 0)
			{
				Status = AFP_ERR_EOF;
				AfpIOFreeBackFillBuffer(pSda);
			}
			else if (pReqPkt->_NlMask != 0)
			{
				for (i = 0, pBuf = pSda->sda_ReplyBuf; i < Size; i++, pBuf++)
				{
				    if ((*pBuf & (BYTE)(pReqPkt->_NlMask)) == (BYTE)(pReqPkt->_NlChar))
					{
						Size = ++i;
						break;
					}
				}
			}
			pSda->sda_ReplySize = (USHORT)Size;
			ASSERT((Status != AFP_ERR_EOF) || (pSda->sda_ReplySize == 0));
		}
		else
		{

#ifdef	PROFILING
			INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoFailed));
#endif
			Status = AfpIoForkRead(pSda,
								   pReqPkt->_pOpenForkEntry,
								   &LOffset,
								   LSize.LowPart,
								   (BYTE)pReqPkt->_NlMask,
								   (BYTE)pReqPkt->_NlChar);
		}
	}

    return(Status);
}


/***	AfpFspDispWrite
 *
 *	This routine implements the AfpWrite API.
 *
 *	The request packet is represented below.
 *
 *	sda_AfpSubFunc	BYTE			EndFlag
 *	sda_ReqBlock	POPENFORKENTRY	pOpenForkEntry
 *	sda_ReqBlock	LONG			Offset
 *	sda_ReqBlock	LONG			Size
 */
AFPSTATUS FASTCALL
AfpFspDispWrite(
	IN	PSDA			pSda
)
{
	FORKOFFST			LOffset;
	FORKSIZE			LSize;
	PFAST_IO_DISPATCH	pFastIoDisp;
	IO_STATUS_BLOCK		IoStsBlk;
	AFPSTATUS			Status = AFP_ERR_NONE;
	BOOLEAN				EndFlag, FreeWriteBuf = True;
    PVOLDESC            pVolDesc;
    PCONNDESC           pConnDesc;
	PREQUEST            pRequest;
    BOOLEAN             fUpdateQuota=FALSE;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
		LONG			_Offset;
		LONG			_Size;
	};
	struct _ResponsePacket
	{
		BYTE	__RealOffset[4];
	};

	PAGED_CODE( );

	EndFlag = (pSda->sda_AfpSubFunc & AFP_END_FLAG) ? True : False;

	ASSERT(VALID_OPENFORKENTRY(pReqPkt->_pOpenForkEntry));

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispWrite: Entered, Session %ld, Fork %ld, Offset %ld, Size %ld %sRelative\n",
			pSda->sda_SessionId, pReqPkt->_pOpenForkEntry->ofe_ForkId,
			pReqPkt->_Offset, pReqPkt->_Size, EndFlag ? "End" : "Begin"));

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_WARN,
			("AfpFspDispWrite: OForkRefNum = %d, pOpenForkEntry = %lx\n",
			pReqPkt->_pOpenForkEntry->ofe_ForkId,pReqPkt->_pOpenForkEntry));
	do
	{
        pRequest = pSda->sda_Request;

        //
        // if we got this Mdl from the Cache mgr, we must return it.  Also, set
        // the status code such that we con't complete the request as yet, but
        // do so only afte cache mgr tells us that the write completed
        //
        if ((pRequest->rq_WriteMdl != NULL) &&
            (pRequest->rq_CacheMgrContext != NULL))
        {
            PDELAYEDALLOC   pDelAlloc;

            pDelAlloc = pRequest->rq_CacheMgrContext;

		    pReqPkt->_pOpenForkEntry->ofe_Flags |= OPEN_FORK_WRITTEN;

            ASSERT(pRequest->rq_WriteMdl == pDelAlloc->pMdl);
            ASSERT(!(pDelAlloc->Flags & AFP_CACHEMDL_ALLOC_ERROR));

            pRequest->rq_CacheMgrContext = NULL;

            AfpReturnWriteMdlToCM(pDelAlloc);

            FreeWriteBuf = False;
            Status = AFP_ERR_EXTENDED;
            break;
        }

        pConnDesc = pReqPkt->_pOpenForkEntry->ofe_pConnDesc;

        ASSERT(VALID_CONNDESC(pConnDesc));

		if ((pReqPkt->_Size < 0) ||
			(!EndFlag && (pReqPkt->_Offset < 0)))
		{
			Status = AFP_ERR_PARAM;
			break;
		}

		ASSERT((pReqPkt->_pOpenForkEntry->ofe_OpenMode & FORK_OPEN_WRITE) &&
			   ((pReqPkt->_Size == 0) ||
			   ((pReqPkt->_Size > 0) && (pSda->sda_IOBuf != NULL))));

		if (pReqPkt->_Size > (LONG)pSda->sda_MaxWriteSize)
			pReqPkt->_Size = (LONG)pSda->sda_MaxWriteSize;

		// Check if we have a lock conflict and also convert the offset &
		// size to absolute values if end relative
		LOffset.QuadPart = pReqPkt->_Offset;
		LSize.QuadPart = pReqPkt->_Size;

		if (pReqPkt->_Size == 0)
		{
			if (!(EndFlag && (pReqPkt->_Offset < 0)))
			{
				break;
			}
		}

		// Skip lock-check if this is the only instance of the open fork and I/O is
		// not end-relative.
		if ((!EndFlag &&
			(pReqPkt->_pOpenForkEntry->ofe_pOpenForkDesc->ofd_UseCount == 1)) ||
			(Status = AfpForkLockOperation( pSda,
											pReqPkt->_pOpenForkEntry,
											&LOffset,
											&LSize,
											IOCHECK,
											EndFlag)) == AFP_ERR_NONE)
		{
			ASSERT (LOffset.HighPart == 0);
			if ((LONG)(LSize.LowPart) != pReqPkt->_Size)
			{
				Status = AFP_ERR_LOCK;
			}
			else if (LSize.LowPart > 0)
			{
                ASSERT(VALID_CONNDESC(pReqPkt->_pOpenForkEntry->ofe_pConnDesc));

				// Assume write will succeed, set flag for FlushFork.
				// This is a one way flag, i.e. only set, never cleared
				pReqPkt->_pOpenForkEntry->ofe_Flags |= OPEN_FORK_WRITTEN;

				// Try the fast I/O path first.  If that fails, call AfpIoForkWrite
				// to use the normal build-an-IRP path.
				pFastIoDisp = pReqPkt->_pOpenForkEntry->ofe_pDeviceObject->DriverObject->FastIoDispatch;
				if ((pFastIoDisp != NULL) &&
					(pFastIoDisp->FastIoWrite != NULL) &&
					pFastIoDisp->FastIoWrite(AfpGetRealFileObject(pReqPkt->_pOpenForkEntry->ofe_pFileObject),
											&LOffset,
											LSize.LowPart,
											True,
											pSda->sda_SessionId,
											pSda->sda_IOBuf,
											&IoStsBlk,
											pReqPkt->_pOpenForkEntry->ofe_pDeviceObject))
				{
					DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
							("AfpFspDispWrite: Fast Write Succeeded\n"));
		
#ifdef	PROFILING
					// The fast I/O path worked. Update statistics
					INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoSucceeded));
#endif  		
					INTERLOCKED_ADD_STATISTICS(&AfpServerStatistics.stat_DataWritten,
											   (ULONG)IoStsBlk.Information,
											   &AfpStatisticsLock);
					Status = AFP_ERR_NONE;
				}
				else
				{
#ifdef	PROFILING
					INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoFailed));
#endif
					if ((Status = AfpIoForkWrite(pSda,
												 pReqPkt->_pOpenForkEntry,
												 &LOffset,
												 LSize.LowPart)) == AFP_ERR_EXTENDED)
					{
						FreeWriteBuf = False;
					}
				}

			}
		}
	} while (False);

	if (FreeWriteBuf)
    {
		AfpFreeIOBuffer(pSda);
    }

	if (Status == AFP_ERR_NONE)
	{
		pSda->sda_ReplySize = SIZE_RESPPKT;
		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
		{
			PUTDWORD2DWORD(pRspPkt->__RealOffset, LOffset.LowPart+LSize.LowPart);
		}
	}

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispWrite: Returning %ld\n", Status));

	return Status;
}



/***	AfpFspDispByteRangeLock
 *
 *	This routine implements the AfpByteRangeLock API.
 *	We go ahead and call the file system to do the actual locking/unlocking.
 *
 *	The request packet is represented below.
 *
 *	sda_SubFunc		BYTE			Start/End Flag AND Lock/Unlock Flag
 *	sda_ReqBlock	POPENFORKENTRY	pOpenForkEntry
 *	sda_ReqBlock	LONG			Offset
 *	sda_ReqBlock	LONG			Length
 */
AFPSTATUS FASTCALL
AfpFspDispByteRangeLock(
	IN	PSDA	pSda
)
{
	BOOLEAN			EndFlag;
	LOCKOP			Lock;
	LONG			Offset;
    FORKOFFST       LOffset;
    FORKSIZE        LSize;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
		LONG			_Offset;
        LONG			_Length;
	};
	struct _ResponsePacket
	{
		BYTE	__RangeStart[4];
	};

	ASSERT (sizeof(struct _RequestPacket) <= (MAX_REQ_ENTRIES_PLUS_1)*sizeof(DWORD));

	PAGED_CODE( );

	Lock = (pSda->sda_AfpSubFunc & AFP_UNLOCK_FLAG) ? UNLOCK : LOCK;
	EndFlag = (pSda->sda_AfpSubFunc & AFP_END_FLAG) ? True : False;

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispByteRangeLock: %sLock - Session %ld, Fork %ld Offset %ld Len %ld %sRelative\n",
			(Lock == LOCK) ? "":"Un", pSda->sda_SessionId,
			pReqPkt->_pOpenForkEntry->ofe_ForkId,
			pReqPkt->_Offset, pReqPkt->_Length, EndFlag ? "End" : "Begin"));

	ASSERT(VALID_OPENFORKENTRY(pReqPkt->_pOpenForkEntry));

	if ((EndFlag && (Lock == UNLOCK))		||
		(pReqPkt->_Length == 0)				||
		(!EndFlag && (pReqPkt->_Offset < 0))||
		((pReqPkt->_Length < 0) && (pReqPkt->_Length != MAXULONG)))
		NOTHING;
	else
	{
		if (pReqPkt->_Length == MAXULONG)
			pReqPkt->_Length = MAXLONG;

		LOffset.QuadPart = Offset = pReqPkt->_Offset;
		LSize.QuadPart = pReqPkt->_Length;

		Status = AfpForkLockOperation(pSda,
									  pReqPkt->_pOpenForkEntry,
									  &LOffset,
									  &LSize,
									  Lock,
									  EndFlag);

		if (Status == AFP_ERR_NONE)
		{
			ASSERT (LOffset.HighPart == 0);
			ASSERT (EndFlag ||
					((LONG)(LOffset.LowPart) == Offset));
			pSda->sda_ReplySize = SIZE_RESPPKT;
			if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
				PUTDWORD2DWORD(pRspPkt->__RangeStart, LOffset.LowPart);
		}
	}

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
			("AfpFspDispByteRangeLock: Returning %ld\n", Status));

	return Status;
}


/***	AfpFspDispFlushFork
 *
 *	This routine implements the AfpFlushFork API. We don't actually do a
 *  real flush, we just query for the current forklength and modified time
 *  for this open fork handle and update our cached data.  Note if 2
 *  different handles to the same file are flushed, we may end up with
 *  different information for each flush.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	POPENFORKENTRY	pOpenForkEntry
 */
AFPSTATUS FASTCALL
AfpFspDispFlushFork(
	IN	PSDA	pSda
)
{
	FORKOFFST	ForkLength;
	DWORD		Status;
    PCONNDESC   pConnDesc;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_INFO,
										("AfpFspDispFlushFork: Entered\n"));

	ASSERT(VALID_OPENFORKENTRY(pReqPkt->_pOpenForkEntry));

	do
	{
		Status = AfpIoQuerySize(&pReqPkt->_pOpenForkEntry->ofe_FileSysHandle,
								&ForkLength);

		ASSERT(NT_SUCCESS(Status));

		if (NT_SUCCESS(Status))
		{
			PVOLDESC		pVolDesc;
			PDFENTRY		pDfEntry;
			POPENFORKDESC	pOpenForkDesc;

			pOpenForkDesc = pReqPkt->_pOpenForkEntry->ofe_pOpenForkDesc;
			pVolDesc = pOpenForkDesc->ofd_pVolDesc;

            ASSERT(IS_VOLUME_NTFS(pVolDesc));

			// Don't let FpExchangeFiles come in while we are accessing
			// the stored FileId and its corresponding DFE
			AfpSwmrAcquireExclusive(&pVolDesc->vds_ExchangeFilesLock);

			AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

			if ((pDfEntry = AfpFindDfEntryById(pVolDesc,
											   pOpenForkDesc->ofd_FileNumber,
											   DFE_FILE)) != NULL)
			{
			    ASSERT (VALID_DFE(pDfEntry));

				AfpIoChangeNTModTime(&pReqPkt->_pOpenForkEntry->ofe_FileSysHandle,
										 &pDfEntry->dfe_LastModTime);

				if (RESCFORK(pReqPkt->_pOpenForkEntry))
					 pDfEntry->dfe_RescLen = ForkLength.LowPart;
				else pDfEntry->dfe_DataLen = ForkLength.LowPart;
			}

			AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
			AfpSwmrRelease(&pVolDesc->vds_ExchangeFilesLock);

            // update the disk quota for this user
            if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
            {
                pConnDesc = pReqPkt->_pOpenForkEntry->ofe_pConnDesc;
                if (AfpConnectionReferenceByPointer(pConnDesc) != NULL)
                {
                    afpUpdateDiskQuotaInfo(pConnDesc);
                }
            }
		}

	} while (False);

	// Always return success
	return AFP_ERR_NONE;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\fwddecl.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

        fwddecl.h

Abstract:

        This file defines dummy structures to avoid the circular relationships in
        header files.

Author:

        Jameel Hyder (microsoft!jameelh)


Revision History:
        2       Oct 1992             Initial Version

Notes:  Tab stop: 4
--*/


#ifndef _FWDDECL_
#define _FWDDECL_


struct _SessDataArea;

struct _ConnDesc;

struct _VolDesc;

struct _FileDirParms;

struct _PathMapEntity;

struct _DirFileEntry;

struct _FileDirParms;

struct _IoPoolHdr;

struct _IoPool;

//
// enable asserts when running checked stack on free builds
//
#if DBG
#ifdef ASSERT
#undef ASSERT
#endif
#define ASSERT(exp)                                                     \
{                                                                       \
    if (!(exp))                                                         \
    {                                                                   \
        DbgPrint( "\n*** Assertion failed: %s (File %s, line %ld)\n",   \
              (exp),__FILE__, __LINE__);                                \
                                                                        \
        DbgBreakPoint();                                                \
    }                                                                   \
}
#endif

// Spinlock macros
#if     DBG
#define INITIALIZE_SPIN_LOCK(_pLock)                                                                                    \
        {                                                                                                                                                       \
                KeInitializeSpinLock(&(_pLock)->SpinLock);                                                              \
                (_pLock)->FileLineLock = 0;                                                                                             \
        }
#else   // DBG
#define INITIALIZE_SPIN_LOCK(_pLock)                                                                \
        {                                                                                                                               \
        KeInitializeSpinLock(&(_pLock)->SpinLock);                                                  \
        }
#endif

#if     DBG
#define ACQUIRE_SPIN_LOCK(_pLock, _pOldIrql)                                                                    \
        {                                                                                                                                                       \
                KeAcquireSpinLock(&(_pLock)->SpinLock,                                                                  \
                                                  _pOldIrql);                                                                                   \
                (_pLock)->FileLineLock = (FILENUM | __LINE__);                                                  \
        }

#define ACQUIRE_SPIN_LOCK_AT_DPC(_pLock)                                                                                \
        {                                                                                                                                                       \
                ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);                                                   \
                KeAcquireSpinLockAtDpcLevel(&(_pLock)->SpinLock);                                               \
                (_pLock)->FileLineLock = (FILENUM | __LINE__ | 0x80000000);                             \
        }

#define RELEASE_SPIN_LOCK(_pLock, _OldIrql)                                                                             \
        {                                                                                                                                                       \
                ASSERT ((_pLock)->FileLineLock != 0);                                                                   \
                ASSERT (((_pLock)->FileLineLock & 0x80000000) == 0);                                    \
                (_pLock)->FileLineLock = 0;                                                                                             \
                (_pLock)->FileLineUnlock = (FILENUM | __LINE__);                                                \
                KeReleaseSpinLock(&(_pLock)->SpinLock,                                                                  \
                                                  _OldIrql);                                                                                    \
        }

#define RELEASE_SPIN_LOCK_FROM_DPC(_pLock)                                                                              \
        {                                                                                                                                                       \
                ASSERT ((_pLock)->FileLineLock != 0);                                                                   \
                ASSERT ((_pLock)->FileLineLock & 0x80000000);                                                   \
                (_pLock)->FileLineLock = 0;                                                                                             \
                (_pLock)->FileLineUnlock = (FILENUM | __LINE__ | 0x80000000);                   \
                KeReleaseSpinLockFromDpcLevel(&(_pLock)->SpinLock);                                             \
                ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);                                                   \
        }

#else   // DBG

#define ACQUIRE_SPIN_LOCK(_pLock, _pOldIrql)                                                                    \
        {                                                                                                                                                       \
                KeAcquireSpinLock(&(_pLock)->SpinLock,                                                                  \
                                                  _pOldIrql);                                                                                   \
        }

#define ACQUIRE_SPIN_LOCK_AT_DPC(_pLock)                                                                                \
        {                                                                                                                                                       \
                KeAcquireSpinLockAtDpcLevel(&(_pLock)->SpinLock);                                               \
        }

#define RELEASE_SPIN_LOCK(_pLock, _OldIrql)                                                                             \
        {                                                                                                                                                       \
                KeReleaseSpinLock(&(_pLock)->SpinLock,                                                                  \
                                                  (_OldIrql));                                                                                  \
        }

#define RELEASE_SPIN_LOCK_FROM_DPC(_pLock)                                                                              \
        {                                                                                                                                                       \
                KeReleaseSpinLockFromDpcLevel(&(_pLock)->SpinLock);                                             \
        }                                                                                                                                                       \

#endif  // DBG

typedef struct
{
    KSPIN_LOCK      SpinLock;
#if DBG
    ULONG           FileLineLock;
    ULONG           FileLineUnlock;
#endif
} AFP_SPIN_LOCK, *PAFP_SPIN_LOCK;

#endif  // _FWDDECL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\fsp_file.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fsp_file.c

Abstract:

	This module contains the entry points for the AFP file APIs queued to
	the FSP. These are all callable from FSP Only.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4

--*/

#define	FILENUM	FILE_FSP_FILE

#include <afp.h>
#include <gendisp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <client.h>
#include <afpinfo.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpFspDispCreateFile)
#pragma alloc_text( PAGE, AfpFspDispSetFileParms)
#pragma alloc_text( PAGE, AfpFspDispCopyFile)
#pragma alloc_text( PAGE, AfpFspDispCreateId)
#pragma alloc_text( PAGE, AfpFspDispResolveId)
#pragma alloc_text( PAGE, AfpFspDispDeleteId)
#pragma alloc_text( PAGE, AfpFspDispExchangeFiles)
#endif

/***	AfpFspDispCreateFile
 *
 *	This is the worker routine for the AfpCreateFile API.
 *
 *	The request packet is represented below.
 *
 *	sda_AfpSubFunc	BYTE		Create option
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_Name1		ANSI_STRING	FileName
 */
AFPSTATUS FASTCALL
AfpFspDispCreateFile(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status = AFP_ERR_PARAM, PostStatus;
	PATHMAPENTITY	PME;
	PDFENTRY		pNewDfe;
	FILESYSHANDLE	hNewFile, hAfpInfo, hParent;
	AFPINFO			afpinfo;
	DWORD			crinfo;
	PATHMAP_TYPE	CreateOption;
	WCHAR			PathBuf[BIG_PATH_LEN];
	PVOLDESC		pVolDesc;		// For post-create processing
	BYTE			PathType;		// -- ditto --
	BOOLEAN			InRoot;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FILE, DBG_LEVEL_INFO,
										("AfpFspDispCreateFile: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));
	
	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	do
	{
		hNewFile.fsh_FileHandle = NULL;
		hAfpInfo.fsh_FileHandle = NULL;
		hParent.fsh_FileHandle = NULL;
		CreateOption = (pSda->sda_AfpSubFunc == AFP_HARDCREATE_FLAG) ?
							HardCreate : SoftCreate;
		AfpInitializePME(&PME, sizeof(PathBuf), PathBuf);

		if (!NT_SUCCESS(Status = AfpMapAfpPath(pReqPkt->_pConnDesc,
											   pReqPkt->_ParentId,
											   &pSda->sda_Name1,
											   PathType = pSda->sda_PathType,
											   CreateOption,
											   DFE_FILE,
											   0,
											   &PME,
											   NULL)))
		{
			break;
		}

		// check for seefiles on the parent directory if hard create
		if (CreateOption == HardCreate)
		{
			if (!NT_SUCCESS(Status = AfpCheckParentPermissions(
												pReqPkt->_pConnDesc,
												PME.pme_pDfeParent->dfe_AfpId,
												&PME.pme_ParentPath,
												DIR_ACCESS_READ,
												&hParent,
												NULL)))
			{
				break;
			}
		}

		AfpImpersonateClient(pSda);

		InRoot = (PME.pme_ParentPath.Length == 0) ? True : False;
		Status = AfpIoCreate(&pVolDesc->vds_hRootDir,
							AFP_STREAM_DATA,
							&PME.pme_FullPath,
							FILEIO_ACCESS_NONE | FILEIO_ACCESS_DELETE,
							FILEIO_DENY_NONE,
							FILEIO_OPEN_FILE,
							AfpCreateDispositions[pSda->sda_AfpSubFunc / AFP_HARDCREATE_FLAG],
							FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_ARCHIVE,
							True,
							NULL,
							&hNewFile,
							&crinfo,
							pVolDesc,
							&PME.pme_FullPath,
// we don't get notified of parent mod time changing if there is no handle
// open for the parent dir at the time of create, which we cannot predict here.
							&PME.pme_ParentPath);

		AfpRevertBack();

		if (!NT_SUCCESS(Status))
		{
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
			break;
		}

		// !!! HACK ALERT !!!
		// At this point we are pretty much done i.e. the create has succeeded
		// and we can return doing the rest of the work post-reply. Any errors
		// from now on SHOULD BE IGNORED. Also NO REFERENCE SHOULD BE MADE TO
		// the PSda & pConnDesc. Status should not be changed either. Also
		// reference the Volume for good measure. It cannot fail !!!
		AfpVolumeReference(pVolDesc);

		AfpCompleteApiProcessing(pSda, AFP_ERR_NONE);
		Status = AFP_ERR_EXTENDED;

		// Add this entry to the IdDb
		if (crinfo == FILE_CREATED)
		{
			pNewDfe = AfpAddDfEntry(pVolDesc,
									PME.pme_pDfeParent,
									&PME.pme_UTail,
									False,
									0);
		}
		else if (crinfo == FILE_SUPERSEDED)
		{
			ASSERT(CreateOption == HardCreate);
			pNewDfe = AfpFindEntryByUnicodeName(pVolDesc,
												&PME.pme_UTail,
												PathType,
												PME.pme_pDfeParent,
												DFE_FILE);
			if (pNewDfe == NULL)
			{
				pNewDfe = AfpAddDfEntry(pVolDesc,
										PME.pme_pDfeParent,
										&PME.pme_UTail,
										False,
										0);
			}

		}
		else ASSERTMSG("AfpFspDispCreateFile: unexpected create action", 0);
			
		if (pNewDfe != NULL)
		{
			afpinfo.afpi_Id = pNewDfe->dfe_AfpId;

			// Create the AfpInfo stream
			if (!NT_SUCCESS(AfpCreateAfpInfoStream(pVolDesc,
												   &hNewFile,
												   afpinfo.afpi_Id,
												   False,
												   &PME.pme_UTail,
												   &PME.pme_FullPath,
												   &afpinfo,
												   &hAfpInfo)))
			{
				// If we fail to add the AFP_AfpInfo stream, we must
				// rewind back to the original state.  i.e. delete
				// the file we just created, and remove it from
				// the Id database.
				AfpIoMarkFileForDelete(&hNewFile,
									   pVolDesc,
									   &PME.pme_FullPath,
									   InRoot ? NULL : &PME.pme_ParentPath);

				AfpDeleteDfEntry(pVolDesc, pNewDfe);
			}
			else
			{
				DWORD			Attr;

				// Get the rest of the File info, and cache it
				PostStatus = AfpIoQueryTimesnAttr(&hNewFile,
												  &pNewDfe->dfe_CreateTime,
												  &pNewDfe->dfe_LastModTime,
												  &Attr);
				
				if (NT_SUCCESS(PostStatus))
				{
					pNewDfe->dfe_NtAttr = (USHORT)Attr & FILE_ATTRIBUTE_VALID_FLAGS;
					pNewDfe->dfe_FinderInfo = afpinfo.afpi_FinderInfo;
					pNewDfe->dfe_BackupTime = afpinfo.afpi_BackupTime;
					pNewDfe->dfe_AfpAttr = afpinfo.afpi_Attributes;
					pNewDfe->dfe_DataLen = 0;
					pNewDfe->dfe_RescLen = 0;
					AfpVolumeSetModifiedTime(pVolDesc);
					AfpCacheParentModTime(pVolDesc,
										  (hParent.fsh_FileHandle == NULL) ? NULL : &hParent,
										  (hParent.fsh_FileHandle == NULL) ? &PME.pme_ParentPath : NULL,
										  PME.pme_pDfeParent,
										  0);
				}
				else
				{
					AfpIoMarkFileForDelete(&hNewFile,
										   pVolDesc,
										   &PME.pme_FullPath,
										   InRoot ? NULL : &PME.pme_ParentPath);
					AfpDeleteDfEntry(pVolDesc, pNewDfe);
				}
			}
		}

		AfpVolumeDereference(pVolDesc);
		ASSERT (Status == AFP_ERR_EXTENDED);
	} while (False);

	if (hNewFile.fsh_FileHandle != NULL)
		AfpIoClose(&hNewFile);

	if (hAfpInfo.fsh_FileHandle != NULL)
		AfpIoClose(&hAfpInfo);

	// If you release the lock before closing the handles,
	// for datahandle the FPOpenFork could get a sharing violation.
	// For AfpInfo stream CopyFile can get a sharing violation.
	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

	if (hParent.fsh_FileHandle != NULL)
		AfpIoClose(&hParent);

	if ((PME.pme_FullPath.Buffer != NULL) &&
		(PME.pme_FullPath.Buffer != PathBuf))
		AfpFreeMemory(PME.pme_FullPath.Buffer);

	return Status;
}


/***	AfpFspDispSetFileParms
 *
 *	This is the worker routine for the AfpSetFileParms API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_ReqBlock	DWORD		File Bitmap
 *	sda_Name1		ANSI_STRING	Path
 *	sda_Name2		BLOCK		File Parameters
 */
AFPSTATUS FASTCALL
AfpFspDispSetFileParms(
	IN	PSDA	pSda
)
{
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	PVOLDESC		pVolDesc;
	DWORD			Bitmap;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
		DWORD		_Bitmap;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FILE, DBG_LEVEL_INFO,
										("AfpFspDispSetFileParms: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	ASSERT(VALID_VOLDESC(pVolDesc));
	
	Bitmap = pReqPkt->_Bitmap;

	AfpInitializeFDParms(&FDParm);
	AfpInitializePME(&PME, 0, NULL);
	do
	{
		// Force the FD_BITMAP_LONGNAME in case a *file* is missing the afpinfo
		// stream we will be able to generate the correct type/creator in
		// AfpSetAfpInfo
		Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										pReqPkt->_ParentId,
										&pSda->sda_Name1,
										pSda->sda_PathType,
										DFE_FILE,
										Bitmap | FD_INTERNAL_BITMAP_OPENACCESS_RW_ATTR |
												 FD_INTERNAL_BITMAP_RETURN_PMEPATHS |
												 FD_BITMAP_LONGNAME,
										&PME,
										&FDParm);

		if (!NT_SUCCESS(Status))
		{
			PME.pme_Handle.fsh_FileHandle = NULL;
			break;
		}

		if (Bitmap & (FD_BITMAP_ATTR |
					  FD_BITMAP_CREATETIME |
					  FD_BITMAP_MODIFIEDTIME))
		{
			DWORD	Attr;
			TIME	ModTime;

			if (!NT_SUCCESS(Status = AfpIoQueryTimesnAttr(&PME.pme_Handle,
														  &FDParm._fdp_CreateTime,
														  &ModTime,
														  &Attr)))
				break;
			
			FDParm._fdp_ModifiedTime = AfpConvertTimeToMacFormat(&ModTime);
			if (Bitmap & FD_BITMAP_ATTR)
				AfpNormalizeAfpAttr(&FDParm, Attr);
		}
		if ((Status = AfpUnpackFileDirParms(pSda->sda_Name2.Buffer,
											(LONG)pSda->sda_Name2.Length,
											&Bitmap,
											&FDParm)) != AFP_ERR_NONE)
			break;

		if (Bitmap != 0)
		{
			if ((Bitmap & FD_BITMAP_ATTR) &&
				(FDParm._fdp_Attr & (FILE_BITMAP_ATTR_DATAOPEN |
									 FILE_BITMAP_ATTR_RESCOPEN |
									 FILE_BITMAP_ATTR_COPYPROT)))
			{
				Status = AFP_ERR_PARAM;
				break;
			}
			AfpSetFileDirParms(pVolDesc, &PME, Bitmap, &FDParm);
		}
	} while (False);
	
	// Return before we close thus saving some time
	AfpCompleteApiProcessing(pSda, Status);

	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	if (PME.pme_FullPath.Buffer != NULL)
	{
		AfpFreeMemory(PME.pme_FullPath.Buffer);
	}

	return AFP_ERR_EXTENDED;
}


/***	AfpFspDispCopyFile
 *
 *	This is the worker routine for the AfpCopyFile API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	Source pConnDesc
 *	sda_ReqBlock	DWORD		Source ParentId
 *	sda_ReqBlock	DWORD		Dest VolId
 *	sda_ReqBlock	DWORD		Dest ParentId
 *	sda_Name1		ANSI_STRING	Source Path
 *	sda_Name2		ANSI_STRING	Dest Path
 *	sda_Name3		ANSI_STRING	New Name
 */
AFPSTATUS FASTCALL
AfpFspDispCopyFile(
	IN	PSDA	pSda
)
{
	PCONNDESC		pConnDescD;
	PATHMAPENTITY	PMESrc, PMEDst;
	FILEDIRPARM		FDParmSrc, FDParmDst;
	PANSI_STRING	pAnsiName;
	UNICODE_STRING	uNewName;
	WCHAR			wcbuf[AFP_FILENAME_LEN+1];
	PSWMR			pSwmr;
	PDFENTRY		pDfeParent, pNewDfe;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	BOOLEAN			DstLockTaken = False, Rename = True, InRoot;
	LONG			i;
	COPY_FILE_INFO	CopyFileInfo;
	PCOPY_FILE_INFO	pCopyFileInfo = &CopyFileInfo;
	DWORD			CreateTime = 0;
	AFPTIME			aModTime;
	TIME			ModTime;

	struct _RequestPacket
	{
		PCONNDESC	_pConnDescS;
		DWORD		_SrcParentId;
		DWORD		_DstVolId;
		DWORD		_DstParentId;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FILE, DBG_LEVEL_INFO,
										("AfpFspDispCopyFile: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDescS) &&
		   VALID_VOLDESC(pReqPkt->_pConnDescS->cds_pVolDesc));

	if	((pConnDescD =
			AfpConnectionReference(pSda, pReqPkt->_DstVolId)) != NULL)
	{
		ASSERT(VALID_CONNDESC(pConnDescD) &&
			   VALID_VOLDESC(pConnDescD->cds_pVolDesc));
	
		AfpInitializeFDParms(&FDParmSrc);
		AfpInitializeFDParms(&FDParmDst);
		AfpInitializePME(&PMESrc, 0, NULL);
		AfpInitializePME(&PMEDst, 0, NULL);
		AfpSetEmptyUnicodeString(&uNewName, sizeof(wcbuf), wcbuf);
        RtlZeroMemory(&CopyFileInfo, sizeof(COPY_FILE_INFO));
		PMESrc.pme_Handle.fsh_FileHandle = NULL;
		PMEDst.pme_Handle.fsh_FileHandle = NULL;

		do
		{
			if (pConnDescD->cds_pVolDesc->vds_Flags & AFP_VOLUME_READONLY)
			{
				Status = AFP_ERR_VOLUME_LOCKED;
				break;
			}

			// Make sure the new name is valid
			pAnsiName = &pSda->sda_Name3;
			if ((pSda->sda_Name3.Length > 0) &&
				((pSda->sda_Name3.Length > AFP_FILENAME_LEN) ||
				((pSda->sda_PathType == AFP_SHORTNAME) &&
				 !AfpIsLegalShortname(&pSda->sda_Name3)) ||
				(!NT_SUCCESS(AfpConvertStringToMungedUnicode(&pSda->sda_Name3,
															 &uNewName)))))
				break;

			Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDescS,
											pReqPkt->_SrcParentId,
											&pSda->sda_Name1,
											pSda->sda_PathType,
											DFE_FILE,
											FD_INTERNAL_BITMAP_OPENACCESS_READ |
												FD_BITMAP_ATTR |
												FD_BITMAP_LONGNAME |
												FD_BITMAP_FINDERINFO |
												FILE_BITMAP_RESCLEN |
												FILE_BITMAP_DATALEN |
												FD_INTERNAL_BITMAP_DENYMODE_WRITE,
											&PMESrc,
											&FDParmSrc);

			if (!NT_SUCCESS(Status))
			{
				break;
			}

			// Source opened ok. However we may have an internal deny conflict
			// Check that
			if (((Status = AfpCheckDenyConflict(pReqPkt->_pConnDescS->cds_pVolDesc,
												FDParmSrc._fdp_AfpId,
												False,
												FORK_OPEN_READ,
												FORK_DENY_WRITE,
												NULL)) != AFP_ERR_NONE) ||
				((Status = AfpCheckDenyConflict(pReqPkt->_pConnDescS->cds_pVolDesc,
												FDParmSrc._fdp_AfpId,
												True,
												FORK_OPEN_READ,
												FORK_DENY_WRITE,
												NULL)) != AFP_ERR_NONE))
			{
				Status = AFP_ERR_DENY_CONFLICT;
				break;
			}

			pSwmr = &pConnDescD->cds_pVolDesc->vds_IdDbAccessLock;
			AfpSwmrAcquireExclusive(pSwmr);
			DstLockTaken = True;

			// Map the destination directory for Lookup
			if (!NT_SUCCESS(Status = AfpMapAfpPath(pConnDescD,
												   pReqPkt->_DstParentId,
												   &pSda->sda_Name2,
												   pSda->sda_PathType,
												   Lookup,
												   DFE_DIR,
												   0,
												   &PMEDst,
												   &FDParmDst)))
			{
				break;
			}

			AfpImpersonateClient(pSda);
			
			// If no new name was supplied, we need to use the
			// current name
			if (pSda->sda_Name3.Length == 0)
			{
				Rename = False;
				pAnsiName = &FDParmSrc._fdp_LongName;
				AfpConvertStringToMungedUnicode(pAnsiName,
												&uNewName);
			}

			// since we really want the path of the thing we are about
			// to create, munge the strings in the PMEDst
			PMEDst.pme_ParentPath = PMEDst.pme_FullPath;
			if (PMEDst.pme_FullPath.Length > 0)
			{
				PMEDst.pme_FullPath.Buffer[PMEDst.pme_FullPath.Length / sizeof(WCHAR)] = L'\\';
				PMEDst.pme_FullPath.Length += sizeof(WCHAR);
			}
			Status = RtlAppendUnicodeStringToString(&PMEDst.pme_FullPath,
													&uNewName);
			ASSERT(NT_SUCCESS(Status));

			InRoot = (PMEDst.pme_ParentPath.Length == 0) ? True : False;
			Status = AfpIoCopyFile1(&PMESrc.pme_Handle,
									&PMEDst.pme_Handle,
									&uNewName,
									pConnDescD->cds_pVolDesc,
									&PMEDst.pme_FullPath,
									InRoot ? NULL : &PMEDst.pme_ParentPath,
									&CopyFileInfo);

			AfpRevertBack();

			if (!NT_SUCCESS(Status))
			{
				break;
			}

			// Add this entry to the IdDb. First find the parent directory
			pDfeParent = AfpFindDfEntryById(pConnDescD->cds_pVolDesc,
											FDParmDst._fdp_AfpId,
											DFE_DIR);
			ASSERT(pDfeParent != NULL);
			pNewDfe = AfpAddDfEntry(pConnDescD->cds_pVolDesc,
									pDfeParent,
									&uNewName,
									False,
									0);

			Status = AFP_ERR_MISC; // Assume failure
			if (pNewDfe != NULL)
			{
				// Put the new file's AFPId into the AfpInfo stream
				AfpInitializeFDParms(&FDParmDst);
				FDParmDst._fdp_Flags = DFE_FLAGS_FILE_NO_ID;
				FDParmDst._fdp_AfpId = pNewDfe->dfe_AfpId;
				FDParmDst._fdp_BackupTime = BEGINNING_OF_TIME;

	            // Copy the finderinfo from the source to the destination
				// Also clear the inited bit so that finder will assign
				// new coordinates for the new file.
				FDParmDst._fdp_FinderInfo = FDParmSrc._fdp_FinderInfo;
				FDParmDst._fdp_FinderInfo.fd_Attr1 &= ~FINDER_FLAG_SET;
				AfpConvertMungedUnicodeToAnsi(&pNewDfe->dfe_UnicodeName,
											  &FDParmDst._fdp_LongName);

				Status = AfpSetAfpInfo(&CopyFileInfo.cfi_DstStreamHandle[0],
									   FILE_BITMAP_FILENUM	|
									   FD_BITMAP_BACKUPTIME	|
									   FD_BITMAP_FINDERINFO,
									   &FDParmDst,
									   NULL,
									   NULL);

				if (NT_SUCCESS(Status))
				{
					// Get the rest of the File info, and cache it
					Status = AfpIoQueryTimesnAttr(&CopyFileInfo.cfi_SrcStreamHandle[0],
												  &pNewDfe->dfe_CreateTime,
												  &pNewDfe->dfe_LastModTime,
												  NULL);
					
					if (NT_SUCCESS(Status))
					{
			            // Copy the finderinfo into the destination DFE.
						// Use the FDParmDst version since it has the right
						// version - see above.
						pNewDfe->dfe_FinderInfo = FDParmDst._fdp_FinderInfo;
						pNewDfe->dfe_BackupTime = BEGINNING_OF_TIME;
						pNewDfe->dfe_AfpAttr = FDParmSrc._fdp_Attr &
														~(FD_BITMAP_ATTR_SET |
														  FILE_BITMAP_ATTR_DATAOPEN |
														  FILE_BITMAP_ATTR_RESCOPEN);
						pNewDfe->dfe_NtAttr =  (USHORT)AfpConvertAfpAttrToNTAttr(pNewDfe->dfe_AfpAttr);
						pNewDfe->dfe_DataLen = FDParmSrc._fdp_DataForkLen;
						pNewDfe->dfe_RescLen = FDParmSrc._fdp_RescForkLen;
	
						AfpCacheParentModTime(pConnDescD->cds_pVolDesc,
											  NULL,
											  &PMEDst.pme_ParentPath,
											  pNewDfe->dfe_Parent,
											  0);
					}

					// Set the attributes such that it matches the source
					Status = AfpIoSetTimesnAttr(&CopyFileInfo.cfi_DstStreamHandle[0],
												NULL,
												NULL,
												pNewDfe->dfe_NtAttr,
												0,
												pConnDescD->cds_pVolDesc,
												&PMEDst.pme_FullPath);
				}

				if (!NT_SUCCESS(Status))
				{
					// If we failed to write the correct AfpId onto the
					// new file, then delete the file, and remove it from
					// the Id database.
					AfpIoMarkFileForDelete(&CopyFileInfo.cfi_DstStreamHandle[0],
										   pConnDescD->cds_pVolDesc,
										   &PMEDst.pme_FullPath,
										   InRoot ? NULL : &PMEDst.pme_ParentPath);

					AfpDeleteDfEntry(pConnDescD->cds_pVolDesc, pNewDfe);
					Status = AFP_ERR_MISC;
				}
			}
		} while (False);

		if (DstLockTaken == True)
			AfpSwmrRelease(pSwmr);

		// If we have successfully come so far, go ahead and complete the copy
		if (Status == AFP_ERR_NONE)
		{
			Status = AfpIoCopyFile2(&CopyFileInfo,
									pConnDescD->cds_pVolDesc,
									&PMEDst.pme_FullPath,
									InRoot ? NULL : &PMEDst.pme_ParentPath);
			if (Status == AFP_ERR_NONE)
			{
				// We need to get the create and modified time from the source
				// file before we close it.
				AfpIoQueryTimesnAttr(&pCopyFileInfo->cfi_SrcStreamHandle[0],
									 &CreateTime,
									 &ModTime,
									 NULL);

				aModTime = AfpConvertTimeToMacFormat(&ModTime);

			} else {

				AfpSwmrAcquireExclusive(pSwmr);
				// Note that we cannot use pNewDfe. We need to remap. It could have
				// got deleted when we relinquished the Swmr.
				pNewDfe = AfpFindDfEntryById(pConnDescD->cds_pVolDesc,
											  FDParmDst._fdp_AfpId,
											  DFE_FILE);
				if (pNewDfe != NULL)
					AfpDeleteDfEntry(pConnDescD->cds_pVolDesc, pNewDfe);
				AfpSwmrRelease(pSwmr);
			}

            // update the disk quota for this user on the destination volume
            if (pConnDescD->cds_pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
            {
                if (AfpConnectionReferenceByPointer(pConnDescD) != NULL)
                {
                    afpUpdateDiskQuotaInfo(pConnDescD);
                }
            }
		}

		// Close the source file and dest directory handles
		if (PMESrc.pme_Handle.fsh_FileHandle != NULL)
			AfpIoClose(&PMESrc.pme_Handle);
		if (PMEDst.pme_Handle.fsh_FileHandle != NULL)
			AfpIoClose(&PMEDst.pme_Handle);

		// Close all the handles, Free the handle space. We come here regardless
		// of success/error. MAKE SURE THE SOURCE HANDLE IS NOT CLOSED HERE SINCE
		// IT HAS BEEN CLOSED ABOVE.
		// MAKE SURE THE DESTINATION HANDLE IS NOT CLOSED HERE SINCE WE NEED IT TO
		// SET THE FILE TIME.
		for (i = 1; i < CopyFileInfo.cfi_NumStreams; i++)
		{
			if (CopyFileInfo.cfi_SrcStreamHandle[i].fsh_FileHandle != NULL)
			{
				AfpIoClose(&CopyFileInfo.cfi_SrcStreamHandle[i]);
			}
			if (CopyFileInfo.cfi_DstStreamHandle[i].fsh_FileHandle != NULL)
			{
				AfpIoClose(&CopyFileInfo.cfi_DstStreamHandle[i]);
			}
		}

		if ((CopyFileInfo.cfi_DstStreamHandle != NULL) &&
		    (CopyFileInfo.cfi_DstStreamHandle[0].fsh_FileHandle != NULL))
		{
			if (Status == AFP_ERR_NONE)
			{
				// Set the creation and modification date on the destination
				// file to match that of the source file
				AfpIoSetTimesnAttr(&pCopyFileInfo->cfi_DstStreamHandle[0],
								   &CreateTime,
								   &aModTime,
								   0,
								   0,
								   pConnDescD->cds_pVolDesc,
								   &PMEDst.pme_FullPath);
			}
			AfpIoClose(&CopyFileInfo.cfi_DstStreamHandle[0]);
		}

		if (PMEDst.pme_FullPath.Buffer != NULL)
			AfpFreeMemory(PMEDst.pme_FullPath.Buffer);

		if (CopyFileInfo.cfi_SrcStreamHandle != NULL)
			AfpFreeMemory(CopyFileInfo.cfi_SrcStreamHandle);
		if (CopyFileInfo.cfi_DstStreamHandle != NULL)
			AfpFreeMemory(CopyFileInfo.cfi_DstStreamHandle);

		AfpConnectionDereference(pConnDescD);
	}

	return Status;
}


/***	AfpFspDispCreateId
 *
 *	This is the worker routine for the AfpCreateId API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		ParentId
 *	sda_Name1		ANSI_STRING	Path
 */
AFPSTATUS FASTCALL
AfpFspDispCreateId(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status = AFP_ERR_PARAM, Status2;
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_ParentId;
	};
	struct _ResponsePacket
	{
		BYTE	__FileId[4];
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FILE, DBG_LEVEL_INFO,
										("AfpFspDispCreateId: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));
	
	do
	{
		AfpInitializePME(&PME, 0, NULL);
		Status = AfpMapAfpPathForLookup(pReqPkt->_pConnDesc,
										pReqPkt->_ParentId,
										&pSda->sda_Name1,
										pSda->sda_PathType,
										DFE_FILE,
										FILE_BITMAP_FILENUM | FD_INTERNAL_BITMAP_OPENACCESS_READ,
										&PME,
										&FDParm);
        // if we get sharing violation we know we have read access to the file
		if (!NT_SUCCESS(Status) && (Status != AFP_ERR_DENY_CONFLICT))
			break;

		// Set the bit in DF Entry
		Status = AfpSetDFFileFlags(pReqPkt->_pConnDesc->cds_pVolDesc,
								   FDParm._fdp_AfpId,
								   0,
								   True,
								   False);
	} while (False);

	if ((Status == AFP_ERR_VOLUME_LOCKED) && (FDParm._fdp_Flags & DFE_FLAGS_FILE_WITH_ID))
	{
		// If the volume is locked, but an Id exists, return it
		Status = AFP_ERR_ID_EXISTS;
	}

	if ((Status == AFP_ERR_NONE) || (Status == AFP_ERR_ID_EXISTS))
	{
		pSda->sda_ReplySize = SIZE_RESPPKT;
		if ((Status2 = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
		{
			PUTDWORD2DWORD(pRspPkt->__FileId, FDParm._fdp_AfpId);
		}
		else
		{
			Status = Status2;
		}
	}

	// Return before we close thus saving some time
	AfpCompleteApiProcessing(pSda, Status);

	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	return AFP_ERR_EXTENDED;
}


/***	AfpFspDispResolveId
 *
 *	This is the worker routine for the AfpResolveId API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		FileId
 *	sda_ReqBlock	DWORD		Bitmap
 */
AFPSTATUS FASTCALL
AfpFspDispResolveId(
	IN	PSDA	pSda
)
{
	DWORD			Bitmap;
	AFPSTATUS		Status = AFP_ERR_PARAM;
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_FileId;
		DWORD		_Bitmap;
	};
	struct _ResponsePacket
	{
		BYTE	__Bitmap[2];
		// Rest of the parameters
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FILE, DBG_LEVEL_INFO,
										("AfpFspDispResolveId: Entered\n"));
	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));
	
	Bitmap = pReqPkt->_Bitmap;

	do
	{
		AfpInitializeFDParms(&FDParm);
		AfpInitializePME(&PME, 0, NULL);

		// HACK: this is to make System 7.5 FindFile not grey out the first
		// item in the list of items found.  Normally we would check for
		// parameter non-zero in the api table in afpapi.c and return an
		// error there, but this is a special case.
		if (pReqPkt->_FileId == 0)
		{
			Status = AFP_ERR_ID_NOT_FOUND;
			break;
		}

		Status = AfpMapAfpIdForLookup(pReqPkt->_pConnDesc,
								pReqPkt->_FileId,
								DFE_FILE,
								Bitmap | FD_INTERNAL_BITMAP_OPENACCESS_READ,
								&PME,
								&FDParm);
		if (!NT_SUCCESS(Status) && (Status != AFP_ERR_DENY_CONFLICT))
		{								
			if (Status == AFP_ERR_OBJECT_NOT_FOUND)
			{
				Status = AFP_ERR_ID_NOT_FOUND;
			}
			break;
		}

		// a deny conflict means the user actually has access to the file, so
		// we need to open for nothing with no sharing modes to get the
		// bitmap parameters.
		if (Status == AFP_ERR_DENY_CONFLICT)
		{
			Status = AfpMapAfpIdForLookup(pReqPkt->_pConnDesc,
										  pReqPkt->_FileId,
										  DFE_FILE,
										  Bitmap,
										  &PME,
										  &FDParm);
			if (!NT_SUCCESS(Status))
			{
				if (Status == AFP_ERR_OBJECT_NOT_FOUND)
				{
					Status = AFP_ERR_ID_NOT_FOUND;
				}
				break;
			}

		}

		if (!(FDParm._fdp_Flags & DFE_FLAGS_FILE_WITH_ID))
		{
			Status = AFP_ERR_ID_NOT_FOUND;
			break;
		}

		pSda->sda_ReplySize = SIZE_RESPPKT +
						EVENALIGN(AfpGetFileDirParmsReplyLength(&FDParm, Bitmap));
	
		if ((Status = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
		{
			AfpPackFileDirParms(&FDParm, Bitmap, pSda->sda_ReplyBuf + SIZE_RESPPKT);
			PUTDWORD2SHORT(pRspPkt->__Bitmap, Bitmap);
		}
	} while (False);

	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	return Status;
}


/***	AfpFspDispDeleteId
 *
 *	This is the worker routine for the AfpDeleteId API.
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		FileId
 */
AFPSTATUS FASTCALL
AfpFspDispDeleteId(
	IN	PSDA	pSda
)
{
	AFPSTATUS		Status = AFP_ERR_PARAM;
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_FileId;
	};

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FILE, DBG_LEVEL_INFO,
										("AfpFspDispDeleteId: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));
	
	do
	{
		AfpInitializePME(&PME, 0, NULL);
		Status = AfpMapAfpIdForLookup(pReqPkt->_pConnDesc,
		                              pReqPkt->_FileId,
									  DFE_FILE,
									  FILE_BITMAP_FILENUM |
									   FD_INTERNAL_BITMAP_OPENACCESS_READWRITE,
									  &PME,
									  &FDParm);
		if (!NT_SUCCESS(Status) && (Status != AFP_ERR_DENY_CONFLICT))
		{
			if (Status == AFP_ERR_OBJECT_NOT_FOUND)
			{
				Status = AFP_ERR_ID_NOT_FOUND;
			}
			break;
		}

		// Set the bit in DF Entry
		Status = AfpSetDFFileFlags(pReqPkt->_pConnDesc->cds_pVolDesc,
								   FDParm._fdp_AfpId,
								   0,
								   False,
								   True);
	} while (False);

	// Return before we close thus saving some time
	AfpCompleteApiProcessing(pSda, Status);

	if (PME.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PME.pme_Handle);

	return AFP_ERR_EXTENDED;
}


/***	AfpFspDispExchangeFiles
 *
 *	This is the worker routine for the AfpExchangeFiles API.
 *
 * Acquire the IdDb Swmr for Write and map both source and destination for
 * lookup (set to open the entities for DELETE access since we are going to
 * rename them). Check that we have the appropriate parent
 * permissions. Then rename source to destiation and vice versa (will need an
 * intermediate name - use a name > 31 chars so that it does not collide with
 * an existing name. Use characters that cannot be accessed by Win32 so that
 * side is taken care of as well (40 spaces should do it). Since we have the
 * Swmr held for WRITE, there is no issue of two different AfpExchangeFile
 * apis trying to rename to the same name). Then inter-change the file ids
 * and the FinderInfo in the AfpInfo streams. Also interchange the create
 * times (retain original ID and create time) on the files. Swap all the other
 * cached info in the 2 DFEntries.
 * Make sure the stuff is setup so that ChangeNotify filters are handled
 * appropriately.
 *
 * If either of the files are currently open, the name and ID in the
 * OpenForkDesc (that each OpenForkEntry points to) has to change to
 * the new name. Note that because the name and Id can now change in
 * the OpenForkDesc, we must make sure that everyone who accesses these
 * is taking appropriate locks.
 *
 *
 *	The request packet is represented below.
 *
 *	sda_ReqBlock	PCONNDESC	pConnDesc
 *	sda_ReqBlock	DWORD		Srce. DirId
 *	sda_ReqBlock	DWORD		Dest. DirId
 *	sda_Name1		ANSI_STRING	Srce. Path
 *	sda_Name2		ANSI_STRING	Dest. Path
 */
AFPSTATUS FASTCALL
AfpFspDispExchangeFiles(
	IN	PSDA	pSda
)
{
	PATHMAPENTITY	PMESrc, PMEDst;
	PVOLDESC		pVolDesc;
	FILEDIRPARM		FDParmSrc, FDParmDst;
	AFPSTATUS		Status = AFP_ERR_NONE, Status2 = AFP_ERR_NONE;
	BOOLEAN			Move = True, RevertBack = False, SrcInRoot, DstInRoot;
	BOOLEAN			RestoreSrcRO = False, RestoreDstRO = False;
	FILESYSHANDLE	hSrcParent, hDstParent;
	DWORD			checkpoint = 0; // denotes what needs cleanup on error
	DWORD			NTAttrSrc = 0, NTAttrDst = 0;
	WCHAR			PathBuf[BIG_PATH_LEN];
	UNICODE_STRING	TempPath;		// temporary filename for renaming files
	struct _RequestPacket
	{
		PCONNDESC	_pConnDesc;
		DWORD		_SrcParentId;
		DWORD		_DstParentId;
	};

#define _CHKPOINT_XCHG_DSTTOTEMP	1
#define _CHKPOINT_XCHG_SRCTODST		2
#define _CHKPOINT_XCHG_TEMPTOSRC	3

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_AFPAPI_FILE, DBG_LEVEL_INFO,
			("AfpFspDispExchangeFiles: Entered\n"));

	ASSERT(VALID_CONNDESC(pReqPkt->_pConnDesc) &&
		   VALID_VOLDESC(pReqPkt->_pConnDesc->cds_pVolDesc));

	pVolDesc = pReqPkt->_pConnDesc->cds_pVolDesc;

	AfpInitializeFDParms(&FDParmSrc);
	AfpInitializeFDParms(&FDParmDst);
	AfpInitializePME(&PMESrc, 0, NULL);
	AfpInitializePME(&PMEDst, 0, NULL);
	AfpSetEmptyUnicodeString(&TempPath, 0, NULL);
	hSrcParent.fsh_FileHandle = NULL;
	hDstParent.fsh_FileHandle = NULL;


	// Don't allow any fork operations that might access the FileId
	// in an OpenForkDesc that could get exchanged.
	AfpSwmrAcquireExclusive(&pVolDesc->vds_ExchangeFilesLock);

	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	do
	{

		if (!NT_SUCCESS(Status = AfpMapAfpPath(pReqPkt->_pConnDesc,
											   pReqPkt->_SrcParentId,
											   &pSda->sda_Name1,
											   pSda->sda_PathType,
											   Lookup,
											   DFE_FILE,
											   FD_INTERNAL_BITMAP_OPENACCESS_DELETE |
												(FILE_BITMAP_MASK &
												~(FD_BITMAP_SHORTNAME | FD_BITMAP_PRODOSINFO)),
											   &PMESrc,
											   &FDParmSrc)))
		{
			break;
		}


		// Check for SeeFiles on the source parent dir
		if (!NT_SUCCESS(Status = AfpCheckParentPermissions(
												pReqPkt->_pConnDesc,
												FDParmSrc._fdp_ParentId,
												&PMESrc.pme_ParentPath,
												DIR_ACCESS_READ,
												&hSrcParent,
												NULL)))
		{
			break;
		}

		if (!NT_SUCCESS(Status = AfpCheckForInhibit(&PMESrc.pme_Handle,
											  FD_BITMAP_ATTR_RENAMEINH,
											  FDParmSrc._fdp_Attr,
											  &NTAttrSrc)))
		{
			break;
		}
		
		if (!NT_SUCCESS(Status = AfpMapAfpPath(pReqPkt->_pConnDesc,
											   pReqPkt->_DstParentId,
											   &pSda->sda_Name2,
											   pSda->sda_PathType,
											   Lookup,
											   DFE_FILE,
											   FD_INTERNAL_BITMAP_OPENACCESS_DELETE |
												(FILE_BITMAP_MASK &
												~(FD_BITMAP_SHORTNAME | FD_BITMAP_PRODOSINFO)),
											   &PMEDst,
											   &FDParmDst)))
		{
			break;
		}

		if (FDParmSrc._fdp_AfpId == FDParmDst._fdp_AfpId)
		{
			// make sure the src and dst are not the same file
			Status = AFP_ERR_SAME_OBJECT;
			break;
		}

		if (FDParmSrc._fdp_ParentId == FDParmDst._fdp_ParentId)
		{
			// if the parent directories are the same, we are not
			// moving anything to a new directory, so the change
			// notify we expect will be a rename in the source dir.
			Move = False;
		}
		else
		{
			// Check for SeeFiles on the destination parent dir
			if (!NT_SUCCESS(Status = AfpCheckParentPermissions(
													pReqPkt->_pConnDesc,
													FDParmDst._fdp_ParentId,
													&PMEDst.pme_ParentPath,
													DIR_ACCESS_READ,
													&hDstParent,
													NULL)))
			{
				break;
			}
		}

		if (!NT_SUCCESS(Status = AfpCheckForInhibit(&PMEDst.pme_Handle,
											  FD_BITMAP_ATTR_RENAMEINH,
											  FDParmDst._fdp_Attr,
											  &NTAttrDst)))
		{
			break;
		}


		//
		// Construct the path to the temporary filename for renaming during
		// the name exchange
		//
		TempPath.MaximumLength = PMEDst.pme_ParentPath.Length + sizeof(WCHAR) +
														AfpExchangeName.Length;
		TempPath.Buffer = PathBuf;
		if ((TempPath.MaximumLength > sizeof(PathBuf)) &&
			(TempPath.Buffer = (PWCHAR)AfpAllocNonPagedMemory(TempPath.MaximumLength)) == NULL)
		{
			Status = AFP_ERR_MISC;
			break;
		}

		AfpCopyUnicodeString(&TempPath, &PMEDst.pme_ParentPath);
		if (TempPath.Length != 0)
		{
			TempPath.Buffer[TempPath.Length / sizeof(WCHAR)] = L'\\';
			TempPath.Length += sizeof(WCHAR);
			ASSERT((TempPath.MaximumLength - TempPath.Length) >= AfpExchangeName.Length);
		}
		Status = RtlAppendUnicodeStringToString(&TempPath, &AfpExchangeName);
		ASSERT(NT_SUCCESS(Status));

		if (NTAttrSrc & FILE_ATTRIBUTE_READONLY)
		{
			// We must temporarily remove the ReadOnly attribute so that
			// we can rename the file/dir
			Status = AfpIoSetTimesnAttr(&PMESrc.pme_Handle,
										NULL,
										NULL,
										0,
										FILE_ATTRIBUTE_READONLY,
										pVolDesc,
										&PMESrc.pme_FullPath);
			if (!NT_SUCCESS(Status))
			{
				break;
			}
			else
				RestoreSrcRO = True;
		}

		if (NTAttrDst & FILE_ATTRIBUTE_READONLY)
		{
			// We must temporarily remove the ReadOnly attribute so that
			// we can rename the file/dir
			Status = AfpIoSetTimesnAttr(&PMEDst.pme_Handle,
										NULL,
										NULL,
										0,
										FILE_ATTRIBUTE_READONLY,
										pVolDesc,
										&PMEDst.pme_FullPath);
			if (!NT_SUCCESS(Status))
			{
				break;
			}
			else
				RestoreDstRO = True;
		}

		// We must impersonate to do the move since it is name based
		AfpImpersonateClient(pSda);
		RevertBack = True;

		SrcInRoot = (PMESrc.pme_ParentPath.Length == 0) ? True : False;
		DstInRoot = (PMEDst.pme_ParentPath.Length == 0) ? True : False;

		// First, rename the destination to a temporary name in the same
		// directory
		Status = AfpIoMoveAndOrRename(&PMEDst.pme_Handle,
									  NULL,
									  &AfpExchangeName,
									  pVolDesc,
									  &PMEDst.pme_FullPath,
									  DstInRoot ? NULL : &PMEDst.pme_ParentPath,
									  NULL,
									  NULL);

		if (NT_SUCCESS(Status))
		{
			checkpoint = _CHKPOINT_XCHG_DSTTOTEMP;
		}
		else
		{
			break;
		}

		// Next, rename the source to the destination name
		Status = AfpIoMoveAndOrRename(&PMESrc.pme_Handle,
									  Move ? &hDstParent : NULL,
									  &PMEDst.pme_UTail,
									  pVolDesc,
									  &PMESrc.pme_FullPath,
									  SrcInRoot ? NULL : &PMESrc.pme_ParentPath,
									  Move ? &PMEDst.pme_FullPath : NULL,
									  (Move && !DstInRoot) ? &PMEDst.pme_ParentPath : NULL);

		if (NT_SUCCESS(Status))
		{
			checkpoint = _CHKPOINT_XCHG_SRCTODST;
		}
		else
		{
			break;
		}


		// Finally, rename the temporary name to the source name
		Status = AfpIoMoveAndOrRename(&PMEDst.pme_Handle,
									  Move ? &hSrcParent : NULL,
									  &PMESrc.pme_UTail,
									  pVolDesc,
									  &TempPath,
									  DstInRoot ? NULL : &PMEDst.pme_ParentPath,
									  Move ? &PMESrc.pme_FullPath : NULL,
									  (Move && !SrcInRoot) ? &PMESrc.pme_ParentPath : NULL);

		if (NT_SUCCESS(Status))
		{
			checkpoint = _CHKPOINT_XCHG_TEMPTOSRC;
		}
		else
		{
			break;
		}

		AfpRevertBack();
		RevertBack = False;

		// Swap the FileIds and FinderInfo in the AfpInfo streams
		Status = AfpSetAfpInfo(&PMESrc.pme_Handle,
							   FILE_BITMAP_FILENUM | FD_BITMAP_FINDERINFO,
							   &FDParmDst,
							   NULL,
							   NULL);

		ASSERT(NT_SUCCESS(Status));
		Status = AfpSetAfpInfo(&PMEDst.pme_Handle,
							   FILE_BITMAP_FILENUM | FD_BITMAP_FINDERINFO,
							   &FDParmSrc,
							   NULL,
							   NULL);

		ASSERT(NT_SUCCESS(Status));
		// Swap the creation dates on the files
		Status = AfpIoSetTimesnAttr(&PMESrc.pme_Handle,
									&FDParmDst._fdp_CreateTime,
									NULL,
									0,
									0,
									pVolDesc,
									&PMEDst.pme_FullPath);
		ASSERT(NT_SUCCESS(Status));
		Status = AfpIoSetTimesnAttr(&PMEDst.pme_Handle,
									&FDParmSrc._fdp_CreateTime,
									NULL,
									0,
									0,
									pVolDesc,
									&PMESrc.pme_FullPath);
		ASSERT(NT_SUCCESS(Status));

		// All the physical file info that we *didn't* swap on the real
		// files, we need to swap in the DFEntries
		AfpExchangeIdEntries(pVolDesc,
							 FDParmSrc._fdp_AfpId,
							 FDParmDst._fdp_AfpId);

		// Now, if either of the 2 files is open, we have to update the
		// OpenForkDesc to contain the correct FileId (we don't bother
		// updating the path since we don't care if Admin shows the
		// original name of the file, even though it has been renamed)
		AfpExchangeForkAfpIds(pVolDesc,
							  FDParmSrc._fdp_AfpId,
							  FDParmDst._fdp_AfpId);

		// update the cached src and dest parent dir mod times
		AfpCacheParentModTime(pVolDesc,
							  &hSrcParent,
							  NULL,
							  NULL,
							  FDParmSrc._fdp_ParentId);

        if (Move)
		{
			AfpCacheParentModTime(pVolDesc,
								  &hDstParent,
								  NULL,
								  NULL,
								  FDParmDst._fdp_ParentId);
		}

	} while (False);

	// Use the checkpoint value to undo any renames that
	// need undoing if there was an error
	if (!NT_SUCCESS(Status))
	{
		switch(checkpoint)
		{
			case _CHKPOINT_XCHG_TEMPTOSRC:
			{
				// Need to rename the original dest back to temp name
				Status2 = AfpIoMoveAndOrRename(&PMEDst.pme_Handle,
											   Move ? &hDstParent : NULL,
											   &AfpExchangeName,
											   pVolDesc,
											   &PMESrc.pme_FullPath,
											   SrcInRoot ? NULL : &PMESrc.pme_ParentPath,
											   Move ? &TempPath : NULL,
											   (Move && !DstInRoot) ? &PMEDst.pme_ParentPath : NULL);
				if (!NT_SUCCESS(Status2))
				{
					break;
				}

				// fall thru;
			}
			case _CHKPOINT_XCHG_SRCTODST:
			{
				// Need to rename the dest back to original src name
				Status2 = AfpIoMoveAndOrRename(&PMESrc.pme_Handle,
											   Move ? &hSrcParent : NULL,
											   &PMESrc.pme_UTail,
											   pVolDesc,
											   &PMEDst.pme_FullPath,
											   DstInRoot ? NULL : &PMEDst.pme_ParentPath,
											   Move ? &PMESrc.pme_FullPath : NULL,
											   (Move && !SrcInRoot) ? &PMESrc.pme_ParentPath : NULL);
				
				if (!NT_SUCCESS(Status2))
				{
					break;
				}

				// fall thru;
			}
			case _CHKPOINT_XCHG_DSTTOTEMP:
			{
				// Need to rename the temp back to original dest name
				Status2 = AfpIoMoveAndOrRename(&PMEDst.pme_Handle,
											   NULL,
											   &PMEDst.pme_UTail,
											   pVolDesc,
											   &TempPath,
											   DstInRoot ? NULL : &PMEDst.pme_ParentPath,
											   NULL,
											   NULL);
				// update the cached src parent dir mod time
				AfpCacheParentModTime(pVolDesc,
									  &hSrcParent,
									  NULL,
									  NULL,
									  FDParmSrc._fdp_ParentId);
		
				if (Move)
				{
					// update the cached dest parent dir mod time
					AfpCacheParentModTime(pVolDesc,
										  &hDstParent,
										  NULL,
										  NULL,
										  FDParmDst._fdp_ParentId);
				}

				break;
			}
			default:
			{
				break;
			}

		} // end switch
	}

	// Set the ReadOnly attribute back on the files if need be
	// NOTE: will we get a notify for this since we havn't closed
	// the handle yet?
	if (RestoreSrcRO)
		AfpIoSetTimesnAttr(&PMESrc.pme_Handle,
							NULL,
							NULL,
							FILE_ATTRIBUTE_READONLY,
							0,
							NULL,
							NULL);
	if (RestoreDstRO)
		AfpIoSetTimesnAttr(&PMEDst.pme_Handle,
							NULL,
							NULL,
							FILE_ATTRIBUTE_READONLY,
							0,
							NULL,
							NULL);

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
	AfpSwmrRelease(&pVolDesc->vds_ExchangeFilesLock);

	if (RevertBack)
		AfpRevertBack();

	if (PMESrc.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PMESrc.pme_Handle);

	if (PMEDst.pme_Handle.fsh_FileHandle != NULL)
		AfpIoClose(&PMEDst.pme_Handle);

	if (hSrcParent.fsh_FileHandle != NULL)
		AfpIoClose(&hSrcParent);

	if (hDstParent.fsh_FileHandle != NULL)
		AfpIoClose(&hDstParent);

	if ((TempPath.Buffer != NULL) &&
		(TempPath.Buffer != PathBuf))
		AfpFreeMemory(TempPath.Buffer);

	if (PMESrc.pme_FullPath.Buffer != NULL)
		AfpFreeMemory(PMESrc.pme_FullPath.Buffer);

	if (PMEDst.pme_FullPath.Buffer != NULL)
		AfpFreeMemory(PMEDst.pme_FullPath.Buffer);

	return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\gendisp.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	gendisp.h

Abstract:

	This module contains prototypes for generic dispatch routines.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/


#ifndef _GENDISP_
#define _GENDISP_

extern
AFPSTATUS FASTCALL
AfpFsdDispInvalidFunc(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispUnsupportedFunc(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispGetSrvrParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispGetSrvrMsg(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispGetUserInfo(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispLogin(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispLoginCont(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispLogout(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispChangePassword(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispMapName(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispMapId(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispOpenVol(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispOpenVol(
	IN	PSDA	pSda
);


AFPSTATUS FASTCALL
AfpFspDispGetVolParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispGetVolParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispSetVolParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispFlush(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispCloseVol(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispOpenDT(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFsdDispCloseDT(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispAddIcon(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispGetIcon(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispGetIconInfo(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispAddAppl(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispGetAppl(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispRemoveAppl(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispAddComment(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispGetComment(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispRemoveComment(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispFlushFork(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispOpenFork(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispCloseFork(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispGetForkParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispSetForkParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispRead(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispWrite(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispByteRangeLock(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispCreateFile(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispSetFileParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispCopyFile(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispCreateId(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispResolveId(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispDeleteId(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispCloseDir(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispExchangeFiles(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispOpenDir(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispCreateDir(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispEnumerate(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispSetDirParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispGetFileDirParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispSetFileDirParms(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispDelete(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispRename(
	IN	PSDA	pSda
);


extern
AFPSTATUS FASTCALL
AfpFspDispMoveAndRename(
	IN	PSDA	pSda
);

extern
AFPSTATUS FASTCALL
AfpFspDispCatSearch(
	IN	PSDA	pSda
);


// Equates to access request and response packets

#define	pReqPkt			((struct _RequestPacket *)(pSda->sda_ReqBlock))
#define	pModPkt			((struct _ModifiedPacket *)(pSda->sda_ReqBlock))
#define	pRspPkt			((struct _ResponsePacket *)(pSda->sda_ReplyBuf))

#define	SIZE_RESPPKT	sizeof(struct _ResponsePacket)
#endif	// _GENDISP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\idindex.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	idindex.h

Abstract:

	This module contains the file and directory id structures.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _IDINDEX_
#define _IDINDEX_

// AFP_IDDBHDR_VERSION2 was an experimental version.
#define AFP_IDDBHDR_VERSION1	0x00010000
#define AFP_IDDBHDR_VERSION2	0x00020000
#define AFP_IDDBHDR_VERSION3	0x00030000
#define AFP_IDDBHDR_VERSION4	0x00040000
#define AFP_IDDBHDR_VERSION5	0x00050000
#define AFP_IDDBHDR_VERSION		AFP_IDDBHDR_VERSION5

typedef struct _IdDbHeader				// Database header
{
	DWORD		idh_Signature;			// Signature
	DWORD		idh_Version;			// Version number
	DWORD		idh_LastId;				// Highest id that is assigned
	AFPTIME		idh_CreateTime;			// Creation time for this volume
	AFPTIME		idh_ModifiedTime;		// Modified time for this volume
	AFPTIME		idh_BackupTime;			// Backup time for this volume
} IDDBHDR, *PIDDBHDR;
// IdDb header is followed by a ULONG count of entries, then the DISKENTRies

#define VALID_DFE(pDfe)		((pDfe) != NULL)

struct _DfeBlock;
struct _DirFileEntry;

#define	MAX_CHILD_HASH_BUCKETS	6

typedef	struct _DirEntry
{
	// NOTE: Keep the ChildDir and ChildFile entries together and in this order
	//		 The code in AfpAddDfEntry depends on this to efficiently zero it out
	//		 Also de_ChildDir is accessed as de_ChildFile[-1] !!!
	struct _DirFileEntry *	de_ChildDir;		// First child in the dir list
	struct _DirFileEntry *	de_ChildFile[MAX_CHILD_HASH_BUCKETS];
												// File 'children' are hashed for faster lookup
	DWORD					de_Access;			// Combined access bits
#ifdef	AGE_DFES
	AFPTIME					de_LastAccessTime;	// Time when this DFE was last accessed
												// Valid for directories only
	LONG					de_ChildForkOpenCount;// Count of open forks within this directory
#endif
} DIRENTRY, *PDIRENTRY;

// Owner access mask (SFI vs. SFO)
#define	DE_OWNER_ACCESS(_pDE)	*((PBYTE)(&(_pDE)->de_Access) + 0)
// Group access mask (SFI vs. SFO)
#define	DE_GROUP_ACCESS(_pDE)	*((PBYTE)(&(_pDE)->de_Access) + 1)
// World access mask (SFI vs. SFO)
#define	DE_WORLD_ACCESS(_pDE)	*((PBYTE)(&(_pDE)->de_Access) + 2)

typedef struct _DirFileEntry
{
	// The dfe_Overflow is overloaded with dfe_NextFree for use by the block
	// allocation package for the DFEs.
#define	dfe_NextFree		dfe_NextOverflow
	struct _DirFileEntry *	dfe_NextOverflow;	// Overflow links
	struct _DirFileEntry **	dfe_PrevOverflow;	// Overflow links
	struct _DirFileEntry *	dfe_NextSibling;	// Next sibling.
	struct _DirFileEntry **	dfe_PrevSibling;	// Previous sibling.
	struct _DirFileEntry *	dfe_Parent;			// Parent entry

	DWORD					dfe_AfpId;			// Afp FileId or DirId (from AfpInfo)
	AFPTIME					dfe_BackupTime;		// Backup time for the file/dir (from AfpInfo)
												// (Volume backup time is stored
												// in the AFP_IdIndex stream)
	AFPTIME					dfe_CreateTime;		// Creation time

	TIME					dfe_LastModTime;	// Last modify time (as a LARGE_INTEGER)

	SHORT					dfe_DirDepth;		// Parent of root at -1, root at 0
	USHORT					dfe_Flags;			// file, dir or file with id

	USHORT					dfe_NtAttr;			// NT Attributes (FILE_ATTRIBUTE_VALID_FLAGS)
	USHORT					dfe_AfpAttr;		// Attributes mask (From AfpInfo)

	union
	{
		// File specific information
		struct									// For Files Only
		{
			DWORD			dfe_DataLen;		// Data fork length
			DWORD			dfe_RescLen;		// Resource fork length
		};
		// Directory specific information
		struct									// For Directories Only
		{
			DWORD			dfe_DirOffspring;	// count of dir offspring
			DWORD			dfe_FileOffspring;	// count of file offspring
		};
	};
	FINDERINFO				dfe_FinderInfo;		// Finder Info (32 bytes) (from AfpInfo)

	// NOTE: When Dfes are copied as a structure, the fields below are NOT TO BE COPIED.
	//		 The fields above should be.
#define	dfe_CopyUpto		dfe_UnicodeName

	UNICODE_STRING			dfe_UnicodeName;	// 'Munged' Unicode Name of the entity

	DWORD					dfe_NameHash;		// Hash value for the upcased munged Unicode name

	// For directories, the DirEntry structure follows this structure. The space for
	// this is allocated immediately after the DFENTRY structure and before the space
	// for the name strings. For files it is NULL. This pointer should not be copied
	// as well !!!
	PDIRENTRY				dfe_pDirEntry;		// Directory related fields
												// NULL for files
} DFENTRY, *PDFENTRY;

// Owner access mask (SFI vs. SFO)
#define	DFE_OWNER_ACCESS(_pDFE)	*((PBYTE)(&(_pDFE)->dfe_pDirEntry->de_Access) + 0)
// Group access mask (SFI vs. SFO)
#define	DFE_GROUP_ACCESS(_pDFE)	*((PBYTE)(&(_pDFE)->dfe_pDirEntry->de_Access) + 1)
// World access mask (SFI vs. SFO)
#define	DFE_WORLD_ACCESS(_pDFE)	*((PBYTE)(&(_pDFE)->dfe_pDirEntry->de_Access) + 2)

typedef	struct _EnumIdAndType
{
	DWORD			eit_Id;
	DWORD			eit_Flags;
} EIT, *PEIT;

// There is the result of enumeration of a directory for this session and is stored
// within the connection descriptor. This is purely for performance reasons. This is
// deleted whenever an api other than AfpEnumerate is called and a result is around.
typedef	struct _EnumDir
{
	DWORD			ed_ParentDirId;		// Anchor point
	DWORD			ed_Bitmap;			// Combination of file & dir bitmaps
	LONG			ed_ChildCount;		// Count of children of the dir being enumerated
	AFPTIME			ed_TimeStamp;		// Time at which created

	PEIT			ed_pEit;			// list of actual entries
	ANSI_STRING		ed_PathName;		// This is the name as passed by the client
										// and is not normalised.
	USHORT			ed_BadCount;		// Count of failed entities
	BYTE			ed_PathType;		// Long name or short name
} ENUMDIR, *PENUMDIR;

typedef	struct _CatSearchSpec
{
	BYTE			__StructLength;
	BYTE			__FillerOrFileDir;
	// The rest of the parameters follow
} CATSEARCHSPEC, *PCATSEARCHSPEC;

// Must be 16 bytes as per AfpCatSearch API
typedef struct _CatalogPosition
{
	USHORT			cp_Flags;			// if zero, then start search from beginning
	USHORT			cp_usPad1;
	DWORD			cp_CurParentId;
	DWORD			cp_NextFileId;
	AFPTIME			cp_TimeStamp;
} CATALOGPOSITION, *PCATALOGPOSITION;

#define CATFLAGS_SEARCHING_FILES		0x0001
#define CATFLAGS_SEARCHING_DIRCHILD		0x0002
#define CATFLAGS_SEARCHING_SIBLING		0x0004
#define	CATFLAGS_WRITELOCK_REQUIRED 	0x0008
#define	CATFLAGS_VALID					(CATFLAGS_SEARCHING_FILES		|	\
										 CATFLAGS_SEARCHING_DIRCHILD	|	\
										 CATFLAGS_SEARCHING_SIBLING		|	\
										 CATFLAGS_WRITELOCK_REQUIRED)

// Maximum time that a mac can hold onto a catsearch position and still
// have the search pickup from there instead of the beginning of the catalog
#define MAX_CATSEARCH_TIME				3600	// In seconds


// DFE_FLAGS_xxxx values for dfe_Flags field of DFENTRY structure
#define DFE_FLAGS_FILE_WITH_ID			0x0100
#define DFE_FLAGS_FILE_NO_ID			0x0200
#define DFE_FLAGS_DIR					0x0400
#define DFE_FLAGS_DFBITS				(DFE_FLAGS_FILE_WITH_ID | \
										 DFE_FLAGS_FILE_NO_ID	| \
										 DFE_FLAGS_DIR | \
                                         DFE_FLAGS_HAS_COMMENT)
#define DFE_FLAGS_HAS_COMMENT			0x0800
#define DFE_FLAGS_INIT_COMPLETED        0x20
#define DFE_FLAGS_ENUMERATED			0x8000

// Encode the child and sibling pointers
#define DFE_FLAGS_HAS_CHILD				0x1000	// Used for reading in IdDb from disk
#define DFE_FLAGS_HAS_SIBLING			0x2000	// Used for reading in IdDb from disk
#define DFE_FLAGS_CSENCODEDBITS			(DFE_FLAGS_HAS_CHILD | DFE_FLAGS_HAS_SIBLING | DFE_FLAGS_HAS_COMMENT)
#define DFE_FLAGS_NAMELENBITS			0x001F	// Encodes the length of the longname
												// which is 31 *characters* max

#define DFE_FLAGS_VALID_DSKBITS			(DFE_FLAGS_CSENCODEDBITS	| \
										 DFE_FLAGS_NAMELENBITS		| \
										 DFE_FLAGS_HAS_COMMENT)

// Valid only for directories when their files have been enumerated from disk
// and now all have cached DFEs in the IDDB tree structure
#define DFE_FLAGS_FILES_CACHED 			0x4000

// DAlreadyOpen and RAlreadyOpen flags for a File
#define DFE_FLAGS_R_ALREADYOPEN			0x0040
#define	DFE_FLAGS_D_ALREADYOPEN			0x0080
#define DFE_FLAGS_OPEN_BITS				(DFE_FLAGS_D_ALREADYOPEN | \
										 DFE_FLAGS_R_ALREADYOPEN)

	
typedef struct _DiskEntry
{
	DWORD		dsk_AfpId;
	AFPTIME		dsk_CreateTime;		// File Creation time
	TIME		dsk_LastModTime;	// Last modify time
	FINDERINFO	dsk_FinderInfo;		// Finder Info (32 bytes) (from AfpInfo)
	AFPTIME		dsk_BackupTime;		// Backup time for the file/dir (from AfpInfo)
									// (Volume backup time is stored
									// in the AFP_IdIndex stream)

	union
	{
		DWORD	dsk_DataLen;		// Data fork length
		DWORD	dsk_Access;			// Combined access rights
	};
	DWORD		dsk_RescLen;		// Resource fork length
	USHORT		dsk_Flags;			// DFE_FLAGS_XXXX
	USHORT		dsk_AfpAttr;		// Attributes mask (From AfpInfo)
	USHORT		dsk_NtAttr;			// From FileAttributes

	USHORT		dsk_Signature;		// AFP_DISKENTRY_SIGNATURE
	WCHAR		dsk_Name[2];		// Longname in 'munged' Unicode will follow and be padded
									// out, if necessary, to DWORD boundry (max 64 bytes)
} DISKENTRY, *PDISKENTRY;

#define AFP_DISKENTRY_SIGNATURE		*(PUSHORT)"::" // illegal name character

// size of buffer used to read-in/write-out the IdDb entries from/to disk
#define	IDDB_UPDATE_BUFLEN				(16*1024)

// Round the length to 4*N
#define DWLEN(_b)	(((_b) + sizeof(DWORD) - 1) & ~(sizeof(DWORD) - 1))

// #define	DFE_IS_DIRECTORY(_pDFE)		(((_pDFE)->dfe_Flags & DFE_FLAGS_DIR) ? True : False)
#define	DFE_IS_DIRECTORY(_pDFE)			((_pDFE)->dfe_pDirEntry != NULL)

// #define	DFE_IS_FILE(_pDFE)			(((_pDFE)->dfe_Flags & (DFE_FLAGS_FILE_NO_ID | DFE_FLAGS_FILE_WITH_ID)) ? True : False)
#define	DFE_IS_FILE(_pDFE)				((_pDFE)->dfe_pDirEntry == NULL)

#define	DFE_IS_FILE_WITH_ID(_pDFE)		(((_pDFE)->dfe_Flags & DFE_FLAGS_FILE_WITH_ID) ? True : False)

#define	DFE_IS_ROOT(_pDFE)				((_pDFE)->dfe_AfpId == AFP_ID_ROOT)

#define	DFE_IS_PARENT_OF_ROOT(_pDFE)	((_pDFE)->dfe_AfpId == AFP_ID_PARENT_OF_ROOT)

#define DFE_IS_NWTRASH(_pDFE)			((_pDFE)->dfe_AfpId == AFP_ID_NETWORK_TRASH)

#define	DFE_SET_DIRECTORY(_pDFE, _ParentDepth)				\
	{														\
		((_pDFE)->dfe_DirDepth = _ParentDepth + 1);			\
		((_pDFE)->dfe_Flags |= DFE_FLAGS_DIR);				\
	}

#define	DFE_SET_FILE(_pDFE)				((_pDFE)->dfe_Flags |= DFE_FLAGS_FILE_NO_ID)

#define	DFE_SET_FILE_ID(_pDFE)			((_pDFE)->dfe_Flags |= DFE_FLAGS_FILE_WITH_ID)

#define	DFE_CLR_FILE_ID(_pDFE)			((_pDFE)->dfe_Flags &= ~DFE_FLAGS_FILE_WITH_ID)

// update just the AFPinfo in the dfentry
#define DFE_UPDATE_CACHED_AFPINFO(_pDFE, pAfpInfo)				\
	{															\
		(_pDFE)->dfe_BackupTime = (pAfpInfo)->afpi_BackupTime;	\
		(_pDFE)->dfe_FinderInfo = (pAfpInfo)->afpi_FinderInfo;	\
		(_pDFE)->dfe_AfpAttr = (pAfpInfo)->afpi_Attributes;		\
		if ((_pDFE)->dfe_Flags & DFE_FLAGS_DIR)					\
		{														\
			DFE_OWNER_ACCESS(_pDFE) = (pAfpInfo)->afpi_AccessOwner;	\
			DFE_GROUP_ACCESS(_pDFE) = (pAfpInfo)->afpi_AccessGroup;	\
			DFE_WORLD_ACCESS(_pDFE) = (pAfpInfo)->afpi_AccessWorld;	\
		}														\
	}


#define DFE_SET_COMMENT(_pDFE)			((_pDFE)->dfe_Flags |= DFE_FLAGS_HAS_COMMENT)

#define DFE_CLR_COMMENT(_pDFE)			((_pDFE)->dfe_Flags &= ~DFE_FLAGS_HAS_COMMENT)

// Check to see if this entry was enumerated on an NTFS directory
#define DFE_HAS_BEEN_SEEN(_pDFE)		((_pDFE)->dfe_Flags & DFE_FLAGS_ENUMERATED)

#define DFE_MARK_UNSEEN(_pDFE)			((_pDFE)->dfe_Flags &= ~DFE_FLAGS_ENUMERATED)

#define DFE_MARK_AS_SEEN(_pDFE)			((_pDFE)->dfe_Flags |= DFE_FLAGS_ENUMERATED)

// Directories only
#define DFE_CHILDREN_ARE_PRESENT(_pDFE) ((_pDFE)->dfe_Flags & DFE_FLAGS_FILES_CACHED)

// Directories only
#define DFE_MARK_CHILDREN_PRESENT(_pDFE) ((_pDFE)->dfe_Flags |= DFE_FLAGS_FILES_CACHED)

#define	DFE_FILE_HAS_SIBLING(_pDFE, _fbi, _pfHasSibling)			\
	{																\
		DWORD		_i;												\
		PDIRENTRY	_pDirEntry;										\
																	\
		*(_pfHasSibling) = False;									\
		if (((_pDFE)->dfe_NextSibling != NULL)	||					\
			((_pDFE)->dfe_Parent->dfe_pDirEntry->de_ChildDir != NULL)) \
		{															\
			*(_pfHasSibling) = True;								\
		}															\
		else														\
		{															\
			_pDirEntry = (_pDFE)->dfe_Parent->dfe_pDirEntry;	 	\
			ASSERT(_pDirEntry != NULL);								\
			for (_i = (_fbi) + 1;									\
				 _i < MAX_CHILD_HASH_BUCKETS;						\
				 _i++)												\
			{														\
				if (_pDirEntry->de_ChildFile[_i] != NULL)			\
				{													\
					*(_pfHasSibling) = True;						\
					break;											\
				}													\
			}														\
		}															\
	}

#define	HASH_DIR_ID(Id, _pVolDesc)		((Id) & ((_pVolDesc)->vds_DirHashTableSize-1))
#define	HASH_FILE_ID(Id, _pVolDesc)		((Id) & ((_pVolDesc)->vds_FileHashTableSize-1))
#define	HASH_CACHE_ID(Id)				((Id) & (IDINDEX_CACHE_ENTRIES-1))

#define	QUAD_SIZED(_X_)			(((_X_) % 8) == 0)

// Values for access checking
#define	ACCESS_READ						1
#define	ACCESS_WRITE					2

extern
NTSTATUS
AfpDfeInit(
	VOID
);

extern
VOID
AfpDfeDeInit(
	VOID
);

extern
PDFENTRY
AfpFindDfEntryById(
	IN	struct _VolDesc *			pVolDesc,
	IN	DWORD						Id,
	IN	DWORD						EntityMask
);

extern
PDFENTRY
AfpFindEntryByUnicodeName(
	IN	struct _VolDesc *			pVolDesc,
	IN	PUNICODE_STRING				pName,
	IN	DWORD						PathType,
	IN	PDFENTRY					pDfeParent,
	IN	DWORD						EntityMask
);

extern
PDFENTRY
AfpAddDfEntry(
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDfeParent,
	IN	PUNICODE_STRING				pUName,
	IN	BOOLEAN						Directory,
	IN	DWORD						AfpId			OPTIONAL
);

extern
PDFENTRY
AfpRenameDfEntry(
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDfEntry,
	IN	PUNICODE_STRING				pNewName
);

extern
PDFENTRY
AfpMoveDfEntry(				
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDfEntry,
	IN	PDFENTRY					pNewParentDfE,
	IN	PUNICODE_STRING				pNewName		OPTIONAL
);

extern
VOID FASTCALL
AfpDeleteDfEntry(
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDfE
);

extern
VOID
AfpExchangeIdEntries(
	IN	struct _VolDesc *			pVolDesc,
	IN	DWORD						AfpId1,
	IN	DWORD						AfpId2
);

extern
VOID FASTCALL
AfpPruneIdDb(
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDfeTarget
);

extern
NTSTATUS FASTCALL
AfpInitIdDb(
	IN	struct _VolDesc *			pVolDesc,
    OUT BOOLEAN         *           pfNewVolume,
    OUT BOOLEAN         *           pfVerifyIndex
);

extern
VOID FASTCALL
AfpFreeIdIndexTables(
	IN	struct _VolDesc *			pVolDesc
);

extern
AFPSTATUS
AfpEnumerate(
	IN	struct _ConnDesc *			pConnDesc,
	IN	DWORD						ParentDirId,
	IN	PANSI_STRING				pPath,
	IN	DWORD						BitmapF,
	IN	DWORD						BitmapD,
	IN	BYTE						PathType,
	IN	DWORD						DFFlags,
	OUT PENUMDIR *					ppEnumDir
);

extern
AFPSTATUS
AfpSetDFFileFlags(
	IN	struct _VolDesc *			pVolDesc,
	IN	DWORD						AfpId,
	IN	DWORD						FlagSet		OPTIONAL,
	IN	BOOLEAN						SetFileId,
	IN	BOOLEAN						ClrFileId
);

extern
VOID
AfpChangeNotifyThread(
	IN	PVOID						pContext
);

extern
VOID FASTCALL
AfpProcessChangeNotify(		
	IN	struct _VolumeNotify *		pVolNotify
);

extern
VOID
AfpQueuePrivateChangeNotify(
	IN	struct _VolDesc *			pVolDesc,
	IN	PUNICODE_STRING				pName,
	IN	PUNICODE_STRING				pPath,
	IN	DWORD						ParentId
);

extern
BOOLEAN FASTCALL
AfpShouldWeIgnoreThisNotification(
	IN	struct _VolumeNotify *		pVolNotify
);

extern
VOID
AfpQueueOurChange(
	IN	struct _VolDesc *			pVolDesc,
	IN	DWORD						Action,
	IN	PUNICODE_STRING				pPath,
	IN  PUNICODE_STRING				pParentPath	OPTIONAL
);

extern
VOID
AfpDequeueOurChange(
		IN struct _VolDesc *   		pVolDesc,
		IN DWORD                    Action,
		IN PUNICODE_STRING          pPath,
		IN PUNICODE_STRING          pParentPath OPTIONAL
);

extern
NTSTATUS FASTCALL
AddToDelayedNotifyList(
	IN  struct _VolDesc *			pVolDesc,
	IN  PUNICODE_STRING				pUName
);

extern
NTSTATUS
RemoveFromDelayedNotifyList(
	IN  struct _VolDesc *			pVolDesc,
	IN  PUNICODE_STRING				pUName,
	IN  PFILE_NOTIFY_INFORMATION    pFNInfo
);

extern
NTSTATUS
CheckAndProcessDelayedNotify(
	IN  struct _VolDesc *			pVolDesc,
	IN  PUNICODE_STRING				pUName,
	IN  PUNICODE_STRING				pUNewname,
	IN  PUNICODE_STRING				pUParent
);

extern
VOID
AfpCacheParentModTime(
	IN	struct _VolDesc *			pVolDesc,
	IN	PFILESYSHANDLE				pHandle		OPTIONAL,	// if pPath not supplied
	IN	PUNICODE_STRING				pPath		OPTIONAL,	// if pHandle not supplied
	IN	PDFENTRY					pDfeParent	OPTIONAL,	// if ParentId not supplied
	IN	DWORD						ParentId	OPTIONAL	// if pDfeParent not supplied
);

extern
AFPSTATUS
AfpCatSearch(
	IN	struct _ConnDesc *			pConnDesc,
	IN	PCATALOGPOSITION			pCatPosition,
	IN	DWORD						Bitmap,
	IN	DWORD						FileBitmap,
	IN	DWORD						DirBitmap,
	IN	struct _FileDirParms *		pFDParm1,
	IN	struct _FileDirParms *		pFDParm2,
	IN	PUNICODE_STRING				pMatchString	OPTIONAL,
	IN OUT	PDWORD					pCount,
	IN	SHORT						Buflen,
	OUT	PSHORT						pSizeLeft,
	OUT	PBYTE						pResults,
	OUT	PCATALOGPOSITION			pNewCatPosition
);

#ifdef	AGE_DFES

extern
VOID FASTCALL
AfpAgeDfEntries(
	IN	struct _VolDesc *			pVolDesc
);

#endif

#define	REENUMERATE		   			0x0001
#define	GETDIRSKELETON				0x0002
#define	GETFILES	    			0x0004
#define	GETENTIRETREE   			0x0008

extern
NTSTATUS
AfpCacheDirectoryTree(
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDFETreeRoot,
	IN	DWORD						Method,
	IN	PFILESYSHANDLE				phRootDir		OPTIONAL,
	IN	PUNICODE_STRING				pDirPath		OPTIONAL
);

extern
AFPSTATUS FASTCALL
AfpOurChangeScavenger(
	IN	struct _VolDesc *			pVolDesc
);

extern
VOID FASTCALL
AfpFlushIdDb(
	IN	struct _VolDesc *			pVolDesc,
	IN	PFILESYSHANDLE				phIdDb
);

extern
VOID
AfpGetDirFileHashSizes(
	IN	struct _VolDesc *	pVolDesc,
    OUT PDWORD              pdwDirHashSz,
    OUT PDWORD              pdwFileHashSz
);

#ifdef IDINDEX_LOCALS

#define	afpConvertBasicToBothDirInfo(_pFBasInfo, _pFBDInfo)			\
{																	\
	(_pFBDInfo)->CreationTime = (_pFBasInfo)->CreationTime;			\
	(_pFBDInfo)->LastWriteTime = (_pFBasInfo)->LastWriteTime;		\
	(_pFBDInfo)->ChangeTime = (_pFBasInfo)->ChangeTime;				\
	(_pFBDInfo)->FileAttributes = (_pFBasInfo)->FileAttributes;		\
	(_pFBDInfo)->EndOfFile.QuadPart = 0;																\
}

#undef	EQU
#ifdef	_IDDB_GLOBALS_
#define	IDDBGLOBAL
#define	EQU				=
#else
#define	IDDBGLOBAL		extern
#define	EQU				; / ## /
#endif

// This bit on a Notify action indicates it is a simulated notify. Volume
// modified time is not updated when such a notify comes in
#define	AFP_ACTION_PRIVATE		0x80000000

// DFEs come in four sizes. This helps in efficiently managing them in a block
// package (see later). THESE SIZES NEED TO BE 4*N, else we run into alignment
// faults on architectures that require it.
#define	DFE_INDEX_TINY			0
#define	DFE_INDEX_SMALL			1
#define	DFE_INDEX_MEDIUM		2
#define	DFE_INDEX_LARGE			3

//
// Make sure each of the sizes below (XXX_U) are multiple of 8
//
#define	DFE_SIZE_TINY			8		// These are lengths for ANSI names
#define	DFE_SIZE_SMALL			12		//		- ditto -
#define	DFE_SIZE_MEDIUM			20		//		- ditto -
#define	DFE_SIZE_LARGE			32		//		- ditto -	corres. to AFP_FILENAME_LEN

#define	DFE_SIZE_TINY_U			DFE_SIZE_TINY*sizeof(WCHAR)		// These are lengths for UNICODE names
#define	DFE_SIZE_SMALL_U		DFE_SIZE_SMALL*sizeof(WCHAR)	//		- ditto -
#define	DFE_SIZE_MEDIUM_U		DFE_SIZE_MEDIUM*sizeof(WCHAR)	//		- ditto -
#define	DFE_SIZE_LARGE_U		DFE_SIZE_LARGE*sizeof(WCHAR)	//		- ditto -	corres. to AFP_FILENAME_LEN

#define	ASIZE_TO_INDEX(_Size)												\
		(((_Size) <= DFE_SIZE_TINY) ? DFE_INDEX_TINY :						\
						(((_Size) <= DFE_SIZE_SMALL) ? DFE_INDEX_SMALL :	\
						 (((_Size) <= DFE_SIZE_MEDIUM) ? DFE_INDEX_MEDIUM : DFE_INDEX_LARGE)))

#define	USIZE_TO_INDEX(_Size)												\
		(((_Size) <= DFE_SIZE_TINY_U) ? DFE_INDEX_TINY :					\
						(((_Size) <= DFE_SIZE_SMALL_U) ? DFE_INDEX_SMALL :	\
						 (((_Size) <= DFE_SIZE_MEDIUM_U) ? DFE_INDEX_MEDIUM : DFE_INDEX_LARGE)))

#define	ALLOC_DFE(Index, fDir)	afpAllocDfe(Index, fDir)
#define FREE_DFE(pDfEntry)		afpFreeDfe(pDfEntry)


LOCAL DWORD FASTCALL
afpGetNextId(
	IN	struct _VolDesc *			pVolDesc
);

LOCAL
NTSTATUS FASTCALL
afpSeedIdDb(
	IN	struct _VolDesc *			pVolDesc
);

LOCAL
VOID
afpPackSearchParms(
	IN	PDFENTRY					pDfe,
	IN	DWORD						Bitmap,
	IN	PBYTE						pBuf
);

LOCAL
NTSTATUS FASTCALL
afpReadIdDb(
	IN	struct _VolDesc *			pVolDesc,
	IN	PFILESYSHANDLE				pfshIdDb,
	OUT	BOOLEAN         *           pfVerifyIndex
);

VOID
afpAddDfEntryAndCacheInfo(
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDfeParent,
	IN	PUNICODE_STRING				pUName,			// munged unicode name
	IN	PFILESYSHANDLE				pfshParentDir,	// open handle to parent directory
	IN	PFILE_BOTH_DIR_INFORMATION	pFBDInfo,		// from enumerate
	IN	PUNICODE_STRING				pNotifyPath,	// to filter out our own AFP_AfpInfo change notifies
	IN	PDFENTRY	*				ppDfEntry,
	IN	BOOLEAN						CheckDuplicate
);

VOID
afpVerifyDFE(
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDfeParent,
	IN	PUNICODE_STRING				pUName,			// munged unicode name
	IN	PFILESYSHANDLE				pfshParentDir,	// open handle to parent directory
	IN	PFILE_BOTH_DIR_INFORMATION	pFBDInfo,		// from enumerate
	IN	PUNICODE_STRING				pNotifyPath,	// to filter out our own AFP_AfpInfo change notifies
	IN	PDFENTRY	*				ppDfEntry
);

PDFENTRY
afpFindEntryByNtPath(
	IN	struct _VolDesc *			pVolDesc,
	IN	DWORD						ChangeAction,	// if ADDED then lookup parent DFE
	IN	PUNICODE_STRING				pPath,
	OUT PUNICODE_STRING				pParent,
	OUT PUNICODE_STRING				pTail
);

PDFENTRY
afpFindEntryByNtName(
	IN	struct _VolDesc *			pVolDesc,
	IN	PUNICODE_STRING				pName,
	IN	PDFENTRY					pDfeParent		// pointer to parent DFENTRY
);

VOID FASTCALL
afpProcessPrivateNotify(
	IN	struct _VolumeNotify *		pVolNotify
);

VOID FASTCALL
afpActivateVolume(
	IN	struct _VolDesc *			pVolDesc
);

VOID
afpRenameInvalidWin32Name(
	IN	PFILESYSHANDLE				phRootDir,
	IN	BOOLEAN						IsDir,
	IN PUNICODE_STRING				pName
);

#define	afpInitializeIdDb(_pVolDesc)									\
	{																	\
		AFPTIME		CurrentTime;										\
		PDFENTRY	pDfEntry;											\
																		\
		/* RO volumes don't use the network trash folder at all */		\
		(_pVolDesc)->vds_LastId	= AFP_ID_NETWORK_TRASH;					\
																		\
		AfpGetCurrentTimeInMacFormat(&CurrentTime);						\
		(_pVolDesc)->vds_CreateTime = CurrentTime;						\
		(_pVolDesc)->vds_ModifiedTime = CurrentTime;					\
		(_pVolDesc)->vds_BackupTime = BEGINNING_OF_TIME;				\
																		\
		/* Create a DFE for the root directory */						\
		afpCreateParentOfRoot(_pVolDesc, &pDfEntry);					\
	}


#ifdef AGE_DFES

#define	afpCreateParentOfRoot(_pVolDesc, _ppDfEntry)					\
	{																	\
		PDFENTRY	pDFE;												\
        struct _DirFileEntry ** _DfeDirBucketStart;                     \
																		\
		/*																\
		 * add the parent of root to the id index.						\
		 * This has to be done here										\
		 * (i.e. cannot call AfpAddDfEntry for parentofroot).			\
		 */																\
																		\
		if ((*(_ppDfEntry) = ALLOC_DFE(0, True)) != NULL)				\
		{																\
			pDFE = *(_ppDfEntry);										\
																		\
			(_pVolDesc)->vds_NumFileDfEntries = 0;						\
			(_pVolDesc)->vds_NumDirDfEntries = 0;						\
			pDFE->dfe_Flags = DFE_FLAGS_DIR | DFE_FLAGS_FILES_CACHED;	\
			pDFE->dfe_DirDepth = -1;									\
			pDFE->dfe_Parent = NULL;									\
			pDFE->dfe_NextOverflow = NULL;								\
																		\
			/* Initialize the DirEntry for ParentOfRoot */				\
			ASSERT((FIELD_OFFSET(DIRENTRY, de_ChildFile) -				\
					FIELD_OFFSET(DIRENTRY, de_ChildDir)) == sizeof(PVOID));\
																		\
			/* These fields are relevant to directories only */			\
			pDFE->dfe_pDirEntry->de_LastAccessTime = BEGINNING_OF_TIME;	\
			pDFE->dfe_pDirEntry->de_ChildForkOpenCount = 0;				\
																		\
			/*															\
			 * The parent of root has no siblings and this should		\
			 * never be referenced										\
			 */															\
			pDFE->dfe_NameHash = 0;										\
			pDFE->dfe_NextSibling = NULL;								\
			pDFE->dfe_PrevSibling = NULL;								\
			pDFE->dfe_AfpId = AFP_ID_PARENT_OF_ROOT;					\
			pDFE->dfe_DirOffspring = pDFE->dfe_FileOffspring = 0;		\
																		\
			/* link it into the hash buckets */							\
            _DfeDirBucketStart = (_pVolDesc)->vds_pDfeDirBucketStart;   \
			AfpLinkDoubleAtHead(_DfeDirBucketStart[HASH_DIR_ID(AFP_ID_PARENT_OF_ROOT,_pVolDesc)],\
								pDFE,									\
								dfe_NextOverflow,						\
								dfe_PrevOverflow);						\
		}																\
	}

#else

#define	afpCreateParentOfRoot(_pVolDesc, _ppDfEntry)					\
	{																	\
		PDFENTRY	pDfEntry;											\
        struct _DirFileEntry ** _DfeDirBucketStart;                     \
																		\
		/*																\
		 * add the parent of root to the id index.						\
		 * This has to be done here										\
		 *	(i.e. cannot call AfpAddDfEntry for parentofroot).			\
		 */																\
																		\
		if ((*(_ppDfEntry) = ALLOC_DFE(0, True)) != NULL)				\
		{																\
			pDfEntry = *(_ppDfEntry);									\
																		\
			(_pVolDesc)->vds_NumFileDfEntries = 0;						\
			(_pVolDesc)->vds_NumDirDfEntries = 0;						\
			pDfEntry->dfe_Flags = DFE_FLAGS_DIR | DFE_FLAGS_FILES_CACHED;\
			pDfEntry->dfe_DirDepth = -1;								\
			pDfEntry->dfe_Parent = NULL;								\
			pDfEntry->dfe_NextOverflow = NULL;							\
																		\
			/* Initialize the DirEntry for ParentOfRoot */				\
			ASSERT((FIELD_OFFSET(DIRENTRY, de_ChildFile) -				\
					FIELD_OFFSET(DIRENTRY, de_ChildDir)) == sizeof(PVOID));\
																		\
			/* The parent of root has no siblings and this should never be referenced */ \
			pDfEntry->dfe_NameHash = 0;									\
			pDfEntry->dfe_NextSibling = NULL;							\
			pDfEntry->dfe_PrevSibling = NULL;							\
			pDfEntry->dfe_AfpId = AFP_ID_PARENT_OF_ROOT;				\
			pDfEntry->dfe_DirOffspring = pDfEntry->dfe_FileOffspring = 0;\
																		\
			/* link it into the hash buckets */							\
            _DfeDirBucketStart = (_pVolDesc)->vds_pDfeDirBucketStart;   \
			AfpLinkDoubleAtHead(_DfeDirBucketStart[HASH_DIR_ID(AFP_ID_PARENT_OF_ROOT,_pVolDesc)],\
								pDfEntry,								\
								dfe_NextOverflow,						\
								dfe_PrevOverflow);						\
		}																\
	}

#endif

#define	afpHashUnicodeName(_pUnicodeName, _pHashValue)					\
	{																	\
		DWORD				j;											\
		UNICODE_STRING		upcaseName;									\
		WCHAR				buffer[AFP_LONGNAME_LEN+1];					\
		PDWORD				pbuf = NULL;								\
																		\
		AfpSetEmptyUnicodeString(&upcaseName, sizeof(buffer), buffer);	\
		RtlUpcaseUnicodeString(&upcaseName, _pUnicodeName, False);		\
		j = upcaseName.Length/sizeof(WCHAR);							\
		buffer[j] = UNICODE_NULL;										\
		pbuf = (PDWORD)buffer;											\
		j /= (sizeof(DWORD)/sizeof(WCHAR));								\
																		\
		for (*(_pHashValue) = 0; j > 0; j--, pbuf++)					\
		{																\
			*(_pHashValue) = (*(_pHashValue) << 3) + *pbuf;				\
		}																\
	}

#ifdef	SORT_DFE_BY_HASH
#define	afpFindDFEByUnicodeNameInSiblingList(_pVolDesc, _pDfeParent, _pName, _ppDfEntry, _EntityMask) \
	{																	\
		DWORD		NameHash; 											\
		PDFENTRY	pD, pF;												\
		BOOLEAN		Found, fFiles;										\
																		\
		afpHashUnicodeName(_pName, &NameHash);							\
																		\
		pD = (_pDfeParent)->dfe_pDirEntry->de_ChildDir;					\
		if (((_EntityMask) & (DFE_ANY | DFE_DIR)) == 0)					\
			pD = NULL;													\
																		\
		pF = NULL;														\
		if ((_EntityMask) & (DFE_ANY | DFE_FILE))						\
			pF = (_pDfeParent)->dfe_pDirEntry->de_ChildFile[NameHash % MAX_CHILD_HASH_BUCKETS];\
																		\
		*(_ppDfEntry) = pD;												\
		Found = fFiles = False;											\
		do																\
		{																\
			for (NOTHING;												\
				 *(_ppDfEntry) != NULL;									\
				 *(_ppDfEntry) = (*(_ppDfEntry))->dfe_NextSibling)		\
			{															\
				if ((*(_ppDfEntry))->dfe_NameHash < NameHash)			\
				{														\
					*(_ppDfEntry) = NULL;								\
					break;												\
				}														\
																		\
				if (((*(_ppDfEntry))->dfe_NameHash == NameHash)	&&		\
					EQUAL_UNICODE_STRING(&((*(_ppDfEntry))->dfe_UnicodeName), \
										 _pName,						\
										 True))							\
				{														\
					afpUpdateDfeAccessTime(_pVolDesc, *(_ppDfEntry));	\
					Found = True;										\
					break;												\
				}														\
			}															\
			if (Found)													\
				break;													\
																		\
			fFiles ^= True;												\
			if (fFiles)													\
			{															\
				*(_ppDfEntry) = pF;										\
			}															\
		} while (fFiles);												\
	}

#define	afpFindDFEByUnicodeNameInSiblingList_CS(_pVolDesc, _pDfeParent, _pName, _ppDfEntry, _EntityMask) \
	{																	\
		DWORD		NameHash; 											\
		PDFENTRY	pD, pF;												\
		BOOLEAN		Found, fFiles;										\
																		\
		afpHashUnicodeName(_pName, &NameHash);							\
																		\
		pD = (_pDfeParent)->dfe_pDirEntry->de_ChildDir;				 	\
		if (((_EntityMask) & (DFE_ANY | DFE_DIR)) == 0)					\
			pD = NULL;													\
																		\
		pF = NULL;														\
		if ((_EntityMask) & (DFE_ANY | DFE_FILE))						\
			pF = (_pDfeParent)->dfe_pDirEntry->de_ChildFile[NameHash % MAX_CHILD_HASH_BUCKETS];\
																		\
		*(_ppDfEntry) = pD;												\
		Found = fFiles = False;											\
		do																\
		{																\
			for (NOTHING;												\
				 *(_ppDfEntry) != NULL;									\
				 *(_ppDfEntry) = (*(_ppDfEntry))->dfe_NextSibling)		\
			{															\
				if ((*(_ppDfEntry))->dfe_NameHash < NameHash)			\
				{														\
					*(_ppDfEntry) = NULL;								\
					break;												\
				}														\
																		\
				if (((*(_ppDfEntry))->dfe_NameHash == NameHash)	&&		\
					EQUAL_UNICODE_STRING_CS(&((*(_ppDfEntry))->dfe_UnicodeName), _pName)) \
				{														\
					afpUpdateDfeAccessTime(_pVolDesc, *(_ppDfEntry));	\
					Found = True;										\
					break;												\
				}														\
			}															\
			if (Found)													\
				break;													\
																		\
			fFiles ^= True;												\
			if (fFiles)													\
			{															\
				*(_ppDfEntry) = pF;										\
			}															\
		} while (fFiles);												\
	}
#else
#define	afpFindDFEByUnicodeNameInSiblingList(_pVolDesc, _pDfeParent, _pName, _ppDfEntry, _EntityMask) \
	{																	\
		DWORD		NameHash; 											\
		PDFENTRY	pD, pF;												\
		BOOLEAN		Found, fFiles;										\
																		\
		afpHashUnicodeName(_pName, &NameHash);							\
																		\
		pD = (_pDfeParent)->dfe_pDirEntry->de_ChildDir;					\
		if (((_EntityMask) & (DFE_ANY | DFE_DIR)) == 0)					\
			pD = NULL;													\
																		\
		pF = NULL;														\
		if ((_EntityMask) & (DFE_ANY | DFE_FILE))						\
			pF = (_pDfeParent)->dfe_pDirEntry->de_ChildFile[NameHash % MAX_CHILD_HASH_BUCKETS];\
																		\
		*(_ppDfEntry) = pD;												\
		Found = fFiles = False;											\
		do																\
		{																\
			for (NOTHING;												\
				 *(_ppDfEntry) != NULL;									\
				 *(_ppDfEntry) = (*(_ppDfEntry))->dfe_NextSibling)		\
			{															\
				if (((*(_ppDfEntry))->dfe_NameHash == NameHash)	&&		\
					EQUAL_UNICODE_STRING(&((*(_ppDfEntry))->dfe_UnicodeName), \
										 _pName,						\
										 True))							\
				{														\
					afpUpdateDfeAccessTime(_pVolDesc, *(_ppDfEntry));	\
					Found = True;										\
					break;												\
				}														\
			}															\
			if (Found)													\
				break;													\
																		\
			fFiles ^= True;												\
			if (fFiles)													\
			{															\
				*(_ppDfEntry) = pF;										\
			}															\
		} while (fFiles);												\
	}

#define	afpFindDFEByUnicodeNameInSiblingList_CS(_pVolDesc, _pDfeParent, _pName, _ppDfEntry, _EntityMask) \
	{																	\
		DWORD		NameHash; 											\
		PDFENTRY	pD, pF;												\
		BOOLEAN		Found, fFiles;										\
																		\
		afpHashUnicodeName(_pName, &NameHash);							\
																		\
		pD = (_pDfeParent)->dfe_pDirEntry->de_ChildDir;				 	\
		if (((_EntityMask) & (DFE_ANY | DFE_DIR)) == 0)					\
			pD = NULL;													\
																		\
		pF = NULL;														\
		if ((_EntityMask) & (DFE_ANY | DFE_FILE))						\
			pF = (_pDfeParent)->dfe_pDirEntry->de_ChildFile[NameHash % MAX_CHILD_HASH_BUCKETS];\
																		\
		*(_ppDfEntry) = pD;												\
		Found = fFiles = False;											\
		do																\
		{																\
			for (NOTHING;												\
				 *(_ppDfEntry) != NULL;									\
				 *(_ppDfEntry) = (*(_ppDfEntry))->dfe_NextSibling)		\
			{															\
				if (((*(_ppDfEntry))->dfe_NameHash == NameHash)	&&		\
					EQUAL_UNICODE_STRING_CS(&((*(_ppDfEntry))->dfe_UnicodeName), _pName)) \
				{														\
					afpUpdateDfeAccessTime(_pVolDesc, *(_ppDfEntry));	\
					Found = True;										\
					break;												\
				}														\
			}															\
			if (Found)													\
				break;													\
																		\
			fFiles ^= True;												\
			if (fFiles)													\
			{															\
				*(_ppDfEntry) = pF;										\
			}															\
		} while (fFiles);												\
	}
#endif

#define	afpInsertDFEInSiblingList(_pDfeParent, _pDfEntry, _fDirectory)	\
	{																	\
		if (fDirectory)													\
		{																\
	        afpInsertDirDFEInSiblingList(_pDfeParent, _pDfEntry);		\
		}																\
		else															\
		{																\
	        afpInsertFileDFEInSiblingList(_pDfeParent, _pDfEntry);		\
		}																\
	}


#define	afpInsertFileDFEInSiblingList(_pDfeParent, _pDfEntry)			\
	{																	\
		DWORD		Index;												\
		PDFENTRY *	ppDfEntry;											\
																		\
		Index = (_pDfEntry)->dfe_NameHash % MAX_CHILD_HASH_BUCKETS;		\
		ppDfEntry = &(_pDfeParent)->dfe_pDirEntry->de_ChildFile[Index];	\
	    afpInsertInSiblingList(ppDfEntry,								\
							   (_pDfEntry));							\
	}


#define	afpInsertDirDFEInSiblingList(_pDfeParent, _pDfEntry)			\
	{																	\
		PDFENTRY *	ppDfEntry;											\
																		\
		ppDfEntry = &(_pDfeParent)->dfe_pDirEntry->de_ChildDir;			\
	    afpInsertInSiblingList(ppDfEntry,								\
							   (_pDfEntry));							\
	}

#ifdef	SORT_DFE_BY_HASH
#define	afpInsertInSiblingList(_ppHead, _pDfEntry)						\
	{																	\
		for (NOTHING;													\
			 *(_ppHead) != NULL;										\
			 (_ppHead) = &(*(_ppHead))->dfe_NextSibling)				\
		{																\
			if ((_pDfEntry)->dfe_NameHash > (*(_ppHead))->dfe_NameHash)	\
			{															\
				break;													\
			}															\
		}																\
		if (*(_ppHead) != NULL)											\
		{																\
			AfpInsertDoubleBefore(_pDfEntry,							\
								  *(_ppHead),							\
								  dfe_NextSibling,						\
								  dfe_PrevSibling);						\
		}																\
		else															\
		{																\
			*(_ppHead) = (_pDfEntry);									\
			(_pDfEntry)->dfe_NextSibling = NULL;						\
			(_pDfEntry)->dfe_PrevSibling = (_ppHead);					\
		}																\
	}
#else
#define	afpInsertInSiblingList(_ppHead, _pDfEntry)						\
	{																	\
		AfpLinkDoubleAtHead(*(_ppHead),									\
							(_pDfEntry),								\
							dfe_NextSibling,							\
							dfe_PrevSibling);							\
	}
#endif

#define	afpInsertDFEInHashBucket(_pVolDesc, _pDfEntry, _fDirectory, _pfS)\
	{																	\
		PDFENTRY	*ppTmp;												\
        struct _DirFileEntry ** _DfeDirBucketStart;                     \
        struct _DirFileEntry ** _DfeFileBucketStart;                    \
																		\
		afpUpdateDfeAccessTime(_pVolDesc, _pDfEntry);					\
		*(_pfS) = True;	/* Assume success */							\
                                                                        \
	  retry:															\
                                                                        \
        if (_fDirectory)                                                \
        {                                                               \
            _DfeDirBucketStart = (_pVolDesc)->vds_pDfeDirBucketStart;   \
            ppTmp = &_DfeDirBucketStart[HASH_DIR_ID((_pDfEntry)->dfe_AfpId,_pVolDesc)]; \
        }                                                               \
        else                                                            \
        {                                                               \
            _DfeFileBucketStart = (_pVolDesc)->vds_pDfeFileBucketStart;   \
            ppTmp = &_DfeFileBucketStart[HASH_FILE_ID((_pDfEntry)->dfe_AfpId,_pVolDesc)]; \
        }                                                               \
                                                                        \
		for (NOTHING;													\
			 *ppTmp != NULL;											\
			 ppTmp = &(*ppTmp)->dfe_NextOverflow)						\
		{																\
			ASSERT(VALID_DFE(*ppTmp));									\
			if ((_pDfEntry)->dfe_AfpId > (*ppTmp)->dfe_AfpId)			\
			{															\
				/* Found our slot */									\
				break;													\
			}															\
			if ((_pDfEntry)->dfe_AfpId == (*ppTmp)->dfe_AfpId)			\
			{															\
				/* Found a collision. Assign a new id and proceed */	\
				(_pDfEntry)->dfe_AfpId = afpGetNextId(_pVolDesc);		\
				if ((_pDfEntry)->dfe_AfpId == 0)						\
				{														\
					/* Uh-oh */											\
					*(_pfS) = False;									\
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,			\
							("afpInsertDFEInHashBucket: Collision & Id Overflow\n"));\
					break;												\
				}														\
				/* Write back the afpinfo stream with the new id */		\
				AfpUpdateIdInAfpInfo(_pVolDesc, _pDfEntry);				\
				goto retry;												\
			}															\
		}																\
		if (*(_pfS))													\
		{																\
			if (*ppTmp != NULL)											\
			{															\
				AfpInsertDoubleBefore((_pDfEntry),						\
									  *ppTmp,							\
									  dfe_NextOverflow,					\
									  dfe_PrevOverflow);				\
			}															\
			else														\
			{															\
				*ppTmp = _pDfEntry;										\
				(_pDfEntry)->dfe_PrevOverflow = ppTmp;					\
			}															\
			(_pVolDesc)->vds_pDfeCache[HASH_CACHE_ID((_pDfEntry)->dfe_AfpId)] = (_pDfEntry); \
		}																\
	}

#define	afpValidateDFEType(_pDfEntry, _EntityMask)						\
	{																	\
		if (((_EntityMask) & DFE_ANY) ||								\
			(((_EntityMask) & DFE_DIR) && DFE_IS_DIRECTORY(_pDfEntry)) || \
			(((_EntityMask) & DFE_FILE) && DFE_IS_FILE(_pDfEntry)))		\
			NOTHING;													\
		else															\
		{																\
			_pDfEntry = NULL;											\
		}																\
	}

/***	afpCheckDfEntry
 *
 *	When enumerating the disk during volume add, if a file/directory
 *	has an AfpId associated with it, then it is validated to see if it is
 *	within range as well as unique.  If there is a collision between AFPIds,
 *	a PC user must have copied (or restored) something from
 *	this volume, or a different volume (or server) that had the same AFPId,
 *	in which case we will give the new entity a different AFP Id;
 *	If there is not a collision between AFPIds, and the Id is larger than the
 *  last Id we know we assigned, then the new entity gets added with a new
 *  AFPId; else if the Id is within the range, we will just use its existing
 *  Id.
 *
 *	Discovered AFPId is:				Action for discovered entity in IdDb is:
 *	--------------------				----------------------------------------
 *	1) > last Id						Add a new entry, assign a new AFPId
 *
 *	2) Collides with existing Id:
 *		* Host copy occurred			Add a new entry, assign a new AFPId
 *
 *	3) < last Id						Insert this entity using same AFPId
 *
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 * VOID
 * afpCheckDfEntry(
 * 	IN	PVOLDESC		pVolDesc,
 * 	IN	PAFPINFO		pAfpInfo,	// AFP Info of the discovered entity
 * 	IN	PUNICODE_STRING pUName,		// Munged unicode name
 * 	IN	BOOLEAN			IsDir,		// is this thing a file or a directory?
 * 	IN	PDFENTRY		pParent,	// parent DFE of the discovered thing
 * 	OUT	PDFENTRY	*	ppDfEntry
 * );
 */
#define	afpCheckDfEntry(_pVolDesc, _AfpId, _pUName, _IsDir, _pParent, _ppDfEntry)	\
	{																	\
		PDFENTRY	pDfeNew;											\
																		\
		if (((_AfpId) > (_pVolDesc)->vds_LastId)	||					\
			((_AfpId) <= AFP_ID_NETWORK_TRASH)		||					\
			(AfpFindDfEntryById(_pVolDesc, _AfpId, DFE_ANY) != NULL))	\
		{																\
			/* add the item to the DB but assign it a new AFP Id */     \
			_AfpId = 0;												 	\
		}																\
																		\
		pDfeNew = AfpAddDfEntry(_pVolDesc,								\
								_pParent,								\
								_pUName,								\
								_IsDir,								 	\
								_AfpId);								\
																		\
		*(_ppDfEntry) = pDfeNew;										\
	}

#ifdef	AGE_DFES
#define	afpUpdateDfeAccessTime(_pVolDesc, _pDfEntry)					\
	{																	\
		if (IS_VOLUME_AGING_DFES(_pVolDesc))							\
		{																\
			if (DFE_IS_DIRECTORY(_pDfEntry))							\
				AfpGetCurrentTimeInMacFormat(&(_pDfEntry)->dfe_pDirEntry->de_LastAccessTime);\
			else AfpGetCurrentTimeInMacFormat(&(_pDfEntry)->dfe_Parent->dfe_pDirEntry->de_LastAccessTime);\
		}																\
	}
#else
#define	afpUpdateDfeAccessTime(pVolDesc, pDfEntry)
#endif

#define	afpMarkAllChildrenUnseen(_pDFETree)								\
	{																	\
		LONG		i = -1;												\
		PDFENTRY	pDFE;												\
																		\
		/*																\
		 * Even if this dir has not had its file children cached in		\
		 * yet, we still want to prune out any dead directory children	\
		 */																\
		for (pDFE = (_pDFETree)->dfe_pDirEntry->de_ChildDir;			\
			 True;														\
			 pDFE = (_pDFETree)->dfe_pDirEntry->de_ChildFile[i])		\
		{																\
			for (NOTHING;												\
				 pDFE != NULL;											\
				 pDFE = pDFE->dfe_NextSibling)							\
			{															\
				DFE_MARK_UNSEEN(pDFE);									\
			}															\
			if (++i == MAX_CHILD_HASH_BUCKETS)							\
				break;													\
		}																\
	}

#define	afpPruneUnseenChildren(_pVolDesc, _pDFETree)					\
	{																	\
		PDFENTRY	pDFE, *ppDfEntry;									\
		LONG		i;													\
																		\
		/*																\
		 * Go thru the list of children for this parent, and if there	\
		 * are any left that are not marked as seen, get rid of them.	\
		 */																\
		ppDfEntry = &(_pDFETree)->dfe_pDirEntry->de_ChildDir;			\
		i = -1;															\
		while (True)													\
		{																\
			while ((pDFE = *ppDfEntry) != NULL)							\
			{															\
				if (!DFE_HAS_BEEN_SEEN(pDFE))							\
				{														\
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,			\
							("afpPruneUnseenChildren: deleting nonexistant IdDb entry\n")); \
																		\
					AfpDeleteDfEntry(_pVolDesc, pDFE);					\
					continue;	/* make sure we don't skip any */		\
				}														\
				ppDfEntry = &pDFE->dfe_NextSibling;						\
			}															\
			if (++i == MAX_CHILD_HASH_BUCKETS)							\
			{															\
				break;													\
			}															\
			ppDfEntry = &(_pDFETree)->dfe_pDirEntry->de_ChildFile[i];	\
		}																\
	}

#define	afpUpdateDfeWithSavedData(_pDfe, _pDiskEnt)						\
	{																	\
		(_pDfe)->dfe_Flags |= (_pDiskEnt)->dsk_Flags & DFE_FLAGS_CSENCODEDBITS;\
		(_pDfe)->dfe_AfpAttr = (_pDiskEnt)->dsk_AfpAttr;				\
		(_pDfe)->dfe_NtAttr = (_pDiskEnt)->dsk_NtAttr;					\
		(_pDfe)->dfe_CreateTime = (_pDiskEnt)->dsk_CreateTime;			\
		(_pDfe)->dfe_LastModTime = (_pDiskEnt)->dsk_LastModTime;		\
		(_pDfe)->dfe_BackupTime = (_pDiskEnt)->dsk_BackupTime;			\
		(_pDfe)->dfe_FinderInfo = (_pDiskEnt)->dsk_FinderInfo;			\
		if (DFE_IS_DIRECTORY((_pDfe)))									\
		{																\
			(_pDfe)->dfe_pDirEntry->de_Access = (_pDiskEnt)->dsk_Access;\
		}																\
		else															\
		{																\
			(_pDfe)->dfe_DataLen = (_pDiskEnt)->dsk_DataLen;			\
			(_pDfe)->dfe_RescLen = (_pDiskEnt)->dsk_RescLen;			\
		}																\
	}

#define	afpSaveDfeData(_pDfe, _pDiskEnt)								\
	{                                                                   \
		/* Write a signature for sanity checking */                     \
		(_pDiskEnt)->dsk_Signature = AFP_DISKENTRY_SIGNATURE;           \
                                                                        \
		(_pDiskEnt)->dsk_AfpId = (_pDfe)->dfe_AfpId;                    \
		(_pDiskEnt)->dsk_AfpAttr = (_pDfe)->dfe_AfpAttr;                \
		(_pDiskEnt)->dsk_NtAttr = (_pDfe)->dfe_NtAttr;                  \
		(_pDiskEnt)->dsk_BackupTime = (_pDfe)->dfe_BackupTime;          \
		(_pDiskEnt)->dsk_CreateTime = (_pDfe)->dfe_CreateTime;          \
		(_pDiskEnt)->dsk_LastModTime = (_pDfe)->dfe_LastModTime;		\
		(_pDiskEnt)->dsk_FinderInfo = (_pDfe)->dfe_FinderInfo;          \
                                                                        \
		/* Encode the number of characters (not bytes) in the name */   \
		(_pDiskEnt)->dsk_Flags =										\
				((_pDfe)->dfe_Flags & DFE_FLAGS_DFBITS)	|				\
				((_pDfe)->dfe_UnicodeName.Length/sizeof(WCHAR));		\
                                                                        \
		/* Copy the name over */                                        \
		RtlCopyMemory(&(_pDiskEnt)->dsk_Name[0],           				\
					  (_pDfe)->dfe_UnicodeName.Buffer,                  \
					  (_pDfe)->dfe_UnicodeName.Length);                 \
	}

// File DFEs are aged after MAX_BLOCK_AGE*FILE_BLOCK_AGE_TIME seconds (currently 2 mins)
// File DFEs are aged after MAX_BLOCK_AGE*DIR_BLOCK_AGE_TIME seconds  (currently 6 mins)
#define	MAX_BLOCK_AGE			6
#define	FILE_BLOCK_AGE_TIME		600			// # of seconds
#define	DIR_BLOCK_AGE_TIME		3600		// # of seconds
#define	BLOCK_64K_ALLOC		    64*1024     // Virtual mem allocates 64K chunks
#define	MAX_BLOCK_TYPE			4			// For TINY, SMALL, MEDIUM & LARGE

#define VALID_DFB(pDfeBlock)	((pDfeBlock) != NULL)

typedef struct _Block64K
{
    struct _Block64K *b64_Next;
    PBYTE             b64_BaseAddress;
    DWORD             b64_PagesFree;
    BYTE              b64_PageInUse[BLOCK_64K_ALLOC/PAGE_SIZE];
} BLOCK64K, *PBLOCK64K;


typedef	struct _DfeBlock
{
	struct _DfeBlock *	dfb_Next;			// Link to next
	struct _DfeBlock **	dfb_Prev;			// Link to previous
	USHORT				dfb_NumFree;		// # of free DFEs in this block
	BYTE				dfb_Age;			// Age of the Block if all are free
	BOOLEAN				dfb_fDir;			// TRUE if it is a Dir DFB - else a file DFB
	PDFENTRY			dfb_FreeHead;		// Head of the list of free DFEs
} DFEBLOCK, *PDFEBLOCK, **PPDFEBLOCK;

LOCAL PDFENTRY FASTCALL
afpAllocDfe(
	IN	LONG						Index,
	IN	BOOLEAN						fDir
);

LOCAL VOID FASTCALL			
afpFreeDfe(					
	IN	PDFENTRY					pDfEntry
);

LOCAL AFPSTATUS FASTCALL
afpDfeBlockAge(				
	IN	PPDFEBLOCK					pBlockHead
);

#if DBG						

VOID FASTCALL
afpDisplayDfe(
	IN	PDFENTRY					pDfEntry
);

NTSTATUS FASTCALL
afpDumpDfeTree(				
	IN	PVOID						Context
);

#endif

IDDBGLOBAL  PBLOCK64K   afp64kBlockHead EQU NULL;

IDDBGLOBAL	PDFEBLOCK	afpDirDfeFreeBlockHead[MAX_BLOCK_TYPE] EQU  { NULL, NULL, NULL };
IDDBGLOBAL	PDFEBLOCK	afpDirDfePartialBlockHead[MAX_BLOCK_TYPE] EQU  { NULL, NULL, NULL };
IDDBGLOBAL	PDFEBLOCK	afpDirDfeUsedBlockHead[MAX_BLOCK_TYPE] EQU  { NULL, NULL, NULL };
IDDBGLOBAL	PDFEBLOCK	afpFileDfeFreeBlockHead[MAX_BLOCK_TYPE] EQU { NULL, NULL, NULL };
IDDBGLOBAL	PDFEBLOCK	afpFileDfePartialBlockHead[MAX_BLOCK_TYPE] EQU { NULL, NULL, NULL };
IDDBGLOBAL	PDFEBLOCK	afpFileDfeUsedBlockHead[MAX_BLOCK_TYPE] EQU { NULL, NULL, NULL };

IDDBGLOBAL	USHORT		afpDfeUnicodeBufSize[MAX_BLOCK_TYPE] EQU	\
	{																\
		DFE_SIZE_TINY_U, DFE_SIZE_SMALL_U,							\
		DFE_SIZE_MEDIUM_U, DFE_SIZE_LARGE_U							\
	};

IDDBGLOBAL	USHORT		afpDfeFileBlockSize[MAX_BLOCK_TYPE] EQU		\
	{																\
		sizeof(DFENTRY) + DFE_SIZE_TINY_U,							\
		sizeof(DFENTRY) + DFE_SIZE_SMALL_U,							\
		sizeof(DFENTRY) + DFE_SIZE_MEDIUM_U,						\
		sizeof(DFENTRY) + DFE_SIZE_LARGE_U							\
	};

IDDBGLOBAL	USHORT		afpDfeDirBlockSize[MAX_BLOCK_TYPE] EQU		    \
	{																    \
		(USHORT)(sizeof(DFENTRY) + sizeof(DIRENTRY) + DFE_SIZE_TINY_U),	\
		(USHORT)(sizeof(DFENTRY) + sizeof(DIRENTRY) + DFE_SIZE_SMALL_U),	\
		(USHORT)(sizeof(DFENTRY) + sizeof(DIRENTRY) + DFE_SIZE_MEDIUM_U),	\
		(USHORT)(sizeof(DFENTRY) + sizeof(DIRENTRY) + DFE_SIZE_LARGE_U)	\
	};

IDDBGLOBAL	USHORT      afpDfeNumFileBlocks[MAX_BLOCK_TYPE] EQU		\
	{																\
		(PAGE_SIZE - sizeof(DFEBLOCK))/						        \
			(sizeof(DFENTRY) + DFE_SIZE_TINY_U),					\
		(PAGE_SIZE - sizeof(DFEBLOCK))/						        \
			(sizeof(DFENTRY) + DFE_SIZE_SMALL_U),					\
		(PAGE_SIZE - sizeof(DFEBLOCK))/						        \
			(sizeof(DFENTRY) + DFE_SIZE_MEDIUM_U),					\
		(PAGE_SIZE - sizeof(DFEBLOCK))/						        \
			(sizeof(DFENTRY) + DFE_SIZE_LARGE_U)					\
	};

IDDBGLOBAL	USHORT      afpDfeNumDirBlocks[MAX_BLOCK_TYPE] EQU		\
	{																\
		(PAGE_SIZE - sizeof(DFEBLOCK))/						        \
			(sizeof(DFENTRY) + sizeof(DIRENTRY) + DFE_SIZE_TINY_U),	\
		(PAGE_SIZE - sizeof(DFEBLOCK))/						        \
			(sizeof(DFENTRY) + sizeof(DIRENTRY) + DFE_SIZE_SMALL_U),\
		(PAGE_SIZE - sizeof(DFEBLOCK))/						        \
			(sizeof(DFENTRY) + sizeof(DIRENTRY) + DFE_SIZE_MEDIUM_U),\
		(PAGE_SIZE - sizeof(DFEBLOCK))/						        \
			(sizeof(DFENTRY) + sizeof(DIRENTRY) + DFE_SIZE_LARGE_U)	\
	};

IDDBGLOBAL	SWMR	afpDfeBlockLock EQU { 0 };

#if DBG

IDDBGLOBAL	LONG		afpDfeAllocCount	EQU 0;
IDDBGLOBAL	LONG		afpDfbAllocCount	EQU 0;
IDDBGLOBAL	LONG		afpDfe64kBlockCount	EQU 0;
IDDBGLOBAL	BOOLEAN		afpDumpDfeTreeFlag	EQU 0;
IDDBGLOBAL	PDFENTRY	afpDfeStack[4096]	EQU { 0 };

#endif

#undef	EQU
#ifdef	_GLOBALS_
#define	EQU				=
#else
#define	EQU				; / ## /
#endif

#endif // IDINDEX_LOCALS

#endif // _IDINDEX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\idindex.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	idindex.c

Abstract:

	This module contains the id index manipulation routines.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992	Initial Version
	24 Feb 1993 SueA	Fix AfpRenameDfEntry and AfpMoveDfEntry to invalidate
						the entire pathcache if the object of the move/rename
						is a directory that has children.  This is faster
						than having to either search the path cache for
						paths that have the moved/renamed dir path as a prefix,
						or having to walk down the subtree below that dir
						and invalidate the cache for each item there.
	05 Oct 1993 JameelH	Performance Changes. Merge cached afpinfo into the
						idindex structure. Make both the ANSI and the UNICODE
						names part of idindex. Added EnumCache for improving
						enumerate perf.
	05 Jun 1995 JameelH	Remove the ANSI name from DFE. Also keep the files
						in the directory in multiple hash buckets instead
						of a single one. The hash buckets are also
						seperated into files and directories for faster
						lookup. The notify filtering is now moved to completion
						time and made over-all optimizations related to iddb.

Notes:		Tab stop: 4

	Directories and files that the AFP server has enumerated have AFP ids
	associated with them. These ids are DWORD and start with 1 (0 is invalid).
	Id 1 is reserved for the 'parent of the volume root' directory.  Id 2 is
	reserved for the volume root directory.  Id 3 is reserved for the Network
	Trash directory.  Volumes that have no Network Trash will not use Id 3.

	These ids are per-volume and a database of ids are kept in memory in the
	form of a sibling tree which mirrors the part of the disk that the AFP
	server knows about (those files and dirs which have at some point been
	enumerated by a mac client).  An index is also maintained for this database
	which is in the form of a sorted hashed index.  The overflow hash links are
	sorted by AFP id in descending order.  This is based on the idea that the
	most recently created items will be accessed most frequently (at least
	for writable volumes).

--*/

#define IDINDEX_LOCALS
#define _IDDB_GLOBALS_
#define	FILENUM	FILE_IDINDEX

#include <afp.h>
#include <scavengr.h>
#include <fdparm.h>
#include <pathmap.h>
#include <afpinfo.h>
#include <access.h>	// for AfpWorldId

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AfpDfeInit)
#pragma alloc_text(PAGE, AfpDfeDeInit)
#pragma alloc_text(PAGE, AfpFindDfEntryById)
#pragma alloc_text(PAGE, AfpFindEntryByUnicodeName)
#pragma alloc_text(PAGE, afpFindEntryByNtName)
#pragma alloc_text(PAGE, AfpAddDfEntry)
#pragma alloc_text(PAGE, AfpRenameDfEntry)
#pragma alloc_text(PAGE, AfpMoveDfEntry)
#pragma alloc_text(PAGE, AfpDeleteDfEntry)
#pragma alloc_text(PAGE, AfpExchangeIdEntries)
#pragma alloc_text(PAGE, AfpPruneIdDb)
#pragma alloc_text(PAGE, AfpEnumerate)
#pragma alloc_text(PAGE, AfpCatSearch)
#pragma alloc_text(PAGE, afpPackSearchParms)
#pragma alloc_text(PAGE, AfpSetDFFileFlags)
#pragma alloc_text(PAGE, AfpCacheParentModTime)
#pragma alloc_text(PAGE, afpAllocDfe)
#pragma alloc_text(PAGE, afpFreeDfe)
#pragma alloc_text(PAGE, AfpFreeIdIndexTables)
#pragma alloc_text(PAGE, AfpInitIdDb)
#pragma alloc_text(PAGE, afpSeedIdDb)
#pragma alloc_text(PAGE, afpDfeBlockAge)
#pragma alloc_text(PAGE, afpRenameInvalidWin32Name)
#ifdef	AGE_DFES
#pragma alloc_text( PAGE, AfpAgeDfEntries)
#endif
#if DBG
#pragma alloc_text( PAGE, afpDumpDfeTree)
#pragma alloc_text( PAGE, afpDisplayDfe)
#endif
#endif

/***	AfpDfeInit
 *
 *	Initialize the Swmr for Dfe Block package and start the aging scavenger for it.
 */
NTSTATUS
AfpDfeInit(
	VOID
)
{
	NTSTATUS	Status;

	// Initialize the DfeBlock Swmr
	AfpSwmrInitSwmr(&afpDfeBlockLock);

#if DBG
	AfpScavengerScheduleEvent(afpDumpDfeTree,
							  NULL,
							  2,
							  True);
#endif


	// Age out file and dir DFEs differently and seperately
	Status = AfpScavengerScheduleEvent(afpDfeBlockAge,
										afpDirDfeFreeBlockHead,
										DIR_BLOCK_AGE_TIME,
										True);
	if (NT_SUCCESS(Status))
	{
		// Age out file and dir DFEs differently and seperately
		Status = AfpScavengerScheduleEvent(afpDfeBlockAge,
										   afpFileDfeFreeBlockHead,
										   FILE_BLOCK_AGE_TIME,
										   True);
	}

	return Status;
}




/***	AfpDfeDeInit
 *
 *	Free any Dfe Blocks that have not yet been aged out.
 */
VOID
AfpDfeDeInit(
	VOID
)
{
	PDFEBLOCK	pDfb;
	int			i;

	ASSERT (afpDfeAllocCount == 0);

	for (i = 0; i < MAX_BLOCK_TYPE; i++)
	{
	    ASSERT (afpDirDfePartialBlockHead[i] == NULL);
	    ASSERT (afpDirDfeUsedBlockHead[i] == NULL);

		for (pDfb = afpDirDfeFreeBlockHead[i];
			 pDfb != NULL;
			 NOTHING)
		{
			PDFEBLOCK	pFree;

			ASSERT(pDfb->dfb_NumFree == afpDfeNumDirBlocks[i]);
			pFree = pDfb;
			pDfb = pDfb->dfb_Next;
			AfpFreeVirtualMemoryPage(pFree);
#if	DBG
			afpDfbAllocCount --;
#endif
		}

	    ASSERT (afpFileDfePartialBlockHead[i] == NULL);
	    ASSERT (afpFileDfeUsedBlockHead[i] == NULL);
		for (pDfb = afpFileDfeFreeBlockHead[i];
			 pDfb != NULL;)
		{
			PDFEBLOCK	pFree;

			ASSERT(pDfb->dfb_NumFree == afpDfeNumFileBlocks[i]);
			pFree = pDfb;
			pDfb = pDfb->dfb_Next;
			AfpFreeVirtualMemoryPage(pFree);
#if	DBG
			afpDfbAllocCount --;
#endif
		}
	}

	ASSERT (afpDfbAllocCount == 0);
}


/***	AfpFindDfEntryById
 *
 *	Search for an entity based on its AFP Id. returns a pointer to the entry
 *	if found, else null.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	READ.
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Shared)
 */
PDFENTRY
AfpFindDfEntryById(
	IN	PVOLDESC	pVolDesc,
	IN	DWORD		Id,
	IN	DWORD		EntityMask
)
{
	PDFENTRY	pDfEntry;
    struct _DirFileEntry    **DfeDirBucketStart;
    struct _DirFileEntry    **DfeFileBucketStart;
	BOOLEAN		Found = False;

	PAGED_CODE( );

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_NumDfeLookupById);
#endif

	if (Id == AFP_ID_ROOT)
	{
		Found = True;
		pDfEntry = pVolDesc->vds_pDfeRoot;
		ASSERT (VALID_DFE(pDfEntry));

#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_DfeCacheHits);
#endif
	}
	else
	{
		pDfEntry = pVolDesc->vds_pDfeCache[HASH_CACHE_ID(Id)];
		if ((pDfEntry != NULL) && (pDfEntry->dfe_AfpId == Id))
		{
			Found = True;
			ASSERT (VALID_DFE(pDfEntry));
#ifdef	PROFILING
			INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_DfeCacheHits);
#endif
		}
		else
		{
			BOOLEAN	retry = False;

#ifdef	PROFILING
			INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_DfeCacheMisses);
#endif
            DfeDirBucketStart = pVolDesc->vds_pDfeDirBucketStart;
            DfeFileBucketStart = pVolDesc->vds_pDfeFileBucketStart;

			if ((EntityMask == DFE_ANY) || (EntityMask == DFE_DIR))
			{
				if (EntityMask == DFE_ANY)
					retry = True;
				pDfEntry = DfeDirBucketStart[HASH_DIR_ID(Id,pVolDesc)];
			}
			else
			{
				pDfEntry = DfeFileBucketStart[HASH_FILE_ID(Id,pVolDesc)];
			}

			do
			{
				for (NOTHING;
					 (pDfEntry != NULL) && (pDfEntry->dfe_AfpId >= Id);
					 pDfEntry = pDfEntry->dfe_NextOverflow)
				{
#ifdef	PROFILING
					INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_DfeDepthTraversed);
#endif
					ASSERT(VALID_DFE(pDfEntry));

					if (pDfEntry->dfe_AfpId < Id)
					{
						break;		// Did not find
					}

					if (pDfEntry->dfe_AfpId == Id)
					{
						pVolDesc->vds_pDfeCache[HASH_CACHE_ID(Id)] = pDfEntry;
						Found = True;
						break;
					}
				}

				if (Found)
				{
					break;
				}

				if (retry)
				{
					ASSERT(EntityMask == DFE_ANY);
					pDfEntry = DfeFileBucketStart[HASH_FILE_ID(Id,pVolDesc)];
				}
				retry ^= True;

			} while (!retry);
		}
	}

	if (Found)
	{
		afpValidateDFEType(pDfEntry, EntityMask);
		if (pDfEntry != NULL)
		{
			afpUpdateDfeAccessTime(pVolDesc, pDfEntry);
		}
	}
	else
	{
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("AfpFindDfEntryById: Not found for id %lx, entity %d\n",
				Id, EntityMask));
		pDfEntry = NULL;
	}

	return pDfEntry;
}


/***	AfpFindEntryByUnicodeName
 *
 *	Search for an entity based on a Unicode name and its parent dfentry.
 *	Returns a pointer to the entry if found, else null.  If lookup is by
 *	longname, we just need to search the parent's children's names as
 *	stored in the database.  If lookup is by shortname, we first assume
 *	that longname == shortname.  If we don't find it in the database, we
 *	must query the filesystem for the longname, then search again.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	READ.
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Shared)
 */
PDFENTRY
AfpFindEntryByUnicodeName(
	IN	PVOLDESC		pVolDesc,
	IN	PUNICODE_STRING	pName,
	IN	DWORD			PathType,	// short or long name
	IN	PDFENTRY		pDfeParent,	// pointer to parent DFENTRY
	IN	DWORD			EntityMask	// find a file,dir or either
)
{
	PDFENTRY		pDfEntry;

	PAGED_CODE( );

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_NumDfeLookupByName);
#endif
	do
	{
		afpFindDFEByUnicodeNameInSiblingList(pVolDesc,
											 pDfeParent,
											 pName,
											 &pDfEntry,
											 EntityMask);

		if ((pDfEntry == NULL) && (PathType == AFP_SHORTNAME))
		{
			AFPSTATUS		Status;
			FILESYSHANDLE	hDir;
			UNICODE_STRING	HostPath;
			UNICODE_STRING	ULongName;
			WCHAR			LongNameBuf[AFP_LONGNAME_LEN+1];

			// AFP does not allow use of the volume root shortname (IA p.13-13)
			if (DFE_IS_PARENT_OF_ROOT(pDfeParent))
			{
				pDfEntry = NULL;
				break;
			}

			AfpSetEmptyUnicodeString(&HostPath, 0, NULL);

			if (!DFE_IS_ROOT(pDfeParent))
			{
				// Get the volume relative path of the parent dir
				if (!NT_SUCCESS(AfpHostPathFromDFEntry(pDfeParent,
													   0,
													   &HostPath)))
				{
					pDfEntry = NULL;
					break;
				}
			}

			// Open the parent directory
			hDir.fsh_FileHandle = NULL;
			Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
								AFP_STREAM_DATA,
								FILEIO_OPEN_DIR,
								DFE_IS_ROOT(pDfeParent) ?
										&UNullString : &HostPath,
								FILEIO_ACCESS_READ,
								FILEIO_DENY_NONE,
								False,
								&hDir);

			if (HostPath.Buffer != NULL)
				AfpFreeMemory(HostPath.Buffer);

			if (!NT_SUCCESS(Status))
			{
				pDfEntry = NULL;
				break;
			}

			// get the LongName associated with this file/dir
			AfpSetEmptyUnicodeString(&ULongName, sizeof(LongNameBuf), LongNameBuf);
			Status = AfpIoQueryLongName(&hDir, pName, &ULongName);
			AfpIoClose(&hDir);
			if (!NT_SUCCESS(Status) ||
				EQUAL_UNICODE_STRING(&ULongName, pName, True))
			{
				pDfEntry = NULL;
				break;
			}

			afpFindDFEByUnicodeNameInSiblingList(pVolDesc,
												 pDfeParent,
												 &ULongName,
												 &pDfEntry,
												 EntityMask);
		} // end else if SHORTNAME
	} while (False);

	return pDfEntry;
}


/***	afpGetNextId
 *
 *	Get the next assignable id for a file/directory. This is a seperate
 *	routine so that AfpAddDfEntry can be paged. Only update the dirty bit
 *	and LastModified time if no new id is assigned.
 *
 *	LOCKS:	vds_VolLock (SPIN)
 */
LOCAL DWORD FASTCALL
afpGetNextId(
	IN	PVOLDESC	pVolDesc
)
{
	KIRQL	OldIrql;
	DWORD	afpId;

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	if (pVolDesc->vds_LastId == AFP_MAX_DIRID)
	{
		// errorlog the case where the assigned Id has wrapped around.
		// call product suppport and have them tell you to copy
		// all the files from one volume onto another volume FROM A MAC
		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
		AFPLOG_ERROR(AFPSRVMSG_MAX_DIRID,
					 STATUS_UNSUCCESSFUL,
					 NULL,
					 0,
					 &pVolDesc->vds_Name);
		return 0;
	}

	afpId = ++ pVolDesc->vds_LastId;
	pVolDesc->vds_Flags |= VOLUME_IDDBHDR_DIRTY;

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

	if (IS_VOLUME_NTFS(pVolDesc))
	{
		AfpVolumeSetModifiedTime(pVolDesc);
	}

	return afpId;
}


/***	afpFindEntryByNtName
 *
 *	Search for an entity based on a Nt name (which could include names > 31
 *  chars or shortnames) and its parent dfentry.
 *	Returns a pointer to the entry if found, else null.
 *
 *	If we don't find it in the database, we query the filesystem for the
 *  longname (in the AFP sense), then search again based on this name.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	READ.
 *
 *	It has been determined that:
 *	a, The name is longer than 31 chars	OR
 *	b, The name lookup in the IdDb has failed.
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 */
PDFENTRY
afpFindEntryByNtName(
	IN	PVOLDESC			pVolDesc,
	IN	PUNICODE_STRING		pName,
	IN	PDFENTRY			pParentDfe	// pointer to parent DFENTRY
)
{
	AFPSTATUS		Status;
	WCHAR			wbuf[AFP_LONGNAME_LEN+1];
	WCHAR			HostPathBuf[BIG_PATH_LEN];
	UNICODE_STRING	uLongName;
	UNICODE_STRING	HostPath;
	FILESYSHANDLE	hDir;
	PDFENTRY		pDfEntry = NULL;

	PAGED_CODE( );

	ASSERT(pParentDfe != NULL);
	ASSERT(pName->Length > 0);
	do
	{
		AfpSetEmptyUnicodeString(&HostPath, sizeof(HostPathBuf), HostPathBuf);

		if (!DFE_IS_ROOT(pParentDfe))
		{
			// Get the volume relative path of the parent dir
			if (!NT_SUCCESS(AfpHostPathFromDFEntry(pParentDfe,
												   0,
												   &HostPath)))
			{
				pDfEntry = NULL;
				break;
			}

		}

		// Open the parent directory
		// NOTE: We CANNOT use the vds_hRootDir handle to enumerate for this
		// purpose.  We MUST open another handle to the root dir because
		// the FileName parameter will be ignored on all subsequent enumerates
		// on a handle.  Therefore we must open a new handle for each
		// enumerate that we want to do for any directory.  When the handle
		// is closed, the 'findfirst' will be cancelled, otherwise we would
		// always be enumerating on the wrong filename!
		hDir.fsh_FileHandle = NULL;
		Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
							AFP_STREAM_DATA,
							FILEIO_OPEN_DIR,
							DFE_IS_ROOT(pParentDfe) ?
								&UNullString : &HostPath,
							FILEIO_ACCESS_NONE,
							FILEIO_DENY_NONE,
							False,
							&hDir);

		if (!NT_SUCCESS(Status))
		{
			pDfEntry = NULL;
			break;
		}

		// get the 'AFP longname' associated with this file/dir.  If the
		// pName is longer than 31 chars, we will know it by its shortname,
		// so query for it's shortname (i.e. the 'AFP longname' we know it
		// by).  If the name is shorter than 31 chars, since we know we
		// didn't find it in our database, then the pName must be the ntfs
		// shortname.  Again, we need to Find the 'AFP longname' that we
		// know it by.
		AfpSetEmptyUnicodeString(&uLongName, sizeof(wbuf), wbuf);
		Status = AfpIoQueryLongName(&hDir, pName, &uLongName);
		AfpIoClose(&hDir);


		if (!NT_SUCCESS(Status) ||
			EQUAL_UNICODE_STRING(&uLongName, pName, True))
		{
			pDfEntry = NULL;

			if ((Status == STATUS_NO_MORE_FILES) ||
				(Status == STATUS_NO_SUCH_FILE))
			{
				// This file must have been deleted.  Since we cannot
				// identify it in our database by the NT name that was
				// passed in, we must reenumerate the parent directory.
				// Anything we don't see on disk that we still have in
				// our database must have been deleted from disk, so get
				// rid of it in the database as well.

				// We must open a DIFFERENT handle to the parent dir since
				// we had already done an enumerate using that handle and
				// searching for a different name.
				hDir.fsh_FileHandle = NULL;
				Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
									AFP_STREAM_DATA,
									FILEIO_OPEN_DIR,
									DFE_IS_ROOT(pParentDfe) ?
										&UNullString : &HostPath,
									FILEIO_ACCESS_NONE,
									FILEIO_DENY_NONE,
									False,
									&hDir);

				if (NT_SUCCESS(Status))
				{
					AfpCacheDirectoryTree(pVolDesc,
										  pParentDfe,
										  REENUMERATE,
										  &hDir,
										  NULL);
					AfpIoClose(&hDir);
				}
			}
			break;
		}

		afpFindDFEByUnicodeNameInSiblingList(pVolDesc,
											 pParentDfe,
											 &uLongName,
											 &pDfEntry,
											 DFE_ANY);
	} while (False);

	if ((HostPath.Buffer != NULL) && (HostPath.Buffer != HostPathBuf))
		AfpFreeMemory(HostPath.Buffer);

	return pDfEntry;
}


/***	afpFindEntryByNtPath
 *
 *	Given a NT path relative to the volume root (which may contain names
 *  > 31 chars or shortnames), look up the entry in the idindex DB.
 *  If the Change Action is FILE_ACTION_ADDED, we want to lookup the entry
 *  for the item's parent dir.  Point the pParent and pTail strings into
 *  the appropriate places in pPath.
 *
 *  Called by the ProcessChangeNotify code when caching information in the DFE.
 *
 *	LOCKS:	vds_VolLock (SPIN)
 */
PDFENTRY
afpFindEntryByNtPath(
	IN	PVOLDESC			pVolDesc,
	IN  DWORD				ChangeAction,	// if ADDED then lookup parent DFE
	IN	PUNICODE_STRING		pPath,
	OUT	PUNICODE_STRING 	pParent,
	OUT	PUNICODE_STRING 	pTail
)
{
	PDFENTRY		pParentDfe, pDfEntry;
	PWSTR			CurPtr, EndPtr;
	USHORT 			Len;
	BOOLEAN			NewComp;

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
			("afpFindEntryByNtPath: Entered for %Z\n", pPath));

	pParentDfe = pVolDesc->vds_pDfeRoot;
	ASSERT(pParentDfe != NULL);
	ASSERT(pPath->Length >= sizeof(WCHAR));
	ASSERT(pPath->Buffer[0] != L'\\');

	// Start off with Parent and Tail as both empty and modify as we go.
	AfpSetEmptyUnicodeString(pTail, 0, NULL);
#if DBG
	AfpSetEmptyUnicodeString(pParent, 0, NULL);	// Need it for the DBGPRINT down below
#endif

	CurPtr = pPath->Buffer;
	EndPtr = (PWSTR)((PBYTE)CurPtr + pPath->Length);
	NewComp = True;
	for (Len = 0; CurPtr < EndPtr; CurPtr++)
	{
		if (NewComp)
		{
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
					("afpFindEntryByNtPath: Parent DFE %lx, Old Parent %Z\n",
					pParentDfe, pParent));

			// The previous char seen was a path separator
			NewComp = False;
			*pParent = *pTail;
			pParent->Length =
			pParent->MaximumLength = Len;
			pTail->Length =
			pTail->MaximumLength = (USHORT)((PBYTE)EndPtr - (PBYTE)CurPtr);
			pTail->Buffer = CurPtr;
			Len = 0;

			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
					("afpFindEntryByNtPath: Current Parent %Z, tail %Z\n",
					pParent, pTail));

			if (pParent->Length > 0)
			{
				// Map this name to a DFE. Do the most common case here
				// If the name is <= AFP_LONGNAME_NAME, then check the
				// current parent's children, else go the long route.
				pDfEntry = NULL;
				//if (pParent->Length/sizeof(WCHAR) <= AFP_LONGNAME_LEN)
				if ((RtlUnicodeStringToAnsiSize(pParent)-1) <= AFP_LONGNAME_LEN)
				{
					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
							("afpFindEntryByNtPath: Looking for %Z in parent DFE %lx\n",
							pParent, pParentDfe));
					afpFindDFEByUnicodeNameInSiblingList(pVolDesc,
														 pParentDfe,
														 pParent,
														 &pDfEntry,
														 DFE_DIR);
				}
				if (pDfEntry == NULL)
				{
					pDfEntry = afpFindEntryByNtName(pVolDesc,
													pParent,
													pParentDfe);
				}
				if ((pParentDfe = pDfEntry) == NULL)
				{
					break;
				}
			}
		}

		if (*CurPtr == L'\\')
		{
			// We have encountered a path terminator
			NewComp = True;
		}
		else Len += sizeof(WCHAR);
	}

	// At this point we have pParentDfe & pParent pointing to the parent directory
	// and pTail pointing to the last component. If it is an add operation, we are
	// set, else map the last component to its Dfe
	if ((ChangeAction != FILE_ACTION_ADDED) && (pParentDfe != NULL))
	{
		pDfEntry = NULL;
		//if (pTail->Length/sizeof(WCHAR) <= AFP_LONGNAME_LEN)
		if ((RtlUnicodeStringToAnsiSize(pTail)-1) <= AFP_LONGNAME_LEN)
		{
			afpFindDFEByUnicodeNameInSiblingList(pVolDesc,
												 pParentDfe,
												 pTail,
												 &pDfEntry,
												 DFE_ANY);
		}

		if (pDfEntry == NULL)
		{
			BOOLEAN KeepLooking = True;

			//
			// We couldn't find this item in the database by the name
			// given, which means that we either know it by a different
			// name or it has been deleted, renamed or moved since.
			// If this is a modify change notify, then search for a
			// corresponding DELETED or RENAMED_OLD_NAME change that might
			// be in the changelist by this same name (so can do a fast
			// case sensitive search).
			//
			// This will speed up the case (avoid disk enumerates) where
			// there are a bunch of changes that we are trying to process
			// for an item, but it has since been deleted.  It will prevent
			// us from re-enumerating the disk looking for the longname
			// and then also trying to prune out dead wood with a call to
			// AfpCacheDirectoryTree(REENUMERATE).
			//
			// This will pimp the case where a PC has made a change using
			// a different name than we know it by (and not deleted or
			// renamed the thing), but this case takes a back seat to the
			// other case that could happen when a mac app does a File-Save
			// doing a lot of writes followed by renames (or ExchangeFiles)
			// and deletes.
			//

			if ( (ChangeAction == FILE_ACTION_MODIFIED)  ||
				 (ChangeAction == FILE_ACTION_MODIFIED_STREAM) )
			{
				KIRQL			OldIrql;
				PLIST_ENTRY		pLink = &pVolDesc->vds_ChangeNotifyLookAhead;
				PVOL_NOTIFY 	pVolNotify;
				UNICODE_STRING	UName;
				PFILE_NOTIFY_INFORMATION	pFNInfo;

				ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

				while (pLink->Flink != &pVolDesc->vds_ChangeNotifyLookAhead)
				{
					pLink = pLink->Flink;
					pVolNotify = CONTAINING_RECORD(pLink, VOL_NOTIFY, vn_DelRenLink);
					pFNInfo = (PFILE_NOTIFY_INFORMATION) (pVolNotify + 1);

					AfpInitUnicodeStringWithNonNullTerm(&UName,
														(USHORT)pFNInfo->FileNameLength,
														pFNInfo->FileName);

					if (EQUAL_UNICODE_STRING_CS(pPath, &UName))
					{
						KeepLooking = False;
						DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_WARN,
								("afpFindEntryByNtPath: Found later REMOVE for %Z, Ignoring change\n", pPath));
						break;
					}
				}

				RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
			}

			if (KeepLooking)
			{
				pDfEntry = afpFindEntryByNtName(pVolDesc,
												pTail,
												pParentDfe);
			}
		}
		pParentDfe = pDfEntry;
	}

	// pParent is pointing to the parent component, we need the entire volume
	// relative path. Make it so. Do not bother if pParentDfe is NULL. Make
	// sure that we handle the case where there is only one component
	if (pParentDfe != NULL)
	{
		*pParent = *pPath;
		pParent->Length = pPath->Length - pTail->Length;
		if (pPath->Length > pTail->Length)
			pParent->Length -= sizeof(L'\\');
	}

	return pParentDfe;
}


/***	AfpAddDfEntry
 *
 *	Triggerred by the creation of a file/directory or discovery of a file/dir
 *	from an enumerate or pathmapping operation. If no AFP Id is supplied, a new
 *	id is assigned to this entity.  If an AFP Id is supplied (we know the Id
 *	is within our current range and does not collide with any other entry), then
 *	we use that Id.  An entry is created and linked in to the database and hash
 *	table. If this is an NTFS volume, the Id database header is marked
 *	dirty if we assigned a new AFP Id, and the volume modification time is
 *	updated.  The hash table overflow entries are sorted in descending AFP Id
 *	order.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	WRITE.
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 */
PDFENTRY
AfpAddDfEntry(
	IN	PVOLDESC			pVolDesc,
	IN	PDFENTRY			pDfeParent,
	IN	PUNICODE_STRING 	pUName,
	IN	BOOLEAN				fDirectory,
	IN	DWORD				AfpId		OPTIONAL
)
{
	PDFENTRY	pDfEntry;
	BOOLEAN		fSuccess;

	PAGED_CODE();

	ASSERT(DFE_IS_DIRECTORY(pDfeParent));

	do
	{
		if ((pDfEntry = ALLOC_DFE(USIZE_TO_INDEX(pUName->Length), fDirectory)) == NULL)
		{
			break;
		}

		pDfEntry->dfe_Flags = 0;

		if (!ARGUMENT_PRESENT((ULONG_PTR)AfpId))
			AfpId = afpGetNextId(pVolDesc);

		if (AfpId == 0)
		{
			// errorlog the case where the assigned Id has wrapped around.
			// call product suppport and have them tell you to copy
			// all the files from one volume onto another volume FROM A MAC
			//
			// NOTE:	How about a utility which will re-assign new ids on
			//			a volume after stopping the server ? A whole lot more
			//			palatable idea.
			FREE_DFE(pDfEntry);
			pDfEntry = NULL;
			break;
		}

		pDfEntry->dfe_AfpId = AfpId;

		// Initialize its parent
		pDfEntry->dfe_Parent = pDfeParent;

		// Copy the name
		AfpCopyUnicodeString(&pDfEntry->dfe_UnicodeName,
							 pUName);

		// And hash it
		afpHashUnicodeName(&pDfEntry->dfe_UnicodeName, &pDfEntry->dfe_NameHash);

		pDfEntry->dfe_NextOverflow = NULL;
		pDfEntry->dfe_NextSibling = NULL;

		// Now link this into the hash bucket, sorted in AFP Id descending order
		// and update the cache
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("AfpAddDfEntry: Linking DFE %lx( Id %ld) for %Z into %s bucket %ld\n",
				pDfEntry, pDfEntry->dfe_AfpId, pUName,
				fDirectory ? "Dir" : "File",
				fDirectory ? HASH_DIR_ID(AfpId,pVolDesc) : HASH_FILE_ID(AfpId,pVolDesc)));

		if (fDirectory)
		{
			DFE_SET_DIRECTORY(pDfEntry, pDfeParent->dfe_DirDepth);
		}
		else
		{
			DFE_SET_FILE(pDfEntry);
		}

		afpInsertDFEInHashBucket(pVolDesc, pDfEntry, fDirectory, &fSuccess);
		if (!fSuccess)
		{
			/* Out of id space - bail out */
			FREE_DFE(pDfEntry);
			pDfEntry = NULL;
			break;
		}

		if (fDirectory)
		{
			if ((pDfeParent->dfe_DirOffspring == 0) && !EXCLUSIVE_VOLUME(pVolDesc))
			{
				DWORD requiredLen;

				// check to see if we need to reallocate a bigger notify buffer.
				// The buffer must be large enough to hold a rename
				// notification (which will contain 2 FILE_NOTIFY_INFORMATION
				// structures) for the deepest element in the directory tree.
				requiredLen = (((pDfEntry->dfe_DirDepth + 1) *
							  ((AFP_FILENAME_LEN + 1) * sizeof(WCHAR))) +
							  FIELD_OFFSET(FILE_NOTIFY_INFORMATION, FileName)) * 2 ;

                if (requiredLen > pVolDesc->vds_RequiredNotifyBufLen)
                {
				    pVolDesc->vds_RequiredNotifyBufLen = requiredLen;
                }
			}
			pDfeParent->dfe_DirOffspring ++;
			pDfEntry->dfe_DirOffspring = 0;
			pDfEntry->dfe_FileOffspring = 0;
			pVolDesc->vds_NumDirDfEntries ++;

#ifdef AGE_DFES
			// These fields are relevant to directories only
			pDfEntry->dfe_pDirEntry->de_LastAccessTime = BEGINNING_OF_TIME;
			pDfEntry->dfe_pDirEntry->de_ChildForkOpenCount = 0;
#endif
			ASSERT((FIELD_OFFSET(DIRENTRY, de_ChildFile) -
					FIELD_OFFSET(DIRENTRY, de_ChildDir)) == sizeof(PVOID));

			// Insert it into its sibling chain
			afpInsertDirDFEInSiblingList(pDfeParent, pDfEntry);
		}
		else
		{
			pDfeParent->dfe_FileOffspring ++;
			pDfEntry->dfe_DataLen = 0;
			pDfEntry->dfe_RescLen = 0;
			pVolDesc->vds_NumFileDfEntries ++;

			// Insert it into its sibling chain
			afpInsertFileDFEInSiblingList(pDfeParent, pDfEntry);
		}

	} while (False);

	return pDfEntry;
}


/***	AfpRenameDfEntry
 *
 *	Triggered by a rename of a file/directory.  If the new name is longer than
 *	the current name, the DFEntry is freed and then reallocated to fit the new
 *	name.  A renamed file/dir must retain its original ID.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	WRITE.
 *
 *	LOCKS:	vds_VolLock (SPIN) for updating the IdDb header.
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 *	LOCK_ORDER: VolDesc lock after IdDb Swmr.
 *
 */
PDFENTRY
AfpRenameDfEntry(
	IN	PVOLDESC			pVolDesc,
	IN	PDFENTRY			pDfEntry,
	IN	PUNICODE_STRING		pNewName
)
{
	BOOLEAN		fDirectory;
	PDFENTRY	pNewDfEntry = pDfEntry;
	DWORD		OldIndex, NewIndex;

	PAGED_CODE( );

	ASSERT((pDfEntry != NULL) && (pNewName != NULL) && (pVolDesc != NULL));

	do
	{
		fDirectory = DFE_IS_DIRECTORY(pDfEntry);
		OldIndex = USIZE_TO_INDEX(pDfEntry->dfe_UnicodeName.MaximumLength);
		NewIndex = USIZE_TO_INDEX(pNewName->Length);
		if (OldIndex != NewIndex)
		{
			if ((pNewDfEntry = ALLOC_DFE(NewIndex, fDirectory)) == NULL)
			{
				pNewDfEntry = NULL;
				break;
			}

			// Careful here how the structures are copied
			RtlCopyMemory(pNewDfEntry,
						  pDfEntry,
						  FIELD_OFFSET(DFENTRY, dfe_CopyUpto));

			// Update the cache
			pVolDesc->vds_pDfeCache[HASH_CACHE_ID(pDfEntry->dfe_AfpId)] = pNewDfEntry;

			// fix up the overflow links from the hash table
			AfpUnlinkDouble(pDfEntry,
							dfe_NextOverflow,
							dfe_PrevOverflow);
			if (pDfEntry->dfe_NextOverflow != NULL)
			{
				AfpInsertDoubleBefore(pNewDfEntry,
									  pDfEntry->dfe_NextOverflow,
									  dfe_NextOverflow,
									  dfe_PrevOverflow);
			}
			else
			{
				*(pDfEntry->dfe_PrevOverflow) = pNewDfEntry;
				pNewDfEntry->dfe_NextOverflow = NULL;
			}

			// now fix any of this thing's children's parent pointers.
			if (fDirectory)
			{
				PDFENTRY	pTmp;
				LONG		i;
	
				// First copy the DirEntry structure
				if (fDirectory)
				{
					*pNewDfEntry->dfe_pDirEntry = *pDfEntry->dfe_pDirEntry;
				}

				// Start with Dir children
				if ((pTmp = pDfEntry->dfe_pDirEntry->de_ChildDir) != NULL)
				{
					// First fix up the first child's PrevSibling pointer
					pTmp->dfe_PrevSibling = &pNewDfEntry->dfe_pDirEntry->de_ChildDir;
	
					for (NOTHING;
						 pTmp != NULL;
						 pTmp = pTmp->dfe_NextSibling)
					{
						ASSERT(pTmp->dfe_Parent == pDfEntry);
						pTmp->dfe_Parent = pNewDfEntry;
					}
				}
	
				// Repeat for File childs as well
				for (i = 0; i < MAX_CHILD_HASH_BUCKETS; i++)
				{
					if ((pTmp = pDfEntry->dfe_pDirEntry->de_ChildFile[i]) != NULL)
					{
						// First  fix up the first child's PrevSibling pointer
						pTmp->dfe_PrevSibling = &pNewDfEntry->dfe_pDirEntry->de_ChildFile[i];
	
						for (NOTHING;
							 pTmp != NULL;
							 pTmp = pTmp->dfe_NextSibling)
						{
							ASSERT(pTmp->dfe_Parent == pDfEntry);
							pTmp->dfe_Parent = pNewDfEntry;
						}
					}
				}
			}
		}

		// Now fix the sibling relationships. Note that this needs to be done
		// regardless of whether a new dfe was created since these depend on
		// name hash which has potentially changed
		AfpUnlinkDouble(pDfEntry,
						dfe_NextSibling,
						dfe_PrevSibling);

		// Copy the new unicode name and create a new hash
		AfpCopyUnicodeString(&pNewDfEntry->dfe_UnicodeName,
							 pNewName);
		afpHashUnicodeName(&pNewDfEntry->dfe_UnicodeName, &pNewDfEntry->dfe_NameHash);

		// Insert it into its sibling chain
		afpInsertDFEInSiblingList(pNewDfEntry->dfe_Parent, pNewDfEntry, fDirectory);

		if (pDfEntry != pNewDfEntry)
			FREE_DFE(pDfEntry);

		AfpVolumeSetModifiedTime(pVolDesc);
	} while (False);

	return pNewDfEntry;
}


/***	AfpMoveDfEntry
 *
 *	Triggered by a move/rename-move of a file/dir.  A moved entity must retain
 *	its AfpId.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	WRITE.
 *
 *	LOCKS:	vds_VolLock (SPIN) for updating the IdDb header.
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 *	LOCK_ORDER: VolDesc lock after IdDb Swmr.
 *
 */
PDFENTRY
AfpMoveDfEntry(
	IN	PVOLDESC			pVolDesc,
	IN	PDFENTRY			pDfEntry,
	IN	PDFENTRY			pNewParentDFE,
	IN	PUNICODE_STRING		pNewName		OPTIONAL
)
{
	SHORT		depthDelta;					// This must be signed
	BOOLEAN		fDirectory;

	PAGED_CODE( );

	ASSERT((pDfEntry != NULL) && (pNewParentDFE != NULL) && (pVolDesc != NULL));

	// do we need to rename the DFEntry ?
	if (ARGUMENT_PRESENT(pNewName) &&
		!EQUAL_UNICODE_STRING(pNewName, &pDfEntry->dfe_UnicodeName, True))
	{
		if ((pDfEntry = AfpRenameDfEntry(pVolDesc,
										 pDfEntry,
										 pNewName)) == NULL)
		{
			return NULL;
		}
	}

	if (pDfEntry->dfe_Parent != pNewParentDFE)
	{
		// unlink the current entry from its parent/sibling associations (but not
		// the overflow hash bucket list since the AfpId has not changed.  The
		// children of this entity being moved (if its a dir and it has any) will
		// remain intact, and move along with the dir)
		AfpUnlinkDouble(pDfEntry, dfe_NextSibling, dfe_PrevSibling);

		fDirectory = DFE_IS_DIRECTORY(pDfEntry);

		// Decrement the old parent's offspring count & increment the new parent
		if (fDirectory)
		{
			ASSERT(pDfEntry->dfe_Parent->dfe_DirOffspring > 0);
			pDfEntry->dfe_Parent->dfe_DirOffspring --;
			pNewParentDFE->dfe_DirOffspring ++;

			// insert it into the new parent's child list
			afpInsertDirDFEInSiblingList(pNewParentDFE, pDfEntry);
		}
		else
		{
			ASSERT(pDfEntry->dfe_Parent->dfe_FileOffspring > 0);
			pDfEntry->dfe_Parent->dfe_FileOffspring --;
			pNewParentDFE->dfe_FileOffspring ++;
#ifdef	AGE_DFES
			if (IS_VOLUME_AGING_DFES(pVolDesc))
			{
				if (pDfEntry->dfe_Flags & DFE_FLAGS_R_ALREADYOPEN)
				{
					pDfEntry->dfe_Parent->dfe_pDirEntry->de_ChildForkOpenCount --;
					pNewParentDFE->dfe_pDirEntry->de_ChildForkOpenCount ++;
				}
				if (pDfEntry->dfe_Flags & DFE_FLAGS_D_ALREADYOPEN)
				{
					pDfEntry->dfe_Parent->dfe_pDirEntry->de_ChildForkOpenCount --;
					pNewParentDFE->dfe_pDirEntry->de_ChildForkOpenCount ++;
				}
			}
#endif
			// insert it into the new parent's child list
			afpInsertFileDFEInSiblingList(pNewParentDFE, pDfEntry);
		}

		pDfEntry->dfe_Parent = pNewParentDFE;

		// If we moved a directory, we must adjust the directory depths of the
		// directory, and all directories below it
		if (fDirectory &&
			((depthDelta = (pNewParentDFE->dfe_DirDepth + 1 - pDfEntry->dfe_DirDepth)) != 0))
		{
			PDFENTRY	pTmp = pDfEntry;

			while (True)
			{
				if ((pTmp->dfe_pDirEntry->de_ChildDir != NULL) &&
					(pTmp->dfe_DirDepth != (pTmp->dfe_Parent->dfe_DirDepth + 1)))
				{
					ASSERT(DFE_IS_DIRECTORY(pTmp));
					pTmp->dfe_DirDepth += depthDelta;
					pTmp = pTmp->dfe_pDirEntry->de_ChildDir;
				}
				else
				{
					ASSERT(DFE_IS_DIRECTORY(pTmp));
					if ((pTmp->dfe_DirDepth != pTmp->dfe_Parent->dfe_DirDepth + 1))
						pTmp->dfe_DirDepth += depthDelta;

					if (pTmp == pDfEntry)
						break;
					else if (pTmp->dfe_NextSibling != NULL)
						 pTmp = pTmp->dfe_NextSibling;
					else pTmp = pTmp->dfe_Parent;
				}
			}
		}
	}

	AfpVolumeSetModifiedTime(pVolDesc);

	return pDfEntry;
}


/***	AfpDeleteDfEntry
 *
 *	Trigerred by the deletion of a file/directory. The entry as well as the
 *	index is unlinked and freed.  If we are deleting a directory that is not
 *	empty, the entire directory tree underneath is deleted as well.  Note when
 *	implementing FPDelete, always attempt the delete from the actual file system
 *	first, then delete from the IdDB if that succeeds.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	WRITE.
 *
 *	LOCKS:	vds_VolLock (SPIN) for updating the IdDb header.
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 *	LOCK_ORDER: VolDesc lock after IdDb Swmr.
 */
VOID FASTCALL
AfpDeleteDfEntry(
	IN	PVOLDESC	pVolDesc,
	IN	PDFENTRY	pDfEntry
)
{
	PDFENTRY	pDfeParent = pDfEntry->dfe_Parent;
	LONG		i;
	BOOLEAN		Prune = False;

	PAGED_CODE( );

	ASSERT(pDfeParent != NULL);

	if (DFE_IS_DIRECTORY(pDfEntry))
	{
		for (i = 0; i < MAX_CHILD_HASH_BUCKETS; i++)
		{
			if (pDfEntry->dfe_pDirEntry->de_ChildFile[i] != NULL)
			{
				Prune = True;
				break;
			}
		}
		if ((pDfEntry->dfe_pDirEntry->de_ChildDir != NULL) || Prune)
		{
			// This will happen if a PC user deletes a tree behind our back
			AfpPruneIdDb(pVolDesc, pDfEntry);
		}
		ASSERT(pDfeParent->dfe_DirOffspring > 0);
		pDfeParent->dfe_DirOffspring --;
	}
	else
	{
		ASSERT(pDfeParent->dfe_FileOffspring > 0);
		pDfeParent->dfe_FileOffspring --;

		// The Finder is bad about deleting APPL mappings (it deletes
		// the file before deleting the APPL mapping so always gets
		// ObjectNotFound error for RemoveAPPL, and leaves turd mappings).
		if (pDfEntry->dfe_FinderInfo.fd_TypeD == *(PDWORD)"APPL")
		{
			AfpRemoveAppl(pVolDesc,
 						  pDfEntry->dfe_FinderInfo.fd_CreatorD,
						  pDfEntry->dfe_AfpId);
		}

	}

	// Unlink it now from the hash table
	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
			("AfpDeleteDfEntry: Unlinking from the hash table\n") );
	AfpUnlinkDouble(pDfEntry,
					dfe_NextOverflow,
					dfe_PrevOverflow);

	// Make sure we get rid of the cache if valid
	if (pVolDesc->vds_pDfeCache[HASH_CACHE_ID(pDfEntry->dfe_AfpId)] == pDfEntry)
		pVolDesc->vds_pDfeCache[HASH_CACHE_ID(pDfEntry->dfe_AfpId)] = NULL;

	// Seperate it now from its siblings
	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
			("AfpDeleteDfEntry: Unlinking from the sibling list\n") );
	AfpUnlinkDouble(pDfEntry,
					dfe_NextSibling,
					dfe_PrevSibling);

	(DFE_IS_DIRECTORY(pDfEntry)) ?
		pVolDesc->vds_NumDirDfEntries -- :
		pVolDesc->vds_NumFileDfEntries --;

	FREE_DFE(pDfEntry);

	AfpVolumeSetModifiedTime(pVolDesc);
}


/***	AfpPruneIdDb
 *
 *	Lops off a branch of the IdDb.  Called by network trash code when
 *	cleaning out the trash directory, or by directory enumerate code that
 *	has discovered a directory has been 'delnoded' by a PC user.  The
 *	IdDb sibling tree is traversed, and each node under the pDfeTarget node
 *	is deleted from the database and freed.  pDfeTarget itself is NOT
 *	deleted.  If necessary, the caller should delete the target itself.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	WRITE.
 *
 *	LOCKS:	vds_VolLock (SPIN) for updating the IdDb header.
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 *	LOCK_ORDER: VolDesc lock after IdDb Swmr.
 */
VOID FASTCALL
AfpPruneIdDb(
	IN	PVOLDESC	pVolDesc,
	IN	PDFENTRY	pDfeTarget
)
{
	PDFENTRY	pCurDfe = pDfeTarget, pDelDfe;
	LONG		i = 0;

	PAGED_CODE( );

	ASSERT((pVolDesc != NULL) && (pDfeTarget != NULL) &&
			(pDfeTarget->dfe_Flags & DFE_FLAGS_DIR));

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
			("AfpPruneIdDb entered...\n") );

	while (True)
	{
		ASSERT(DFE_IS_DIRECTORY(pCurDfe));

		// Delete all the file children of this node first
		for (i = 0; i < MAX_CHILD_HASH_BUCKETS; i++)
		{
			while ((pDelDfe = pCurDfe->dfe_pDirEntry->de_ChildFile[i]) != NULL)
			{
				AfpDeleteDfEntry(pVolDesc, pDelDfe);
			}
		}

		if (pCurDfe->dfe_pDirEntry->de_ChildDir != NULL)
		{
			pCurDfe = pCurDfe->dfe_pDirEntry->de_ChildDir;
		}
		else if (pCurDfe == pDfeTarget)
		{
			return;
		}
		else if (pCurDfe->dfe_NextSibling != NULL)
		{
			pDelDfe = pCurDfe;
			pCurDfe = pCurDfe->dfe_NextSibling;
			AfpDeleteDfEntry(pVolDesc, pDelDfe);
		}
		else
		{
			pDelDfe = pCurDfe;
			pCurDfe = pCurDfe->dfe_Parent;
			AfpDeleteDfEntry(pVolDesc, pDelDfe);
		}
	}
}


/***	AfpExchangeIdEntries
 *
 *	Called by AfpExchangeFiles api.
 *
 *	Callable from within the Fsp only. The caller should take Swmr lock for
 *	WRITE.
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 */
VOID
AfpExchangeIdEntries(
	IN	PVOLDESC	pVolDesc,
	IN	DWORD		AfpId1,
	IN	DWORD		AfpId2
)
{
	PDFENTRY pDFE1, pDFE2;
	DFENTRY	 DFEtemp;

	PAGED_CODE( );

	pDFE1 = AfpFindDfEntryById(pVolDesc, AfpId1, DFE_FILE);
	ASSERT(pDFE1 != NULL);

	pDFE2 = AfpFindDfEntryById(pVolDesc, AfpId2, DFE_FILE);
	ASSERT(pDFE2 != NULL);

    // a customer hit this problem on NT4 where one of the Dfe's was NULL!
    if (pDFE1 == NULL || pDFE2 == NULL)
    {
        ASSERT(0);
        return;
    }

	DFEtemp = *pDFE2;

	pDFE2->dfe_Flags = pDFE1->dfe_Flags;
	pDFE2->dfe_BackupTime  = pDFE1->dfe_BackupTime;
	pDFE2->dfe_LastModTime = pDFE1->dfe_LastModTime;
	pDFE2->dfe_DataLen = pDFE1->dfe_DataLen;
	pDFE2->dfe_RescLen = pDFE1->dfe_RescLen;
	pDFE2->dfe_NtAttr  = pDFE1->dfe_NtAttr;
	pDFE2->dfe_AfpAttr = pDFE1->dfe_AfpAttr;

	pDFE1->dfe_Flags = DFEtemp.dfe_Flags;
	pDFE1->dfe_BackupTime  = DFEtemp.dfe_BackupTime;
	pDFE1->dfe_LastModTime = DFEtemp.dfe_LastModTime;
	pDFE1->dfe_DataLen = DFEtemp.dfe_DataLen;
	pDFE1->dfe_RescLen = DFEtemp.dfe_RescLen;
	pDFE1->dfe_NtAttr  = DFEtemp.dfe_NtAttr;
	pDFE1->dfe_AfpAttr = DFEtemp.dfe_AfpAttr;
}


/***	AfpEnumerate
 *
 *	Enumerates files and dirs in a directory using the IdDb.
 *	An array of ENUMDIR structures is returned which represent
 *	the enumerated files and dirs.
 *
 *	Short Names
 *	ProDos Info
 *	Offspring count
 *	Permissions/Owner Id/Group Id
 *
 *	LOCKS: vds_idDbAccessLock (SWMR, Shared)
 *
 */
AFPSTATUS
AfpEnumerate(
	IN	PCONNDESC			pConnDesc,
	IN	DWORD				ParentDirId,
	IN	PANSI_STRING		pPath,
	IN	DWORD				BitmapF,
	IN	DWORD				BitmapD,
	IN	BYTE				PathType,
	IN	DWORD				DFFlags,
	OUT PENUMDIR *			ppEnumDir
)
{
	PENUMDIR		pEnumDir;
	PDFENTRY		pDfe, pTmp;
	PEIT			pEit;
	AFPSTATUS		Status;
	PATHMAPENTITY	PME;
	BOOLEAN			NeedHandle = False;
	FILEDIRPARM		FDParm;
	PVOLDESC		pVolDesc = pConnDesc->cds_pVolDesc;
	LONG			EnumCount;
	BOOLEAN			ReleaseSwmr = False, NeedWriteLock = False;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
			("AfpEnumerate Entered\n"));

	do
	{
		// Check if this enumeration matches the current enumeration
		if ((pEnumDir = pConnDesc->cds_pEnumDir) != NULL)
		{
			if ((pEnumDir->ed_ParentDirId == ParentDirId) &&
				(pEnumDir->ed_PathType == PathType) &&
				(pEnumDir->ed_TimeStamp >= pVolDesc->vds_ModifiedTime) &&
				(pEnumDir->ed_Bitmap == (BitmapF + (BitmapD << 16))) &&
				(((pPath->Length == 0) && (pEnumDir->ed_PathName.Length == 0)) ||
				 RtlCompareMemory(pEnumDir->ed_PathName.Buffer,
								 pPath->Buffer,
								 pPath->Length)))
			{
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
						("AfpEnumerate found cache hit\n"));
				INTERLOCKED_INCREMENT_LONG(&AfpServerStatistics.stat_EnumCacheHits);
				*ppEnumDir = pEnumDir;
				Status = AFP_ERR_NONE;
				break;
			}

			// Does not match, cleanup the previous entry
			AfpFreeMemory(pEnumDir);
			pConnDesc->cds_pEnumDir = NULL;
		}

		INTERLOCKED_INCREMENT_LONG(&AfpServerStatistics.stat_EnumCacheMisses);
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("AfpEnumerate creating new cache\n"));

		// We have no current enumeration. Create one now
		*ppEnumDir = NULL;
		AfpInitializeFDParms(&FDParm);
		AfpInitializePME(&PME, 0, NULL);

		if (IS_VOLUME_NTFS(pVolDesc))
		{
			NeedHandle = True;
		}
		Status = AfpMapAfpPathForLookup(pConnDesc,
										ParentDirId,
										pPath,
										PathType,
										DFE_DIR,
										DIR_BITMAP_DIRID |
											DIR_BITMAP_GROUPID |
											DIR_BITMAP_OWNERID |
											DIR_BITMAP_ACCESSRIGHTS |
											FD_INTERNAL_BITMAP_OPENACCESS_READCTRL |
											DIR_BITMAP_OFFSPRINGS,
										NeedHandle ? &PME : NULL,
										&FDParm);

		if (Status != AFP_ERR_NONE)
		{
			if (Status == AFP_ERR_OBJECT_NOT_FOUND)
				Status = AFP_ERR_DIR_NOT_FOUND;
			break;
		}

		if (NeedHandle)
		{
			AfpIoClose(&PME.pme_Handle);
		}

		// For admin, set all access bits
		if (pConnDesc->cds_pSda->sda_ClientType == SDA_CLIENT_ADMIN)
		{
			FDParm._fdp_UserRights = DIR_ACCESS_ALL | DIR_ACCESS_OWNER;
		}

		if ((BitmapF != 0) && (FDParm._fdp_UserRights & DIR_ACCESS_READ))
			DFFlags |= DFE_FILE;
		if ((BitmapD != 0) && (FDParm._fdp_UserRights & DIR_ACCESS_SEARCH))
			DFFlags |= DFE_DIR;

		// Catch access denied error here
		if (DFFlags == 0)
		{
			Status = AFP_ERR_ACCESS_DENIED;
			break;
		}

		// All is hunky-dory so far, go ahead with the enumeration now

#ifdef GET_CORRECT_OFFSPRING_COUNTS
	take_swmr_for_enum:
#endif
		NeedWriteLock ?
			AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock) :
			AfpSwmrAcquireShared(&pVolDesc->vds_IdDbAccessLock);
		ReleaseSwmr = True;

		// Lookup the dfentry of the AfpIdEnumDir
		if ((pDfe = AfpFindDfEntryById(pVolDesc,
										FDParm._fdp_AfpId,
										DFE_DIR)) == NULL)
		{
			Status = AFP_ERR_OBJECT_NOT_FOUND;
			break;
		}

		// Allocate a ENUMDIR structure and initialize it
		EnumCount = 0;
		if (DFFlags & DFE_DIR)
			EnumCount += (DWORD)(pDfe->dfe_DirOffspring);
		if (DFFlags & DFE_FILE)
			EnumCount += (DWORD)(pDfe->dfe_FileOffspring);

		if (EnumCount == 0)
		{
			Status = AFP_ERR_OBJECT_NOT_FOUND;
			break;
		}

		if ((pEnumDir = (PENUMDIR)AfpAllocNonPagedMemory(sizeof(ENUMDIR) +
														 pPath->MaximumLength +
														 EnumCount*sizeof(EIT))) == NULL)
		{
			Status = AFP_ERR_OBJECT_NOT_FOUND;
			break;
		}

		pEnumDir->ed_ParentDirId = ParentDirId;
		pEnumDir->ed_ChildCount = EnumCount;
		pEnumDir->ed_PathType = PathType;
		pEnumDir->ed_Bitmap = (BitmapF + (BitmapD << 16));
		pEnumDir->ed_BadCount = 0;
		pEnumDir->ed_pEit = pEit = (PEIT)((PBYTE)pEnumDir + sizeof(ENUMDIR));
		AfpSetEmptyAnsiString(&pEnumDir->ed_PathName,
							  pPath->MaximumLength,
							  (PBYTE)pEnumDir +
									sizeof(ENUMDIR) +
									EnumCount*sizeof(EIT));
		RtlCopyMemory(pEnumDir->ed_PathName.Buffer,
					  pPath->Buffer,
					  pPath->Length);

		*ppEnumDir = pConnDesc->cds_pEnumDir = pEnumDir;

		// Now copy the enum parameters (Afp Id and file/dir flag) of
		// each of the children, files first
		if (DFFlags & DFE_FILE)
		{
			LONG	i;

			for (i = 0; i < MAX_CHILD_HASH_BUCKETS; i++)
			{
				for (pTmp = pDfe->dfe_pDirEntry->de_ChildFile[i];
					 pTmp != NULL;
					 pTmp = pTmp->dfe_NextSibling, pEit ++)
				{
					ASSERT(!DFE_IS_DIRECTORY(pTmp));

					pEit->eit_Id = pTmp->dfe_AfpId;
					pEit->eit_Flags = DFE_FILE;
				}
			}
		}
		if (DFFlags & DFE_DIR)
		{
			for (pTmp = pDfe->dfe_pDirEntry->de_ChildDir;
				 pTmp != NULL;
				 pTmp = pTmp->dfe_NextSibling, pEit ++)
			{
				ASSERT(DFE_IS_DIRECTORY(pTmp));

				pEit->eit_Id = pTmp->dfe_AfpId;
				pEit->eit_Flags = DFE_DIR;

#ifdef GET_CORRECT_OFFSPRING_COUNTS
				// We are returning a directory offspring, make sure
				// that it has its children cached in so we get the correct
				// file and dir offspring counts for it, otherwise Finder
				// 'view by name' doesn't work correctly because it sees
				// zero as the offspring count and clicking on the triangle
				// shows nothing since it tries to be smart and doesn't
				// explicitly enumerate that dir if offspring count is zero.
				//
				// This can be a big performance hit if a directory has lots
				// of subdirectories which in turn have tons of files.
				//
				// JH - Could we alternately return incorrect information about
				//		files as long as there are directry children. What else
				//		will break ?
				// if (!DFE_CHILDREN_ARE_PRESENT(pTmp) && (pTmp->dfe_DirOffspring == 0))
				if (!DFE_CHILDREN_ARE_PRESENT(pTmp))
				{
					if (!AfpSwmrLockedExclusive(&pVolDesc->vds_IdDbAccessLock) &&
						!AfpSwmrUpgradeToExclusive(&pVolDesc->vds_IdDbAccessLock))
					{
						NeedWriteLock = True;
						AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
						ReleaseSwmr = False;
						// We must free the memory here in case the next
						// time we enumerate the dir it has more children
						// than it had the first time -- since we must let go
						// of the swmr here things could change.
						AfpFreeMemory(pEnumDir);
						*ppEnumDir = pConnDesc->cds_pEnumDir = NULL;
						goto take_swmr_for_enum;
					}

					AfpCacheDirectoryTree(pVolDesc,
										  pTmp,
										  GETFILES,
										  NULL,
										  NULL);
				} // if children not cached
#endif
			}
		}

		AfpGetCurrentTimeInMacFormat(&pEnumDir->ed_TimeStamp);
		Status = AFP_ERR_NONE;
	} while (False);

	if (ReleaseSwmr)
		AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

	return Status;
}


/***	AfpCatSearch
 *
 *	This routine does a left-hand search on the DFE tree to search for
 *  file/dirs that match the search criteria indicated in pFDParm1 and
 *  pFDParm2.
 *
 *	LOCKS: vds_idDbAccessLock (SWMR, Shared or Exclusive)
 */
AFPSTATUS
AfpCatSearch(
	IN	PCONNDESC			pConnDesc,
	IN	PCATALOGPOSITION	pCatPosition,
	IN	DWORD				Bitmap,
	IN	DWORD				FileBitmap,
	IN	DWORD				DirBitmap,
	IN	PFILEDIRPARM		pFDParm1,
	IN	PFILEDIRPARM		pFDParm2,
	IN	PUNICODE_STRING		pMatchString	OPTIONAL,
	IN OUT	PDWORD			pCount,
	IN  SHORT				Buflen,
	OUT	PSHORT				pSizeLeft,
	OUT	PBYTE				pResults,
	OUT	PCATALOGPOSITION	pNewCatPosition
)
{
	PVOLDESC	pVolDesc = pConnDesc->cds_pVolDesc;
	PDFENTRY	pCurParent, pCurFile;
	BOOLEAN		MatchFiles = True, MatchDirs = True, NewSearch = False;
	BOOLEAN		HaveSeeFiles, HaveSeeFolders, CheckAccess = False;
	AFPSTATUS	Status = AFP_ERR_NONE;
	LONG		i;
	DWORD		ActCount = 0;
	SHORT		SizeLeft = Buflen;
	PSWMR		pSwmr = &(pConnDesc->cds_pVolDesc->vds_IdDbAccessLock);
	USHORT		Flags;
	UNICODE_STRING	CurPath;

	typedef struct _SearchEntityPkt
	{
		BYTE	__Length;
		BYTE	__FileDirFlag;
		// The real parameters follow
	} SEP, *PSEP;
	PSEP 	pSep;

	PAGED_CODE( );

	pSep = (PSEP)pResults;
	RtlZeroMemory(pNewCatPosition, sizeof(CATALOGPOSITION));

  CatSearchStart:
	Flags = pCatPosition->cp_Flags;
	pCurFile = NULL;
	i = MAX_CHILD_HASH_BUCKETS;

	if (Flags & CATFLAGS_WRITELOCK_REQUIRED)
	{
		ASSERT(Flags == (CATFLAGS_SEARCHING_FILES | CATFLAGS_WRITELOCK_REQUIRED));
		AfpSwmrAcquireExclusive(pSwmr);
		Flags &= ~CATFLAGS_WRITELOCK_REQUIRED;
	}
	else
		AfpSwmrAcquireShared(pSwmr);

	if (Flags == 0)
	{
		//
		// Start search from beginning of catalog (i.e. the root directory)
		//
		i = 0;
		pCurParent = pVolDesc->vds_pDfeRoot;
		pCurFile = pCurParent->dfe_pDirEntry->de_ChildFile[0];
		if (IS_VOLUME_NTFS(pVolDesc))
			CheckAccess = True;
		Flags = CATFLAGS_SEARCHING_FILES;
		NewSearch = True;
	}
	else
	{
		//
		// This is a continuation of a previous search, pickup where we
		// left off
		//

		AFPTIME CurrentTime;

		AfpGetCurrentTimeInMacFormat(&CurrentTime);

		// If we cannot find the current parent dir specified by this
		// catalog position, or too much time has elapsed since the
		// user last sent in this catalog position, then restart the search
		// from the root dir.  The reason we have a time limitation is that
		// if someone made a CatSearch request N minutes ago, and the
		// current position is deep in the tree, the directory permissions
		// higher up in the tree could have changed by now so that the user
		// shouldn't even have access to this part of the tree anymore.
		// Since we do move up in the tree without rechecking permissions,
		// this could happen.  (We assume that if we got down to the current
		// position in the tree that we had to have had access higher up
		// in order to get here, so moving up is ok.  But if somebody comes
		// back a day later and continues the catsearch where it left off,
		// we shouldn't let them.)  It is too expensive to be rechecking
		// parents' parent permissions everytime we move back up the tree.
		if (((CurrentTime - pCatPosition->cp_TimeStamp) >= MAX_CATSEARCH_TIME) ||
			((pCurParent = AfpFindDfEntryById(pVolDesc,
											  pCatPosition->cp_CurParentId,
											  DFE_DIR)) == NULL))
		{
			// Start over from root directory
			Status = AFP_ERR_CATALOG_CHANGED;
			DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_WARN,
					("AfpCatSearch: Time diff >= MAX_CATSEARCH_TIME or couldn't find CurParent Id!\n"));
			pCurParent = pVolDesc->vds_pDfeRoot;
			Flags = CATFLAGS_SEARCHING_FILES;
			pSep = (PSEP)pResults;
			Status = AFP_ERR_NONE;
			MatchFiles = True;
			MatchDirs = True;
			SizeLeft = Buflen;
			ActCount = 0;
			if (IS_VOLUME_NTFS(pVolDesc))
				CheckAccess = True;
			NewSearch = True;
		}
		else if (pCatPosition->cp_TimeStamp < pVolDesc->vds_ModifiedTime)
		{
			Status = AFP_ERR_CATALOG_CHANGED;
			ASSERT(IS_VOLUME_NTFS(pVolDesc));
			DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_WARN,
					("AfpCatSearch: Catalog timestamp older than IdDb Modtime\n"));
		}

		ASSERT(DFE_IS_DIRECTORY(pCurParent));

		// If we need to resume searching the files for this parent, find the
		// one we should start with, if it is not the first file child.
		if (Flags & CATFLAGS_SEARCHING_FILES)
		{
			//
			// Default is to start with parent's first child which
			// may or may not be null depending on if the parent has had
			// its file children cached in or not.  If we are restarting a
			// search because we had to let go of the IdDb SWMR in order to
			// reaquire for Exclusive access, this parent's children could
			// very well have been cached in by someone else in the mean time.
			// If so then we will pick it up here.
			//
			i = 0;
			pCurFile = pCurParent->dfe_pDirEntry->de_ChildFile[0];

			if (pCatPosition->cp_NextFileId != 0)
			{

				// Find the DFE corresponding to the next fileID to look at
				if (((pCurFile = AfpFindDfEntryById(pVolDesc,
													pCatPosition->cp_NextFileId,
													DFE_FILE)) == NULL) ||
					(pCurFile->dfe_Parent != pCurParent))
				{
					// If we can't find the file that was specified, start over
					// with this parent's first file child and indicate there may
					// be duplicates returned or files missed
					Status = AFP_ERR_CATALOG_CHANGED;
					DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_WARN,
							 ("AfpCatSearch: Could not find file Child ID!\n"));
					i = 0;
					pCurFile = pCurParent->dfe_pDirEntry->de_ChildFile[0];
				}
				else
				{
					i = (pCurFile->dfe_NameHash % MAX_CHILD_HASH_BUCKETS);
				}
			}
		}
	}

	if (pFDParm1->_fdp_Flags == DFE_FLAGS_FILE_WITH_ID)
		MatchDirs = False;
	else if (pFDParm1->_fdp_Flags == DFE_FLAGS_DIR)
		MatchFiles = False;


	if (NewSearch && MatchDirs)
	{
		SHORT Length;

		ASSERT (DFE_IS_ROOT(pCurParent));

		// See if the volume root itself is a match
		if ((Length = AfpIsCatSearchMatch(pCurParent,
										  Bitmap,
										  DirBitmap,
										  pFDParm1,
										  pFDParm2,
										  pMatchString)) != 0)
		{
			ASSERT(Length <= SizeLeft);
			PUTSHORT2BYTE(&pSep->__Length, Length - sizeof(SEP));
			pSep->__FileDirFlag = FILEDIR_FLAG_DIR;

			afpPackSearchParms(pCurParent,
							   DirBitmap,
							   (PBYTE)pSep + sizeof(SEP));

			pSep = (PSEP)((PBYTE)pSep + Length);
			SizeLeft -= Length;
			ASSERT(SizeLeft >= 0);
			ActCount ++;
		}
	}
	NewSearch = False;

	while (True)
	{
		HaveSeeFiles = HaveSeeFolders = True;

		//
		// First time thru, if we are resuming a search and need to start
		// with the pCurParent's sibling, then do so.
		//
		if (Flags & CATFLAGS_SEARCHING_SIBLING)
		{
			Flags &= ~CATFLAGS_SEARCHING_SIBLING;
			goto check_sibling;
		}

		//
		// If we have not searched this directory yet and this is NTFS, check
		// that user has seefiles/seefolders access in this directory
		//
		if (CheckAccess)
		{
			BYTE		UserRights;
			NTSTATUS	PermStatus;

			ASSERT(IS_VOLUME_NTFS(pVolDesc));
			AfpSetEmptyUnicodeString(&CurPath, 0, NULL);

			// Get the root relative path of this directory
			if (NT_SUCCESS(AfpHostPathFromDFEntry(pCurParent,
												  0,
												  &CurPath)))
			{
				// Check for SeeFiles/SeeFolders which is the most common case
				if (!NT_SUCCESS((PermStatus = AfpCheckParentPermissions(pConnDesc,
																		pCurParent->dfe_AfpId,
																		&CurPath,
																		DIR_ACCESS_READ | DIR_ACCESS_SEARCH,
																		NULL,
																		&UserRights))))
				{
					if (PermStatus == AFP_ERR_ACCESS_DENIED)
					{
						if ((UserRights & DIR_ACCESS_READ) == 0)
							HaveSeeFiles = False;

						if ((UserRights & DIR_ACCESS_SEARCH) == 0)
							HaveSeeFolders = False;
					}
					else
						HaveSeeFiles = HaveSeeFolders = False;
				}

				if (CurPath.Buffer != NULL)
					AfpFreeMemory(CurPath.Buffer);
			}
			else
			{
				HaveSeeFiles = HaveSeeFolders = False;
				DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_ERR,
						("AfpCatSearch: Could not get host path from DFE!!\n"));
			}

			CheckAccess = False;
		}

		// Search the files first if have seefiles access on the current
		// parent and the user has asked for file matches.  If we are
		// resuming a search by looking at a directory child first, don't look
		// at the files.
		if (HaveSeeFiles && MatchFiles && (Flags & CATFLAGS_SEARCHING_FILES))
		{
			PDFENTRY	pDFE;
			SHORT		Length;
			AFPSTATUS	subStatus = AFP_ERR_NONE, subsubStatus = AFP_ERR_NONE;

			if (!DFE_CHILDREN_ARE_PRESENT(pCurParent))
			{
				if (!AfpSwmrLockedExclusive(pSwmr) &&
					!AfpSwmrUpgradeToExclusive(pSwmr))
				{
					if (ActCount > 0)
					{
						// We have at least one thing to return to the user,
						// so return it now and set the flag for next time
						// to take the write lock.
						pNewCatPosition->cp_NextFileId = 0;
						Flags |= CATFLAGS_WRITELOCK_REQUIRED;
						break; // out of while loop
					}
					else
					{
						// Let go of lock and reaquire it for exclusive
						// access.  Start over where we left off here if
						// possible.  Put a new timestamp in the catalog
						// position so if it changes between the time we let
						// go of the lock and reaquire it for exclusive access,
						// we will return AFP_ERR_CATALOG_CHANGED since
						// something could change while we don't own the lock.
						AfpSwmrRelease(pSwmr);
						pCatPosition->cp_Flags = CATFLAGS_WRITELOCK_REQUIRED |
												 CATFLAGS_SEARCHING_FILES;
						pCatPosition->cp_CurParentId = pCurParent->dfe_AfpId;
						pCatPosition->cp_NextFileId = 0;
						AfpGetCurrentTimeInMacFormat(&pCatPosition->cp_TimeStamp);
						DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_INFO,
								("AfpCatSearch: Lock released; reaquiring Exclusive\n"));
						goto CatSearchStart;
					}
				}

				AfpCacheDirectoryTree(pVolDesc,
									  pCurParent,
									  GETFILES,
									  NULL,
									  NULL);
				i = 0;
				pCurFile = pCurParent->dfe_pDirEntry->de_ChildFile[0];

				// If we have the exclusive lock, downgrade it to shared so
				// we don't lock out others who want to read.
				if (AfpSwmrLockedExclusive(pSwmr))
					AfpSwmrDowngradeToShared(pSwmr);
			}

			//
			// Search files for matches.  If we are picking up in the middle
			// of searching the files, then start with the right one as pointed
			// at by pCurFile.
			//
			while (TRUE)
			{
				while (pCurFile == NULL)
				{
					i ++;
					if (i < MAX_CHILD_HASH_BUCKETS)
					{
						pCurFile = pCurParent->dfe_pDirEntry->de_ChildFile[i];
					}
					else
					{
						subsubStatus = STATUS_NO_MORE_FILES;
						break; // out of while (pCurFile == NULL)
					}
				}

				if (subsubStatus != AFP_ERR_NONE)
				{
					break;
				}

				ASSERT(pCurFile->dfe_Parent == pCurParent);

				if ((Length = AfpIsCatSearchMatch(pCurFile,
												  Bitmap,
												  FileBitmap,
												  pFDParm1,
												  pFDParm2,
												  pMatchString)) != 0)
				{
					// Add this to the output buffer if there is room
					if ((Length <= SizeLeft) && (ActCount < *pCount))
					{
						PUTSHORT2BYTE(&pSep->__Length, Length - sizeof(SEP));
						pSep->__FileDirFlag = FILEDIR_FLAG_FILE;

						afpPackSearchParms(pCurFile,
										   FileBitmap,
										   (PBYTE)pSep + sizeof(SEP));

						pSep = (PSEP)((PBYTE)pSep + Length);
						SizeLeft -= Length;
						ASSERT(SizeLeft >= 0);
						ActCount ++;
					}
					else
					{
						// We don't have enough room to return this entry, or
						// we already have found the requested count.  So this
						// will be where we pick up from on the next search
						pNewCatPosition->cp_NextFileId = pCurFile->dfe_AfpId;
						subStatus = STATUS_BUFFER_OVERFLOW;
						break;
					}
				}
                pCurFile = pCurFile->dfe_NextSibling;
			}

			if (subStatus != AFP_ERR_NONE)
			{
				break;	// out of while loop
			}

			Flags = 0;
		}

		// If have seefolders on curparent and curparent has a dir child,
		// Move down the tree to the parent's first directory branch
		if (HaveSeeFolders && (pCurParent->dfe_pDirEntry->de_ChildDir != NULL))
		{
			SHORT Length;

			// If user has asked for directory matches, try the parent's
			// first directory child as a match
			if (MatchDirs &&
				((Length = AfpIsCatSearchMatch(pCurParent->dfe_pDirEntry->de_ChildDir,
											   Bitmap,
											   DirBitmap,
											   pFDParm1,
											   pFDParm2,
											   pMatchString)) != 0))
			{
				// Add this to the output buffer if there is room
				if ((Length <= SizeLeft) && (ActCount < *pCount))
				{
					PUTSHORT2BYTE(&pSep->__Length, Length - sizeof(SEP));
					pSep->__FileDirFlag = FILEDIR_FLAG_DIR;

					afpPackSearchParms(pCurParent->dfe_pDirEntry->de_ChildDir,
									   DirBitmap,
									   (PBYTE)pSep + sizeof(SEP));

					pSep = (PSEP)((PBYTE)pSep + Length);
					SizeLeft -= Length;
					ASSERT(SizeLeft >= 0);
					ActCount ++;
				}
				else
				{
					// We don't have enough room to return this entry, so
					// it will be where we pick up from on the next search
					Flags = CATFLAGS_SEARCHING_DIRCHILD;
					break;
				}
			}

			// Make the current parent's first dir child the new pCurParent
			// and continue the search from there.
			pCurParent = pCurParent->dfe_pDirEntry->de_ChildDir;
			if (IS_VOLUME_NTFS(pVolDesc))
				CheckAccess = True;
			Flags = CATFLAGS_SEARCHING_FILES;
			i = 0;
			pCurFile = pCurParent->dfe_pDirEntry->de_ChildFile[0];
			continue;
		}

		// We either don't have the access rights to go into any directories
		// under this parent, or the current parent did not have any directory
		// children.  See if it has any siblings.  We know we have access to
		// see this level of siblings since we are at this level in the first
		// place.
  check_sibling:
		if (pCurParent->dfe_NextSibling != NULL)
		{
			SHORT 	Length;

			// If user has asked for directory matches, try the parent's
			// next sibling as a match
			if (MatchDirs &&
				((Length = AfpIsCatSearchMatch(pCurParent->dfe_NextSibling,
											   Bitmap,
											   DirBitmap,
											   pFDParm1,
											   pFDParm2,
											   pMatchString)) != 0))
			{
				// Add this to the output buffer if there is room
				if ((Length <= SizeLeft) && (ActCount < *pCount))
				{
					PUTSHORT2BYTE(&pSep->__Length, Length - sizeof(SEP));
					pSep->__FileDirFlag = FILEDIR_FLAG_DIR;

					afpPackSearchParms(pCurParent->dfe_NextSibling,
									   DirBitmap,
									   (PBYTE)pSep + sizeof(SEP));

					pSep = (PSEP)((PBYTE)pSep + Length);
					SizeLeft -= Length;
					ASSERT(SizeLeft >= 0);
					ActCount ++;
				}
				else
				{
					// We don't have enough room to return this entry, so
					// it will be where we pick up from on the next search
					Flags = CATFLAGS_SEARCHING_SIBLING;
					break;
				}
			}

			// Make the current parent's next sibling the new pCurParent and
			// continue the search from there
			pCurParent = pCurParent->dfe_NextSibling;
			if (IS_VOLUME_NTFS(pVolDesc))
				CheckAccess = True;
			Flags = CATFLAGS_SEARCHING_FILES;
			i = 0;
			pCurFile = pCurParent->dfe_pDirEntry->de_ChildFile[0];
			continue;
		}

		// When we hit the root directory again we have searched everything.
		if (DFE_IS_ROOT(pCurParent))
		{
			Status = AFP_ERR_EOF;
			break;
		}

		// Move back up the tree and see if the parent has a sibling to
		// traverse.  If not, then it will come back here and move up
		// the tree again till it finds a node with a sibling or hits
		// the root.
		pCurParent = pCurParent->dfe_Parent;
		goto check_sibling;
	}

	if ((Status == AFP_ERR_NONE) || (Status == AFP_ERR_CATALOG_CHANGED) ||
		(Status == AFP_ERR_EOF))
	{
		// return the current catalog position and number of items returned
		if (Status != AFP_ERR_EOF)
		{
			ASSERT(Flags != 0);
			ASSERT(ActCount > 0);
			pNewCatPosition->cp_Flags = Flags;
			pNewCatPosition->cp_CurParentId = pCurParent->dfe_AfpId;
			AfpGetCurrentTimeInMacFormat(&pNewCatPosition->cp_TimeStamp);
		}
		*pCount = ActCount;
		ASSERT(SizeLeft >= 0);
		*pSizeLeft = SizeLeft;
	}

	AfpSwmrRelease(pSwmr);

	return Status;
}


/***	afpPackSearchParms
 *
 *
 * 	LOCKS_ASSUMED: vds_IdDbAccessLock (Shared or Exclusive)
 */
VOID
afpPackSearchParms(
	IN	PDFENTRY	pDfe,
	IN	DWORD		Bitmap,
	IN	PBYTE		pBuf
)
{
	DWORD		Offset = 0;
	ANSI_STRING	AName;
	BYTE		NameBuf[AFP_LONGNAME_LEN+1];

	PAGED_CODE( );

    RtlZeroMemory (NameBuf, AFP_LONGNAME_LEN+1);

	if (Bitmap & FD_BITMAP_PARENT_DIRID)
	{
		PUTDWORD2DWORD(pBuf, pDfe->dfe_Parent->dfe_AfpId);
		Offset += sizeof(DWORD);
	}
	if (Bitmap & FD_BITMAP_LONGNAME)
	{
		PUTDWORD2SHORT(pBuf + Offset, Offset + sizeof(USHORT));
		Offset += sizeof(USHORT);
#ifndef DBCS
// 1996.09.26 V-HIDEKK
		PUTSHORT2BYTE(pBuf + Offset, pDfe->dfe_UnicodeName.Length/sizeof(WCHAR));
#endif
		AfpInitAnsiStringWithNonNullTerm(&AName, sizeof(NameBuf), NameBuf);
		AfpConvertMungedUnicodeToAnsi(&pDfe->dfe_UnicodeName,
									  &AName);
#ifdef DBCS
// FiX #11992 SFM: As a result of search, I get incorrect file information.
// 1996.09.26 V-HIDEKK
        PUTSHORT2BYTE(pBuf + Offset, AName.Length);
#endif

		RtlCopyMemory(pBuf + Offset + sizeof(BYTE),
					  NameBuf,
					  AName.Length);
#ifdef DBCS
// FiX #11992 SFM: As a result of search, I get incorrect file information.
// 1996.09.26 V-HIDEKK
        Offset += sizeof(BYTE) + AName.Length;
#else
		Offset += sizeof(BYTE) + pDfe->dfe_UnicodeName.Length/sizeof(WCHAR);
#endif
	}

	if (Offset & 1)
		*(pBuf + Offset) = 0;
}


/***	AfpSetDFFileFlags
 *
 *	Set or clear the DAlreadyOpen or RAlreadyOpen flags for a DFEntry of type
 *	File, or mark the file as having a FileId assigned.
 *
 *	LOCKS: vds_idDbAccessLock (SWMR, Exclusive)
 */
AFPSTATUS
AfpSetDFFileFlags(
	IN	PVOLDESC		pVolDesc,
	IN	DWORD			AfpId,
	IN	DWORD			Flags		OPTIONAL,
	IN	BOOLEAN			SetFileId,
	IN	BOOLEAN			ClrFileId
)
{
	PDFENTRY		pDfeFile;
	AFPSTATUS		Status = AFP_ERR_NONE;

	PAGED_CODE( );

	ASSERT(!(SetFileId | ClrFileId) || (SetFileId ^ ClrFileId));

	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	pDfeFile = AfpFindDfEntryById(pVolDesc, AfpId, DFE_FILE);
	if (pDfeFile != NULL)
	{
#ifdef	AGE_DFES
		if (IS_VOLUME_AGING_DFES(pVolDesc))
		{
			if (Flags)
			{
				pDfeFile->dfe_Parent->dfe_pDirEntry->de_ChildForkOpenCount ++;
			}
		}
#endif
		pDfeFile->dfe_Flags |=  (Flags & DFE_FLAGS_OPEN_BITS);
		if (SetFileId)
		{
			if (DFE_IS_FILE_WITH_ID(pDfeFile))
				Status = AFP_ERR_ID_EXISTS;
			DFE_SET_FILE_ID(pDfeFile);
		}
		if (ClrFileId)
		{
			if (!DFE_IS_FILE_WITH_ID(pDfeFile))
				Status = AFP_ERR_ID_NOT_FOUND;
			DFE_CLR_FILE_ID(pDfeFile);
		}
	}
	else Status = AFP_ERR_OBJECT_NOT_FOUND;

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
	return Status;
}


/***	AfpCacheParentModTime
 *
 *	When the contents of a directory change, the parent LastMod time must be
 *  updated.  Since we don't want to wait for a notification of this,
 *  certain apis must go query for the new parent mod time and cache it.
 *  These include:  CreateDir, CreateFile, CopyFile (Dest), Delete,
 *  Move (Src & Dest), Rename and ExchangeFiles.
 *
 *  LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Exclusive)
 */
VOID
AfpCacheParentModTime(
	IN	PVOLDESC		pVolDesc,
	IN	PFILESYSHANDLE	pHandle		OPTIONAL,	// if pPath not supplied
	IN	PUNICODE_STRING	pPath		OPTIONAL,	// if pHandle not supplied
	IN	PDFENTRY		pDfeParent	OPTIONAL,	// if ParentId not supplied
	IN	DWORD			ParentId	OPTIONAL 	// if pDfeParent not supplied
)
{
	FILESYSHANDLE	fshParent;
	PFILESYSHANDLE 	phParent;
	NTSTATUS		Status;

	PAGED_CODE( );

	ASSERT(AfpSwmrLockedExclusive(&pVolDesc->vds_IdDbAccessLock));

	if (!ARGUMENT_PRESENT(pDfeParent))
	{
		ASSERT(ARGUMENT_PRESENT((ULONG_PTR)ParentId));
		pDfeParent = AfpFindDfEntryById(pVolDesc, ParentId, DFE_DIR);
		if (pDfeParent == NULL)
		{
			return;
		}
	}

	if (!ARGUMENT_PRESENT(pHandle))
	{
		ASSERT(ARGUMENT_PRESENT(pPath));
		Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
							AFP_STREAM_DATA,
							FILEIO_OPEN_DIR,
							pPath,
							FILEIO_ACCESS_NONE,
							FILEIO_DENY_NONE,
							False,
							&fshParent);
		if (!NT_SUCCESS(Status))
		{
			return;
		}
		phParent = &fshParent;
	}
	else
	{
		ASSERT(pHandle->fsh_FileHandle != NULL);
		phParent = pHandle;
	}

	AfpIoQueryTimesnAttr(phParent,
						 NULL,
						 &pDfeParent->dfe_LastModTime,
						 NULL);
	if (!ARGUMENT_PRESENT(pHandle))
	{
		AfpIoClose(&fshParent);
	}
}


/***	afpAllocDfe
 *
 *	Allocate a DFE from the DFE Blocks. The DFEs are allocated in 4K chunks and internally
 *	managed. The idea is primarily to reduce the number of faults we may take during
 *	enumeration/pathmap code in faulting in multiple pages to get multiple DFEs.
 *
 *	The DFEs are allocated out of paged memory.
 *
 *	It is important to keep blocks which are all used up at the end, so that if we hit a
 *	block which is empty, we can stop.
 *
 *	LOCKS:	afpDfeBlockLock (SWMR, Exclusive)
 */
LOCAL PDFENTRY FASTCALL
afpAllocDfe(
	IN	LONG	Index,
	IN	BOOLEAN	fDir
)
{
	PDFEBLOCK	pDfb;
	PDFENTRY	pDfEntry = NULL;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;

	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_DFEAllocCount);
	AfpGetPerfCounter(&TimeS);
#endif

	PAGED_CODE( );

	ASSERT ((Index >= 0) && (Index < MAX_BLOCK_TYPE));

	AfpSwmrAcquireExclusive(&afpDfeBlockLock);

	// If the block head has no free entries then there are none !!
	// Pick the right block based on whether it is file or dir
	pDfb = fDir ? afpDirDfePartialBlockHead[Index] : afpFileDfePartialBlockHead[Index];
	if (pDfb == NULL)
	{
		//
		// There are no partial blocks. Check if there any free ones and if there move them to partial
		// since we about to allocate from them
		//
		if (fDir)
		{
			pDfb = afpDirDfeFreeBlockHead[Index];
			if (pDfb != NULL)
			{
				AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);
				AfpLinkDoubleAtHead(afpDirDfePartialBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
			}
		}
		else
		{
			pDfb = afpFileDfeFreeBlockHead[Index];
			if (pDfb != NULL)
			{
				AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);
				AfpLinkDoubleAtHead(afpFileDfePartialBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
			}
		}
	}

	if (pDfb != NULL)

	{
		ASSERT(VALID_DFB(pDfb));
		ASSERT((fDir && (pDfb->dfb_NumFree <= afpDfeNumDirBlocks[Index])) ||
			   (!fDir && (pDfb->dfb_NumFree <= afpDfeNumFileBlocks[Index])));

		ASSERT (pDfb->dfb_NumFree != 0);
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("afpAllocDfe: Found space in Block %lx\n", pDfb));
	}

	if (pDfb == NULL)
	{
		ASSERT(QUAD_SIZED(sizeof(DFEBLOCK)));
		ASSERT(QUAD_SIZED(sizeof(DIRENTRY)));
		ASSERT(QUAD_SIZED(sizeof(DFENTRY)));

		if ((pDfb = (PDFEBLOCK)AfpAllocateVirtualMemoryPage()) != NULL)
		{
			LONG	i;
			USHORT	DfeSize, UnicodeSize, MaxDfes, DirEntrySize;

#if	DBG
			afpDfbAllocCount ++;
#endif
			UnicodeSize = afpDfeUnicodeBufSize[Index];

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpAllocDfe: No free %s blocks. Allocated a new block %lx for index %ld\n",
					fDir ? "Dir" : "File", pDfb, Index));

			//
           	// Link it in the partial list as we are about to allocate one block out of it anyway.
			//
			if (fDir)
			{
				AfpLinkDoubleAtHead(afpDirDfePartialBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
				DfeSize = afpDfeDirBlockSize[Index];
				pDfb->dfb_NumFree = MaxDfes = afpDfeNumDirBlocks[Index];
				DirEntrySize = sizeof(DIRENTRY);
			}
			else
			{
				AfpLinkDoubleAtHead(afpFileDfePartialBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
				DfeSize = afpDfeFileBlockSize[Index];
				pDfb->dfb_NumFree = MaxDfes = afpDfeNumFileBlocks[Index];
				DirEntrySize = 0;
			}

			ASSERT(QUAD_SIZED(DfeSize));
			pDfb->dfb_fDir = fDir;
			pDfb->dfb_Age = 0;

			// Initialize the list of free dfentries
			for (i = 0, pDfEntry = pDfb->dfb_FreeHead = (PDFENTRY)((PBYTE)pDfb + sizeof(DFEBLOCK));
				 i < MaxDfes;
				 i++, pDfEntry = pDfEntry->dfe_NextFree)
			{
				pDfEntry->dfe_NextFree = (i == (MaxDfes - 1)) ?
											NULL :
											(PDFENTRY)((PBYTE)pDfEntry + DfeSize);
				pDfEntry->dfe_pDirEntry = fDir ?
								pDfEntry->dfe_pDirEntry = (PDIRENTRY)((PCHAR)pDfEntry+sizeof(DFENTRY)) : NULL;
				pDfEntry->dfe_UnicodeName.Buffer = (PWCHAR)((PCHAR)pDfEntry+
															DirEntrySize+
															sizeof(DFENTRY));
				pDfEntry->dfe_UnicodeName.MaximumLength = UnicodeSize;
			}
		}
        else
        {
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
					("afpAllocDfe: AfpAllocateVirtualMemoryPage failed\n"));

            AFPLOG_ERROR(AFPSRVMSG_VIRTMEM_ALLOC_FAILED,
                         STATUS_INSUFFICIENT_RESOURCES,
                         NULL,
                         0,
                         NULL);
        }
	}

	if (pDfb != NULL)
	{
		PDFEBLOCK	pTmp;

		ASSERT(VALID_DFB(pDfb));

		pDfEntry = pDfb->dfb_FreeHead;
		ASSERT(VALID_DFE(pDfEntry));
		ASSERT(pDfb->dfb_fDir ^ (pDfEntry->dfe_pDirEntry == NULL));
#if	DBG
		afpDfeAllocCount ++;
#endif
		pDfb->dfb_FreeHead = pDfEntry->dfe_NextFree;
		pDfb->dfb_NumFree --;

		//
		// If the block is now empty (completely used), unlink it from here and move it
		// to the Used list.
		//
		if (pDfb->dfb_NumFree == 0)
		{
			AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);
			if (fDir)
			{
				AfpLinkDoubleAtHead(afpDirDfeUsedBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
			}
			else
			{
				AfpLinkDoubleAtHead(afpFileDfeUsedBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
			}
		}

		pDfEntry->dfe_UnicodeName.Length = 0;
	}

	AfpSwmrRelease(&afpDfeBlockLock);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_DFEAllocTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	if ((pDfEntry != NULL) &&
		(pDfEntry->dfe_pDirEntry != NULL))
	{
		// For a directory ZERO out the directory entry
		RtlZeroMemory(&pDfEntry->dfe_pDirEntry->de_ChildDir, sizeof(DIRENTRY));
	}

	return pDfEntry;
}


/***	afpFreeDfe
 *
 *	Return a DFE to the allocation block.
 *
 *	LOCKS:	afpDfeBlockLock (SWMR, Exclusive)
 */
LOCAL VOID FASTCALL
afpFreeDfe(
	IN	PDFENTRY	pDfEntry
)
{
	PDFEBLOCK	pDfb;
	USHORT		NumBlks, index;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;

	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_DFEFreeCount);
	AfpGetPerfCounter(&TimeS);
#endif

	PAGED_CODE( );

	// NOTE: The following code *depends* on the fact that we allocate DFBs as
	//		 64K blocks and also that these are allocated *at* 64K boundaries
	//		 This lets us *cheaply* get to the owning DFB from the DFE.
	pDfb = (PDFEBLOCK)((ULONG_PTR)pDfEntry & ~(PAGE_SIZE-1));
	ASSERT(VALID_DFB(pDfb));
	ASSERT(pDfb->dfb_fDir ^ (pDfEntry->dfe_pDirEntry == NULL));

	AfpSwmrAcquireExclusive(&afpDfeBlockLock);

#if	DBG
	afpDfeAllocCount --;
#endif

	index = USIZE_TO_INDEX(pDfEntry->dfe_UnicodeName.MaximumLength);
	NumBlks = (pDfb->dfb_fDir) ? afpDfeNumDirBlocks[index] : afpDfeNumFileBlocks[index];

	ASSERT((pDfb->dfb_fDir && (pDfb->dfb_NumFree < NumBlks)) ||
		   (!pDfb->dfb_fDir && (pDfb->dfb_NumFree < NumBlks)));

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
			("AfpFreeDfe: Returning pDfEntry %lx to Block %lx, size %d\n",
			pDfEntry, pDfb, pDfEntry->dfe_UnicodeName.MaximumLength));

	pDfb->dfb_NumFree ++;
	pDfEntry->dfe_NextFree = pDfb->dfb_FreeHead;
	pDfb->dfb_FreeHead = pDfEntry;

	if (pDfb->dfb_NumFree == 1)
	{
		LONG		Index;

		//
		// The block is now partially free (it used to be completely used). move it to the partial list.
		//

		Index = USIZE_TO_INDEX(pDfEntry->dfe_UnicodeName.MaximumLength);
		AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);
		if (pDfb->dfb_fDir)
		{
			AfpLinkDoubleAtHead(afpDirDfePartialBlockHead[Index],
								pDfb,
								dfb_Next,
								dfb_Prev);
		}
		else
		{
			AfpLinkDoubleAtHead(afpFileDfePartialBlockHead[Index],
								pDfb,
								dfb_Next,
								dfb_Prev);
		}
	}
	else if (pDfb->dfb_NumFree == NumBlks)
	{
		LONG		Index;

		//
		// The block is now completely free (used to be partially used). move it to the free list
		//

		Index = USIZE_TO_INDEX(pDfEntry->dfe_UnicodeName.MaximumLength);
		pDfb->dfb_Age = 0;
		AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);

		if (AfpServerState == AFP_STATE_STOP_PENDING)
		{
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpFreeDfe: Freeing Block %lx\n", pDfb));
			AfpFreeVirtualMemoryPage(pDfb);
#if	DBG
			afpDfbAllocCount --;
#endif
		}

		else
		{
			if (pDfb->dfb_fDir)
			{
				AfpLinkDoubleAtHead(afpDirDfeFreeBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
			}
			else
			{
				AfpLinkDoubleAtHead(afpFileDfeFreeBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
			}
		}
	}

	AfpSwmrRelease(&afpDfeBlockLock);
#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_DFEFreeTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
}


/***	afpDfeBlockAge
 *
 *	Age out Dfe Blocks
 *
 *	LOCKS:	afpDfeBlockLock (SWMR, Exclusive)
 */
AFPSTATUS FASTCALL
afpDfeBlockAge(
	IN	PPDFEBLOCK	ppBlockHead
)
{
	int			index, MaxDfes;
	PDFEBLOCK	pDfb;

	PAGED_CODE( );

	AfpSwmrAcquireExclusive(&afpDfeBlockLock);

	for (index = 0; index < MAX_BLOCK_TYPE; index++)
	{
		pDfb = ppBlockHead[index];
		if (pDfb != NULL)
		{
			MaxDfes = pDfb->dfb_fDir ? afpDfeNumDirBlocks[index] : afpDfeNumFileBlocks[index];
		}

		while (pDfb != NULL)
		{
			PDFEBLOCK	pFree;

			ASSERT(VALID_DFB(pDfb));

			pFree = pDfb;
			pDfb = pDfb->dfb_Next;

			ASSERT (pFree->dfb_NumFree == MaxDfes);

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpDfeBlockAge: Aging Block %lx, Size %d\n", pFree,
					pFree->dfb_fDir ? afpDfeDirBlockSize[index] : afpDfeFileBlockSize[index]));
			if (++(pFree->dfb_Age) >= MAX_BLOCK_AGE)
			{
#ifdef	PROFILING
				INTERLOCKED_INCREMENT_LONG( &AfpServerProfile->perf_DFEAgeCount);
#endif
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
						("afpDfeBlockAge: Freeing Block %lx, Size %d\n", pFree,
						pDfb->dfb_fDir ? afpDfeDirBlockSize[index] : afpDfeFileBlockSize[index]));
				AfpUnlinkDouble(pFree, dfb_Next, dfb_Prev);
				AfpFreeVirtualMemoryPage(pFree);
#if	DBG
				afpDfbAllocCount --;
#endif
			}
		}
	}

	AfpSwmrRelease(&afpDfeBlockLock);

	return AFP_ERR_REQUEUE;
}


/***	AfpInitIdDb
 *
 *	This routine initializes the memory image (and all related volume descriptor
 *	fields) of the ID index database for a new volume.  The entire tree is
 *  scanned so all the file/dir cached info can be read in and our view of
 *  the volume tree will be complete.  If an index database already exists
 *  on the disk for the volume root directory, that stream is read in. If this
 *	is a newly created volume, the Afp_IdIndex stream is created on the root of
 *	the volume.  If this is a CDFS volume, only the memory image is initialized.
 *
 *	The IdDb is not locked since the volume is still 'in transition' and not
 *	accessed by anybody.
 */
NTSTATUS FASTCALL
AfpInitIdDb(
	IN	PVOLDESC    pVolDesc,
    OUT BOOLEAN    *pfNewVolume,
    OUT BOOLEAN    *pfVerifyIndex
)
{
	NTSTATUS		Status;
	ULONG			CreateInfo;
	FILESYSHANDLE	fshIdDb;
    IDDBHDR         IdDbHdr;
    BOOLEAN         fLogEvent=FALSE;


	PAGED_CODE( );

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
			("AfpInitIdDb: Initializing Id Database...\n"));

    *pfNewVolume = FALSE;

	do
	{
		afpInitializeIdDb(pVolDesc);

		// if this is not a CDFS volume, attempt to create the ID DB header
		// stream.  If it already exists, open it and read it in.
		if (IS_VOLUME_NTFS(pVolDesc))
		{
			// Force the scavenger to write out the IdDb and header when the
			// volume is successfully added
			pVolDesc->vds_Flags |= VOLUME_IDDBHDR_DIRTY;

			Status = AfpIoCreate(&pVolDesc->vds_hRootDir,
								AFP_STREAM_IDDB,
								&UNullString,
								FILEIO_ACCESS_READWRITE,
								FILEIO_DENY_WRITE,
								FILEIO_OPEN_FILE_SEQ,
								FILEIO_CREATE_INTERNAL,
								FILE_ATTRIBUTE_NORMAL,
								False,
								NULL,
								&fshIdDb,
								&CreateInfo,
								NULL,
								NULL,
								NULL);

			if (!NT_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
					("AfpInitIdDb: AfpIoCreate failed with %lx\n", Status));
                ASSERT(0);

                fLogEvent = TRUE;
				break;
			}

			if (CreateInfo == FILE_OPENED)
			{
				// read in the existing header. If we fail, just start from scratch
				Status = afpReadIdDb(pVolDesc, &fshIdDb, pfVerifyIndex);
				if (!NT_SUCCESS(Status) || (pVolDesc->vds_pDfeRoot == NULL))
					CreateInfo = FILE_CREATED;
			}

			if (CreateInfo == FILE_CREATED)
			{
				// add the root and parent of root to the idindex
				// and initialize a new header
				Status = afpSeedIdDb(pVolDesc);
                *pfNewVolume = TRUE;
			}
			else if (CreateInfo != FILE_OPENED)
			{
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
					("AfpInitIdDb: unexpected create action 0x%lx\n", CreateInfo));
				ASSERTMSG("Unexpected Create Action\n", 0); // this should never happen
                fLogEvent = TRUE;
				Status = STATUS_UNSUCCESSFUL;
			}

			AfpIoClose(&fshIdDb);

            //
            // write back the IdDb header to the file, but with bad signature.
            // If server shuts down, the correct signature will be
            // written.  If macfile is closed down using "net stop macfile"
            // signature is corrupted with a different type
            // If cool boot/bugcheck, a third type
            // During volume startup, we will know from the signature, 
            // whether to rebuild completely, read iddb but verify or
            // not rebuild at all
            //

            if (NT_SUCCESS(Status))
            {

				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
					("AfpInitIdDb: ***** Corrupting IDDB header ***** \n"));

                AfpVolDescToIdDbHdr(pVolDesc, &IdDbHdr);
            
                IdDbHdr.idh_Signature = AFP_SERVER_SIGNATURE_INITIDDB;

                AfpVolumeUpdateIdDbAndDesktop(pVolDesc,FALSE,FALSE,&IdDbHdr);
            }

		}
		else
		{
			// its CDFS, just initialize the memory image of the IdDB
			Status = afpSeedIdDb(pVolDesc);
            *pfNewVolume = TRUE;
		}

	} while (False);

	if (fLogEvent)
	{
		AFPLOG_ERROR(AFPSRVMSG_INIT_IDDB,
					 Status,
					 NULL,
					 0,
					 &pVolDesc->vds_Name);
		Status = STATUS_UNSUCCESSFUL;
	}

	return Status;
}


/***	afpSeedIdDb
 *
 *	This routine adds the 'parent of root' and the root directory entries
 *	to a newly created ID index database (the memory image of the iddb).
 *
**/
LOCAL NTSTATUS FASTCALL
afpSeedIdDb(
	IN	PVOLDESC pVolDesc
)
{
	PDFENTRY		pDfEntry;
	AFPTIME			CurrentTime;
	AFPINFO			afpinfo;
	FILESYSHANDLE	fshAfpInfo, fshComment, fshData;
	DWORD			i, crinfo, Attr;
	FINDERINFO		FinderInfo;
	NTSTATUS		Status = STATUS_SUCCESS;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
			("afpSeedIdDb: Creating new Id Database...\n"));

	do
	{
		pDfEntry = AfpFindDfEntryById(pVolDesc,
									  AFP_ID_PARENT_OF_ROOT,
									  DFE_DIR);
		ASSERT (pDfEntry != NULL);

		// add the root directory to the id index
		if ((pDfEntry = AfpAddDfEntry(pVolDesc,
									  pDfEntry,
									  &pVolDesc->vds_Name,
									  True,
									  AFP_ID_ROOT)) == NULL )
		{
			Status = STATUS_NO_MEMORY;
			break;
		}
		pVolDesc->vds_pDfeRoot = pDfEntry;	// Initialize pointer to root.

		// Attempt to open the comment stream. If it succeeds, set a flag in
		// the DFE indicating that this thing does indeed have a comment.
		if (NT_SUCCESS(AfpIoOpen(&pVolDesc->vds_hRootDir,
								 AFP_STREAM_COMM,
								 FILEIO_OPEN_FILE,
								 &UNullString,
								 FILEIO_ACCESS_NONE,
								 FILEIO_DENY_NONE,
								 False,
								 &fshComment)))
		{
			DFE_SET_COMMENT(pDfEntry);
			AfpIoClose(&fshComment);
		}

		// Get the directory information for volume root dir. Do not get the
		// mod-time. See below.
		Status = AfpIoQueryTimesnAttr(&pVolDesc->vds_hRootDir,
									  &pDfEntry->dfe_CreateTime,
									  NULL,
									  &Attr);
		// Setup up root directories Last ModTime such that it will
		// get enumerated.
        AfpConvertTimeFromMacFormat(BEGINNING_OF_TIME,
									&pDfEntry->dfe_LastModTime);

		ASSERT(NT_SUCCESS(Status));

		pDfEntry->dfe_NtAttr = (USHORT)Attr & FILE_ATTRIBUTE_VALID_FLAGS;

		if (IS_VOLUME_NTFS(pVolDesc))
		{
			if (NT_SUCCESS(Status = AfpCreateAfpInfo(&pVolDesc->vds_hRootDir,
													 &fshAfpInfo,
													 &crinfo)))
			{
				if ((crinfo == FILE_CREATED) ||
					(!NT_SUCCESS(AfpReadAfpInfo(&fshAfpInfo, &afpinfo))))
				{
					Status = AfpSlapOnAfpInfoStream(NULL,
													NULL,
													&pVolDesc->vds_hRootDir,
													&fshAfpInfo,
													AFP_ID_ROOT,
													True,
													NULL,
													&afpinfo);
				}
				else
				{
					// Just make sure the afp ID is ok, preserve the rest
					if (afpinfo.afpi_Id != AFP_ID_ROOT)
					{
						afpinfo.afpi_Id = AFP_ID_ROOT;
						AfpWriteAfpInfo(&fshAfpInfo, &afpinfo);
					}
				}
				AfpIoClose(&fshAfpInfo);

				pDfEntry->dfe_AfpAttr = afpinfo.afpi_Attributes;
				pDfEntry->dfe_FinderInfo = afpinfo.afpi_FinderInfo;
				if (pVolDesc->vds_Flags & AFP_VOLUME_HAS_CUSTOM_ICON)
				{
					// Don't bother writing back to disk since we do not
					// try to keep this in sync in the permanent afpinfo
					// stream with the actual existence of the icon<0d> file.
					pDfEntry->dfe_FinderInfo.fd_Attr1 |= FINDER_FLAG_HAS_CUSTOM_ICON;
				}
				pDfEntry->dfe_BackupTime = afpinfo.afpi_BackupTime;
				DFE_OWNER_ACCESS(pDfEntry) = afpinfo.afpi_AccessOwner;
				DFE_GROUP_ACCESS(pDfEntry) = afpinfo.afpi_AccessGroup;
				DFE_WORLD_ACCESS(pDfEntry) = afpinfo.afpi_AccessWorld;
			}
		}
		else // CDFS
		{
			RtlZeroMemory(&pDfEntry->dfe_FinderInfo, sizeof(FINDERINFO));

			if (IS_VOLUME_CD_HFS(pVolDesc))
			{
				Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
							 AFP_STREAM_DATA,
							 FILEIO_OPEN_DIR,
							 &UNullString,
							 FILEIO_ACCESS_NONE,
							 FILEIO_DENY_NONE,
							 False,
							 &fshData);
				if (!NT_SUCCESS(Status))
				{
				    DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
					  ("afpSeedIdDb: AfpIoOpeno failed with %lx for CD_HFS\n", Status));
				    break;
				}

				AfpIoClose(&fshData);
			}
			pDfEntry->dfe_BackupTime = BEGINNING_OF_TIME;
			DFE_OWNER_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);
			DFE_GROUP_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);
			DFE_WORLD_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);
			pDfEntry->dfe_AfpAttr = 0;
		}
	} while (False);

	return Status;
}


/***	AfpFreeIdIndexTables
 *
 *	Free the allocated memory for the volume id index tables. The volume is
 *	about to be deleted. Ensure that either the volume is readonly or it is
 *	clean i.e. the scavenger threads have written it back.
 *
 */
VOID FASTCALL
AfpFreeIdIndexTables(
	IN	PVOLDESC pVolDesc
)
{
	DWORD	i;
    struct _DirFileEntry ** DfeDirBucketStart;
    struct _DirFileEntry ** DfeFileBucketStart;

	PAGED_CODE( );

	ASSERT (IS_VOLUME_RO(pVolDesc) ||
			(pVolDesc->vds_pOpenForkDesc == NULL));

	// Traverse each of the hashed indices and free the entries.
	// Need only traverse the overflow links. Ignore other links.
	// JH - Do not bother if we are here during shutdown
	if (AfpServerState != AFP_STATE_SHUTTINGDOWN)
	{
		PDFENTRY pDfEntry, pFree;

        AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

        DfeFileBucketStart = pVolDesc->vds_pDfeFileBucketStart;

        if (DfeFileBucketStart)
        {
		    for (i = 0; i < pVolDesc->vds_FileHashTableSize; i++)
		    {
			    for (pDfEntry = DfeFileBucketStart[i];
				    pDfEntry != NULL;
				    NOTHING)
			    {
    				ASSERT(VALID_DFE(pDfEntry));

    				pFree = pDfEntry;
				    pDfEntry = pDfEntry->dfe_NextOverflow;
				    FREE_DFE(pFree);
			    }
			    DfeFileBucketStart[i] = NULL;
		    }
        }

        DfeDirBucketStart = pVolDesc->vds_pDfeDirBucketStart;

        if (DfeDirBucketStart)
        {
		    for (i = 0; i < pVolDesc->vds_DirHashTableSize; i++)
		    {
    			for (pDfEntry = DfeDirBucketStart[i];
				    pDfEntry != NULL;
				    NOTHING)
			    {
    				ASSERT(VALID_DFE(pDfEntry));

				    pFree = pDfEntry;
				    pDfEntry = pDfEntry->dfe_NextOverflow;
				    FREE_DFE(pFree);
			    }
			    DfeDirBucketStart[i] = NULL;
		    }
        }

		RtlZeroMemory(pVolDesc->vds_pDfeCache,
					  IDINDEX_CACHE_ENTRIES * sizeof(PDFENTRY));

        AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
	}
}


/***	afpRenameInvalidWin32Name
 *
 */
VOID
afpRenameInvalidWin32Name(
	IN	PFILESYSHANDLE		phRootDir,
	IN	BOOLEAN				IsDir,
	IN	PUNICODE_STRING		pName
)
{
	FILESYSHANDLE	Fsh;
	NTSTATUS		rc;
	WCHAR			wc;

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
			("afpRenameInvalidWin32Name: renaming on the fly %Z\n", pName));

	// Rename it now
	if (NT_SUCCESS(AfpIoOpen(phRootDir,
							 AFP_STREAM_DATA,
							 IsDir ? FILEIO_OPEN_DIR : FILEIO_OPEN_FILE,
							 pName,
							 FILEIO_ACCESS_DELETE,
							 FILEIO_DENY_NONE,
							 False,
							 &Fsh)))
	{
		DWORD	NtAttr;

		// Before we attempt a rename, check if the RO bit is set. If it is
		// reset it temporarily.
		rc = AfpIoQueryTimesnAttr(&Fsh, NULL, NULL, &NtAttr);
		ASSERT(NT_SUCCESS(rc));

		if (NtAttr & FILE_ATTRIBUTE_READONLY)
		{
			rc = AfpIoSetTimesnAttr(&Fsh,
									NULL,
									NULL,
									0,
									FILE_ATTRIBUTE_READONLY,
									NULL,
									NULL);
			ASSERT(NT_SUCCESS(rc));
		}

		// Convert the name back to UNICODE so that munging happens !!!
		wc = pName->Buffer[(pName->Length - 1)/sizeof(WCHAR)];
		if (wc == UNICODE_SPACE)
			pName->Buffer[(pName->Length - 1)/sizeof(WCHAR)] = AfpMungedUnicodeSpace;
		if (wc == UNICODE_PERIOD)
			pName->Buffer[(pName->Length - 1)/sizeof(WCHAR)] = AfpMungedUnicodePeriod;

		rc = AfpIoMoveAndOrRename(&Fsh,
								  NULL,
								  pName,
								  NULL,
								  NULL,
								  NULL,
								  NULL,
								  NULL);
		ASSERT(NT_SUCCESS(rc));

		// Set the RO Attr back if it was set to begin with
		if (NtAttr & FILE_ATTRIBUTE_READONLY)
		{
			rc = AfpIoSetTimesnAttr(&Fsh,
									NULL,
									NULL,
									FILE_ATTRIBUTE_READONLY,
									0,
									NULL,
									NULL);
			ASSERT(NT_SUCCESS(rc));
		}

		AfpIoClose(&Fsh);
	}
}


LONG	afpVirtualMemoryCount = 0;
LONG	afpVirtualMemorySize = 0;

/***	AfpAllocVirtualMemory
 *
 *	This is a wrapper over NtAllocateVirtualMemory.
 */
PBYTE FASTCALL
AfpAllocateVirtualMemoryPage(
	IN	VOID
)
{
	PBYTE		pMem = NULL;
	NTSTATUS	Status;
    PBLOCK64K   pCurrBlock;
    PBLOCK64K   pTmpBlk;
    SIZE_T      Size64K;
    DWORD       i, dwMaxPages;


    Size64K = BLOCK_64K_ALLOC;
    dwMaxPages = (BLOCK_64K_ALLOC/PAGE_SIZE);
    pCurrBlock = afp64kBlockHead;

    //
    // if we have never allocated a 64K block as yet, or we don't have one that
    // has any free page(s) in it, allocate a new block!
    //
    if ((pCurrBlock == NULL) || (pCurrBlock->b64_PagesFree == 0))
    {
        pCurrBlock = (PBLOCK64K)AfpAllocNonPagedMemory(sizeof(BLOCK64K));
        if (pCurrBlock == NULL)
        {
            return(NULL);
        }

	    ExInterlockedIncrementLong(&afpVirtualMemoryCount, &AfpStatisticsLock);
	    ExInterlockedAddUlong(&afpVirtualMemorySize, (ULONG)Size64K, &(AfpStatisticsLock.SpinLock));
	    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
		    							 &pMem,
			    						 0L,
				    					 &Size64K,
					    				 MEM_COMMIT,
						    			 PAGE_READWRITE);
        if (NT_SUCCESS(Status))
        {
            ASSERT(pMem != NULL);

#if DBG
            afpDfe64kBlockCount++;
#endif

            pCurrBlock->b64_Next = afp64kBlockHead;
            pCurrBlock->b64_BaseAddress = pMem;
            pCurrBlock->b64_PagesFree = dwMaxPages;
            for (i=0; i<dwMaxPages; i++)
            {
                pCurrBlock->b64_PageInUse[i] = FALSE;
            }
            afp64kBlockHead = pCurrBlock;

        }
        else
        {
            AfpFreeMemory(pCurrBlock);
            return(NULL);
        }
    }


    //
    // if we came this far, we are guaranteed that pCurrBlock is pointing to a
    // block that has at least one page free
    //


    ASSERT ((pCurrBlock != NULL) &&
            (pCurrBlock->b64_PagesFree > 0) &&
            (pCurrBlock->b64_PagesFree <= dwMaxPages));

    // find out which page is free
    for (i=0; i<dwMaxPages; i++)
    {
        if (pCurrBlock->b64_PageInUse[i] == FALSE)
        {
            break;
        }
    }

    ASSERT(i < dwMaxPages);

    pCurrBlock->b64_PagesFree--;
    pCurrBlock->b64_PageInUse[i] = TRUE;
    pMem = ((PBYTE)pCurrBlock->b64_BaseAddress) + (i * PAGE_SIZE);


    //
    // if this 64kblock has no more free pages in it, move it to a spot after
    // all the blocks that have some pages free in it.  For that, we first
    // find the guy who has no pages free in him and move this block after him
    //
    if (pCurrBlock->b64_PagesFree == 0)
    {
        pTmpBlk = pCurrBlock->b64_Next;

        if (pTmpBlk != NULL)
        {
            while (1)
            {
                // found a guy who has no free page in it?
                if (pTmpBlk->b64_PagesFree == 0)
                {
                    break;
                }
                // is this the last guy on the list?
                if (pTmpBlk->b64_Next == NULL)
                {
                    break;
                }
                pTmpBlk = pTmpBlk->b64_Next;
            }
        }

        // if we found a block
        if (pTmpBlk)
        {
            ASSERT(afp64kBlockHead == pCurrBlock);

            afp64kBlockHead = pCurrBlock->b64_Next;
            pCurrBlock->b64_Next = pTmpBlk->b64_Next;
            pTmpBlk->b64_Next = pCurrBlock;
        }
    }

	return pMem;
}


VOID FASTCALL
AfpFreeVirtualMemoryPage(
	IN	PVOID	pBuffer
)
{
	NTSTATUS	Status;
    PBYTE       BaseAddr;
    PBLOCK64K   pCurrBlock;
    PBLOCK64K   pPrevBlk;
    SIZE_T      Size64K;
    DWORD       i, dwMaxPages, dwPageNum, Offset;


    dwMaxPages = (BLOCK_64K_ALLOC/PAGE_SIZE);
    Size64K = BLOCK_64K_ALLOC;
    pCurrBlock = afp64kBlockHead;
    pPrevBlk = afp64kBlockHead;

    BaseAddr = (PBYTE)((ULONG_PTR)pBuffer & ~(BLOCK_64K_ALLOC - 1));
    Offset = (DWORD)(((PBYTE)pBuffer - BaseAddr));

    dwPageNum = Offset/PAGE_SIZE;

    ASSERT(Offset < BLOCK_64K_ALLOC);

    while (pCurrBlock != NULL)
    {
        if (pCurrBlock->b64_BaseAddress == BaseAddr)
        {
            break;
        }

        pPrevBlk = pCurrBlock;
        pCurrBlock = pCurrBlock->b64_Next;
    }

    ASSERT(pCurrBlock->b64_BaseAddress == BaseAddr);

    pCurrBlock->b64_PageInUse[dwPageNum] = FALSE;
    pCurrBlock->b64_PagesFree++;

    //
    // if all the pages in this block are unused, then it's time to free this block
    // after removing from the list
    //
    if (pCurrBlock->b64_PagesFree == dwMaxPages)
    {
        // is our guy the first (and potentially the only one) on the list?
        if (afp64kBlockHead == pCurrBlock)
        {
            afp64kBlockHead = pCurrBlock->b64_Next;
        }
        // nope, there are others and we're somewhere in the middle (or end)
        else
        {
            pPrevBlk->b64_Next = pCurrBlock->b64_Next;
        }

        AfpFreeMemory(pCurrBlock);

	    ExInterlockedDecrementLong(&afpVirtualMemoryCount, &AfpStatisticsLock);
	    ExInterlockedAddUlong(&afpVirtualMemorySize,
                              -1*((ULONG)Size64K),
                              &(AfpStatisticsLock.SpinLock));
	    Status = NtFreeVirtualMemory(NtCurrentProcess(),
		    						 (PVOID *)&BaseAddr,
			    					 &Size64K,
				    				 MEM_RELEASE);

#if DBG
        ASSERT(afpDfe64kBlockCount > 0);
        afpDfe64kBlockCount--;
#endif

    }

    //
    // if a page became available in this block for the first time, move this
    // block to the front of the list (unless it already is there)
    //
    else if (pCurrBlock->b64_PagesFree == 1)
    {
        if (afp64kBlockHead != pCurrBlock)
        {
            pPrevBlk->b64_Next = pCurrBlock->b64_Next;
            pCurrBlock->b64_Next = afp64kBlockHead;
            afp64kBlockHead = pCurrBlock;
        }
    }
}

#ifdef	AGE_DFES

/***	AfpAgeDfEntries
 *
 *	Age out DfEntries out of the Id database. The Files in directories which have not been
 *	accessed for VOLUME_IDDB_AGE_DELAY are aged out. The directories are marked so that
 *	they will be enumerated when they are hit next.
 *
 *	LOCKS:	vds_idDbAccessLock(SWMR, Exclusive)
 */
VOID FASTCALL
AfpAgeDfEntries(
	IN	PVOLDESC	pVolDesc
)
{
	PDFENTRY	pDfEntry, *Stack = NULL;
	LONG		i, StackPtr = 0;
	AFPTIME		Now;

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	AfpGetCurrentTimeInMacFormat(&Now);
	AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

	// Potentially all of the files can be aged out. Allocate 'stack' space
	// for all of the directory DFEs
	if ((Stack = (PDFENTRY *)
				AfpAllocNonPagedMemory(pVolDesc->vds_NumDirDfEntries*sizeof(PDFENTRY))) != NULL)
	{
		// 'Prime' the stack of Dfe's
		Stack[StackPtr++] = pVolDesc->vds_pDfeRoot;

		while (StackPtr > 0)
		{
			PDFENTRY	pDir;

			pDfEntry = Stack[--StackPtr];

			ASSERT(DFE_IS_DIRECTORY(pDfEntry));
			if ((pDfEntry->dfe_AfpId >= AFP_FIRST_DIRID) &&
				(pDfEntry->dfe_pDirEntry->de_ChildForkOpenCount == 0)	 &&
				((Now - pDfEntry->dfe_pDirEntry->de_LastAccessTime) > VOLUME_IDDB_AGE_DELAY))
			{
				PDFENTRY	pFile, pNext;

				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
						("AfpAgeDfEntries: Aging out directory %Z\n", &pDfEntry->dfe_UnicodeName));
				// This directory's files need to be nuked
				pDfEntry->dfe_FileOffspring = 0;
				pDfEntry->dfe_Flags &= ~DFE_FLAGS_FILES_CACHED;

				for (i = 0; i < MAX_CHILD_HASH_BUCKETS; i++)
				{
					for (pFile = pDfEntry->dfe_pDirEntry->de_ChildFile[i];
						 pFile != NULL;
						 pFile = pNext)
					{
						pNext = pFile->dfe_NextSibling;

						// Unlink it from the hash buckets
						AfpUnlinkDouble(pFile,
										dfe_NextOverflow,
										dfe_PrevOverflow);
						// Nuke it from the cache if it is there
						if (pVolDesc->vds_pDfeCache[HASH_CACHE_ID(pFile->dfe_AfpId)] == pFile)
						{
							pVolDesc->vds_pDfeCache[HASH_CACHE_ID(pFile->dfe_AfpId)] = NULL;
						}
						// Finally free it
						FREE_DFE(pFile);
					}
					pDfEntry->dfe_pDirEntry->de_ChildFile[i] = NULL;
				}
			}

#if 0
			// NOTE: Should we leave the tree under 'Network Trash Folder' alone ?
			if (pDfEntry->dfe_AfpId == AFP_ID_NETWORK_TRASH)
				continue;
#endif
			// Pick up all the child directories of this directory and 'push' them on stack
			for (pDir = pDfEntry->dfe_pDirEntry->de_ChildDir;
				 pDir != NULL;
				 pDir = pDir->dfe_NextSibling)
			{
				Stack[StackPtr++] = pDir;
			}
		}

		AfpFreeMemory(Stack);
	}

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
}

#endif

#if	DBG

NTSTATUS FASTCALL
afpDumpDfeTree(
	IN	PVOID	Context
)
{
	PVOLDESC	pVolDesc;
	PDFENTRY	pDfEntry, pChild;
	LONG		i, StackPtr;

	if (afpDumpDfeTreeFlag)
	{
		afpDumpDfeTreeFlag = 0;

		for (pVolDesc = AfpVolumeList; pVolDesc != NULL; pVolDesc = pVolDesc->vds_Next)
		{
			StackPtr = 0;
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
					("Volume : %Z\n", &pVolDesc->vds_Name));
			afpDfeStack[StackPtr++] = pVolDesc->vds_pDfeRoot;

			while (StackPtr > 0)
			{
				pDfEntry = afpDfeStack[--StackPtr];
				afpDisplayDfe(pDfEntry);
				for (i = 0; i < MAX_CHILD_HASH_BUCKETS; i++)
				{
					for (pChild = pDfEntry->dfe_pDirEntry->de_ChildFile[i];
						 pChild != NULL;
						 pChild = pChild->dfe_NextSibling)
					{
						afpDisplayDfe(pChild);
					}
				}
				for (pChild = pDfEntry->dfe_pDirEntry->de_ChildDir;
					 pChild != NULL;
					 pChild = pChild->dfe_NextSibling)
				{
					afpDfeStack[StackPtr++] = pChild;
				}
			}
		}
	}

	return AFP_ERR_REQUEUE;
}


VOID FASTCALL
afpDisplayDfe(
	IN	PDFENTRY	pDfEntry
)
{
	USHORT	i;

	// Figure out the indenting. One space for every depth unit of parent
	// If this is a directory, a '+' and then the dir name
	// If this is a file, then just the file name

	for (i = 0; i < (pDfEntry->dfe_Parent->dfe_DirDepth + 1); i++)
	{
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("%c   ", 0xB3));
	}
	if (pDfEntry->dfe_NextSibling == NULL)
	{
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("%c%c%c%c", 0xC0, 0xC4, 0xC4, 0xC4));
	}
	else
	{
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("%c%c%c%c", 0xC3, 0xC4, 0xC4, 0xC4));
	}
	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
			("%Z ", &pDfEntry->dfe_UnicodeName));

	if (pDfEntry->dfe_Flags & DFE_FLAGS_DIR)
	{
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("(%c, %lx, Id = %lx)\n", 0x9F, pDfEntry, pDfEntry->dfe_AfpId));
	}
	else
	{
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("(%c, %lx, Id = %lx)\n", 0x46, pDfEntry, pDfEntry->dfe_AfpId));
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\intrlckd.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	intrlckd.c

Abstract:

	This module contains the routines that should have been in the EX package.
	This manipulates inter-locked operations on flags and such.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	5 Sep 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_INTRLCKD

#include <afp.h>


/***	AfpInterlockedSetDword
 *
 *	Set specified bits using the spin-lock to provide an interlocked operation.
 */
VOID FASTCALL
AfpInterlockedSetDword(
	IN	PDWORD		pSrc,
	IN	DWORD		Mask,
	IN	PAFP_SPIN_LOCK	pSpinLock
)
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(pSpinLock, &OldIrql);

	*pSrc |= Mask;

	RELEASE_SPIN_LOCK(pSpinLock, OldIrql);
}



/***	AfpInterlockedClearDword
 *
 *	Clear specified bits using the spin-lock to provide an
 *	interlocked operation.
 */
VOID FASTCALL
AfpInterlockedClearDword(
	IN	PDWORD		pSrc,
	IN	DWORD		Mask,
	IN	PAFP_SPIN_LOCK	pSpinLock
)
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(pSpinLock, &OldIrql);

	*pSrc &= ~Mask;

	RELEASE_SPIN_LOCK(pSpinLock, OldIrql);
}



/***	AfpInterlockedSetNClearDword
 *
 *	Set and Clear specified bits using the spin-lock to provide an
 *	interlocked operation.
 */
VOID FASTCALL
AfpInterlockedSetNClearDword(
	IN	PDWORD		pSrc,
	IN	DWORD		SetMask,
	IN	DWORD		ClrMask,
	IN	PAFP_SPIN_LOCK	pSpinLock
)
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(pSpinLock, &OldIrql);

	*pSrc |= SetMask;
	*pSrc &= ~ClrMask;

	RELEASE_SPIN_LOCK(pSpinLock, OldIrql);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\iopool.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	iopool.h

Abstract:

	This module contains the IO pool management stuff.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Feb 1994		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _IOPOOL_

#define	_IOPOOL_

#define	DWORDSIZEBLOCK(Size)		(((Size) + sizeof(DWORD) - 1) & ~(sizeof(DWORD)-1))
#define	LONGLONGSIZEBLOCK(Size)		((Size) + (sizeof(LONGLONG) - (Size)%(sizeof(LONGLONG))))
#define	PAGED_BLOCK_SIGNATURE		*(PDWORD)"PAGD"
#define	NONPAGED_BLOCK_SIGNATURE	*(PDWORD)"NPGD"

/* MSKK hideyukn, Our Nls table is larger than 0x20000, 07/05/95 */
// used for debug builds only: bumped up to 0x200000 (note one more 0)
#define	MAXIMUM_ALLOC_SIZE			0x200000			// For sanity checking

typedef	struct
{
	unsigned	tg_Size:20;
	unsigned	tg_Flags:4;
	unsigned	tg_Tag:8;
} TAG, *PTAG;

#define	MAX_POOL_AGE		6
#define	POOL_AGE_TIME		15
#define	POOL_ALLOC_SIZE		(0x2000) - POOL_OVERHEAD
#define	NUM_BUFS_IN_POOL	3

#define	POOL_ALLOC_3		ASP_QUANTUM
#define	POOL_ALLOC_2		1600
#define	POOL_ALLOC_1		512
#define	LOCKS_BUF_SPACE		(POOL_ALLOC_SIZE - sizeof(IOPOOL) -				\
							 POOL_ALLOC_1 - POOL_ALLOC_2 - POOL_ALLOC_3	-	\
							 (NUM_BUFS_IN_POOL * sizeof(IOPOOL_HDR)))

#define IO_POOL_NOT_IN_USE  0
#define IO_POOL_IN_USE      1
#define IO_POOL_HUGE_BUFFER 2

#define	NUM_LOCKS_IN_POOL	((LOCKS_BUF_SPACE)/(sizeof(IOPOOL_HDR) + sizeof(FORKLOCK)))

// The pool is structured as a set of 1 each of POOL_ALLOC_x buffers linked in
// ascending order of sizes. The balance of the POOL_ALLOC_SIZE is divided into
// a number of fork-lock structures. The layout is as follows:
//
//			+---------------------+
//			|  IoPool Structure   |----------+
//			|                     |--+       |
//			+---------------------+  |       |
//		 +--|    IoPool Hdr       |<-+       |
//		 |  +---------------------+          |
//		 |  |                     |          |
//		 |  .      Buffer 1       .          |
//		 |  |                     |          |
//		 |  +---------------------+          |
//		 +->|    IoPool Hdr       |--+       |
//		    +---------------------+  |       |
//		    |                     |  |       |
//		    .      Buffer 2       .  |       |
//		    |                     |  |       |
//		    +---------------------+  |       |
//	   |||--|    IoPool Hdr       |<-+       |
//			+---------------------+          |
//			|                     |          |
//			.      Buffer 3       .          |
//			|                     |          |
//			+---------------------+          |
//		 +--|    IoPool Hdr       |<---------+
//		 |  +---------------------+
//		 |  |                     |
//		 .  .      ForkLock1      .
//		 .  |                     |
//		 |  +---------------------+
//		 +->|    IoPool Hdr       |--|||
//		    +---------------------+
//		    |                     |
//		    .      ForkLockN      .
//		    |                     |
//		    +---------------------+
//
//
#if DBG
#define	POOLHDR_SIGNATURE			*(PDWORD)"PLH"
#define	VALID_PLH(pPoolHdr)			(((pPoolHdr) != NULL) && \
									 ((pPoolHdr)->Signature == POOLHDR_SIGNATURE))
#else
#define	VALID_PLH(pPoolHdr)			((pPoolHdr) != NULL)
#endif

typedef	struct _IoPoolHdr
{
#if	DBG
	DWORD				Signature;
	DWORD				IoPoolHdr_Align1;
#endif
	union
	{
		struct _IoPoolHdr *	iph_Next;    // Valid when it is on the free list
		struct _IoPool	  *	iph_pPool;   // Valid when it is allocated. Used
										 // to put it back on the free list
	};
	DWORD				IoPoolHdr_Align2;
	TAG					iph_Tag;	 	// Keep it at end since it is accessed
										 // by moving back from the free ptr
} IOPOOL_HDR, *PIOPOOL_HDR;

#if DBG
#define	IOPOOL_SIGNATURE			*(PDWORD)"IOP"
#define	VALID_IOP(pPool)			(((pPool) != NULL) && \
									 ((pPool)->Signature == IOPOOL_SIGNATURE))
#else
#define	VALID_IOP(pPool)			((pPool) != NULL)
#endif

typedef	struct _IoPool
{
#if	DBG
	DWORD				Signature;
	DWORD				QuadAlign1;
#endif
	struct _IoPool *	iop_Next;
	struct _IoPool **	iop_Prev;
	struct _IoPoolHdr *	iop_FreeBufHead;	// The list of POOL headers start here
	struct _IoPoolHdr *	iop_FreeLockHead;	// The list of fork-locks start here
	DWORD				QuadAlign2;
	USHORT				iop_Age;			// Used to age out pool
	BYTE				iop_NumFreeBufs;	// Number of free IO buffer
	BYTE				iop_NumFreeLocks;	// Number of free fork locks
} IOPOOL, *PIOPOOL;

LOCAL	PIOPOOL		afpIoPoolHead = { NULL };
LOCAL	AFP_SPIN_LOCK	afpIoPoolLock = { 0 };
LOCAL	USHORT		afpPoolAllocSizes[NUM_BUFS_IN_POOL] =
					{
						POOL_ALLOC_1,
						POOL_ALLOC_2,
						POOL_ALLOC_3
					};

LOCAL AFPSTATUS FASTCALL
afpIoPoolAge(
	IN	PVOID	pContext
);

#endif	// _IOPOOL_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\intrlckd.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

        intrlckd.h

Abstract:

        This module defines the routines that should have been in the EX package.
        This manipulates inter-locked operations on flags and such.

Author:

        Jameel Hyder (microsoft!jameelh)


Revision History:
        5 Sep 1992              Initial Version

Notes:  Tab stop: 4
--*/

#ifndef _INTRLCKD_
#define _INTRLCKD_

extern
VOID  FASTCALL
AfpInterlockedSetDword(
        IN      PDWORD          pSrc,
        IN      DWORD           Mask,
        IN      PAFP_SPIN_LOCK  pSpinLock
);


extern
VOID FASTCALL
AfpInterlockedClearDword(
        IN      PDWORD          pSrc,
        IN      DWORD           Mask,
        IN      PAFP_SPIN_LOCK  pSpinLock
);


extern
VOID FASTCALL
AfpInterlockedSetNClearDword(
        IN      PDWORD          pSrc,
        IN      DWORD           SetMask,
        IN      DWORD           ClrMask,
        IN      PAFP_SPIN_LOCK  pSpinLock
);


// Macros for Interlocked/ExInterlocked calls
//
// For future reference, here is the difference between all the different
// kernel mode interlocked routines:
//
// InterlockedIncrement/Decrement - fastest on all platforms, inlined
// where appropriate to avoid call overhead.  No spinlock required, usable
// on paged data. Operation is atomic ONLY with respect to other Interlocked
// calls.
//
// ExInterlockedIncrement/Decrement - not as efficient, requires a function
// call and a spinlock.  Operation is atomic ONLY with respect to other
// ExInterlockedIncrement/Decrement calls.  There is no reason to use this
// instead of InterlockedIncrement/Decrement. Does not actually acquire the
// spinlock.  Required for backwards compatibility.
//
// ExInterlockedAddUlong - most inefficient, requires a function call and a
// spinlock.  Spinlock is actually acquired, so the operation is atomic with
// respect to anything that acquires the same spinlock.
//
#define INTERLOCKED_INCREMENT_LONG(p)             InterlockedIncrement(p)
#define INTERLOCKED_DECREMENT_LONG(p)             InterlockedDecrement(p)
#define INTERLOCKED_ADD_STATISTICS(p, v, l)       ExInterlockedAddLargeStatistic(p, v)

#define INTERLOCKED_INCREMENT_LONG_DPC(p,l)       InterlockedIncrement(p)
#define INTERLOCKED_DECREMENT_LONG_DPC(p,l)       InterlockedDecrement(p)
#ifdef  NT40
#define INTERLOCKED_ADD_ULONG(p, v, l)            ExInterlockedExchangeAdd(p, v)
#else
#define INTERLOCKED_ADD_ULONG(p, v, l)            ExInterlockedAddUlong(p, v, &(l)->SpinLock)
#endif
#define INTERLOCKED_ADD_ULONG_DPC(p, v, l)        ExInterlockedAddUlong(p, v, l)
#define INTERLOCKED_ADD_LARGE_INTGR(p, v, l)      ExInterlockedAddLargeInteger(p, v, &(l)->SpinLock)
#define INTERLOCKED_ADD_LARGE_INTGR_DPC(p, v, l)  ExInterlockedAddLargeInteger(p, v, &(l)->SpinLock)

#endif  // _INTRLCKD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\macansi.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	macansi.h

Abstract:

	This module contains prototypes for ANSI to UNICODE conversion routines.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	10 Jul 1992		Initial Version

Notes:	Tab stop: 4

--*/

#ifndef	_MACANSI_
#define	_MACANSI_

extern
NTSTATUS FASTCALL
AfpGetMacCodePage(
	IN	LPWSTR				PathCP
);

extern
NTSTATUS
AfpMacAnsiInit(
	VOID
);

extern
VOID
AfpMacAnsiDeInit(
	VOID
);

extern
NTSTATUS FASTCALL
AfpConvertStringToUnicode(
	IN	PANSI_STRING		pAnsiString,
	OUT	PUNICODE_STRING		pUnicodeString
);


extern
NTSTATUS FASTCALL
AfpConvertStringToAnsi(
	IN	PUNICODE_STRING		pUnicodeString,
	OUT	PANSI_STRING		pAnsiString
);

extern
NTSTATUS FASTCALL
AfpConvertStringToMungedUnicode(
	IN	PANSI_STRING		pAnsiString,
	OUT	PUNICODE_STRING		pUnicodeString
);

extern
NTSTATUS FASTCALL
AfpConvertMungedUnicodeToAnsi(
	IN	PUNICODE_STRING		pUnicodeString,
	OUT	PANSI_STRING		pAnsiString
);

extern
AFPSTATUS FASTCALL
AfpConvertMacAnsiToHostAnsi(
	IN	OUT PANSI_STRING	pAnsiString
);

extern
VOID FASTCALL
AfpConvertHostAnsiToMacAnsi(
	IN	OUT PANSI_STRING	pAnsiString
);

extern
BOOLEAN FASTCALL
AfpEqualUnicodeString(
    IN PUNICODE_STRING 		String1,
    IN PUNICODE_STRING 		String2
);

extern
BOOLEAN FASTCALL
AfpPrefixUnicodeString(
    IN PUNICODE_STRING		String1,
    IN PUNICODE_STRING		String2
);

extern
BOOLEAN FASTCALL
AfpIsProperSubstring(
	IN	PUNICODE_STRING		pString,
	IN	PUNICODE_STRING		pSubString
);

extern
BOOLEAN FASTCALL
AfpIsLegalShortname(
	IN	PANSI_STRING		pShortName
);

extern
PCHAR
AfpStrChr(
    IN  PBYTE               String,
    IN  DWORD               StringLen,
    IN  BYTE                Char
);

// HACK: Space and Period are also mapped BUT ONLY if they occur at end
#define	ANSI_SPACE					' '
#define	ANSI_PERIOD					'.'
#define	ANSI_APPLE_CHAR				0xF0

#define	UNICODE_SPACE				L' '
#define	UNICODE_PERIOD				L'.'

GLOBAL	WCHAR	AfpMungedUnicodeSpace EQU 0;
GLOBAL	WCHAR	AfpMungedUnicodePeriod EQU 0;

#ifdef	_MACANSI_LOCALS

// Invalid NtFs characters are mapped starting at this value
#define	AFP_INITIAL_INVALID_HIGH	0x20
#define	AFP_INVALID_HIGH			0x7F
#define	AFP_ALT_UNICODE_BASE		0xF000

LOCAL	PWCHAR	afpAltUnicodeTable = NULL;
LOCAL	PBYTE	afpAltAnsiTable = NULL;
LOCAL	WCHAR	afpLastAltChar = AFP_ALT_UNICODE_BASE + AFP_INITIAL_INVALID_HIGH;
LOCAL	WCHAR	afpAppleUnicodeChar = 0;

#endif	// _MACANSI_LOCALS

#endif	// _MACANSI_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\macansi.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	macansi.c

Abstract:

	This module contains conversion routines from macintosh ansi to unicode
	and vice versa


Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	10 Jul 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	_MACANSI_LOCALS
#define	FILENUM	FILE_MACANSI

#include <afp.h>

#define	FlagOn(x, y)	((x) & (y))

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfpMacAnsiInit)
#pragma alloc_text( PAGE, AfpMacAnsiDeInit)
#pragma alloc_text( PAGE, AfpGetMacCodePage)
#pragma alloc_text( PAGE, AfpConvertStringToUnicode)
#pragma alloc_text( PAGE, AfpConvertStringToAnsi)
#pragma alloc_text( PAGE, AfpConvertStringToMungedUnicode)
#pragma alloc_text( PAGE, AfpConvertMungedUnicodeToAnsi)
#pragma alloc_text( PAGE, AfpConvertMacAnsiToHostAnsi)
#pragma alloc_text( PAGE, AfpConvertHostAnsiToMacAnsi)
#pragma alloc_text( PAGE, AfpIsLegalShortname)
#pragma alloc_text( PAGE, AfpIsProperSubstring)
#endif

/***	AfpMacAnsiInit
 *
 *	Initialize the code page for macintosh ANSI.
 */
NTSTATUS
AfpMacAnsiInit(
	VOID
)
{
	NTSTATUS	Status = STATUS_SUCCESS;
	int			i, SizeAltTbl;

	// Allocate the table for the alternate unicode characters
	SizeAltTbl = (AFP_INVALID_HIGH - AFP_INITIAL_INVALID_HIGH + 1) * sizeof(WCHAR);
	if ((afpAltUnicodeTable = (PWCHAR)AfpAllocZeroedPagedMemory(SizeAltTbl)) == NULL)
		return STATUS_INSUFFICIENT_RESOURCES;

	// Allocate and initialize the table for the reverse mapping table
	SizeAltTbl = (AFP_INVALID_HIGH - AFP_INITIAL_INVALID_HIGH + 1)*sizeof(BYTE);
	if ((afpAltAnsiTable = (PBYTE)AfpAllocZeroedPagedMemory(SizeAltTbl)) == NULL)
	{
		AfpFreeMemory(afpAltUnicodeTable);
		afpAltUnicodeTable = NULL;
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	// Initialize the tables for the alternate unicode characters
	for (i = AFP_INITIAL_INVALID_HIGH + 1; i <= AFP_INVALID_HIGH; i++)
	{
		if (!FsRtlIsAnsiCharacterLegalNtfs((BYTE)i, False))
		{
			afpAltUnicodeTable[i-AFP_INITIAL_INVALID_HIGH] = afpLastAltChar;
			afpAltAnsiTable[afpLastAltChar - (AFP_ALT_UNICODE_BASE + AFP_INITIAL_INVALID_HIGH)] = (BYTE)i;
			afpLastAltChar++;
		}
	}

	// HACK: Also add in a couple of codes for 'space' and 'period' - they are only
	//		 used if they are at end. Another one for the 'apple' character
	AfpMungedUnicodeSpace =
	afpAltUnicodeTable[ANSI_SPACE-AFP_INITIAL_INVALID_HIGH] = afpLastAltChar;
	afpAltAnsiTable[afpLastAltChar - (AFP_ALT_UNICODE_BASE + AFP_INITIAL_INVALID_HIGH)] = ANSI_SPACE;
	afpLastAltChar ++;

	AfpMungedUnicodePeriod =
	afpAltUnicodeTable[ANSI_PERIOD-AFP_INITIAL_INVALID_HIGH] = afpLastAltChar;
	afpAltAnsiTable[afpLastAltChar - (AFP_ALT_UNICODE_BASE + AFP_INITIAL_INVALID_HIGH)] = ANSI_PERIOD;
	afpLastAltChar ++;

	// This is yet another hack
	afpAppleUnicodeChar = afpLastAltChar;
	afpLastAltChar ++;

	RtlZeroMemory(&AfpMacCPTableInfo, sizeof(AfpMacCPTableInfo));

	return Status;
}


/***	AfpMacAnsiDeInit
 *
 *	De-initialize the code page for macintosh ANSI.
 */
VOID
AfpMacAnsiDeInit(
	VOID
)
{
	PAGED_CODE( );

	if (AfpTranslationTable != NULL)
	{
		AfpFreeMemory(AfpTranslationTable);
	}

	if (AfpCasePreserveTranslationTable != NULL)
	{
		AfpFreeMemory(AfpCasePreserveTranslationTable);
	}

	if (AfpRevTranslationTable != NULL)
	{
		AfpFreeMemory(AfpRevTranslationTable);
	}

	if (afpAltUnicodeTable != NULL)
	{
		AfpFreeMemory(afpAltUnicodeTable);
	}

	if (afpAltAnsiTable != NULL)
	{
		AfpFreeMemory(afpAltAnsiTable);
	}

	if (AfpMacCPBaseAddress != NULL)
	{
		AfpFreeMemory(AfpMacCPBaseAddress);
	}
}


/***	AfpConvertStringToUnicode
 *
 *	Convert a Mac ANSI string to a unicode string.
 */
AFPSTATUS FASTCALL
AfpConvertStringToUnicode(
	IN	PANSI_STRING	pAnsiString,
	OUT	PUNICODE_STRING	pUnicodeString
)
{

	NTSTATUS	Status;
	ULONG		ulCast;

	PAGED_CODE( );

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	Status = RtlCustomCPToUnicodeN(&AfpMacCPTableInfo,
								   pUnicodeString->Buffer,
								   pUnicodeString->MaximumLength,
								   &ulCast, pAnsiString->Buffer,
								   pAnsiString->Length);
	if (NT_SUCCESS(Status))
		pUnicodeString->Length = (USHORT)ulCast;
	else
	{
		AFPLOG_ERROR(AFPSRVMSG_MACANSI2UNICODE, Status, NULL, 0, NULL);
	}

	return Status;
}



/***	AfpConvertStringToAnsi
 *
 *	Convert a unicode string to a Mac ANSI string.
 */
AFPSTATUS FASTCALL
AfpConvertStringToAnsi(
	IN	PUNICODE_STRING	pUnicodeString,
	OUT	PANSI_STRING	pAnsiString
)
{
	NTSTATUS	Status;
	ULONG		ulCast;

	PAGED_CODE( );

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	Status = RtlUnicodeToCustomCPN(&AfpMacCPTableInfo,
								   pAnsiString->Buffer,
								   pAnsiString->MaximumLength,
								   &ulCast, pUnicodeString->Buffer,
								   pUnicodeString->Length);
	if (NT_SUCCESS(Status))
		pAnsiString->Length = (USHORT)ulCast;
	else
	{
		AFPLOG_ERROR(AFPSRVMSG_UNICODE2MACANSI, Status, NULL, 0, NULL);
	}

	return Status;
}



/***	AfpConvertStringToMungedUnicode
 *
 *	Convert a Mac ANSI string to a unicode string. If there are any characters
 *	in the ansi string which are invalid filesystem (NTFS) characters, then
 *	map them to alternate unicode characters based on the table.
 */
AFPSTATUS FASTCALL
AfpConvertStringToMungedUnicode(
	IN	PANSI_STRING	pAnsiString,
	OUT	PUNICODE_STRING	pUnicodeString
)
{
	USHORT		i, len;
	BYTE		c;
	NTSTATUS	Status;
	ULONG		ulCast;
	PWCHAR		pWBuf;

	PAGED_CODE( );

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	ASSERT(afpAltUnicodeTable != NULL);

	Status = RtlCustomCPToUnicodeN(&AfpMacCPTableInfo,
								   pUnicodeString->Buffer,
								   pUnicodeString->MaximumLength,
								   &ulCast,
								   pAnsiString->Buffer,
								   pAnsiString->Length);
	if (NT_SUCCESS(Status))
		pUnicodeString->Length = (USHORT)ulCast;
	else
	{
		AFPLOG_ERROR(AFPSRVMSG_MACANSI2UNICODE, Status, NULL, 0, NULL);
		return Status;
	}

	// Walk the ANSI string looking for the invalid characters and map it
	// to the alternate set

	for (i = 0, len = pAnsiString->Length, pWBuf = pUnicodeString->Buffer;
		 i < len;
		 i++, pWBuf ++)
	{
	    c = pAnsiString->Buffer[i];
		if (c == ANSI_APPLE_CHAR)
			*pWBuf = afpAppleUnicodeChar;
		else if (c < AFP_INITIAL_INVALID_HIGH)
			*pWBuf = c + AFP_ALT_UNICODE_BASE;
		else if (!FsRtlIsAnsiCharacterLegalNtfs(c, False))
		{
			ASSERT (c <= AFP_INVALID_HIGH);
			*pWBuf = afpAltUnicodeTable[c - AFP_INITIAL_INVALID_HIGH];
		}
/* MSKK eichim, Appended to handle DBCS trailing 0x5c, 03/16/95 */
#ifdef DBCS
        if (FsRtlIsLeadDbcsCharacter(c))
            i++;
#endif // DBCS
	}

	// HACK: Make sure the last character in the name is not a 'space' or a '.'
	c = pAnsiString->Buffer[pAnsiString->Length - 1];
	if ((c == ANSI_SPACE) || (c == ANSI_PERIOD))
/* MSKK hideyukn, Unicode char length not eqaul to ansi byte length in DBCS, 06/30/95 */
#ifdef DBCS
        pUnicodeString->Buffer[(pUnicodeString->Length/sizeof(WCHAR)) - 1]
                                        = afpAltUnicodeTable[c - AFP_INITIAL_INVALID_HIGH];
#else
		pUnicodeString->Buffer[len - 1] = afpAltUnicodeTable[c - AFP_INITIAL_INVALID_HIGH];
#endif // DBCS

	return STATUS_SUCCESS;
}



/***	AfpConvertMungedUnicodeToAnsi
 *
 *	Convert a unicode string with possible alternate unicode characters
 *	to Mac Ansi.
 *	This is inverse of AfpConvertStringToMungedUnicode().
 */
NTSTATUS FASTCALL
AfpConvertMungedUnicodeToAnsi(
	IN	PUNICODE_STRING	pUnicodeString,
	OUT	PANSI_STRING	pAnsiString
)
{
	USHORT		i, len;
	WCHAR		wc;
	NTSTATUS	Status;
	ULONG		ulCast;
	PBYTE		pABuf;

	PAGED_CODE( );

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	Status = RtlUnicodeToCustomCPN(&AfpMacCPTableInfo,
								   pAnsiString->Buffer,
								   pAnsiString->MaximumLength,
								   &ulCast, pUnicodeString->Buffer,
								   pUnicodeString->Length);
	if (NT_SUCCESS(Status))
		pAnsiString->Length = (USHORT)ulCast;
	else
	{
		AFPLOG_ERROR(AFPSRVMSG_UNICODE2MACANSI, Status, NULL, 0, NULL);
	}

	// Walk the Unicode string looking for alternate unicode chars and
	// replacing the ansi equivalents by the real ansi characters.
	for (i = 0, len = pUnicodeString->Length/(USHORT)sizeof(WCHAR), pABuf = pAnsiString->Buffer;
		i < len;
		i++, pABuf++)
	{
		wc = pUnicodeString->Buffer[i];
		if (wc == afpAppleUnicodeChar)
			*pABuf = ANSI_APPLE_CHAR;
		else if ((wc >= AFP_ALT_UNICODE_BASE) && (wc < afpLastAltChar))
		{
			wc -= AFP_ALT_UNICODE_BASE;
			if (wc < AFP_INITIAL_INVALID_HIGH)
				 *pABuf = (BYTE)wc;
			else *pABuf = afpAltAnsiTable[wc - AFP_INITIAL_INVALID_HIGH];
		}
/* MSKK hideyukn, Unicode char length not eqaul to ansi byte length in DBCS, 06/30/95 */
#ifdef DBCS
        if (FsRtlIsLeadDbcsCharacter(*pABuf))
            pABuf++;
#endif // DBCS
	}

	return Status;
}

/***	AfpConvertMacAnsiToHostAnsi
 *
 *	Convert a Mac ansi string to its host counterpart in uppercase OEM codepage.
 *  (in place). The name of this routine is misleading as a late bugfix was
 *  made to change the codepage used, but the name of the routine didn't change
 *  so none of the calling code had to be changed.  It should really be called
 *  AfpConvertMacAnsiToUpcaseOem.  This routine is only called to uppercase
 *  mac passwords for logon and changepassword.
 *
 */
AFPSTATUS FASTCALL
AfpConvertMacAnsiToHostAnsi(
	IN	OUT	PANSI_STRING	pAnsiString
)
{
	LONG	i, Len;
	BYTE	*pBuf;

	PAGED_CODE( );

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
	// ASSERT (AfpTranslationTable != NULL);
	ASSERT (AfpCasePreserveTranslationTable != NULL);

	Len = pAnsiString->Length;
	pBuf = pAnsiString->Buffer;

	for (i = 0; i < Len; i++, pBuf++)
	{
/* MSKK NaotoN Appended to handle DBCS Mac path name 11/10/93 */
#ifdef DBCS
		if (FsRtlIsLeadDbcsCharacter( *pBuf )) {
			i++ ;
			pBuf++ ;
		}
		else
#endif // DBCS
		*pBuf = AfpCasePreserveTranslationTable[*pBuf];
	}
	return AFP_ERR_NONE;
}

/***	AfpConvertHostAnsiToMacAnsi
 *
 *	Convert a host unicode string to its mac counterpart in place.
 *	Only characters <= 0x20 and >= 0x80 are translated.
 *
 *	NOTE: This is extremely hacky and intended for translating messages only.
 */
VOID FASTCALL
AfpConvertHostAnsiToMacAnsi(
	IN	OUT PANSI_STRING	pAnsiString
)
{
	LONG	i, Len;
	BYTE	c, *pBuf;

	PAGED_CODE( );

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
	ASSERT (AfpRevTranslationTable != NULL);

	Len = pAnsiString->Length;
	pBuf = pAnsiString->Buffer;

	for (i = 0; i < Len; i++, pBuf++)
	{
		c = *pBuf;
/* MSKK NaotoN Appended to skip if Kanji 12/17/93 */
#ifdef DBCS
		if (FsRtlIsLeadDbcsCharacter( c )) {
			i++ ;
			pBuf++ ;
		}
		else
#endif // DBCS
		if (c < 0x20)
		{
			*pBuf = AfpRevTranslationTable[c];
		}
		else if (c >= 0x80)
		{
			*pBuf = AfpRevTranslationTable[c-(0x80-0x20)];
		}
	}
}

/***	AfpEqualUnicodeString
 *
 *	The AfpEqualUnicodeString function compares two counted unicode
 *	strings for equality using case SENSITIVE compare. This routine
 *	exists because it must be called at DPC level by the volume.c code
 *	for comparing 2 non-paged strings, and the RtlEqualUnicodeString
 *	routine that we would normally call is pageable code.
 *
 *	Note that case INSENSITIVE compare would require accessing
 *	paged up-case table info, and therefore could not be done at DPC level.
 *
 *	Arguments:
 *		String1 - Pointer to the first string.
 *		String2 - Pointer to the second string.
 *
 *	Return Value:
 *		True if String1 equals String2 and False otherwise.
 *
 *	Note: This is called at DPC level from volume.c and must not be made
 *		a pageable routine.
 */

BOOLEAN FASTCALL
AfpEqualUnicodeString(
	IN	PUNICODE_STRING	String1,
	IN	PUNICODE_STRING	String2
)
{
	WCHAR		*s1, *s2;
	USHORT		n1, n2;

	n1 = (USHORT)(String1->Length/sizeof(WCHAR));
	n2 = (USHORT)(String2->Length/sizeof(WCHAR));

	if (n1 != n2)
	{
		return False;
	}

	s1 = String1->Buffer;
	s2 = String2->Buffer;

	while (n1--)
	{
		if (*s1++ != *s2++)
		{
			return False;
		}
	}

	return True;
}


/***	AfpPrefixUnicodeString
 *
 *	The AfpPrefixUnicodeString function determines if the String1
 *	counted string parameter is a prefix of the String2 counted string
 *	parameter using case SENSITIVE compare. This routine exists because it
 *	must be called at DPC level by the volume.c code for comparing
 *	two non-paged strings, and the RtlPrefixUnicodeString routine that we
 *	would normally call is pageable code.
 *
 *	Note that case INSENSITIVE compare would require accessing
 *	paged up-case table info, and therefore could not be done at DPC level.
 *
 *	Arguments:
 *		String1 - Pointer to the first unicode string.
 *		String2 - Pointer to the second unicode string.
 *
 *	Return Value:
 *		True if String1 equals a prefix of String2 and False otherwise.
 *
 *	Note: This is called at DPC level from volume.c and must not be made
 *		 	   a pageable routine.
 */

BOOLEAN FASTCALL
AfpPrefixUnicodeString(
	IN	PUNICODE_STRING	String1,
	IN	PUNICODE_STRING	String2
)
{
	PWSTR s1, s2;
	ULONG n;
	WCHAR c1, c2;

	if (String2->Length < String1->Length)
	{
		return False;
	}

	s1 = String1->Buffer;
	s2 = String2->Buffer;
    n = String1->Length/sizeof(WCHAR);
	while (n--)
	{
		c1 = *s1++;
		c2 = *s2++;
		if (c1 != c2)
		{
			return False;
		}
	}
	return True;
}

/*** AfpGetMacCodePage
 *
 *	Open the default macintosh codepage, create a section backed by that file,
 *  map a view to the section, and initialize the CodePage info structure
 *  that is used with the RtlCustomCP routines.  Then create the Mac Ansi to
 *  Host Ansi mapping table.
 *
 *  BEWARE!
 *	This routine may only be called ONCE!  This will be called from the first
 *  admin call to ServerSetInfo.  Therefore, there can be NO calls to the
 *  macansi routines within this module (except for MacAnsiInit) before that
 *  happens.
 */
NTSTATUS FASTCALL
AfpGetMacCodePage(
	IN	LPWSTR	PathCP
)
{
	NTSTATUS 		Status;
	FILESYSHANDLE	FileHandle;
	UNICODE_STRING	uPathCP, devPathCP;
	ULONG			viewsize = 0;
	WCHAR			UnicodeTable[2*AFP_XLAT_TABLE_SIZE];
	BYTE			AnsiTable[2*AFP_XLAT_TABLE_SIZE + 1];
	UNICODE_STRING	UnicodeString;
	ANSI_STRING		AnsiString;
	LONG			i;

	PAGED_CODE( );

	FileHandle.fsh_FileHandle = NULL;
	UnicodeString.Length = AFP_XLAT_TABLE_SIZE * sizeof(WCHAR);
	UnicodeString.MaximumLength = (AFP_XLAT_TABLE_SIZE + 1) * sizeof(WCHAR);
	UnicodeString.Buffer = UnicodeTable;

	RtlInitUnicodeString(&uPathCP, PathCP);
	devPathCP.Length = 0;
	devPathCP.MaximumLength = uPathCP.Length + DosDevices.Length + sizeof(WCHAR);
	if ((devPathCP.Buffer = (PWSTR)AfpAllocPagedMemory(devPathCP.MaximumLength)) == NULL)
	{
		Status = STATUS_NO_MEMORY;
		AFPLOG_ERROR(AFPSRVMSG_MAC_CODEPAGE, Status, NULL, 0, NULL);
		return Status;
	}
	AfpCopyUnicodeString(&devPathCP, &DosDevices);
	RtlAppendUnicodeStringToString(&devPathCP, &uPathCP);

	do
	{
		FORKSIZE	liCPlen;
		LONG		lCPlen, sizeread=0;

		Status = AfpIoOpen(NULL,
						   AFP_STREAM_DATA,
						   FILEIO_OPEN_FILE,
						   &devPathCP,
						   FILEIO_ACCESS_READ,
						   FILEIO_DENY_NONE,
						   False,
						   &FileHandle);

		if (!NT_SUCCESS(Status))
			break;

		if (!NT_SUCCESS(Status = AfpIoQuerySize(&FileHandle,
												&liCPlen)))
			break;

		// NOTE: This assumes the codepage file will never be so big that
		// the high bit of the LowPart of the size will be set
		lCPlen = (LONG)liCPlen.LowPart;
		if ((AfpMacCPBaseAddress = (PUSHORT)AfpAllocPagedMemory(lCPlen)) == NULL)
		{
			Status = STATUS_NO_MEMORY;
			break;
		}

		Status = AfpIoRead(&FileHandle,
						   &LIZero,
						   lCPlen,
						   &sizeread,
						   (PBYTE)AfpMacCPBaseAddress);
		AfpIoClose(&FileHandle);

		if (!NT_SUCCESS(Status))
			break;

		if (sizeread != lCPlen)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		RtlInitCodePageTable(AfpMacCPBaseAddress, &AfpMacCPTableInfo);

		// Initialize mac ANSI to host upcase Oem translation table
		// Start by allocating memory for the table and filling it up.

/* HitoshiT modify following line to keep Unicode translation table.	5/18/94	*/
#ifdef DBCS
		if ((AfpTranslationTable = AfpAllocPagedMemory(2*AFP_XLAT_TABLE_SIZE*sizeof(USHORT) + 1)) == NULL)
#else
		if ((AfpTranslationTable = AfpAllocPagedMemory(2*AFP_XLAT_TABLE_SIZE + 1)) == NULL)
#endif // DBCS
		{
			Status = STATUS_NO_MEMORY;
			break;
		}

		// Initialize mac ANSI to host Oem translation table
		// Start by allocating memory for the table and filling it up.

#ifdef DBCS
		if ((AfpCasePreserveTranslationTable = AfpAllocPagedMemory(2*AFP_XLAT_TABLE_SIZE*sizeof(USHORT) + 1)) == NULL)
#else
		if ((AfpCasePreserveTranslationTable = AfpAllocPagedMemory(2*AFP_XLAT_TABLE_SIZE + 1)) == NULL)
#endif // DBCS
		{
			Status = STATUS_NO_MEMORY;
			break;
		}

		for (i = 0; i < 2*AFP_XLAT_TABLE_SIZE; i++)
			AnsiTable[i] = (BYTE)i;

		// Now translate this from Mac ANSI to unicode
		AnsiString.Length = 2*AFP_XLAT_TABLE_SIZE;
		AnsiString.MaximumLength = 	2*AFP_XLAT_TABLE_SIZE + 1;
		AnsiString.Buffer = AnsiTable;

		UnicodeString.Length = 0;
		UnicodeString.MaximumLength = sizeof(UnicodeTable);
		UnicodeString.Buffer =	UnicodeTable;

		Status = AfpConvertStringToUnicode(&AnsiString, &UnicodeString);
		if (!NT_SUCCESS(Status))
			break;

		// Now convert the entire table to uppercase host Oem Codepage
		AnsiString.Length = 0;
/* HitoshiT modify following line to keep Unicode translation table	5/18/94 */
#ifdef DBCS
		AnsiString.MaximumLength = 2*AFP_XLAT_TABLE_SIZE * sizeof(USHORT) + 1;
#else
		AnsiString.MaximumLength = 2*AFP_XLAT_TABLE_SIZE + 1;
#endif // DBCS
		AnsiString.Buffer = AfpTranslationTable;

		Status = RtlUpcaseUnicodeStringToOemString(&AnsiString, &UnicodeString, False);
		// Bug 342062
		// Bug introduced due to RtlpDidUnicodeToOemWork check 
		// introduced in RtlUpcaseUnicodeStringToOemString
		// We have characters which will be mapped to default characters
		// and hence we should ignore STATUS_UNMAPPABLE_CHARACTER
		if ((!NT_SUCCESS(Status))&&(Status!=STATUS_UNMAPPABLE_CHARACTER))
			break;

		// Now convert the entire table to host Oem Codepage
		AnsiString.Length = 0;
#ifdef DBCS
		AnsiString.MaximumLength = 2*AFP_XLAT_TABLE_SIZE * sizeof(USHORT) + 1;
#else
		AnsiString.MaximumLength = 2*AFP_XLAT_TABLE_SIZE + 1;
#endif // DBCS
		AnsiString.Buffer = AfpCasePreserveTranslationTable;

		Status = RtlUnicodeStringToOemString(&AnsiString, &UnicodeString, False);

		if ((!NT_SUCCESS(Status))&&(Status!=STATUS_UNMAPPABLE_CHARACTER))
			break;

		// Initialize host ANSI to mac ANSI translation table
		// Start by allocating memory for the table and filling it up.
		if ((AfpRevTranslationTable = AfpAllocPagedMemory(AFP_REV_XLAT_TABLE_SIZE + 1)) == NULL)
		{
			Status = STATUS_NO_MEMORY;
			break;
		}

		for (i = 0; i < 0x20; i++)
			AfpRevTranslationTable[i] = (BYTE)i;

		for (i = 0x80; i < 256; i++)
			AfpRevTranslationTable[i-(0x80-0x20)] = (BYTE)i;

		// Get rid of the line feed char
		AfpRevTranslationTable[0x0A] = 0;

		// Now translate host ANSI to unicode
		AnsiString.Length = AFP_REV_XLAT_TABLE_SIZE;
		AnsiString.MaximumLength = 	AFP_REV_XLAT_TABLE_SIZE + 1;
		AnsiString.Buffer = AfpRevTranslationTable;

		UnicodeString.Length = 0;

		Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, False);
		if (!NT_SUCCESS(Status))
			break;

		// and then translate from unicode to Mac ANSI
		Status = AfpConvertStringToAnsi(&UnicodeString, &AnsiString);

	} while (False);

	if (!NT_SUCCESS(Status))
	{
		AFPLOG_ERROR(AFPSRVMSG_MAC_CODEPAGE, Status, NULL, 0, NULL);
		if (AfpMacCPBaseAddress != NULL)
		{
			AfpFreeMemory(AfpMacCPBaseAddress);
			AfpMacCPBaseAddress = NULL;
		}

		if (FileHandle.fsh_FileHandle != NULL)
		{
			AfpIoClose(&FileHandle);
		}

		if (AfpTranslationTable != NULL)
		{
			AfpFreeMemory(AfpTranslationTable);
			AfpTranslationTable = NULL;
		}

		if (AfpCasePreserveTranslationTable != NULL)
		{
			AfpFreeMemory(AfpCasePreserveTranslationTable);
			AfpCasePreserveTranslationTable = NULL;
		}

		if (AfpRevTranslationTable != NULL)
		{
			AfpFreeMemory(AfpRevTranslationTable);
			AfpRevTranslationTable = NULL;
		}
	}

	AfpFreeMemory(devPathCP.Buffer);
	return Status;
}

/*** AfpIsLegalShortname
 *
 * Does a mac shortname conform to FAT 8.3 naming conventions?
 *
 */
BOOLEAN FASTCALL
AfpIsLegalShortname(
	IN	PANSI_STRING	pShortName			// Mac ANSI string
)
{
	return(FsRtlIsFatDbcsLegal(*pShortName, False, False, False));

}

/***	AfpIsProperSubstring
 *
 *	This routine looks for the substring pSubString in pString.  Both
 *  strings are in unicode, the comparison is done case insensitive
 *  (i.e. ignoring case).  This is used by the AfpCatSearch code.
 *
 */
BOOLEAN FASTCALL
AfpIsProperSubstring(
	IN	PUNICODE_STRING	pString,
	IN	PUNICODE_STRING	pSubString
)
{
	WCHAR			*s1, *s2, *ts1;
	USHORT			l1, l2, tl1;
	WCHAR			buf1[AFP_LONGNAME_LEN], buf2[AFP_LONGNAME_LEN];
	UNICODE_STRING	u1, u2;

	PAGED_CODE( );

	// see if this is a no-op?
	if (pSubString->Length > pString->Length)
		return False;

	AfpSetEmptyUnicodeString(&u1, sizeof(buf1), buf1);
	AfpSetEmptyUnicodeString(&u2, sizeof(buf2), buf2);
	if (!NT_SUCCESS(RtlUpcaseUnicodeString(&u1, pString, False)) ||
		!NT_SUCCESS(RtlUpcaseUnicodeString(&u2, pSubString, False)))
		return False;
	
	l1 = u1.Length/sizeof(WCHAR);
	s1 = u1.Buffer;

	do
	{
		l2 = u2.Length/sizeof(WCHAR);
		s2 = u2.Buffer;
		if (l2 > l1)
			return False;

		// look for the next occurrence of the first char of s2 in string s1
		while (l1)
		{
			if (*s2 == *s1)
				break;

			s1++;
			l1--;
		}

		if (l1 < l2)
			return False;
		if (l2 == 1)
			return True;

		l1--; l2--;
		s1++; s2++;

		ts1 = s1;
		tl1 = l1;

		while (l2)
		{
			// Look for substring s2 from current position in s1
			if (*s2 != *ts1)
				break;

			tl1--; l2--;
			ts1++; s2++;
		}

		if (l2 == 0)
			return True;

	} while (True);

	// Should never get here
	KeBugCheck(0);
}

/*** AfpStrChr
 *
 * DBCS sensitive strchr()
 *
 */
PCHAR
AfpStrChr(
    IN  PBYTE               String,
    IN  DWORD               StringLen,
    IN  BYTE                Char
)
{
    DWORD   BytesRemaining;


    BytesRemaining = StringLen;

    while (BytesRemaining > 0)
    {

/* MSKK hideyukn, strchr() does not work with DBCS, 08/07/95 */
#ifdef DBCS
        if (FsRtlIsLeadDbcsCharacter(*String))
        {
            String += 2;
            continue;
        }
#endif /* DBCS */

        if (*String == Char)
        {
            return(String);
        }

        String++;
        BytesRemaining--;
    }

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\lists.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	lists.h

Abstract:

	This module contains the macros for managing lists

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Oct 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _LISTS_
#define _LISTS_

#define	AfpLinkDoubleAtHead(_pHead, _p, Next, Prev)			\
	{														\
		(_p)->Next = (_pHead);								\
		(_p)->Prev = &(_pHead);								\
		if ((_pHead) != NULL)								\
		(_pHead)->Prev = &(_p)->Next;						\
			(_pHead) = (_p);								\
	}

#define	AfpLinkDoubleAtEnd(_pThis, _pLast, Next, Prev)		\
	{														\
		(_pLast)->Next = (_pThis);							\
		(_pThis)->Prev = &(_pLast)->Next;					\
		(_pThis)->Next = NULL;								\
	}

#define	AfpInsertDoubleBefore(_pThis, _pBefore, Next, Prev)	\
	{														\
		(_pThis)->Next = (_pBefore);						\
		(_pThis)->Prev = (_pBefore)->Prev;					\
		(_pBefore)->Prev = &(_pThis)->Next;					\
		*((_pThis)->Prev) = (_pThis);						\
	}

#define	AfpUnlinkDouble(_p, Next, Prev)						\
	{														\
		*((_p)->Prev) = (_p)->Next;							\
		if ((_p)->Next != NULL)								\
			(_p)->Next->Prev = (_p)->Prev;					\
	}

#endif	// _LISTS_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\nwtrash.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	nwtrash.h

Abstract:

	This file defines the file network trash folder routine prototypes

Author:

	Sue Adams (microsoft!suea)


Revision History:
	13 Aug 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_NWTRASH_
#define	_NWTRASH_

//
//	NtOpenFile/NtCreateFile values for the network trash folder
//

#define	AFP_NWT_ACCESS		FILEIO_ACCESS_DELETE
#define AFP_NWT_SHAREMODE	FILE_SHARE_READ | FILE_SHARE_WRITE
#define AFP_NWT_OPTIONS		FILEIO_OPEN_DIR
#define AFP_NWT_ATTRIBS		FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN
#define AFP_NWT_DISPOSITION	FILEIO_CREATE_SOFT

typedef struct _WalkDirNode {
	BOOLEAN				wdn_Enumerated;
	FILESYSHANDLE		wdn_Handle;
	UNICODE_STRING		wdn_RelativePath;
	struct _WalkDirNode *wdn_Next;
} WALKDIR_NODE, *PWALKDIR_NODE;

typedef NTSTATUS (*WALKDIR_WORKER)(PFILESYSHANDLE phRelative, PWCHAR Name, ULONG Namelen, BOOLEAN IsDir);


extern
NTSTATUS
AfpCreateNetworkTrash(
	IN	PVOLDESC	pVolDesc
);

extern
NTSTATUS
AfpDeleteNetworkTrash(
	IN	PVOLDESC	pVolDesc,
	IN	BOOLEAN		VolumeStart
);

extern
NTSTATUS
AfpWalkDirectoryTree(
	IN	PFILESYSHANDLE	phTargetDir,
	IN	WALKDIR_WORKER	NodeWorker
);

extern
NTSTATUS
AfpGetNextDirectoryInfo(
	IN OUT	PFILE_DIRECTORY_INFORMATION	* ppInfoBuf,
	OUT		PWCHAR		*	pNodeName,
	OUT		PULONG			pNodeNameLen,
	OUT		PBOOLEAN		pIsDir
);

#ifdef	NWTRASH_LOCALS

LOCAL
NTSTATUS
afpCleanNetworkTrash(
	IN	PVOLDESC			pVolDesc,
	IN	PFILESYSHANDLE		phNWT,
	IN	PDFENTRY			pDfeNWT OPTIONAL
);

LOCAL
NTSTATUS
afpPushDirNode(
	IN OUT	PWALKDIR_NODE *	ppStackTop,
	IN		PUNICODE_STRING pParentPath,	// path to parent (NULL iff walk target)
	IN		PUNICODE_STRING	pDirName		// name of current directory node
);

LOCAL
VOID
afpPopDirNode(
	IN OUT	PWALKDIR_NODE *	ppStackTop
);

LOCAL
NTSTATUS
afpNwtDeleteFileEntity(
	IN	PFILESYSHANDLE	phRelative,
	IN	PWCHAR			Name,
	IN	ULONG			Namelen,
	IN 	BOOLEAN			IsDir
);

#endif	// NWTRASH_LOCALS

#endif 	// _NWTRASH_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\pathmap.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	pathmap.c

Abstract:

	This module contains the routines that manipulate AFP paths.

Author:

	Sue Adams	(microsoft!suea)


Revision History:
	04 Jun 1992			Initial Version
	05 Oct 1993 JameelH	Performance Changes. Merge cached afpinfo into the
						idindex structure. Make both the ANSI and the UNICODE
						names part of idindex. Added EnumCache for improving
						enumerate perf.

Notes:	Tab stop: 4
--*/

#define	_PATHMAP_LOCALS
#define	FILENUM	FILE_PATHMAP

#include <afp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <afpinfo.h>
#include <client.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpMapAfpPath)
#pragma alloc_text( PAGE, AfpMapAfpPathForLookup)
#pragma alloc_text( PAGE, AfpMapAfpIdForLookup)
#pragma alloc_text( PAGE, afpGetMappedForLookupFDInfo)
#pragma alloc_text( PAGE, afpMapAfpPathToMappedPath)
#pragma alloc_text( PAGE, AfpHostPathFromDFEntry)
#pragma alloc_text( PAGE, AfpCheckParentPermissions)
#pragma alloc_text( PAGE, afpOpenUserHandle)
#endif


/***	AfpMapAfpPath
 *
 *	If mapping is for lookup operation, a FILESYSHANDLE open in the user's
 *	context is returned,  The caller MUST close this handle when done with it.
 *
 *	If pFDParm is non-null, it will be filled in as appropriate according to Bitmap.
 *
 *	If mapping is for create operation, the volume root-relative host pathname
 *	(in unicode) of the item we are about to create is returned. For lookup
 *	operation the paths refer to the item being pathmapped.  This routine
 *	always returns the paths in the PME.  It is the caller's responsibility
 *	to free the Full HostPath Buffer, if it is not supplied already.
 *
 *	The caller MUST have the IdDb locked for Exclusive access.
 *
 *	LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Exclusive)
 *
 */
AFPSTATUS
AfpMapAfpPath(
	IN		PCONNDESC		pConnDesc,
	IN		DWORD			DirId,
	IN		PANSI_STRING	pPath,
	IN		BYTE			PathType,			// short names or long names
	IN		PATHMAP_TYPE	MapReason,	 		// for lookup or hard/soft create?
	IN		DWORD			DFFlag,				// map to file? dir? or either?
	IN		DWORD			Bitmap,				// what fields of FDParm to fill in
	OUT		PPATHMAPENTITY	pPME,
	OUT		PFILEDIRPARM	pFDParm OPTIONAL	// for lookups only
)
{
	PVOLDESC		pVolDesc;
	MAPPEDPATH		mappedpath;
	AFPSTATUS		Status;
#ifdef	PROFILING
	TIME			TimeS, TimeE, TimeD;
#endif

	PAGED_CODE( );

	ASSERT((pConnDesc != NULL));

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_PathMapCount);
	AfpGetPerfCounter(&TimeS);
#endif

	pVolDesc = pConnDesc->cds_pVolDesc;
	ASSERT(IS_VOLUME_NTFS(pVolDesc));
	ASSERT(AfpSwmrLockedExclusive(&pVolDesc->vds_IdDbAccessLock));

	// initialize some fields in the PME
	AfpSetEmptyUnicodeString(&pPME->pme_ParentPath, 0, NULL);

	do
	{
		Status = afpMapAfpPathToMappedPath(pVolDesc,
										   DirId,
										   pPath,
										   PathType,
										   MapReason,
										   DFFlag,
										   True,
										   &mappedpath);
		if ((Status != AFP_ERR_NONE) &&
			!((MapReason == HardCreate) &&
			  (Status == AFP_ERR_OBJECT_EXISTS) &&
			  (DFFlag == DFE_FILE)))
		{
			break;
		}

		ASSERT(pPME != NULL);

		// Get the volume relative path to the parent directory for
		// creates, or to the item for lookups
		if ((Status = AfpHostPathFromDFEntry(mappedpath.mp_pdfe,
											 // since CopyFile and Move have to lookup
											 // the destination parent dir paths, we
											 // need to allocate extra room for them in
											 // the path to append the filename
											 (MapReason == Lookup) ?
												(AFP_LONGNAME_LEN + 1) * sizeof(WCHAR):
												mappedpath.mp_Tail.Length + sizeof(WCHAR),
											 &pPME->pme_FullPath)) != AFP_ERR_NONE)
			break;

		// if Pathmap is for hard (files only) or soft create (file or dir)
		if (MapReason != Lookup)
		{
			ASSERT(pFDParm == NULL);

			// fill in the dfe of parent dir in which create will take place
			pPME->pme_pDfeParent = mappedpath.mp_pdfe;

			// fill in path to parent
			pPME->pme_ParentPath = pPME->pme_FullPath;

			// Add a path separator if we are not at the root
			if (pPME->pme_FullPath.Length > 0)
			{
				pPME->pme_FullPath.Buffer[pPME->pme_FullPath.Length / sizeof(WCHAR)] = L'\\';
				pPME->pme_FullPath.Length += sizeof(WCHAR);
			}

			pPME->pme_UTail.Length = pPME->pme_UTail.MaximumLength = mappedpath.mp_Tail.Length;
			pPME->pme_UTail.Buffer = (PWCHAR)((PBYTE)pPME->pme_FullPath.Buffer +
											  pPME->pme_FullPath.Length);

			Status = RtlAppendUnicodeStringToString(&pPME->pme_FullPath,
													&mappedpath.mp_Tail);
			ASSERT(NT_SUCCESS(Status));
		}
		else // lookup operation
		{
			pPME->pme_pDfEntry = mappedpath.mp_pdfe;
			pPME->pme_UTail.Length = mappedpath.mp_pdfe->dfe_UnicodeName.Length;
			pPME->pme_UTail.Buffer = (PWCHAR)((PBYTE)pPME->pme_FullPath.Buffer +
											  pPME->pme_FullPath.Length -
											  pPME->pme_UTail.Length);

			pPME->pme_ParentPath.Length =
			pPME->pme_ParentPath.MaximumLength = pPME->pme_FullPath.Length - pPME->pme_UTail.Length;

			if (pPME->pme_FullPath.Length > pPME->pme_UTail.Length)
			{
				// subtract the path separator if not in root dir
				pPME->pme_ParentPath.Length -= sizeof(WCHAR);
				ASSERT(pPME->pme_ParentPath.Length >= 0);
			}
			pPME->pme_ParentPath.Buffer = pPME->pme_FullPath.Buffer;
			pPME->pme_UTail.MaximumLength = pPME->pme_FullPath.MaximumLength - pPME->pme_ParentPath.Length;

			Status = afpGetMappedForLookupFDInfo(pConnDesc,
												 mappedpath.mp_pdfe,
												 Bitmap,
												 pPME,
												 pFDParm);
			// if this fails do not free path buffer and set it back to
			// null.  We don't know that the path buffer isn't on
			// the callers stack. Caller should always clean it up himself.
		}
	} while (False);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);		
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_PathMapTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	return Status;
}

/***	AfpMapAfpPathForLookup
 *
 *	Maps an AFP dirid/pathname pair to an open handle (in the user's context)
 *	to the DATA stream of the file/dir.
 *	The DirID database is locked for read for the duration of this
 *	routine, unless afpMapAfpPathToMappedPath returns
 *  AFP_ERR_WRITE_LOCK_REQUIRED in which case the DirID database will be locked
 *  for write.  This will only happen the first time a mac tries to access
 *  a directory who's files have not yet been cached in.
 *
 *	LOCKS: vds_IdDbAccessLock (SWMR, Shared OR Exclusive)
 */
AFPSTATUS
AfpMapAfpPathForLookup(
	IN		PCONNDESC		pConnDesc,
	IN		DWORD			DirId,
	IN		PANSI_STRING	pPath,
	IN		BYTE			PathType,	  // short names or long names
	IN		DWORD			DFFlag,
	IN		DWORD			Bitmap,
	OUT		PPATHMAPENTITY	pPME	OPTIONAL,
	OUT		PFILEDIRPARM	pFDParm OPTIONAL
)
{
	MAPPEDPATH	mappedpath;
	PVOLDESC	pVolDesc;
	PSWMR		pIdDbLock;
	AFPSTATUS	Status;
	BOOLEAN		swmrLockedExclusive = False;
	PATHMAP_TYPE mapReason = Lookup;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;
#endif

	PAGED_CODE( );

	ASSERT((pConnDesc != NULL));


#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_PathMapCount);
	AfpGetPerfCounter(&TimeS);
#endif

#ifndef GET_CORRECT_OFFSPRING_COUNTS
	if (pConnDesc->cds_pSda->sda_AfpFunc == _AFP_ENUMERATE)
	{
		mapReason = LookupForEnumerate;
	}
#endif

	pVolDesc  = pConnDesc->cds_pVolDesc;
	pIdDbLock = &(pVolDesc->vds_IdDbAccessLock);

	AfpSwmrAcquireShared(pIdDbLock);

	do
	{
		do
		{
			Status = afpMapAfpPathToMappedPath(pVolDesc,
											  DirId,
											  pPath,
											  PathType,
											  mapReason,	// lookups only
											  DFFlag,
											  swmrLockedExclusive,
											  &mappedpath);
	
			if (Status == AFP_ERR_WRITE_LOCK_REQUIRED)
			{
				ASSERT (!swmrLockedExclusive);
				// Pathmap needed to cache in the files for the last directory
				// in the path but didn't have the write lock to the ID database
				AfpSwmrRelease(pIdDbLock);
				AfpSwmrAcquireExclusive(pIdDbLock);
				swmrLockedExclusive = True;
				continue;
			}
			break;
		} while (True);

		if (!NT_SUCCESS(Status))
		{
			DBGPRINT (DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							("AfpMapAfpPathForLookup: afpMapAfpPathToMappedPath failed: Error = %lx\n", Status));
			break;
		}

		if (ARGUMENT_PRESENT(pPME))
		{
			pPME->pme_FullPath.Length = 0;
		}

		if (Bitmap & FD_INTERNAL_BITMAP_RETURN_PMEPATHS)
		{
			ASSERT(ARGUMENT_PRESENT(pPME));
			if ((Status = AfpHostPathFromDFEntry(mappedpath.mp_pdfe,
												 (Bitmap & FD_INTERNAL_BITMAP_OPENFORK_RESC) ?
														AfpResourceStream.Length : 0,
												 &pPME->pme_FullPath)) != AFP_ERR_NONE)
				break;

			pPME->pme_UTail.Length = mappedpath.mp_pdfe->dfe_UnicodeName.Length;
			pPME->pme_UTail.Buffer = (PWCHAR)((PBYTE)pPME->pme_FullPath.Buffer +
											  pPME->pme_FullPath.Length - pPME->pme_UTail.Length);

			pPME->pme_ParentPath.Length =
			pPME->pme_ParentPath.MaximumLength = pPME->pme_FullPath.Length - pPME->pme_UTail.Length;

			if (pPME->pme_FullPath.Length > pPME->pme_UTail.Length)
			{
				// subtract the path separator if not in root dir
				pPME->pme_ParentPath.Length -= sizeof(WCHAR);
				ASSERT(pPME->pme_ParentPath.Length >= 0);
			}
			pPME->pme_ParentPath.Buffer = pPME->pme_FullPath.Buffer;
			pPME->pme_UTail.MaximumLength = pPME->pme_FullPath.MaximumLength - pPME->pme_ParentPath.Length;
		}

		Status = afpGetMappedForLookupFDInfo(pConnDesc,
											 mappedpath.mp_pdfe,
											 Bitmap,
											 pPME,
											 pFDParm);
	} while (False);

	AfpSwmrRelease(pIdDbLock);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_PathMapTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	return Status;

}

/***	AfpMapAfpIdForLookup
 *
 *	Maps an AFP id to an open FILESYSTEMHANDLE (in the user's context) to
 * 	to the DATA stream of the file/dir.
 *	The DirID database is locked for shared or exclusive access for the duration
 *	of this routine.
 *
 *	LOCKS: vds_IdDbAccessLock (SWMR, Shared OR Exclusive)
 */
AFPSTATUS
AfpMapAfpIdForLookup(
	IN		PCONNDESC		pConnDesc,
	IN		DWORD			AfpId,
	IN		DWORD			DFFlag,
	IN		DWORD			Bitmap,
	OUT		PPATHMAPENTITY	pPME	OPTIONAL,
	OUT		PFILEDIRPARM	pFDParm OPTIONAL
)
{
	PVOLDESC	pVolDesc;
	PSWMR		pIdDbLock;
	AFPSTATUS	Status;
	PDFENTRY	pDfEntry;
	BOOLEAN		CleanupLock = False;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;
#endif

	PAGED_CODE( );

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_PathMapCount);
	AfpGetPerfCounter(&TimeS);
#endif

	ASSERT((pConnDesc != NULL));

	do
	{
		if (AfpId == 0)
		{
			Status = AFP_ERR_PARAM;
			break;
		}

		pVolDesc  = pConnDesc->cds_pVolDesc;
		pIdDbLock = &(pVolDesc->vds_IdDbAccessLock);

		AfpSwmrAcquireShared(pIdDbLock);
		CleanupLock = True;

		if ((AfpId == AFP_ID_PARENT_OF_ROOT) ||
			((pDfEntry = AfpFindDfEntryById(pVolDesc, AfpId, DFE_ANY)) == NULL))
		{
			Status = AFP_ERR_OBJECT_NOT_FOUND;
			break;
		}

		if (((DFFlag == DFE_DIR) && DFE_IS_FILE(pDfEntry)) ||
			((DFFlag == DFE_FILE) && DFE_IS_DIRECTORY(pDfEntry)))
		{
			Status = AFP_ERR_OBJECT_TYPE;
			break;
		}

		if (ARGUMENT_PRESENT(pPME))
		{
			pPME->pme_FullPath.Length = 0;
		}

		Status = afpGetMappedForLookupFDInfo(pConnDesc,
											 pDfEntry,
											 Bitmap,
											 pPME,
											 pFDParm);
	} while (False);

	if (CleanupLock)
	{
		AfpSwmrRelease(pIdDbLock);
	}

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_PathMapTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	return Status;
}

/***	afpGetMappedForLookupFDInfo
 *
 *	After a pathmap for LOOKUP operation, this routine is called to
 *	return various FileDir parm information about the mapped file/dir.
 *	The following FileDir information is always returned:
 *		AFP DirId/FileId
 *		Parent DirId
 *		DFE flags (indicating item is a directory, a file, or a file with an ID)
 *		Attributes (Inhibit bits and D/R Already open bits normalized with
 *					the NTFS attributes for RO, System, Hidden, Archive)
 *		BackupTime
 *		CreateTime
 *		ModifiedTime
 *
 *	The following FileDir information is returned according to the flags set
 *	in word 0 of the Bitmap parameter (these correspond to the AFP file/dir
 *	bitmap):
 *		Longname
 *		Shortname
 *		FinderInfo
 *		ProDosInfo
 *		Directory Access Rights (as stored in AFP_AfpInfo stream)
 *		Directory OwnerId/GroupId
 *		Directory Offspring count (file count and dir count are separate)
 *
 *	The open access is stored in word 1 of the Bitmap parameter.
 *	This is used by AfpOpenUserHandle (for NTFS volumes) or AfpIoOpen (for
 *	CDFS volumes) when opening the data stream of the file/dir (under
 *	impersonation for NTFS) who's handle will be returned within the
 *	pPME parameter if supplied.
 *
 *	LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Shared)
 *
 */
LOCAL
AFPSTATUS
afpGetMappedForLookupFDInfo(
	IN	PCONNDESC			pConnDesc,
	IN	PDFENTRY			pDfEntry,
	IN	DWORD				Bitmap,
	OUT	PPATHMAPENTITY		pPME	OPTIONAL,	// Supply for NTFS only if need a
												// handle in user's context, usually
												// for security checking purposes
	OUT	PFILEDIRPARM		pFDParm	OPTIONAL	// Supply if want returned FDInfo
)
{
	BOOLEAN			fNtfsVol;
	AFPSTATUS		Status = STATUS_SUCCESS;
	DWORD			OpenAccess = FILEIO_ACCESS_NONE;
	FILESYSHANDLE	fsh;
	PFILESYSHANDLE	pHandle = NULL;

	PAGED_CODE( );

	fNtfsVol = IS_VOLUME_NTFS(pConnDesc->cds_pVolDesc);
	if (ARGUMENT_PRESENT(pPME))
	{
		pHandle = &pPME->pme_Handle;
	}
	else if ((fNtfsVol &&
			(Bitmap & (FD_BITMAP_SHORTNAME | FD_BITMAP_PRODOSINFO))))
	{
		pHandle = &fsh;
	}

	if (pHandle != NULL)
	{
		if (!NT_SUCCESS(Status = afpOpenUserHandle(pConnDesc,
												   pDfEntry,
												   (ARGUMENT_PRESENT(pPME) &&
													(pPME->pme_FullPath.Buffer != NULL)) ?
														&pPME->pme_FullPath : NULL,
												   Bitmap,		// encode open/deny modes
												   pHandle)))
		{
			if ((Status == AFP_ERR_DENY_CONFLICT) &&
				ARGUMENT_PRESENT(pFDParm))
			{
				// For CreateId/ResolveId/DeleteId
				pFDParm->_fdp_AfpId = pDfEntry->dfe_AfpId;
				pFDParm->_fdp_Flags = (pDfEntry->dfe_Flags & DFE_FLAGS_DFBITS);
			}
			return Status;
		}
	}

	do
	{
		if (ARGUMENT_PRESENT(pFDParm))
		{
			pFDParm->_fdp_AfpId = pDfEntry->dfe_AfpId;
			pFDParm->_fdp_ParentId = pDfEntry->dfe_Parent->dfe_AfpId;

			ASSERT(!((pDfEntry->dfe_Flags & DFE_FLAGS_DIR) &&
					 (pDfEntry->dfe_Flags & (DFE_FLAGS_FILE_WITH_ID | DFE_FLAGS_FILE_NO_ID))));

			pFDParm->_fdp_Flags = (pDfEntry->dfe_Flags & DFE_FLAGS_DFBITS);

			if (Bitmap & FD_BITMAP_FINDERINFO)
			{
				pFDParm->_fdp_FinderInfo = pDfEntry->dfe_FinderInfo;
			}

			pFDParm->_fdp_Attr = pDfEntry->dfe_AfpAttr;
			AfpNormalizeAfpAttr(pFDParm, pDfEntry->dfe_NtAttr);

			// The Finder uses the Finder isInvisible flag over
			// the file system Invisible attribute to tell if the thing is
			// displayed or not.  If the PC turns off the hidden attribute
			// we should clear the Finder isInvisible flag
			if ((Bitmap & FD_BITMAP_FINDERINFO) &&
				!(pFDParm->_fdp_Attr & FD_BITMAP_ATTR_INVISIBLE))
			{
				pFDParm->_fdp_FinderInfo.fd_Attr1 &= ~FINDER_FLAG_INVISIBLE;
			}

			pFDParm->_fdp_BackupTime = pDfEntry->dfe_BackupTime;
			pFDParm->_fdp_CreateTime = pDfEntry->dfe_CreateTime;
			pFDParm->_fdp_ModifiedTime = AfpConvertTimeToMacFormat(&pDfEntry->dfe_LastModTime);

			if (Bitmap & FD_BITMAP_LONGNAME)
			{
				ASSERT((pFDParm->_fdp_LongName.Buffer != NULL) &&
					   (pFDParm->_fdp_LongName.MaximumLength >=
						pDfEntry->dfe_UnicodeName.Length/(USHORT)sizeof(WCHAR)));
				AfpConvertMungedUnicodeToAnsi(&pDfEntry->dfe_UnicodeName,
											  &pFDParm->_fdp_LongName);
			}

			if (Bitmap & FD_BITMAP_SHORTNAME)
			{
				ASSERT(pFDParm->_fdp_ShortName.Buffer != NULL);

				if (!fNtfsVol)
				{
					ASSERT(pFDParm->_fdp_ShortName.MaximumLength >=
										(pDfEntry->dfe_UnicodeName.Length/sizeof(WCHAR)));
					AfpConvertMungedUnicodeToAnsi(&pDfEntry->dfe_UnicodeName,
												  &pFDParm->_fdp_ShortName);

					// if asking for shortname on CDFS, we will fill in the pFDParm
					// shortname with the pDfEntry longname, ONLY if it is an 8.3 name
					if (!AfpIsLegalShortname(&pFDParm->_fdp_ShortName))
					{
						pFDParm->_fdp_ShortName.Length = 0;
					}
				}
				else
				{
					// get NTFS shortname
					ASSERT(pFDParm->_fdp_ShortName.MaximumLength >= AFP_SHORTNAME_LEN);
					ASSERT(pHandle != NULL);

					Status = AfpIoQueryShortName(pHandle,
												 &pFDParm->_fdp_ShortName);
					if (!NT_SUCCESS(Status))
					{
						pFDParm->_fdp_ShortName.Length = 0;
						break;
					}
				}
			}

			if (DFE_IS_FILE(pDfEntry))
			{
				if (pDfEntry->dfe_Flags & DFE_FLAGS_D_ALREADYOPEN)
					pFDParm->_fdp_Attr |= FILE_BITMAP_ATTR_DATAOPEN;
				if (pDfEntry->dfe_Flags & DFE_FLAGS_R_ALREADYOPEN)
					pFDParm->_fdp_Attr |= FILE_BITMAP_ATTR_RESCOPEN;
				if (Bitmap & FILE_BITMAP_RESCLEN)
				{
					pFDParm->_fdp_RescForkLen = pDfEntry->dfe_RescLen;
				}
				if (Bitmap & FILE_BITMAP_DATALEN)
				{
					pFDParm->_fdp_DataForkLen = pDfEntry->dfe_DataLen;
				}
			}

			if (Bitmap & FD_BITMAP_PRODOSINFO)
			{
				if (fNtfsVol)
				{
					ASSERT(pHandle != NULL);
					Status = AfpQueryProDos(pHandle,
											&pFDParm->_fdp_ProDosInfo);
					if (!NT_SUCCESS(Status))
					{
						break;
					}
				}
				else	// CDFS File or Directory
				{
					RtlZeroMemory(&pFDParm->_fdp_ProDosInfo, sizeof(PRODOSINFO));
					if (DFE_IS_FILE(pDfEntry))	// CDFS file
					{
						AfpProDosInfoFromFinderInfo(&pDfEntry->dfe_FinderInfo,
													&pFDParm->_fdp_ProDosInfo);
					}
					else	// CDFS Directory
					{
						pFDParm->_fdp_ProDosInfo.pd_FileType[0] = PRODOS_TYPE_DIR;
						pFDParm->_fdp_ProDosInfo.pd_AuxType[1] = PRODOS_AUX_DIR;
					}
				}
			}

			// check for dir here since enumerate ANDs the file and dir bitmaps
			if (DFE_IS_DIRECTORY(pDfEntry) &&
				(Bitmap & (DIR_BITMAP_ACCESSRIGHTS |
						   DIR_BITMAP_OWNERID |
						   DIR_BITMAP_GROUPID)))
			{
				if (fNtfsVol)
				{
					// Because the file and dir bitmaps are OR'd together,
					// and the OwnerId bit is overloaded with the RescLen bit,
					// we don't know if this bit was actually included in the
					// file bitmap or the dir bitmap.  The api would have
					// determined whether or not it needed a handle based on
					// these bitmaps, so based on the pPME we can tell if we
					// actually need to query for security or not.
					if (ARGUMENT_PRESENT(pPME))
					{
						pFDParm->_fdp_OwnerRights = DFE_OWNER_ACCESS(pDfEntry);
						pFDParm->_fdp_GroupRights = DFE_GROUP_ACCESS(pDfEntry);
						pFDParm->_fdp_WorldRights = DFE_WORLD_ACCESS(pDfEntry);

						// Query this user's rights
						Status = AfpQuerySecurityIdsAndRights(pConnDesc->cds_pSda,
															  pHandle,
															  Bitmap,
															  pFDParm);
						if (!NT_SUCCESS(Status))
						{
							break;
						}
					}
				}
				else
				{
					pFDParm->_fdp_OwnerRights =
					pFDParm->_fdp_GroupRights =
					pFDParm->_fdp_WorldRights =
					pFDParm->_fdp_UserRights  = (DIR_ACCESS_READ | DIR_ACCESS_SEARCH);
					pFDParm->_fdp_OwnerId = pFDParm->_fdp_GroupId = 0;
				}
			}

			// Must check for type directory since this Bitmap bit is overloaded
			if (DFE_IS_DIRECTORY(pDfEntry) && (Bitmap & DIR_BITMAP_OFFSPRINGS))
			{
#ifndef GET_CORRECT_OFFSPRING_COUNTS
				if (!DFE_CHILDREN_ARE_PRESENT(pDfEntry) &&
					(pDfEntry->dfe_DirOffspring == 0))
				{
					// If the files have not yet been cached in for this dir,
					// return non-zero filecount so that system 7.x view by
					// name will enumerate the directory if user clicks the
					// triangle for this dir.  If you return zero offspring
					// What might break from lying like this?
					pFDParm->_fdp_FileCount = 1;
                }
				else
#endif
					pFDParm->_fdp_FileCount = pDfEntry->dfe_FileOffspring;

				pFDParm->_fdp_DirCount  = pDfEntry->dfe_DirOffspring;
			}
		}
	} while (False);

	if (pHandle == &fsh)
	{
		// if we had to open a handle just to query shortname or ProDOS
		// close it
		AfpIoClose(&fsh);
	}

	return Status;
}


/***	afpMapAfpPathToMappedPath
 *
 *	Maps an AFP DirId/pathname pair to a MAPPEDPATH structure.
 *	The CALLER must have the DirId/FileId database locked for shared
 *	access (or Exclusive access if they need that level of lock for other
 *	operations on the IDDB, to map a path only requires shared lock)
 *
 *	LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Shared OR Exclusive)
 */
LOCAL
AFPSTATUS
afpMapAfpPathToMappedPath(
	IN		PVOLDESC		pVolDesc,
	IN		DWORD			DirId,
	IN		PANSI_STRING	Path,		// relative to DirId
	IN		BYTE			PathType,	// short names or long names
	IN		PATHMAP_TYPE	MapReason,  // for lookup or hard/soft create?
	IN		DWORD			DFflag,		// file, dir or don't know which
	IN		BOOLEAN			LockedExclusive,
	OUT		PMAPPEDPATH		pMappedPath

)
{
	PDFENTRY		pDFEntry, ptempDFEntry;
	CHAR			*position, *tempposition;
	int				length, templength;
	ANSI_STRING		acomponent;
	CHAR			component[AFP_FILENAME_LEN+1];
	BOOLEAN			checkEnumForParent = False, checkEnumForDir = False;

	PAGED_CODE( );

	ASSERT(pVolDesc != NULL);

#ifndef GET_CORRECT_OFFSPRING_COUNTS
	if (MapReason == LookupForEnumerate)
	{
		checkEnumForDir = True;
		MapReason = Lookup;
	}
#endif

	// Initialize the returned MappedPath structure
	pMappedPath->mp_pdfe = NULL;
	AfpSetEmptyUnicodeString(&pMappedPath->mp_Tail,
							 sizeof(pMappedPath->mp_Tailbuf),
							 pMappedPath->mp_Tailbuf);

	// Lookup the initial DirId in the index database, it better be valid
	if ((pDFEntry = AfpFindDfEntryById(pVolDesc,
									   DirId,
									   DFE_DIR)) == NULL)
	{
		return AFP_ERR_OBJECT_NOT_FOUND;
	}

	ASSERT(Path != NULL);
	tempposition = position = Path->Buffer;
	templength = length = Path->Length;

	do
	{
		// Lookup by DirId only?
		if (length == 0)				// no path was given
		{
			if (MapReason != Lookup)	// mapping is for create
			{
				return AFP_ERR_PARAM;	// missing the file or dirname
			}
			else if (DFE_IS_PARENT_OF_ROOT(pDFEntry))
			{
				return AFP_ERR_OBJECT_NOT_FOUND;
			}
			else
			{
				pMappedPath->mp_pdfe = pDFEntry;
#ifdef GET_CORRECT_OFFSPRING_COUNTS
				checkEnumForParent = checkEnumForDir = True;
#endif
				break;
			}
		}

		//
		// Pre-scan path to munge for easier component breakdown
		//

		// Get rid of a leading null to make scanning easier
		if (*position == AFP_PATHSEP)
		{
			length--;
			position++;
			if (length == 0)	// The path consisted of just one null byte
			{
				if (MapReason != Lookup)
				{
					return AFP_ERR_PARAM;
				}
				else if (DFE_IS_PARENT_OF_ROOT(pDFEntry))
				{
					return AFP_ERR_OBJECT_NOT_FOUND;
				}
				else if (((DFflag == DFE_DIR) && DFE_IS_FILE(pDFEntry)) ||
						 ((DFflag == DFE_FILE) && DFE_IS_DIRECTORY(pDFEntry)))
				{
					return AFP_ERR_OBJECT_TYPE;
				}
				else
				{
					pMappedPath->mp_pdfe = pDFEntry;
#ifdef GET_CORRECT_OFFSPRING_COUNTS
					checkEnumForParent = checkEnumForDir = True;
#endif
					break;
				}
			}
		}

		//
		// Get rid of a trailing null if it is not an "up" token --
		// i.e. preceded by another null.
		// The 2nd array access is ok because we know we have at
		// least 2 chars at that point
		//
		if ((position[length-1] == AFP_PATHSEP) &&
			(position[length-2] != AFP_PATHSEP))
		{
				length--;
		}


		// begin parsing out path components, stop when you find the last component
		while (1)
		{
			afpGetNextComponent(position,
								length,
								PathType,
								component,
								&templength);
			if (templength < 0)
			{
				// component was too long or an invalid AFP character was found
				return AFP_ERR_PARAM;
			}

			length -= templength;
			if (length == 0)
			{
				// we found the last component
				break;
			}

			position += templength;

			if (component[0] == AFP_PATHSEP)	// moving up?
			{	// make sure you don't go above parent of root!
				if (DFE_IS_PARENT_OF_ROOT(pDFEntry))
				{
					return AFP_ERR_OBJECT_NOT_FOUND;
				}
				else pDFEntry = pDFEntry->dfe_Parent;	//backup one level
			}
			else // Must be a directory component moving DOWN in tree
			{
				RtlInitString(&acomponent, component);
				AfpConvertStringToMungedUnicode(&acomponent, &pMappedPath->mp_Tail);
				if ((ptempDFEntry = AfpFindEntryByUnicodeName(pVolDesc,
															  &pMappedPath->mp_Tail,
															  PathType,
															  pDFEntry,
															  DFE_DIR)) == NULL)
				{
					return AFP_ERR_OBJECT_NOT_FOUND;
				}
				else
				{
					pDFEntry = ptempDFEntry;
				}
			}
		} // end while

		//
		// we have found the last component
		// is the last component an 'up' token?
		//
		if (component[0] == AFP_PATHSEP)
		{
			// don't bother walking up beyond the root
			switch (pDFEntry->dfe_AfpId)
			{
				case AFP_ID_PARENT_OF_ROOT:
					return AFP_ERR_OBJECT_NOT_FOUND;
				case AFP_ID_ROOT:
					return ((MapReason == Lookup) ? AFP_ERR_OBJECT_NOT_FOUND :
													AFP_ERR_PARAM);
				default: // backup one level
					pMappedPath->mp_pdfe = pDFEntry->dfe_Parent;
			}

			// this better be a lookup request
			if (MapReason != Lookup)
			{
				if (DFflag == DFE_DIR)
				{
					return AFP_ERR_OBJECT_EXISTS;
				}
				else
				{
					return AFP_ERR_OBJECT_TYPE;
				}
			}

			// had to have been a lookup operation
			if (DFflag == DFE_FILE)
			{
				return AFP_ERR_OBJECT_TYPE;
			}
			else
			{
#ifdef GET_CORRECT_OFFSPRING_COUNTS
				checkEnumForParent = checkEnumForDir = True;
#endif
				break;
			}
		} // endif last component was an 'up' token

		// the last component is a file or directory name
		RtlInitString(&acomponent, component);
		AfpConvertStringToMungedUnicode(&acomponent,
										&pMappedPath->mp_Tail);

		//
		// Before we search our database for the last component of the
		// path, make sure all the files have been cached in for this
		// directory
		//
		if (!DFE_CHILDREN_ARE_PRESENT(pDFEntry))
		{
			if (!LockedExclusive &&
				!AfpSwmrUpgradeToExclusive(&pVolDesc->vds_IdDbAccessLock))
			{
				return AFP_ERR_WRITE_LOCK_REQUIRED;
			}
			else
			{
				NTSTATUS status;
				LockedExclusive = True;
				status = AfpCacheDirectoryTree(pVolDesc,
											   pDFEntry,
											   GETFILES,
											   NULL,
											   NULL);
				if (!NT_SUCCESS(status))
				{
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							("afpMapAfpPathToMappedPath: could not cache dir tree for %Z (0x%lx)\n",
							 &(pDFEntry->dfe_UnicodeName), status) );
					return AFP_ERR_MISC;
				}
			}
		}

		ptempDFEntry = AfpFindEntryByUnicodeName(pVolDesc,
												 &pMappedPath->mp_Tail,
												 PathType,
												 pDFEntry,
												 DFE_ANY);

		if (MapReason == Lookup)	// its a lookup request
		{
			if (ptempDFEntry == NULL)
			{
				return AFP_ERR_OBJECT_NOT_FOUND;
			}
			else if (((DFflag == DFE_DIR) && DFE_IS_FILE(ptempDFEntry)) ||
					 ((DFflag == DFE_FILE) && DFE_IS_DIRECTORY(ptempDFEntry)))
			{
				return AFP_ERR_OBJECT_TYPE;
			}
			else
			{
				pMappedPath->mp_pdfe = ptempDFEntry;
#ifdef GET_CORRECT_OFFSPRING_COUNTS
				if (DFE_IS_DIRECTORY(ptempDFEntry))
					// we've already made sure this thing's parent was
					// enumerated already above.
					checkEnumForDir = True;
#endif
				break;
			}
		}
		else	// path mapping is for a create
		{
			ASSERT(DFflag != DFE_ANY); // Create must specify the exact type

			// Save the parent DFEntry
			pMappedPath->mp_pdfe = pDFEntry;

			if (ptempDFEntry != NULL)
			{
				// A file or dir by that name exists in the database
				// (and we will assume it exists on disk)
				if (MapReason == SoftCreate)
				{
					// Attempting create of a directory, or soft create of a file,
					// and dir OR file by that name exists,
					if ((DFflag == DFE_DIR) || DFE_IS_FILE(ptempDFEntry))
					{
						return AFP_ERR_OBJECT_EXISTS;
					}
					else
					{
						return AFP_ERR_OBJECT_TYPE;
					}
				}
				else if (DFE_IS_FILE(ptempDFEntry))
				{
					// Must be hard create and file by that name exists
					if (ptempDFEntry->dfe_Flags & DFE_FLAGS_OPEN_BITS)
					{
						return AFP_ERR_FILE_BUSY;
					}
					else
					{
						// note we return object_exists instead of no_err
						return AFP_ERR_OBJECT_EXISTS;
					}
				}
				else
				{
					// Attempting hard create of file, but found a directory
					return AFP_ERR_OBJECT_TYPE;
				}
			}
			else
			{
				return AFP_ERR_NONE;
			}
		}

	} while (False);

	// The only way we should have gotten here is if we successfully mapped
	// the path to a DFENTRY for lookup and would return AFP_ERR_NONE
	ASSERT((pMappedPath->mp_pdfe != NULL) && (MapReason == Lookup));

#ifdef GET_CORRECT_OFFSPRING_COUNTS
	if (checkEnumForParent)
	{
		if (!DFE_CHILDREN_ARE_PRESENT(pMappedPath->mp_pdfe->dfe_Parent))
		{
			if (!LockedExclusive &&
				!AfpSwmrUpgradeToExclusive(&pVolDesc->vds_IdDbAccessLock))
			{
				return AFP_ERR_WRITE_LOCK_REQUIRED;
			}
			else
			{
				NTSTATUS status;
				LockedExclusive = True;
				status = AfpCacheDirectoryTree(pVolDesc,
											   pMappedPath->mp_pdfe->dfe_Parent,
											   GETFILES,
											   NULL,
											   NULL);
				if (!NT_SUCCESS(status))
				{
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							("afpMapAfpPathToMappedPath: could not cache dir tree for %Z (0x%lx)\n",
							 &(pMappedPath->mp_pdfe->dfe_Parent->dfe_UnicodeName), status) );
					return AFP_ERR_MISC;
				}
			}
		}

	}
#endif

	if (checkEnumForDir)
	{
		if (!DFE_CHILDREN_ARE_PRESENT(pMappedPath->mp_pdfe))
		{
			if (!LockedExclusive &&
				!AfpSwmrUpgradeToExclusive(&pVolDesc->vds_IdDbAccessLock))
			{
				return AFP_ERR_WRITE_LOCK_REQUIRED;
			}
			else
			{
				NTSTATUS status;
				LockedExclusive = True;
				status = AfpCacheDirectoryTree(pVolDesc,
											   pMappedPath->mp_pdfe,
											   GETFILES,
											   NULL,
											   NULL);
				if (!NT_SUCCESS(status))
				{
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							("afpMapAfpPathToMappedPath: could not cache dir tree for %Z (0x%lx)\n",
							 &(pMappedPath->mp_pdfe->dfe_UnicodeName), status) );
					return AFP_ERR_MISC;
				}
			}
		}

	}


	return AFP_ERR_NONE;
}


/***	AfpHostPathFromDFEntry
 *
 *	This routine takes a pointer to a DFEntry and builds the full
 *	host path (in unicode) to that entity by ascending the ID database
 *	tree.
 *
 *	IN	pDFE	--	pointer to DFEntry of which host path is desired
 *	IN	taillen --	number of extra *bytes*, if any, the caller
 *					desires to have allocated for the host path,
 *					including room for any path separators
 *	OUT	ppPath	--	pointer to UNICODE string
 *
 *	The caller must have the DirID/FileID database locked for read
 *	before calling this routine. The caller can supply a buffer which will
 *	be used if sufficient. Caller must free the allocated (if any)
 * 	unicode string buffer.
 *
 *	LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Shared)
 */
AFPSTATUS
AfpHostPathFromDFEntry(
	IN		PDFENTRY		pDFE,
	IN		DWORD			taillen,
	OUT		PUNICODE_STRING	pPath
)
{
	AFPSTATUS		Status = AFP_ERR_NONE;
	DWORD			pathlen = taillen;
	PDFENTRY		*pdfelist = NULL, curpdfe = NULL;
	PDFENTRY		apdfelist[AVERAGE_NODE_DEPTH];
	int				counter;

	PAGED_CODE( );

	pPath->Length = 0;

	do
	{
		if (DFE_IS_FILE(pDFE))
		{
			counter = pDFE->dfe_Parent->dfe_DirDepth;
		}
		else // its a DIRECTORY entry
		{
			ASSERT(DFE_IS_DIRECTORY(pDFE));
			if (DFE_IS_ROOT(pDFE))
			{
				if ((pathlen > 0) && (pPath->MaximumLength < pathlen))
				{
					if ((pPath->Buffer = (PWCHAR)AfpAllocNonPagedMemory(pathlen)) == NULL)
					{
						Status = AFP_ERR_MISC;
						break;
					}
					pPath->MaximumLength = (USHORT)pathlen;
				}
				break;				// We are done
			}

			if (DFE_IS_PARENT_OF_ROOT(pDFE))
			{
				Status = AFP_ERR_OBJECT_NOT_FOUND;
				break;
			}

			ASSERT(pDFE->dfe_DirDepth >= 1);
			counter = pDFE->dfe_DirDepth - 1;
		}

		if (counter)
		{
			// if node is within average depth, use the array on the stack,
			// otherwise, allocate an array
			if (counter <= AVERAGE_NODE_DEPTH)
			{
				pdfelist = apdfelist;
			}
			else
			{
				pdfelist = (PDFENTRY *)AfpAllocNonPagedMemory(counter*sizeof(PDFENTRY));
				if (pdfelist == NULL)
				{
					Status = AFP_ERR_MISC;
					break;
				}
			}
			pathlen += counter * sizeof(WCHAR); // room for path separators
		}

		curpdfe = pDFE;
		pathlen += curpdfe->dfe_UnicodeName.Length;

		// walk up the tree till you find the root, collecting string lengths
		// and PDFENTRY values as you go...
		while (counter--)
		{
			pdfelist[counter] = curpdfe;
			curpdfe = curpdfe->dfe_Parent;
			pathlen += curpdfe->dfe_UnicodeName.Length;
		}

		// we are in the root, start building up the host path buffer
		if (pathlen > pPath->MaximumLength)
		{
			pPath->Buffer = (PWCHAR)AfpAllocNonPagedMemory(pathlen);
			if (pPath->Buffer == NULL)
			{
				Status = AFP_ERR_MISC;
				break;
			}
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
					("AfpHostPathFromDFEntry: Allocated path buffer %lx\n",
					pPath->Buffer));
			pPath->MaximumLength = (USHORT)pathlen;
		}

		counter = 0;
		do
		{
			RtlAppendUnicodeStringToString(pPath, &curpdfe->dfe_UnicodeName);
			if (curpdfe != pDFE)
			{	// add a path separator
				pPath->Buffer[pPath->Length / sizeof(WCHAR)] = L'\\';
				pPath->Length += sizeof(WCHAR);
				curpdfe = pdfelist[counter++];
				continue;
			}
			break;
		} while (True);

		if (pdfelist && (pdfelist != apdfelist))
			AfpFreeMemory(pdfelist);
	} while (False);

	return Status;
}



/***	AfpCheckParentPermissions
 *
 *	Check if this user has the necessary SeeFiles or SeeFolders permissions
 *	to the parent directory of a file or dir we have just pathmapped.
 *
 *	LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Exclusive or Shared)
 */
AFPSTATUS
AfpCheckParentPermissions(
	IN	PCONNDESC			pConnDesc,
	IN	DWORD				ParentDirId,
	IN	PUNICODE_STRING		pParentPath,	// path of dir to check
	IN	DWORD				RequiredPerms,	// seefiles,seefolders,makechanges mask
	OUT	PFILESYSHANDLE		pHandle OPTIONAL, // return open parent handle?
	OUT	PBYTE				pUserRights OPTIONAL // return user rights?
)
{
	NTSTATUS		Status = AFP_ERR_NONE;
	FILEDIRPARM		FDParm;
	PATHMAPENTITY	PME;
	PVOLDESC		pVolDesc = pConnDesc->cds_pVolDesc;
	PDFENTRY		pDfEntry;

	PAGED_CODE( );

	ASSERT(IS_VOLUME_NTFS(pVolDesc) && (ParentDirId != AFP_ID_PARENT_OF_ROOT));
	ASSERT(AfpSwmrLockedExclusive(&pVolDesc->vds_IdDbAccessLock) ||
		   AfpSwmrLockedShared(&pVolDesc->vds_IdDbAccessLock));

	do
	{
		PME.pme_Handle.fsh_FileHandle = NULL;
		if (ARGUMENT_PRESENT(pHandle))
		{
			pHandle->fsh_FileHandle = NULL;
		}
		ASSERT(ARGUMENT_PRESENT(pParentPath));
		AfpInitializePME(&PME, pParentPath->MaximumLength, pParentPath->Buffer);
		PME.pme_FullPath.Length = pParentPath->Length;

		if ((pDfEntry = AfpFindDfEntryById(pVolDesc,
											ParentDirId,
											DFE_DIR)) == NULL)
		{
			Status = AFP_ERR_OBJECT_NOT_FOUND;
			break;
		}

		ASSERT(DFE_IS_DIRECTORY(pDfEntry));
		AfpInitializeFDParms(&FDParm);

		Status = afpGetMappedForLookupFDInfo(pConnDesc,
											 pDfEntry,
											 DIR_BITMAP_ACCESSRIGHTS |
												FD_INTERNAL_BITMAP_OPENACCESS_READCTRL,
											 &PME,
											 &FDParm);

		if (!NT_SUCCESS(Status))
		{
			if (PME.pme_Handle.fsh_FileHandle != NULL)
			{
				AfpIoClose(&PME.pme_Handle);
			}
			break;
		}

		if ((FDParm._fdp_UserRights & RequiredPerms) != RequiredPerms)
		{
			Status = AFP_ERR_ACCESS_DENIED;
		}

		if (ARGUMENT_PRESENT(pHandle) && NT_SUCCESS(Status))
		{
			*pHandle = PME.pme_Handle;
		}
		else
		{
			AfpIoClose(&PME.pme_Handle);
		}

		if (ARGUMENT_PRESENT(pUserRights))
		{
			*pUserRights = FDParm._fdp_UserRights;
		}

	} while (False);

	return Status;
}

/***	afpOpenUserHandle
 *
 * Open a handle to data or resource stream of an entity in the user's
 * context.  Only called for NTFS volumes.
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Shared)
 */
AFPSTATUS
afpOpenUserHandle(
	IN	PCONNDESC			pConnDesc,
	IN	PDFENTRY			pDfEntry,
	IN	PUNICODE_STRING		pPath		OPTIONAL,	// path of file/dir to open
	IN	DWORD				Bitmap,					// to extract the Open access mode
	OUT	PFILESYSHANDLE		pfshData				// Handle of data stream of object
)
{
	PVOLDESC		pVolDesc = pConnDesc->cds_pVolDesc;
	NTSTATUS		Status;
	DWORD			OpenAccess;
	DWORD			DenyMode;
	BOOLEAN			isdir, CheckAccess = False, Revert = False;
	WCHAR			HostPathBuf[BIG_PATH_LEN];
	UNICODE_STRING	uHostPath;

	PAGED_CODE( );

	pfshData->fsh_FileHandle = NULL;

	isdir = (DFE_IS_DIRECTORY(pDfEntry)) ? True : False;
	OpenAccess = AfpMapFDBitmapOpenAccess(Bitmap, isdir);

	// Extract the index into the AfpDenyModes array from Bitmap
	DenyMode = AfpDenyModes[(Bitmap & FD_INTERNAL_BITMAP_DENYMODE_ALL) >>
								FD_INTERNAL_BITMAP_DENYMODE_SHIFT];

	do
	{
		if (ARGUMENT_PRESENT(pPath))
		{
			uHostPath = *pPath;
		}
		else
		{
			AfpSetEmptyUnicodeString(&uHostPath,
									 sizeof(HostPathBuf),
									 HostPathBuf);
			ASSERT ((Bitmap & FD_INTERNAL_BITMAP_OPENFORK_RESC) == 0);
			if (!NT_SUCCESS(AfpHostPathFromDFEntry(pDfEntry,
												   0,
												   &uHostPath)))
			{
				Status = AFP_ERR_MISC;
				break;
			}
		}

		CheckAccess = False;
		Revert = False;
		// Don't impersonate or check access if this is ADMIN calling
		// or if volume is CDFS. If this handle will be used for setting
		// permissions, impersonate the user token instead. The caller
		// should have determined by now that this chappie has access
		// to change permissions.
		if (Bitmap & FD_INTERNAL_BITMAP_OPENACCESS_RWCTRL)
		{
			Revert = True;
			AfpImpersonateClient(NULL);
		}

		else if (!(Bitmap & FD_INTERNAL_BITMAP_SKIP_IMPERSONATION) &&
				 (pConnDesc->cds_pSda->sda_ClientType != SDA_CLIENT_ADMIN) &&
				 IS_VOLUME_NTFS(pVolDesc))
		{
			CheckAccess = True;
			Revert = True;
			AfpImpersonateClient(pConnDesc->cds_pSda);
		}

		DBGPRINT(DBG_COMP_AFPINFO, DBG_LEVEL_INFO,
				("afpOpenUserHandle: OpenMode %lx, DenyMode %lx\n",
				OpenAccess, DenyMode));

		if (Bitmap & FD_INTERNAL_BITMAP_OPENFORK_RESC)
		{
			DWORD	crinfo;	// was the Resource fork opened or created?

			ASSERT(IS_VOLUME_NTFS(pVolDesc));
			ASSERT((uHostPath.MaximumLength - uHostPath.Length) >= AfpResourceStream.Length);
			RtlCopyMemory((PBYTE)(uHostPath.Buffer) + uHostPath.Length,
						  AfpResourceStream.Buffer,
						  AfpResourceStream.Length);
			uHostPath.Length += AfpResourceStream.Length;
			Status = AfpIoCreate(&pVolDesc->vds_hRootDir,
								 AFP_STREAM_DATA,
								 &uHostPath,
								 OpenAccess,
								 DenyMode,
								 FILEIO_OPEN_FILE,
								 FILEIO_CREATE_INTERNAL,
								 FILE_ATTRIBUTE_NORMAL,
								 True,
								 NULL,
								 pfshData,
								 &crinfo,
								 NULL,
								 NULL,
								 NULL);
		}
		else
		{
			Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
								AFP_STREAM_DATA,
								isdir ?
									FILEIO_OPEN_DIR : FILEIO_OPEN_FILE,
								&uHostPath,
								OpenAccess,
								DenyMode,
								CheckAccess,
								pfshData);
		}

		if (Revert)
			AfpRevertBack();

		if (!ARGUMENT_PRESENT(pPath))
		{
			if ((uHostPath.Buffer != NULL) && (uHostPath.Buffer != HostPathBuf))
				AfpFreeMemory(uHostPath.Buffer);
		}

		if (!NT_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpOpenUserHandle: NtOpenFile/NtCreateFile (Open %lx, Deny %lx) %lx\n",
					OpenAccess, DenyMode, Status));
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
			break;
		}

	} while (False);

	if (!NT_SUCCESS(Status) && (pfshData->fsh_FileHandle != NULL))
	{
		AfpIoClose(pfshData);
	}

	return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\scavengr.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	scavengr.c

Abstract:

	This file implements the scavenger queue management interface.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	_SCAVENGER_LOCALS
#define	FILENUM	FILE_SCAVENGR

#include <afp.h>
#include <scavengr.h>
#include <client.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfpScavengerInit)
#pragma alloc_text( PAGE, AfpScavengerDeInit)
#endif

/***	AfpScavengerInit
 *
 *	Initialize the scavenger system. This consists of a queue protected by a
 *	spin lock and timer coupled to a DPC. The scavenger accepts requests to
 *	schedule a worker after N units of time.
 */
NTSTATUS
AfpScavengerInit(
	VOID
)
{
	BOOLEAN			TimerStarted;
	LARGE_INTEGER	TimerValue;

	KeInitializeTimer(&afpScavengerTimer);
	INITIALIZE_SPIN_LOCK(&afpScavengerLock);
	KeInitializeDpc(&afpScavengerDpc, afpScavengerDpcRoutine, NULL);
	TimerValue.QuadPart = AFP_SCAVENGER_TIMER_TICK;
	TimerStarted = KeSetTimer(&afpScavengerTimer,
							  TimerValue,
							  &afpScavengerDpc);
	ASSERT(!TimerStarted);

	return STATUS_SUCCESS;
}


/***	AfpScavengerDeInit
 *
 *	De-Initialize the scavenger system. Just cancel the timer.
 */
VOID
AfpScavengerDeInit(
	VOID
)
{
	KeCancelTimer(&afpScavengerTimer);
}


/***	AfpScavengerEnqueue
 *
 *	Here is a thesis on the code that follows.
 *
 *	The scavenger events are maintained as a list which the scavenger thread
 *	looks at every timer tick. The list is maintained in such a way that only
 *	the head of the list needs to be updated every tick i.e. the entire list
 *	is never scanned. The way this is achieved is by keeping delta times
 *	relative to the previous entry.
 *
 *	Every timer tick, the relative time at the head of the list is decremented.
 *	When that goes to ZERO, the head of the list is unlinked and dispatched.
 *
 *	To give an example, we have the following events queued at time slots
 *	X			Schedule A after 10 ticks.
 *	X+3			Schedule B after 5  ticks.
 *	X+5			Schedule C after 4  ticks.
 *	X+8			Schedule D after 6  ticks.
 *
 *	So A will schedule at X+10, B at X+8 (X+3+5), C at X+9 (X+5+4) and
 *	D at X+14 (X+8+6).
 *
 *	The above example covers all the situations.
 *
 *	- NULL List.
 *	- Inserting at head of list.
 *	- Inserting in the middle of the list.
 *	- Appending to the list tail.
 *
 *	The list will look as follows.
 *
 *		    BEFORE                          AFTER
 *		    ------                          -----
 *
 *    X   Head -->|                          Head -> A(10) ->|
 *    A(10)
 *
 *    X+3 Head -> A(7) ->|           Head -> B(5) -> A(2) ->|
 *    B(5)
 *
 *    X+5 Head -> B(3) -> A(2) ->|   Head -> B(3) -> C(1) -> A(1) ->|
 *    C(4)
 *
 *    X+8 Head -> C(1) -> A(1) ->|   Head -> C(1) -> A(1) -> D(4) ->|
 *    D(6)
 *
 *	The granularity is one tick.
 *
 *	LOCKS_ASSUMED:	AfpScavengerLock (SPIN)
 */
VOID
afpScavengerEnqueue(
	IN	PSCAVENGERLIST	pListNew
)
{
	PSCAVENGERLIST		pList, *ppList;
	LONG				DeltaTime = pListNew->scvgr_AbsTime;

	// The DeltaTime is adjusted in every pass of the loop to reflect the
	// time after the previous entry that the new entry will schedule.
	for (ppList = &afpScavengerList;
		 (pList = *ppList) != NULL;
		 ppList = &pList->scvgr_Next)
	{
		if (DeltaTime <= pList->scvgr_RelDelta)
		{
			pList->scvgr_RelDelta -= DeltaTime;
			break;
		}
		DeltaTime -= pList->scvgr_RelDelta;
	}

	pListNew->scvgr_RelDelta = DeltaTime;
	pListNew->scvgr_Next = pList;
	*ppList = pListNew;
}


/***	AfpScavengerScheduleEvent
 *
 *	Insert an event in the scavenger event list. If the list is empty, then
 *	fire off a timer. The time is specified in ticks. Each tick is currently
 *	ONE SECOND. It may not be negative.
 *
 *	The granularity is one tick.
 */
NTSTATUS
AfpScavengerScheduleEvent(
	IN	SCAVENGER_ROUTINE	Worker,		// Routine to invoke when time expires
	IN	PVOID				pContext,	// Context to pass to the routine
	IN	LONG				DeltaTime,	// Schedule after this much time
	IN	BOOLEAN				fQueue		// If TRUE, then worker must be queued
)
{
	PSCAVENGERLIST	pList = NULL;
	KIRQL			OldIrql;
	NTSTATUS		Status = STATUS_SUCCESS;

	// Negative DeltaTime is invalid. ZERO is valid which implies immediate action
	ASSERT (DeltaTime >= 0);

	do
	{
		pList = (PSCAVENGERLIST)AfpAllocNonPagedMemory(sizeof(SCAVENGERLIST));
		if (pList == NULL)
		{
		    DBGPRINT(DBG_COMP_SCVGR, DBG_LEVEL_ERR,
			    ("AfpScavengerScheduleEvent: malloc Failed\n"));
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		AfpInitializeWorkItem(&pList->scvgr_WorkItem,
							  afpScavengerWorker,
							  pList);
		pList->scvgr_Worker = Worker;
		pList->scvgr_Context = pContext;
		pList->scvgr_AbsTime = DeltaTime;
		pList->scvgr_fQueue = fQueue;

		if (DeltaTime == 0)
		{
			ASSERT (fQueue);
			AfpQueueWorkItem(&pList->scvgr_WorkItem);
			break;
		}

		if (!afpScavengerStopped)
		{
	        ACQUIRE_SPIN_LOCK(&afpScavengerLock, &OldIrql);

            //
            // due to an assumption made elsewhere, it's necessary to check
            // this again after holding the spinlock!
            //
            if (!afpScavengerStopped)
            {
			    afpScavengerEnqueue(pList);
			    RELEASE_SPIN_LOCK(&afpScavengerLock, OldIrql);
            }
            else
            {
			    DBGPRINT(DBG_COMP_SCVGR, DBG_LEVEL_ERR,
					("AfpScavengerScheduleEvent: Called after Flush !!\n"));

			    RELEASE_SPIN_LOCK(&afpScavengerLock, OldIrql);
		        AfpFreeMemory(pList);
                Status = STATUS_UNSUCCESSFUL;
            }
		}

	} while (False);

	return Status;
}



/***	AfpScavengerKillEvent
 *
 *	Kill an event that was previously scheduled.
 */
BOOLEAN
AfpScavengerKillEvent(
	IN	SCAVENGER_ROUTINE	Worker,		// Routine that was scheduled
	IN	PVOID				pContext	// Context
)
{
	PSCAVENGERLIST	pList, *ppList;
	KIRQL			OldIrql;

	ACQUIRE_SPIN_LOCK(&afpScavengerLock, &OldIrql);

	// The DeltaTime is adjusted in every pass of the loop to reflect the
	// time after the previous entry that the new entry will schedule.
	for (ppList = &afpScavengerList;
		 (pList = *ppList) != NULL;
		 ppList = &pList->scvgr_Next)
	{
		if ((pList->scvgr_Worker == Worker) &&
	        (pList->scvgr_Context == pContext))
		{
			*ppList = pList->scvgr_Next;
			if (pList->scvgr_Next != NULL)
			{
				pList->scvgr_Next->scvgr_RelDelta += pList->scvgr_RelDelta;
			}
			break;
		}
	}

	RELEASE_SPIN_LOCK(&afpScavengerLock, OldIrql);

	if (pList != NULL)
		AfpFreeMemory(pList);

	return (pList != NULL);
}


/***	afpScavengerDpcRoutine
 *
 *	This is called in at DISPATCH_LEVEL when the timer expires. The entry at
 *	the head of the list is decremented and if ZERO unlinked and queued to the
 *	worker. If the list is non-empty, the timer is fired again.
 */
LOCAL VOID
afpScavengerDpcRoutine(
	IN	PKDPC	pKDpc,
	IN	PVOID	pContext,
	IN	PVOID	SystemArgument1,
	IN	PVOID	SystemArgument2
)
{
	PSCAVENGERLIST	pList;
	AFPSTATUS		Status;
	BOOLEAN			TimerStarted;
	LARGE_INTEGER	TimerValue;
#ifdef	PROFILING
	TIME			TimeS, TimeE;
	DWORD			NumDispatched = 0;

	AfpGetPerfCounter(&TimeS);
#endif


    AfpSecondsSinceEpoch++;

	if (afpScavengerStopped)
	{
		DBGPRINT(DBG_COMP_SCVGR, DBG_LEVEL_ERR,
				("afpScavengerDpcRoutine: Entered after flush !!!\n"));
		return;
	}

	if (afpScavengerList != NULL)
	{
		ACQUIRE_SPIN_LOCK_AT_DPC(&afpScavengerLock);

		if (afpScavengerList->scvgr_RelDelta != 0)
			(afpScavengerList->scvgr_RelDelta)--;

		// We should never be here if we have no work to do
		while (afpScavengerList != NULL)
		{
			// Dispatch all entries that are ready to go
			if (afpScavengerList->scvgr_RelDelta == 0)
			{
				pList = afpScavengerList;
				afpScavengerList = pList->scvgr_Next;
				DBGPRINT(DBG_COMP_SCVGR, DBG_LEVEL_INFO,
						("afpScavengerDpcRoutine: Dispatching %lx\n",
						pList->scvgr_WorkItem.wi_Worker));

				// Release spin lock as the caller might call us back
				RELEASE_SPIN_LOCK_FROM_DPC(&afpScavengerLock);

				Status = AFP_ERR_QUEUE;
				if (!pList->scvgr_fQueue)
				{
					Status = (*pList->scvgr_Worker)(pList->scvgr_Context);
#ifdef	PROFILING
					NumDispatched++;
#endif
				}

				ACQUIRE_SPIN_LOCK_AT_DPC(&afpScavengerLock);

				if (Status == AFP_ERR_QUEUE)
				{
					DBGPRINT(DBG_COMP_SCVGR, DBG_LEVEL_INFO,
								("afpScavengerDpcRoutine: Queueing %lx\n",
								pList->scvgr_WorkItem.wi_Worker));
					AfpQueueWorkItem(&pList->scvgr_WorkItem);
				}
				else if (Status == AFP_ERR_REQUEUE)
				{
					afpScavengerEnqueue(pList);
				}
				else AfpFreeMemory(pList);
			}
			else break;
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&afpScavengerLock);
	}

	TimerValue.QuadPart = AFP_SCAVENGER_TIMER_TICK;
	TimerStarted = KeSetTimer(&afpScavengerTimer,
							  TimerValue,
							  &afpScavengerDpc);
	ASSERT(!TimerStarted);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	ACQUIRE_SPIN_LOCK_AT_DPC(&AfpStatisticsLock);
	AfpServerProfile->perf_ScavengerCount += NumDispatched;
	AfpServerProfile->perf_ScavengerTime.QuadPart +=
									(TimeE.QuadPart - TimeS.QuadPart);
	RELEASE_SPIN_LOCK_FROM_DPC(&AfpStatisticsLock);
#endif
}


/***	AfpScavengerFlushAndStop
 *
 *	Force all entries in the scavenger queue to be dispatched immediately. No
 *	more queue'ing of scavenger routines is permitted after this. The scavenger
 *	essentially shuts down. Callable only in the worker context.
 */
VOID
AfpScavengerFlushAndStop(
	VOID
)
{
	PSCAVENGERLIST	pList;
	KIRQL			OldIrql;

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	DBGPRINT(DBG_COMP_SCVGR, DBG_LEVEL_INFO,
						("afpScavengerFlushAndStop: Entered\n"));

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	ACQUIRE_SPIN_LOCK(&afpScavengerLock, &OldIrql);

	afpScavengerStopped = True;

	KeCancelTimer(&afpScavengerTimer);

	if (afpScavengerList != NULL)
	{
		// Dispatch all entries right away
		while (afpScavengerList != NULL)
		{
			AFPSTATUS	Status;

			pList = afpScavengerList;
			afpScavengerList = pList->scvgr_Next;

			// Call the worker with spin-lock held since they expect to be
			// called at DPC. We are safe since if the worker tries to
			// call AfpScavengerScheduleEvent(), we'll not try to re-acquire
			// the lock as afpScavengerStopped is True.
			DBGPRINT(DBG_COMP_SCVGR, DBG_LEVEL_INFO,
						("afpScavengerFlushAndStop: Dispatching %lx\n",
						pList->scvgr_WorkItem.wi_Worker));

			if (!(pList->scvgr_fQueue))
				Status = (*pList->scvgr_Worker)(pList->scvgr_Context);

			if (pList->scvgr_fQueue ||
				(Status == AFP_ERR_QUEUE))
			{
				// Well do it the hard way, if the worker insists on working
				// at non DISPACTH level.
				RELEASE_SPIN_LOCK(&afpScavengerLock, OldIrql);
				(*pList->scvgr_Worker)(pList->scvgr_Context);
				ACQUIRE_SPIN_LOCK(&afpScavengerLock, &OldIrql);
			}
			AfpFreeMemory(pList);
		}
	}
	RELEASE_SPIN_LOCK(&afpScavengerLock, OldIrql);
}


/***	AfpScavengerWorker
 *
 *	This gets invoked when the scavenger Dpc queues up the routine.
 */
LOCAL VOID FASTCALL
afpScavengerWorker(
	IN	PSCAVENGERLIST	pList
)
{
	AFPSTATUS		Status;
	KIRQL			OldIrql;
#ifdef	PROFILING
	TIME			TimeS, TimeE;

	AfpGetPerfCounter(&TimeS);
#endif

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	// Call the worker routine
	Status = (*pList->scvgr_Worker)(pList->scvgr_Context);

	ASSERT (Status != AFP_ERR_QUEUE);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);
	AfpServerProfile->perf_ScavengerCount++;
	AfpServerProfile->perf_ScavengerTime.QuadPart +=
									(TimeE.QuadPart - TimeS.QuadPart);
	RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);
#endif

	if (Status == AFP_ERR_REQUEUE)
	{
		ACQUIRE_SPIN_LOCK(&afpScavengerLock, &OldIrql);
		afpScavengerEnqueue(pList);
		RELEASE_SPIN_LOCK(&afpScavengerLock, OldIrql);
	}
	else
	{
		ASSERT (NT_SUCCESS(Status));
		AfpFreeMemory(pList);
	}
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\pathmap.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	pathmap.c

Abstract:

	This module contains definitions relating to manipulation of AFP paths.

Author:

	Sue Adams	(microsoft!suea)


Revision History:
	04 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_PATHMAP_
#define _PATHMAP_

#define UNICODE_HOST_PATHSEPZ	L"\\"	// a null terminated wide string
#define ANSI_HOST_PATHSEP		'\\'
#define AFP_PATHSEP				0
#define UNICODE_AFP_PATHSEP		UNICODE_NULL
#define AVERAGE_NODE_DEPTH		16

// describes the entity found by pathmapping routines
typedef struct _PathMapEntity
{
	// Handle is returned for LOOKUPS ONLY!
	FILESYSHANDLE		pme_Handle;	// Handle to DATA Stream, returned for lookups

	// Full, UTail and ParentPath are returned whenever the following bitmap
	//
	//		FD_INTERNAL_BITMAP_RETURN_PMEPATHS
	// is specified in the AfpMapAfpPath call. These are mostly for Create and
	// for lookups ONLY for apis that MAKE DISK CHANGES which will produce a
	// change notification to come in. Caller must free the FullPath.Buffer.
	// All other strings point into this buffer and do not need to be freed.
	// Also used by Open to get the path of the file being opened.
	UNICODE_STRING	pme_FullPath;	// Fully qualified relative to volume root
	UNICODE_STRING	pme_UTail;		// Points to last component of Full
	UNICODE_STRING	pme_ParentPath;	// Points to Full w/ length of UTail deleted

	// pme_pDfeParent is used for Create and points to the parent directory.
	// pme_pDfEntry is used for lookup (mainly for delete case) and points to the entity.
	union
	{
		PDFENTRY	pme_pDfeParent; // DFE of parent dir in which to create
		PDFENTRY	pme_pDfEntry;	// DFE of of the entity for Lookup
	};
} PATHMAPENTITY, *PPATHMAPENTITY;

#define	AfpInitializePME(pPME, FullPathLen, FullPathBuffer)			\
				(pPME)->pme_FullPath.Buffer = FullPathBuffer;		\
                (pPME)->pme_FullPath.MaximumLength = FullPathLen;	\
                (pPME)->pme_Handle.fsh_FileHandle = NULL

//
// Values for path mapping DFFlag parameter;
// DFE_DIR/FILE/ANY tell the pathmapping code what type of entity we are
// trying to lookup/create
//
#define	DFE_DIR					0x0001	// Specified if the object should be a dir
#define	DFE_FILE				0x0002	// Specified if the object should be a file
#define	DFE_ANY					0x0004	// Specified if the object can be either

//
// Values for reason of pathmap: Lookup, SoftCreate or HardCreate
//
typedef enum _PATHMAP_TYPE
{
	Lookup,
	SoftCreate,
	HardCreate,
	LookupForEnumerate		// Same as Lookup but file children will be cached
							// in during pathmap of the directory itself.
} PATHMAP_TYPE;

extern
AFPSTATUS
AfpMapAfpPath(
	IN		PCONNDESC			pConnDesc,
	IN		DWORD				DirId,
	IN		PANSI_STRING		Path,
	IN		BYTE				PathType,			
	IN		PATHMAP_TYPE		MapReason,
	IN		DWORD				DFFlag,
	IN		DWORD				Bitmap,
	OUT		PPATHMAPENTITY		pPME,
	OUT		PFILEDIRPARM		pFDParm OPTIONAL	// for lookups only
);

extern
AFPSTATUS
AfpMapAfpPathForLookup(
	IN		PCONNDESC			pConnDesc,
	IN		DWORD				DirId,
	IN		PANSI_STRING		Path,
	IN		BYTE				PathType,	
	IN		DWORD				DFFlag,
	IN		DWORD				Bitmap,
	OUT		PPATHMAPENTITY		pPME OPTIONAL,		
	OUT		PFILEDIRPARM		pFDParm OPTIONAL
);

extern
AFPSTATUS
AfpMapAfpIdForLookup(
	IN		PCONNDESC			pConnDesc,
	IN		DWORD				AfpId,
	IN		DWORD				DFFlag,
	IN		DWORD				Bitmap,
	OUT		PPATHMAPENTITY		pPME OPTIONAL,	
	OUT		PFILEDIRPARM		pFDParm OPTIONAL
);

extern
AFPSTATUS
AfpHostPathFromDFEntry(
	IN		PDFENTRY			pDFE,
	IN		DWORD				taillen,
	OUT		PUNICODE_STRING		pPath

);


extern
AFPSTATUS
AfpCheckParentPermissions(
	IN	PCONNDESC				pConnDesc,
	IN	DWORD					ParentDirId,
	IN	PUNICODE_STRING			pParentPath,
	IN	DWORD					RequiredPerms,
	OUT	PFILESYSHANDLE			pHandle OPTIONAL,
	OUT	PBYTE					pUserRights OPTIONAL
);

#ifdef	_PATHMAP_LOCALS

// An AFP path to an entity consists of a Dirid and pathname.  A MAPPEDPATH
// structure resolves the AFP path into a PDFENTRY for the entity on lookups,
// or to a PDFENTRY of the parent directory plus the UNICODE file/dir name
// of the entity on creates.
typedef struct _MappedPath
{
	PDFENTRY		mp_pdfe;
	UNICODE_STRING	mp_Tail;						// valid for Create only
	WCHAR			mp_Tailbuf[AFP_FILENAME_LEN+1]; // for mp_tail.Buffer
// mp_Tail is also used as an interim buffer during pathmap for looking up
// by name in the idindex database.
} MAPPEDPATH, *PMAPPEDPATH;

/* private function prototypes */

LOCAL
AFPSTATUS
afpGetMappedForLookupFDInfo(
	IN	PCONNDESC				pConnDesc,
	IN	PDFENTRY				pDfEntry,
	IN	DWORD					Bitmap,
	OUT	PPATHMAPENTITY			pPME OPTIONAL,
	OUT	PFILEDIRPARM			pFDParm	OPTIONAL
);

/***	afpGetNextComponent
 *
 *	Takes an AFP path with leading and trailing nulls removed,
 *	and parses out the next path component.
 *
 *	pComponent must point to a buffer of at least AFP_LONGNAME_LEN+1
 *	characters in length if pathtype is AFP_LONGNAME or AFP_SHORTNAME_LEN+1
 *	if pathtype is AFP_SHORTNAME.
 *
 *	Returns the number of bytes (Mac ANSI characters) parsed off of
 *	pPath, else -1 for error.
LOCAL VOID
afpGetNextComponent(
	IN	PCHAR					pPath,
	IN	int						Length,
	IN	BYTE					PathType,
	OUT	PCHAR					Component,
	OUT	PINT					pIndex
	)
 */
#define	afpGetNextComponent(_pPath, _Length, _PathType, _Component, _pIndex)	\
	do																			\
	{                                                                           \
		int			Length = _Length;                                           \
		PCHAR		pPath = _pPath;                                             \
		int			maxlen;                                                     \
		CHAR		ch;                                                         \
	                                                                            \
		maxlen = (_PathType == AFP_LONGNAME) ?                                  \
						AFP_LONGNAME_LEN :                                      \
						AFP_SHORTNAME_LEN;                                      \
		*(_pIndex) = 0;                                                         \
                                                                                \
		while ((Length > 0) && ((ch = *pPath) != '\0'))                         \
		{                                                                       \
			if ((*(_pIndex) == maxlen) || (ch == ':'))                          \
			{                                                                   \
	            /* component too long or invalid char */                        \
				*(_pIndex) = -1;                                                \
				break;                                                          \
			}                                                                   \
	                                                                            \
			(_Component)[(*(_pIndex))++] = ch;                                  \
	                                                                            \
			pPath++;                                                            \
			Length--;                                                           \
		}                                                                       \
                                                                                \
		if (*(_pIndex) == -1)                                                   \
			break;                                                              \
	                                                                            \
		/* null terminate the component */                                      \
		(_Component)[*(_pIndex)] = (CHAR)0;                                     \
	                                                                            \
		if ((PathType == AFP_SHORTNAME) && ((_Component)[0] != AFP_PATHSEP))    \
		{                                                                       \
			ANSI_STRING	as;                                                     \
	                                                                            \
			AfpInitUnicodeStringWithNonNullTerm(&as, *(_pIndex), _Component);   \
			if (!AfpIsLegalShortname(&as))                                      \
			{                                                                   \
				*(_pIndex) = -1;                                                \
				break;                                                          \
			}                                                                   \
		}                                                                       \
	                                                                            \
		/* if we stopped due to null, move past it */                           \
		if (Length > 0)                                                         \
		{                                                                       \
			(*(_pIndex))++;                                                     \
		}																		\
	} while (FALSE);


LOCAL
AFPSTATUS
afpMapAfpPathToMappedPath(
	IN		PVOLDESC			pVolDesc,
	IN		DWORD				DirId,
	IN		PANSI_STRING		Path,
	IN		BYTE				PathType,
	IN		PATHMAP_TYPE		MapReason,
	IN 		DWORD				DFflag,
	IN		BOOLEAN				LockedForWrite,
	OUT		PMAPPEDPATH			pMappedPath

);

LOCAL
AFPSTATUS
afpOpenUserHandle(
	IN	PCONNDESC				pConnDesc,
	IN	struct _DirFileEntry *	pDfEntry,
	IN	PUNICODE_STRING			pPath		OPTIONAL,
	IN	DWORD					Bitmap,
	OUT	PFILESYSHANDLE			pfshData	 // Handle of data stream of object
);

#endif	// _PATHMAP_LOCALS

#endif	// _PATHMAP_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\scavengr.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	scavengr.h

Abstract:

	This file defines the scavenger thread interface.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_SCAVENGER_
#define	_SCAVENGER_

typedef	AFPSTATUS	(FASTCALL *SCAVENGER_ROUTINE)(IN PVOID Parameter);

extern
NTSTATUS
AfpScavengerInit(
	VOID
);

extern
VOID
AfpScavengerDeInit(
	VOID
);

extern
NTSTATUS
AfpScavengerScheduleEvent(
	IN	SCAVENGER_ROUTINE	Worker,		// Routine to invoke when time expires
	IN	PVOID				pContext,	// Context to pass to the routine
	IN	LONG				DeltaTime,	// Schedule after this much time
	IN	BOOLEAN				fQueue		// If TRUE, then worker must be queued
);

extern
BOOLEAN
AfpScavengerKillEvent(
	IN	SCAVENGER_ROUTINE	Worker,		// Routine that was scheduled
	IN	PVOID				pContext	// Context
);

extern
VOID
AfpScavengerFlushAndStop(
	VOID
);

#ifdef	_SCAVENGER_LOCALS

// Keep this at a ONE second level. Most clients should be using close to
// 10 ticks or so.
#define	AFP_SCAVENGER_TIMER_TICK	-1*NUM_100ns_PER_SECOND

typedef	struct _ScavengerList
{
	struct _ScavengerList *	scvgr_Next;		// Link to next
	LONG					scvgr_AbsTime;	// Absolute time
	LONG					scvgr_RelDelta;	// Relative to the previous entry
	BOOLEAN					scvgr_fQueue;	// If TRUE, should always be queued
	SCAVENGER_ROUTINE		scvgr_Worker;	// Real Worker
	PVOID					scvgr_Context;	// Real context
	WORK_ITEM				scvgr_WorkItem;	// Used for queueing to worker thread
} SCAVENGERLIST, *PSCAVENGERLIST;

LOCAL	KTIMER				afpScavengerTimer = { 0 };
LOCAL	KDPC				afpScavengerDpc = { 0 };
LOCAL	BOOLEAN				afpScavengerStopped = False;
LOCAL	PSCAVENGERLIST		afpScavengerList = NULL;
LOCAL	AFP_SPIN_LOCK			afpScavengerLock = { 0 };

LOCAL VOID
afpScavengerDpcRoutine(
	IN	PKDPC				pKDpc,
	IN	PVOID				pContext,
	IN	PVOID				SystemArgument1,
	IN	PVOID				SystemArgument2
);

LOCAL VOID FASTCALL
afpScavengerWorker(
	IN	PSCAVENGERLIST		pList
);

#endif	// _SCAVENGER_LOCALS

#endif	// _SCAVENGER_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\nwtrash.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	nwtrash.c

Abstract:

	This module contains the routines for performing Network Trash Folder
	operations.

Author:

	Sue Adams (microsoft!suea)


Revision History:
	06 Aug 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	NWTRASH_LOCALS
#define	FILENUM	FILE_NWTRASH

#include <afp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <nwtrash.h>
#include <afpinfo.h>
#include <access.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpCreateNetworkTrash)
#pragma alloc_text( PAGE, AfpDeleteNetworkTrash)
#pragma alloc_text( PAGE, afpCleanNetworkTrash)
#pragma alloc_text( PAGE, AfpWalkDirectoryTree)
#pragma alloc_text( PAGE, afpPushDirNode)
#pragma alloc_text( PAGE, afpPopDirNode)
#pragma alloc_text( PAGE, AfpGetNextDirectoryInfo)
#pragma alloc_text( PAGE, afpNwtDeleteFileEntity)
#endif

/***	AfpCreateNetworkTrash
 *
 *	Create the network trash folder for a newly added volume.
 *  Make sure it is hidden and make sure the streams are intact.
 *  This routine may only be called for NTFS volumes.  Note that even
 *  ReadOnly NTFS volumes will have a trash created.  This is because
 *  if someone is going to toggle the volume ReadOnly bit, we don't need
 *  to worry about creating/deleting the trash on the fly.
 *  We keep an open handle to the network trash stored in the volume
 *  descriptor so that nobody can come in behind our backs and delete
 *  it.
 */
NTSTATUS
AfpCreateNetworkTrash(
	IN	PVOLDESC	pVolDesc
)
{
	FILESYSHANDLE	hNWT;
	PDFENTRY		pDfEntry;
	NTSTATUS 		Status;
	ULONG	 		info, Attr;
	AFPINFO			afpInfo;
	BOOLEAN			ReleaseSwmr = False;
	PISECURITY_DESCRIPTOR pSecDesc;
	FILEDIRPARM		fdparm;		// This is used to set the hidden attribute
								// of the FinderInfo for network trash folder

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_IDINDEX,DBG_LEVEL_INFO,("\tCreating Network Trash...\n"));
	ASSERT(pVolDesc->vds_Flags & VOLUME_NTFS);

	hNWT.fsh_FileHandle = NULL;

	Status = AfpMakeSecurityDescriptorForUser(&AfpSidWorld, &AfpSidWorld, &pSecDesc);

	if (!NT_SUCCESS(Status))
		return Status;

	ASSERT (pSecDesc != NULL);
	ASSERT (pSecDesc->Dacl != NULL);

	do
	{
		// NOTE: NTFS allows me to open a Readonly directory for
		// delete access.
		Status = AfpIoCreate(&pVolDesc->vds_hRootDir,
							 AFP_STREAM_DATA,
							 &AfpNetworkTrashNameU,
							 AFP_NWT_ACCESS | AFP_OWNER_ACCESS,
							 AFP_NWT_SHAREMODE,
							 AFP_NWT_OPTIONS,
							 AFP_NWT_DISPOSITION,
							 AFP_NWT_ATTRIBS, // makes it hidden
							 False,
							 pSecDesc,
							 &hNWT,
							 &info,
							 NULL,
							 NULL,
							 NULL);

		// Free the memory allocated for the security descriptor
		AfpFreeMemory(pSecDesc->Dacl);
		AfpFreeMemory(pSecDesc);

		if (!NT_SUCCESS(Status))
			break;

		ASSERT(info == FILE_CREATED);

		// Add the AfpInfo stream
		Status = AfpSlapOnAfpInfoStream(NULL,
										NULL,
										&hNWT,
										NULL,
										AFP_ID_NETWORK_TRASH,
										True,
										NULL,
										&afpInfo);
		if (!NT_SUCCESS(Status))
			break;

		// it does not exist in the ID index database, add it
		AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
		ReleaseSwmr = True;

		ASSERT(pVolDesc->vds_pDfeRoot != NULL);

		pDfEntry = AfpAddDfEntry(pVolDesc,
								 pVolDesc->vds_pDfeRoot,
								 &AfpNetworkTrashNameU,
								 True,
								 AFP_ID_NETWORK_TRASH);

		if (pDfEntry == NULL)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		// NOTE: pDfEntry now points to the "Network Trash Folder"

		// Get directory info to cache
		Status = AfpIoQueryTimesnAttr(&hNWT,
									  &pDfEntry->dfe_CreateTime,
									  &pDfEntry->dfe_LastModTime,
									  &Attr);
	
		ASSERT(NT_SUCCESS(Status));

		ASSERT(Attr & FILE_ATTRIBUTE_HIDDEN);
		pDfEntry->dfe_NtAttr = (USHORT)Attr & FILE_ATTRIBUTE_VALID_FLAGS;
		pDfEntry->dfe_AfpAttr = afpInfo.afpi_Attributes;
		pDfEntry->dfe_FinderInfo = afpInfo.afpi_FinderInfo;
		pDfEntry->dfe_BackupTime = afpInfo.afpi_BackupTime;
		DFE_OWNER_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);
		DFE_GROUP_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);
		DFE_WORLD_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);

		// ok, we know it now exists both on disk and in the database
		if (NT_SUCCESS(Status))
		{
			RtlZeroMemory(&fdparm, sizeof(fdparm));
			fdparm._fdp_Flags = DFE_FLAGS_DIR;
			fdparm._fdp_AfpId = AFP_ID_NETWORK_TRASH;
			fdparm._fdp_FinderInfo = afpInfo.afpi_FinderInfo;

			// We must set the invisible flag in the finder info, because
			// System 6 seems to ignore the hidden attribute.
			pDfEntry->dfe_FinderInfo.fd_Attr1 |= FINDER_FLAG_INVISIBLE;
			fdparm._fdp_FinderInfo.fd_Attr1 |= FINDER_FLAG_INVISIBLE;
			Status = AfpSetAfpInfo(&hNWT,
								   FD_BITMAP_FINDERINFO,
								   &fdparm,
								   NULL,
								   NULL);
		}
	} while (False);

	if (hNWT.fsh_FileHandle != NULL)
		AfpIoClose(&hNWT);

	if (!NT_SUCCESS(Status))
	{
		AFPLOG_ERROR(AFPSRVMSG_CREATE_NWTRASH,
					 Status,
					 NULL,
					 0,
					 &pVolDesc->vds_Name);
	}
	else
	{
		// Open a Network Trash handle to keep around so that no one can
		// come in and delete the Network Trash dir out from under us
		Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
						   AFP_STREAM_DATA,
						   AFP_NWT_OPTIONS,
						   &AfpNetworkTrashNameU,
						   FILEIO_ACCESS_READ,
						   AFP_NWT_SHAREMODE,
						   False,
						   &pVolDesc->vds_hNWT);
	
		if (!NT_SUCCESS(Status))
		{
			AFPLOG_ERROR(AFPSRVMSG_CREATE_NWTRASH, Status, NULL, 0,
						 &pVolDesc->vds_Name);
		}
	}

	if (ReleaseSwmr)
	{
		AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
	}

	return Status;
}

/*** AfpDeleteNetworkTrash
 *
 *	Delete the network trash folder from disk when a volume is being added,
 *  deleted or stopped.
 *
 * 	NOTE: this must be called in the server's context to ensure that we have
 * 	LOCAL_SYSTEM access to all the trash directories created by users
 */
NTSTATUS
AfpDeleteNetworkTrash(
	IN	PVOLDESC	pVolDesc,
	IN	BOOLEAN		VolumeStart 	// Is volume starting or is it stopping
)
{
	FILESYSHANDLE	hNWT;
	NTSTATUS 		Status;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
										("\tDeleting Network Trash...\n") );
	ASSERT(pVolDesc->vds_Flags & VOLUME_NTFS);

	if (!VolumeStart)
	{
		// Close the handle to Network Trash that we keep open so PC users can't
		// delete the directory out from under us.
		if (pVolDesc->vds_hNWT.fsh_FileHandle != NULL)
		{
			AfpIoClose(&pVolDesc->vds_hNWT);
			pVolDesc->vds_hNWT.fsh_FileHandle = NULL;
		}
	}

	do
	{
		AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);

		// Open for delete access
		Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
						   AFP_STREAM_DATA,
						   AFP_NWT_OPTIONS,
						   &AfpNetworkTrashNameU,
						   AFP_NWT_ACCESS,
						   AFP_NWT_SHAREMODE,
						   False,
						   &hNWT);
		// there is no network trash folder to delete
		if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
		{
			Status = STATUS_SUCCESS;
			break;
		}
	
		if (NT_SUCCESS(Status))
		{
			Status = afpCleanNetworkTrash(pVolDesc, &hNWT, NULL);
	
			if (NT_SUCCESS(Status) || !VolumeStart)
			{
	
				// NOTE: NTFS will allow me to open the directory for
				// DELETE access if it is marked Readonly, but I cannot delete it.
				// Clear the Readonly Bit on the Network Trash Folder
				AfpIoSetTimesnAttr(&hNWT,
								   NULL,
								   NULL,
								   0,
								   FILE_ATTRIBUTE_READONLY,
								   NULL,
								   NULL);
				Status = AfpIoMarkFileForDelete(&hNWT,
												NULL,
												NULL,
												NULL);
		
			}
	
			AfpIoClose(&hNWT);
		}
	} while (False);

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

	if ((!NT_SUCCESS(Status)) && (Status != STATUS_OBJECT_NAME_NOT_FOUND))
	{
		AFPLOG_ERROR(AFPSRVMSG_DELETE_NWTRASH,
					 Status,
					 NULL,
					 0,
					 &pVolDesc->vds_Name);
		Status = STATUS_UNSUCCESSFUL;
	}

	return Status;
}

/*** afpCleanNetworkTrash
 *
 *	Delete the contents of the network trash folder referenced by hNWT.
 *  If pDfeNWT is non-null, then delete the file/dir entries from the IdIndex
 *  database.  If pDfeNWT is null, the volume is being deleted and the
 *  IdIndex database is getting blown away too, so don't bother removing the
 *  entries.
 */
LOCAL
NTSTATUS
afpCleanNetworkTrash(
	IN	PVOLDESC		pVolDesc,
	IN	PFILESYSHANDLE	phNWT,
	IN	PDFENTRY		pDfeNWT OPTIONAL
)
{
	NTSTATUS Status;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_IDINDEX,DBG_LEVEL_INFO,("afpCleanNetworkTrash entered\n"));

	if (pDfeNWT != NULL)
	{
		ASSERT(pDfeNWT->dfe_AfpId == AFP_ID_NETWORK_TRASH);
		// clean out all child DFEntries belonging to the network trash
		AfpPruneIdDb(pVolDesc,pDfeNWT);
	}

	Status = AfpWalkDirectoryTree(phNWT, afpNwtDeleteFileEntity);

	return Status;
}

NTSTATUS
AfpWalkDirectoryTree(
	IN	PFILESYSHANDLE	phTargetDir,
	IN	WALKDIR_WORKER	NodeWorker
)
{
	PFILE_DIRECTORY_INFORMATION	tmpptr;
	PWALKDIR_NODE	DirNodeStacktop = NULL, pcurrentnode;
	NTSTATUS		rc, status = STATUS_SUCCESS;
	PBYTE			enumbuf;
	PWCHAR			nodename;
	ULONG			nodenamelen;
	BOOLEAN			isdir;
	UNICODE_STRING	udirname;

	PAGED_CODE( );

	//
	// allocate the buffer that will hold enumerated files and dirs
	//
	if ((enumbuf = (PBYTE)AfpAllocPANonPagedMemory(AFP_ENUMBUF_SIZE)) == NULL)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	do	// error handling loop
	{
		//
		// prime the pump with the top level (target dir) directory handle
		//
		if ((rc = afpPushDirNode(&DirNodeStacktop, NULL, NULL))
															!= STATUS_SUCCESS)
		{
			status = rc;
			break;
		}
		else
		{
			DirNodeStacktop->wdn_Handle = *phTargetDir;
		}

		//
		// keep popping enumerated directories off the stack until stack empty
		//
		while ((pcurrentnode = DirNodeStacktop) != NULL)
		{
			if (pcurrentnode->wdn_Enumerated == False)
			{
				//
				// get a handle to the directory so it can be enumerated
				//
				if (pcurrentnode->wdn_Handle.fsh_FileHandle == NULL)
				{
					RtlInitUnicodeString(&udirname,
										 pcurrentnode->wdn_RelativePath.Buffer);
					// open a handle to the thing relative to the phTargetDir
					rc = AfpIoOpen(phTargetDir,
								 AFP_STREAM_DATA,
								 FILEIO_OPEN_DIR,
								 &udirname,
								 FILEIO_ACCESS_READ,
								 FILEIO_DENY_NONE,
								 False,
								 &pcurrentnode->wdn_Handle);

					if (!NT_SUCCESS(rc))
					{
						status = rc;
						break;
					}
				}

				//
				// keep enumerating till we get all the entries
				//
				while (True)
				{
					rc = AfpIoQueryDirectoryFile(&pcurrentnode->wdn_Handle,
												 (PFILE_DIRECTORY_INFORMATION)enumbuf,
												 AFP_ENUMBUF_SIZE,
												 FileDirectoryInformation,
												 False,	// return multiple entries
												 False,	// don't restart scan
												 NULL);

					ASSERT(rc != STATUS_PENDING);

					if ((rc == STATUS_NO_MORE_FILES) ||
						(rc == STATUS_NO_SUCH_FILE))
					{
						pcurrentnode->wdn_Enumerated = True;
						break; // that's it, we've seen everything there is
					}
					//
					// NOTE: if we get STATUS_BUFFER_OVERFLOW, the IO status
					// information field does NOT tell us the required size
					// of the buffer, so we wouldn't know how big to realloc
					// the enum buffer if we wanted to retry, so don't bother
					else if (!NT_SUCCESS(rc))
					{
						status = rc;
						break;	// enumerate failed, bail out
					}

					//
					// process the enumerated files and dirs
					//
					tmpptr = (PFILE_DIRECTORY_INFORMATION)enumbuf;
					while (True)
					{
						rc = AfpGetNextDirectoryInfo(&tmpptr,
													 &nodename,
													 &nodenamelen,
													 &isdir);

						if (rc == STATUS_NO_MORE_ENTRIES)
						{
							break;
						}

						if (isdir == True)
						{
							AfpInitUnicodeStringWithNonNullTerm(&udirname,
													   (USHORT)nodenamelen,
													   nodename);

							if (RtlEqualUnicodeString(&Dot,&udirname,False) ||
								RtlEqualUnicodeString(&DotDot,&udirname,False))
							{
								continue;
							}

							//
							// push it onto the dir node stack
							//
							rc = afpPushDirNode(&DirNodeStacktop,
												&pcurrentnode->wdn_RelativePath,
												&udirname);
							if (rc != STATUS_SUCCESS)
							{
								status = rc;
								break;
							}
						}
						else
						{
							//
							// its a file, call worker with its relative handle
							// and path
							//
							rc = NodeWorker(&pcurrentnode->wdn_Handle,
											nodename,
											nodenamelen,
											False);
							if (!NT_SUCCESS(rc))
							{
								status = rc;
								break;
							}
						}

					} // while more entries in the enumbuf


					if (!NT_SUCCESS(status))
					{
						break;
					}

				} // while there are more files to enumerate

				if (pcurrentnode->wdn_Handle.fsh_FileHandle != phTargetDir->fsh_FileHandle)
				{
					AfpIoClose(&pcurrentnode->wdn_Handle);
				}
			}
			else	// we have already enumerated this directory
			{
				if (pcurrentnode->wdn_RelativePath.Length != 0)
				{
					// call the worker routine on this directory node
					rc = NodeWorker(phTargetDir,
									pcurrentnode->wdn_RelativePath.Buffer,
									pcurrentnode->wdn_RelativePath.Length,
									True);
				}
				else rc = STATUS_SUCCESS;

				afpPopDirNode(&DirNodeStacktop);
				if (!NT_SUCCESS(rc))
				{
					status = rc;
					break;
				}

			}


			if (!NT_SUCCESS(status))
			{
				break;
			}

		} // while there are directories to pop

	} while (False); // error handling loop

	while (DirNodeStacktop != NULL)
	{
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
				 ("AfpWalkDirectoryTree: WARNING: cleaning up dir stack\n") );
		// clean up in case of error
		afpPopDirNode(&DirNodeStacktop);
	}
	AfpFreePANonPagedMemory(enumbuf, AFP_ENUMBUF_SIZE);
	return status;
}

/***	afpPushDirNode
 *
 *	Keep a record of all the directories we have encountered so far during
 *  enumeration of the tree.  We need to process directories from the
 *  bottom up because the WalkTree node worker routine does a delete
 *	on all the items in a tree, and we certainly cant be deleting directories that
 *  are not empty.
 *
 */
LOCAL
NTSTATUS
afpPushDirNode(
	IN OUT	PWALKDIR_NODE	*ppStacktop,
	IN		PUNICODE_STRING pParentPath,	// path to parent (NULL iff walk root)
	IN		PUNICODE_STRING	pDirName		// name of current node directory
)
{
	PWALKDIR_NODE	tempptr;
	UNICODE_STRING	ubackslash;
	ULONG			memsize;
	USHORT			namesize = 0;

	PAGED_CODE( );

	if (pParentPath != NULL)
	{
		namesize = pParentPath->Length + sizeof(WCHAR) +
				   pDirName->Length + sizeof(UNICODE_NULL);
	}
	memsize = namesize + sizeof(WALKDIR_NODE);

	if ((tempptr = (PWALKDIR_NODE)AfpAllocNonPagedMemory(memsize)) == NULL)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	tempptr->wdn_Enumerated = False;
	tempptr->wdn_Handle.fsh_FileHandle = NULL;
	tempptr->wdn_RelativePath.Length = 0;
	tempptr->wdn_RelativePath.MaximumLength = namesize;

	if (pParentPath != NULL)
	{
		tempptr->wdn_RelativePath.Buffer = (LPWSTR)((PBYTE)tempptr +
														  sizeof(WALKDIR_NODE));
		if (pParentPath->Length != 0)
		{
			RtlInitUnicodeString(&ubackslash,L"\\");
			AfpCopyUnicodeString(&tempptr->wdn_RelativePath,pParentPath);
			RtlAppendUnicodeStringToString(&tempptr->wdn_RelativePath,
										   &ubackslash);
		}

		RtlAppendUnicodeStringToString(&tempptr->wdn_RelativePath,pDirName);
		tempptr->wdn_RelativePath.Buffer[tempptr->wdn_RelativePath.Length/sizeof(WCHAR)] = UNICODE_NULL;

	}
	else
	{
		tempptr->wdn_RelativePath.Buffer = NULL;
	}

	// push it on the stack
	tempptr->wdn_Next = *ppStacktop;
	*ppStacktop = tempptr;

	return STATUS_SUCCESS;
}

/*** afpPopDirNode
 *
 * Pop the top DirNode off of the stack and free it
 *
 ***/
LOCAL
VOID
afpPopDirNode(
	IN OUT PWALKDIR_NODE	*ppStackTop
)
{
	PWALKDIR_NODE	tempptr;

	PAGED_CODE( );

	ASSERT(*ppStackTop != NULL);

	tempptr = (*ppStackTop)->wdn_Next;
	AfpFreeMemory(*ppStackTop);
	*ppStackTop = tempptr;

}

/***	AfpGetNextDirectoryInfo
 *
 * Given a buffer full of FILE_DIRECTORY_INFORMATION entries as returned
 * from a directory enumerate, find the next structure in the buffer and
 * return the name information out of it, and whether or not the item
 * is a file or directory. Also update the ppInfoBuf to point to the next
 * available entry to return for the next time this routine is called.
 *
 */
NTSTATUS
AfpGetNextDirectoryInfo(
	IN OUT	PFILE_DIRECTORY_INFORMATION	*ppInfoBuf,
	OUT		PWCHAR		*pNodeName,
	OUT		PULONG		pNodeNameLen,
	OUT		PBOOLEAN	pIsDir
)
{
	PFILE_DIRECTORY_INFORMATION		tempdirinfo;

	PAGED_CODE( );

	if (*ppInfoBuf == NULL)
	{
		return STATUS_NO_MORE_ENTRIES;
	}

	tempdirinfo = *ppInfoBuf;
	if (tempdirinfo->NextEntryOffset == 0)
	{
		*ppInfoBuf = NULL;
	}
	else
	{
		(PBYTE)*ppInfoBuf += tempdirinfo->NextEntryOffset;
	}

	*pIsDir = (tempdirinfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ?
																True : False;
	*pNodeNameLen = tempdirinfo->FileNameLength;
	*pNodeName = tempdirinfo->FileName;

	return STATUS_SUCCESS;
}

/***	afpNwtDeleteFileEntity
 *
 * Delete a file or directory opening it with the name relative to phRelative
 * handle.
 * NOTE: can we use NtDeleteFile here since we dont really care about
 * any security checking?  Then we wouldn't even have to open a handle,
 * although that routine opens one for DELETE_ON_CLOSE for us, then
 * closes it.
 */
LOCAL
NTSTATUS
afpNwtDeleteFileEntity(
	IN	PFILESYSHANDLE	phRelative,
	IN	PWCHAR			Name,
	IN	ULONG			Namelen,
	IN 	BOOLEAN			IsDir
)
{
	ULONG			OpenOptions;
	FILESYSHANDLE	hEntity;
	NTSTATUS		rc;
	UNICODE_STRING	uname;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
									("\nafpNwtDeleteFileEntity entered\n"));

	OpenOptions = IsDir ? FILEIO_OPEN_DIR : FILEIO_OPEN_FILE;

	AfpInitUnicodeStringWithNonNullTerm(&uname,(USHORT)Namelen,Name);
	rc = AfpIoOpen(phRelative,
				   AFP_STREAM_DATA,
				   OpenOptions,
				   &uname,
				   FILEIO_ACCESS_DELETE,
				   FILEIO_DENY_ALL,
				   False,
				   &hEntity);

	if (!NT_SUCCESS(rc))
	{
		return rc;
	}

	rc = AfpIoMarkFileForDelete(&hEntity, NULL, NULL, NULL);

	if (!NT_SUCCESS(rc))
	{
		// If the file is marked readonly, try clearing the RO attribute
		if (((rc == STATUS_ACCESS_DENIED) || (rc == STATUS_CANNOT_DELETE)) &&
			(NT_SUCCESS(AfpIoSetTimesnAttr(&hEntity,
										   NULL,
										   NULL,
										   0,
										   FILE_ATTRIBUTE_READONLY,
										   NULL,
										   NULL))))

		{
			rc = AfpIoMarkFileForDelete(&hEntity, NULL, NULL, NULL);
		}
		if (!NT_SUCCESS(rc))
		{
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
			("\nafpNwtDeleteFileEntity: could not delete file/dir (rc=0x%lx)\n",rc));
			DBGBRK(DBG_LEVEL_ERR);
		}
	}
	// NOTE: if marking it for delete fails, at least we could try deleting
	// the afpId stream so that we wouldn't find it at some future point...

	AfpIoClose(&hEntity);

	return rc;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\sda.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	sda.c

Abstract:

	This module contains the session data area manipulation routines.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4

--*/

#define	_SDA_LOCALS
#define	FILENUM	FILE_SDA

#include <afp.h>
#include <scavengr.h>
#include <access.h>
#include <client.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfpSdaInit)
#pragma alloc_text( PAGE, afpCloseSessionAndFreeSda)
#pragma alloc_text( PAGE, AfpSdaCheckSession)
#endif

/***	AfpSdaInit
 *
 *	Initialize Sda Data structures. Called at init time.
 */
NTSTATUS
AfpSdaInit(
	VOID
)
{
	ASSERT(sizeof(SDA) <= 512);
	INITIALIZE_SPIN_LOCK(&AfpSdaLock);

	return STATUS_SUCCESS;
}


/***	AfpSdaReferenceSessionById
 *
 *	Reference a session by its id. The SDA cannot be referenced if it is
 *	marked closed. The SDA should be referenced before using it.
 *
 *	LOCKS:		AfpSdaLock (SPIN), sda_Lock (SPIN)
 *	LOCK_ORDER:	sda_Lock after AfpSdaLock
 */
PSDA FASTCALL
AfpSdaReferenceSessionById(
	IN DWORD	SessId
)
{
	PSDA	pSda=NULL;
    PSDA    pRetSda=NULL;
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

	for (pSda = AfpSessionList;
		 (pSda != NULL) && (pSda->sda_SessionId >= SessId);
		 pSda = pSda->sda_Next)
	{
		if (pSda->sda_SessionId == SessId)
		{
			ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

            if ((pSda->sda_Flags & SDA_CLOSING) == 0)
            {
			    ASSERT((pSda->sda_RefCount > 0) &&
				   (pSda->sda_SessionId != 0));

			    pSda->sda_RefCount ++;
                pRetSda = pSda;

			    DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
				    ("AfpSdaReferenceSessionById: New Count %d\n", pSda->sda_RefCount));
            }

			RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
			break;
		}
	}

	RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

	return pRetSda;
}


/***	AfpSdaReferenceSessionByPointer
 *
 *	Reference a session by pointer. The SDA cannot be referenced if it is
 *	marked closed. The SDA should be referenced before using it.
 *
 */
PSDA FASTCALL
AfpSdaReferenceSessionByPointer(
	IN PSDA     pSda
)
{
    PSDA    pRetSda=NULL;
	KIRQL	OldIrql;


    ASSERT(VALID_SDA(pSda));

	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

    if ((pSda->sda_Flags & SDA_CLOSING) == 0)
    {
	    pSda->sda_RefCount ++;
        pRetSda = pSda;
    }

	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);

	return pRetSda;
}



/***	afpSdaCloseSessionAndFreeSda
 *
 *	Run by the scavenger in the worker context. This is initiated as part of
 *	session cleanup.
 */
LOCAL AFPSTATUS FASTCALL
afpCloseSessionAndFreeSda(
	IN	PSDA	pSda
)
{
	POPENFORKSESS	    pOpenForkSess;
    PASP_XPORT_ENTRIES  XportTable;


	DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
			("afpCloseSessionAndFreeSda: Cleaning up session %lx\n",
			pSda->sda_SessionId));

	PAGED_CODE( );

#ifdef	OPTIMIZE_GUEST_LOGONS
	if (pSda->sda_ClientType != SDA_CLIENT_GUEST)
	{
#endif
#ifndef	INHERIT_DIRECTORY_PERMS
		// First free up paged memory used by the sda
		if (pSda->sda_pSecDesc != NULL)
		{
			if (pSda->sda_pSecDesc->Dacl != NULL)
				AfpFreeMemory(pSda->sda_pSecDesc->Dacl);
			AfpFreeMemory(pSda->sda_pSecDesc);
		}
#endif
		if ((pSda->sda_UserSid != NULL) && (pSda->sda_UserSid != &AfpSidWorld))
			AfpFreeMemory(pSda->sda_UserSid);

		if ((pSda->sda_GroupSid != NULL) && (pSda->sda_GroupSid != &AfpSidWorld))
			AfpFreeMemory(pSda->sda_GroupSid);

		if (pSda->sda_pGroups != NULL)
			AfpFreeMemory(pSda->sda_pGroups);
#ifdef	OPTIMIZE_GUEST_LOGONS
	}
#endif

	// Free any chains of fork entries that we created
	pOpenForkSess = pSda->sda_OpenForkSess.ofs_Link;
	while (pOpenForkSess != NULL)
	{
		POPENFORKSESS	pFree;

		pFree = pOpenForkSess;
		pOpenForkSess = pOpenForkSess->ofs_Link;
		AfpFreeMemory(pFree);
	}

	// Next log-out the user
	DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
			("afpCloseSessionAndFreeSda: Closing User Token\n"));

#ifdef	OPTIMIZE_GUEST_LOGON
	if ((pSda->sda_UserToken != NULL) && (pSda->sda_ClientType != SDA_CLIENT_GUEST))
#else
	if (pSda->sda_UserToken != NULL)
#endif
		NtClose(pSda->sda_UserToken);

	// Make sure there are no resource leaks
	ASSERT (pSda->sda_cOpenVolumes == 0);
	ASSERT (pSda->sda_pConnDesc == 0);
	ASSERT (pSda->sda_cOpenForks == 0);

    XportTable = pSda->sda_XportTable;

	(*(XportTable->asp_FreeConn))(pSda->sda_SessHandle);

    if (pSda->sda_ReplyBuf)
    {
	    DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_ERR,
			("afpCloseSessionAndFreeSda: %d bytes would have leaked!\n",pSda->sda_ReplySize));

        // TRUE => lie that the lock is held: we don't need lock no more
        AfpFreeReplyBuf(pSda, TRUE);
    }

	// Free the sda memory, finally
	AfpFreeMemory(pSda);


	// If the server is stopping and the count of sessions has gone to zero
	// clear the termination confirmation event to unblock the admin thread
	if (((AfpServerState == AFP_STATE_STOP_PENDING) ||
		 (AfpServerState == AFP_STATE_SHUTTINGDOWN)) &&
		(AfpNumSessions == 0))
	{
		DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_WARN,
			("afpSdaCloseSessionAndFreeSda: Unblocking server stop\n"));
		KeSetEvent(&AfpStopConfirmEvent, IO_NETWORK_INCREMENT, False);
	}

	DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO, ("afpCloseSessionAndFreeSda: Done\n"));

	return AFP_ERR_NONE;
}



/***	AfpSdaDereferenceSession
 *
 *	Dereference this SDA. This is called in response to either a AfpLogout
 *	request, a forced shutdown of this session by either SessionClose() api,
 *	the server shutdown or the session shutdown from the client end.
 *	The Sda should not be dereferenced until the entire request is processed
 *	i.e. the reply has ALSO COMPLETED.
 *
 *	NOTE: We unlink the session from the list but do not update the count till
 *		  the entire cleanup is complete.
 *
 *	LOCKS:		AfpSdaLock (SPIN), sda_Lock (SPIN), AfpStatisticsLock (SPIN)
 */
VOID FASTCALL
AfpSdaDereferenceSession(
	IN PSDA	pSda
)
{
	PSDA *		ppSda;
	KIRQL		OldIrql;
	LONG		RefCount;
    BOOLEAN     fTcpSession=TRUE;

	ASSERT(VALID_SDA(pSda));
	ASSERT((pSda->sda_RefCount > 0) &&
		   (pSda->sda_SessionId != 0));

	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);
	RefCount = -- (pSda->sda_RefCount);
    if (RefCount == 0)
    {
        pSda->sda_Flags |= SDA_CLOSING;

        fTcpSession = (pSda->sda_Flags & SDA_SESSION_OVER_TCP)? TRUE : FALSE;
    }
	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);


	DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
			("AfpSdaDereferenceSession: Session %ld, New Count %ld\n",
			pSda->sda_SessionId, RefCount));

	// If there are more references, then we are done.
	if (RefCount > 0)
		return;

    ASSERT(RefCount == 0);     // catch refcount going below 0!

	ASSERT (!(pSda->sda_Flags & SDA_REQUEST_IN_PROCESS));

	DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
				("AfpSdaDereferenceSession: Closing down session %ld\n",
				pSda->sda_SessionId));

	// Cancel the scavenger event for checking this user's kickoff time
	AfpScavengerKillEvent(AfpSdaCheckSession,
						 (PVOID)((ULONG_PTR)(pSda->sda_SessionId)));

	// First unlink the Sda from the sessions list
	ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

	for (ppSda = &AfpSessionList;
		 *ppSda != NULL;
		 ppSda = &(*ppSda)->sda_Next)
		if (pSda == *ppSda)
			break;

	ASSERT(*ppSda == pSda);

	*ppSda = pSda->sda_Next;

	// Update the count of active sessions
	ASSERT (AfpNumSessions > 0);
	--AfpNumSessions;

	RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

	// Free all buffers associated with the Sda
	// Now free the SDA memory
	if (pSda->sda_WSName.Buffer != NULL)
		AfpFreeMemory(pSda->sda_WSName.Buffer);

	if ((pSda->sda_ClientType != SDA_CLIENT_GUEST) &&
		(pSda->sda_UserName.Buffer != NULL))
		AfpFreeMemory(pSda->sda_UserName.Buffer);

	if (pSda->sda_Challenge != NULL)
		AfpFreeMemory(pSda->sda_Challenge);

	if (pSda->sda_DomainName.Buffer != NULL)
		AfpFreeMemory(pSda->sda_DomainName.Buffer);

	if (pSda->sda_Message != NULL)
		AfpFreeMemory(pSda->sda_Message);

	// Finally update statistics
	INTERLOCKED_ADD_ULONG((PLONG)&AfpServerStatistics.stat_CurrentSessions,
						  (ULONG)-1,
						  &AfpStatisticsLock);

	// it was a TCP session? update that counter as well
    if (fTcpSession)
    {
	    INTERLOCKED_ADD_ULONG((PLONG)&AfpServerStatistics.stat_TcpSessions,
		    				  (ULONG)-1,
			    			  &AfpStatisticsLock);
    }

	// The balance of the clean-up has to happen at LOW_LEVEL in the context
	// of the worker thread. So queue it up
	if ((OldIrql == DISPATCH_LEVEL) ||
		(PsGetCurrentProcess() != AfpProcessObject))
	{
		DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
				("AfpSdaDereferenceSession: Queuing Close&Free to Scavenger\n"));

		AfpScavengerScheduleEvent(afpCloseSessionAndFreeSda,
								  (PVOID)pSda,
								  0,
								  True);
	}
	else
	{
		afpCloseSessionAndFreeSda(pSda);
	}
}



/***	AfpSdaCreateNewSession
 *
 *	A new session has been initiated. Allocate and initialize a Sda and return a
 *	pointer to it. The new sda is linked into the list of active sessions.
 *
 *	LOCKS:		AfpSdaLock (SPIN), AfpServerGlobalLock (SPIN)
 *	LOCK_ORDER:	AfpServerGlobalLock after AfpSdaLock
 */
PSDA FASTCALL
AfpSdaCreateNewSession(
	IN	PVOID	SessionHandle,
    IN  BOOLEAN fOverTcp
)
{
	KIRQL	OldIrql;
	PSDA	*ppSda, pSda = NULL;


	if ((DWORD)AfpNumSessions < AfpServerMaxSessions)
	{
		if ((pSda = (PSDA)AfpAllocNonPagedMemory(SDA_SIZE)) == NULL)
			return NULL;

		// Initialize SDA fields
		RtlZeroMemory(pSda, sizeof(SDA));
#if DBG
		pSda->Signature = SDA_SIGNATURE;
#endif
		INITIALIZE_SPIN_LOCK(&pSda->sda_Lock);

		// Reference this Session
		pSda->sda_RefCount = 1;

		pSda->sda_Flags = SDA_USER_NOT_LOGGEDIN;

        if (fOverTcp)
        {
            pSda->sda_Flags |= SDA_SESSION_OVER_TCP;
            pSda->sda_XportTable = &AfpDsiEntries;
            pSda->sda_MaxWriteSize = DSI_SERVER_REQUEST_QUANTUM;
        }
        else
        {
            pSda->sda_XportTable = &AfpAspEntries;
            pSda->sda_MaxWriteSize = ASP_QUANTUM;
        }

		pSda->sda_SessHandle = SessionHandle;

		InitializeListHead(&pSda->sda_DeferredQueue);
		AfpInitializeWorkItem(&pSda->sda_WorkItem,
							  AfpStartApiProcessing,
							  pSda);
		AfpGetCurrentTimeInMacFormat(&pSda->sda_TimeLoggedOn);
		pSda->sda_tTillKickOff = MAXLONG;

		// Initialize space for request/response
		pSda->sda_SizeNameXSpace = (USHORT)(SDA_SIZE - sizeof(SDA));
		pSda->sda_NameXSpace = (PBYTE)pSda + sizeof(SDA);

		ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

		// Assign a new session id to this session
		pSda->sda_SessionId = afpNextSessionId ++;

		ASSERT(pSda->sda_SessionId != 0);

		// Link the Sda into the active session list
		for (ppSda = &AfpSessionList;
			 *ppSda != NULL;
			 ppSda = &((*ppSda)->sda_Next))
		{
			if ((*ppSda)->sda_SessionId < pSda->sda_SessionId)
				break;
		}

		pSda->sda_Next = *ppSda;
		*ppSda = pSda;

		// Update the count of active sessions
		AfpNumSessions++;

		RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

		// Finally update statistics
		ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);
		AfpServerStatistics.stat_CurrentSessions ++;
		AfpServerStatistics.stat_TotalSessions ++;
		if (AfpServerStatistics.stat_CurrentSessions >
										AfpServerStatistics.stat_MaxSessions)
		AfpServerStatistics.stat_MaxSessions =
										AfpServerStatistics.stat_CurrentSessions;
        if (fOverTcp)
        {
            AfpServerStatistics.stat_TcpSessions++;

            if (AfpServerStatistics.stat_TcpSessions >
                                        AfpServerStatistics.stat_MaxTcpSessions)
            {
                AfpServerStatistics.stat_MaxTcpSessions =
                                        AfpServerStatistics.stat_TcpSessions;
            }
        }
		RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);
	}

	return pSda;
}


/***	AfpSdaCloseSession
 *
 *	Setup to close the session
 */
AFPSTATUS FASTCALL
AfpSdaCloseSession(
	IN	PSDA	pSda
)
{
	LONG	ConnRef;
	DWORD	ForkRef, MaxOForkRefNum;

	DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
			("AfpSdaCloseSession: Entered for session %lx\n",
			pSda->sda_SessionId));

	// We should be coming in from the scavenger worker in its context i.e. at LOW_LEVEL.
	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	// Close down the open forks from this session
    MaxOForkRefNum = pSda->sda_MaxOForkRefNum;
	for (ForkRef = 1; ForkRef <= MaxOForkRefNum; ForkRef++)
	{
		POPENFORKENTRY	pOpenForkEntry;
		KIRQL			OldIrql;

		KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
		pOpenForkEntry = AfpForkReferenceByRefNum(pSda, ForkRef);
		KeLowerIrql(OldIrql);

		if (pOpenForkEntry != NULL)
		{
			DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
					("AfpSdaCloseSession: Forcing close of fork %lx, id %lx\n",
					ForkRef, pOpenForkEntry->ofe_ForkId));

			AfpForkClose(pOpenForkEntry);

			AfpForkDereference(pOpenForkEntry);
		}
	}

	// Now close down all open volumes.
	// Note that AfpConnectionClose will unlink the ConnDesc from the Sda
	for (ConnRef = 1; ConnRef <= afpLargestVolIdInUse; ConnRef++)
	{
		PCONNDESC	pConnDesc;

		if ((pConnDesc = AfpConnectionReference(pSda, ConnRef)) != NULL)
		{
			AfpConnectionClose(pConnDesc);
			AfpConnectionDereference(pConnDesc);
		}
	}

	DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO, ("AfpCloseSession: Done\n"));

	ASSERT (pSda->sda_Flags & SDA_SESSION_CLOSED);

	AfpSdaDereferenceSession(pSda);

	return AFP_ERR_NONE;
}


/***	AfpAdmWSessionClose
 *
 *	Close a session forcibly. This is an admin operation and must be queued
 *	up since this can potentially cause filesystem operations that are valid
 *	only in the system process context.
 *
 *	LOCKS:		AfpSdaLock (SPIN), sda_Lock (SPIN)
 *	LOCK_ORDER:	sda_Lock after AfpSdaLock
 */
NTSTATUS
AfpAdmWSessionClose(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	AFPSTATUS			Status = AFPERR_InvalidId;
	DWORD				SessId;
	PSDA				pSda;
	KIRQL				OldIrql;
	PAFP_SESSION_INFO	pSessInfo = (PAFP_SESSION_INFO)InBuf;
	USHORT				AttnWord;
	BOOLEAN				Shoot = False;

	AttnWord = ATTN_USER_DISCONNECT;
	if ((AfpServerState == AFP_STATE_SHUTTINGDOWN) ||
        (AfpServerState == AFP_STATE_STOP_PENDING))
		AttnWord = ATTN_SERVER_SHUTDOWN;

	if ((SessId = pSessInfo->afpsess_id) != 0)
	{
		if ((pSda = AfpSdaReferenceSessionById(SessId)) != NULL)
		{
			Status = AFP_ERR_NONE;

			ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

			if ((pSda->sda_Flags & (SDA_CLOSING | SDA_SESSION_CLOSED | SDA_CLIENT_CLOSE)) == 0)
			{
				Shoot = True;
				pSda->sda_Flags |= SDA_CLOSING | SDA_SESSION_CLOSED;
			}

			RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);

			if (Shoot)
			{
				// Tell the client (s)he's being shot
				AfpSpSendAttention(pSda, AttnWord, True);

				AfpSpCloseSession(pSda);
			}
			AfpSdaDereferenceSession(pSda);
		}
        else
        {
		    DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_ERR,
				("AfpAdmWSessionClose: no pSda found for SessId %d\n",pSessInfo->afpsess_id));
        }
	}
	else
	{
		PSDA	pSdaNext;

		// Here we want to block incoming sessions while we kill the existing ones
        AfpSpDisableListens();

		Status = AFP_ERR_NONE;
		ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

		for (pSda = AfpSessionList; pSda != NULL; pSda = pSdaNext)
		{
			ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

			Shoot = False;
			pSdaNext = pSda->sda_Next;
			if ((pSda->sda_Flags & (SDA_CLOSING | SDA_SESSION_CLOSED | SDA_CLIENT_CLOSE)) == 0)
			{
				pSda->sda_Flags |= SDA_CLOSING | SDA_SESSION_CLOSED;
				pSda->sda_RefCount ++;
				Shoot = True;
			}

			RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

			if (Shoot)
			{
				RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

				// Tell the client (s)he's being shot
				AfpSpSendAttention(pSda, AttnWord, True);

				AfpSpCloseSession(pSda);

				AfpSdaDereferenceSession(pSda);

				ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);
				pSdaNext = AfpSessionList;
			}
		}
		RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

		// Enable new incoming sessions - but only if we are not paused
		if ((AfpServerState & (AFP_STATE_PAUSED | AFP_STATE_PAUSE_PENDING)) == 0)
		{
			AfpSpEnableListens();
		}
	}

	return Status;
}


/***	AfpSdaCheckSession
 *
 *	Check if a session needs to be forcibly closed. If we are called by the
 *  scavenger for the first time and our scavenger interval is not
 *  SESSION_CHECK_TIME, we need to reschedule ourselves to run at this
 *	interval.
 *
 *	Since the sda_tTillKickOff is only used here, it needs
 *	no protection.
 */
AFPSTATUS FASTCALL
AfpSdaCheckSession(
	IN	PVOID	pContext
)
{
	PSDA				pSda;
	DWORD				SessionId = (DWORD)((ULONG_PTR)pContext);
	AFPSTATUS			Status = AFP_ERR_REQUEUE;
	BOOLEAN				RequeueOurself = False;

	PAGED_CODE( );

	if ((pSda = AfpSdaReferenceSessionById(SessionId)) != NULL)
	{
		if (pSda->sda_tTillKickOff > SESSION_WARN_TIME)
		{
			// This is the first time this routine has run, and it was
			// originally scheduled to run at a time greater than
			// SESSION_WARN_TIME.  Therefore, we need to reschedule this
			// scavenger event ourselves with a new SESSION_CHECK_TIME
			// interval.  This is the only time we need to do this.
			pSda->sda_tTillKickOff = SESSION_WARN_TIME;
			Status = AFP_ERR_NONE;
			RequeueOurself = True;
		}
		else if (pSda->sda_tTillKickOff > 0)
			pSda->sda_tTillKickOff -= SESSION_CHECK_TIME;

		ASSERT(pSda->sda_tTillKickOff <= SESSION_WARN_TIME);

		DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_WARN,
				("AfpSdaCheckSession: Below warn level %ld\n",
				pSda->sda_tTillKickOff));

		// If we are at 0, kick this user out. Else just
		// send him a friendly warning.
		if (pSda->sda_tTillKickOff == 0)
		{
			AFP_SESSION_INFO	SessionInfo;

			DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_WARN,
					("AfpSdaCheckSession: Booting session %ld\n", SessionId));

			SessionInfo.afpsess_id = SessionId;
			AfpAdmWSessionClose(&SessionInfo, 0, NULL);
			Status = AFP_ERR_NONE;		// Do not reschedule
		}
		else
		{
			DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_WARN,
					("AfpSdaCheckSession: Warning session %ld\n", SessionId));

			AfpSpSendAttention(pSda,
							   (USHORT)(ATTN_USER_DISCONNECT |
										((pSda->sda_tTillKickOff/60) & ATTN_TIME_MASK)),
								True);
		}

		if (RequeueOurself)
		{
			AfpScavengerScheduleEvent(
							AfpSdaCheckSession,
							(PVOID)((ULONG_PTR)pSda->sda_SessionId),
							SESSION_CHECK_TIME,
							True);
		}

		AfpSdaDereferenceSession(pSda);
	}

	return Status;
}


/***	AfpKillSessionsOverProtocol
 *
 *	Kill all the sessions over a specific protocol (TCP/IP or Appletalk)
 */
VOID FASTCALL
AfpKillSessionsOverProtocol(
	IN	BOOLEAN     fAppletalkSessions
)
{
	PSDA        pSda;
	PSDA        pSdaNext;
    KIRQL       OldIrql;
    USHORT      AttnWord;


    AttnWord = ATTN_USER_DISCONNECT;

	ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

	for (pSda = AfpSessionList; pSda != NULL; pSda = pSdaNext)
	{
		ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

		pSdaNext = pSda->sda_Next;

        //
        // if this session is already being closing, skip it
        //
		if (pSda->sda_Flags & (SDA_CLOSING | SDA_SESSION_CLOSED | SDA_CLIENT_CLOSE))
		{
            RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
            continue;
		}

        //
        // if we are asked to kill all Appletalk sessions and this session
        // over Appletalk, skip it
        //
        if (fAppletalkSessions)
        {
            if (pSda->sda_Flags & SDA_SESSION_OVER_TCP)
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
	                ("AfpKillSessionsOverProtocol: skipping TCP session %lx\n",pSda));

                RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
                continue;
            }
        }

        //
        // we are asked to kill all TCP/IP sessions, and this session is
        // over Appletalk: skip it
        //
        else
        {
            if (!(pSda->sda_Flags & SDA_SESSION_OVER_TCP))
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
	                ("AfpKillSessionsOverProtocol: skipping Appletalk session %lx\n",pSda));

                RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
                continue;
            }
        }
		pSda->sda_Flags |= SDA_CLOSING | SDA_SESSION_CLOSED;

        // put a DISCONNECT refcount
		pSda->sda_RefCount ++;
		
        RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

		RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

		// give client the bad news
		AfpSpSendAttention(pSda, AttnWord, True);

		AfpSpCloseSession(pSda);

        // and remove that DISCONNECT refcount
		AfpSdaDereferenceSession(pSda);

		ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

        // start from the head of the list
		pSdaNext = AfpSessionList;
	}

	RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

}


/***	AfpFreeReplyBuf
 *
 *	Free up the reply buffer
 *
 */
VOID
AfpFreeReplyBuf(
    IN  PSDA    pSda,
    IN  BOOLEAN fLockHeld
)
{
    KIRQL       OldIrql;
    BOOLEAN     fRelease=FALSE;
    PBYTE       pReplyBuffer;


    if (!fLockHeld)
    {
        ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);
        fRelease = TRUE;
    }

    ASSERT(pSda->sda_ReplyBuf != NULL);

    pReplyBuffer = pSda->sda_ReplyBuf - DSI_BACKFILL_OFFSET(pSda);

    if (pReplyBuffer == pSda->sda_NameXSpace)
    {
        ASSERT(pSda->sda_Flags & SDA_NAMEXSPACE_IN_USE);
        pSda->sda_Flags &= ~SDA_NAMEXSPACE_IN_USE;
    }
    else
    {
        AfpFreeMemory(pReplyBuffer);
    }

    pSda->sda_ReplyBuf = NULL;
    pSda->sda_ReplySize = 0;

    if (fRelease)
    {
        RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);
    }
}



/***	afpUpdateDiskQuotaInfo
 *
 *	Get Available disk quota for this user
 *
 */

VOID FASTCALL
afpUpdateDiskQuotaInfo(
    IN PCONNDESC    pConnDesc
)
{

	FILE_FS_SIZE_INFORMATION	fssizeinfo;
	IO_STATUS_BLOCK				IoStsBlk;
	NTSTATUS					rc;
	LONG						BytesPerAllocationUnit;
	LARGE_INTEGER				FreeBytes, VolumeSize;
    KIRQL                       OldIrql;


    ASSERT(VALID_CONNDESC(pConnDesc));

    ASSERT(VALID_VOLDESC(pConnDesc->cds_pVolDesc));

	ASSERT(VALID_VOLDESC(pConnDesc->cds_pVolDesc) &&
           VALID_FSH(&pConnDesc->cds_pVolDesc->vds_hRootDir) &&
           (KeGetCurrentIrql() < DISPATCH_LEVEL));

    AfpImpersonateClient(pConnDesc->cds_pSda);

	rc = NtQueryVolumeInformationFile(
                pConnDesc->cds_pVolDesc->vds_hRootDir.fsh_FileHandle,
				&IoStsBlk,
				(PVOID)&fssizeinfo,
				sizeof(fssizeinfo),
				FileFsSizeInformation);

    AfpRevertBack();

	if (!NT_SUCCESS(rc))
	{
        DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
		("afpUpdateDiskQuotaInfo: NtQueryVolInfoFile failed 0x%lx\n",rc));

        // take away the refcount we put before calling this routine
        AfpConnectionDereference(pConnDesc);
        return;
	}

	//
	// note Macintosh can only handle 2Gb volume size. So kludge appropriately.
	// System 7.5 and beyond has upped this to 4GB. Optionally handle this if
	// the volume has that bit turned on.
	//

	BytesPerAllocationUnit =
		(LONG)(fssizeinfo.BytesPerSector * fssizeinfo.SectorsPerAllocationUnit);

	FreeBytes  = RtlExtendedIntegerMultiply(fssizeinfo.AvailableAllocationUnits,
											BytesPerAllocationUnit);

	VolumeSize = RtlExtendedIntegerMultiply(fssizeinfo.TotalAllocationUnits,
							BytesPerAllocationUnit);

    ACQUIRE_SPIN_LOCK(&pConnDesc->cds_ConnLock, &OldIrql);
    pConnDesc->cds_QuotaLimit = VolumeSize;
    pConnDesc->cds_QuotaAvl = FreeBytes;
    RELEASE_SPIN_LOCK(&pConnDesc->cds_ConnLock, OldIrql);

    DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
        ("afpUpdateDiskQuotaInfo: Conn %lx Limit=%ld, Available=%ld\n",
        pConnDesc,pConnDesc->cds_QuotaLimit.LowPart,pConnDesc->cds_QuotaAvl.LowPart));

    // take away the refcount we put before calling this routine
    AfpConnectionDereference(pConnDesc);

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\memory.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	memory.c

Abstract:

	This module contains the routines which allocates and free memory - both
	paged and non-paged.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version
	11 Mar 1993		SueA - Fixed AfpAllocUnicodeString to expect byte count,
					       not char count
Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_MEMORY

#define	AFPMEM_LOCALS
#include <afp.h>
#include <iopool.h>
#include <scavengr.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfpMemoryInit)
#pragma alloc_text( PAGE, AfpMemoryDeInit)
#endif


/***	AfpMemoryInit
 *
 *	Initialize the IO Pool system.
 */
NTSTATUS
AfpMemoryInit(
	VOID
)
{
	NTSTATUS	Status;

	INITIALIZE_SPIN_LOCK(&afpIoPoolLock);

	Status = AfpScavengerScheduleEvent(afpIoPoolAge,
									   NULL,
									   POOL_AGE_TIME,
									   False);
	return Status;
}

/***	AfpMemoryDeInit
 *
 *	Free any IO pool buffers.
 */
VOID
AfpMemoryDeInit(
	VOID
)
{
	PIOPOOL	pPool, pFree;

	for (pPool = afpIoPoolHead;
		 pPool != NULL;)
	{
		ASSERT(VALID_IOP(pPool));
		pFree = pPool;
		pPool = pPool->iop_Next;
		ASSERT (pFree->iop_NumFreeBufs == NUM_BUFS_IN_POOL);
		ASSERT (pFree->iop_NumFreeLocks == NUM_LOCKS_IN_POOL);
		AfpFreeMemory(pFree);
	}
}

/***	AfpAllocMemory
 *
 *	Allocate a block of memory from either the paged or the non-paged pool
 *	based on the memory tag. This is just a wrapper over ExAllocatePool.
 *	Allocation failures are error-logged. We always allocate a DWORD more
 *	than the specified size to accomodate the size. This is used by
 *	AfpFreeMemory to update the statistics.
 *
 *	While we are debugging, we also pad the block with a signature and test
 *	it when we free it. This detects memory overrun.
 */
PBYTE FASTCALL
AfpAllocMemory(
#ifdef	TRACK_MEMORY_USAGE
	IN	LONG	Size,
	IN	DWORD	FileLine
#else
	IN	LONG	Size
#endif
)
{
	KIRQL		OldIrql;
	PBYTE		Buffer;
	DWORD		OldMaxUsage;
	POOL_TYPE	PoolType;
	PDWORD		pCurUsage, pMaxUsage, pCount, pLimit;
        PDWORD          pDwordBuf;
	BOOLEAN		Zeroed;
#if DBG
	DWORD		Signature;
#endif
#ifdef	PROFILING
	TIME		TimeS1, TimeS2, TimeE, TimeD;

	AfpGetPerfCounter(&TimeS1);
#endif

	ASSERT ((Size & ~MEMORY_TAG_MASK) < MAXIMUM_ALLOC_SIZE);

	// Make sure that this allocation will not put us over the limit
	// of paged/non-paged pool that we can allocate.
	//
	// Account for this allocation in the statistics database.

	Zeroed = False;
	if (Size & ZEROED_MEMORY_TAG)
	{
		Zeroed = True;
        Size &= ~ZEROED_MEMORY_TAG;
	}

	if (Size & NON_PAGED_MEMORY_TAG)
	{
		PoolType  = NonPagedPool;
		pCurUsage = &AfpServerStatistics.stat_CurrNonPagedUsage;
		pMaxUsage = &AfpServerStatistics.stat_MaxNonPagedUsage;
		pCount    =	&AfpServerStatistics.stat_NonPagedCount;
		pLimit    = &AfpNonPagedPoolLimit;
#if DBG
		Signature = NONPAGED_BLOCK_SIGNATURE;
#endif
	}
	else
	{
		ASSERT (Size & PAGED_MEMORY_TAG);
		PoolType  = PagedPool;
		pCurUsage = &AfpServerStatistics.stat_CurrPagedUsage;
		pMaxUsage = &AfpServerStatistics.stat_MaxPagedUsage;
		pCount    =	&AfpServerStatistics.stat_PagedCount;
		pLimit    = &AfpPagedPoolLimit;
#if DBG
		Signature = PAGED_BLOCK_SIGNATURE;
#endif
	}

	Size &= ~MEMORY_TAG_MASK;

    if (Size == 0 )
    {
		DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_ERR,
				("afpAllocMemory: Alloc for 0 bytes!\n"));
        ASSERT(0);
        return(NULL);
    }

	Size = DWORDSIZEBLOCK(Size) +
#if DBG
			sizeof(DWORD) +				// For the signature
#endif
                        LONGLONGSIZEBLOCK(sizeof(TAG));

	ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);

	*pCurUsage += Size;
	(*pCount) ++;

	OldMaxUsage = *pMaxUsage;
	if (*pCurUsage > *pMaxUsage)
		*pMaxUsage = *pCurUsage;

	RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeS2);
#endif

	// Do the actual memory allocation.  Allocate four extra bytes so
	// that we can store the size of the allocation for the free routine.
	if ((Buffer = ExAllocatePoolWithTag(PoolType, Size, AFP_TAG)) == NULL)
	{
		ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);

		*pCurUsage -= Size;
		*pMaxUsage = OldMaxUsage;

		RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);
		AFPLOG_DDERROR(AFPSRVMSG_PAGED_POOL, STATUS_NO_MEMORY, &Size,
					 sizeof(Size), NULL);

		DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_ERR,
			("AfpAllocMemory: ExAllocatePool returned NULL for %d bytes\n",Size));

		return NULL;
	}
#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS2.QuadPart;
	if (PoolType == NonPagedPool)
	{
		INTERLOCKED_INCREMENT_LONG(AfpServerProfile->perf_ExAllocCountN);
	
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_ExAllocTimeN,
									TimeD,
									&AfpStatisticsLock);
	else
	{
		INTERLOCKED_INCREMENT_LONG(AfpServerProfile->perf_ExAllocCountP);
	
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_ExAllocTimeP,
									TimeD,
									&AfpStatisticsLock);
	}

	TimeD.QuadPart = TimeE.QuadPart - TimeS1.QuadPart;
	if (PoolType == NonPagedPool)
	{
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_AfpAllocCountN);
	}
	else
	{
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_AfpAllocTimeP,
									TimeD,
									&AfpStatisticsLock);
	}
#endif

	// Save the size of this block along with the tag in the extra space we allocated.
        pDwordBuf = (PDWORD)Buffer;

#if DBG
        *pDwordBuf = 0xCAFEBEAD;
#endif
        // skip past the unused dword (it's only use in life is to get the buffer quad-aligned!)
        pDwordBuf++;

	((PTAG)pDwordBuf)->tg_Size = Size;
	((PTAG)pDwordBuf)->tg_Tag = (PoolType == PagedPool) ? PGD_MEM_TAG : NPG_MEM_TAG;

#if DBG
	// Write the signature at the end
	*(PDWORD)((PBYTE)Buffer + Size - sizeof(DWORD)) = Signature;
#endif

#ifdef	TRACK_MEMORY_USAGE
	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
			("AfpAllocMemory: %lx Allocated %lx bytes @%lx\n",
			*(PDWORD)((PBYTE)(&Size) - sizeof(Size)), Size, Buffer));
	AfpTrackMemoryUsage(Buffer, True, (BOOLEAN)(PoolType == PagedPool), FileLine);
#endif

	// Return a pointer to the memory after the tag. Clear the memory, if requested
        //
        // We need the memory to be quad-aligned, so even though sizeof(TAG) is 4, we skip
        // LONGLONG..., which is 8.  The 1st dword is unused (for now?), the 2nd dword is the TAG

        Buffer += LONGLONGSIZEBLOCK(sizeof(TAG));

        Size -= LONGLONGSIZEBLOCK(sizeof(TAG));

	if (Zeroed)
	{
#if	DBG
		RtlZeroMemory(Buffer, Size - sizeof(DWORD));
#else
		RtlZeroMemory(Buffer, Size);
#endif
	}


	return Buffer;
}


/***	AfpAllocNonPagedLowPriority
 *
 *	Allocate a block of non-paged memory with a low priority
 */
PBYTE FASTCALL
AfpAllocNonPagedLowPriority(
#ifdef	TRACK_MEMORY_USAGE
	IN	LONG	Size,
	IN	DWORD	FileLine
#else
	IN	LONG	Size
#endif
)
{
	KIRQL		OldIrql;
	PBYTE		Buffer;
	DWORD		OldMaxUsage;
	POOL_TYPE	PoolType;
	PDWORD		pCurUsage, pMaxUsage, pCount, pLimit;
    PDWORD      pDwordBuf;
#if DBG
	DWORD		Signature;
#endif
#ifdef	PROFILING
	TIME		TimeS1, TimesS2, TimeE, TimeD;

	AfpGetPerfCounter(&TimeS1);
#endif

	ASSERT ((Size & ~MEMORY_TAG_MASK) < MAXIMUM_ALLOC_SIZE);

	PoolType  = NonPagedPool;
	pCurUsage = &AfpServerStatistics.stat_CurrNonPagedUsage;
	pMaxUsage = &AfpServerStatistics.stat_MaxNonPagedUsage;
	pCount    =	&AfpServerStatistics.stat_NonPagedCount;
	pLimit    = &AfpNonPagedPoolLimit;

#if DBG
	Signature = NONPAGED_BLOCK_SIGNATURE;
#endif

	Size &= ~MEMORY_TAG_MASK;
	Size = DWORDSIZEBLOCK(Size) +
#if DBG
			sizeof(DWORD) +				// For the signature
#endif
                        LONGLONGSIZEBLOCK(sizeof(TAG));

	ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);

	*pCurUsage += Size;
	(*pCount) ++;


	OldMaxUsage = *pMaxUsage;
	if (*pCurUsage > *pMaxUsage)
		*pMaxUsage = *pCurUsage;

	RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeS2);
#endif

	// Do the actual memory allocation.  Allocate four extra bytes so
	// that we can store the size of the allocation for the free routine.

	Buffer = ExAllocatePoolWithTagPriority(PoolType,
                                           Size,
                                           AFP_TAG,
                                           LowPoolPriority);

	if (Buffer == NULL)
	{
        ASSERT(0);

		ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);

		*pCurUsage -= Size;
		*pMaxUsage = OldMaxUsage;

		RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);
		AFPLOG_DDERROR(AFPSRVMSG_PAGED_POOL, STATUS_NO_MEMORY, &Size,
					 sizeof(Size), NULL);
		return NULL;
	}

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS2.QuadPart;

	INTERLOCKED_INCREMENT_LONG(AfpServerProfile->perf_ExAllocCountN);
	
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_ExAllocTimeN,
								TimeD,
								&AfpStatisticsLock);

	TimeD.QuadPart = TimeE.QuadPart - TimeS1.QuadPart;
	
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_AfpAllocCountN);
#endif

	// Save the size of this block along with the tag in the extra space we allocated.
    pDwordBuf = (PDWORD)Buffer;

#if DBG
    *pDwordBuf = 0xCAFEBEAD;
#endif
        // skip past the unused dword (it's only use in life is to get the buffer quad-aligned!)
    pDwordBuf++;

	((PTAG)pDwordBuf)->tg_Size = Size;
	((PTAG)pDwordBuf)->tg_Tag = (PoolType == PagedPool) ? PGD_MEM_TAG : NPG_MEM_TAG;

#if DBG
	// Write the signature at the end
	*(PDWORD)((PBYTE)Buffer + Size - sizeof(DWORD)) = Signature;
#endif

#ifdef	TRACK_MEMORY_USAGE
	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
			("AfpAllocMemory: %lx Allocated %lx bytes @%lx\n",
			*(PDWORD)((PBYTE)(&Size) - sizeof(Size)), Size, Buffer));
	AfpTrackMemoryUsage(Buffer, True, (BOOLEAN)(PoolType == PagedPool), FileLine);
#endif

	// Return a pointer to the memory after the tag. Clear the memory, if requested
    //
    // We need the memory to be quad-aligned, so even though sizeof(TAG) is 4, we skip
    // LONGLONG..., which is 8.  The 1st dword is unused (for now?), the 2nd dword is the TAG

    Buffer += LONGLONGSIZEBLOCK(sizeof(TAG));

    Size -= LONGLONGSIZEBLOCK(sizeof(TAG));

	return Buffer;
}

/***	AfpFreeMemory
 *
 *	Free the block of memory allocated via AfpAllocMemory.
 *	This is a wrapper around ExFreePool.
 */
VOID FASTCALL
AfpFreeMemory(
	IN	PVOID	pBuffer
)
{
	BOOLEAN	Paged = False;
	DWORD	Size;
        DWORD   numDwords;
        PDWORD  pDwordBuf;
	PTAG	pTag;
        DWORD   i;
#ifdef	PROFILING
	TIME	TimeS1, TimeS2, TimeE, TimeD1, TimeD2;

	AfpGetPerfCounter(&TimeS1);
#endif


	//
	// Get a pointer to the block allocated by ExAllocatePool.
	//
	pTag = (PTAG)((PBYTE)pBuffer - sizeof(TAG));
	Size = pTag->tg_Size;

	if (pTag->tg_Tag == IO_POOL_TAG)
	{
		AfpIOFreeBuffer(pBuffer);
		return;
	}

	pBuffer = ((PBYTE)pBuffer - LONGLONGSIZEBLOCK(sizeof(TAG)));

	if (pTag->tg_Tag == PGD_MEM_TAG)
		Paged = True;

#if DBG
	{
		DWORD	Signature;

		// Check the signature at the end
		Signature = (Paged) ? PAGED_BLOCK_SIGNATURE : NONPAGED_BLOCK_SIGNATURE;

		if (*(PDWORD)((PBYTE)pBuffer + Size - sizeof(DWORD)) != Signature)
		{
			DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_FATAL,
					("AfpFreeMemory: Memory Overrun\n"));
			DBGBRK(DBG_LEVEL_FATAL);
			return;
		}
		// Clear the signature
		*(PDWORD)((PBYTE)pBuffer + Size - sizeof(DWORD)) -= 1;

        // change the memory so that we can catch weirdnesses like using freed memory
        numDwords = (Size/sizeof(DWORD));
        numDwords -= 3;                  // 2 dwords at the beginning and 1 at the end

        pDwordBuf = (PULONG)pBuffer;
        *pDwordBuf++ = 0xABABABAB;         // to indicate that it's freed!
        pDwordBuf++;                       // skip past the tag
        for (i=0; i<numDwords; i++,pDwordBuf++)
        {
            *pDwordBuf = 0x55667788;
        }
	}

#endif	// DBG

#ifdef	TRACK_MEMORY_USAGE
	AfpTrackMemoryUsage(pBuffer, False, Paged, 0);
#endif

	//
	// Update the pool usage statistic.
	//
	if (Paged)
	{
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_CurrPagedUsage,
							  (ULONG)(-(LONG)Size),
							  &AfpStatisticsLock);
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_PagedCount,
							  (ULONG)-1,
							  &AfpStatisticsLock);
	}
	else
	{
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_CurrNonPagedUsage,
							  (ULONG)(-(LONG)Size),
							  &AfpStatisticsLock);
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_NonPagedCount,
							  (ULONG)-1,
							  &AfpStatisticsLock);
	}

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeS2);
#endif

	// Free the pool and return.
	ExFreePool(pBuffer);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD2.QuadPart = TimeE.QuadPart - TimeS2.QuadPart;
	if (Paged)
	{
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_ExFreeCountP);
	
		INTERLOCKED_ADD_LARGE_INTGR(AfpServerProfile->perf_ExFreeTimeP,
									TimeD2,
									&AfpStatisticsLock);
		TimeD1.QuadPart = TimeE.QuadPart - TimeS1.QuadPart;
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_AfpFreeCountP);
	
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_AfpFreeTimeP,
									TimeD1,
									&AfpStatisticsLock);
	}
	else
	{
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_ExFreeCountN);
	
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_ExFreeTimeN,
									TimeD2,
									&AfpStatisticsLock);
		TimeD1.QuadPart = TimeE.QuadPart - TimeS1.QuadPart;
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_AfpFreeCountN);
	
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_AfpFreeTimeN,
									TimeD1,
									&AfpStatisticsLock);
	}
#endif
}


/***	AfpAllocPAMemory
 *
 *	Similar to AfpAllocMemory, except that this allocates page-aligned/page-granular memory.
 */
PBYTE FASTCALL
AfpAllocPAMemory(
#ifdef	TRACK_MEMORY_USAGE
	IN	LONG	Size,
	IN	DWORD	FileLine
#else
	IN	LONG	Size
#endif
)
{
	KIRQL		OldIrql;
	PBYTE		Buffer;
	DWORD		OldMaxUsage;
	POOL_TYPE	PoolType;
	PDWORD		pCurUsage, pMaxUsage, pCount, pLimit;
	BOOLEAN		PageAligned;
#if DBG
	DWORD		Signature;
#endif
#ifdef	PROFILING
	TIME		TimeS1, TimeS2, TimeE, TimeD;

	AfpGetPerfCounter(&TimeS1);
#endif

	ASSERT ((Size & ~MEMORY_TAG_MASK) < MAXIMUM_ALLOC_SIZE);

	ASSERT (((Size & ~MEMORY_TAG_MASK) % PAGE_SIZE) == 0);

	//
	// Make sure that this allocation will not put us over the limit
	// of paged/non-paged pool that we can allocate.
	//
	// Account for this allocation in the statistics database.

	if (Size & NON_PAGED_MEMORY_TAG)
	{
		PoolType  = NonPagedPool;
		pCurUsage = &AfpServerStatistics.stat_CurrNonPagedUsage;
		pMaxUsage = &AfpServerStatistics.stat_MaxNonPagedUsage;
		pCount    =	&AfpServerStatistics.stat_NonPagedCount;
		pLimit    = &AfpNonPagedPoolLimit;
#if DBG
		Signature = NONPAGED_BLOCK_SIGNATURE;
#endif
	}
	else
	{
		ASSERT (Size & PAGED_MEMORY_TAG);
		PoolType = PagedPool;
		pCurUsage = &AfpServerStatistics.stat_CurrPagedUsage;
		pMaxUsage = &AfpServerStatistics.stat_MaxPagedUsage;
		pCount    =	&AfpServerStatistics.stat_PagedCount;
		pLimit    = &AfpPagedPoolLimit;
#if DBG
		Signature = PAGED_BLOCK_SIGNATURE;
#endif
	}

	Size &= ~MEMORY_TAG_MASK;

	ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);

	*pCurUsage += Size;
	(*pCount) ++;

// apparently very old code, added to track some problem: not needed anymore
#if 0
#if DBG
	// Make sure that this allocation will not put us over the limit
	// of paged pool that we can allocate. ONLY FOR CHECKED BUILDS NOW.

	if (*pCurUsage > *pLimit)
	{
		*pCurUsage -= Size;

		DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_ERR,
				("afpAllocMemory: %sPaged Allocation exceeds limits %lx/%lx\n",
				(PoolType == NonPagedPool) ? "Non" : "", Size, *pLimit));

		RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

		DBGBRK(DBG_LEVEL_FATAL);

		AFPLOG_DDERROR((PoolType == PagedPool) ?
							AFPSRVMSG_PAGED_POOL : AFPSRVMSG_NONPAGED_POOL,
						STATUS_NO_MEMORY,
						NULL,
						0,
						NULL);

		return NULL;
	}
#endif
#endif  // #if 0

	OldMaxUsage = *pMaxUsage;
	if (*pCurUsage > *pMaxUsage)
		*pMaxUsage = *pCurUsage;

	RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeS2);
#endif

	// Do the actual memory allocation.
	if ((Buffer = ExAllocatePoolWithTag(PoolType, Size, AFP_TAG)) == NULL)
	{
		ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);

		*pCurUsage -= Size;
		*pMaxUsage = OldMaxUsage;

		RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);
		AFPLOG_DDERROR(AFPSRVMSG_PAGED_POOL, STATUS_NO_MEMORY, &Size,
					 sizeof(Size), NULL);
#if DBG
        DbgBreakPoint();
#endif
		return NULL;
	}
#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS2.QuadPart;
	INTERLOCKED_INCREMENT_LONG((PoolType == NonPagedPool) ?
									&AfpServerProfile->perf_ExAllocCountN :
									&AfpServerProfile->perf_ExAllocCountP);

	INTERLOCKED_ADD_LARGE_INTGR((PoolType == NonPagedPool) ?
									&AfpServerProfile->perf_ExAllocTimeN :
									&AfpServerProfile->perf_ExAllocTimeP,
								 TimeD,
								 &AfpStatisticsLock);

	TimeD.QuadPart = TimeE.QuadPart - TimeS1.QuadPart;
	INTERLOCKED_INCREMENT_LONG((PoolType == NonPagedPool) ?
									&AfpServerProfile->perf_AfpAllocCountN :
									&AfpServerProfile->perf_AfpAllocCountP);

	INTERLOCKED_ADD_LARGE_INTGR((PoolType == NonPagedPool) ?
									&AfpServerProfile->perf_AfpAllocTimeN :
									&AfpServerProfile->perf_AfpAllocTimeP,
								 TimeD,
								 &AfpStatisticsLock);
#endif

#ifdef	TRACK_MEMORY_USAGE
	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
			("AfpAllocMemory: %lx Allocated %lx bytes @%lx\n",
			*(PDWORD)((PBYTE)(&Size) - sizeof(Size)), Size, Buffer));
	AfpTrackMemoryUsage(Buffer, True, (BOOLEAN)(PoolType == PagedPool), FileLine);
#endif

	return Buffer;
}


/***	AfpFreePAMemory
 *
 *	Free the block of memory allocated via AfpAllocPAMemory.
 */
VOID FASTCALL
AfpFreePAMemory(
	IN	PVOID	pBuffer,
	IN	DWORD	Size
)
{
	BOOLEAN	Paged = True;
#ifdef	PROFILING
	TIME	TimeS1, TimeS2, TimeE, TimeD;

	AfpGetPerfCounter(&TimeS1);
#endif

	ASSERT ((Size & ~MEMORY_TAG_MASK) < MAXIMUM_ALLOC_SIZE);

	ASSERT (((Size & ~MEMORY_TAG_MASK) % PAGE_SIZE) == 0);

	if (Size & NON_PAGED_MEMORY_TAG)
		Paged = False;

#ifdef	TRACK_MEMORY_USAGE
	AfpTrackMemoryUsage(pBuffer, False, Paged, 0);
#endif

	//
	// Update the pool usage statistic.
	//
	Size &= ~(NON_PAGED_MEMORY_TAG | PAGED_MEMORY_TAG);
	if (Paged)
	{
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_CurrPagedUsage,
							  (ULONG)(-(LONG)Size),
							  &AfpStatisticsLock);
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_PagedCount,
							  (ULONG)-1,
							  &AfpStatisticsLock);
	}
	else
	{
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_CurrNonPagedUsage,
							  (ULONG)(-(LONG)Size),
							  &AfpStatisticsLock);
		INTERLOCKED_ADD_ULONG(&AfpServerStatistics.stat_NonPagedCount,
							  (ULONG)-1,
							  &AfpStatisticsLock);
	}

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeS2);
#endif

	// Free the pool and return.
	ExFreePool(pBuffer);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS2.QuadPart;
	INTERLOCKED_INCREMENT_LONG( Paged ?
									&AfpServerProfile->perf_ExFreeCountP :
									&AfpServerProfile->perf_ExFreeCountN);

	INTERLOCKED_ADD_LARGE_INTGR(Paged ?
									&AfpServerProfile->perf_ExFreeTimeP :
									&AfpServerProfile->perf_ExFreeTimeN,
								 TimeD,
								 &AfpStatisticsLock);
	TimeD1.QuadPart = TimeE.QuadPart - TimeS1.QuadPart;
	INTERLOCKED_INCREMENT_LONG( Paged ?
									&AfpServerProfile->perf_AfpFreeCountP :
									&AfpServerProfile->perf_AfpFreeCountN);

	INTERLOCKED_ADD_LARGE_INTGR(Paged ?
									&AfpServerProfile->perf_AfpFreeTimeP :
									&AfpServerProfile->perf_AfpFreeTimeN,
								 TimeD,
								 &AfpStatisticsLock);
#endif
}


/***	AfpAllocIrp
 *
 *	This is a wrapper over IoAllocateIrp. We also do some book-keeping.
 */
PIRP FASTCALL
AfpAllocIrp(
	IN CCHAR StackSize
)
{
	PIRP	pIrp;

	if ((pIrp = IoAllocateIrp(StackSize, False)) == NULL)
	{
		DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
				("afpAllocIrp: Allocation failed\n"));
        if (KeGetCurrentIrql() < DISPATCH_LEVEL)
        {
		    AFPLOG_ERROR(AFPSRVMSG_ALLOC_IRP, STATUS_INSUFFICIENT_RESOURCES,
					 NULL, 0, NULL);
        }
	}
    else
    {
#ifdef	PROFILING
	    INTERLOCKED_INCREMENT_LONG((PLONG)&AfpServerProfile->perf_cAllocatedIrps);
#endif
        AFP_DBG_INC_COUNT(AfpDbgIrpsAlloced);
    }

	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
							("AfAllocIrp: Allocated Irp %lx\n", pIrp));
	return pIrp;
}


/***	AfpFreeIrp
 *
 *	This is a wrapper over IoFreeIrp. We also do some book-keeping.
 */
VOID FASTCALL
AfpFreeIrp(
	IN	PIRP	pIrp
)
{
	ASSERT (pIrp != NULL);

	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
							("AfFreeIrp: Freeing Irp %lx\n", pIrp));
	IoFreeIrp(pIrp);

    AFP_DBG_DEC_COUNT(AfpDbgIrpsAlloced);

#ifdef	PROFILING
	INTERLOCKED_DECREMENT_LONG((PLONG)&AfpServerProfile->perf_cAllocatedIrps);
#endif
}


/***	AfpAllocMdl
 *
 *	This is a wrapper over IoAllocateMdl. We also do some book-keeping.
 */
PMDL FASTCALL
AfpAllocMdl(
	IN	PVOID	pBuffer,
	IN	DWORD	Size,
	IN	PIRP	pIrp
)
{
	PMDL	pMdl;

	if ((pMdl = IoAllocateMdl(pBuffer, Size, False, False, pIrp)) == NULL)
	{
		DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
				("AfpAllocMdl: Allocation failed\n"));
		AFPLOG_ERROR(AFPSRVMSG_ALLOC_MDL, STATUS_INSUFFICIENT_RESOURCES,
					 NULL, 0, NULL);
	}
	else
	{
#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG((PLONG)&AfpServerProfile->perf_cAllocatedMdls);
#endif
        AFP_DBG_INC_COUNT(AfpDbgMdlsAlloced);
		MmBuildMdlForNonPagedPool(pMdl);
	}

	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
							("AfAllocMdl: Allocated Mdl %lx\n", pMdl));
	return pMdl;
}


/***	AfpFreeMdl
 *
 *	This is a wrapper over IoFreeMdl. We also do some book-keeping.
 */
VOID FASTCALL
AfpFreeMdl(
	IN	PMDL	pMdl
)
{
	ASSERT (pMdl != NULL);

	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
							("AfFreeMdl: Freeing Mdl %lx\n", pMdl));
	IoFreeMdl(pMdl);
    AFP_DBG_DEC_COUNT(AfpDbgMdlsAlloced);

#ifdef	PROFILING
	INTERLOCKED_DECREMENT_LONG((PLONG)&AfpServerProfile->perf_cAllocatedMdls);
#endif
}



/***	AfpMdlChainSize
 *
 *	This routine counts the bytes in the mdl chain
 */
DWORD FASTCALL
AfpMdlChainSize(
	IN	PMDL    pMdl
)
{
    DWORD   dwSize=0;

    while (pMdl)
    {
        dwSize += MmGetMdlByteCount(pMdl);
        pMdl = pMdl->Next;
    }

	return (dwSize);
}


/***	AfpIOAllocBuffer
 *
 *	Maintain a pool of I/O buffers and fork-locks. These are aged out when not in use.
 */
PVOID FASTCALL
AfpIOAllocBuffer(
	IN	DWORD  	BufSize
)
{
	KIRQL		OldIrql;
	PIOPOOL		pPool;
	PIOPOOL_HDR	pPoolHdr, *ppPoolHdr;
	BOOLEAN		Found = False;
	PVOID		pBuf = NULL;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;

	INTERLOCKED_INCREMENT_LONG( &AfpServerProfile->perf_BPAllocCount );

	AfpGetPerfCounter(&TimeS);
#endif

	ASSERT (BufSize <= (DSI_SERVER_REQUEST_QUANTUM+DSI_HEADER_SIZE));

	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
			("AfpIOAllocBuffer: Request for %d\n", BufSize));

    //
    // if a large block (over 4K on x86) is being allocated, we don't want to
    // tie it in in the IoPool.  Do a direct allocation, set flags etc. so we know
    // how to free it when it's freed
    //
    if (BufSize > ASP_QUANTUM)
    {
		pPoolHdr = (PIOPOOL_HDR) ExAllocatePoolWithTag(
                                    NonPagedPool,
                                    (BufSize + sizeof(IOPOOL_HDR)),
                                    AFP_TAG);
        if (pPoolHdr == NULL)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("AfpIOAllocBuffer: big buf alloc (%d bytes) failed!\n",BufSize));

            return(NULL);
        }

#if	DBG
	    pPoolHdr->Signature = POOLHDR_SIGNATURE;
#endif
	    pPoolHdr->iph_Tag.tg_Tag = IO_POOL_TAG;
        pPoolHdr->iph_Tag.tg_Flags = IO_POOL_HUGE_BUFFER;

        // we only have 20 bits for tg_Size, so the size had better be less than that!
        ASSERT(BufSize <= 0xFFFFF);

        pPoolHdr->iph_Tag.tg_Size = BufSize;

        return((PVOID)((PBYTE)pPoolHdr + sizeof(IOPOOL_HDR)));
    }


	ACQUIRE_SPIN_LOCK(&afpIoPoolLock, &OldIrql);

  try_again:
	for (pPool = afpIoPoolHead;
		 pPool != NULL;
		 pPool = pPool->iop_Next)
	{
		ASSERT(VALID_IOP(pPool));

		if (BufSize > sizeof(FORKLOCK))
		{
			if (pPool->iop_NumFreeBufs > 0)
			{
				LONG	i;

				for (i = 0, ppPoolHdr = &pPool->iop_FreeBufHead;
					 (i < pPool->iop_NumFreeBufs);
					 ppPoolHdr = &pPoolHdr->iph_Next, i++)
				{
					pPoolHdr = *ppPoolHdr;
					ASSERT(VALID_PLH(pPoolHdr));

					if (pPoolHdr->iph_Tag.tg_Size >= BufSize)
					{
						DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
								("AfpIOAllocBuffer: Found space (bufs) in pool %lx\n", pPool));
						ASSERT (pPoolHdr->iph_Tag.tg_Flags == IO_POOL_NOT_IN_USE);
						*ppPoolHdr = pPoolHdr->iph_Next;
						INTERLOCKED_INCREMENT_LONG((PLONG)&AfpServerStatistics.stat_IoPoolHits);

						Found = True;
						break;
					}
				}
				if (Found)
					break;
			}
		}
		else if (pPool->iop_NumFreeLocks > 0)
		{
			// Even IO buffers for size <= sizeof(FORKLOCK) are allocated out of the
			// lock pool - hey why not !!!
			pPoolHdr = pPool->iop_FreeLockHead;
			ASSERT(VALID_PLH(pPoolHdr));

			ASSERT(pPoolHdr->iph_Tag.tg_Flags == IO_POOL_NOT_IN_USE);
			pPool->iop_FreeLockHead = pPoolHdr->iph_Next;
			DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
					("AfpIOAllocBuffer: Found space (locks) in pool %lx\n", pPool));
			INTERLOCKED_INCREMENT_LONG((PLONG)&AfpServerStatistics.stat_IoPoolHits);
						
			Found = True;
			break;
		}

		// All empty pool blocks are the end.
		if ((pPool->iop_NumFreeBufs == 0) && (pPool->iop_NumFreeLocks == 0))
		{
			break;
		}
	}

	if (!Found)
	{
		INTERLOCKED_INCREMENT_LONG((PLONG)&AfpServerStatistics.stat_IoPoolMisses);
					
		// If we failed to find it, allocate a new pool chunk, initialize and
		// link it in
		pPool = (PIOPOOL)AfpAllocNonPagedMemory(POOL_ALLOC_SIZE);
		DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
				("AfpIOAllocBuffer: No free slot, allocated a new pool %lx\n", pPool));

		if (pPool != NULL)
		{
			LONG	i;
			PBYTE	p;

#if	DBG
			pPool->Signature = IOPOOL_SIGNATURE;
#endif
			pPool->iop_NumFreeBufs = NUM_BUFS_IN_POOL;
			pPool->iop_NumFreeLocks = (BYTE)NUM_LOCKS_IN_POOL;
			AfpLinkDoubleAtHead(afpIoPoolHead, pPool, iop_Next, iop_Prev);
			p = (PBYTE)pPool + sizeof(IOPOOL);
            pPool->iop_FreeBufHead =  (PIOPOOL_HDR)p;

			// Initialize pool of buffers and locks
			for (i = 0, pPoolHdr = pPool->iop_FreeBufHead;
				 i < (NUM_BUFS_IN_POOL + NUM_LOCKS_IN_POOL);
				 i++)
			{
#if	DBG
				pPoolHdr->Signature = POOLHDR_SIGNATURE;
#endif
				pPoolHdr->iph_Tag.tg_Flags = IO_POOL_NOT_IN_USE;		// Mark it un-used
				pPoolHdr->iph_Tag.tg_Tag = IO_POOL_TAG;
				if (i < NUM_BUFS_IN_POOL)
				{
					p += sizeof(IOPOOL_HDR) + (pPoolHdr->iph_Tag.tg_Size = afpPoolAllocSizes[i]);
					if (i == (NUM_BUFS_IN_POOL-1))
					{
						pPoolHdr->iph_Next = NULL;
						pPoolHdr = pPool->iop_FreeLockHead =  (PIOPOOL_HDR)p;
					}
                    else
					{
						pPoolHdr->iph_Next = (PIOPOOL_HDR)p;
						pPoolHdr = (PIOPOOL_HDR)p;
					}
				}
				else
				{
					pPoolHdr->iph_Tag.tg_Size = sizeof(FORKLOCK);
					p += (sizeof(IOPOOL_HDR) + sizeof(FORKLOCK));
					if (i == (NUM_BUFS_IN_POOL+NUM_LOCKS_IN_POOL-1))
					{
						pPoolHdr->iph_Next = NULL;

					}
					else
					{
						pPoolHdr->iph_Next = (PIOPOOL_HDR)p;
						pPoolHdr = (PIOPOOL_HDR)p;

					}
				}
			}

			// Adjust this since we'll increment this again up above. This was
			// really a miss and not a hit
			INTERLOCKED_DECREMENT_LONG((PLONG)&AfpServerStatistics.stat_IoPoolHits);
						
			goto try_again;
		}
	}

	if (Found)
	{
		PIOPOOL	pTmp;

		ASSERT(VALID_IOP(pPool));
		ASSERT(VALID_PLH(pPoolHdr));

		pPoolHdr->iph_pPool = pPool;
		pPoolHdr->iph_Tag.tg_Flags = IO_POOL_IN_USE;		// Mark it used
		pPool->iop_Age = 0;
		pBuf = (PBYTE)pPoolHdr + sizeof(IOPOOL_HDR);
		if (BufSize > sizeof(FORKLOCK))
		{
			pPool->iop_NumFreeBufs --;
		}
		else
		{
			pPool->iop_NumFreeLocks --;
		}

		// If the block is now empty, unlink it from here and move it
		// to the first empty slot. We know that all blocks 'earlier' than
		// this are non-empty.
		if ((pPool->iop_NumFreeBufs == 0) &&
	        (pPool->iop_NumFreeLocks == 0) &&
			((pTmp = pPool->iop_Next) != NULL) &&
			((pTmp->iop_NumFreeBufs > 0) || (pTmp->iop_NumFreeLocks > 0)))
		{
			ASSERT(VALID_IOP(pTmp));

			AfpUnlinkDouble(pPool, iop_Next, iop_Prev);
			for (; pTmp != NULL; pTmp = pTmp->iop_Next)
			{
				if (pTmp->iop_NumFreeBufs == 0)
				{
					// Found a free one. Park it right here.
					AfpInsertDoubleBefore(pPool, pTmp, iop_Next, iop_Prev);
					break;
				}
				else if (pTmp->iop_Next == NULL)	// We reached the end
				{
					AfpLinkDoubleAtEnd(pPool, pTmp, iop_Next, iop_Prev);
					break;
				}
			}
		}
	}

	RELEASE_SPIN_LOCK(&afpIoPoolLock, OldIrql);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_BPAllocTime,
								TimeD,
								&AfpStatisticsLock);
#endif

	return pBuf;
}


/***	AfpIOFreeBuffer
 *
 *	Return the IO buffer to the pool. Reset its age to 0. Insert into the free list
 *	in ascending order of sizes for bufs and at the head for locks
 */
VOID FASTCALL
AfpIOFreeBuffer(
	IN	PVOID	pBuf
)
{
	KIRQL		OldIrql;
	PIOPOOL		pPool;
	PIOPOOL_HDR	pPoolHdr, *ppPoolHdr;
#ifdef	PROFILING
	TIME			TimeS, TimeE, TimeD;

	INTERLOCKED_INCREMENT_LONG( &AfpServerProfile->perf_BPFreeCount);
				
	AfpGetPerfCounter(&TimeS);
#endif

	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
			("AfpIOFreeBuffer: Freeing %lx\n", pBuf));

	pPoolHdr = (PIOPOOL_HDR)((PBYTE)pBuf - sizeof(IOPOOL_HDR));
	ASSERT(VALID_PLH(pPoolHdr));
	ASSERT (pPoolHdr->iph_Tag.tg_Flags != IO_POOL_NOT_IN_USE);
	ASSERT (pPoolHdr->iph_Tag.tg_Tag == IO_POOL_TAG);

    //
    // if this is a huge buffer we allocated, free it here and return
    //
    if (pPoolHdr->iph_Tag.tg_Flags == IO_POOL_HUGE_BUFFER)
    {
        ASSERT(pPoolHdr->iph_Tag.tg_Size > ASP_QUANTUM);

        ExFreePool((PVOID)pPoolHdr);
        return;
    }

	pPool = pPoolHdr->iph_pPool;
	ASSERT(VALID_IOP(pPool));

	ACQUIRE_SPIN_LOCK(&afpIoPoolLock, &OldIrql);

	if (pPoolHdr->iph_Tag.tg_Size > sizeof(FORKLOCK))
	{
		ASSERT (pPool->iop_NumFreeBufs < NUM_BUFS_IN_POOL);

		for (ppPoolHdr = &pPool->iop_FreeBufHead;
			 (*ppPoolHdr) != NULL;
			 ppPoolHdr = &(*ppPoolHdr)->iph_Next)
		{
			ASSERT(VALID_PLH(*ppPoolHdr));
			if ((*ppPoolHdr)->iph_Tag.tg_Size > pPoolHdr->iph_Tag.tg_Size)
			{
				DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
						("AfpIOFreeBuffer: Found slot for %lx (%lx)\n",
						pBuf, pPool));
				break;
			}
		}
		pPoolHdr->iph_Next = (*ppPoolHdr);
		*ppPoolHdr = pPoolHdr;
		pPool->iop_NumFreeBufs ++;
	}
	else
	{
		ASSERT (pPool->iop_NumFreeLocks < NUM_LOCKS_IN_POOL);

		pPoolHdr->iph_Next = pPool->iop_FreeLockHead;
        pPool->iop_FreeLockHead = pPoolHdr;
		pPool->iop_NumFreeLocks ++;
	}

	pPoolHdr->iph_Tag.tg_Flags = IO_POOL_NOT_IN_USE;		// Mark it un-used

	// If this block's status is changing from a 'none available' to 'available'
	// move him to the head of the list.
	if ((pPool->iop_NumFreeBufs + pPool->iop_NumFreeLocks) == 1)
	{
		AfpUnlinkDouble(pPool, iop_Next, iop_Prev);
		AfpLinkDoubleAtHead(afpIoPoolHead,
							pPool,
							iop_Next,
							iop_Prev);
	}

	RELEASE_SPIN_LOCK(&afpIoPoolLock, OldIrql);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_BPFreeTime,
								TimeD,
								&AfpStatisticsLock);
#endif
}


/***	afpIoPoolAge
 *
 *	Scavenger worker for aging out the IO pool.
 */
LOCAL AFPSTATUS FASTCALL
afpIoPoolAge(
	IN	PVOID	pContext
)
{
	PIOPOOL	pPool;

	DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_INFO,
			("afpIOPoolAge: Entered\n"));

	ACQUIRE_SPIN_LOCK_AT_DPC(&afpIoPoolLock);

	for (pPool = afpIoPoolHead;
		 pPool != NULL;
		 NOTHING)
	{
		PIOPOOL	pFree;

		ASSERT(VALID_IOP(pPool));

		pFree = pPool;
		pPool = pPool->iop_Next;

		// Since all blocks which are completely used up are at the tail end of
		// the list, if we encounter one, we are done.
		if ((pFree->iop_NumFreeBufs == 0) &&
	        (pFree->iop_NumFreeLocks == 0))
			break;

		if ((pFree->iop_NumFreeBufs == NUM_BUFS_IN_POOL) &&
			(pFree->iop_NumFreeLocks == NUM_LOCKS_IN_POOL))
		{
			DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_WARN,
					("afpIOPoolAge: Aging pool %lx\n", pFree));
			if (++(pFree->iop_Age) >= MAX_POOL_AGE)
			{
#ifdef	PROFILING
				INTERLOCKED_INCREMENT_LONG( &AfpServerProfile->perf_BPAgeCount);
#endif
				DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_WARN,
						("afpIOPoolAge: Freeing pool %lx\n", pFree));
				AfpUnlinkDouble(pFree, iop_Next, iop_Prev);
				AfpFreeMemory(pFree);
			}
		}
	}

	RELEASE_SPIN_LOCK_FROM_DPC(&afpIoPoolLock);

	return AFP_ERR_REQUEUE;
}


#ifdef	TRACK_MEMORY_USAGE

#define	MAX_PTR_COUNT	4*1024
#define	MAX_MEM_USERS	256
LOCAL	struct _MemPtr
{
	PVOID	mptr_Ptr;
	DWORD	mptr_FileLine;
} afpMemPtrs[MAX_PTR_COUNT] = { 0 };

typedef	struct
{
	ULONG	mem_FL;
	ULONG	mem_Count;
} MEM_USAGE, *PMEM_USAGE;

LOCAL	MEM_USAGE	afpMemUsageNonPaged[MAX_MEM_USERS] = {0};
LOCAL	MEM_USAGE	afpMemUsagePaged[MAX_MEM_USERS] = {0};

LOCAL	AFP_SPIN_LOCK		afpMemTrackLock = {0};

/***	AfpTrackMemoryUsage
 *
 *	Keep track of memory usage by storing and clearing away pointers as and
 *	when they are allocated or freed. This helps in keeping track of memory
 *	leaks.
 *
 *	LOCKS:	AfpMemTrackLock (SPIN)
 */
VOID
AfpTrackMemoryUsage(
	IN	PVOID	pMem,
	IN	BOOLEAN	Alloc,
	IN	BOOLEAN	Paged,
	IN	ULONG	FileLine
)
{
	KIRQL			OldIrql;
	static	int		i = 0;
	PMEM_USAGE		pMemUsage;
	int				j, k;

	pMemUsage = afpMemUsageNonPaged;
	if (Paged)
		pMemUsage = afpMemUsagePaged;

	ACQUIRE_SPIN_LOCK(&afpMemTrackLock, &OldIrql);

	if (Alloc)
	{
		for (j = 0; j < MAX_PTR_COUNT; i++, j++)
		{
			i = i & (MAX_PTR_COUNT-1);
			if (afpMemPtrs[i].mptr_Ptr == NULL)
			{
				afpMemPtrs[i].mptr_FileLine = FileLine;
				afpMemPtrs[i++].mptr_Ptr = pMem;
				break;
			}
		}
		for (k = 0; k < MAX_MEM_USERS; k++)
		{
			if (pMemUsage[k].mem_FL == FileLine)
			{
				pMemUsage[k].mem_Count ++;
				break;
			}
		}
		if (k == MAX_MEM_USERS)
		{
			for (k = 0; k < MAX_MEM_USERS; k++)
			{
				if (pMemUsage[k].mem_FL == 0)
				{
					pMemUsage[k].mem_FL = FileLine;
					pMemUsage[k].mem_Count = 1;
					break;
				}
			}
		}
		if (k == MAX_MEM_USERS)
		{
			DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_ERR,
				("AfpTrackMemoryUsage: Out of space on afpMemUsage !!!\n"));
			DBGBRK(DBG_LEVEL_FATAL);
		}
	}
	else
	{
		for (j = 0, k = i; j < MAX_PTR_COUNT; j++, k--)
		{
			k = k & (MAX_PTR_COUNT-1);
			if (afpMemPtrs[k].mptr_Ptr == pMem)
			{
				afpMemPtrs[k].mptr_Ptr = NULL;
				afpMemPtrs[k].mptr_FileLine = 0;
				break;
			}
		}
	}

	RELEASE_SPIN_LOCK(&afpMemTrackLock, OldIrql);

	if (j == MAX_PTR_COUNT)
	{
		DBGPRINT(DBG_COMP_MEMORY, DBG_LEVEL_ERR,
			("AfpTrackMemoryUsage: (%lx) %s\n",
			FileLine, Alloc ? "Table Full" : "Can't find"));
	}
}

#endif	// TRACK_MEMORY_USAGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\swmr.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	swmr.h

Abstract:

	This module contains the Single writer-Multi reader access structures
	Also the lock-list-count structures.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _SWMR_
#define _SWMR_

#if DBG
#define	SWMR_SIGNATURE		*(DWORD *)"SWMR"
#define	VALID_SWMR(pSwmr)	(((pSwmr) != NULL) && \
							 ((pSwmr)->Signature == SWMR_SIGNATURE))
#else
#define	VALID_SWMR(pSwmr)	((pSwmr) != NULL)
#endif

#define SWMR_SOMEONE_WAITING( _pSwmr ) ((_pSwmr)->swmr_cExclWaiting || \
                                        (_pSwmr)->swmr_cSharedWaiting)
typedef struct _SingleWriterMultiReader
{
#if	DBG
	DWORD		Signature;
#endif
	BYTE		swmr_cOwnedExclusive;	// # of times a single thread has owned it exclusively
	BYTE		swmr_cExclWaiting;		// Number of writers waiting
	BYTE		swmr_cSharedOwners;		// Count of threads owning shared access
	BYTE		swmr_cSharedWaiting;	// Count of threads waiting for shared access
	PETHREAD	swmr_ExclusiveOwner;	// Owning thread for exclusive access
	KSEMAPHORE	swmr_ExclSem;			// semaphore for Exclusive owners
	KSEMAPHORE	swmr_SharedSem;			// Semaphore for Shared owners
} SWMR, *PSWMR;

extern
VOID FASTCALL
AfpSwmrInitSwmr(
	IN OUT	PSWMR	pSwmr
);

extern
VOID FASTCALL
AfpSwmrAcquireShared(
	IN	PSWMR	pSwmr
);

VOID FASTCALL
AfpSwmrAcquireExclusive(
	IN	PSWMR	pSwmr
);

extern
VOID FASTCALL
AfpSwmrRelease(
	IN	PSWMR	pSwmr
);

extern
BOOLEAN FASTCALL
AfpSwmrUpgradeToExclusive(
	IN	PSWMR	pSwmr
);

extern
VOID FASTCALL
AfpSwmrDowngradeToShared(
	IN	PSWMR	pSwmr
);

#define	AfpSwmrLockedShared(pSwmr)		\
					(((pSwmr)->swmr_cSharedOwners != 0) && \
					 ((pSwmr)->swmr_cOwnedExclusive == 0))
										
#define	AfpSwmrLockedExclusive(pSwmr)	\
					(((pSwmr)->swmr_cOwnedExclusive != 0) && \
					 ((pSwmr)->swmr_ExclusiveOwner == PsGetCurrentThread()))

#endif	// _SWMR_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\server.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	server.c

Abstract:

	This module contains server global data and server init code.
	This is used by the admin interface to start-off the server.


Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	_GLOBALS_
#define	SERVER_LOCALS
#define	FILENUM	FILE_SERVER

#include <seposix.h>
#include <afp.h>
#include <afpadmin.h>
#include <access.h>
#include <client.h>
#include <tcp.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfpInitializeDataAndSubsystems)
#pragma alloc_text( PAGE, AfpDeinitializeSubsystems)
#pragma alloc_text( PAGE, AfpAdmSystemShutdown)
#pragma alloc_text( PAGE, AfpCreateNewThread)
#pragma alloc_text( PAGE_AFP, AfpAdmWServerSetInfo)
//#pragma alloc_text( PAGE_AFP, AfpSetServerStatus)
#endif

// This is the device handle to the stack.
BOOLEAN	            afpSpNameRegistered = False;
HANDLE				afpSpAddressHandle = NULL;
PDEVICE_OBJECT		afpSpAppleTalkDeviceObject = NULL;
PFILE_OBJECT		afpSpAddressObject = NULL;
LONG				afpSpNumOutstandingReplies = 0;

/***	AfpInitializeDataAndSubsystems
 *
 *	Initialize Server Data and all subsystems.
 */
NTSTATUS
AfpInitializeDataAndSubsystems(
	VOID
)
{
	NTSTATUS		Status;
    PBYTE           pBuffer;
    PBYTE           pDest;
	LONG			i, j;

	// Initialize various global locks
	INITIALIZE_SPIN_LOCK(&AfpServerGlobalLock);
	INITIALIZE_SPIN_LOCK(&AfpSwmrLock);
	INITIALIZE_SPIN_LOCK(&AfpStatisticsLock);

#if DBG
	INITIALIZE_SPIN_LOCK(&AfpDebugSpinLock);
    InitializeListHead(&AfpDebugDelAllocHead);
#endif

	KeInitializeEvent(&AfpStopConfirmEvent, NotificationEvent, False);
	KeInitializeMutex(&AfpPgLkMutex, 0xFFFF);
	AfpInitializeWorkItem(&AfpTerminateThreadWI, NULL, NULL);

	// The default security quality of service
	AfpSecurityQOS.Length = sizeof(AfpSecurityQOS);
	AfpSecurityQOS.ImpersonationLevel = SecurityImpersonation;
	AfpSecurityQOS.ContextTrackingMode = SECURITY_STATIC_TRACKING;
	AfpSecurityQOS.EffectiveOnly = False;

	// Timeout(s) value used by AfpIoWait
	FiveSecTimeOut.QuadPart = (-5*NUM_100ns_PER_SECOND);
	ThreeSecTimeOut.QuadPart = (-3*NUM_100ns_PER_SECOND);
	TwoSecTimeOut.QuadPart = (-2*NUM_100ns_PER_SECOND);
	OneSecTimeOut.QuadPart = (-1*NUM_100ns_PER_SECOND);

	// Default Type Creator. Careful with the initialization here.This has
	// to be processor independent
	AfpSwmrInitSwmr(&AfpEtcMapLock);
	PUTBYTE42BYTE4(&AfpDefaultEtcMap.etc_type, AFP_DEFAULT_ETC_TYPE);
	PUTBYTE42BYTE4(&AfpDefaultEtcMap.etc_creator, AFP_DEFAULT_ETC_CREATOR);
	PUTBYTE42BYTE4(&AfpDefaultEtcMap.etc_extension, AFP_DEFAULT_ETC_EXT);

	// Determine if the machine is little or big endian. This is not currently used
	// at all. The idea is to maintain all on-disk databases in little-endian
	// format and on big-endian machines, convert on the way-in and out.
	i = 0x01020304;
	AfpIsMachineLittleEndian = (*(BYTE *)(&i) == 0x04);
	AfpServerState = AFP_STATE_IDLE;
	AfpServerOptions = AFP_SRVROPT_NONE;
    AfpServerMaxSessions = AFP_MAXSESSIONS;

	AfpGetCurrentTimeInMacFormat((PAFPTIME)&AfpServerStatistics.stat_TimeStamp);

    //AfpGetCurrentTimeInMacFormat(&AfpSrvrNotifSentTime);

    // generate a "unique" signature for our server
    pDest = &AfpServerSignature[0];
    for (i=0; i<2; i++)
    {
        pBuffer = AfpGetChallenge();
        if (pBuffer)
        {
		    RtlCopyMemory(pDest, pBuffer, MSV1_0_CHALLENGE_LENGTH);
            pDest += MSV1_0_CHALLENGE_LENGTH;
            AfpFreeMemory(pBuffer);
        }
    }

#ifdef	PROFILING
	// Allocate this directly since AfpAllocMemory() uses AfpServerProfile !!!
	if ((AfpServerProfile = (PAFP_PROFILE_INFO)ExAllocatePoolWithTag(NonPagedPool,
																	 sizeof(AFP_PROFILE_INFO),
																	 AFP_TAG)) == NULL)
		return STATUS_INSUFFICIENT_RESOURCES;
	RtlZeroMemory(AfpServerProfile, sizeof(AFP_PROFILE_INFO));
	KeQueryPerformanceCounter(&AfpServerProfile->perf_PerfFreq);
#endif

    AfpInitStrings();

	// Initialize the sub-systems
	for (i = 0; i < NUM_INIT_SYSTEMS; i++)
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("AfpInitializeDataAndSubsystems: Initializing s\n",
			AfpInitSubSystems[i].InitRoutineName));

		if (AfpInitSubSystems[i].InitRoutine != NULL)
		{
			Status = (*AfpInitSubSystems[i].InitRoutine)();
			if (!NT_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
					("AfpInitializeDataAndSubsystems: %s failed %lx\n",
					AfpInitSubSystems[i].InitRoutineName, Status));

				// One of the subsystems failed to initialize. Deinitialize all
				// of them which succeeded.
				for (j = 0; j < i; j++)
				{
					if (AfpInitSubSystems[j].DeInitRoutine != NULL)
					{
						DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
								("AfpInitializeDataAndSubsystems: Deinitializing %s\n",
								AfpInitSubSystems[j].DeInitRoutineName));
						(*AfpInitSubSystems[j].DeInitRoutine)();
					}
#if DBG
					AfpInitSubSystems[j].Deinitialized = True;
#endif
				}
				return Status;
			}
#if DBG
			AfpInitSubSystems[i].Initialized = True;
#endif
		}
	}

	return STATUS_SUCCESS;
}



/***	AfpDeinitializeSubsystems
 *
 *	De-initialize all subsystems.
 */
VOID
AfpDeinitializeSubsystems(
	VOID
)
{
	LONG	i;

	PAGED_CODE( );

	// De-initialize the sub-systems
	for (i = 0; i < NUM_INIT_SYSTEMS; i++)
	{
		if (AfpInitSubSystems[i].DeInitRoutine != NULL)
		{
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
					("AfpDeinitializeDataAndSubsystems: Deinitializing %s\n",
					AfpInitSubSystems[i].DeInitRoutineName));
			(*AfpInitSubSystems[i].DeInitRoutine)();
		}
#if DBG
		AfpInitSubSystems[i].Deinitialized = True;
#endif
	}
}


/***	AfpSetServerStatus
 *
 *	Set the Server status block via afpSpSetStatus. This is called in once at
 *	server startup and anytime a change in server status makes this necessary.
 *	By now, ServerSetInfo() has happened and it has been validated that all
 *	paramters are kosher.
 *
 *	LOCKS:	AfpServerGlobalLock (SPIN)
 */
AFPSTATUS
AfpSetServerStatus(
    IN VOID
)
{
	KIRQL		OldIrql;
	AFPSTATUS	Status=STATUS_SUCCESS;
	AFPSTATUS	Status2;
	struct _StatusHeader
	{
		BYTE  	_MachineString[2];	// These are offsets relative to the struct
		BYTE  	_AfpVersions[2];	// ---------- do ------------
		BYTE  	_UAMs[2];			// ---------- do ------------
		BYTE  	_VolumeIcon[2];		// ---------- do ------------
		BYTE  	_Flags[2];			// Server Flags
						// The actual strings start here
	} *pStatusHeader;
	PASCALSTR	pStr;
    PBYTE       pNumUamPtr;
	LONG		Size;
	USHORT		Flags;
	BOOLEAN		GuestAllowed = False,
				ClearTextAllowed = False,
                NativeAppleUamSupported = False,
                MicrosoftUamSupported = False,
				AllowSavePass = False;
	BYTE		CountOfUams;
    PBYTE       pSignOffset;
    PBYTE       pNetAddrOffset;
	DWORD       IpAddrCount=0;
    PBYTE       IpAddrBlob=NULL;
    NTSTATUS    ntStatus;


	// Assert that all the info that we can possibly stuff in can indeed fit
	// in the buffer that we'll allocate

	// Allocate a buffer to fill the status information in. This will be
	// freed by AfpSpSetStatus(), this can be freed. We do not know up front
	// how much we'll need. Err on the safe side
	if ((pStatusHeader = (struct _StatusHeader *)
				AfpAllocZeroedNonPagedMemory(ASP_MAX_STATUS_BUF)) == NULL)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

    //
    // first, find out if we have any TCPIP addresses
    //
    ntStatus = DsiGetIpAddrBlob(&IpAddrCount, &IpAddrBlob);
    if (!NT_SUCCESS(ntStatus))
    {
        AfpFreeMemory(pStatusHeader);

        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("AfpSetServerStatus: DsiGetIpAddrBlob failed %lx\n",ntStatus));
		return STATUS_INSUFFICIENT_RESOURCES;
    }

	ACQUIRE_SPIN_LOCK(&AfpServerGlobalLock, &OldIrql);

	GuestAllowed = (AfpServerOptions & AFP_SRVROPT_GUESTLOGONALLOWED) ?
											 True : False;

	ClearTextAllowed = (AfpServerOptions & AFP_SRVROPT_CLEARTEXTLOGONALLOWED) ?
											 True : False;

    MicrosoftUamSupported = (AfpServerOptions & AFP_SRVROPT_MICROSOFT_UAM)?
                                             True : False;

    NativeAppleUamSupported = (AfpServerOptions & AFP_SRVROPT_NATIVEAPPLEUAM) ?
                                             True : False;

    if (!ClearTextAllowed && !MicrosoftUamSupported && !NativeAppleUamSupported)
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
	        ("AfpSetServerStatus: got to enable at least one UAM! Failing request\n"));

	    RELEASE_SPIN_LOCK(&AfpServerGlobalLock, OldIrql);
        AfpFreeMemory(pStatusHeader);
        if (IpAddrBlob)
        {
            AfpFreeMemory(IpAddrBlob);
        }
        return(STATUS_INVALID_PARAMETER);
    }

	Size = sizeof(struct _StatusHeader) +		// Status header
		   AfpServerName.Length + 1 + 			// Server Name
		   AFP_MACHINE_TYPE_LEN + 1 +			// Machine String
		   AfpVersion20.Length + 1 +			// Afp Versions
		   AfpVersion21.Length + 1 +
		   ICONSIZE_ICN;						// Volume Icon & Mask

	ASSERT(Size <= ASP_MAX_STATUS_BUF);

	// Specify our capabilities
	Flags = SRVRINFO_SUPPORTS_COPYFILE  |
			SRVRINFO_SUPPORTS_CHGPASSWD |
			SRVRINFO_SUPPORTS_SERVERMSG |
            SRVRINFO_SUPPORTS_SRVSIGN   |
            SRVRINFO_SUPPORTS_SRVNOTIFY |
#ifdef	CLIENT36
			SRVRINFO_SUPPORTS_MGETREQS  |
#endif
			((AfpServerOptions & AFP_SRVROPT_ALLOWSAVEDPASSWORD) ?
				0: SRVRINFO_DISALLOW_SAVEPASS);

    // do we have any ipaddresses?
    if (IpAddrCount > 0)
    {
        Flags |= SRVRINFO_SUPPORTS_TCPIP;
    }

	PUTSHORT2SHORT(&pStatusHeader->_Flags, Flags);

	// Copy the Server Name
	pStr = (PASCALSTR)((PBYTE)pStatusHeader + sizeof(struct _StatusHeader));
	pStr->ps_Length = (BYTE)(AfpServerName.Length);
	RtlCopyMemory(pStr->ps_String, AfpServerName.Buffer, AfpServerName.Length);
	(PBYTE)pStr += AfpServerName.Length + 1;

    // do we need a pad byte?
    if (((PBYTE)pStr - (PBYTE)pStatusHeader) % 2 == 1)
    {
        *(PBYTE)pStr = 0;
        ((PBYTE)pStr)++;
    }

    // skip past the Signature Offset field: we'll store the value later
    pSignOffset = (PBYTE)pStr;
    ((PBYTE)pStr) += 2;

    if (AfpServerBoundToAsp || AfpServerBoundToTcp)
    {
        // skip past the Network Address Count Offset: we'll store the value later
        pNetAddrOffset = (PBYTE)pStr;
        ((PBYTE)pStr) += 2;
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("AfpSetServerStatus: Neither TCP nor Appletalk is active!!\n"));
    }

	PUTSHORT2SHORT(pStatusHeader->_MachineString,
					 (USHORT)((PBYTE)pStr - (PBYTE)pStatusHeader));


	// Copy the machine name string
	pStr->ps_Length = (BYTE) AFP_MACHINE_TYPE_LEN;
	RtlCopyMemory(pStr->ps_String, AFP_MACHINE_TYPE_STR, AFP_MACHINE_TYPE_LEN);
	(PBYTE)pStr += AFP_MACHINE_TYPE_LEN + 1;

	// Copy the Afp Version Strings
	PUTSHORT2SHORT(pStatusHeader->_AfpVersions,
			(USHORT)((PBYTE)pStr - (PBYTE)pStatusHeader));

	*((PBYTE)pStr)++ = AFP_NUM_VERSIONS;
	pStr->ps_Length = (BYTE)AfpVersion20.Length;
	RtlCopyMemory(pStr->ps_String, AfpVersion20.Buffer, AfpVersion20.Length);
	(PBYTE)pStr += AfpVersion20.Length + 1;

	pStr->ps_Length = (BYTE)AfpVersion21.Length;
	RtlCopyMemory(pStr->ps_String, AfpVersion21.Buffer, AfpVersion21.Length);
	(PBYTE)pStr += AfpVersion21.Length + 1;

	pStr->ps_Length = (BYTE)AfpVersion22.Length;
	RtlCopyMemory(pStr->ps_String, AfpVersion22.Buffer, AfpVersion22.Length);
	(PBYTE)pStr += AfpVersion22.Length + 1;

	// We always support at least one UAM!
	PUTSHORT2SHORT(pStatusHeader->_UAMs, (USHORT)((PBYTE)pStr - (PBYTE)pStatusHeader));
	pNumUamPtr = (PBYTE)pStr;
    ((PBYTE)pStr)++;

    CountOfUams = 0;

	if (GuestAllowed)
	{
		pStr->ps_Length = (BYTE)AfpUamGuest.Length;
		RtlCopyMemory(pStr->ps_String, AfpUamGuest.Buffer,
													AfpUamGuest.Length);
		(PBYTE)pStr += AfpUamGuest.Length + 1;
        CountOfUams++;
        Size += (AfpUamGuest.Length + 1);
	}
    else
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	        ("AfpSetServerStatus: Guest is disabled\n"));
    }


	if (ClearTextAllowed)
	{
		pStr->ps_Length = (BYTE)AfpUamClearText.Length;
		RtlCopyMemory(pStr->ps_String, AfpUamClearText.Buffer,
													AfpUamClearText.Length);
		(PBYTE)pStr += AfpUamClearText.Length + 1;
        CountOfUams++;
        Size += (AfpUamClearText.Length + 1);
	}
    else
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	        ("AfpSetServerStatus: ClearText UAM is NOT configured\n"));
    }

    if (MicrosoftUamSupported)
    {
        // copy in "Microsoft V1.0" string
	    pStr->ps_Length = (BYTE)AfpUamCustomV1.Length;
	    RtlCopyMemory(pStr->ps_String, AfpUamCustomV1.Buffer, AfpUamCustomV1.Length);
	    (PBYTE)pStr += AfpUamCustomV1.Length + 1;
        CountOfUams++;
        Size += (AfpUamCustomV1.Length + 1 + 1);

        // copy in "Microsoft V2.0" string
	    pStr->ps_Length = (BYTE)AfpUamCustomV2.Length;
	    RtlCopyMemory(pStr->ps_String, AfpUamCustomV2.Buffer, AfpUamCustomV2.Length);
	    (PBYTE)pStr += AfpUamCustomV2.Length + 1;
        CountOfUams++;
        Size += (AfpUamCustomV2.Length + 1 + 1);
    }
    else
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	        ("AfpSetServerStatus: Microsoft UAM is NOT configured\n"));
    }

    if (NativeAppleUamSupported)
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	        ("AfpSetServerStatus: Apple's native UAM is configured\n"));

    	pStr->ps_Length = (BYTE)AfpUamApple.Length;
    	RtlCopyMemory(pStr->ps_String, AfpUamApple.Buffer, AfpUamApple.Length);
	    (PBYTE)pStr += AfpUamApple.Length + 1;
        CountOfUams++;
        Size += (AfpUamApple.Length + 1 + 1);

// 2-way not included for now
#if ALLOW_2WAY_ASWELL
	    pStr->ps_Length = (BYTE)AfpUamApple2Way.Length;
	    RtlCopyMemory(pStr->ps_String, AfpUamApple2Way.Buffer, AfpUamApple2Way.Length);
	    (PBYTE)pStr += AfpUamApple2Way.Length + 1;
        CountOfUams++;
        Size += (AfpUamApple2Way.Length + 1 + 1);
#endif
    }

    // how many UAM's are we telling the client we support
	*pNumUamPtr = CountOfUams;

    // now we know where Server signature goes: write the offset
	PUTSHORT2SHORT(pSignOffset,(USHORT)((PBYTE)pStr - (PBYTE)pStatusHeader));

    // copy the Server signature
    RtlCopyMemory((PBYTE)pStr, AfpServerSignature, 16);
    ((PBYTE)pStr) += 16;

    //
    // if we have network address(es), send that info over!
    //
    if ((IpAddrCount > 0) || (AfpServerBoundToAsp))
    {
        // now we know where Network Address Count Offset goes: write the offset
	    PUTSHORT2SHORT(pNetAddrOffset,(USHORT)((PBYTE)pStr - (PBYTE)pStatusHeader));

        // how many addresses are we returning?
        *(PBYTE)pStr = ((BYTE)IpAddrCount) + ((AfpServerBoundToAsp) ? 1 : 0);
        ((PBYTE)pStr)++;

        // copy the ipaddresses, if bound
        if (IpAddrCount > 0)
        {
            // copy the blob containing the Length, Tag and Ipaddress info
            RtlCopyMemory((PBYTE)pStr, IpAddrBlob, IpAddrCount*DSI_NETWORK_ADDR_LEN);
            ((PBYTE)pStr) += (IpAddrCount*DSI_NETWORK_ADDR_LEN);
        }

        // now copy the appletalk addres, if bound
        if (AfpServerBoundToAsp)
        {
            *(PBYTE)pStr = DSI_NETWORK_ADDR_LEN;
            ((PBYTE)pStr)++;

            *(PBYTE)pStr = ATALK_NETWORK_ADDR_ATKTAG;
            ((PBYTE)pStr)++;

            PUTDWORD2DWORD((PBYTE)pStr, AfpAspEntries.asp_AtalkAddr.Address);

            ((PBYTE)pStr) += sizeof(DWORD);
        }
    }

	// Now get the volume icon, if any
	if (AfpServerIcon != NULL)
	{
		RtlCopyMemory((PBYTE)pStr, AfpServerIcon, ICONSIZE_ICN);
		PUTSHORT2SHORT(pStatusHeader->_VolumeIcon,
				(USHORT)((PBYTE)pStr - (PBYTE)pStatusHeader));
	}
	else PUTSHORT2SHORT(pStatusHeader->_VolumeIcon, 0);

	RELEASE_SPIN_LOCK(&AfpServerGlobalLock, OldIrql);

    if (AfpServerBoundToAsp)
    {
	    Status = AfpSpSetAspStatus((PBYTE)pStatusHeader, Size);
    }

    if (AfpServerBoundToTcp)
    {
	    Status2 = AfpSpSetDsiStatus((PBYTE)pStatusHeader, Size);

        // as long as one succeeds, we want the call to succeed
        if (!NT_SUCCESS(Status))
        {
            Status = Status2;
        }
    }

	AfpFreeMemory(pStatusHeader);

    if (IpAddrBlob)
    {
        AfpFreeMemory(IpAddrBlob);
    }

	return Status;
}



/***	AfpAdmWServerSetInfo
 *
 *	This routine sets various server globals with data supplied by the admin.  The
 *	following server globals are set by this routine:
 *
 *	- Server Name
 *	- Maximum Sessions (valid values are 1 through AFP_MAXSESSIONS)
 *	- Server Options (i.e. guest logon allowed, etc.)
 *	- Server Login Message
 *  - Maximum paged and non-paged memory limits
 *  - Macintosh Code Page File
 *
 *	The server name and memory limits can only be changed while the server
 *	is stopped. The Macintosh Code Page File may only be set ONE time after
 *  the AFP server driver is loaded. i.e. if you want to reset the codepage,
 *  the service must unload the AFP server, then reload it.
 *
 *  This routine must execute in the context of the worker thread, since we
 *  need to map the Macintosh CodePage into the server's virtual memory
 *  space, not the client's.
 *
 *	LOCKS: AfpServerGlobalLock (SPIN)
 */
AFPSTATUS
AfpAdmWServerSetInfo(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	KIRQL			OldIrql;
	AFPSTATUS		rc;
	ANSI_STRING		amsg, aname;
	UNICODE_STRING	uname, umsg, oldloginmsgU;
	DWORD			parmflags = ((PSETINFOREQPKT)InBuf)->sirqp_parmnum;
	PAFP_SERVER_INFO pSvrInfo = (PAFP_SERVER_INFO)((PCHAR)InBuf+sizeof(SETINFOREQPKT));
	BOOLEAN			setstatus = False;
	BOOLEAN			locktaken = False;
	BOOLEAN			servernameexists = False;


	amsg.Length = 0;
	amsg.MaximumLength = 0;
	amsg.Buffer = NULL;

	aname.Length = 0;
	aname.MaximumLength = 0;
	aname.Buffer = NULL;

	AfpSetEmptyUnicodeString(&umsg, 0, NULL);
	AfpSetEmptyUnicodeString(&oldloginmsgU, 0, NULL);

	/* Validate all limits */
	if ((parmflags & ~AFP_SERVER_PARMNUM_ALL)			||

		((parmflags & AFP_SERVER_PARMNUM_OPTIONS) &&
		 (pSvrInfo->afpsrv_options & ~AFP_SRVROPT_ALL)) ||

		((parmflags & AFP_SERVER_PARMNUM_MAX_SESSIONS) &&
		 ((pSvrInfo->afpsrv_max_sessions > AFP_MAXSESSIONS) ||
		  (pSvrInfo->afpsrv_max_sessions == 0))))
	{
	    DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_ERR,
		    ("AfpAdmWServerSetInfo: invalid parm!\n"));
		return AFPERR_InvalidParms_MaxSessions;
	}

    if (parmflags == AFP_SERVER_GUEST_ACCT_NOTIFY)
    {
        AfpServerOptions ^= AFP_SRVROPT_GUESTLOGONALLOWED;

	    DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_ERR,
		    ("AfpAdmWServerSetInfo: Guest account is now %s\n",
            (AfpServerOptions & AFP_SRVROPT_GUESTLOGONALLOWED)? "enabled":"disabled"));

        AfpSetServerStatus();
        return(STATUS_SUCCESS);
    }

	if (parmflags & AFP_SERVER_PARMNUM_CODEPAGE)
	{
		// You may only set the Macintosh CodePage once
		if (AfpMacCPBaseAddress != NULL)
			return AFPERR_InvalidServerState;
		else
		{
			rc = AfpGetMacCodePage(pSvrInfo->afpsrv_codepage);
			if (!NT_SUCCESS(rc))
			{
				return AFPERR_CodePage;
			}
		}
	}

	if (parmflags & AFP_SERVER_PARMNUM_LOGINMSG)
	{
		RtlInitUnicodeString(&umsg, pSvrInfo->afpsrv_login_msg);
		if (umsg.Length == 0)
		{
			umsg.Buffer = NULL;
		}
		amsg.MaximumLength = (USHORT)RtlUnicodeStringToAnsiSize(&umsg);
		amsg.Length = amsg.MaximumLength - 1;

		if (amsg.Length > AFP_MESSAGE_LEN)
		{
			return AFPERR_InvalidParms_LoginMsg;
		}

		if (amsg.Length != 0)
		{
			if ((umsg.Buffer =
					(LPWSTR)AfpAllocPagedMemory(umsg.Length+1)) == NULL)
			{
				return STATUS_INSUFFICIENT_RESOURCES;
			}

			if ((amsg.Buffer =
					(PCHAR)AfpAllocNonPagedMemory(amsg.MaximumLength)) == NULL)
			{
				AfpFreeMemory(umsg.Buffer);
				return STATUS_INSUFFICIENT_RESOURCES;
			}

			RtlCopyMemory(umsg.Buffer, pSvrInfo->afpsrv_login_msg, umsg.Length);
			rc = RtlUnicodeStringToAnsiString(&amsg, &umsg, False);
			if (!NT_SUCCESS(rc))
			{
				AfpFreeMemory(amsg.Buffer);
				AfpFreeMemory(umsg.Buffer);
				return AFPERR_InvalidParms;
			}
			else AfpConvertHostAnsiToMacAnsi(&amsg);
		}
	}

	do
	{
		if (parmflags & AFP_SERVER_PARMNUM_NAME)
		{
			RtlInitUnicodeString(&uname,pSvrInfo->afpsrv_name);
			aname.MaximumLength = (USHORT)RtlUnicodeStringToAnsiSize(&uname);
			aname.Length = aname.MaximumLength - 1;

			if ((aname.Length == 0) || (aname.Length > AFP_SERVERNAME_LEN))
			{
	            DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_ERR,
			        ("AfpAdmWServerSetInfo: bad name length %d, rejecting\n,aname.Length"));
				rc = AFPERR_InvalidServerName_Length;
				break;
			}

			if ((aname.Buffer = AfpAllocNonPagedMemory(aname.MaximumLength)) == NULL)
			{
	            DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_ERR,
			        ("AfpAdmWServerSetInfo: malloc failed on name change\n"));
				rc = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}
			rc = AfpConvertStringToAnsi(&uname, &aname);
			if (!NT_SUCCESS(rc))
			{
				rc = AFPERR_InvalidServerName;
	            DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_ERR,
				    ("AfpAdmWServerSetInfo: AfpConvertStringToAnsi failed %lx\n",rc));
				break;
			}
		}

		rc = STATUS_SUCCESS;

		//
		// take the global data lock and set the new information
		//
		ACQUIRE_SPIN_LOCK(&AfpServerGlobalLock, &OldIrql);
		locktaken = True;

		// Validate if we are in the right state to receive some of the
		// parameters
		if ((AfpServerState != AFP_STATE_IDLE) &&
			 (parmflags & (AFP_SERVER_PARMNUM_PAGEMEMLIM |
						  AFP_SERVER_PARMNUM_NONPAGEMEMLIM)))
		{
	        DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_ERR,
			    ("AfpAdmWServerSetInfo: failure at 1\n"));

			rc = AFPERR_InvalidServerState;
			break;
		}

		else if ((AfpServerState == AFP_STATE_IDLE) &&
				 (parmflags & (AFP_SERVER_PARMNUM_NAME |
						  AFP_SERVER_PARMNUM_PAGEMEMLIM |
						  AFP_SERVER_PARMNUM_NONPAGEMEMLIM)) !=
						 (DWORD)(AFP_SERVER_PARMNUM_NAME |
						  AFP_SERVER_PARMNUM_PAGEMEMLIM |
						  AFP_SERVER_PARMNUM_NONPAGEMEMLIM))
		{
	        DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_ERR,
			    ("AfpAdmWServerSetInfo: failure at 2\n"));

			rc = AFPERR_InvalidParms;
			break;
		}

		if (parmflags & (AFP_SERVER_PARMNUM_PAGEMEMLIM |
						 AFP_SERVER_PARMNUM_NONPAGEMEMLIM))
		{
			AfpPagedPoolLimit = pSvrInfo->afpsrv_max_paged_mem * 1024;
			AfpNonPagedPoolLimit = pSvrInfo->afpsrv_max_nonpaged_mem * 1024;
		}

		if (parmflags & AFP_SERVER_PARMNUM_NAME)
		{
			setstatus = ((AfpServerState == AFP_STATE_RUNNING) ||
						(AfpServerState == AFP_STATE_START_PENDING));

			rc = STATUS_SUCCESS;
			if (AfpServerName.Buffer == NULL)
			{
				AfpServerName = aname;
			}
            else
            {
                servernameexists = True;
            }

			// Re-register the name only if the service up and running
			// No point registering the name on a service not functioning.
			// This causes problems as we falsely advertise
			// the AFP server in the browser when it is not really available.
			if (setstatus) 
			{

				// deregister the old name, if one exists
				if ((AfpServerBoundToAsp) && (servernameexists))
				{
					RELEASE_SPIN_LOCK(&AfpServerGlobalLock,OldIrql);
					rc = AfpSpRegisterName(&AfpServerName, False);
					ACQUIRE_SPIN_LOCK(&AfpServerGlobalLock, &OldIrql);
			    
					AfpFreeMemory(AfpServerName.Buffer);
				}

				AfpServerName = aname;

				// if deregister succeeded, register the new name
				if ((NT_SUCCESS(rc)) && (AfpServerBoundToAsp))
				{
					RELEASE_SPIN_LOCK(&AfpServerGlobalLock,OldIrql);
					rc = AfpSpRegisterName(&AfpServerName, True);
					ACQUIRE_SPIN_LOCK(&AfpServerGlobalLock, &OldIrql);
				}

			}
		}

		if (parmflags & AFP_SERVER_PARMNUM_OPTIONS)
		{
			if (pSvrInfo->afpsrv_options & AFP_SRVROPT_STANDALONE)
			{
				// Server is NtProductServer or NtProductWinNt
				AfpServerIsStandalone = True;
				if (AfpSidNone == NULL)
				{
					// If we didn't initialize the AfpSidNone during
					// AfpInitSidOffsets then the service either sent
					// us bogus offsets, or this bit is bogus
					rc = AFPERR_InvalidParms;
					break;
				}
				pSvrInfo->afpsrv_options &= ~AFP_SRVROPT_STANDALONE;
			}
            if (!setstatus)
            {
			    setstatus =
				    (AfpServerOptions ^ pSvrInfo->afpsrv_options) ? True : False;
			    setstatus = setstatus &&
                                ((AfpServerState == AFP_STATE_RUNNING) ||
                                 (AfpServerState == AFP_STATE_START_PENDING));
            }
			AfpServerOptions = pSvrInfo->afpsrv_options;
		}

		if (parmflags & AFP_SERVER_PARMNUM_LOGINMSG)
		{
			if (AfpLoginMsg.Buffer != NULL)
			{
				AfpFreeMemory(AfpLoginMsg.Buffer);
			}
			AfpLoginMsg = amsg;
			oldloginmsgU = AfpLoginMsgU;
			AfpLoginMsgU = umsg;
		}

		if (parmflags & AFP_SERVER_PARMNUM_MAX_SESSIONS)
		{
			if (AfpServerMaxSessions != pSvrInfo->afpsrv_max_sessions)
			{
				BOOLEAN	KillSome;

				KillSome = (AfpServerMaxSessions > pSvrInfo->afpsrv_max_sessions);

                AfpServerMaxSessions = pSvrInfo->afpsrv_max_sessions;

				RELEASE_SPIN_LOCK(&AfpServerGlobalLock,OldIrql);
				locktaken = False;
			}
		}
	} while (False);

	if (locktaken)
	{
		RELEASE_SPIN_LOCK(&AfpServerGlobalLock,OldIrql);
	}

	if (!NT_SUCCESS(rc))
	{
	    DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_ERR,
		    ("AfpAdmWServerSetInfo: returning %lx\n",rc));
		if (amsg.Buffer != NULL)
		{
			AfpFreeMemory(amsg.Buffer);
		}
		if (aname.Buffer != NULL)
		{
			if (AfpServerName.Buffer == aname.Buffer)
            {
                AfpServerName.Buffer = NULL;
			    AfpServerName.MaximumLength = 0;
			    AfpServerName.Length = 0;
            }
			AfpFreeMemory(aname.Buffer);
		}
	}
	else if (setstatus)
	{
		return (AfpSetServerStatus());
	}

	if (oldloginmsgU.Buffer != NULL)
		AfpFreeMemory(oldloginmsgU.Buffer);

	return rc;
}



/***	AfpCreateNewThread
 *
 *	Create either an admin or a worker thread.
 */
NTSTATUS FASTCALL
AfpCreateNewThread(
	IN	VOID	(*ThreadFunc)(IN PVOID pContext),
	IN	LONG	ThreadNum
)
{
	NTSTATUS			Status;
	HANDLE				FspThread;

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("AfpCreateNewThread: Creating thread %lx\n", ThreadFunc));

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
	ASSERT ((AfpServerState == AFP_STATE_IDLE) ||
			(ThreadNum < AFP_MAX_THREADS) && (AfpNumThreads >= AFP_MIN_THREADS));
	Status = PsCreateSystemThread(&FspThread,
								  THREAD_ALL_ACCESS,
								  NULL,
								  NtCurrentProcess(),
								  NULL,
								  ThreadFunc,
								  (PVOID)((ULONG_PTR)ThreadNum));
	if (!NT_SUCCESS(Status))
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
				("AfpCreateNewThread: Cannot create threads %lx\n", Status));
		AFPLOG_DDERROR(AFPSRVMSG_CREATE_THREAD, Status, NULL, 0, NULL);
	}
	else
	{
		// Close the handle to the thread so that it goes away when the
		// thread terminates
		NtClose(FspThread);
	}
	return Status;
}


/***	AfpQueueWorkItem
 *
 *	Queue a work item to the worker thread.
 *
 *	LOCKS:		AfpStatisticsLock
 */
VOID FASTCALL
AfpQueueWorkItem(
	IN	PWORK_ITEM		pWI
)
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);

	AfpServerStatistics.stat_CurrQueueLength ++;
#ifdef	PROFILING
	AfpServerProfile->perf_QueueCount ++;
#endif
	if (AfpServerStatistics.stat_CurrQueueLength > AfpServerStatistics.stat_MaxQueueLength)
		AfpServerStatistics.stat_MaxQueueLength++;

	RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("AfpQueueWorkItem: Queueing %lx (%lx)\n",
			pWI->wi_Worker, pWI->wi_Context));

	INTERLOCKED_ADD_ULONG(&AfpWorkerRequests, 1, &AfpServerGlobalLock);

	// Insert work item in worker queue
	KeInsertQueue(&AfpWorkerQueue, &pWI->wi_List);
}


/***	AfpWorkerThread
 *
 *	This thread is used to do all the work that is queued to the FSP.
 *
 *	We want to dynamically create and destroy threads so that we can
 *	optimize the number of threads used. The number of threads range
 *	from AFP_MIN_THREADS - AFP_MAX_THREADS.
 *	A new thread is created if the number of entries in the queue
 *	exceeds AFP_THREAD_THRESHOLD_REQ. A thread is terminated if the	request count
 *	drops below AFP_THREAD_THRESHOLD_IDLE.
 */
VOID
AfpWorkerThread(
	IN	PVOID	pContext
)
{
	NTSTATUS		Status;
	PLIST_ENTRY		pList;
	PWORK_ITEM		pWI;
	LONG			IdleCount = 0;
	LONG			ThreadNum, CreateId;
	ULONG			BasePriority = THREAD_BASE_PRIORITY_MAX;
	KIRQL			OldIrql;
	BOOLEAN			Release = False;
	BOOLEAN			ReasonToLive = True;

	ThreadNum = (LONG)(LONG_PTR)pContext;

	ASSERT (AfpThreadState[ThreadNum] == AFP_THREAD_STARTED);

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
			("AfpWorkerThread: Thread %ld Starting. NumThreads %ld\n",
			ThreadNum, AfpNumThreads));

	// Update the thread statistics.
	ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);
	AfpServerStatistics.stat_CurrThreadCount ++;
	if (AfpServerStatistics.stat_CurrThreadCount > AfpServerStatistics.stat_MaxThreadCount)
        AfpServerStatistics.stat_MaxThreadCount = AfpServerStatistics.stat_CurrThreadCount;
	RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

	// Set the thread base priority to 'foreground'
	NtSetInformationThread( NtCurrentThread(),
							ThreadBasePriority,
							&BasePriority,
							sizeof(BasePriority));

	// Disable hard-error pop-ups for this thread
    IoSetThreadHardErrorMode( FALSE );
	AfpThreadPtrsW[ThreadNum] = PsGetCurrentThread();

	do
	{
		AfpThreadState[ThreadNum] = AFP_THREAD_WAITING;

		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("AfpWorkerThread: About to block\n"));

// DELALLOCQUEUE: unrem the #if 0 part
#if 0
        //
        // first check if there is someone waiting to get buffer allocation:
        // let's deal with them first, so some connection doesn't get "blocked"
        // because transport underneath doesn't have buffer
        //
		pList = KeRemoveQueue(&AfpDelAllocQueue, KernelMode, NULL);
        if (pList != NULL)
        {
			AfpThreadState[ThreadNum] = AFP_THREAD_BUSY;

			pWI = CONTAINING_RECORD(pList, WORK_ITEM, wi_List);

			// Call the worker
			(pWI->wi_Worker)(pWI->wi_Context);

			IdleCount = 0;

            continue;
        }
#endif

		pList = KeRemoveQueue(&AfpWorkerQueue, KernelMode, &ThreeSecTimeOut);
		Status = STATUS_SUCCESS;
		if ((NTSTATUS)((ULONG_PTR)pList) == STATUS_TIMEOUT)
			Status = STATUS_TIMEOUT;

		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("AfpWorkerThread: %s\n",
				(Status == STATUS_SUCCESS) ? "Another Work item" : "Timer - check"));

		if (Status == STATUS_SUCCESS)
		{
			pWI = CONTAINING_RECORD(pList, WORK_ITEM, wi_List);

			if (pWI == &AfpTerminateThreadWI)
			{
				BOOLEAN	Requeue;

				ReasonToLive = False;
				ACQUIRE_SPIN_LOCK(&AfpServerGlobalLock, &OldIrql);
				AfpNumThreads --;
				Requeue = (AfpNumThreads != 0);
				RELEASE_SPIN_LOCK(&AfpServerGlobalLock, OldIrql);

				AfpThreadState[ThreadNum] = AFP_THREAD_DEAD;
				if (!Requeue)
				{
					ASSERT((AfpServerState == AFP_STATE_STOPPED) ||
						   (AfpServerState == AFP_STATE_IDLE));
					Release = True;
				}
				else
				{
					// Re-queue this work-item so that other threads can die too !!!
					KeInsertQueue(&AfpWorkerQueue, &AfpTerminateThreadWI.wi_List);
				}
				break;
			}

			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
					("AfpWorkerThread: Dispatching %lx (%lx)\n",
					pWI->wi_Worker, pWI->wi_Context));

			AfpThreadState[ThreadNum] = AFP_THREAD_BUSY;
#if DBG
			AfpThreadDispCount[ThreadNum] ++;
#endif
			// Call the worker
			(pWI->wi_Worker)(pWI->wi_Context);

			ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

			INTERLOCKED_ADD_ULONG((PLONG)(&AfpServerStatistics.stat_CurrQueueLength),
									(ULONG)-1,
									&AfpStatisticsLock);

			INTERLOCKED_ADD_ULONG(&AfpWorkerRequests, (ULONG)-1, &AfpServerGlobalLock);
			IdleCount = 0;
		}
		else
		{
			IdleCount ++;
		}

		ACQUIRE_SPIN_LOCK(&AfpServerGlobalLock, &OldIrql);

		if (((AfpWorkerRequests - AfpNumThreads) > AFP_THREAD_THRESHOLD_REQS) &&
			(AfpNumThreads < AFP_MAX_THREADS))
		{
			for (CreateId = 0; CreateId < AFP_MAX_THREADS; CreateId++)
			{
				if (AfpThreadState[CreateId] == AFP_THREAD_DEAD)
				{
					AfpThreadState[CreateId] = AFP_THREAD_STARTED;
					break;
				}
			}

			if (CreateId < AFP_MAX_THREADS)
			{
				AfpNumThreads++;

				ASSERT (CreateId < AFP_MAX_THREADS);

				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
						("AfpWorkerThread: Creating New Thread %ld\n", CreateId));

				RELEASE_SPIN_LOCK(&AfpServerGlobalLock, OldIrql);
				Status = AfpCreateNewThread(AfpWorkerThread, CreateId);
				ACQUIRE_SPIN_LOCK(&AfpServerGlobalLock, &OldIrql);

				if (!NT_SUCCESS(Status))
				{
					ASSERT(AfpThreadState[CreateId] == AFP_THREAD_STARTED);
					AfpThreadState[CreateId] = AFP_THREAD_DEAD;
					AfpNumThreads --;
				}
			}
		}
		else if ((AfpNumThreads > AFP_MIN_THREADS) &&
				 (IdleCount >= AFP_THREAD_THRESHOLD_IDLE))
		{
			ReasonToLive = False;
            AfpThreadState[ThreadNum] = AFP_THREAD_DEAD;
			AfpNumThreads --;
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
					("AfpWorkerThread: Thread %ld About to commit suicide, NumThreads %ld\n",
					ThreadNum, AfpNumThreads));
		}

		RELEASE_SPIN_LOCK(&AfpServerGlobalLock, OldIrql);

	} while (ReasonToLive);

	AfpThreadPtrsW[ThreadNum] = NULL;

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
			("AfpWorkerThread: Thread %ld Quitting\n", ThreadNum));

	INTERLOCKED_ADD_ULONG((PLONG)&AfpServerStatistics.stat_CurrThreadCount,
							(ULONG)-1,
							&AfpStatisticsLock);

	// if this is the last thread in the system, set things up so that unload code
	// can wait on the pointer and know when this thread has really died and not just
	// when KeSetEvent is called
	if (Release)
	{
		AfpThreadPtrsW[ThreadNum] = PsGetCurrentThread();
		ObReferenceObject(AfpThreadPtrsW[ThreadNum]);

		KeSetEvent(&AfpStopConfirmEvent, IO_NETWORK_INCREMENT, False);
	}
}


/***	AfpInitStrings
 *
 *	Initializes all the strings
 */
VOID FASTCALL
AfpInitStrings(
    IN VOID
)
{
	// Initialize UAM Strings
	RtlInitString(&AfpUamGuest, NO_USER_AUTHENT_NAME);
	RtlInitString(&AfpUamClearText, CLEAR_TEXT_AUTHENT_NAME);
	RtlInitString(&AfpUamCustomV1, CUSTOM_UAM_NAME_V1);
	RtlInitString(&AfpUamCustomV2, CUSTOM_UAM_NAME_V2);
	RtlInitString(&AfpUamApple, RANDNUM_EXCHANGE_NAME);
	RtlInitString(&AfpUamApple2Way, TWOWAY_EXCHANGE_NAME);

	// Initialize AFP Versions
	RtlInitString(&AfpVersion20, AFP_VER_20_NAME);
	RtlInitString(&AfpVersion21, AFP_VER_21_NAME);
	RtlInitString(&AfpVersion22, AFP_VER_22_NAME);

	// Default Workstation name
	RtlInitUnicodeString(&AfpDefaultWksta, AFP_DEFAULT_WORKSTATION);

	RtlInitUnicodeString(&AfpNetworkTrashNameU, AFP_NWTRASH_NAME_U);
}


/***	AfpAdmSystemShutdown
 *
 *	Called during system shutdown. Simply close all active sessions and stop the volumes.
 */
AFPSTATUS
AfpAdmSystemShutdown(
	IN	OUT	PVOID 	Inbuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID 		Outbuf		OPTIONAL
)
{
	AFP_SESSION_INFO	SessInfo;
	NTSTATUS			Status;

	if ((AfpServerState & ( AFP_STATE_STOPPED		|
							AFP_STATE_STOP_PENDING	|
							AFP_STATE_SHUTTINGDOWN)) == 0)
	{
		AfpServerState = AFP_STATE_SHUTTINGDOWN;

        DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
						("AfpAdmSystemShutdown: Shutting down server\n"));

        // Disable listens now that we are about to stop
		AfpSpDisableListens();

		SessInfo.afpsess_id = 0;	// Shutdown all sessions
		AfpAdmWSessionClose(&SessInfo, 0, NULL);

		// Wait for the sessions to complete, if there were active sessions
		if (AfpNumSessions > 0) do
		{
			Status = AfpIoWait(&AfpStopConfirmEvent, &FiveSecTimeOut);
			if (Status == STATUS_TIMEOUT)
			{
				DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
						("AfpAdmSystemShutdown: Timeout Waiting for %ld sessions to die, re-waiting\n",
						AfpNumSessions));
			}
		} while (Status == STATUS_TIMEOUT);

        // bring down the DSI-TCP interface
        DsiDestroyAdapter();

        // wait until DSI cleans up its interface with TCP
        AfpIoWait(&DsiShutdownEvent, NULL);

        // Set the flag to indicate that server is shutting down
        fAfpServerShutdownEvent = TRUE;

		// Now tell each of the volume scavengers to shut-down
		AfpVolumeStopAllVolumes();
	}

	return AFP_ERR_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\sda.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	sda.h

Abstract:

	This module contains session data area and related data structures.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _SDA_
#define _SDA_

// sda_Flags values
#define	SDA_USER_NOT_LOGGEDIN	0x0000	//
#define	SDA_USER_LOGIN_PARTIAL	0x0001	// Encrypted logon is half-way done
#define	SDA_USER_LOGGEDIN		0x0002
#define	SDA_LOGIN_MASK			0x0003

#define	SDA_REQUEST_IN_PROCESS	0x0004	// A request is being processed
#define	SDA_REPLY_IN_PROCESS	0x0008	// A reply has been posted
#define	SDA_NAMEXSPACE_IN_USE	0x0010	// NameXSpace is in use by reply processing

#define	SDA_DEREF_VOLUME		0x0020	// Dereference volume before reply
#define	SDA_DEREF_OFORK			0x0040	// Dereference open-fork before reply
#define	SDA_LOGIN_FAILED		0x0080	// Funky stuff for AFP 2.1 Chooser
#define	SDA_CLIENT_CLOSE		0x0100	// Set if the close if hapenning from the client side
#define	SDA_QUEUE_IF_DPC		0x0200	// Copied from the dispatch table (see afpapi.c)
#define	SDA_SESSION_CLOSED		0x0400	// If set, do not close session in deref.
#define	SDA_SESSION_CLOSE_COMP	0x0800	// If set, close completion called for this session
#define SDA_SESSION_OVER_TCP    0x1000  // this is an AFP/TCP session
#define SDA_SESSION_NOTIFY_SENT 0x2000  // Server Notification sent to this sda
#define	SDA_CLOSING				0x8000	// Session is marked to die

// sda_ClientType values
#define	SDA_CLIENT_GUEST		NO_USER_AUTHENT
#define	SDA_CLIENT_CLEARTEXT	CLEAR_TEXT_AUTHENT
#define	SDA_CLIENT_MSUAM_V1     CUSTOM_UAM_V1
#define	SDA_CLIENT_MSUAM_V2     CUSTOM_UAM_V2
#define SDA_CLIENT_RANDNUM      RANDNUM_EXCHANGE
#define SDA_CLIENT_TWOWAY       TWOWAY_EXCHANGE
#define SDA_CLIENT_ADMIN		AFP_NUM_UAMS

#define	MAX_REQ_ENTRIES			7
#define	MAX_REQ_ENTRIES_PLUS_1	8		// used to allocate space 1 DWORD more 
										// than required. The first entry is
										// used to store pointer to VolDesc
										// or ConnDesc. The extra DWORD is used
										// to accomodate 64-bit pointer if we
										// have one
#define	MAX_VAR_ENTRIES			3

#define	SESSION_CHECK_TIME		60		// In seconds
#define	SESSION_WARN_TIME		SESSION_CHECK_TIME * 10

// SDA_SIZE is the total size allocated to the SDA pointer
// This includes sizeof(SDA) plus additional buffer allocated for
// copying strings into. This extra space is allocated after the
// first sizeof(SDA) bytes. The size is purely a ball-park figure
// The original design does not mention why the total space was 384
// Currently we are doubling the space to accomodate 64-bit stuff
#ifdef _WIN64
#define	SDA_SIZE				(((768 - POOL_OVERHEAD)+7) & 0xfffffff8)
#else
#define	SDA_SIZE				(((450 - POOL_OVERHEAD)+7) & 0xfffffff8)
#endif

// Linked list of deferred request packets. If the session is already
// processing a request, then subsequent requests are queued. These
// are always handled in a FIFO order.
typedef	struct _DeferredRequestQueue
{
	LIST_ENTRY	drq_Link;
	PREQUEST   	drq_pRequest;
} DFRDREQQ, *PDFRDREQQ;

/*
 * This is the per-session data area. This is allocated whenever a listen is
 * posted. At that point it is in the outstanding session list. When the listen
 * is completed, it moves to the active session list.
 */
#if DBG
#define	SDA_SIGNATURE		*(DWORD *)"SDA"
#define	VALID_SDA(pSda)		(((pSda) != NULL) && \
							 ((pSda)->Signature == SDA_SIGNATURE))
#else
#define	VALID_SDA(pSda)		((pSda) != NULL)
#endif

typedef struct _SessDataArea
{
#if	DBG
	DWORD			Signature;
#endif
	struct _SessDataArea * sda_Next;	// link to next session in session list
	AFP_SPIN_LOCK		sda_Lock;			// Lock for manipulating certain SDA
										// fields
	DWORD			sda_Flags;			// Bit mask of the SDA states
	LONG			sda_RefCount;		// Count of references to this SDA
    PASP_XPORT_ENTRIES  sda_XportTable; // pointer to ASP's or DSI's entry points
    DWORD           sda_MaxWriteSize;   // 64000 for TCP/IP, 4624 for Appletalk
	PVOID			sda_SessHandle;		// Asp Session handle
	PREQUEST		sda_Request;		// Current request
	HANDLE			sda_UserToken;		// Logon token for this user.
	PSID			sda_UserSid;		// SID representing owner
	PSID			sda_GroupSid;		// SID representing primary group
	PTOKEN_GROUPS	sda_pGroups;		// List of groups this user is member of
#ifdef	INHERIT_DIRECTORY_PERMS
	DWORD			sda_UID;			// User Id corres. to sda_UserSid
	DWORD			sda_GID;			// Group Id corres. to sda_GroupSid
#else
	PISECURITY_DESCRIPTOR sda_pSecDesc; // Security descriptor used by directory
										// Creation API
	DWORD			sda_Dummy;			// For alignment
#endif
	PANSI_STRING	sda_Message;		// The actual message in macintosh ansi
										// The above field is used only for
										// client specific message. Broadcast
										// messages are stored in a global area
	UNICODE_STRING	sda_WSName;			// Workstation name of logged in user
	UNICODE_STRING	sda_UserName;		// User name
	UNICODE_STRING	sda_DomainName;		// DomainName for Login/ChgPwd

#ifdef	PROFILING
	TIME			sda_ApiStartTime;	// Time stamp when Api req. was recvd.
	TIME			sda_QueueTime;		// Time spent waiting for worker thread
#endif

	DWORD			sda_SessionId;		// Session Id for use by admin APIs
	AFPTIME			sda_TimeLoggedOn;	// Time when session established
										// in macintosh time
	DWORD			sda_tTillKickOff;	// # of seconds before this session will
										// be kicked off
	struct _ConnDesc *	sda_pConnDesc;	// List of connections by this session
	struct _OpenForkSession	sda_OpenForkSess;
										// List of open files by this session
	LONG			sda_cOpenVolumes;	// Number of volumes mounted (admin api)
	LONG			sda_cOpenForks;		// Number of forks opened	 (admin api)
	DWORD			sda_MaxOForkRefNum;	// High-water mark of the fork-ref num assigned

	BYTE			sda_AfpFunc;		// AFP API in execution for FSP
	BYTE			sda_AfpSubFunc;		// Sub function code used by some APIs
	BYTE			sda_ClientVersion;	// AFP Version of the client s/w
										// AFP_VER_20
										// AFP_VER_21
	BYTE			sda_ClientType;		// One of SDA_CLIENT_XXXX
	BYTE			sda_PathType;		// For all path based calls
	USHORT			sda_SizeNameXSpace;	// Constant, initialized once
	USHORT			sda_ReplySize;		// Size of the reply buffer

#define		sda_ReadStatus	sda_SecUtilResult
	NTSTATUS		sda_SecUtilResult;	// Result of scurity utitility call
	PSID			sda_SecUtilSid;		// Name to Sid translation. Should be
										// freed if non-null.
	// The incoming packet is copied here. The parameters from the RequestBuf
	// are un-marshalled into this. Each API structures this differently. Make
	// sure sda_Name and sda_ReqBlock are together and next to each other AND
	// in this order. The code in afpapi.c depends on this while clearing this.
	// The extra DWORD is used in cases where the first entry is reused to
	// stored pointer values. On 64-bit architecture we require 2 DWORD at
	// the start of the ReqBlock.
	DWORD 			sda_ReqBlock[MAX_REQ_ENTRIES_PLUS_1];
	ANSI_STRING		sda_Name[MAX_VAR_ENTRIES];

#define	sda_Name1	sda_Name[0]
#define	sda_Name2	sda_Name[1]
#define	sda_Name3	sda_Name[2]

#define	sda_IOBuf	sda_ReplyBuf
#define	sda_IOSize	sda_ReplySize

	PBYTE			sda_ReplyBuf;		// Reply Buffer (variable size)

	AFPAPIWORKER	sda_WorkerRoutine;	// Api Worker
	WORK_ITEM		sda_WorkItem;		// For queueing up to worker threads

	PBYTE			sda_Challenge;		// Challenge from MSV1_0

	LIST_ENTRY		sda_DeferredQueue;	// Queue of deferred requests
	PBYTE			sda_NameBuf;		// Space is allocated for variable
										// part of request buffer here.
	PBYTE			sda_NameXSpace;
} SDA, *PSDA;

GLOBAL	AFP_SPIN_LOCK		AfpSdaLock EQU {0};// Lock for session list
GLOBAL	PSDA			AfpSessionList EQU NULL;
										// Linked-List of sessions

// These values are subject to tuning.
GLOBAL	LONG			AfpNumSessions EQU 0;
GLOBAL	UNICODE_STRING	AfpDefaultWksta EQU {0, 0, NULL};

extern
NTSTATUS
AfpSdaInit(
	VOID
);

extern
VOID
AfpSdaDeInit(
	VOID
);

extern
PSDA FASTCALL
AfpSdaCreateNewSession(
	IN	PVOID	SessionHandle,
    IN  BOOLEAN fOverTcp
);

extern
VOID FASTCALL
afpQueueDeferredRequest(
	IN	PSDA		pSda,
	IN	PREQUEST	pRequest
);

extern
PSDA FASTCALL
AfpSdaReferenceSessionById(
	IN	DWORD				SessId
);

extern
PSDA FASTCALL
AfpSdaReferenceSessionByPointer(
	IN	PSDA				pSda
);

extern
VOID FASTCALL
AfpSdaDereferenceSession(
	IN	PSDA				pSda
);

extern
AFPSTATUS FASTCALL
AfpSdaCloseSession(
	IN	PSDA				pSda
);

extern
AFPSTATUS
AfpAdmWSessionClose(
	IN	OUT	PVOID			Inbuf	OPTIONAL,
	IN	LONG				OutBufLen OPTIONAL,
	OUT	PVOID				Outbuf OPTIONAL
);

extern
AFPSTATUS FASTCALL
AfpSdaCheckSession(
	IN	PVOID				pContext
);

extern
VOID FASTCALL
AfpKillSessionsOverProtocol(
	IN	BOOLEAN     fAppletalkSessions
);

extern
VOID FASTCALL
afpUpdateDiskQuotaInfo(
    IN struct _ConnDesc *  pConnDesc
);

#ifdef	_SDA_LOCALS

LOCAL	DWORD		afpNextSessionId = 1;

LOCAL AFPSTATUS FASTCALL
afpCloseSessionAndFreeSda(
	IN	PSDA				pSda
);

#endif	// _SDA_LOCALS

#endif	// _SDA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\server.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	server.h

Abstract:

	This module contains server definition and data structures relating to
	server class APIs.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_SERVER_
#define	_SERVER_

// AfpGetSrvrMsg values
#define	SRVRMSG_LOGIN				0
#define	SRVRMSG_SERVER				1
#define	SRVRMSG_BITMAP_MESSAGE		1

// Attention word definitions. These are the only one's used.
#define	ATTN_SERVER_SHUTDOWN		0x8000
#define	ATTN_USER_DISCONNECT		0x9000
#define	ATTN_SERVER_MESSAGE			0x2000
#define ATTN_SERVER_NOTIFY          0x3001
#define	ATTN_TIME_MASK				0x0FFF

// AfpGetUserInfo values
#define	USERINFO_BITMAP_USERID		1
#define	USERINFO_BITMAP_PRIGID		2
#define	USERINFO_THISUSER			1

// AfpMapId subfunction values
#define	MAP_USER_ID					1
#define	MAP_GROUP_ID				2
#define	MAP_USER_NAME				3
#define	MAP_GROUP_NAME				4

#define	SRVRPARMS_VOLUMEHASPASS		0x80

// AfpGetSrvrInfo values
#define	SRVRINFO_SUPPORTS_COPYFILE	0x0001
#define	SRVRINFO_SUPPORTS_CHGPASSWD	0x0002
#define	SRVRINFO_DISALLOW_SAVEPASS	0x0004
#define	SRVRINFO_SUPPORTS_SERVERMSG	0x0008
#define SRVRINFO_SUPPORTS_SRVSIGN   0x0010
#define SRVRINFO_SUPPORTS_TCPIP     0x0020
#define SRVRINFO_SUPPORTS_SRVNOTIFY 0x0040
#define	SRVRINFO_SUPPORTS_MGETREQS	0x8000
#define	SRVRINFO_MASK				0x800F

// in hopes that we will save some network traffic, we delay server notification for
// some time, so if too many changes are happening (e.g. xcopy on that dir) then
// we send just one notification for several of the changes combined...
#define AFP_MIN_SRVR_NOTIF_INTERVAL 3

// at the same time, we don't want to not send a notification for too long
#define AFP_MAX_SRVR_NOTIF_INTERVAL 15

// Server State values.
#define	AFP_STATE_IDLE				0xFF
#define AFP_STATE_STOPPED			0x00
#define AFP_STATE_STOP_PENDING		0x01
#define AFP_STATE_START_PENDING		0x02
#define AFP_STATE_RUNNING			0x04
#define AFP_STATE_PAUSE_PENDING		0x08
#define AFP_STATE_PAUSED			0x10
#define AFP_STATE_CONTINUE_PENDING	0x20
#define	AFP_STATE_SHUTTINGDOWN		0x40
#define AFP_STATE_PENDING_ANY		(AFP_STATE_STOP_PENDING  | \
									AFP_STATE_START_PENDING | \
									AFP_STATE_PAUSE_PENDING | \
									AFP_STATE_CONTINUE_PENDING)

#define	AFP_XLAT_TABLE_SIZE			128
#define	AFP_REV_XLAT_TABLE_SIZE		256 - (0x80 - 0x20)

// all server global data must be non-pagable if it is protected by
// an executive spin-lock (i.e. accessed at IRQL DISPATCH_LEVEL)

GLOBAL	AFP_SPIN_LOCK			AfpServerGlobalLock EQU {0};
GLOBAL	AFP_SPIN_LOCK			AfpSwmrLock EQU {0};
GLOBAL	PBYTE					AfpServerIcon EQU NULL;
GLOBAL	PANSI_STRING			AfpServerMsg EQU NULL;
GLOBAL	ANSI_STRING				AfpServerName EQU { 0, 0 , NULL};
GLOBAL	ANSI_STRING				AfpLoginMsg EQU { 0, 0 , NULL};
GLOBAL	UNICODE_STRING			AfpLoginMsgU EQU { 0, 0 , NULL};

// There is no lock protecting the following codepage related variables
GLOBAL	PBYTE					AfpTranslationTable EQU NULL;
GLOBAL	PBYTE					AfpRevTranslationTable EQU NULL;
GLOBAL	PBYTE					AfpCasePreserveTranslationTable EQU NULL;
GLOBAL	PUSHORT					AfpMacCPBaseAddress EQU NULL;
GLOBAL	CPTABLEINFO				AfpMacCPTableInfo EQU { 0 };

GLOBAL	DWORD					AfpServerState EQU AFP_STATE_IDLE;
GLOBAL	DWORD					AfpServerMaxSessions EQU AFP_MAXSESSIONS;
GLOBAL	KEVENT					AfpStopConfirmEvent EQU { 0 };
GLOBAL	KMUTEX					AfpPgLkMutex EQU { 0 };
GLOBAL	DWORD					AfpServerOptions EQU AFP_SRVROPT_NONE;
GLOBAL	PDEVICE_OBJECT			AfpDeviceObject EQU NULL;
GLOBAL	BOOLEAN					AfpServerIsStandalone EQU { 0 };

GLOBAL	LONG					AfpEtcMapCount EQU 0;	// # valid entries
GLOBAL	LONG					AfpEtcMapsSize EQU 0;	// # entries allocated
GLOBAL	struct _EtcMapInfo *	AfpEtcMaps EQU NULL;	// array of entries
GLOBAL	struct _EtcMapInfo		AfpDefaultEtcMap EQU { 0 };
GLOBAL	SWMR					AfpEtcMapLock EQU { 0 };

GLOBAL	DWORD  			        AfpSecondsSinceEpoch EQU 0;
#ifdef USE_OBSOLETE_LSA_API
GLOBAL	HANDLE					AfpLsaHandle EQU NULL;
#endif

GLOBAL  CredHandle                              AfpSecHandle EQU {0, 0};
GLOBAL	HANDLE					AfpFspToken EQU NULL;

#ifdef OPTIMIZE_GUEST_LOGONS
GLOBAL	HANDLE					AfpGuestToken EQU NULL;
#endif

GLOBAL  ULONG                                   EncryptionKeyCount EQU 0;
GLOBAL	PEPROCESS				AfpProcessObject EQU NULL;
GLOBAL	DWORD					AfpAuthenticationPackage EQU 0;
GLOBAL	PETHREAD				AfpThread EQU NULL;

GLOBAL	AFP_SPIN_LOCK				AfpStatisticsLock EQU {0};
GLOBAL	AFP_STATISTICS_INFO_EX	AfpServerStatistics EQU { 0 };

GLOBAL  DWORD                   AfpSrvrNotifSentTime EQU 0;
GLOBAL  BOOLEAN                 fAfpServerShutdownEvent EQU FALSE;
GLOBAL  BOOLEAN                 fAfpAdminStop EQU FALSE;

#ifdef	PROFILING
GLOBAL	PAFP_PROFILE_INFO		AfpServerProfile EQU NULL;
#endif

GLOBAL	DWORD					AfpPagedPoolLimit EQU AFP_DEF_MAXPAGEDMEM * 1024;
GLOBAL	DWORD					AfpNonPagedPoolLimit EQU AFP_DEF_MAXNONPAGEDMEM * 1024;
GLOBAL	SECURITY_QUALITY_OF_SERVICE	AfpSecurityQOS EQU { 0 };
GLOBAL	ANSI_STRING				AfpVersions[AFP_NUM_VERSIONS] EQU { 0 };

#define	AfpVersion20			AfpVersions[AFP_VER_20]
#define	AfpVersion21			AfpVersions[AFP_VER_21]
#define	AfpVersion22			AfpVersions[AFP_VER_22]

GLOBAL	ANSI_STRING				AfpUamStrings[AFP_NUM_UAMS] EQU { 0 };

#define	AfpUamGuest				AfpUamStrings[NO_USER_AUTHENT]
#define	AfpUamClearText			AfpUamStrings[CLEAR_TEXT_AUTHENT]
#define	AfpUamCustomV1			AfpUamStrings[CUSTOM_UAM_V1]
#define	AfpUamCustomV2			AfpUamStrings[CUSTOM_UAM_V2]
#define AfpUamApple             AfpUamStrings[RANDNUM_EXCHANGE]
#define AfpUamApple2Way         AfpUamStrings[TWOWAY_EXCHANGE]

GLOBAL	LARGE_INTEGER			FiveSecTimeOut	EQU	{0, 0};
GLOBAL	LARGE_INTEGER			ThreeSecTimeOut	EQU	{0, 0};
GLOBAL	LARGE_INTEGER			TwoSecTimeOut	EQU	{0, 0};
GLOBAL  LARGE_INTEGER           OneSecTimeOut   EQU {0, 0};
GLOBAL	LARGE_INTEGER			LIZero			EQU {0, 0};
GLOBAL	UNICODE_STRING			UNullString 	EQU {0, 0, NULL};

GLOBAL  BYTE                    AfpServerSignature[16] EQU {0};

#define THREAD_BASE_PRIORITY_MAX    2   // maximum thread base priority boost

// To manage our own threads
#define	AFP_MIN_THREADS					3	// Independent of processors
#define	AFP_MAX_THREADS					200	// Independent of processors
#define	NUM_NOTIFY_QUEUES				2	// # of change notify threads

#define	AFP_THREAD_THRESHOLD_REQS		2
#define	AFP_THREAD_THRESHOLD_IDLE		8

typedef BYTE	THREAD_STATE, *PTHREAD_STATE;

typedef	LONG	(FASTCALL *WORKER)(IN PVOID);

#define	AFP_THREAD_DEAD					0
#define	AFP_THREAD_STARTED				1
#define	AFP_THREAD_WAITING				2
#define	AFP_THREAD_BUSY					3

typedef	struct
{
	LIST_ENTRY	wi_List;
	WORKER		wi_Worker;
	PVOID		wi_Context;
} WORK_ITEM, *PWORK_ITEM;

GLOBAL	WORK_ITEM				AfpTerminateThreadWI EQU { 0 };

#define	AfpInitializeWorkItem(pWI, Worker, Context)	\
		{											\
			InitializeListHead(&(pWI)->wi_List);	\
			(pWI)->wi_Worker = (WORKER)(Worker);	\
			(pWI)->wi_Context = (Context);			\
		}

GLOBAL	THREAD_STATE		AfpThreadState[AFP_MAX_THREADS]	EQU { AFP_THREAD_DEAD };
GLOBAL	PETHREAD			AfpThreadPtrsW[AFP_MAX_THREADS] EQU { NULL };
GLOBAL	PETHREAD			AfpThreadPtrsN[NUM_NOTIFY_QUEUES] EQU { NULL };

#if DBG
GLOBAL	LONG				AfpThreadDispCount[AFP_MAX_THREADS] EQU	{ 0 };
GLOBAL	AFP_SPIN_LOCK		AfpDebugSpinLock EQU {0};
GLOBAL  LIST_ENTRY          AfpDebugDelAllocHead;

GLOBAL  DWORD               AfpReadCMAlloced   EQU {0};
GLOBAL  DWORD               AfpWriteCMAlloced  EQU {0};
GLOBAL  DWORD               AfpDbgMdlsAlloced  EQU 0;
GLOBAL  DWORD               AfpDbgIrpsAlloced  EQU 0;

#define AFP_DBG_INC_COUNT(_Val)                         \
{                                                       \
    KIRQL       _OldIrql;                               \
    ACQUIRE_SPIN_LOCK(&AfpDebugSpinLock, &_OldIrql);    \
    _Val++;                                             \
    RELEASE_SPIN_LOCK(&AfpDebugSpinLock, _OldIrql);     \
}
#define AFP_DBG_DEC_COUNT(_Val)                         \
{                                                       \
    KIRQL       _OldIrql;                               \
    ACQUIRE_SPIN_LOCK(&AfpDebugSpinLock, &_OldIrql);    \
    if (_Val == 0)                                      \
    {                                                   \
        DbgPrint("How come this is 0!!\n");             \
        DbgBreakPoint();                                \
    }                                                   \
    _Val--;                                             \
    RELEASE_SPIN_LOCK(&AfpDebugSpinLock, _OldIrql);     \
}
#else
#define AFP_DBG_INC_COUNT(_Val)
#define AFP_DBG_DEC_COUNT(_Val)
#endif

GLOBAL	LONG				AfpLockCount		EQU 0;
GLOBAL	PVOID				AfpLockHandle		EQU NULL;
GLOBAL	LONG				AfpWorkerRequests	EQU 0;
GLOBAL	LONG				AfpNumThreads		EQU 0;
GLOBAL	LONG				AfpNumNotifyThreads	EQU 0;
GLOBAL	LONG				AfpNumAdminThreads	EQU 0;
GLOBAL	KQUEUE				AfpWorkerQueue		EQU { 0 };
GLOBAL	KQUEUE				AfpDelAllocQueue	EQU { 0 };
GLOBAL	KQUEUE				AfpAdminQueue		EQU { 0 };

GLOBAL	BOOLEAN				AfpIsMachineLittleEndian EQU True;

GLOBAL  HANDLE              AfpTdiNotificationHandle EQU NULL;
GLOBAL  BOOLEAN             AfpServerBoundToAsp      EQU FALSE;
GLOBAL  BOOLEAN             AfpServerBoundToTcp      EQU FALSE;

typedef	AFPSTATUS			(FASTCALL *AFPAPIWORKER)  (IN struct _SessDataArea *);
typedef	AFPSTATUS			(*ADMINAPIWORKER)(IN PVOID, IN LONG, OUT PVOID);
			
typedef	NTSTATUS			(*AFPINITSUBS)	(VOID);
typedef	VOID				(*AFPDEINITSUBS)(VOID);

#define AFPAttachProcess(_CurrProc)                   \
{                                                     \
    if ((_CurrProc) != AfpProcessObject)  \
    {                                                 \
        KeAttachProcess( (PRKPROCESS)AfpProcessObject );\
    }                                                 \
}

#define AFPDetachProcess(_CurrProc)                   \
{                                                     \
    if ((_CurrProc) != AfpProcessObject)  \
    {                                                 \
        KeDetachProcess();                            \
    }                                                 \
}

extern
NTSTATUS
AfpInitializeDataAndSubsystems(
	VOID
);

extern
VOID
AfpDeinitializeSubsystems(
	VOID
);

extern
VOID FASTCALL
AfpUnmarshallReq(
	IN	struct _SessDataArea *  pSda
);

extern
VOID FASTCALL
AfpDisposeRequest(
	IN	struct _SessDataArea *  pSda,
	IN	AFPSTATUS				RetCode
);

extern
VOID FASTCALL
AfpStartApiProcessing(
	IN	struct _SessDataArea *  pSda
);

extern
VOID FASTCALL
AfpCompleteApiProcessing(
	IN	struct _SessDataArea *  pSda,
	IN	AFPSTATUS				RetCode
);

extern
NTSTATUS FASTCALL
AfpGetWriteBuffer(
	IN	struct _SessDataArea *  pSda,
	IN	PREQUEST                pRequest
);

extern
NTSTATUS
AfpSetServerStatus(
	IN VOID
);

extern
AFPSTATUS
AfpAdmWServerSetInfo(
	IN	OUT	PVOID 				Inbuf		OPTIONAL,
	IN	LONG					OutBufLen	OPTIONAL,
	OUT	PVOID 					Outbuf		OPTIONAL
);


extern
NTSTATUS FASTCALL
AfpCreateNewThread(
	IN	VOID					(*ThreadFunc)(IN PVOID pContext),
	IN	LONG					ThreadNum
);


extern
VOID FASTCALL
AfpInitStrings(
    IN VOID
);


extern
VOID
AfpWorkerThread(
	IN	PVOID					pContext
);

extern
VOID FASTCALL
AfpQueueWorkItem(
	IN	PWORK_ITEM				pWI
);

extern
VOID
AfpSleepAWhile(
	IN	DWORD					SleepDuration
);

#ifdef	SERVER_LOCALS

#define	NUM_INIT_SYSTEMS		11

typedef struct _AfpInitSystems
{
	AFPINITSUBS		InitRoutine;
	AFPDEINITSUBS	DeInitRoutine;
#if DBG
	BOOLEAN			Initialized;
	BOOLEAN			Deinitialized;
	PCHAR			InitRoutineName;
	PCHAR			DeInitRoutineName;
#endif
} INIT_SYSTEMS, *PINIT_SYSTEMS;

extern	INIT_SYSTEMS	AfpInitSubSystems[];

extern
VOID FASTCALL
afpQueueDeferredRequest(
	IN	struct _SessDataArea *  pSda,
	IN	PREQUEST				pRequest
);

#endif	// SERVER_LOCALS

#endif	// _SERVER_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\tcp.h ===
/*

Copyright (c) 1998  Microsoft Corporation

Module Name:

	tcp.h

Abstract:

	This module contains definitions, declarations relevant to AFP/TCP


Author:

	Shirish Koti


Revision History:
	22 Jan 1998		Initial Version

--*/

#ifndef _TCP_
#define _TCP_

#define INVALID_HANDLE_VALUE          ((HANDLE)(-1))

#define AFP_TCP_BINDNAME        L"\\Device\\Tcp"
#define AFP_TCP_PORT            548

#define DSI_ADAPTER_SIGNATURE    *(DWORD *)"TADP"
#define DSI_CONN_SIGNATURE       *(DWORD *)"TCON"
#define DSI_REQUEST_SIGNATURE    *(DWORD *)"DREQ"

// number of connections on the free list
#define DSI_INIT_FREECONNLIST_SIZE   10

typedef ULONG   IPADDRESS;

// let's not send more than 10 ipaddresses to the Mac
#define DSI_MAX_IPADDR_COUNT    10

#define DSI_NETWORK_ADDR_LEN    6
#define DSI_NETWORK_ADDR_IPTAG  0x01

#define ATALK_NETWORK_ADDR_LEN      6
#define ATALK_NETWORK_ADDR_ATKTAG   0x03


#define DSI_HEADER_SIZE         16

#define DSI_TICKLE_TIMER        30   // every 30 seconds, see who needs a tickle
#define DSI_TICKLE_TIME_LIMIT   30   // if 30+ seconds since we last heard, send tickle

// the only DSI packets (i.e. packets that originate from the DSI layer) are
// for DsiOpenSession, DsiCloseSession and DsiTickle.  DsiOpenSession is the
// largest of these because it has the 6 bytes of options.  The spec says that
// this is a variable length field, but it only has given one option (Server
// Request Quantum) that the server can send.  If more options are ever defined,
// this define will have to change.  For now, only 6 additional bytes
//
#define DSI_MAX_DSI_OPTION_LEN  6
#define DSI_OPENSESS_OPTION_LEN 4
#define DSI_OPTION_FIXED_LEN    2

#define DSI_MAX_DSI_PKT_SIZE    (DSI_HEADER_SIZE + DSI_MAX_DSI_OPTION_LEN)

// round off to dword-align
#define DSI_BUFF_SIZE        ((DSI_MAX_DSI_PKT_SIZE) + (4 - (DSI_MAX_DSI_PKT_SIZE%4)))


//
// the htonX macros 'lifted' from sockets\netinet\in.h
//
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define htons(x) _byteswap_ushort((USHORT)(x))
#define htonl(x) _byteswap_ulong((ULONG)(x))
#else
#define htons(x)        ((((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00))

#define htonl(x)        ((((x) >> 24) & 0x000000FFL) | \
                         (((x) >>  8) & 0x0000FF00L) | \
                         (((x) <<  8) & 0x00FF0000L) | \
                         (((x) << 24) & 0xFF000000L))
#endif
#define ntohs(x)    htons(x)
#define ntohl(x)    htonl(x)

typedef NTSTATUS (FASTCALL *DSI_WORKER)(IN PVOID Context);

typedef struct _IpAddrEntity
{
    LIST_ENTRY  Linkage;
    IPADDRESS   IpAddress;

} IPADDRENTITY, *PIPADDRENTITY;


typedef struct _TcpAdptr
{
    DWORD               adp_Signature;
    DWORD               adp_RefCount;
    DWORD               adp_State;
    LIST_ENTRY          adp_ActiveConnHead;
    LIST_ENTRY          adp_FreeConnHead;
    DWORD               adp_NumFreeConnections;
    AFP_SPIN_LOCK       adp_SpinLock;
    HANDLE              adp_FileHandle;
    PFILE_OBJECT        adp_pFileObject;

} TCPADPTR, *PTCPADPTR;


// values for the adp_State field of TCPADPTR
#define TCPADPTR_STATE_INIT         0x1
#define TCPADPTR_STATE_BOUND        0x2
#define TCPADPTR_STATE_CLOSING      0x4
#define TCPADPTR_STATE_CLEANED_UP   0x8

//
// the DSI Commands
//
#define DSI_COMMAND_CLOSESESSION 1
#define DSI_COMMAND_COMMAND      2
#define DSI_COMMAND_GETSTATUS    3
#define DSI_COMMAND_OPENSESSION  4
#define DSI_COMMAND_TICKLE       5
#define DSI_COMMAND_WRITE        6
#define DSI_COMMAND_ATTENTION    8


//
// call-ins into AFP
//
#define AfpCB_SessionNotify       AfpSdaCreateNewSession
#define AfpCB_RequestNotify       afpSpHandleRequest
#define AfpCB_GetWriteBuffer      AfpGetWriteBuffer
#define AfpCB_ReplyCompletion     afpSpReplyComplete
#define AfpCB_AttnCompletion      afpSpAttentionComplete
#define AfpCB_CloseCompletion     afpSpCloseComplete

typedef struct _DsiReq
{
    LIST_ENTRY      dsi_Linkage;
    DWORD           dsi_Signature;
    struct _TcpConn *dsi_pTcpConn;       // the connection that this req belongs to
    REQUEST         dsi_AfpRequest;      // the request structure for AFP's use
    DWORD           dsi_RequestLen;      // how many bytes in the DSI command
    DWORD           dsi_WriteLen;        // total bytes to write (only in DSIWrite)
    USHORT          dsi_RequestID;       // what's the request ID
    BYTE            dsi_Command;         // what command is it
    BYTE            dsi_Flags;           // is this a request or a response?
    PBYTE           dsi_PartialBuf;      // buffer, in case partial data arrives
    DWORD           dsi_PartialBufSize;  // number of bytes in the partial buffer
    DWORD           dsi_PartialWriteSize; // number of bytes of the Write got so far
    PMDL            dsi_pDsiAllocedMdl;   // our mdl, if afp doesn't give us one
    PVOID           dsi_AttnContext;      // afp's context for SendAttention
    BYTE            dsi_RespHeader[DSI_BUFF_SIZE];  // header during response
} DSIREQ, *PDSIREQ;


typedef struct _TcpConn
{
    LIST_ENTRY          con_Linkage;
    DWORD               con_Signature;
    PTCPADPTR           con_pTcpAdptr;
    DWORD               con_RefCount;
    USHORT              con_State;
    USHORT              con_RcvState;
    DWORD               con_BytesWithTcp;
    DWORD               con_LastHeard;
    IPADDRESS           con_DestIpAddr;
    PDSIREQ             con_pDsiReq;
    LIST_ENTRY          con_PendingReqs;
    PSDA                con_pSda;
    PIRP                con_pRcvIrp;
    DWORD               con_MaxAttnPktSize;
    USHORT              con_OutgoingReqId;
    USHORT              con_NextReqIdToRcv;
    HANDLE              con_FileHandle;
    PFILE_OBJECT        con_pFileObject;
    AFP_SPIN_LOCK       con_SpinLock;
} TCPCONN, *PTCPCONN;


// values for the con_State field of TCPCONN
#define TCPCONN_STATE_INIT                  0x001
#define TCPCONN_STATE_CONNECTED             0x002
#define TCPCONN_STATE_AFP_ATTACHED          0x004
#define TCPCONN_STATE_NOTIFY_AFP            0x008
#define TCPCONN_STATE_NOTIFY_TCP            0x010
#define TCPCONN_STATE_PARTIAL_DATA          0x020
#define TCPCONN_STATE_TCP_HAS_IRP           0x040
#define TCPCONN_STATE_TICKLES_STOPPED       0x080
#define TCPCONN_STATE_CLOSING               0x100
#define TCPCONN_STATE_ABORTIVE_DISCONNECT   0x200
#define TCPCONN_STATE_RCVD_REMOTE_CLOSE     0x400
#define TCPCONN_STATE_CLEANED_UP            0x800


// values for con_RcvState field of TCPCONN
#define DSI_NEW_REQUEST         0    // waiting for new request
#define DSI_PARTIAL_HEADER      1    // got 1 or more but, less than 16 bytes of hdr
#define DSI_HDR_COMPLETE        2    // got full header, but 0 data
#define DSI_PARTIAL_COMMAND     3    // got full hdr, and part of data
#define DSI_COMMAND_COMPLETE    4    // got hdr and all the data with it
#define DSI_AWAITING_WRITE_MDL  5    // awaiting write mdl from afp server
#define DSI_PARTIAL_WRITE       6    // write command in progress
#define DSI_WRITE_COMPLETE      7    // all write bytes are in

#define DSI_REQUEST     0
#define DSI_REPLY       1

#define DSI_OFFSET_FLAGS            0
#define DSI_OFFSET_COMMAND          1
#define DSI_OFFSET_REQUESTID        2
#define DSI_OFFSET_DATAOFFSET       4
#define DSI_OFFSET_ERROROFFSET      4
#define DSI_OFFSET_DATALEN          8
#define DSI_OFFSET_RESERVED         12

#define DSI_OFFSET_OPTION_TYPE      0
#define DSI_OFFSET_OPTION_LENGTH    1
#define DSI_OFFSET_OPTION_OPTION    2

#define DSI_OPTION_SRVREQ_QUANTUM   0

#define DSI_SERVER_REQUEST_QUANTUM    65535

//
// get the relevant info from the DSI header.  If it's a Write
// request, the Enclosed Data Offset field contains how big the
// request part is.  The Total Data Length field contains how many
// bytes follow the DSI header.  The difference between the two
// is the size of the Write.
//

#define DSI_PARSE_HEADER(_pDsiReq, _Buffer)                         \
{                                                                   \
    (_pDsiReq)->dsi_Flags = (_Buffer)[DSI_OFFSET_FLAGS];            \
    (_pDsiReq)->dsi_Command = (_Buffer)[DSI_OFFSET_COMMAND];        \
                                                                    \
    GETSHORT2SHORT((&((_pDsiReq)->dsi_RequestID)),                  \
                   (&(_Buffer)[DSI_OFFSET_REQUESTID]));             \
                                                                    \
    if ((_pDsiReq)->dsi_Command == DSI_COMMAND_WRITE)               \
    {                                                               \
        GETDWORD2DWORD((&((_pDsiReq)->dsi_RequestLen)),             \
                       (&(_Buffer)[DSI_OFFSET_DATAOFFSET]));        \
                                                                    \
        GETDWORD2DWORD((&((_pDsiReq)->dsi_WriteLen)),               \
                       (&(_Buffer)[DSI_OFFSET_DATALEN]));           \
                                                                    \
        (_pDsiReq)->dsi_WriteLen -= (_pDsiReq)->dsi_RequestLen;     \
    }                                                               \
    else                                                            \
    {                                                               \
        GETDWORD2DWORD((&((_pDsiReq)->dsi_RequestLen)),             \
                       (&(_Buffer)[DSI_OFFSET_DATALEN]));           \
    }                                                               \
}


typedef struct _DsiHeader
{
    BYTE        Flags;
    BYTE        Command;
    USHORT      RequestID;
    DWORD       DataOffset;
    DWORD       TotalLength;
    DWORD       Reserved;
} DSIHEADER, *PDSIHEADER;


typedef struct _TcpWorkItem
{
    WORK_ITEM       tcp_WorkItem;
    DSI_WORKER      tcp_Worker;
    PVOID           tcp_Context;
} TCPWORKITEM, *PTCPWORKITEM;

#define VALID_TCPCONN(_pTcpConn)                                       \
    ((_pTcpConn->con_Signature == DSI_CONN_SIGNATURE) &&               \
     (_pTcpConn->con_RefCount > 0 && _pTcpConn->con_RefCount < 5000))   \


#define DsiTerminateConnection(pTcpConn)    \
        DsiKillConnection(pTcpConn, 0)

#define DsiAbortConnection(pTcpConn)        \
        DsiKillConnection(pTcpConn, TDI_DISCONNECT_ABORT)


//
// the globals
//

GLOBAL  PTCPADPTR       DsiTcpAdapter EQU NULL;

GLOBAL  AFP_SPIN_LOCK   DsiAddressLock;
GLOBAL  LIST_ENTRY      DsiIpAddrList;

GLOBAL  PBYTE           DsiStatusBuffer EQU NULL;
GLOBAL  DWORD           DsiStatusBufferSize EQU 0;

GLOBAL  BOOLEAN         DsiTcpEnabled EQU TRUE;

GLOBAL  AFP_SPIN_LOCK   DsiResourceLock;
GLOBAL  LIST_ENTRY      DsiFreeRequestList;
GLOBAL  DWORD           DsiFreeRequestListSize EQU 0;

GLOBAL  DWORD           DsiNumTcpConnections EQU 0;

GLOBAL  KEVENT          DsiShutdownEvent EQU {0};

//
// prototypes for functions in dsi.c
//

NTSTATUS
DsiAfpSetStatus(
    IN  PVOID   Context,
    IN  PUCHAR  pStatusBuf,
    IN  USHORT  StsBufSize
);

NTSTATUS
DsiAfpCloseConn(
    IN  PTCPCONN    pTcpConn
);

NTSTATUS
DsiAfpFreeConn(
    IN  PTCPCONN    pTcpConn
);

NTSTATUS FASTCALL
DsiAfpListenControl(
    IN  PVOID       Context,
    IN  BOOLEAN     Enable
);

NTSTATUS FASTCALL
DsiAfpWriteContinue(
    IN  PREQUEST    pRequest
);

NTSTATUS FASTCALL
DsiAfpReply(
    IN  PREQUEST    pRequest,
    IN  PBYTE       pResultCode
);

NTSTATUS
DsiAfpSendAttention(
    IN  PTCPCONN    pTcpConn,
    IN  USHORT      AttentionWord,
    IN  PVOID       pContext
);

NTSTATUS
DsiAcceptConnection(
    IN  PTCPADPTR       pTcpAdptr,
    IN  IPADDRESS       MacIpAddr,
    OUT PTCPCONN       *ppRetTcpConn
);


NTSTATUS
DsiProcessData(
    IN  PTCPCONN    pTcpConn,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    IN  PBYTE       pDsiData,
    OUT PULONG      pBytesAccepted,
    OUT PIRP       *ppRetIrp
);


BOOLEAN
DsiValidateHeader(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq
);


NTSTATUS
DsiAfpReplyCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
);


NTSTATUS
DsiAcceptConnectionCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            Context
);

BOOLEAN
DsiKillConnection(
    IN  PTCPCONN    pTcpConn,
    IN DWORD        DiscFlag
);

NTSTATUS
DsiDisconnectWithTcp(
    IN  PTCPCONN    pTcpConn,
    IN DWORD        DiscFlag
);

NTSTATUS
DsiDisconnectWithAfp(
    IN  PTCPCONN    pTcpConn,
    IN  NTSTATUS    Reason
);

NTSTATUS
DsiTcpDisconnectCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            Context
);

NTSTATUS
DsiTcpRcvIrpCompletion(
    IN  PDEVICE_OBJECT  Unused,
    IN  PIRP            pIrp,
    IN  PVOID           pContext
);

NTSTATUS
DsiExecuteCommand(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq
);


NTSTATUS
DsiOpenSession(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq
);

NTSTATUS
DsiSendDsiRequest(
    IN  PTCPCONN    pTcpConn,
    IN  DWORD       DataLen,
    IN  USHORT      AttentionWord,
    IN  PVOID       AttentionContext,
    IN  BYTE        Command
);

NTSTATUS
DsiSendDsiReply(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq,
    IN  NTSTATUS    OpStatus
);

NTSTATUS
DsiSendStatus(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq
);


AFPSTATUS FASTCALL
DsiSendTickles(
    IN  PVOID pUnUsed
);


NTSTATUS
DsiSendCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
);



//
// prototypes for functions in tcptdi.c
//

NTSTATUS
DsiOpenTdiAddress(
    IN  PTCPADPTR       pTcpAdptr,
    OUT PHANDLE         pRetFileHandle,
    OUT PFILE_OBJECT   *ppRetFileObj
);


NTSTATUS
DsiOpenTdiConnection(
    IN PTCPCONN     pTcpConn
);

NTSTATUS
DsiAssociateTdiConnection(
    IN PTCPCONN     pTcpConn
);

NTSTATUS
DsiSetEventHandler(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PFILE_OBJECT     pFileObject,
    IN ULONG            EventType,
    IN PVOID            EventHandler,
    IN PVOID            Context
);

NTSTATUS
DsiTdiSynchronousIrp(
    IN PIRP             pIrp,
    PDEVICE_OBJECT      pDeviceObject
);

NTSTATUS
DsiTdiCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
);


NTSTATUS
DsiTdiSend(
    IN  PTCPCONN    pTcpConn,
    IN  PMDL        pMdl,
    IN  DWORD       DataLen,
    IN  PVOID       pCompletionRoutine,
    IN  PVOID       pContext
);

VOID
DsiIpAddressCameIn(
    IN  PTA_ADDRESS         Address,
    IN  PUNICODE_STRING     DeviceName,
    IN  PTDI_PNP_CONTEXT    Context2
);

VOID
DsiIpAddressWentAway(
    IN  PTA_ADDRESS         Address,
    IN  PUNICODE_STRING     DeviceName,
    IN  PTDI_PNP_CONTEXT    Context2
);

NTSTATUS
DsiTdiConnectHandler(
    IN PVOID                EventContext,
    IN int                  MacIpAddrLen,
    IN PVOID                pSrcAddress,
    IN int                  DsiDataLength,
    IN PVOID                pDsiData,
    IN int                  OptionsLength,
    IN PVOID                pOptions,
    OUT CONNECTION_CONTEXT  *pOurConnContext,
    OUT PIRP                *ppOurAcceptIrp
);

NTSTATUS
DsiTdiReceiveHandler(
    IN  PVOID       EventContext,
    IN  PVOID       ConnectionContext,
    IN  USHORT      RcvFlags,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    OUT PULONG      pBytesAccepted,
    IN  PVOID       pDsiData,
    OUT PIRP       *ppIrp
);

NTSTATUS
DsiTdiDisconnectHandler(
    IN PVOID        EventContext,
    IN PVOID        ConnectionContext,
    IN ULONG        DisconnectDataLength,
    IN PVOID        pDisconnectData,
    IN ULONG        DisconnectInformationLength,
    IN PVOID        pDisconnectInformation,
    IN ULONG        DisconnectIndicators
);

NTSTATUS
DsiTdiErrorHandler(
    IN PVOID    EventContext,
    IN NTSTATUS Status
);


NTSTATUS
DsiCloseTdiAddress(
    IN PTCPADPTR    pTcpAdptr
);

NTSTATUS
DsiCloseTdiConnection(
    IN PTCPCONN     pTcpConn
);

//
// prototypes for functions in tcputil.c
//

VOID
DsiInit(
    IN VOID
);

NTSTATUS FASTCALL
DsiCreateAdapter(
    IN VOID
);

BOOLEAN
IsThisOnAppletalksDefAdapter(
    IN PUNICODE_STRING  pBindDeviceName
);

NTSTATUS FASTCALL
DsiCreateTcpConn(
    IN PTCPADPTR    pTcpAdptr
);

NTSTATUS
DsiAddIpaddressToList(
    IN  IPADDRESS   IpAddress
);

BOOLEAN
DsiRemoveIpaddressFromList(
    IN  IPADDRESS   IpAddress
);

PDSIREQ
DsiGetRequest(
    IN VOID
);

PBYTE
DsiGetReqBuffer(
    IN DWORD    BufLen
);

VOID
DsiFreeRequest(
    PDSIREQ     pDsiReq
);

VOID
DsiFreeReqBuffer(
    IN PBYTE    pBuffer
);

VOID
DsiDereferenceAdapter(
    IN PTCPADPTR    pTcpAdptr
);

VOID
DsiDereferenceConnection(
    IN PTCPCONN     pTcpConn
);

NTSTATUS
DsiDestroyAdapter(
    IN VOID
);

NTSTATUS FASTCALL
DsiFreeAdapter(
    IN PTCPADPTR    pTcpAdptr
);

NTSTATUS FASTCALL
DsiFreeConnection(
    IN PTCPCONN     pTcpConn
);

NTSTATUS
DsiGetIpAddrBlob(
    IN DWORD    *pIpAddrCount,
    IN PBYTE    *ppIpAddrBlob
);

PIRP
DsiGetIrpForTcp(
    IN  PTCPCONN    pTcpConn,
    IN  PBYTE       pBuffer,
    IN  PMDL        pInputMdl,
    IN  DWORD       ReadSize
);

PMDL
DsiMakePartialMdl(
    IN  PMDL        pOrgMdl,
    IN  DWORD       dwOffset
);

NTSTATUS FASTCALL
DsiUpdateAfpStatus(
    IN PVOID    Unused
);

NTSTATUS
DsiScheduleWorkerEvent(
    IN  DSI_WORKER      WorkerRoutine,
    IN  PVOID           Context
);

VOID FASTCALL
DsiWorker(
    IN PVOID    Context
);

PTCPADPTR
DsiRefAdptrByBindName(
    IN  PUNICODE_STRING    pBindDeviceName
);

VOID
DsiShutdown(
    IN VOID
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\secutil.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	secutil.h

Abstract:


Author:

	Narendra Gidwani (microsoft!NarenG)


Revision History:
	8 Sept. 1992			 Initial Version

Notes:  Tab stop: 4
--*/
											
#ifndef	_SECUTIL_
#define	_SECUTIL_

typedef struct _AFP_SID_NAME
{
	AFPTIME					LastAccessedTime;
	UNICODE_STRING			Name;
	struct _AFP_SID_NAME *	SidLink;		
	BYTE					Sid[1]; 	
} AFP_SID_NAME, *PAFP_SID_NAME;


typedef struct _AFP_SID_MACID
{
	struct _AFP_SID_MACID   *Next;
    DWORD                   MacId;
	BYTE					Sid[1]; 	
} AFP_SID_MACID, *PAFP_SID_MACID;

extern
NTSTATUS
AfpSecUtilInit(
	VOID
);

extern
VOID
AfpSecUtilDeInit(
	VOID
);

extern
NTSTATUS
AfpSecurityUtilityWorker(
	IN	PIRP pIrp,
	IN	PIO_STACK_LOCATION pIrpSp
);

extern
NTSTATUS FASTCALL
AfpNameToSid(
	IN	PSDA			  pSda,
	IN	PUNICODE_STRING   Name
);

extern
NTSTATUS
AfpSidToName(
	IN	PSDA			pSda,
	IN	PSID			Sid,
	OUT	PAFP_SID_NAME *	ppTranslatedSid
);

extern
NTSTATUS FASTCALL
AfpSidToMacId(
	IN	PSID			Sid,
	OUT PULONG			pMacId
);

extern
NTSTATUS FASTCALL
AfpMacIdToSid(
	IN	ULONG			MacId,
	OUT PSID *			ppSid
);

extern
NTSTATUS FASTCALL
AfpChangePassword(
	IN	PSDA				pSda,
	IN	PAFP_PASSWORD_DESC	pPassword
);


extern
AFPSTATUS FASTCALL
AfpInitSidOffsets(
	IN	ULONG			SidOffstPairs,
	IN	PAFP_SID_OFFSET	pSidOff
);

extern
VOID
AfpTerminateSecurityUtility(
	VOID
);

#ifdef	_SECUTIL_LOCALS

#define SIZE_SID_LOOKUP_TABLE			51
#define SID_HASH_RADIX					11
#define	SID_NAME_AGE					300	// In seconds

#define MAX_SECWORKITEM_QLEN            5000

typedef	VOID (*SEC_COMPLETION_ROUTINE)(IN ULONG, IN PVOID);

typedef struct _SEC_WORK_ITEM
{
	LIST_ENTRY				Links;

	PVOID					pOutput;
	LONG					OutputBufSize;
	SEC_COMPLETION_ROUTINE	pCompletionRoutine;
	PKEVENT					pCompletionEvent;
	PSDA					pSda;
} SEC_WORK_ITEM, *PSEC_WORK_ITEM;

typedef enum _SECURITY_THREAD_STATE
{
	IDLE=1,
  	BUSY,
	NOT_AVAILABLE

} SECURITY_THREAD_STATE;

typedef struct _AFP_SECURITY_THREAD
{

	SECURITY_THREAD_STATE	State;
	PIRP					pIrp;
 	PSEC_WORK_ITEM			pSecWorkItem;
} AFP_SECURITY_THREAD, *PAFP_SECURITY_THREAD;

// Array of utiity threads

LOCAL	AFP_SECURITY_THREAD 	afpSecurityThread[NUM_SECURITY_UTILITY_THREADS] = { 0 };

// Hash table for SID/Name cache

LOCAL	PAFP_SID_NAME *			afpSidLookupTable	= (PAFP_SID_NAME*)NULL;
LOCAL   PAFP_SID_MACID *        afpSidToMacIdTable  = (PAFP_SID_MACID*)NULL;

LOCAL   PAFP_SID_MACID          afpLastCachedSid = (PAFP_SID_MACID)NULL;
LOCAL   DWORD                   afpNextMacIdToUse = 1;

// Queue of work items for the SecurityThreads

LOCAL	LIST_ENTRY				afpSecWorkItemQ = { 0 };
LOCAL   DWORD                   afpSecWorkItemQLength = { 0 };


// Single Writer Multi Reader for the SID/Name cache

LOCAL	SWMR 					afpSWMRForSidNameCache = { 0 };

// Spinlock protects the array of worker threads, the work queue and the
// 'in progress' count/event
LOCAL	AFP_SPIN_LOCK				afpSecUtilLock = { 0 };

// Signalled when no work is in progress.
LOCAL	KEVENT					afpUtilWorkInProgressEvent = { 0 };
LOCAL	LONG					afpUtilWorkInProgress = 0;


LOCAL
NTSTATUS
afpQueueSecWorkItem(
	IN	AFP_FSD_CMD_ID			FsdCommand,
	IN	PSDA					pSda,
	IN	PKEVENT					pCompletionEvent,
	IN	PAFP_FSD_CMD_PKT 		pAfpFsdCmdPkt,
	IN	LONG					BufSize,
	IN	SEC_COMPLETION_ROUTINE	pCompletionRoutine
);

#define	ALLOC_SWI()	(PSEC_WORK_ITEM)AfpAllocNonPagedMemory(sizeof(SEC_WORK_ITEM))

LOCAL VOID
afpCompleteNameToSid(
	IN ULONG Index,
	IN PVOID pInBuf
);

LOCAL VOID
afpCompleteSidToName(
	IN ULONG Index,
	IN PVOID pInBuf
);

LOCAL VOID
afpCompleteMacIdToSid(
	IN ULONG Index,
	IN PVOID pInBuf
);

LOCAL VOID
afpCompleteChangePassword(
	IN ULONG Index,
	IN PVOID pInBuf
);

LOCAL VOID
afpCompleteLogEvent(
	IN	ULONG	Index,
	IN	PVOID	pInBuf
);

LOCAL NTSTATUS FASTCALL
afpUpdateNameSidCache(
	IN WCHAR * Name,
	IN PSID	Sid
);

LOCAL PAFP_SID_NAME FASTCALL
afpLookupSid(
	IN	PSID Sid
);

LOCAL ULONG FASTCALL
afpHashSid(
	IN PSID	Sid
);

LOCAL VOID
afpDeInitializeSecurityUtility(
	VOID
);

AFPSTATUS FASTCALL
afpAgeSidNameCache(
	IN	PVOID	pContext
);

#endif	// _SECUTIL_LOCALS

#endif	// _SECUTIL_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\secutil.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	secutil.c

Abstract:

	This module contains code to accomplish the following tasks:

	1) Translate a SID to a name.
	2) Translate a name to a SID.
	3) Change the password for a given user.
	4) Translate a SID to a Mac Id.
	5) Translate a Mac Id to a SID.
	6) Server event logging

	This module communicates with the AFP Server Service to accomplish these
	functions. The real work is done in the Server Service. This utility
	exists because these functions cannot be made by calling APIs in kernel
	mode.

	The basic flow of control begins with an FSCTL from the server service.
	This FSCTL is marked as pending till one of the four functions is to be
	carried out. Then the IRP output buffer contains the function ID and
	function input data and the IRP is maeked as complete. The actual
	function is executed by the server service and the results are obtained
	by the server FSD via the next FSCTL. Most if this information is cached
	in paged-memory.


Author:

	Narendra Gidwani (microsoft!nareng)

Revision History:
	8	Sept 1992 		Initial Version
	28	Jan	 1993		SueA - added support for server event logging

--*/

#define	_SECUTIL_LOCALS
#define	FILENUM	FILE_SECUTIL

#include <afp.h>
#include <scavengr.h>
#include <secutil.h>
#include <access.h>
#include <seposix.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AfpSecUtilInit)
#pragma alloc_text(PAGE, AfpSecUtilDeInit)
#pragma alloc_text(PAGE, afpDeInitializeSecurityUtility)
#pragma alloc_text(PAGE, AfpInitSidOffsets)
#pragma alloc_text(PAGE, AfpNameToSid)
#pragma alloc_text(PAGE, afpCompleteNameToSid)
#pragma alloc_text(PAGE, AfpSidToName)
#pragma alloc_text(PAGE, afpCompleteSidToName)
#pragma alloc_text(PAGE, AfpSidToMacId)
#pragma alloc_text(PAGE, AfpMacIdToSid)
#pragma alloc_text(PAGE, AfpChangePassword)
#pragma alloc_text(PAGE, afpCompleteChangePassword)
#pragma alloc_text(PAGE, afpLookupSid)
#pragma alloc_text(PAGE, afpUpdateNameSidCache)
#pragma alloc_text(PAGE, afpHashSid)
#pragma alloc_text(PAGE, AfpLogEvent)
#pragma alloc_text(PAGE, afpCompleteLogEvent)
#pragma alloc_text(PAGE, afpQueueSecWorkItem)
#pragma alloc_text(PAGE, afpAgeSidNameCache)
#endif


/***	AfpSecUtilInit
 *
 *	This routine will allocate intialize all the cache tables and
 * 	data structures used by this module. afpDeInitializeSecurityUtility
 *	should be call to Deallocate this memory.
 */
NTSTATUS
AfpSecUtilInit(
	VOID
)
{
	ULONG		Index;
	NTSTATUS	Status = STATUS_SUCCESS;

	// Initialize
	do
	{
		INITIALIZE_SPIN_LOCK(&afpSecUtilLock);

		// Set to Signalled state initially since there is no work in progress
		KeInitializeEvent(&afpUtilWorkInProgressEvent, NotificationEvent, True);

		// Initialize Single Write Multi-reader access for the SID/NAME cache
		AfpSwmrInitSwmr(&afpSWMRForSidNameCache);

		InitializeListHead(&afpSecWorkItemQ);

		// Allocate space for the SID Lookup table
		afpSidLookupTable = (PAFP_SID_NAME*)ALLOC_ACCESS_MEM(sizeof(PAFP_SID_NAME) * SIZE_SID_LOOKUP_TABLE);

		if (afpSidLookupTable == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		// Initialize Sid lookup table
	 	RtlZeroMemory(afpSidLookupTable,
					  sizeof(PAFP_SID_NAME) * SIZE_SID_LOOKUP_TABLE);

        afpSidToMacIdTable = (PAFP_SID_MACID *)
                ALLOC_ACCESS_MEM(sizeof(PAFP_SID_MACID) * SIZE_SID_LOOKUP_TABLE);

        if (afpSidToMacIdTable == NULL)
        {
            AfpFreeMemory(afpSidLookupTable);
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
        }

        RtlZeroMemory(afpSidToMacIdTable, sizeof(PAFP_SID_NAME) * SIZE_SID_LOOKUP_TABLE);

		// Initialize array of thread structures.
	 	for (Index = 0; Index < NUM_SECURITY_UTILITY_THREADS; Index++)
		{
		 	afpSecurityThread[Index].State = NOT_AVAILABLE;
		 	afpSecurityThread[Index].pSecWorkItem = (PSEC_WORK_ITEM)NULL;
		 	afpSecurityThread[Index].pIrp = (PIRP)NULL;
		}

		// Start the aging process
		AfpScavengerScheduleEvent(afpAgeSidNameCache,
								  NULL,
								  SID_NAME_AGE,
								  True);
	} while(False);

	return Status;
}


/***	AfpSecUtilDeInit
 *
 *	This routine will free the allocated resources from this module.
 * 	This is called during server unload.
 */
VOID
AfpSecUtilDeInit(
	VOID
)
{
	PAFP_SID_NAME 		  pSidName, pFree;
    PAFP_SID_MACID        pSidMacId, pFreeM;
	DWORD				  Count;

	PAGED_CODE();

	// De-Allocate space for the Sid Lookup table
	for(Count = 0; Count < SIZE_SID_LOOKUP_TABLE; Count++)
	{
		for (pSidName = afpSidLookupTable[Count]; pSidName != NULL; NOTHING)
		{
			pFree = pSidName;
			pSidName = pSidName->SidLink;
			AfpFreeMemory(pFree);
		}
	}

 	AfpFreeMemory(afpSidLookupTable);

    afpLastCachedSid = NULL;

	// De-Allocate space for the Sid-to-MacId Lookup table
	for(Count = 0; Count < SIZE_SID_LOOKUP_TABLE; Count++)
	{
		for (pSidMacId = afpSidToMacIdTable[Count]; pSidMacId != NULL; NOTHING)
		{
			pFreeM = pSidMacId;
			pSidMacId = pSidMacId->Next;
			AfpFreeMemory(pFreeM);
		}
	}

 	AfpFreeMemory(afpSidToMacIdTable);

	ASSERT(IsListEmpty(&afpSecWorkItemQ));
}


/***	AfpTerminateSecurityUtility
 *
 * 	This is called during server stop. All the service threads are told
 *	to terminate.
 */
VOID
AfpTerminateSecurityUtility(
	VOID
)
{
	KIRQL			 		OldIrql;
	ULONG			 		 Index;
	PAFP_SECURITY_THREAD	pSecThrd;
	PVOID					pBufOut;
	PIO_STACK_LOCATION		pIrpSp;

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
		("AfpTerminateSecurityUtility: waiting for workers to finish work..."));

	// Allow any remaining event logs to be processed
	AfpIoWait(&afpUtilWorkInProgressEvent, NULL);

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
		("AfpTerminateSecurityUtility: done waiting."));

	 do {

		ACQUIRE_SPIN_LOCK(&afpSecUtilLock, &OldIrql);

	 	for (pSecThrd = afpSecurityThread,Index = 0;
			 Index < NUM_SECURITY_UTILITY_THREADS;
			 Index++, pSecThrd++)
		{
			if (pSecThrd->State != NOT_AVAILABLE)
			{
				ASSERT(pSecThrd->State != BUSY);
		 		pSecThrd->State = NOT_AVAILABLE ;
				break;
			}
		}

		RELEASE_SPIN_LOCK(&afpSecUtilLock, OldIrql);

		// We are done, all threads are terminated
	 	if (Index == NUM_SECURITY_UTILITY_THREADS)
			 	return;

		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("AfpTerminateSecurityUtility: Terminating thread %ld\n", Index));

		pIrpSp  = IoGetCurrentIrpStackLocation(pSecThrd->pIrp);
		pBufOut = pSecThrd->pIrp->AssociatedIrp.SystemBuffer;

		ASSERT(pIrpSp->Parameters.FileSystemControl.OutputBufferLength >= sizeof(AFP_FSD_CMD_HEADER));

	 	((PAFP_FSD_CMD_HEADER)pBufOut)->dwId 		= Index;
	 	((PAFP_FSD_CMD_HEADER)pBufOut)->FsdCommand = AFP_FSD_CMD_TERMINATE_THREAD;
		pSecThrd->pIrp->IoStatus.Information = sizeof(AFP_FSD_CMD_HEADER);

		pSecThrd->pIrp->IoStatus.Status = STATUS_SUCCESS;

	 	IoCompleteRequest(pSecThrd->pIrp, IO_NETWORK_INCREMENT);
		  pSecThrd->pIrp = NULL;
	} while (True);
}

/***	AfpInitSidOffsets
 *
 *	This routine will be called by AfpAdmServerSetParms to initialize the
 *	the array of Sid-Offset pairs.
 */
AFPSTATUS FASTCALL
AfpInitSidOffsets(
	IN	ULONG			SidOffstPairs,
	IN	PAFP_SID_OFFSET	pSidOff
)
{
	ULONG	SizeOfBufReqd = 0, SizeAdminSid = 0, SizeNoneSid = 0, SubAuthCount;
	LONG	i;
	BOOLEAN	IsDC = True;	// Assume Domain Controller

	PAGED_CODE();

	DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
			("AfpInitSidOffsets: Entered, Count = %ld\n", SidOffstPairs));


	//
	// Determine if this is a Domain Controller or not by looking for
	// the 'account' domain. If the machine is a PDC/BDC, the service will
	// NOT send down the Account domain offset.
	//
	for (i = 0; i < (LONG)SidOffstPairs; i++)
	{
		if ((pSidOff[i].SidType == AFP_SID_TYPE_DOMAIN) &&
			 (pSidOff[i].Offset == SE_ACCOUNT_DOMAIN_POSIX_OFFSET))
		  {
			// We are either a server or a workstation (i.e. NtProductServer
			// or NtProductWinNt)
			IsDC = False;
		}

	}

	//
	// Determine the amount of memory needed
	//
	for (i = 0; i < (LONG)SidOffstPairs; i++)
	{
		SizeOfBufReqd += sizeof(AFP_SID_OFFSET) + RtlLengthSid(pSidOff[i].pSid);

		// Initialize DomainAdmins sid and size if this is a domain controller
		// AND this is the primary domain offset
		if (IsDC && (pSidOff[i].SidType == AFP_SID_TYPE_PRIMARY_DOMAIN))
		{
			ASSERT (SizeAdminSid == 0);
			ASSERT (AfpSidAdmins == NULL);

			SubAuthCount = *RtlSubAuthorityCountSid(pSidOff[i].pSid);

			SizeAdminSid = RtlLengthRequiredSid(SubAuthCount + 1);

			if ((AfpSidAdmins = (PSID)ALLOC_ACCESS_MEM(SizeAdminSid)) == NULL)
			{
				return STATUS_INSUFFICIENT_RESOURCES;
			}

			RtlCopySid(SizeAdminSid, AfpSidAdmins, pSidOff[i].pSid);

			// Add the relative ID
			*RtlSubAuthorityCountSid(AfpSidAdmins) = (UCHAR)(SubAuthCount+1);

			*RtlSubAuthoritySid(AfpSidAdmins, SubAuthCount) = DOMAIN_GROUP_RID_ADMINS;

				AfpSizeSidAdmins = RtlLengthSid(AfpSidAdmins);

		}
	}

	ASSERT (SizeOfBufReqd != 0);

	// HACK: To fake out the loop below we set SizeNoneSid to nonzero
	// on PDC/BDC. Since the AfpServerIsStandalone variable will not
	// get set until service calls AfpAdmWServerSetInfo we can
	// infer it here since we don't want to try to manufacture the None
	// sid on a PDC/BDC.
	if (IsDC)
		SizeNoneSid = 1;

	// If we did not get the Domain admins sid, we must be running on a
	// stand-alone machine. So manufacture MACHINE\Administrators
	// SID instead.  Also manufacture MACHINE\None if this is not a DC.
	for (i = SidOffstPairs - 1;
		 ((SizeAdminSid == 0) || (SizeNoneSid == 0)) && (i >= 0);
		 i--)
	{
		// Initialize "Administrators" sid and size
		if (pSidOff[i].SidType == AFP_SID_TYPE_DOMAIN)
		{
			if (RtlEqualSid(&AfpSidBuiltIn, pSidOff[i].pSid))
			{
				ASSERT (SizeAdminSid == 0);
				ASSERT (AfpSidAdmins == NULL);

				SubAuthCount = *RtlSubAuthorityCountSid(pSidOff[i].pSid);

				SizeAdminSid = RtlLengthRequiredSid(SubAuthCount + 1);

				if ((AfpSidAdmins = (PSID)ALLOC_ACCESS_MEM(SizeAdminSid)) == NULL)
				{
					return STATUS_INSUFFICIENT_RESOURCES;
				}

				RtlCopySid(SizeAdminSid, AfpSidAdmins, pSidOff[i].pSid);

				// Add the relative ID
				*RtlSubAuthorityCountSid(AfpSidAdmins) = (UCHAR)(SubAuthCount+1);

				*RtlSubAuthoritySid(AfpSidAdmins, SubAuthCount) = DOMAIN_ALIAS_RID_ADMINS;

				AfpSizeSidAdmins = RtlLengthSid(AfpSidAdmins);

			}
			else if (pSidOff[i].Offset == SE_ACCOUNT_DOMAIN_POSIX_OFFSET)
			{
				ASSERT (SizeNoneSid == 0);
				ASSERT (AfpSidNone == NULL);

				SubAuthCount = *RtlSubAuthorityCountSid(pSidOff[i].pSid);

				SizeNoneSid = RtlLengthRequiredSid(SubAuthCount + 1);

				if ((AfpSidNone = (PSID)ALLOC_ACCESS_MEM(SizeNoneSid)) == NULL)
				{
					return STATUS_INSUFFICIENT_RESOURCES;
				}

				RtlCopySid(SizeNoneSid, AfpSidNone, pSidOff[i].pSid);

				// Add the relative ID
				*RtlSubAuthorityCountSid(AfpSidNone) = (UCHAR)(SubAuthCount+1);

				// Note that the "None" sid on standalone is the same as the
				// "Domain Users" Sid on PDC/BDC. (On PDC/BDC the primary
				// domain is the same as the account domain).
				*RtlSubAuthoritySid(AfpSidNone, SubAuthCount) = DOMAIN_GROUP_RID_USERS;

				AfpSizeSidNone = RtlLengthSid(AfpSidNone);
			}
		}
	}

	ASSERT (SizeAdminSid != 0);
	ASSERT (AfpSidAdmins != NULL);

#if DBG
	if (IsDC)
	{
		ASSERT(AfpSidNone == NULL);
	}
	else
	{
		ASSERT(AfpSidNone != NULL);
	}
#endif

	return AFP_ERR_NONE;
}


/***	AfpSecurityUtilityWorker
 *
 * 		This is the main entry point for the security utility thread that
 *		comes from the AFP server service. This is called if the FSD receives
 *	a IRP_MJ_FILE_SYSTEM_CONTROL major function code.
 *
 *	This routine will:
 *	1) Assign a thread structure if this is a newly created thread.
 *	2) Complete the previous work item if this is not a newly created
 *		thread.
 *	3) Check to see if there are any work items to be processed from the
 *		Security utility work item queue. If there is a work item, it will
 *		de-queue the work item and complete the IRP. Otherwise it will
 *		mark the IRP as pending and return STATUS_PENDING.
 *
 */
NTSTATUS
AfpSecurityUtilityWorker(
	IN	PIRP 				pIrp,
	IN  PIO_STACK_LOCATION  pIrpSp		// Pointer to the IRP stack location
)
{
	USHORT		FuncCode;
	USHORT		Method;
	KIRQL		OldIrql;
	PVOID		pBufIn;
	PVOID		pBufOut;
	LONG		iBufLen;
	ULONG		Index;
	NTSTATUS	Status;
	BOOLEAN		FoundMoreWork = False;

	DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
			("afpSecurityUtilityWorker: Entered \n"));

	FuncCode = (USHORT)
				AFP_CC_BASE(pIrpSp->Parameters.FileSystemControl.FsControlCode);

	Method = (USHORT)
			  AFP_CC_METHOD(pIrpSp->Parameters.FileSystemControl.FsControlCode);

 	if ((FuncCode != CC_BASE_GET_FSD_COMMAND) || (Method != METHOD_BUFFERED))
		return STATUS_INVALID_PARAMETER;

	// Get the output buffer and its length. Input and Output buffers are
	// both pointed to by the SystemBuffer

	iBufLen = pIrpSp->Parameters.FileSystemControl.InputBufferLength;
	pBufIn  = pIrp->AssociatedIrp.SystemBuffer;

    if ((iBufLen != 0) && (iBufLen < sizeof(AFP_FSD_CMD_HEADER)))
    {
	    DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
		    ("afpSecurityUtilityWorker: iBufLen too small %d\n",iBufLen));
	    ASSERT(0);
		return STATUS_INVALID_PARAMETER;
    }

	pBufOut = pBufIn;

	if (pBufOut == NULL)
		return STATUS_INVALID_PARAMETER;

	// If this is a newly created thread, we need to find a slot for it

	if (iBufLen == 0)
	{
		ACQUIRE_SPIN_LOCK(&afpSecUtilLock,&OldIrql);

	 	for (Index = 0; Index < NUM_SECURITY_UTILITY_THREADS; Index++)
		{
		 	if (afpSecurityThread[Index].State == NOT_AVAILABLE)
			{
		 		afpSecurityThread[Index].State = BUSY;
				break;
			}
		}

		RELEASE_SPIN_LOCK(&afpSecUtilLock,OldIrql);

        // no more threads?  fail the request
		if (Index == NUM_SECURITY_UTILITY_THREADS)
        {
		    DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
			    ("afpSecurityUtilityWorker: no thread available, failing request\n"));
		    ASSERT(0);
		    return STATUS_INSUFFICIENT_RESOURCES;
        }

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
			("afpSecurityUtilityWorker: New Thread given slot=%d\n",Index));
	}
	else
	{
		PAFP_SECURITY_THREAD	pSecThrd;

		// The id is actually the slot index into the array of security threads

	 	Index = ((PAFP_FSD_CMD_HEADER)pBufIn)->dwId;

	 	if (Index >= NUM_SECURITY_UTILITY_THREADS)
			return STATUS_INVALID_PARAMETER;

		pSecThrd = &afpSecurityThread[Index];

        if (pSecThrd->State != BUSY)
        {
		    DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
			    ("afpSecurityUtilityWorker: thread is not busy!\n"));
		    ASSERT(0);
		    return STATUS_INVALID_PARAMETER;
        }

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
		("afpSecurityUtilityThread: Thread slot=%d completed request\n",Index));

	 	// Complete the current job

 		(*((pSecThrd->pSecWorkItem)->pCompletionRoutine))(Index, pBufIn);

		 // The job is completed so set the work item pointer to NULL.
		pSecThrd->pSecWorkItem = (PSEC_WORK_ITEM)NULL;
	}

	// OK, we are done with the previous job. Now we check to see if there
	// are any jobs in the queue

	ACQUIRE_SPIN_LOCK(&afpSecUtilLock,&OldIrql);

	if (iBufLen != 0)
	{
		ASSERT(afpUtilWorkInProgress > 0);
		// This is not a newly created thread, so decrement the count of
		// work items in progress. If it goes to zero and the work queue
		// is empty, signal the event signifying there is no work in progress
		if ((--afpUtilWorkInProgress == 0) && IsListEmpty(&afpSecWorkItemQ))
		{
			KeSetEvent(&afpUtilWorkInProgressEvent, IO_NETWORK_INCREMENT, False);
		}
	}

	if (IsListEmpty(&afpSecWorkItemQ))
	{
		// There is no work to be done so mark this irp as pending and
		// wait for a job

		afpSecurityThread[Index].State = IDLE;
		IoMarkIrpPending(pIrp);
		 afpSecurityThread[Index].pIrp = pIrp;
		Status = STATUS_PENDING;

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
		("afpSecurityUtilityWorker: Thread slot=%d marked as IDLE\n",Index));
	}
	else
	{
		// Otherwise, there is a job to be processed, so take it off the queue.

		// Increment the count of work items in progress and set the event
		// to not signalled
		afpUtilWorkInProgress ++;
		KeClearEvent(&afpUtilWorkInProgressEvent);
		FoundMoreWork = True;

		afpSecurityThread[Index].State = BUSY;

 		afpSecurityThread[Index].pSecWorkItem =
							(PSEC_WORK_ITEM)RemoveHeadList(&afpSecWorkItemQ);

        ASSERT(afpSecWorkItemQLength > 0);

        afpSecWorkItemQLength--;

		ASSERT((LONG)(pIrpSp->Parameters.FileSystemControl.OutputBufferLength) >=
					(afpSecurityThread[Index].pSecWorkItem)->OutputBufSize);

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
			("afpSecurityUtilityWorker: Thread slot=%d marked as BUSY\n",Index));
	}

	RELEASE_SPIN_LOCK(&afpSecUtilLock,OldIrql);

	// If there is a work item to process

	if (FoundMoreWork)
	{

		Status = STATUS_SUCCESS;

		// Simply copy the command packet into the IRP and return.
		RtlCopyMemory(pBufOut,
						(afpSecurityThread[Index].pSecWorkItem)->pOutput,
						(afpSecurityThread[Index].pSecWorkItem)->OutputBufSize);

	 	((PAFP_FSD_CMD_HEADER)pBufOut)->dwId = Index;

		pIrp->IoStatus.Information =
						(afpSecurityThread[Index].pSecWorkItem)->OutputBufSize;
	}

	 return Status;
}


/***	afpGetIndexOfIdle
 *
 * 	This routine will first check to see if there are any threads that
 *	are idle and are waiting for work to do. If there are, then it will
 *	mark it as busy and up the count of in progress items and release the
 *	InProgress event. Else it will queue up the work-item.
 */
LONG FASTCALL
afpGetIndexOfIdle(
	 IN	PSEC_WORK_ITEM 		pSecWorkItem
)
{
	KIRQL	OldIrql;
	LONG	Index;

	ACQUIRE_SPIN_LOCK(&afpSecUtilLock, &OldIrql);

	// See if there are any threads that are ready to process this request
 	for (Index = 0; Index < NUM_SECURITY_UTILITY_THREADS; Index++)
	{
		if (afpSecurityThread[Index].State == IDLE)
		{
			// If we found a thread that is ready, mark it as busy
			// Increment the count of work items in progress and set the event
			// to not signalled
			afpUtilWorkInProgress ++;
			KeClearEvent(&afpUtilWorkInProgressEvent);

			afpSecurityThread[Index].State = BUSY;
			break;
		}
	}

	if (Index == NUM_SECURITY_UTILITY_THREADS)
	{
		// All threads are busy so queue up this request.
		// Alternatively, it could be the case that someone has tried
		// to log an event before the usermode utility thread(s) have
		// started, in which case we should just queue up the item.
		InsertTailList(&afpSecWorkItemQ, &pSecWorkItem->Links);

        afpSecWorkItemQLength++;
	}

	RELEASE_SPIN_LOCK(&afpSecUtilLock, OldIrql);

	return Index;
}


/***	afpQueueSecWorkItem
 *
 * 	This routine will first check to see if there are any threads that
 *	are idle and are waiting for work to do. If there are, then it will
 *	copy the command packet into the IRP's output buffer and mark that
 *	IRP as complete. Otherwise, it will insert this work item at the
 *	tail of the work item queue.
 */
LOCAL NTSTATUS
afpQueueSecWorkItem(
	IN	AFP_FSD_CMD_ID			FsdCommand,
	IN	PSDA					pSda,
	IN	PKEVENT					pEvent,
	IN	PAFP_FSD_CMD_PKT 		pAfpFsdCmdPkt,
	IN	LONG					BufSize,
	IN	SEC_COMPLETION_ROUTINE	pCompletionRoutine
)
{
	LONG				Index;
	PSEC_WORK_ITEM 		pSecWorkItem;

	DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
			("afpQueueSecWorkItem: Entered \n"));

	if ((pSecWorkItem = ALLOC_SWI()) == NULL)
		return STATUS_NO_MEMORY;

	pSecWorkItem->pSda = pSda;
	pSecWorkItem->pCompletionEvent = pEvent;
	pSecWorkItem->pCompletionRoutine = pCompletionRoutine;
	pSecWorkItem->OutputBufSize = BufSize;
	pSecWorkItem->pOutput = pAfpFsdCmdPkt;

	pAfpFsdCmdPkt->Header.FsdCommand = FsdCommand;

	Index = afpGetIndexOfIdle(pSecWorkItem);

	if (Index < NUM_SECURITY_UTILITY_THREADS)
	{
		PAFP_SECURITY_THREAD	pSecThrd;
		PIO_STACK_LOCATION		pIrpSp;

		// Wake this thread up by marking this IRP as complete
		pSecThrd = &afpSecurityThread[Index];
		pIrpSp  = IoGetCurrentIrpStackLocation(pSecThrd->pIrp);


		ASSERT((LONG)(pIrpSp->Parameters.FileSystemControl.OutputBufferLength) >=
												pSecWorkItem->OutputBufSize);

		pAfpFsdCmdPkt->Header.dwId = Index;
		RtlCopyMemory(pSecThrd->pIrp->AssociatedIrp.SystemBuffer,
					  pAfpFsdCmdPkt,
					  BufSize);

		pSecThrd->pSecWorkItem = pSecWorkItem;

		pSecThrd->pIrp->IoStatus.Information = (ULONG)(pSecWorkItem->OutputBufSize);

		pSecThrd->pIrp->IoStatus.Status = STATUS_SUCCESS;

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
				("afpQueueSecWorkItem: Abount to release IRP\n"));

		IoCompleteRequest(afpSecurityThread[Index].pIrp, IO_NETWORK_INCREMENT);
	}

	return AFP_ERR_EXTENDED;
}


/***	AfpNameToSid
 *
 *	The FSD will call this routine to do a Name to SID translation.
 *  This routine will simply create a work item to do the translation.
 *  This work item will eventually be executed by the user-mode service.
 *  When the work item is completed, afpCompleteNameToSid will be called
 *  which will put the result in the SDA.
 *
 *  Returns: STATUS_SUCCESS
 *			  STATUS_NO_MEMORY
 *
 *	MODE: Non-blocking
 */
NTSTATUS FASTCALL
AfpNameToSid(
	IN  PSDA		 	  pSda,
	IN  PUNICODE_STRING	Name
)
{
	PAFP_FSD_CMD_PKT pAfpFsdCmdPkt;
	LONG			 BufSize;

	PAGED_CODE();

	 DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
				("AfpNameToSid: mapping %ws\n", Name->Buffer));

	// Set up the work item that will translate the name to the SID

	BufSize = sizeof(AFP_FSD_CMD_PKT) + Name->Length + sizeof(WCHAR);

	if ((pAfpFsdCmdPkt = (PAFP_FSD_CMD_PKT)AfpAllocPagedMemory(BufSize)) == NULL)
	{
		return STATUS_NO_MEMORY;
	}

	RtlCopyMemory(pAfpFsdCmdPkt->Data.Name,
					Name->Buffer,
					Name->Length);
	 *(PWCHAR)(&pAfpFsdCmdPkt->Data.Name[Name->Length]) = UNICODE_NULL;

	return afpQueueSecWorkItem(AFP_FSD_CMD_NAME_TO_SID,
								pSda,
								NULL,
								pAfpFsdCmdPkt,
								BufSize,
								afpCompleteNameToSid);
}


/***	afpCompleteNameToSid
 *
 *	This routine will be called by AfpSecurityUtilityWorker when the
 *	thread that processed the work item queued up by afpNameToSid returns.
 *	This routine will free memory allocated by the afpNameToSid routine.
 *  It will insert the result in the SDA, and then queue up the worker
 *  routine that originally requested the lookup.
 */
LOCAL VOID
afpCompleteNameToSid(
	IN ULONG Index,
	IN PVOID pInBuf
)
{
	PAFP_FSD_CMD_PKT pAfpFsdCmdPkt;
	PSDA			 pSda;
	 PSID			 pSid;

	PAGED_CODE();

	pSda = (afpSecurityThread[Index].pSecWorkItem)->pSda;

	pAfpFsdCmdPkt = (PAFP_FSD_CMD_PKT)
					(afpSecurityThread[Index].pSecWorkItem)->pOutput;

	// If there was no error then set the result in the SDA
	if (NT_SUCCESS(((PAFP_FSD_CMD_PKT)pInBuf)->Header.ntStatus))
	{
	 	pSid = (PSID)(((PAFP_FSD_CMD_PKT)pInBuf)->Data.Sid);

		afpUpdateNameSidCache((PWCHAR)pAfpFsdCmdPkt->Data.Name, pSid);

		pSda->sda_SecUtilSid = (PSID)AfpAllocPagedMemory(RtlLengthSid(pSid));

		if (pSda->sda_SecUtilSid == (PSID)NULL)
			 pSda->sda_SecUtilResult = STATUS_NO_MEMORY;
		 else RtlCopySid(RtlLengthSid(pSid), pSda->sda_SecUtilSid, pSid);
	 }
	 else pSda->sda_SecUtilSid = (PSID)NULL;

	pSda->sda_SecUtilResult = ((PAFP_FSD_CMD_PKT)pInBuf)->Header.ntStatus;

	AfpFreeMemory(afpSecurityThread[Index].pSecWorkItem->pOutput);
	AfpFreeMemory(afpSecurityThread[Index].pSecWorkItem);

 	AfpQueueWorkItem(&(pSda->sda_WorkItem));
}


/***	AfpSidToName
 *
 *	The FSD will call this routine to do a SID to Name translation. It
 *	will first check to see if the SID is in the cache. If it is, it
 *	will return a pointer to the AFP_SID_NAME structure from which the
 *	translated Name value may be extracted and it will return
 *	STATUS_SUCCESS.
 *	Otherwise, it will queue up a SID to Name lookup request to the
 *	AFP server service and return AFP_ERR_EXTENDED.
 *
 *	MODE: Non-blocking
 */
NTSTATUS
AfpSidToName(
	IN  PSDA		 	  pSda,
	IN  PSID				  Sid,
	OUT PAFP_SID_NAME  	 *ppTranslatedSid
)
{
	PAFP_FSD_CMD_PKT pAfpFsdCmdPkt;
	LONG			 BufSize;

	PAGED_CODE();

	// First, check to see if the SID is cached
	AfpDumpSid("AfpSidToName: mapping Sid", Sid);

	if ((*ppTranslatedSid = afpLookupSid(Sid)) != NULL)
	 {
		 DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
			  ("AfpSidToName: mapped to %ws\n", (*ppTranslatedSid)->Name.Buffer));
		return STATUS_SUCCESS;
	}

	// Not cached so we need to call the user-mode service to do this
	// translation
	BufSize = sizeof(AFP_FSD_CMD_PKT) + RtlLengthSid(Sid);

	if ((pAfpFsdCmdPkt = (PAFP_FSD_CMD_PKT)AfpAllocPagedMemory(BufSize)) == NULL)
	{
		return STATUS_NO_MEMORY;
	}

	RtlCopyMemory(pAfpFsdCmdPkt->Data.Sid, Sid, BufSize - sizeof(AFP_FSD_CMD_PKT));

	return afpQueueSecWorkItem(AFP_FSD_CMD_SID_TO_NAME,
								pSda,
								NULL,
								pAfpFsdCmdPkt,
								BufSize,
								afpCompleteSidToName);
}


/***	afpCompleteSidToName
 *
 *	This routine will be called by AfpSecurityUtilityWorker when the
 *	thread that processed the work item queued up by AfpSidToName returns.
 *	This routine will update the Name/SID cache, free memory allocated
 *	by the AfpSidtoName routine, and then queue up the worker routine that
 *	originally requested the lookup.
 */
LOCAL VOID
afpCompleteSidToName(
	IN ULONG Index,
	IN PVOID pInBuf
)
{
	PAFP_FSD_CMD_PKT pAfpFsdCmdPkt;
	PSDA			 pSda;

	PAGED_CODE();

	pAfpFsdCmdPkt = (PAFP_FSD_CMD_PKT)
					(afpSecurityThread[Index].pSecWorkItem)->pOutput;

	// If there was no error then update the cache
	if (NT_SUCCESS(((PAFP_FSD_CMD_PKT)pInBuf)->Header.ntStatus))
		afpUpdateNameSidCache((WCHAR*)(((PAFP_FSD_CMD_PKT)pInBuf)->Data.Name),
								(PSID)(pAfpFsdCmdPkt->Data.Sid));

	pSda = (afpSecurityThread[Index].pSecWorkItem)->pSda;

	pSda->sda_SecUtilResult = ((PAFP_FSD_CMD_PKT)pInBuf)->Header.ntStatus;

	AfpFreeMemory(afpSecurityThread[Index].pSecWorkItem->pOutput);
	AfpFreeMemory(afpSecurityThread[Index].pSecWorkItem);

 	AfpQueueWorkItem(&(pSda->sda_WorkItem));
}


/***	AfpSidToMacId
 *
 *	This routine is called by the FSD to map a SID to an AFP ID. This call
 *	will first extract the domain SID from this SID. IT will then check
 *	to see if this domain SID exists in the afpSidOffsetTable cache.
 *	If it does not exist STATUS_NONE_MAPPED will be returned.
 *
 *	MODE: Blocking
 */
NTSTATUS FASTCALL
AfpSidToMacId(
	IN  PSID	pSid,
	OUT PULONG	pMacId
)
{
    PAFP_SID_MACID      pSidMacId, pPrevSidMacId=NULL;
	USHORT			    SidLen;
	NTSTATUS			Status;
    ULONG               Location;

	PAGED_CODE();

	AfpDumpSid("AfpSidToMacId: Mapping Sid", pSid);

	if (RtlEqualSid(pSid, &AfpSidNull) ||
		(AfpServerIsStandalone && RtlEqualSid(pSid, AfpSidNone)))
	{
		*pMacId = 0;
		return STATUS_SUCCESS;
	}


    ASSERT(afpSWMRForSidNameCache.swmr_ExclusiveOwner != PsGetCurrentThread());

    AfpSwmrAcquireExclusive(&afpSWMRForSidNameCache);

	Location = afpHashSid(pSid);

    for (pSidMacId = afpSidToMacIdTable[Location];
         pSidMacId != NULL;
         pSidMacId = pSidMacId->Next)
    {
        // Found the MacId for this Sid?  we already have it: return it
        if (RtlEqualSid(pSid, &(pSidMacId->Sid)))
        {
            *pMacId = pSidMacId->MacId;
            AfpSwmrRelease(&afpSWMRForSidNameCache);
            return STATUS_SUCCESS;
        }

        pPrevSidMacId = pSidMacId;
    }

    //
    // we don't have a MacId for this sid in our cache.  Create a new one
    //

	SidLen = (USHORT)RtlLengthSid(pSid);

	pSidMacId = (PAFP_SID_MACID)ALLOC_ACCESS_MEM(sizeof(AFP_SID_MACID) + SidLen);

	if (pSidMacId == NULL)
    {
	    AfpSwmrRelease(&afpSWMRForSidNameCache);
		return STATUS_NO_MEMORY;
    }

	RtlCopyMemory(pSidMacId->Sid, pSid, SidLen);
    pSidMacId->Next = NULL;

    // assign a MacId for this Sid
    pSidMacId->MacId = afpNextMacIdToUse++;

    // and insert this into the list
    if (pPrevSidMacId)
    {
        ASSERT(pPrevSidMacId->Next == NULL);
        pPrevSidMacId->Next = pSidMacId;
    }
    else
    {
        ASSERT(afpSidToMacIdTable[Location] == NULL);
        afpSidToMacIdTable[Location] = pSidMacId;
    }

    *pMacId = pSidMacId->MacId;

    afpLastCachedSid = pSidMacId;

    AfpSwmrRelease(&afpSWMRForSidNameCache);

	return STATUS_SUCCESS;
}


/***	AfpMacIdToSid
 *
 *	This routine is called by the FSD to map a Afp Id to SID.
 *	*ppSid should be freed the caller using AfpFreeMemory.
 *
 *	MODE: Blocking
 */
NTSTATUS FASTCALL
AfpMacIdToSid(
	IN  ULONG	MacId,
	OUT PSID *	ppSid
)
{
    PAFP_SID_MACID      pSidMacId;
	ULONG				Count;
	DWORD				cbSid;
  	DWORD				SubAuthCount;
  	DWORD				GreatestOffset;
	NTSTATUS			Status;

	PAGED_CODE();


	if (MacId == 0)
	{
        *ppSid = &AfpSidNull;
		return STATUS_SUCCESS;
	}

    AfpSwmrAcquireShared(&afpSWMRForSidNameCache);

    // see if we just cached this Sid (quite likely)
    if ((afpLastCachedSid != NULL) &&
        (afpLastCachedSid->MacId == MacId))
    {
        *ppSid = &(afpLastCachedSid->Sid);
        AfpSwmrRelease(&afpSWMRForSidNameCache);
		return STATUS_SUCCESS;
    }

    for (Count = 0; Count < SIZE_SID_LOOKUP_TABLE; Count++)
    {
        for (pSidMacId = afpSidToMacIdTable[Count];
             pSidMacId != NULL;
             pSidMacId = pSidMacId->Next )
        {
            if (pSidMacId->MacId == MacId)
            {
                *ppSid = &(pSidMacId->Sid);
                AfpSwmrRelease(&afpSWMRForSidNameCache);
                return STATUS_SUCCESS;
            }
        }
    }

    AfpSwmrRelease(&afpSWMRForSidNameCache);

    *ppSid = NULL;

    return STATUS_NONE_MAPPED;
}


/***	AfpChangePassword
 *
 *	This routine is called by the FSD to change a password for a user.
 *	Most of the work for this is done by the AFP service. The work item
 *	is simply queued up. This routine waits for the completion and returns
 *	with thre result of the call.
 *
 *	MODE: Blocking
 */
NTSTATUS FASTCALL
AfpChangePassword(
	IN	PSDA				pSda,
	IN PAFP_PASSWORD_DESC	pPassword
)
{
	KEVENT				CompletionEvent;
	PAFP_FSD_CMD_PKT 	pAfpFsdCmdPkt	= NULL;
	NTSTATUS			Status;

	PAGED_CODE();

	do
	{

		 // Initialize the event that we will wait for
		 //
		KeInitializeEvent(&CompletionEvent, NotificationEvent, False);

		if ((pAfpFsdCmdPkt =
			(PAFP_FSD_CMD_PKT)AfpAllocPagedMemory(sizeof(AFP_FSD_CMD_PKT))) == NULL)
		{
			Status =  STATUS_NO_MEMORY;
			break;
		}

		// Copy all the change password data

		RtlCopyMemory(&(pAfpFsdCmdPkt->Data.Password),
				 pPassword,
				 sizeof(AFP_PASSWORD_DESC));

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
						("afpChangePassword: Queing work item\n"));

		// Block till request completes
		if ((Status = afpQueueSecWorkItem(AFP_FSD_CMD_CHANGE_PASSWORD,
										 pSda,
										 &CompletionEvent,
										 pAfpFsdCmdPkt,
										 sizeof(AFP_FSD_CMD_PKT),
										 afpCompleteChangePassword)) == AFP_ERR_EXTENDED)
		{
			AfpIoWait(&CompletionEvent, NULL);

			// Request complete. Set return code.
			Status = pSda->sda_SecUtilResult;
		}
		else AfpFreeMemory(pAfpFsdCmdPkt);
	} while(False);

	 return Status;
}


/***	afpCompleteChangePassword
 *
 *	MODE: Blocking
 */
LOCAL VOID
afpCompleteChangePassword(
	IN ULONG Index,
	IN PVOID pInBuf
)
{
	PSEC_WORK_ITEM 		pSecWorkItem = afpSecurityThread[Index].pSecWorkItem;

	PAGED_CODE();

	// Set the completion result
	pSecWorkItem->pSda->sda_SecUtilResult =
								((PAFP_FSD_CMD_PKT)pInBuf)->Header.ntStatus;

	AfpFreeMemory(afpSecurityThread[Index].pSecWorkItem->pOutput);

	// Signal that this call is completed
	KeSetEvent(pSecWorkItem->pCompletionEvent,
				IO_NETWORK_INCREMENT,
				False);

	AfpFreeMemory(afpSecurityThread[Index].pSecWorkItem);
}

/***	afpLookupSid
 *
 *	Given a pointer to a SID value, this routine will search the cache
 *	for it. If it is found it returns a pointer to the AFP_SID_NAME
 *	structure so that the translated name may be extracted from it.
 */
LOCAL PAFP_SID_NAME FASTCALL
afpLookupSid(
	IN  PSID Sid
)
{
	PAFP_SID_NAME	pAfpSidName;

	PAGED_CODE();

	AfpSwmrAcquireShared(&afpSWMRForSidNameCache);

	for (pAfpSidName = afpSidLookupTable[afpHashSid(Sid)];
		  pAfpSidName != NULL;
		  pAfpSidName = pAfpSidName->SidLink)
	{
		if (RtlEqualSid(Sid, &(pAfpSidName->Sid)))
		{
			break;
		}
	}

	AfpSwmrRelease(&afpSWMRForSidNameCache);

	return pAfpSidName;

}

/***	afpUpdateNameSidCache
 *
 *	This routine will update the SID/Name cache given a SID/translated
 *	name pair.
 */
LOCAL NTSTATUS FASTCALL
afpUpdateNameSidCache(
	IN WCHAR * Name,
	IN PSID	 Sid
)
{
	PAFP_SID_NAME	pAfpSidName;
	ULONG			Location;
	USHORT			NameLen, SidLen;

	PAGED_CODE();

	NameLen = wcslen(Name) * sizeof(WCHAR);
	SidLen = (USHORT)RtlLengthSid(Sid);
	pAfpSidName = (PAFP_SID_NAME)ALLOC_ACCESS_MEM(sizeof(AFP_SID_NAME) +
											NameLen + SidLen + sizeof(WCHAR));
	if (pAfpSidName == NULL)
		return STATUS_NO_MEMORY;

	// Copy the data into the cache node
	RtlCopyMemory(pAfpSidName->Sid, Sid, SidLen);

	pAfpSidName->Name.Length = NameLen;
	pAfpSidName->Name.MaximumLength = NameLen + sizeof(WCHAR);
	pAfpSidName->Name.Buffer = (LPWSTR)((PBYTE)pAfpSidName +
										sizeof(AFP_SID_NAME) + SidLen);

	RtlCopyMemory(pAfpSidName->Name.Buffer, Name, NameLen);
	AfpGetCurrentTimeInMacFormat(&pAfpSidName->LastAccessedTime);

	// Insert into Sid lookup table
	AfpSwmrAcquireExclusive(&afpSWMRForSidNameCache);

	Location = afpHashSid(Sid);

	pAfpSidName->SidLink 		= afpSidLookupTable[Location];
	afpSidLookupTable[Location] = pAfpSidName;

	AfpSwmrRelease(&afpSWMRForSidNameCache);

	return STATUS_SUCCESS;

}


/***	afpHashSid
 *
 *	Given a SID value, this routine will return the bucket index of
 *	where this value is or should be stored.
 */
LOCAL ULONG FASTCALL
afpHashSid(
	IN PSID	Sid
)
{
	ULONG	Count;
	ULONG	Index;
	ULONG	Location;
	PBYTE	pByte;

	PAGED_CODE();

	for(Count 		= RtlLengthSid(Sid),
		 pByte 		= (PBYTE)Sid,
		 Index 		= 0,
		 Location 	= 0;

		 Index < Count;

		 Index++,
		 pByte++)

		Location = (Location * SID_HASH_RADIX) + *pByte;

	return (Location % SIZE_SID_LOOKUP_TABLE);
}


/***	afpAgeSidNameCache
 *
 *	This is called by the scavenger periodically to age out the cache. The
 *	entries that are aged are the ones not accessed for atleast SID_NAME_AGE
 *	seconds.
 */
AFPSTATUS FASTCALL
afpAgeSidNameCache(
	IN	PVOID	pContext
)
{
	PAFP_SID_NAME	pSidName, *ppSidName;
	AFPTIME			Now;
	int				i;

	PAGED_CODE();

	AfpGetCurrentTimeInMacFormat(&Now);

	AfpSwmrAcquireExclusive(&afpSWMRForSidNameCache);

	for (i = 0; i < SIZE_SID_LOOKUP_TABLE; i++)
	{
		for (ppSidName = &afpSidLookupTable[i];
			 (pSidName = *ppSidName) != NULL;)
		{
			if ((Now - pSidName->LastAccessedTime) > SID_NAME_AGE)
			{
				*ppSidName = pSidName->SidLink;
				AfpFreeMemory(pSidName);
			}
			else ppSidName = &pSidName->SidLink;
		}
	}

	AfpSwmrRelease(&afpSWMRForSidNameCache);

	// Requeue ourselves
	return AFP_ERR_REQUEUE;
}


/***	AfpLogEvent
 *
 *	Create a work item containing the event information for the user-mode
 *  service to write to the event log on behalf of the server.  When the
 *  work item is completed, afpCompleteLogEvent will be called to cleanup
 *  the work item buffers.  This routine is called to log both errors and
 *  events.  If FileHandle is specified, the name of the file/dir associated
 *  with the handle will be queried, and that will be used as the *first*
 *  insertion string.  Only one insertion string is allowed.
 *  Errorlog data will always be preceded by the file+line number from which
 *  the error was logged, and the NTSTATUS code.
 */
VOID
AfpLogEvent(
	IN USHORT		EventType, 			// Error, Information etc.
	IN ULONG		MsgId,
	IN DWORD		File_Line  OPTIONAL,// For errorlog only
	IN NTSTATUS		Status 		OPTIONAL,// For errorlog only
	IN PBYTE RawDataBuf OPTIONAL,
	IN LONG			RawDataLen,
	IN HANDLE FileHandle OPTIONAL,// For fileio errorlogs only
	IN LONG			String1Len,
	IN PWSTR        String1	 OPTIONAL
)
{
	PAFP_FSD_CMD_PKT	pAfpFsdCmdPkt;
	LONG					outbuflen, extradatalen = 0;
	UNICODE_STRING		path;
	PBYTE tmpptr = NULL;
	PWSTR  UNALIGNED *  ppstr = NULL;
	int					stringcount = 0;

	PAGED_CODE();

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

#ifdef	STOP_ON_ERRORS
	DBGBRK(DBG_LEVEL_ERR);
#endif

	AfpSetEmptyUnicodeString(&path, 0, NULL);

    //
    // if due to some weird condition, we have too many items pending on the queue, don't
    // accept this (note that we aren't taking a spinlock here: it's ok to be off by 1!)
    //
    if (afpSecWorkItemQLength > MAX_SECWORKITEM_QLEN)
    {
        ASSERT(0);
        return;
    }

	outbuflen = sizeof(AFP_FSD_CMD_HEADER) + sizeof(AFP_EVENTLOG_DESC) +
				RawDataLen + String1Len + sizeof(WCHAR) +
				sizeof(DWORD); // extra space for aligning string ptrs if needed

	if (ARGUMENT_PRESENT(String1))
	{
		outbuflen += sizeof(PWSTR);
		stringcount ++;
	}

	if (EventType == EVENTLOG_ERROR_TYPE)
	{
		extradatalen = sizeof(File_Line) + sizeof(Status);
		outbuflen += extradatalen;

		// Update error statistics count
		INTERLOCKED_INCREMENT_LONG(&AfpServerStatistics.stat_Errors);
	}

	 if (ARGUMENT_PRESENT(FileHandle))
	{
		outbuflen += sizeof(PWSTR);
		stringcount ++;

		// Figure out the filename associated with the handle
		if (!NT_SUCCESS(AfpQueryPath(FileHandle, &path,
								MAX_FSD_CMD_SIZE - outbuflen - sizeof(WCHAR))))
		{
			return;
		}
		outbuflen += path.Length + sizeof(WCHAR);
	}

	ASSERT(outbuflen <= MAX_FSD_CMD_SIZE);

	pAfpFsdCmdPkt = (PAFP_FSD_CMD_PKT)AfpAllocZeroedNonPagedMemory(outbuflen);

	if (pAfpFsdCmdPkt == NULL)
	{
		if (path.Buffer != NULL)
		{
			AfpFreeMemory(path.Buffer);
		}
		return;
	}

	// Fill in the command data
	pAfpFsdCmdPkt->Data.Eventlog.MsgID		 = MsgId;
	pAfpFsdCmdPkt->Data.Eventlog.EventType	= EventType;
	pAfpFsdCmdPkt->Data.Eventlog.StringCount = (USHORT)stringcount;
	pAfpFsdCmdPkt->Data.Eventlog.DumpDataLen = RawDataLen + extradatalen;
	// Fill in the offset to the dump data
	pAfpFsdCmdPkt->Data.Eventlog.pDumpData = tmpptr = (PBYTE)0 +
												sizeof(AFP_FSD_CMD_HEADER) +
												sizeof(AFP_EVENTLOG_DESC);

	 OFFSET_TO_POINTER(tmpptr, pAfpFsdCmdPkt);

	if (tmpptr == NULL)
	{
		if (path.Buffer != NULL)
		{
			AfpFreeMemory(path.Buffer);
			path.Buffer = NULL;
		}
		if (pAfpFsdCmdPkt != NULL)
		{
			AfpFreeMemory(pAfpFsdCmdPkt);
			pAfpFsdCmdPkt = NULL;
		}
		return;
	}

	if (EventType == EVENTLOG_ERROR_TYPE)
	{
		RtlCopyMemory(tmpptr, &File_Line, sizeof(File_Line));
		tmpptr += sizeof(File_Line);
		RtlCopyMemory(tmpptr, &Status, sizeof(Status));
		tmpptr += sizeof(Status);
	}

	RtlCopyMemory(tmpptr, RawDataBuf, RawDataLen);
	tmpptr += RawDataLen;

	// Align tmpptr on DWORD boundary for filling in string pointers
	tmpptr = (PBYTE)DWLEN((ULONG_PTR)tmpptr);

	if (tmpptr == NULL)
	{
		if (path.Buffer != NULL)
		{
			AfpFreeMemory(path.Buffer);
			path.Buffer = NULL;
		}
		if (pAfpFsdCmdPkt != NULL)
		{
			AfpFreeMemory(pAfpFsdCmdPkt);
			pAfpFsdCmdPkt = NULL;
		}
		return;
	}

	// Fill in the offset to the insertion string pointers
	pAfpFsdCmdPkt->Data.Eventlog.ppStrings = (PWSTR *)(tmpptr - (PBYTE)pAfpFsdCmdPkt);
	ppstr = (PWSTR *)tmpptr;
	ASSERT(((ULONG_PTR)ppstr & 3) == 0);
	*ppstr = NULL;

	// Advance over the string pointers to the place we will copy the strings
	tmpptr += stringcount * sizeof(PWSTR);
	ASSERT((LONG)(tmpptr - (PBYTE)pAfpFsdCmdPkt) < outbuflen);

	// If a handle was supplied, its path will always be the first string
	if (path.Length > 0)
	{
		ASSERT((LONG)(tmpptr + path.Length - (PBYTE)pAfpFsdCmdPkt) < outbuflen);
		RtlCopyMemory(tmpptr, path.Buffer, path.Length);
		*ppstr = (PWSTR)(tmpptr - (PBYTE)pAfpFsdCmdPkt);
		ppstr ++;
		tmpptr += path.Length;
		ASSERT((LONG)(tmpptr + sizeof(WCHAR) - (PBYTE)pAfpFsdCmdPkt) <=
												outbuflen);
		*(PWCHAR)tmpptr = UNICODE_NULL;
		tmpptr += sizeof(WCHAR);
		AfpFreeMemory(path.Buffer);
	}

	ASSERT((LONG)(tmpptr + String1Len - (PBYTE)pAfpFsdCmdPkt) <
												outbuflen);
	if (String1Len > 0)
	{
		RtlCopyMemory(tmpptr, String1, String1Len);
		*ppstr = (LPWSTR)(tmpptr - (ULONG_PTR)pAfpFsdCmdPkt);
		tmpptr += String1Len;
		ASSERT((LONG)(tmpptr + sizeof(WCHAR) - (PBYTE)pAfpFsdCmdPkt) <=
											outbuflen);
		*(PWCHAR)tmpptr = UNICODE_NULL;
	}


	afpQueueSecWorkItem(AFP_FSD_CMD_LOG_EVENT,
						NULL,
						NULL,
						pAfpFsdCmdPkt,
						outbuflen,
						afpCompleteLogEvent);
}

/***	afpCompleteLogEvent
 *
 *	This routine will be called by AfpSecurityUtilityWorker when the
 *  thread that processed the AfpLogEvent returns.  All this does is frees
 *  up the work item memory.
 */
LOCAL VOID
afpCompleteLogEvent(
	IN	ULONG	Index,
	IN	PVOID	pInBuf
)
{

	PAGED_CODE();

	AfpFreeMemory(afpSecurityThread[Index].pSecWorkItem->pOutput);
	AfpFreeMemory(afpSecurityThread[Index].pSecWorkItem);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\swmr.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	swmr.c

Abstract:

	This module contains the single-writer, multi-reader semaphore routines
	and the lock-list-count routines.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_SWMR

#include <afp.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpSwmrInitSwmr)
#endif

/***	AfpSwmrInitSwmr
 *
 *	Initialize the access data structure. Involves initialization of the spin
 *	lock and the shared and exclusive semaphores. All counts are zeroed.
 */
VOID FASTCALL FASTCALL
AfpSwmrInitSwmr(
	IN OUT	PSWMR	pSwmr
)
{
#if DBG
	pSwmr->Signature = SWMR_SIGNATURE;
#endif
	pSwmr->swmr_cOwnedExclusive = 0;
	pSwmr->swmr_cExclWaiting = 0;
	pSwmr->swmr_cSharedOwners = 0;
	pSwmr->swmr_cSharedWaiting = 0;
	pSwmr->swmr_ExclusiveOwner = NULL;
	KeInitializeSemaphore(&pSwmr->swmr_SharedSem, 0, MAXLONG);
	KeInitializeSemaphore(&pSwmr->swmr_ExclSem, 0, MAXLONG);
}


/***	AfpSwmrAcquireShared
 *
 *	Take the semaphore for shared access.
 */
VOID FASTCALL
AfpSwmrAcquireShared(
	IN	PSWMR	pSwmr
)
{
	NTSTATUS	Status;
	KIRQL		OldIrql;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;
#endif

	ASSERT (VALID_SWMR(pSwmr));

	// This should never be called at DISPATCH_LEVEL
	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	ACQUIRE_SPIN_LOCK(&AfpSwmrLock, &OldIrql);

	if ((pSwmr->swmr_cOwnedExclusive > 0) ||
		(pSwmr->swmr_cExclWaiting != 0))
	{
		pSwmr->swmr_cSharedWaiting++;
		RELEASE_SPIN_LOCK(&AfpSwmrLock, OldIrql);

		DBGPRINT(DBG_COMP_LOCKS, DBG_LEVEL_INFO,
				("AfpSwmrAcquireShared: Blocking for Shared %lx\n", pSwmr));

#ifdef	PROFILING
		AfpGetPerfCounter(&TimeS);
#endif

		do
		{
			Status = AfpIoWait(&pSwmr->swmr_SharedSem, &FiveSecTimeOut);
			if (Status == STATUS_TIMEOUT)
			{
				DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
						("AfpSwmrAcquireShared: Timeout Waiting for Shared acess, re-waiting (%lx)\n", pSwmr));
			}
		} while (Status == STATUS_TIMEOUT);
		ASSERT (pSwmr->swmr_cOwnedExclusive == 0);
		ASSERT (pSwmr->swmr_cSharedOwners != 0);

#ifdef	PROFILING
		AfpGetPerfCounter(&TimeE);
		TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_SwmrWaitCount);
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_SwmrWaitTime,
									 TimeD,
									 &AfpStatisticsLock);
#endif
	}
	else // Its either free or shared owners are present with no exclusive waiters
	{
		pSwmr->swmr_cSharedOwners++;
		RELEASE_SPIN_LOCK(&AfpSwmrLock, OldIrql);
	}
#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeE.QuadPart = -(TimeE.QuadPart);
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_SwmrLockTimeR,
								 TimeE,
								 &AfpStatisticsLock);
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_SwmrLockCountR);
#endif
}


/***	AfpSwmrAcquireExclusive
 *
 *	Take the semaphore for exclusive access.
 */
VOID FASTCALL
AfpSwmrAcquireExclusive(
	IN	PSWMR	pSwmr
)
{
	NTSTATUS	Status;
	KIRQL		OldIrql;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;
#endif

	ASSERT (VALID_SWMR(pSwmr));

	// This should never be called at DISPATCH_LEVEL
	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	ACQUIRE_SPIN_LOCK(&AfpSwmrLock, &OldIrql);

	// If the exclusive access is already granted, Check if it is
	// the same thread requesting. If so grant it.
	if ((pSwmr->swmr_cOwnedExclusive != 0) &&
		(pSwmr->swmr_ExclusiveOwner == PsGetCurrentThread()))
	{
		pSwmr->swmr_cOwnedExclusive ++;
		RELEASE_SPIN_LOCK(&AfpSwmrLock, OldIrql);
	}
	
	else if ((pSwmr->swmr_cOwnedExclusive > 0)	||
			 (pSwmr->swmr_cExclWaiting != 0)	||
			 (pSwmr->swmr_cSharedOwners != 0))
	{
		pSwmr->swmr_cExclWaiting++;
		RELEASE_SPIN_LOCK(&AfpSwmrLock, OldIrql);

		DBGPRINT(DBG_COMP_LOCKS, DBG_LEVEL_INFO,
				("AfpSwmrAcquireExclusive: Blocking for exclusive %lx\n", pSwmr));

#ifdef	PROFILING
		AfpGetPerfCounter(&TimeS);
#endif
		do
		{
			Status = AfpIoWait(&pSwmr->swmr_ExclSem, &FiveSecTimeOut);
			if (Status == STATUS_TIMEOUT)
			{
				DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
						("AfpSwmrAcquireExclusive: Timeout Waiting for exclusive acess, re-waiting\n"));
			}
		} while (Status == STATUS_TIMEOUT);
		ASSERT (pSwmr->swmr_cOwnedExclusive == 1);
		pSwmr->swmr_ExclusiveOwner = PsGetCurrentThread();

#ifdef	PROFILING
		AfpGetPerfCounter(&TimeE);
		TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_SwmrWaitCount);
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_SwmrWaitTime,
									 TimeD,
									 &AfpStatisticsLock);
#endif
	}
	else // it is free
	{
		pSwmr->swmr_cOwnedExclusive ++;

		ASSERT(pSwmr->swmr_ExclusiveOwner == NULL);
		pSwmr->swmr_ExclusiveOwner = PsGetCurrentThread();
		RELEASE_SPIN_LOCK(&AfpSwmrLock, OldIrql);
	}
#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeE.QuadPart = -(TimeE.QuadPart);
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_SwmrLockTimeW,
								 TimeE,
								 &AfpStatisticsLock);
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_SwmrLockCountW);
#endif
}


/***	AfpSwmrRelease
 *
 *	Release the specified access. It is assumed that the current thread had
 *	called AfpSwmrAcquirexxxAccess() before this is called. If the SWMR is owned
 *	exclusively, then there cannot possibly be any shared owners active. When releasing
 *	the swmr, we first check for exclusive waiters before shared waiters.
 */
VOID FASTCALL
AfpSwmrRelease(
	IN	PSWMR	pSwmr
)
{
	KIRQL	OldIrql;
#ifdef	PROFILING
	TIME	Time;
	BOOLEAN	Exclusive = False;
#endif
    BOOLEAN fWasShared=FALSE;

	ASSERT (VALID_SWMR(pSwmr));

	ACQUIRE_SPIN_LOCK(&AfpSwmrLock, &OldIrql);
	if (pSwmr->swmr_cOwnedExclusive > 0)
	{
		ASSERT((pSwmr->swmr_cSharedOwners == 0) &&
			   (pSwmr->swmr_ExclusiveOwner == PsGetCurrentThread()));
		pSwmr->swmr_cOwnedExclusive--;
		if (pSwmr->swmr_cOwnedExclusive == 0)
			pSwmr->swmr_ExclusiveOwner = NULL;
#ifdef	PROFILING
		Exclusive = True;
#endif
	}
	else if (pSwmr->swmr_cSharedOwners != 0)
	{
	    // Was owned for shared access
		pSwmr->swmr_cSharedOwners--;
        fWasShared = TRUE;
	}
	else
	{
		// Releasing w/o acquiring ?
		KeBugCheck(0);
	}

	// If there are shared owners present then we are done. Else check for any
	// waiting shared/exclusive waiters
	if ((pSwmr->swmr_cOwnedExclusive == 0) && (pSwmr->swmr_cSharedOwners == 0))
	{
		if ( (pSwmr->swmr_cExclWaiting) &&
             (fWasShared || (!pSwmr->swmr_cSharedWaiting)) )
		{
			ASSERT(pSwmr->swmr_cOwnedExclusive == 0);
			pSwmr->swmr_cOwnedExclusive = 1;
			pSwmr->swmr_cExclWaiting--;

			DBGPRINT(DBG_COMP_LOCKS, DBG_LEVEL_INFO,
						("AfpSwmrReleasAccess: Waking exclusive waiter %lx\n", pSwmr));

			// Wake up the first exclusive waiter. Everybody else coming in will
			// see the access is busy.
			KeReleaseSemaphore(&pSwmr->swmr_ExclSem,
							   SEMAPHORE_INCREMENT,
							   1,
							   False);
		}
		else if (pSwmr->swmr_cSharedWaiting)
		{
			pSwmr->swmr_cSharedOwners = pSwmr->swmr_cSharedWaiting;
			pSwmr->swmr_cSharedWaiting = 0;

			DBGPRINT(DBG_COMP_LOCKS, DBG_LEVEL_INFO,
						("AfpSwmrReleasAccess: Waking %d shared owner(s) %lx\n",
						pSwmr->swmr_cSharedOwners, pSwmr));

			KeReleaseSemaphore(&pSwmr->swmr_SharedSem,
							   SEMAPHORE_INCREMENT,
							   pSwmr->swmr_cSharedOwners,
							   False);
		}
	}
	RELEASE_SPIN_LOCK(&AfpSwmrLock, OldIrql);
#ifdef	PROFILING
	AfpGetPerfCounter(&Time);
	INTERLOCKED_ADD_LARGE_INTGR(Exclusive ?
									&AfpServerProfile->perf_SwmrLockTimeW :
									&AfpServerProfile->perf_SwmrLockTimeR,
								 Time,
								 &AfpStatisticsLock);
#endif
}


/***	AfpSwmrUpgradeAccess
 *
 *	The caller currently has shared access. Upgrade him to exclusive, if possible.
 */
BOOLEAN FASTCALL
AfpSwmrUpgradeToExclusive(
	IN	PSWMR	pSwmr
)
{
	KIRQL	OldIrql;
	BOOLEAN	RetCode = False;		// Assume failed

	ASSERT (VALID_SWMR(pSwmr));

	ASSERT((pSwmr->swmr_cOwnedExclusive == 0) && (pSwmr->swmr_cSharedOwners != 0));

	ACQUIRE_SPIN_LOCK(&AfpSwmrLock, &OldIrql);
	if (pSwmr->swmr_cSharedOwners == 1)		// Possible if there are no more shared owners
	{
		pSwmr->swmr_cSharedOwners = 0;
		pSwmr->swmr_cOwnedExclusive = 1;
        pSwmr->swmr_ExclusiveOwner = PsGetCurrentThread();
		RetCode = True;
#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_SwmrUpgradeCount);
#endif
	}
	RELEASE_SPIN_LOCK(&AfpSwmrLock, OldIrql);

	return RetCode;
}


/***	AfpSwmrDowngradeAccess
 *
 *	The caller currently has exclusive access. Downgrade him to shared.
 */
VOID FASTCALL
AfpSwmrDowngradeToShared(
	IN	PSWMR	pSwmr
)
{
	KIRQL	OldIrql;
	int		cSharedWaiting;

	ASSERT (VALID_SWMR(pSwmr));

	ASSERT((pSwmr->swmr_cOwnedExclusive == 1) &&
		   (pSwmr->swmr_ExclusiveOwner == PsGetCurrentThread()) &&
		   (pSwmr->swmr_cSharedOwners == 0));

	ACQUIRE_SPIN_LOCK(&AfpSwmrLock, &OldIrql);
	pSwmr->swmr_cOwnedExclusive = 0;
    pSwmr->swmr_ExclusiveOwner = NULL;
	pSwmr->swmr_cSharedOwners = 1;
	if (cSharedWaiting = pSwmr->swmr_cSharedWaiting)
	{
		pSwmr->swmr_cSharedOwners += (BYTE)cSharedWaiting;
		pSwmr->swmr_cSharedWaiting = 0;

		DBGPRINT(DBG_COMP_LOCKS, DBG_LEVEL_INFO,
					("AfpSwmrDowngradeAccess: Waking %d Reader(s) %lx\n",
					cSharedWaiting, pSwmr));

		KeReleaseSemaphore(&pSwmr->swmr_SharedSem,
						SEMAPHORE_INCREMENT,
						cSharedWaiting,
						False);
	}
	RELEASE_SPIN_LOCK(&AfpSwmrLock, OldIrql);
#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_SwmrDowngradeCount);
#endif
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\client\afpsvc_c_stub.c ===
#include "afpsvc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\volume.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	volume.c

Abstract:

	This module contains the volume list manipulation routines and worker
	routines for some afp volume apis.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4

	Volumes are represented by two distinct data structures VolDesc and ConnDesc

	VolDesc:This structure represents a configured volume. The information in
			this descriptor consists of static configuration information like
			the name of the volume and its path, reconfigurable information like
			the volume password and volume options and dynamic information like
			the open desktop, id database, open forks etc.
			The list of VolDesc structures orignate from AfpVolumeList and is
			protected by AfpVolumeListLock . The Volume descriptor fields are
			protected by vds_VolLock.

			A volume descriptor has a UseCount field which specifies how many
			clients have this volume open. The reference count specifies the
			number of references to this volume. A volume descriptor can be
			unlinked from the AfpVolumeList ONLY if the UseCount is ZERO. It
			can be freed only when the reference count is ZERO. The reference
			count can NEVER be less than the use count.

	ConnDesc:This is created for every instance of a volume opened by a client.
			This structure is mostly used in the context of the client. This
			is also used by the admin connection apis. The ConnDesc list is
			linked to its owning VolDesc, its owning SDA and AfpConnList. The
			list orignating from the SDA is protected by sda_Lock. The list
			orignating from AfpConnList is protected by AfpConnLock and the
			list orignating from the VolDesc is protected by vds_VolLock.

			The order in which the locks are acquired is as follows:

			1. AfpConnLock
			2. cds_ConnLock
			3. vds_VolLock
--*/

#define	FILENUM	FILE_VOLUME
#define	VOLUME_LOCALS
#include <afp.h>
#include <fdparm.h>
#include <scavengr.h>
#include <nwtrash.h>
#include <pathmap.h>
#include <afpinfo.h>
#include <forkio.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfpVolumeInit)
#pragma alloc_text( PAGE, AfpAdmWVolumeAdd)
#pragma alloc_text( PAGE, AfpVolumePostChangeNotify)
#pragma alloc_text( PAGE, afpVolumeChangeNotifyComplete)
#pragma alloc_text( PAGE, afpVolumeCloseHandleAndFreeDesc)
#pragma alloc_text( PAGE, afpNudgeCdfsVolume)
#pragma alloc_text( PAGE, AfpVolumeUpdateIdDbAndDesktop)
#pragma alloc_text( PAGE_AFP, AfpVolumeReferenceByUpCaseName)
#pragma alloc_text( PAGE_AFP, AfpVolumeReferenceByPath)
#pragma alloc_text( PAGE_AFP, afpConnectionReferenceById)
#pragma alloc_text( PAGE_AFP, afpVolumeAdd)
#pragma alloc_text( PAGE_AFP, afpVolumeCheckForDuplicate)
#pragma alloc_text( PAGE_AFP, AfpAdmWVolumeDelete)
#pragma alloc_text( PAGE_AFP, AfpAdmWConnectionClose)
#pragma alloc_text( PAGE_AFP, afpVolumeGetNewIdAndLinkToList)
#pragma alloc_text( PAGE_AFP, AfpVolumeStopAllVolumes)
#pragma alloc_text(PAGE, afpAllocNotify)
#pragma alloc_text(PAGE, afpFreeNotify)
#pragma alloc_text(PAGE, afpNotifyBlockAge)
#pragma alloc_text(PAGE, afpFreeNotifyBlockMemory)
#endif


/***	AfpVolumeInit
 *
 *	Initialize Volume Data structures. Called at init time.
 */
NTSTATUS
AfpVolumeInit(
	VOID
)
{
	LONG		i;

	INITIALIZE_SPIN_LOCK(&AfpConnLock);
	INITIALIZE_SPIN_LOCK(&AfpVolumeListLock);
	AfpSwmrInitSwmr(&afpNotifyBlockLock);
	AfpSwmrInitSwmr(&AfpVolumeListSwmr);

	for (i = 0; i < NUM_NOTIFY_QUEUES; i++)
	{
		InitializeListHead(&AfpVolumeNotifyList[i]);
		InitializeListHead(&AfpVirtualMemVolumeNotifyList[i]);
		AfpNotifyListCount[i] = 0;
		AfpNotifyQueueCount[i] = 0;
	}

    // Age out Notify Blocks
    AfpScavengerScheduleEvent(afpNotifyBlockAge,
				afpDirNotifyFreeBlockHead,
				NOTIFY_DIR_BLOCK_AGE_TIME,
				True);

	return STATUS_SUCCESS;
}


/***	AfpVolumeReference
 *
 *	Mark the volume descriptor as being referenced.
 *
 *	LOCKS:		vds_VolLock (SPIN)
 *
 *	Callable from DISPATCH_LEVEL.
 */
BOOLEAN FASTCALL
AfpVolumeReference(
	IN	PVOLDESC	pVolDesc
)
{
	KIRQL	OldIrql;
	BOOLEAN	RetCode = False;

	ASSERT (VALID_VOLDESC(pVolDesc));

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	// NOTE: in order for ChangeNotify code to reference volume
	// before it is officially not INTRANSITION, we must allow
	// a reference before INTRANSITION
	if (!(pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED)))
	{
		ASSERT (pVolDesc->vds_RefCount >= pVolDesc->vds_UseCount);

		pVolDesc->vds_RefCount++;

		RetCode = True;
	}

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
	return RetCode;
}


/***	AfpVolumeReferenceByUpCaseName
 *
 *	Reference the volume in AfpVolumeList with the same vds_UpCaseName as
 *	pTargetName.  Since we are holding the AfpVolumeListLock (SpinLock)
 *	and are at DPC level, our string comparison must be case sensitive, because
 *	the codepage used to do case insensitive compares is in paged memory, and
 *	we cannot take a pagefault at DPC level.
 *
 *	If we find the volume we are looking for, it will be referenced.  THE
 *	CALLER IS THEN RESPONSIBLE FOR DEREFERENCING THE VOLUME!!!
 *
 *	LOCKS:		vds_VolLock (SPIN), AfpVolumeListLock (SPIN)
 *	LOCK_ORDER: vds_VolLock after AfpVolumeListLock
 *
 */
PVOLDESC FASTCALL
AfpVolumeReferenceByUpCaseName(
	IN	PUNICODE_STRING	pTargetName
)
{
	PVOLDESC	pVolDesc;
	KIRQL		OldIrql;

	ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

	for (pVolDesc = AfpVolumeList;
		 pVolDesc != NULL;
		 pVolDesc = pVolDesc->vds_Next)
	{
		BOOLEAN	Found;

		Found = False;

		ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);

		if ((pVolDesc->vds_Flags & (VOLUME_DELETED |
									VOLUME_STOPPED |
									VOLUME_INTRANSITION)) == 0)
		{
			if (AfpEqualUnicodeString(pTargetName,
									  &pVolDesc->vds_UpCaseName))
			{
				pVolDesc->vds_RefCount ++;
				Found = True;
			}

		}

		RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);

		if (Found)
			break;
	}

	RELEASE_SPIN_LOCK(&AfpVolumeListLock,OldIrql);

	return pVolDesc;
}


/***	AfpVolumeReferenceByPath
 *
 *	Reference the volume by a path into the volume. We ignore volumes which are
 *	marked as in-transition, stopped or deleted. Also this is only supported for
 *	NTFS volumes since thats what these are used for.
 *
 *	LOCKS:		AfpVolumeListLock (SPIN), vds_VolLock (SPIN)
 *	LOCK_ORDER:	vds_VolLock after AfpVolumeListLock
 *
 */
AFPSTATUS FASTCALL
AfpVolumeReferenceByPath(
	IN	PUNICODE_STRING	pFDPath,
	OUT	PVOLDESC	*	ppVolDesc
)
{
	UNICODE_STRING		UpCasedVolPath;
	KIRQL				OldIrql;
	PVOLDESC			pVolDesc;
	AFPSTATUS			Status = AFPERR_DirectoryNotInVolume;

	// Allocate a buffer for upcasing the path. Tag on a trailing '\' at the
	// end. Then uppercase the volume path
	*ppVolDesc = NULL;
	UpCasedVolPath.MaximumLength = pFDPath->Length + 2*sizeof(WCHAR);
	if ((UpCasedVolPath.Buffer = (LPWSTR)
				AfpAllocNonPagedMemory(UpCasedVolPath.MaximumLength)) == NULL)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	RtlUpcaseUnicodeString(&UpCasedVolPath, pFDPath, False);
	UpCasedVolPath.Buffer[UpCasedVolPath.Length/sizeof(WCHAR)] = L'\\';
	UpCasedVolPath.Length += sizeof(WCHAR);

	// Scan the volume list and map the path to a volume descriptor
	// If we get a match, reference the volume
	ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

	for (pVolDesc = AfpVolumeList;
		 pVolDesc != NULL;
		 pVolDesc = pVolDesc->vds_Next)
	{
		BOOLEAN	Found;

		Found = False;

		ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);

		if ((pVolDesc->vds_Flags & (VOLUME_INTRANSITION | VOLUME_STOPPED | VOLUME_DELETED)) == 0)
		{
			if (AfpPrefixUnicodeString(&pVolDesc->vds_Path, &UpCasedVolPath))
			{
				Found = True;
                // Share out NTFS, CD and CD-HFS 
				if (IS_VOLUME_NTFS(pVolDesc) || IS_VOLUME_RO(pVolDesc))
				// if (IS_VOLUME_NTFS(pVolDesc))
				{
					pVolDesc->vds_RefCount ++;
					Status = STATUS_SUCCESS;
					*ppVolDesc = pVolDesc;
				}
				else
				{
				    Status = AFPERR_UnsupportedFS;
                    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
                            ("AfpVolumeReferenceByPath: *** AFPERR_UnsupportedFS**" ));
				}
			}
		}
		RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);

		if (Found)
			break;
	}
	RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

	AfpFreeMemory(UpCasedVolPath.Buffer);

	return Status;
}


/***	afpUnlinkVolume
 *
 *	Unlink the volume from the free list
 *
 *	LOCKS: AfpVolumeListLock (SPIN)
 */
LOCAL VOID FASTCALL
afpUnlinkVolume(
	IN	PVOLDESC	pVolDesc
)
{
	PVOLDESC *	ppVolDesc;
	KIRQL		OldIrql;

	// It is now safe for a new volume to be added using the same root
	// directory that this volume had used.  Unlink this volume from the
	// global volume list.
	ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

	for (ppVolDesc = &AfpVolumeList;
		 *ppVolDesc != NULL;
		 ppVolDesc = &(*ppVolDesc)->vds_Next)
	{
		if (*ppVolDesc == pVolDesc)
			break;		// found it
	}

	ASSERT (*ppVolDesc != NULL);

	// Adjust the count of configured volumes
	AfpVolCount --;

	// Unlink it now
	*ppVolDesc = pVolDesc->vds_Next;

	// Is this the smallest recyclable Volid ?
	if (pVolDesc->vds_VolId < afpSmallestFreeVolId)
		afpSmallestFreeVolId = pVolDesc->vds_VolId;

        // if the volume with largest id so far is going away, update our value for largest id
        if (pVolDesc->vds_VolId == afpLargestVolIdInUse)
	{
                afpLargestVolIdInUse = 0;
		for (ppVolDesc = &AfpVolumeList;
			 *ppVolDesc != NULL;
			 ppVolDesc = &((*ppVolDesc)->vds_Next))
		{
			if ((*ppVolDesc)->vds_VolId > afpLargestVolIdInUse)
                                afpLargestVolIdInUse = (*ppVolDesc)->vds_VolId;
		}
	}

	// If the server is stopping and the count of sessions has gone to zero
	// clear the termination confirmation event to unblock the admin thread

	if (((AfpServerState == AFP_STATE_STOP_PENDING) ||
		 (AfpServerState == AFP_STATE_SHUTTINGDOWN)) &&
		(AfpVolCount == 0))
	{
		DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_WARN,
				("afpVolumeCloseHandleAndFreeDesc: Unblocking server stop\n"));

		KeSetEvent(&AfpStopConfirmEvent, IO_NETWORK_INCREMENT, False);
	}

	RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);
}


/***	afpVolumeCloseHandleAndFreeDesc
 *
 *	If the last entity to dereference the volume is at DPC level, this is run
 *	by the scavenger thread to perform the last rites for a volume descriptor.
 *	Otherwise, the last entity to dereference the deleted volume will call
 *	this routine directly.  The reason this is done here is because the last
 *	dereference may happen at DPC level and we cannot do this at DPC level.
 *
 *	The VolDesc is marked DELETED or STOPPED and as such, anyone looking at the
 *	VolDesc in the volume list will treat it as though it is non-existant.
 *	The one exception to this is the volume add code which must look at the
 *	volume root path in order to prohibit anyone from adding a new volume
 *	which points to the same path until we have actually done the final
 *	cleanup on the directory tree, such as deleting the network trash, deleting
 *	the various streams, etc.  In effect, the VOLUME_DELETED or VOLUME_STOPPED
 *	flags act as a lock for the volume, so that during this routine no locks are
 *	needed.
 *
 */
LOCAL AFPSTATUS FASTCALL
afpVolumeCloseHandleAndFreeDesc(
	IN	PVOLDESC		pVolDesc
)
{
	int				        id;
	FILESYSHANDLE	        streamhandle;
	PLIST_ENTRY	            pList;
	int				        i;
    PDELAYED_NOTIFY         pDelayedNotify;

	PAGED_CODE( );

	ASSERT(VALID_VOLDESC(pVolDesc));

	DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_WARN,
			("afpVolumeCloseHandleAndFreeDesc: Shutting Down volume %d\n",
			pVolDesc->vds_VolId));

	DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_WARN,
			("afpVolumeCloseHandleAndFreeDesc: Freeing up desktop tables\n"));
	// Free the volume desktop
	AfpFreeDesktopTables(pVolDesc);

	DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_WARN,
			("afpVolumeCloseHandleAndFreeDesc: Freeing up iddb tables\n"));
	// Free the id index tables
	AfpFreeIdIndexTables(pVolDesc);

	// Delete the Network Trash Folder and the Afp_IdIndex, AFP_DeskTop,
	// and AFP_AfpInfo streams from volume root directory (the streams
	// are removed only if the volume is being deleted.  NetworkTrash is
	// removed whenever the volume stops/gets deleted)
	if (IS_VOLUME_NTFS(pVolDesc))
	{
		DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_WARN,
				("afpVolumeCloseHandleAndFreeDesc: Deleting the Network trash tree\n"));
		AfpDeleteNetworkTrash(pVolDesc, False);
		if (!(pVolDesc->vds_Flags & (VOLUME_INTRANSITION | VOLUME_STOPPED)))
		{
			WCHAR	wchVolIcon[AFPSERVER_VOLUME_ICON_FILE_SIZE] = AFPSERVER_VOLUME_ICON_FILE;
			UNICODE_STRING UIconName;

			for (id = AFP_STREAM_IDDB;id < AFP_STREAM_COMM; id++)
			{
				if (NT_SUCCESS(AfpIoOpen(&pVolDesc->vds_hRootDir,
										 id,
										 FILEIO_OPEN_FILE,
										 &UNullString,
										 FILEIO_ACCESS_DELETE,
										 FILEIO_DENY_NONE,
										 False,
										 &streamhandle)))
				{
					AfpIoMarkFileForDelete(&streamhandle, NULL, NULL, NULL);
					AfpIoClose(&streamhandle);
				}
			}

			UIconName.Buffer = wchVolIcon;
			UIconName.Length = UIconName.MaximumLength =
					(AFPSERVER_VOLUME_ICON_FILE_SIZE - 1) * sizeof(WCHAR);

			// Delete the hidden volume Icon file
			if (NT_SUCCESS(AfpIoOpen(&pVolDesc->vds_hRootDir,
									 AFP_STREAM_DATA,
									 FILEIO_OPEN_FILE,
									 &UIconName,
									 FILEIO_ACCESS_DELETE,
									 FILEIO_DENY_NONE,
									 False,
									 &streamhandle)))

			{

				AfpIoMarkFileForDelete(&streamhandle, NULL, NULL, NULL);
				AfpIoClose(&streamhandle);
			}
		}
	}

	// Flush out any queued 'our changes' on this volume
	for (i = 0; i < NUM_AFP_CHANGE_ACTION_LISTS; i++)
	{
		POUR_CHANGE	pChange;

		ASSERTMSG("afpVolumeCloseHandleAndFreeDesc: vds_OurChangeList not empty\n",
				 IsListEmpty(&pVolDesc->vds_OurChangeList[i]));

		while (!IsListEmpty(&pVolDesc->vds_OurChangeList[i]))
		{
			pList = RemoveHeadList(&pVolDesc->vds_OurChangeList[i]);
			pChange = CONTAINING_RECORD(pList, OUR_CHANGE, oc_Link);
			DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
					("afpVolumeCloseHandleAndFreeDesc: Manually freeing list for Action %x, Pathname %Z\n",
					i, &pChange->oc_Path));
			AfpFreeMemory(pChange);
		}
	}

	afpUnlinkVolume(pVolDesc);

	// Close the volume handle
	AfpIoClose(&pVolDesc->vds_hRootDir);
	if (pVolDesc->vds_EnumBuffer != NULL)
    {
		AfpFreePANonPagedMemory(pVolDesc->vds_EnumBuffer, AFP_ENUMBUF_SIZE);
    }

    if (pVolDesc->vds_pDfeDirBucketStart)
    {
        AfpFreeMemory(pVolDesc->vds_pDfeDirBucketStart);
    }

    if (pVolDesc->vds_pDfeFileBucketStart)
    {
        AfpFreeMemory(pVolDesc->vds_pDfeFileBucketStart);
    }

    pList = pVolDesc->vds_DelayedNotifyList.Flink;
    while (pList != &pVolDesc->vds_DelayedNotifyList)
    {
        DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
            ("afpVolumeCloseHandleAndFreeDesc: freeing delayed notify buf %lx\n",pDelayedNotify));

        pDelayedNotify = CONTAINING_RECORD (pList, DELAYED_NOTIFY, dn_List);
        pList = pList->Flink;
        RemoveEntryList(&pDelayedNotify->dn_List);
        AfpFreeMemory(pDelayedNotify->filename.Buffer);
        AfpFreeMemory(pDelayedNotify);
    }

    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
        ("afpVolumeCloseHandleAndFreeDesc: freeing %lx for vol %Z\n",
        pVolDesc,&pVolDesc->vds_Name));

	AfpFreeMemory(pVolDesc);

	return AFP_ERR_NONE;
}


/***	AfpVolumeDereference
 *
 *	Dereference the volume descriptor. If it is marked to be deleted then
 *	also perform its last rites. Note that updates to the databases need
 *	to happen at a lower irql than DISPATCH_LEVEL. For this reason these
 *	activities have to be queued up for the scavenger to handle.
 *
 *	LOCKS:		vds_VolLock (SPIN)
 *
 *	Callable from DISPATCH_LEVEL.
 *
 *	NOTE: This should be re-entrant.
 */
VOID FASTCALL
AfpVolumeDereference(
	IN	PVOLDESC	pVolDesc
)
{
	KIRQL			OldIrql;
	BOOLEAN			Cleanup = False;


	ASSERT (pVolDesc != NULL);
	ASSERT (VALID_VOLDESC(pVolDesc));


	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	ASSERT (pVolDesc->vds_RefCount >= pVolDesc->vds_UseCount);

	pVolDesc->vds_RefCount --;

	if ((pVolDesc->vds_RefCount == 0) &&
		(pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED)))
		Cleanup = True;

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

	if (Cleanup)
	{
        if ((pVolDesc->vds_Flags & VOLUME_INITIAL_CACHE) &&
            !(pVolDesc->vds_Flags & VOLUME_INTRANSITION))
        {
            // set this so we don't reset the Indexing global flag again!
            pVolDesc->vds_Flags |= VOLUME_INTRANSITION;
        }

		ASSERT((pVolDesc->vds_UseCount == 0) &&
			   (pVolDesc->vds_pOpenForkDesc == NULL));

		// We have to defer the actual close of the volume root handle to the
		// scavenger, if we are at DISPATCH_LEVEL.

		if (OldIrql == DISPATCH_LEVEL)
		{
			 DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
					("AfpVolumeDereference: Queuing Close&Free to Scavenger\n"));

			 AfpScavengerScheduleEvent(afpVolumeCloseHandleAndFreeDesc,
									   pVolDesc,
									   0,
									   True);
		}
		else
        {
            afpVolumeCloseHandleAndFreeDesc(pVolDesc);
        }

	}
}


/***	AfpVolumeMarkDt
 *
 *	Set the ConnDesc for this volume to indicate that the desktop is
 *	opened/closed.
 *
 *	LOCKS:	cds_ConnLock (SPIN)
 *
 *	Callable from DISPATCH_LEVEL.
 */
BOOLEAN
AfpVolumeMarkDt(
	IN  PSDA		pSda,
	IN  PCONNDESC	pConnDesc,
	IN  DWORD		OpenState
)
{
	BOOLEAN		Success = True;

	ACQUIRE_SPIN_LOCK_AT_DPC(&pConnDesc->cds_ConnLock);
	if (OpenState)
	{
		 pConnDesc->cds_Flags |= CONN_DESKTOP_OPENED;
	}
	else if (pConnDesc->cds_Flags & CONN_DESKTOP_OPENED)
	{
		pConnDesc->cds_Flags &= ~CONN_DESKTOP_OPENED;
	}
	else
	{
		 Success = False;
	}
	RELEASE_SPIN_LOCK_FROM_DPC(&pConnDesc->cds_ConnLock);

	return Success;
}


/***	AfpVolumeSetModifiedTime
 *
 *	Set the Volume Modified time for this volume to the current time.
 *
 *	Callable from DISPATCH_LEVEL.
 *
 *	LOCKS:	vds_VolLock (SPIN)
 */
VOID FASTCALL
AfpVolumeSetModifiedTime(
	IN  PVOLDESC	pVolDesc
)
{
	KIRQL		OldIrql;
    AFPTIME     OriginalTime;
    DWORD       dwSchedDelay;
    BOOLEAN     fSendNotification=FALSE;


	// ASSERT (IS_VOLUME_NTFS(pVolDesc));

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

    OriginalTime = pVolDesc->vds_ModifiedTime;
	AfpGetCurrentTimeInMacFormat(&pVolDesc->vds_ModifiedTime);

	pVolDesc->vds_Flags |= VOLUME_IDDBHDR_DIRTY;

    //
    // volume was modified: need to inform all the Afp22 clients
    //
    if ((pVolDesc->vds_ModifiedTime > OriginalTime) &&
		((pVolDesc->vds_Flags & (VOLUME_DELETED |
								 VOLUME_STOPPED |
								 VOLUME_INTRANSITION )) == 0))
    {
        fSendNotification = TRUE;

        // put SendNotif refcount
        pVolDesc->vds_RefCount++;

        //
        // if we don't have a notification pending, reset our MustSend clock!
        // (idea here is that if there are too many notifications happening withing
        // a very short time, we don't want to send a notification for every change,
        // but at the same time, don't want to wait beyond AFP_MAX_SRVR_NOTIF_INTERVAL
        // to send a notification).
        //
        if (!(pVolDesc->vds_Flags & VOLUME_SRVR_NOTIF_PENDING))
        {
            dwSchedDelay = AFP_MIN_SRVR_NOTIF_INTERVAL;

            pVolDesc->vds_TimeToSendNotify =
                        AfpSecondsSinceEpoch + AFP_MIN_SRVR_NOTIF_INTERVAL;

            pVolDesc->vds_TimeMustSendNotify =
                            AfpSecondsSinceEpoch + AFP_MAX_SRVR_NOTIF_INTERVAL;

            pVolDesc->vds_Flags |= VOLUME_SRVR_NOTIF_PENDING;
        }

        // advance the next send time by a second
        else
        {
            if (pVolDesc->vds_TimeToSendNotify >= AfpSecondsSinceEpoch)
            {
                pVolDesc->vds_TimeToSendNotify = pVolDesc->vds_TimeToSendNotify + 1;
            }
            else
            {
                pVolDesc->vds_TimeToSendNotify = AfpSecondsSinceEpoch + 1;
            }

            dwSchedDelay = (pVolDesc->vds_TimeToSendNotify - AfpSecondsSinceEpoch);
        }

    }

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

    // if necessary, tell those AFP22 clients that volume mod time changed
    if (fSendNotification)
    {
        AfpScavengerScheduleEvent(AfpSendServerNotification,
                                  pVolDesc,
                                  dwSchedDelay,
                                  True);
    }

}

AFPSTATUS FASTCALL
AfpSendServerNotification(
	IN  PVOLDESC	pVolDesc
)
{
    KIRQL       OldIrql;
    PSDA        pSda;
    PSDA        pSdaNext;
    PCONNDESC   pConnDesc;
    BOOLEAN     fSendOnThisSda;
    BOOLEAN     fMustSend=FALSE;



    ASSERT (VALID_VOLDESC(pVolDesc));
	// ASSERT (IS_VOLUME_NTFS(pVolDesc));

    ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

    // is the volume shutting down?  if so, don't do anything
	if (pVolDesc->vds_Flags & (VOLUME_DELETED |
	                           VOLUME_STOPPED |
	                           VOLUME_INTRANSITION))
    {
        RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

        // remove the SendNotif refcount
        AfpVolumeDereference(pVolDesc);

        return(AFP_ERR_NONE);
    }

    // is it time to send the notify?
    if (AfpSecondsSinceEpoch >= pVolDesc->vds_TimeToSendNotify)
    {
        fMustSend = TRUE;
    }

    //
    // has it been a while since we sent a notify?  This would happen if a there is
    // a big tree copy going on the server which keeps pushing vds_TimeToSendNotify
    // forward, so AfpSecondsSinceEpoch is never less or equal to it.
    //
    else if (AfpSecondsSinceEpoch >= pVolDesc->vds_TimeMustSendNotify)
    {
        fMustSend = TRUE;
    }

    if (fMustSend)
    {
        pVolDesc->vds_Flags &= ~VOLUME_SRVR_NOTIF_PENDING;

        pVolDesc->vds_TimeMustSendNotify = AfpSecondsSinceEpoch;
    }

    RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

    if (!fMustSend)
    {
        // remove the SendNotif refcount
        AfpVolumeDereference(pVolDesc);

        return(AFP_ERR_NONE);
    }

    ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

    for (pSda = AfpSessionList; pSda != NULL; pSda = pSdaNext)
    {
        pSdaNext = pSda->sda_Next;

        ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

        //
        // if the sda is closing, or if the client is older than version AFP2.2 or if
        // we have just sent the notify to the client, skip this sda
        //
        if ((pSda->sda_Flags & (SDA_CLOSING | SDA_SESSION_CLOSED | SDA_CLIENT_CLOSE)) ||
            (pSda->sda_ClientVersion < AFP_VER_22) ||
            (pSda->sda_Flags & SDA_SESSION_NOTIFY_SENT))
        {
            RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
            continue;
        }

        //
        // find out if this session has mounted this volume.  Only if it is, we
        // send notification to this session
        //

        fSendOnThisSda = FALSE;
        pConnDesc = pSda->sda_pConnDesc;

        while (pConnDesc != NULL)
        {
            ASSERT(VALID_CONNDESC(pConnDesc));

            if (pConnDesc->cds_pVolDesc == pVolDesc)
            {
                fSendOnThisSda = TRUE;
                pSda->sda_RefCount ++;
                break;
            }
            pConnDesc = pConnDesc->cds_Next;
        }

        pSda->sda_Flags |= SDA_SESSION_NOTIFY_SENT;

        RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

        RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

        if (fSendOnThisSda)
        {
            AfpSpSendAttention(pSda, ATTN_SERVER_NOTIFY, False);

            AfpSdaDereferenceSession(pSda);
        }

        ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

        pSdaNext = AfpSessionList;
    }

    RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

    //
    // now, go back and reset that flag
    //
    ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);
    for (pSda = AfpSessionList; pSda != NULL; pSda = pSda->sda_Next)
    {
        pSdaNext = pSda->sda_Next;

        ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

        pSda->sda_Flags &= ~SDA_SESSION_NOTIFY_SENT;

        RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
    }
    RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

    // remove the SendNotif refcount
    AfpVolumeDereference(pVolDesc);

    return(AFP_ERR_NONE);
}


/***	AfpConnectionReference
 *
 *	Map the volume id to a pointer to the connection descriptor. Traverse the
 *	list starting from the Sda. Since the open volume can be reference from
 *	both the session using it as well as the worker serving admin requests,
 *	we need a lock.
 *
 *	LOCKS:		AfpConnLock, vds_VolLock (SPIN), cds_ConnLock (SPIN).
 *
 *	LOCK_ORDER:	vds_VolLock after cds_ConnLock. (via AfpVolumeReference)
 *
 *	Callable from DISPATCH_LEVEL.
 */
PCONNDESC FASTCALL
AfpConnectionReference(
	IN  PSDA		pSda,
	IN  LONG		VolId
)
{
	PCONNDESC	pConnDesc;
	KIRQL		OldIrql;

	KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

	pConnDesc = AfpConnectionReferenceAtDpc(pSda, VolId);

	KeLowerIrql(OldIrql);

	return pConnDesc;
}



/***	AfpConnectionReferenceAtDpc
 *
 *	Map the volume id to a pointer to the connection descriptor. Traverse the
 *	list starting from the Sda. Since the open volume can be reference from
 *	both the session using it as well as the worker serving admin requests,
 *	we need a lock.
 *
 *	LOCKS:		AfpConnLock, vds_VolLock (SPIN), cds_ConnLock (SPIN).
 *
 *	LOCK_ORDER:	vds_VolLock after cds_ConnLock. (via AfpVolumeReference)
 *
 *	Callable from DISPATCH_LEVEL ONLY
 */
PCONNDESC FASTCALL
AfpConnectionReferenceAtDpc(
	IN  PSDA		pSda,
	IN  LONG		VolId
)
{
	PCONNDESC	pConnDesc, pCD = NULL;
	PVOLDESC	pVolDesc;

	ASSERT (VALID_SDA(pSda) && (VolId != 0));
	ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

	ACQUIRE_SPIN_LOCK_AT_DPC(&AfpConnLock);
	for (pConnDesc = pSda->sda_pConnDesc;
		 pConnDesc != NULL;
		 pConnDesc = pConnDesc->cds_Next)
	{
		if (pConnDesc->cds_pVolDesc->vds_VolId == VolId)
			break;
	}
	RELEASE_SPIN_LOCK_FROM_DPC(&AfpConnLock);

	if (pConnDesc != NULL)
	{
		ASSERT(VALID_CONNDESC(pConnDesc));

		pVolDesc = pConnDesc->cds_pVolDesc;
		ASSERT(VALID_VOLDESC(pVolDesc));

		ACQUIRE_SPIN_LOCK_AT_DPC(&pConnDesc->cds_ConnLock);

		if ((pConnDesc->cds_Flags & CONN_CLOSING) == 0)
		{
			pCD = pConnDesc;
			pConnDesc->cds_RefCount ++;
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&pConnDesc->cds_ConnLock);
	}

	DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
			("AfpConnectionReferenence: VolId %d, pConnDesc %lx\n", VolId, pConnDesc));

	return pCD;
}



/***	AfpConnectionReferenceByPointer
 *
 *	Reference the Connection descriptor. This is used by the admin APIs.
 *
 *	LOCKS:		vds_VolLock (SPIN), cds_ConnLock (SPIN).
 *
 *	LOCK_ORDER:	vds_VolLock after cds_ConnLock. (via AfpVolumeReference)
 *
 *	Callable from DISPATCH_LEVEL.
 */
PCONNDESC FASTCALL
AfpConnectionReferenceByPointer(
	IN	PCONNDESC	pConnDesc
)
{
	PCONNDESC	pCD = NULL;
	PVOLDESC	pVolDesc;
	KIRQL		OldIrql;

	ASSERT (VALID_CONNDESC(pConnDesc));

	pVolDesc = pConnDesc->cds_pVolDesc;
	ASSERT(VALID_VOLDESC(pVolDesc));

	ACQUIRE_SPIN_LOCK(&pConnDesc->cds_ConnLock, &OldIrql);

	if ((pConnDesc->cds_Flags & CONN_CLOSING) == 0)
	{
		pConnDesc->cds_RefCount ++;
		pCD = pConnDesc;
	}

	RELEASE_SPIN_LOCK(&pConnDesc->cds_ConnLock, OldIrql);

	return pCD;
}


/***	afpConnectionReferenceById
 *
 *	Map the Connection id to a pointer to the connection descriptor.
 *	Traverse the list starting from the AfpConnList. This is called by
 *	the Admin CloseConnection API.
 *
 *	LOCKS:		AfpConnLock, cds_ConnLock (SPIN).
 *
 *	LOCK_ORDER:	vds_VolLock after cds_ConnLock. (via AfpVolumeReference)
 *
 *	Callable from DISPATCH_LEVEL.
 */
LOCAL PCONNDESC FASTCALL
afpConnectionReferenceById(
	IN  DWORD		ConnId
)
{
	PCONNDESC	pConnDesc;
	PCONNDESC	pRetConnDesc=NULL;
	PVOLDESC	pVolDesc;
	KIRQL		OldIrql;

	ASSERT (ConnId != 0);

	ACQUIRE_SPIN_LOCK(&AfpConnLock, &OldIrql);

	for (pConnDesc = AfpConnList;
		 pConnDesc != NULL;
		 pConnDesc = pConnDesc->cds_NextGlobal)
	{
		if (pConnDesc->cds_ConnId == ConnId)
			break;
	}

	if (pConnDesc != NULL)
	{
		ASSERT(VALID_CONNDESC(pConnDesc));

#if DBG
		pVolDesc = pConnDesc->cds_pVolDesc;
		ASSERT(VALID_VOLDESC(pVolDesc));
#endif

		ACQUIRE_SPIN_LOCK_AT_DPC(&pConnDesc->cds_ConnLock);

		if ((pConnDesc->cds_Flags & CONN_CLOSING) == 0)
		{
			pConnDesc->cds_RefCount ++;
            pRetConnDesc = pConnDesc;
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&pConnDesc->cds_ConnLock);
	}

	RELEASE_SPIN_LOCK(&AfpConnLock, OldIrql);

	return pRetConnDesc;
}


/***	AfpConnectionDereference
 *
 *	Dereference the open volume. If this is the last reference to it and the
 *	connection is marked to shut down, perform its last rites.
 *
 *	LOCKS:		vds_VolLock (SPIN), cds_ConnLock (SPIN), AfpConnLock (SPIN)
 *
 *	LOCK_ORDER:	vds_VolLock after cds_ConnLock
 *
 *	Callable from DISPATCH_LEVEL.
 */
VOID FASTCALL
AfpConnectionDereference(
	IN  PCONNDESC	pConnDesc
)
{
	PCONNDESC *		ppConnDesc;
	KIRQL			OldIrql;
	PSDA			pSda;
	PVOLDESC		pVolDesc;
	BOOLEAN			Cleanup;

	ASSERT (VALID_CONNDESC(pConnDesc) && (pConnDesc->cds_pVolDesc != NULL));

	ASSERT (pConnDesc->cds_RefCount > 0);

	ACQUIRE_SPIN_LOCK(&pConnDesc->cds_ConnLock, &OldIrql);

	Cleanup = (--(pConnDesc->cds_RefCount) == 0);

	RELEASE_SPIN_LOCK(&pConnDesc->cds_ConnLock, OldIrql);

	DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
			("AfpConnectionDereferenence: pConnDesc %lx %s\n", pConnDesc,
											Cleanup ? "cleanup" : "normal"));

	if (!Cleanup)
	{
		return;
	}

	ASSERT(pConnDesc->cds_Flags & CONN_CLOSING);

	// Unlink this from the global list
	ACQUIRE_SPIN_LOCK(&AfpConnLock, &OldIrql);

	for (ppConnDesc = &AfpConnList;
		 *ppConnDesc != NULL;
		 ppConnDesc = &(*ppConnDesc)->cds_NextGlobal)
	{
		if (pConnDesc == *ppConnDesc)
			break;
	}
	ASSERT (*ppConnDesc != NULL);
	*ppConnDesc = pConnDesc->cds_NextGlobal;

	pVolDesc = pConnDesc->cds_pVolDesc;

	RELEASE_SPIN_LOCK(&AfpConnLock, OldIrql);

	INTERLOCKED_ADD_ULONG(&pVolDesc->vds_UseCount,
						  (DWORD)-1,
						  &pVolDesc->vds_VolLock);

	ACQUIRE_SPIN_LOCK(&pConnDesc->cds_ConnLock, &OldIrql);

	// Now unlink it from the Sda.
	pSda = pConnDesc->cds_pSda;
	for (ppConnDesc = &pSda->sda_pConnDesc;
		 *ppConnDesc != NULL;
		 ppConnDesc = &(*ppConnDesc)->cds_Next)
	{
		if (pConnDesc == *ppConnDesc)
			break;
	}

	ASSERT (*ppConnDesc != NULL);
	*ppConnDesc = pConnDesc->cds_Next;

	// Even though the connection is now history we need to release this
	// lock to get the right IRQL back.
	RELEASE_SPIN_LOCK(&pConnDesc->cds_ConnLock, OldIrql);

	INTERLOCKED_ADD_ULONG(&pSda->sda_cOpenVolumes,
						  (ULONG)-1,
						  &pSda->sda_Lock);

	// De-reference the volume descriptor and free the connection descriptor
	AfpVolumeDereference(pConnDesc->cds_pVolDesc);

	if (pConnDesc->cds_pEnumDir != NULL)
		AfpFreeMemory(pConnDesc->cds_pEnumDir);

	// Finally free the connection descriptor
	AfpFreeMemory(pConnDesc);

	DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
			("AfpConnectionDereferenence: pConnDesc %lx is history\n", pConnDesc));
}



/***	AfpConnectionOpen
 *
 *	Open the specified volume. If the volume is already open this translates
 *	to a NOP. If the volume has a password, then it is checked.
 *
 *	The volume list lock is obtained for the duration of the processing.
 *
 *	Callable from DISPATCH_LEVEL.
 *
 *	LOCKS:	AfpVolumeListLock (SPIN), vds_VolLock (SPIN)
 *
 *	LOCK_ORDER: vds_VolLock after AfpVolumeListLock
 */
AFPSTATUS
AfpConnectionOpen(
	IN  PSDA			pSda,
	IN  PANSI_STRING	pVolName,
	IN  PANSI_STRING	pVolPass,
	IN  DWORD			Bitmap,
	OUT PBYTE			pVolParms
)
{
	PVOLDESC		pVolDesc;
	PCONNDESC		pConnDesc;
	AFPSTATUS		Status = AFP_ERR_NONE;
	KIRQL			OldIrql;
	BOOLEAN			VolFound = False;

	// First find the volume descriptor for this volume
	if (KeGetCurrentIrql() == DISPATCH_LEVEL)
	{
		ACQUIRE_SPIN_LOCK_AT_DPC(&AfpVolumeListLock);

		for (pVolDesc = AfpVolumeList;
			 pVolDesc != NULL;
			 pVolDesc = pVolDesc->vds_Next)
		{
			// Ignore volumes that are in the process of being added but
			// the operation has not completed yet.
			ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);

			if ((pVolDesc->vds_Flags & (VOLUME_CDFS_INVALID 	|
										VOLUME_INTRANSITION 	|
										VOLUME_INITIAL_CACHE	|
										VOLUME_DELETED			|
										VOLUME_STOPPED)) == 0)
			{
				// The compare is case sensitive here
				if (EQUAL_STRING(&pVolDesc->vds_MacName, pVolName, False))
				{
                    //
                    // if DiskQuota is enabled, we need to first find out the
                    // quota for this user which we cannot do at dpc: so come
                    // back at task time
                    //
                    if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
                    {
		                DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
		                    ("AfpConnectionOpen: %lx disk-quota on, queuing\n",pVolDesc));

			            RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);
		                RELEASE_SPIN_LOCK_FROM_DPC(&AfpVolumeListLock);
		                return AFP_ERR_QUEUE;
                    }
                    else  // DiskQuota is not enabled: go ahead and process at DPC
                    {
					    pVolDesc->vds_RefCount ++;
					    pVolDesc->vds_UseCount ++;
					    VolFound = True;
                    }
				}
			}
#if DBG
			else if (pVolDesc->vds_Flags & VOLUME_CDFS_INVALID)
				ASSERT (!IS_VOLUME_NTFS(pVolDesc));
#endif
			RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);

			if (VolFound)
				break;
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&AfpVolumeListLock);

		if (pVolDesc == NULL)
		{
			return AFP_ERR_QUEUE;
		}

	}
	else
	{
		// We are here because we did not find the volume at DISPATCH_LEVEL and
		// possibly the volume has been specified with a different case. Catch
		// this
		WCHAR			VolNameBuf[AFP_VOLNAME_LEN + 1];
		WCHAR			UpCasedNameBuffer[AFP_VOLNAME_LEN + 1];
		UNICODE_STRING	UpCasedVolName;
		UNICODE_STRING	UVolName;

        pVolDesc = NULL;

		AfpSetEmptyUnicodeString(&UVolName, sizeof(VolNameBuf), VolNameBuf);
		AfpSetEmptyUnicodeString(&UpCasedVolName, sizeof(UpCasedNameBuffer), UpCasedNameBuffer);
		Status = AfpConvertStringToUnicode(pVolName, &UVolName);
		ASSERT (NT_SUCCESS(Status));

		Status = RtlUpcaseUnicodeString(&UpCasedVolName, &UVolName, False);

        if (!NT_SUCCESS(Status))
        {
            return(AFP_ERR_PARAM);
        }

		ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

		for (pVolDesc = AfpVolumeList;
			 pVolDesc != NULL;
			 pVolDesc = pVolDesc->vds_Next)
		{
			// Ignore volumes that are in the process of being added but
			// the operation has not completed yet.
			ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);

			if ((pVolDesc->vds_Flags & (VOLUME_CDFS_INVALID 	|
										VOLUME_INTRANSITION 	|
										VOLUME_INITIAL_CACHE	|
										VOLUME_DELETED			|
										VOLUME_STOPPED)) == 0)
			{
				if (AfpEqualUnicodeString(&pVolDesc->vds_UpCaseName,
										  &UpCasedVolName))
				{
					pVolDesc->vds_RefCount ++;
					pVolDesc->vds_UseCount ++;
					VolFound = True;
				}
			}

			RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);

			if (VolFound)
				break;
		}

		RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

		if (pVolDesc == NULL)
		{
			return AFP_ERR_PARAM;
		}
	}

	ASSERT (pVolDesc != NULL);

	do
	{
		ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

		// Check for volume password, if one exists. Volume password is
		// case sensitive.

		if ((pVolDesc->vds_Flags & AFP_VOLUME_HASPASSWORD) &&
			((pVolPass->Buffer == NULL) ||
			 (!EQUAL_STRING(pVolPass, &pVolDesc->vds_MacPassword, False))))
		{
			Status = AFP_ERR_ACCESS_DENIED;
			break;
		}

		// Check if the volume is already open
		for (pConnDesc = pSda->sda_pConnDesc;
			 pConnDesc != NULL;
			 pConnDesc = pConnDesc->cds_Next)
		{
			if (pConnDesc->cds_pVolDesc == pVolDesc)
			{
				if (pConnDesc->cds_Flags & CONN_CLOSING)
					continue;
				// Dereference the volume since we already have it open
				pVolDesc->vds_RefCount --;
				pVolDesc->vds_UseCount --;
				break;
			}
		}

		// This volume is already open. Unlock the volume.
		if (pConnDesc != NULL)
		{
			RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
			break;
		}

		DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
				("AfpConnectionOpen: Opening a fresh connection volid=%d\n",
					pVolDesc->vds_VolId));

		// This is a fresh open. Check if we have access to it and if we satisfy
		// the MAXUSES. If not dereference the volume before we quit
		if ((pVolDesc->vds_UseCount > pVolDesc->vds_MaxUses) ||
			(!(pVolDesc->vds_Flags & AFP_VOLUME_GUESTACCESS) &&
			 (pSda->sda_ClientType == SDA_CLIENT_GUEST)))
		{
			Status = AFP_ERR_TOO_MANY_FILES_OPEN;
			break;
		}

		// All is hunky-dory. Go ahead with the open
		pConnDesc = (PCONNDESC)AfpAllocZeroedNonPagedMemory(sizeof(CONNDESC));
		if (pConnDesc == NULL)
		{
			Status = AFP_ERR_MISC;
			break;
		}

		ASSERT ((pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED)) == 0);

		// Now release the vds_VolLock before we acquire the link it into
		// the global list since we acquire the AfpConnLock then.
		// Re-acquire it when we are done. We are safe since the VolDesc has
		// been referenced
		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

		// Initialize the connection structure fields
	#if DBG
		pConnDesc->Signature = CONNDESC_SIGNATURE;
	#endif
		pConnDesc->cds_pSda = pSda;
		pConnDesc->cds_pVolDesc = pVolDesc;
		pConnDesc->cds_RefCount = 1;		// Creation reference

		AfpGetCurrentTimeInMacFormat(&pConnDesc->cds_TimeOpened);
		INITIALIZE_SPIN_LOCK(&pConnDesc->cds_ConnLock);

		// Assign a new connection id and link it in the global connection list.
		afpConnectionGetNewIdAndLinkToList(pConnDesc);

		// Link the new ConnDesc into the sda.
		pConnDesc->cds_Next = pSda->sda_pConnDesc;
		pSda->sda_pConnDesc = pConnDesc;
		pSda->sda_cOpenVolumes ++;
	} while (False);

	// We are holding the vds_VolLock if an error occured. The volume has a
	// usecount and reference count which we need to get rid of.
	if (!NT_SUCCESS(Status))
	{
		pVolDesc->vds_RefCount --;
		pVolDesc->vds_UseCount --;

		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
	}
	else
    {
        //
        // if disk-quota is enabled on this volume, get this user's quota info
        //
        if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
        {
            ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

            // up the refcount (this can't fail: we just created the thing!)
            AfpConnectionReferenceByPointer(pConnDesc);
            afpUpdateDiskQuotaInfo(pConnDesc);
        }
        else
        {
            // initialize these to something meaningful for now
            pConnDesc->cds_QuotaLimit = pVolDesc->vds_VolumeSize;
            pConnDesc->cds_QuotaAvl = pVolDesc->vds_FreeBytes;
        }

        AfpVolumePackParms(pSda, pVolDesc, Bitmap, pVolParms);
    }

	return Status;
}


/***	AfpConnectionClose
 *
 *	Close the connection - this represents an open volume.
 */
VOID FASTCALL
AfpConnectionClose(
	IN	PCONNDESC		pConnDesc
)
{
	KIRQL	OldIrql;

	ASSERT (VALID_CONNDESC(pConnDesc));
	ASSERT (pConnDesc->cds_RefCount > 1);
	ASSERT ((pConnDesc->cds_Flags & CONN_CLOSING) == 0);

	ACQUIRE_SPIN_LOCK(&pConnDesc->cds_ConnLock, &OldIrql);

	pConnDesc->cds_Flags |= CONN_CLOSING;

	RELEASE_SPIN_LOCK(&pConnDesc->cds_ConnLock, OldIrql);

	// Take away the creation reference.
	AfpConnectionDereference(pConnDesc);
}


/***	AfpVolumeGetParmsReplyLength
 *
 *	Compute the size of buffer required to copy the volume parameters based
 *	on the bitmap.
 */
USHORT FASTCALL
AfpVolumeGetParmsReplyLength(
	IN  DWORD		Bitmap,
	IN	USHORT		NameLen
)
{
	LONG	i;
	USHORT	Size = sizeof(USHORT);	// to accomodate a copy of the bitmap
	static	BYTE	Bitmap2Size[12] =
				{
					sizeof(USHORT),	                // Attributes
					sizeof(USHORT),	                // Signature
					sizeof(DWORD),	                // Creation date
					sizeof(DWORD),	                // Mod date
					sizeof(DWORD),	                // Backup date
					sizeof(USHORT),	                // Volume Id
					sizeof(DWORD),	                // Bytes Free
					sizeof(DWORD),	                // Bytes total
					sizeof(USHORT) + sizeof(BYTE),  // Volume name
                    sizeof(DWORD) + sizeof(DWORD),  // Extended Bytes Free
                    sizeof(DWORD) + sizeof(DWORD),  // Extended Bytes Total
                    sizeof(DWORD)                   // Allocation Block size
				};


	ASSERT ((Bitmap & ~VOL_BITMAP_MASK) == 0);

	if (Bitmap & VOL_BITMAP_VOLUMENAME)
		Size += NameLen;

	for (i = 0; Bitmap; i++)
	{
		if (Bitmap & 1)
			Size += (USHORT)Bitmap2Size[i];
		Bitmap >>= 1;
	}
	return Size;
}



/***	AfpVolumePackParms
 *
 *	Pack the volume parameters in the reply buffer. The AfpVolumeListLock is taken
 *	before the volume parameters are accessed. The parameters are copied in
 *	the on-the-wire format.
 *
 *	LOCKS:	vds_VolLock	(SPIN)
 */
VOID
AfpVolumePackParms(
	IN  PSDA		pSda,
	IN  PVOLDESC	pVolDesc,
	IN  DWORD		Bitmap,
	OUT PBYTE		pReplyBuf
)
{
	int		        Offset = sizeof(USHORT);
	KIRQL	        OldIrql;
	DWORD	        Attr;
    PCONNDESC       pConnDesc;
    PBYTE           pVolNamePtr;
    LARGE_INTEGER   QuotaAvailable={0};
    LARGE_INTEGER   QuotaLimit={0};

	// older Macs have problems with 2 or 4Gig volumes
	LARGE_INTEGER	TwoGig =  { 0x7E200000, 0 };
	LARGE_INTEGER	FourGig = { 0xFFFFFFFF, 0 };
    LARGE_INTEGER   Limit;
    BOOLEAN         fAfp21OrOlderClient=TRUE;


    //
    // get this info out before we grab the pVolDesc lock
    //
	if (Bitmap & (VOL_BITMAP_BYTESFREE | VOL_BITMAP_VOLUMESIZE |
                  VOL_BITMAP_EXTBYTESFREE | VOL_BITMAP_EXTBYTESTOTAL))
    {

        QuotaLimit = pVolDesc->vds_VolumeSize;
        QuotaAvailable = pVolDesc->vds_FreeBytes;

        if (pSda->sda_ClientVersion >= AFP_VER_22)
        {
            fAfp21OrOlderClient = FALSE;
        }

        if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
        {
            pConnDesc = AfpConnectionReference(pSda, pVolDesc->vds_VolId);

            if (pConnDesc)
            {
                ACQUIRE_SPIN_LOCK(&pConnDesc->cds_ConnLock, &OldIrql);

                QuotaLimit = pConnDesc->cds_QuotaLimit;

                // if user's available quota shows 10MB, but space left on the
                // disk shows 3MB, we need to return 3MB (smaller of the two)
                //
                if (QuotaAvailable.QuadPart > pConnDesc->cds_QuotaAvl.QuadPart)
                {
                    QuotaAvailable = pConnDesc->cds_QuotaAvl;
                }

                RELEASE_SPIN_LOCK(&pConnDesc->cds_ConnLock, OldIrql);

                AfpConnectionDereference(pConnDesc);
            }
        }

        //
        // AFP2.1 and older clients can't handle more than 4GB (2GB if so configured)
        // Lie to the client so it survives
        //
        if (fAfp21OrOlderClient)
        {
    	    Limit = ((AfpServerOptions & AFP_SRVROPT_4GB_VOLUMES) ||
		    	    (pVolDesc->vds_Flags & AFP_VOLUME_4GB)) ? FourGig : TwoGig;

	        if (QuotaLimit.QuadPart > Limit.QuadPart)
            {
                QuotaLimit = Limit;
            }

            if (QuotaAvailable.QuadPart > Limit.QuadPart)
            {
                QuotaAvailable = Limit;
            }
        }
        else
        {
            Limit = FourGig;
        }
    }

	// First copy the bitmap
	PUTDWORD2SHORT(pReplyBuf, Bitmap);

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);
	if (Bitmap & VOL_BITMAP_ATTR)
	{
		Attr = pVolDesc->vds_Flags & AFP_VOLUME_MASK_AFP;
		if (pSda->sda_ClientVersion < AFP_VER_21)
			Attr &= AFP_VOLUME_READONLY;	// Do not give Afp 2.0 any more bits

		PUTDWORD2SHORT(pReplyBuf + Offset, Attr);
		Offset += sizeof(USHORT);
	}
	if (Bitmap & VOL_BITMAP_SIGNATURE)
	{
		PUTSHORT2SHORT(pReplyBuf + Offset, AFP_VOLUME_FIXED_DIR);
		Offset += sizeof(USHORT);
	}
	if (Bitmap & VOL_BITMAP_CREATETIME)
	{
		PUTDWORD2DWORD(pReplyBuf + Offset, pVolDesc->vds_CreateTime);
		Offset += sizeof(DWORD);
	}
	if (Bitmap & VOL_BITMAP_MODIFIEDTIME)
	{
		PUTDWORD2DWORD(pReplyBuf + Offset, pVolDesc->vds_ModifiedTime);
		Offset += sizeof(DWORD);
	}
	if (Bitmap & VOL_BITMAP_BACKUPTIME)
	{
		PUTDWORD2DWORD(pReplyBuf + Offset, pVolDesc->vds_BackupTime);
		Offset += sizeof(DWORD);
	}
	if (Bitmap & VOL_BITMAP_VOLUMEID)
	{
		PUTSHORT2SHORT(pReplyBuf + Offset, pVolDesc->vds_VolId);
		Offset += sizeof(USHORT);
	}
	if (Bitmap & VOL_BITMAP_BYTESFREE)
	{
        //
        // if this is a huge volume (and we are talking to an AFP2.2 or later client)
        // we need to fill 4GB in this field
        //
        if (QuotaAvailable.QuadPart > Limit.QuadPart)
        {
    	    PUTDWORD2DWORD(pReplyBuf + Offset, Limit.LowPart);
	        Offset += sizeof(DWORD);
        }
        else
        {
		    PUTDWORD2DWORD(pReplyBuf + Offset, QuotaAvailable.LowPart);
		    Offset += sizeof(DWORD);
        }
	}

	if (Bitmap & VOL_BITMAP_VOLUMESIZE)
	{
        //
        // if this is a huge volume (and we are talking to an AFP2.2 or later client)
        // we need to fill 4GB in this field
        //
        if (QuotaLimit.QuadPart > Limit.QuadPart)
        {
		    PUTDWORD2DWORD(pReplyBuf + Offset, Limit.LowPart);
		    Offset += sizeof(DWORD);
        }
        else
        {
		    PUTDWORD2DWORD(pReplyBuf + Offset, QuotaLimit.LowPart);
		    Offset += sizeof(DWORD);
        }
	}


    // save pointer to where we need to write the offset: we'll write at the
    // end after we figure out where the name goes
	if (Bitmap & VOL_BITMAP_VOLUMENAME)
	{
        pVolNamePtr = pReplyBuf + Offset;

		Offset += sizeof(USHORT);
	}

    //
    // 8-bytes to say how many free bytes there are
    //
    if (Bitmap & VOL_BITMAP_EXTBYTESFREE)
    {
	    PUTDWORD2DWORD(pReplyBuf + Offset, QuotaAvailable.HighPart);
	    Offset += sizeof(DWORD);

	    PUTDWORD2DWORD(pReplyBuf + Offset, QuotaAvailable.LowPart);
	    Offset += sizeof(DWORD);
    }

    //
    // 8-bytes to say how many bytes there are on the volume
    //
    if (Bitmap & VOL_BITMAP_EXTBYTESTOTAL)
    {
	    PUTDWORD2DWORD(pReplyBuf + Offset, QuotaLimit.HighPart);
	    Offset += sizeof(DWORD);

	    PUTDWORD2DWORD(pReplyBuf + Offset, QuotaLimit.LowPart);
	    Offset += sizeof(DWORD);
    }

    //
    // 4-bytes to say what is the block allocation size
    //
    if (Bitmap & VOL_BITMAP_ALLOCBLKSIZE)
    {
	    PUTDWORD2DWORD(pReplyBuf + Offset, pVolDesc->vds_AllocationBlockSize);
	    Offset += sizeof(DWORD);
    }

    // now, write the volume name (if asked for), after writing the offset, now
    // that we know it (subtract 2: we measure from parms, not Bitmap field)
	if (Bitmap & VOL_BITMAP_VOLUMENAME)
	{
		PUTSHORT2SHORT(pVolNamePtr, (Offset - sizeof(USHORT)));

		PUTSHORT2BYTE(pReplyBuf + Offset, pVolDesc->vds_MacName.Length);
		Offset += sizeof(BYTE);
		RtlCopyMemory(pReplyBuf + Offset,
					  pVolDesc->vds_MacName.Buffer,
					  pVolDesc->vds_MacName.Length);
	}

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
}


/***	AfpVolumeStopAllVolumes
 *
 *	This is called at service stop time. All configured volumes are asked to
 *	stop. Wait for the actual stop to happen before returning.
 *
 *	LOCKS:		AfpVolumeListLock (SPIN), vds_VolLock
 *	LOCK_ORDER:	vds_VolLock after AfpVolumeListLock
 */
VOID
AfpVolumeStopAllVolumes(
	VOID
)
{
	KIRQL		OldIrql;
	PVOLDESC	pVolDesc, pVolDescx = NULL;
	BOOLEAN		Wait, CancelNotify = False;
	NTSTATUS	Status;


	pVolDesc = AfpVolumeList;

	ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

	if (Wait = (AfpVolCount > 0))
	{
		KeClearEvent(&AfpStopConfirmEvent);

		for (NOTHING; pVolDesc != NULL; pVolDesc = pVolDesc->vds_Next)
		{
			if ((pVolDesc == pVolDescx) ||
				(pVolDesc->vds_Flags & (VOLUME_STOPPED | VOLUME_DELETED)))
				continue;

			pVolDescx = pVolDesc;

			ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);

			// Cancel posted change notify
			pVolDesc->vds_Flags |= VOLUME_STOPPED;

			if (pVolDesc->vds_Flags & VOLUME_NOTIFY_POSTED)
			{
				DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
						("AfpStopAllVolumes: Cancel notify on volume %ld\n",
						pVolDesc->vds_VolId));
				// ASSERT (IS_VOLUME_NTFS(pVolDesc));
				ASSERT (pVolDesc->vds_pIrp != NULL);

				CancelNotify = True;

				// Cancel after releasing the volume lock since the completion
				// routine acquires it and it could be called in the context
				// of IoCancelIrp(). Also Cancel uses paged resource and so
				// must be called w/o holding any spin locks.
				RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);
				RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

				IoCancelIrp(pVolDesc->vds_pIrp);

				ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);
			}
			else RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);

			// Remove the creation reference
			AfpVolumeDereference(pVolDesc);
		}
	}

	RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

	if (CancelNotify)
	{
		DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
				("AfpStopAllVolumes: Waiting on all notify to complete\n"));
		do
		{
			Status = AfpIoWait(&AfpStopConfirmEvent, &FiveSecTimeOut);
			if (Status == STATUS_TIMEOUT)
			{
				DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
						("AfpVolumeStopAllVolumes: Timeout Waiting for cancel notify, re-waiting\n"));
			}
		} while (Status == STATUS_TIMEOUT);
	}

	if (Wait)
	{
		KeClearEvent(&AfpStopConfirmEvent);

		AfpScavengerFlushAndStop();

		if (AfpVolCount > 0)
			AfpIoWait(&AfpStopConfirmEvent, NULL);
	}
	else
	{
		AfpScavengerFlushAndStop();
	}
}


/***	afpConnectionGetNewIdAndLinkToList
 *
 *	Get a new connection id for a volume that is being opened. A connection
 *	id ranges from 1 to MAXULONG. If it wraps, then the entire connection
 *	list is scanned to get a free one.
 *
 *	LOCKS:	AfpConnectionLock (SPIN)
 */
LOCAL VOID FASTCALL
afpConnectionGetNewIdAndLinkToList(
	IN	PCONNDESC	pConnDesc
)
{
	KIRQL		OldIrql;
	PCONNDESC *	ppConnDesc;

	ACQUIRE_SPIN_LOCK(&AfpConnLock, &OldIrql);

	pConnDesc->cds_ConnId = afpNextConnId++;

	for (ppConnDesc = &AfpConnList;
		 *ppConnDesc != NULL;
		 ppConnDesc = &(*ppConnDesc)->cds_NextGlobal)
	{
		if ((*ppConnDesc)->cds_ConnId < pConnDesc->cds_ConnId)
			break;
	}
	pConnDesc->cds_NextGlobal = *ppConnDesc;
	*ppConnDesc = pConnDesc;
	RELEASE_SPIN_LOCK(&AfpConnLock, OldIrql);
}


/***	AfpVolumeUpdateIdDbAndDesktop
 *
 *	Called by the volume scavenger to write either the IdDb header and/or the
 *	dektop to disk.
 */
VOID
AfpVolumeUpdateIdDbAndDesktop(
	IN	PVOLDESC			pVolDesc,
	IN	BOOLEAN				WriteDt,
	IN	BOOLEAN				WriteIdDb,
	IN	PIDDBHDR			pIdDbHdr	OPTIONAL
)
{
	FILESYSHANDLE	fshIdDb;
	NTSTATUS		Status;
	BOOLEAN			WriteBackROAttr = False;
    TIME            ModTime;
    NTSTATUS        ModStatus=AFP_ERR_MISC;

	PAGED_CODE();

	DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
			("AfpVolumeUpdateIdDbAndDesktop: Called by volume scavenger\n") );

    ModStatus = AfpIoRestoreTimeStamp(&pVolDesc->vds_hRootDir,
                                      &ModTime,
                                      AFP_RETRIEVE_MODTIME);

	// If we need to update the IdIndex or Desktop streams, make sure
	// the ReadOnly bit is not set on the volume root directory
	AfpExamineAndClearROAttr(&pVolDesc->vds_hRootDir, &WriteBackROAttr, NULL, NULL);

	// Update the disk image of the IdDb header and/or the whole database if it is dirty
	if (WriteIdDb || ARGUMENT_PRESENT(pIdDbHdr))
	{
		if (NT_SUCCESS(Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
										  AFP_STREAM_IDDB,
										  WriteIdDb ?
											FILEIO_OPEN_FILE_SEQ : FILEIO_OPEN_FILE,
										  &UNullString,
										  FILEIO_ACCESS_WRITE,
										  FILEIO_DENY_WRITE,
										  False,
										  &fshIdDb)))
		{

			if (ARGUMENT_PRESENT(pIdDbHdr))
			{
				DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
						("AfpVolumeUpdateIdDbAndDesktop: Writing IdDb Header...\n") );
	
                if (!fAfpServerShutdownEvent)
                {
                    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
                            ("AfpVolumeUpdateIdDbAndDesktop: Corrupting IDDB header\n"));
                    pIdDbHdr->idh_Signature = AFP_SERVER_SIGNATURE_INITIDDB;
                }

				if (!NT_SUCCESS(Status = AfpIoWrite(&fshIdDb,
													&LIZero,
													sizeof(IDDBHDR),
													(PBYTE)pIdDbHdr)))
				{
					// Write failed, put back the dirty bit.
					AfpInterlockedSetDword(&pVolDesc->vds_Flags,
											VOLUME_IDDBHDR_DIRTY,
											&pVolDesc->vds_VolLock);
	
					AFPLOG_ERROR(AFPSRVMSG_WRITE_IDDB,
								 Status,
								 NULL,
								 0,
								 &pVolDesc->vds_Name);
					DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
							("AfpVolumeUpdateIdDbAndDesktop: Error writing IdDb Header %lx\n",
							Status));
				}
			}
			if (WriteIdDb)
			{
				AfpFlushIdDb(pVolDesc, &fshIdDb);
			}

            AfpIoClose(&fshIdDb);

		}
		else
		{
			// Open failed, put back the dirty bit
			AfpInterlockedSetDword(&pVolDesc->vds_Flags,
									VOLUME_IDDBHDR_DIRTY,
									&pVolDesc->vds_VolLock);

			AFPLOG_ERROR(AFPSRVMSG_WRITE_IDDB,
						 Status,
						 NULL,
						 0,
						 &pVolDesc->vds_Name);
			DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
					("AfpVolumeUpdateIdDbAndDesktop: Error opening IdDb Header %lx\n",
					Status));
		}
	}

	if (WriteDt)
	{
		AfpUpdateDesktop(pVolDesc);
	}

	AfpPutBackROAttr(&pVolDesc->vds_hRootDir, WriteBackROAttr);

    if (ModStatus == AFP_ERR_NONE)
    {

        ModStatus = AfpIoRestoreTimeStamp(&pVolDesc->vds_hRootDir,
                                          &ModTime,
                                          AFP_RESTORE_MODTIME);
    }


}

 /***	afpNudgeCdfsVolume
 *
 *	Called from within the volume scavenger to verify if either a CD which we
 *	believe to be valid is still so or one we believe to be invalid has become
 *	valid again.
 */
LOCAL VOID FASTCALL
afpNudgeCdfsVolume(
	IN	PVOLDESC	pVolDesc
)
{
	PFILE_FS_VOLUME_INFORMATION	pVolumeInfo;
	LONGLONG			VolumeBuf[(sizeof(FILE_FS_VOLUME_INFORMATION) + 128)/sizeof(LONGLONG) + 1];
	IO_STATUS_BLOCK				IoStsBlk;
	NTSTATUS					Status;

	PAGED_CODE();

	// Just nudge the CD volume handle to see if this is valid, if
	// not mark the volume as invalid.
	pVolumeInfo = (PFILE_FS_VOLUME_INFORMATION)VolumeBuf;
	Status = NtQueryVolumeInformationFile(pVolDesc->vds_hRootDir.fsh_FileHandle,
										  &IoStsBlk,
										  (PVOID)pVolumeInfo,
										  sizeof(VolumeBuf),
										  FileFsVolumeInformation);
	if (NT_SUCCESS(Status))
	{
		if (pVolDesc->vds_Flags & VOLUME_CDFS_INVALID)
		{
			DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
					("afpNudgeCdfsVolume: Volume %d online again !!!\n",
					pVolDesc->vds_VolId));
			AfpInterlockedClearDword(&pVolDesc->vds_Flags,
								   VOLUME_CDFS_INVALID,
								   &pVolDesc->vds_VolLock);
			AfpVolumeSetModifiedTime(pVolDesc);
		}
	}
	else if ((Status == STATUS_WRONG_VOLUME)		||
			 (Status == STATUS_INVALID_VOLUME_LABEL)||
			 (Status == STATUS_NO_MEDIA_IN_DEVICE)	||
			 (Status == STATUS_UNRECOGNIZED_VOLUME))
	{
		DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
				("afpNudgeCdfsVolume: Volume %d error %lx, marking volume invalid\n",
				pVolDesc->vds_VolId, Status));
		if (!(pVolDesc->vds_Flags & VOLUME_CDFS_INVALID))
		{
			// AFP_LOGERR();
		}
		AfpInterlockedSetDword(&pVolDesc->vds_Flags,
							   VOLUME_CDFS_INVALID,
							   &pVolDesc->vds_VolLock);
		AfpVolumeSetModifiedTime(pVolDesc);
	}
}


/***	AfpUpdateVolFreeSpaceAndModTime
 *
 *	Update free space on a volume and other volumes on the same physical drive. Update
 *	volume modified time on the volume as well.
 *
 *	LOCKS:	AfpVolumeListLock (SPIN)
 */
VOID FASTCALL
AfpUpdateVolFreeSpaceAndModTime(
	IN	PVOLDESC	pVolDesc,
    IN  BOOLEAN     fUpdateModTime
)
{
	PVOLDESC	    pVds;
	KIRQL		    OldIrql, OldIrql1;
	NTSTATUS	    Status;
	WCHAR		    DriveLetter;
	LARGE_INTEGER   FreeSpace;
	AFPTIME		    ModifiedTime;


	ASSERT (VALID_VOLDESC(pVolDesc));

	// Get new values for Free space on disk
	Status = AfpIoQueryVolumeSize(pVolDesc, &FreeSpace, NULL);

	if (!NT_SUCCESS(Status))
	{
		return;
	}

	// Update the free space on all volumes on the same physical ntfs partition
	ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

	DriveLetter = pVolDesc->vds_Path.Buffer[0];
	AfpGetCurrentTimeInMacFormat(&ModifiedTime);

	for (pVds = AfpVolumeList; pVds != NULL; pVds = pVds->vds_Next)
	{
		if (pVds->vds_Path.Buffer[0] == DriveLetter)
		{
			DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
					("AfpUpdateVolFreeSpace: Updating free space for volume %Z\n",
					&pVds->vds_Path));

			ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);
			pVds->vds_FreeBytes = FreeSpace;

            // have we been asked to update volume mod time?
            if (fUpdateModTime)
            {
			    pVolDesc->vds_ModifiedTime = ModifiedTime;
			    pVolDesc->vds_Flags |= VOLUME_IDDBHDR_DIRTY;
            }
			RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);
		}
	}

	RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

}


/***	AfpVolumeScavenger
 *
 *	This is invoked by the scavenger periodically. It initiates the updates to
 *	the id index stream and the desktop stream. If the volume is marked for
 *	shutdown (STOPPED), then do one final flush to disk if needed.  This will
 *	guarantee that any remaining changes get flushed before stopping.
 *	If the volume is marked to either shutdown or delete, then it dereferences
 *	the volume and does not	reschedule itself.
 *
 *	For CD volumes, we want to try to check if the CD is still valid, if not we
 *	want to mark the volume appropritely - basically update the modified date
 *	on the volume - this will cause the clients to come in to refresh and we'll
 *	take care of it then.
 *
 *	LOCKS: vds_VolLock(SPIN),vds_idDbAccessLock(SWMR, Shared),vds_DtAccessLock(SWMR, Shared)
 */
AFPSTATUS FASTCALL
AfpVolumeScavenger(
	IN	PVOLDESC	pVolDesc
)
{
	KIRQL			OldIrql;
	IDDBHDR			IdDbHdr;
	BOOLEAN			WriteHdr = False, WriteIdDb = False, DerefVol = False;
	BOOLEAN			WriteDt = False, AgeDfes = False;
    BOOLEAN         MacLimitExceeded = False;
	AFPSTATUS		RequeueStatus = AFP_ERR_REQUEUE;

	ASSERT(VALID_VOLDESC(pVolDesc) && (pVolDesc->vds_RefCount > 0));

	// Determine if any updates needs to happen. Lock down the volume first
	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
			("AfpVolumeScavenger: Volume %ld Scavenger entered @ %s_LEVEL\n",
		pVolDesc->vds_VolId,
		(OldIrql == DISPATCH_LEVEL) ? "DISPATCH" : "LOW"));

	if (pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED))
	{
		if (IS_VOLUME_NTFS(pVolDesc))
		{
			pVolDesc->vds_cScvgrIdDb = 1;
			pVolDesc->vds_cScvgrDt = 1;
		}
		DerefVol = True;
	}

	if (IS_VOLUME_NTFS(pVolDesc))
	{
		AFPTIME	CurTime;

#ifdef	AGE_DFES
		if (OldIrql == DISPATCH_LEVEL)
		{
			pVolDesc->vds_ScavengerInvocationCnt ++;
		}
#endif

		if (DerefVol && pVolDesc->vds_Flags & VOLUME_IDDBHDR_DIRTY)
		{
		    WriteHdr = True;
		}

		if (pVolDesc->vds_cScvgrIdDb > 0)
		{
		    WriteIdDb = True;
		    WriteHdr = False;	// We will always write the header with the iddb
		}

		if (pVolDesc->vds_cScvgrDt > 0)
		{
		    WriteDt = True;
		}
	}
#ifdef	AGE_DFES
	else	// Not NTFS
	{
		pVolDesc->vds_ScavengerInvocationCnt ++;
	}

	if (IS_VOLUME_AGING_DFES(pVolDesc) &&
		((pVolDesc->vds_ScavengerInvocationCnt % VOLUME_IDDB_AGE_GRANULARITY) == 0))
	{
		AgeDfes = True;
	}
#endif

    // if we are at DPC, return (we will come back at non-dpc)
	if (OldIrql == DISPATCH_LEVEL)
	{
	    RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
		return AFP_ERR_QUEUE;
	}


    // check to see if we have exceeded Mac limits (4GB vol size, 65535 file/folders)
    // if we know we have exceeded the limit, we have already logged an event.  Don't even
    // bother checking in that case.

    if (!pVolDesc->MacLimitExceeded)
    {
        DWORD   dwNumDirs = pVolDesc->vds_NumDirDfEntries;
        DWORD   dwNumFiles = pVolDesc->vds_NumFileDfEntries;

        if ( (dwNumDirs  > APLIMIT_MAX_FOLDERS) ||
             (dwNumFiles > APLIMIT_MAX_FOLDERS) ||
            (dwNumDirs+dwNumFiles > APLIMIT_MAX_FOLDERS) )
        {
            MacLimitExceeded = True;
            pVolDesc->MacLimitExceeded = TRUE;
        }
    }

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

    // update the disk space, but don't update timestamp

    AfpUpdateVolFreeSpaceAndModTime(pVolDesc, FALSE);

    if (MacLimitExceeded)
    {
        AFPLOG_INFO( AFPSRVMSG_TOO_MANY_FOLDERS,
	     		     0,
				     NULL,
					 0,
					 &pVolDesc->vds_Name);

	    DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
				("AfpVolumeScavenger: more than 65535 files+folders on volume %lx\n", pVolDesc) );

    }

	// The following is intentionally bit-wise or instead of logical or
	// The result is same except that this is more efficient
	if (WriteHdr | WriteIdDb | WriteDt)
	{
		ASSERT (IS_VOLUME_NTFS(pVolDesc));

		// Snapshot the IdDbHdr for updating to the disk if it is dirty
		if (WriteHdr)
		{
			ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

			AfpVolDescToIdDbHdr(pVolDesc, &IdDbHdr);

			// Clear the dirty bit
			pVolDesc->vds_Flags &= ~VOLUME_IDDBHDR_DIRTY;

			RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
		}

		AfpVolumeUpdateIdDbAndDesktop(pVolDesc,
									  WriteDt,
									  WriteIdDb,
									  WriteHdr ? &IdDbHdr : NULL);
	}

	if (!DerefVol)
	{
		if (!IS_VOLUME_NTFS(pVolDesc))
		{
			afpNudgeCdfsVolume(pVolDesc);
		}
#ifdef	AGE_DFES
		if (AgeDfes)
		{
			AfpAgeDfEntries(pVolDesc);
		}
#endif
	}
	else
	{
		AfpInterlockedClearDword(&pVolDesc->vds_Flags,
								 VOLUME_SCAVENGER_RUNNING,
								 &pVolDesc->vds_VolLock);
		AfpVolumeDereference(pVolDesc);
		RequeueStatus = AFP_ERR_NONE;
	}

	return RequeueStatus;
}


/***	afpVolumeAdd
 *
 *	Add a newly created volume to the server volume list.  At this point,
 *	at least the volume names, volume path and volume spinlock fields must be
 *	initialized in the volume descriptor.
 *
 *	LOCKS: AfpVolumeListLock (SPIN)
 */
LOCAL AFPSTATUS FASTCALL
afpVolumeAdd(
	IN  PVOLDESC pVolDesc
)
{
	KIRQL		OldIrql;
	AFPSTATUS	rc;

	DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
			("afpVolumeAdd entered\n"));

	// acquire the lock for server global volume list
	ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

	// make sure a volume by that name does not already exist, and
	// make sure a volume doesn't already point to the same volume root dir
	// or to an ancestor or descendent directory of the root dir
	rc = afpVolumeCheckForDuplicate(pVolDesc);
	if (!NT_SUCCESS(rc))
	{
		RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);
		return rc;
	}

	// Assign a new volume id and link in the new volume
	afpVolumeGetNewIdAndLinkToList(pVolDesc);

	// release the server global volume list lock
	RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

	return STATUS_SUCCESS;
}


/***	afpCheckForDuplicateVolume
 *
 *	Check for new volume that a volume by the same name does not
 *	already exist, and that the volume root does not point to an ancestor,
 *	descendent or same directory of an existing volume.  Note that each volume
 *	in the volume list is checked *regardless* of whether or not it is marked
 *	IN_TRANSITION or DELETED.
 *
 *	LOCKS_ASSUMED: AfpVolumeListLock (SPIN)
 */
LOCAL AFPSTATUS FASTCALL
afpVolumeCheckForDuplicate(
	IN PVOLDESC Newvol
)
{
	PVOLDESC	pVolDesc;
	AFPSTATUS	Status = AFP_ERR_NONE;

	DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
			("afpCheckForDuplicateVolume entered\n"));

	do
	{
		for (pVolDesc = AfpVolumeList;
			 pVolDesc != NULL;
			 pVolDesc = pVolDesc->vds_Next)
		{
			// We do not take vds_VolLock for each volume since even if a
			// volume is in transition, its names and path are at least
			// initialized, and cannot change.  We do not reference each
			// volume since in order for to delete or stop a volume, the
			// AfpVolListLock must be taken to unlink it from the list,
			// and whoever called us owns that lock.  These are special
			// exceptions ONLY allowed for the volume add code. Also ignore
			// the volumes that are on their way out. We do not want to punt
			// cases where somebody does a delete followed by an add.

			if (pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED))
				continue;

			if (AfpEqualUnicodeString(&pVolDesc->vds_UpCaseName,
									  &Newvol->vds_UpCaseName))
			{
				Status = AFPERR_DuplicateVolume;
				break;
			}
			// volume paths are stored as uppercase since we cannot do a case
			// insensitive compare while holding a spinlock (DPC level)
			if (AfpPrefixUnicodeString(&pVolDesc->vds_Path, &Newvol->vds_Path) ||
				AfpPrefixUnicodeString(&Newvol->vds_Path, &pVolDesc->vds_Path))
			{
				Status = AFPERR_NestedVolume;
				break;
			}
		}
	} while (False);

	return Status;
}


/***	afpVolumeGetNewIdAndLinkToList
 *
 *	Assign a new volume id to a volume that is being added. The volume is also
 *	inserted into the list but marked as "in transition". This should be cleared
 *	when the volume is 'ready to be mounted'.
 *	The volume ids are recycled. A volume id also cannot be 0 and cannot
 *	exceed MAXSHORT.
 *
 *	We always assign the lowest free id that is not in use. For example if
 *	there are currently N volumes with ids 1, 2, 4, 5 ... N then the newly
 *	created volume will be id 3.
 *
 *	LOCKS_ASSUMED:	AfpVolumeListLock (SPIN)
 */
LOCAL VOID FASTCALL
afpVolumeGetNewIdAndLinkToList(
	IN	PVOLDESC	pVolDesc
)
{
	PVOLDESC	*ppVolDesc;

	DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
			("afpGetNewVolIdAndLinkToList entered\n"));

	pVolDesc->vds_Flags |= (VOLUME_INTRANSITION | VOLUME_INITIAL_CACHE);
	AfpVolCount ++;						// Up the count of volumes.
	pVolDesc->vds_VolId = afpSmallestFreeVolId++;
										// This will always be valid
	DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
			("afpGetNewVolIdAndLinkToList: using volID %d\n",
			pVolDesc->vds_VolId));

	// See if we need to do anything to make the above True next time around
	if (afpSmallestFreeVolId <= AfpVolCount)
	{
		// What this means is that we have some holes. Figure out the first
		// free id that can be used.
		for (ppVolDesc = &AfpVolumeList;
			 *ppVolDesc != NULL;
			 ppVolDesc = &((*ppVolDesc)->vds_Next))
		{
			if ((*ppVolDesc)->vds_VolId < afpSmallestFreeVolId)
				continue;
			else if ((*ppVolDesc)->vds_VolId == afpSmallestFreeVolId)
				afpSmallestFreeVolId++;
			else
				break;
		}
	}
	DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
			("afpGetNewVolIdAndLinkToList: next free volID is %d\n",
			afpSmallestFreeVolId));

        // make sure our LargestVolIdInUse value is accurate
        //
        if (afpLargestVolIdInUse < pVolDesc->vds_VolId )
            afpLargestVolIdInUse = pVolDesc->vds_VolId;

	// Now link the descriptor in the list.
	for (ppVolDesc = &AfpVolumeList;
		 *ppVolDesc != NULL;
		 ppVolDesc = &((*ppVolDesc)->vds_Next))
	{
		ASSERT (pVolDesc->vds_VolId != (*ppVolDesc)->vds_VolId);
		if (pVolDesc->vds_VolId < (*ppVolDesc)->vds_VolId)
			break;
	}
	pVolDesc->vds_Next = *ppVolDesc;
	*ppVolDesc = pVolDesc;
}


/***	AfpAdmWVolumeAdd
 *
 *	This routine adds a volume to the server global list of volumes headed by
 *	AfpVolumeList.  The volume descriptor is created and initialized.  The ID
 *	index is read in (or created).  The same is true with the desktop.
 *
 *	This routine will be queued to the worker thread.
 *
 */
AFPSTATUS
AfpAdmWVolumeAdd(
	IN	OUT	PVOID	Inbuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		Outbuf		OPTIONAL
)
{
	PVOLDESC		pVolDesc = NULL;
	UNICODE_STRING	RootName;
	FILESYSHANDLE	hVolRoot;
	DWORD			tempflags;
	DWORD			memsize;
	USHORT			ansivolnamelen, devpathlen;
	PBYTE			tempptr;
	UNICODE_STRING	uname, upwd, upath, udevpath;
	AFPSTATUS		status = STATUS_SUCCESS;
	PAFP_VOLUME_INFO pVolInfo = (PAFP_VOLUME_INFO)Inbuf;
	BOOLEAN			WriteBackROAttr = False, RefForNotify = False;
	BOOLEAN			VolLinked = False;
    BOOLEAN         fNewVolume;
    BOOLEAN         fVerifyIndex = FALSE;
    DWORD           dwDirHashSz;
    DWORD           dwFileHashSz;
	int				i;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
			("AfpAdmWVolumeAdd entered\n"));

	do
	{
		if (pVolInfo->afpvol_props_mask & AFP_VOLUME_DISALLOW_CATSRCH)
        {
		    pVolInfo->afpvol_props_mask &= ~AFP_VOLUME_DISALLOW_CATSRCH;
	        tempflags = AFP_VOLUME_SUPPORTS_FILEID;
        }
        else
        {
	        tempflags = AFP_VOLUME_SUPPORTS_FILEID | AFP_VOLUME_SUPPORTS_CATSRCH;
        }

		RtlInitUnicodeString(&uname,pVolInfo->afpvol_name);
		RtlInitUnicodeString(&upwd,pVolInfo->afpvol_password);
		RtlInitUnicodeString(&upath,pVolInfo->afpvol_path);
        hVolRoot.fsh_FileHandle = NULL;

		// need to prepend "\DOSDEVICES\" to the path of volume root
		devpathlen = upath.MaximumLength + DosDevices.MaximumLength;
		if ((udevpath.Buffer = (PWSTR)AfpAllocNonPagedMemory(devpathlen)) == NULL)
		{
			status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}
		udevpath.Length = 0;
		udevpath.MaximumLength = devpathlen;
		AfpCopyUnicodeString(&udevpath,&DosDevices);
		RtlAppendUnicodeStringToString(&udevpath,&upath);


		// open a handle to the volume root
		status = AfpIoOpen(NULL,
						   AFP_STREAM_DATA,
						   FILEIO_OPEN_DIR,
						   &udevpath,
						   FILEIO_ACCESS_NONE,
						   FILEIO_DENY_NONE,
						   False,
						   &hVolRoot);

		AfpFreeMemory(udevpath.Buffer);

		if (!NT_SUCCESS(status))
		{
		  break;
		}

		if (!AfpIoIsSupportedDevice(&hVolRoot, &tempflags))
		{
			status = AFPERR_UnsupportedFS;
            DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_ERR,
                            ("AfpAdmWVolumeAdd: AFPERR_UnsupportedFS\n"));
			break;
		}

		// allocate a new volume descriptor -- allocate ALL required memory in
		// one fell swoop.  That is, we will just tack all the required string
		// pointers onto the end of the memory chunk that we allocate for the
		// volume descriptor.  In this way, we don't have to deal with checking
		// error codes in a million different places for memory routines and
		// have to clean up a million different pointers if one allocation should
		// fail.
		// NOTE: when deleting a volume, don't free all the individual strings
		//	   withing the voldesc, just free the one chunk of memory

		memsize = sizeof(VOLDESC) +			// volume descriptor
											// mac ansi volume name
				 (ansivolnamelen = (USHORT)RtlUnicodeStringToAnsiSize(&uname)) +
				  uname.MaximumLength * 2 + // unicode volume names (orginial
											//  and uppercase version)
				 AFP_VOLPASS_LEN+1  +		// mac ansi password
				 upath.MaximumLength +		// unicode root path
				 sizeof(WCHAR);				// need to append '\' to root path

		if ((pVolDesc = (PVOLDESC)AfpAllocZeroedNonPagedMemory(memsize)) == NULL)
		{
		  status = STATUS_INSUFFICIENT_RESOURCES;
		  break;
		}

	#if DBG
		pVolDesc->Signature = VOLDESC_SIGNATURE;
	#endif

		// the volume lock MUST be initialized prior to linking into global
		// volume list
		INITIALIZE_SPIN_LOCK(&pVolDesc->vds_VolLock);

		AfpSwmrInitSwmr(&pVolDesc->vds_IdDbAccessLock);
		AfpSwmrInitSwmr(&pVolDesc->vds_ExchangeFilesLock);

		for (i = 0; i < NUM_AFP_CHANGE_ACTION_LISTS; i++)
		{
			InitializeListHead(&pVolDesc->vds_OurChangeList[i]);
		}

		InitializeListHead(&pVolDesc->vds_ChangeNotifyLookAhead);

		InitializeListHead(&pVolDesc->vds_DelayedNotifyList);

		// calculate pointer for the unicode path string
		tempptr = (PBYTE)pVolDesc + sizeof(VOLDESC);

		// initialize unicode path string
		AfpSetEmptyUnicodeString(&(pVolDesc->vds_Path),
								 upath.MaximumLength + sizeof(WCHAR),tempptr);
		// This must be stored as uppercase since we cannot do case insensitive
		// string compares at DPC level (holding the volume spinlock) to
		// detect nested volumes
		RtlUpcaseUnicodeString(&(pVolDesc->vds_Path), &upath, False);

		// Does the path already contain a trailing backslash?
		if (pVolDesc->vds_Path.Buffer[(pVolDesc->vds_Path.Length/sizeof(WCHAR))-1] != L'\\')
		{
			// append a backslash to simplify search for nested volumes
			RtlCopyMemory(tempptr + upath.Length, L"\\", sizeof(WCHAR));
			pVolDesc->vds_Path.Length += sizeof(WCHAR);
			RtlCopyMemory(tempptr + upath.Length + sizeof(WCHAR), L"",
													sizeof(UNICODE_NULL));
		}

		// calculate pointer for the unicode volume name
		tempptr += upath.MaximumLength + sizeof(WCHAR);

		// initialize the unicode volume name
		AfpSetEmptyUnicodeString(&(pVolDesc->vds_Name),uname.MaximumLength,tempptr);
		AfpCopyUnicodeString(&(pVolDesc->vds_Name),&uname);
		RtlCopyMemory(tempptr + uname.Length,L"",sizeof(UNICODE_NULL));

		// calculate pointer for the UPPER CASE unicode volume name
		tempptr += uname.MaximumLength;

		// initialize the UPPER CASE unicode volume name
		AfpSetEmptyUnicodeString(&(pVolDesc->vds_UpCaseName),uname.MaximumLength,tempptr);
		RtlUpcaseUnicodeString(&(pVolDesc->vds_UpCaseName), &uname, False);
		RtlCopyMemory(tempptr + uname.Length,L"",sizeof(UNICODE_NULL));

		// calculate pointer for the mac ansi volume name
		tempptr += uname.MaximumLength;

		// initialize the mac ansi volume name
		AfpSetEmptyAnsiString(&(pVolDesc->vds_MacName),ansivolnamelen,tempptr);
		status = AfpConvertStringToAnsi(&uname, &(pVolDesc->vds_MacName));
		if (!NT_SUCCESS(status))
		{
			status = AFPERR_InvalidVolumeName;
			break;
		}

		// calculate pointer for the mac ansi password
		tempptr += ansivolnamelen;

		// initialize the mac ansi password
		AfpSetEmptyAnsiString(&pVolDesc->vds_MacPassword, AFP_VOLPASS_LEN+1, tempptr);
		if (pVolInfo->afpvol_props_mask & AFP_VOLUME_HASPASSWORD)
		{
			status = AfpConvertStringToAnsi(&upwd, &pVolDesc->vds_MacPassword);
			if (!NT_SUCCESS(status))
			{
				status = AFPERR_InvalidPassword;
				break;
			}
			pVolDesc->vds_MacPassword.Length = AFP_VOLPASS_LEN;
		}

		pVolDesc->vds_Flags = 0;

		// Add a creation reference and one for this routine itself.
		pVolDesc->vds_RefCount = 2;

		// add the volume to the global volume list - but mark it as 'add pending'
		status = afpVolumeAdd(pVolDesc);
		if (!NT_SUCCESS(status))
		{
			break;
		}
		VolLinked = True;

		// set miscellaneous fields in volume descriptor
		pVolDesc->vds_hRootDir = hVolRoot;


		pVolDesc->vds_hNWT.fsh_FileHandle = NULL;
		pVolDesc->vds_MaxUses = pVolInfo->afpvol_max_uses;

		pVolDesc->vds_Flags |= (pVolInfo->afpvol_props_mask | tempflags);
		pVolDesc->vds_UseCount = 0;
		pVolDesc->vds_pOpenForkDesc = NULL;

#ifdef	BLOCK_MACS_DURING_NOTIFYPROC
		pVolDesc->vds_QueuedNotifyCount = 0;
#endif
        if (pVolDesc->vds_Flags & VOLUME_DISKQUOTA_ENABLED)
        {
		    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
		        ("AfpAdmWVolumeAdd: DiskQuota is enabled on volume %Z\n",&pVolDesc->vds_Name));
        }

        AfpGetDirFileHashSizes(pVolDesc, &dwDirHashSz, &dwFileHashSz);

		DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
    	    ("AfpAdmWVolumeAdd: DirHash = %d, FileHash = %d, VolSize = %d for vol %Z\n",
            dwDirHashSz,dwFileHashSz,
            (memsize + (sizeof(struct _DirFileEntry *) * (dwDirHashSz+dwFileHashSz))),
            &pVolDesc->vds_Name));

        pVolDesc->vds_DirHashTableSize = dwDirHashSz;
        pVolDesc->vds_FileHashTableSize = dwFileHashSz;

        pVolDesc->vds_pDfeDirBucketStart = (struct _DirFileEntry **)
            AfpAllocZeroedNonPagedMemory(sizeof(struct _DirFileEntry *) * dwDirHashSz);

        if (pVolDesc->vds_pDfeDirBucketStart == NULL)
        {
		    status = STATUS_INSUFFICIENT_RESOURCES;
		    break;
        }

        pVolDesc->vds_pDfeFileBucketStart = (struct _DirFileEntry **)
            AfpAllocZeroedNonPagedMemory(sizeof(struct _DirFileEntry *) * dwFileHashSz);

        if (pVolDesc->vds_pDfeFileBucketStart == NULL)
        {
		    status = STATUS_INSUFFICIENT_RESOURCES;
		    break;
        }

		// snapshot the disk space information
		status = AfpIoQueryVolumeSize(pVolDesc,
									  &pVolDesc->vds_FreeBytes,
									  &pVolDesc->vds_VolumeSize);

		if (!NT_SUCCESS(status))
		{
			break;
		}

		if (IS_VOLUME_NTFS(pVolDesc))
		{
			// In order to create IdIndex, AfpInfo and Desktop, the volume
			// root directory cannot be marked read only
			AfpExamineAndClearROAttr(&hVolRoot, &WriteBackROAttr, NULL, NULL);

			// Get rid of the NetworkTrash directory if it exists
			status = AfpDeleteNetworkTrash(pVolDesc, True);
			if (!NT_SUCCESS(status))
			{
				break;
			}
		}

		// initialize the desktop
		status = AfpInitDesktop(pVolDesc, &fNewVolume);
		if (!NT_SUCCESS(status))
		{
			break;
		}

        // if we just created the index database stream, this must be a new
        // volume.  Also, this is the first pass.  Note these facts
        if (fNewVolume)
        {
		    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
    		    ("AfpAdmWVolumeAdd: AfpInitDesktop says volume %Z is new\n",
                &pVolDesc->vds_Name));

            pVolDesc->vds_Flags |= VOLUME_NEW_FIRST_PASS;
        }

		// initialize the ID index database.
		status = AfpInitIdDb(pVolDesc, &fNewVolume, &fVerifyIndex);
		if (!NT_SUCCESS(status))
		{
		    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
    		    ("AfpAdmWVolumeAdd: AfpInitIdDb failed %lx on volume %Z\n",
                status,&pVolDesc->vds_Name));

			break;
		}

        if (fNewVolume)
        {
		    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
    		    ("AfpAdmWVolumeAdd: AfpInitIdDb says volume %Z is new\n",
                &pVolDesc->vds_Name));

            pVolDesc->vds_Flags |= VOLUME_NEW_FIRST_PASS;
        }

		if (IS_VOLUME_NTFS(pVolDesc))
		{
			// Create the network trash if this is not a CDFS volume;
			// a volume can be changed to/from readonly on the fly, so by putting
			// the network trash even on a readonly NTFS volume, we avoid a lot
			// of painful extra work.  This must be done AFTER initializing
			// the ID index database since we add the DFE for nwtrash.  We do
			// it here BEFORE posting the change notify since if an error
			// occurs, we don't have to clean up the posted notify.
			status = AfpCreateNetworkTrash(pVolDesc);
			if (!NT_SUCCESS(status))
			{
				break;
			}

            //
            // if it's a volume that was created earlier, and if this is not
            // an exclusive volume, post the chgntfy irp
            //
		    if (!fNewVolume && !EXCLUSIVE_VOLUME(pVolDesc))
		    {
    			// Begin monitoring changes to the tree. Even though we may
			    // start processing PC changes before we have finished
			    // enumerating the tree, if we get notified of part of the
			    // tree we have yet to cache (and therefore can't find it's
			    // path in our database its ok, since we will end up
			    // picking up the change when we enumerate that branch.  Also,
			    // by posting this before starting to cache the tree instead
			    // of after, we will pick up any changes that are made to parts
			    // of the tree we have already seen, otherwise we would miss
			    // those.

			    // Explicitly reference this volume for ChangeNotifies and post it
			    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

			    if (AfpVolumeReference(pVolDesc))
                {
			        RefForNotify = True;
			        pVolDesc->vds_RequiredNotifyBufLen = AFP_VOLUME_NOTIFY_STARTING_BUFSIZE;
			        status = AfpVolumePostChangeNotify(pVolDesc);
			        if (!NT_SUCCESS(status))
			        {
    				    AfpVolumeDereference(pVolDesc);
				        RefForNotify = False;
				        break;
			        }
			        status = STATUS_SUCCESS;
                }
                else
                {
		            DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
    			        ("AfpAdmWVolumeAdd: couldn't reference volume %Z!!\n",
                        &pVolDesc->vds_Name));

				    RefForNotify = False;
			        status = STATUS_UNSUCCESSFUL;
                }
		    }
            else
            {
		        DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
				    ("AfpAdmWVolumeAdd: postponing chg-notify irp for %Z\n",&pVolDesc->vds_Name));
            }

		}
	} while (False);

	AfpPutBackROAttr(&hVolRoot, WriteBackROAttr);
	if (WriteBackROAttr && NT_SUCCESS(status))
	{
		pVolDesc->vds_pDfeRoot->dfe_NtAttr |= FILE_ATTRIBUTE_READONLY;
	}

	if (NT_SUCCESS(status))
	{
        if (fNewVolume || fVerifyIndex)
        {
            // put Indexing refcount, removed when we begin indexing
            pVolDesc->vds_RefCount++;
    
            AfpScavengerScheduleEvent(AfpVolumeBeginIndexing,
                                    pVolDesc,
                                    0,
                                    True);
        }
        else
        {
	        // mark the volume as 'officially' added.
	        AfpInterlockedClearDword(&pVolDesc->vds_Flags,
							        VOLUME_INTRANSITION,
                                    &pVolDesc->vds_VolLock);

            // activate the volume if IDDB was read correctly from the file
            afpActivateVolume(pVolDesc);

        }
	}
	else
	{

#if DBG
        if (pVolDesc)
        {
		    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
				("AfpAdmWVolumeAdd: Failed to add volume %Z %lx\n",&pVolDesc->vds_Name,status));
        }
        else
        {
		    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
				("AfpAdmWVolumeAdd: Failed to add volume %lx\n",status));
        }
#endif

		if ((hVolRoot.fsh_FileHandle != NULL) && !VolLinked)
		{
			AfpIoClose(&hVolRoot);
		}

		if (VolLinked)
		{
			// don't clear the VOLUME_INTRANSITION bit since this bit along
			// with VOLUME_DELETED bit signify the special case of an
			// error occurrence during volume add.
			pVolDesc->vds_Flags |= VOLUME_DELETED;

			// Remove the creation reference
			AfpVolumeDereference(pVolDesc);

			// if a Notify was posted, we need to cancel it here.  By
			// deleting the network trash we trigger the notify to complete.
			// This is safer than trying to cancel the irp since there are
			// windows where the vds_VolLock is not held between 2 threads
			// checking/setting vds_Flags. (Notify complete and repost).
			// The spin lock cannot be held while cancelling the Irp.
			//
			// Do this after marking the volume as DELETED since when the
			// notify completion sees the volume is being deleted it will
			// not repost (and will clean up the Irp, etc.).
			if (RefForNotify)
			{
				// Note at this point we are guaranteed there is a trash
				// directory since if creating the trash had failed, we
				// would have failed the volume add before posting the
				// change notify.
				AfpDeleteNetworkTrash(pVolDesc, False);
			}
		}
		else if (pVolDesc != NULL)
		{
            if (pVolDesc->vds_pDfeDirBucketStart)
            {
                AfpFreeMemory(pVolDesc->vds_pDfeDirBucketStart);
            }

            if (pVolDesc->vds_pDfeFileBucketStart)
            {
                AfpFreeMemory(pVolDesc->vds_pDfeFileBucketStart);
            }

			AfpFreeMemory(pVolDesc);
		}
	}

	// Dereferencing the volume here takes care of any necessary error cleanup work
	if (VolLinked)
	{
		AfpVolumeDereference(pVolDesc);
	}

	return status;
}


/***	AfpAdmWVolumeDelete
 *
 *	This routine deletes a volume from the server global list of volumes
 *	headed by AfpVolumeList and recycles its volid.  A volume with active
 *	connections cannot be deleted.
 *
 *	LOCKS: AfpVolumeListLock (SPIN), vds_VolLock (SPIN)
 *	LOCK_ORDER: vds_VolLock (SPIN) after AfpVolumeListLock (SPIN)
 *
 */
AFPSTATUS
AfpAdmWVolumeDelete(
	IN	OUT	PVOID	Inbuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		Outbuf		OPTIONAL
)
{
	WCHAR			wcbuf[AFP_VOLNAME_LEN + 1];
	UNICODE_STRING	uvolname, upcasename;
	KIRQL			OldIrql;
	PVOLDESC		pVolDesc;
	AFPSTATUS		Status = STATUS_SUCCESS;

	DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
			("AfpAdmWVolumeDelete entered\n"));

	RtlInitUnicodeString(&uvolname, ((PAFP_VOLUME_INFO)Inbuf)->afpvol_name);
	AfpSetEmptyUnicodeString(&upcasename, sizeof(wcbuf), wcbuf);
	Status = RtlUpcaseUnicodeString(&upcasename, &uvolname, False);
	ASSERT(NT_SUCCESS(Status));

	do
	{
		// Reference the volume while we clean-up
		pVolDesc = AfpVolumeReferenceByUpCaseName(&upcasename);

		if (pVolDesc == NULL)
		{
			Status = AFPERR_VolumeNonExist;
			break;
		}

		ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

		// make sure there are no AFP clients using the volume
		if (pVolDesc->vds_UseCount != 0)
		{
			RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
			Status = AFPERR_VolumeBusy;
            AfpVolumeDereference(pVolDesc);
			break;
		}

		// if this volume is in the process of being stopped or deleted,
		// in effect it should be 'invisible' to the caller.
		if (pVolDesc->vds_Flags & (VOLUME_STOPPED | VOLUME_DELETED))
		{
			RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
			Status = AFPERR_VolumeNonExist;
            AfpVolumeDereference(pVolDesc);
			break;
		}

        if ((pVolDesc->vds_Flags & VOLUME_INITIAL_CACHE) &&
            !(pVolDesc->vds_Flags & VOLUME_INTRANSITION))
        {
            // set this so we don't reset the Indexing global flag again!
            pVolDesc->vds_Flags |= VOLUME_INTRANSITION;
        }

		pVolDesc->vds_Flags |= VOLUME_DELETED;
		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

		// Remove the creation reference
		AfpVolumeDereference(pVolDesc);

		// Cancel posted change notify
		if (pVolDesc->vds_Flags & VOLUME_NOTIFY_POSTED)
		{
			DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
					("AfpAdmWVolumeDelete: Cancel notify on volume %ld\n",
					pVolDesc->vds_VolId));
			ASSERT (pVolDesc->vds_pIrp != NULL);

			// Cancel after releasing the volume lock since the completion
			// routine acquires it and it could be called in the context
			// of IoCancelIrp(). Also Cancel uses paged resource and so
			// must be called w/o holding any spin locks.

			IoCancelIrp(pVolDesc->vds_pIrp);
		}

		// We have a reference to the volume from AfpFindVolumeByUpcaseName
		ASSERT(pVolDesc->vds_RefCount >= 1);

		// Cancel the OurChange scavenger for this volume.
		if (AfpScavengerKillEvent(AfpOurChangeScavenger, pVolDesc))
		{
			// If it was deleted from scavenger list, run it one last time
			AfpOurChangeScavenger(pVolDesc);
		}

		// Cancel the volume scavenger and call it ourselves to avoid the delay
		if (AfpScavengerKillEvent(AfpVolumeScavenger, pVolDesc))
		{
			// This will do the dereference for the scavenger reference
			// Take away our reference before calling the volume scavenger
			AfpVolumeDereference(pVolDesc);
			AfpVolumeScavenger(pVolDesc);
		}
		else
        {
            AfpVolumeDereference(pVolDesc);
        }
	} while (False);

	return Status;
}



/***	AfpAdmWConnectionClose
 *
 *	Close a connection forcibly. This is an admin operation and must be queued
 *	up since this can potentially cause filesystem operations that are valid
 *	only in the system process context.
 *
 *	LOCKS: AfpConnLock (SPIN), cds_ConnLock (SPIN)
 *	LOCK_ORDER: cds_ConnLock (SPIN) after AfpConnLock (SPIN)
 */
AFPSTATUS
AfpAdmWConnectionClose(
	IN	OUT	PVOID	InBuf		OPTIONAL,
	IN	LONG		OutBufLen	OPTIONAL,
	OUT	PVOID		OutBuf		OPTIONAL
)
{
	AFPSTATUS				Status = AFPERR_InvalidId;
	PCONNDESC				pConnDesc;
	DWORD					ConnId;
	PAFP_CONNECTION_INFO	pConnInfo = (PAFP_CONNECTION_INFO)InBuf;
	AFP_SESSION_INFO		SessInfo;
	BOOLEAN					KillSessionToo;

	if ((ConnId = pConnInfo->afpconn_id) != 0)
	{
		if ((pConnDesc = afpConnectionReferenceById(ConnId)) != NULL)
		{
			SessInfo.afpsess_id = pConnDesc->cds_pSda->sda_SessionId;
			KillSessionToo = (pConnDesc->cds_pSda->sda_cOpenVolumes == 1) ?
											True : False;
			AfpConnectionClose(pConnDesc);
			AfpConnectionDereference(pConnDesc);

			if (KillSessionToo)
			{
				AfpAdmWSessionClose(&SessInfo, 0, NULL);
			}
			Status = AFP_ERR_NONE;
		}
	}
	else
	{
		DWORD			ConnId = MAXULONG;
		KIRQL			OldIrql;
		BOOLEAN			Shoot;

		Status = AFP_ERR_NONE;
		while (True)
		{
			ACQUIRE_SPIN_LOCK(&AfpConnLock, &OldIrql);

			for (pConnDesc = AfpConnList;
				 pConnDesc != NULL;
				 pConnDesc = pConnDesc->cds_NextGlobal)
			{
				if (pConnDesc->cds_ConnId > ConnId)
					continue;

				ACQUIRE_SPIN_LOCK_AT_DPC(&pConnDesc->cds_ConnLock);

				ConnId = pConnDesc->cds_ConnId;

				Shoot = False;

				if (!(pConnDesc->cds_Flags & CONN_CLOSING))
				{
					pConnDesc->cds_RefCount ++;
					Shoot = True;
					SessInfo.afpsess_id = pConnDesc->cds_pSda->sda_SessionId;
					KillSessionToo = (pConnDesc->cds_pSda->sda_cOpenVolumes == 1) ?
															True : False;
				}

				RELEASE_SPIN_LOCK_FROM_DPC(&pConnDesc->cds_ConnLock);

				if (Shoot)
				{
					RELEASE_SPIN_LOCK(&AfpConnLock, OldIrql);

					AfpConnectionClose(pConnDesc);
					AfpConnectionDereference(pConnDesc);

					if (KillSessionToo)
					{
						AfpAdmWSessionClose(&SessInfo, 0, NULL);
					}
					break;
				}
			}
			if (pConnDesc == NULL)
			{
				RELEASE_SPIN_LOCK(&AfpConnLock, OldIrql);
				break;
			}
		}
	}

	return Status;
}



/***	AfpVolumeBeginIndexing
 *
 *	Check if another volume is doing it's indexing: if yes, put it back on the
 *  queue and try later.  If no one else is indexing, start indexing this volume
 *
 */
AFPSTATUS FASTCALL
AfpVolumeBeginIndexing(
    IN  PVOLDESC            pVolDesc
)
{

    KIRQL           OldIrql;
    UNICODE_STRING  RootName;
    BOOLEAN         fVolumeStopped=FALSE;
	LARGE_INTEGER	IndexStartTime;


    // is the volume stopped or deleted?  ignore this then
    ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);
    if (pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED))
    {
	    DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
    	    ("AfpVolumeBeginIndexing: volume %Z stopping, cancelling indexing\n",&pVolDesc->vds_Name));
        fVolumeStopped = TRUE;
    }
    RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);


    if (fVolumeStopped)
    {
	    // Remove the Indexing reference
	    AfpVolumeDereference(pVolDesc);

        return(AFP_ERR_NONE);
    }

	KeQuerySystemTime (&IndexStartTime);
	pVolDesc->vds_IndxStTime = IndexStartTime;

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
	    ("AfpVolumeBeginIndexing: indexing volume %Z at %8lx%08lx\n",&pVolDesc->vds_Name, 
		 0xffffffff*IndexStartTime.HighPart,
		 0xffffffff*IndexStartTime.LowPart));

	// scan the entire directory tree and sync disk with iddb.  Must be
	// done AFTER initializing the Desktop since we may add APPL mappings
	// while enumerating the disk.  Also we need to know if we read an
	// old style desktop off the disk, and if so, need to rebuild all the
	// APPL mappings so they have the parentID.
	
	AfpSetEmptyUnicodeString(&RootName, 0, NULL);
	AfpQueuePrivateChangeNotify(pVolDesc,
								&RootName,
								&RootName,
								AFP_ID_ROOT);

	// mark the volume as 'officially' added.
	AfpInterlockedClearDword(&pVolDesc->vds_Flags,
							VOLUME_INTRANSITION,
							&pVolDesc->vds_VolLock);

	// Remove the Indexing reference
	AfpVolumeDereference(pVolDesc);

    return(AFP_ERR_NONE);
}



/***	AfpVolumePostChangeNotify
 *
 *	Post a change notify on the root of the volume.  If the current size of
 *  the notify buffer for this volume is not large enough to accomodate a path
 *  containing n+1 macintosh filename components, (where n is the maximum
 *  depth of the directory tree and a component is a maximum of 31 unicode
 *  chars plus 1 char path separator), then the buffer is reallocated.
 *  The notify buffer does not ever shrink in size since we cannot keep track
 *  of the maximum depth of each branch of the directory tree whenever a
 *  directory is deleted.
 *
 *  Note that the initial size of the notify buffer is
 *  AFP_VOLUME_NOTIFY_STARTING_BUFSIZE.  When a volume is added, the change
 *  notify is posted *before* the Id Index database is constructed so we do
 *  not know what the maximum depth of the tree is yet.  In most cases this
 *  buffer length is sufficient and will probably never get reallocated unless
 *  some sadistic test is running that creates very deep directories.  Note
 *  that since the maximum path in win32 is 260 chars, the initial buffer
 *  size is adequate to handle any changes notified from PC side.
 *
 */
NTSTATUS FASTCALL
AfpVolumePostChangeNotify(
	IN	PVOLDESC		pVolDesc
)
{
	PIRP				pIrp = NULL;
	PMDL				pMdl = NULL;
	PBYTE				pNotifyBuf = NULL;
	DWORD				NotifyBufSize = 0;
	NTSTATUS			Status = STATUS_SUCCESS;
	PDEVICE_OBJECT		pDeviceObject;
	PIO_STACK_LOCATION	pIrpSp;

	PAGED_CODE ();

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	ASSERT(pVolDesc->vds_pFileObject != NULL);

	do
	{
		// Get the address of the target device object.
		pDeviceObject = IoGetRelatedDeviceObject(AfpGetRealFileObject(pVolDesc->vds_pFileObject));

        // free that irp: we need to allocate a new one, in case some
        // filter driver chained itself in
		if ((pIrp = pVolDesc->vds_pIrp) != NULL)
        {
            if (pIrp->MdlAddress != NULL)
            {
			    pNotifyBuf = MmGetSystemAddressForMdlSafe(
						pIrp->MdlAddress,
						NormalPagePriority);

			    AfpFreeMdl(pIrp->MdlAddress);

				if (pNotifyBuf != NULL)
				{
					AfpFreeMemory(pNotifyBuf);

					pNotifyBuf = NULL;
				}
            }

            pVolDesc->vds_pIrp = NULL;
            AfpFreeIrp(pIrp);
        }

		// Allocate and initialize the IRP for this operation, if we do not already
		// have an Irp allocated for this volume.
		if ((pIrp = AfpAllocIrp(pDeviceObject->StackSize)) == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		pVolDesc->vds_pIrp = pIrp;

		
		// Re-initialize the stack location.
		pIrp->CurrentLocation = (CCHAR)(pIrp->StackCount + 1);
		pIrp->Tail.Overlay.CurrentStackLocation =
										((PIO_STACK_LOCATION)((UCHAR *)(pIrp) +
										sizeof(IRP) +
										((pDeviceObject->StackSize) * sizeof(IO_STACK_LOCATION))));

        //
		// If we aren't going to resue the buffer and the mdl, allocate a buffer for
        // Notify information and create an Mdl for it.
        //
        if (pNotifyBuf == NULL)
        {
		    NotifyBufSize = pVolDesc->vds_RequiredNotifyBufLen;

		    if (((pNotifyBuf = AfpAllocNonPagedMemory(NotifyBufSize)) == NULL) ||
			    ((pMdl = AfpAllocMdl(pNotifyBuf, NotifyBufSize, pIrp)) == NULL))
		    {
			    Status = STATUS_INSUFFICIENT_RESOURCES;
			    break;
		    }
        }
        else
        {
            ASSERT(pMdl != NULL);
            pIrp->MdlAddress = pMdl;
        }

        ASSERT(NotifyBufSize > 0);

		// Set up the completion routine.
		IoSetCompletionRoutine( pIrp,
								afpVolumeChangeNotifyComplete,
								pVolDesc,
								True,
								True,
								True);

		pIrp->Tail.Overlay.OriginalFileObject = AfpGetRealFileObject(pVolDesc->vds_pFileObject);
		pIrp->Tail.Overlay.Thread = AfpThread;
		pIrp->RequestorMode = KernelMode;

		// Get a pointer to the stack location for the first driver. This will be
		// used to pass the original function codes and the parameters.
		pIrpSp = IoGetNextIrpStackLocation(pIrp);
		pIrpSp->MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
		pIrpSp->MinorFunction = IRP_MN_NOTIFY_CHANGE_DIRECTORY;
		pIrpSp->FileObject = AfpGetRealFileObject(pVolDesc->vds_pFileObject);
		pIrpSp->DeviceObject = pDeviceObject;

		// Copy the parameters to the service-specific portion of the IRP.
		pIrpSp->Parameters.NotifyDirectory.Length = NotifyBufSize;

		// We do not try to catch FILE_NOTIFY_CHANGE_SECURITY since it will
		// complete with FILE_ACTION_MODIFIED, and we can't tell that it was
		// actually security that changed.  A change in security will update
		// the last ChangeTime, but we can't pick this up for every
		// FILE_ACTION_MODIFIED that comes in!  So the result will be that
		// if PC changes security, we will not update the modified time on
		// a directory (nor the VolumeModified time so that mac would
		// reenumerate any open windows to display the change in security).
		pIrpSp->Parameters.NotifyDirectory.CompletionFilter =
												FILE_NOTIFY_CHANGE_NAME			|
												FILE_NOTIFY_CHANGE_ATTRIBUTES	|
												FILE_NOTIFY_CHANGE_SIZE			|
												FILE_NOTIFY_CHANGE_CREATION	|
												FILE_NOTIFY_CHANGE_STREAM_SIZE	|
												FILE_NOTIFY_CHANGE_LAST_WRITE;

		pIrpSp->Flags = SL_WATCH_TREE;

		ASSERT(!(pVolDesc->vds_Flags & VOLUME_DELETED));

		INTERLOCKED_INCREMENT_LONG( &afpNumPostedNotifies );

		AfpInterlockedSetDword( &pVolDesc->vds_Flags,
								VOLUME_NOTIFY_POSTED,
								&pVolDesc->vds_VolLock);

		Status = IoCallDriver(pDeviceObject, pIrp);
		DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
				("AfpVolumePostChangeNotify: Posted ChangeNotify on %Z (status 0x%lx)\n",
				  &pVolDesc->vds_Name, Status));
	} while (False);

	ASSERTMSG("Post of Volume change notify failed!", NT_SUCCESS(Status));

	if (Status == STATUS_INSUFFICIENT_RESOURCES)
	{
		AFPLOG_DDERROR( AFPSRVMSG_NONPAGED_POOL,
						STATUS_NO_MEMORY,
						NULL,
						0,
						NULL);

		if (pNotifyBuf != NULL)
			AfpFreeMemory(pNotifyBuf);

		if (pIrp != NULL)
			AfpFreeIrp(pIrp);

		if (pMdl != NULL)
			AfpFreeMdl(pMdl);
	}

	return Status;
}



/***	afpVolumeChangeNotifyComplete
 *
 *	This is the completion routine for a posted change notify request. Queue
 *	this Volume for ChangeNotify processing. No items should be processed
 *  until the volume is marked as started because the volume may be in the
 *  middle of its initial sync with disk of the entire tree, and we don't
 *  want to 'discover' a part of the tree that we may not have seen yet but
 *  that somebody just changed.
 *
 *	LOCKS:		AfpServerGlobalLock (SPIN), vds_VolLock (SPIN)
 */
NTSTATUS
afpVolumeChangeNotifyComplete(
	IN	PDEVICE_OBJECT	pDeviceObject,
	IN	PIRP			pIrp,
	IN	PVOLDESC		pVolDesc
)
{
	PVOL_NOTIFY	pVolNotify = NULL;
	PBYTE		pBuf;
	NTSTATUS	status = STATUS_SUCCESS;

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	ASSERT(VALID_VOLDESC(pVolDesc));

	ASSERT(pIrp == pVolDesc->vds_pIrp);

	ASSERT(pIrp->MdlAddress != NULL);

	pBuf = MmGetSystemAddressForMdlSafe(
			pIrp->MdlAddress,
			NormalPagePriority);

	AfpInterlockedClearDword(&pVolDesc->vds_Flags,
							 VOLUME_NOTIFY_POSTED,
							 &pVolDesc->vds_VolLock);

	INTERLOCKED_DECREMENT_LONG(&afpNumPostedNotifies);

	if (((AfpServerState == AFP_STATE_SHUTTINGDOWN) ||
		 (AfpServerState == AFP_STATE_STOP_PENDING)) &&
		 (afpNumPostedNotifies == 0))
	{
		// If we are getting out, unblock the the admin thread
		KeSetEvent(&AfpStopConfirmEvent, IO_NETWORK_INCREMENT, False);
	}

	if (((pIrp->IoStatus.Status != STATUS_CANCELLED) &&
		((pVolDesc->vds_Flags & (VOLUME_STOPPED | VOLUME_DELETED)) == 0)) &&
			(pBuf != NULL)
		)
	{
		if ((NT_SUCCESS(pIrp->IoStatus.Status)) &&
			(pIrp->IoStatus.Information > 0))
		{
			// Allocate a notify structure and copy the data into it.
			// Post another notify before we process this one
			pVolNotify = (PVOL_NOTIFY)AfpAllocNonPagedMemory(sizeof(VOL_NOTIFY) +
															 (ULONG)(pIrp->IoStatus.Information) +
															 (AFP_LONGNAME_LEN + 1)*sizeof(WCHAR));
			if (pVolNotify != NULL)
			{
				AfpGetCurrentTimeInMacFormat(&pVolNotify->vn_TimeStamp);
				pVolNotify->vn_pVolDesc = pVolDesc;
				pVolNotify->vn_Processor = AfpProcessChangeNotify;
				RtlCopyMemory((PCHAR)pVolNotify + sizeof(VOL_NOTIFY),
							  pBuf,
							  pIrp->IoStatus.Information);
			}
			else
			{
                DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,("Out of memory!!\n"));
                ASSERT(0);
				status = STATUS_INSUFFICIENT_RESOURCES;
			}
		}
		else
		{
            if (pIrp->IoStatus.Status == STATUS_NOTIFY_ENUM_DIR)
            {
                pVolDesc->vds_RequiredNotifyBufLen *= 2;

                if (pVolDesc->vds_RequiredNotifyBufLen > AFP_VOLUME_NOTIFY_MAX_BUFSIZE)
                {
                    DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
                        ("afpVolumeChangeNotifyComplete: even %d isn't enough (%d,%lx)??\n",
                        AFP_VOLUME_NOTIFY_MAX_BUFSIZE,pVolDesc->vds_RequiredNotifyBufLen,pBuf));
                    ASSERT(0);

                    pVolDesc->vds_RequiredNotifyBufLen = AFP_VOLUME_NOTIFY_MAX_BUFSIZE;
                }
            }
            else
            {
                DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
                    ("afpVolumeChangeNotifyComplete: Status %lx, Info %d\n",
                    pIrp->IoStatus.Status,pIrp->IoStatus.Information));
                ASSERT(0);
            }

			status = pIrp->IoStatus.Status;
		}

		// Repost our ChangeNotify request if the last one completed
		// without an error
		if (NT_SUCCESS(pIrp->IoStatus.Status))
		{
			AfpVolumePostChangeNotify(pVolDesc);
		}
		else
		{
			// If this notify completed with an error, we cannot recursively
			// repost another one, since it will just keep completing with
			// the same error and we will run out of stack space recursing.
			// We will have to queue up a work item so that the
			// change notify request will get reposted for this volume.
			// Note that in the time it takes to do this, many changes could
			// pile up so the next completion would have multiple entries
			// returned in the list.
			AfpScavengerScheduleEvent(AfpVolumePostChangeNotify,
									  (PVOID)pVolDesc,
									  0,
									  True);
		}

		if (pVolNotify != NULL)
		{
			if (AfpShouldWeIgnoreThisNotification(pVolNotify))
			{
				AfpFreeMemory(pVolNotify);
			}
			else
			{
				PFILE_NOTIFY_INFORMATION pFNInfo;

				// Reference the volume for Notify processing
				if (AfpVolumeReference(pVolDesc))
                {
				    AfpVolumeInsertChangeNotifyList(pVolNotify, pVolDesc);
	
				    pFNInfo = (PFILE_NOTIFY_INFORMATION)(pVolNotify + 1);
				    if ((pFNInfo->Action == FILE_ACTION_REMOVED) ||
					    (pFNInfo->Action == FILE_ACTION_RENAMED_OLD_NAME))
				    {
					    // Chain all the rename and delete changes off of the
					    // volume descriptor in case we ever need to lookahead
					    // for one.  We only look at the first change in each
					    // FILE_NOTIFY_INFORMATION since normally there will only
					    // be one entry per buffer since we repost our changenotify
					    // within our completion routine.
					    ExInterlockedInsertTailList(&pVolDesc->vds_ChangeNotifyLookAhead,
						    						&pVolNotify->vn_DelRenLink,
							    					&(pVolDesc->vds_VolLock.SpinLock));
				    }
				    else
				    {
					    // Just set links to initialized state. These will never be looked at.
					    InitializeListHead(&pVolNotify->vn_DelRenLink);
				    }
                }
                else
                {
		            DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
    			        ("afpVolumeChangeNotifyComplete: couldn't reference volume %Z!!\n",
                        &pVolDesc->vds_Name));

				    AfpFreeMemory(pVolNotify);
                }
			}
		}
		else
		{
			AFPLOG_ERROR(AFPSRVMSG_MISSED_NOTIFY,
						 status,
						 NULL,
						 0,
						 &pVolDesc->vds_Name);
		}
	}
	else
	{
		// Free the resources and get out
		AfpFreeMdl(pIrp->MdlAddress);

		if (pBuf != NULL)
			AfpFreeMemory(pBuf);
		AfpFreeIrp(pIrp);
		pVolDesc->vds_pIrp = NULL;

		AfpVolumeDereference(pVolDesc);
	}

	// Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
	// will stop working on the IRP.

	return STATUS_MORE_PROCESSING_REQUIRED;
}

/***	afpAllocNotify
 *
 *	Allocate a Notify from the Notify Blocks. The Notify's are allocated 
 *  in 4K chunks and internally managed. The idea is primarily to reduce 
 *  the dependency we may have on non-paged/paged memory during posting 
 *  private notify code.
 *
 *	The Notify's are allocated out of virtual memory.
 *
 *	LOCKS:	afpNotifyBlockLock (SWMR, Exclusive)
 *
 */
PVOL_NOTIFY 
afpAllocNotify(
	IN	LONG	Index,
	IN	BOOLEAN	fDir
)
{
	PVOL_NOTIFY_BLOCK	pDfb;
	PVOL_NOTIFY	pVolNotify = NULL;

	PAGED_CODE( );

	ASSERT ((Index >= 0) && (Index < NOTIFY_MAX_BLOCK_TYPE));

	AfpSwmrAcquireExclusive(&afpNotifyBlockLock);


	// If the block head has no free entries then there are none !!
	// Pick the right block based on whether it is file or dir
	pDfb = afpDirNotifyPartialBlockHead[Index];
	if (pDfb == NULL)
	{
		// Currently we will directly allocate it instead of managing
		// the free list and assigning out of it
		//
		// There are no partial blocks. Check if there any free ones 
		// and if there move them to partial
		// since we about to allocate from them
		//
			pDfb = afpDirNotifyFreeBlockHead[Index];
			if (pDfb != NULL)
			{
				AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);
				AfpLinkDoubleAtHead(afpDirNotifyPartialBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
			}
	}

	if (pDfb != NULL)

	{
		ASSERT(VALID_NOTIFY_BLOCK(pDfb));
		ASSERT((pDfb->dfb_NumFree <= afpNotifyNumDirBlocks[Index]));

		ASSERT (pDfb->dfb_NumFree != 0);
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("afpAllocDfe: Found space in Block %lx\n", pDfb));
	}

	if (pDfb == NULL)
	{

		if ((pDfb = (PVOL_NOTIFY_BLOCK)AfpAllocateVirtualMemoryPage()) != NULL)
		{
			USHORT	i;
			USHORT 	MaxDfes, NotifySize;

			afpNotifyBlockAllocCount ++;
			// update max notify block alloc count
			if (afpNotifyBlockAllocCount > afpMaxNotifyBlockAllocCount)
			{
				afpMaxNotifyBlockAllocCount = afpNotifyBlockAllocCount;
			}

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpAllocNotify: No free blocks. Allocated a new block %lx , count=%ld\n",
					pDfb, afpNotifyBlockAllocCount));

			//
           		// Link it in the partial list as we are about to 
			// allocate one block out of it anyway.
			//
			AfpLinkDoubleAtHead(afpDirNotifyPartialBlockHead[Index],
								pDfb,
								dfb_Next,
								dfb_Prev);
			NotifySize = afpNotifyDirBlockSize[Index];
			pDfb->dfb_NumFree = MaxDfes = afpNotifyNumDirBlocks[Index];

			ASSERT(QUAD_SIZED(NotifySize));
			pDfb->dfb_Age = 0;

			// Initialize the list of free notify entries
			for (i = 0, pVolNotify = pDfb->dfb_FreeHead = (PVOL_NOTIFY)((PBYTE)pDfb + sizeof(VOL_NOTIFY_BLOCK));
				 i < MaxDfes;
				 i++, pVolNotify = pVolNotify->Notify_NextFree)
			{
				pVolNotify->Notify_NextFree = (i == (MaxDfes - 1)) ?
											NULL :
											(PVOL_NOTIFY)((PBYTE)pVolNotify + NotifySize);
			}
		}
        	else
        	{
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
					("afpAllocDfe: AfpAllocateVirtualMemoryPage failed\n"));

            		AFPLOG_ERROR(AFPSRVMSG_VIRTMEM_ALLOC_FAILED,
                         	STATUS_INSUFFICIENT_RESOURCES,
                         	NULL,
                         	0,
                         	NULL);
        	}
	}

	if (pDfb != NULL)
	{
		PVOL_NOTIFY_BLOCK	pTmp;

		ASSERT(VALID_NOTIFY_BLOCK(pDfb));

		pVolNotify = pDfb->dfb_FreeHead;
		afpNotifyAllocCount ++;
		pDfb->dfb_FreeHead = pVolNotify->Notify_NextFree;
		pDfb->dfb_NumFree --;

		//
		// If the block is now empty (completely used), unlink it 
		// from here and move it to the Used list.
		//
		if (pDfb->dfb_NumFree == 0)
		{
			AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);
				AfpLinkDoubleAtHead(afpDirNotifyUsedBlockHead[Index],
									pDfb,
									dfb_Next,
									dfb_Prev);
		}

	}

	AfpSwmrRelease(&afpNotifyBlockLock);

	return pVolNotify;
}


/***	afpFreeNotify
 *
 *	Return a Notify to the allocation block.
 *
 *	LOCKS:	afpNotifyBlockLock (SWMR, Exclusive)
 */
VOID 
afpFreeNotify(
	IN	PVOL_NOTIFY	pVolNotify
)
{
	PVOL_NOTIFY_BLOCK	pDfb;
	ULONG		NumBlks, index;

	PAGED_CODE( );

	// NOTE: The following code *depends* on the fact that we allocate DFBs as
	//		 64K blocks and also that these are allocated *at* 64K boundaries
	//		 This lets us *cheaply* get to the owning DFB from the DFE.
	pDfb = (PVOL_NOTIFY_BLOCK)((ULONG_PTR)pVolNotify & ~(PAGE_SIZE-1));
	ASSERT(VALID_NOTIFY_BLOCK(pDfb));

	AfpSwmrAcquireExclusive(&afpNotifyBlockLock);

	afpNotifyAllocCount --;

	index = NOTIFY_USIZE_TO_INDEX(pVolNotify->vn_VariableLength);
	NumBlks = afpNotifyNumDirBlocks[index];

	ASSERT(pDfb->dfb_NumFree < NumBlks);

#if DBG
	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
			("AfpFreeDfe: Returning Notify %lx to Block %lx, index=%ld, dfb=%ld, alloc=%ld\n",
			pVolNotify, pDfb, index, pDfb->dfb_NumFree+1, afpNotifyAllocCount));
#endif

	pDfb->dfb_NumFree ++;
	pVolNotify->Notify_NextFree = pDfb->dfb_FreeHead;
	pDfb->dfb_FreeHead = pVolNotify;

	if (pDfb->dfb_NumFree == 1)
	{
		ULONG		Index;

		//
		// The block is now partially free (it used to be completely used). move it to the partial list.
		//

		Index = NOTIFY_USIZE_TO_INDEX(pVolNotify->vn_VariableLength);
		AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);
		AfpLinkDoubleAtHead(afpDirNotifyPartialBlockHead[Index],
							pDfb,
							dfb_Next,
							dfb_Prev);
	}
	else if (pDfb->dfb_NumFree == NumBlks)
	{
		ULONG		Index;

		//
		// The block is now completely free (used to be partially used). move it to the free list
		//

		Index = NOTIFY_USIZE_TO_INDEX(pVolNotify->vn_VariableLength);
		pDfb->dfb_Age = 0;
		AfpUnlinkDouble(pDfb, dfb_Next, dfb_Prev);

		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
				("afpFreeDfe: Freeing Block %lx, Index=%ld\n", pDfb, Index));

		AfpLinkDoubleAtHead(afpDirNotifyFreeBlockHead[Index],
							pDfb,
							dfb_Next,
							dfb_Prev);
	}

	AfpSwmrRelease(&afpNotifyBlockLock);

}

/***	afpNotifyBlockAge
 *
 *	Age out Notify Blocks
 *
 *	LOCKS:	afpNotifyBlockLock (SWMR, Exclusive)
 */
AFPSTATUS FASTCALL
afpNotifyBlockAge(
	IN	PPVOL_NOTIFY_BLOCK	ppBlockHead
)
{
	int			index, MaxDfes;
	PVOL_NOTIFY_BLOCK	pDfb;

	PAGED_CODE( );

	AfpSwmrAcquireExclusive(&afpNotifyBlockLock);

	for (index = 0; index < NOTIFY_MAX_BLOCK_TYPE; index++)
	{
		pDfb = ppBlockHead[index];
		if (pDfb != NULL)
		{
			MaxDfes = afpNotifyNumDirBlocks[index];
		}

		while (pDfb != NULL)
		{
			PVOL_NOTIFY_BLOCK pFree;

			ASSERT(VALID_NOTIFY_BLOCK(pDfb));

			pFree = pDfb;
			pDfb = pDfb->dfb_Next;

			ASSERT (pFree->dfb_NumFree == MaxDfes);

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpNotifyBlockAge: Aging Block %lx, Size %d\n", pFree,
					afpNotifyDirBlockSize[index]));
			if (++(pFree->dfb_Age) >= NOTIFY_MAX_BLOCK_AGE)
			{
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
						("afpNotifyBlockAge: Freeing Block %lx, Size %d\n", pFree,
						afpNotifyDirBlockSize[index]));
				AfpUnlinkDouble(pFree, dfb_Next, dfb_Prev);
				AfpFreeVirtualMemoryPage(pFree);
				afpNotifyBlockAllocCount--;
			}
		}
	}

	AfpSwmrRelease(&afpNotifyBlockLock);

	return AFP_ERR_REQUEUE;
}

/***	afpFreeNotifyBlockMemory
 *
 *	Forced Freeing of Notify Blocks
 *
 *	LOCKS:	afpNotifyBlockLock (SWMR, Exclusive)
 */
VOID afpFreeNotifyBlockMemory (
)
{
	int			index, MaxDfes;
	PVOL_NOTIFY_BLOCK	pDfb;

	PAGED_CODE( );

	AfpSwmrAcquireExclusive(&afpNotifyBlockLock);

	for (index = 0; index < NOTIFY_MAX_BLOCK_TYPE; index++)
	{
		pDfb = afpDirNotifyFreeBlockHead[index];
		if (pDfb != NULL)
		{
			MaxDfes = afpNotifyNumDirBlocks[index];
		}

		while (pDfb != NULL)
		{
			PVOL_NOTIFY_BLOCK pFree;

			ASSERT(VALID_NOTIFY_BLOCK(pDfb));

			pFree = pDfb;
			pDfb = pDfb->dfb_Next;

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpFreeNotifyBlockMemory: Cleaningup Free Block %lx, Size %d\n", 
					 pFree, afpNotifyDirBlockSize[index]));
				AfpUnlinkDouble(pFree, dfb_Next, dfb_Prev);
				AfpFreeVirtualMemoryPage(pFree);
				afpNotifyBlockAllocCount--;
		}

		pDfb = afpDirNotifyPartialBlockHead[index];
		while (pDfb != NULL)
		{
			PVOL_NOTIFY_BLOCK pFree;

			ASSERT(VALID_NOTIFY_BLOCK(pDfb));

			pFree = pDfb;
			pDfb = pDfb->dfb_Next;

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpFreeNotifyBlockMemory: Cleaningup Partial Block %lx, Size %d\n", 
					 pFree, afpNotifyDirBlockSize[index]));
				AfpUnlinkDouble(pFree, dfb_Next, dfb_Prev);
				AfpFreeVirtualMemoryPage(pFree);
				afpNotifyBlockAllocCount--;
		}

		pDfb = afpDirNotifyUsedBlockHead[index];
		while (pDfb != NULL)
		{
			PVOL_NOTIFY_BLOCK pFree;

			ASSERT(VALID_NOTIFY_BLOCK(pDfb));

			pFree = pDfb;
			pDfb = pDfb->dfb_Next;

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
					("afpFreeNotifyBlockMemory: Cleaningup Used Block %lx, Size %d\n", 
					 pFree, afpNotifyDirBlockSize[index]));
				AfpUnlinkDouble(pFree, dfb_Next, dfb_Prev);
				AfpFreeVirtualMemoryPage(pFree);
				afpNotifyBlockAllocCount--;
		}
	}

	AfpSwmrRelease(&afpNotifyBlockLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\tcputil.c ===
/*

Copyright (c) 1998  Microsoft Corporation

Module Name:

	tcputil.c

Abstract:

	This module contains utility routines that used to implement the AFP/TCP interface


Author:

	Shirish Koti


Revision History:
	22 Jan 1998		Initial Version

--*/

#define	FILENUM	FILE_TCPUTIL

#include <afp.h>
#include <scavengr.h>



/***	DsiInit
 *
 *	This routine initialization of DSI related globals
 *
 *  Returns:  nothing
 *
 */
VOID
DsiInit(
    IN VOID
)
{
    DsiTcpAdapter = NULL;

    INITIALIZE_SPIN_LOCK(&DsiAddressLock);

    INITIALIZE_SPIN_LOCK(&DsiResourceLock);

    InitializeListHead(&DsiFreeRequestList);
    InitializeListHead(&DsiIpAddrList);

    KeInitializeEvent(&DsiShutdownEvent, NotificationEvent, False);

    //
    // initialize the function table of entry points into DSI
    //
    AfpDsiEntries.asp_AtalkAddr.Address = 0;
    AfpDsiEntries.asp_AspCtxt   = NULL;
    AfpDsiEntries.asp_SetStatus = DsiAfpSetStatus;
    AfpDsiEntries.asp_CloseConn = DsiAfpCloseConn;
    AfpDsiEntries.asp_FreeConn  = DsiAfpFreeConn;
    AfpDsiEntries.asp_ListenControl = DsiAfpListenControl;
    AfpDsiEntries.asp_WriteContinue = DsiAfpWriteContinue;
    AfpDsiEntries.asp_Reply = DsiAfpReply;
    AfpDsiEntries.asp_SendAttention = DsiAfpSendAttention;

}



/***	DsiCreateAdapter
 *
 *	This routine creates an adapter object.  It's called whenever TDI tells us that
 *  a tcpip interface became available
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS FASTCALL
DsiCreateAdapter(
    IN VOID
)
{
    NTSTATUS            status;
    PTCPADPTR           pTcpAdptr;
    PTCPADPTR           pCurrTcpAdptr;
    KIRQL               OldIrql;
    HANDLE              FileHandle;
    PFILE_OBJECT        pFileObject;
    DWORD               i;


    KeClearEvent(&DsiShutdownEvent);

    pTcpAdptr = (PTCPADPTR)AfpAllocZeroedNonPagedMemory(sizeof(TCPADPTR));
    if (pTcpAdptr == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiCreateInterface: alloc for PTCPADPTR failed\n"));

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto DsiCreateAdapter_ErrExit;
    }

    pTcpAdptr->adp_Signature = DSI_ADAPTER_SIGNATURE;

    pTcpAdptr->adp_RefCount  = 1;                   // creation refcount

    pTcpAdptr->adp_State     = TCPADPTR_STATE_INIT;

    InitializeListHead(&pTcpAdptr->adp_ActiveConnHead);
    InitializeListHead(&pTcpAdptr->adp_FreeConnHead);

    INITIALIZE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock);

    pTcpAdptr->adp_FileHandle = INVALID_HANDLE_VALUE;
    pTcpAdptr->adp_pFileObject = NULL;


    //
    // ok, save this adapter as our global adapter (there can only be one
    // "adapter" active at any time.
    //

    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);

    ASSERT(DsiTcpAdapter == NULL);

    if (DsiTcpAdapter == NULL)
    {
        DsiTcpAdapter = pTcpAdptr;
        status = STATUS_SUCCESS;
        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiCreateAdapter: DsiTcpAdapter is not NULL!\n"));
        ASSERT(0);

        status = STATUS_ADDRESS_ALREADY_EXISTS;
        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);
        goto DsiCreateAdapter_ErrExit;
    }


    //
    // create TDI address for the AFP port
    //
    status = DsiOpenTdiAddress(pTcpAdptr,
                               &FileHandle,
                               &pFileObject);
    if (!NT_SUCCESS(status))
    {
	    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiCreateAdapter: ...TdiAddr.. failed %lx on %lx!\n",
            status,pTcpAdptr));

        goto DsiCreateAdapter_ErrExit;
    }


    ACQUIRE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, &OldIrql);

    pTcpAdptr->adp_FileHandle = FileHandle;
    pTcpAdptr->adp_pFileObject = pFileObject;

    // mark that we now have opened the tdi address object
    pTcpAdptr->adp_State |= TCPADPTR_STATE_BOUND;

    // we are going to create DSI_INIT_FREECONNLIST_SIZE connections to put
    // on the free list.  Idea is at any time, so many (currently 2) connections
    // should be on the free list.

    pTcpAdptr->adp_RefCount += DSI_INIT_FREECONNLIST_SIZE;

    RELEASE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, OldIrql);

    //
    // now, schedule an event to create those connections for the free list
    //
    for (i=0; i<DSI_INIT_FREECONNLIST_SIZE; i++)
    {
        DsiScheduleWorkerEvent(DsiCreateTcpConn, pTcpAdptr);
    }

    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);
    AfpServerBoundToTcp = TRUE;
    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    // start off tickle timer (monitor all connections to see who needs a tickle)
    AfpScavengerScheduleEvent(DsiSendTickles, NULL, DSI_TICKLE_TIMER, False);

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,("AFP/TCP bound and ready\n"));

    //
    // if we came this far, all went well: return success
    //
    return(STATUS_SUCCESS);


//
// Error path
//
DsiCreateAdapter_ErrExit:

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
        ("DsiCreateAdapter: couldn't create global adapter (%lx)\n",status));

    ASSERT(0);

    if (status != STATUS_ADDRESS_ALREADY_EXISTS)
    {
        ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);
        DsiTcpAdapter = NULL;
        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);
    }

    if (pTcpAdptr)
    {
        AfpFreeMemory(pTcpAdptr);
    }

    return(status);
}



/***	DsiCreateTcpConn
 *
 *	This routine creates a connection object, creates a tdi connection for it
 *  and associates it with the tdi address object for the AFP port, and finally
 *  puts it on the free connections list of the adapter in question.
 *
 *  Parm IN:  pTcpAdptr - adapter context
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS FASTCALL
DsiCreateTcpConn(
    IN PTCPADPTR    pTcpAdptr
)
{
    PTCPCONN    pTcpConn;
    NTSTATUS    status;
    KIRQL       OldIrql;


    ASSERT(pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);


    pTcpConn = (PTCPCONN)AfpAllocZeroedNonPagedMemory(sizeof(TCPCONN));
    if (pTcpConn == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiCreateTcpConn: alloc for TCPCONN failed\n"));

        // remove the CONN refcount (we put before calling this routine)
        DsiDereferenceAdapter(pTcpAdptr);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pTcpConn->con_pTcpAdptr      = pTcpAdptr;
    pTcpConn->con_Signature      = DSI_CONN_SIGNATURE;
    pTcpConn->con_State          = TCPCONN_STATE_INIT;
    pTcpConn->con_RcvState       = DSI_NEW_REQUEST;
    pTcpConn->con_DestIpAddr     = 0;
    pTcpConn->con_RefCount       = 1;
    pTcpConn->con_pDsiReq        = NULL;
    pTcpConn->con_FileHandle     = INVALID_HANDLE_VALUE;
    pTcpConn->con_pFileObject    = NULL;

    DBGREFCOUNT(("DsiCreateTcpConn: CREATION inc %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    InitializeListHead(&pTcpConn->con_PendingReqs);

    //
    // initialize the TDI stuff for this connection and open handles
    //
    status = DsiOpenTdiConnection(pTcpConn);
    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiCreateTcpConn: ..TdiConn.. failed %lx\n",status));

        // remove the CONN refcount (we put before calling this routine)
        DsiDereferenceAdapter(pTcpAdptr);
        AfpFreeMemory(pTcpConn);
        return(status);
    }


    //
    // associate this connection with the addr object
    //
    status = DsiAssociateTdiConnection(pTcpConn);
    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiCreateTcpConn: ..AssociateTdiConn.. failed %lx\n",status));

        DsiCloseTdiConnection(pTcpConn);
        AfpFreeMemory(pTcpConn);
        // remove the CONN refcount (we put before calling this routine)
        DsiDereferenceAdapter(pTcpAdptr);
        return(status);
    }

    //
    // the connection is ready to be queued to the Free list.  Make sure the
    // addr object isn't closing before putting this puppy on the list
    //
    ACQUIRE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, &OldIrql);

    if (!(pTcpAdptr->adp_State & TCPADPTR_STATE_CLOSING))
    {
        InsertTailList(&pTcpAdptr->adp_FreeConnHead,&pTcpConn->con_Linkage);
        pTcpAdptr->adp_NumFreeConnections++;
        status = STATUS_SUCCESS;
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiCreateTcpConn: Failed #2, pTcpAdptr %lx is closing\n",pTcpAdptr));

        status = STATUS_INVALID_ADDRESS;
    }

    RELEASE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, OldIrql);

    //
    // if something went wrong, undo everything
    //
    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiCreateTcpConn: something went wrong status=%lx, conn not created\n",status));

        // close the TDI handles
        DsiCloseTdiConnection(pTcpConn);

        AfpFreeMemory(pTcpConn);

        // remove the CONN refcount (we put before calling this routine)
        DsiDereferenceAdapter(pTcpAdptr);
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
            ("DsiCreateTcpConn: put new connection %lx on free list\n",pTcpConn));
    }

    return(status);
}



/***	DsiAddIpaddressToList
 *
 *	This routine saves an "active" ipaddress in our list of ipaddresses
 *
 *  Parm IN:  IpAddress - the ipaddress to save
 *
 *  Returns:  result of the operation
 *
 */
NTSTATUS
DsiAddIpaddressToList(
    IN  IPADDRESS   IpAddress
)
{
    KIRQL           OldIrql;
    PLIST_ENTRY     pList;
    PIPADDRENTITY   pIpaddrEntity;
    PIPADDRENTITY   pTmpIpaddrEntity;
    BOOLEAN         fAlreadyPresent=FALSE;


    pIpaddrEntity =
        (PIPADDRENTITY)AfpAllocZeroedNonPagedMemory(sizeof(IPADDRENTITY));
    if (pIpaddrEntity == NULL)
    {
	    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAddIpaddressToList: malloc failed! (%lx)\n",IpAddress));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pIpaddrEntity->IpAddress = IpAddress;

    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);

    pList = DsiIpAddrList.Flink;

    while (pList != &DsiIpAddrList)
    {
        pTmpIpaddrEntity = CONTAINING_RECORD(pList, IPADDRENTITY, Linkage);
        if (pTmpIpaddrEntity->IpAddress == IpAddress)
        {
            fAlreadyPresent = TRUE;
            break;
        }
        pList = pList->Flink;
    }

    if (fAlreadyPresent)
    {
	    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAddIpaddressToList: %d.%d.%d.%d already present!\n",
            (IpAddress>>24)&0xFF,(IpAddress>>16)&0xFF,(IpAddress>>8)&0xFF,IpAddress&0xFF));

        ASSERT(0);

        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);
        return(STATUS_ADDRESS_ALREADY_EXISTS);
    }

    InsertTailList(&DsiIpAddrList, &pIpaddrEntity->Linkage);

    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    return(STATUS_SUCCESS);

}


/***	DsiRemoveIpaddressFromList
 *
 *	This routine remove ipaddress from our list of ipaddresses
 *
 *  Parm IN:  IpAddress - the ipaddress to remove
 *
 *  Returns:  TRUE if we removed the ipaddress, FALSE if we didn't
 *
 */
BOOLEAN
DsiRemoveIpaddressFromList(
    IN  IPADDRESS   IpAddress
)
{
    KIRQL           OldIrql;
    PLIST_ENTRY     pList;
    PIPADDRENTITY   pIpaddrEntity;
    BOOLEAN         fFoundInList=FALSE;


    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);

    pList = DsiIpAddrList.Flink;

    while (pList != &DsiIpAddrList)
    {
        pIpaddrEntity = CONTAINING_RECORD(pList, IPADDRENTITY, Linkage);
        if (pIpaddrEntity->IpAddress == IpAddress)
        {
            fFoundInList = TRUE;
            break;
        }
        pList = pList->Flink;
    }

    if (!fFoundInList)
    {
	    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiRemoveIpaddressFromList: %d.%d.%d.%d not in the list!\n",
            (IpAddress>>24)&0xFF,(IpAddress>>16)&0xFF,(IpAddress>>8)&0xFF,IpAddress&0xFF));

        ASSERT(0);

        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);
        return(FALSE);
    }

    RemoveEntryList(&pIpaddrEntity->Linkage);

    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    AfpFreeMemory(pIpaddrEntity);

    return(TRUE);
}



/***	DsiGetRequest
 *
 *	This routine allocates a DSI Request structure and returns.  For performance
 *  reasons, we don't alloc new memory each time, but save a list of these
 *
 *  Parm IN:  nothin'
 *
 *  Returns:  pointer to a DSIREQ strucutre (NULL on failure)
 *
 */
PDSIREQ
DsiGetRequest(
    IN VOID
)
{
    PDSIREQ         pDsiReq=NULL;
    PLIST_ENTRY     pList;
    KIRQL           OldIrql;


    ACQUIRE_SPIN_LOCK(&DsiResourceLock, &OldIrql);

    if (!IsListEmpty(&DsiFreeRequestList))
    {
        pList = RemoveHeadList(&DsiFreeRequestList);
        pDsiReq = CONTAINING_RECORD(pList, DSIREQ, dsi_Linkage);

        ASSERT(DsiFreeRequestListSize > 0);
        DsiFreeRequestListSize--;

        RtlZeroMemory(pDsiReq, sizeof(DSIREQ));
    }

    RELEASE_SPIN_LOCK(&DsiResourceLock, OldIrql);

    if (pDsiReq == NULL)
    {
        pDsiReq = (PDSIREQ)AfpAllocZeroedNonPagedMemory(sizeof(DSIREQ));
    }

    if (pDsiReq != NULL)
    {
        pDsiReq->dsi_Signature = DSI_REQUEST_SIGNATURE;

        InitializeListHead(&pDsiReq->dsi_Linkage);
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiGetRequest: malloc failed!\n"));
    }

    return(pDsiReq);
}



/***	DsiGetReqBuffer
 *
 *	This routine allocates a buffer to hold either a header or a command
 *  The likelihood of this function getting called is pretty slim (basically
 *  if a packet is fragmented by TCP).  So we simply make a call to alloc
 *
 *  Parm IN:  BufLen - length of the buffer requested
 *
 *  Returns:  pointer to a buffer (NULL on failure)
 *
 */
PBYTE
DsiGetReqBuffer(
    IN DWORD    BufLen
)
{
    PBYTE       pBuffer=NULL;

    pBuffer = AfpAllocNonPagedMemory(BufLen);

#if DBG
    if (pBuffer == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
        ("DsiGetReqBuffer: malloc failed!\n"));
    }
#endif

    return(pBuffer);
}


/***	DsiFreeRequest
 *
 *	This routine frees up a previously allocated DSI Request structure.  Again,
 *  for performance reasons, we don't free up the memory but put this in a list
 *
 *  Parm IN:  pDsiReq - the request to be freed
 *
 *  Returns:  nothing
 *
 */
VOID
DsiFreeRequest(
    PDSIREQ     pDsiReq
)
{

    KIRQL           OldIrql;
    BOOLEAN         fQueueTooBig = TRUE;


    if ((pDsiReq->dsi_PartialBuf != NULL) &&
        (pDsiReq->dsi_PartialBuf != &pDsiReq->dsi_RespHeader[0]))
    {
        ASSERT(pDsiReq->dsi_PartialBufSize > 0);
        DsiFreeReqBuffer(pDsiReq->dsi_PartialBuf);

        pDsiReq->dsi_PartialBuf = NULL;
        pDsiReq->dsi_PartialBufSize = 0;
    }

    // if there was an Mdl we got via cache mgr, it had better be returned to system
    ASSERT(pDsiReq->dsi_AfpRequest.rq_CacheMgrContext == NULL);

    //
    // if we came here via abnormal disconnect, this could be non-null
    //
    if (pDsiReq->dsi_pDsiAllocedMdl)
    {
        AfpFreeMdl(pDsiReq->dsi_pDsiAllocedMdl);
    }

#if DBG
    RtlFillMemory(pDsiReq, sizeof(DSIREQ), 'f');
#endif

    ACQUIRE_SPIN_LOCK(&DsiResourceLock, &OldIrql);

    if (DsiFreeRequestListSize < DsiNumTcpConnections)
    {
        InsertTailList(&DsiFreeRequestList, &pDsiReq->dsi_Linkage);
        DsiFreeRequestListSize++;
        fQueueTooBig = FALSE;
    }

    RELEASE_SPIN_LOCK(&DsiResourceLock, OldIrql);

    if (fQueueTooBig)
    {
        AfpFreeMemory(pDsiReq);
    }


    return;
}


/***	DsiFreeReqBuffer
 *
 *	This routine allocates a buffer to hold either a header or a command
 *  The likelihood of this function getting called is pretty slim (basically
 *  if a packet is fragmented by TCP).  So we simply make a call to alloc
 *
 *  Parm IN:  BufLen - length of the buffer requested
 *
 *  Returns:  pointer to a buffer (NULL on failure)
 *
 */
VOID
DsiFreeReqBuffer(
    IN PBYTE    pBuffer
)
{
    ASSERT(pBuffer != NULL);

    AfpFreeMemory(pBuffer);

    return;
}


/***	DsiDereferenceAdapter
 *
 *	This routine dereferences the adapter object.  When refcount goes to 0, it
 *  removes it from the global list of adapters.  If at task time, it calls a
 *  routine to close tcp handles and free the memory.  If at dpc, it schedules
 *  an event to do the same.
 *
 *  Parm IN:  pTcpAdptr - adapter context
 *
 *  Returns:  nothin'
 *
 */
VOID
DsiDereferenceAdapter(
    IN PTCPADPTR    pTcpAdptr
)
{
    KIRQL       OldIrql;
    BOOLEAN     fDone=FALSE;


    ASSERT(pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);

    ACQUIRE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, &OldIrql);

    pTcpAdptr->adp_RefCount--;

    if (pTcpAdptr->adp_RefCount == 0)
    {
        fDone = TRUE;
        ASSERT(pTcpAdptr->adp_State & TCPADPTR_STATE_CLOSING);
    }

    RELEASE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, OldIrql);

    if (!fDone)
    {
        return;
    }

    //
    // this dude's life is over: do the needful to bid goodbye
    //

    // if we are at DPC, we need to do all the cleanup (file handle closing etc.)
    // at task time: queue an event
    if (KeGetCurrentIrql() == DISPATCH_LEVEL)
    {
        // queue an event, since we are at dpc
        DsiScheduleWorkerEvent(DsiFreeAdapter, pTcpAdptr);
    }
    else
    {
        DsiFreeAdapter(pTcpAdptr);
    }

    return;
}



/***	DsiDereferenceConnection
 *
 *	This routine dereferences the connection object.  When refcount goes to 0, it
 *  removes it from the list of connections.  If at task time, it calls a
 *  routine to close tcp handles and free the memory.  If at dpc, it schedules
 *  an event to do the same.
 *
 *  Parm IN:  pTcpConn - connection context
 *
 *  Returns:  nothin'
 *
 */
VOID
DsiDereferenceConnection(
    IN PTCPCONN     pTcpConn
)
{
    KIRQL       OldIrql;
    BOOLEAN     fDone=FALSE;


    ASSERT(VALID_TCPCONN(pTcpConn));

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    pTcpConn->con_RefCount--;

    if (pTcpConn->con_RefCount == 0)
    {
        fDone = TRUE;
        ASSERT(pTcpConn->con_State & TCPCONN_STATE_CLOSING);
    }

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    if (!fDone)
    {
        return;
    }

    //
    // this dude's life is over: do the needful to bid goodbye
    //

#if 0
    // if we are at DPC, we need to do all the cleanup (file handle closing etc.)
    // at task time: queue an event
    if (KeGetCurrentIrql() == DISPATCH_LEVEL)
    {
        // queue an event, since we are at dpc
        DsiScheduleWorkerEvent(DsiFreeConnection, pTcpConn);
    }
    else
    {
        DsiFreeConnection(pTcpConn);
    }
#endif

    // schedule a worker event to free this connection
    DsiScheduleWorkerEvent(DsiFreeConnection, pTcpConn);

    return;
}


/***	DsiDestroyAdapter
 *
 *	This routine destroys the global adapter object.
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiDestroyAdapter(
    IN VOID
)
{
    KIRQL               OldIrql;
    PLIST_ENTRY         pFreeList;
    PLIST_ENTRY         pActiveList;
    PTCPCONN            pTcpConn;
    BOOLEAN             fAlreadyCleanedUp=FALSE;


    if (DsiTcpAdapter == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiDestroyAdapter: adapter gone!  How did this happen!!\n"));

        // unblock the event!
        KeSetEvent(&DsiShutdownEvent, IO_NETWORK_INCREMENT, False);
        return(STATUS_SUCCESS);
    }

    // stop the tickle timer
    if (!AfpScavengerKillEvent(DsiSendTickles, NULL))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiDestroyAdapter: TickleTimer not running or hit timing window!!\n"));
    }

    ACQUIRE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, &OldIrql);

    if (DsiTcpAdapter->adp_State & TCPADPTR_STATE_CLEANED_UP)
    {
        fAlreadyCleanedUp = TRUE;
    }

    DsiTcpAdapter->adp_State |= TCPADPTR_STATE_CLOSING;
    DsiTcpAdapter->adp_State |= TCPADPTR_STATE_CLEANED_UP;

    if (fAlreadyCleanedUp)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiDestroyAdapter: already destroyed!\n"));

        ASSERT(IsListEmpty(&DsiTcpAdapter->adp_FreeConnHead));
        ASSERT(IsListEmpty(&DsiTcpAdapter->adp_ActiveConnHead));
        ASSERT(DsiTcpAdapter->adp_NumFreeConnections == 0);

        RELEASE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, OldIrql);
        return(STATUS_SUCCESS);
    }

    //
    // free up all the connections from the Free list
    //
    while (!IsListEmpty(&DsiTcpAdapter->adp_FreeConnHead))
    {
        pFreeList = DsiTcpAdapter->adp_FreeConnHead.Flink;

        pTcpConn = CONTAINING_RECORD(pFreeList, TCPCONN, con_Linkage);

        RemoveEntryList(&pTcpConn->con_Linkage);

        ASSERT(DsiTcpAdapter->adp_NumFreeConnections > 0);

        DsiTcpAdapter->adp_NumFreeConnections--;

        InitializeListHead(&pTcpConn->con_Linkage);

        RELEASE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, OldIrql);

        pTcpConn->con_State |= TCPCONN_STATE_CLOSING;
        DsiDereferenceConnection(pTcpConn);

        DBGREFCOUNT(("DsiDestroyAdapter: Creation dec %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

        ACQUIRE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, &OldIrql);
    }

    //
    // kill all the connections from the Active list
    //
    pActiveList = DsiTcpAdapter->adp_ActiveConnHead.Flink;

    while (pActiveList != &DsiTcpAdapter->adp_ActiveConnHead)
    {
        pTcpConn = CONTAINING_RECORD(pActiveList, TCPCONN, con_Linkage);

        pActiveList = pActiveList->Flink;

        ACQUIRE_SPIN_LOCK_AT_DPC(&pTcpConn->con_SpinLock);

        // if this connection is already closing, skip it
        if (pTcpConn->con_State & TCPCONN_STATE_CLOSING)
        {
            RELEASE_SPIN_LOCK_FROM_DPC(&pTcpConn->con_SpinLock);
            continue;
        }

        // put ABORT refcount for now
        pTcpConn->con_RefCount++;

        DBGREFCOUNT(("DsiDestroyAdapter: ABORT inc %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

        RemoveEntryList(&pTcpConn->con_Linkage);
        InitializeListHead(&pTcpConn->con_Linkage);

        RELEASE_SPIN_LOCK_FROM_DPC(&pTcpConn->con_SpinLock);

        RELEASE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, OldIrql);

        DsiAbortConnection(pTcpConn);

        // remove that ABORT refcount
        DsiDereferenceConnection(pTcpConn);

        DBGREFCOUNT(("DsiDestroyAdapter: ABORT dec %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

        ACQUIRE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, &OldIrql);

        // since we released the lock, things could have changed: start over
        pActiveList = DsiTcpAdapter->adp_ActiveConnHead.Flink;
    }

    RELEASE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, OldIrql);

    // remove the creation refcount
    DsiDereferenceAdapter(DsiTcpAdapter);

    return(STATUS_SUCCESS);

}


/***	DsiKillConnection
 *
 *	This routine kills an active connection.
 *
 *  Parm IN:  pTcpConn - the connection to kill
 *
 *  Returns:  TRUE if we killed it, FALSE if we couldn't
 *
 */
BOOLEAN
DsiKillConnection(
    IN PTCPCONN     pTcpConn,
    IN DWORD        DiscFlag
)
{
    KIRQL           OldIrql;
    NTSTATUS        status;
    PDSIREQ         pPartialDsiReq=NULL;
    BOOLEAN         fFirstVisit=TRUE;



    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    if (pTcpConn->con_State & TCPCONN_STATE_CLEANED_UP)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
            ("DsiKillConnection: connection %lx already cleaned up\n",pTcpConn));

        fFirstVisit = FALSE;
    }

    pTcpConn->con_State &= ~TCPCONN_STATE_CONNECTED;
    pTcpConn->con_State |= (TCPCONN_STATE_CLOSING | TCPCONN_STATE_CLEANED_UP);

    //
    // if a request is waiting for an mdl to become available, don't touch it here.
    // When afp returns with mdl (or null mdl), we'll clean up this request
    //
    if (pTcpConn->con_RcvState != DSI_AWAITING_WRITE_MDL)
    {
        pPartialDsiReq = pTcpConn->con_pDsiReq;
        pTcpConn->con_pDsiReq = NULL;
    }

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    if (pPartialDsiReq)
    {
        // if we had allocated an mdl, let afp know so afp can free it
        if ((pPartialDsiReq->dsi_Command == DSI_COMMAND_WRITE) &&
            (pPartialDsiReq->dsi_AfpRequest.rq_WriteMdl != NULL))
        {
            AfpCB_RequestNotify(STATUS_REMOTE_DISCONNECT,
                                pTcpConn->con_pSda,
                                &pPartialDsiReq->dsi_AfpRequest);
        }

        DsiFreeRequest(pPartialDsiReq);

        // remove the REQUEST refcount
        DsiDereferenceConnection(pTcpConn);

        DBGREFCOUNT(("DsiKillConnection: REQUEST dec %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
    }

    status = (DiscFlag == TDI_DISCONNECT_ABORT)?
                STATUS_LOCAL_DISCONNECT: STATUS_REMOTE_DISCONNECT;

    // give AFP the bad news
    DsiDisconnectWithAfp(pTcpConn, status);

    // give TCP the bad news
    DsiDisconnectWithTcp(pTcpConn, DiscFlag);

    // remove the Creation refcount if this is the first time we're visiting
    // this routine
    if (fFirstVisit)
    {
        DsiDereferenceConnection(pTcpConn);

        DBGREFCOUNT(("DsiKillConnection: Creation dec %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
    }

    return(TRUE);
}



/***	DsiFreeAdapter
 *
 *	This routine frees the adapter object after closing the tcp handles
 *
 *  Parm IN:  pTcpAdptr - adapter object
 *
 *  Returns:  result of the operation
 *
 */
NTSTATUS FASTCALL
DsiFreeAdapter(
    IN PTCPADPTR    pTcpAdptr
)
{

    BOOLEAN         fRecreateAdapter=FALSE;
    KIRQL           OldIrql;


    ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

    ASSERT(pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);
    ASSERT(pTcpAdptr->adp_State & TCPADPTR_STATE_CLOSING);
    ASSERT(pTcpAdptr->adp_RefCount == 0);

    // close file handles
    DsiCloseTdiAddress(pTcpAdptr);

    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);

    DsiTcpAdapter = NULL;
    AfpServerBoundToTcp = FALSE;

    //
    // it's possible that by the time we did all the cleanup and everything,
    // an ipaddress(es) became available.  If that has happened, go ahead and
    // create the global adapter again!
    //
    if (!IsListEmpty(&DsiIpAddrList))
    {
        fRecreateAdapter = TRUE;
    }

    // if we are shutting down, don't create the adapter again!
    if ((AfpServerState == AFP_STATE_STOP_PENDING) ||
        (AfpServerState == AFP_STATE_SHUTTINGDOWN) ||
        (AfpServerState == AFP_STATE_STOPPED))
    {
        fRecreateAdapter = FALSE;
    }

    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    ASSERT(pTcpAdptr->adp_pFileObject == NULL);
    ASSERT(pTcpAdptr->adp_FileHandle == INVALID_HANDLE_VALUE);

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
        ("DsiFreeAdapter: freeing adapter %lx\n",pTcpAdptr));

    AfpFreeMemory(pTcpAdptr);

    // wake up that blocked thread!
    KeSetEvent(&DsiShutdownEvent, IO_NETWORK_INCREMENT, False);

    if (fRecreateAdapter)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiFreeAdapter: ipaddress came in, so recreating global adapter\n"));

        DsiCreateAdapter();
    }

    return(STATUS_SUCCESS);
}



/***	DsiFreeConnection
 *
 *	This routine frees the connection object after closing the tcp handles
 *
 *  Parm IN:  pTcpConn - connection object
 *
 *  Returns:  result of the operation
 *
 */
NTSTATUS FASTCALL
DsiFreeConnection(
    IN PTCPCONN     pTcpConn
)
{

    KIRQL       OldIrql;
    PTCPADPTR   pTcpAdptr;
    IPADDRESS   IpAddress;


    ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

    ASSERT(pTcpConn->con_Signature == DSI_CONN_SIGNATURE);
    ASSERT(pTcpConn->con_State & TCPCONN_STATE_CLOSING);
    ASSERT(pTcpConn->con_RefCount == 0);

    pTcpAdptr = pTcpConn->con_pTcpAdptr;

    ASSERT(pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);

    // close file handles
    DsiCloseTdiConnection(pTcpConn);

    // remove this puppy from the list
    ACQUIRE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, &OldIrql);
    RemoveEntryList(&pTcpConn->con_Linkage);
    RELEASE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, OldIrql);

    // remove the CONN refcount for this connection
    DsiDereferenceAdapter(pTcpConn->con_pTcpAdptr);

    ASSERT(pTcpConn->con_pFileObject == NULL);
    ASSERT(pTcpConn->con_FileHandle == INVALID_HANDLE_VALUE);

#if DBG
    IpAddress = pTcpConn->con_DestIpAddr;

    if (IpAddress)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
            ("DsiFreeConnection: freeing connection on %d.%d.%d.%d (%lx)\n",
            (IpAddress>>24)&0xFF,(IpAddress>>16)&0xFF,(IpAddress>>8)&0xFF,
            IpAddress&0xFF,pTcpConn));
    }

    pTcpConn->con_Signature = 0xDEADBEEF;
#endif

    AfpFreeMemory(pTcpConn);

    return(STATUS_SUCCESS);
}


/***	DsiGetIpAddrBlob
 *
 *	This routine generates a 'blob' that gets plugged into the ServerInfo buffer.
 *  Here we walk the ipaddr list and generate a blob with all the available
 *  ipaddresses (6-byte-per-ipaddress_
 *
 *  Parm OUT: pIpAddrCount - how many ipaddresses there are in the system
 *            ppIpAddrBlob - pointer to a pointer to a buffer
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiGetIpAddrBlob(
    OUT DWORD    *pIpAddrCount,
    OUT PBYTE    *ppIpAddrBlob
)
{
    KIRQL               OldIrql;
    PLIST_ENTRY         pList;
    DWORD               AddrCount=0;
    DWORD               TmpCount=0;
    PBYTE               AddrBlob;
    PBYTE               pCurrentBlob;
    PIPADDRENTITY       pIpaddrEntity;


    *pIpAddrCount = 0;
    *ppIpAddrBlob = NULL;

    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);

    if (!DsiTcpEnabled)
    {
        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiGetIpAddrBlob: Server is disabled\n"));

        return(STATUS_SUCCESS);
    }


    //
    // find out how many ipaddresses are there on the list
    //
    AddrCount = 0;
    pList = DsiIpAddrList.Flink;
    while (pList != &DsiIpAddrList)
    {
        AddrCount++;
        pList = pList->Flink;
    }

    if (AddrCount == 0)
    {
        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiGetIpAddrBlob: calling AfpSetServerStatus with 0 addrs\n"));

        return(STATUS_SUCCESS);
    }

    if (AddrCount > DSI_MAX_IPADDR_COUNT)
    {
        AddrCount = DSI_MAX_IPADDR_COUNT;
    }

    AddrBlob = AfpAllocZeroedNonPagedMemory(AddrCount * DSI_NETWORK_ADDR_LEN);

    if (AddrBlob == NULL)
    {
        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

	    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiGetIpAddrBlob: malloc failed\n"));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // create a "blob" that AfpSetServerStatus can directly copy
    //
    TmpCount = 0;
    pCurrentBlob = AddrBlob;

    pList = DsiIpAddrList.Flink;
    while (pList != &DsiIpAddrList)
    {
        pIpaddrEntity = CONTAINING_RECORD(pList, IPADDRENTITY, Linkage);

        pCurrentBlob[0] = DSI_NETWORK_ADDR_LEN;
        pCurrentBlob[1] = DSI_NETWORK_ADDR_IPTAG;
        PUTDWORD2DWORD(&pCurrentBlob[2], pIpaddrEntity->IpAddress);

        pCurrentBlob += DSI_NETWORK_ADDR_LEN;

        pList = pList->Flink;

        TmpCount++;
        if (TmpCount == AddrCount)
        {
            break;
        }
    }

    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    *pIpAddrCount = AddrCount;
    *ppIpAddrBlob = AddrBlob;

    return(STATUS_SUCCESS);
}



/***	DsiGetIrpForTcp
 *
 *	This routine is called when we need to pass an irp back to TCP to get the
 *  remainint data (when it has more data than it has indicated to us).
 *  Here we allocate an mdl if there isn't one already, and allocate and
 *  initialize an irp ready to be sent to TCP
 *
 *  Parm IN:  pTcpConn - the connection object
 *            pBuffer - buffer that TCP will copy data in
 *            pInputMdl - if non-null, then we don't allocate a new mdl
 *            ReadSize - how many bytes do we need
 *
 *  Returns:  pIrp if successful, NULL otherwise
 *
 *  NOTE: pTcpConn spinlock is held on entry
 *
 */
PIRP
DsiGetIrpForTcp(
    IN  PTCPCONN    pTcpConn,
    IN  PBYTE       pBuffer,
    IN  PMDL        pInputMdl,
    IN  DWORD       ReadSize
)
{
    PDEVICE_OBJECT                  pDeviceObject;
    PIRP                            pIrp=NULL;
    PTDI_REQUEST_KERNEL_RECEIVE     pRequest;
    PMDL                            pMdl;

    pDeviceObject = IoGetRelatedDeviceObject(pTcpConn->con_pFileObject);

    pIrp = AfpAllocIrp(pDeviceObject->StackSize);
    if (pIrp == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiGetIrpForTcp: alloc irp failed!\n"));

        return(NULL);
    }

    if (pInputMdl)
    {
        pMdl = pInputMdl;
    }
    else
    {
        pMdl = AfpAllocMdl(pBuffer, ReadSize, NULL);

        if (pMdl == NULL)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiGetIrpForTcp: alloc mdl failed!\n"));

            AfpFreeIrp(pIrp);
            return(NULL);
        }
    }

    pTcpConn->con_pRcvIrp = pIrp;

    pTcpConn->con_State |= TCPCONN_STATE_TCP_HAS_IRP;

    // put TcpIRP refcount, removed when the irp completes
    pTcpConn->con_RefCount++;

    DBGREFCOUNT(("DsiGetIrpForTcp: TcpIRP inc %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    TdiBuildReceive(pIrp,
                    pDeviceObject,
                    pTcpConn->con_pFileObject,
                    DsiTcpRcvIrpCompletion,
                    (PVOID)pTcpConn,
                    pMdl,
                    TDI_RECEIVE_NORMAL,
                    ReadSize);

    //
    // this irp will be returned to TCP, so do what IoSubSystem
    // would have done if we had called IoCallDriver
    //
    IoSetNextIrpStackLocation(pIrp);

    return(pIrp);
}



/***	DsiMakePartialMdl
 *
 *	This routine is called when we need to reissue an Mdl (via irp) back to TCP
 *  because TCP prematurely completed the previous irp (i.e. all the requested
 *  bytes haven't come in yet, but say Push bit was set or something).  In such
 *  a case, we need to give a new mdl which accounts for the bytes we have got
 *  so far (i.e. the offset has changed)
 *
 *  Parm IN:  pOrgMdl - the original Mdl we gave to TCp
 *            dwOffset - what offset we want the new partial Mdl to describe
 *
 *  Returns:  the new partial Mdl if successful, NULL otherwise
 *
 */
PMDL
DsiMakePartialMdl(
    IN  PMDL        pOrgMdl,
    IN  DWORD       dwOffset
)
{
    PMDL    pSubMdl;
    PMDL    pPartialMdl=NULL;
    DWORD   dwNewMdlLen;
    PVOID   vAddr;


    ASSERT(pOrgMdl != NULL);
    ASSERT(dwOffset > 0);

    ASSERT(dwOffset < AfpMdlChainSize(pOrgMdl));

    pSubMdl = pOrgMdl;

    //
    // get to the Mdl that is going to have this offset
    //
    while (dwOffset >= MmGetMdlByteCount(pSubMdl))
    {
        dwOffset -= MmGetMdlByteCount(pSubMdl);
        pSubMdl = pSubMdl->Next;

        ASSERT(pSubMdl != NULL);
    }

    ASSERT(MmGetMdlByteCount(pSubMdl) > dwOffset);

    vAddr = (PVOID)((PUCHAR)MmGetMdlVirtualAddress( pSubMdl ) + dwOffset);

    dwNewMdlLen = MmGetMdlByteCount(pSubMdl) - dwOffset;

    pPartialMdl = IoAllocateMdl(vAddr, dwNewMdlLen, FALSE, FALSE, NULL);

    if (pPartialMdl == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiMakePartialMdl: IoAllocateMdl failed\n"));
        return(NULL);
    }

    AFP_DBG_INC_COUNT(AfpDbgMdlsAlloced);

    IoBuildPartialMdl(pSubMdl, pPartialMdl, vAddr, dwNewMdlLen);

    // if there are further Mdl's down the original, link them on
    pPartialMdl->Next = pSubMdl->Next;

    return(pPartialMdl);

}



/***	DsiUpdateAfpStatus
 *
 *	This routine is just a wrapper function so that we can schedule an event to
 *  call the real function AfpSetServerStatus
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS FASTCALL
DsiUpdateAfpStatus(
    IN PVOID    Unused
)
{
    NTSTATUS            status;


    status = AfpSetServerStatus();

    return(status);
}



/***	DsiScheduleWorkerEvent
 *
 *	This routine schedules an event for a later time.  This routine is called
 *  typically when we are at dpc but something (e.g. file handle operations)
 *  needs to be done at passive level.  This routine puts the request on the
 *  worker queue.
 *
 *  Parm IN:  WorkerRoutine - the routine to be exececuted by the worker thread
 *            Context - parameter for that routine
 *
 *  Returns:  result of the operation
 *
 */
NTSTATUS
DsiScheduleWorkerEvent(
    IN  DSI_WORKER      WorkerRoutine,
    IN  PVOID           Context
)
{
    PTCPWORKITEM    pTWItem;

    pTWItem = (PTCPWORKITEM)AfpAllocZeroedNonPagedMemory(sizeof(TCPWORKITEM));
    if (pTWItem == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiScheduleWorkerEvent: alloc failed!\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AfpInitializeWorkItem(&pTWItem->tcp_WorkItem, DsiWorker, pTWItem);

    pTWItem->tcp_Worker = WorkerRoutine;
    pTWItem->tcp_Context = Context;

    AfpQueueWorkItem(&pTWItem->tcp_WorkItem);

    return(STATUS_SUCCESS);
}



/***	DsiScheduleWorkerEvent
 *
 *	This routine gets called by the worker thread when DsiScheduleWorkerEvent
 *  schedules an event.  This routine then calls the actual routine that was
 *  scheduled for later time.
 *
 *  Parm IN:  Context - the work item
 *
 *  Returns:  result of the operation
 *
 */
VOID FASTCALL
DsiWorker(
    IN PVOID    Context
)
{
    PTCPWORKITEM    pTWItem;
    NTSTATUS        status;

    pTWItem = (PTCPWORKITEM)Context;


    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    (*pTWItem->tcp_Worker)(pTWItem->tcp_Context);

    AfpFreeMemory(pTWItem);
}




/***	DsiShutdown
 *
 *	This routine is called when sfm is shutting down.  We basically make sure
 *  that all the resources are freed up, file handles closed etc.
 *
 *  Returns:  Nothing
 *
 */
VOID
DsiShutdown(
    IN VOID
)
{
    KIRQL           OldIrql;
    PLIST_ENTRY     pList;
    PIPADDRENTITY   pIpaddrEntity;
    PDSIREQ         pDsiReq=NULL;



    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);

    while (!IsListEmpty(&DsiIpAddrList))
    {
        pList = RemoveHeadList(&DsiIpAddrList);

        pIpaddrEntity = CONTAINING_RECORD(pList, IPADDRENTITY, Linkage);

        AfpFreeMemory(pIpaddrEntity);
    }

    if (DsiStatusBuffer != NULL)
    {
        AfpFreeMemory(DsiStatusBuffer);
        DsiStatusBuffer = NULL;
    }

    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    // kill the global adapter if it's around
    if (DsiTcpAdapter)
    {
        KeClearEvent(&DsiShutdownEvent);

        DsiDestroyAdapter();

        // if the "adapter" is still hanging around, wait till it's gone
        if (DsiTcpAdapter)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiShutdown: waiting for the TCP interface to go away...\n"));

            AfpIoWait(&DsiShutdownEvent, NULL);

            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiShutdown: ... and the wait is over!\n"));
        }
    }

    ACQUIRE_SPIN_LOCK(&DsiResourceLock, &OldIrql);

    while (!IsListEmpty(&DsiFreeRequestList))
    {
        pList = RemoveHeadList(&DsiFreeRequestList);
        pDsiReq = CONTAINING_RECORD(pList, DSIREQ, dsi_Linkage);

        AfpFreeMemory(pDsiReq);
        DsiFreeRequestListSize--;
    }

    RELEASE_SPIN_LOCK(&DsiResourceLock, OldIrql);

    ASSERT(DsiFreeRequestListSize == 0);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\tcptdi.c ===
/*

Copyright (c) 1998  Microsoft Corporation

Module Name:

	tcptdi.c

Abstract:

	This module contains the interfaces to the TCP/IP stack via TDI


Author:

	Shirish Koti


Revision History:
	22 Jan 1998		Initial Version

--*/

#define	FILENUM	FILE_TCPTDI

#include <afp.h>



/***	DsiOpenTdiAddress
 *
 *	This routine creates a TDI address for the AFP port on the given adapter
 *
 *  Parm IN:  pTcpAdptr - adapter object
 *
 *  Parm OUT: pRetFileHandle - file handle to the address object
 *            ppRetFileObj - pointer to file object pointer
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiOpenTdiAddress(
    IN  PTCPADPTR       pTcpAdptr,
    OUT PHANDLE         pRetFileHandle,
    OUT PFILE_OBJECT   *ppRetFileObj
)
{

    OBJECT_ATTRIBUTES           AddressAttributes;
    IO_STATUS_BLOCK             IoStatusBlock;
    PFILE_FULL_EA_INFORMATION   EaBuffer;
    NTSTATUS                    status;
    UNICODE_STRING              ucDeviceName;
    PTRANSPORT_ADDRESS          pTransAddressEa;
    PTRANSPORT_ADDRESS          pTransAddr;
    TDI_ADDRESS_IP              TdiIpAddr;
    HANDLE                      FileHandle;
    PFILE_OBJECT                pFileObject;
    PDEVICE_OBJECT              pDeviceObject;
    PEPROCESS                   CurrentProcess;
    BOOLEAN                     fAttachAttempted;


    ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

    ASSERT(pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);

    *pRetFileHandle = INVALID_HANDLE_VALUE;

    // copy device name into the unicode string

    ucDeviceName.MaximumLength = (wcslen(AFP_TCP_BINDNAME) + 1)*sizeof(WCHAR);
    ucDeviceName.Length = 0;
    ucDeviceName.Buffer = (PWSTR)AfpAllocZeroedNonPagedMemory(
                                    ucDeviceName.MaximumLength);

    if (ucDeviceName.Buffer == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiOpenTdiAddress: malloc for ucDeviceName Failed\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = RtlAppendUnicodeToString(&ucDeviceName, AFP_TCP_BINDNAME);
    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiOpenTdiAddress: RtlAppend... failed %lx\n",status));

        AfpFreeMemory(ucDeviceName.Buffer);
        return(status);
    }

    EaBuffer = (PFILE_FULL_EA_INFORMATION)AfpAllocZeroedNonPagedMemory(
                    sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                    TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                    sizeof(TRANSPORT_ADDRESS) +
                    sizeof(TDI_ADDRESS_IP));

    if (EaBuffer == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiOpenTdiAddress: malloc for Eabuffer failed!\n"));

        AfpFreeMemory(ucDeviceName.Buffer);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    EaBuffer->NextEntryOffset = 0;
    EaBuffer->Flags = 0;
    EaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;

    EaBuffer->EaValueLength = sizeof(TRANSPORT_ADDRESS) -1
                                + sizeof(TDI_ADDRESS_IP);

    // put "TransportAddress" into the name
    RtlMoveMemory(EaBuffer->EaName,
                  TdiTransportAddress,
                  EaBuffer->EaNameLength + 1);

    // fill in the IP address and Port number
    //
    pTransAddressEa = (TRANSPORT_ADDRESS *)&EaBuffer->EaName[EaBuffer->EaNameLength+1];

    // allocate Memory for the transport address
    //
    pTransAddr = (PTRANSPORT_ADDRESS)AfpAllocZeroedNonPagedMemory(
                    sizeof(TDI_ADDRESS_IP)+sizeof(TRANSPORT_ADDRESS));

    if (pTransAddr == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiOpenTdiAddress: malloc for pTransAddr failed!\n"));

        AfpFreeMemory(ucDeviceName.Buffer);
        AfpFreeMemory(EaBuffer);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pTransAddr->TAAddressCount = 1;
    pTransAddr->Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
    pTransAddr->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;

    TdiIpAddr.sin_port = htons(AFP_TCP_PORT);    // put in network order
    TdiIpAddr.in_addr  = 0;                      // inaddr_any


    // zero fill the  last component of the IP address
    //
    RtlFillMemory((PVOID)&TdiIpAddr.sin_zero,
                  sizeof(TdiIpAddr.sin_zero),
                  0);

    // copy the ip address to the end of the structure
    //
    RtlMoveMemory(pTransAddr->Address[0].Address,
                  (CONST PVOID)&TdiIpAddr,
                  sizeof(TdiIpAddr));

    // copy the ip address to the end of the name in the EA structure
    //
    RtlMoveMemory((PVOID)pTransAddressEa,
                  (CONST PVOID)pTransAddr,
                  sizeof(TDI_ADDRESS_IP) + sizeof(TRANSPORT_ADDRESS)-1);


    InitializeObjectAttributes(
        &AddressAttributes,
        &ucDeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);


    CurrentProcess = IoGetCurrentProcess();
    AFPAttachProcess(CurrentProcess);
    fAttachAttempted = TRUE;

    status = ZwCreateFile(
                    &FileHandle,
                    GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                    &AddressAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    0,
                    (PVOID)EaBuffer,
                    sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                        EaBuffer->EaNameLength + 1 +
                        EaBuffer->EaValueLength);

    // don't need these no more..
    AfpFreeMemory((PVOID)pTransAddr);
    AfpFreeMemory((PVOID)EaBuffer);
    AfpFreeMemory(ucDeviceName.Buffer);


    if (NT_SUCCESS(status))
    {
        // if the ZwCreate passed set the status to the IoStatus
        status = IoStatusBlock.Status;

        if (!NT_SUCCESS(status))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiOpenTdiAddress: ZwCreateFile failed, iostatus=%lx\n",status));

            AFPDetachProcess(CurrentProcess);
            return(status);
        }

        // dereference the file object to keep the device ptr around to avoid
        // this dereference at run time
        //
        status = ObReferenceObjectByHandle(
                        FileHandle,
                        (ULONG)0,
                        0,
                        KernelMode,
                        (PVOID *)&pFileObject,
                        NULL);

        if (NT_SUCCESS(status))
        {
            AFPDetachProcess(CurrentProcess);
            fAttachAttempted = FALSE;

	        pDeviceObject = IoGetRelatedDeviceObject(pFileObject);

            status = DsiSetEventHandler(
                            pDeviceObject,
                            pFileObject,
                            TDI_EVENT_ERROR,
                            (PVOID)DsiTdiErrorHandler,
                            (PVOID)pTcpAdptr);

            if (NT_SUCCESS(status))
            {
                status = DsiSetEventHandler(
                                pDeviceObject,
                                pFileObject,
                                TDI_EVENT_RECEIVE,
                                (PVOID)DsiTdiReceiveHandler,
                                (PVOID)pTcpAdptr);

                if (NT_SUCCESS(status))
                {
                    status = DsiSetEventHandler(
                                    pDeviceObject,
                                    pFileObject,
                                    TDI_EVENT_DISCONNECT,
                                    (PVOID)DsiTdiDisconnectHandler,
                                    (PVOID)pTcpAdptr);

                    if (NT_SUCCESS(status))
                    {
                        status = DsiSetEventHandler(
                                        pDeviceObject,
                                        pFileObject,
                                        TDI_EVENT_CONNECT,
                                        (PVOID)DsiTdiConnectHandler,
                                        (PVOID)pTcpAdptr);

                        if (NT_SUCCESS(status))
                        {
                            // all worked well: done here

                            *pRetFileHandle = FileHandle;
                            *ppRetFileObj = pFileObject;

                            return(status);
                        }
                        else
                        {
                            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                                ("DsiOpenTdiAddress: Set.. DsiTdiConnectHandler failed %lx\n",
                                status));
                        }
                    }
                    else
                    {
                        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                            ("DsiOpenTdiAddress: Set.. DsiTdiDisconnectHandler failed %lx\n",
                            status));
                    }
                }
                else
                {
                    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                        ("DsiOpenTdiAddress: Set.. DsiTdiReciveHandler failed %lx\n",
                        status));
                }

                //
                // ERROR Case
                //
                ObDereferenceObject(pFileObject);
                ZwClose(FileHandle);

                return(status);
            }
            else
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiOpenTdiAddress: Set.. DsiTdiErrorHandler failed %lx\n",
                    status));
            }

        }
        else
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiOpenTdiAddress: ObReferenceObjectByHandle failed %lx\n",status));

            ZwClose(FileHandle);
        }

    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiOpenTdiAddress: ZwCreateFile failed %lx\n",status));
    }

    if (fAttachAttempted)
    {
        AFPDetachProcess(CurrentProcess);
    }

    return(status);
}



/***	DsiOpenTdiConnection
 *
 *	This routine creates a TDI Conection for the given connection object
 *
 *  Parm IN:  pTcpConn - connection object
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiOpenTdiConnection(
    IN PTCPCONN     pTcpConn
)
{

    IO_STATUS_BLOCK             IoStatusBlock;
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    PFILE_FULL_EA_INFORMATION   EaBuffer;
    UNICODE_STRING              RelativeDeviceName = {0,0,NULL};
    PMDL                        pMdl;
    PEPROCESS                   CurrentProcess;
    BOOLEAN                     fAttachAttempted;


    ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

    ASSERT(VALID_TCPCONN(pTcpConn));

    ASSERT(pTcpConn->con_pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);

    InitializeObjectAttributes (
        &ObjectAttributes,
        &RelativeDeviceName,
        0,
        pTcpConn->con_pTcpAdptr->adp_FileHandle,
        NULL);

    // Allocate memory for the address info to be passed to the transport
    EaBuffer = (PFILE_FULL_EA_INFORMATION)AfpAllocZeroedNonPagedMemory (
                    sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                    TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                    sizeof(CONNECTION_CONTEXT));

    if (!EaBuffer)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiOpenTdiConnection: alloc for EaBuffer failed\n"));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    EaBuffer->NextEntryOffset = 0;
    EaBuffer->Flags = 0;
    EaBuffer->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    EaBuffer->EaValueLength = sizeof (CONNECTION_CONTEXT);

    // copy ConnectionContext to EaName
    RtlMoveMemory( EaBuffer->EaName, TdiConnectionContext, EaBuffer->EaNameLength + 1 );

    // put out context into the EaBuffer
    RtlMoveMemory (
        (PVOID)&EaBuffer->EaName[EaBuffer->EaNameLength + 1],
        (CONST PVOID)&pTcpConn,
        sizeof (CONNECTION_CONTEXT));

    CurrentProcess = IoGetCurrentProcess();
    AFPAttachProcess(CurrentProcess);;
    fAttachAttempted = TRUE;

    Status = ZwCreateFile (
                 &pTcpConn->con_FileHandle,
                 GENERIC_READ | GENERIC_WRITE,
                 &ObjectAttributes,     // object attributes.
                 &IoStatusBlock,        // returned status information.
                 NULL,                  // block size (unused).
                 FILE_ATTRIBUTE_NORMAL, // file attributes.
                 0,
                 FILE_CREATE,
                 0,                     // create options.
                 (PVOID)EaBuffer,       // EA buffer.
                 sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                    TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                    sizeof(CONNECTION_CONTEXT));

    AfpFreeMemory((PVOID)EaBuffer);

    if (NT_SUCCESS(Status))
    {

        // if the ZwCreate passed set the status to the IoStatus
        //
        Status = IoStatusBlock.Status;

        if (NT_SUCCESS(Status))
        {
            // dereference file handle, now that we are at task time
            Status = ObReferenceObjectByHandle(
                        pTcpConn->con_FileHandle,
                        0L,
                        NULL,
                        KernelMode,
                        (PVOID *)&pTcpConn->con_pFileObject,
                        NULL);

            if (NT_SUCCESS(Status))
            {
                AFPDetachProcess(CurrentProcess);

                return(Status);
            }
            else
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiOpenTdiConnection: ObReference.. failed %lx\n",Status));

                ZwClose(pTcpConn->con_FileHandle);
            }
        }
        else
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiOpenTdiConnection: ZwCreateFile IoStatus failed %lx\n",Status));
        }
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiOpenTdiConnection: ZwCreateFile failed %lx\n",Status));
    }

    if (fAttachAttempted)
    {
        AFPDetachProcess(CurrentProcess);
    }

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
        ("DsiOpenTdiConnection: taking error path, returning %lx\n",Status));

    return Status;

}




/***	DsiAssociateTdiConnection
 *
 *	This routine associates a TDI connection with the address object for AFP port
 *
 *  Parm IN:  pTcpConn - connection object
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiAssociateTdiConnection(
    IN PTCPCONN     pTcpConn
)
{
    NTSTATUS            status;
    PIRP                pIrp;
    PDEVICE_OBJECT      pDeviceObject;


    ASSERT(VALID_TCPCONN(pTcpConn));

    ASSERT(pTcpConn->con_pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);

    pDeviceObject = IoGetRelatedDeviceObject(pTcpConn->con_pFileObject);

    if ((pIrp = AfpAllocIrp(pDeviceObject->StackSize)) == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAssociateTdiConnection: alloc for pIrp failed\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    TdiBuildAssociateAddress(
                pIrp,
                pDeviceObject,
                pTcpConn->con_pFileObject,
                DsiTdiCompletionRoutine,
                NULL,
                pTcpConn->con_pTcpAdptr->adp_FileHandle);

    status = DsiTdiSynchronousIrp(pIrp, pDeviceObject);

    if (status != STATUS_SUCCESS)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAssociateTdiConnection: ..TdiSynch.. failed %lx\n",status));
    }

    AfpFreeIrp(pIrp);

    return(status);
}




/***	DsiSetEventHandler
 *
 *	This routine sends an irp down to the tcp stack to set a specified event handler
 *
 *  Parm IN:  pDeviceObject - TCP's device object
 *            pFileObject - file object corresponding to the address object
 *            EventType - TDI_EVENT_CONNECT, TDI_EVENT_RECEIVE etc.
 *            EventHandler - the handler for this event
 *            Context - our adapter object
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiSetEventHandler(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PFILE_OBJECT     pFileObject,
    IN ULONG            EventType,
    IN PVOID            EventHandler,
    IN PVOID            Context
)
{

    PIRP                pIrp;
    NTSTATUS            status;


    if ((pIrp = AfpAllocIrp(pDeviceObject->StackSize)) == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiSetEventHandler: alloc for pIrp failed\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    TdiBuildSetEventHandler(pIrp,
                            pDeviceObject,
                            pFileObject,
                            NULL,
                            NULL,
                            EventType,
                            EventHandler,
                            Context);

    status = DsiTdiSynchronousIrp(pIrp, pDeviceObject);

    if (status != STATUS_SUCCESS)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiSetEventHandler: ..TdiSynch.. failed %lx\n",status));
    }

    AfpFreeIrp(pIrp);

    return(status);

}




/***	DsiTdiSynchronousIrp
 *
 *	This routine sends an irp down to the tcp stack, and blocks until the irp
 *  is completed
 *
 *  Parm IN:  pIrp - the irp that needs to be sent down
 *            pDeviceObject - TCP's device object
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiTdiSynchronousIrp(
    IN PIRP             pIrp,
    PDEVICE_OBJECT      pDeviceObject
)
{

    NTSTATUS            status;
    KEVENT              Event;


    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    IoSetCompletionRoutine(pIrp,
                           (PIO_COMPLETION_ROUTINE)DsiTdiCompletionRoutine,
                           (PVOID)&Event,
                           TRUE,
                           TRUE,
                           TRUE);

    status = IoCallDriver(pDeviceObject, pIrp);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTdiSynchronousIrp: IoCallDriver failed %lx\n",status));
    }

    if (status == STATUS_PENDING)
    {
        status = KeWaitForSingleObject((PVOID)&Event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
        if (!NT_SUCCESS(status))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiTdiSynchronousIrp: KeWaitFor... failed %lx\n",status));
            return(status);
        }
        status = pIrp->IoStatus.Status;
    }

    return(status);
}



/***	DsiTdiCompletionRoutine
 *
 *	This routine gets called when the irp sent in DsiTdiSynchronousIrp is
 *  completed
 *
 *  Parm IN:  pDeviceObject - TCP's device object
 *            pIrp - the irp that got completed
 *            Context - our adapter object
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiTdiCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
)
{
    KeSetEvent((PKEVENT )Context, 0, FALSE);
    return(STATUS_MORE_PROCESSING_REQUIRED);
}



/***	DsiTdiSend
 *
 *	This routine is the send routine for all DSI sends out to TCP
 *
 *  Parm IN:  pTcpConn - the connection object
 *            pMdl - mdl containing the buffer
 *            DataLen - how many bytes to send
 *            pCompletionRoutine - whom to call when send completes
 *            pContext - context for the completion routine
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiTdiSend(
    IN  PTCPCONN    pTcpConn,
    IN  PMDL        pMdl,
    IN  DWORD       DataLen,
    IN  PVOID       pCompletionRoutine,
    IN  PVOID       pContext
)
{
    PDEVICE_OBJECT      pDeviceObject;
    PIRP                pIrp;
    NTSTATUS            status;


// make sure beginning of the packet looks like the DSI header
#if DBG
    PBYTE  pPacket;
    pPacket = MmGetSystemAddressForMdlSafe(
			pMdl,
			NormalPagePriority);
	if (pPacket != NULL)
		ASSERT(*(DWORD *)&pPacket[DSI_OFFSET_DATALEN] == ntohl(DataLen-DSI_HEADER_SIZE));
#endif

    pDeviceObject = IoGetRelatedDeviceObject(pTcpConn->con_pFileObject);

    if ((pIrp = AfpAllocIrp(pDeviceObject->StackSize)) == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTdiSend: AllocIrp failed\n"));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pIrp->CancelRoutine = NULL;

    TdiBuildSend(
        pIrp,
        pDeviceObject,
        pTcpConn->con_pFileObject,
        pCompletionRoutine,
        pContext,
        pMdl,
        0,
        DataLen);

    status = IoCallDriver(pDeviceObject,pIrp);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTdiSend: IoCallDriver failed %lx\n",status));
    }

    return(STATUS_PENDING);

}



/***	DsiIpAddressCameIn
 *
 *	This routine gets called when ipaddress becomes available on an adapter
 *
 *  Parm IN:  Address - TA_ADDRESS
 *            Context1 -
 *            Context2 -
 *
 *  Returns:  none
 *
 */
VOID
DsiIpAddressCameIn(
    IN  PTA_ADDRESS         Address,
    IN  PUNICODE_STRING     DeviceName,
    IN  PTDI_PNP_CONTEXT    Context2
)
{
    IPADDRESS           IpAddress;
    PUNICODE_STRING     pBindDeviceName;
    NTSTATUS            status=STATUS_SUCCESS;
    KIRQL               OldIrql;
    BOOLEAN             fCreateAdapter=FALSE;
    BOOLEAN             fClosing=FALSE;


    pBindDeviceName = DeviceName;

    // if this is not an ipaddress, we don't care: just return
    if (Address->AddressType != TDI_ADDRESS_TYPE_IP)
    {
        return;
    }

    IpAddress = ntohl(((PTDI_ADDRESS_IP)&Address->Address[0])->in_addr);

    if (IpAddress == 0)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
            ("AfpTdiIpAddressCameIn: ipaddress is 0 on %ws!\n",
            (pBindDeviceName)->Buffer));
        return;
    }

	DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
        ("AfpTdiIpAddressCameIn: %d.%d.%d.%d on %ws\n",
        (IpAddress>>24)&0xFF,(IpAddress>>16)&0xFF,(IpAddress>>8)&0xFF,
        IpAddress&0xFF,(pBindDeviceName)->Buffer));


    if 