ame
	Non zero - number of bytes in prettyname

--*/
	_ASSERT( pchDest != 0 ) ;
	_ASSERT( cbDest > 0 ) ;

	DWORD	cbRtn = 0 ;

	DWORD cchPrettyName;
	const char *pszPrettyName = GetPrettyName(&cchPrettyName);
	if (GetPrettyName(&cchPrettyName) != NULL ) {
		if (cbDest >= cchPrettyName ) {
			CopyMemory(pchDest, pszPrettyName, cchPrettyName);
			cbRtn = cchPrettyName;
		} else {
			return	0;
		}
	}	

	return	cbRtn ;
}

DWORD
CNewsGroup::CopyPrettyname(	
		char*	pchDest,	
		DWORD	cbDest
		)	{
/*++

Routine Description :

	This function retrieves the prettyname for a newsgroup.
	If there is no prettyname, we return 0, otherwise we return the
	number of bytes copied into the provided buffer.
	We will also copy in the terminating CRLF for the line.

Arguments :

	pchDest - Buffer to store prettyname
	cbDest -  Number of bytes in destination buffer

Return Value :

	0 == No Prettyname
	Non zero - number of bytes in prettyname

--*/

	_ASSERT( pchDest != 0 ) ;
	_ASSERT( cbDest > 0 ) ;

	DWORD	cbRtn = 0 ;
	DWORD cch;
	const char *psz = GetPrettyName(&cch);
	static	char	szEOL[] = "\r\n" ;

	//
	//	per RFC, return newsgroup name if no prettyname is available
	//
	
	if( psz == 0 ) {
		psz = GetNativeName();
		cch = GetGroupNameLen();
	}
		
	if( cbDest >= cch + sizeof( szEOL ) ) {
		CopyMemory( pchDest, psz, cch ) ;
		cbRtn = cch ;
	}	else	{
		return	0 ;
	}

	CopyMemory( pchDest+cbRtn, szEOL, sizeof( szEOL ) - 1 ) ;
	cbRtn += sizeof( szEOL ) - 1 ;

	return cbRtn ;
}

BOOL
CNewsGroup::IsGroupVisible(
					CSecurityCtx&	ClientLogon,
					CEncryptCtx&    ClientSslLogon,
					BOOL			IsClientSecure,
					BOOL			fPost,
					BOOL			fDoTest
					) {
/*++

Routine Description :

	Determine whether the client has visibility to this newsgroup.

Arguments :

	ClientLogon -	The CSecurityCtx containing the clients logon
			information etc...
	IsClientSecure - Is the client connected over a secure (SSL)
			session
	fPost -		Does the client want to post to the group or
			read from the group.

Return Value :

	TRUE	if the client has visibility to the newsgroup

	NOTE: check for visibility is done only if enabled in the vroot info mask

--*/

	BOOL fReturn = TRUE;

#if 0
	VrootInfoShare() ;
#endif

	if( IsVisibilityRestrictedInternal() )
	{
		fReturn = IsGroupAccessibleInternal(
									ClientLogon,
									ClientSslLogon,
									IsClientSecure,
									fPost,
									fDoTest
									) ;
	}

#if 0
	VrootInfoShareRelease() ;
#endif

	return	fReturn ;
}

BOOL
CNewsGroup::IsGroupAccessible(
					CSecurityCtx    &ClientLogon,
					CEncryptCtx     &EncryptCtx,
					BOOL			IsClientSecure,
					BOOL			fPost,
					BOOL			fDoTest
					) {
/*++

Routine Description :

	Determine whether the client has access to this newsgroup.

	****** This is now done via instant update in the expiry thread ********
	Do this after updating our virtual root information, and
	the grab the necessary locks to make sure virtual root
	info. doesn't change while we're running !

Arguments :

	ClientLogon -	The CSecurityCtx containing the clients logon
			information etc...
	SslContext - The CEncryptCtx containing all the SSL connection
			information like cert-mapping, key size etc.
	IsClientSecure - Is the client connected over a secure (SSL)
			session
	fPost -		Does the client want to post to the group or
			read from the group.

Return Value :

	TRUE	if the client can access the newsgroup

--*/


#if 0	// Not needed if we pickup instant updates
	UpdateVrootInfo() ;
#endif

#if 0
	VrootInfoShare() ;
#endif

	BOOL	fReturn = IsGroupAccessibleInternal(
									ClientLogon,
									EncryptCtx,
									IsClientSecure,
									fPost,
									fDoTest
									) ;

#if 0
	VrootInfoShareRelease() ;
#endif

	return	fReturn ;
}

BOOL
CNewsGroup::IsGroupAccessibleInternal(
					CSecurityCtx&	ClientLogon,
					CEncryptCtx&	SslContext,
					BOOL			IsClientSecure,
					BOOL			fPost,
					BOOL			fDoTest
					) {
/*++

Routine Description :

	Determine whether the client has access to this newsgroup.

	******** Assumes locks are held **************

Arguments :

	ClientLogon -	The CSecurityCtx containing the clients logon
			information etc...
	SslContext - The CEncryptCtx containing all the SSL connection
			information like cert-mapping, key size etc.
	IsClientSecure - Is the client connected over a secure (SSL)
			session
	fPost -		Does the client want to post to the group or
			read from the group.
	hCertToken - If SSL client cert has been mapped to an NT account,
			this is the mapped token.

Return Value :

	TRUE	if the client can access the newsgroup

--*/

	TraceFunctEnter("CNewsGroup::IsGroupAccessibleInternal");

	HANDLE hCertToken = SslContext.QueryCertificateToken();

	if( IsSecureGroupOnlyInternal() &&
			(!IsClientSecure || !IsSecureEnough( SslContext.QueryKeySize() ))  )
		return	FALSE ;

	// check write access
	if( fPost && IsReadOnlyInternal() )
		return	FALSE ;

	if( !ClientLogon.IsAuthenticated() && !hCertToken )
		return	FALSE ;

#if 0   // Moved to vroot
	if( m_hImpersonation )
		return	TRUE ;
#endif

	//
	//	Don't bother doing all this access checking stuff we
	//	go through below if we're on a FAT drive.
	//
#if 0   // Moved to vroot
	if( m_FileSystemType == FS_FAT )
		return	TRUE ;
#endif

	BOOL	fReturn = FALSE ;
	DWORD	dwError = ERROR_SUCCESS ;

	if( !fDoTest ) {

		return	TRUE ;
	
	}	else	{

		DWORD	dwTest = NNTP_ACCESS_READ ;

		if( fPost ) {

			dwTest = NNTP_ACCESS_POST ;

		}	

		//
		//	Do the SSL session based auth first
		//
		
		if( hCertToken )
		{
            fReturn = CNewsGroupCore::IsGroupAccessible(    hCertToken,
                                                            dwTest );
		} else {

			//
			// ok, now do the auth level check
			// NOTE: SSL session token takes precedence over logon context
			//

			HANDLE hToken = NULL;
			BOOL fNeedsClosed = FALSE;

			SelectToken(&ClientLogon, &SslContext, &hToken, &fNeedsClosed);

            fReturn = CNewsGroupCore::IsGroupAccessible(
                                hToken,
                                dwTest );

            if (fNeedsClosed)
            	CloseHandle(hToken);
		}
	}
	SetLastError( dwError ) ;

	return	fReturn ;
}

BOOL
CNewsGroup::DeleteAllXoverData()	{
/*++

Routine Description :

	This function deletes all of the xover index files that may exist in
	the	newsgroup.

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/
#if 0

	BOOL	fReturn = TRUE ;
	char	szLocalPath[MAX_PATH*2] ;
	char*	szEnd ;
	WIN32_FIND_DATA	finddata ;

	lstrcpy( szLocalPath, m_lpstrPath ) ;
	szEnd = szLocalPath + lstrlen( szLocalPath ) ;
	lstrcat( szEnd, "\\*.xix" ) ;

	BOOL	fImpersonated = FALSE ;
	if( m_hImpersonation ) {
		fImpersonated = ImpersonateLoggedOnUser( m_hImpersonation ) ;
	}

	HANDLE	hFind = FindFirstFile( szLocalPath, &finddata ) ;
	if( hFind != INVALID_HANDLE_VALUE ) {

		do	{
			if( !(finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {
				char*	pchTail = strchr( (char*)finddata.cFileName, '.' ) ;
				if( pchTail != 0 ) {
					if( lstrcmp( pchTail, ".xix" ) == 0 ) {

						char	szFile[MAX_PATH*2] ;
						lstrcpy( szFile, szLocalPath ) ;
						szFile[ szEnd - szLocalPath ] = '\0' ;
						lstrcat( szFile, "\\" ) ;
						lstrcat( szFile, finddata.cFileName ) ;

						if( !DeleteFile( szFile ) ) {
	
							//printf( " NNTPBLD : Failure to delete file %s\n"
							//		" NNTPBLD : Nt Error Code %d\n", szFile, GetLastError() ) ;
							break ;

						}

					}
				}
			}
		}	while( FindNextFile( hFind, &finddata ) ) ;

		DWORD	dwError = GetLastError() ;

		FindClose( hFind ) ;

		if( dwError != ERROR_NO_MORE_FILES ) {
			fReturn = FALSE ;
		}
	}

	if( fImpersonated ) {
		RevertToSelf() ;
	}

	return	fReturn;
#else
	return FALSE;
#endif
}

BOOL
CNewsGroup::ScanXoverIdx(
    OUT ARTICLEID&  xixLowestFound,
    OUT ARTICLEID&  xixHighestFound
    )
/*++

Description:

    Scan current directory for all *.xix files and return
    the xixLowestFound and xixHighestFound

--*/
{
#if 0
    char        path[MAX_PATH*2] ;
    DWORD       fRet = TRUE;
    WIN32_FIND_DATA fData;
    HANDLE      hFind;
    ARTICLEID   LowestFound = 0xFFFFFFFF;   // store temporaryly in local variable
    ARTICLEID   HighestFound = 0;


    TraceFunctEnter( "CNewsGroup::ScanXoverIdx" );

    //
    // Scan for *.xix file
    //
    lstrcpy( path, m_lpstrPath ) ;
    lstrcat( path, "\\*.xix" );

    //
    // Look for files with *.xix in the group
    //
    hFind = FindFirstFile( path, &fData );
    if ( hFind == INVALID_HANDLE_VALUE )
    {
        //
        // No *.xix files found in this directory, SetLastError to
        // ERROR_FILE_NOT_FOUND and bail
        //
        DebugTrace(0, "No *.xix found in %s", path);
        SetLastError( ERROR_FILE_NOT_FOUND );
        fRet = FALSE;
    }
    else
    {
        do
        {

            ARTICLEID xixId;
            PCHAR p;

            //
            // Get the xix filename prefix
            //

            p=strtok(fData.cFileName,".");
            if ( p == NULL ) {
                SetLastError(ERROR_INVALID_PARAMETER);
                fRet = FALSE;
                DebugTrace(0,"Cannot get article ID from %s\n",fData.cFileName);
                break;
            }

		    if( sscanf( p, "%x", &xixId ) != 1 )
		    {
                SetLastError(ERROR_INVALID_PARAMETER);
                fRet = FALSE;
                DebugTrace(0,"Cannot sscanf article ID from %s\n",p);
                break ;
            }

		    xixId = ArticleIdMapper( xixId ) ;

		    LowestFound = min(LowestFound, xixId);
            HighestFound = max(HighestFound, xixId);

        } while ( FindNextFile(hFind,&fData) );

        if (hFind != INVALID_HANDLE_VALUE)
            FindClose( hFind );
    }

    // only assign return value when changed
    if (LowestFound != 0xFFFFFFFF)
        xixLowestFound = LowestFound;
    if (HighestFound != 0)
        xixHighestFound = HighestFound;

    return fRet;
#else
	return FALSE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\newsgrp.inl ===
#if 0
BOOL
CNewsTree::RemoveDirectory( CGRPPTR pGroup )	{

	BOOL fRet = TRUE;

	//
	//	The call to remove a groups directory is a member of the newstree class
	//  because we want to grab a share lock on the newstree. This is required so
	//	we avoid a window where a create group call attempts to re-create the
	//	directory while we are deleting it.
	//

	char* szGroup = pGroup->GetName();
	CGRPPTR pNewGroup = GetGroupPreserveBuffer( szGroup, lstrlen(szGroup)+1 );

	// !! should move before GetGroup if possible !!
	m_LockTables.ShareLock() ;

	if( pNewGroup == 0 )
	{
		// the group has not been re-created, so it is ok to remove the directory
		if(!pGroup->RemoveDirectory())
		{
			fRet = FALSE;
		}
	}

	m_LockTables.ShareUnlock() ;

	return fRet;
}
#endif

DWORD
CNewsGroup::GetArticleEstimate( ) {
	return GetMessageCount();
}

ARTICLEID
CNewsGroup::GetFirstArticle() {
	return GetLowWatermark();
}

ARTICLEID
CNewsGroup::GetLastArticle() {
	return GetHighWatermark();
}

#if 0
BOOL
CNewsGroup::IsSpecial()	{

	CNewsTree*	ptree = m_pTree ;

	if( ptree != 0 ) {
		return	ptree->IsSpecial( m_groupid ) ;
	}
	return	FALSE ;
}
#endif

inline	DWORD	
CNewsGroup::ByteSwapper( 
		DWORD	dw 
		) {
/*++

Routine Description : 

	Given a DWORD reorder all the bytes within the DWORD.

Arguments : 

	dw - DWORD to shuffle

Return Value ; 

	Shuffled DWORD

--*/

	WORD	w = LOWORD( dw ) ;
	BYTE	lwlb = LOBYTE( w ) ;
	BYTE	lwhb = HIBYTE( w ) ;

	w = HIWORD( dw ) ;
	BYTE	hwlb = LOBYTE( w ) ;
	BYTE	hwhb = HIBYTE( w ) ;

	return	MAKELONG( MAKEWORD( hwhb, hwlb ), MAKEWORD( lwhb, lwlb )  ) ;
}

inline	ARTICLEID
CNewsGroup::ArticleIdMapper( 
		ARTICLEID	dw
		)	{
/*++

Routine Description : 

	Given an articleid mess with the id to get something that when
	converted to a string will build nice even B-trees on NTFS file systems.
	At the same time, the function must be easily reversible.
	In fact - 

	ARTICLEID == ArticleMapper( ArticleMapper( ARTICLEID ) ) 

Arguments : 

	articleId - the Article Id to mess with

Return Value : 

	A new article id 

--*/
#if 0 
	DWORD	dw1 = dw & 0xaaaaaaaa ;
	DWORD	dw2 = dw & (~0xaaaaaaaa ) ;

	//
	//	Move every other bit around and then recombine with the 
	//	other bits.
	//

	return	ByteSwapper( dw1 ) | dw2 ;
#else
	return	ByteSwapper( dw ) ;
#endif
}


#if 0
inline	void
CNewsGroup::VrootInfoShare()	{
/*++

Routine Description :

	Grab the lock for this newsgroup in shared mode.
	We will use one of the locks pointer to by gLockPathInfo
	indexed by our groupid.

Arguments : 

	None.

Return Value : 

	None.

--*/

	(m_pTree->m_LockPathInfo)[ m_groupid % (m_pTree->m_NumberOfLocks) ].ShareLock() ;

}

inline	void
CNewsGroup::VrootInfoShareRelease()	{
/*++

Routine Description :

	Release the lock for this newsgroup in shared mode.
	We will use one of the locks pointer to by gLockPathInfo
	indexed by our groupid.

Arguments : 

	None.

Return Value : 

	None.

--*/

	(m_pTree->m_LockPathInfo)[ m_groupid % (m_pTree->m_NumberOfLocks) ].ShareUnlock() ;


}

inline	void
CNewsGroup::VrootInfoExclusive()	{
/*++

Routine Description :

	Grab the lock for this newsgroup in exclusive mode.
	We will use one of the locks pointer to by gLockPathInfo
	indexed by our groupid.

Arguments : 

	None.

Return Value : 

	None.

--*/

	(m_pTree->m_LockPathInfo)[ m_groupid % (m_pTree->m_NumberOfLocks) ].ExclusiveLock() ;

}

inline	void
CNewsGroup::VrootInfoExclusiveRelease()	{
/*++

Routine Description :

	Release the lock for this newsgroup from Exclusive ownership.
	We will use one of the locks pointer to by gLockPathInfo
	indexed by our groupid.

Arguments : 

	None.

Return Value : 

	None.

--*/

	(m_pTree->m_LockPathInfo)[ m_groupid % (m_pTree->m_NumberOfLocks) ].ExclusiveUnlock() ;

}
#endif


#if 0


inline	void
CNewsTree::LockHelpText()	{

	m_Description.ReadData() ;

}

inline	void
CNewsTree::UnlockHelpText()	{

	m_Description.FinishReadData() ;
}

inline	void
CNewsTree::LockModeratorText()	{

	m_Moderators.ReadData() ;

}

inline	void
CNewsTree::UnlockModeratorText()	{

	m_Moderators.FinishReadData() ;

}

inline	void
CNewsTree::LockPrettynamesText()	{

	m_Prettynames.ReadData() ;

}

inline	void
CNewsTree::UnlockPrettynamesText()	{

	m_Prettynames.FinishReadData() ;

}
#endif

inline	char
CNewsGroup::GetListCharacter()	{
/*++

Routine Description : 

	This function returns the character that should be 
	displayed next to the newsgroup in the list active command.
	For moderated groups this is 'm'
	For read/only groups this is 'n'

Arguments : 

	None.

Return Value : 

	A character to display.

--*/

	char	ch = 'y' ;

#if 0
	CNewsTree*	ptree = m_pTree ;

	ptree->LockModeratorText() ;
	if(	m_lpstrModerator ) {
		ch = 'm' ;
	}
	ptree->UnlockModeratorText() ; 
#endif

	if( IsModerated() ) {
		ch = 'm' ;
	}
	if( ch == 'y' ) {
		if( IsReadOnly() ) {
			ch =  'n' ;
		}
	}
	return	ch ;
}


inline void
CNewsTree::InterlockedResetGroupIdHigh( void ) {
#if 0
    m_LockTables.ExclusiveLock() ;
    m_idHigh = FIRST_GROUPID;
    m_LockTables.ExclusiveUnlock() ;
#endif
}

inline void
CNewsTree::InterlockedMaxGroupIdHigh( GROUPID groupid ) {
#if 0
    m_LockTables.ExclusiveLock() ;
    m_LockTables.ExclusiveLock() ;
    GROUPID idHigh = max( m_idHigh, groupid );
    if (m_idHigh < idHigh)
        m_idHigh = idHigh + 1;  // +1 to be 1 bigger than the biggest only
                                // if groupid is bigger
    m_LockTables.ExclusiveUnlock() ;
#endif
}

inline GROUPID
CNewsTree::InterlockedIncrementGroupIdHigh( void ) {
#if 0
    m_LockTables.ExclusiveLock() ;
    GROUPID    groupid;
    m_LockTables.ExclusiveLock() ;
    groupid = m_idHigh++;
    m_LockTables.ExclusiveUnlock() ;
    return groupid;
#else
	return -1;
#endif
}

inline	BOOL
CNewsGroup::IsReadOnlyInternal(	)	{
/*++

Routine Description : 

	Determine whether a newsgroup is read only, 
	basically we do this by checking if the WRITE flag is missing.

	***** ASSUMES LOCKS ARE HELD **********


Arguments : 

	None.

Return Value : 

	TRUE if the group is read only - this can be set on a per newsgroup basis.
	(by default a newsgroup is NOT read-only. It becomes read-only if either
	its virtual root is made read-only OR the newsgroup is made read-only via an RPC)

	FALSE otherwise.

--*/

	return	( CNewsGroupCore::IsReadOnly() || !(GetAccessMask() & VROOT_MASK_WRITE) );
}

inline	BOOL
CNewsGroup::IsSecureGroupOnlyInternal()	{
/*++

Routine Description : 

	Determine whether the newsgroup is accessible only 
	through SSL encrypted sessions.
	Basically we check if the VROOT_MASK_SSL bit is present.


	***** ASSUMES LOCKS ARE HELD **********

Arguments : 

	None.
	
Return Value

	TRUE if the group should only be accessed through SSL.

--*/

	return 	(GetSSLAccessMask() & MD_ACCESS_SSL ) ||
			(GetSSLAccessMask() & MD_ACCESS_SSL128 );
}

inline	BOOL
CNewsGroup::IsSecureEnough( DWORD dwKeySize )	{
/*++

Routine Description : 

	Determine whether the key size of the SSL session is secure enough
	based on virtual root settings for this group.


	***** ASSUMES LOCKS ARE HELD **********

Arguments : 

	DWORD	dwKeySize

Return Value

	TRUE if the right key size is being used

--*/

	if( GetSSLAccessMask() & MD_ACCESS_SSL128 ) {
		return ( 128 == dwKeySize );
	}

	return TRUE;
}

inline	BOOL
CNewsGroup::IsVisibilityRestrictedInternal()	{
/*++

Routine Description : 

	Determine whether a newsgroup is to be checked for visibility, 
	basically we do this by checking if the EXECUTE flag is set.
	NOTE: this is a hack - we are over-riding the EXECUTE bit !!

	***** ASSUMES LOCKS ARE HELD **********


Arguments : 

	None.

Return Value : 

	TRUE if the EXECUTE bit is set, FALSE otherwise

--*/

	return	(GetAccessMask() & VROOT_MASK_EXECUTE) ;
}

inline	BOOL
CNewsGroup::IsReadOnly(	)	{
/*++

Routine Description : 

	Determine whether a newsgroup is read only, 
	basically we do this by checking if the WRITE flag is missing.

Arguments : 

	None.

Return Value : 

	TRUE if the group is read only,.
	FALSE otherwise.

--*/

#if 0
	VrootInfoShare() ;
#endif

	BOOL	fReturn = IsReadOnlyInternal() ;

#if 0
	VrootInfoShareRelease() ;
#endif

	return	fReturn ;
}

inline	BOOL
CNewsGroup::IsSecureGroupOnly()	{
/*++

Routine Description : 

	Determine whether the newsgroup is accessible only 
	through SSL encrypted sessions.
	Basically we check if the VROOT_MASK_SSL bit is present.

Arguments : 

	None.

Return Value

	TRUE if the group should only be accessed through SSL.

--*/

#if 0
	VrootInfoShare() ;	
#endif

	BOOL	fReturn  = IsSecureGroupOnlyInternal() ;

#if 0
	VrootInfoShareRelease() ;
#endif

	return	fReturn ;
}

inline	BOOL
CNewsGroup::IsVisibilityRestricted()	{
/*++

Routine Description : 

	Determine whether visibility is restricted on this newsgroup. If visibility is restricted
	on a newsgroup, it will not appear in LIST and other wildmat iterators if the client does
	not have read access.

	Basically we check if the VROOT_MASK_EXECUTE bit is present.

Arguments : 

	None.

Return Value

	TRUE if visibility is restricted on this newsgroup

--*/

#if 0
	VrootInfoShare() ;	
#endif

	BOOL	fReturn  = IsVisibilityRestrictedInternal() ;

#if 0
	VrootInfoShareRelease() ;
#endif

	return	fReturn ;
}

inline	BOOL
CNewsGroup::AddXoverData(
				ARTICLEID	article,
				LPBYTE		lpb,
				DWORD		cb	
				)	{
/*++

Routine Description : 

	Add xover data to our index files !

Arguments : 

	article - the id of the article we are adding xover data for !
	lpb - the bytes containing the raw xover data !
	cb - Number of bytes in the xover data !

Return Value : 

	TRUE if successfull, 
	FALSE otherwise.

--*/

#if 0
	BOOL	fImpersonated = FALSE ;

	VrootInfoShare() ;

	if( m_hImpersonation ) {
		fImpersonated = ImpersonateLoggedOnUser( m_hImpersonation ) ;
	}

	BOOL	fSuccess = 

	XOVER_CACHE(m_pTree)->AppendEntry(	
								m_groupid,
								m_lpstrPath,
								article,
								lpb,
								cb 
								) ;

	VrootInfoShareRelease() ;

	if( fImpersonated )	{
		RevertToSelf() ;
	}

	return	fSuccess ;
#else
	return FALSE;
#endif
}

inline	DWORD
CNewsGroup::ListgroupFillBuffer(
				LPBYTE		lpb,
				DWORD		cb,
				ARTICLEID	artidStart,
				ARTICLEID	artidFinish,
				ARTICLEID	&artidLast,
				HXOVER		&hXover
				)	{
/*++

Routine Description : 

	Get Listgroup data from the index files.

Arguments : 

	lpb - buffer where we are to store xover data
	cb -	number of bytes available in the buffer
	artidStart - First article we want in the query results
	artidFinish - Last article we want in the query results (inclusive)
	artidLast - Next article id we should query for
	hXover - Handle which will optimize future queries

Return Value : 

	Number of bytes placed in the buffer.

--*/

#if 0
	BOOL	fImpersonated = FALSE ;

	VrootInfoShare() ;

	if( m_hImpersonation ) {
		fImpersonated = ImpersonateLoggedOnUser( m_hImpersonation ) ;
	}

	DWORD	cbReturn = 

	XOVER_CACHE(m_pTree)->ListgroupFillBuffer(	
							lpb,
							cb,
							m_groupid,
							m_lpstrPath,
							artidStart,
							artidFinish,
							artidLast,
							hXover	
							) ;

	VrootInfoShareRelease() ;
	
	if( fImpersonated ) {
		RevertToSelf() ;
	}

	return	cbReturn ;
#else
	return FALSE;
#endif
}

inline	BOOL
CNewsGroup::ExpireXoverData()	{
/*++

Routine Description : 

	Expire xover index files

Arguments : 

	None.

Retun Value : 

	TRUE if successfull, FALSE if an error occurred !


--*/

	CGrabShareLock	lock( this ) ;

	ARTICLEID	artNewLow ;

	BOOL	fSuccess = TRUE ;
	if( m_iLowWatermark != 0 ) {

		char	szCachePath[MAX_PATH*2] ;
		BOOL	fFlatDir ;
		if( ComputeXoverCacheDir( szCachePath, fFlatDir, TRUE ) )	{
	
			fSuccess = 
				XOVER_CACHE(((CNewsTree*)m_pNewsTree))->ExpireRange(	
											m_dwGroupId, 
											szCachePath,
											fFlatDir,
											m_artXoverExpireLow,
											m_iLowWatermark - 1,
											artNewLow 
											) ;
			if( fSuccess ) 
				m_artXoverExpireLow = artNewLow ;
		}
	}
	return	fSuccess ;
}

inline	BOOL
CNewsGroup::DeleteXoverData(
					ARTICLEID	artid	
					)	{
/*++

Routine Description : 

	An article has been cancelled - get rid of its xover information.

Arguments ; 

	artid - The cancelled article

Return Value : 

	TRUE if successfull, FALSE otherwise.

--*/

	BOOL	fSuccess = FALSE ;

	char	szCachePath[MAX_PATH*2] ;
	BOOL	fFlatDir ;
	if( ComputeXoverCacheDir( szCachePath, fFlatDir ) )	{
		fSuccess = 
			XOVER_CACHE(((CNewsTree*)m_pNewsTree))->RemoveEntry(	
									m_dwGroupId,
									szCachePath,
									fFlatDir,
									artid 
									) ;
	}

	return	fSuccess ;
}
inline	BOOL
CNewsGroup::FlushGroup()	{
/*++

Routine Description : 

	Flush all xover cache entries for this group

Arguments : 

	None.

Retun Value : 

	TRUE if successfull, FALSE if an error occurred !


--*/

	BOOL	fSuccess = TRUE ;

	fSuccess = XOVER_CACHE(((CNewsTree*)m_pNewsTree))->FlushGroup( m_dwGroupId ) ;
	return	fSuccess ;
}

#if 0
inline CNewsTree *CNewsGroup::GetTree() {
	return (CNewsTree*) m_pNewsTree;
}
#endif


inline
CGroupIterator::CGroupIterator(	
	CNewsTree*  pTree,
	LPMULTISZ	lpPatterns, 
	CGRPCOREPTR &pFirst,
	BOOL		fIncludeSecureGroups,
	BOOL		fIncludeSpecial,
	class CSecurityCtx* pClientLogon,	// NON-NULL for visibility check
	BOOL		IsClientSecure,
	class CEncryptCtx*  pClientSslLogon
	) : 
		CGroupIteratorCore(pTree, lpPatterns, pFirst, fIncludeSpecial),
		m_pClientLogon(pClientLogon),
		m_IsClientSecure(IsClientSecure),
		m_pClientSslLogon(pClientSslLogon),
		m_fIncludeSecureGroups(fIncludeSecureGroups)
	{

	// OK, now that we're here, we're pointing to the first non-deleted,
	// non-special(unless requested) group that matches the pattern.

	BOOL fSawInvisible = FALSE;

	CGRPPTR pGroup = Current();

	if (pGroup == NULL)
	    return;

	if (m_pClientLogon && m_pClientSslLogon) {

		fSawInvisible = !pGroup->IsGroupVisible(
			*m_pClientLogon,
			*m_pClientSslLogon,
			m_IsClientSecure,
			FALSE, TRUE);
	}

	if (fSawInvisible || (!m_fIncludeSecureGroups && pGroup->IsSecureGroupOnly()))
		Next();

}

inline
CGroupIterator::CGroupIterator( 
	CNewsTree*  	pTree,
	CGRPCOREPTR		&pFirst,
	BOOL			fIncludeSecureGroups,
	class CSecurityCtx* pClientLogon,	// NON-NULL for visibility check
	BOOL	IsClientSecure,
	class CEncryptCtx*  pClientSslLogon
	) :
		CGroupIteratorCore(pTree, pFirst),
		m_pClientLogon(pClientLogon),
		m_IsClientSecure(IsClientSecure),
		m_pClientSslLogon(pClientSslLogon),
		m_fIncludeSecureGroups(fIncludeSecureGroups)
	{

	// OK, now that we're here, we're pointing to the first non-deleted,
	// non-special(unless requested) group that matches the pattern.

	BOOL fSawInvisible = FALSE;

	CGRPPTR pGroup = Current();

	if (pGroup == NULL)
	    return;

	if (m_pClientLogon && m_pClientSslLogon) {

		fSawInvisible = !pGroup->IsGroupVisible(
			*m_pClientLogon,
			*m_pClientSslLogon,
			m_IsClientSecure,
			FALSE, TRUE);
	}

	if (fSawInvisible || (!m_fIncludeSecureGroups && pGroup->IsSecureGroupOnly()))
		Next();

}


inline void __stdcall
CGroupIterator::Next() {

	CGroupIteratorCore::Next();

	while (!IsEnd()) {

		CGRPPTR pGroup = Current();

       	if (pGroup == NULL)
	        return;

		if (!m_fIncludeSecureGroups && pGroup->IsSecureGroupOnly()) {
			CGroupIteratorCore::Next();
			continue;
		}

		if (m_pClientLogon && m_pClientSslLogon &&
			!pGroup->IsGroupVisible(
				*m_pClientLogon,
				*m_pClientSslLogon,
				m_IsClientSecure,
				FALSE, TRUE)) {
			CGroupIteratorCore::Next();
			continue;
		}

		// Made it here, so the group is OK

		break;

	}


}

inline void __stdcall
CGroupIterator::Prev() {

	CGroupIteratorCore::Prev();

	while (!IsBegin()) {

		CGRPPTR pGroup = Current();

	    if (pGroup == NULL)
	        return;

		if (!m_fIncludeSecureGroups && pGroup->IsSecureGroupOnly()) {
			CGroupIteratorCore::Prev();
			continue;
		}

		if (m_pClientLogon && m_pClientSslLogon &&
			!pGroup->IsGroupVisible(
				*m_pClientLogon,
				*m_pClientSslLogon,
				m_IsClientSecure,
				FALSE, TRUE)) {
			CGroupIteratorCore::Prev();
			continue;
		}

		// Made it here, so the group is OK

		break;

	}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\newstree.cpp ===
/*++

	newstree.cpp

	This file contains the code implementing the CNewsTree object.
	There can only be one CNewsTree object per Tigris server.
	Each CNewsTree object is responsible for helping callers
	search and find arbitrary newsgroups.

	To support this, the CNewsTree object maintains two HASH Tables -
	One hash table for searching for newsgroups by name, another
	to search by GROUP ID.
	Additionally, we maintain a linked list of (alphabetical) of all
	the newsgroups.  And finally, we maintain a thread which is used
	to periodically save newsgroup information and handle expiration.


--*/




#define		DEFINE_FHASH_FUNCTIONS
#include    "tigris.hxx"

#include <malloc.h>

//template	class	TFHash<	CGrpLpstr, LPSTR > ;
//template	class	TFHash<	CGrpGroupId,	GROUPID > ;

static	char	szSlaveGroup[]	= "_slavegroup._slavegroup" ;
#define VROOT_CHANGE_LATENCY 10000

#ifdef	_NO_TEMPLATES_

FHASH_CONSTRUCTOR( CGrpLpstr, LPSTR ) ;
FHASH_INIT( CGrpLpstr, LPSTR ) ;
FHASH_ISVALID( CGrpLpstr, LPSTR ) ;
FHASH_DESTRUCTOR( CGrpLpstr, LPSTR ) ;
FHASH_COMPUTEINDEX( CGrpLpstr, LPSTR ) ;
FHASH_INSERT( CGrpLpstr, LPSTR ) ;
FHASH_SEARCH( CGrpLpstr, LPSTR ) ;
FHASH_DELETE( CGrpLpstr, LPSTR ) ;


FHASH_CONSTRUCTOR( CGrpGroupId, GROUPID ) ;
FHASH_INIT( CGrpGroupId, GROUPID ) ;
FHASH_ISVALID( CGrpGroupId, GROUPID ) ;
FHASH_DESTRUCTOR( CGrpGroupId, GROUPID ) ;
FHASH_COMPUTEINDEX( CGrpGroupId, GROUPID ) ;
FHASH_INSERT( CGrpGroupId, GROUPID ) ;
FHASH_SEARCH( CGrpGroupId, GROUPID ) ;
FHASH_DELETE( CGrpGroupId, GROUPID ) ;

#endif

//
//	This sets up all of our static members etc...
//
HANDLE CNewsTree::m_hTermEvent = 0 ;
HANDLE CNewsTree::m_hCrawlerThread = NULL ;

BOOL
CNewsTree::InitCNewsTree( 
		PNNTP_SERVER_INSTANCE	pInstance,
		BOOL&	fFatal
		) {
/*++

Routine Description : 

	Create a singular newstree object and then initialize it.

Arguments : 

	pInstance - Virtual server instance
	fFatal    - set to TRUE if a fatal error occurs

Return Value : 

	TRUE on success

--*/


	CNewsTree* ptree = pInstance->GetTree();
	_ASSERT( ptree );

    if( ptree->Init( pInstance, fFatal ) )	{
		return TRUE;
	}

    return  FALSE ;
}

BOOL
CNewsTree::StopTree()	{
/*++

Routine Description : 

	This function signals all of the background threads we create that 
	it is time to stop and shuts them down.

Arguments : 

	None.

Return Value : 
	TRUE if Successfull.

--*/

    m_bStoppingTree = TRUE;
	CNewsTreeCore::StopTree();

	m_pInstance->ShutdownDirNot();

    return TRUE;
}

CNewsTree::CNewsTree(INntpServer *pServerObject) :
	m_bStoppingTree( FALSE ),
    m_cNumExpireByTimes( 1 ),
    m_cNumFFExpires( 1 ),
	CNewsTreeCore(pServerObject)
	{
	//
	//	Constructor sets newstree up into initially empty state
	//
}

CNewsTree::~CNewsTree()	{
	//
	//	All of our member destructors should take care of stuff !
	//
	TraceFunctEnter( "CNewsTree::~CNewsTree" ) ;
}

BOOL
CNewsTree::Init( 
			PNNTP_SERVER_INSTANCE	pInstance,
			BOOL& fFatal
			) {
/*++

Routine Description : 

	Initialize the news tree.
	We need to setup the hash tables, check that the root virtual root is intact
	and then during regular server start up we would load a list of newsgroups from 
	a file.

Arguments : 


Return Value : 

	TRUE if successfull.

--*/
	//
	//	This function will initialize the newstree object
	//	and read the group.lst file if it can.
	//

	TraceFunctEnter( "CNewsTree::Init" ) ;

	BOOL	fRtn;
	fRtn =  CNewsTreeCore::Init(pInstance->GetVRTable(), 
	                            pInstance->GetInstanceWrapperEx(),
								fFatal, 
								gNumLocks, 
								RejectGenomeGroups);

	m_pInstance = pInstance ;
    m_bStoppingTree = FALSE;

    return  fRtn ;
}

void    
CNewsTree::BeginExpire( BOOL& fDoFileScan )
{
    CheckExpire( fDoFileScan );
    g_pNntpSvc->m_pExpireThrdpool->BeginJob( (PVOID)this );
}

void    
CNewsTree::EndExpire()
{
    TraceFunctEnter("CNewsTree::EndExpire");

    DWORD dwWait = g_pNntpSvc->m_pExpireThrdpool->WaitForJob( INFINITE );
    if( WAIT_OBJECT_0 != dwWait ) {
        ErrorTrace(0,"Wait failed - error is %d", GetLastError() );
        _ASSERT( FALSE );
    }

    BOOL fDoFileScan = FALSE;
    CheckExpire( fDoFileScan );
    if( fDoFileScan ) {
        m_cNumExpireByTimes = 1;
    } else {
        m_cNumExpireByTimes++;
    }
}

void    
CNewsTree::CheckExpire( BOOL& fDoFileScan )
{
    fDoFileScan = FALSE;
}

BOOL
CNewsTree::DeleteGroupFile()	{
/*++

Routine Description : 

	This function deletes the group.lst file (The file that
	we save the newstree to.)
	
Arguments : 

	None.

Return Value : 

	TRUE if successfull.
	FALSE otherwise.  We will preserver GetLastError() from the DeleteFile() call.

--*/

	
	return	DeleteFile( m_pInstance->QueryGroupListFile() ) ;

}

BOOL
CNewsTree::VerifyGroupFile( )	{
/*++

Routine Description : 

	This function checks that the group.lst file is intact and 
	appears to be valid.  We do this by merely confirming some check sum
	bytes that should be the last 4 bytes at the end of the file.

Arguments : 

	None.

Return Value : 

	TRUE if the Group.lst file is good.
	FALSE if corrupt or non-existant.

--*/

	CMapFile	map(	m_pInstance->QueryGroupListFile(), FALSE, 0 ) ;
	if( map.fGood() ) {

		DWORD	cb ;
		char*	pchBegin = (char*)map.pvAddress( &cb ) ;

		DWORD	UNALIGNED*	pdwCheckSum = (DWORD UNALIGNED *)(pchBegin + cb - 4);
		
		if( *pdwCheckSum != INNHash( (BYTE*)pchBegin, cb-4 ) ) {
			return	FALSE ;
		}	else	{
			return	TRUE ;
		}
	}
	return	FALSE ;
}

DWORD	__stdcall	
CNewsTree::NewsTreeCrawler(	void* )	{
/*++

Routine Description : 

	This function does all background manipulation of newsgroups
	required by the server.
	There are 4 main functions that need to be accomplished : 

		1) Periodically save an updated file of group information
		if the news tree has been updated.

		2) Expire articles.

		3) Process the rmgroup queue

Arguments : 

	None.

Return Value : 

	None.

--*/

	DWORD	dwWait = WAIT_TIMEOUT;
	PNNTP_SERVER_INSTANCE pInstance = NULL ;

	TraceFunctEnter( "CNewsTree::NewsTreeCrawler" );

	if( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {
		dwWait = WaitForSingleObject( 
								CNewsTree::m_hTermEvent, 
								2 *60 * 1000		// wait for all instances to boot
								);
	}

	if( WAIT_OBJECT_0 == dwWait ) {
		return 0 ;
	}

	//
	//	The crawler thread will periodically iterate over all instances
	//	to expire articles and process its rmgroup queue
	//

	while( g_pInetSvc->QueryCurrentServiceState() != SERVICE_STOP_PENDING )
    {
              
		// dwWait == WAIT_TIMEOUT only when this thread wakes up per schedule
		if( WAIT_TIMEOUT == dwWait && (g_pInetSvc->QueryCurrentServiceState() == SERVICE_RUNNING) )
		{
			//	Get the min and max instance ids
			DWORD dwMinInstanceId = 0;
			DWORD dwMaxInstanceId = 0;

			if( FindIISInstanceRange( g_pNntpSvc, &dwMinInstanceId, &dwMaxInstanceId ) ) 
			{
				//
				//	Iterate over all instances 
				//
				for( DWORD dwCurrInstance = dwMinInstanceId; 
						dwCurrInstance <= dwMaxInstanceId; dwCurrInstance++)
				{
					pInstance = FindIISInstance( g_pNntpSvc, dwCurrInstance );
					if( pInstance == NULL ) {
						ErrorTrace(0,"Expire thread: FindIISInstance returned NULL: instance %d", dwCurrInstance);
						continue;
					}

					//
					//	Call method to expire articles in an instance
					//

					CShareLockNH* pLockInstance = pInstance->GetInstanceLock();

					pLockInstance->ShareLock();
					if( !ExpireInstance( pInstance ) ) {
						ErrorTrace(0,"ExpireInstance %d failed", dwCurrInstance );
					} else {
						DebugTrace(0, "ExpireInstance %d returned success", dwCurrInstance );
					}
					pLockInstance->ShareUnlock();

					//	Release the ref added by FindIISInstance()
					pInstance->Dereference();

					//	No use continuing the iteration if service is stopping !
					if ( g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING ) break;
				}
			} else {
				ErrorTrace(0, "FindIISInstanceRange failed" );
			}
		}

		dwWait = WaitForSingleObject( 
								CNewsTree::m_hTermEvent, 
								dwNewsCrawlerTime
								);

        if ( WAIT_OBJECT_0 == dwWait )
        {
			//	Time to die !!
			break ;
		}
	}	// end while

	return	0 ;
}

//
//	Expire articles in a given virtual server instance
//

BOOL
CNewsTree::ExpireInstance(
				PNNTP_SERVER_INSTANCE	pInstance
				)
{
	BOOL fRet = TRUE ;
	TraceFunctEnter("CNewsTree::ExpireInstance");

	// bail if service is stopping or expire is not ready for this instance
	if( (pInstance->QueryServerState() != MD_SERVER_STATE_STARTED)	||
		pInstance->m_BootOptions									||
		!pInstance->ExpireObject()									||
		!pInstance->ExpireObject()->m_FExpireRunning				|| 
		(pInstance->QueryServerState() == MD_SERVER_STATE_STOPPING)	||
		(g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) ) 
	{
		ErrorTrace(0, "Instance %d not ready for expire", pInstance->QueryInstanceId() );
		TraceFunctLeave();
		return FALSE ;
	}

    CNewsTree*  pTree = pInstance->GetTree() ;

	//
	// Process any pending rmgroups
	//
	(pInstance->ExpireObject())->ProcessRmgroupQueue( pTree );

    //
    //  Expiring articles by time is fast - the work is farmed out to a thread pool
    //
    (pInstance->ExpireObject())->ExpireArticlesByTime( pTree );

    //
    //  Expiring articles by size is slow - a single thread scans the groups
    //  NOTE: Expire policies that are by both time and size get processed here
    //
    //(pInstance->ExpireObject())->ExpireArticlesBySize( pTree );

	TraceFunctLeave();
	return fRet ;
}

BOOL
CNewsTree::RemoveGroup( CGRPPTR     pGroup )
{
    TraceFunctEnter("CNewsTree::RemoveGroup");

    // remove group from internal hash tables and lists
    return CNewsTreeCore::RemoveGroup(pGroup );
}

static	char	szCreateFileString[] = "\\\\?\\" ;
		
BOOL
CNewsTree::CreateDirectoryPath(	
				LPSTR	lpstr, 
				DWORD	cbValid,
				LPSTR&	lpstrOut,
				LPSTR   lpstrGroup,
				CGRPPTR *ppGroup,
				BOOL&	fExists
				)		{
/*++

Routine Description : 

	Given a newsgroup name create the corresponding directory.
	Return the path needed to access that directory !

Arguments : 

	lpstr - The newsgroup name.
	cbValid - Number of bytes in newsgroup name.
	lpstrOut - Out parameter - gets pointer to a path which can 
		access the directory, this path may skip the leading '\\?\' if the 
		path has no funky elements to it.
	lpstrGroup - The newsgroup name in . form
	ppGroup - If the directory for this group exists, search for a deleted group in the rmgroup queue
			  Return this group if found in the queue.
	fExists - Out param indicates if the directory already exists

Return Value : 

	TRUE if successfull.
	FALSE otherwise.	

--*/


	TraceFunctEnter(	"CreateDirectoryPath" ) ;

	lpstrOut = lpstr ;
	fExists = FALSE;

	char*	pchSlash = 0 ;		
	if( cbValid == 0 && memcmp( lpstr, szCreateFileString, sizeof( szCreateFileString ) - 1 ) == 0 ) {
		pchSlash = strchr( lpstr+sizeof(szCreateFileString)-1, '\\' ) ;
		if( pchSlash > lpstr && pchSlash[-1] == ':' ) {
			pchSlash = strchr( pchSlash+1, '\\' ) ;
		}
	}	else	{
		if( cbValid > 0 ) 
			pchSlash = strchr(	lpstr+cbValid+1, '\\' ) ;
		else
			pchSlash = strchr( lpstr, '\\' ) ;
	}

	if( memcmp( lpstr, szCreateFileString, sizeof( szCreateFileString ) - 1 ) == 0 ) {

		lpstrOut = lpstr + sizeof( szCreateFileString ) - 1 ;
	
	}

	DWORD	dw = 0 ;

	DebugTrace( 0, "About to create directory %s", lpstr ) ;
	
	
	while( pchSlash )	{
		*pchSlash = '\0' ;
		BOOL	fSuccess = CreateDirectory( lpstrOut, 0 ) ;
		if( !fSuccess && GetLastError() != ERROR_ALREADY_EXISTS ) {
			if( lpstrOut != lpstr ) {
				lpstrOut = lpstr ;
				fSuccess = CreateDirectory( lpstr, 0 ) ;
			}
		}
				
		if( !fSuccess ) {
			dw = GetLastError() ;
			if( dw != ERROR_ALREADY_EXISTS )	{
				ErrorTrace( 0, "Error Creating Directory %d", dw ) ;
				*pchSlash = '\\' ;		
				return	FALSE ;
			}
		}
		*pchSlash = '\\' ;
		pchSlash = strchr( pchSlash+1, '\\' ) ;
	}

	DebugTrace( 0, "Succesfully completed creating directories" ) ;

	BOOL fSuccess = CreateDirectory( lpstrOut, 0 ) ;
	if( !fSuccess && GetLastError() != ERROR_ALREADY_EXISTS ) {
		if( lpstrOut != lpstr ) {
			lpstrOut = lpstr ;
			fSuccess = CreateDirectory( lpstr, 0 ) ;
		}
	}

	if( !fSuccess ) {
		dw = GetLastError() ;

		if( dw != ERROR_ALREADY_EXISTS ) {
			ErrorTrace( 0, "Error Creating Directory %d", dw ) ;
			return	FALSE ;
		}

		// Check only if RmgroupQueue exists and ppGroup is NON-NULL
		if( dw == ERROR_ALREADY_EXISTS && (m_pInstance->ExpireObject())->m_RmgroupQueue && ppGroup) {
			
			// This may be a newsgroup on the deleted queue
			// If so, yank it from that queue 
			// The articles in this group are deleted after the exclusive lock is released
			BOOL fElem = FALSE;
			if(!(m_pInstance->ExpireObject()->m_RmgroupQueue)->IsEmpty())
				fElem = (m_pInstance->ExpireObject()->m_RmgroupQueue)->Search( ppGroup, lpstrGroup );

			if(!fElem)
			{
				*ppGroup = NULL;
				fExists = TRUE;		// directory exists - an old avtar of this group may be around
			}
			else
			{
				DebugTrace(0, "Found rmgroup in queue while trying to re-create %s", lpstrGroup);
			}
		}
	}

	return	TRUE ;
}

CGroupIterator*
CNewsTree::ActiveGroups(
					BOOL	fIncludeSecureGroups,
					CSecurityCtx* pClientLogon,
					BOOL	IsClientSecure,
					CEncryptCtx* pClientSslLogon,
                    BOOL    fReverse
					) {
/*++

Routine Description : 

	Build an iterator that can be used to walk all of the 
	client visible newsgroups.

Arguments : 
	
	fIncludeSecureGroups - 
		IF TRUE then the iterator we return will visit the
		SSL only newsgroups.

Return Value : 

	An iterator, NULL if an error occurs

--*/

	m_LockTables.ShareLock() ;
	CGRPCOREPTR	pStart;
    if( !fReverse ) {
		CNewsGroupCore *p = m_pFirst;
		while (p && p->IsDeleted()) p = p->m_pNext;
		pStart = p;
    } else {
		CNewsGroupCore *p = m_pLast;
		while (p && p->IsDeleted()) p = p->m_pPrev;
		pStart = p;
    }	
	m_LockTables.ShareUnlock() ;

	CGroupIterator*	pReturn = new	CGroupIterator( 
												this,
												pStart,
												fIncludeSecureGroups,
												pClientLogon,
												IsClientSecure,
												pClientSslLogon
												) ;
	return	pReturn ;
}

CGroupIterator*
CNewsTree::GetIterator( 
					LPMULTISZ	lpstrPattern, 
					BOOL		fIncludeSecureGroups,
					BOOL		fIncludeSpecialGroups,
					CSecurityCtx* pClientLogon,
					BOOL	IsClientSecure,
					CEncryptCtx* pClientSslLogon
					) {
/*++

Routine Description : 

	Build an iterator that 	will list newsgroups meeting
	all of the specified requirements.

Arguments : 

	lpstrPattern - wildmat patterns the newsgroup must match
	fIncludeSecureGroups - if TRUE then include secure (SSL only) newsgroups
	fIncludeSpecialGroups - if TRUE then include reserved newsgroups

Return Value : 

	An iterator, NULL on error

--*/

	CGRPCOREPTR pFirst;

	m_LockTables.ShareLock();
	CNewsGroupCore *p = m_pFirst;
	while (p != NULL && p->IsDeleted()) p = p->m_pNext;
	pFirst = p;
	m_LockTables.ShareUnlock();

	CGroupIterator*	pIterator = XNEW CGroupIterator(
												this,
												lpstrPattern, 
												pFirst,
												fIncludeSecureGroups,
												fIncludeSpecialGroups,
												pClientLogon,
												IsClientSecure,
												pClientSslLogon
												) ;

    return  pIterator ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\newsgrp.h ===
/*++
// newsgrp.h -
//
// This file provides classes defining the interfaces to newsgroups.
//
// A newsgroup will be represented on disk as a directory containing a set
// of files.  Each of those files will be an article in the newsgroup.
// CNewsGroup will represent a newsgroup within a server.  Each newsgroup directory
// on the hard disk will contain a file which holds config information for the
// newsgroup.  If there is no such file, than we will inherit the config information of
// a parent newsgroup.
//
// In this file we provide two classes - CNewsGroup, the generic newsgroup,
//	and CNewsTree a class which will be used to manipulate the newstree as a whole.
//  Only one CNewsTree object will exist in the NNTP server.
//
//	The following are registry keys which we will examine on Boot Up to determine newsgroup
//	properties :
//
//		NNTP\Roots - this key will contain a sub key for each directory specified in the
//			Admin Roots dialog.  During boot up we will recursively scan all subdirectories
//			from each of these roots to locate every newsgroup object.
//
//		NNTP\Expirations - this registry key will contain expiration information for newsgroups.
//			Each subkey will have an 'expiration name'.  The subkey will contain reg values
//			that represent Expiration Time, Expiration Disk Size, and a REG_MULTI_SZ that contains
//			a regular expression strings which specify which newsgroups use this expiration
//			policy.
//
//		In addition there will be some values under NNTP\ServerSettings which specify how
//		large the newsgroup hash tables should be which can be tweaked to improve server
//		performance.
//
//	The following newsgroup properties will be stored in config files which are
//	stored in each newsgroup directory.  If a newsgroup directory does not have such a config
//	file it can inherit the properties from a file farther up the directory tree.
//	(Not the newsgroup tree.)
//
//		MSN Token for the newsgroup
//		Moderated flag
//		Read Only flag
//		Low Article Number
//		High Article Number
//		Number of Articles.
//
//	These properties will be accessed through the NT GetPrivateProfile, WritePrivateProfile api's
//	and the .ini files will be hand editable.
//
//	Initialization -
//
//		The CNewsTree object must be initialized before News Feeds are read from the registry.
//		Upon boot the CNewsTree object will do the following steps :
//
//			1) Recursively Scan from Volume Root directories and create a Newsgroup object
//				for every newsgroup.
//			2) Read the NNTP\Expirations registry key and set the Newsgroup expiration policies
//				appropriately.
//			
//		After this has been completed, the Feeds will be read from the registry and each Newsgroup
//		object will be visited to set its Feed pointers.
//
//	Iteration -
//
//		In the following situations it will be necessary to enumerate newsgroups
//		in combination with some pattern string
//		(A pattern string is something in the form of 'comp.*')
//
//			Expiration Configuration - setting newsgroup expiration properties
//			Feed Configuration - setting newsgroup feed information
//			Client Requests - processing commands such as 'list comp.*' and 'newnews comp.*'
//
//		To support this file will defined a CGroupIterator class which can handle
//		all of these requests.   This CGroupIterator will be able to work its way through an
//		Alphabetically sorted list of newsgroup (held by CNewsTree) and check that each
//		newsgroup meets the pattern matching requirements.  Each time somebody with
//		a CGroupIterator object calls its Next() function, the iterator will start examining
//		from its current position in the list to find the next valid CNewsGroup object.
//
//		This is done in terms of an Iteration function instead of a call back for the following
//		reasons :
//			1) When processing Client Requests the session code will want to be able to build
//			partial results to send to the Client.
//
//
//  Implementation Schedule for all classes defined by this file :
//
//		Milestone 1 related work ;
//			Build complete tree of objects, and save articles in news groups 	1w  dev and test
//			(Unit Test : An .exe that will build the entire CNewsTree structure in memory and
//			do multi-threaded searches in that structure.)
//
//		Milestone 2 related work :
//			Expire articles from the news tree	1w dev and test
//			(Unit test : an .exe that will build entire CNewsTree structure in memory, and will start
//			deleting articles.)
//
//		Milestone 3 related work :
//			Newsgroup spread across volumes and iteration through newsgroups based on pattern match strings.
//			(This covers the CGroupIterator class)
//			Time Estimate : 2weeks dev. and test
//
//		Milestone 4 related work :
//			Caching of group information, especially CArticle objects.
//	
--*/




#ifndef	_NEWSGRP_H_
#define	_NEWSGRP_H_


#include    "smartptr.h"
#include    "string.h"
#include	"fhash.h"
#include	"rwnew.h"
#include	"addon.h"

// built from news\server\newstree\src\newstree.idl
// both are in news\core\include
#include	"group.h"
#include 	"nwstree.h"

class	CArticle ;
class	CArticleRef ;
class	COutFeed ;
class	CArticleCore ;
class	CToClientArticle ;

// extern	CXoverCache	gXCache ;

typedef CRefPtr< CArticle > CARTPTR ;
typedef CRefPtr< COutFeed > COUTFEEDPTR ;
typedef	CRefPtr< CArticle >	CARTPTR ;
typedef	CRefPtr< CToClientArticle >	CTOCLIENTPTR ;

//
//	Utility functions
//
extern	DWORD	Scan(	char*	pchBegin,	char	ch,	DWORD	cb ) ;
extern	DWORD	ScanEOL(	char*	pchBegin,	DWORD	cb ) ;
extern	DWORD	ScanEOLEx(	char*	pchBegin,	DWORD	cb ) ;
extern	DWORD	ScanTab(	char*	pchBegin,	DWORD	cb ) ;
extern	DWORD	ScanWS(	char*	pchBegin,	DWORD	cb ) ;
extern  DWORD	ScanDigits(	char*	pchBegin,	DWORD	cb ) ;
extern  DWORD   ScanNthTab( char* pchBegin, DWORD nTabs ) ;
extern	void	BuildVirtualPath(	LPSTR	lpstrOut,	LPSTR	lpstrGroupName ) ;

#define	CREATE_FILE_STRING	"\\\\?\\"

//
//	This is a protototype for a function that will be called during
//	shutdown. This is needed to send stop hints to SCM
//
typedef	void	(*	SHUTDOWN_HINT_PFN)(	void	) ;

//---------------------------------
//
//  This section defines some basic info which
//  needs to be specified in other header files.
//


#define	FIRST_RESERVED_GROUPID	1
#define	LAST_RESERVED_GROUPID	256
#define	FIRST_GROUPID			257
#define MAX_HIGHMARK_GAP		100000

class	CNewsGroup : public CNewsGroupCore {

	friend CGroupIterator;

//
//	A CNewsGroup object represents one newsgroup.
//	Newsgroups are accessed through 3 mechanisms that are
//	supported in CNewsTree -
//	
//	Hash Table by newsgroup name
//	Hash Table by newsgroup id
//	CGroupIterator - iterate through all newsgroups alphabetically
//
//	We store everything that represents a newsgroup.
//	In some cases such as for moderators and descriptive text,
//	the data references locations within a Memory Mapping
//	managed by a CAddon derived object.  In these cases
//	we must carefully synchronize access to the info.
//
private :

	FILETIME m_time;

    //
    //  Expire time horizon
    //
    FILETIME    m_ftExpireHorizon;

	//
	//	Determine whether this newsgroup is Read Only
	//
	inline	BOOL	IsReadOnlyInternal() ;

	//
	//	Determine whether this newsgroup requires SSL
	//
	inline	BOOL	IsSecureGroupOnlyInternal() ;

	//
	//	Determine if key size is secure enough for this newsgroup
	//
	inline	BOOL	IsSecureEnough( DWORD dwKeySize ) ;

	//
	//	Determine whether visibility is restricted on this newsgroup
	//
	inline	BOOL	IsVisibilityRestrictedInternal() ;

	//
	//	Function for determining whether a newsgroup is accessible
	//	by a client, assumes all the necessary locks are held when
	//	called !!!
	//
	BOOL	IsGroupAccessibleInternal(	
						class	CSecurityCtx&	ClientLogon,	
						class	CEncryptCtx&	SslContext,	
						BOOL			IsClientSecure,
						BOOL			fPost,
						BOOL			fDoTest = FALSE
						) ;


#if 0
	//
	//	Locking functions - control access to fields that vary
	//	as virtual roots are changed.
	//
	//	Grab the lock for this newsgroup in shared mode
	//
	inline	void	VrootInfoShare() ;
	//	
	//	release the lock from shared mode
	//
	inline	void	VrootInfoShareRelease() ;
	//
	//	grab the lock for vroot info exclusively
	//
	inline	void	VrootInfoExclusive() ;
	//
	//	release the lock from exclusive mode
	//
	inline	void	VrootInfoExclusiveRelease() ;
#endif


	//
	//	Helper function for generating file system article ids that
	//	optimize CreateFile() performance.
	//
	inline	DWORD	ByteSwapper( DWORD ) ;

	//
	//	This function mucks with bits in articleid's so that when
	//	we create/open files we get good performance from CreateFile()
	//	on NTFS systems.  (Results in file names which give better
	//	performance with the OS's poorly balanced B-Trees)
	//	
	inline	ARTICLEID	ArticleIdMapper( ARTICLEID ) ;

    //
    // Private Interface for CNewsTree for hashing CNewsGroup objects.
    //
    friend      class   CNewsTree ;

    // for debugger extension
	friend		CNewsGroup* DbgPrintNewsgroup(CNewsGroup * pSrcGroup);

public :

	//------------------------------------
    //  Initialization Interface -
    //   The following functions are used to create & destroy newsgroup objects.
    //
    // Lightweight Constructors -
    // These constructors do very simple initialization.  The Init() functions
    // need to be called to get a functional newsgroup.
    //
    CNewsGroup(CNewsTreeCore *pNewsTree) :
    	CNewsGroupCore(pNewsTree) {}

    BOOL    Init(	char *szVolume,
					char *szGroup,
					char *szNativeGroup,
					char *szVirtualPath,
					GROUPID	groupid,
					DWORD	dwAccess,
					HANDLE	hImpersonation,
					DWORD	dwFileSystem,
					DWORD   dwSslAccess = 0,
					DWORD   dwContentIndexFlag = 0
					) ;

	BOOL	SetArticleWatermarks();

	//-------------------------------------
	// Feed Interfaces
	//	These interfaces are used to Get and Set the feeds that are in this
	//	newsgroup object.
	//
	
	//
	// The following two functions tells can be used to get and set
	//	the feed to the Master Server for this newsgroup.
	//	If there is no COutMasterFeed for the newsgroup, then
	//	this newsgroup will generate its own article id's.
	//
	//COutMasterFeed*	SetMasterFeed( COutMasterFeed *pMaster ) ;
	//COutMasterFeed*	GetMasterFeed( ) ;

	//
	// This function should only be used when changing the configuration of
	//	feeds on the server, in particular when adding a feed to this server.
	//
	//BOOL	InsertFeed( COutFeed* pFeed ) ;

	BOOL			GetRealPath(	char*	lpstrPath,	DWORD&	cbPath	) ;


	//------------------------------------
	//  Article Management Interface -
	//   The following functions allow the caller to manipulation
	//	 Articles within the newsgroup.
	
	//
	// Call this function when you wish to read the article into memory.
	// This function will create a memory mapping and the use this to
	// initialize a CArticle.  This class may cache CArticle's.
	//
	CTOCLIENTPTR
	GetArticle(
				ARTICLEID		artid,
				IN	STOREID&	storeid,
				CSecurityCtx*	pSecurity,
				CEncryptCtx*	pEncrypt,
				BOOL			fCacheIn
				)	;

	//	
	//	This function will retrieve an article from the driver !
	//
	BOOL			GetArticle(	IN	ARTICLEID	artid,
								IN	CNewsGroup*	pCurrentGroup,
								IN	ARTICLEID	artidCurrent,
								IN	STOREID&	storeid,
								IN	class	CSecurityCtx*	pSecurity,
								IN	class	CEncryptCtx*	pEncrypt,
								IN	BOOL	fCache,
								OUT	FIO_CONTEXT*	&pContext,
								IN	CNntpComplete*	pComplete
								) ;

	//
	// retrieve article with a different fInit function
	//
	CToClientArticle *  GetArticle(
                CNntpServerInstanceWrapper  *pInstance,
				ARTICLEID		            artid,
				IN	STOREID&	            storeid,
				CSecurityCtx*	            pSecurity,
				CEncryptCtx*	            pEncrypt,
				CAllocator                  *pAllocator,
				BOOL			            fCacheIn );
		
	void			CalibrateWatermarks( ARTICLEID	LowestFound, ARTICLEID HighestFound ) ;

	//
	//	Copy an article into the tree, doing necessary security stuff !
	//
	BOOL			InsertArticle(
							CArticle *pArticle,
							void *pGrouplist,
							DWORD dwFeedId,
							ARTICLEID,
							LPSTR	lpstrFileName,
							class	CSecurityCtx*	pSecurity,
							BOOL	fIsSecureSession,
							const char *multiszNewsgroups
							) ;

	//
	//	Create an ArticleFile and do the necessary IO to create an article -
	//	this is used when incoming articles are small enough to fit in memory cache !
	//
	BOOL			InsertArticle(
							CArticle *pArticle,
							void *pGrouplist,
							DWORD dwFeedId,
							ARTICLEID,
							char*	pchHead,
							DWORD	cbHead,
							char*	pchBody,
							DWORD	cbBody,
							class	CSecurityCtx*	pSecurity,
							BOOL	fIsSecureSession,
							const char *multiszNewsgroups
							) ;

	//
	//	Interface for saving Xover Data into index files !
	//
	inline
	BOOL			AddXoverData(	
							ARTICLEID	article,
							LPBYTE		lpb,
							DWORD		cb
							) ;


	//
	//	Interface used by XOVER cache for doing cache fills !
	//
	void
	FillBufferInternal(
					IN	ARTICLEID	articleIdLow,
					IN	ARTICLEID	articleIdHigh,
					IN	ARTICLEID*	particleIdNext,
					IN	LPBYTE		lpb,
					IN	DWORD		cbIn,
					IN	DWORD*		pcbOut,
					IN	CNntpComplete*	pComplete
					)	;

	//
	//	Interface for getting Xover data from the index files !
	//
	void			FillBuffer(
							IN	class	CSecurityCtx*	pSecurity,
							IN	class	CEncryptCtx*	pEncrypt,
							class	CXOverAsyncComplete&	complete
							) ;

    //
    // Interface for getting xhdr data from the index files !
    //
    void            FillBuffer(
				            IN	class	CSecurityCtx*	pSecurity,
				            IN	class	CEncryptCtx*	pEncrypt,
				            IN	class	CXHdrAsyncComplete&	complete
				            );

	//
	//	Interface for getting Xover data for the search command
	//
	void			FillBuffer(
							IN	class	CSecurityCtx*	pSecurity,
							IN	class	CEncryptCtx*	pEncrypt,
							class	CSearchAsyncComplete&	complete
							) ;

	//
	//	Interface for getting Xhdr data for the xpat command
	//
	void			FillBuffer(
							IN	class	CSecurityCtx*	pSecurity,
							IN	class	CEncryptCtx*	pEncrypt,
							class	CXpatAsyncComplete&	complete
							) ;


	//
	//	Interface for getting Listgroup data from the index files !
	//
	inline
	DWORD			ListgroupFillBuffer(
							LPBYTE		lpb,
							DWORD		cb,
							ARTICLEID	artidStart,
							ARTICLEID	artidFinish,
							ARTICLEID	&artidLast,
							HXOVER		&hXover
							) ;


	//
	//	Interface for expiring an Xover entry from an index file !	
	//
	inline
	BOOL			ExpireXoverData( ) ;

	//
	//	Interface for getting rid of all xover index files !
	//
	BOOL			DeleteAllXoverData() ;

	//
	//	Interface for flushing all entries for this group
	//
	inline
	BOOL			FlushGroup( ) ;

	//
	//	Interface for deleting an Xover entry - use for cancel'd articles !
	//
	inline
	BOOL			DeleteXoverData(
							ARTICLEID	article
							) ;

    // Physically (and Logically) remove an article from the news tree. This
    // function only affects the news tree. Other data structure that keep
    // information pointing to this article need to be changed before calling
    // this function. Of course, physical deletion implies primary group.
    //
    BOOL           ExpireArticles( FILETIME ftExpireHorizon, class CArticleHeap &ArtHeap, class CXIXHeap &XixHeap, DWORD &dwSize );
    BOOL           ExpireArticlesByTime( FILETIME ftExpireHorizon );
    BOOL           ExpireArticlesByTimeSpecialCase( FILETIME ftExpireHorizon );
    BOOL           ProbeForExpire( ARTICLEID ArtId, FILETIME ftExpireHorizon );
    ARTICLEID      CalcHighExpireId( ARTICLEID LowId, ARTICLEID HighId, FILETIME ftExpireHorizon, DWORD NumThreads );
    BOOL           ExpireArticlesByTimeEx( FILETIME ftExpireHorizon );
    BOOL           DeleteArticles( SHUTDOWN_HINT_PFN pfnHint = NULL, DWORD dwStartTick = 0 );
    BOOL           DeletePhysicalArticle( HANDLE, BOOL, ARTICLEID, STOREID* );
    BOOL           DeleteLogicalArticle( ARTICLEID );
    BOOL           RemoveDirectory();
	

	//
	//	This function is for use when rebuilding the server, we will rescan the newsgroups
	//	and rebuild the high low watermarks, as well as the count of articles.
	//	This function will reset the count of articles back to 0.
	//
	inline	void		ResetCount() {
		SetMessageCount(0);
	}

	//
	// Call this function to create an article in the Newsgroup
	// with an article id of ARTICLEID which is
	// a reference to another Article in another Newsgroup.  This will be
	// used when processing Cross Posted Articles.
	//

	//
	//	Copy moderator's name into a buffer - returns number
	//	of bytes copied.
	//	This function will try to grab a lock before copying the
	//	data
	//
	DWORD	CopyModerator(	char*	lpbDestination,	DWORD	cbSize ) ;

	//
	//	Copy prettyname into a buffer - returns number
	//	of bytes copied.
	//	This function will try to grab a lock before copying the
	//	data
	//
	DWORD	CopyPrettyname(	char*	lpbDestination,	DWORD	cbSize ) ;

	//
	//	This function copies the prettyname without the terminating CRLF appended !
	//
	DWORD	CopyPrettynameForRPC(	char*	lpstrPrettyname, DWORD	cbPrettyname ) ;

	//
    // Command interface - used to implement NNTP commands
    //

	//
	//	This function copies whatever help text we have for a group
	//	into a buffer
	//
	DWORD	CopyHelpText(	char*	lpbDestination,	DWORD	cbSize ) ;

	//
	//	This function copies the help text without the terminating CRLF appended !
	//
	DWORD	CopyHelpTextForRPC(	char*	lpbDestintation,	DWORD	cbSize ) ;

	//
	//	Determine whether this newsgroup is Read Only
	//
	inline	BOOL	IsReadOnly();

	//
	//	Determine whether visibility is restricted on this newsgroup
	//
	inline	BOOL	IsVisibilityRestricted() ;

	//
	//	Determine whether this newsgroup requires SSL
	//
	inline	BOOL	IsSecureGroupOnly() ;

	BOOL	IsGroupVisible(
					class CSecurityCtx&	ClientLogon,
					class CEncryptCtx&  ClientSslLogon,
					BOOL			IsClientSecure,
					BOOL			fPost,
					BOOL			fDoTest = FALSE
					) ;

	//
	//	Check whether a newsgroup is accessible
	//
	BOOL	IsGroupAccessible(	
						class	CSecurityCtx&	ClientLogon,	
						class	CEncryptCtx&	SslContext,	
						BOOL			IsClientSecure,
						BOOL			fPost,
						BOOL			fDoTest = FALSE
						) ;

	//
	//	If TRUE, nntpbld will rebuild this group by scanning articles on disk !
	//
	BOOL		m_fRebuild;

	//
	//	This function returns the character that should be displayed
	//	next to the newsgroup in response to a list active command !
	//
	inline	char	GetListCharacter() ;

	//
	//	Number of articles in newsgroup
	//
    inline  DWORD GetArticleEstimate() ;

	//
	//	Smallest ARTICLEID in group
	//
    inline  ARTICLEID GetFirstArticle() ;

	//
	//	Largest ARTICLEID in group
	//
    inline  ARTICLEID GetLastArticle() ;

	//
	//
	//
	inline	DWORD	FillNativeName(char*	szBuff, DWORD	cbSize)	{
		LPSTR	lpstr = GetNativeName() ;
		DWORD	cb = strlen( lpstr ) ;
		if( cbSize >= cb ) {
			CopyMemory( szBuff, GetNativeName(), cb ) ;
			return	cb ;
		}
		return	0 ;
	}

	//
	//	Get owning newstree object
	//
	//inline  CNewsTree* GetTree();

	//
	//	Set GROUPID for newsgroup
	//
    inline  void         SetGroupId( GROUPID groupid ) {
		_ASSERT(FALSE);
	}
	
	//
	//	Reference to newsgroup name
	//	
    inline  LPSTR&       GetGroupName() {
		return GetName();
	}

    inline  LPCSTR       GetNativeGroupName() {
		return GetNativeName();
	}

	//
	//	Time newsgroup was created
	//
	FILETIME	GetGroupTime() ;
	void		SetGroupTime(FILETIME ft);

	//
	//	Expire time horizon for this group
	//
    FILETIME	    GetGroupExpireTime() { return m_ftExpireHorizon; }
    inline VOID     SetGroupExpireTime(FILETIME ft) { m_ftExpireHorizon = ft; }

	//
	//	Compute the hash value of a newsgroup name
	//
    static	DWORD   ComputeNameHash( LPSTR  lpstr ) {
		return CNewsGroupCore::ComputeNameHash(lpstr);
	}

	//
	//	Compute the hash value of a newsgroup id
	//
    static	DWORD   ComputeIdHash( GROUPID  group ) {
		return CNewsGroupCore::ComputeIdHash(group);
	}

	//
	//	During Boot recovery this function will scan the newsgroups
	//	directory and re-enter all of the article files into hash tables etc...
	//
	BOOL	ProcessGroup(	class	CBootOptions*	pOptions,
							BOOL	fParseFile
							) ;

	BOOL	ProcessGroupEx(	class	CBootOptions*	pOptions ) ;

    //
    // Scan current directory for all *.xix files and return
    // the xixLowestFound and xixHighestFound
    //
    BOOL    ScanXoverIdx( OUT ARTICLEID&  xixLowestFound, OUT ARTICLEID&  xixHighestFound );

    BOOL    ParseXoverEntry( CBootOptions*       pOptions,
                             IN PCHAR            pbXover,
                             IN DWORD            cbXover,
                             IN OUT GROUPID&     groupid,
                             IN OUT ARTICLEID&   LowestFound,
                             IN OUT ARTICLEID&   HighestFound,
                             IN OUT int&         cArticle,
                             IN OUT BOOL&        fCheckNative );
} ;

#if 0
//
//	Inline functions for the CNewsGroup Class
//
//
//

// Return the GROUPID of the Newsgroup
inline	GROUPID&
CNewsGroup::GetGroupId()	{
	return	m_groupid ;
}

inline	void
CNewsGroup::SetGroupId( GROUPID groupid)	{
	m_groupid = groupid ;
}

// Return the Name of the Newsgroup
inline	LPSTR&
CNewsGroup::GetGroupName( )		{
	return	m_lpstrGroup ;
}

// Return the Native name of the Newsgroup - if we have one
inline	LPSTR&
CNewsGroup::GetNativeGroupName( )		{
	return (m_lpstrNativeGroupName ? m_lpstrNativeGroupName : m_lpstrGroup);
}

//
// The following typedefs define types that are used within the CNewsTree
//  class, and may be returned by it.
//
#endif

typedef CRefPtr2< CNewsGroup >               CGRPPTR ;
typedef CRefPtr2HasRef< CNewsGroup >               CGRPPTRHASREF ;

//
//	Function for matching Newsgroups - all Negations must precede all other pattern matching strings !
//
extern		BOOL	MatchGroup( LPMULTISZ	multiszPatterns,	CGRPCOREPTR	pGroup ) ;	
extern		BOOL	MatchGroupList(	LPMULTISZ	multiszPatterns,	LPMULTISZ	multiSzNewgroups ) ;




//-----------------------------------------------------------
//
// This class is used to find CNewsGroup objects.   There should only
// ever exist one object of this class.
//
// Group's can be found through two means :
//   1) Use the name of the group as it appears in an article
//	 2) Using a Group ID number
//
// Group ID Numbers are used in Article Links.  A link from one article to another
// will contain a Group ID Number and Article Number to represent the link.
//
// We will maintain a Hash Table to find CNewsGroup objects based on newsgroup name.
// We will also maintain a Hash Table to find CNewsGroup objects based on Group ID.
//
// Finally, we will maintain a doubly linked list of CNewsGroups which is sorted by
//	name.  This linked list will be used to support pattern matching iterators.
//
class	CNewsTree: public CNewsTreeCore	{
private :

	friend	class	CGroupIterator ;
	friend	class CNewsGroup;
	friend	NNTP_IIS_SERVICE::InitiateServerThreads();
	friend  NNTP_IIS_SERVICE::TerminateServerThreads();

	friend  VOID DbgPrintNewstree(CNewsTree* ptree, DWORD nGroups);

	//
	//	Pointer to owning virtual server
	//
	PNNTP_SERVER_INSTANCE	m_pInstance ;

	//
	//	Handle to thread which crawls through newsgroups
	//
	static HANDLE	m_hCrawlerThread ;

	//
	//	Handle to event used to terminate crawler thread
	//
	static HANDLE	m_hTermEvent ;

	//
	//	Crawler thread - top level function of thread
	//
	static	DWORD	__stdcall	NewsTreeCrawler( void* ) ;

    BOOL    Init( PNNTP_SERVER_INSTANCE	pInstance, BOOL& fFatal );

protected:
	CNewsGroupCore *AllocateGroup() {
		return XNEW CNewsGroup(this);
	}

public :
	
	//-----------------------------
	// Initialization Interface - functions for getting the CNewsTree into memory,
	//  and load all our configuration information at server startup.
	//

    CNewsTree( INntpServer *pServerObject) ;
	CNewsTree( CNewsTree& ) ;
	~CNewsTree() ;
	
    inline	CNewsTree*	GetTree() { return this; }

	//
	//	Create the initial news tree the server will work with.
	//
	static	BOOL  InitCNewsTree( PNNTP_SERVER_INSTANCE pInstance,
								 BOOL& fFatal);

	//
	//	Expire articles in this tree's virtual server instance
	//
	static	BOOL		ExpireInstance(
								PNNTP_SERVER_INSTANCE	pInstance
								) ;

    //
    //  Begin/End an expire job on this tree
    //
    void    BeginExpire( BOOL& fDoFileScan );
    void    EndExpire();
    void    CheckExpire( BOOL& fDoFileScan );

	//
	//	Update the vroot info of all newsgroups in the tree
	//
	void	UpdateVrootInfo() ;

	//
	//	Stop all background processing - kill any threads we started etc...
	//
    BOOL        StopTree();

	//
	//	Get owning virtual server instance
	//
	inline PNNTP_SERVER_INSTANCE GetVirtualServer() { return m_pInstance; }

	//
	//	Copy the file containing newsgroups to a backup
	//
	void	RenameGroupFile( ) ;

#if 0
	// One critical section used for allocating article id's !!
	CRITICAL_SECTION	m_critLowAllocator ;
	CRITICAL_SECTION	m_critIdAllocator ;
#endif

	//
	//	Number of Locks we are using to protect access to
	//	our m_lpstrPath and fields
	//
	DWORD		m_NumberOfLocks ;

#if 0
	//
	//	Pointer to array of locks - reference by computing
	//	modulus of m_groupId by gNumberOfLocks
	//
#ifdef	_USE_RWNH_
	CShareLockNH*	m_LockPathInfo ;
#else
	CShareLock*	m_LockPathInfo ;
#endif
#endif

	//
	//	Variable to indicate that we wish background threads to STOP
	//
    volatile BOOL        m_bStoppingTree; // TRUE when the crawler thread should abbreviate it's work.

    //
    //  Count of number of expire by time cycles on this tree
    //
    DWORD                m_cNumExpireByTimes;

    //
    //  number of times we expired by find first/next
    //
    DWORD                m_cNumFFExpires;

	//
	//	Indicate to background threads that the newstree has changed and needs to be saved.
	//
	void	Dirty() ;	// mark the tree as needing to be saved !!


#if 0
	//
	//	Used during bootup to figure out what the range of GROUPID's in the
	//	group file is.
	//
	void	ReportGroupId( GROUPID	groupid ) ;
#endif

	
	//
	//	Check that the group.lst file is intact - this verifies the checksum.
	//	This code is used by the chkhash/boot recovery code.
	//
	BOOL	VerifyGroupFile() ;

	//
	//	Delete the group.lst file, whatever its actual name may be.
	//	We do this when we want to rebuild all the server data structures from scratch.
	//
	BOOL	DeleteGroupFile() ;
	
		


	//---------------------------------
	// Group Location Interface - find a news Group for an article
	//

	// Find an article based on a string and its length
	CGRPPTRHASREF GetGroup(const char *szGroupName, int cch ) {
		CGRPCOREPTR p = CNewsTreeCore::GetGroup(szGroupName, cch);
		return (CNewsGroup *) ((CNewsGroupCore *) p);
	}
	CGRPPTRHASREF GetGroupPreserveBuffer(const char	*szGroupName, int cch ) {
		CGRPCOREPTR p = CNewsTreeCore::GetGroupPreserveBuffer(szGroupName, cch);
		return (CNewsGroup *) ((CNewsGroupCore *) p);
	}
	
	// Find a newsgroup given an CArticleRef
	CGRPPTRHASREF GetGroup( CArticleRef& art) {
		CGRPCOREPTR p = CNewsTreeCore::GetGroup(art);
		return (CNewsGroup *) ((CNewsGroupCore *) p);
	}
	
	// Find a newsgroup based on its GROUPID
	CGRPPTRHASREF GetGroupById( GROUPID id, BOOL fFirm = FALSE  ) {
		CGRPCOREPTR p = CNewsTreeCore::GetGroupById(id, fFirm );
		return (CNewsGroup *) ((CNewsGroupCore *) p);
	}
	
	GROUPID	GetSlaveGroupid() ;

	// Find the parent of a newsgroup
	CGRPPTRHASREF GetParent( IN  char* lpGroupName,
					   IN  DWORD cbGroup,
					   OUT DWORD& cbConsumed
					   )
	{
		CGRPCOREPTR p = CNewsTreeCore::GetParent(lpGroupName,
											     cbGroup,
												 cbConsumed);
		return (CNewsGroup *) ((CNewsGroupCore *) p);
	}
    //
    // The following function takes a list of strings which are
	// terminated by a double NULL and builds an iterator object
	// which can be used examine all the group objects.
    //
    CGroupIterator  *GetIterator(	LPMULTISZ	lpstrPattern,	
									BOOL		fIncludeSecureGroups = FALSE,
									BOOL		fIncludeSpecialGroups = FALSE,
									class CSecurityCtx* pClientLogon = NULL,
									BOOL		IsClientSecure = FALSE,
									class CEncryptCtx* pClientSslLogon = NULL
									) ;

	//----------------------------------
	//	Active NewsGroup Interface - Specify an interface for generating a
	//  list of active newsgroups and estimates of their contents.
	//
    CGroupIterator	*ActiveGroups( 	BOOL		fIncludeSecureGroups = FALSE,
									class CSecurityCtx* pClientLogon = NULL,
									BOOL		IsClientSecure = FALSE,
									class CEncryptCtx* pClientSslLogon = NULL,
                                    BOOL        fReverse = FALSE
									) ;	

	//----------------------------------
    // Group Control interface - These functions can be used to remove
    // and add newsgroups.

    //
    // RemoveGroup is called once we've parsed an article that kills
    // a newsgroup or the Admin GUI decides to destroy an article.
    //
    BOOL RemoveGroup( CGRPPTR    pGroup ) ;

#if 0
	//
	// Remove a group directory
	//
	inline BOOL RemoveDirectory( CGRPPTR pGroup );
#endif

#if 0
    //
    // CreateGroup is called with the name of a new newsgroup which we've
    // gotten through a feed or from Admin. We are given only the name
    // of the new newsgroup.  We will find the parent group by removing
    // trailing ".Group" strings from the string we are passed.
    // We will clone the properties of this newsgroup to create our new
    // newsgroup.
    //
    BOOL    CreateGroup( LPSTR      lpstrGroupName,	BOOL	fIsAllLowerCase	) ;
#endif

	BOOL	CreateDirectoryPath(	
				LPSTR	lpstr,
				DWORD	cbValid,
				LPSTR&	lpstrOut,
				LPSTR   lpstrGroup,
				CGRPPTR *ppGroup,
				BOOL&	fExists
				) ;

	//
	//	Build all of the newsgroups from a list active file on disk somewhere !
	//
	BOOL	BuildTree( LPSTR	szFile ) ;
	BOOL	BuildTreeEx( LPSTR	szFile ) ;
    BOOL    HashGroupId( CNewsGroup *pGroup ) ;

	//
	//	Check whether a GROUPID is in the 'special' range
	//

	inline	BOOL	IsSpecial( GROUPID	groupid ) ;


	//
	//	For use by CNewsGroup objects only !!
	//
	//	LockHelpText - lock the text in the description object
	//	so that we don't it doesn't change while we try to read it !
	//
	inline	void	LockHelpText() ;
	//	
	//	reverse of LockHelpText()
	//
	inline	void	UnlockHelpText() ;
	//
	//	Lock moderator object in shared mode to access contents
	//
	inline	void	LockModeratorText() ;
	//
	//	unlock CModerator object
	//
	inline	void	UnlockModeratorText() ;
	//
	//	Lock prettynames object in shared mode to access contents
	//
	inline	void	LockPrettynamesText() ;
	//
	//	unlock CPrettyname object
	//
	inline	void	UnlockPrettynamesText() ;

	//
	//	The following functions will add and delete moderator and description
	//	entries.
	//	These are for use by the Admin RPC's which set this information !
	//

    //
    //  Set m_idHigh
    //
    inline  void        InterlockedResetGroupIdHigh( void );
    inline  void        InterlockedMaxGroupIdHigh( GROUPID groupid );
    inline  GROUPID     InterlockedIncrementGroupIdHigh( void );

    void    Remove( CNewsGroup *pGroup ) ;
    void    RemoveEx( CNewsGroup *pGroup ) ;
} ;

//	wildmat strings have the following pattern matching elements :
//		Range of characters ie:  com[p-z]
//		Asterisk ie:	comp.*   (matches all newsgroups descended from 'comp')
//		Negations ie:	!comp.*  (excludes all newsgroups descended from 'comp' )
//
//	The CGroupIterator will implement these semantics in the following way :
//
//		All newsgroups are held in the CNewsTree object in a doubly linked list in alphabetical order.
//		The CGroupIterator will hold onto a CRefPtr2<> for the current newsgroup.
//		Because the CNewsGroup objects are reference counted, the current newsgroup can never be destroyed from
//		underneath the iterator.
//
//		When the user calls the Iterator's Next() or Prev() functions, we will simply follow next pointers
//		untill we find another newsgroup which matches the pattern and to which the user has access.
//
//		In order to determine whether the any given newsgroup matches the specified pattern, we will use the
//		wildmat() function that is part of the INN source.  We will have to call the wildmat() function for each
//		pattern string until we get a succesfull match.
//

class	CGroupIterator : public CGroupIteratorCore {
private:

	// visibility check
	CSecurityCtx*	m_pClientLogon ;
	CEncryptCtx*	m_pClientSslLogon ;
	BOOL			m_IsClientSecure ;
	BOOL			m_fIncludeSecureGroups;

	//
	//	Only the CNewsTree Class can create CGroupIterator objects.
	//
	friend	class	CNewsTree ;
	//
	//	Constructor
	//	
	//	The CGroupIterator constructor does no memory allocation - all of the arguments
	//	passed are allocated by the caller.  CGroupIterator will destroy the arguments within
	//	its destructor.
	//
	CGroupIterator(	
				CNewsTree*  pTree,
				LPMULTISZ	lpPatterns,
				CGRPCOREPTR &pFirst,
				BOOL		fIncludeSecureGroups,
				BOOL		fIncludeSpecial,
				class CSecurityCtx* pClientLogon = NULL,	// NON-NULL for visibility check
				BOOL		IsClientSecure = FALSE,
				class CEncryptCtx*  pClientSslLogon = NULL
				);

	CGroupIterator(
				CNewsTree*  	pTree,
				CGRPCOREPTR		&pFirst,
				BOOL			fIncludeSecureGroups,
				class CSecurityCtx* pClientLogon = NULL,	// NON-NULL for visibility check
				BOOL	IsClientSecure = FALSE,
				class CEncryptCtx*  pClientSslLogon = NULL
				);

public :
	CGRPPTRHASREF Current() {
		CGRPCOREPTR p = CGroupIteratorCore::Current();
		return (CNewsGroup *) ((CNewsGroupCore *) p);
	}

	virtual void	__stdcall Next() ;
	virtual void	__stdcall Prev() ;

    // Check if two iterators meet each other
	BOOL    Meet( CGroupIterator *iter )  {
	    return m_pCurrentGroup == iter->m_pCurrentGroup;
	}
} ;

#include    "newsgrp.inl"


#endif	// _NEWSGRP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\newwild.cpp ===
#include	"tigris.hxx"
#include "wildmat.h"

//---[ Description of the Wildmat standard ]-----------------------------------
//
//  Taken from:
//
//  INTERNET-DRAFT                                               S. Barber
//  Expires: September 1, 1996                  Academ Consulting Services
//                                                              April 1996
//                           Common NNTP Extensions
//                        draft-barber-nntp-imp-03.txt
//  
//      The WILDMAT format was first developed by Rich Salz to provide
//      a uniform mechanism for matching patterns in the same manner
//      that the UNIX shell matches filenames. There are five pattern
//      matching operations other than a strict one-to-one match
//      between the pattern and the source to be checked for a match.
//      The first is an asterisk (*) to match any sequence of zero or
//      more characters. The second is a question mark (?) to match any
//      single character. The third specifies a specific set of
//      characters. The set is specified as a list of characters, or as
//      a range of characters where the beginning and end of the range
//      are separated by a minus (or dash) character, or as any
//      combination of lists and ranges. The dash can also be included
//      in the range as a character it if is the beginning or end of
//      the range. This set is enclosed in square brackets. The close
//      square bracket (]) may be used in a range if it is the first
//      character in the set. The fourth operation is the same as the
//      logical not of the third operation and is specified the same
//      way as the third with the addition of a caret character (^) at
//      the beginning of the test string just inside the open square
//      bracket. The final operation uses the backslash character to
//      invalidate the special meaning of the a open square bracket ([),
//      the asterisk, or the question mark.
//  
//  3.3.1 Examples
//  
//      a. [^]-] -- matches any character other than a close square bracket
//                  or a minus sign/dash.
//  
//      b. *bdc  -- matches any string that ends with the string "bdc"
//                  including the string "bdc" (without quotes).
//  
//      c. [0-9a-zA-Z] -- matches any string containing any alphanumeric string
//                  in English.
//  
//      d. a??d  --  matches any four character string which begins
//                   with a and ends with d.
//  
//-----------------------------------------------------------------------------



//----[ NOTES ]----------------------------------------------------------------
//                                                                            
// 		This function will raise an invalid access exception if either pszText                                                     
// 		or pszPattern is invalid or not null terminated while dereferencing the                                                    
// 		string. If this is possible, surround the call in a try-except block.                                                      
//  
//-----------------------------------------------------------------------------



//---[ Defines ]---------------------------------------------------------------

#define STACK_SIZE      256



//---[ HrMatchWildmat ]--------------------------------------------------------
//
//  Description:
//
//      Provides support for the "Wildmat" wild-card matching standard. See
//      description above.
//
//  Params:
//
//      pszText         String to test
//      pszPattern      Pattern to test against
//
//  Returns:
//      
//      ERROR_SUCCESS               If function succeeded, and match was found
//      ERROR_INVALID_PARAMETER     Text or pattern string is invalid
//      
//      ERROR_CAN_NOT_COMPLETE      Some other error occurred.
//
//  
//-----------------------------------------------------------------------------


HRESULT HrMatchWildmat(const char* pszText, const char* pszPattern)
{


	_ASSERT(pszText != NULL && pszPattern != NULL);



	BOOL fCharSet = FALSE;	// TRUE if currently parsing a character set in a pattern
	BOOL fNegated = FALSE;	// TRUE if there is a '^' at the beginning of the set
	BOOL fInSet   = FALSE;  // indicates when matching of a character set has completed
				// used to short-circuit character set evaluation
	int iStackPtr = 0;	// stack pointer
    
	const char* textStack[STACK_SIZE];	// stack of text pointers
	const char* patternStack[STACK_SIZE];	// stack of pattern pointers


	// If the pattern consists solely of a * then any text will match
	if (strcmp(pszPattern, "*") == 0)
		return ERROR_SUCCESS;


	while (TRUE) 
    {
		switch (*pszPattern) 
        {
		    case '*':
		    	if (fCharSet) 
                    goto DEFAULT;	// according to unix solution this is not an error
                    

				// If there is a * at the end of the pattern then at this point we are
				// sure that we got a match
				if (pszPattern[1] == '\0')
					return ERROR_SUCCESS;


				// We could write a simpler recursive wildmat function. Here we would
				// recursively call wildmat. Instead, for performance reasons this
				// solution is iterative.
				// Here we save the current values of the text pointer and stack pointer
				// on a stack and we leave the * in the pattern, with the effect of
				// matching one character with the *. The next time through the while
				// loop, the * will still be in the pattern, thus we will try to match
				// the rest of the input with this *. If it turns to fail, we go back
				// one character.
				// See the comments right before the BACK label below.
		    	if (*pszText != '\0') 
                {
		    		if (iStackPtr == STACK_SIZE) 
                        return ERROR_CAN_NOT_COMPLETE;			// stack overflow
                        
		    		textStack[iStackPtr] = pszText;			// save current text pointer
		    		patternStack[iStackPtr] = pszPattern;	// save current pattern pointer
		    		iStackPtr++;
		    		pszPattern--;	// leave * in the input pattern and match one character
		    	}
		    	break;

		    case '?':
		    	if (fCharSet) 
                    goto DEFAULT;	// according to unix solution this is not an error
		    	if (*pszText == '\0') 
                    goto BACK;
		    	break;

		    case '[':
		    	if (fCharSet) 
                    return ERROR_INVALID_PARAMETER;
                    
		    	fCharSet = TRUE;		    // beginning a character set
		    	fNegated = FALSE;			// so far we haven't seen a '^'
		    	fInSet = FALSE;				// used to short-circuit the evaluation of
		    						// membership to the character set

		    	// treat '^', '-' and ']' as special cases if they are
		    	// at the beginning of the character set (also "[^-a]" and "[^]a]")
		    	if (pszPattern[1] == '^') 
                {
		    		fNegated = TRUE;
		    		pszPattern++;
		    	}
		    	// '-' and ']' are literals if they appear at the beggining of the set
		    	if (pszPattern[1] == '-' || pszPattern[1] == ']') 
                {
		    		fInSet = (*pszText == pszPattern[1]);
		    		pszPattern++;
		    	}
		    	break;
		    		
		    case ']':
		    	if (fCharSet) 
                {
		    		if ((!fNegated && !fInSet) || (fNegated && fInSet)) 
                        goto BACK;
                        
		    		fCharSet = FALSE;		// this marks the end of a character set
		    	} 
                else 
                {
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	}
		    	break;

		    case '-':
		    	if (fCharSet) 
                {
		    		unsigned char startRange = pszPattern[-1];	// we use unsigned char
					unsigned char endRange;						// to support extended
					unsigned char ch;							// characters

		    		if (pszPattern[1] == '\0')
		    			return ERROR_INVALID_PARAMETER;
		    		else 
                    {
                        if (pszPattern[1] == ']')		// a dash at the end of the set is
		    			    fInSet = (*pszText == '-');	// treated as a literal
		    		    else 
                        {							    // we have a range
		    		    	if (pszPattern[1] == '\\')  // escape character, skip it
                            {	
		    		    		pszPattern++;
		    		    		if (pszPattern[1] == '\0') 
                                    return ERROR_INVALID_PARAMETER;
		    		    	}
							ch = *pszText;
							endRange = pszPattern[1];

							if (startRange > endRange)
								return ERROR_INVALID_PARAMETER;
							// here is where we could need unsigned characters
		    		    	fInSet = (ch >= startRange && ch <= endRange);
		    		    	pszPattern++;
		    		    	break;
		    		    }
                    }
		    	} 
                else 
                {						// outside a character set '-' has no special meaning
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	}
		    	break;

		    case '\0':					// end of the pattern
		    	if (fCharSet) 
                    return ERROR_INVALID_PARAMETER;
		    	if (*pszText == '\0')
		    		return ERROR_SUCCESS;
		    	else
		    		goto BACK;
		    	break;

		    default:				
DEFAULT:    	
                if (*pszPattern == '\\') 
                {
		    		pszPattern++;		// escape character, treat the next character as a literal
		    		if (*pszPattern == '\0') 
                        return ERROR_INVALID_PARAMETER;
		    	}
		    	if (!fCharSet) 
                {						// any other character is treated as a literal
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	} 
                else 
                {
		    		// the following if takes care of the two "special" cases:
		    		//		[c-a]       (we don't want to accept c), and
		    		//		[c-]		(we want to accept c)
		    		if (!(pszPattern[1] == '-' && pszPattern[2] != ']'))
		    			fInSet = (*pszText == *pszPattern);
		    	}
		    	break;
		} // switch

		pszPattern++;
		
        if (!fCharSet) 
        {
			if (*pszText != '\0') 
                pszText++;
		} 
        else 
        {               			// code to short-circuit character set evaluation
			if (fInSet) 			// skip the rest of the character set
            {		
				while (*pszPattern != '\0' && *pszPattern != ']') 
                {
					if (*pszPattern == '\\')
                    {				// escape character, treat the next character as a literal
						pszPattern++;
						if (*pszPattern == '\0') 
                            return ERROR_INVALID_PARAMETER;
					}
					pszPattern++;
				}
			}
		}
		continue;	// the continue statement is to jump to the beginning of the loop,
					// we could have used used goto some label but that's what continue's
					// are for.


		// This is only reached by jumping to BACK.
		// This is equivalent to returning from a recursive solution of wildmat.
		// If the stack pointer is zero then the bottommost "recursive call" failed,
		// otherwise we "unwind one stack frame" and resume execution of the previous
		// call at the top of the while loop. Notice that since "recursive calls" are
		// only done when we find a '*' in the pattern outside a character set, the
		// value of fCharSet has to be set to false.
BACK:	
        if (iStackPtr == 0)                     	// we exhausted all possibilities
            return ERROR_FILE_NOT_FOUND;
            
		iStackPtr--;						    	// try matching no characters with the '*'
		pszText = textStack[iStackPtr];
		pszPattern = patternStack[iStackPtr] + 1;	// eat the '*' matching no input characters
		fCharSet = FALSE;				        	// this has to be the case
	} // while

    // should never get here
	_ASSERT(FALSE);						
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\nnprocs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nnprocs.h

Abstract:

    This module contains function prototypes used by the NNTP server.

Author:

    Johnson Apacible (JohnsonA)     12-Sept-1995

Revision History:

    Kangrong Yan ( KangYan )    28-Feb-1998
        Added one prototype for fixed length Unicode-Ascii convertion func.

--*/

#ifndef	_NNPROCS_
#define	_NNPROCS_

#include "nntputil.h"

//
//  uuencode/uudecode
//
//  Taken from NCSA HTTP and wwwlib.
//  (Copied from Gibraltar code -johnsona)
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

class BUFFER;

BOOL
uudecode(
    char   * bufcoded,
    BUFFER * pbuffdecoded,
    DWORD  * pcbDecoded
    );

BOOL
uuencode(
    BYTE *   bufin,
    DWORD    nbytes,
    BUFFER * pbuffEncoded
    );

DWORD
NntpGetTime(
    VOID
    );

BOOL
fMultiSzRemoveDupI(
    char * multiSz,
    DWORD & c,
	CAllocator * pAllocator
    );

void
vStrCopyInc(
    char * szIn,
    char * & szOut
    );

DWORD
multiszLength(
	  char const * multisz
	  );

const char *
multiszCopy(
    char const * multiszTo,
    const char * multiszFrom,
    DWORD dwCount
    );

char *
szDownCase(
		   char * sz,
		   char * szBuf
		   );

VOID
NntpLogEventEx(
    IN DWORD  idMessage,              // id for log message
    IN WORD   cSubStrings,            // count of substrings
    IN const CHAR * apszSubStrings[], // substrings in the message
    IN DWORD  errCode,                // error code if any
	IN DWORD  dwInstanceId			  // virtual server instance id
    );

VOID
NntpLogEvent(
    IN DWORD  idMessage,              // id for log message
    IN WORD   cSubStrings,            // count of substrings
    IN const CHAR * apszSubStrings[], // substrings in the message
    IN DWORD  errCode                 // error code if any
    );

BOOL
IsIPInList(
    IN PDWORD IPList,
    IN DWORD IPAddress
    );

//
// nntpdata.cpp
//

APIERR
InitializeGlobals();

VOID
TerminateGlobals();

//
//  Socket utilities.
//

APIERR InitializeSockets( VOID );

VOID TerminateSockets( VOID );

VOID
NntpOnConnect(
    SOCKET        sNew,
    SOCKADDR_IN * psockaddr,
    PVOID         pEndpointContext,
    PVOID         pAtqEndpointObject
    );

VOID
NntpOnConnectEx(
    VOID * pAtqContext,
    DWORD  cdWritten,
    DWORD  err,
    OVERLAPPED * lpo
    );

VOID
NntpCompletion(
    PVOID        Context,
    DWORD        BytesWritten,
    DWORD        CompletionStatus,
    OVERLAPPED * lpo
    );

VOID
BuzzOff( 
	SOCKET s,
	SOCKADDR_IN* psockaddr,
	DWORD dwInstance );

BOOL
VerifyClientAccess(
			  IN CSessionSocket*	   pSocket,
			  IN SOCKADDR_IN * 		   psockaddr
			  );

//
//  IPC functions.
//

APIERR InitializeIPC( VOID );
VOID TerminateIPC( VOID );

//
// security.cpp
//

BOOL
NntpInitializeSecurity(
            VOID
            );

VOID
NntpTerminateSecurity(
            VOID
            );

//
// feedmgr.cpp
//

PFEED_BLOCK
AllocateFeedBlock(
	IN PNNTP_SERVER_INSTANCE pInstance,
    IN LPSTR	KeyName OPTIONAL,
	IN BOOL		fCleanSetup,
    IN LPCSTR	ServerName,
    IN FEED_TYPE FeedType,
    IN BOOL		AutoCreate,
    IN PULARGE_INTEGER StartTime,
    IN PFILETIME NextPull,
    IN DWORD	FeedInterval,
    IN PCHAR	Newsgroups,
    IN DWORD	NewsgroupsSize,
    IN PCHAR	Distribution,
    IN DWORD	DistributionSize,
    IN BOOL		IsUnicode,
	IN BOOL		fEnabled,
	IN LPCSTR	UucpName,
	IN LPCSTR	FeedTempDirectory,
	IN DWORD	MaxConnectAttempts,
	IN DWORD	ConcurrentSessions,
	IN DWORD	SessionSecurityType,
	IN DWORD	AuthenticationSecurityType,
	IN LPSTR	NntpAccount,
	IN LPSTR	NntpPassword,
	IN BOOL		fAllowControlMessages,
	IN DWORD	OutgoingPort,
	IN DWORD	FeedPairId,
	IN DWORD*	ParmErr
    );

BOOL
InitializeFeedManager(
				PNNTP_SERVER_INSTANCE pInstance,
                BOOL&	fFatal
                 );

VOID
TerminateFeedManager(
                PNNTP_SERVER_INSTANCE pInstance
                 );
VOID
DereferenceFeedBlock(
	PNNTP_SERVER_INSTANCE pInstance,
    PFEED_BLOCK FeedBlock
    );

VOID
CloseFeedBlock(
	PNNTP_SERVER_INSTANCE pInstance,
    PFEED_BLOCK FeedBlock
    );

LPSTR
ServerNameFromCompletionContext(	
	LPVOID	lpv 
	) ;

VOID
ConvertTimeToString(
    IN PFILETIME Ft,
    OUT CHAR Date[],
    OUT CHAR Time[]
    );

VOID
CompleteFeedRequest(
			IN PNNTP_SERVER_INSTANCE pInstance,
            IN PVOID Context,
			IN FILETIME	NextPullTime,
            BOOL Success,
			BOOL NoData
            );

BOOL
ValidateFeedType(
    DWORD FeedType
    );

//
// svcstat.c
//


#endif // _NNPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\nntpdata.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nntpdata.cpp

Abstract:

    This module contains routines to initialize any global data

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

--*/

#include	"tigris.hxx"
#include    "smtpdll.h"

//
//	Vars to track global Init()'s
//
#define     FINIT_VAR( arg )    fSuccessfullInit ## arg

BOOL	FINIT_VAR( FileHandleCache ) = FALSE ;
BOOL    FINIT_VAR( CBuffer ) = FALSE ;
BOOL    FINIT_VAR( CPacket ) = FALSE ;
BOOL    FINIT_VAR( CIO ) = FALSE ;
BOOL    FINIT_VAR( CSessionSocket ) = FALSE ;
BOOL    FINIT_VAR( CChannel ) = FALSE ;
BOOL    FINIT_VAR( CIODriver ) = FALSE ;
BOOL    FINIT_VAR( CArticle ) = FALSE ;
BOOL    FINIT_VAR( CInFeed ) = FALSE ;
BOOL    FINIT_VAR( CSessionState ) = FALSE ;
BOOL	FINIT_VAR( CXoverIndex ) = FALSE ;
BOOL    FINIT_VAR( InitEncryption ) = FALSE ;
BOOL    FINIT_VAR( InitSecurity ) = FALSE ;
BOOL    FINIT_VAR( InitModeratedProvider ) = FALSE ;
BOOL    FINIT_VAR( XoverCacheLibrary ) = FALSE ;
BOOL    FINIT_VAR( NNTPHashLibrary ) = FALSE ;
BOOL    FINIT_VAR( IDirectoryNotification ) = FALSE ;
BOOL	FINIT_VAR( CNNTPVRootTable ) = FALSE;
BOOL    FINIT_VAR( InitAdminBase ) = FALSE ;

// globals
char	g_szSpecialExpireGroup[1024];

//
// Notification object used for watching changes in CAPI store
//
STORE_CHANGE_NOTIFIER *g_pCAPIStoreChangeNotifier;

//
// Function prototypes
//

BOOL
GetRegistrySettings(
            VOID
            );

APIERR
InitializeCPools();

VOID
TerminateCPools();

HRESULT
InitAdminBase();

VOID
UninitAdminBase();

void
TerminateSecurityGlobals();

BOOL
InitializeSecurityGlobals();

//
// Controls the level of debugging
//

DWORD DebugLevel = NNTP_DEBUG_FEEDMGR |
                    NNTP_DEBUG_REGISTRY |
                    NNTP_DEBUG_FEEDBLOCK;

DWORD NntpDebug;

//
//	Boolean controlling whether the server will generate the .err files !
//
BOOL	fGenerateErrFiles = TRUE ;

//
//	Global config of hash table use of PageEntry's - 
//	The more RAM a box has, the more PageEntry's the
//	better the caching of frequently used hash table pages !
//
//	Number of PageEntry objects for the Xover table
//
DWORD	XoverNumPageEntry = 512 ;

//
//	Number of PageEntry objects for the Article table
//
DWORD	ArticleNumPageEntry = 256 ;

//
//	Number of PageEntry objects for the History table
//
DWORD	HistoryNumPageEntry = 128 ;

//
//	Number of Locks to use in various arrays of locks !
//
DWORD	gNumLocks = 64 ;

//
//	Used to determine how frequency of .xix sorting is related to 
//	number of clients !
//
DWORD	gdwSortFactor = 5 ;

#if 0
//
//	Control what size buffers the server uses
//
DWORD	cbLargeBufferSize = 33 * 1024 ;
DWORD	cbMediumBufferSize = 4 * 1024 ;
DWORD	cbSmallBufferSize =  512 ;
#endif


DWORD	HistoryExpirationSeconds = DEF_EXPIRE_INTERVAL ;
DWORD	ArticleTimeLimitSeconds = DEF_EXPIRE_INTERVAL + SEC_PER_WEEK ;

//
//	Service version string
//
CHAR	szVersionString[128] ;

//
//	Time the newstree crawler threads before iterations over
//	the newstree - default - 30 minutes
//
DWORD	dwNewsCrawlerTime = 30 * 60 * 1000 ;

//
//	This is an upper bound on the time spent by the server in 
//	cleaning up on net stop - default - 1 minute !
//
DWORD	dwShutdownLatency = 2 * 60 * 1000 ;

//
//	This is an upper bound on the time the server will wait
//	for an instance to start !
//
DWORD	dwStartupLatency = 2 * 60 * 1000 ;

//
//  Number of threads in expire thread pool
//
DWORD	dwNumExpireThreads = 4 ;

//
//  Number of special case expire threads
//
DWORD	gNumSpecialCaseExpireThreads = 4;

//
//  Article count threshold to trigger special case expire
//
DWORD	gSpecialExpireArtCount = 100 * 1000;

//
//  Amount of RAM to use for hash page-cache -
//  Passing in 0 to InitHashLib() lets hashmap
//  calculate a good default !
//
DWORD	dwPageCacheSize = 0 ;

//
//  Limit on file handle cache - default is 0
//  so we set sane limits !!
//
DWORD   dwFileHandleCacheSize = 0 ;

//
//  Limit on xix handles per table - default is 0
//  so we set sane limits !!
//
DWORD   dwXixHandlesPerTable = 0 ;

//
//	Do we allow NT to buffer our hash table files ??
//
BOOL	HashTableNoBuffering = FALSE ;

//
//  Rate at which expire by time does File scans
//
DWORD	gNewsTreeFileScanRate = 20 ;

//
//	Type of From: header to use in mail messages
//	mfNone		-	empty from header (default)
//	mfAdmin		-	AdminEmail name
//	mfArticle	-	Article From header
//
MAIL_FROM_SWITCH	mfMailFromHeader = mfNone;

//
// !!! Temporary
//

BOOL RejectGenomeGroups = FALSE;

//
//	Bool to determine whether we will honor a message-id in an article
//	posted by a client !
//
BOOL	gHonorClientMessageIDs = TRUE ;

//
//	BOOL used to determine whether we will generate the NNTP-Posting-Host
//	header on client Posts. Default is to not generate this.
//
BOOL		gEnableNntpPostingHost = TRUE ;

//
//	Rate at which we poll vroot information to update CNewsGroup objects
//	(in minutes)
//
DWORD	gNewsgroupUpdateRate = 5 ;	// default - 5 minutes

//
//	Bool used to determine whether the server enforces Approved: header
//	matching on moderated posts !
//
BOOL	gHonorApprovedHeaders = TRUE ;

//
//  Shall we back fill the lines header during client post ?
//
BOOL    g_fBackFillLines = TRUE;

//
// DLL Module instance handles
//
HINSTANCE g_hLonsiNT = NULL;   // for lonsint.dll
BOOL    g_bLoadLonsiNT = FALSE;

//
// Coinit done
//
BOOL    g_fCoInited = FALSE;

//
// DLL Function pointers
//
// For lonsint.dll

GET_DEFAULT_DOMAIN_NAME_FN pfnGetDefaultDomainName = NULL;

//
// Global impersonation token for process
//
HANDLE g_hProcessImpersonationToken = NULL;

//
// For debugging
//

DWORD numField = 0;
DWORD numArticle = 0;
DWORD numPCParse = 0;
DWORD numPCString = 0;
DWORD numDateField = 0;
DWORD numCmd = 0;
DWORD numFromPeerArt = 0;
DWORD numMapFile = 0;

//#define HEAP_INIT_SIZE  (KB * KB)

//
// Global heap handle
//
//HANDLE  g_hHeap;

APIERR
InitializeGlobals()
{

    //
    // CoInitialize here
    //
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if ( FAILED( hr ) && hr != CO_E_ALREADYINITIALIZED ) {
	    _ASSERT( 0 );
	    g_fCoInited = FALSE;
	    return ERROR_STATIC_INIT;
	}

    g_fCoInited = TRUE;

    APIERR error;
	MB mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    PCHAR args [1];

	MEMORYSTATUS	memStatus ;
	memStatus.dwLength = sizeof( MEMORYSTATUS ) ;
	GlobalMemoryStatus( &memStatus ) ;
	
	TraceFunctEnter("InitializeGlobals");

	//
	//	Initialize the file handle cache !
	//
	if( !InitializeCache() ) {
		return	ERROR_NOT_READY ;
	}
	FINIT_VAR( FileHandleCache ) = TRUE ;

	//
	// do global SEO initialization
	//
	hr = SEOGetServiceHandle(&(g_pNntpSvc->m_punkSEOHandle));
	if (FAILED(hr)) {
		_ASSERT(FALSE);
		// we're in trouble here.  we'll try and continue on, but server events
		// probably won't work right
		g_pNntpSvc->m_punkSEOHandle = NULL;
		NntpLogEvent(	SEO_INIT_FAILED, 
						0, 
						(const char **)NULL, 
						hr
						);
	} else {
		//
		//  do any global server events registration that needs to exist
		//
		HRESULT hr = RegisterSEOService();
		if (FAILED(hr)) {
			ErrorTrace(0, "RegisterSEOService returned %x", hr);
			NntpLogEvent(	SEO_INIT_FAILED, 
							0, 
							(const char **)NULL, 
							hr
							);
		} else {
			// 
			// clean up any orphaned SEO sources related to NNTP
			//
			hr = UnregisterOrphanedSources();
			if (FAILED(hr)) {
				ErrorTrace(0, "UnregisterOrphanedSources returned %x", hr);
				NntpLogEvent(	SEO_INIT_FAILED, 
								0, 
								(const char **)NULL, 
								hr
								);
			}
		}
	}

	//
	//	Initialize all global CPools
	//
	if( !InitializeCPools() ) {
        args[0] = "CPool init failed";
        goto error_exit;
	}

	//
	//	Get global reg settings
	//
    if (!GetRegistrySettings()){
        goto error_exit;
    }

    //
    //  Initialize global XOVER Cache
    //
    if( !XoverCacheLibraryInit( dwXixHandlesPerTable ) ) {
        args[0] = "Xover cache init failed";
        goto error_exit;
    }   else    {
        FINIT_VAR( XoverCacheLibrary ) = TRUE ;
    }

    if( !InitializeNNTPHashLibrary(dwPageCacheSize) )  {
        args[0] = "NNTP Hash init failed";
        goto error_exit;
    }   else    {
        FINIT_VAR( NNTPHashLibrary ) = TRUE ;
    } 

    //
    // Initialize all the security related contexts
    //
    if ( !InitializeSecurityGlobals() ) {
        ErrorTrace( 0, "Initialize security globals failed %d",
                        GetLastError() );
        goto error_exit;
    }

    //
	//  Initialize SMTP provider interface for moderated newsgroups
    //
    if(!InitModeratedProvider())
    {
		ErrorTrace(0,"Failed to initialize moderated newsgroups provider");
		NntpLogEvent(	NNTP_INIT_MODERATED_PROVIDER, 
						0, 
						(const char **)NULL, 
						0
						);
        // NOTE: failure to init moderated provider should not prevent service start
    }
    else
		FINIT_VAR( InitModeratedProvider ) = TRUE;

	hr = IDirectoryNotification::GlobalInitialize(DIRNOT_TIMEOUT,
		DIRNOT_MAX_INSTANCES, DIRNOT_INSTANCE_SIZE, StopHintFunction );
	if (FAILED(hr)) {
		ErrorTrace(0, "Failed to initialize directory notification");
		NntpLogEvent(	NNTP_INIT_DIRNOT_FAILED, 
						0, 
						(const char **)NULL, 
						hr
						);
	} else {
		FINIT_VAR( IDirectoryNotification ) = TRUE;
	}

	// initialize exvroot.lib
	hr = CVRootTable::GlobalInitialize();
	if (FAILED(hr)) {
		ErrorTrace(0, "Failed to initialize vroot table");
		goto error_exit;
	} else {
		FINIT_VAR(CNNTPVRootTable) = TRUE;
	}

    //
    //  Initialize the IMSAdminBase object for MB access checks
    //
    hr = InitAdminBase();
	if (FAILED(hr)) {
		ErrorTrace(0, "Failed to initialize IMSAdminBaseW");
	} else {
		FINIT_VAR( InitAdminBase ) = TRUE;
	}

    return NO_ERROR;

error_exit:

	SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    error = GetLastError();
    NntpLogEvent(	NNTP_EVENT_OUT_OF_MEMORY,
					1,
                    (const char**)args,
					error
				   );	

    return(error);

} // InitializeGlobals

VOID
TerminateGlobals()
{
	TraceFunctEnter("TerminateGlobals");

    StopHintFunction() ;

	//
	// do global SEO cleanup
	//
	if (g_pNntpSvc->m_punkSEOHandle != NULL) {
		g_pNntpSvc->m_punkSEOHandle->Release();
	}

	//
	//	Wait for global CPool alloc count on session socket objects
	//	to go to zero !
	//
	//	need to check Pool.GetAllocCount instead of InUseList.Empty
	//	because alloc goes to zero during the delete operator
	//	instead of during the destructor - this closes the window
	//	between the count going to zero and the destructor completing.
	//
	//

	DWORD   cSessions = CSessionSocket::gSocketAllocator.GetAllocCount() ;
	DWORD   j = 0;

	if( cSessions ) {
		Sleep( 1000 );
		StopHintFunction() ;
	}

	cSessions = CSessionSocket::gSocketAllocator.GetAllocCount() ;

	for( int i=0; cSessions && i<120; i++, j++ )
	{
		Sleep( 1000 );
		DebugTrace(0, "Shutdown sleep %d seconds. Count: %d", i,
					CSessionSocket::gSocketAllocator.GetAllocCount() );

		if( (j%10) == 0 ) {
			StopHintFunction() ;
		}

		//
		//  If we make progress, then reset i.  This will mean that the server
		//  wont stop until 2 minutes after we stop making progress.
		//
		DWORD   cSessionsNew = CSessionSocket::gSocketAllocator.GetAllocCount() ;
		if( cSessions != cSessionsNew ) {
			i = 0 ;
		}
		cSessions = cSessionsNew ;
	}

	_ASSERT( i<1200 );

    if( FINIT_VAR( XoverCacheLibrary ) ) {
        XoverCacheLibraryTerm() ;
    }


    if( FINIT_VAR( NNTPHashLibrary ) ) {
        TermNNTPHashLibrary() ;
    }

    //
    // Terminate all security stuff
    //
    TerminateSecurityGlobals();

    //
    // Terminate CPools
    //
	TerminateCPools();

    //
    // Terminate moderated newsgroups provider
    //
    if( FINIT_VAR( InitModeratedProvider ))
        TerminateModeratedProvider();

    StopHintFunction() ;

	// unload exvroot.lib
	if (FINIT_VAR(CNNTPVRootTable)) {
		CVRootTable::GlobalShutdown();
	}

    //
    //  Cleanup IMSAdminBaseW object
    //
    if( FINIT_VAR( InitAdminBase ) ) {
        UninitAdminBase();
    }

	if( FINIT_VAR( FileHandleCache ) ) {
		_VERIFY( TerminateCache() ) ;
	}

	//
	// If we have done co-init, de-init it
	//
	if ( g_fCoInited ) CoUninitialize();

    return;

} // TerminateGlobals

BOOL
GetRegistrySettings(
            VOID
            )
{
    DWORD error;
    HKEY key = NULL;
    DWORD i = 0;
    CHAR data[1024];
    DWORD valueType;
    DWORD dataSize;
	DWORD	dwNewsCrawler = 0 ;
	DWORD	cbBufferSize = 0 ;
	DWORD	dwLatency = 0 ;
	DWORD	dwData = 0 ;
	DWORD	Honor = 0 ;
	DWORD	dwExpire = 0 ;
    //DWORD	dwType ;
    //DWORD	dw ;

    ENTER("GetRegistrySettings")

    //
    // Open root key
    //

    error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                StrParmKey,
                NULL,
                KEY_QUERY_VALUE,
                &key
                );

    if ( error != NO_ERROR ) {
        ErrorTrace(0,"Error %d opening %s\n",error,StrParmKey);
        goto error_exit;
    }

	dataSize = sizeof( dwNewsCrawler ) ;
	error = RegQueryValueEx(
						key,
						StrNewsCrawlerTime,
						NULL,
						&valueType,
						(LPBYTE)&dwNewsCrawler,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	The registry entry is in minutes - convert to milliseconds
		//
		dwNewsCrawlerTime = dwNewsCrawler * 60 * 1000 ;		

	}	else	{

		dwNewsCrawlerTime = 30 * 60 * 1000 ;

	}

	dataSize = sizeof( DWORD ) ;
	error = RegQueryValueEx(
						key,
						StrMailFromHeader,
						NULL,
						&valueType,
						(LPBYTE)&mfMailFromHeader,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	Should be a valid switch
		//
		if( (mfMailFromHeader != mfNone) && 
				(mfMailFromHeader != mfAdmin) && (mfMailFromHeader != mfArticle)
				) {
			mfMailFromHeader = mfNone;
		}

	}	else	{

		mfMailFromHeader = mfNone;

	}

	dataSize = sizeof( dwLatency ) ;
	error = RegQueryValueEx(
						key,
						StrShutdownLatency,
						NULL,
						&valueType,
						(LPBYTE)&dwLatency,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	The registry entry is in minutes - convert to milliseconds
		//
		dwShutdownLatency = dwLatency * 60 * 1000 ;		

	}	else	{

		dwShutdownLatency = 2 * 60 * 1000 ;

	}

	dataSize = sizeof( dwLatency ) ;
	error = RegQueryValueEx(
						key,
						StrStartupLatency,
						NULL,
						&valueType,
						(LPBYTE)&dwLatency,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	The registry entry is in minutes - convert to milliseconds
		//
		dwStartupLatency = dwLatency * 60 * 1000 ;		

	}	else	{

		dwStartupLatency = 2 * 60 * 1000 ;

	}

	dataSize = sizeof( dwNumExpireThreads ) ;
	error = RegQueryValueEx(
						key,
						StrNumExpireThreads,
						NULL,
						&valueType,
						(LPBYTE)&dwNumExpireThreads,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	Ensure that this does not exceed MAX_EXPIRE_THREADS
		//

	}	else	{

		dwNumExpireThreads = 4 ;
	}

	dataSize = sizeof( gNumSpecialCaseExpireThreads ) ;
	error = RegQueryValueEx(
						key,
						StrNumSpecialCaseExpireThreads,
						NULL,
						&valueType,
						(LPBYTE)&gNumSpecialCaseExpireThreads,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	Cap the max at 16 !
		//
        if( gNumSpecialCaseExpireThreads > 16 ) {
            gNumSpecialCaseExpireThreads = 16;
        }

	}	else	{

        //  default !
		gNumSpecialCaseExpireThreads = 4 ;
	}

	dataSize = sizeof( gSpecialExpireArtCount ) ;
	error = RegQueryValueEx(
						key,
						StrSpecialExpireArtCount,
						NULL,
						&valueType,
						(LPBYTE)&gSpecialExpireArtCount,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	This should not be less than 100,000
		//
#if 0
        if( gSpecialExpireArtCount < 100*1000 ) {
            gSpecialExpireArtCount = 100*1000;
        }
#endif
	}	else	{

		gSpecialExpireArtCount = 100*1000;
	}

	dataSize = sizeof( data ) ;
	error = RegQueryValueEx(
						key,
						StrSpecialExpireGroup,
						NULL,
						&valueType,
						(LPBYTE)data,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_SZ) ) {

		//
		//	This should be the group native name
		//
        lstrcpy( g_szSpecialExpireGroup, data );
        _strlwr( g_szSpecialExpireGroup );

	}	else	{

		//
        //  default is control.cancel !
        //
        lstrcpy( g_szSpecialExpireGroup, "control.cancel" );
	}

	dataSize = sizeof( dwPageCacheSize ) ;
	error = RegQueryValueEx(
						key,
						StrPageCacheSize,
						NULL,
						&valueType,
						(LPBYTE)&dwPageCacheSize,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	Units are in MB
		//
        dwPageCacheSize *= 1024*1024;

	}	else	{

		_ASSERT( dwPageCacheSize == 0 );
	}

	dataSize = sizeof( dwFileHandleCacheSize ) ;
	error = RegQueryValueEx(
						key,
						StrFileHandleCacheSize,
						NULL,
						&valueType,
						(LPBYTE)&dwFileHandleCacheSize,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {


	}	else	{

		_ASSERT( dwFileHandleCacheSize == 0 );
	}

	dataSize = sizeof( dwXixHandlesPerTable ) ;
	error = RegQueryValueEx(
						key,
						StrXixHandlesPerTable,
						NULL,
						&valueType,
						(LPBYTE)&dwXixHandlesPerTable,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {


	}	else	{

		_ASSERT( dwXixHandlesPerTable == 0 );
	}

#if 0		// X5:178268 (note that it's init to FALSE above)
	dataSize = sizeof( HashTableNoBuffering ) ;
	error = RegQueryValueEx(
						key,
						StrHashTableNoBuffering,
						NULL,
						&valueType,
						(LPBYTE)&HashTableNoBuffering,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

	}	else	{

		HashTableNoBuffering = FALSE ;

	}
#endif

	dataSize = sizeof( gNewsTreeFileScanRate ) ;
	error = RegQueryValueEx(
						key,
						StrNewsTreeFileScanRate,
						NULL,
						&valueType,
						(LPBYTE)&gNewsTreeFileScanRate,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

	}	else	{

		gNewsTreeFileScanRate = 20 ;
	}

	dataSize = sizeof( dwData ) ;
	error = RegQueryValueEx(
						key,
						StrNewsVrootUpdateRate,
						NULL,
						&valueType,
						(LPBYTE)&dwData,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
	
		gNewsgroupUpdateRate = dwData ;

	}	else	{

		gNewsgroupUpdateRate = 2 ;	// 2 minutes - 

	}
	//
	//	Convert minutes to milliseconds
	//	
	gNewsgroupUpdateRate *= 60 * 1000 ;

    //
    // reject genome?
    //

    dataSize = sizeof(RejectGenomeGroups);
    error = RegQueryValueEx(
                        key,
                        StrRejectGenome,
                        NULL,
                        &valueType,
                        (LPBYTE)data,
                        &dataSize
                        );

    if ( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
        RejectGenomeGroups = *((PDWORD)data);
    }

	cbBufferSize = 0 ;
	dataSize = sizeof( cbBufferSize ) ;
	error = RegQueryValueEx(
						key,	
						StrSmallBufferSize,
						NULL,
						&valueType,
						(LPBYTE)&cbBufferSize,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		cbSmallBufferSize = cbBufferSize;
	}	else	{
		//	Default should already be set !
	}

	cbBufferSize = 0 ;
	dataSize = sizeof( cbBufferSize ) ;
	error = RegQueryValueEx(
						key,	
						StrMediumBufferSize,
						NULL,
						&valueType,
						(LPBYTE)&cbBufferSize,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		cbMediumBufferSize = cbBufferSize;
	}	else	{
		//	Default should already be set !
	}

	cbBufferSize = 0 ;
	dataSize = sizeof( cbBufferSize ) ;
	error = RegQueryValueEx(
						key,	
						StrLargeBufferSize,
						NULL,
						&valueType,
						(LPBYTE)&cbBufferSize,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		cbLargeBufferSize = cbBufferSize;
	}	else	{
		//	Default should already be set !
	}

	dataSize = sizeof( dwExpire ) ;
	error = RegQueryValueEx(
						key,
						StrHistoryExpiration,
						NULL,
						&valueType,
						(LPBYTE)&dwExpire,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		
		dwExpire *= SEC_PER_DAY ;
		HistoryExpirationSeconds = dwExpire ;

	}	else	{

		HistoryExpirationSeconds = DEF_EXPIRE_INTERVAL ;

	}


	dwExpire = 0 ;
	dataSize = sizeof( dwExpire ) ;
	error = RegQueryValueEx(
						key,
						StrArticleTimeLimit,
						NULL,
						&valueType,
						(LPBYTE)&dwExpire,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		
		ArticleTimeLimitSeconds = dwExpire *= SEC_PER_DAY ;

	}	else	{

		ArticleTimeLimitSeconds = HistoryExpirationSeconds + SEC_PER_WEEK ;

	}


	Honor = 0 ;
	dataSize = sizeof( Honor ) ;
	error = RegQueryValueEx(
						key,	
						StrHonorClientMessageIDs,
						NULL,
						&valueType,
						(LPBYTE)&Honor,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		gHonorClientMessageIDs = (!!Honor) ;
	}	else	{
		//	Default should already be set !
	}

	dwData = 1 ;
	dataSize = sizeof( dwData ) ;
	error = RegQueryValueEx(
						key,	
						StrEnableNntpPostingHost,
						NULL,
						&valueType,
						(LPBYTE)&dwData,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		//
		//	Since the string is called 'Enable' - a non-zero
		//	value in the registry will enable this header
		//
		gEnableNntpPostingHost = !(!dwData) ;
	}	else	{
		//	Default should already be set !
	}

	dwData = 1 ;
	dataSize = sizeof( dwData ) ;
	error = RegQueryValueEx(
						key,	
						StrGenerateErrFiles,
						NULL,
						&valueType,
						(LPBYTE)&dwData,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		//
		//	Since the string is called 'Disable' - a non-zero
		//	value in the registry will disable newnews commands,
		//	but a 0 will allow them !
		//
		fGenerateErrFiles = !(!dwData) ;
	}	else	{
		//	Default should already be set !
	}

	dwData = 1 ;
	dataSize = sizeof( dwData ) ;
	error = RegQueryValueEx(
						key,	
						StrHonorApprovedHeader,
						NULL,
						&valueType,
						(LPBYTE)&dwData,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		//
		//	Since the string is called 'Disable' - a non-zero
		//	value in the registry will disable newnews commands,
		//	but a 0 will allow them !
		//
		gHonorApprovedHeaders = BOOL(dwData) ;
	}	else	{
		//	Default should already be set !
	}

	//
	//	Compute defaults for the number of PageEntry objects we should use in the hash tables !
	//

	MEMORYSTATUS	memStatus ;
	memStatus.dwLength = sizeof( memStatus ) ;

	GlobalMemoryStatus( &memStatus ) ;

	//	
	//	Now we know how much physical RAM the system has, so base PageEntry sizes on this !
	//	Note that each PageEntry will have a 4K page !
	//
	//

	if( memStatus.dwTotalPhys >= (30 * 1024 * 1024) ) {

		gNumLocks = 32 ;

		XoverNumPageEntry = 6 * 256 ;	// Uses 6MB ram
		ArticleNumPageEntry = 4 * 256 ;	// Uses 4 MB ram
		HistoryNumPageEntry = 1 * 256 ; // Uses 1 MB ram

	}

	if( memStatus.dwTotalPhys >= (60 * 1024 * 1024) ) {

		gNumLocks = 64 ;

		XoverNumPageEntry = 12 * 256 ;	// Uses 12 MB ram
		ArticleNumPageEntry = 8 * 256 ;	// Uses 8 MB ram
		HistoryNumPageEntry = 1 * 256 ; // Uses 1MB ram

	}

	if( memStatus.dwTotalPhys >= (120 * 1024 * 1024) ) {

		gdwSortFactor = 10 ; 

		gNumLocks = 96 ;

		XoverNumPageEntry = 24 * 256 ; // Uses 24 MB ram
		ArticleNumPageEntry = 16 * 256 ; // Uses 16 MB ram
		HistoryNumPageEntry = 4 * 256 ;		// Uses 4 MB ram

	}

	if( memStatus.dwTotalPhys >= (250 * 1024 * 1024) ) {

		gdwSortFactor = 25 ;

		gNumLocks = 128 ;

		XoverNumPageEntry = 36 * 256 ; // Uses 36 MB ram
		ArticleNumPageEntry = 24 * 256 ; // Uses 24 MB ram
		HistoryNumPageEntry = 4 * 256 ; // Uses 4 MB ram

	}

	if( memStatus.dwTotalPhys >= (500 * 1024 * 1024) ) {

		gdwSortFactor = 40 ;

		gNumLocks = 256 ;

	}

	dwData = 1 ;
	dataSize = sizeof( dwData ) ;
	error = RegQueryValueEx(
						key,	
						StrArticlePageEntry,
						NULL,
						&valueType,
						(LPBYTE)&dwData,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		//
		//	User specifies the size in MegaBytes ! so we do some math for them 
		//	to generate the appropriate constant !
		//	Don't let them specify more than the physical RAM on the box !
		//
		if( dwData != 0 && (dwData * 256 < memStatus.dwTotalPhys) )
			ArticleNumPageEntry = dwData * 256 ;
	}	else	{
		//	Default should already be set !
	}

	dwData = 1 ;
	dataSize = sizeof( dwData ) ;
	error = RegQueryValueEx(
						key,	
						StrHistoryPageEntry,
						NULL,
						&valueType,
						(LPBYTE)&dwData,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		//
		//	User specifies the size in MegaBytes ! so we do some math for them 
		//	to generate the appropriate constant !
		//	Don't let them specify more than the physical RAM on the box !
		//
		if( dwData != 0 && (dwData * 256 < memStatus.dwTotalPhys) )
			HistoryNumPageEntry = dwData * 256 ;
	}	else	{
		//	Default should already be set !
	}
	
	dwData = 1 ;
	dataSize = sizeof( dwData ) ;
	error = RegQueryValueEx(
						key,	
						StrXoverPageEntry,
						NULL,
						&valueType,
						(LPBYTE)&dwData,
						&dataSize 
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		//
		//	User specifies the size in MegaBytes ! so we do some math for them 
		//	to generate the appropriate constant !
		//	Don't let them specify more than the physical RAM on the box !
		//
		if( dwData != 0 && (dwData * 256 < memStatus.dwTotalPhys) )
			XoverNumPageEntry = dwData * 256 ;
	}	else	{
		//	Default should already be set !
	}

    dwData = 1;
    dataSize = sizeof(dwData);
	error = RegQueryValueEx(    key,
	                            StrPostBackFillLines,
                                NULL,
                                &valueType,
                                (LPBYTE)&dwData,
                                &dataSize );
    if ( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) && dwData == 0) {
        //
        // User specifies not to back fill the lines header
        //
        g_fBackFillLines = FALSE;
    } else {
        //
        // when the value is set to 1 or wrongly set or not set, we'll back fill
        //
        g_fBackFillLines = TRUE;
    }
                                
    RegCloseKey( key );

    LEAVE
    return(TRUE);

error_exit:

    if ( key != NULL) {
        RegCloseKey( key );
    }
    LEAVE
    return(FALSE);
}

APIERR
InitializeCPools()
{
	//
	//	Before we create and boot all instances, setup global cpools etc !
    //

    if( !CArticle::InitClass() )
        return  FALSE ;

    FINIT_VAR( CArticle ) = TRUE ;

    if( !CBuffer::InitClass() )     
        return  FALSE ;

    FINIT_VAR( CBuffer ) = TRUE ;

    if( !CPacket::InitClass() )
        return  FALSE ;

    FINIT_VAR( CPacket ) = TRUE ;

    if( !CIO::InitClass() )
        return  FALSE ;

    FINIT_VAR( CIO ) = TRUE ;

    StartHintFunction() ;

    if( !CSessionSocket::InitClass() )
        return  FALSE ;

    FINIT_VAR( CSessionSocket ) = TRUE ;

    if( !CChannel::InitClass() )
        return  FALSE ;

    FINIT_VAR( CChannel ) = TRUE ;

    if( !CIODriver::InitClass() ) 
        return  FALSE ;

    FINIT_VAR( CIODriver ) = TRUE ;

    if( !CInFeed::InitClass() )
        return  FALSE ;

    FINIT_VAR( CInFeed ) = TRUE ;

    if( !CSessionState::InitClass() )
        return  FALSE ;

    FINIT_VAR( CSessionState ) = TRUE ;

	return TRUE;
}

VOID
TerminateCPools()
{
	//
	//	Shutdown global cpools !
	//
    if( FINIT_VAR( CSessionSocket ) ) {
        CSessionSocket::TermClass() ;
		FINIT_VAR( CSessionSocket ) = FALSE ;
	}

    if( FINIT_VAR( CIODriver ) ) {
        CIODriver::TermClass() ;
		FINIT_VAR( CIODriver ) = FALSE ;
	}

    if( FINIT_VAR( CChannel ) ) {
        CChannel::TermClass() ;
		FINIT_VAR( CChannel ) = FALSE ;
	}

    if( FINIT_VAR( CIO ) ) {
        CIO::TermClass() ;
		FINIT_VAR( CIO ) = FALSE ;
	}

    if( FINIT_VAR( CPacket ) ) {
        CPacket::TermClass() ;
		FINIT_VAR( CPacket ) = FALSE ;
	}

    if( FINIT_VAR( CBuffer ) ) {
        CBuffer::TermClass() ;
		FINIT_VAR( CBuffer ) = FALSE ;
	}

    if( FINIT_VAR( CArticle ) ) {
        CArticle::TermClass() ;
		FINIT_VAR( CArticle ) = FALSE ;
	}

    if( FINIT_VAR( CInFeed ) ) {
        CInFeed::TermClass() ;
		FINIT_VAR( CInFeed ) = FALSE ;
	}

    if( FINIT_VAR( CSessionState ) ) {
        CSessionState::TermClass() ;
		FINIT_VAR( CSessionState ) = FALSE ;
	}

}

BOOL
InitializeSecurityGlobals()
{
    TraceFunctEnter( "GetDLLEntryPoints" );
    HANDLE  hAccToken = NULL;

    // Initialize CEncryptCtx class
    if( !CEncryptCtx::Initialize( "NntpSvc", 
    							  (struct IMDCOM*) g_pInetSvc->QueryMDObject(),
    							  (PVOID)&(g_pNntpSvc->m_smcMapContext ) ) ) {
        return  FALSE ;
	} else {
        FINIT_VAR( InitEncryption ) = TRUE ;
    }

    // Initialize CSecurityCtx class
    if( !CSecurityCtx::Initialize() ) {
        ErrorTrace( 0, "security init failed %d", GetLastError() );
        return FALSE;
    } else {
        FINIT_VAR( InitSecurity ) = TRUE;
    }

    // Load lonsint and get entry points to its funcs
    // Only when the image is not mapped do we explicitely
    // load it
    g_hLonsiNT = LoadLibrary( "lonsint.dll" );

    if ( g_hLonsiNT ) {
        g_bLoadLonsiNT = TRUE;
        pfnGetDefaultDomainName = (GET_DEFAULT_DOMAIN_NAME_FN)
            GetProcAddress( g_hLonsiNT, "IISGetDefaultDomainName" );
        if ( NULL == pfnGetDefaultDomainName ) {
            ErrorTrace( 0, "Get Proc IISGetDefaultDomainName Address failed %d",
                        GetLastError() );
            return FALSE;
        }
    } else {
        ErrorTrace( 0, "Load library lonsint.dll failed" );
        g_bLoadLonsiNT = FALSE;
        return FALSE;
    }

    // Get the process access token for system operations
    if ( !OpenProcessToken( GetCurrentProcess(),
                            TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY,
                            &hAccToken ) ) {
        ErrorTrace( 0, "Open Process token failed %d", GetLastError() );
        return FALSE;
    } else {
        // Dup the token to get an impersonation token
        _ASSERT( hAccToken );
        if ( !DuplicateTokenEx(   hAccToken,
                                  0,
                                   NULL,
                                  SecurityImpersonation,
                                  TokenImpersonation,
                                  &g_hProcessImpersonationToken ) ) {
            ErrorTrace( 0, "Duplicate token failed %d", GetLastError() );
            CloseHandle( hAccToken );
            return FALSE;
        }

        // Here we have got the right token
        CloseHandle( hAccToken );
     }

    //
    // Create the CAPI store notification object
    //
    g_pCAPIStoreChangeNotifier = XNEW STORE_CHANGE_NOTIFIER();
    if ( !g_pCAPIStoreChangeNotifier ) {
        ErrorTrace( 0, "Failed to create CAPIStoreChange notifier err: %u", GetLastError() );
        if ( GetLastError() == NO_ERROR )
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }
    
    return TRUE;
}

void
TerminateSecurityGlobals()
{
    // Terminate CEncryptCtx class
    if( FINIT_VAR( InitEncryption ) ) {
        CEncryptCtx::Terminate() ;
		FINIT_VAR( InitEncryption ) = FALSE ;
	}
	
    // Terminate CSecurity class
    if( FINIT_VAR( InitSecurity ) ) {
        CSecurityCtx::Terminate() ;  
        FINIT_VAR( InitSecurity ) = FALSE;
    }
    
    // Unload lonsint.dll, if necessary
    if ( g_bLoadLonsiNT ) {
        _ASSERT( g_hLonsiNT );
        FreeLibrary( g_hLonsiNT );
        g_bLoadLonsiNT = FALSE;
    }

    // Close the process token
    if ( g_hProcessImpersonationToken ) {
        CloseHandle( g_hProcessImpersonationToken );
        g_hProcessImpersonationToken = NULL;
    }

    // Terminate CAPIStore notification object
    if ( g_pCAPIStoreChangeNotifier ) {
        XDELETE g_pCAPIStoreChangeNotifier;
        g_pCAPIStoreChangeNotifier = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\nntpdata.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntpdata.h

Abstract:

    This module contains declarations for globals.

Author:

    Johnson Apacible (JohnsonA)     26-Sept-1995

Revision History:

--*/

#ifndef _NNTPDATA_
#define _NNTPDATA_
#define _LMACCESS_              // prevents duplicate defn. in lmaccess.h


extern GET_DEFAULT_DOMAIN_NAME_FN pfnGetDefaultDomainName;

//
//	Xover Sort Performance global - used to determine how frequently we 
//	sort xover entries !
//
extern	DWORD	gdwSortFactor ;


//
//	Do we put rejected articles into .err files ?
//
extern	BOOL	fGenerateErrFiles ;


//
//	Global config of hash table use of PageEntry's - 
//	The more RAM a box has, the more PageEntry's the
//	better the caching of frequently used hash table pages !
//
//	Number of PageEntry objects for the Xover table
//
extern	DWORD	XoverNumPageEntry ;

//
//	Number of PageEntry objects for the Article table
//
extern	DWORD	ArticleNumPageEntry ;

//
//	Number of PageEntry objects for the History table
//
extern	DWORD	HistoryNumPageEntry ;

//
//	Size of hash table page cache in bytes
//
extern	DWORD	dwPageCacheSize ;

//
//	Limit on file handle cache
//
extern	DWORD	dwFileHandleCacheSize ;

//
//	Limit on xix handles per table
//
extern	DWORD	dwXixHandlesPerTable ;

//
//	Do we allow NT to buffer our hash table files ??
//
extern	BOOL	HashTableNoBuffering ;

//
//	Number of Hash Table locks we should use !
//
extern	DWORD	gNumLocks ;

//
//	Global config of buffer sizes
//

//
//	The largest buffer we will use - must be big enough to hold
//	encrypted SSL blobs in contiguous chunks
//
extern	DWORD	cbLargeBufferSize ;

//
//	Medium size buffers - will be used for commands which generate large
//	responses, and when sending files through SSL
//
extern	DWORD	cbMediumBufferSize ;

//
//	Small buffers - used to read client commands and send small responses.
//
extern	DWORD	cbSmallBufferSize ;

//
//	Time limits for the history table
//
extern	DWORD	HistoryExpirationSeconds ;
extern	DWORD	ArticleTimeLimitSeconds ;

//
//	Service version string
//
extern  CHAR	szVersionString[128] ;

//
//	Service title
//
extern  char    szTitle[] ;

//
//	This is the time the newstree crawler thread sleeps between
//	expiration cycles on the newstree.
//
extern	DWORD	dwNewsCrawlerTime ;

//
//	This is an upper bound on the time the server will wait
//	for an instance to start !
//
extern	DWORD	dwStartupLatency ;

//
//	This is an upper bound on the time spent by the server in 
//	cleaning up on net stop !
//
extern	DWORD	dwShutdownLatency ;

//
//  Number of threads in expire thread pool
//
extern  DWORD	dwNumExpireThreads ;

//
//  Number of special case expire threads
//
extern  DWORD	gNumSpecialCaseExpireThreads ;

//
//  Special expire article count threshold -
//  special case code executes if art count is greater
//  than this number !
//
extern  DWORD	gSpecialExpireArtCount ;

//
//  Rate at which expire by time does file scans
//
extern  DWORD	gNewsTreeFileScanRate ;

//
//	Switch for type of from header to use in mail messages
//
extern	MAIL_FROM_SWITCH	mfMailFromHeader;

//
//	control how frequently we use LookupVirtualRoot to 
//	update newsgroup information !
//
extern	DWORD	gNewsgroupUpdateRate ;

//
//	Bool used to determine whether we will use a message-id a client puts
//	in his post !
//
extern	BOOL	gHonorClientMessageIDs ;

//
//	Bool used to determine whether the server enforces Approved: header
//	matching on moderated posts !
//
extern	BOOL	gHonorApprovedHeaders ;

//
//	BOOL used to determine whether we will generate the NNTP-Posting-Host
//	header on client Posts. Default is to not generate this.
//
extern	BOOL	gEnableNntpPostingHost ;

//
//  Shall we backfill the lines header during inbound ?
//
extern BOOL     g_fBackFillLines;

//
// Name of the list file
//

extern CHAR ListFileName[];

//
// Global service ptr
//
extern PNNTP_IIS_SERVICE g_pNntpSvc ;

//
// Name of newsgroup to special case for expire
//
extern char g_szSpecialExpireGroup[];

//
// misc externs
//

extern DWORD GroupFileNameSize;
extern BOOL RejectGenomeGroups;
extern const char szWSChars[];
extern const char szWSNullChars[];
extern const char szNLChars[];
extern const char szWSNLChars[];
extern const char StrNewLine[];
extern const char StrTermLine[];
extern LPSTR StrUnknownUser;

//
// strings
//

extern LPSTR StrParmKey;
extern LPSTR StrFeedKey;
extern LPSTR StrVirtualRootsKey;
extern LPSTR StrExpireKey;
extern LPSTR StrExpireNewsgroups;
extern LPSTR StrExpirePolicy;
extern LPSTR StrTreeRoot;
extern LPSTR StrRejectGenome;
extern LPSTR StrServerName;
extern LPSTR StrFeedType;
extern LPSTR StrFeedInterval;
extern LPSTR StrFeedDistribution;
extern LPSTR StrFeedNewsgroups;
extern LPSTR StrFeedAutoCreate;
extern LPSTR StrPeerTempDir;
extern LPSTR StrPeerGapSize;
extern LPSTR StrFeedTempDir;
extern LPSTR StrFeedUucpName ;
extern LPSTR StrFeedMaxConnectAttempts;
extern LPSTR StrFeedConcurrentSessions ;
extern LPSTR StrFeedSecurityType ;
extern LPSTR StrFeedAuthType;
extern LPSTR StrFeedAuthAccount ;
extern LPSTR StrFeedAuthPassword ;
extern LPSTR StrFeedStartHigh;
extern LPSTR StrFeedStartLow;
extern LPSTR StrFeedIsMaster;
extern LPSTR StrNntpHubName;
extern LPSTR StrFeedNextPullLow;
extern LPSTR StrFeedNextPullHigh;
extern LPSTR StrFeedAllowControl;
extern LPSTR StrFeedOutgoingPort;
extern LPSTR StrFeedPairId;
extern LPSTR StrMasterIPList;
extern LPSTR StrPeerIPList;
extern LPSTR StrListFileName;
extern LPSTR StrQueueFile;
extern LPSTR StrExpireHorizon;
extern LPSTR StrExpireSpace;
extern LPSTR StrCleanBoot ;
extern LPSTR StrSocketRecvSize ;
extern LPSTR StrSocketSendSize ;
extern LPSTR StrBuffer ;
extern LPSTR StrCommandLogMask ;
extern LPSTR StrActiveFile ;
extern LPSTR StrDescriptiveFile ;
extern LPSTR StrGroupList ;
extern LPSTR StrModeratorFile ;
extern LPSTR StrFeedDisabled ;
extern LPSTR StrAFilePath ;
extern LPSTR StrHFilePath ;
extern LPSTR StrXFilePath ;
extern LPSTR StrModeratorPath ;
extern LPSTR StrHistoryExpiration ;
extern LPSTR StrArticleTimeLimit ;
extern LPSTR StrAllowClientPosts ;
extern LPSTR StrAllowFeedPosts ;
extern LPSTR StrServerSoftLimit ;
extern LPSTR StrServerHardLimit ;
extern LPSTR StrFeedSoftLimit ;
extern LPSTR StrFeedHardLimit ;
extern LPSTR StrServerOrg ;
extern LPSTR StrAllowControlMessages;
extern LPWSTR StrSmtpAddressW ;
extern LPWSTR StrUucpNameW ;
extern LPSTR StrUucpNameA ;
extern LPWSTR StrDefaultModeratorW ;
extern LPWSTR StrAuthPackagesW ;
extern LPSTR StrSmallBufferSize ;
extern LPSTR StrMediumBufferSize ;
extern LPSTR StrLargeBufferSize ;
extern LPSTR StrNewsCrawlerTime ;
extern LPSTR StrNewsVrootUpdateRate ;
extern LPSTR StrHonorClientMessageIDs ;
extern LPSTR StrDisableNewnews ;
extern LPSTR StrEnableNntpPostingHost ;
extern LPSTR StrNumExpireThreads ;
extern LPSTR StrNumSpecialCaseExpireThreads ;
extern LPSTR StrSpecialExpireGroup ;
extern LPSTR StrSpecialExpireArtCount ;
extern LPSTR StrNewsTreeFileScanRate ;
extern LPSTR StrGenerateErrFiles ;
extern LPSTR StrXoverPageEntry ;
extern LPSTR StrArticlePageEntry ;
extern LPSTR StrHistoryPageEntry ;
extern LPSTR StrShutdownLatency ;
extern LPSTR StrStartupLatency ;
extern LPSTR StrHonorApprovedHeader ;
extern LPSTR StrMailFromHeader ;
extern LPSTR StrPageCacheSize ;
extern LPSTR StrFileHandleCacheSize ;
extern LPSTR StrXixHandlesPerTable ;
extern LPSTR StrHashTableNoBuffering ;
extern LPSTR StrPostBackFillLines;

#endif // _NNTPDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\nntpsrvi.cpp ===
//
//  Copyright    (c)    1998        Microsoft Corporation
//
//  Module Name:
//
//       nntpsrv.cpp
//
//  Abstract:
//
//		This module implements the INntpServer interface
//
//  Author:
//
//      Alex Wetmore
//
//  Revision History:

#include "tigris.hxx"

DWORD
CNntpServer::QueryServerMode()
/*++
Routine description:

    Get the server mode, whether it's in normal state, or rebuild
    state.  If it's in rebuild state, in what rebuild type ?

Arguments:

    None.

Return value:

    NNTP_SERVER_NORMAL/NNTP_SERVER_STANDARD_REBUILD/NNTP_SERVER_
--*/
{
    TraceFunctEnter( "CNntpServer::QueryServerMode" );
    DWORD   dwMode;

    if ( m_pInstance->m_BootOptions ) {

        if ( NNTPBLD_DEGREE_STANDARD == m_pInstance->m_BootOptions->ReuseIndexFiles )
            dwMode = NNTP_SERVER_STANDARD_REBUILD;
        else 
            dwMode = NNTP_SERVER_CLEAN_REBUILD;
    } else 
        dwMode = NNTP_SERVER_NORMAL;

    TraceFunctLeave();
    return dwMode;
}

BOOL
CNntpServer::SkipNonLeafDirWhenRebuild()
/*++
Routine description:

    Tells the client whether should skip non-leaf dir during rebuild

Arguments:

    None.

Return value:

    TRUE, should skip, FALSE otherwise
--*/
{
    return m_pInstance->m_BootOptions->OmitNonleafDirs;
}

BOOL
CNntpServer::ShouldContinueRebuild()
/*++
Routine description:

    Tells if anybody has cancelled the rebuild ?

Arguments:

    None.

Return value:

    TRUE, yes you should continue; FALSE otherwise
--*/
{
    return ( m_pInstance->m_BootOptions->m_dwCancelState != NNTPBLD_CMD_CANCEL_PENDING 
            && g_pInetSvc->QueryCurrentServiceState() != SERVICE_STOP_PENDING);
}

BOOL
CNntpServer::MessageIdExist( LPSTR szMessageId )
/*++
Routine description:

    Does this message id exist in the server article table ?

Arguments:

    LPSTR szMessageId - Message id to check

Return value:

    TRUE if exists, FALSE otherwise
--*/
{
    return m_pInstance->ArticleTable()->SearchMapEntry( szMessageId );
}

void
CNntpServer::SetRebuildLastError( DWORD err )
/*++
Routine description:

    Set the last error happened during rebuild

Arguments:

    DWORD dw - Last error

Return value:

    None.
--*/
{
    m_pInstance->SetRebuildLastError( err );
}

//
// find the primary groupid/articleid for an article given the secondary
// groupid/articleid
//
// arguments:
//  pgroupSecondary - the property bag for the secondary crosspost
//  artidSecondary - the article ID for the secondary crosspost
//  ppgroupPrimary - gets filled in with the property bag for the primary
//                   crosspost.  the caller should Release() this when
//                   they are done with it.
//  partidPrimary - the article id for the primary crosspost
//
// returns:
//  S_OK - found primary
//  S_FALSE - the values given were the primary
//  or an error code
//
void CNntpServer::FindPrimaryArticle(INNTPPropertyBag *pgroupSecondary,
                           			 DWORD   		  artidSecondary,
                           			 INNTPPropertyBag **ppgroupPrimary,
                           			 DWORD   		  *partidPrimary,
									 BOOL			  fStorePrimary,
									 INntpComplete    *pComplete,
									 INntpComplete    *pProtocolComplete )
{
	_ASSERT(m_pInstance != NULL);
	_ASSERT(ppgroupPrimary != NULL);
	_ASSERT(pgroupSecondary != NULL);
	_ASSERT(partidPrimary != NULL);
	if (pgroupSecondary == NULL || 
		ppgroupPrimary == NULL || 
		partidPrimary == NULL) 
	{
		pComplete->SetResult(E_INVALIDARG);
		pComplete->Release();
		return;
	}

	CXoverMap *pMap = m_pInstance->XoverTable();
	_ASSERT(pMap != NULL);
	if (pMap == NULL) {
		pComplete->SetResult(E_UNEXPECTED);
		pComplete->Release();
		return;
	}

	// get the secondary group id from the property bag
	DWORD groupidSecondary;
	HRESULT hr;
	hr = pgroupSecondary->GetDWord(NEWSGRP_PROP_GROUPID,
							       &groupidSecondary);
	if (FAILED(hr)) {
		pComplete->SetResult(hr);
		pComplete->Release();
		return;
	}

	// do the lookup
	DWORD groupidPrimary, artidPrimary;
	GROUP_ENTRY rgCrossposts[MAX_NNTPHASH_CROSSPOSTS];
	BYTE rgcStoreCrossposts[MAX_NNTPHASH_CROSSPOSTS];
	DWORD cGrouplistSize = sizeof(GROUP_ENTRY) * MAX_NNTPHASH_CROSSPOSTS;
	DWORD cGroups;

	if (!pMap->GetArticleXPosts(groupidSecondary,
								artidSecondary,
								FALSE,
								rgCrossposts,
								cGrouplistSize,
								cGroups,
								rgcStoreCrossposts))
	{
		pComplete->SetResult(HRESULT_FROM_WIN32(GetLastError()));
		pComplete->Release();
		return;
	}

	if (fStorePrimary) {
		// find the primary article for the store containing groupidSecondary.
		// we do this by scanning the crosspost list and keeping track of the
		// current store primary at any point in the list.  when we find
		// groupidSecondary in the list we will also know where its primary
		// is and can return that.
		DWORD i;				// current position in rgCrossposts
		DWORD iStorePrimaryPos = 0;	// position of current primary in rgCrossposts
		DWORD iStore;			// position in rgcStoreCrossposts
		DWORD cCrossposts;		// total of rgcStoreCrossposts to index iStore

		iStore = 0;
		cCrossposts = rgcStoreCrossposts[iStore];

		artidPrimary = -1;

		for (i = 0; artidPrimary == -1 && i < cGroups; i++) {
			if (i == cCrossposts) {
				iStore++;
				iStorePrimaryPos = i;
				cCrossposts += rgcStoreCrossposts[iStore];
			}
			if (rgCrossposts[i].GroupId == groupidSecondary) {
				_ASSERT(rgCrossposts[i].ArticleId == artidSecondary);
				groupidPrimary = rgCrossposts[iStorePrimaryPos].GroupId;
				artidPrimary = rgCrossposts[iStorePrimaryPos].ArticleId;
				break;
			}
		}
		_ASSERT(artidPrimary != -1);
		if (artidPrimary == -1) {
			// we aren't int he list of crossposts.  return the primary
			groupidPrimary = rgCrossposts[0].GroupId;
			artidPrimary = rgCrossposts[0].ArticleId;
		}
	} else {
		groupidPrimary = rgCrossposts[0].GroupId;
		artidPrimary = rgCrossposts[0].ArticleId;
	}

	// get the group property bag for the primary group
	CGRPPTR pGroup = m_pInstance->GetTree()->GetGroupById(groupidPrimary);
	if (pGroup == NULL) {
		// this should never happen with properly in-sync hash tables.  
		// BUGBUG - should we remove this entry from the hashtable?
		//_ASSERT(FALSE);
		pComplete->SetResult(HRESULT_FROM_WIN32(ERROR_NOT_FOUND));
		pComplete->Release();
		return;
	}

	*ppgroupPrimary = pGroup->GetPropertyBag();
#ifdef DEBUG
	if ( pProtocolComplete ) ((CNntpComplete*)pProtocolComplete)->BumpGroupCounter();
#endif
	*partidPrimary = artidPrimary;

	_ASSERT((groupidPrimary == groupidSecondary && artidPrimary == artidSecondary) ||
			(groupidPrimary != groupidSecondary));

	pComplete->SetResult((groupidPrimary == groupidSecondary) ? S_OK : S_FALSE);
	pComplete->Release();
}

//
// Create the entries in the hash tables for a new article.
//
void CNntpServer::CreatePostEntries(char				*pszMessageId,
					   			    DWORD				cHeaderLength,
					   			    STOREID				*pStoreId,
					   			    BYTE				cGroups,
					   			    INNTPPropertyBag	**rgpGroups,
					   			    DWORD				*rgArticleIds,
					   			    BOOL                fAllocArtId,
					   			    INntpComplete		*pCompletion)
{

	TraceQuietEnter("CNntpServer::CreatePostEntries");

	_ASSERT(pszMessageId != NULL);
	_ASSERT(pStoreId != NULL);
	_ASSERT(cGroups > 0);
	_ASSERT(rgpGroups != NULL);
	_ASSERT(rgArticleIds != NULL);
	_ASSERT(pCompletion != NULL);


    CArticleRef articleRef;

	if (pszMessageId == NULL || pStoreId == NULL ||
		cGroups == 0 || rgpGroups == NULL || rgArticleIds == NULL ||
		pCompletion == NULL)
	{
		pCompletion->SetResult(E_INVALIDARG);
		pCompletion->Release();
		return;
	}

	char rgchBuffer[4096];
	CAllocator allocator(rgchBuffer, 4096);
	CNEWSGROUPLIST grouplist;
	CNAMEREFLIST namereflist;

	if (!grouplist.fInit(cGroups, &allocator) || !namereflist.fInit(cGroups, &allocator)) {
		pCompletion->SetResult(E_OUTOFMEMORY);
		pCompletion->Release();
		return;
	}

	// allocate article ids for each of the groups
	DWORD i = 0;
	for (i = 0; i < cGroups; i++) {
		CNewsGroupCore *pGroup = ((CNNTPPropertyBag *) rgpGroups[i])->GetGroup();
		CPostGroupPtr PostGroupPtr(pGroup);
		grouplist.AddTail(PostGroupPtr);

		NAME_AND_ARTREF Nameref;
		(Nameref.artref).m_groupId = pGroup->GetGroupId();
		if ( fAllocArtId ) 
		    (Nameref.artref).m_articleId = pGroup->AllocateArticleId();
		else (Nameref.artref).m_articleId = rgArticleIds[i];
		(Nameref.pcName).vInsert(pGroup->GetNativeName());
		namereflist.AddTail(Nameref);

		if ( fAllocArtId ) rgArticleIds[i] = (Nameref.artref).m_articleId;

        // Save off the first group/article ID for use by AddArticleToPushFeeds
		if (i == 0) {
		    articleRef.m_groupId = (Nameref.artref).m_groupId;
		    articleRef.m_articleId = (Nameref.artref).m_articleId;
		}
	}

	CPCString pcXOver;

	CNntpReturn ret2;
	BOOL f = m_pInstance->ArticleTable()->InsertMapEntry(pszMessageId);
	if (!f) {
		ErrorTrace((DWORD_PTR)this, "InsertMapEntry failed, %x", GetLastError());
	} else {
		f = gFeedManfPost(m_pInstance->GetInstanceWrapper(),
						  grouplist,
						  namereflist,
						  NULL,
						  FALSE,
						  NULL,
						  (CStoreId *) pStoreId,
						  &cGroups,
						  1,
						  pcXOver,
						  ret2,
						  -3,
						  pszMessageId,
						  (WORD) cHeaderLength);
		if (f) {
            // We only want to add articles to the push feed if we're not
            // doing a rebuild.
            if (QueryServerMode() == NNTP_SERVER_NORMAL) {
		        if (!m_pInstance->GetInstanceWrapper()->AddArticleToPushFeeds(
				    grouplist,
					articleRef,
					NULL,
					ret2))
			    {
			    	ErrorTrace((DWORD_PTR)this, "AddArticleToPushFeeds failed, %x", GetLastError());
			    }
			}
        } else {
			ErrorTrace((DWORD_PTR)this, "gFeedManfPost failed, %x", GetLastError());
		}
	}

	if (!f) {
	    if (GetLastError() == ERROR_ALREADY_EXISTS)
	        pCompletion->SetResult(S_FALSE);
        else
		    pCompletion->SetResult(E_OUTOFMEMORY);
	} else {
		pCompletion->SetResult(S_OK);
	}

	pCompletion->Release();
	return;
}

void CNntpServer::AllocArticleNumber(BYTE				cGroups,
					   			    INNTPPropertyBag	**rgpGroups,
					   			    DWORD				*rgArticleIds,
					   			    INntpComplete		*pCompletion)
{
	_ASSERT(cGroups > 0);
	_ASSERT(rgpGroups != NULL);
	_ASSERT(rgArticleIds != NULL);
	_ASSERT(pCompletion != NULL);

	if (cGroups == 0 || rgpGroups == NULL || rgArticleIds == NULL ||
		pCompletion == NULL)
	{
		pCompletion->SetResult(E_INVALIDARG);
		pCompletion->Release();
		return;
	}

	// allocate article ids for each of the groups
	DWORD i = 0;
	for (i = 0; i < cGroups; i++) {
		CNewsGroupCore *pGroup = ((CNNTPPropertyBag *) rgpGroups[i])->GetGroup();
		if (pGroup == NULL) {
			pCompletion->SetResult(E_INVALIDARG);
			pCompletion->Release();
			return;
		}
		rgArticleIds[i] = pGroup->AllocateArticleId();
	}

	pCompletion->SetResult(S_OK);
	pCompletion->Release();
	return;
}

void
CNntpServer::DeleteArticle(
    char            *pszMessageId,
    INntpComplete   *pCompletion
    )
//
// Delete Article entries from hash table
//
{
    _ASSERT(m_pInstance != NULL);

    //
    // Confirm that the article is not in the table
    //

    WORD	HeaderOffset ;
    WORD	HeaderLength ;
    ARTICLEID ArticleNo;
    GROUPID GroupId;
    CStoreId storeid;

    //
    // Look for the article. It is OK if there is none.
    //
    if (!(m_pInstance->ArticleTable())->GetEntryArticleId( pszMessageId, 
                                                           HeaderOffset,
                                                           HeaderLength,
                                                           ArticleNo, 
                                                           GroupId,
                                                           storeid) )
    {
        if (ERROR_FILE_NOT_FOUND == GetLastError())
        {
		    pCompletion->SetResult(ERROR_FILE_NOT_FOUND);
        } else {
		    pCompletion->SetResult(E_INVALIDARG);
        }
		pCompletion->Release();
        return;
    }

    CNntpReturn ret2;
    //  Delete article out of hash table
    if ( ! (m_pInstance->ExpireObject()->ExpireArticle( m_pInstance->GetTree(), 
                                                        GroupId, 
                                                        ArticleNo, 
                                                        &storeid, 
                                                        ret2, 
                                                        NULL, 
                                                        TRUE,   //fMustDelete
                                                        FALSE, 
                                                        FALSE )))
    {
        pCompletion->SetResult(GetLastError());
    } else {
        pCompletion->SetResult(S_OK);
    }

    pCompletion->Release();
    return;
}

BOOL CNntpServer::IsSlaveServer(
    WCHAR*              pwszPickupDir,
    LPVOID              lpvContext
    )
{
    if (pwszPickupDir) {
        LPWSTR  pwsz = m_pInstance->QueryPickupDirectory();
        if (pwsz) {
            wcscpy(pwszPickupDir, pwsz);
        }
    }

    return (m_pInstance->m_ConfiguredMasterFeeds > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\nntpinst.cxx ===
/*++

   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        nntpinst.cxx

   Abstract:

        This module defines the NNTP_SERVER_INSTANCE class
		and the NNTP_IIS_SERVICE class.

   Author:

        Johnson Apacible    (JohnsonA)      June-04-1996

   Revision History:

        Kangrong Yan    ( KangYan )     Feb-28-1998
            Have MD notification function pick up MB events of feed config
            change.  Feed config used to be done thru RPCs.  But now Admin
            is supposed to write config updates directly to metabase and
            this change should be picked up by instance.  The instance is
            also responsible for feeding this update into feed blocks.

        Kangrong Yan    ( KangYan )     Oct-21-1998
            Rebuild code consolidation.

--*/

#include "tigris.hxx"
#include "smtpdll.h"

#include <nsepname.hxx>
#include <malloc.h>

//
//	Auth defaults
//

#define DEFAULT_ALLOW_ANONYMOUS         TRUE
#define DEFAULT_ALLOW_GUEST_ACCESS      TRUE
#define DEFAULT_ANONYMOUS_ONLY          FALSE

#define DEFAULT_READ_ACCESS_MASK        0
#define DEFAULT_WRITE_ACCESS_MASK       0
#define DEFAULT_MSDOS_DIR_OUTPUT        TRUE

#define DEFAULT_USE_SUBAUTH             TRUE
#define DEFAULT_LOGON_METHOD            LOGON32_LOGON_INTERACTIVE
#define DEFAULT_ANONYMOUS_PWD           ""
#define INETA_DEF_LEVELS_TO_SCAN		2

//
//	Globals
//
static  char    szPostsCode[] = "200 " ;
static  char    szPostsAllowed[] = " Posting Allowed \r\n" ;
static  char    szNoPostsCode[] = "201 " ;
static  char    szPostsNotAllowed[] = " Posting Not Allowed \r\n" ;
char    szTitle[] = "Nntpsvc" ;

const LPSTR     pszPackagesDefault = "NTLM\0";
const DWORD     ccbPackagesDefault = sizeof( "NTLM\0" );

PFN_SF_NOTIFY   g_pFlushMapperNotify[MT_LAST] = { NULL, NULL, NULL, NULL };
PFN_SF_NOTIFY   g_pSslKeysNotify = NULL;

static char mszStarNullNull[3] = "*\0";

extern STORE_CHANGE_NOTIFIER *g_pCAPIStoreChangeNotifier;

inline BOOL
ConvertToMultisz(LPSTR szMulti, DWORD *pdwCount, LPSTR szAuthPack)
{
	CHAR *pcStart = szAuthPack, *pc;
	DWORD dw = 0;

	pc = pcStart;
	if (*pc == '\0' || *pc == ',') return FALSE;

	*pdwCount = 0;
	while (TRUE) {
		if (*pc == '\0') {
			strcpy(&szMulti[dw], pcStart);
			(*pdwCount)++;
			dw += lstrlen(pcStart);
			szMulti[dw + 1] = '\0';
			return TRUE;
		}
		else if (*pc == ',') {
			*pc = '\0';
			strcpy(&szMulti[dw], pcStart);
			(*pdwCount)++;
			dw += lstrlen(pcStart);
			dw++;
			*pc = ',';
			pcStart = ++pc;
		}
		else {
			pc++;
		}
	}
}

DWORD
ParseDescriptor(
    IN const CHAR * Descriptor,
    OUT LPDWORD IpAddress,
    OUT PUSHORT IpPort,
    OUT const CHAR ** HostName
    );

DWORD
InitializeInstances(
    PNNTP_IIS_SERVICE pService
    )
/*++

Routine Description:

    Reads the instances from the metabase

Arguments:

    pService - Server instances added to.

Return Value:

    Win32

--*/
{
    DWORD   i;
    DWORD   cInstances = 0;
	MB      mb( (IMDCOM*) pService->QueryMDObject() );
    CHAR    szKeyName[MAX_PATH+1];
    DWORD   err = NO_ERROR;
    BUFFER  buff;
    BOOL    fMigrateRoots = FALSE;
    DWORD   dwEvent ;
	BOOL	fAtLeastOne = FALSE ;

	TraceFunctEnter("InitializeInstances");

    //
    //  Open the metabase for write to get an atomic snapshot
    //

ReOpen:

    if ( !mb.Open( "/LM/nntpsvc/",
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DebugTrace(0, "InitializeInstances: Cannot open path %s error %lu\n",
                    "/LM/NNTPSVC/", GetLastError() );

        //
        //  If the nntp service key isn't here, just create it
        //

        if ( !mb.Open( "",
                       METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ||
             !mb.AddObject( "/LM/NNTPSVC/" ))
        {
            return GetLastError();
        }

        DebugTrace(0, "/LM/NNTPSVC not found auto-created\n");

        mb.Close();
        goto ReOpen;
    }

    //
    // Loop through instance keys and build a list.  We don't keep the
    // metabase open because the instance instantiation code will need
    // to write to the metabase
    //

TryAgain:
    i = 0;
    while ( mb.EnumObjects( "",
                            szKeyName,
                            i++ ))
    {
        //BOOL fRet;
        DWORD dwInstance;
        //CHAR szRegKey[MAX_PATH+1];

        //
        // Get the instance id
        //

        DebugTrace(0,"instance key %s\n",szKeyName);

        dwInstance = atoi( szKeyName );
        if ( dwInstance == 0 ) {
            DebugTrace(0,"invalid instance ID %s\n",szKeyName);
            continue;
        }

        if ( buff.QuerySize() < (cInstances + 1) * sizeof(DWORD) )
        {
            if ( !buff.Resize( (cInstances + 10) * sizeof(DWORD)) )
            {
                return GetLastError();
            }
        }

        ((DWORD *) buff.QueryPtr())[cInstances++] = dwInstance;
    }

    if ( cInstances == 0 )
    {
        DebugTrace(0,"No defined instances\n");

        if ( !mb.AddObject( "1" ) )
        {
            DebugTrace(0,"Unable to create first instance: error %d\n", GetLastError() );
            return GetLastError();
        }

        fMigrateRoots = TRUE; // Force reg->metabase migration of virtual directories
        goto TryAgain;
    }

    _VERIFY( mb.Close() );

	//
	//	At this point we have at least one instance !
	//
    for ( i = 0; i < cInstances; i++ )
    {
        DWORD dwInstance = ((DWORD *)buff.QueryPtr())[i];

        if( !g_pInetSvc->AddInstanceInfo( dwInstance, fMigrateRoots ) ) {

            err = GetLastError();
            DebugTrace(0,"InitializeInstances: cannot create instance %lu error %lu\n",
					dwInstance,err);

#if 0
			// failure to boot an instance is fatal !
            break;
#endif
        } else {
			// at least one instance booted !
			fAtLeastOne = TRUE ;
		}
	}

	// the service will boot if at least one instance booted ok
	if( fAtLeastOne ) {
		err = NO_ERROR ;
	}

	//
	//	Now, that all instances have booted, kick off server wide threads
	//	like feeds and expires. These threads should skip any instances
	//	that are not in the started state. It is important to terminate these
	//	threads FIRST on the shutdown path !
	//
	if( !pService->InitiateServerThreads() ) {
		err = GetLastError();
		ErrorTrace(0,"Failed to InitiateServerThreads: error is %d", err);
		NntpLogEventEx( NNTP_INIT_SERVER_THREADS_FAILED, 0, (const CHAR**)NULL, err, 0 );
	}

	if( NO_ERROR == err )
	{
		//
		//	At this point, we have initialized all globals (including CPools),
		//	booted all server instances and started their ATQ engines.
		//

		// log an event on startup
		dwEvent = NNTP_EVENT_SERVICE_STARTED ;
		err = NO_ERROR ;

		// Log a successful boot event !
		PCHAR args [1];
		args [0] = szVersionString;

		NntpLogEvent(
				dwEvent,
				1,
				(const char**)args,
				0
				) ;
	}

    return err;

} // InitializeInstances

VOID
TerminateInstances(
    PNNTP_IIS_SERVICE pService
    )
/*++

Routine Destion:

    Shutdown each instance and terminate all global cpools

Arguments:

    pService - Server instances added to.

Return Value:

    Win32

--*/
{
	TraceFunctEnter("TerminateInstances");

    //
    //  Acquire and release global r/w lock
    //  This lock is acquired shared by all RPC code paths
    //  This enables any RPC threads that have "snuck" past
    //  FindIISInstance() to complete...
    //  NOTE that new RPCs will not get past FindIISInstance()
    //  because the service state is SERVICE_STOP_PENDING.
    //
    ACQUIRE_SERVICE_LOCK_EXCLUSIVE();
    RELEASE_SERVICE_LOCK_EXCLUSIVE();

	//
	//	Signal system threads (eg: rebuild threads) to stop
	//
	if( !pService->TerminateServerThreads() ) {
		//
		//	TODO: handle error
		//
		_ASSERT( FALSE );
	}

	TraceFunctLeave();
}

//+---------------------------------------------------------------
//
//  Function:   CheckIISInstance
//
//  Synopsis:   Checks an instance to see if it is running
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------
BOOL
CheckIISInstance(
    PNNTP_SERVER_INSTANCE pInstance
    )
{
	TraceFunctEnter("CheckIISInstance");

	//
	//	If the server instance is not in the started state, return FALSE
	//
	if( !pInstance ||
		(pInstance->QueryServerState() != MD_SERVER_STATE_STARTED) ||
		pInstance->m_BootOptions ||
		(g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING)
		   )
	{
		// instance is not runnable
		return FALSE ;
	}

	TraceFunctLeave();

	// instance is good
	return TRUE ;
}

PNNTP_SERVER_INSTANCE
FindIISInstance(
    PNNTP_IIS_SERVICE pService,
	DWORD	dwInstanceId,
	BOOL	fStarted
    )
/*++

Routine Description:

    Find an instance given the instance id

	!! If an instance is returned we will AddRef it, caller needs
	   to Deref !!

Arguments:

    pService - Server instances added to.

Return Value:

    Win32

--*/
{
	PFN_INSTANCE_ENUM pfnInstanceEnum = NULL ;
	PNNTP_SERVER_INSTANCE pInstance = NULL ;

	TraceFunctEnter("FindIISInstance");

	//
	//	Iterate over all instances
	//
	pfnInstanceEnum = (PFN_INSTANCE_ENUM)&CheckInstanceId;

	if( !pService->EnumServiceInstances(
									(PVOID)(SIZE_T)dwInstanceId,
									(PVOID)&pInstance,
									pfnInstanceEnum
									) )
	{
		DebugTrace(0,"Finished enumerating instances");
	}

	_ASSERT( !pInstance || (dwInstanceId == pInstance->QueryInstanceId()) );

	//
	//	If the server instance is not in the started state, return NULL !
	//
	if( fStarted && pInstance &&
		((pInstance->QueryServerState() != MD_SERVER_STATE_STARTED) ||
		  pInstance->m_BootOptions ||
		  (pService->QueryCurrentServiceState() != SERVICE_RUNNING)
		  ) )
	{
		pInstance->Dereference();
		pInstance = NULL;
	}

	TraceFunctLeave();

	return pInstance ;
}

//+---------------------------------------------------------------
//
//  Function:   CheckInstanceId
//
//  Synopsis:   Callback from IIS_SERVICE iterator
//
//  Arguments:  void
//
//  Returns:    TRUE is success, else FALSE
//
//  History:
//
//----------------------------------------------------------------

BOOL
CheckInstanceId(
		PVOID					pvContext,
		PVOID					pvContext1,
		PIIS_SERVER_INSTANCE	pInstance
		)
{
	PNNTP_SERVER_INSTANCE pNntpInstance = (PNNTP_SERVER_INSTANCE)pInstance ;
	DWORD dwInstanceId = (DWORD)((DWORD_PTR)pvContext);
	PNNTP_SERVER_INSTANCE* ppNntpInstance = (PNNTP_SERVER_INSTANCE*)pvContext1 ;

	//
	//	Check this instance for its id - if it matches the id we are looking for
	//	return FALSE to discontinue the iteration.
	//
	if( dwInstanceId == pNntpInstance->QueryInstanceId() )
	{
		// found it
		*ppNntpInstance = pNntpInstance ;
		pInstance->Reference();			// Caller needs to do a Deref !
		return FALSE ;
	}

	// did not find it - continue iteration
	return TRUE;
}

BOOL
FindIISInstanceRange(
    PNNTP_IIS_SERVICE pService,
	LPDWORD		pdwMinInstanceId,
	LPDWORD		pdwMaxInstanceId
    )
/*++

Routine Description:

    Find the min and max instance ids

Arguments:

    pService - Server instances added to.

Return Value:

    If TRUE, *pdwMinInstanceId and *pdwMaxInstanceId contain the
	right min and max values. If FALSE, they are both set to 0.

--*/
{
	PFN_INSTANCE_ENUM pfnInstanceEnum = NULL ;
	BOOL fRet = TRUE ;
	*pdwMinInstanceId = 0;
	*pdwMaxInstanceId = 0;

	TraceFunctEnter("FindIISInstanceRange");

	//
	//	Iterate over all instances
	//
	pfnInstanceEnum = (PFN_INSTANCE_ENUM)&CheckInstanceIdRange;

	if( !pService->EnumServiceInstances(
									(PVOID)pdwMinInstanceId,
									(PVOID)pdwMaxInstanceId,
									pfnInstanceEnum
									) ) {
		_ASSERT( FALSE );	// this should not happen !
	}

	_ASSERT( *pdwMinInstanceId != 0 );
	_ASSERT( *pdwMaxInstanceId != 0 );

	TraceFunctLeave();

	return fRet ;
}

//+---------------------------------------------------------------
//
//  Function:   CheckInstanceIdRange
//
//  Synopsis:   Callback from IIS_SERVICE iterator
//
//  Arguments:  void
//
//  Returns:    TRUE is success, else FALSE
//
//  History:
//
//----------------------------------------------------------------

BOOL
CheckInstanceIdRange(
		PVOID					pvContext,
		PVOID					pvContext1,
		PIIS_SERVER_INSTANCE	pInstance
		)
{
	LPDWORD	pdwMinInstanceId = (LPDWORD) pvContext  ;
	LPDWORD	pdwMaxInstanceId = (LPDWORD) pvContext1 ;
	DWORD	dwInstanceId	 = pInstance->QueryInstanceId();

	if( *pdwMinInstanceId == 0 )
	{
		//
		//	Initially set min and max to the first id
		//
		_ASSERT( *pdwMaxInstanceId == 0 );
		*pdwMinInstanceId = dwInstanceId ;
		*pdwMaxInstanceId = dwInstanceId ;
	} else {
		//
		//	Check to see if this instance's ID changes our min or max
		//
		if( dwInstanceId < *pdwMinInstanceId ) {
			//	found someone with an id lower than our min so far
			*pdwMinInstanceId = dwInstanceId ;
		}
		if( dwInstanceId > *pdwMaxInstanceId ) {
			//	found someone with an id higher than our max so far
			*pdwMaxInstanceId = dwInstanceId ;
		}
	}

	// continue iteration
	return TRUE;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::NNTP_SERVER_INSTANCE
//
//  Synopsis:   Constructor
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

NNTP_SERVER_INSTANCE::NNTP_SERVER_INSTANCE(
        IN PNNTP_IIS_SERVICE pService,
        IN DWORD  dwInstanceId,
        IN USHORT Port,
        IN LPCSTR lpszRegParamKey,
        IN LPWSTR lpwszAnonPasswordSecretName,
        IN LPWSTR lpwszVirtualRootsSecretName,
        IN BOOL   fMigrateRoots
        )
:   IIS_SERVER_INSTANCE(pService,
                        dwInstanceId,
                        Port,
                        lpszRegParamKey,
                        lpwszAnonPasswordSecretName,
                        lpwszVirtualRootsSecretName,
                        fMigrateRoots),

    m_signature                 (NNTP_SERVER_INSTANCE_SIGNATURE),
    m_fRecoveryBoot( FALSE ),
	m_ServiceStartCalled( FALSE ),
    m_hRegKey( 0 ),
    m_cbPostsAllowed( 0 ),
    m_cbPostsNotAllowed( 0 ),
	m_NntpDNSNameSize( 0 ),
	m_PeerGapSize( 0 ),
	m_BootOptions( NULL ),
	m_OurNntpRole( RolePeer ),
	m_HubNameSize( 0 ),
	m_pTree( NULL ),
	m_pNntpServerObject(NULL),
	m_pInstanceWrapper(NULL),
	m_pInstanceWrapperEx( NULL ),
	m_FeedManagerRunning( FALSE ),
	m_NumberOfMasters( 0 ),
	m_NumberOfPeersAndSlaves( 0 ),
	m_ConfiguredMasterFeeds( 0 ),
	m_ConfiguredSlaveFeeds( 0 ),
	m_ConfiguredPeerFeeds( 0 ),
	m_InitVar( 0 ),
	m_fAllFilesMustExist( FALSE ),
	m_fUseOriginal( TRUE ),
	m_pDirNot( NULL ),
	m_heNoPickups( NULL ),
	m_dwSslAccessPerms( 0 ),
	m_lpAdminEmail( NULL ),
	m_cbAdminEmail( 0 ),
	m_dwLevelsToScan( INETA_DEF_LEVELS_TO_SCAN ),
	m_cbCleartextAuthPackage(0),
	m_ProviderPackages( NULL ),
	m_cProviderPackages( 0 ),
	m_cFeedReportTimer( 0 ),
	m_cFeedReportInterval( 0 ),
	m_cMaxSearchResults( 0 ),
    m_pSSLInfo( NULL ),
    m_pIMailMsgClassFactory( NULL ),
    m_pRebuild( NULL ),
    m_dwLastRebuildError( NO_ERROR ),
    m_dwProgress( 0 )
{
	TraceFunctEnter("NNTP_SERVER_INSTANCE::NNTP_SERVER_INSTANCE");
    DebugTrace(0,"Init instance from %s\n", lpszRegParamKey );

	m_ProviderNames[0] = '\0';
	m_szMembershipBroker[0] = '\0';
	m_szCleartextAuthPackage[0] = '\0';

	//
	//	Init certificate mappers
	//

    for ( DWORD i = 0 ; i < MT_LAST ; ++i ) {
        m_apMappers[i] = NULL;
    }

#if 0
    // This check is done in iisnntp.cxx. Returning at this point
    // causes problems when the destructor is called !
    if ( QueryServerState( ) == MD_SERVER_STATE_INVALID ) {
        return;
    }
#endif

	//
	//	Set Metabase paths
	//

	lstrcpy( m_szMDFeedPath, QueryMDPath() );
	lstrcat( m_szMDFeedPath, "/Feeds/" );
	lstrcpy( m_szMDVRootPath, QueryMDPath() );
	lstrcat( m_szMDVRootPath, "/ROOT/" );

    //
    // Init statistics object
    //
    INIT_LOCK( &m_StatLock );
    ClearStatistics();

	// Misc Feeds stuff
	ZeroMemory( (PVOID)&m_ftCurrentTime, sizeof(FILETIME) );
	ZeroMemory( (PVOID)&m_liCurrentTime, sizeof(ULARGE_INTEGER) );

	//
	//	Initialize server greeting strings, file paths, DNS name etc
	//
	if( !InitializeServerStrings() ) {
		// handle error
	}

    //
    // Initialize Critical sections
    //
	InitializeCriticalSection( &m_critFeedRPCs ) ;
	InitializeCriticalSection( &m_critFeedTime ) ;
	InitializeCriticalSection( &m_critFeedConfig ) ;
	InitializeCriticalSection( &m_critNewsgroupRPCs ) ;
	InitializeCriticalSection( &m_critRebuildRpc ) ;
	InitializeCriticalSection( &m_critBoot ) ;

	// should be NULL to begin with
	m_pArticleTable = NULL ;
	m_pHistoryTable = NULL ;
	m_pXoverTable = NULL ;
	m_pXCache = NULL ;
	m_pExpireObject = NULL ;
	m_pVRootTable = NULL;
	m_pActiveFeeds = NULL ;
	m_pPassiveFeeds = NULL ;
	m_pInUseList = NULL ;

	// reset counters for client postings and directory pickup
	m_pFeedblockClientPostings = XNEW FEED_BLOCK;
	if (m_pFeedblockClientPostings != NULL) {
		ZeroMemory(m_pFeedblockClientPostings, sizeof(FEED_BLOCK));
		m_pFeedblockClientPostings->FeedId = (DWORD) -1;
		m_pFeedblockClientPostings->FeedType = FEED_TYPE_PASSIVE;
		m_pFeedblockClientPostings->Signature = FEED_BLOCK_SIGN;
		m_pFeedblockClientPostings->ServerName = 0;
	}
	m_pFeedblockDirPickupPostings = XNEW FEED_BLOCK;
	if (m_pFeedblockDirPickupPostings != NULL) {
		ZeroMemory(m_pFeedblockDirPickupPostings, sizeof(FEED_BLOCK));
		m_pFeedblockDirPickupPostings->FeedId = (DWORD) -2;
		m_pFeedblockDirPickupPostings->FeedType = FEED_TYPE_PASSIVE;
		m_pFeedblockDirPickupPostings->Signature = FEED_BLOCK_SIGN;
		m_pFeedblockDirPickupPostings->ServerName = 0;
	}

    TraceFunctLeave();

    return;

} // NNTP_SERVER_INSTANCE::NNTP_SERVER_INSTANCE

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::~NNTP_SERVER_INSTANCE
//
//  Synopsis:   Destructor
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

NNTP_SERVER_INSTANCE::~NNTP_SERVER_INSTANCE(
                        VOID
                        )
{
    DWORD i = 0;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::~NNTP_SERVER_INSTANCE");

	//
	// Stop() the instance - needs to be called after we unbind atq
	//

	Stop() ;

	if( m_ProviderPackages != NULL ) {
		LocalFree( (PVOID)m_ProviderPackages );
		m_ProviderPackages = NULL;
	}

    //
    // delete statistics object
    //
    DELETE_LOCK( &m_StatLock );

	//
	// delete the directory notification object
	//
	if (m_pDirNot != NULL) XDELETE m_pDirNot;
	m_pDirNot = NULL;
	if (m_heNoPickups != NULL) _VERIFY(CloseHandle(m_heNoPickups));
	m_heNoPickups = NULL;

	//
	// delete feed blocks
	//
    if ( m_pFeedblockClientPostings ) XDELETE m_pFeedblockClientPostings;
    m_pFeedblockClientPostings = NULL;
    if ( m_pFeedblockDirPickupPostings ) XDELETE m_pFeedblockDirPickupPostings;
    m_pFeedblockDirPickupPostings = NULL;

    //
    // Terminate Critical Sections
    //

	DeleteCriticalSection( &m_critFeedRPCs ) ;
	DeleteCriticalSection( &m_critFeedTime ) ;
	DeleteCriticalSection( &m_critFeedConfig ) ;
	DeleteCriticalSection( &m_critNewsgroupRPCs ) ;
	DeleteCriticalSection( &m_critRebuildRpc ) ;
	DeleteCriticalSection( &m_critBoot ) ;

    UINT iM;
    for ( iM = 0 ; iM < MT_LAST ; ++iM )
    {
        if ( m_apMappers[iM] )
        {
            ((RefBlob*)(m_apMappers[iM]))->Release();
        }
    }

    TraceFunctLeave();

} // NNTP_SERVER_INSTANCE::~NNTP_SERVER_INSTANCE

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::Start
//
//  Synopsis:   Called to start -
//				This function should return FALSE on all
//				boot errors. The fFatal param will be set to
//				TRUE if the boot error is fatal.
//
//				Returning FALSE will prevent the instance from
//				being started ie. it will be in the stopped state.
//				The only actions possible on such an
//				instance are things like nntpbld that correct
//				non-fatal boot errors.
//
//				All such non-fatal errors, will result in an
//				event log that tells the admin what to do to
//				correct the situation (eg run nntpbld)
//
//  Arguments:  fFatal - is set to TRUE if a fatal error occurs on boot
//
//  Returns:    TRUE is success, else FALSE
//
//  History:    HowardCu    Created         23 May 1995
//
//----------------------------------------------------------------
BOOL NNTP_SERVER_INSTANCE::Start( BOOL& fFatal )
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::Start" );

	BOOL	fSuccess = TRUE ;
	DWORD	err ;
	PCHAR	args [2];
	CHAR	szId [20];
	HRESULT hr;
	BOOL    fUpgrade = FALSE;

	EnterCriticalSection( &m_critBoot );

	m_ServiceStartCalled = TRUE ;
	//m_dwProgress = 0;
	fFatal = FALSE ;

	StartHintFunction() ;

	//
	//	Allocate memory for member objects
	//	These are freed in the Stop() function which will be called
	//	when the service stops.
	//
	if( !AllocateServerStructures() ) {
		fFatal = TRUE ;	// fatal
		goto Exit ;
	}

    //
    // Read the Nntp specfic params
	//	- private params are read from registry
	//	- public params are read from the metabase
    //

    if ( !ReadPrivateNntpParams( ) || !ReadPublicNntpParams( FC_NNTP_ALL ) ) {
		fFatal = TRUE ;	// fatal
		goto Exit ;
    }

	err = ReadAuthentInfo();
	if( err != NO_ERROR ) {
		// TODO: handle error
	}

    //  Read IP sec info from metabase
	ReadIpSecList();

	_VERIFY( m_pActiveFeeds->Init()  );
	_VERIFY( m_pPassiveFeeds->Init() );
    INITIALIZE_VAR( m_InitVar, FEEDLIST_INIT );

    //
    // Make sure all hash tables are either not here or
    // are all here.
    //

	if (!VerifyHashTablesExist()) {
		fSuccess = FALSE ;
	}

    //
	//	We will attempt to boot all data structures always. If any data str
	//	(like hash tables) do not boot, the server will be in a stopped state.
    //


	if( !(CNewsTree::InitCNewsTree( this, fFatal ) ) )  {
		fSuccess = FALSE ;
		if( fFatal ) { goto Exit ; }
    }

    INITIALIZE_VAR( m_InitVar, CNEWSTREE_INIT );

	if (!m_pTree->LoadTree( QueryGroupListFile(),
	                        QueryGroupVarListFile(),
	                        fUpgrade,
	                        QueryInstanceId(),
	                        m_fAllFilesMustExist)) {
		fSuccess = FALSE;
		goto Exit;
	}

	//
	//	Initialize expire policies from metabase and the rmgroup queue
	//	Only fatal errors are failure to allocate memory.
	//

    if( !m_pExpireObject->InitializeExpires( StopHintFunction, fFatal, QueryInstanceId() ) ) {
		fSuccess = FALSE ;
		if( fFatal ) { goto Exit ; }
	}

	INITIALIZE_VAR( m_InitVar, EXPIRE_INIT );
    INITIALIZE_VAR( m_InitVar, RMGROUP_QUEUE_INIT );


	//
	//	so far so good - lets do the hash tables now.
	//	if any one of them fail to boot, we will return FALSE
	//	and remain in the stopped state.

    if( !m_pArticleTable->Initialize( m_ArticleTableFile, 0, HashTableNoBuffering )  ) {

		args[0] = m_ArticleTableFile;
		NntpLogEventEx( NNTP_BAD_HASH_TABLE, 1, (const CHAR**)args, GetLastError(), QueryInstanceId() );

		fSuccess = FALSE ;
		goto Exit ;
	}

    INITIALIZE_VAR( m_InitVar, ARTICLE_TABLE_INIT );

    StartHintFunction() ;

    if( !m_pHistoryTable->Initialize(	m_HistoryTableFile,
										TRUE,
										0,
										DEF_EXPIRE_INTERVAL, // Default Expire Interval !
										4,					// Crawl at least 4 pages all the time !
										HashTableNoBuffering) ) {

		args[0] = m_HistoryTableFile;
		NntpLogEventEx( NNTP_BAD_HASH_TABLE, 1, (const CHAR**)args, GetLastError(), QueryInstanceId() );

		fSuccess = FALSE ;
		goto Exit ;
	}

    INITIALIZE_VAR( m_InitVar, HISTORY_TABLE_INIT );

    StartHintFunction() ;

    if( !m_pXoverTable->Initialize( m_XoverTableFile, 0, HashTableNoBuffering ) ) {

		args[0] = m_XoverTableFile;
		NntpLogEventEx( NNTP_BAD_HASH_TABLE, 1, (const CHAR**)args, GetLastError(), QueryInstanceId() );

		fSuccess = FALSE ;
		goto Exit ;
	}

    INITIALIZE_VAR( m_InitVar, XOVER_TABLE_INIT );

    StartHintFunction();

    //
    // Check consistency between xover table and newstree
    //
    if ( !ServerDataConsistent() ) {
        _ASSERT( 0 );
		NntpLogEventEx(NNTP_HASH_TABLE_INCONSISTENT,
			0,
			(const CHAR**)NULL,
			0,
			QueryInstanceId()
			);
        fSuccess = FALSE;
        goto Exit;
    }

    StartHintFunction() ;

	if (FAILED(m_pVRootTable->Initialize(QueryMDVRootPath(), m_pInstanceWrapperEx, fUpgrade ))) {
		fSuccess = FALSE;
		goto Exit;
	}

    INITIALIZE_VAR( m_InitVar, VROOTTABLE_INIT );

    //
    //	Call UpdateVrootInfo() to decorate the newsgroups with
    //	vroot properties like SSL access perms..
    //	UpdateVrootInfo() will try to read the MB only once per vroot
    //
    //  Dummy call, take out
    //m_pTree->UpdateVrootInfo();

    if( !m_pXCache->Init(MAX_HANDLES,StopHintFunction) ) {
		fFatal = TRUE ;	// fatal
		goto Exit ;
	}

    INITIALIZE_VAR( m_InitVar, CXOVER_CACHE_INIT );

    StartHintFunction() ;

    //
    // Start feed manager
    //

    if ( !InitializeFeedManager( this, fFatal ) ) {
		fSuccess = FALSE ;
		if( fFatal ) { goto Exit ; }
    }

    INITIALIZE_VAR( m_InitVar, FEED_MANAGER_INIT );

    StartHintFunction() ;

    //
	// initialize shinjuku
	//
	m_pSEORouter = NULL;
	/*
	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (hr == CO_E_ALREADYINITIALIZED || SUCCEEDED(hr)) {
	*/

	//
    // Get interface pointer for IMailMsg class factory
    //
    CLSID clsidIMsg;
	hr = CLSIDFromProgID( L"Exchange.MailMsg", &clsidIMsg );
	if (SUCCEEDED(hr)) {
	    hr = CoGetClassObject((REFCLSID) clsidIMsg,
		                       CLSCTX_INPROC_SERVER,
		                       NULL,
		                       (REFIID) IID_IClassFactory,
		                       (void**)&m_pIMailMsgClassFactory );
	}

	if ( FAILED( hr ) || NULL == m_pIMailMsgClassFactory ) {
	    _ASSERT( 0 );
	    ErrorTrace( 0, "Create IMailMsg class factory failed %x", hr );
	    m_pIMailMsgClassFactory = NULL;
	    fFatal = TRUE;
	    goto Exit;
	}


	hr = SEOGetRouter(NNTP_SOURCE_TYPE_GUID,
	    			  (REFGUID) CStringGUID(GUID_NNTPSVC, QueryInstanceId()),
						  &m_pSEORouter);
	if (hr != S_OK) {
		m_pSEORouter = NULL;
		NntpLogEventEx(SEO_INIT_FAILED_INSTANCE,
	    			   0,
					   (const char **) NULL,
					   hr,
					   QueryInstanceId());
	}
	else INITIALIZE_VAR(m_InitVar, SEO_INIT);

    StartHintFunction() ;

	//
	// Start directory pickup - should check server state
	// If server is in MD_SERVER_STATE_PAUSED, this should
	// be disabled.
	//
	if (m_szPickupDirectory[0] == (WCHAR) 0) {
		ErrorTrace(0, "no pickup directory specified");
	} else {
		//
		// we do not want dir notifications active during rebuilds !!
		// Ideally, we should be able to start this up, so
		// that we do not have special switches based on boot options !!
		// this check means that after nntpbld, the instance will
		// need to be restarted for dir notifications to be enabled.
		//

		if( m_BootOptions == NULL ) {
			//
			// create and start the pickup directory monitor
			//
			m_pDirNot = XNEW IDirectoryNotification;
			if (m_pDirNot == NULL) {
				TraceFunctLeave();
				fFatal = TRUE;
				goto Exit;
			}

			m_cPendingPickups = 0;
			m_heNoPickups = CreateEvent(NULL, TRUE, TRUE, NULL);
			if (m_heNoPickups == NULL) {
				XDELETE m_pDirNot;
				m_pDirNot = NULL;
			} else {
				this->Reference();
				hr = m_pDirNot->Initialize( m_szPickupDirectory,
							                this,
							                FALSE,
							                FILE_NOTIFY_CHANGE_FILE_NAME,
							                FILE_ACTION_ADDED,
							                PickupFile);
				if (FAILED(hr)) {
					this->Dereference();
					XDELETE m_pDirNot;
					m_pDirNot = NULL;
					//
					//	Failure to init dir not is not fatal
					//

					NntpLogEvent(NNTP_INIT_DIRNOT_FAILED,
						0,
						(const char **)NULL,
						hr
						);

				} else {
					INITIALIZE_VAR(m_InitVar, DIRNOT_INIT);
				}
			}
		}
	}


Exit:

	if( GetLastError() == ERROR_NOT_ENOUGH_MEMORY ) {
		fFatal = TRUE ;	// fatal
	}

	if( fFatal ) fSuccess = FALSE;	// No success with fatal errors !

	if( fSuccess ) {

		//  Log a successful boot event !
		args [0] = szVersionString;
		_itoa( QueryInstanceId(), szId, 10 );
		args [1] = szId;

		NntpLogEvent( NNTP_EVENT_INSTANCE_STARTED, 2, (const char**)args, 0 ) ;


	} else {
		ErrorTrace(0,"Instance %d boot failed: rebuild needed", QueryInstanceId() );
	}

	LeaveCriticalSection( &m_critBoot );

    TraceFunctLeave();
    return fSuccess ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::Stop
//
//  Synopsis:   Called to stop
//
//  Arguments:  VOID
//
//  Returns:    TRUE is success, else FALSE
//
//  History:    HowardCu    Created         23 May 1995
//
//----------------------------------------------------------------

BOOL NNTP_SERVER_INSTANCE::Stop()
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::Stop" );

	EnterCriticalSection( &m_critBoot );

	if( !m_ServiceStartCalled ) {
		LeaveCriticalSection( &m_critBoot );
		return FALSE ;
	}

    //
    //  Dont want feeds started while we're stopping !
    //
    if( IS_INITIALIZED( m_InitVar, FEED_MANAGER_INIT ) ) {
        TerminateFeedManager( this ) ;
		TERMINATE_VAR( m_InitVar, FEED_MANAGER_INIT ) ;
	}

	StopHintFunction() ;

	//
	// we shutdown directory notification in pTree->StopTree!
	//
	// note: sometimes StopTree doesn't get called (if the newstree
	// wasn't started for instance).  in those cases we shutdown here.
	//
	if (IS_INITIALIZED(m_InitVar, DIRNOT_INIT)) {
		WaitForPickupThreads();
		ShutdownDirNot();
		TERMINATE_VAR( m_InitVar, DIRNOT_INIT ) ;
	}

	StopHintFunction() ;

    //
    // enumerate all users to call their Disconnect method
    //
    if( m_pInUseList ) {
        m_pInUseList->EnumAllSess( EnumSessionShutdown, 0, 0 );
    }

    //
    // Release IMailmsg class factory
    //
    //_ASSERT( m_pIMailMsgClassFactory );
    if ( m_pIMailMsgClassFactory ) {
        m_pIMailMsgClassFactory->Release();
        m_pIMailMsgClassFactory = NULL;
    }

	//
	// shutdown shinjuku
	//
	if (IS_INITIALIZED(m_InitVar, SEO_INIT)) {
		// this causes SEO to drop all loaded objects (like ddrop)
		m_pSEORouter->Release();
		m_pSEORouter = NULL;
		TERMINATE_VAR( m_InitVar, SEO_INIT ) ;
	}

	//
	// here we see if we are getting shutdown because we are being
	// deleted.  if so then we'll remove all of our bindings from
	// the shinjuku event binding database
	//
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    if (mb.Open(QueryMDPath())) {
		// our metabase path still exists, so we aren't being deleted
		mb.Close();
	} else {
		// our metabase path is gone, delete the shinjuku binding
		// database
		HRESULT hr = UnregisterSEOInstance(QueryInstanceId());
		if (FAILED(hr)) {
			ErrorTrace(0, "UnregisterSEOInstance(%lu) failed with %x",
				QueryInstanceId(), hr);
			NntpLogEventEx(SEO_DELETE_INSTANCE_FAILED,
						   0,
						   (const char **) NULL,
						   hr,
						   QueryInstanceId());
		}
	}

	// clean up any dirnot references in the retryq
	if ( m_pDirNot ) m_pDirNot->CleanupQueue();

	CoFreeUnusedLibraries();
	StopHintFunction() ;

    //
    //  Terminate CNewsTree first so that all references to groups are aren't dead
    //  when we kill this guy !
    //
    if( IS_INITIALIZED( m_InitVar, RMGROUP_QUEUE_INIT ) ) {
        m_pExpireObject->TerminateRmgroups( m_pTree ) ;
		TERMINATE_VAR( m_InitVar, RMGROUP_QUEUE_INIT ) ;
    }

    //
    // Tell crawler threads to abbreviate their work.
    //
    if( IS_INITIALIZED( m_InitVar, CNEWSTREE_INIT ) ) {
		_ASSERT( m_pTree );
        m_pTree->StopTree() ;
	}

    if( IS_INITIALIZED( m_InitVar, EXPIRE_INIT ) ) {
        m_pExpireObject->TerminateExpires( GetInstanceLock() ) ;
		TERMINATE_VAR( m_InitVar, EXPIRE_INIT ) ;
	}

	StopHintFunction() ;

    if( IS_INITIALIZED( m_InitVar, CNEWSTREE_INIT ) ) {
		_ASSERT( m_pTree );
		m_pTree->TermTree() ;
	}

    if( IS_INITIALIZED( m_InitVar, VROOTTABLE_INIT ) ) {
		_ASSERT(m_pVRootTable != NULL);
		XDELETE m_pVRootTable;
		m_pVRootTable = NULL;
		TERMINATE_VAR( m_InitVar, VROOTTABLE_INIT ) ;
	}

	StopHintFunction() ;

    if( IS_INITIALIZED( m_InitVar, CNEWSTREE_INIT ) ) {
		_ASSERT( m_pTree );
		XDELETE m_pTree;
		m_pTree = NULL;
		TERMINATE_VAR( m_InitVar, CNEWSTREE_INIT ) ;
	}

	StopHintFunction();

    if( IS_INITIALIZED( m_InitVar, XOVER_TABLE_INIT ) ) {
        m_pXoverTable->Shutdown() ;
		TERMINATE_VAR( m_InitVar, XOVER_TABLE_INIT ) ;
	}

	StopHintFunction() ;

    if( IS_INITIALIZED( m_InitVar, HISTORY_TABLE_INIT ) ) {
        m_pHistoryTable->Shutdown() ;
		TERMINATE_VAR( m_InitVar, HISTORY_TABLE_INIT ) ;
	}

	StopHintFunction() ;

    if( IS_INITIALIZED( m_InitVar, ARTICLE_TABLE_INIT ) ) {
        m_pArticleTable->Shutdown() ;
		TERMINATE_VAR( m_InitVar, ARTICLE_TABLE_INIT ) ;
	}

	StopHintFunction() ;

    if( IS_INITIALIZED( m_InitVar, CXOVER_CACHE_INIT ) ) {
        m_pXCache->Term() ;
		TERMINATE_VAR( m_InitVar, CXOVER_CACHE_INIT ) ;
	}

	StopHintFunction() ;

    if( IS_INITIALIZED( m_InitVar, FEEDLIST_INIT ) ) {
        _ASSERT( m_pActiveFeeds && m_pPassiveFeeds );
    	m_pActiveFeeds->Term() ;
	    m_pPassiveFeeds->Term() ;
		TERMINATE_VAR( m_InitVar, FEEDLIST_INIT ) ;
	}

    //
    // free the SSL info object
    //
    if ( m_pSSLInfo != NULL ) {
        DWORD dwCount = IIS_SSL_INFO::Release( m_pSSLInfo );
        m_pSSLInfo = NULL;
    }

	m_rfAccessCheck.Reset( (IMDCOM*)g_pInetSvc->QueryMDObject() );

	FreeServerStructures();

    RegCloseKey( m_hRegKey ) ;
    m_hRegKey = 0 ;

    // Log a successful stop event !
    PCHAR args [2];
	CHAR  szId [20];
    args [0] = szVersionString;
	_itoa( QueryInstanceId(), szId, 10 );
	args [1] = szId;

    NntpLogEvent(
            NNTP_EVENT_INSTANCE_STOPPED,
            2,
            (const char**)args,
            0
            ) ;

	m_ServiceStartCalled = FALSE ;

	LeaveCriticalSection( &m_critBoot );
    return TRUE;
}

#if 0
//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::StartHashTables
//
//  Synopsis:   Call this function to boot several NNTP hash table
//				include XOVER.HSH, ARTICLE.HSH, XoverCache.
//				It also allocates all server structures.
//				TRUE if all tables boot successfully.
//
//				This is call from the rebuid thread to only boot
//				the hash table for STANDARD rebuild of group.lst.
//				Caller should be responsible to call StopHashTables()
//				upon rebuild complete to stop all hash tables before
//				attempting to boot the entire instance.
//
//				All such non-fatal errors, will result in an
//				event log that tells the admin what to do to
//				correct the situation (eg run MEDIUM/THOROUGH rebuild)
//
//  Arguments:  fFatal - is set to TRUE if a fatal error occurs on boot
//
//  Returns:    TRUE is success, else FALSE
//
//  History:
//
//----------------------------------------------------------------
BOOL NNTP_SERVER_INSTANCE::StartHashTables( void )
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::StartHashTables" );

	BOOL	fSuccess = TRUE ;
    BOOL    fFatal = FALSE;
    DWORD   err;
	PCHAR	args [2];

	EnterCriticalSection( &m_critBoot );

	m_ServiceStartCalled = TRUE ;

	//
	//	Allocate memory for member objects
	//	These are freed in the StopHashTables() function which will be called
	//	when rebuild finishes.
	//
	if( !AllocateServerStructures() ) {
		fSuccess = FALSE ;	// fatal
		goto Exit ;
	}

    //
    // Read the Nntp specfic params
	//	- private params are read from registry
	//	- public params are read from the metabase
    //  only need to read public params.
    //

    if ( !ReadPublicNntpParams( FC_NNTP_ALL ) ) {
		fSuccess = FALSE ;
		goto Exit ;
    }

    //
    // If we are booting up with the correct boot option:
    // a) Delete m_BootOptions->szGroupListTmp
    // b) Swap the value for m_GroupListFile and
    // m_BootOptions->szGroupListTmp so we rebuild on szGroupListTmp
    //
    if (m_BootOptions)
    {
        if (m_BootOptions->ReuseIndexFiles == NNTPBLD_DEGREE_STANDARD)
        {
            _ASSERT( m_BootOptions->szGroupListTmp );
            _ASSERT( m_GroupListFile );

            DeleteFile( m_BootOptions->szGroupListTmp );

            CHAR    psz[MAX_PATH];
            lstrcpy( psz, m_GroupListFile );
            lstrcpy( m_GroupListFile, m_BootOptions->szGroupListTmp );
            lstrcpy( m_BootOptions->szGroupListTmp, psz );
        }
    }

    //
    // Make sure both hash tables exists!!!
    //

	if (!VerifyHashTablesExist( TRUE )) {
		// TODO: BINLIN add eventlog to indicate running Thorough rebuild
        fSuccess = FALSE;
        goto Exit;
	}

#if 0
    m_pTree = XNEW CNewsTree() ;
	if( !m_pTree ) { fSuccess = FALSE;	goto Exit; }

	if( !(CNewsTree::InitCNewsTree( this, fFatal ) ) )  {

		if( fFatal ) { fSuccess = FALSE ; goto Exit ; }
    }

    INITIALIZE_VAR( m_InitVar, CNEWSTREE_INIT );
#endif

    //
    //	Call UpdateVrootInfo() to decorate the newsgroups with
    //	vroot properties like SSL access perms..
    //	UpdateVrootInfo() will try to read the MB only once per vroot
    //
#if 0
    m_pTree->UpdateVrootInfo();
#endif

    //
    // Boot the XoverCache data structure
    //
    if( !m_pXCache->Init(MAX_HANDLES,StopHintFunction) ) {
		fSuccess = FALSE;
		goto Exit ;
	}

    INITIALIZE_VAR( m_InitVar, CXOVER_CACHE_INIT );

	//
	//	so far so good - lets do the hash tables now.
	//	if any one of them fail to boot, we will return FALSE
	//

    if( !m_pArticleTable->Initialize( m_ArticleTableFile, 0, HashTableNoBuffering )  ) {

		args[0] = m_ArticleTableFile;
		NntpLogEventEx( NNTP_BAD_HASH_TABLE, 1, (const CHAR**)args, GetLastError(), QueryInstanceId() );

		fSuccess = FALSE ;
		goto Exit ;
	}

    INITIALIZE_VAR( m_InitVar, ARTICLE_TABLE_INIT );

    if( !m_pXoverTable->Initialize( m_XoverTableFile, 0, HashTableNoBuffering ) ) {

		args[0] = m_XoverTableFile;
		NntpLogEventEx( NNTP_BAD_HASH_TABLE, 1, (const CHAR**)args, GetLastError(), QueryInstanceId() );

		fSuccess = FALSE ;
		goto Exit ;
	}

    INITIALIZE_VAR( m_InitVar, XOVER_TABLE_INIT );

Exit:

	err = GetLastError();
	if( !fSuccess ) {

		ErrorTrace(0,"Instance %d failed to boot hash tables during rebuild - %X", QueryInstanceId(), err );
	}

	LeaveCriticalSection( &m_critBoot );

    TraceFunctLeave();
    return fSuccess ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::StopHashTables
//
//  Synopsis:   Called to stop hash tables booted by StartHashTables
//
//  Arguments:  VOID
//
//  Returns:    TRUE is success, else FALSE
//
//  History:
//
//----------------------------------------------------------------

BOOL NNTP_SERVER_INSTANCE::StopHashTables()
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::StopHashTables" );

	EnterCriticalSection( &m_critBoot );

	if( !m_ServiceStartCalled ) {
		LeaveCriticalSection( &m_critBoot );
		return FALSE ;
	}

    if( IS_INITIALIZED( m_InitVar, CNEWSTREE_INIT ) ) {
		_ASSERT( m_pTree );
		m_pTree->TermTree( ) ;
		XDELETE m_pTree;
		m_pTree = NULL;
		TERMINATE_VAR( m_InitVar, CNEWSTREE_INIT ) ;
	}

    if( IS_INITIALIZED( m_InitVar, XOVER_TABLE_INIT ) ) {
        m_pXoverTable->Shutdown() ;
		TERMINATE_VAR( m_InitVar, XOVER_TABLE_INIT ) ;
	}

    if( IS_INITIALIZED( m_InitVar, ARTICLE_TABLE_INIT ) ) {
        m_pArticleTable->Shutdown() ;
		TERMINATE_VAR( m_InitVar, ARTICLE_TABLE_INIT ) ;
	}

    if( IS_INITIALIZED( m_InitVar, CXOVER_CACHE_INIT ) ) {
        m_pXCache->Term() ;
		TERMINATE_VAR( m_InitVar, CXOVER_CACHE_INIT ) ;
	}

	FreeServerStructures();

	m_ServiceStartCalled = FALSE ;

	LeaveCriticalSection( &m_critBoot );
    return TRUE;
}
#endif

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::ReadPrivateNntpParams
//
//  Synopsis:   Read private reg settings
//				Reads reg values not defined in UI
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::ReadPrivateNntpParams()
{
    DWORD   dw;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::ReadPrivateNntpParams");

    //
    //  Default set of commands to log.
    //  Unless we pick up something otherwise from the registry -
    //  we will generate transaction logs for the following commands.
    //

    m_dwCommandLogMask = (DWORD) (
                            eArticle |
                            eBody	 |
                            eHead    |
                            eIHave   |
                            ePost    |
                            eXReplic |
                            eQuit    |
                            eUnimp   |	// eUnimp - really means anything we dont recognize
							eOutPush ) ;


	//	NOTE: this is closed in the instance destructor
    if (!RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                        QueryRegParamKey(),
                        0,
                        KEY_READ | KEY_WRITE,
                        &m_hRegKey ) == ERROR_SUCCESS)

    {
        return  FALSE ;

    }   else    {

		BOOL fNonBlocking = TRUE;
        if( GetRegDword( m_hRegKey, StrBuffer, &dw )  ) {
			fNonBlocking = (dw != 0) ;
            g_pNntpSvc->SetNonBlocking(fNonBlocking) ;
        }

        DebugTrace( (DWORD_PTR)this,    "Buffered Writes %sabled",
                    fNonBlocking ? "En" : "Dis" ) ;

        //
        // if buffered writes are disabled then the default is
        // set the send buffer sizes to 0 to control buffer
        // allocations at the applcation level
        //
        if( fNonBlocking == FALSE ) {
            g_pNntpSvc->SetSockSendBuffSize( 0 ) ;
        }

        if( GetRegDword(m_hRegKey, StrSocketRecvSize, &dw ) ) {
            g_pNntpSvc->SetSockSendBuffSize( (int)dw ) ;
        }
        if( GetRegDword(m_hRegKey, StrSocketSendSize, &dw ) ) {
            g_pNntpSvc->SetSockRecvBuffSize( (int)dw ) ;
        }

        if( GetRegDword(m_hRegKey, StrCommandLogMask, &dw ) ) {
            m_dwCommandLogMask = dw ;
        }
	}

    if( GetRegDword(    m_hRegKey,  StrCleanBoot,   &dw ) ) {
        if( dw == 0 ) {
            m_fRecoveryBoot = TRUE ;
        }
    }

    if( !ReadMappers() ) {
    	//
    	//	No mapper configured
    	//
    	DebugTrace(0,"ReadMappers failed");
   	}

	return TRUE ;

} // NNTP_SERVER_INSTANCE::ReadPrivateNntpParams

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::ReadPublicNntpParams
//
//  Synopsis:   Read public config info from metabase
//
//  Arguments:
//
//  Returns:    TRUE if successful, FALSE on error
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::ReadPublicNntpParams(
    IN FIELD_CONTROL FieldsToRead
    )
{
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
	DWORD   dwSize = MAX_PATH, dw ;
	CHAR	data [1024];
	DWORD   err = NO_ERROR;
	BOOL	fSuccess = TRUE;
	STR		str;

    ENTER("ReadPublicNntpParams")

	//
	//	This lock is grabbed by any code that reads config params like
	//	SmtpServerAddress etc.
	//

    LockConfigWrite();

	//
	//	Open the metabase key for this instance and
	//	read all params !
	//

    if ( mb.Open( QueryMDPath() ) )
	{
		if( IsFieldSet( FieldsToRead, FC_NNTP_AUTHORIZATION ) ) {
			if ( !mb.GetDword( "",
							   MD_AUTHORIZATION,
							   IIS_MD_UT_SERVER,
							   &m_dwAuthorization ) )
			{
				m_dwAuthorization = MD_AUTH_ANONYMOUS;
			}
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_POSTINGMODES ) ) {
			if ( !mb.GetDword( "",
							   MD_ALLOW_CLIENT_POSTS,
							   IIS_MD_UT_SERVER,
							   &dw ) )
			{
				m_fAllowClientPosts = NNTP_DEF_ALLOWCLIENTPOSTS ;
			} else {
				m_fAllowClientPosts = dw ? TRUE : FALSE ;
			}

			if ( !mb.GetDword( "",
							   MD_ALLOW_FEED_POSTS,
							   IIS_MD_UT_SERVER,
							   &dw ) )
			{
				m_fAllowFeedPosts = NNTP_DEF_ALLOWFEEDPOSTS ;
			} else {
				m_fAllowFeedPosts = dw ? TRUE : FALSE ;
			}
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_POSTLIMITS ) ) {
			if ( !mb.GetDword( "",
							   MD_CLIENT_POST_SOFT_LIMIT,
							   IIS_MD_UT_SERVER,
							   &m_cbSoftLimit ) )
			{
				m_cbSoftLimit = NNTP_DEF_CLIENTPOSTSOFTLIMIT ;
			}

			if ( !mb.GetDword( "",
							   MD_CLIENT_POST_HARD_LIMIT,
							   IIS_MD_UT_SERVER,
							   &m_cbHardLimit ) )
			{
				m_cbHardLimit = NNTP_DEF_CLIENTPOSTHARDLIMIT ;
			}
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_FEEDLIMITS ) ) {
			if ( !mb.GetDword( "",
							   MD_FEED_POST_SOFT_LIMIT,
							   IIS_MD_UT_SERVER,
							   &m_cbFeedSoftLimit ) )
			{
				m_cbFeedSoftLimit = NNTP_DEF_FEEDPOSTSOFTLIMIT ;
			}

			if ( !mb.GetDword( "",
							   MD_FEED_POST_HARD_LIMIT,
							   IIS_MD_UT_SERVER,
							   &m_cbFeedHardLimit ) )
			{
				m_cbFeedHardLimit = NNTP_DEF_FEEDPOSTHARDLIMIT ;
			}
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_CONTROLSMSGS ) ) {
			if ( !mb.GetDword( "",
							   MD_ALLOW_CONTROL_MSGS,
							   IIS_MD_UT_SERVER,
							   &dw ) )
			{
				m_fAllowControlMessages = NNTP_DEF_ALLOWCONTROLMSGS ;
			} else {
				m_fAllowControlMessages = dw ? TRUE : FALSE ;
			}
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_SMTPADDRESS ) ) {
			dwSize = MAX_PATH ;
			if( !mb.GetString(	"",
								MD_SMTP_SERVER,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				m_szSmtpAddress[0] = (WCHAR)0;
				m_cbSmtpAddress = sizeof(WCHAR);
			} else {
				ZeroMemory( m_szSmtpAddress, sizeof( m_szSmtpAddress ) ) ;

				m_cbSmtpAddress =
					MultiByteToWideChar(	CP_ACP, MB_PRECOMPOSED, data, dwSize, m_szSmtpAddress,
						sizeof( m_szSmtpAddress ) / sizeof( m_szSmtpAddress[0] ) ) ;
				m_cbSmtpAddress *= sizeof(WCHAR);
			}
		}

		//
    	// Update auth stuff
		//

    	if (IsFieldSet( FieldsToRead, FC_NTAUTHENTICATION_PROVIDERS))
		{
			CHAR szAuthPack[MAX_PATH];
			DWORD dwLen;
			if (mb.GetStr("", MD_NTAUTHENTICATION_PROVIDERS, IIS_MD_UT_SERVER, &str, METADATA_INHERIT, ""))
			{
				lstrcpy(szAuthPack, str.QueryStr());
				dwLen = lstrlen(szAuthPack);
				DebugTrace((LPARAM)this, "Authentication packages=%s", szAuthPack);
				if (!ConvertToMultisz(m_ProviderNames, &m_cProviderPackages, szAuthPack))
				{
					CopyMemory(m_ProviderNames, pszPackagesDefault, ccbPackagesDefault);
					m_cProviderPackages = 1;
				}
			}
			else
			{
				DebugTrace((LPARAM)this, "Use default authentication packages=%s", pszPackagesDefault);
				CopyMemory(m_ProviderNames, pszPackagesDefault, ccbPackagesDefault);
				m_cProviderPackages = 1;
			}

			// set the AUTH_BLOCK info
			if (!SetProviderPackages())
			{
				ErrorTrace((LPARAM)this, "Unable to allocate AUTH_BLOCK");
			}
		}

		//
		// Read the Membership Broker name that will be used with MBS_BASIC
		//

	    if (IsFieldSet( FieldsToRead, FC_MD_SERVER_SS_AUTH_MAPPING))
		{
			if (mb.GetStr("", MD_MD_SERVER_SS_AUTH_MAPPING, IIS_MD_UT_SERVER, &str, METADATA_INHERIT, ""))
			{
				strncpy(m_szMembershipBroker, str.QueryStr(), MAX_PATH);
				StateTrace((LPARAM)this, "Membership Broker name is set to %s", m_szMembershipBroker);
			}
			else
			{
				m_szMembershipBroker[0] = '\0';
				StateTrace((LPARAM)this, "No Membership Broker name configured");
			}
		}

	    if (IsFieldSet( FieldsToRead, FC_NNTP_CLEARTEXT_AUTH_PROVIDER))
		{
			m_cbCleartextAuthPackage = sizeof(m_szCleartextAuthPackage);
			if (mb.GetStr("", MD_NNTP_CLEARTEXT_AUTH_PROVIDER, IIS_MD_UT_SERVER, &str, METADATA_INHERIT, ""))
			{
				lstrcpy(m_szCleartextAuthPackage, str.QueryStr());
				m_cbCleartextAuthPackage = lstrlen(m_szCleartextAuthPackage) + 1;

				StateTrace((LPARAM)this, "Cleartext authentication provider: <%s>, length %u",
							m_szCleartextAuthPackage,
							m_cbCleartextAuthPackage);
			}
			else
			{
				m_szCleartextAuthPackage[0] = '\0';
				m_cbCleartextAuthPackage = 0;
				StateTrace((LPARAM)this, "No default cleartext authentication provider specified, using CleartextLogon");
			}
		}

		//	TODO: define a bit mask if this param can be changed on the fly
		if( FieldsToRead == FC_NNTP_ALL ) {
			if (!mb.GetDword( "",
							  MD_FEED_REPORT_PERIOD,
							  IIS_MD_UT_SERVER,
							  &dw))
			{
				m_cFeedReportInterval = NNTP_DEF_FEED_REPORT_PERIOD;
			} else {
				m_cFeedReportInterval = dw;
			}

			if (!mb.GetDword( "",
							  MD_MAX_SEARCH_RESULTS,
							  IIS_MD_UT_SERVER,
							  &dw))
			{
				m_cMaxSearchResults = NNTP_DEF_MAX_SEARCH_RESULTS;
			} else {
				m_cMaxSearchResults = dw;
			}

			dwSize = MAX_PATH ;
			if( !mb.GetString(	"",
								MD_PICKUP_DIRECTORY,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				m_szPickupDirectory[0] = (WCHAR)0;
				m_cbPickupDirectory = sizeof(WCHAR);
			} else {
				ZeroMemory( m_szPickupDirectory, sizeof( m_szPickupDirectory ) ) ;

				m_cbPickupDirectory =
					MultiByteToWideChar(	CP_ACP, MB_PRECOMPOSED, data, dwSize, m_szPickupDirectory,
						sizeof( m_szPickupDirectory ) / sizeof( m_szPickupDirectory[0] ) ) ;
				m_cbPickupDirectory *= sizeof(WCHAR);

				if (m_szPickupDirectory[lstrlenW(m_szPickupDirectory) - 1] != L'\\')
					lstrcatW(m_szPickupDirectory, L"\\");
			}

			dwSize = MAX_PATH ;
			if( !mb.GetString(	"",
								MD_FAILED_PICKUP_DIRECTORY,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				m_szFailedPickupDirectory[0] = (WCHAR)0;
				m_cbFailedPickupDirectory = sizeof(WCHAR);
			} else {
				ZeroMemory( m_szFailedPickupDirectory, sizeof( m_szFailedPickupDirectory ) ) ;

				m_cbFailedPickupDirectory =
					MultiByteToWideChar(	CP_ACP, MB_PRECOMPOSED, data, dwSize, m_szFailedPickupDirectory,
						sizeof( m_szFailedPickupDirectory ) / sizeof( m_szFailedPickupDirectory[0] ) ) ;
				m_cbFailedPickupDirectory *= sizeof(WCHAR);

				if (m_szFailedPickupDirectory[lstrlenW(m_szFailedPickupDirectory) - 1] != L'\\')
					lstrcatW(m_szFailedPickupDirectory, L"\\");
			}
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_UUCPNAME ) ) {
			dwSize = MAX_PATH ;
			ZeroMemory( m_szUucpName, sizeof( m_szUucpName ) ) ;
			if( !mb.GetString(	"",
								MD_NNTP_UUCP_NAME,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				m_cbUucpName =
					MultiByteToWideChar(	CP_ACP, MB_PRECOMPOSED, m_NntpHubName, m_HubNameSize, m_szUucpName,
						sizeof( m_szUucpName ) / sizeof( m_szUucpName[0] ) ) ;
			} else {
				m_cbUucpName =
					MultiByteToWideChar(	CP_ACP, MB_PRECOMPOSED, data, dwSize, m_szUucpName,
						sizeof( m_szUucpName ) / sizeof( m_szUucpName[0] ) ) ;
			}
			m_cbUucpName *= sizeof(WCHAR);
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_DEFAULTMODERATOR ) ) {
			dwSize = MAX_MODERATOR_NAME ;
			if( !mb.GetString(	"",
								MD_DEFAULT_MODERATOR,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				m_szDefaultModerator[0] = (WCHAR)0;
				m_cbDefaultModerator = sizeof(WCHAR);
			} else {
				m_cbDefaultModerator =
					MultiByteToWideChar(	CP_ACP, MB_PRECOMPOSED, data, dwSize, m_szDefaultModerator,
						sizeof( m_szDefaultModerator ) / sizeof( m_szDefaultModerator[0] ) ) ;
				m_cbDefaultModerator *= sizeof(WCHAR);
			}
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_UUCPNAME ) ) {

    		//
	    	// Get the name of the master
	    	// Pickup MB notification only if in no-posting mode !
	    	// The hub name is used in the posting path for the path hdr etc
		    //

		    if( (!FAllowClientPosts() && !FAllowFeedPosts()) ||
		        (FieldsToRead == FC_NNTP_ALL) ) {

    		    // default !
        		lstrcpy(m_NntpHubName, m_NntpDNSName ) ;
	        	dwSize = 1024 ;
		        if( mb.GetString(	"",
			        				MD_NNTP_UUCP_NAME,
				        			IIS_MD_UT_SERVER,
					        		data,
						        	&dwSize  ) )
        		{
	        		if( data[0] != '\0' ) {
		        		lstrcpy(m_NntpHubName, data);
			        }
		        }

    		    m_HubNameSize = lstrlen(m_NntpHubName);

        		DO_DEBUG(REGISTRY) {
	        		DebugTrace(0,"Hubname set to %s\n", m_NntpHubName);
		        }
	        }
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_DISABLE_NEWNEWS ) ) {
			if ( !mb.GetDword( "",
							   MD_DISABLE_NEWNEWS,
							   IIS_MD_UT_SERVER,
							   &dw ) )
			{
		        //	Default should already be set !
		        m_fNewnewsAllowed = TRUE ;
			} else {
				m_fNewnewsAllowed = dw ? FALSE : TRUE ;
			}
		}

		//
		//	Get the vroot depth level - default is 2
		//

    	if( !mb.GetDword( 	"",
            		     	MD_LEVELS_TO_SCAN,
		                 	IIS_MD_UT_SERVER,
                		 	&m_dwLevelsToScan
		                 	) )
		{
			m_dwLevelsToScan = INETA_DEF_LEVELS_TO_SCAN ;
		}

		//	TODO: define a bit mask if this param can be changed on the fly
		if( FieldsToRead == FC_NNTP_ALL ) {
			dwSize = 1024 ;
    		lstrcpy( m_ListFileName, "\\\\?\\" ) ;
			if( !mb.GetString(	"",
								MD_LIST_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				// default !
				lstrcat(m_ListFileName, NNTP_DEF_LISTFILE);
			} else {
				lstrcat(m_ListFileName, data);
			}

			DO_DEBUG(REGISTRY) {
				DebugTrace(0,"List file set to %s\n",m_ListFileName);
			}

			dwSize = 1024 ;
			if( !mb.GetString(	"",
								MD_ARTICLE_TABLE_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	There should already be a default set up before we are called !
				//
			} else {
				lstrcpy( m_ArticleTableFile, data ) ;
			}

			dwSize = 1024 ;
			if( !mb.GetString(	"",
								MD_HISTORY_TABLE_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	There should already be a default set up before we are called !
				//
			} else {
				lstrcpy( m_HistoryTableFile, data ) ;
			}

			dwSize = 1024 ;
			if( !mb.GetString(	"",
								MD_XOVER_TABLE_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	There should already be a default set up before we are called !
				//
			} else {
				lstrcpy( m_XoverTableFile, data ) ;
			}

			dwSize = 1024 ;
			if( !mb.GetString(	"",
								MD_GROUP_LIST_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	There should already be a default set up before we are called !
				//
			} else {
				lstrcpy( m_GroupListFile, data ) ;
                SetGroupListBakTmpPath();
			}

			dwSize = 1024 ;
			if( !mb.GetString(	"",
								MD_GROUPVAR_LIST_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	This is a hack to make groupvar.lst path the same as group.lst
				//  This should be taken out once we can configure virtual instances
				//  using rserver.vbs
				//
				strcpy( m_GroupVarListFile, m_GroupListFile );
				LPSTR lpstrPtr = m_GroupVarListFile + strlen( m_GroupVarListFile );
				while( lpstrPtr != m_GroupVarListFile && *lpstrPtr != '\\' )
				    lpstrPtr--;
				strcpy( lpstrPtr + 1, "groupvar.lst" );
			} else {
				lstrcpy( m_GroupVarListFile, data ) ;
                //SetGroupListBakTmpPath();
			}

			dwSize = 1024 ;
			if( !mb.GetString(	"",
								MD_GROUP_HELP_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	There should already be a default set up before we are called !
				//
			} else {
				lstrcpy( m_GroupHelpFile, data ) ;
			}

			dwSize = 1024 ;
			if( !mb.GetString(	"",
								MD_MODERATOR_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	There should already be a default set up before we are called !
				//
			} else {
				lstrcpy( m_ModeratorFile, data ) ;
			}

			dwSize = 1024 ;
			if( !mb.GetString(	"",
								MD_PRETTYNAMES_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	There should already be a default set up before we are called !
				//
			} else {
				lstrcpy( m_PrettynamesFile, data ) ;
			}

			dwSize = 1024 ;
			if( !mb.GetString(	"",
								MD_DROP_DIRECTORY,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	There should already be a default set up before we are called !
				//
			} else {
				lstrcpy( m_szDropDirectory, data ) ;
			}

			dwSize = MAX_MODERATOR_NAME ;
			if( mb.GetString(	"",
								MD_ADMIN_EMAIL,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				m_lpAdminEmail =  XNEW char [dwSize];
				if( m_lpAdminEmail ) {
					lstrcpy( m_lpAdminEmail, data );
					m_cbAdminEmail = dwSize;
				}
			}
		}

	} else {

        ErrorTrace(0,"Error opening %s\n", QueryMDPath() );
		UnLockConfigWrite();
        LEAVE
		return FALSE ;
    }

    mb.Close();
    UnLockConfigWrite();

    LEAVE
    return(TRUE);

} // NNTP_SERVER_INSTANCE::ReadPublicNntpParams

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::ReadMappers
//
//  Synopsis:   Read mappers for this instance
//
//  Arguments:  None
//
//  Returns:    TRUE if successful, FALSE otherwise
//
//  Notes  :    Instance must be locked before calling this function
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::ReadMappers(
    )
{
    MB      			mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    DWORD               dwR;
    UINT                iM;
    LPVOID              aOldMappers[MT_LAST];
    BOOL                fSt = FALSE;

    LockConfigWrite();

	//
	// get ssl setting
	//

    if ( mb.Open( QueryMDPath() ) )
	{
		if ( !mb.GetDword( "",
						   MD_SSL_ACCESS_PERM,
						   IIS_MD_UT_SERVER,
						   &m_dwSslAccessPerms ) )
		{
			m_dwSslAccessPerms = 0;
		}
		mb.Close();
	}

    //
    // release reference to current mappers
    //

    memcpy( aOldMappers, m_apMappers, MT_LAST*sizeof(LPVOID) );

    for ( iM = 0 ; iM < MT_LAST ; ++iM )
    {
        if ( m_apMappers[iM] )
        {
            ((RefBlob*)(m_apMappers[iM]))->Release();
            m_apMappers[iM] = NULL;
        }
    }

    //
    // Read mappers from Name Space Extension Metabase
    //

    if ( !g_pInetSvc->QueryMDNseObject() )
    {
    	UnLockConfigWrite();
        return FALSE;
    }

    MB                  mbx( (IMDCOM*) g_pInetSvc->QueryMDNseObject() );

    if ( mbx.Open( QueryMDPath() ) )
    {
        dwR = sizeof(LPVOID);
        if ( !mbx.GetData( NSEPM_CERT11_PATH,
                           MD_CPP_CERT11,
                           IIS_MD_UT_SERVER,
                           BINARY_METADATA,
                           &m_apMappers[MT_CERT11],
                           &dwR,
                           0 ) )
        {
            m_apMappers[MT_CERT11] = NULL;
        }
        dwR = sizeof(LPVOID);
        if ( !mbx.GetData( NSEPM_CERTW_PATH,
                           MD_CPP_CERTW,
                           IIS_MD_UT_SERVER,
                           BINARY_METADATA,
                           &m_apMappers[MT_CERTW],
                           &dwR,
                           0 ) )
        {
            m_apMappers[MT_CERTW] = NULL;
        }
#if 0
        dwR = sizeof(LPVOID);
        if ( !mbx.GetData( NSEPM_BASIC_PATH,
                           MD_CPP_ITA,
                           IIS_MD_UT_SERVER,
                           BINARY_METADATA,
                           &m_apMappers[MT_ITA],
                           &dwR,
                           0 ) )
        {
            m_apMappers[MT_ITA] = NULL;
        }
        dwR = sizeof(LPVOID);
        if ( !mbx.GetData( NSEPM_DIGEST_PATH,
                           MD_CPP_DIGEST,
                           IIS_MD_UT_SERVER,
                           BINARY_METADATA,
                           &m_apMappers[MT_MD5],
                           &dwR,
                           0 ) )
        {
            m_apMappers[MT_MD5] = NULL;
        }
#endif
        mbx.Close();

        fSt = TRUE;
    }

    //
    // Call notification functions for mappers existence change
    // ( i.e. from non-exist to exist or exist to non-exist )
    //

    if ( (aOldMappers[MT_CERT11] == NULL) != (m_apMappers[MT_CERT11] == NULL)
         && g_pFlushMapperNotify[MT_CERT11] )
    {
        (g_pFlushMapperNotify[MT_CERT11])( SIMSSL_NOTIFY_MAPPER_CERT11_CHANGED, this );
    }

    if ( (aOldMappers[MT_CERTW] == NULL) != (m_apMappers[MT_CERTW] == NULL)
         && g_pFlushMapperNotify[MT_CERTW] )
    {
        (g_pFlushMapperNotify[MT_CERTW])( SIMSSL_NOTIFY_MAPPER_CERTW_CHANGED, this );
    }

#if 0
    if ( (aOldMappers[MT_ITA] == NULL) != (m_apMappers[MT_ITA] == NULL)
         && g_pFlushMapperNotify[MT_ITA] )
    {
        (g_pFlushMapperNotify[MT_ITA])( SF_NOTIFY_MAPPER_ITA_CHANGED, this );
    }

    if ( (aOldMappers[MT_MD5] == NULL) != (m_apMappers[MT_MD5] == NULL)
         && g_pFlushMapperNotify[MT_MD5] )
    {
        (g_pFlushMapperNotify[MT_MD5])( SF_NOTIFY_MAPPER_MD5_CHANGED, this );
    }
#endif

	UnLockConfigWrite();
    return fSt;
}

LPVOID
NNTP_SERVER_INSTANCE::QueryMapper(
    MAPPER_TYPE mt
    )
/*++

   Description

       Returns mapper

   Arguments:

       mt - mapper type

   Returns:

       ptr to Blob referencing mapper or NULL if no such mapper

--*/
{
    LPVOID pV;

    LockConfigRead();

    if ( pV = m_apMappers[(UINT)mt] )
    {
        ((RefBlob*)pV)->AddRef();
    }
    else
    {
        pV = NULL;
    }

    UnLockConfigRead();

    return pV;
}

BOOL
SetFlushMapperNotify(
    DWORD nt,
    PFN_SF_NOTIFY pFn
    )
/*++

   Description

       Set the function called to notify that a mapper is being flushed
       Can be called only once for a given mapper type

   Arguments:

       nt - notification type
       pFn - function to call to notify mapper flushed

   Returns:

       TRUE if function reference stored, FALSE otherwise

--*/
{
    MAPPER_TYPE mt;

    switch ( nt )
    {
#if 0
        case SF_NOTIFY_MAPPER_MD5_CHANGED:
            mt = MT_MD5;
            break;

        case SF_NOTIFY_MAPPER_ITA_CHANGED:
            mt = MT_ITA;
            break;
#endif
        case SIMSSL_NOTIFY_MAPPER_CERT11_CHANGED:
            mt = MT_CERT11;
            break;

        case SIMSSL_NOTIFY_MAPPER_CERTW_CHANGED:
            mt = MT_CERTW;
            break;

        default:
            return FALSE;
    }

    if ( g_pFlushMapperNotify[(UINT)mt] == NULL || pFn == NULL )
    {
        g_pFlushMapperNotify[(UINT)mt] = pFn;
        return TRUE;
    }

    return FALSE;
}


BOOL
SetSllKeysNotify(
    PFN_SF_NOTIFY pFn
    )
/*++

   Description

       Set the function called to notify SSL keys have changed
       Can be called only once

   Arguments:

       pFn - function to call to notify SSL keys change

   Returns:

       TRUE if function reference stored, FALSE otherwise

--*/
{
    if ( g_pSslKeysNotify == NULL || pFn == NULL )
    {
        g_pSslKeysNotify = pFn;
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::ReadAuthentInfo
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

DWORD
NNTP_SERVER_INSTANCE::ReadAuthentInfo(
    IN BOOL ReadAll,
    IN DWORD SingleItemToRead,
	IN BOOL Notify
    )
/*++

    Reads per-instance authentication info from the metabase.

    Arguments:

        ReadAll - If TRUE, then all authentication related items are
            read from the metabase. If FALSE, then only a single item
            is read.

        SingleItemToRead - The single authentication item to read if
            ReadAll is FALSE. Ignored if ReadAll is TRUE.

		Notify - If TRUE, this is a MB notification

    Returns:

        DWORD - 0 if successful, !0 otherwise.

--*/
{

    DWORD tmp;
    DWORD err = NO_ERROR;
    BOOL rebuildAcctDesc = FALSE;
	TCP_AUTHENT_INFO* pTcpAuthentInfo = NULL;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );

	TraceFunctEnter("NNTP_SERVER_INSTANCE::ReadAuthentInfo");

    //
    // Lock our configuration (since we'll presumably be making changes)
    // and open the metabase.
    //

    LockConfigWrite();

    if( !mb.Open( QueryMDPath() ) ) {
        err = GetLastError();
        DebugTrace(0,"ReadAuthentInfo: cannot open metabase, error %lx\n",err);
    }

	//
	// Read into one of two copies depending on BOOL switch. This is so
	// we sync with usage of this struct in simauth.
	//
	pTcpAuthentInfo = &m_TcpAuthentInfo ;
	if( Notify && m_fUseOriginal ) {
		pTcpAuthentInfo = &m_TcpAuthentInfo2;
	}

    //
    // Read the anonymous username if necessary. Note this is a REQUIRED
    // property. If it is missing from the metabase, bail.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_ANONYMOUS_USER_NAME ) ) {

        if( mb.GetStr(
                "",
                MD_ANONYMOUS_USER_NAME,
                IIS_MD_UT_SERVER,
                &(pTcpAuthentInfo->strAnonUserName)
                ) ) {

            rebuildAcctDesc = TRUE;

        } else {

            err = GetLastError();
            DebugTrace(0,"ReadAuthentInfo: cannot read MD_ANONYMOUS_USER_NAME, error %lx\n",err);

        }
    }

    //
    // Read the "use subauthenticator" flag if necessary. This is an
    // optional property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_ANONYMOUS_USE_SUBAUTH ) ) {

        if( !mb.GetDword(
                "",
                MD_ANONYMOUS_USE_SUBAUTH,
                IIS_MD_UT_SERVER,
                &tmp
                ) ) {

            tmp = DEFAULT_USE_SUBAUTH;
        }

        (pTcpAuthentInfo->fDontUseAnonSubAuth) = !tmp;
    }

    //
    // Read the anonymous password if necessary. This is an optional
    // property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_ANONYMOUS_PWD ) ) {

        if( mb.GetStr(
                "",
                MD_ANONYMOUS_PWD,
                IIS_MD_UT_SERVER,
                &(pTcpAuthentInfo->strAnonUserPassword),
                METADATA_INHERIT,
                DEFAULT_ANONYMOUS_PWD
                ) ) {

            rebuildAcctDesc = TRUE;

        } else {

            //
            // Since we provided a default value to mb.GetStr(), it should
            // only fail if something catastrophic occurred, such as an
            // out of memory condition.
            //

            err = GetLastError();
            DebugTrace(0,"ReadAuthentInfo: cannot read MD_ANONYMOUS_PWD, error %lx\n",err);
        }
    }

    //
    // Read the default logon domain if necessary. This is an optional
    // property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_DEFAULT_LOGON_DOMAIN ) ) {

        if( !mb.GetStr(
                "",
                MD_DEFAULT_LOGON_DOMAIN,
                IIS_MD_UT_SERVER,
                &(pTcpAuthentInfo->strDefaultLogonDomain)
                ) ) {

            //
            // Generate a default domain name.
            //

            err = GetDefaultDomainName( &(pTcpAuthentInfo->strDefaultLogonDomain) );

            if( err != NO_ERROR ) {

                DebugTrace(0,"ReadAuthentInfo: cannot get default domain name, error %d\n",err);

            }

        }

    }

    //
    // Read the logon method if necessary. This is an optional property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_LOGON_METHOD ) ) {

        if( !mb.GetDword(
                "",
                MD_LOGON_METHOD,
                IIS_MD_UT_SERVER,
                &tmp
                ) ) {

            tmp = DEFAULT_LOGON_METHOD;

        }

        pTcpAuthentInfo->dwLogonMethod = tmp;

    }

    //
    // If anything changed that could affect the anonymous account
    // descriptor, then rebuild the descriptor.
    //

    if( err == NO_ERROR && rebuildAcctDesc ) {

        if( !BuildAnonymousAcctDesc( pTcpAuthentInfo ) ) {

            DebugTrace(0,"ReadAuthentInfo: BuildAnonymousAcctDesc() failed\n");
            err = ERROR_NOT_ENOUGH_MEMORY;  // SWAG

        }

    }

	//
	//	ok, done updating the copy - pull the switch
	//
	if( Notify ) {
		m_fUseOriginal = !m_fUseOriginal ;
	}

    UnLockConfigWrite();
    return err;

}   // NNTP_SERVER_INSTANCE::ReadAuthentInfo

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::MDChangeNotify
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

VOID
NNTP_SERVER_INSTANCE::MDChangeNotify(
    MD_CHANGE_OBJECT * pcoChangeList
    )
/*++

  This method handles the metabase change notification for this instance

  Arguments:

    pcoChangeList - path and id that has changed

--*/
{
    FIELD_CONTROL control = 0;
    DWORD i;
    DWORD err;
    DWORD id;
    BOOL  fUpdateVroot = FALSE;
    BOOL  fReadMappers = FALSE;
    DWORD dwFeedID;
    BOOL  fSslModified = FALSE;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::MDChangeNotify");

    //
    // Let the parent deal with it.
    //

    IIS_SERVER_INSTANCE::MDChangeNotify( pcoChangeList );

    //
    //  The instance needs to be started !
    //

    if( QueryServerState() != MD_SERVER_STATE_STARTED ) {
        return;
    }


    //
    // Interpret the changes.
    //

    for( i = 0 ; i < pcoChangeList->dwMDNumDataIDs ; i++ ) {

        id = pcoChangeList->pdwMDDataIDs[i];

        switch( id ) {

        case MD_ALLOW_CLIENT_POSTS :
        case MD_ALLOW_FEED_POSTS :
            control |= FC_NNTP_POSTINGMODES;
            break;

        case MD_CLIENT_POST_SOFT_LIMIT :
        case MD_CLIENT_POST_HARD_LIMIT :
            control |= FC_NNTP_POSTLIMITS;
            break;

        case MD_FEED_POST_SOFT_LIMIT :
        case MD_FEED_POST_HARD_LIMIT :
            control |= FC_NNTP_FEEDLIMITS;
            break;

        case MD_ALLOW_CONTROL_MSGS :
            control |= FC_NNTP_CONTROLSMSGS;
            break;

        case MD_SMTP_SERVER :
            control |= FC_NNTP_SMTPADDRESS;
            break;

        case MD_NNTP_UUCP_NAME :
            control |= FC_NNTP_UUCPNAME;
            break;

        case MD_DISABLE_NEWNEWS :
            control |= FC_NNTP_DISABLE_NEWNEWS;
            break;

        case MD_DEFAULT_MODERATOR :
            control |= FC_NNTP_DEFAULTMODERATOR;
            break;

        case MD_AUTHORIZATION :
            control |= FC_NNTP_AUTHORIZATION;
            break;

        case MD_NTAUTHENTICATION_PROVIDERS :
            control |= FC_NTAUTHENTICATION_PROVIDERS;
            break;

		case MD_NNTP_CLEARTEXT_AUTH_PROVIDER:
            control |= FC_NNTP_CLEARTEXT_AUTH_PROVIDER;
            break;

		case MD_MD_SERVER_SS_AUTH_MAPPING:
            control |= FC_MD_SERVER_SS_AUTH_MAPPING;
            break;

        case MD_IP_SEC :
            ReadIpSecList();
            break;

        case MD_IS_CONTENT_INDEXED:
            fUpdateVroot = TRUE;
            break;

        case MD_ACCESS_PERM :
        case MD_SSL_ACCESS_PERM :
       		if ( !_strnicmp( (const char*)pcoChangeList->pszMDPath,
							 QueryMDVRPath(), lstrlen(QueryMDVRPath()) ) ) {
            	fUpdateVroot = TRUE;
           	} else if( !_strnicmp( (const char*)pcoChangeList->pszMDPath,
        							QueryMDPath(), lstrlen(QueryMDPath()) ) ) {
        		fReadMappers = TRUE;
       		}
       		break;

#if 0
        case MD_ALLOW_ANONYMOUS :
            control |= FC_NNTP_ALLOW_ANONYMOUS;
            break;

        case MD_ANONYMOUS_ONLY :
            control |= FC_NNTP_ANONYMOUS_ONLY;
            break;
#endif

        case MD_ANONYMOUS_USER_NAME :
        case MD_ANONYMOUS_PWD :
        case MD_ANONYMOUS_USE_SUBAUTH :
        case MD_DEFAULT_LOGON_DOMAIN :
        case MD_LOGON_METHOD :
            err = ReadAuthentInfo( TRUE, id, TRUE );

            if( err != NO_ERROR ) {

                DebugTrace(
					0,
					"NNTP_SERVER_INSTANCE::MDChangeNotify() cannot read authentication info, error %d",
                    err
                    );
            }
            break;

        case MD_SSL_CERT_HASH:
        case MD_SSL_CERT_CONTAINER:
        case MD_SSL_CERT_PROVIDER:
        case MD_SSL_CERT_OPEN_FLAGS:
        case MD_SSL_CERT_STORE_NAME:
        case MD_SSL_CTL_IDENTIFIER:
        case MD_SSL_CTL_CONTAINER:
        case MD_SSL_CTL_PROVIDER:
        case MD_SSL_CTL_PROVIDER_TYPE:
        case MD_SSL_CTL_OPEN_FLAGS:
        case MD_SSL_CTL_STORE_NAME:
		case MD_SSL_CTL_SIGNER_HASH:
		case MD_SSL_USE_DS_MAPPER:
            fSslModified = TRUE;
            break;
        }
    }

    //
    // If anything related to SSL has changed, call the function used to flush
    // the SSL / Schannel credential cache and reset the server certificate
    //
    if ( fSslModified && g_pSslKeysNotify ) {
        (g_pSslKeysNotify) ( SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED, this );
        ResetSSLInfo( this );
    }

    if( control != 0 ) {
        if( !ReadPublicNntpParams( control ) ) {
            DebugTrace(0,"NNTP_SERVER_INSTANCE::MDChangeNotify() cannot read config");
        }
    }

    if( fUpdateVroot ) {
		// received reg change notification on virtual root update -
		// update all newsgroups
		// LATER - since we have the vroot path, we should be able
		// to do the update only for groups that match this path...
        _ASSERT( m_pTree );
        // this call is doing nothing, take out
		//m_pTree->UpdateVrootInfo() ;

#ifdef DEBUG
        NntpLogEvent( NNTP_EVENT_VROOT_UPDATED, 0, (const CHAR**)NULL, 0 );
#endif
    }

    if( fReadMappers ) {
    	ReadMappers();
   	}

    //
    // Here handles the feed config change notification
    //
    if ( VerifyFeedPath( ( LPSTR ) (pcoChangeList->pszMDPath), &dwFeedID ) &&
         IsNotMyChange( ( LPSTR ) (pcoChangeList->pszMDPath ) , pcoChangeList->dwMDChangeType ) )
        UpdateFeed( pcoChangeList, dwFeedID );
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::ReadIpSecList
//
//  Synopsis:   read ip sec info from metabase
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::ReadIpSecList(void)
{
	IMDCOM*             pMBCom;
	METADATA_HANDLE     hMB;
	HRESULT             hRes;
	METADATA_RECORD     mdRecord;
	DWORD               dwRequiredLen;
	DWORD				dwErr;
	//BOOL                fMustRel;
	BOOL				fSuccess;

	m_rfAccessCheck.Reset( (IMDCOM*)g_pInetSvc->QueryMDObject() );

    pMBCom = (IMDCOM*)g_pInetSvc->QueryMDObject();
    hRes = pMBCom->ComMDOpenMetaObject( METADATA_MASTER_ROOT_HANDLE,
                                        (BYTE *) QueryMDPath(),
                                        METADATA_PERMISSION_READ,
                                        5000,
                                        &hMB );
    if ( SUCCEEDED( hRes ) )
     {
            mdRecord.dwMDIdentifier  = MD_IP_SEC;
            mdRecord.dwMDAttributes  = METADATA_INHERIT | METADATA_REFERENCE;
            mdRecord.dwMDUserType    = IIS_MD_UT_FILE;
            mdRecord.dwMDDataType    = BINARY_METADATA;
            mdRecord.dwMDDataLen     = 0;
            mdRecord.pbMDData        = (PBYTE)NULL;

            hRes = pMBCom->ComMDGetMetaData( hMB,
                                             (LPBYTE)"",
                                             &mdRecord,
                                             &dwRequiredLen );
            if ( SUCCEEDED( hRes ) && mdRecord.dwMDDataTag )
            {
                m_rfAccessCheck.Set( mdRecord.pbMDData,
                                     mdRecord.dwMDDataLen,
                                     mdRecord.dwMDDataTag );
            }

            _VERIFY( SUCCEEDED(pMBCom->ComMDCloseMetaObject( hMB )) );
     }
     else
     {
            fSuccess = FALSE;
            dwErr = HRESULTTOWIN32( hRes );
     }

	 return TRUE;

}

DWORD
NNTP_SERVER_INSTANCE::GetCurrentSessionCount()
{
	return m_pInUseList->GetListCount() ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::LookupVirtualRoot
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::LookupVirtualRoot(
    IN     const CHAR *       pszRoot,
    OUT    CHAR *             pszDirectory,
    IN OUT LPDWORD            lpcbSize,
    OUT    LPDWORD            lpdwAccessMask,
    OUT    LPDWORD            pcchDirRoot,
    OUT    LPDWORD            pcchVroot,
    OUT    HANDLE*            phImpersonationToken,
    IN     const CHAR *       pszAddress,
    OUT    LPDWORD            lpdwFileSystem,
    IN	   VrootPropertyAddon* pvpaBlob
    )   {
/*++

Routine Description :

    Wrap the call to the Gibraltar virtual root stuff - we hide the GetTsvcCache() code etc...
    from the rest of the server.  Otherwise, we have the same interface as Gibraltar
    provides for virtual roots.

Arguments :
    pszRoot - Path to lookup
    pszDirectory - resolved path
    lpcbSize - IN/OUT resolved path length
    lpdwAccessMask - Access to allow to directory


Return Value :
    TRUE if successfull, FALSE otherwise.

--*/

	BOOL  fRet = TRUE;
	LPSTR lpstrNewRoot;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::LookupVirtualRoot");

	//
	// find the vroot object
	//
	NNTPVROOTPTR pVRoot;

	_ASSERT(m_pVRootTable != NULL);
	HRESULT hr = m_pVRootTable->FindVRoot(pszRoot, &pVRoot);
	_ASSERT(pVRoot != NULL);
	_ASSERT(hr == S_OK);

	_ASSERT(*lpcbSize != NULL);
	hr = pVRoot->MapGroupToPath(pszRoot, pszDirectory, *lpcbSize, pcchDirRoot,
								pcchVroot);
	_ASSERT(SUCCEEDED(hr));
	if (SUCCEEDED(hr)) {
		*lpcbSize = lstrlen(pszDirectory);
		if (lpdwAccessMask != NULL) *lpdwAccessMask = pVRoot->GetAccessMask();
		if (lpdwFileSystem != NULL) *lpdwFileSystem = FS_FAT;
		if (pvpaBlob != NULL) {
			pvpaBlob->fChanged = TRUE;
			pvpaBlob->dwSslAccessMask = pVRoot->GetSSLAccessMask();
			pvpaBlob->dwContentIndexFlag = pVRoot->IsContentIndexed();
		}
	}

	if (SUCCEEDED(hr)) return TRUE; else return FALSE;

}


//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::TsEnumVirtualRoots
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::TsEnumVirtualRoots(
    PFN_VR_ENUM pfnCallback,
    VOID *      pvContext
    )
{
    MB              mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    if ( !mb.Open( QueryMDPath(),
               METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        return FALSE;
    }

    return TsRecursiveEnumVirtualRoots(
                    pfnCallback,
                    pvContext,
                    IIS_MD_INSTANCE_ROOT "/",
                    m_dwLevelsToScan,
                    (LPVOID)&mb,
                    TRUE );
}


BOOL
NNTP_SERVER_INSTANCE::TsRecursiveEnumVirtualRoots(
    PFN_VR_ENUM pfnCallback,
    VOID *      pvContext,
    LPSTR       pszCurrentPath,
    DWORD       dwLevelsToScan,
    LPVOID      pvMB,
    BOOL        fGetRoot
    )
/*++
    Description:

        Enumerates all of the virtual directories defined for this server
        instance

    Arguments:
        pfnCallback - Enumeration callback to call for each virtual directory
        pvContext - Context pfnCallback receives
        pszCurrentPath - path where to start scanning for VRoots
        dwLevelsToScan - # of levels to scan recursively for vroots
        pvMB - ptr to MB to access metabase. Is LPVOID to avoid having to include
               mb.hxx before any ref to iistypes.hxx
        fGetRoot - TRUE if pszCurrentPath is to be considered as vroot to process

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{

    DWORD           err;
    MB*             pMB = (MB*)pvMB;

    DWORD           dwMask;
    CHAR            szUser[UNLEN+1];
    CHAR            szPassword[PWLEN+1];
    CHAR            szDirectory[MAX_PATH + UNLEN + 3];
    DWORD           cb;

    CHAR            nameBuf[METADATA_MAX_NAME_LEN+2];
    CHAR            tmpBuf[sizeof(nameBuf)];

    DWORD           cbCurrentPath;
    VIRTUAL_ROOT    vr;
    DWORD           i = 0;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::TsRecursiveEnumVirtualRoots");

    //
    //  Enumerate all of the listed items in the metabase
    //  and add them
    //

    cbCurrentPath = strlen( pszCurrentPath );
    CopyMemory( nameBuf, pszCurrentPath, cbCurrentPath + 1);

    while ( TRUE ) {

        //METADATA_RECORD mdRecord;
        DWORD  dwFileSystem = FS_ERROR;

        err = NO_ERROR;

        if ( fGetRoot ) {

            fGetRoot = FALSE;

        } else {

            if ( !pMB->EnumObjects( pszCurrentPath,
                                  nameBuf + cbCurrentPath,
                                  i++ ))
            {
                break;
            }

            if ( dwLevelsToScan > 1 )
            {
                cb = strlen( nameBuf );
                nameBuf[ cb ] = '/';
                nameBuf[ cb + 1 ] = '\0';

                if ( !TsRecursiveEnumVirtualRoots(
                    pfnCallback,
                    pvContext,
                    nameBuf,
                    dwLevelsToScan - 1,
                    pMB,
                    FALSE ) )
                {
                    return FALSE;
                }

                nameBuf[ cb ] = '\0';
            }
        }

        //
        // Get Directory path
        //

        cb = sizeof( szDirectory );

        if ( !pMB->GetString( nameBuf,
                            MD_VR_PATH,
                            IIS_MD_UT_FILE,
                            szDirectory,
                            &cb,
                            0 ))
        {
            DebugTrace(0,"Error %x reading path from %s. Not a VR.\n",
                      GetLastError(), nameBuf);
            continue;
        }

        //
        // Get mask
        //

        if ( !pMB->GetDword( nameBuf,
                           MD_ACCESS_PERM,
                           IIS_MD_UT_FILE,
                           &dwMask,
                           0))
        {
            dwMask = VROOT_MASK_READ;

            DebugTrace(0,"Error %x reading mask from %s\n",
                  GetLastError(), nameBuf);
        }

        //
        // Get username
        //

        cb = sizeof( szUser );

        if ( !pMB->GetString( nameBuf,
                            MD_VR_USERNAME,
                            IIS_MD_UT_FILE,
                            szUser,
                            &cb,
                            0))
        {
//            DBGPRINTF((DBG_CONTEXT,"Error %d reading path from %s\n",
//                      GetLastError(), nameBuf));

            szUser[0] = '\0';
        }

        DebugTrace(0,"Reading %s: Path[%s] User[%s] Mask[%d]\n",
                  nameBuf, szDirectory, szUser, dwMask);

        if ( (szUser[0] != '\0') &&
             (szDirectory[0] == '\\') && (szDirectory[1] == '\\') ) {

            cb = sizeof( szPassword );

            //
            //  Retrieve the password for this address/share
            //

            if ( !pMB->GetString( nameBuf,
                                MD_VR_PASSWORD,
                                IIS_MD_UT_FILE,
                                szPassword,
                                &cb,
                                METADATA_SECURE))
            {
                DebugTrace(0,"Error %d reading path from %s\n",
                          GetLastError(), nameBuf);

                szPassword[0] = '\0';
            }
        }
        else
        {
            szPassword[0] = '\0';
        }

        //
        //  Now set things up for the callback
        //

        _ASSERT( !_strnicmp( nameBuf, IIS_MD_INSTANCE_ROOT, sizeof(IIS_MD_INSTANCE_ROOT) - 1));

        //
        //  Add can modify the root - don't modify the working
        //  vroot path
        //

        strcpy( tmpBuf, nameBuf );

        vr.pszAlias     = tmpBuf + sizeof(IIS_MD_INSTANCE_ROOT) - 1;
        vr.pszMetaPath  = tmpBuf;
        vr.pszPath      = szDirectory;
        vr.dwAccessPerm = dwMask;
        vr.pszUserName  = szUser;
        vr.pszPassword  = szPassword;

		if( m_BootOptions ) {
			m_BootOptions->ReportPrint("Scanning virtual root %s Physical Path %s\n",
							vr.pszAlias, vr.pszPath);
		}

        if ( !pfnCallback( pvContext, pMB, &vr ))
        {
            //
            // !!! so what do we do here?
            //

            DebugTrace(0,"EnumCallback returns FALSE\n");
            if( m_BootOptions ) {
				m_BootOptions->ReportPrint("Failed to scan vroot %s Path %s: error is %d\n",
								vr.pszAlias, vr.pszPath, GetLastError());
            }
        }

    } // while

    return TRUE;

} // Enum

BOOL
NNTP_SERVER_INSTANCE::ClearStatistics()
{
    LockStatistics( this );
    ZeroMemory((PVOID)&m_NntpStats, sizeof(NNTP_STATISTICS_0));
    m_NntpStats.TimeOfLastClear = NntpGetTime( );
    UnlockStatistics( this );
    return TRUE;

} // ClearStatistics

BOOL
NNTP_SERVER_INSTANCE::SetProviderPackages()
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::SetProviderPackages" );

	LPSTR	psz;
	DWORD	i;

	PAUTH_BLOCK	pBlock = NULL;

    if ( m_ProviderNames == NULL || m_cProviderPackages == 0)
	{
		ErrorTrace((LPARAM)this, "Invalid Parameters: 0x%08X, %d",
			m_ProviderNames, m_cProviderPackages );
		return FALSE;
    }

	pBlock = (PAUTH_BLOCK)LocalAlloc(0, m_cProviderPackages * sizeof(AUTH_BLOCK));
	if (pBlock == NULL)
	{
		ErrorTrace( 0, "AUTH_BLOCK LocalAlloc failed: %d", GetLastError() );
		return FALSE;
	}

	//
	// start at 1 since 0 indicates the Invalid protocol
	//
	for ( i=0, psz = (LPSTR)m_ProviderNames; i< m_cProviderPackages; i++ )
	{
		//
		// this would be the place to check whether the package was valid
		//
		DebugTrace( 0, "Protocol: %s", psz);

		pBlock[i].Name = psz;

		psz += lstrlen(psz) + 1;
	}

	//
	// if we're replacing already set packages; free their memory
	//
    if (m_ProviderPackages != NULL )
	{
        LocalFree((PVOID)m_ProviderPackages );
        m_ProviderPackages = NULL;
    }
	m_ProviderPackages = pBlock;

	return	TRUE;

} // SetAuthPackageNames


//+---------------------------------------------------------------
//
//  Function:  NNTP_SERVER_INSTANCE::GetPostsAllowed
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

LPSTR
NNTP_SERVER_INSTANCE::GetPostsAllowed(
                DWORD&  cb
                )
/*++

Routine description :

    Get the connection string to send to clients whom we are not going to
    allow to post.

Arguments :

    cb - out parameter to get the number of bytes in the string

Return Value :

    Pointer to the string !

--*/
{
    cb = 0 ;
    if( m_cbPostsAllowed != 0 ) {
        cb = m_cbPostsAllowed ;
        return  m_szPostsAllowed ;
    }
    return  0 ;
}

//+---------------------------------------------------------------
//
//  Function: NNTP_SERVER_INSTANCE::GetPostsNotAllowed
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

LPSTR
NNTP_SERVER_INSTANCE::GetPostsNotAllowed(
                        DWORD&  cb
                        )
/*++

Routine Description :

    Get the connection string to send to clients whom we are going to allow
    to post.

Arguments :

    cb - An out parameter to get the number of bytes in the greeting string.

Return Value :

    Pointer to the connection string.

--*/
{
    cb = 0 ;
    if( m_cbPostsNotAllowed != 0 ) {
        cb = m_cbPostsNotAllowed ;
        return  m_szPostsNotAllowed ;
    }
    return  0 ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::SetPostingModes
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::SetPostingModes(
		MB&		mb,
        BOOL    AllowClientPosts,
        BOOL    AllowFeedPosts,
        BOOL    fSaveSettings
        )
/*++

Routine Description :

    Save the posting modes for the server to the registry and modify
    the current settings for the posting modes.

Arguments :
    AllowClientPosts - TRUE means allow clients to post
    AllowFeedPosts - TRUE means allow feeds to post
    fSaveSettings - TRUE means modify the registry.

Return Value :
    TRUE    if saved successfully (if a registry error occurs
        the mode is still changed but the change won't be picked up on
        the next reboot !)
    FALSE - error occurred

--*/
{
    BOOL    fRtn = TRUE ;

    if( AllowClientPosts ||
        AllowFeedPosts ) {

        if( !   (m_pArticleTable->IsActive() &&
                 m_pHistoryTable->IsActive() &&
                 m_pXoverTable->IsActive()) ) {
            SetLastError( ERROR_DISK_FULL ) ;
            return  FALSE ;
        }
    }

    m_fAllowClientPosts = AllowClientPosts ;
    m_fAllowFeedPosts = AllowFeedPosts ;

    DWORD   dwData = m_fAllowClientPosts ;
    if ( fSaveSettings && !mb.SetDword( "",
                                        MD_ALLOW_CLIENT_POSTS,
                                        IIS_MD_UT_SERVER,
                                        dwData ) )
    {
        fRtn = FALSE ;
    }

    dwData = m_fAllowFeedPosts ;
    if ( fSaveSettings && !mb.SetDword( "",
                                        MD_ALLOW_FEED_POSTS,
                                        IIS_MD_UT_SERVER,
                                        dwData ) )
    {
        fRtn = FALSE ;
    }

    return  fRtn ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::SetPostingLimits
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::SetPostingLimits(
		MB&		mb,
        DWORD   cbHardLimit,
        DWORD   cbSoftLimit
        )
/*++

Routine Description :

    Set the limits on the size of postings the server will set, and save
    these values to the registry if possible.
    The new values will always take effect, but if an error occurs they
    may not be saved in the registry.

Arguments :
    cbHardLimit - Number of bytes the server will take before breaking the session
    cbSoftLimit - Largest post the server will take

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    BOOL    fRtn = TRUE ;

    m_cbHardLimit = cbHardLimit ;
    m_cbSoftLimit = cbSoftLimit ;

    DWORD   dwData = m_cbHardLimit;
    if ( !mb.SetDword( "",
						MD_CLIENT_POST_HARD_LIMIT,
						IIS_MD_UT_SERVER,
						dwData ) )
    {
        fRtn = FALSE ;
	}

    dwData = m_cbSoftLimit ;
    if ( !mb.SetDword( "",
						MD_CLIENT_POST_SOFT_LIMIT,
						IIS_MD_UT_SERVER,
						dwData ) )
    {
        fRtn = FALSE ;
	}

    return  fRtn ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::SetControlMessages
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::SetControlMessages(
		MB&		mb,
        BOOL    fControlMessages
        )
/*++

Routine Description :

    Sets the Boolean indicating whether control messages are processed and
    these values to the registry if possible.
    The new values will always take effect, but if an error occurs they
    may not be saved in the registry.

Arguments :
    fControlMessages - allow control messages

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    BOOL    fRtn = TRUE ;

    m_fAllowControlMessages = fControlMessages ;

    DWORD   dwData = m_fAllowControlMessages;
	if ( !mb.SetDword( "",
						MD_ALLOW_CONTROL_MSGS,
						IIS_MD_UT_SERVER,
						dwData ) )
	{
		fRtn = FALSE ;
	}

    return  fRtn ;
}

//+---------------------------------------------------------------
//
//  Function:  NNTP_SERVER_INSTANCE::SetFeedLimits
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------


BOOL
NNTP_SERVER_INSTANCE::SetFeedLimits(
		MB&		mb,
        DWORD   cbHardLimit,
        DWORD   cbSoftLimit
        )
/*++

Routine Description :

    Set the limits on the size of postings FROM A FEED the server will accept, and save
    these values to the registry if possible.
    The new values will always take effect, but if an error occurs they
    may not be saved in the registry.

Arguments :
    cbHardLimit - Number of bytes the server will take before breaking the session
    cbSoftLimit - Largest post the server will take

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    BOOL    fRtn = TRUE ;

    m_cbFeedHardLimit = cbHardLimit ;
    m_cbFeedSoftLimit = cbSoftLimit ;

    DWORD   dwData = m_cbFeedHardLimit;
	if ( !mb.SetDword( "",
						MD_FEED_POST_HARD_LIMIT,
						IIS_MD_UT_SERVER,
						dwData ) )
	{
		fRtn = FALSE ;
	}

    dwData = m_cbFeedSoftLimit ;
	if ( !mb.SetDword( "",
						MD_FEED_POST_SOFT_LIMIT,
						IIS_MD_UT_SERVER,
						dwData ) )
	{
		fRtn = FALSE ;
	}

    return  fRtn ;
}


//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::SetSmtpAddress
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::SetSmtpAddress(
		MB&		mb,
        LPWSTR  pszSmtpAddress
        )
/*++

Routine Description :

    Set the name of the SMTP server to send moderated newsgroup postings to
    and write these values to the registry if possible.
    The new values will always take effect, but if an error occurs they
    may not be saved in the registry.

Arguments :
    pszSmtpAddress - DNS name or stringized IP address of the SMTP server

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::SetSmtpAddress" );

    BOOL    fRtn = TRUE ;
    DWORD   cbAddress;
	CHAR	szSmtpAddressA [MAX_PATH+1];

    if ( pszSmtpAddress == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return  FALSE;
    }

    cbAddress = lstrlenW( pszSmtpAddress ) + 1;
    cbAddress *= sizeof(WCHAR);
    if ( cbAddress > sizeof( m_szSmtpAddress ) )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return  FALSE;
    }

    LockConfigWrite();

    CopyMemory( m_szSmtpAddress, pszSmtpAddress, cbAddress );
    m_cbSmtpAddress = cbAddress;

    UnLockConfigWrite();

    // signal the moderated provider interface about the change
    SignalSmtpServerChange();

	CopyUnicodeStringIntoAscii( szSmtpAddressA, m_szSmtpAddress );
	if ( !mb.SetString( "",
						MD_SMTP_SERVER,
						IIS_MD_UT_SERVER,
						szSmtpAddressA ) )
	{
        ErrorTrace( (LPARAM)this,
                    "SetString failed: %d",
                    GetLastError() );
        return  FALSE;
	}

    return  TRUE;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::SetUucpName
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::SetUucpName(
		MB&     mb,
        LPWSTR  pszUucpName
        )
/*++

Routine Description :

    Set the server's UucpName name and write these values to the
    registry if possible.
    The new values will always take effect, but if an error occurs they
    may not be saved in the registry.

Arguments :
    pszSmtpAddress - server's UUCP name

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::SetUucpName" );

    BOOL    fRtn = TRUE ;
    DWORD   cbUucpName;
	CHAR	szUucpNameA [MAX_PATH+1];

    if ( pszUucpName == NULL  || *pszUucpName == '\0' )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return  FALSE;
    }

    cbUucpName = lstrlenW( pszUucpName ) + 1;
    cbUucpName *= sizeof(WCHAR);
    if ( cbUucpName > sizeof( m_szUucpName ) )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return  FALSE;
    }

    LockConfigWrite();

    CopyMemory( m_szUucpName, pszUucpName, cbUucpName );
    m_cbUucpName = cbUucpName;

    UnLockConfigWrite();

	CopyUnicodeStringIntoAscii( szUucpNameA, m_szUucpName );
	if ( !mb.SetString( "",
						MD_NNTP_UUCP_NAME,
						IIS_MD_UT_SERVER,
						szUucpNameA ) )
	{
        ErrorTrace( (LPARAM)this,
                    "SetString failed: %d",
                    GetLastError() );
        return  FALSE;
	}

    return  TRUE;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::GetSmtpAddress
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------


BOOL
NNTP_SERVER_INSTANCE::GetSmtpAddress(
        LPSTR   pszSmtpAddress,
        PDWORD  pcbAddress
        )
/*++

Routine Description :

    Set the name of the SMTP server to send moderated newsgroup postings to
    and write these values to the registry if possible.
    The new values will always take effect, but if an error occurs they
    may not be saved in the registry.

Arguments :
    pszSmtpAddress: buffer to receive DNS name or stringized IP address
                    of the SMTP server

    pcbAddress:     max size of buffer to receive DNS name or stringized
                    IP address of the SMTP server and the returned size

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::GetSmtpAddress" );

    BOOL    fRtn = TRUE ;
    //DWORD   cbAddress;

    if ( m_cbSmtpAddress > *pcbAddress )
    {
        *pcbAddress = m_cbSmtpAddress;
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return  FALSE;
    }

    if ( pszSmtpAddress == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return  FALSE;
    }

    LockConfigRead();

    if ( m_cbSmtpAddress > sizeof(WCHAR) )
    {
        *pcbAddress = WideCharToMultiByte(
                            CP_ACP,
                            0,
                            m_szSmtpAddress,
                            (int)m_cbSmtpAddress/sizeof(WCHAR),
                            pszSmtpAddress,
                            *pcbAddress,
                            NULL,
                            NULL
                        );
        if ( *pcbAddress == 0 )
        {
            ErrorTrace( (LPARAM)this,
                        "WideCharToMultiByte failed: %d",
                        GetLastError() );
        }
    }
    else
    {
        *pcbAddress = sizeof( "127.0.0.1" );
        CopyMemory( pszSmtpAddress, "127.0.0.1", *pcbAddress );
    }

    UnLockConfigRead();

    return  TRUE;
}

//+---------------------------------------------------------------
//
//  Function:  NNTP_SERVER_INSTANCE::GetUucpName
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::GetUucpName(
        LPSTR   pszUucpName,
        PDWORD  pcbUucpName
        )
/*++

Routine Description :

    Set the services' UUCP name
    and write these values to the registry if possible.
    The new values will always take effect, but if an error occurs they
    may not be saved in the registry.

Arguments :
    pszUucpName:    buffer to receive DNS name or stringized IP address
                    of the SMTP server

    pcbUucpName:    max size of buffer to receive DNS name or stringized
                    IP address of the SMTP server and the returned size

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::GetUucpName" );

    BOOL    fRtn = TRUE ;
    //DWORD   cbUucpName;

    if ( m_cbUucpName > *pcbUucpName )
    {
        *pcbUucpName = m_cbUucpName;
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return  FALSE;
    }

    if ( pszUucpName == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return  FALSE;
    }

    LockConfigRead();

    *pcbUucpName = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        m_szUucpName,
                        (int)m_cbUucpName/sizeof(WCHAR),
                        pszUucpName,
                        *pcbUucpName,
                        NULL,
                        NULL
                    );

    if ( *pcbUucpName == 0 )
    {
        ErrorTrace( (LPARAM)this,
                    "WideCharToMultiByte failed: %d",
                    GetLastError() );
    }

    UnLockConfigRead();

    return  TRUE;
}

//+---------------------------------------------------------------
//
//  Function:  NNTP_SERVER_INSTANCE::SetDefaultModerator
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::SetDefaultModerator(
		MB&		mb,
        LPWSTR  pszDefaultModerator
        )
/*++

Routine Description :

    Set the default moderator (email address) for moderated newsgroups
    and write these values to the registry if possible.
    The new values will always take effect, but if an error occurs they
    may not be saved in the registry.

Arguments :
    pszDefaultModerator - default moderator address

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::SetDefaultModerator" );

    BOOL    fRtn = TRUE ;
    DWORD   cbDefaultModerator;
	CHAR	szDefaultModeratorA [MAX_MODERATOR_NAME+1];

    if ( pszDefaultModerator == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return  FALSE;
    }

    cbDefaultModerator = lstrlenW( pszDefaultModerator ) + 1;
    cbDefaultModerator *= sizeof(WCHAR);
    if ( cbDefaultModerator > sizeof( m_szDefaultModerator ) )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return  FALSE;
    }

    LockConfigWrite();

    CopyMemory( m_szDefaultModerator, pszDefaultModerator, cbDefaultModerator );
    m_cbDefaultModerator = cbDefaultModerator;

    UnLockConfigWrite();

	CopyUnicodeStringIntoAscii( szDefaultModeratorA, m_szDefaultModerator );
	if ( !mb.SetString( "",
						MD_DEFAULT_MODERATOR,
						IIS_MD_UT_SERVER,
						szDefaultModeratorA ) )
	{
        ErrorTrace( (LPARAM)this,
                    "SetString failed: %d",
                    GetLastError() );
        return  FALSE;
	}

    return  TRUE;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::GetDefaultModerator
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::GetDefaultModerator(
		LPSTR	pszNewsgroup,
        LPSTR   pszDefaultModerator,
        PDWORD  pcbDefaultModerator
        )
/*++

Routine Description :

    Get the name of the default moderator to send moderated newsgroup postings to.
	default moderator = hiphenated-newsgroup-name@default

Arguments :

	pszNewsgroup:			name of newsgroup
    pszDefaultModerator:	buffer to receive default moderator
    pcbDefaultModerator:    max size of buffer to receive default moderator;
							set to actual size returned.

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::GetDefaultModerator" );

    BOOL    fRtn = TRUE ;
    DWORD   cbDefaultModerator;
	DWORD	cbNewsgroup;

    if ( (pszDefaultModerator == NULL) || (pszNewsgroup == NULL) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return  FALSE;
    }

	cbNewsgroup = lstrlen( pszNewsgroup )+1;
	cbDefaultModerator = *pcbDefaultModerator;
    if ( m_cbDefaultModerator+cbNewsgroup+1 > cbDefaultModerator )
    {
        *pcbDefaultModerator = m_cbDefaultModerator+cbNewsgroup+1;
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return  FALSE;
    }

	DWORD i = 0;
	if( !wcschr( m_szDefaultModerator, (WCHAR)'@' ) )
	{
		//
		//	prefix hipehnated-newsgroup-name and @ sign
		//
		PCHAR pch = pszNewsgroup;
		for( i=0; *(pch+i) != '\0'; i++)
		{
			*(pszDefaultModerator+i) = ( *(pch+i) == '.' ) ? '-' : *(pch+i);
		}
		*(pszDefaultModerator+i) = '@';
		i++;
	}

	// null terminate string
	*(pszDefaultModerator+i) = '\0';
	*pcbDefaultModerator = i;

    LockConfigRead();

    if ( m_cbDefaultModerator > sizeof(WCHAR) )
    {
        *pcbDefaultModerator += WideCharToMultiByte(
									CP_ACP,
									0,
									m_szDefaultModerator,
									(int)m_cbDefaultModerator/sizeof(WCHAR),
									pszDefaultModerator+(*pcbDefaultModerator),
									cbDefaultModerator -(*pcbDefaultModerator),
									NULL,
									NULL
									);
        if ( *pcbDefaultModerator == i )
        {
            ErrorTrace( (LPARAM)this,
                        "WideCharToMultiByte failed: %d",
                        GetLastError() );
        }
    }
    else
    {
#if 0
        DWORD cbDefault = sizeof( "uunet.uu.net" );
        CopyMemory( pszDefaultModerator+(*pcbDefaultModerator), "uunet.uu.net", cbDefault);
        *pcbDefaultModerator += cbDefault;
#endif
		// no default configured !
		*pszDefaultModerator = '\0';
		*pcbDefaultModerator = 0;
    }

    UnLockConfigRead();

    return  TRUE;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::InitiateConnectionEx
//
//  Synopsis:   Called to resume
//
//  Arguments:  void
//
//  Returns:    TRUE is success, else FALSE
//
//  History:    HowardCu    Created         23 May 1995
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::InitiateConnectionEx(
        void*   patqContext
        )
/*++

Routine Description :

    This function accepts incoming calls from clients that are handled through AcceptEx.

Arguments :

    patqContext - an already allocate ATQ context for the session

Return Value :

    TRUE if we accepted the connection - FALSE otherwise.


--*/
{
    SOCKET  sNew = INVALID_SOCKET ;
    PVOID   pvBuff = 0 ;
    SOCKADDR*   psockaddrLocal = 0 ;
    SOCKADDR*   psockaddrRemote = 0 ;
    PIIS_ENDPOINT pEndpoint;

    AtqGetAcceptExAddrs(
        (PATQ_CONTEXT)patqContext,
        &sNew,
        &pvBuff,
		(PVOID*)&pEndpoint,
        &psockaddrLocal,
        &psockaddrRemote
        );

    return  InitiateConnection( (HANDLE)sNew, (SOCKADDR_IN*)psockaddrRemote,
                                (SOCKADDR_IN*)psockaddrLocal, patqContext,
								pEndpoint->IsSecure() ) ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::InitiateConnection
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::InitiateConnection(
    HANDLE			hSocket,
    SOCKADDR_IN*    psockaddr,
    SOCKADDR_IN*    psockaddrLocal,
    void*			patqContext,
	BOOL			fIsSecure
    )
/*++

Routine Description :

    Create the correct socket and context information for an incoming connection.
    Do so after making sure that the server is in a state to accept calls.

Arguments :

    hSocket - Winsock handle for the socket
    psockaddr - The remote guys IP address
    psockaddrLocal - The IP address the remote guy connected to
    patqContext - Optionally present Atq Context for session
	fIsSecure - Is this an SSL connection ?

Return Value :

    TRUE if successfull and socket accepted
    FALSE otherwise.


--*/
{
    USHORT  incomingPort = 119 ;
    if( psockaddrLocal )
        incomingPort = ntohs( psockaddrLocal->sin_port ) ;

    ENTER("NNTP_SERVER_INSTANCE::InitiateConnection")

    Assert( hSocket != (HANDLE)INVALID_SOCKET ) ;
    Assert( psockaddr != 0 ) ;



    CInFeed * pfeedFromClient = NULL;
    CInFeed * pfeedFromMaster = NULL;
    CInFeed * pfeedFromSlave = NULL;
    CInFeed * pfeedFromPeer = NULL;

    //
    // Create a feed, at most one of the CInFeed parameters will be nonnull.
    // Which one that is, tells the type of feed created.
    //

    CInFeed*    pFeed = pfeedCreateInFeed(
									this,
                                    psockaddr,
                                    psockaddrLocal?(psockaddrLocal->sin_addr.s_addr == psockaddr->sin_addr.s_addr) : FALSE,
                                    pfeedFromClient,
                                    pfeedFromMaster,
                                    pfeedFromSlave,
                                    pfeedFromPeer
                                    );

    if( pFeed ) {

        pFeed->SetLoginName("<feed>");

        DWORD localIP = 0 ;
        if( psockaddrLocal != 0 )
            localIP = psockaddrLocal->sin_addr.s_addr;
        CSessionSocket* pSocket =
            new CSessionSocket( this, localIP, incomingPort, FALSE) ;	// pass this instance to session socket !

        if( pSocket != NULL ) {

            //  Do the IP access check !
            if ( !VerifyClientAccess( pSocket, psockaddr ) ) {
                delete  pSocket ;		// does a Deref on this
                delete  pFeed ;
				ErrorTrace( 0, "connection denied - failed access check" ) ;
				return( FALSE);
            }

            if( pSocket->Accept(    hSocket,    pFeed, psockaddr, patqContext, fIsSecure ) ) {
                DebugTrace( 0, "CSessionSOcket::AcceptSocket succeeded!!" ) ;
                return  TRUE     ;
            }   else    {
                delete  pSocket ;		// does a Deref on this
                delete  pFeed;
				ErrorTrace( 0, "Failed to accept connection" ) ;
				return( FALSE);
            }
        }
    }
    ErrorTrace( 0, "Failed to accept connection" ) ;
	this->DecrementCurrentConnections();
	this->Dereference();
    return( FALSE);
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::InitializeServerStrings
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::InitializeServerStrings( VOID )
{
	BOOL 	fRet = TRUE ;
	PCHAR 	args [1];
	CHAR 	szId [20];
	char	szServerPath[ MAX_PATH ] ;

    CopyMemory( szServerPath, "c:\\", sizeof( "c:\\" ) ) ;
	_itoa( QueryInstanceId(), szId, 10 );
	args [0] = szId;

    m_szSmtpAddress[0] = (WCHAR)0;
    m_cbSmtpAddress = 1;

    m_szUucpName[0] = (WCHAR)0;
    m_cbUucpName = 1;

    HMODULE hModule = GetModuleHandle( NNTP_MODULE_NAME ) ;
    if( hModule != 0 ) {

        if( !GetModuleFileName( hModule, szServerPath, sizeof( szServerPath ) ) )   {
            CopyMemory( szServerPath, "c:\\", sizeof( "c:\\" ) ) ;
        }   else    {

            CopyMemory( m_szPostsAllowed, szPostsCode, sizeof( szPostsCode ) ) ;
            CopyMemory( m_szPostsNotAllowed, szNoPostsCode, sizeof( szNoPostsCode ) ) ;

            m_cbPostsAllowed = sizeof( szPostsCode ) + SetVersionStrings(   szServerPath, szTitle,
                    &m_szPostsAllowed[sizeof(szPostsCode)-1], sizeof( m_szPostsAllowed ) - sizeof( szPostsCode ) ) ;

            if( m_cbPostsAllowed + sizeof( szPostsAllowed ) >= sizeof( m_szPostsAllowed ) ) {
                m_szPostsAllowed[ sizeof( szPostsCode )-1 ] = '\0' ;
            }
            lstrcat( m_szPostsAllowed, szPostsAllowed ) ;
            m_cbPostsAllowed = lstrlen( m_szPostsAllowed ) ;

            m_cbPostsNotAllowed = sizeof( szNoPostsCode ) + SetVersionStrings(  szServerPath, szTitle,
                    &m_szPostsNotAllowed[sizeof(szNoPostsCode)-1], sizeof( m_szPostsNotAllowed ) - sizeof( szNoPostsCode ) ) ;

            if( m_cbPostsNotAllowed + sizeof( szPostsNotAllowed ) >= sizeof( m_szPostsNotAllowed ) )    {
                m_szPostsNotAllowed[ sizeof( szNoPostsCode )-1 ] = '\0' ;
            }
            lstrcat( m_szPostsNotAllowed, szPostsNotAllowed ) ;
            m_cbPostsNotAllowed = lstrlen( m_szPostsNotAllowed ) ;

            SetVersionStrings(  szServerPath, szTitle, szVersionString, 128 );

            int cb = lstrlen( szServerPath ) ;
            while( szServerPath[cb] != '\\' ) {
                szServerPath[cb--] = '\0' ;
            }
        }
    }

	//
	//	Initialize file paths - GetRegistrySettings may overwrite defaults !
	//
	lstrcpy( m_ArticleTableFile, szServerPath ) ;
	lstrcat( m_ArticleTableFile, NNTP_DEF_ARTICLETABLEFILE ) ;

	lstrcpy( m_HistoryTableFile, szServerPath ) ;
	lstrcat( m_HistoryTableFile, NNTP_DEF_HISTORYTABLEFILE ) ;

	lstrcpy( m_XoverTableFile, szServerPath ) ;
	lstrcat( m_XoverTableFile, NNTP_DEF_XOVERTABLEFILE ) ;

	lstrcpy( m_GroupListFile, szServerPath ) ;
	lstrcat( m_GroupListFile, NNTP_DEF_GROUPLISTFILE ) ;
    SetGroupListBakTmpPath();

	lstrcpy( m_GroupVarListFile, szServerPath ) ;
	lstrcat( m_GroupVarListFile, NNTP_DEF_GROUPVARLISTFILE ) ;

	lstrcpy( m_GroupHelpFile, szServerPath ) ;
	lstrcat( m_GroupHelpFile, NNTP_DEF_GROUPHELPFILE ) ;

	lstrcpy( m_ModeratorFile, szServerPath ) ;
	lstrcat( m_ModeratorFile, NNTP_DEF_MODERATORFILE ) ;

	lstrcpy( m_PrettynamesFile, szServerPath ) ;
	lstrcat( m_PrettynamesFile, NNTP_DEF_PRETTYNAMESFILE ) ;

	lstrcpy( m_szDropDirectory, szServerPath ) ;
	lstrcat( m_szDropDirectory, NNTP_DEF_DROPDIRECTORY ) ;

	//
	//	Initialize DNS name
	//
	if( gethostname( m_NntpDNSName, sizeof( m_NntpDNSName ) ) == SOCKET_ERROR ) {
		NntpLogEvent(	NNTP_CANT_GET_DNSNAME, 1, (const CHAR **)args, 0 ) ;
		goto	error_exit ;
	}	else	{

		hostent	*phostent = gethostbyname( m_NntpDNSName ) ;
		if( phostent == 0 ) {
			NntpLogEvent( NNTP_CANT_GET_DNSNAME, 1, (const CHAR**)args, 0) ;
			goto	error_exit ;
		}	else	{
			DWORD	cbName = lstrlen( phostent->h_name ) ;
			if( 1+cbName > sizeof( m_NntpDNSName ) ) {
				NntpLogEvent( NNTP_DNS_TOO_LARGE, 1, (const CHAR**)args, 0 ) ;
				goto	error_exit ;
			}
			CopyMemory( m_NntpDNSName, phostent->h_name, cbName+1 ) ;
			m_NntpDNSNameSize = cbName ;
		}
	}

	return fRet;

error_exit:

	return FALSE ;
}

BOOL
NNTP_SERVER_INSTANCE::AllocateServerStructures( VOID )
{
	LPCSTR lpPath = QueryMDPath();

	// should be NULL to begin with
	_ASSERT( !m_pArticleTable );
	_ASSERT( !m_pHistoryTable );
	_ASSERT( !m_pXoverTable );
	_ASSERT( !m_pXCache );
	_ASSERT( !m_pExpireObject );
	_ASSERT( !m_pActiveFeeds );
	_ASSERT( !m_pPassiveFeeds );
	_ASSERT( !m_pInUseList );
	_ASSERT( !m_pNntpServerObject);
	_ASSERT( !m_pInstanceWrapper);
	_ASSERT( !m_pInstanceWrapperEx );

	if( !(m_pArticleTable 		= CMsgArtMap::CreateMsgArtMap())			||
		!(m_pHistoryTable 		= CHistory::CreateCHistory())				||
		!(m_pXoverTable	  		= CXoverMap::CreateXoverMap())				||
		!(m_pXCache		  		= CXoverCache::CreateXoverCache())			||
		!(m_pNntpServerObject  	= XNEW CNntpServer(this))					||
		!(m_pInstanceWrapper  	= XNEW CNntpServerInstanceWrapperImpl(this))	||
		!(m_pInstanceWrapperEx  = XNEW CNntpServerInstanceWrapperImplEx(this))   ||
		!(m_pTree	  	  		= XNEW CNewsTree(m_pNntpServerObject))		||
		!(m_pVRootTable   		= XNEW CNNTPVRootTable(GetINewsTree(),
									CNewsTree::VRootRescanCallback))		||
		!(m_pExpireObject 		= XNEW CExpire(lpPath))						||
		!(m_pActiveFeeds  		= XNEW CFeedList)							||
		!(m_pPassiveFeeds 		= XNEW CFeedList)							||
		!(m_pInUseList    		= XNEW CSocketList)
		) {

		//
		//	Failed to allocate an object - free allocs that succeeded !
		//
		DELETE_CHK( m_pArticleTable ) ;
		DELETE_CHK( m_pHistoryTable ) ;
		DELETE_CHK( m_pXoverTable ) ;
		DELETE_CHK( m_pXCache ) ;
		DELETE_CHK( m_pExpireObject ) ;
		DELETE_CHK( m_pActiveFeeds ) ;
		DELETE_CHK( m_pPassiveFeeds ) ;
		DELETE_CHK( m_pInUseList ) ;
		DELETE_CHK( m_pNntpServerObject ) ;
		DELETE_CHK( m_pInstanceWrapper ) ;
		DELETE_CHK( m_pInstanceWrapperEx );

        // failure to allocate is fatal at this point !
        return FALSE;
	}

	// success !
	return TRUE ;
}

VOID
NNTP_SERVER_INSTANCE::FreeServerStructures( VOID )
{
	//
	//	Free if members are non-NULL
	//
	DELETE_CHK( m_pArticleTable ) ;
	DELETE_CHK( m_pHistoryTable ) ;
	DELETE_CHK( m_pXoverTable ) ;
	DELETE_CHK( m_pXCache ) ;
	DELETE_CHK( m_pExpireObject ) ;
	DELETE_CHK( m_pActiveFeeds ) ;
	DELETE_CHK( m_pPassiveFeeds ) ;
	DELETE_CHK( m_pInUseList ) ;
	DELETE_CHK( m_pNntpServerObject ) ;
	DELETE_CHK( m_pInstanceWrapper ) ;
	DELETE_CHK( m_pInstanceWrapperEx );

	if( m_lpAdminEmail ) {
		XDELETE[] m_lpAdminEmail;
		m_lpAdminEmail = NULL;
		m_cbAdminEmail = 0;
	}
}

BOOL
NNTP_SERVER_INSTANCE::VerifyHashTablesExist(
            BOOL fIgnoreGroupList
            )
{
    DWORD nFiles = 0;
	BOOL  fRet = TRUE ;
	DWORD dwError = 0;
    HANDLE hFind;
    WIN32_FIND_DATA findData;

	m_fAllFilesMustExist = FALSE ;

    //
    // check for artmap file
    //

    hFind = FindFirstFile(
                m_ArticleTableFile,
                &findData
                );

    if ( hFind != INVALID_HANDLE_VALUE ) {
        nFiles++;
        FindClose(hFind);
    }

    //
    // check for artmap file
    //

    hFind = FindFirstFile(
                m_XoverTableFile,
                &findData
                );

    if ( hFind != INVALID_HANDLE_VALUE ) {
        nFiles++;
        FindClose(hFind);
    }

    if (!fIgnoreGroupList)
    {
        hFind = FindFirstFile(
                    m_GroupListFile,
                    &findData
                    );

        if ( hFind != INVALID_HANDLE_VALUE ) {
            nFiles++;
            FindClose(hFind);
        }
    }

    //
    // ok, nFiles should either be 0 or 3 if fIgnoreGroupList == FALSE
    // otherwise, both hash tables must exist!!!
    //

    if ( fIgnoreGroupList )
    {
        if (nFiles != 2)
        {
            PCHAR args [1];
            CHAR  szId [20];
            _itoa( QueryInstanceId(), szId, 10 );
            args [0] = szId;

            ErrorTraceX(0,"only %d files found", nFiles);
            NntpLogEvent( NNTP_EVENT_HASH_MISSING,
                          1,
                          (const CHAR**)args,
                          nFiles );

            SetLastError(ERROR_FILE_NOT_FOUND);
            return(FALSE);
        }
    }
    else
    {
        //  BUGBUG: group.lst can be missing in PT MM1
        if ((nFiles != 0) && (nFiles != 2) && (nFiles != 3))
        {
            PCHAR args [1];
            CHAR  szId [20];
            _itoa( QueryInstanceId(), szId, 10 );
            args [0] = szId;

            ErrorTraceX(0,"only %d files found", nFiles);
            NntpLogEvent( NNTP_EVENT_HASH_CORRUPT,
                          1,
                          (const CHAR**)args,
                          nFiles );

            SetLastError(ERROR_FILE_NOT_FOUND);
            return(FALSE);
        }
    }

	if( nFiles == 3 ) {
		m_fAllFilesMustExist = TRUE ;
	}

    return fRet ;

} // VerifyHashTablesExist

//
//	Query the metabase for server bindings
//

DWORD
NNTP_SERVER_INSTANCE::QueryServerIP()
{
    MB mb( (IMDCOM*)m_Service->QueryMDObject() );
    MULTISZ msz;
    DWORD status = NO_ERROR;
    const CHAR * scan;
    DWORD ipAddress;
    USHORT ipPort;
    const CHAR * hostName;

    //
    // Open the metabase and get the current binding list.
    //

    if( mb.Open( QueryMDPath() ) ) {

        if( !mb.GetMultisz(
                "",
                MD_SERVER_BINDINGS,
                IIS_MD_UT_SERVER,
                &msz
                ) ) {

            status = GetLastError();

            if( status == MD_ERROR_DATA_NOT_FOUND ) {
            	//
            	//	Did not find server bindings
            	//
            	SetLastError( status );
            	return 0;
           	}
		}

        //
        // Close the metabase before continuing, as anyone that needs
        // to update the service status will need write access.
        //

        mb.Close();

    } else {

        status = GetLastError();

    }

    //
    // Scan the multisz and look for instances we'll need to create.
    //

    if( status == NO_ERROR ) {

        for( scan = msz.First() ;
             scan != NULL ;
             scan = msz.Next( scan ) ) {

            //
            // Parse the descriptor (in "ip_address:port:host_name" form)
            // into its component parts.
            //

            status = ParseDescriptor(
                                     scan,
                                     &ipAddress,
                                     &ipPort,
                                     &hostName
                                     );

            if( status == NO_ERROR ) {
            	//
            	//	Return the first IP found in MultiSz
            	//
            	return ipAddress ;
            }
		}
	}

    SetLastError( status );
	return 0;
}

DWORD
ParseDescriptor(
    IN const CHAR * Descriptor,
    OUT LPDWORD IpAddress,
    OUT PUSHORT IpPort,
    OUT const CHAR ** HostName
    )
/*++

Routine Description:

    Parses a descriptor string of the form "ip_address:ip_port:host_name"
    into its component parts.

Arguments:

    Descriptor - The descriptor string.

    IpAddress - Receives the IP address component if present, or
        INADDR_ANY if not.

    IpPort - Recieves the IP port component.

    HostName - Receives a pointer to the host name component.

Return Value:

    DWORD - Completion status. 0 if successful, !0 otherwise.

--*/
{

    const CHAR * ipAddressString;
    const CHAR * ipPortString;
    const CHAR * hostNameString;
    const CHAR * end;
    CHAR temp[sizeof("123.123.123.123")];
    INT length;
    LONG tempPort;

    //
    // Sanity check.
    //

    _ASSERT( Descriptor != NULL );
    _ASSERT( IpAddress != NULL );
    _ASSERT( IpPort != NULL );
    _ASSERT( HostName != NULL );

    //
    // Find the various parts of the descriptor;
    //

    ipAddressString = Descriptor;

    ipPortString = strchr( ipAddressString, ':' );

    if( ipPortString == NULL ) {
        goto fatal;
    }

    ipPortString++;

    hostNameString = strchr( ipPortString, ':' );

    if( hostNameString == NULL ) {
        goto fatal;
    }

    hostNameString++;

    //
    // Validate and parse the IP address portion.
    //

    if( *ipAddressString == ':' ) {

        *IpAddress = INADDR_ANY;

    } else {

        length = (INT)(ipPortString - ipAddressString - 1);

        if( length > sizeof(temp) ) {
            goto fatal;
        }

        memcpy(
            temp,
            ipAddressString,
            length
            );

        temp[length] = '\0';

        *IpAddress = (DWORD)inet_addr( temp );

        if( *IpAddress == INADDR_NONE ) {
            goto fatal;
        }

    }

    //
    // Validate and parse the port.
    //

    if( *ipPortString == ':' ) {
        goto fatal;
    }

    length = (INT)(hostNameString - ipPortString);

    if( length > sizeof(temp) ) {
        goto fatal;
    }

    memcpy(
        temp,
        ipPortString,
        length
        );

    temp[length] = '\0';

    tempPort = strtol(
                   temp,
                   (CHAR **)&end,
                   0
                   );

    if( tempPort <= 0 || tempPort > 0xFFFF ) {
        goto fatal;
    }

    if( *end != ':' ) {
        goto fatal;
    }

    *IpPort = (USHORT)tempPort;

    //
    // Validate and parse the host name.
    //

    if( *hostNameString == ' ' || *hostNameString == ':' ) {
        goto fatal;
    }

    *HostName = hostNameString;

    return NO_ERROR;

fatal:

    return ERROR_INVALID_PARAMETER;

}   // ParseDescriptor

NNTP_SERVER_INSTANCE::CreateControlGroups()
/*++

Routine Description:

    Create the control.* groups if they do not exist

Arguments:

Return Value:

    BOOL - TRUE on success and FALSE on failure !

--*/
{
	char	szNewsgroup [3][MAX_NEWSGROUP_NAME] ;
	BOOL    fRet = TRUE ;

	TraceFunctEnter( "NNTP_SERVER_INSTANCE::CreateControlGroups" ) ;

	lstrcpy( szNewsgroup[0], "control.newgroup" );
	lstrcpy( szNewsgroup[1], "control.rmgroup" );
	lstrcpy( szNewsgroup[2], "control.cancel" );

	CNewsTree*	ptree = GetTree() ;
	CGRPPTR	pGroup;

    for( int i=0; i<3; i++ ) {

	    EnterCriticalSection( &m_critNewsgroupRPCs ) ;

    	pGroup = ptree->GetGroup( szNewsgroup[i], lstrlen( szNewsgroup[i] ) ) ;
	    if( pGroup == 0 ) {
            //
            //  Group does not exist - create it !
            //
        	if( !ptree->CreateGroup( szNewsgroup[i], TRUE, NULL, FALSE ) ) {
        	    ErrorTrace(0,"Failed to create newsgroup %s", szNewsgroup[i]);
        	    fRet = FALSE ;
        	}	else	{
        	    DebugTrace(0,"Created newsgroup %s", szNewsgroup[i]);
       	    }
    	}

	    LeaveCriticalSection( &m_critNewsgroupRPCs ) ;
    }

    return fRet ;
}

void
NNTP_SERVER_INSTANCE::AdjustWatermarkIfNec( CNewsGroupCore *pNewGroup )
/*++
Routine description:

    Look up RmGroupQueue, to see if an old group with the same name
    exists.    If the old group exists, we'll have to bump our lowwatermark
    so that new posts will not overwrite old messages

Arguments:

    CNewsGroupCore *pNewsGroup  - The new group

Return value:

    None.
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::AdjustWatermarkIfNec" );
    _ASSERT( pNewGroup );

    //
    // Find the old group from rmgroup queue, if it exists
    //
    CGRPPTR         pOldGroup = NULL;
    BOOL            fFound = FALSE;
    DWORD	        dwStartTick = GetTickCount();

    //
    // If there is no rmgroup queue, we are done
    //
    if ( NULL == m_pExpireObject->m_RmgroupQueue ) return;

    fFound = m_pExpireObject->m_RmgroupQueue->Search( &pOldGroup, pNewGroup->GetGroupName() );

    //
    // If not found, we are done
    //
    if ( FALSE == fFound ) return;

    //
    // OK, now we should update the watermark
    //
    pNewGroup->SetLowWatermark( pOldGroup->GetHighWatermark() + 1 );
    pNewGroup->SetHighWatermark( pOldGroup->GetHighWatermark() );
    pNewGroup->SetMessageCount( 0 );

    //
    // Save them to the fixed prop file
    //
    pNewGroup->SaveFixedProperties();

    //
    // Now I am going to help ProcessRmGroupQ to process this group
    //
    pOldGroup->DeleteArticles( NULL, dwStartTick );
}

void
NNTP_SERVER_INSTANCE::SetWin32Error(    LPSTR   szVRootPath,
                                        DWORD   dwErr )
/*++
Routine description:

    Set win32 error code into one metabase vroot.  This is done in server
    because the server has the knowledge of metabase internal interface.
    Doing so inside vroot only ( by using MB external interface caused
    one deadlock )

Arguments:

    LPSTR   szVRootPath - The vroot path in MB to set this error code in
    DWORD   dwErr       - The Win32 error code to set

Return value:

    None.
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::SetWin32Error" );
    _ASSERT( szVRootPath );

    MB  mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    //
    // Open the key for read and write
    //
    if ( ! mb.Open( szVRootPath, METADATA_PERMISSION_WRITE ) ) {
        ErrorTrace(0, "Can't open feed key %d", GetLastError() );
        return;
    }

    //
    // Now set the error code
    //
    if ( !mb.SetDword(  "",
						MD_WIN32_ERROR,
						IIS_MD_UT_SERVER,
						dwErr,
						METADATA_VOLATILE) ) {
	    ErrorTrace( 0, "Set dword failed %d", GetLastError() );
	    mb.Close();
	    return;
	}

	//
	// Close MB
	//
	mb.Close();
	return;
}

BOOL
NNTP_SERVER_INSTANCE::EnqueueRmgroup(   CNewsGroupCore *pGroup )
/*++
Routine description:

    Insert the newsgroup into rmgroup queue

Arguments:

    CNewsGroupCore *pGroup - The newsgroup to be inserted

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::EnqueueRmgroup" );
    _ASSERT( pGroup );

    return ExpireObject()->m_RmgroupQueue->Enqueue( (CNewsGroup*)pGroup );
}

IIS_SSL_INFO*
NNTP_SERVER_INSTANCE::QueryAndReferenceSSLInfoObj( VOID )
/*++

   Description

       Returns SSL info for this instance; calls Reference() before returning

   Arguments:

       None

   Returns:

       Ptr to SSL info object on success, NULL if failure

--*/
{
    TraceFunctEnterEx((LPARAM)this, "NNTP_SERVER_INSTANCE::QueryAndReferenceSSLInfoObj");
    IIS_SSL_INFO *pPtr = NULL;

    LockThisForRead();

    //
    // If it's null, we may have to create it - unlock, lock for write and make sure it's
    // still NULL before creating it
    //
    if ( !m_pSSLInfo )
    {
        UnlockThis();

        LockThisForWrite();

        //
        // Still null, so create it now
        //
        if ( !m_pSSLInfo )
        {
            m_pSSLInfo = IIS_SSL_INFO::CreateSSLInfo( (LPTSTR) QueryMDPath(),
                                                            (IMDCOM *) g_pInetSvc->QueryMDObject() );

            if ( m_pSSLInfo == NULL )
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                UnlockThis();
                return NULL;
            }

		 // Add an internal reference
		 m_pSSLInfo->Reference();

         //
         // Register for changes
         //
         IIS_SERVER_CERT *pCert = m_pSSLInfo->GetCertificate();
		 if ( pCert ) {
			LogCertStatus();
		 }

         IIS_CTL *pCTL = m_pSSLInfo->GetCTL();
		 if ( pCTL ) {
			LogCTLStatus();
		 }

         if ( g_pCAPIStoreChangeNotifier )
         {
             if ( pCert && pCert->IsValid() )
             {
                 if (!g_pCAPIStoreChangeNotifier->RegisterStoreForChange( pCert->QueryStoreName(),
                                                                  pCert->QueryStoreHandle(),
                                                                  ResetSSLInfo,
                                                                  (PVOID) this ) )
                 {
                     DebugTrace((LPARAM)this,
                                "Failed to register for change event on store %s",
                                pCert->QueryStoreName());
                 }
             }

             if ( pCTL && pCTL->IsValid() )
             {
                 if (!g_pCAPIStoreChangeNotifier->RegisterStoreForChange( pCTL->QueryStoreName(),
                                                      pCTL->QueryOriginalStore(),
                                                                      ResetSSLInfo,
                                                                      (PVOID) this ) )
                 {
                     DebugTrace((LPARAM)this,
                                "Failed to register for change event on store %s",
                                pCTL->QueryStoreName());
                 }
             }

			 if ( pCert && pCert->IsValid() || pCTL && pCTL->IsValid() ) {

				HCERTSTORE hRootStore = CertOpenStore( 	CERT_STORE_PROV_SYSTEM_A,
														0,
														NULL,
														CERT_SYSTEM_STORE_LOCAL_MACHINE,
														"ROOT" );
				if ( hRootStore ) {
					//
					// watch for changes to root store
					//
					if ( !g_pCAPIStoreChangeNotifier->RegisterStoreForChange( 	"ROOT",
																				hRootStore,
																				ResetSSLInfo,
																				(PVOID)this ) ) {
						DebugTrace( 0, "Failed to register for change event on root store" );
					}

					CertCloseStore( hRootStore, 0 );
				} else {

					DebugTrace( 0, "Failed to open root store %d", GetLastError() );
				}
			 }
         } // if (g_pStoreChangeNotifier)

     } // if ( !m_pSSLInfo )

 } //if ( !m_pSSLInfo )

 //
 // At this point, m_pSSLInfo should not be NULL anymore, so add a reference
 //
 m_pSSLInfo->Reference();

 pPtr = m_pSSLInfo;

 UnlockThis();

 TraceFunctLeaveEx( (LPARAM)this );

 return pPtr;
}

VOID NNTP_SERVER_INSTANCE::ResetSSLInfo( LPVOID pvParam )
/*++
    Description:

        Wrapper function for function to call to notify of SSL changes

    Arguments:

        pvParam - pointer to instance for which SSL keys have changed

    Returns:

        Nothing

--*/
{

	TraceFunctEnter( "NNTP_SERVER_INSTANCE::ResetSSLInfo" );

    //
    // Call function to flush credential cache etc
    //
    if ( g_pSslKeysNotify )
    {
        g_pSslKeysNotify( SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED,
                          pvParam );
    }

    NNTP_SERVER_INSTANCE *pInst = (NNTP_SERVER_INSTANCE *) pvParam;

    pInst->LockThisForRead();

    if ( pInst->m_pSSLInfo )
    {
        pInst->UnlockThis();

        pInst->LockThisForWrite();

        if ( pInst->m_pSSLInfo )
        {
            //
            // Stop watching for change notifications
            //
            IIS_SERVER_CERT *pCert = pInst->m_pSSLInfo->QueryCertificate();
            IIS_CTL *pCTL = pInst->m_pSSLInfo->QueryCTL();

            if ( g_pCAPIStoreChangeNotifier )
            {
                if ( pCert && pCert->IsValid() )
                {
                    g_pCAPIStoreChangeNotifier->UnregisterStore( pCert->QueryStoreName(),
                                                             ResetSSLInfo,
                                                             (PVOID) pvParam );
                }

                if ( pCTL && pCTL->IsValid() )
                {
                    g_pCAPIStoreChangeNotifier->UnregisterStore( pCTL->QueryStoreName(),
                                                             ResetSSLInfo,
                                                             (PVOID) pvParam );
                }

				//
				// Stop watching for root store
				//
				g_pCAPIStoreChangeNotifier->UnregisterStore(	"ROOT",
																ResetSSLInfo,
																(PVOID)pvParam );

            }

            //
            // Release internal reference
            //
            IIS_SSL_INFO::Release( pInst->m_pSSLInfo );

            //
            // Next call to QueryAndReferenceSSLObj() will create it again
            //
            pInst->m_pSSLInfo = NULL;
        }
    }

    pInst->UnlockThis();

	TraceFunctLeaveEx( (LPARAM)NULL );
}

VOID NNTP_SERVER_INSTANCE::LogCertStatus()
/*++
    Description:

       Writes system log event about status of server certificate if the cert is in some
       way not quite kosher eg expired, revoked, not signature-valid

    Arguments:

       None

    Returns:

       Nothing
--*/
{
	TraceFunctEnterEx((LPARAM)this, "NNTP_SERVER_INSTANCE::LogCertStatus");
    _ASSERT( m_pSSLInfo );

    DWORD dwCertValidity = 0;

    //
    // If we didn't construct the cert fully, log an error
    //
    if ( !m_pSSLInfo->QueryCertificate()->IsValid() )
    {
        CONST CHAR *apszMsgs[2];
        CHAR achInstance[20];
        CHAR achErrorNumber[20];
        wsprintf( achInstance,
                  "%lu",
                  QueryInstanceId() );
        wsprintf( achErrorNumber,
                  "0x%x",
                  GetLastError() );

        apszMsgs[0] = achInstance;
        apszMsgs[1] = achErrorNumber;

        DWORD dwStatus = m_pSSLInfo->QueryCertificate()->Status();
        DWORD dwStringID = 0;

        DebugTrace((LPARAM)this,
                   "Couldn't retrieve server cert; status : %d",
                   dwStatus);

        switch ( dwStatus )
        {
        case CERT_ERR_MB:
            dwStringID = SSL_MSG_CERT_MB_ERROR;
            break;

        case CERT_ERR_CAPI:
            dwStringID = SSL_MSG_CERT_CAPI_ERROR;
            break;

        case CERT_ERR_CERT_NOT_FOUND:
            dwStringID = SSL_MSG_CERT_NOT_FOUND;
            break;

        default:
            dwStringID = SSL_MSG_CERT_INTERNAL_ERROR;
            break;
        }

        NntpLogEvent(dwStringID,
                              2,
                              apszMsgs,
                              0 );

		TraceFunctLeaveEx((LPARAM)this);
        return;
    }


    //
    // If cert is invalid in some other way , write the appropriate log message
    //
    if ( m_pSSLInfo->QueryCertValidity( &dwCertValidity ) )
    {
        const CHAR *apszMsgs[1];
        CHAR achInstance[20];
        wsprintfA( achInstance,
                   "%lu",
                   QueryInstanceId() );
        apszMsgs[0] = achInstance;
        DWORD dwMsgID = 0;

        if ( ( dwCertValidity & CERT_TRUST_IS_NOT_TIME_VALID ) ||
             ( dwCertValidity & CERT_TRUST_IS_NOT_TIME_NESTED ) ||
             ( dwCertValidity & CERT_TRUST_CTL_IS_NOT_TIME_VALID ) )
        {
            DebugTrace((LPARAM)this,
                       "Server cert/CTL is not time-valid or time-nested");

            dwMsgID = SSL_MSG_TIME_INVALID_SERVER_CERT;
        }


        if ( dwCertValidity & CERT_TRUST_IS_REVOKED )
        {
            DebugTrace((LPARAM)this,
                       "Server Cert is revoked");

            dwMsgID = SSL_MSG_REVOKED_SERVER_CERT;
        }

        if ( ( dwCertValidity & CERT_TRUST_IS_UNTRUSTED_ROOT ) ||
             ( dwCertValidity & CERT_TRUST_IS_PARTIAL_CHAIN ) )
        {
            DebugTrace((LPARAM)this,
                       "Server Cert doesn't chain up to a trusted root");

            dwMsgID = SSL_MSG_UNTRUSTED_SERVER_CERT;
        }

        if ( ( dwCertValidity & CERT_TRUST_IS_NOT_SIGNATURE_VALID ) ||
             ( dwCertValidity & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID ) )
        {
            DebugTrace((LPARAM)this,
                       "Server Cert/CTL is not signature valid");

            dwMsgID = SSL_MSG_SIGNATURE_INVALID_SERVER_CERT;
        }

        if ( dwMsgID )
        {
            NntpLogEvent( dwMsgID,
                                1,
                         apszMsgs,
                               0 ) ;
        }
    }

	TraceFunctLeaveEx((LPARAM)this);

}

VOID NNTP_SERVER_INSTANCE::LogCTLStatus()
/*++
    Description:

       Writes system log event about status of server CTL if CTL isn't valid

    Arguments:

      None

    Returns:

       Nothing
--*/
{
	TraceFunctEnterEx((LPARAM)this, "NNTP_SERVER_INSTANCE::LogCTLStatus");

    _ASSERT( m_pSSLInfo );

    //
    // If we didn't construct the CTL fully, log an error
    //
    if ( !m_pSSLInfo->QueryCTL()->IsValid() )
    {
        CONST CHAR *apszMsgs[2];
        CHAR achInstance[20];
        CHAR achErrorNumber[20];
        wsprintf( achInstance,
                  "%lu",
                  QueryInstanceId() );
        wsprintf( achErrorNumber,
                  "0x%x",
                  GetLastError() );

        apszMsgs[0] = achInstance;
        apszMsgs[1] = achErrorNumber;

        DWORD dwStatus = m_pSSLInfo->QueryCTL()->QueryStatus();
        DWORD dwStringID = 0;

        DebugTrace((LPARAM)this,
                   "Couldn't retrieve server CTL; status : %d\n",
                   dwStatus);

        switch ( dwStatus )
        {
        case CERT_ERR_MB:
            dwStringID = SSL_MSG_CTL_MB_ERROR;
            break;

        case CERT_ERR_CAPI:
            dwStringID = SSL_MSG_CTL_CAPI_ERROR;
            break;

        case CERT_ERR_CERT_NOT_FOUND:
            dwStringID = SSL_MSG_CTL_NOT_FOUND;
            break;

        default:
            dwStringID = SSL_MSG_CTL_INTERNAL_ERROR;
            break;
        }

        NntpLogEvent( dwStringID,
                              2,
                              apszMsgs,
                              0 );
		TraceFunctLeaveEx((LPARAM)this);
        return;
    }
	TraceFunctLeaveEx((LPARAM)this);
}

#if 0

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::BuildFileName
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::BuildFileName(
                    char*   szFileOut,
                    DWORD   cbFileOut,
                    char*   szFileIn
                    )
/*++

Routine Description :

    This function uses the directory where the service is installed to build
    paths for finding service files.

Arguments :
    szFileOut - Buffer in which to save path
    cbFileOut - size of output buffer
    szFileIn -  File name to be concatenated to service path

Return Value :
    TRUE if successfull, FALSE otherwise.

--*/
{

    DWORD   cbPath = 0 ;
    ZeroMemory( szFileOut, cbFileOut ) ;
    if( cbFileOut > ((cbPath = lstrlen( m_szServerPath )) + lstrlen( szFileIn ) + 1) ) {

        CopyMemory( szFileOut, m_szServerPath, cbPath ) ;
        if( szFileOut[cbPath-1] != '\\' ) {
            szFileOut[cbPath++] = '\\' ;
        }
        lstrcat( szFileOut, szFileIn ) ;
        return  TRUE ;
    }
    return  FALSE ;
}

#endif

#if 0
HRESULT NNTP_SERVER_INSTANCE::TriggerSEOPost(REFIID iidEvent,
											 CArticle *pArticle,
						   					 void *pGrouplist,
											 DWORD *pdwOperations,
											 char *szFilename,
											 HANDLE hFile,
											 DWORD dwFeedId)
{
	return TriggerServerEvent(m_pSEORouter, iidEvent, pArticle,
							  (CNEWSGROUPLIST *) pGrouplist,
							  pdwOperations, szFilename, hFile, dwFeedId);
}
#endif

BOOL NNTP_SERVER_INSTANCE::CancelMessage(const char *pszMessageID) {
	TraceFunctEnter("NNTP_SERVER_INSTANCE::CancelMessage");

	CInFeed *pInFeed;
	DWORD rc = TRUE;

	pInFeed = new CFromClientFeed();
	if (pInFeed != NULL) {
		CPCString pcMessageID;
		pcMessageID.m_pch = (char *) pszMessageID;
		pcMessageID.m_cch = lstrlen(pszMessageID);
		CNntpReturn nntpReturn;
		rc = pInFeed->fApplyCancelArticle(this->GetInstanceWrapper(), NULL, NULL, TRUE, pcMessageID, nntpReturn);

		if (!rc) {
			switch (nntpReturn.m_nrc) {
				case nrcArticleBadMessageID:
					SetLastError(ERROR_INVALID_PARAMETER);
					break;
				case nrcNoAccess:
					SetLastError(ERROR_ACCESS_DENIED);
					break;
				default:
					if (GetLastError() == 0)
						SetLastError(ERROR_NOT_ENOUGH_MEMORY);
					break;
			}
		}

		delete pInFeed;
	} else {
		ErrorTrace((DWORD_PTR) this, "new CFromClientFeed returned NULL");
		SetLastError(ERROR_OUTOFMEMORY);
		rc = FALSE;
	}

	DebugTrace((DWORD_PTR) this, "returning %lu, ec = %lu", rc, GetLastError());
	TraceFunctLeave();
	return rc;
}

void
NNTP_SERVER_INSTANCE::SetGroupListBakTmpPath( )
{
    DWORD   dwLen = lstrlen( m_GroupListFile );

    _ASSERT( dwLen > 0 );

    //
    // Generate Group.lst.bak path
    //

    lstrcpy( m_GroupListBak, m_GroupListFile );

    CHAR*   p=m_GroupListBak+dwLen;

    while (*p != '\\' && p > m_GroupListBak) p--;

    _ASSERT( p > m_GroupListBak );

    lstrcpy( p, NNTP_DEF_GROUPLISTBAK );

    //
    // Generate Group.lst.tmp path only if we have a valid
    // m_BootOptions member
    //

    if (m_BootOptions != NULL)
    {
        lstrcpy( m_BootOptions->szGroupListTmp, m_GroupListFile );

        p=m_BootOptions->szGroupListTmp+dwLen;

        while (*p != '\\' && p > m_BootOptions->szGroupListTmp) p--;

        _ASSERT( p > m_BootOptions->szGroupListTmp );

        lstrcpy( p, NNTP_DEF_GROUPLISTTMP );
    }
}

BOOL
NNTP_SERVER_INSTANCE::UpdateIsComplete( IN LPSTR   szMDPath,
                                        OUT PBOOL  pfCompleted )
/*++
Routine description:

    Check if one feed update transaction is over, by checking
    the MD_FEED_HANDSHAKE flag.

Arguements:

    IN LPSTR szMDPath - The MD path under which the flag will be checked
    OUT PBOOL pfCompleted - The buffer to return if it's completed

Return value:

    TRUE if the completion check is successful, FALSE otherwise, eg.
    the metabase key can't be opened for read.
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::UpdateIsComplete" );
    _ASSERT( szMDPath );

    MB      mb( ( IMDCOM*) g_pInetSvc->QueryMDObject() );
    DWORD   dwHandShake;

    *pfCompleted = FALSE;

    //
    // Try open the metabase key with read permission
    //
    if ( !mb.Open(  szMDPath, METADATA_PERMISSION_READ ) ) {
        //
        // admin should have closed the feed key after writing
        // the handshake flag.  So if open error with read request,
        // we assume admin is not done with updating one feed yet:
        //
        // This assumption requires admin to close a write handle to
        // a metabase object and then save the object at least once
        // for every feed change.  Otherwise we'll lose information
        // for feed update
        //
        goto func_exit;
    }

    //
    // Read the handshake flag
    //
    if ( !mb.GetDword(  "",
                        MD_FEED_HANDSHAKE,
                        IIS_MD_UT_SERVER,
                        &dwHandShake ) ) {
        //
        // The handshake property should already have been
        // created when instance starts up.  This is an error
        //
        ErrorTrace( 0, "Get MD property %d failed", MD_FEED_HANDSHAKE );
        mb.Close();
        goto fail_exit;
    }

    switch( dwHandShake ) {

        case FEED_UPDATING:
            break;

        case FEED_UPDATE_COMPLETE:
            *pfCompleted = TRUE;
            break;

        default:
            _ASSERT( 0 );   // shouldn't be other values.
    }

func_exit:
    mb.Close();
    TraceFunctLeave();
    return TRUE;

fail_exit:
    TraceFunctLeave( );
    return FALSE;
}

BOOL
NNTP_SERVER_INSTANCE::VerifyFeedPath(   IN  LPSTR  szMDPath,
                                        OUT PDWORD  pdwFeedID )
/*++
Routine description:

    Verify if the MD notification path is really the feed path.
    If it is, extract the feed ID ( optional ).

Arguments:

    IN LPSTR szMDPath - The path to verify
    OUT PDWORD pdwFeedID - Pointer to buffer to return Feed ID

Return value:

    TRUE if verify succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::VerifyFeedPath" );
    _ASSERT( szMDPath );

    LPSTR   lpstrFeedPath = QueryMDFeedPath();
    LPSTR   lpstrDigitBegin;
    LPSTR   lpstrDigitEnd;
    CHAR    szBuffer[MAX_PATH];
    DWORD   dwIDLen;
    BOOL    fResult = FALSE;

    //
    // Instance feed path should be prefix of szMDPath
    //
    if ( _strnicmp( szMDPath, lpstrFeedPath, lstrlen( lpstrFeedPath ) ) != 0 ) {
        DebugTrace(0, "Shouldn't have been trapped in feed change notification" );
        goto Exit;
    }

    //
    // If feed ID wants to be extracted
    //
    if ( pdwFeedID ) {

        lpstrDigitBegin = szMDPath + lstrlen( lpstrFeedPath );

        while( *lpstrDigitBegin && !isdigit( *lpstrDigitBegin ) )
            lpstrDigitBegin++;

        lpstrDigitEnd = lpstrDigitBegin;

        while( *lpstrDigitEnd && isdigit( *lpstrDigitEnd ) )
            lpstrDigitEnd++;

        _ASSERT( lpstrDigitEnd <= szMDPath + lstrlen( szMDPath ) );

        dwIDLen = (DWORD)( lpstrDigitEnd - lpstrDigitBegin ) / sizeof ( CHAR );

        strncpy( szBuffer, lpstrDigitBegin, dwIDLen );
        *( szBuffer + dwIDLen ) = 0;

        *pdwFeedID = atol( szBuffer );

        //
        // if Feed ID is zero, failed
        //
        if ( 0 == pdwFeedID ) {
            ErrorTrace(0, "Notified MD path incorrect" );
            goto Exit;
        }
    }

    fResult = TRUE;

Exit:

    TraceFunctLeave( );
    return fResult;
}

BOOL
NNTP_SERVER_INSTANCE::AddSetFeed( IN DWORD dwFeedID )
/*++
Routine description:

    Add a feed or set feed info in the feed block data.  Parameters
    are loaded from metabase first.

Arguments:

    IN DWORD dwFeedID - The feed ID to set

Return value:

    TRUE if succeed, FALSE otherwise.
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::AddSetFeed" );
    _ASSERT( dwFeedID > 0 );

    CHAR           szFeedPath[MAX_PATH+1];    // buffer for feed key
    MB              mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    NNTP_FEED_INFO  feedInfo;
    CHAR            szFeedServer[MAX_PATH+1];
    WCHAR           wszFeedServer[MAX_PATH+1];
    DWORD           dwDataSize;
    DWORD           dwErrorMask = 0;

    CHAR            Distribution[1024];
    WCHAR           wszDistribution[1024];
    CHAR            szBigBuffer[1024];
    DWORD           dwDistributionSize;
    CHAR            Newsgroup[1024];
    WCHAR           wszNewsgroup[1024];
    DWORD           dwNewsgroupSize;
    CHAR            TempDir[1024];
    WCHAR           wszTempDir[1024];
    DWORD           dwTempDirSize;
    CHAR            UucpName[1024];
    WCHAR           wszUucpName[1024];
    DWORD           dwUucpNameSize;
    CHAR            NntpAccount[MAX_PATH+1];
    WCHAR           wszNntpAccount[MAX_PATH+1];
    DWORD           dwNntpAccountSize;
    CHAR            NntpPassword[MAX_PATH+1];
    WCHAR           wszNntpPassword[MAX_PATH+1];
    DWORD           dwNntpPassword;

    DWORD           dwAllowControlMsg;
    APIERR          err;
    DWORD           dwFeedIDToReturn;   // needed by AddFeed call

    DWORD           dwMetadataBuffer;
    CHAR            szKeyName[MAX_PATH];

    dwDistributionSize = sizeof( Distribution );
    ZeroMemory( Distribution, dwDistributionSize );
    MULTISZ         msz1( Distribution, dwDistributionSize );

    dwNewsgroupSize = sizeof( Newsgroup );
    ZeroMemory( Newsgroup, dwNewsgroupSize );
    MULTISZ         msz2( Newsgroup, dwNewsgroupSize );

    PFEED_BLOCK     pfeedBlock1 = NULL;
    PFEED_BLOCK     pfeedBlock2 = NULL;

    sprintf( szFeedPath, "%sFeed%d/", QueryMDFeedPath(), dwFeedID );

    //
    // Open the feed key for read and write
    //
    if ( ! mb.Open( szFeedPath, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) {
        ErrorTrace(0, "Can't open feed key" );
        goto fail_exit;
    }

    //
    // Set default info values
    //
    ZeroMemory( &feedInfo, sizeof( NNTP_FEED_INFO ) );
    feedInfo.Enabled = TRUE;
    feedInfo.fAllowControlMessages = TRUE;
    feedInfo.OutgoingPort = NNTP_PORT;
    feedInfo.ConcurrentSessions = 1;
    feedInfo.AuthenticationSecurityType = AUTH_PROTOCOL_NONE;

    //
    // Begin loading parameters
    //

    if ( !mb.GetDword(  "",
                        MD_FEED_DISABLED,
                        IIS_MD_UT_SERVER,
                        &dwMetadataBuffer ) )
        feedInfo.Enabled = TRUE;    // default - allow feed
    else
        feedInfo.Enabled = dwMetadataBuffer ? TRUE : FALSE ;

    dwDataSize = MAX_PATH;
    if ( mb.GetString(  "",
                        MD_FEED_SERVER_NAME,
                        IIS_MD_UT_SERVER,
                        szFeedServer,
                        &dwDataSize ) ) {
        CopyAsciiStringIntoUnicode( wszFeedServer, szFeedServer );
        feedInfo.ServerName = wszFeedServer;
    } else {
        dwErrorMask |= FEED_PARM_SERVERNAME;
        err = ERROR_INVALID_PARAMETER;
        goto mark_error;
    }

    if ( ! mb.GetDword( "",
                        MD_FEED_TYPE,
                        IIS_MD_UT_SERVER,
                        &feedInfo.FeedType ) )
    {
        dwErrorMask |= FEED_PARM_FEEDTYPE;
        err = ERROR_INVALID_PARAMETER;
        goto mark_error;
    }

    if ( !ValidateFeedType( feedInfo.FeedType ) ) {
        dwErrorMask |= FEED_PARM_FEEDTYPE;
        err = ERROR_INVALID_PARAMETER;
        goto mark_error;
    }

    if ( !mb.GetDword(  "",
                        MD_FEED_CREATE_AUTOMATICALLY,
                        IIS_MD_UT_SERVER,
                        &dwMetadataBuffer ) )
        feedInfo.AutoCreate = FALSE;
    else
        feedInfo.AutoCreate = dwMetadataBuffer ? TRUE : FALSE;

    if ( !FEED_IS_PASSIVE( feedInfo.FeedType ) ) {

        if ( !mb.GetDword(  "",
                            MD_FEED_INTERVAL,
                            IIS_MD_UT_SERVER,
                            &feedInfo.FeedInterval ) )
            feedInfo.FeedInterval = DEF_FEED_INTERVAL;
        else if ( feedInfo.FeedInterval < MIN_FEED_INTERVAL )
                feedInfo.FeedInterval = MIN_FEED_INTERVAL;


        if ( !mb.GetDword(  "",
                            MD_FEED_START_TIME_HIGH,
                            IIS_MD_UT_SERVER,
                            &feedInfo.StartTime.dwHighDateTime ) ) {
           feedInfo.StartTime.dwHighDateTime = 0;
           feedInfo.StartTime.dwLowDateTime = 0;
           goto end_time;
        }

        if ( !mb.GetDword( "",
                           MD_FEED_START_TIME_LOW,
                           IIS_MD_UT_SERVER,
                           &feedInfo.StartTime.dwLowDateTime ) ) {
            feedInfo.StartTime.dwLowDateTime = 0;
            feedInfo.StartTime.dwHighDateTime = 0;
            goto end_time;
        }

        if ( FEED_IS_PULL( feedInfo.FeedType ) ) {

            if ( !mb.GetDword(  "",
                                MD_FEED_NEXT_PULL_HIGH,
                                IIS_MD_UT_SERVER,
                                &feedInfo.PullRequestTime.dwHighDateTime ) )
                feedInfo.PullRequestTime.dwHighDateTime = 0;

            if ( !mb.GetDword(  "",
                                MD_FEED_NEXT_PULL_LOW,
                                IIS_MD_UT_SERVER,
                                &feedInfo.PullRequestTime.dwLowDateTime ) ) {
                feedInfo.PullRequestTime.dwHighDateTime = 0;
                feedInfo.PullRequestTime.dwLowDateTime = 0;
            }
        }
    } else {
        feedInfo.StartTime.dwHighDateTime = 0;
        feedInfo.StartTime.dwLowDateTime = 0;
        feedInfo.FeedInterval = 0;
    }

end_time:


    if ( !mb.GetMultisz(    "",
                            MD_FEED_DISTRIBUTION,
                            IIS_MD_UT_SERVER,
                            &msz1 ) ) {
        dwErrorMask |= FEED_PARM_DISTRIBUTION;
        err = ERROR_INVALID_PARAMETER;
        goto mark_error;
    }

    dwDistributionSize = msz1.QueryCCH();
    CopyMemory( szBigBuffer, msz1.QueryStr(), dwDistributionSize );
    CopyNAsciiStringIntoUnicode( wszDistribution, szBigBuffer,
        dwDistributionSize, sizeof(szBigBuffer) / sizeof(WCHAR) );
    feedInfo.Distribution =  wszDistribution;
    feedInfo.cbDistribution = sizeof( WCHAR ) * dwDistributionSize;

    if ( !mb.GetMultisz(    "",
                            MD_FEED_NEWSGROUPS,
                            IIS_MD_UT_SERVER,
                            &msz2 ) ) {
        dwErrorMask |= FEED_PARM_NEWSGROUPS;
        err = ERROR_INVALID_PARAMETER;
        goto mark_error;
    }

    dwNewsgroupSize = msz2.QueryCCH();
    CopyMemory( szBigBuffer, msz2.QueryStr(), dwNewsgroupSize );
    CopyNAsciiStringIntoUnicode( wszNewsgroup, szBigBuffer,
        dwNewsgroupSize, sizeof(szBigBuffer) / sizeof(WCHAR) );
    feedInfo.Newsgroups = wszNewsgroup;
    feedInfo.cbNewsgroups = sizeof( WCHAR ) * dwNewsgroupSize;

    dwTempDirSize = sizeof( TempDir );
    ZeroMemory( TempDir, dwTempDirSize );
    if ( !mb.GetString(    "",
                            MD_FEED_TEMP_DIRECTORY,
                            IIS_MD_UT_SERVER,
                            TempDir,
                            &dwTempDirSize ) ) {
        // we'll use the system temp path so that we
        // don't fail those feeds that are missing temp
        // paths
        /*
        dwErrorMask |= FEED_PARM_TEMPDIR;
        err = ERROR_INVALID_PARAMETER;
        goto mark_error;*/
        _VERIFY( GetTempPath( 1023, TempDir ) );
    }

    CopyAsciiStringIntoUnicode( wszTempDir, TempDir );
    feedInfo.FeedTempDirectory = wszTempDir;
    feedInfo.cbFeedTempDirectory = 2 * dwTempDirSize;

    if ( FEED_IS_PUSH( feedInfo.FeedType ) ) {

        dwUucpNameSize =  sizeof( UucpName );
        if ( !mb.GetString( "",
                            MD_FEED_UUCP_NAME,
                            IIS_MD_UT_SERVER,
                            UucpName,
                            &dwUucpNameSize ) ) {
            //
            // attempt to use remote server name
            //
            if ( inet_addr( szFeedServer ) == INADDR_NONE ) {
                lstrcpy( UucpName, szFeedServer );
                dwUucpNameSize = lstrlen( UucpName );
            } else {
                dwErrorMask |= FEED_PARM_UUCPNAME;
                err = ERROR_INVALID_PARAMETER;
                goto mark_error;
            }
        }

        CopyAsciiStringIntoUnicode( wszUucpName, UucpName );
        feedInfo.UucpName = wszUucpName;
        feedInfo.cbUucpName = dwUucpNameSize;

        if ( !mb.GetDword( "",
                            MD_FEED_CONCURRENT_SESSIONS,
                            IIS_MD_UT_SERVER,
                            &feedInfo.ConcurrentSessions ) ) {
            dwErrorMask |= FEED_PARM_CONCURRENTSESSION;
            err = ERROR_INVALID_PARAMETER;
            goto mark_error;
        }
    }

    if ( FEED_IS_PUSH( feedInfo.FeedType ) || FEED_IS_PULL( feedInfo.FeedType ) ) {
        if ( !mb.GetDword(  "",
                            MD_FEED_MAX_CONNECTION_ATTEMPTS,
                            IIS_MD_UT_SERVER,
                            &feedInfo.MaxConnectAttempts ) ) {
            dwErrorMask |= FEED_PARM_MAXCONNECT;
            err = ERROR_INVALID_PARAMETER;
            goto mark_error;
        }
    }

    if ( !mb.GetDword(  "",
                        MD_FEED_AUTHENTICATION_TYPE,
                        IIS_MD_UT_SERVER,
                        &feedInfo.AuthenticationSecurityType ) ) {
        dwErrorMask |= FEED_PARM_AUTHTYPE;
        err = ERROR_INVALID_PARAMETER;
        goto mark_error;
    }

    if ( feedInfo.AuthenticationSecurityType != AUTH_PROTOCOL_NONE &&
         feedInfo.AuthenticationSecurityType == AUTH_PROTOCOL_CLEAR ) {

        dwNntpAccountSize = sizeof( NntpAccount );
        if ( !mb.GetString( "",
                            MD_FEED_ACCOUNT_NAME,
                            IIS_MD_UT_SERVER,
                            NntpAccount,
                            &dwNntpAccountSize ) ) {
            dwErrorMask |= FEED_PARM_ACCOUNTNAME;
            err = ERROR_INVALID_PARAMETER;
            goto mark_error;
        }

        CopyAsciiStringIntoUnicode( wszNntpAccount, NntpAccount );
        feedInfo.NntpAccountName = wszNntpAccount;
        feedInfo.cbAccountName = 2 * dwNntpAccountSize;

        dwNntpPassword= sizeof( NntpPassword );
        if ( !mb.GetString( "",
                            MD_FEED_PASSWORD,
                            IIS_MD_UT_SERVER,
                            NntpPassword,
                            &dwNntpPassword,
                            METADATA_SECURE) ) {
            dwErrorMask |= FEED_PARM_PASSWORD;
            err = ERROR_INVALID_PARAMETER;
            goto mark_error;
        }

        CopyAsciiStringIntoUnicode( wszNntpPassword, NntpPassword );
        feedInfo.NntpPassword = wszNntpPassword;
        feedInfo.cbPassword = dwNntpPassword;
    }

    if ( !mb.GetDword(  "",
                        MD_FEED_ALLOW_CONTROL_MSGS,
                        IIS_MD_UT_SERVER,
                        &dwAllowControlMsg ) )
        feedInfo.fAllowControlMessages = TRUE;
    else
        feedInfo.fAllowControlMessages = dwAllowControlMsg ? TRUE : FALSE;

    mb.GetDword(   "",
                   MD_FEED_OUTGOING_PORT,
                    IIS_MD_UT_SERVER,
                    &feedInfo.OutgoingPort );

    mb.GetDword(    "",
                    MD_FEED_FEEDPAIR_ID,
                    IIS_MD_UT_SERVER,
                    &feedInfo.FeedPairId );

    feedInfo.FeedId = dwFeedID;

    if ( !mb.GetDword(  "",
                        MD_FEED_SECURITY_TYPE,
                        IIS_MD_UT_SERVER,
                        &feedInfo.SessionSecurityType ) )
        feedInfo.SessionSecurityType = 0;

    //
    // OK, now it's time to do the right thing
    //

    //
    // We should find out if this is a feed add or set
    // Because when a feed is added, metabase notification
    // would be two steps:
    // 1. Add key
    // 2. Set new info
    // But we are ignoring the first notification because one
    // feed update transaction isn't over until new info is
    // set.  So the only way to check if this is a new feed
    // is to search the feed list, while not from the MB
    // notification object.
    //
    pfeedBlock1 = m_pActiveFeeds->Search( dwFeedID );
    pfeedBlock2 = m_pPassiveFeeds->Search( dwFeedID );
    if ( !pfeedBlock1 && !pfeedBlock2 ) {
        sprintf( szKeyName, "feed%d", dwFeedID );
        err = AddFeedToFeedBlock(   NULL,
                                    QueryInstanceId(),
                                    (LPI_FEED_INFO)&feedInfo,
                                    szKeyName,
                                    &dwErrorMask,
                                    &dwFeedIDToReturn );
    } else {
        if ( pfeedBlock1 ) m_pActiveFeeds->FinishWith( this, pfeedBlock1 );
        if ( pfeedBlock2 ) m_pActiveFeeds->FinishWith( this, pfeedBlock2 );
        err = SetFeedInformationToFeedBlock(    NULL,
                                                QueryInstanceId(),
                                                (LPI_FEED_INFO)&feedInfo,
                                                &dwErrorMask );
    }

mark_error:

    //
    // Now set the error code and masks
    //
    if ( !mb.SetDword(  "",
                        MD_FEED_ADMIN_ERROR,
                        IIS_MD_UT_SERVER,
                        err  ) ) {
        mb.Close();
        ErrorTrace(0, "Setting error code fail" );
        goto fail_exit;
    }

    if ( !mb.SetDword(  "",
                        MD_FEED_ERR_PARM_MASK,
                        IIS_MD_UT_SERVER,
                        dwErrorMask ) )  {
        mb.Close();
        ErrorTrace(0, "Setting parm mask fail" );
        goto fail_exit;
    }

    //
    // Now we may set handshake confirm
    //
    if ( !mb.SetDword(  "",
                        MD_FEED_HANDSHAKE,
                        IIS_MD_UT_SERVER,
                        FEED_UPDATE_CONFIRM ) ) {
        mb.Close();
        ErrorTrace(0, "Setting hand shake fail" );
        goto fail_exit;
    }

    mb.Close();
    mb.Save();

    TraceFunctLeave( );
    return TRUE;

fail_exit:

    TraceFunctLeave( );
    return FALSE;
}

VOID
NNTP_SERVER_INSTANCE::DeleteFeed( IN DWORD dwFeedID )
/*++
Routine description:

    Delete the feed in the feed block data structure, when
    receiving the notification of feed deletion in metabase

Arguments:

    IN DWORD dwFeedID - Feed ID to delete

Return value:

    None.
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::DeleteFeed" );
    _ASSERT( dwFeedID > 0 );

    DeleteFeedFromFeedBlock(    NULL,
                                QueryInstanceId(),
                      dwFeedID );

    TraceFunctLeave( );
}

VOID
NNTP_SERVER_INSTANCE::UpdateFeed( IN PMD_CHANGE_OBJECT pcoChangeList,
                                  IN DWORD dwFeedID )
/*++
Routine description:

    When the MB change occurs with feed ID level property change,
    this method gets called to check what has been changed in
    the metabase and do necessary updates to the feed block.

Arguments:

    IN MD_CHANGE_OBJECT *pcoChangeList - The metabase change object

Return value:

    None.
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::UpdateFeed" );
    _ASSERT( pcoChangeList );

    BOOL            fOK;
    BOOL            fUpdateIsComplete;

    //
    // If it's a deletion, we don't need to ssync up with admin
    //
    if ( pcoChangeList->dwMDChangeType == MD_CHANGE_TYPE_DELETE_OBJECT ) {
        DeleteFeed( dwFeedID );
        goto func_exit;
    }

    //
    // Is one update transaction over ?
    //
    // For changes made before one transaction is over, we will remember
    // the parameter that has been changed by setting the feed update
    // mask.  Only when one transaction is over will we really update
    // the feed block info.
    //
    // Assume: admin behaves properly so that consecutive updates during
    //         one transaction happened to one feed and we assume the
    //         feed to change is specified by the MD path of last
    //         MD notification during one transaction
    //
    fOK = UpdateIsComplete( ( LPSTR ) ( pcoChangeList->pszMDPath ) ,
                            &fUpdateIsComplete );

    if ( !fOK ) {   // this is error, but what we can do is ignore
                    // this update
        ErrorTrace(0, "UpdateIsComplete failed" );
        goto func_exit;
    }

    //
    // If it's not complete, we should ignore this notification
    //
    if ( !fUpdateIsComplete ) goto func_exit;

    //
    // If it's completed, we should deal with two cases:
    // 1)  Feed info set
    // 2)  Feed Add
    // for which we should check the change type
    //
    if ( pcoChangeList->dwMDChangeType != MD_CHANGE_TYPE_ADD_OBJECT &&
         pcoChangeList->dwMDChangeType != MD_CHANGE_TYPE_SET_DATA &&
         pcoChangeList->dwMDChangeType != MD_CHANGE_TYPE_DELETE_DATA )
        // we ignore it
        goto func_exit;

    //
    // If it's feed info set or add, we should reload / load all
    // the parameters and feed them into feed block
    //
    if ( ! AddSetFeed( dwFeedID ) )
        ErrorTrace(0, "AddSetFeed fail" );  // currently we keep silent

func_exit:

    TraceFunctLeave( );
}

BOOL
NNTP_SERVER_INSTANCE::IsNotMyChange( IN LPSTR szMDPath, DWORD dwMDChangeType )
/*++
Routine description:

    Server instance is picking up MB change for feed and setting
    flags to MB.  This setting could also result in MB notification.
    We don't want to be trapped in this dead loop.  So this function
    checks if the notification is generated by myself.  If the handshake
    flag is "confirmed", it means the changed is caused by itself.
    Otherwise it's caused by admin.

Arguments:

    IN LPSTR szMDPath - The metabase path to check

Return value:

    TRUE if it's not changed by myself, FALSE otherwise
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::IsNotChange" );
    _ASSERT( szMDPath );
    BOOL    fResult;
    DWORD   dwHandShake;

    MB mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    //
    // open the handshake key for read
    //
    if ( !mb.Open( szMDPath, METADATA_PERMISSION_READ ) ) {
        //
        // This could be a delete, when it's a deletion,
        // we should still go ahead updating feed block
        //
        if ( dwMDChangeType != MD_CHANGE_TYPE_DELETE_OBJECT ) {
            ErrorTrace(0, "open md key %s fail", szMDPath );
            fResult = FALSE;  // this doesn't necessarily mean
                                // my change.  But by returning
                                // false we are telling caller
                                // that there is no need to proceed
                                // with this update, since we even
                                // can not read the metabase key
            goto func_exit;
        } else {
            fResult = TRUE;
            goto func_exit;
        }
    }

    if ( !mb.GetDword(  "",
                        MD_FEED_HANDSHAKE,
                        IIS_MD_UT_SERVER,
                        &dwHandShake ) ) {
        ErrorTrace(0, "fail to read handshake" );
        fResult = FALSE;  // same comments as above
        mb.Close();
        goto func_exit;
    }

    fResult = dwHandShake == FEED_UPDATE_CONFIRM ? FALSE : TRUE;
    mb.Close();

func_exit:

    TraceFunctLeave( );
    return fResult;
}

BOOL
NNTP_SERVER_INSTANCE::MailArticle(  CNewsGroupCore *pGroupCore,
                                    ARTICLEID       artid,
                                    LPSTR           szModerator )
/*++
Routine description:

    Mail the article out to moderator

Arguments:

    CNewsGroupcore *pGroupCore  - The group to load the article from
    ARTICLEID       artid       - Article id inside that special group

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::MailArticle" );
    _ASSERT( pGroupCore );
    _ASSERT( artid > 0 );

    //
    // Init get the article object
    //
    STOREID storeid;
    const DWORD cchMaxBuffer = 2 * 1024; // this should be enough
    									 // for normal cases, if
    									 // it's not enough, CAllocator
    									 // will use "new"
    CHAR        pchBuffer[cchMaxBuffer];
    CAllocator  allocator(pchBuffer, cchMaxBuffer);
    CToClientArticle    *pArticle = ((CNewsGroup*)pGroupCore)->GetArticle(  GetInstanceWrapper(),
                                                                artid,
                                                                storeid,
                                                                NULL,
                                                                NULL,
                                                                &allocator,
                                                                TRUE );
    _ASSERT( pArticle );
    if ( !pArticle ) {
        ErrorTrace( 0, "Get article object failed %d", GetLastError());
        return FALSE;
    }

    //
    // Now use the article library to mail it
    //
    BOOL f = pArticle->fMailArticle( szModerator );

    delete pArticle;
    TraceFunctLeave();
    return f;
}

///////////////////////////////////////////////////////////////////////////////
// Rebuild related methods
///////////////////////////////////////////////////////////////////////////////
DWORD
NNTP_SERVER_INSTANCE::GetRebuildProgress()
{
    return m_dwProgress;
}

DWORD
NNTP_SERVER_INSTANCE::GetRebuildLastError()
{
    return m_dwLastRebuildError;
}

void
NNTP_SERVER_INSTANCE::SetRebuildProgress( DWORD dw )
{
    m_dwProgress = dw;
}

void
NNTP_SERVER_INSTANCE::SetRebuildLastError( DWORD dw )
{
    m_dwLastRebuildError = dw;
}

BOOL
NNTP_SERVER_INSTANCE::BlockUntilStable()
{
    return m_pVRootTable->BlockUntilStable( 1000 );
}

BOOL
NNTP_SERVER_INSTANCE::AllConnected()
{
    return m_pVRootTable->AllConnected();
}

BOOL
NNTP_SERVER_INSTANCE::CreateRebuildObject()
/*++
Routine description:

    Create the proper rebuild object ( standard or complete rebuild ), based
    on the options we have now.

Arguments:

    None.

Return value:

    TRUE, if succeeded, FALSE otherwise.  If false, LastError will be set
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::CreateRebuildObject" );

    //
    // There should be no previous rebuild going on here
    //
    _ASSERT( NULL == m_pRebuild );

    if ( NNTPBLD_DEGREE_STANDARD == m_BootOptions->ReuseIndexFiles ) {

        // We should create CStandardReBuild
        m_pRebuild = XNEW CStandardRebuild( this, m_BootOptions );
    } else {

        // We should create CCompleteRebuild
        m_pRebuild = XNEW CCompleteRebuild( this, m_BootOptions );

    }

    if ( NULL == m_pRebuild ) {
        ErrorTrace( 0, "Create rebuild object failed" );
        NntpLogEventEx( NNTP_REBUILD_FAILED,
                        0,
                        NULL,
                        GetLastError(),
                        QueryInstanceId() ) ;

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    TraceFunctLeave();
    return TRUE;
}

VOID
NNTP_SERVER_INSTANCE::Rebuild()
/*++
Routine description:

    Main driving routine to do per virtual server rebuild

Arguments:

    None.

Return value:

    None.
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::Rebuild" );
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    //
    // Step 1. Create the rebuild object
    //
    if ( !CreateRebuildObject() ) {

        ErrorTrace( 0, "Creating rebuild objects failed %d", GetLastError() );
        m_BootOptions->ReportPrint( "Creating rebuild object failed - error %d\n",
                                    GetLastError() );
        goto Exit;
    }

    _ASSERT( m_pRebuild );

    //
    // Step 2. Preparation for starting the server
    //
    if ( !m_pRebuild->PrepareToStartServer() ) {

        SetRebuildLastError( GetLastError() );
        ErrorTrace( 0, "Prepare building a tree failed %d", GetLastError() );
        m_BootOptions->ReportPrint( "Prepare building tree failed - error %d\n",
                                    GetLastError() );
        goto Exit;
    }

    //
    // I give it 10% progress on this
    //
    SetRebuildProgress( 10 );

    //
    // Step 3. Start the server
    //
    // We want to start the server at this point and let drivers' initialization
    // and decorate newstree take care of building a news tree.  The driver
    // should read property on INntpServer to see if the server is in rebuild
    // mode.  If the server is not in rebuild mode, he should go as usual,
    // otherwise, he should take special care.
    //
    if ( !m_pRebuild->StartServer() ) {

        SetRebuildLastError( GetLastError() );
        ErrorTrace( 0, "Start the server failed %d", GetLastError() );
        m_BootOptions->ReportPrint( "Start the server during rebuild failed - error %d\n",
                                    GetLastError() );
        goto Exit;
    }

    //
    // Delete all the special files ( in slave groups )
    //
    m_pRebuild->DeleteSpecialFiles();

    //
    // I give it 40% progress on this
    //
    SetRebuildProgress( 50 );

    //
    // Step 4. Build the group objects ( and hash tables for clean rebuild case )
    //
    if ( !m_pRebuild->RebuildGroupObjects() ) {

        SetRebuildLastError( GetLastError() );
        ErrorTrace( 0, "Rebuild group objects failed %d", GetLastError() );
        NntpLogEventEx( NNTP_REBUILD_FAILED,
                        0,
                        NULL,
                        GetLastError(),
                        QueryInstanceId() ) ;

        m_BootOptions->ReportPrint( "Rebuild group objects failed - error %d\n",
                                    GetLastError() );
        m_pRebuild->StopServer();
        goto Exit;
    }

    //
    // I give it another 45% progress on this
    //
    SetRebuildProgress( 95 );

    //
    // Step 5. Turn on posting
    //
	_ASSERT( QueryServerState() == MD_SERVER_STATE_STARTED );
	if( mb.Open( QueryMDPath(), METADATA_PERMISSION_WRITE ) ) {
    	SetPostingModes( mb, TRUE, TRUE, TRUE );
    	mb.Close();
   	}

   	//
   	// I confirm that it's completed
   	//
   	SetRebuildProgress( 100 );

Exit:
    //
    // Step 6. Rebuild completed, destroy rebulid object
    //
    if ( m_pRebuild ) {
        XDELETE m_pRebuild;
        m_pRebuild = NULL;
    }

   	//
   	// Step 7. Clean up rebuild option
   	//
   	EnterCriticalSection( &m_critRebuildRpc ) ;

	// NOTE: this is created on a rebuild RPC !
	if( m_BootOptions ) {
		if( INVALID_HANDLE_VALUE != m_BootOptions->m_hOutputFile ) {
			_VERIFY( CloseHandle( m_BootOptions->m_hOutputFile ) );
		}
		XDELETE m_BootOptions;
		m_BootOptions = NULL;
	}

	LeaveCriticalSection( &m_critRebuildRpc ) ;
}

BOOL
NNTP_SERVER_INSTANCE::ServerDataConsistent()
/*++
Routine description:

    Check consistency of server data: newstree against xover table

Arguments:

    None.

Return value:

    TRUE if server data are in consistent, FALSE otherwise
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::ServerDataConsistent" );

    //
    // Enumerate the newstree
    //
    CNewsTree *pTree = GetTree();
    if ( NULL == pTree || pTree->IsStopping() ) {
        ErrorTrace( 0, "Tree is null or beging shutdown" );
        return FALSE;
    }

    CGroupIterator *pIterator = pTree->GetIterator( mszStarNullNull, TRUE );
    if ( NULL == pIterator ) {
        ErrorTrace( 0, "Get newstree iterator failed %d", GetLastError());
        return FALSE;
    }

    while( !pTree->IsStopping() && !pIterator->IsEnd() ) {

        CGRPPTR pGroup = pIterator->Current();
        _ASSERT( pGroup );

#if 0
        DWORD   dwLowWatermark = pGroup->GetLowWatermark();
        DWORD   dwHighWatermark = pGroup->GetHighWatermark();
        DWORD   dwMessageCount = pGroup->GetMessageCount();

        //
        // Check against itself
        //
        if (    dwMessageCount == 0 && dwHighWatermark != dwLowWatermark - 1 ||
                dwMessageCount > 0 && dwHighWatermark - dwLowWatermark < dwMessageCount - 1 ) {
            XDELETE pIterator;
            return FALSE;
        }

        //
        // Check against hash table
        //
	    for (   DWORD i = dwLowWatermark; i <= dwHighWatermark;
			    i += (  dwHighWatermark - dwLowWatermark == 0 ? 1:
					    dwHighWatermark - dwLowWatermark ) ) {
            DWORD groupidPrimary, artidPrimary;
	        GROUP_ENTRY rgCrossposts[MAX_NNTPHASH_CROSSPOSTS];
	        BYTE rgcStoreCrossposts[MAX_NNTPHASH_CROSSPOSTS];
	        DWORD cGrouplistSize = sizeof(GROUP_ENTRY) * MAX_NNTPHASH_CROSSPOSTS;
	        DWORD cGroups;

            GROUPID groupidSecondary = pGroup->GetGroupId();
            ARTICLEID artidSecondary = i;
	        if (!XoverTable()->GetArticleXPosts(groupidSecondary,
			        					artidSecondary,
					        			FALSE,
							        	rgCrossposts,
								        cGrouplistSize,
								        cGroups,
								        rgcStoreCrossposts)) {
			    ErrorTrace( 0, "Article (%d/%d ) not found in xover table",
			                groupidSecondary, artidSecondary );
			    XDELETE pIterator;
			    return FALSE;
			}

			//
			// Primary article id must be between primary group's high/low watermark
			//
			CGRPPTR pPrimaryGroup = pTree->GetGroup( rgCrossposts[0].GroupId );
			if ( !pPrimaryGroup ) {
			    ErrorTrace( 0, "Primary group %d doesn't exist in tree", rgCrossposts[0].GroupId );
			    XDELETE pIterator;
			    return FALSE;
			}

            if ( rgCrossposts[0].ArticleId < pPrimaryGroup->GetLowWatermark() ||
                 rgCrossposts[0].ArticleId > pPrimaryGroup->GetHighWatermark() ) {
                ErrorTrace( 0, "Article id %d of group %d is outside watermarks",
                            rgCrossposts[0].ArticleId, rgCrossposts[0].GroupId );
                XDELETE pIterator;
                return FALSE;
            }
        }
#endif

        if ( !pGroup->WatermarkConsistent() ) {
            ErrorTrace( 0, "Group watermark inconsistent" );
            XDELETE pIterator;
            return FALSE;
        }

        //
        // OK, this group has passed, lets get to the next group
        //
        pIterator->Next();
    }

    //
    // If we have successfully come here, the server data is in good shape
    //
    XDELETE pIterator;
    TraceFunctLeave();
    return TRUE;
}

DWORD
NNTP_SERVER_INSTANCE::GetVRootWin32Error(   LPWSTR  wszVRootPath,
                                            PDWORD  pdwWin32Error )
/*++
Routine description:

    Get vroot connection status from vrtable, this is just a wrapper
    to relay the work to the vroot table

Arguments:

    LPWSTR wszVRootPath - The vroot path to look up for
    PDWORD pdwWin32Error - To return the win32 connection error code

Return value:

    NOERROR if succeeded, WIN32 error code otherwise
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::GetVRootWin32Error" );
    _ASSERT( wszVRootPath );
    _ASSERT( pdwWin32Error );

    DWORD dw = m_pVRootTable->GetVRootWin32Error(   wszVRootPath,
                                                    pdwWin32Error );

    TraceFunctLeave();
    return dw;
}

#if 0
NET_API_STATUS
NET_API_FUNCTION
NntprAddDropNewsgroup(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    IN LPCSTR szNewsgroup
    )
{
	return NERR_Success;
}

NET_API_STATUS
NET_API_FUNCTION
NntprRemoveDropNewsgroup(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    IN LPCSTR szNewsgroup
    )
{
	return NERR_Success;
}
#endif

NET_API_STATUS
NET_API_FUNCTION
NntprCancelMessageID(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    IN LPCSTR pszMessageID
    )
{
    ACQUIRE_SERVICE_LOCK_SHARED();

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	DWORD err = NERR_Success;
	if (!pInstance->CancelMessage(pszMessageID)) {
		err = GetLastError();
		_ASSERT(err != NERR_Success);
	}

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

	return err;
}

CInFeed *NNTP_SERVER_INSTANCE::NewClientFeed() {
	if (m_OurNntpRole == RoleSlave) {
		return new CSlaveFromClientFeed();
	} else {
		return new CFromClientFeed();
	}
}

INewsTree *NNTP_SERVER_INSTANCE::GetINewsTree() {
	return m_pTree->GetINewsTree();
}

//
// this function performs service level server events registration
//
HRESULT RegisterSEOService() {
	HRESULT hr;
	CComBSTR bstrNNTPOnPostCatID = (LPCOLESTR) CStringGUID(CATID_NNTP_ON_POST);
	CComBSTR bstrNNTPOnPostFinalCatID = (LPCOLESTR) CStringGUID(CATID_NNTP_ON_POST_FINAL);

	//
	// see if we've done the service level registration by getting the list
	// of source types and seeing if the NNTP source type is registered
	//
	CComPtr<IEventManager> pEventManager;
	hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL,
					 	  IID_IEventManager, (LPVOID *) &pEventManager);
	if (hr != S_OK) return hr;
	CComPtr<IEventSourceTypes> pSourceTypes;
	hr = pEventManager->get_SourceTypes(&pSourceTypes);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSourceType> pSourceType;
	CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(NNTP_SOURCE_TYPE_GUID);
	hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
	if (FAILED(hr)) return hr;
	// if this failed then we need to register the source type and event
	// component categories
	if (hr == S_FALSE) {
		// register the component categories
		CComPtr<IEventComCat> pComCat;
		hr = CoCreateInstance(CLSID_CEventComCat, NULL, CLSCTX_ALL,
						 	  IID_IEventComCat, (LPVOID *) &pComCat);
		if (hr != S_OK) return hr;
		CComBSTR bstrNNTPOnPostCATID = (LPCOLESTR) CStringGUID(CATID_NNTP_ON_POST);
		CComBSTR bstrOnPost = "NNTP OnPost";
		hr = pComCat->RegisterCategory(bstrNNTPOnPostCATID, bstrOnPost, 0);
		if (FAILED(hr)) return hr;
		CComBSTR bstrNNTPOnPostFinalCATID = (LPCOLESTR) CStringGUID(CATID_NNTP_ON_POST_FINAL);
		CComBSTR bstrOnPostFinal = "NNTP OnPostFinal";
		hr = pComCat->RegisterCategory(bstrNNTPOnPostFinalCATID, bstrOnPostFinal, 0);
		if (FAILED(hr)) return hr;

		// register the source type
		hr = pSourceTypes->Add(bstrSourceTypeGUID, &pSourceType);
		if (FAILED(hr)) return hr;
		_ASSERT(hr == S_OK);
		CComBSTR bstrSourceTypeDisplayName = "NNTP Server";
		hr = pSourceType->put_DisplayName(bstrSourceTypeDisplayName);
		if (FAILED(hr)) return hr;
		hr = pSourceType->Save();
		if (FAILED(hr)) return hr;

		// add the event types to the source type
		CComPtr<IEventTypes> pEventTypes;
		hr = pSourceType->get_EventTypes(&pEventTypes);
		if (FAILED(hr)) return hr;
		hr = pEventTypes->Add(bstrNNTPOnPostCatID);
		if (FAILED(hr)) return hr;
		_ASSERT(hr == S_OK);
		hr = pEventTypes->Add(bstrNNTPOnPostFinalCatID);
		if (FAILED(hr)) return hr;
		_ASSERT(hr == S_OK);
	}

	return S_OK;
}

//
// this function performs instance level server events registration
//
HRESULT RegisterSEOInstance(DWORD dwInstanceID, char *szDropDirectory) {
	HRESULT hr;
	CComBSTR bstrNNTPOnPostFinalCatID = (LPCOLESTR) CStringGUID(CATID_NNTP_ON_POST_FINAL);

	//
	// find the NNTP source type in the event manager
	//
	CComPtr<IEventManager> pEventManager;
	hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL,
					 	  IID_IEventManager, (LPVOID *) &pEventManager);
	if (hr != S_OK) return hr;
	CComPtr<IEventSourceTypes> pSourceTypes;
	hr = pEventManager->get_SourceTypes(&pSourceTypes);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSourceType> pSourceType;
	CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(NNTP_SOURCE_TYPE_GUID);
	hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
	_ASSERT(hr != S_OK || pSourceType != NULL);
	if (hr != S_OK) return hr;

	//
	// generate a GUID for this source, which is based on GUID_NNTPSVC
	// mangled by the instance ID
	//
	CComPtr<IEventUtil> pEventUtil;
	hr = CoCreateInstance(CLSID_CEventUtil, NULL, CLSCTX_ALL,
					 	  IID_IEventUtil, (LPVOID *) &pEventUtil);
	if (hr != S_OK) return hr;
	CComBSTR bstrNNTPSvcGUID = (LPCOLESTR) CStringGUID(GUID_NNTPSVC);
	CComBSTR bstrSourceGUID;
	hr = pEventUtil->GetIndexedGUID(bstrNNTPSvcGUID, dwInstanceID, &bstrSourceGUID);
	if (FAILED(hr)) return hr;

	//
	// see if this source is registered with the list of sources for the
	// NNTP source type
	//
	CComPtr<IEventSources> pEventSources;
	hr = pSourceType->get_Sources(&pEventSources);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSource> pEventSource;
	hr = pEventSources->Item(&CComVariant(bstrSourceGUID), &pEventSource);
	if (FAILED(hr)) return hr;
	//
	// if the source guid doesn't exist then we need to register a new
	// source for the NNTP source type and add directory drop as a binding
	//
	if (hr == S_FALSE) {
		// register the NNTPSvc source
		hr = pEventSources->Add(bstrSourceGUID, &pEventSource);
		if (FAILED(hr)) return hr;
		char szSourceDisplayName[50];
		_snprintf(szSourceDisplayName, 50, "nntpsvc %lu", dwInstanceID);
		CComBSTR bstrSourceDisplayName = szSourceDisplayName;
		hr = pEventSource->put_DisplayName(bstrSourceDisplayName);
		if (FAILED(hr)) return hr;

		// create the event database for this source
		CComPtr<IEventDatabaseManager> pDatabaseManager;
		hr = CoCreateInstance(CLSID_CEventMetabaseDatabaseManager, NULL, CLSCTX_ALL,
						 	  IID_IEventDatabaseManager, (LPVOID *) &pDatabaseManager);
		if (hr != S_OK) return hr;
		CComBSTR bstrEventPath;
		CComBSTR bstrService = "nntpsvc";
		hr = pDatabaseManager->MakeVServerPath(bstrService, dwInstanceID, &bstrEventPath);
		if (FAILED(hr)) return hr;
		CComPtr<IUnknown> pDatabaseMoniker;
		hr = pDatabaseManager->CreateDatabase(bstrEventPath, &pDatabaseMoniker);
		if (FAILED(hr)) return hr;
		hr = pEventSource->put_BindingManagerMoniker(pDatabaseMoniker);
		if (FAILED(hr)) return hr;

		// save everything we've done so far
		hr = pEventSource->Save();
		if (FAILED(hr)) return hr;
		hr = pSourceType->Save();
		if (FAILED(hr)) return hr;

		// add a new binding for Directory Drop with an empty newsgroup
		// list rule
		CComPtr<IEventBindingManager> pBindingManager;
		hr = pEventSource->GetBindingManager(&pBindingManager);
		if (FAILED(hr)) return hr;
		CComPtr<IEventBindings> pEventBindings;
		hr = pBindingManager->get_Bindings(bstrNNTPOnPostFinalCatID, &pEventBindings);
		if (FAILED(hr)) return hr;
		CComPtr<IEventBinding> pEventBinding;
		hr = pEventBindings->Add(L"", &pEventBinding);
		if (FAILED(hr)) return hr;
		CComBSTR bstrBindingDisplayName = "Directory Drop";
		hr = pEventBinding->put_DisplayName(bstrBindingDisplayName);
		if (FAILED(hr)) return hr;
		CComBSTR bstrSinkClass = "NNTP.DirectoryDrop";
		hr = pEventBinding->put_SinkClass(bstrSinkClass);
		if (FAILED(hr)) return hr;
		CComPtr<IEventPropertyBag> pSourceProperties;
		hr = pEventBinding->get_SourceProperties(&pSourceProperties);
		if (FAILED(hr)) return hr;
		CComBSTR bstrPropName;
		CComBSTR bstrPropValue;
		bstrPropName = "NewsgroupList";
		bstrPropValue = "";
		hr = pSourceProperties->Add(bstrPropName, &CComVariant(bstrPropValue));
		if (FAILED(hr)) return hr;
		CComPtr<IEventPropertyBag> pSinkProperties;
		hr = pEventBinding->get_SinkProperties(&pSinkProperties);
		if (FAILED(hr)) return hr;
		bstrPropName = "Drop Directory";
		bstrPropValue = szDropDirectory;
		hr = pSinkProperties->Add(bstrPropName, &CComVariant(bstrPropValue));
		if (FAILED(hr)) return hr;
		hr = pEventBinding->Save();
		if (FAILED(hr)) return hr;
	}

	return S_OK;
}

//
// this function performs instance level unregistration
//
HRESULT UnregisterSEOInstance(DWORD dwInstanceID) {
	HRESULT hr;

	//
	// find the NNTP source type in the event manager
	//
	CComPtr<IEventManager> pEventManager;
	hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL,
					 	  IID_IEventManager, (LPVOID *) &pEventManager);
	if (hr != S_OK) return hr;
	CComPtr<IEventSourceTypes> pSourceTypes;
	hr = pEventManager->get_SourceTypes(&pSourceTypes);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSourceType> pSourceType;
	CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(NNTP_SOURCE_TYPE_GUID);
	hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
	_ASSERT(hr != S_OK || pSourceType != NULL);
	if (hr != S_OK) return hr;

	//
	// generate a GUID for this source, which is based on GUID_NNTPSVC
	// mangled by the instance ID
	//
	CComPtr<IEventUtil> pEventUtil;
	hr = CoCreateInstance(CLSID_CEventUtil, NULL, CLSCTX_ALL,
					 	  IID_IEventUtil, (LPVOID *) &pEventUtil);
	if (hr != S_OK) return hr;
	CComBSTR bstrNNTPSvcGUID = (LPCOLESTR) CStringGUID(GUID_NNTPSVC);
	CComBSTR bstrSourceGUID;
	hr = pEventUtil->GetIndexedGUID(bstrNNTPSvcGUID, dwInstanceID, &bstrSourceGUID);
	if (FAILED(hr)) return hr;

	//
	// remove this source from the list of registered sources
	//
	CComPtr<IEventSources> pEventSources;
	hr = pSourceType->get_Sources(&pEventSources);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSource> pEventSource;
	hr = pEventSources->Remove(&CComVariant(bstrSourceGUID));
	if (FAILED(hr)) return hr;

	return S_OK;
}

HRESULT UnregisterOrphanedSources(void) {
	HRESULT hr;

	//
	// find the NNTP source type in the event manager
	//
	CComPtr<IEventManager> pEventManager;
	hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL,
					 	  IID_IEventManager, (LPVOID *) &pEventManager);
	if (hr != S_OK) return hr;
	CComPtr<IEventSourceTypes> pSourceTypes;
	hr = pEventManager->get_SourceTypes(&pSourceTypes);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSourceType> pSourceType;
	CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(NNTP_SOURCE_TYPE_GUID);
	hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
	_ASSERT(hr != S_OK || pSourceType != NULL);
	if (hr != S_OK) return hr;

	//
	// get the list of sources registered for this source type
	//
	CComPtr<IEventSources> pSources;
	hr = pSourceType->get_Sources(&pSources);
	if (FAILED(hr)) return hr;
	CComPtr<IEnumVARIANT> pSourceEnum;
	hr = pSources->get__NewEnum((IUnknown **) &pSourceEnum);
	if (FAILED(hr)) return hr;

	do {
		VARIANT varSource;

		hr = pSourceEnum->Next(1, &varSource, NULL);
		if (FAILED(hr)) return hr;
		if (hr == S_OK) {
			if (varSource.vt == VT_DISPATCH) {
				CComPtr<IEventSource> pSource;

				// QI for the IEventSource interface
				hr = varSource.punkVal->QueryInterface(IID_IEventSource,
													 (void **) &pSource);
				if (FAILED(hr)) return hr;
				varSource.punkVal->Release();

				// get the binding manager
				CComBSTR bstrSourceID;
				hr = pSource->get_ID(&bstrSourceID);
				if (FAILED(hr)) return hr;

				// get the index from the SourceID
				CStringGUID guidIndex(bstrSourceID);
				DWORD iInstance;
				if (guidIndex.GetIndex(GUID_NNTPSVC, &iInstance)) {
					// see if this instance exists
    				MB mb((IMDCOM*)g_pInetSvc->QueryMDObject());
					char szMBPath[50];

					_snprintf(szMBPath, 50, "LM/nntpsvc/%lu", iInstance);
					if (mb.Open(szMBPath)) {
						// it exists, so just close the mb and keep going
						mb.Close();
					} else {
						// the instance is gone, clean up this source in
						// the metabase
						hr = pSources->Remove(&CComVariant(bstrSourceID));
						_ASSERT(SUCCEEDED(hr));
					}
				}

				pSource.Release();
			} else {
				_ASSERT(FALSE);
			}
		}
	} while (hr == S_OK);

	return S_OK;
}

//
// This function handles picking up files from the pickup directory.
//
// parameters:
// 		pvInstance [in] - a void pointer to the current instance
//		pwszFilename [in] - the filename that was detected in the pickup dir
// returns:
//		TRUE - the file was handled.  if TRUE is returned than directory
//				notification won't put this file on the retryq.
//		FALSE - the file was not handled.  this causes the file to be put
//				onto the retry q.  PickupFile will be called with this file
//				again.
// notes:
//  	pInstance->IncrementPickupCount() and DecrementPickupCount() should
//		be used to keep track of the number of threads which are currently
//		in this method.  the instance won't shutdown until there are no
// 		threads in this method.
//
BOOL NNTP_SERVER_INSTANCE::PickupFile(PVOID pvInstance, WCHAR *pwszFilename) {
	DWORD dwFileSizeHigh = 0;
    ULARGE_INTEGER liStart;
    ULARGE_INTEGER liNow;
    FILETIME now;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::PickupFile");

	//
	// Since this is a Sync event, we'll increase the number of runnable
	// threads in the Atq pool.
	//
	AtqSetInfo(AtqIncMaxPoolThreads, NULL);

	//
	// Now see if there is at least one Atq thread available to handle
	// any completions from the store
	//

	if (AtqGetInfo(AtqAvailableThreads) < 1) {
		AtqSetInfo(AtqDecMaxPoolThreads, NULL);
		TraceFunctLeave();
	    return FALSE;
	}


    GetSystemTimeAsFileTime(&now);
    LI_FROM_FILETIME(&liStart, &now);

	NNTP_SERVER_INSTANCE *pInstance = (NNTP_SERVER_INSTANCE *) pvInstance;

	pInstance->IncrementPickupCount();

	//
	// Check to see if the instance is good !
	//
	if( !CheckIISInstance( pInstance ) ) {
		ErrorTrace(0,"Instance %d not runnable", pInstance->QueryInstanceId() );
		pInstance->DecrementPickupCount();
		AtqSetInfo(AtqDecMaxPoolThreads, NULL);
		TraceFunctLeave();
		// we return TRUE so that this item isn't put back onto the retry q
		return TRUE;
	}

	//
	// open the file
	//
	HANDLE hFile = CreateFileW(pwszFilename, GENERIC_READ | GENERIC_WRITE,
							   0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		if (GetLastError() == ERROR_FILE_NOT_FOUND) {
			ErrorTrace(0, "%S reported in pickup dir, but doesn't exist",
				pwszFilename);
			pInstance->DecrementPickupCount();
		    AtqSetInfo(AtqDecMaxPoolThreads, NULL);
			TraceFunctLeave();
			return TRUE;
		} else {
			ErrorTrace(0, "%S reported in pickup dir, can't open, retry later",
				pwszFilename);
			pInstance->DecrementPickupCount();
		    AtqSetInfo(AtqDecMaxPoolThreads, NULL);
			TraceFunctLeave();
			return FALSE;
		}
	}

	//
	// handle 0 length files - zap 'em !
	//

	if( !GetFileSize( hFile, &dwFileSizeHigh ) && !dwFileSizeHigh ) {
		ErrorTrace(0,"%S is zero length - deleting", pwszFilename);
		_VERIFY( CloseHandle( hFile ) );
		DeleteFileW( pwszFilename );
		pInstance->DecrementPickupCount();
		AtqSetInfo(AtqDecMaxPoolThreads, NULL);
		TraceFunctLeave();
		return TRUE;
	}

	//
	// post this file
	//
	CInFeed *pFeed;

	pFeed = pInstance->NewClientFeed();
	if (pFeed == NULL) {
		ErrorTrace(0, "couldn't allocate CFromClientFeed to handle %S",
			pwszFilename);
    	_VERIFY(CloseHandle(hFile));
		pInstance->DecrementPickupCount();
		AtqSetInfo(AtqDecMaxPoolThreads, NULL);
		TraceFunctLeave();
		return FALSE;
	}
	BOOL fSuccess;
	DWORD dwSecondary;
	CNntpReturn nr;
	fSuccess = pFeed->fInit(pInstance->m_pFeedblockDirPickupPostings,
				 			pInstance->m_PeerTempDirectory,
				 			0,
				 			0,
				 			0,
				 			FALSE,
				 			TRUE,
				 			pInstance->m_pFeedblockDirPickupPostings->FeedId);

	if (fSuccess) {
		fSuccess = pFeed->PostPickup(pInstance->GetInstanceWrapper(),
									 NULL,
									 NULL,
									 TRUE,
									 hFile,
									 dwSecondary,
									 nr);
	}

	delete pFeed;
	_VERIFY(CloseHandle(hFile));

	WCHAR *pwszDestDirectory = pInstance->QueryFailedPickupDirectory();

	// check the status and act appropriately
	if (fSuccess || pwszDestDirectory[0] == (WCHAR) 0) {
		// the post was successful, delete the file
		if (!DeleteFileW(pwszFilename)) {
			ErrorTrace(0, "DeleteFileW(%S) failed with %lu",
				pwszFilename, GetLastError());
//			_ASSERT(FALSE);
		}
	} else {
		// the post failed, move the file to a badarticles directory
		WCHAR wszDest[MAX_PATH + 1];
		WCHAR *pwszBasename = pwszFilename + lstrlenW(pwszFilename);
		while (pwszBasename[-1] != L'\\' && pwszBasename > pwszFilename)
			*pwszBasename--;
		lstrcpyW(wszDest, pwszDestDirectory);
		lstrcatW(wszDest, pwszBasename);

		if (!MoveFileExW(pwszFilename, wszDest, MOVEFILE_COPY_ALLOWED)) {
			ErrorTrace(0, "MoveFileW(%S, %S) failed with %lu",
				pwszFilename, wszDest, GetLastError());

			// if this failed then we need to make a unique name to copy
			// to
			UINT cDest = GetTempFileNameW(pwszDestDirectory, L"nws", 0,
				wszDest);

			// this can fail if the bad articles directory has all temp file
			// names used or if the directory doesn't exist
			if (cDest == 0) {
				ErrorTrace(0, "GetTempFileNameW failed with %lu", GetLastError());
				if (!DeleteFileW(pwszFilename)) {
					ErrorTrace(0, "DeleteFileW(%S) failed with %lu",
						pwszFilename, GetLastError());
					_ASSERT(FALSE);
				}
			} else {
				// GetTempFileName creates a 0 byte file with the name wszDest,
				// so we need to allow copying over that
				if (!MoveFileExW(pwszFilename, wszDest, MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING)) {
					// this should never happen.  just in case it does we just
					// delete the file
					ErrorTrace(0, "MoveFile(%S, %S) failed with %lu",
						pwszFilename, wszDest, GetLastError());
					if (!DeleteFileW(pwszFilename)) {
						ErrorTrace(0, "DeleteFileW(%S) failed with %lu",
							pwszFilename, GetLastError());
//						_ASSERT(FALSE);
					}
				}
			}
		}
	}

#ifdef BUGBUG
	//
	// we log an event if they have event logging turned on for the Post
	// command and if this is an error or if they have erroronly logging
	// turned off
	//
	if (pInstance->GetCommandLogMask() & ePost &&
		((!(pInstance->GetCommandLogMask() & eErrorsOnly)) ||
		 (NNTPRET_IS_ERROR(nr.m_nrc))))
	{
		//
		// make a transaction log event
		//
	    INETLOG_INFORMATION request;			// log information
		char szFilename[MAX_PATH];				// the filename in ascii
		if (!WideCharToMultiByte(CP_ACP, 0, pwszFilename, -1, szFilename, MAX_PATH, NULL, NULL)) szFilename[0] = 0;

		// build the request structure
		ZeroMemory( &request, sizeof(request));
		request.pszClientUserName = "<pickup>";
	    // How long were we processing this?
	    GetSystemTimeAsFileTime( &now );
	    LI_FROM_FILETIME( &liNow, &now );
	    liNow.QuadPart -= liStart.QuadPart;
	    liNow.QuadPart /= (ULONGLONG)( 10 * 1000 );
	    request.msTimeForProcessing = liNow.LowPart;
		request.dwWin32Status = dwSecondary;
		request.dwProtocolStatus = nr.m_nrc;
		request.pszOperation = "post";
		request.cbOperation  = 4;
		if (*szMessageID != 0) {
			request.pszTarget = szGroups;
			request.cbTarget = lstrlen(szGroups);
		}
		if (*szGroups != 0) {
			request.pszParameters = szMessageID;
		}

		// log the event
	    if (pInstance->m_Logging.LogInformation(&request) != NO_ERROR) {
	        ErrorTrace(0,"Error %d Logging information!", GetLastError());
	    }
	}
#endif

	pInstance->DecrementPickupCount();
	AtqSetInfo(AtqDecMaxPoolThreads, NULL);
	TraceFunctLeave();
	return TRUE;
}

#include "seo_i.c"
#include "mailmsg_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\nntpinst.inl ===
#if 0
inline
BOOL NNTP_IIS_SERVICE::AcquireEnumLock()
{
	InterlockedIncrement( &m_lEnumLock );
	if( QueryServiceState() == SERVICE_STOP_PENDING ) {
		InterlockedDecrement( &m_lEnumLock );
		return FALSE ;
	}

	return TRUE ;
}

inline 
VOID NNTP_IIS_SERVICE::ReleaseEnumLock()
{
	InterlockedDecrement( &m_lEnumLock );
}

inline
BOOL NNTP_IIS_SERVICE::AcquireEnumLockExclusive()
{
	if( InterlockedIncrement( &m_lEnumLock ) == 0 ) {
		return TRUE ;
	}

	InterlockedDecrement( &m_lEnumLock );
	return FALSE ;
}

inline 
VOID NNTP_IIS_SERVICE::ReleaseEnumLockExclusive()
{
	InterlockedDecrement( &m_lEnumLock );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\outfeed.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    outfeed.h

Abstract:

    This module contains class declarations/definitions for

		COutFeed

    **** Overview ****

	A COutFeed object accepts articles to be pushed to a peer, master,
	or slave.


Author:

    Carl Kadie (CarlK)     23-Jan-1995

Revision History:

!!! Pull "ToClient.h" to here because all outfeeds use the same client
--*/


#ifndef	_OUTFEED_H_
#define	_OUTFEED_H_

#include	"infeed.h"

//
//
//
// COutFeed - pure virtual base class for processing outgoing articles.
//			article.
//

class	COutFeed:	public CFeed 	{
private : 

	//
	//	The Queue which tracks all of the GROUPID/ARTICLEID's of the
	//	outbound articles !!
	//
	class	CFeedQ*			m_pFeedQueue ;

	//
	// No construction without a FeedQ provided !!
	//
	COutFeed(void) {};	


protected : 

	//
	//	String which is prepended to basic check commands !
	//
	static	char	szCheck[] ;

	//
	//
	//
	static	char	szTakethis[] ;

	//
	// Constructor is protected - you can only have derived types !
	//
	COutFeed(	
			class	CFeedQ*	pFeedQueue, 
			PNNTP_SERVER_INSTANCE pInstance
			) 	: m_pFeedQueue( pFeedQueue ), 
				m_pInstance( pInstance )
				{
	}

	//
	// virtual server instance for this feed
	//
	PNNTP_SERVER_INSTANCE	m_pInstance ;	


//
// Public Members
//

public : 

	//
	// Destructor
	//
	virtual ~COutFeed(void) {};

	BOOL	fInit(	
			PVOID	feedCompletionContext ) ;
			

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"Outbound" ;
				}

	//
	//	Add an article to the queue of outbound messages 
	//
	inline	BOOL	
	Append(	GROUPID	groupid,	
			ARTICLEID	articleid 
			) ;

	//
	//	Get an article from the queue of outbound messages 
	//
	inline	BOOL	
	Remove(	GROUPID&	groupid,	
			ARTICLEID&	articleid 
			) ;		
	
	//
	//	Build the command string we will send to the remote site !
	//
	virtual	int		
	FormatCommand(	
			BYTE*	lpb,	
			DWORD	cb,	
			DWORD&	ibStart,	
			GROUPID	groupid,	
			ARTICLEID	articleid, 
			CTOCLIENTPTR&	pArticle 
			) = 0 ;

	//
	//	Does the remote site want us to retry the posting !
	//
	virtual	BOOL	
	RetryPost(	NRC	nrcCode ) = 0 ;

	//
	//	Does this type of feed support a 'streaming' mode ? 
	//
	virtual	BOOL
	SupportsStreaming() = 0 ;


	//
	//	How many bytes does CheckCommandLength() stick before the 
	//	message-id in a 'check' command ? ? 
	//
	virtual	DWORD	
	CheckCommandLength() ;

	//
	//	Puts a check command in the buffer - if the call 
	//	fails because there is not enough room then return
	//	value is 0 and GetLastError() == ERROR_INSUFFICIENT_BUFFER
	//
	virtual	DWORD
	FormatCheckCommand(	
			BYTE*		lpb, 
			DWORD		cb, 
			GROUPID		groupid, 
			ARTICLEID	articleid	
			) ;

	//
	//	Puts a 'takethis' command into the buffer - if the call
	//	fails because there is not enough room return value is 0 
	//	and GetLastError() == ERROR_INSUFFICIENT_BUFFER
	//	If it fails because the article no longer exists GetLastError() == ERROR_FILE_NOT_FOUND
	//
	virtual	DWORD
	FormatTakethisCommand(
			BYTE*		lpb, 
			DWORD		cb, 
			GROUPID		groupid, 
			ARTICLEID	articleid, 
			CTOCLIENTPTR&	pArticle
			) ;

	virtual void IncrementFeedCounter(DWORD nrc) {
		::IncrementFeedCounter((struct _FEED_BLOCK *) m_feedCompletionContext, nrc);
	}
};

class	COutToMasterFeed :	public	COutFeed	{
public : 

	COutToMasterFeed(	class	CFeedQ*	pFeedQueue, 
						PNNTP_SERVER_INSTANCE pInstance)
		: COutFeed( pFeedQueue, pInstance) {}

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"Out To Master" ;
				}


	//
	//	Build the command string we will send to the remote site !
	//
	int		
	FormatCommand(	
			BYTE*	lpb,	
			DWORD	cb,	
			DWORD&	ibStart,	
			GROUPID	groupid,	
			ARTICLEID	articleid, 
			CTOCLIENTPTR& pArticle 
			) ;

	BOOL	
	RetryPost(	
			NRC	nrcCode 
			) ;

	//
	//	Does this feed type support a mode-streaming version? (No)
	//
	BOOL
	SupportsStreaming() ;

	//
	//	Puts a check command in the buffer - if the call 
	//	fails because there is not enough room then return
	//	value is 0 and GetLastError() == ERROR_INSUFFICIENT_BUFFER
	//
	DWORD
	FormatCheckCommand(	
			BYTE*		lpb, 
			DWORD		cb, 
			GROUPID		groupid, 
			ARTICLEID	articleid	
			) ;
	//
	//	Puts a 'takethis' command into the buffer - if the call
	//	fails because there is not enough room return value is 0 
	//	and GetLastError() == ERROR_INSUFFICIENT_BUFFER
	//	If it fails because the article no longer exists GetLastError() == ERROR_FILE_NOT_FOUND
	//
	DWORD
	FormatTakethisCommand(
			BYTE*		lpb, 
			DWORD		cb, 
			GROUPID		groupid, 
			ARTICLEID	articleid, 
			CTOCLIENTPTR&	pArticle
			) ;
} ;


class	COutToSlaveFeed :	public	COutFeed	{
public : 

	COutToSlaveFeed(	class	CFeedQ*	pFeedQueue, PNNTP_SERVER_INSTANCE pInstance) 
		: COutFeed( pFeedQueue, pInstance) {}
	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"Out To Slave" ;
				}

	//
	//	Build the command string we will send to the remote site !
	//
	int		
	FormatCommand(	
			BYTE*	lpb,	
			DWORD	cb,	
			DWORD&	ibStart,	
			GROUPID	groupid,	
			ARTICLEID	articleid, 
			CTOCLIENTPTR& pArticle 
			) ;

	BOOL	
	RetryPost(	
			NRC	nrcCode 
			) ;

	//
	//	Does this feed type support a mode-streaming version? (No)
	//
	BOOL
	SupportsStreaming() ;


} ;

class	COutToPeerFeed :	public	COutFeed	{
public : 

	COutToPeerFeed(	class	CFeedQ*	pFeedQueue, PNNTP_SERVER_INSTANCE pInstance) 
		: COutFeed( pFeedQueue, pInstance ) {}

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"Out To Peer" ;
				}

	//
	//	Build the command string we will send to the remote site !
	//
	int		
	FormatCommand(	
			BYTE*	lpb,	
			DWORD	cb,	
			DWORD&	ibStart,	
			GROUPID	groupid,	
			ARTICLEID	articleid, 
			CTOCLIENTPTR& pArticle 
			) ;

	BOOL	
	RetryPost(	
			NRC	nrcCode 
			) ;

	//
	//	Does this feed type support a mode-streaming version? (Yes)
	//
	BOOL
	SupportsStreaming() ;

	//
	//	Puts a 'takethis' command into the buffer - if the call
	//	fails because there is not enough room return value is 0 
	//	and GetLastError() == ERROR_INSUFFICIENT_BUFFER
	//	If it fails because the article no longer exists GetLastError() == ERROR_FILE_NOT_FOUND
	//
	DWORD
	FormatTakethisCommand(
			BYTE*		lpb, 
			DWORD		cb, 
			GROUPID		groupid, 
			ARTICLEID	articleid, 
			CTOCLIENTPTR&	pArticle
			) ;

} ;


//
// Other functions
//

BOOL fAddArticleToPushFeeds(
						PNNTP_SERVER_INSTANCE pInstance,
						CNEWSGROUPLIST& newsgroups,
						CArticleRef artrefFirst,
						char * multiszPath,
						CNntpReturn & nntpReturn
						);

BOOL MatchGroupList(
			   char * multiszPatterns,
			   CNEWSGROUPLIST& newsgroups
			   );


inline	BOOL
COutFeed::Append(	GROUPID	groupid,	
					ARTICLEID	articleid ) {

	if( m_pFeedQueue != 0 ) 
		return	m_pFeedQueue->Append( groupid, articleid ) ;
	return	FALSE ;
}

inline	BOOL
COutFeed::Remove(	GROUPID&	groupid,	
					ARTICLEID&	articleid )	{

	if( m_pFeedQueue != 0 ) 
		return	m_pFeedQueue->Remove( groupid, articleid ) ;
	return	FALSE ;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\outfeed.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    outfeed.cpp

Abstract:

    This module contains definition for the COutFeed base class
	and related functions

Author:

    Carl Kadie (CarlK)     23-Jan-1996

Revision History:

--*/

#include	<stdlib.h>
#include "tigris.hxx"

BOOL
IsServerInPath(	LPSTR	lpstrServer,	LPMULTISZ	multiszPath ) {

	LPSTR	lpstrCurrent = multiszPath ;
	while( *lpstrCurrent != '\0' ) {
		if( lstrcmpi( lpstrServer, lpstrCurrent ) == 0 ) {
			return	TRUE ;
		}
		lpstrCurrent += lstrlen( lpstrCurrent ) + 1 ;
	}
	return	FALSE ;
}


BOOL
fAddArticleToPushFeeds(
					   PNNTP_SERVER_INSTANCE pInstance,
					   CNEWSGROUPLIST& newsgroups,
					   CArticleRef artrefFirst,
					   char * multiszPath,
					   CNntpReturn & nntpReturn
    )
{

	NRC	nrc = nrcOK ;

	TraceFunctEnter( "fAddArticleToPushFeeds" ) ;

	StateTrace( DWORD(0), "Matching Article GRP %d ART %d path %s", 
		artrefFirst.m_groupId, artrefFirst.m_articleId,	multiszPath ) ;

	for( PFEED_BLOCK	feedBlock = pInstance->m_pActiveFeeds->StartEnumerate();
			feedBlock != 0; 
			feedBlock = pInstance->m_pActiveFeeds->NextEnumerate( feedBlock ) ) {

		if( feedBlock->pFeedQueue != 0 ) {
			char * multiszPattern = *(feedBlock->Newsgroups);

			if (MatchGroupList(multiszPattern, newsgroups))	 {

				_ASSERT( feedBlock->UucpName != 0 ) ;

				if( FEED_IS_SLAVE(feedBlock->FeedType) || 
					multiszPath == 0 || 
					!MultiSzIntersect( feedBlock->UucpName, multiszPath ) ) {

					StateTrace( DWORD(0), "Attempting to add GRP %d ART %d to feed %s %x", 
						artrefFirst.m_groupId, artrefFirst.m_articleId, 
						feedBlock->KeyName, feedBlock ) ;

					if (!feedBlock->pFeedQueue->Append(artrefFirst.m_groupId, artrefFirst.m_articleId))	{
						nrc = nrcCantAddToQueue ;
						pInstance->m_pActiveFeeds->FinishEnumerate( feedBlock ) ;

						// bug bug ... if an error occurs we should probably remove
						// the feedBlock from the list and continue processing !				
						break ;
					}
				}
			}
		}

    }

    return nntpReturn.fSet( nrc );

}

/*++
	
	MatchGroupList -
		
	True if at least one group matches the pattern

--*/
BOOL
MatchGroupList(
			   char * multiszPatterns,
			   CNEWSGROUPLIST& newsgroups
			   )
{

	TraceFunctEnter( "MatchGroupList" ) ;

		//
		// For each newsgroup ...
		//

		POSITION	pos = newsgroups.GetHeadPosition() ;
		while( pos  )
		{
			CPostGroupPtr *pPostGroupPtr = newsgroups.GetNext(pos);
			CGRPCOREPTR * ppGroup = &(pPostGroupPtr->m_pGroup);

			//
			//  See if this newsgroup matches the pattern
			//

			if (MatchGroup(multiszPatterns, (* ppGroup)->GetName()))	{

				StateTrace( DWORD(0), "Pattern %s matches group %s", multiszPatterns, (*ppGroup)->GetName() ) ;

				return TRUE;
			}

		}

	StateTrace( DWORD(0), "No match for article" ) ;

	return FALSE;
}

BOOL
COutFeed::fInit(	PVOID			feedCompletionContext ) {

	_ASSERT(	ifsUninitialized == m_feedState ) ;
	m_feedState = ifsUninitialized ;
	m_feedCompletionContext = feedCompletionContext ;

	return	TRUE ;
}	

BOOL
COutToSlaveFeed::RetryPost(	NRC	nrcCode ) {

	if( nrcCode != nrcArticleTransferredOK && nrcCode != nrcArticlePostedOK )	{
		if( nrcCode == nrcTransferFailedTryAgain ) {
			return	TRUE ;
		}	else if( nrcCode == nrcTransferFailedGiveUp ) {
			return	FALSE ;
		}	else	{

			//
			//	Some other kind of wierd error occurred - give up !
			//
			return	FALSE ;
		}


	}					

	return	FALSE ;
}

int
COutToSlaveFeed::FormatCommand(	
							BYTE*		lpb,	
							DWORD		cb,	
							DWORD&		ibStart,
							GROUPID		groupid,
							ARTICLEID	articleid,
							CTOCLIENTPTR&	pArticle 
							)	{


	static	char	szXReplic[] = "xreplic " ;
	ibStart = 0 ;

	//
	//	We need to get a hold of the groupid's and articleid's for this article.
	//	We will use the end of the buffer in which we are to generate our string
	//	as scratch space.  We start by assuming that there aren't more than 10 entires
	//	if that fails we will use a larger portion of our buffer as scrach space !
	//


	DWORD			cGroups = 10 ;
	DWORD			cbGroupList = sizeof( GROUP_ENTRY ) * cGroups ;
	DWORD			cbAvailable = cb - cbGroupList ;

	PGROUP_ENTRY	pEntries = (PGROUP_ENTRY)(lpb + cbAvailable) ;
	
	if( !m_pInstance->XoverTable()->GetArticleXPosts(	
										groupid, 
										articleid,
										FALSE,
										pEntries, 
										cbGroupList,
										cGroups ) )		{

		if( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {

			_ASSERT( cbGroupList > 10 * sizeof( GROUP_ENTRY ) ) ;
		
			if( cbGroupList > cb ) {

				return 0 ;
			
			}	else	{

				cbAvailable = cb - cbGroupList ;
				pEntries = (PGROUP_ENTRY)(lpb + cbAvailable) ;

				if( !m_pInstance->XoverTable()->GetArticleXPosts(	
													groupid,	
													articleid,
													FALSE,
													pEntries, 
													cbGroupList,
													cGroups ) )	{
					return	0 ;
				
				}	

			}
		}	else	{

			return	0 ;

		}
	}

	//
	//	If we reach here we are ready to produce the command line !
	//

	if( cbAvailable > sizeof( szXReplic ) )	{

		CopyMemory(	lpb,	szXReplic, sizeof( szXReplic ) - 1 ) ;
		cbAvailable -= (sizeof( szXReplic ) - 1) ;
		DWORD	ibCopy = sizeof( szXReplic ) - 1 ;
		CGRPPTR	pGroup ;
		CNewsTree*	ptree = m_pInstance->GetTree() ;

		for( DWORD i=0; i < cGroups; i++ ) {

			pGroup = ptree->GetGroupById( pEntries[i].GroupId ) ;

			//
			//	Separate arguments with comma's
			//
			if( i != 0 ) {
				lpb[ibCopy++] = ',' ;
				cbAvailable -- ;
			}

			if( pGroup == 0 ) {

				return 0 ;

			}	else	{
				
				LPSTR	lpstrName = pGroup->GetNativeName() ;
				DWORD	cbName = lstrlen( lpstrName ) ;
				//
				//	Test for room for newsgroup name and digits and CRLF !!!
				//
				if( ibCopy+cbName+19 > cbAvailable )	{
					SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
					return	0 ;
				}

				CopyMemory( lpb+ibCopy, lpstrName, cbName ) ;
				ibCopy += cbName ;
				lpb[ibCopy++] = '/' ;
				_itoa( pEntries[i].ArticleId, (char*)lpb+ibCopy, 10 ) ;
				ibCopy += lstrlen( (char*)lpb+ibCopy ) ;
			}
		}

		if( ibCopy+2 < cbAvailable ) {
			lpb[ibCopy++] = '\r' ;
			lpb[ibCopy++] = '\n' ;

			CNewsTree*	ptree = m_pInstance->GetTree() ;
			pGroup = ptree->GetGroupById( groupid ) ;	
			if( pGroup != 0 ) {
				CStoreId	storeid ;
				FILETIME	ft ;
				BOOL		fPrimary ;
				WORD		HeaderOffset ;
				WORD		HeaderLength ;
				DWORD cStoreIds = 1;
				DWORD	DataLen = 0 ;
				if( m_pInstance->XoverTable()->ExtractNovEntryInfo(
										groupid, 
										articleid, 
										fPrimary, 
										HeaderOffset, 
										HeaderLength, 
										&ft, 
										DataLen, 
										0,
										cStoreIds,
										&storeid,
										NULL))	{
					_ASSERT( fPrimary ) ;
					pArticle = pGroup->GetArticle(	
										articleid, 
										storeid,
										0, 
										0, 
										TRUE
										) ;
				}

			}

			if( pArticle != 0 )	{
				return	ibCopy ;
			}
			SetLastError( ERROR_FILE_NOT_FOUND ) ;
		}

	}	else	{

		SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;

	}

	return	0 ;
}

BOOL
COutToMasterFeed::RetryPost(	NRC		nrcCode )	{

	if(	nrcCode != nrcArticleTransferredOK && nrcCode != nrcArticlePostedOK ) {
		if( nrcCode == nrcPostingNotAllowed ) {
			return	TRUE ;
		}
	}

	return	FALSE ;
}

int
COutToMasterFeed::FormatCommand(	
							BYTE*		lpb,
							DWORD		cb,
							DWORD&		ibStart,
							GROUPID		groupid,
							ARTICLEID	articleid,
							CTOCLIENTPTR&	pArticle 
							)	{

#if 0 
	static	char	szPost[] = "post\r\n" ;

	CopyMemory( lpb, szPost, sizeof( szPost ) -1 ) ;
	ibStart = 0 ;
	return	sizeof( szPost ) - 1 ;
#endif
	ibStart = 0 ;

	DWORD	ibData = 0 ;
	CNewsTree*	ptree = m_pInstance->GetTree() ;

	CGRPPTR		pGroup = ptree->GetGroupById( groupid ) ;	
	if( pGroup != 0 ) {

		//
		//	bugbug ... last parameter to GetArticle should be based on whether
		//	we're using an SSL session - however at the time of writing SSL
		//	feeds weren't supported, so TRUE is safe !
		//
#ifndef	BUGBUG
		pArticle = 0 ;
#else
		pArticle = pGroup->GetArticle(	
								articleid, 
								storeid,
								0, 
								0, 
								TRUE
								) ;
#endif

		if( pArticle != 0 ) {

			static	char	szIHave[] = "ihave " ;
			CopyMemory( lpb, szIHave, sizeof( szIHave ) - 1 ) ;
			cb -= sizeof( szIHave ) - 1 ;
			ibData += sizeof( szIHave ) - 1 ;
			DWORD	cbMessageId = 0 ;
			
			if( pArticle->fGetHeader(	"Message-ID", 
										lpb + ibData,
										cb,
										cbMessageId ) ) {
				cb -= cbMessageId ;
				ibData += cbMessageId ;
				return	ibData ;
			}
		}	else	{

			SetLastError( ERROR_FILE_NOT_FOUND ) ;

		}
	}	else	{

		PCHAR	args[2] ;
		char	szArticleId[20] ;
		_itoa( articleid, szArticleId, 10 ) ;
		args[0] = szArticleId ;
		args[1] = "_slavegroup._slavegroup" ;

		NntpLogEventEx( NNTP_QUEUED_ARTICLE_FAILURE,
				2,
				(const char **)args, 
				GetLastError(),
				m_pInstance->QueryInstanceId()
				) ;

		SetLastError(	ERROR_DIRECTORY ) ;

	}	
	pArticle = 0 ;

	return	 0 ;
}

BOOL
COutToPeerFeed::RetryPost(	NRC		nrcCode )	{

	if(	nrcCode != nrcArticleTransferredOK && nrcCode != nrcArticlePostedOK ) {
		if( nrcCode == nrcPostingNotAllowed || nrcCode == nrcTransferFailedTryAgain ) {
			return	TRUE ;
		}
	}

	return	FALSE ;
}

int
COutToPeerFeed::FormatCommand(	BYTE*		lpb,
								DWORD		cb,
								DWORD&		ibStart,
								GROUPID		groupid,
								ARTICLEID	articleid,
								CTOCLIENTPTR&	pArticle 
								)	{


	static	char	szIHave[] = "ihave " ;
	CopyMemory(	lpb, szIHave, sizeof( szIHave ) - 1 ) ;

	DWORD	cbMessageIdSize = cb - sizeof( szIHave ) - 2 ;
	FILETIME	filetime ;
	BOOL		fPrimary ;
	WORD		HeaderOffset ;
	WORD		HeaderLength ;
	DWORD		cStoreIds = 1;
	CStoreId	storeid ;

	if(	m_pInstance->XoverTable()->ExtractNovEntryInfo(
                                    groupid,
                                    articleid,
									fPrimary,
									HeaderOffset,
									HeaderLength,
									&filetime,
									cbMessageIdSize,
									(char*)lpb + sizeof( szIHave ) - 1,
									cStoreIds,
									&storeid,
									NULL) ) {

		_ASSERT( fPrimary ) ;

		ibStart = 0 ;
		int	cbOut = cbMessageIdSize + sizeof( szIHave ) - 1 ;
		lpb[cbOut++] = '\r' ;
		lpb[cbOut++] = '\n' ;		


		CNewsTree*	ptree = m_pInstance->GetTree() ;
		CGRPPTR	pGroup = ptree->GetGroupById( groupid ) ;	
		if( pGroup != 0 ) {
			pArticle = pGroup->GetArticle(	
									articleid, 
									storeid,
									0, 
									0, 
									TRUE
									) ;
		}
		
		if( pArticle != 0 ) {
			return	cbOut ;
		}
	}	

	SetLastError( ERROR_FILE_NOT_FOUND ) ;

	return	0 ;
}

BOOL
COutToMasterFeed::SupportsStreaming()	{
	return	TRUE ;
}

BOOL
COutToSlaveFeed::SupportsStreaming()	{
	return	FALSE ;
}

BOOL
COutToPeerFeed::SupportsStreaming()	{
	return	TRUE ;
}

char	COutFeed::szCheck[]	= "check " ;

char	COutFeed::szTakethis[] = "takethis " ;

DWORD
COutFeed::FormatCheckCommand(
				BYTE*		lpb, 
				DWORD		cb, 
				GROUPID		groupid, 
				ARTICLEID	articleid
				) {
/*++

Routine Description : 

	Build the command when we are using streaming feeds !

Arguments : 

	lpb - Buffer to place command in !
	cb - size of the buffer
	groupid	 - Group containing article we wish to send
	articleid - Id of the article within the group !

Return Value : 

	Number of bytes in buffer consumed !
	0 if failure !

--*/

	_ASSERT( SupportsStreaming() ) ;
	_ASSERT( lpb != 0 ) ;
	_ASSERT( cb != 0 ) ;
	_ASSERT( groupid != INVALID_GROUPID ) ;
	_ASSERT( articleid != INVALID_ARTICLEID ) ;

	if( cb <= (sizeof( szCheck )+2) ) {
		SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
		return	 0 ;
	}

	CopyMemory(	lpb, szCheck, sizeof( szCheck ) ) ;

	FILETIME	ft ;
	BOOL		fPrimary ;
	WORD		HeaderOffset ;
	WORD		HeaderLength ;

	//
	//	NOTE : subtract 2 additional for CRLF !!
	//
	DWORD		cbSize = cb - sizeof( szCheck ) - 2 ;	
	
	DWORD cStoreIds = 0;

	if( m_pInstance->XoverTable()->ExtractNovEntryInfo(
							groupid, 
							articleid, 
							fPrimary, 
							HeaderOffset, 
							HeaderLength, 
							&ft, 
							cbSize, 
							(char*)lpb + sizeof( szCheck ) - 1 ,
							cStoreIds,
							NULL,
							NULL))	{

		//
		//	We should always be dealing with the primary article !
		//
		_ASSERT( fPrimary ) ;

		DWORD	cbOut = cbSize + sizeof( szCheck ) - 1 ;
		
		lpb[cbOut++] = '\r' ;
		lpb[cbOut++] = '\n' ;
		return	cbOut ;
	}
							
	return	0 ;
}

DWORD
COutToMasterFeed::FormatCheckCommand(	
							BYTE*		lpb,
							DWORD		cb,
							GROUPID		groupid,
							ARTICLEID	articleid
							)	{

	DWORD	ibData = 0 ;
	CNewsTree*	ptree = m_pInstance->GetTree() ;

	CGRPPTR		pGroup = ptree->GetGroupById( groupid ) ;	
	if( pGroup != 0 ) {

		CTOCLIENTPTR	pArticle ;
		//
		//	bugbug ... last parameter to GetArticle should be based on whether
		//	we're using an SSL session - however at the time of writing SSL
		//	feeds weren't supported, so TRUE is safe !
		//
		//
		//	If we don't have an m_pCurrentArticle, we need to go to the
		//	hashtables and get a storeid to use with the driver !
		//
		CStoreId	storeid ;

		pArticle = pGroup->GetArticle(	
									articleid, 
									storeid,
									0, 
									0, 
									TRUE
									) ;
		if( pArticle != 0 ) {

			CopyMemory( lpb, szCheck, sizeof( szCheck ) - 1 ) ;
			cb -= sizeof( szCheck ) - 1 ;
			ibData += sizeof( szCheck ) - 1 ;
			DWORD	cbMessageId = 0 ;
			
			if( pArticle->fGetHeader(	"Message-ID", 
										lpb + ibData,
										cb,
										cbMessageId ) ) {
				cb -= cbMessageId ;
				ibData += cbMessageId ;
				return ibData ;
			}
		}	else	{
			SetLastError( ERROR_FILE_NOT_FOUND ) ;
		}
	}	else	{

		PCHAR	args[2] ;
		char	szArticleId[20] ;
		_itoa( articleid, szArticleId, 10 ) ;
		args[0] = szArticleId ;
		args[1] = "_slavegroup._slavegroup" ;

		NntpLogEventEx( NNTP_QUEUED_ARTICLE_FAILURE,
				2,
				(const char **)args, 
				GetLastError(),
				m_pInstance->QueryInstanceId()
				) ;

		SetLastError(	ERROR_DIRECTORY ) ;
	}	
	return	 0 ;
}

DWORD
COutFeed::CheckCommandLength()	{

	return	sizeof( szCheck ) - 1 ;

}

DWORD
COutFeed::FormatTakethisCommand(	
							BYTE*		lpb,
							DWORD		cb,
							GROUPID		groupid,
							ARTICLEID	articleid,
							CTOCLIENTPTR&	pArticle
							)	{

	_ASSERT( 1==0 ) ;

	return	0 ;
}

DWORD
COutToMasterFeed::FormatTakethisCommand(	
							BYTE*		lpb,
							DWORD		cb,
							GROUPID		groupid,
							ARTICLEID	articleid,
							CTOCLIENTPTR&	pArticle
							)	{

	DWORD	ibData = 0 ;
	CNewsTree*	ptree = m_pInstance->GetTree() ;

	CGRPPTR	pGroup = ptree->GetGroupById( groupid ) ;	
	if( pGroup != 0 ) {

		//
		//	bugbug ... last parameter to GetArticle should be based on whether
		//	we're using an SSL session - however at the time of writing SSL
		//	feeds weren't supported, so TRUE is safe !
		//
		//
		//
		//	If we don't have an m_pCurrentArticle, we need to go to the
		//	hashtables and get a storeid to use with the driver !
		//
		CStoreId	storeid ;

		pArticle = pGroup->GetArticle(	
									articleid, 
									storeid,
									0, 
									0, 
									TRUE
									) ;
		if( pArticle != 0 ) {

			CopyMemory( lpb, szTakethis, sizeof( szTakethis ) - 1 ) ;
			cb -= sizeof( szTakethis ) - 1 ;
			ibData += sizeof( szTakethis ) - 1 ;
			DWORD	cbMessageId = 0 ;
			
			if( pArticle->fGetHeader(	"Message-ID", 
										lpb + ibData,
										cb,
										cbMessageId ) ) {
				cb -= cbMessageId ;
				ibData += cbMessageId ;
				return	ibData ;
			}
		}	else	{

			SetLastError( ERROR_FILE_NOT_FOUND ) ;

		}
	}	else	{

		PCHAR	args[2] ;
		char	szArticleId[20] ;
		_itoa( articleid, szArticleId, 10 ) ;
		args[0] = szArticleId ;
		args[1] = "_slavegroup._slavegroup" ;

		NntpLogEventEx( NNTP_QUEUED_ARTICLE_FAILURE,
				2,
				(const char **)args, 
				GetLastError(),
				m_pInstance->QueryInstanceId()
				) ;

		SetLastError(	ERROR_DIRECTORY ) ;

	}	
	pArticle = 0 ;

	return	 0 ;
}

DWORD
COutToPeerFeed::FormatTakethisCommand(
				BYTE*		lpb,
				DWORD		cb, 
				GROUPID		groupid, 
				ARTICLEID	articleid, 
				CTOCLIENTPTR&	pArticle
				)	{


	CStoreId	storeid ;


	_ASSERT( SupportsStreaming() ) ;
	_ASSERT(	lpb != 0 ) ;
	_ASSERT(	cb != 0 ) ;
	_ASSERT(	groupid != INVALID_GROUPID ) ;
	_ASSERT(	articleid != INVALID_ARTICLEID ) ;
	
	if( cb < sizeof( szTakethis ) + 2 ) {
		SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
		return 0 ;
	}	

	CopyMemory(	lpb, szTakethis, sizeof( szTakethis ) ) ;

	FILETIME	ft ;
	BOOL		fPrimary ;
	WORD		HeaderOffset ;
	WORD		HeaderLength ;

	//
	//	NOTE : subtract 2 additional for CRLF !!
	//
	DWORD		cbSize = cb - sizeof( szTakethis ) - 2 ;	
	DWORD		cStoreIds = 1;

	if( m_pInstance->XoverTable()->ExtractNovEntryInfo(
							groupid, 
							articleid, 
							fPrimary, 
							HeaderOffset, 
							HeaderLength, 
							&ft, 
							cbSize, 
							(char*)lpb + sizeof( szTakethis ) - 1 ,
							cStoreIds,
							&storeid,
							NULL))	{

		//
		//	We should always be dealing with the primary article !
		//
		_ASSERT( fPrimary ) ;

		DWORD	cbOut = cbSize + sizeof( szTakethis ) - 1 ;
		
		lpb[cbOut++] = '\r' ;
		lpb[cbOut++] = '\n' ;

		if( !fPrimary ) {
			if( !m_pInstance->ArticleTable()->GetEntryArticleId(
							(char*)lpb + sizeof( szTakethis ) - 1,
							HeaderOffset, 
							HeaderLength, 
							articleid, 
							groupid,
							storeid) ) {

				return	0 ;
			}
		}
		
		CGRPPTR	pGroup = m_pInstance->GetTree()->GetGroupById( groupid ) ;
		if( pGroup != 0 && (pArticle = pGroup->GetArticle(
										articleid, 
										storeid,
										0,
										0, 
										FALSE
										)) != 0  ) {

			
			return	cbOut ;
		}
	}
	return	0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\nntpsrvi.h ===
//
//  Copyright    (c)    1998        Microsoft Corporation
//
//  Module Name:
//
//      nntpsrvi.h
//
//  Abstract:
//
//		Defines CNntpServer, which implements the INntpServer interface
//
//  Author:
//
//      Alex Wetmore
//
//  

class NNTP_SERVER_INSTANCE;

class CNntpServer : public INntpServer {
	private:
	    //
	    // Pointer to the newsgroup object
	    //
	    NNTP_SERVER_INSTANCE *m_pInstance;
	
	    //
	    // Reference counting
	    //
	    LONG   m_cRef;

	public:
	    //
	    // Constructors
	    //
	    CNntpServer(NNTP_SERVER_INSTANCE *pInstance) {
	        m_pInstance = pInstance;
	        m_cRef = 1;
	    }

	public:
		//
		// INntpServer ----------------------------------------------------
		//

		//
		// find the primary groupid/articleid for an article given the secondary
		// groupid/articleid
		//
		// returns:
		//  S_OK - found primary
		//  S_FALSE - the values given were the primary
		//  otherwise error
		//
		void __stdcall FindPrimaryArticle(INNTPPropertyBag *pgroupSecondary,
		                   				  DWORD   		  artidSecondary,
		                   				  INNTPPropertyBag **pgroupPrimary,
		                   				  DWORD   		  *partidPrimary,
		                   				  BOOL              fInStore,
										  INntpComplete    *pComplete,
										  INntpComplete    *pProtocolComplete = NULL );

		//
		// Create the entries in the hash tables for a new article.
		//
		void __stdcall CreatePostEntries(char				*pszMessageId,
							   			 DWORD				iHeaderLength,
							   			 STOREID			*pStoreId,
							   			 BYTE				cGroups,
							   			 INNTPPropertyBag	**rgpGroups,
							   			 DWORD				*rgArticleIds,
							   			 BOOL               fAllocArtId,
							   			 INntpComplete		*pCompletion);	


        //
        // Delete article out of the hash table
        //
        void __stdcall DeleteArticle( char            *pszMessageId,
                                      INntpComplete   *pCompletion );

        //
        // This tells the driver what rebuild mode the server is in
        // The returned value should be NNTP_SERVER_NORMAL, NNTP_SERVER
        // _STANDARD_REBUILD or NNTP_SERVER_CLEAN_REBUILD
        //
        DWORD __stdcall QueryServerMode();

        //
        // Tells whether should skip non-leaf dir during rebuild
        //
        BOOL __stdcall SkipNonLeafDirWhenRebuild();

        //
        // Has anybody cancelled the rebuild ?
        //
        BOOL __stdcall ShouldContinueRebuild();

        //
        // Does this message id exist in article table ?
        //
        BOOL __stdcall MessageIdExist( LPSTR szMessageId );

        //
        // Set the rebuild last error to server
        //
        void __stdcall SetRebuildLastError( DWORD err );
        

        //
        // Obtain article number for each newsgroups.
        //
        void __stdcall AllocArticleNumber(  BYTE                cGroups,
                                            INNTPPropertyBag    **rgpGroups,
                                            DWORD               *rgArticleIds,
                                            INntpComplete       *pCompletion);

        //
        // Return whether this is a Slave server, and the pickup dir
        //
        BOOL __stdcall IsSlaveServer( WCHAR*          pwszPickupDir,
                                      LPVOID          lpvContext );

		//
	    // IUnknown ------------------------------------------------------
		//
	    HRESULT __stdcall QueryInterface(const IID& iid, VOID** ppv) {
	        if (iid == IID_IUnknown) {
	            *ppv = static_cast<IUnknown*>(this);
	        } else if (iid == IID_INntpServer) {
	            *ppv = static_cast<INntpServer*>(this);
	        } else {
	            *ppv = NULL;
	            return E_NOINTERFACE;
	        }
	        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	        return S_OK;
	    }

	    ULONG __stdcall AddRef() {
			return InterlockedIncrement(&m_cRef);
	    }
	
	    ULONG __stdcall Release() {
	        if ( InterlockedDecrement(&m_cRef) == 0 ) {
				// we should never hit zero because the instance creates 
				// us and should always have one reference
	            _ASSERT( 0 );
	        }
	
	        return m_cRef;
	    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\packet.h ===
/*++

	packet.h

	This file contains the class definitions for buffers and packets, the two type hierarchies
	which describe basic IO operations.

	A CBuffer is a reference counted buffer which is variable sized.
	CBuffer's will be created in one of several standard sizes, the size stored in the m_cbTotal field.


	We have the following inheritance hierarchy : 


							CPacket 
				
					/			|		\
				/				|			 \
			
		CTransmitPacket		CRWPacket		CControlPacket

							/		\
						   /		 \
					CReadPacket		CWritePacket


	CTransmitPacket - 
		represents TransmitFile operations

	CReadPacket - 
		represents an async read from a socket or file

	CWritePacket - 
		represents an async write to a socket or file

	CControlPacket - 
		does not represent any real IO - used by CIODrivers to 
		control simultaneous operations 


--*/

#ifndef	_PACKET_H_
#define	_PACKET_H_

#include	"cbuffer.h"
#include	"gcache.h"
#include	"io.h"


//
// CPool Signature
//

#define PACKET_SIGNATURE (DWORD)'1191'

#ifdef	_NO_TEMPLATES_

DECLARE_SMARTPTRFUNC(	CBuffer ) 

#endif


//
//	CPacket - 
//	the classes derived from this will describe the most basic read's and write's (and TransmitFile's)
//	that are done against socket's and file handles.
//
//	The basic CPacket object describes the following : 
//
//		m_fRequest -  This is TRUE until an the IOs associated with this packet have completed.
//			ie.	if this is a read m_fRequest will be set to FALSE when the read completes.
//
//		m_fRead - Does this represent a 'read' or a 'write'
//
//		m_sequenceno - This is used to order how packets are processing.  sequence numbers are 
//			issued in a strictly increasing order as the packets are issued.
//			The sequenceno is set when the packet is issued (ie AtqReadFile is called) not when 
//			the packet is created.
//
//		m_iStream - for completed packets this is the number of logical bytes since the stream
//			was opened that preceded this packet.
//
//		m_pOwner - the CIODriver object responsible for processing this packet when it completes.
//
//		m_cbBytes - the number of bytes that were transfered by this IO operation !
//
//
class	CPacket : public CQElement	{
private : 
	static	CPacketAllocator	gAllocator ;
protected : 
	inline	CPacket(	CIODriver&, BOOL, BOOL fSkipQueue = FALSE ) ;
	inline	CPacket(	CIODriver&,	CPacket& ) ;
	virtual	~CPacket() ;
public : 
	ExtendedOverlap	m_ovl ;		// Overlap Structure
	BOOL		m_fRequest ;	// TRUE if this is a request packet, FALSE if this is a completion packet.

	//
	//	Is this packet a Read or a Writes (CTransmitPacket and CWritePacket are both 'Writes')
	//
	BOOL		m_fRead ;		// Which Queue to process on !? Reads or Writes !?

	//
	//	This flag indicates that we do not need to do any queueing in how this packet is handled !
	//
	BOOL		m_fSkipQueue ;
	
	//
	//	Packet Sequence Number
	//
	SEQUENCENO	m_sequenceno ;	// The sequenceno of this IOPacket

	//
	//	Number of bytes into the logical stream the data carried by this packet begins !
	//
	STRMPOSITION	m_iStream ;		// The beginning stream position of the data within this packet
	
	//
	//	Number of legit bytes moved by this packet.  Set when the IO completes 
	//
	unsigned	m_cbBytes ;		// Number of bytes transferred

	//
	//	The CIODriver to which this packet should be completed (ie call is ProcessPacket())
	//
	CDRIVERPTR	m_pOwner ;		// The Owning CIODriver derived object !

	//
	//	This is used only with CIODriverSource's.  When the packet is 
	//	issued we figure out what CIOPassThru object to process the packet with
	//	and store it here.
	//
	DWORD		m_dwPassThruIndex ;
	
	//
	//	The following two fields are 'extra' DWORD's that we provide
	//	to be used by CIO classes as they please.
	//
	DWORD		m_dwExtra1 ;
	DWORD		m_dwExtra2 ;

	//
	//	Pointer to the CIODriver which originated the request - 
	//	this is set if we are using a filter
	//
	CDRIVERPTR	m_pSource ;

	//
	//	For File IO only - pointer to the CFileChannel object which
	//	issues the IO's - because we can't use the ATQ completion contexts 
	//	with file handles for various reasons !
	//
	CFileChannel*	m_pFileChannel ;

	//
	// Both m_fRequest and m_sequenceno must be set if this is a valid request packet !!
	//	If this is a CWritePacket it must also have a pBuffer
	//	If this is a CTransmiPacket it must also have a hFile
	//	If this is a Read Request then whether the packet has a BUFFER depends on the 
	//	Channel the request was issued to.
	//
	virtual	BOOL		IsValidRequest( BOOL	fReadsRequireBuffers ) ;	
	//
	// A completed request must have cbBytes set, and if it 
	//	is a read or Write request, it must have a BUFFER!
	//
	virtual	BOOL		IsValidCompletion() ;
	//
	// Before a packet is destroyed it should be validly completed !
	//
	virtual	BOOL		IsCompleted() = 0 ;

	inline	BOOL	IsValid() ;

	//
	//	For use with CIODriverSource objects - give a CIOPassThru derived object a 
	//	chance at massaging the packet.
	//
	virtual	BOOL	InitRequest( class	CIODriverSource&,	class	CSessionSocket*,	class	CIOPassThru	*pio,	BOOL& ) ;

	//
	//	Two variations on completing packets - one for use with CIODriverSource, the other with CIODriverSink objects 
	//
	virtual	unsigned	Complete( IN	CIOPassThru*	pIn, IN CSessionSocket*, CPacket* pRequest, OUT BOOL& ) = 0 ;
	virtual	unsigned	Complete( INOUT	CIO*&	pIn, IN CSessionSocket* ) = 0 ;
	inline	void	ForwardRequest(	CSessionSocket*	pSocket ) ;

	//
	//	Compare packet sequence numbers 
	//
	inline	BOOL	operator > ( CPacket &rhs ) ;
	inline	BOOL	operator < ( CPacket &lhs ) ;

	//
	//	Legality checking functions
	//
	virtual	BOOL	FConsumable() ;
	virtual	BOOL	FLegal( BOOL	fRead ) = 0 ;

	//
	//	Functions for determining the derived class.
	//	Maybe we should use the new C++ Dynamic Cast ?
	//	These are mostly used for debugging
	//	
	//
	inline	virtual	CReadPacket*	ReadPointer() ;
	inline	virtual	CWritePacket*	WritePointer() ;
	inline	virtual	CTransmitPacket*	TransmitPointer() ;
	inline	virtual	CControlPacket*	ControlPointer() ;

	//
	//	Initialize CPool so memory allocations work 
	//
	static	BOOL	InitClass() ;

	//
	//	Discard all CPool stuff !
	//
	static	BOOL	TermClass() ;


	//
	//	Memory manage of CPacket's - 
	//	operator new can take a CPacketCache - which is used to cache packets and 
	//	avoid contention on critical sections.
	//	ReleaseBuffers - a virtual function that should be called when ready to destroy 
	//	a packet to release all of its buffers.
	//	Destroy - All the destructors are protected so that people that wish to 
	//	get rid of CPacket's must call 'Destroy'.	Destroy calls the destructor for the packet
	//	however it does not release the memory associated with a packet - this must be handled
	//	explicitly after calling destroy. (This approach allows the caller to 'cache' CPacket's).
	//
	//

	void*	operator	new(	
								size_t	size,	
								CPacketCache*	pCache = 0 
								) ;

	//
	//	This function will release any buffers the packet is pointing at 
	//
	virtual	void	ReleaseBuffers(	
								CSmallBufferCache*	pBufferCache,
								CMediumBufferCache*	pMediumCache
								) ;

	//
	//	This function will call the destructor for the packet but will not release the memory
	//
	static	inline	void*	Destroy(	
								CPacket*	pPacket 
								)	
								{	delete	pPacket ;	return (void*)pPacket ;	}

	//
	//	This function will call the destructor AND release the memory !
	//	
	static	inline	void	DestroyAndDelete(	CPacket*	pPacket )	{	delete	pPacket ;	gAllocator.Release( (void*)pPacket ) ;	}

	//
	//	The delete operator will do nothing but call the destructor - callers should use
	//	DestroyAndDelete to release the memory as well
	//
	void	operator	delete(	void*	pv ) ;
} ;

//
//	The CRWPacket class contains all information common to both
//	Read and Write IO operations.
//
class	CRWPacket : public	CPacket	{
protected :
	//inline	CRWPacket() ; 
	//inline	CRWPacket(	BOOL	) ;
	inline	CRWPacket(	CIODriver&, 
						BOOL fRead = FALSE 
						) ;

	inline	CRWPacket(	CIODriver&,	
						CBuffer&,	
						unsigned	size, 
						unsigned	cbTrailer,
						BOOL fRead = FALSE	
						) ;

	inline	CRWPacket(	CIODriver&,	
						CBuffer&	pbuffer,	
						unsigned	ibStartData,	
						unsigned	ibEndData, 
						unsigned	ibStart, 
						unsigned	ibEnd, 
						unsigned	cbTrailer,
						BOOL fRead = FALSE 
						) ;

	inline	CRWPacket(	CIODriver&,	
						CRWPacket& 
						) ;

	inline	~CRWPacket( ) ;
public : 
	CBUFPTR		m_pbuffer ;		// The buffer in which this data resides
	unsigned	m_ibStart ;		// The start of the region within buffer reserved for the Packet
	unsigned	m_ibEnd ;		// The end of the region within buffer reserved for the Packet
	unsigned	m_ibStartData ;	// The start of the actual data within the buffer
	unsigned	m_ibEndData ;	// The end of the actual data within the buffer
	unsigned	m_cbTrailer ;	// number of bytes beyond the end of the packet reserved for 
								// use by lower levels for encryption data etc...

	BOOL		IsValid() ;
	BOOL		IsValidRequest( BOOL	fReadsRequireBuffers ) ;
	BOOL		IsValidCompletion( ) ;
	BOOL		IsCompleted() ;
	void		InitRequest(	CBUFPTR	pBufPtr, int ibStart, int ibEnd, 
					int ibStartData, CDRIVERPTR pDriver ) ;

	//
	//	Utility functions for getting at various parts of the data in the packet.
	//	People must never touch bytes beyond End() or before Start().  Nor 
	//	can anybody assume that they are the only ones using the buffer pointed
	//	to by this packet.
	//
	char*		StartData( void ) ;
	char*		EndData( void ) ;
	char*		Start( void ) ;
	char*		End( void ) ;

	void	ReleaseBuffers(	CSmallBufferCache*	pBufferCache, CMediumBufferCache* pMediumCache ) ;
} ;

//
//	The CReadPacket class represents read operations. All data
//	is contained in the CRWPacket class.  This class enables us to use 
//	function overloading to process Read Packets only.
//	NOTE that the ExtendedOverlap structure contains enough information
//	to determine whether something is a CReadPacket.
//
class	CReadPacket	: public	CRWPacket	{
private : 
	CReadPacket() ;
protected : 
	~CReadPacket( ) ;
public : 
	CReadPacket(	CIODriver&	driver, 
					unsigned	size,
					unsigned	m_cbFront,	
					unsigned	m_cbTail,	
					CBuffer&	pbuffer
					) ;

	CReadPacket(	CIODriver&	driver ) ;

	inline		CReadPacket(	CIODriver&	driver,	
								CReadPacket&	read 
								) ;

	BOOL		FConsumable() ;
	BOOL		FLegal( BOOL	fRead ) ;
	BOOL		IsValid() ;
	BOOL		IsValidRequest( BOOL	fReadsRequireBuffers ) ;
	BOOL		InitRequest( class	CIODriverSource&,	class	CSessionSocket*,	class	CIOPassThru	*pio,	BOOL& ) ;
	unsigned	Complete( INOUT	CIOPassThru*	pIn, IN CSessionSocket*, CPacket* pRequest, OUT BOOL& ) ;
	unsigned	Complete( INOUT	CIO*&	pIn, IN CSessionSocket* ) ;
	inline		CReadPacket*	ReadPointer() ;
} ;

//
//	The CWritePacket class represents write operations.
//
class	CWritePacket	: public	CRWPacket	{
private : 
	CWritePacket() ;	
protected : 
	~CWritePacket( ) ;
public : 
	CWritePacket(	CIODriver&	driver,	
					CBuffer&	pbuffer,	
					unsigned	ibStartData,	
					unsigned	ibEndData,	
					unsigned	ibStart,	
					unsigned	ibEnd,
					unsigned	cbTrailer
					) ;

	inline		CWritePacket(	
					CIODriver&	driver,	
					CWritePacket&	write 
					) ;

	BOOL		FLegal( BOOL	fRead ) ;
	BOOL		IsValid() ;
	BOOL		IsValidRequest( BOOL	fReadsRequireBuffers ) ;
	BOOL		InitRequest( class	CIODriverSource&,	class	CSessionSocket*,	class	CIOPassThru	*pio,	BOOL& ) ;
	unsigned	Complete( INOUT	CIOPassThru*	pIn, IN CSessionSocket*, CPacket* pRequest, OUT BOOL& ) ;
	unsigned	Complete( INOUT	CIO*&	pIn, IN CSessionSocket* ) ;
	inline		CWritePacket*	WritePointer() ;
} ;

//
//	This class represents TransmitFile() operations.
//
class	CTransmitPacket	: public	CPacket	{
private : 
	CTransmitPacket() ;
protected : 
	~CTransmitPacket( ) ;
public : 
	FIO_CONTEXT*	m_pFIOContext ;	// The file from the cache we are to send !
	unsigned	m_cbOffset ;		// Starting offset within file
	unsigned	m_cbLength ;

	TRANSMIT_FILE_BUFFERS	m_buffers ;	
	
	inline		
	CTransmitPacket(	CIODriver&, 
						FIO_CONTEXT*,  
						unsigned	ibOffset,	
						unsigned	cbLength 
						) ;
						
	inline		CTransmitPacket(	
						CIODriver&	driver,	
						CTransmitPacket&	transmit 
						) ;

	BOOL		FLegal( BOOL	fRead ) ;
	BOOL		IsValid() ;
	BOOL		IsValidRequest( BOOL	fReadsRequireBuffers ) ;
	BOOL		IsValidCompletion( ) ;
	BOOL		IsCompleted() ;
	//BOOL		InitRequest( HANDLE	hFile, int cbOffset ) ;

	BOOL		InitRequest( class	CIODriverSource&,	class	CSessionSocket*,	class	CIOPassThru	*pio,	BOOL& ) ;
	unsigned	Complete( INOUT	CIOPassThru*	pIn, IN CSessionSocket*, CPacket* pRequest, OUT BOOL& ) ;
	unsigned	Complete( INOUT	CIO*&	pIn, IN CSessionSocket* ) ;
	inline		CTransmitPacket*	TransmitPointer() ;
} ;

class	CExecutePacket	:	public	CPacket	{
protected : 
	//
	//	Data captured from the Execution !
	//
	DWORD	m_cbTransfer ;
	//
	//	Did the operation complete !
	//
	BOOL	m_fComplete ;
	//
	//	Do we need a larger buffer to perform the operation !
	//
	BOOL	m_fLargerBuffer ;
	//
	//	The write packet containing the clients data !
	//
	CWritePacket*	m_pWrite ;
	//
	//	Special CIO class that is our friend
	//
	friend	class	CIOWriteAsyncComplete ;
	friend	class	CIOWriteAsyncCMD ;
	friend	class	CIOShutdown ;
public :
	inline	
	CExecutePacket(	CIODriver&	driver	) ;

	#ifdef	DEBUG
	~CExecutePacket()	{
		//
		//	Somebody must ensure this is released before we're destroyed !
		//
		_ASSERT( m_pWrite == 0 ) ;
	}
	#endif
	

	BOOL
	FLegal(	BOOL	fRead ) 	{
		return	TRUE ;
	}

	BOOL
	IsValidRequest(	BOOL	fReadsRequireBuffers ) {
		return	TRUE ;
	}

	BOOL
	IsCompleted()	{
		return	TRUE ;
	}
	
	unsigned	
	Complete(	INOUT	CIOPassThru*	pIn, 
				IN CSessionSocket*, 
				CPacket* pRequest, 
				OUT BOOL& 
				) 	{
		DebugBreak() ;
		return	0 ;
	}
	
	unsigned	
	Complete(	INOUT	CIO*&	pIn, 
				IN CSessionSocket* pSocket
				) ;
} ;




class	CControlPacket	:	public	CPacket	{
protected : 
	~CControlPacket()	{}
public : 

	ControlInfo	m_control ;
	
	CControlPacket(	CIODriver&	driver ) ;	
	
	void	StartIO(	CIO&	pio,	BOOL	fStart ) ;
	void	StartIO(	CIOPassThru&	pio,	BOOL	fStart ) ;
	void	Shutdown(	BOOL	fCloseSource = TRUE ) ;
	void	Reset( ) ;

	BOOL	FLegal(		BOOL	fRead ) ;
	BOOL	IsValidRequest(	BOOL	fReadsRequireBuffers ) ;
	BOOL		IsCompleted() ;
	unsigned	Complete( INOUT	CIOPassThru*	pIn, IN CSessionSocket*, CPacket* pRequest, OUT BOOL& ) ;
	unsigned	Complete( INOUT	CIO*&	pIn, IN CSessionSocket* ) ;

	CControlPacket*	ControlPointer() ;
} ;


#define	MAX_PACKET_SIZE	max(	sizeof( CReadPacket ),	\
							max(	sizeof( CWritePacket ),	\
								max(	sizeof( CControlPacket ),  sizeof( CTransmitPacket ) ) ) ) 


#endif	//	_PACKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\nscphack.cpp ===
#include	"tigris.hxx"
//#include	<windows.h>

DWORD
NetscapeHackFunction(
		LPBYTE		lpbBuffer,
		DWORD		cbBuffer,
		DWORD		cbBufferMax,
		DWORD&		cbNewHeader,
		LPBYTE		szHackString,
		BYTE		szRepairString[2]
		)	{

	
	if( cbBuffer == cbBufferMax ) {
		return	0 ;
	}

	//
	//	Find the end of the header !
	//
	BYTE	*lpbState = szHackString ;
	BYTE	*lpbEndBuffer = lpbBuffer + cbBuffer ;
	DWORD	cNewlines = 0 ;

	for( LPBYTE	lpbCurrent = lpbBuffer;
			lpbCurrent < lpbEndBuffer;
			lpbCurrent ++ ) {

		if( *lpbCurrent == '\n' ) {
			cNewlines ++ ;
		}

		if( *lpbCurrent == *lpbState ) {
			lpbState ++ ;
			if( *lpbState == '\0' ) {
				break ;
			}
		}	else	{
			if( *lpbCurrent == szHackString[0] ) {
				lpbState = &szHackString[1] ;
			}	else	{
				lpbState = &szHackString[0] ;
			}
		}
	}

	//
	//	Did we find the end of the header ??
	//
	if( lpbCurrent == lpbEndBuffer )
		return	0 ;
	
	if( cNewlines + cbBuffer > cbBufferMax ) {
		//
		//	No room to do buffer manipulation to make
		//	it into a good article !
		//
		return	0 ;
	}

	MoveMemory( lpbBuffer+cNewlines, lpbBuffer, cbBuffer ) ;
	LPBYTE	lpbBegin = lpbBuffer ;

	for( LPBYTE	lpbStart = lpbBuffer+cNewlines;
				lpbStart <= lpbCurrent+cNewlines ;
				lpbStart ++, lpbBuffer++ ) {

		*lpbBuffer = *lpbStart ;
		if( *lpbBuffer == szHackString[0] ) {
			*lpbBuffer++ = szRepairString[0] ;
			*lpbBuffer = szRepairString[1] ;
		}
	}
	cbNewHeader = (DWORD)(lpbBuffer - lpbBegin) ;
	
	return	cNewlines + cbBuffer ;
}

#ifdef	UNIT_TEST

int	
main(	int	argc, char**	argv ) {

	char	szTestString[] =
				"Subject: control message \n"
				"control: cancel <fjdklsfjlsd@fjdksl>\n"
				"approved: test\n"
				"from:  test \n"
				"\n\n"
				"body"
				"\r\n.\r\n" ;

	BYTE	rgb[4000] ;

	FillMemory( rgb, sizeof( rgb ), 0xcc ) ;

	CopyMemory( rgb, szTestString, sizeof( szTestString )-1 ) ;

	DWORD	cbHeader ;

	DWORD	cb =
	NetscapeHackFunction(
					rgb,
					sizeof( szTestString )-1,
					sizeof( rgb ),
					cbHeader,
					(BYTE*)"\n\n",
					(BYTE*)"\r\n"
					) ;

	if( memcmp( rgb+cb-5, "\r\n.\r\n", 5 ) != 0 )
		DebugBreak() ;
					
	FillMemory( rgb, sizeof( rgb ), 0xcc ) ;

	CopyMemory( rgb, szTestString, sizeof( szTestString )-1 ) ;

	DWORD	cbBuffer = sizeof( szTestString ) -1 + 5 ;
	rgb[cbBuffer] = 0xff ;

	cb =
	NetscapeHackFunction(
					rgb,
					sizeof( szTestString )-1,
					cbBuffer,
					cbHeader,
					(BYTE*)"\n\n",
					(BYTE*)"\r\n"
					) ;

	if( memcmp( rgb+cb-5, "\r\n.\r\n", 5 ) != 0 )
		DebugBreak() ;
						
	if( rgb[cbBuffer] != 0xff )
		DebugBreak() ;				
				
	FillMemory( rgb, sizeof( rgb ), 0xcc ) ;

	CopyMemory( rgb, szTestString, sizeof( szTestString )-1 ) ;

	cbBuffer = sizeof( szTestString ) -1 + 5 - 1;
	rgb[cbBuffer] = 0xff ;

	cb =
	NetscapeHackFunction(
					rgb,
					sizeof( szTestString )-1,
					cbBuffer,
					cbHeader,
					(BYTE*)"\n\n",
					(BYTE*)"\r\n"
					) ;

	if( cb != 0 )
		DebugBreak() ;
						
	if( rgb[cbBuffer] != 0xff )
		DebugBreak() ;				

	if( memcmp( rgb, szTestString, sizeof( szTestString ) - 1 ) != 0 ) {
		DebugBreak() ;
	}

	char	szIllegalString[] =
					"from: test \n"
					"subject: what \n"
					"howsthat: fjdskl \n"
					"no empty line\n"
					"again no emtpy line\n"
					"\r\n.\r\n" ;

	FillMemory( rgb, sizeof( rgb ), 0xcc ) ;

	CopyMemory( rgb, szIllegalString, sizeof( szIllegalString )-1 ) ;

	cbBuffer = sizeof( rgb ) - 1;
	rgb[cbBuffer] = 0xff ;

	cb =
	NetscapeHackFunction(
					rgb,
					sizeof( szTestString )-1,
					cbBuffer,
					cbHeader,
					(BYTE*)"\n\n",
					(BYTE*)"\r\n"
					) ;

	if( cb != 0 )
		DebugBreak() ;
						
	if( rgb[cbBuffer] != 0xff )
		DebugBreak() ;	
	
	if( memcmp( rgb, szIllegalString, sizeof( szIllegalString ) - 1 ) != 0 ) {
		DebugBreak() ;
	}
			
	return 0 ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\packet.cpp ===
/*++

	packet.cpp

	This file contains the code which implements the CPacket derived classes.
	A CPacket derived object describes the most basic IO operation that is performed.


--*/




#include	"tigris.hxx"

#ifdef	CIO_DEBUG
#include	<stdlib.h>		// For Rand() function
#endif

#ifdef	_NO_TEMPLATES_

DECLARE_ORDEREDLISTFUNC( CPacket )

#endif


//
//	CPool for allocating all packets
//
CPool	CPacketAllocator::PacketPool ;

CPacketAllocator::CPacketAllocator()	{
}

BOOL
CPacketAllocator::InitClass() {
/*++

Routine Description :

	Initialize the CPacketAllocator class.
	This class wraps all calls to CPool, basically so we can
	easily use CCache to cache allocations of packets.

	This function will have the CPool reserver the necessary memory.

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE  otherwise

--*/
	return	PacketPool.ReserveMemory( MAX_PACKETS, MAX_PACKET_SIZE ) ;
}

BOOL
CPacketAllocator::TermClass()	{
/*++

Routine Description :

	Release all of the memory associated with Packets.

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise

--*/
	_ASSERT( PacketPool.GetAllocCount() == 0 ) ;
	return	PacketPool.ReleaseMemory() ;
}

#ifdef	DEBUG
//
//	The following debug functions are called
//	from CCache in order to emulate some of the debug
//	checking that is done in CPool when packet allocations
//	are cached.
//
//
void
CPacketAllocator::Erase(
					void*	lpv
					) {
/*++

Routine Description :

	File a block of memory to make it easy to spot in the debugger

Arguments :

	lpv - memory allocated for a CPacket derived object.

Return Value :

	None

--*/

	FillMemory( (BYTE*)lpv, MAX_PACKET_SIZE, 0xCC ) ;

}

BOOL
CPacketAllocator::EraseCheck(
					void*	lpv
					)	{
/*++

Routine Description :

	Check that a block of memory was cleared by
	CPacketAllocator::Erase()

Arguments :

	lpv - block of memory

Return Value :

	TRUE if Erase()'d
	FALSE otherwise

--*/

	BYTE*	lpb = (BYTE*)lpv ;
	for( int i=0; i<MAX_PACKET_SIZE; i++ ) {
		if( lpb[i] != 0xCC ) {
			return	FALSE ;
		}
	}
	return	TRUE ;
}

BOOL
CPacketAllocator::RangeCheck(
					void*	lpv
					)	{
/*++

Routine Description :

	Check that a block of memory is in a range
	we would allocate.
	Cpool doesn't have enough support for this.

Arguments :

	lpv - address to check

Returns :

	Always TRUE

--*/
	return	TRUE ;
}

BOOL
CPacketAllocator::SizeCheck(
					DWORD	cb
					)	{
/*++

Routine Description :

	Check that a requested size is legitimate

Arguments :

	cb - requested size

Return Value :

	TRUE if the size is good !

--*/

	if( cb <= MAX_PACKET_SIZE )
		return	TRUE ;

	return	FALSE ;
}
#endif

//
//	Global allocator used by CPacket
//
CPacketAllocator	CPacket::gAllocator ;

//
//	Pointer to the same global allocator that
//	CCache needs to use
//
CPacketAllocator	*CPacketCache::PacketAllocator ;

BOOL
CPacket::InitClass( )	{
/*++

Routine Description :

	Initialize the CPacket class

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise

--*/

	if( CPacketAllocator::InitClass() )	{
		CPacketCache::InitClass( &gAllocator ) ;
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CPacket::TermClass()	{
/*++

Routine Description :

	Terminate everything regarding CPacket's

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise

--*/

	return	CPacketAllocator::TermClass() ;

}

void
CPacket::ReleaseBuffers(
					CSmallBufferCache*	pBufferCache,
					CMediumBufferCache*	pMediumCache
					) {
/*++

Routine Description :

	This function is supposed to release any buffers
	that the CPacket may contain.  This is a virtual
	function that should be overridden by CPackets which
	contain buffers.

Arguments :

	pBufferCache - Cache to hold small buffers
	pMediumCache - Cache to hold medium size buffers

Return Value :

	None.

--*/
}

void
CRWPacket::ReleaseBuffers(
				CSmallBufferCache*	pBufferCache,
				CMediumBufferCache*	pMediumCache
				) {
/*++

Routine Description :

	This function is supposed to release any buffers
	that the CRWPacket may contain.

Arguments :

	pBufferCache - Cache to hold small buffers
	pMediumCache - Cache to hold medium size buffers

Return Value :

	None.

--*/

	if( pBufferCache ) {
		CBuffer*	pbuffer = m_pbuffer.Release() ;
		if( pbuffer )	{
			if( pbuffer->m_cbTotal < CBufferAllocator::rgPoolSizes[0] ) {
				pBufferCache->Free( (void*)pbuffer ) ;
			}	else	{
				pMediumCache->Free( (void*)pbuffer ) ;
			}
		}
	}	else	{
		m_pbuffer = 0 ;
	}
}

BOOL	CPacket::InitRequest(
					class	CIODriverSource&,
					CSessionSocket	*,
					CIOPassThru*	pio,
					BOOL	&fAcceptRequests ) {
	fAcceptRequests = FALSE ;
	Assert( 1==0 ) ;
	return	FALSE ;
}


BOOL	CPacket::IsValidRequest(
					BOOL	fReadsRequireBuffers
					) {
/*++

Routine Description :

	Check whether this packet is in valid state, given that
	it has not yet been issued.

Arguments :

	fReadsRequireBuffers - if TRUE and this is a read we should
		have a buffer

Return Value :

	TRUE if good
	FALSE otherwise


--*/

	if( !m_fRequest ) {
		return	FALSE ;
	}
	//if(	m_sequenceno == INVALID_SEQUENCENO )	{
	//	return	FALSE ;
	//}
	//if( m_iStream == INVALID_STRMPOSITION )	{
	//	return	FALSE ;
	//}
	//if( (m_sequenceno == INVALID_SEQUENCENO && m_iStream != INVALID_STRMPOSITION) ||
	//	(m_sequenceno != INVALID_SEQUENCENO && m_iStream == INVALID_STRMPOSITION) ) {
	//	return	FALSE ;
	//}

#if 0
	if( m_cbBytes != UINT_MAX )	{
		return	FALSE ;
	}
#endif
	if( m_ovl.m_pHome != this )		{
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL	CRWPacket::IsValidRequest(
				BOOL	fReadsRequireBuffers
				)	{
/*++

Routine Description :

	Check whether this packet is in valid state, given that
	it has not yet been issued.

Arguments :

	fReadsRequireBuffers - if TRUE and this is a read we should
		have a buffer

Return Value :

	TRUE if good
	FALSE otherwise


--*/


	if( !CPacket::IsValidRequest( fReadsRequireBuffers ) ) {
		return	FALSE ;
	}
	if( m_ibStartData < m_ibStart ) {
		return	FALSE ;
	}
	if( m_ibEnd < m_ibStart )	{
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CReadPacket::IsValidRequest(
					BOOL	fReadsRequireBuffers
					)	{
/*++

Routine Description :

	Check whether this packet is in valid state, given that
	it has not yet been issued.

Arguments :

	fReadsRequireBuffers - if TRUE and this is a read we should
		have a buffer

Return Value :

	TRUE if good
	FALSE otherwise


--*/


	if( m_cbBytes != 0 )	{
		return	FALSE ;
	}
	if( !m_fRead )	{
		return	FALSE ;
	}
	if( !CRWPacket::IsValidRequest( fReadsRequireBuffers ) ) {
		return	FALSE ;
	}
	if(	m_ibEndData != 0 )		{	// m_ibEndData is not set until we have completed
									// must be zero on all requests
		return	FALSE ;
	}
	if( fReadsRequireBuffers )	{
		if( m_pbuffer == 0 )	{
			return	FALSE ;
		}
		if( m_ibEnd == m_ibStart )	{	// End must not equal Start - no zero length
										// Reads Allowed !!!!
			return	FALSE ;
		}
		if( m_ibEnd == 0 ) {
			return	FALSE ;
		}
	}	else	{
		if( m_pbuffer != 0 )	{
			return	FALSE ;
		}
		// All fields must be 0 if there is no buffer !!
		if( m_ibStart != 0 )	{
			return	FALSE ;
		}
		if( m_ibEnd != 0 )	{
			return	FALSE ;
		}
		if( m_ibStartData != 0 )	{
			return	FALSE ;
		}
		if(	m_ibEndData != 0 )	{
			return	FALSE ;
		}
	}
	return	TRUE ;
}

BOOL
CWritePacket::IsValidRequest(
							BOOL	fReadsRequireBuffers
							)	{
/*++

Routine Description :

	Check whether this packet is in valid state, given that
	it has not yet been issued.

Arguments :

	fReadsRequireBuffers - if TRUE and this is a read we should
		have a buffer

Return Value :

	TRUE if good
	FALSE otherwise


--*/


	if( !((int)m_cbBytes >= 0 && m_cbBytes <= (m_ibEndData - m_ibStartData)) )	{
		return	FALSE ;
	}
	if( m_fRead )	{
		return	FALSE ;
	}
	if( !CRWPacket::IsValidRequest(	fReadsRequireBuffers ) )	{
		return	FALSE ;
	}
	if( m_pbuffer == 0 )	{	// WRITES MUST HAVE BUFFERS
		return	FALSE ;
	}
	if( m_ibEnd == m_ibStart )	{	// NO ZERO LENGTH WRITES !
		return	FALSE ;
	}
	if( m_ibEndData < m_ibStartData )	{
		return	FALSE ;
	}
	if( m_ibEndData == m_ibStartData )	{
		return	FALSE ;
	}
	if( m_ibEndData == 0 ) {	// WRITES MUST SPECIFY BOTH STARTDATA and ENDDATA
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CTransmitPacket::IsValidRequest(
							BOOL	fReadsRequireBuffers
							)	{
/*++

Routine Description :

	Check whether this packet is in valid state, given that
	it has not yet been issued.

Arguments :

	fReadsRequireBuffers - if TRUE and this is a read we should
		have a buffer

Return Value :

	TRUE if good
	FALSE otherwise


--*/

	if( m_cbBytes != 0 )	{
		return	FALSE ;
	}
	if( m_fRead )	{
		return	FALSE ;
	}
	if( !CPacket::IsValidRequest( fReadsRequireBuffers ) )	{
		return	FALSE ;
	}
	if( m_pFIOContext == 0 )	{
		return	FALSE ;
	}
	if( m_pFIOContext->m_hFile == INVALID_HANDLE_VALUE ) 	{
		return	FALSE ;
	}
	if( m_cbOffset == UINT_MAX )	{
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CPacket::IsValidCompletion(	  )	{
/*++

Routine Description :

	Given that the IO for this has completed successfully,
	check that the packet is in a valid state.

Arguments :

	None.

Return Value :

	TRUE if good
	FALSE otherwise

--*/
	if( m_fRequest ) {
		return	FALSE ;
	}
	if( m_cbBytes == UINT_MAX )		{		// We can complete 0 bytes, although we can't request it !
		return	FALSE ;
	}
	if(	EQUALSI( m_sequenceno, (DWORD)INVALID_SEQUENCENO ) )	{
		return	FALSE ;
	}
	if(	EQUALSI( m_iStream, (DWORD)INVALID_STRMPOSITION )	)	{
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CRWPacket::IsValidCompletion( )		{
/*++

Routine Description :

	Given that the IO for this has completed successfully,
	check that the packet is in a valid state.

Arguments :

	None.

Return Value :

	TRUE if good
	FALSE otherwise

--*/


	if( !CPacket::IsValidCompletion()	)	{
		return	FALSE ;
	}
	if( m_ibStartData < m_ibStart )	{
		return	FALSE ;
	}
	if( m_ibEnd < m_ibStart )	{
		return	FALSE ;
	}
//	Not valid for write packets !!
//	if( (m_ibStartData + m_cbBytes != m_ibEndData) && m_cbBytes != 0 )	{
//		return	FALSE ;
//	}
#ifdef	RETIRED
    //
    // This check works most of the time except when writing to a file
    // and the machine runs out of disk space.  Retired untill we can
    // figure out how to not _ASSERT in that case !
    //

	//
	//	This check ensures that if we are issuing packets against a file
	//  that the file offsets are being properly synchronized !!
	//
	if(	m_ovl.m_ovl.Offset != 0 && m_ovl.m_ovl.Offset != (1+LOW(m_iStream)) && m_cbBytes != 0 )	{
		return	FALSE ;
	}
#endif	// CIO_DEBUG
	return	TRUE ;
}

BOOL
CTransmitPacket::IsValidCompletion( )	{
/*++

Routine Description :

	Given that the IO for this has completed successfully,
	check that the packet is in a valid state.

Arguments :

	None.

Return Value :

	TRUE if good
	FALSE otherwise

--*/

	if( !CPacket::IsValidCompletion() )		{
		return	FALSE ;
	}
	if( m_pFIOContext == 0 )	{
		return	FALSE ;
	}
	if( m_pFIOContext->m_hFile == INVALID_HANDLE_VALUE ) 	{
		return	FALSE ;
	}
	if( m_cbOffset == UINT_MAX	)	{
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CRWPacket::IsCompleted()	{

	if( !IsValidCompletion() )	{
		return	FALSE ;
	}
	if( m_cbBytes != m_ibStartData - m_ibEndData )	{
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL	CTransmitPacket::IsCompleted()	{
	if( m_fRead )	{
		return	FALSE ;
	}
	if(	!IsValidCompletion() )	{
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL	CControlPacket::IsCompleted( )	{

	if( m_control.m_pio )
		return	FALSE ;
	return	TRUE ;
}



/*++

Routine description -

	Determine whether the packet is consumable - ie.
	can the data in the packet be only partly consumed
	by the CIO completion function.

	This is only TRUE of read packets, where we
	may use only a portion of the data in any IO completion.

Return Value :

	CReadPacket::FConsumable returns TRUE

	all others return FALSE.

--*/
BOOL
CReadPacket::FConsumable()	{
	return	TRUE ;
}

BOOL
CPacket::FConsumable()	{
	return	FALSE ;
}


/*++

Routine Description :

	Determine whether a packet can be used
	for Reads.
	This function is used to make sure that packets
	are delivered to the correct CStreams within CIODriver's.
	ie. we want to make sure that reads are processed
	by objects meant to process reads, etc...

Arguments :

	fRead - if TRUE then this packet is assumed to be a read

Return Value :

	TRUE if the packet is being used correctly.

--*/
BOOL	CReadPacket::FLegal( BOOL	fRead )	{
	return	fRead ;
}

BOOL	CWritePacket::FLegal(	BOOL	fRead )		{
	return	!fRead ;
}

BOOL	CTransmitPacket::FLegal(	BOOL	fRead )		{
	return	!fRead ;
}


BOOL	CReadPacket::InitRequest(	class	CIODriverSource&	driver,	CSessionSocket	*pSocket,	CIOPassThru*	pio, BOOL	&fAcceptRequests ) {
	return	pio->InitRequest( driver, pSocket, this, fAcceptRequests ) ;
}

unsigned
CReadPacket::Complete(	CIOPassThru*		pio,
						CSessionSocket*	pSocket,
						CPacket*	pPacket,
						BOOL&		fCompleteRequest
						)	{
/*++

Routine Description :

	This function is called by CIODriverSource's when an IO has
	completed.  Our job is to bump the member variables
	(ie. m_ibEndData) to indicate the number of bytes transferred
	and the call the CIO's completion function.

Arguments :

	pio - Reference to a pointer to the CIO object processing this data
	pSocket - Socket associated with the IO
	pPacket - The packet representing the request which started this
	fCompleteRequest - out parameter - set to TRUE when the pPacket
		has been completed and should be processed

Return Value :

	Number of bytes in the CReadPacket consumed.

--*/

	TraceFunctEnter( "CReadPacket::Complete" ) ;

	Assert( m_ibEndData == 0 || m_ibEndData == (m_ibStartData + m_cbBytes) || m_cbBytes == 0 ) ;
	m_ibEndData = m_ibStartData + m_cbBytes ;

	DebugTrace( (DWORD_PTR)this, "pbuffer %x ibStart %d ibEnd %d StartData %d EndData %d",
		(CBuffer*)m_pbuffer, m_ibStart, m_ibEnd, m_ibStartData, m_ibEndData ) ;

	Assert( IsValidCompletion() ) ;

	unsigned	cbConsumed = pio->Complete(	pSocket,	this,	pPacket,	fCompleteRequest ) ;
	m_ibStartData += cbConsumed ;

	DebugTrace( (DWORD_PTR)this, "CONSUMED %d ibStart %d ibEnd %d StartData %d EndData %d",
		cbConsumed, m_ibStart, m_ibEnd, m_ibStartData, m_ibEndData ) ;


#ifdef	CIO_DEBUG
	if( m_ovl.m_ovl.Offset != 0 )	{
		m_ovl.m_ovl.Offset += cbConsumed ;
	}
#endif
	return	cbConsumed ;
}

unsigned
CReadPacket::Complete(
					CIO*		&pio,
					CSessionSocket*	pSocket
					) {
/*++

Routine Description :

	Called by a CIODriver object when a read has completed, we bump
	m_ibEndData to match the number of bytes read, and the call the
	correct CIO completion function.

Arguments :

	pio - an OUT parameter passed to CIO::Complete, which the CIO object
		can use to set the next CIO object.

	pSocket - socket associated with this stuff

Return Value :

	Number of bytes in the packet consumed.

--*/

	TraceFunctEnter( "CReadPacket::Complete" ) ;

	Assert( m_ibEndData == 0 || m_ibEndData == (m_ibStartData + m_cbBytes) || m_cbBytes == 0 ) ;
	m_ibEndData = m_ibStartData + m_cbBytes ;
	Assert( IsValidCompletion() ) ;

	DebugTrace( (DWORD_PTR)this, "pbuffer %x ibStart %d ibEnd %d StartData %d EndData %d",
		(CBuffer*)m_pbuffer, m_ibStart, m_ibEnd, m_ibStartData, m_ibEndData ) ;

	unsigned	cbConsumed = pio->Complete( pSocket, this, pio ) ;
	m_ibStartData += cbConsumed ;

	DebugTrace( (DWORD_PTR)this, "CONSUMED %d ibStart %d ibEnd %d StartData %d EndData %d",
		cbConsumed, m_ibStart, m_ibEnd, m_ibStartData, m_ibEndData ) ;

#ifdef	CIO_DEBUG
	if( m_ovl.m_ovl.Offset != 0 )	{
		m_ovl.m_ovl.Offset += cbConsumed ;
	}
#endif
	return	cbConsumed ;
}

BOOL	CWritePacket::InitRequest(	class	CIODriverSource&	driver,	CSessionSocket	*pSocket,	CIOPassThru*	pio, BOOL	&fAcceptRequests ) {
	return	pio->InitRequest( driver, pSocket, this, fAcceptRequests ) ;
}


unsigned
CWritePacket::Complete(
					CIOPassThru*		pio,
					CSessionSocket*	pSocket,
					CPacket*	pPacket,
					BOOL&		fCompleteRequest
					)	{
/*++

Routine Description :

	This function is called by CIODriverSource's when an IO has
	completed.  Our job is to bump the member variables
	(ie. m_ibEndData) to indicate the number of bytes transferred
	and the call the CIO's completion function.

Arguments :

	pio - Reference to a pointer to the CIO object processing this data
	pSocket - Socket associated with the IO
	pPacket - The packet representing the request which started this
	fCompleteRequest - out parameter - set to TRUE when the pPacket
		has been completed and should be processed

Return Value :

	Number of bytes in the CReadPacket consumed.

--*/



	TraceFunctEnter( "CWritePacket::Complete" ) ;

	//Assert( m_ibEndData == m_ibStartData + m_cbBytes || m_cbBytes == 0 ) ;
	Assert( IsValidCompletion() ) ;

	DebugTrace( (DWORD_PTR)this, "pbuffer %x ibStart %d ibEnd %d StartData %d EndData %d",
		(CBuffer*)m_pbuffer, m_ibStart, m_ibEnd, m_ibStartData, m_ibEndData ) ;

	unsigned	cbConsumed = pio->Complete( pSocket,	this,	pPacket, fCompleteRequest ) ;
	m_ibStartData += cbConsumed ;

	DebugTrace( (DWORD_PTR)this, "CONSUMED %d ibStart %d ibEnd %d StartData %d EndData %d",
		cbConsumed, m_ibStart, m_ibEnd, m_ibStartData, m_ibEndData ) ;

#ifdef	CIO_DEBUG
	if( m_ovl.m_ovl.Offset != 0 )	{
		m_ovl.m_ovl.Offset += cbConsumed ;
	}
#endif
	return	cbConsumed ;
}

unsigned
CWritePacket::Complete(
				CIO*		&pio,
				CSessionSocket*	pSocket
				)	{
/*++

Routine Description :

	Called by a CIODriver object when a write has completed, we bump
	m_ibEndData to match the number of bytes read, and the call the
	correct CIO completion function.

Arguments :

	pio - an OUT parameter passed to CIO::Complete, which the CIO object
		can use to set the next CIO object.

	pSocket - socket associated with this stuff

Return Value :

	Number of bytes in the packet consumed.

--*/

	TraceFunctEnter( "CWritePacket::Complete" ) ;

	//Assert( m_ibEndData == m_ibStartData + m_cbBytes || m_cbBytes == 0 ) ;
	Assert( IsValidCompletion() ) ;

	DebugTrace( (DWORD_PTR)this, "pbuffer %x ibStart %d ibEnd %d StartData %d EndData %d",
		(CBuffer*)m_pbuffer, m_ibStart, m_ibEnd, m_ibStartData, m_ibEndData ) ;

	unsigned	cbConsumed = pio->Complete( pSocket,	this,	pio	) ;

	m_ibStartData += cbConsumed ;

	DebugTrace( (DWORD_PTR)this, "CONSUMED %d ibStart %d ibEnd %d StartData %d EndData %d",
		cbConsumed, m_ibStart, m_ibEnd, m_ibStartData, m_ibEndData ) ;

#ifdef	CIO_DEBUG
	if( m_ovl.m_ovl.Offset != 0 )	{
		m_ovl.m_ovl.Offset += cbConsumed ;
	}
#endif
	return	cbConsumed ;
}

BOOL	CTransmitPacket::InitRequest(	class	CIODriverSource&	driver,	CSessionSocket	*pSocket,	CIOPassThru*	pio, BOOL	&fAcceptRequests ) {
	return	pio->InitRequest( driver, pSocket, this, fAcceptRequests ) ;
}

unsigned	CTransmitPacket::Complete(	CIOPassThru*		pio,
									CSessionSocket*	pSocket,
									CPacket*	pPacket,
									BOOL&		fCompleteRequest )	{
	Assert( IsValidCompletion() ) ;

	pio->Complete(	pSocket, this, pPacket, fCompleteRequest ) ;
	return	m_cbBytes ;
}


unsigned
CTransmitPacket::Complete(
						CIO*		&pio,
						CSessionSocket*	pSocket
						)	{
/*++

Routine Description :

	Called by a CIODriver object when a TransmitFile has completed.
	We call the CIO objects completion function to do the main work.

Arguments :

	pio - an OUT parameter passed to CIO::Complete, which the CIO object
		can use to set the next CIO object.

	pSocket - socket associated with this stuff

Return Value :

	Number of bytes in the packet consumed.
	TransmitFile's cannot be partially consumed so the return value is
	always the same number of bytes as those sent.

--*/

	Assert( IsValidCompletion() ) ;
	pio->Complete( pSocket,	this,	pio	) ;
	return	m_cbBytes ;
}


unsigned
CControlPacket::Complete(
					CIOPassThru*		pio,
					CSessionSocket*	pSocket,
					CPacket*	pPacket,
					BOOL&		fCompleteRequest )	{

	Assert( 1==0 ) ;
	// Do NOT complete these
	//pio = m_pio ;
	return	m_cbBytes ;
}

unsigned
CControlPacket::Complete(
					CIO*&	pio,
					CSessionSocket*
					)	{
	Assert( 1==0 ) ;
	pio = m_control.m_pio ;
	return	m_cbBytes ;
}

void
CControlPacket::StartIO(
					CIO&	pio,
					BOOL	fStart
					)	{
/*++

Routine Description :

	This function is called when we want to setup a control
	packet to pass a CIO object into a CIODriver for processing.
	To ensure that only 1 thread is accessing CIODriver member
	variables etc... at a time, when we want to start a new
	CIO operation, we set up a packet and then process it as if
	it were a completed IO.  T

Arguments :

	pio - The CIO derived object we want to start
	fStart - Whether to call the CIO objects Start() function

Return Value :

	None.

--*/

	Assert( m_control.m_type == ILLEGAL );
	Assert( m_control.m_pio == 0 ) ;
	Assert(	m_control.m_fStart == FALSE ) ;

	m_control.m_type  = START_IO ;
	m_control.m_pio = &pio ;
	m_control.m_fStart = fStart ;
}

void
CControlPacket::StartIO(
				CIOPassThru&	pio,
				BOOL	fStart
				)	{
/*++

Routine Description :

	This function is called when we want to setup a control
	packet to pass a CIO object into a CIODriver for processing.
	To ensure that only 1 thread is accessing CIODriver member
	variables etc... at a time, when we want to start a new
	CIO operation, we set up a packet and then process it as if
	it were a completed IO.  T

Arguments :

	pio - The CIOPassThru derived object we want to start
	fStart - Whether to call the CIO objects Start() function

Return Value :

	None.

--*/


	Assert( m_control.m_type == ILLEGAL );
	Assert( m_control.m_pioPassThru == 0 ) ;
	Assert(	m_control.m_fStart == FALSE ) ;

	m_control.m_type = START_IO ;
	m_control.m_pioPassThru = &pio ;
	m_control.m_fStart = fStart ;
}

void
CControlPacket::Shutdown(
				BOOL	fCloseSource
				)	{
/*++

Routine Description :

	Set up a control packet so that when processed by a CIODriver
	the CIODriver will terminate all IO and shutdown.
	This is used whenever we want to drop a session.

Arguments :

	fCloseSource - if TRUE then we want the underlying socket or handle
		to be closed as well

Return Value :

	None.

--*/

	Assert( m_control.m_type == ILLEGAL );
	Assert( m_control.m_fCloseSource == FALSE ) ;

	m_control.m_type = SHUTDOWN ;
	m_control.m_fCloseSource = fCloseSource ;
}


unsigned
CExecutePacket::Complete(
			INOUT	CIO*&	pIn,
			IN CSessionSocket* pSocket
			) 	{
	pIn->Complete(	pSocket, this, pIn ) ;
	return	0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\packet.inl ===
inline	ExtendedOverlap::ExtendedOverlap() : 
/*++

Routine Description : 

	Build an extended overlap structure.
	Zero initialize.

Arguments : 

	None.

Return Value : 

	None.

--*/
	m_pHome( 0 ) {
	ZeroMemory( &m_ovl, sizeof( m_ovl ) ) ;
} 

inline	void*
CPacket::operator	new(	
					size_t	size,	
					CPacketCache*	pCache 
					) {
/*++

Routine Description : 

	Allocate memory for a CPacket object. If we can do so, 
	get the memory from the cache.

Arguments : 

	size - size of packet object
	pCache - optionally present pointer to a Cache to use

Return Value  : 

	Memory allocated for the CPacket object.

--*/

	if( pCache ) {
		return	pCache->Alloc( size ) ;
	}
	return	gAllocator.Allocate( size ) ;
}

inline	void
CPacket::operator	delete(	
						void	*pv 
						)	{
/*++

Routine Description : 

	Usually in C++ operator delete releases the memory for an object, 
	however since we want to do fancy memory management we 
	want to control how the memory is released more directly.
	SO, delete does NOTHING.  this means a delete of a CPacket
	will call the desctructor, however the caller still gets 
	to free the memory.

	Note : You can call desctructors directly in C++, however
	since there are several derived classes of CPacket, there
	is no good way to know which desctructor to call other than
	to let the compiler handle it.

	So after the caller uses delete on a CPacket to invoke
	the correct desctructor, they must then release the memory
	however they wish to do so.

Arguments : 

	pv - address of object we wont release

Return Value  :

	None.

--*/

}

inline	CPacket::CPacket(	CIODriver&	driver, BOOL fRead, BOOL fSkipQueue ) : 
/*++

Routine Desctiption : 

	Build a base CPacket object.
	We always start out knowing who our 'owner' is - 
	this is the CIODriver which will handle our completion 
	processing.

Arguments : 

	driver - CIOdriver which will handle IO completion processing 
		of this packet
	fRead - is this a read or write packet ?

Return Value : 

	None.

--*/
	m_pOwner( &driver ), 
	m_fRequest( TRUE ), 
	m_fSkipQueue( fSkipQueue ),
	m_cbBytes( 0 ),
	m_fRead( fRead ),
	m_dwExtra1( 0 ),
	m_dwExtra2( 0 ),
	m_pFileChannel( 0 )
{
	ASSIGNI( m_sequenceno, (DWORD)INVALID_SEQUENCENO ) ;
	ASSIGNI( m_iStream, (DWORD)INVALID_STRMPOSITION  ) ; 
}

inline	CPacket::CPacket(	CIODriver&	driver,	CPacket&	packet ) : 
/*++

Routine description : 

	Build a CPacket object which is a clone of another,
	however we may have a different owner.

Arguments : 

	driver - our owner
	packet - the packet we are to otherwise clone.

Return Value : 

	None.

--*/
	m_pOwner( &driver ), 
	m_fRequest( TRUE ),	
	m_cbBytes( packet.m_cbBytes ),
	m_fRead( packet.m_fRead ),
	m_dwExtra1( 0 ),
	m_dwExtra2( 0 ),
	m_pFileChannel( 0 )	{

	ASSIGNI( m_sequenceno, (DWORD)INVALID_SEQUENCENO );
	ASSIGNI( m_iStream, (DWORD)INVALID_STRMPOSITION );

	_ASSERT( EQUALSI( packet.m_iStream, (DWORD)INVALID_STRMPOSITION ) );
	_ASSERT( packet.m_fRequest == TRUE ) ;
	_ASSERT( !EQUALSI( packet.m_sequenceno, (DWORD)INVALID_SEQUENCENO ) );
}

inline	CPacket::~CPacket(	)	{
/*++

Routine Description : 

	Destroy a CPacket.

Arguments : 

	None.

Return Value : 

	NOne.

--*/
}

inline	BOOL	CPacket::operator>(	
						CPacket&	rhs 
						)	{
/*++

Routine Description : 

	Determine which if the Left Hand Side packet
	has a larger sequence number

Arguments : 

	rhs - packet on the Right Hand Side of a 'b>c' expression

Return Value : 

	TRUE if this packet has a larger sequenceno

--*/
	return	GREATER( m_sequenceno, rhs.m_sequenceno ) ;
}

inline	BOOL	CPacket::operator<( 
						CPacket&	rhs 
						)	{
/*++

Routine Description : 

	Does this packet have a smaller sequence number ?

Arguments : 

	rhs - Right hand side of b<c expression

Returns : 

	TRUE if this has a smaller sequence number

--*/
	return	LESSER( m_sequenceno, rhs.m_sequenceno ) ;
}

inline	CReadPacket*	CPacket::ReadPointer()	{
/*++

Routine Description : 

	Occassionally we are dealing with a packet through
	a pointer to a derived class, and we want to know 
	which of the derived classes the pointer is.
	In CReadPacket this will be overridden to return 
	the CReadPacket pointer.

Arguments : 

	NOne.

Return Value : 

	Always NULL.

--*/
	return	0 ;
}

inline	CWritePacket*	CPacket::WritePointer()	{
/*++

Routine Description : 

	Occassionally we are dealing with a packet through
	a pointer to a derived class, and we want to know 
	which of the derived classes the pointer is.
	In CWritePacket this will be overridden to return 
	the CWritePacket pointer.

Arguments : 

	NOne.

Return Value : 

	Always NULL.

--*/

	return	0 ;
}

inline	CTransmitPacket*	CPacket::TransmitPointer()	{
/*++

Routine Description : 

	Occassionally we are dealing with a packet through
	a pointer to a derived class, and we want to know 
	which of the derived classes the pointer is.
	In CTransmitPacket this will be overridden to return 
	the CTransmitPacket pointer.

Arguments : 

	NOne.

Return Value : 

	Always NULL.

--*/

	return	0 ;
}

inline	CControlPacket*		CPacket::ControlPointer()	{
/*++

Routine Description : 

	Occassionally we are dealing with a packet through
	a pointer to a derived class, and we want to know 
	which of the derived classes the pointer is.
	In CCOntrolPacket this will be overridden to return 
	the CControlPacket pointer.

Arguments : 

	NOne.

Return Value : 

	Always NULL.

--*/

	return	0 ;
}

inline	CRWPacket::CRWPacket(	
					CIODriver&	driver, 
					BOOL fRead 
					)	: 
/*++

Routine Description : 

	Create a default Read/Write packet.

Arguments : 

	driver - owning driver
	fRead - TRUE if this is a Read Packet

Return Value : 

	None.

--*/
	CPacket( driver, fRead ),	
	m_pbuffer( 0 ),	
	m_ibStart( 0 ),	
	m_ibEnd( 0 ),
	m_ibStartData( 0 ),	
	m_ibEndData( 0 )	{
}

inline	CRWPacket::CRWPacket(	
					CIODriver&	driver,	
					CBuffer&	pbuffer,	
					unsigned	size, 
					unsigned	cbTrailer, 
					BOOL fRead ) : 
/*++

Routine Description : 

	Create a default read/write packet with a provided buffer

Arguments : 

	driver - owning CIODriver
	pbuffer - buffer we will use
	size - size of our buffer
	fRead - TRUE if this is a read

Return Value : 

	None.

--*/
	CPacket( driver, fRead ),	
	m_pbuffer(	&pbuffer ),	
	m_ibStart( 0 ),
	m_ibEnd( size - cbTrailer ),	
	m_ibStartData( 0 ),	
	m_ibEndData( 0 ),
	m_cbTrailer( cbTrailer )	{
}

inline	CRWPacket::CRWPacket(	
						CIODriver&	driver,
						CBuffer&	pbuffer,	
						unsigned	ibStartData,	
						unsigned	ibEndData, 
						unsigned	ibStart, 
						unsigned	ibEnd, 
						unsigned	cbTrailer,
						BOOL fRead ) : 
/*++

Routine description : 

	Create a CRWPacket with all the fields full initiazlied

Arguments : 

	driver - owning driver
	pbuffer - buffer this packet is using
	ibStartData - start of data within buffer
	ibEndData - end of data within buffer
	ibStart - start offset within buffer we can use
	ibEnd - end offset within buffer we can use
	fRead - TRUE if this will be a read packet

Return Value : 

	None.

--*/
	CPacket( driver, fRead ) , 
	m_pbuffer( &pbuffer ), 
	m_ibStartData( ibStartData ), 
	m_ibEndData( ibEndData ),
	m_ibStart( ibStart ),	
	m_ibEnd( ibEnd ),
	m_cbTrailer( cbTrailer ) {

	_ASSERT( m_ibStart <= m_ibStartData ) ;
	_ASSERT(	m_ibEnd >= m_ibEndData ) ;
	_ASSERT(	m_ibStart <= m_ibEnd ) ;
	_ASSERT(	m_ibStartData <= m_ibEndData ) ;
	_ASSERT(	m_ibEnd + m_cbTrailer <= pbuffer.m_cbTotal ) ;
}

inline	CRWPacket::CRWPacket(	
					CIODriver&	driver,	
					CRWPacket&	packet 
					) : 
/*++

Routine Description : 

	Build a packet that is a clone of another except for 
	who the owning driver is

Arguments : 

	driver - owning driver
	packet - packet to be cloned

Return Value : 

	None.

--*/
	CPacket( driver, packet ), 
	m_pbuffer( packet.m_pbuffer ), 
	m_ibStartData( packet.m_ibStartData ),
	m_ibEndData( packet.m_ibEndData ), 
	m_ibStart( packet.m_ibStart ), 
	m_ibEnd( packet.m_ibEnd )	{
}
	

inline	CRWPacket::~CRWPacket()		{
}

inline	char*	CRWPacket::StartData(	
							void 
							)	{
/*++

Routine Description : 

	Get the address of the first byte with data in it.

Arguments : 

	None.

Return Value : 

	pointer to First usefull byte.

--*/
	
	_ASSERT( m_pbuffer != 0 ) ;
	return	&m_pbuffer->m_rgBuff[ m_ibStartData ] ;	
}

inline	char*	CRWPacket::EndData(	void )	{
/*++

Routine Description : 

	Get the address of the byte following the last byte with data in it.

Arguments : 

	None.

Return Value : 

	pointer to one beyond last byte with data

--*/

	_ASSERT(	m_pbuffer != 0 ) ;
	return	&m_pbuffer->m_rgBuff[ m_ibEndData ] ;
}

inline	char*	CRWPacket::Start( void )	{
/*++

Routine Description : 

	Get the address of the first byte we may mess with

Arguments : 

	None.

Return Value : 

	pointer to First usable byte

--*/

	_ASSERT(	m_pbuffer != 0 ) ;
	return	&m_pbuffer->m_rgBuff[ m_ibStart ] ;
}

inline	char*	CRWPacket::End( void )	{
/*++

Routine Description : 

	Get the address of the byte following the last byte we can use

Arguments : 

	None.

Return Value : 

	pointer to one beyond last usefull byte

--*/

	_ASSERT(	m_pbuffer != 0 ) ;
	return	&m_pbuffer->m_rgBuff[ m_ibEnd ] ;
}

inline	CReadPacket::CReadPacket(	
						CIODriver&	driver 
						) : 
/*++

Routine Description :

	Build a CReadPacket with the specified owner

Arguments : 

	driver - owning CIODriver, will do completion processing of packet

Return Value :

	None.

--*/
	CRWPacket( driver, TRUE )	{
	m_ovl.m_pHome = this ;
}

inline	CReadPacket::CReadPacket(	
					CIODriver& driver,	
					unsigned	size,
					unsigned	cbFront,	
					unsigned	cbTrailer,	
					CBuffer& pbuffer
					) : 
/*++

Routine Description : 

	Build a CReadPacket with the specified buffer and
	with the usefull area of the buffer restricted

Arguments : 

	driver - ownding CIODriver
	size - size of the buffer
	cbFront - padding space at front of buffer
	cbTail - padding space at tail of buffer
	pbuffer - buffer to use

Return Value : 

	None.
		
--*/
	CRWPacket( driver, pbuffer, size, cbTrailer, TRUE )	{
	m_ovl.m_pHome = this ;
	//	pbuffer should be initialized by CRWPacket() constructor !
	_ASSERT( cbFront < size ) ;
	_ASSERT( cbFront < m_pbuffer->m_cbTotal ) ;
	if( m_pbuffer != 0 )	{
		m_ibStartData += cbFront ;
	}
}

inline	CReadPacket::CReadPacket(	
					CIODriver&	driver,	
					CReadPacket&	packet 
					) : 
/*++

Routine description : 

	Build a CReadPacket that clones another CReadPacket

Arguments : 

	driver - owning driver object
	packet - packet to be cloned

Return Value : 

	None.

--*/
	CRWPacket( driver, packet ) {
	m_ovl.m_pHome = this ;
}

inline	CReadPacket::~CReadPacket()		{
}

inline	CReadPacket*	CReadPacket::ReadPointer()	{
	return	this ;
}

inline	CWritePacket::CWritePacket(	
				CIODriver	&driver,	
				CBuffer&	pbuffer,	
				unsigned	ibStartData, 
				unsigned ibEndData, 
				unsigned	ibStart,	
				unsigned	ibEnd,
				unsigned	cbTrailer
				) : 
/*++

Routine Description : 

	Build a CWritePacket.

Arguments : 

	driver - owning driver
	pbuffer - buffer to be used
	ibStartData - offset of data to be sent within buffer
	ibEndData - offset of last byte of data
	ibStart - Start of usable portion of buffer
	ibEnd - End of usable portion of buffer

Returns : 

	Nothing

--*/
	CRWPacket( driver, pbuffer, ibStartData, ibEndData, ibStart, ibEnd, cbTrailer )	{
	m_ibEndData = ibEndData ;
	m_ovl.m_pHome = this ;
}

inline	CWritePacket::CWritePacket(	
						CIODriver	&driver,	
						CWritePacket&	packet 
						) : 
/*++

Routine Description : 

	Build a CWritePacket cloned from another

Arguments : 

	driver - owning CIODriver
	packet - CWritePacket to clone

Returns : 

	Nothing

--*/
	CRWPacket( driver, packet ) {
	m_ovl.m_pHome = this ;
}

inline	CWritePacket::~CWritePacket()	{
}

inline	CWritePacket*	CWritePacket::WritePointer()	{
	return	this ;
}

inline	CTransmitPacket::CTransmitPacket(	
		CIODriver&	driver,	
		FIO_CONTEXT*	pFIOContext,
		unsigned	ibOffset, 
		unsigned	cbLength 
		) : 
/*++

Routine Description ; 

	Build a CTransmitPacket

Arguments : 

	driver - owning driver
	hFile - file to transmit
	ibOffset - first byte of file to send
	cbLength - number of bytes in file to send

Return Value : 

	None.

--*/
	CPacket( driver, FALSE ), 
	m_pFIOContext( pFIOContext ), 
	m_cbOffset( ibOffset ),
	m_cbLength( cbLength )  {
	m_ovl.m_pHome = this ;
	ZeroMemory( &m_buffers, sizeof( m_buffers ) ) ;
}

inline	CTransmitPacket::CTransmitPacket(	
			CIODriver&	driver,	
			CTransmitPacket&	packet 
			) : 
/*++

Routine Description : 

	Build a CTransmitPacket which clones another

Arguments : 

	driver - owning CIODriver
	packet - packet to clone

Return Value : 

	None.

--*/
	CPacket( driver, packet ), 
	m_pFIOContext( packet.m_pFIOContext ), 
	m_cbOffset( packet.m_cbOffset ), 
	m_cbLength( packet.m_cbLength ), 
	m_buffers( packet.m_buffers ) {
	m_ovl.m_pHome = this ;
}

inline	CTransmitPacket::~CTransmitPacket()	{
}

inline	CTransmitPacket*	CTransmitPacket::TransmitPointer()	{
	return	this ;
}

inline	CControlPacket::CControlPacket( 
		CIODriver&	driver 
		)	: 
/*++

Routine Description : 

	Build a CControlPacket

Arguments : 

	driver - owning driver, will do completion processing of this packet

Return Value : 

	None.

--*/
	CPacket( driver, FALSE )	{

	m_fRequest = FALSE ;

}

inline	BOOL	
CControlPacket::FLegal( 
					BOOL	fRead 
					)	{
	return	TRUE ;
}

inline	BOOL	
CControlPacket::IsValidRequest(	
				BOOL	fReadsRequireBuffers 
				)	{
/*++

Routine Description : 

	Check that the control packet is legally setup

Arguments : 

	fReadsRequireBuffers - TRUE indicates this CIODriver does not require
		that buffers be pre-allocated for reads
		we can ignore this.

Return Value : 

	TRUE if setup

--*/


	if( m_control.m_type != START_IO &&
		m_control.m_type != SHUTDOWN ) {
		return	FALSE ;
	}
	if( m_control.m_type == START_IO ) {
		if( m_control.m_pio == 0 &&
			m_control.m_pioPassThru == 0 ) 
			return	FALSE ;
		if( m_control.m_pio != 0 &&
			m_control.m_pioPassThru != 0 ) 
			return	FALSE ;
	}
	return	TRUE ;
}

inline	void	
CControlPacket::Reset(	)	{
/*++

Routine description : 

	Put a control packet back into a just created state

Arguments : 
	
	none.

Return Value : 

	none.

--*/

	_ASSERT( IsValidRequest( TRUE ) ) ;

	m_control.m_type = ILLEGAL ;
	m_control.m_pio = 0 ;
	m_control.m_pioPassThru = 0 ;
	m_control.m_fStart = FALSE ;

}

inline	CControlPacket*	CControlPacket::ControlPointer()	{
	return	this ;
}	

inline	BOOL	CPacket::IsValid() {
	if( m_ovl.m_pHome != this )		{
		return	FALSE ;
	}
	return	TRUE ;
}

	

inline	void
CPacket::ForwardRequest( 
				CSessionSocket*	pSocket 
				)	{
/*++

Routine description : 

	THis function will get the packet processed as if it has
	just completed.

Arguments : 

	pSocket - the CSessionSocket which this IO is associated with.

Return Value : 

	None.

--*/
	_ASSERT( !m_fRequest ) ;
	_ASSERT( pSocket != 0 ) ;

	if( m_fRead ) 
		m_pOwner->m_pReadStream->ProcessPacket( this, pSocket ) ;
	else
		m_pOwner->m_pWriteStream->ProcessPacket( this, pSocket ) ;
}



inline	BOOL	CReadPacket::IsValid() {
	return	TRUE ;
}

inline	BOOL	CWritePacket::IsValid()		{
	return	TRUE ;
}

inline	BOOL	CTransmitPacket::IsValid()	{
	return	TRUE ;
}

inline	
CExecutePacket::CExecutePacket(	CIODriver&	driver )	: 
	CPacket( driver, FALSE, TRUE ),
	m_cbTransfer( 0 ),
	m_fComplete( FALSE ),
	m_fLargerBuffer( FALSE ),
	m_pWrite( 0 )	{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\passthru.cpp ===
#define	SECURITY_WIN32
#include	<buffer.hxx>

#define	INCL_INETSRV_INCS
#include	"tigris.hxx"

/*
extern	"C"	{
#include <rpc.h>
#include <sspi.h>
#include <spseal.h>
#include <issperr.h>
#include <ntlmsp.h>
#include <sslsp.h>
}

#include	"sslmsgs.h"
*/

CIOPassThru::CIOPassThru() : CIO( 0 ) {
}

BOOL
CIOPassThru::InitRequest(	CIODriverSource&	driver,	CSessionSocket*	pSocket, CReadPacket*	pPacket,	BOOL	&fAcceptRequests ) {

	fAcceptRequests = TRUE ;
	CReadPacket*	pRead = driver.Clone( pPacket ) ;

	if( pRead != 0 ) {
		BOOL	eof ;
		driver.IssuePacket( pRead, pSocket, eof ) ;
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CIOPassThru::InitRequest(	CIODriverSource&	driver,	CSessionSocket*	pSocket, CWritePacket*	pWritePacket,	BOOL	&fAcceptRequests ) {
	fAcceptRequests = TRUE ;

	CWritePacket*	pWrite = driver.Clone( pWritePacket ) ;
	if( pWrite != 0 ) {
		BOOL	eof ;
		driver.IssuePacket( pWrite, pSocket, eof ) ;
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CIOPassThru::InitRequest(	CIODriverSource&	driver,	CSessionSocket*	pSocket, CTransmitPacket*	pTransmitPacket,	BOOL	&fAcceptRequests ) {
	fAcceptRequests = TRUE ;

	CTransmitPacket*	pTransmit = driver.Clone( pTransmitPacket ) ;
	if( pTransmit != 0 ) {
		BOOL	eof ;
		driver.IssuePacket( pTransmit, pSocket, eof ) ;
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CIOPassThru::Start(	CIODriverSource&	driver,	CSessionSocket*	pSocket,	
						BOOL&	fAcceptRequest,	BOOL&	fRequireRequests,	unsigned	cAhead  ) {

	fAcceptRequest = TRUE ;
	fRequireRequests = TRUE ;

	return	TRUE ;
}

BOOL
CIOPassThru::Start( CIODriver&	driver,	CSessionSocket*	pSocket, unsigned	cAhead ) {
	_ASSERT( 1==0 ) ;
	return	FALSE ;
}

int
CIOPassThru::Complete(	
				CSessionSocket*	pSocket,	
				CReadPacket*	pPacket,	
				CPacket*	pRequest,	
				BOOL	&fComplete
				) {

	fComplete = TRUE ;
	
	pRequest->m_cbBytes = pPacket->m_cbBytes ;

	return	pPacket->m_cbBytes ;
}	
		

int	
CIOPassThru::Complete(	
				CSessionSocket*	pSocket,	
				CWritePacket*	pPacket,	
				CPacket*	pRequest,	
				BOOL&	fComplete
				) {

	fComplete = TRUE ;

	pRequest->m_cbBytes = pPacket->m_cbBytes ;

	return	pPacket->m_cbBytes ;
}

void
CIOPassThru::Complete(	
				CSessionSocket*	pSocket,	
				CTransmitPacket*	pPacket,	
				CPacket*	pRequest,	
				BOOL&	fComplete
				)		{

	fComplete = TRUE ;

	pRequest->m_cbBytes = pPacket->m_cbBytes ;
	pRequest->m_ovl.m_ovl = pPacket->m_ovl.m_ovl ;

}

CIOSealMessages::CIOSealMessages( CEncryptCtx& encrypt ) :
	m_encrypt( encrypt )
{
}

void
CIOSealMessages::Shutdown(
			CSessionSocket*	pSocket,
			CIODriver&		driver,
			enum	SHUTDOWN_CAUSE	cause,
			DWORD			dw
			) {

}

BOOL
CIOSealMessages::InitRequest(	
						CIODriverSource&	driver,	
						CSessionSocket*	pSocket,
						CWritePacket*	pWritePacket,	
						BOOL	&fAcceptRequests
						) {

	fAcceptRequests = TRUE ;

	CWritePacket*	pWrite = driver.Clone( pWritePacket ) ;
	if( pWrite != 0 ) {
		BOOL	eof ;

		if( !SealMessage(	pWrite ) )		{

			_ASSERT( 1==0 ) ;

		}	else	{
			pWrite->m_pSource = pWritePacket->m_pOwner ;
			driver.IssuePacket( pWrite, pSocket, eof ) ;
			return	TRUE ;
		}
	}
	if( pWrite ) {
		//delete	pWrite ;
		CPacket::DestroyAndDelete( pWrite ) ;
	}
	return	FALSE ;
}

BOOL
CIOSealMessages::Start(	
						CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						BOOL&	fAcceptRequest,	
						BOOL&	fRequireRequests,	
						unsigned	cAhead
						) {

	fAcceptRequest = TRUE ;
	fRequireRequests = TRUE ;

	return	TRUE ;
}

int	
CIOSealMessages::Complete(	
					CSessionSocket*	pSocket,	
					CWritePacket*	pPacket,	
					CPacket*	pRequest,	
					BOOL&	fComplete
					) {

	fComplete = TRUE ;

	// As far as the requestor is concerned there are no additional bytes !
	CWritePacket*	pWritePacket = pRequest->WritePointer() ;
	if( pWritePacket )	{
		pWritePacket->m_cbBytes = pWritePacket->m_ibEndData - pWritePacket->m_ibStartData ;
	}	else	{
		_ASSERT( 1==0 ) ;
		// May eventually handle TransmitPackets here !!
	}
	return	pPacket->m_cbBytes ;
}

CIOUnsealMessages::CIOUnsealMessages( CEncryptCtx&	encrypt ) :
	m_encrypt( encrypt ),
	m_pbuffer( 0 ),
	m_ibStart( 0 ),
	m_ibStartData( 0 ),
	m_ibEnd( 0 ),
	m_ibEndData( 0 ) ,
	m_cbRequired( 0 )
{
}

void
CIOUnsealMessages::Shutdown(
			CSessionSocket*	pSocket,
			CIODriver&		driver,
			enum	SHUTDOWN_CAUSE	cause,
			DWORD			dw
			) {

}

BOOL
CIOUnsealMessages::InitRequest(	
					CIODriverSource&	driver,	
					CSessionSocket*	pSocket,
					CReadPacket*	pReadPacket,	
					BOOL	&fAcceptRequests
					) {

	fAcceptRequests = TRUE ;

	CReadPacket*	pRead = driver.Clone( pReadPacket ) ;
	if( pRead != 0 ) {
		BOOL	eof ;
		pRead->m_pSource = pReadPacket->m_pOwner ;
		driver.IssuePacket( pRead, pSocket, eof ) ;
		return	TRUE ;
	}
	if( pRead ) {
		//delete	pRead;
		CPacket::DestroyAndDelete( pRead ) ;
	}				
	return	FALSE ;
}

BOOL
CIOUnsealMessages::Start(	CIODriverSource&	driver,	CSessionSocket*	pSocket,	
						BOOL&	fAcceptRequest,	BOOL&	fRequireRequests,	unsigned	cAhead  ) {
	fAcceptRequest = TRUE ;
	fRequireRequests = TRUE ;


	//driver.SetChannelDebug( 3 ) ;

	return	TRUE ;
}


BOOL	
CIOUnsealMessages::DecryptInputBuffer(	
					IN	LPBYTE	pBuffer,
					IN	DWORD	cbInBuffer,
					OUT	DWORD&	cbLead,
					OUT	DWORD&	cbConsumed,
					OUT	DWORD&	cbParsable,
					OUT	DWORD&	cbRequired,
					OUT	BOOL&	fComplete
					)	{

	LPBYTE	lpDecrypted;
	LPBYTE	lpRemaining = pBuffer ;
	LPBYTE	lpEnd = pBuffer + cbInBuffer ;
	DWORD	cbDecrypted;
	DWORD	cbOriginal = cbInBuffer ;
	LPBYTE	pNextSeal = 0 ;
	BOOL	fRet ;
	//DWORD	cbParsable = 0;
	

	//
	// initialize to zero so app does not inadvertently post large read
	//
	cbLead = 0 ;
	cbParsable = 0 ;
	cbRequired = 0 ;
	fComplete = FALSE ;
	cbConsumed = 0 ;
	

	TraceFunctEnterEx( (LPARAM)this, "CIOUnsealMessagse::DecryptInputBuffer" );

	while( cbInBuffer &&
			(fRet = m_encrypt.UnsealMessage(	lpRemaining,
										cbInBuffer,
										&lpDecrypted,
										&cbDecrypted,
										&cbRequired,
										&pNextSeal )) )
	{
	    _ASSERT( cbRequired < 32768 );
		DebugTrace( (LPARAM)this,
					"Decrypted %d bytes at offset %d",
					cbDecrypted,
					lpDecrypted - pBuffer );

		fComplete = TRUE ;

		if( cbLead == 0 ) {
			cbLead = (DWORD)(lpDecrypted - pBuffer) ;
		}	else	{

			//
			// overwrite the encryption header -
			//	NOTE - only move the decrypted bytes !!
			//
			MoveMemory( pBuffer + cbLead + cbParsable,
						lpDecrypted,
						cbDecrypted );
		}

		//
		// increment where the next parsing should take place
		//
		cbParsable += cbDecrypted;

		//
		//	move to the next potential seal buffer
		//
		if( pNextSeal != NULL ) {

			_ASSERT( pNextSeal > lpRemaining );
			_ASSERT( pNextSeal <= lpRemaining + cbInBuffer );
			//
			// remove header, body and trailer from input buffer length
			//
			cbInBuffer -= (DWORD)(pNextSeal - lpRemaining);
			lpRemaining = pNextSeal ;

		}	else	{
			//
			// in this case we received a seal message at the boundary
			// of the IO buffer
			//
			cbInBuffer = 0;
			lpRemaining = lpEnd ;
		}
	}

	DebugTrace( (LPARAM)this,
				"UnsealMessage returned: 0x%08X",
				GetLastError() );

	cbConsumed = (DWORD)(lpRemaining - pBuffer) ;

	if( fRet == FALSE ) {

		DWORD	dwError = GetLastError();

		DebugTrace( (LPARAM)this,
					"UnsealMessage returned: 0x%08X",
					GetLastError() );

		//
		// deal with seal fragments at the end of the IO buffer
		//
		if ( dwError == SEC_E_INCOMPLETE_MESSAGE )	{
			_ASSERT( cbInBuffer != 0 );

			//
			// move the remaining memory forward
			//
			DebugTrace( (LPARAM)this,
						"Seal fragment remaining: %d bytes",
						cbInBuffer );
		}	else	if( dwError != NO_ERROR ) 	{
			return	FALSE;
		}
	}
	return	TRUE ;
}



int	
CIOUnsealMessages::Complete(	
					CSessionSocket*	pSocket,	
					CReadPacket*	pPacket,
					CPacket*	pRequest,	
					BOOL&	fComplete
					) {
/*++

Routine Description :

	A read has completed, and we wish to figure out if we can unseal the data.
	This function will attempt to unseal the data when it has accumulated
	enough bytes to build one SSL packet.

Arguments :

	pSocket - The socket the IO is happening on
	pPacket - The packet which completed
	pRequest - The packet where we will put the unseal'd data for further
		processing
	fComplete - OUT parameter, we set this to true when we have
		been able to unseal the data and put this in pRequest

Return Value :

	Number of bytes of the completed read packet which we consumed

--*/

	DWORD	cbReturn = 0 ;
	
	if( m_pbuffer != 0 ) {
	
		DWORD	cbToCopy = 0 ;		
		if( m_cbRequired == 0 ) {
			cbToCopy = min( min( 32, pPacket->m_cbBytes ), (m_ibEnd - m_ibEndData) ) ;
		}	else	{

			cbToCopy = min( m_cbRequired, pPacket->m_cbBytes ) ;

			_ASSERT( m_ibEnd <= m_pbuffer->m_cbTotal ) ;
			_ASSERT( cbToCopy < (m_ibEnd - m_ibEndData) ) ;

			m_cbRequired -= cbToCopy ;
		}
		_ASSERT( cbToCopy <= m_ibEnd - m_ibEndData ) ;
		_ASSERT( m_ibEnd >= m_pbuffer->m_cbTotal ) ;
		CopyMemory( &m_pbuffer->m_rgBuff[ m_ibEndData ], pPacket->StartData(), cbToCopy ) ;
		m_ibEndData += cbToCopy ;		
		cbReturn = cbToCopy ;
	}	else	{
		m_pbuffer = pPacket->m_pbuffer ;
		_ASSERT( m_cbRequired == 0 ) ;
		m_ibStart = pPacket->m_ibStart ;
		m_ibEnd = pPacket->m_ibEnd ;
		m_ibStartData = pPacket->m_ibStartData ;
		m_ibEndData = pPacket->m_ibEndData ;
		_ASSERT( m_cbRequired == 0 ) ;	// Set to 0 on last packet we succesfully unsealed !
	}

	if( m_cbRequired == 0 ) {
		DWORD	cbConsumed = 0 ;
		DWORD	ibStartData = 0 ;
		DWORD	ibEndData = 0 ;
		DWORD	cbData = 0 ;
		fComplete = FALSE ;


		BOOL	fSuccess = DecryptInputBuffer(
										(LPBYTE)&m_pbuffer->m_rgBuff[m_ibStartData],
										m_ibEndData - m_ibStartData,
										ibStartData,
										cbConsumed,
										cbData,
										m_cbRequired,
										fComplete
										) ;
        _ASSERT( m_cbRequired < 32768 );
		ibStartData += m_ibStartData ;
		ibEndData = ibStartData + cbData ;
		DWORD	ibEnd = m_ibStartData + cbConsumed ;

		_ASSERT( ibEndData <= ibEnd ) ;
		_ASSERT( ibStartData <= ibEndData ) ;

		if( !fSuccess )	{
			DWORD	dw = GetLastError() ;
	
			//
			//	Fatal error - blow off the session.
			//
			
			pPacket->m_pOwner->UnsafeClose( pSocket,	
											CAUSE_ENCRYPTION_FAILURE,
											dw ) ;											
			return	pPacket->m_cbBytes ;

		}	else	{

			//
			//	If we haven't figured out how many bytes we've used already
			//	than we'll use all of the bytes in the packet, we either
			//	decrypted some or will set aside the bytes we couldn't
			//	decrypt for the next try.
			//
			
			if( cbReturn == 0 ) {
				cbReturn = pPacket->m_cbBytes ;
			}


			if( fComplete ) {

				//
				//	We have successfully unsealed a bunch of data
				//	Mark the pRequest packet with the data we unsealed,
				//	and update our internal state.
				//
		
				_ASSERT( pRequest->ReadPointer() != 0 ) ;

				CReadPacket*	pReadRequest = (CReadPacket *)pRequest ;

				pReadRequest->m_pbuffer = m_pbuffer ;
				pReadRequest->m_ibStart = m_ibStart ;
				pReadRequest->m_ibStartData = ibStartData ;
				//pReadRequest->m_ibEndData = ibEndData ; Not needed !
				pReadRequest->m_ibEnd = ibEndData ;
				pReadRequest->m_cbBytes = ibEndData - ibStartData ;
				_ASSERT( cbData == pReadRequest->m_cbBytes ) ;

				if( ibEnd == m_ibEndData ) {
					m_pbuffer = 0 ;
					m_ibStart = m_ibStartData = m_ibEnd = m_ibEndData = 0 ;
				}	else	{
					m_ibStartData = ibEnd ;
					m_ibStart = ibEnd ;

				}

			}
			if( m_cbRequired != 0 ) {
				if( m_cbRequired > m_ibEnd - m_ibEndData ) {	
					//
					// Need to allocate a larger buffer and move the data there !!
					//

					DWORD	cbOldBytes = m_ibEndData - m_ibStartData ;
					DWORD	cbTotal = cbOldBytes + m_cbRequired ;					
					DWORD	cbOut = 0 ;

					CBuffer*	pbufferNew = new( cbTotal, cbOut )	CBuffer( cbOut ) ;

					_ASSERT( cbOldBytes < pbufferNew->m_cbTotal ) ;
					_ASSERT( cbTotal <= pbufferNew->m_cbTotal ) ;

					if( pbufferNew == 0 ) {
						//
						//	Fatal error - blow off the session !
						//
						pPacket->m_pOwner->UnsafeClose( pSocket,
														CAUSE_OOM,
														0 ) ;
						return	pPacket->m_cbBytes ;

					}	else	{
						//
						//	We have a buffer large enough to hold the entire
						//	Seal'd message, so copy the fraction we have into
						//	the buffer, and set things up so that future read
						//	completions will append to this buffer.
						//
						CopyMemory( &pbufferNew->m_rgBuff[0],
									&m_pbuffer->m_rgBuff[m_ibStartData],
									cbOldBytes ) ;
						m_pbuffer = pbufferNew ;
						m_ibStart = 0 ;
						m_ibStartData = 0 ;
						m_ibEnd = pbufferNew->m_cbTotal ;
						m_ibEndData = cbOldBytes ;
					}
				}
			}
		}
	}

	//
	//	If we did not complete the request, issue another read
	//
	if( !fComplete ) {
		CReadPacket*	pRead = pPacket->m_pOwner->CreateDefaultRead( m_cbRequired ) ;

		if( pRead != 0 ) {
			pRead->m_pSource = pRequest->m_pOwner ;
			BOOL	eof ;
			pRead->m_pOwner->IssuePacket( pRead, pSocket, eof ) ;
		}	else	{

			//
			//	Fatal error, blow off the session.
			//
			pPacket->m_pOwner->UnsafeClose(	pSocket,
											CAUSE_OOM,
											0 ) ;
		}
	}


	_ASSERT( cbReturn != 0 ) ;
	return	cbReturn ;
}

DWORD	CIOTransmitSSL::MAX_OUTSTANDING_WRITES = 4 ;
DWORD	CIOTransmitSSL::RESTORE_FLOW = 1 ;

CIOTransmitSSL::CIOTransmitSSL(	
							CEncryptCtx&	encrypt,
							CIODriver&		sink
							) :
/*++

Routine Description :

	Construct a CIOTransmitSSL object.
	We will initialize ourselves into a neutral state,
	InitRequest must be called before we start transferring a file.

Arguments :

	encryp - The encryption context we should use
	sink -	The CIODriver managing our socket IO's

Return Value :

	none.

--*/
		m_encryptCtx( encrypt ),
		m_pSocketSink( &sink ),
		m_pbuffers( 0 ),
		m_cReads( 0 ),
		m_cWrites( 0 ),
		m_cWritesCompleted( 0 ),
		m_ibCurrent( 0 ),
		m_ibEnd( 0 ),
		m_cbTailConsumed( 0 ),
		m_fFlowControlled( FALSE ),
		m_cFlowControlled( LONG_MIN ),
		m_fCompleted( FALSE )	{

}

BOOL
CIOTransmitSSL::Start(	
						CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						BOOL&	fAcceptRequest,	
						BOOL&	fRequireRequests,	
						unsigned	cAhead
						) {

	fAcceptRequest = TRUE ;
	fRequireRequests = TRUE ;

	return	TRUE ;
}

void
CIOTransmitSSL::Shutdown(
			CSessionSocket*	pSocket,
			CIODriver&		driver,
			enum	SHUTDOWN_CAUSE	cause,
			DWORD			dw
			) {
/*++

Routine Description :

	This function is called to notify us of any IO errors that
	occurred.  If the error is serious, we will make sure everything
	gets torn down.  (IO's could fail on the file or socket, but not
	both.  If a failure of either occurs, tear down both.)

Arguments :

	pSOcket - Socket IO is associated with
	driver - The driver that is notifying us
	cause -	The reason we're being notified
	dw -	Optional DWORD, we ignore it

Return Value :
	
	None.

--*/

	if( cause != CAUSE_NORMAL_CIO_TERMINATION ) {

		Term( pSocket, cause, dw ) ;

	}

}

void
CIOTransmitSSL::ShutdownFunc(
			void*	pv,
			SHUTDOWN_CAUSE	cause,
			DWORD	dwError
			)	{

}	
			

void
CIOTransmitSSL::Reset()	{

	if( m_pFileChannel != 0 )	{
		m_pFileChannel->ReleaseSource() ;
	}

	m_pDriverSource = 0 ;

	m_pFileChannel = 0 ;
	m_pFileDriver = 0 ;
	m_pbuffers = 0 ;
	m_cReads = 0 ;
	m_cWrites = 0 ;
	m_cWritesCompleted = 0 ;
	m_ibCurrent = 0 ;
	m_ibEnd = 0 ;
	m_cbTailConsumed = 0 ;
	m_fFlowControlled = FALSE ;
	m_cFlowControlled = LONG_MIN ;
	m_fCompleted = FALSE ;	

}

void
CIOTransmitSSL::Term(
					CSessionSocket*	pSocket,	
					enum	SHUTDOWN_CAUSE	cause,
					DWORD	dwError
					)	{
/*++

Routine Description :

	Call the necessary UnsafeClose() functions to tear down sessions
	and CIODrivers.

Arguments :

	pSocket - Socket IO is associate with
	cause -		The reason for termination, if this is CAUSE_NORMAL_CIO_TERMINATION
				we don't tear down the socket, just the file IO
	dwError - optional DWORD

Returns

	Nothing

--*/


	if( m_pFileDriver ) {
		m_pFileChannel->ReleaseSource() ;
		m_pFileDriver->UnsafeClose(
							pSocket,
							cause,	
							dwError
							) ;
	}

	if( cause != CAUSE_NORMAL_CIO_TERMINATION ) {

		if( m_pSocketSink ) {
			m_pSocketSink->UnsafeClose(
								pSocket,
								cause,
								dwError
								) ;
		}
	}	
}



BOOL
CIOTransmitSSL::InitRequest(
						CIODriverSource&	driver,
						CSessionSocket*		pSocket,
						CTransmitPacket*	pTransmitPacket,
						BOOL&				fAcceptRequests
						) {
/*++

Routine Description :

	We have received a Transmit File request - all the necessary
	CIODriver's etc... to manage async IO for the file.

Arguments :

	driver - CIODriverSource which received the request
	pSocket - socket we are doing the IO on
	pTransmitPacket - the request
	fAcceptRequests - OUT parameter indicating whether we
		can accept additional requests while a first is
		in progress.  We always set this to FALSE>

Return Value :
	
	TRUE if Successfull, FALSE otherwise.

--*/

	m_pbuffers = &pTransmitPacket->m_buffers ;

	fAcceptRequests = FALSE ;

	_ASSERT( m_pFileChannel == 0 ) ;
	_ASSERT( m_pFileDriver == 0 ) ;
	_ASSERT( m_cWrites == 0 ) ;
	_ASSERT( m_cWritesCompleted == 0 ) ;
	_ASSERT( m_ibCurrent == 0 ) ;
	_ASSERT( m_ibEnd == 0 ) ;
	_ASSERT( m_fCompleted == FALSE ) ;

	m_pSocketSink = &driver ;
	m_pDriverSource = pTransmitPacket->m_pOwner ;

	m_pFileChannel = new	CFileChannel( ) ;

	if( m_pFileChannel &&
		m_pFileChannel->Init(	pTransmitPacket->m_pFIOContext,
								pSocket,
								pTransmitPacket->m_cbOffset,
								TRUE,	
								pTransmitPacket->m_cbLength
								) )	{

		m_pFileDriver = new	CIODriverSink( driver.GetMediumCache() ) ;
		if( m_pFileDriver &&
			m_pFileDriver->Init(	m_pFileChannel,
									pSocket,
									CIOTransmitSSL::ShutdownFunc,
									(void*)this,
									m_encryptCtx.GetSealHeaderSize(),
									0,
									m_encryptCtx.GetSealTrailerSize()
									) )	{

			m_cWrites = 0 ;	
			m_cWritesCompleted = 0 ;
			m_ibCurrent = 0 ;
			m_ibEnd = pTransmitPacket->m_cbLength ;
			m_cbTailConsumed = 0 ;
			m_fCompleted = FALSE ;

			//
			//	All of our IO Drivers are ready to go -
			//	now we need to compute our initial member variables
			//	and start the transfer going.
			//

			if( m_pFileDriver->SendReadIO( pSocket, *this, TRUE ) ) {
				return	TRUE ;
			}
		}
	}

	m_pbuffers = 0 ;
	m_pFileChannel = 0 ;
	m_pFileDriver = 0 ;
	m_pSocketSink = 0 ;

	return	FALSE ;
}

BOOL	
CIOTransmitSSL::Start(	
				CIODriver&	driver,	
				CSessionSocket*	pSocket,
				unsigned cAhead
				)	{
/*++

Routine Description :

	This function is called when we're ready to start issuing async
	reads against the file.  We will issue a bunch to get us going.

Arguments :

	driver - the CIODriver letting us know we're ready
	pSocket - Socket the IO is associated with
	cAhead - how many reads are already outstanding against the file
		should always be zero

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/

	//
	//	FIRST - determine what we are going to do with transmit buffers !
	//

	BOOL	eof = FALSE ;
	CReadPacket*	pRead = 0 ;
	BOOL	fCompleted = FALSE ;

	DWORD	cbConsume = 0 ;

	m_cReads = -2 ;

	while( !m_fCompleted &&
			cAhead < 2 &&
			m_ibCurrent < m_ibEnd  )	{
		pRead = driver.CreateDefaultRead( cbMediumRequest ) ;

		if( pRead !=  0 ) {
			pRead->m_pSource = m_pDriverSource ;
			ComputeNextRead( pRead ) ;
			cAhead ++ ;
			m_cWrites ++ ;
			InterlockedIncrement( &m_cReads ) ;
			driver.IssuePacket( pRead, pSocket, eof ) ;
		}
	}	

	return	TRUE ;
}


void
CIOTransmitSSL::ComputeNextRead(	
						CReadPacket*	pRead
						) {
/*++

Routine Description :

	Figure out what the offsets of the next read will be.
	Since we know that File reads always fill their buffers, we
	can anticipate how many bytes we'll get, and advance
	m_ibCurrent to help figure out when we've issued enough reads.

Arguments :

	pRead - The read packet we'll be issuing

Return Value :

	None.

--*/

	if( m_cWrites == 0 ) {

		if( m_pbuffers->Head ) {
			
			CopyMemory( pRead->StartData(), m_pbuffers->Head, m_pbuffers->HeadLength ) ;
			pRead->m_ibStartData += m_pbuffers->HeadLength ;
			pRead->m_dwExtra1 = m_pbuffers->HeadLength ;

		}
	}

	DWORD	cbWillRead = min(	pRead->m_ibEnd - pRead->m_ibStartData,
								m_ibEnd - m_ibCurrent ) ;

	m_ibCurrent += cbWillRead ;

	pRead->m_dwExtra2 = m_ibCurrent ;

}

BOOL
CIOTransmitSSL::CompleteRead(
						CReadPacket*	pRead,
						CWritePacket*	pWrite
						)	{
/*++

Routine Description :

	Given a completed Read, adjust a Write Packet to account for
	any leading text in the packet, also figure out whether this
	was the last read issued.

Arguments :

	pRead - The read packet
	pWrite - The write we will be issuing

Return Value :

	TRUE if this was the last read

--*/

	if( pRead->m_dwExtra1 != 0 ) {
		_ASSERT( pRead->m_dwExtra1 <= pRead->m_ibStartData ) ;
		pWrite->m_ibStartData -= pRead->m_dwExtra1 ;
	}

	if( pRead->m_dwExtra2 == m_ibEnd )
		return	TRUE ;

	return	FALSE ;
}

int
CIOTransmitSSL::Complete(
					CSessionSocket*	pSocket,
					CReadPacket*	pRead,
					CIO*&			pio )	{
/*++

Routine Description :

	Process an async read that just completed from a file.

Arguments :

	pSocket - the socket we will be sending our data out on
	pRead - the read packet that just completed.
	pio - an out parameter allowing us to set the next CIO operation

Return Value :

	number of bytes consumed.

--*/

	BOOL	eof ;
	
	CWritePacket*	pExtraWrite = 0 ;

	InterlockedDecrement( &m_cReads ) ;
	
	//
	//	Check if we should do another read
	//
	if( !m_fCompleted &&
		m_ibCurrent < m_ibEnd ) {

		long sign = InterlockedIncrement( &m_cFlowControlled ) ;

		if( sign < 0 ) {

			do	{
				
				CReadPacket*	pNewRead = pRead->m_pOwner->CreateDefaultRead( cbMediumRequest ) ;
				
				if( pNewRead ) {
					pNewRead->m_pSource = m_pDriverSource ;
					ComputeNextRead( pNewRead ) ;
					pNewRead->m_pOwner->IssuePacket( pNewRead, pSocket, eof ) ;
					m_cWrites ++ ;
				}	else	{

					//	fatal error - blwo things off
					Term( pSocket, CAUSE_OOM, 0 ) ;
					pio = 0 ;
					return	pRead->m_cbBytes ;
	
				}
			}	while(
						InterlockedIncrement( &m_cReads ) < 0 &&
						!m_fCompleted &&
						m_ibCurrent < m_ibEnd ) ;
		}
	}

	//
	//	Build the write packet we will use to send the data
	//	out to the socket.
	//
	CWritePacket*	pWrite = m_pSocketSink->CreateDefaultWrite( pRead ) ;
	if( pWrite == 0 ) {

		//	fatal error
		Term( pSocket, CAUSE_OOM, 0 ) ;
		pio = 0 ;
		return	pRead->m_cbBytes ;	
	}

	pWrite->m_pSource = pRead->m_pSource ;

	//
	//	Adjust the write packet for lead text, figure out
	//	whether we have issued the last read
	//
	BOOL	fComplete = CompleteRead( pRead, pWrite ) ;

	//
	//	We have completed the final read - send the trailer text
	//	if necessary
	//
	if( fComplete ) {

		//
		//	Is there any trailer text ?
		//
		if( m_pbuffers && m_pbuffers->Tail ) {

			LPVOID	lpvTail = m_pbuffers->Tail ;
			DWORD	cbTail = m_pbuffers->TailLength ;

			DWORD	cbAvailable = pWrite->m_ibEnd - pWrite->m_ibEndData ;

			cbAvailable = min( cbAvailable, cbTail ) ;

			//	
			//	Put as much trailer text as we can into the
			//	WritePacket we have available.
			//
			if( cbAvailable != 0 ) {

				CopyMemory( pWrite->EndData(), lpvTail, cbAvailable ) ;
				pWrite->m_ibEndData += cbAvailable ;
				cbTail -= cbAvailable ;

			}

			
			//
			//	Do we need another packet for the remaining trailer text ?
			//
			if( cbTail != 0 ) {

				pExtraWrite = m_pSocketSink->CreateDefaultWrite( m_pbuffers->TailLength ) ;
				if( !pExtraWrite ) {

					CPacket::DestroyAndDelete( pWrite ) ;		
					Term( pSocket, CAUSE_OOM, 0 ) ;
					pio = 0 ;
					return	pRead->m_cbBytes ;
				}	else	{
					pExtraWrite->m_pSource = pRead->m_pSource ;
					CopyMemory( pExtraWrite->StartData(), m_pbuffers->Tail, m_pbuffers->TailLength ) ;
					pExtraWrite->m_ibEndData = pExtraWrite->m_ibStartData + m_pbuffers->TailLength ;

				}
			}
		}	
	}

	//
	//	Encrypt our data
	//
	if( !SealMessage( pWrite ) ) {
		
		CPacket::DestroyAndDelete( pWrite ) ;
		if( pExtraWrite )
			CPacket::DestroyAndDelete( pExtraWrite ) ;
		Term( pSocket, CAUSE_ENCRYPTION_FAILURE, 0 ) ;
		pio = 0 ;
		return	pRead->m_cbBytes ;
	}


	pWrite->m_pSource = pRead->m_pSource ;

	//
	//	Figure out whether we need to apply any flow control !
	//	Always do this before writing data to the client,
	//	to ensure that the Write completion function will be called
	//	after any monkey business we do here.
	//
	if( m_cWrites - m_cWritesCompleted > MAX_OUTSTANDING_WRITES ) {

		if( !m_fFlowControlled ) {
			m_cFlowControlled = -1 ;
			m_fFlowControlled = TRUE ;
		}

	}	else	{

		if( !m_fFlowControlled ) {
			m_cFlowControlled = LONG_MIN ;
		}

	}

	//
	//	Mark that we are now completed before we issue our writes	
	//	but after we have bumped m_cWrites !
	//
	if( fComplete )
		m_fCompleted = TRUE ;

	//
	//	Send the data to the client.
	//
	pWrite->m_pOwner->IssuePacket( pWrite, pSocket, eof ) ;

	//
	//	If there's an extra blob of text, send it
	//
	if( pExtraWrite ) {
	
		if( !SealMessage( pExtraWrite ) ) {

			CPacket::DestroyAndDelete( pExtraWrite ) ;
			Term( pSocket, CAUSE_ENCRYPTION_FAILURE, 0 ) ;
			pio = 0 ;
			return	pRead->m_cbBytes ;

		}	else	{

			pExtraWrite->m_pSource = pRead->m_pSource ;
			pExtraWrite->m_pOwner->IssuePacket( pExtraWrite, pSocket, eof ) ;

		}
	}

	//
	//	If we're finished, reset the Current CIO pointer for this driver.
	//
	if( fComplete )	{
		pio = 0 ;
	}

	return	pRead->m_cbBytes ;
}

int	
CIOTransmitSSL::Complete(	
					CSessionSocket*	pSocket,	
					CWritePacket*	pPacket,	
					CPacket*	pRequest,	
					BOOL&	fComplete
					) {
/*++

Routine Description :

	Process Write completions to the remote end
	of the socket.

Arguments :

	pSocket - Socket we are sending data out on
	pPacket - the Write that completed
	pRequest - the Packet that started things going in InitRequest()
	fComplete - OUT parameter - set this to TRUE when
			we have transferred the whole file.

Return Value :

	number of bytes of the packet consumed - always consume all the bytes


--*/

	m_cWritesCompleted ++ ;

	long	cFlowControlled = 0 ;

	if( m_fCompleted && m_cWritesCompleted == m_cWrites ) {

		//	everything is done - mark the request with the
		//	number of bytes transferred, and then
		//	indicate to the caller that it should be completed.

		pRequest->m_cbBytes =	m_pbuffers->HeadLength +
								m_pbuffers->TailLength +
								m_ibEnd ;
		fComplete = TRUE ;

		//
		//	This should only tear down the CIODriver managing the files
		//	async IO.  NOTE - Term() should call ReleaseSource() on the
		//	file channel and ensure the handle doesn't get accidentally closed.
		//	
		Term( pSocket, CAUSE_NORMAL_CIO_TERMINATION, 0 ) ;

		//
		//	We can safely do a reset here, because we only reach
		//	this point if the last read completed, so we are the only
		//	thread touching these member variables.
		//
		Reset() ;


	}	else	if( m_fFlowControlled ) 	{

		BOOL	eof ;

		if( m_cWrites - m_cWritesCompleted <= RESTORE_FLOW &&
			m_pSocketSink != 0 ) {


			cFlowControlled = m_cFlowControlled + 1 ;
			
			while( cFlowControlled >= 0
					&& !m_fCompleted
					&&	m_ibCurrent < m_ibEnd ) {

				CReadPacket*	pRead = m_pFileDriver->CreateDefaultRead( cbMediumRequest ) ;
				
				if( pRead == 0 ) {

					// fatal error - blow off session !

				}	else	{
					pRead->m_pSource = m_pDriverSource ;
					InterlockedIncrement( &m_cReads ) ;
					m_cWrites ++ ;
					ComputeNextRead( pRead ) ;
					pRead->m_pOwner->IssuePacket( pRead, pSocket, eof ) ;
				}
				cFlowControlled -- ;
			}
			InterlockedExchange( &m_cFlowControlled, LONG_MIN ) ;
			m_fFlowControlled = FALSE ;
		}
	}
	return	pPacket->m_cbBytes ;
}






CIOServerSSL::CIOServerSSL(
			CSessionState* pstate,
			CEncryptCtx& encrypt
			) :
/*++

Routine Description :

	Create a default CIOServerSSL object that is ready to start Conversing with
	a client.

Arguments :

	pstate - The state that should start off the state machine when we've
		successfully SSL exchanged with the remote end
	encrypt - The CEncryptCtx managing our SSL keys etc...

Return Value :

	None.

--*/
	CIO(pstate ),
	m_encrypt( encrypt ),
	m_pWrite( 0 ),
	m_fAuthenticated( FALSE ),
	m_cPending( 1 ),
	m_fStarted( FALSE ),
	m_ibStartData( 0 ),
	m_ibEndData( 0 ),
	m_ibEnd( 0 )
{
}

CIOServerSSL::~CIOServerSSL()	{

	if( m_pWrite != 0 )
		CPacket::DestroyAndDelete( m_pWrite ) ;
	m_pWrite = 0 ;
	
}

BOOL
CIOServerSSL::Start(
				CIODriver&	driver,	
				CSessionSocket*	pSocket,	
				unsigned cAhead
				) {
/*++

Routine Description :

	Issue the first IO required when a client is trying to
	negogtiate with us.
	We want to read the first SSL blob.

Arguments :

	driver - CIODriver through which we issue IO's
	pSocket - socket associated with this IO
	cAhead - number of completed reads ahead in the queue (should be 0)

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/


	CReadPacket*	pRead = 0 ;
	if( !m_fStarted )	{
		pRead = driver.CreateDefaultRead( cbMediumRequest ) ;
		if( pRead != 0 ) {
			BOOL	eof ;
			driver.IssuePacket(  pRead, pSocket, eof ) ;
			m_fStarted = TRUE ;
			return	TRUE ;
		}
	}	else	{
		return	TRUE ;
	}
	//
	//	Error Fall Through !!
	//
	if( pRead != 0 ) {
		//delete	pRead ;
		CPacket::DestroyAndDelete( pRead ) ;
	}
	return	FALSE ;
}


BOOL
CIOServerSSL::SetupSource(	
					CIODriver&	driver,
					CSessionSocket*	pSocket
					) {
/*++

Routine Description :

	After successfully doing a SSL logon, setup a CIODriverSource
	to filter and encrypt all of the IO from here on.

Arguments :

	driver - the CIODriver which is controlling the top level of IO
	pSocket - socket associated with all IO !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/


	CIOPASSPTR	pIOReads = new( driver )	CIOUnsealMessages( m_encrypt ) ;
	CIOPASSPTR	pIOWrites = new( driver )	CIOSealMessages( m_encrypt ) ;
	CIOPASSPTR	pIOTransmits = new( driver )	CIOTransmitSSL( m_encrypt, driver ) ;

	//
	//	Ensure that allocations succeeded !
	//
	if( pIOReads == 0 ||
		pIOWrites == 0 ||
		pIOTransmits == 0 )	{

		return	FALSE ;

	}

	CIODriverSource*	pSource = new	CIODriverSource(
													driver.GetMediumCache()
													) ;

	if( pSource ) {
		CIOPASSPTR	pTemp = 0 ;
		if(	driver.InsertSource( 	*pSource,	
									pSocket,
									0,
									m_encrypt.GetSealHeaderSize(),
									0,
									m_encrypt.GetSealTrailerSize(),
									*pIOReads,
									*pIOWrites,
									*pIOTransmits,
									pTemp,
									pTemp
									) )	{
			pSource->SetRequestSequenceno( m_sequencenoNextRead, m_sequencenoNextWrite ) ;
			return	TRUE ;
		}
	}	

	if( pSource )
		delete	pSource ;
	return	FALSE ;
}



int
CIOServerSSL::Complete(	CSessionSocket*	pSocket,	
						CReadPacket*	pRead,	
						CIO*&	pio
						) {
/*++

Routine Description :

	we are in the midst of an SSL negogtiation - accumulate reads in a buffer
	in case the SSL negogtiation blobs are split across reads, and then let
	the CEncryptCtx do the meat of the negogtiation.
	
Arguments :

	pSocket - Socket this IO is associated with
	pRead -		Packet containing the completed data
	pio	-		The current CIO pointer

Return Value :

	number of bytes we use from the read
	
--*/

	TraceFunctEnter( "CIOServerSSL::Complete - CReadPacket" ) ;

	// Save the sequenceno from the packets for initializing the new Source Stream
	ASSIGN( m_sequencenoNextRead, pRead->m_sequenceno );
	INC(m_sequencenoNextRead);

	if( !m_fAuthenticated ) {

		BYTE*		lpbOut = 0 ;
		DWORD		cbBuffOut;
		BOOL		fMore ;
		long		sign = 0 ;
		IN_ADDR		addr;


		//
		//	In most cases we'll need to send something back immediately -
		//	so pre-allocate it !!
		//

		if( m_pWrite == 0 )
			m_pWrite = pRead->m_pOwner->CreateDefaultWrite( cbMediumRequest ) ;
		if( m_pWrite == 0 ) {
			//
			//	Fatal error - blow off session !
			//
			pRead->m_pOwner->UnsafeClose(
										pSocket,	
										CAUSE_OOM,
										0
										) ;
			pio = 0 ;
			return	pRead->m_cbBytes ;
		}	else	{

			//
			//	Save buffers and offsets, because we may not have a complete blob
			//	of data, and if we don't, we want to accumulate reads into a
			//	complete blob.
			//

			if( m_pbuffer == 0 ) {

				m_pbuffer = pRead->m_pbuffer ;
				m_ibStartData = pRead->m_ibStartData ;
				m_ibEndData = pRead->m_ibEndData ;
				m_ibEnd = pRead->m_ibEnd ;

			}	else	{

				//
				//	Append this read to what we have room for in the buffer !!
				//
				DWORD	cbAvailable = m_ibEnd - m_ibEndData ;
				DWORD	cbRequired = pRead->m_ibEndData - pRead->m_ibStartData ;
				if( cbRequired > cbAvailable ) {

					//
					//	Blob is too big for us - blow off the session !
					//

					pRead->m_pOwner->UnsafeClose(
												pSocket,	
												CAUSE_OOM,
												0
												) ;
					CPacket::DestroyAndDelete( m_pWrite ) ;
					m_pWrite = 0 ;
					pio = 0 ;
					return	pRead->m_cbBytes ;

				}	else	{
					//
					//	Catenate this latest read together with our other data !
					//
					CopyMemory( &m_pbuffer->m_rgBuff[m_ibEndData], pRead->StartData(), cbRequired ) ;
					m_ibEndData += cbRequired ;
				}
			}

			//
			// need to set cbBuffOut to the maximum sizeof the output buffer
			//
			cbBuffOut = (DWORD)((DWORD_PTR)m_pWrite->End() - (DWORD_PTR)m_pWrite->StartData());

			//
			// need to get a stringized instance of our local IP addr
			//
			addr.s_addr = pSocket->m_localIpAddress;

    		char	szPort[16] ;
    		ULONG   cbExtra = 0; // Number of bytes in tail not processed by successful handshake

			_itoa( pSocket->m_nntpPort, szPort, 10 ) ;

			DWORD	dw = m_encrypt.Converse(
								&m_pbuffer->m_rgBuff[m_ibStartData],
								m_ibEndData - m_ibStartData,
								(BYTE*)m_pWrite->StartData(),
								&cbBuffOut,
								&fMore,
								inet_ntoa( addr ),
								szPort,
								pSocket->m_context.m_pInstance,
								pSocket->m_context.m_pInstance->QueryInstanceId(),
								&cbExtra
								) ;

			if( dw == SEC_E_INCOMPLETE_MESSAGE ) {

				//	indicate that we still need more data - following code will issue
				//	read !
				fMore = TRUE ;

				//
				//	Should be no outgoing data !!
				//	
				_ASSERT( cbBuffOut == 0 ) ;


			}	else if( dw != NO_ERROR ) {

				//
				//	Fatal error - tear down session !!
				//
				pRead->m_pOwner->UnsafeClose( pSocket,	
											CAUSE_ENCRYPTION_FAILURE,
											dw
											) ;
				pio = 0 ;
				return	pRead->m_cbBytes ;

			}	else	{

				//
				//	Reset member variables - we processed a complete blob,
				//	and we may process more
				//

				m_pbuffer = 0 ;
				m_ibStartData = 0 ;
				m_ibEndData = 0 ;
				m_ibEnd = 0 ;

				//
				//	If we got the last blob, then authentication is complete !
				//

				if( !fMore )
					m_fAuthenticated = TRUE ;

				//
				//	Any bytes to send to the client ?
				//
				if( cbBuffOut != 0 ) {

					//
					//	Take care that there is no way our destructor
					//	could destroy a packet we've issued !!
					//

					CWritePacket*	pWrite = m_pWrite ;
					m_pWrite = 0 ;

					//
					//	Okay - now send the data !
					//

					pWrite->m_ibEndData = pWrite->m_ibStartData + cbBuffOut ;
					BOOL	eof= FALSE ;
					InterlockedIncrement( &m_cPending ) ;
					pWrite->m_pOwner->IssuePacket( pWrite, pSocket, eof ) ;
				}
			}
		}

		//
		//	Are we done yet ??
		//
		if( !fMore ) {

			_ASSERT( m_fAuthenticated == TRUE ) ;

			if( cbBuffOut != 0 )
				sign = InterlockedDecrement( &m_cPending ) ;

			if( sign == 0 ) {
				// Write has completed !!	
				//
				//	Prepare the next state in the state machine - and then check to see whether
				//	we should do the initialization !!
				//

				if( SetupSource( *pRead->m_pOwner, pSocket ) ) {
					_ASSERT( m_pState != 0 ) ;
					CIORead*	pReadIO = 0 ;
					CIOWrite*	pWriteIO = 0 ;
					if( m_pState->Start( pSocket, pRead->m_pOwner, pReadIO, pWriteIO ) ) {

						if( pWriteIO != 0 ) {
							if( !pRead->m_pOwner->SendWriteIO( pSocket, *pWriteIO ) )	{
								pWriteIO->DestroySelf() ;
								if( pReadIO ) {
									pReadIO->DestroySelf() ;
									pReadIO = 0 ;
								}
							}
						}
						pio = pReadIO ;

					}	else	{
						ErrorTrace( (DWORD_PTR)this, "Failed state machine" ) ;

						pRead->m_pOwner->UnsafeClose(
													pSocket,	
													CAUSE_IODRIVER_FAILURE,
													0
													) ;
						pio = 0 ;

					}
				}
			}	else	{

				pio = 0 ;

			}

		}	else	{
			//
			//	Not finished convers'ing - issue more reads !
			//

			CReadPacket*	pReadPacket = pRead->m_pOwner->CreateDefaultRead( cbMediumRequest ) ;
			if( pReadPacket  != 0 ) {
				BOOL	eof ;
				pReadPacket->m_pOwner->IssuePacket( pReadPacket, pSocket, eof ) ;
			}	else	{
				pRead->m_pOwner->UnsafeClose(
											pSocket,	
											CAUSE_OOM,
											0
											) ;
				pio = 0 ;
				//
				//	We will fall through and return the right thing !!
				//
			}
		}
	}	else	{
		//
		//	If we are authenticated we should no longer be in this state !
		//
		_ASSERT( 1==0 ) ;
	}
	return	pRead->m_cbBytes ;
}	

int	
CIOServerSSL::Complete(	
				CSessionSocket*	pSocket,	
				CWritePacket*	pWrite,	
				CIO*& pio
				) {

	TraceFunctEnter( "CIOServerSSL::Complete - CWritePacket" ) ;

	// Save the sequenceno from the packets for initializing the new Source Stream
	ASSIGN( m_sequencenoNextWrite, pWrite->m_sequenceno );
	INC(m_sequencenoNextWrite);

	long	sign = InterlockedDecrement( &m_cPending ) ;

	if( sign == 0 ) {
		if( m_fAuthenticated ) {
			// Write has completed !!	
			//
			//	Prepare the next state in the state machine - and then check to see whether
			//	we should do the initialization !!
			//
			if( SetupSource( *pWrite->m_pOwner, pSocket ) ) {
				_ASSERT( m_pState != 0 ) ;
				CIORead*	pReadIO = 0 ;
				CIOWrite*	pWriteIO = 0 ;
				if( m_pState->Start( pSocket, pWrite->m_pOwner, pReadIO, pWriteIO ) ) {

					if( pReadIO != 0 ) {
						if( !pWrite->m_pOwner->SendReadIO( pSocket, *pReadIO ) )
							pReadIO->DestroySelf() ;
					}
					pio = pWriteIO ;

				}	else	{
					ErrorTrace( (DWORD_PTR)this, "Failed state machine" ) ;

					// bugbug ... should do UnsafeClose(), but how do we clean up security 1?
					_ASSERT( 1==0 ) ;

				}
			}
		}
	}	else	if( m_fAuthenticated ) {
		pio = 0 ;
	}
	return pWrite->m_cbBytes ;
}

void
CIOServerSSL::Complete(	CSessionSocket*	pSocket,	CTransmitPacket*	pTransmit,	CIO*& pio/*CIOPassThru*&	pio,
					CPacket*	pRequest,	BOOL	&fComplete */) {

	_ASSERT( 1==0 ) ;
	return ;
}

void
CIOServerSSL::Shutdown(
			CSessionSocket*	pSocket,
			CIODriver&	driver,
			SHUTDOWN_CAUSE	cause,
			DWORD	dwError
			)	{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\pcache.h ===
/*++

	PCACHE.H

	This file defines several classes which manage the allocation of 
	packets, buffers and other object.
	
	Most of this is build upon a general Cache mechanism defined in gcache.h
	which uses InterlockedExchange to allocate object.
	This caching is done to avoid excessive use of Critical Sections which
	protect the underlying CPool objects which actually allocate the RAW 
	memory.

	This file declares pairs of classes - 
	for each 'Cache'ing' allocator, there is a CClassAllocator derived
	object which manages cache misses.  This object is derived from CClassAllocator
	so that the 'cache'ing objects can derive from CCache.

--*/

#ifndef	_PCACHE_H_
#define	_PCACHE_H_

#include 	"cbuffer.h"
#include	"gcache.h"





//--------------------------------------------------------
//
//	@class	The CPacket class represents IO operations.  These are queueable
//	operations and are therefore derived from CQElement.
//


class	CPacketAllocator : public	CClassAllocator	{
//
//	This class caches all sorts of packets.
//
private : 
	//
	//	CPacket knows about us
	//
	friend	class	CPacket ;
	//
	//	PacketPool is the underlying CPool object which manages the raw memory
	//
	static	CPool	PacketPool ;
	//
	//	A private constructor - there should only be one CPacketAllocator object ever.
	//
	CPacketAllocator() ;
public : 
	//
	//	Initialize the class - mostly just initializes our CPool
	//
	static	BOOL	InitClass() ;

	//
	//	Release everything allocated by InitClass()
	//
	static	BOOL	TermClass() ;


	//
	//	Allocate memory for a packet
	//
	LPVOID	Allocate(	DWORD	cb, DWORD	&cbOut = CClassAllocator::cbJunk )	{	cbOut = cb ; return	PacketPool.Alloc() ;	}
	
	//
	//	Release a packets memory
	//
	void	Release( void *lpv )		{	PacketPool.Free( lpv ) ;	}

#ifdef	DEBUG
	void	Erase(	void*	lpv ) ;
	BOOL	EraseCheck(	void*	lpv ) ;
	BOOL	RangeCheck( void*	lpv ) ;
	BOOL	SizeCheck(	DWORD	cb ) ;
#endif
} ;

class	CPacketCache : public	CCache	{
//
//	This class actually cache's the CPacket objects
//
private : 
	//
	//	Pointer to the underlying PacketAllocator we use
	//
	static	CPacketAllocator*	PacketAllocator ;
	//
	//	space to hold cache'd pointers
	//
	void*	lpv[4] ;
public : 
	//
	//	Set static pointer - can not fail
	//
	static	void	InitClass(	CPacketAllocator*	Allocator )	{	PacketAllocator = Allocator ; }

	//
	//	Create a cache - we just let CCache initialize our buffer
	//
	inline	CPacketCache(	) :		CCache( lpv, 4 )	{} ;
	//
	//	Release everything in the cache back to the allocator
	//
	inline	~CPacketCache( ) {		Empty( PacketAllocator ) ;	}
	
	//
	//	Free a packet's memory to cache if possible
	//
	inline	void	Free(	void*	lpv )  	{	CCache::Free( lpv, PacketAllocator ) ;	}
	
	//
	//	Allocate memory from the cache if possible.
	//
	inline	void*	Alloc(	DWORD	size,	DWORD&	cbOut=CCache::cbJunk )  	{	return	CCache::Alloc( size, PacketAllocator, cbOut ) ; }
} ;



#endif	// _PCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\queue.cpp ===
//
// Queue.cpp
//
// This file contains several classes which implement various
// flavors of Queues and Stacks.  The intention is to develop
// stacks and queues which are Thread safe and DO NOT USE blocking
// primitives.
//
// Since it has taken several iterations to arrive at partially
// succesfull results, each class is used in a template defined
// in queue.h.  This template (CQueue) is designed to allow
// specification of an Implementation class and a base type
// for elements in the queue, which is always CQElement in this code.
//
// The most succesfull classes below are :
// CQAppendSafe - this class is MT safe for Appending elements,
//  Removal of elements would require a Critical Section to
//  become thread safe.
//

#include "tigris.hxx"

#define Assert  _ASSERT

#include	"queue.h"

#if 0 
CQAppendSafe::CQAppendSafe( ) {

	//
	// The Queue always contains at least one element
	// which is never removed.  This ensures that the
	// Head and Tail pointers ALWAYS point at different things.
	//
	m_pHead = m_pTail = &m_special ;
	m_special.m_pNext = 0 ;

}

CQAppendSafe::~CQAppendSafe( ) {

	Assert( m_pHead == m_pTail ) ;
	Assert( m_pTail->m_pNext == 0 ) ;
	Assert( m_pHead == &m_special ) ;

}

CQElement*
CQAppendSafe::Remove( void ) {
	CQElement	*pTemp = 0 ;
#ifdef	QUEUE_DEBUG
	int	loopcount = 0 ;
#endif	QUEUE_DEBUG

	do	{
		//
		// If the Head Elements NEXT pointer is NULL then we
		// can't remove because we won't know what to set it to.
		// (QUEUE NEVER IS EMPTY - m_pHead MUST ALWAYS BE NON NULL !)
		//
		if( m_pHead->m_pNext != 0 ) {
			pTemp = m_pHead ;
			m_pHead = pTemp->m_pNext ;
			Assert( pTemp != m_pHead ) ;	// Can't have circular lists!
		}	else 	{
			return	0 ;
		}

		//
		// The m_special Element must always remain in the list.
		// NOTE : after appending, we MAY not be able to get another
		// element if the other threads haven't finished with their NEXT pointers.
		//
		if( pTemp == &m_special )
			Append( pTemp ) ;

#ifdef	QUEUE_DEBUG
		//
		// Should never require more than 2 loop iterations !
		//
		Assert( loopcount++ < 2 ) ;
#endif
	}	while( pTemp == &m_special ) ;

	return	pTemp ;
}

CQElement*
CQAppendSafe::Front( void ) {
	return	m_pHead ;
}

void
CQAppendSafe::Append( CQElement*	pAppend ) {
	pAppend->m_pNext = 0 ;
	CQElement*	pTemp = (CQElement*)InterlockedExchangePointer( (void**)&m_pTail, pAppend ) ;
	Assert( pTemp != 0 ) ;
	pTemp->m_pNext = pAppend ;
}

BOOL
CQAppendSafe::IsEmpty( ) {

	return	m_pHead->m_pNext == 0 ;
}

		
CQSafe::CQSafe()	{
	InitializeCriticalSection( &m_critRemove ) ;
}

CQSafe::~CQSafe()	{
	DeleteCriticalSection(	&m_critRemove ) ;
}

CQElement*
CQSafe::Remove( void )	{

	EnterCriticalSection(	&m_critRemove ) ;
	CQElement*	pRtn = CQAppendSafe::Remove() ;
	LeaveCriticalSection(	&m_critRemove ) ;
	return	pRtn ;
}

CQElement*
CQSafe::Front( void ) {
	EnterCriticalSection(	&m_critRemove ) ;
	CQElement*	pRtn = CQAppendSafe::Front() ;
	LeaveCriticalSection( &m_critRemove ) ;
	return	pRtn ;
}

BOOL
CQSafe::IsEmpty( void ) {
	EnterCriticalSection(	&m_critRemove ) ;
	BOOL	fRtn = CQAppendSafe::IsEmpty() ;
	LeaveCriticalSection(	&m_critRemove ) ;
	return	fRtn ;
}

CQUnsafe::CQUnsafe() : m_pHead( 0 ), m_pTail( 0 ) {}

CQUnsafe::~CQUnsafe( ) {
	Assert( m_pHead == 0 ) ;
	Assert( m_pTail == 0 ) ;
}

CQElement*
CQUnsafe::Remove( ) {
	CQElement *pRtn = m_pHead ;
	if( pRtn ) {
		m_pHead = pRtn->m_pNext ;
		if( m_pHead == 0 ) {
			m_pTail = 0 ;
		}
	}
	return	pRtn ;
}

CQElement*
CQUnsafe::Front( ) {
	return	m_pHead ;
}

void
CQUnsafe::Append( CQElement *p ) {

	Assert( p->m_pNext == 0 ) ;

	if( m_pTail ) {
		m_pTail->m_pNext = p ;
		m_pTail = p ;
	}	else	{
		m_pHead = m_pTail = p ;
	}
}
#endif

	
COrderedList::COrderedList() : m_pHead( 0 ), m_pTail( 0 )  { }

COrderedList::~COrderedList()	{
	m_pHead = 0 ;
	m_pTail = 0 ;
}

void
COrderedList::Insert( CQElement *p, BOOL (*pfn)(CQElement*, CQElement*) ) {

	Assert( p->m_pNext == 0 ) ;
	Assert( (m_pHead==0 && m_pTail==0) || (m_pHead!=0 && m_pTail!=0) ) ;

	if( !m_pHead )	{
		m_pHead = p ;
		m_pTail = p ;
	}	else	{

		CQElement**	pp = &m_pHead ;
		while( *pp && pfn( *pp, p ) ) {
			pp = & (*pp)->m_pNext ;
		}
		Assert( pp != 0 ) ;
		p->m_pNext = *pp ;
		*pp = p ;
		if( p->m_pNext == 0 )	{
			m_pTail = p ;
		}
	}

	Assert( (m_pHead==0 && m_pTail==0) || (m_pHead!=0 && m_pTail!=0) ) ;
}

void
COrderedList::Append( CQElement	*p,	BOOL	(*pfn)(CQElement *, CQElement *) )	{

	Assert( p->m_pNext == 0 ) ;
	Assert( (m_pHead==0 && m_pTail==0) || (m_pHead!=0 && m_pTail!=0) ) ;

	if( !m_pHead )	{
		m_pHead = p ;
		m_pTail = p ;
	}	else	{
		if( pfn( m_pTail, p ) )		{
			m_pTail->m_pNext = p ;
			p->m_pNext = 0 ;
			m_pTail = p ;
		}	else	{
			Insert( p, pfn ) ;
		}
	}
	Assert( (m_pHead==0 && m_pTail==0) || (m_pHead!=0 && m_pTail!=0) ) ;
}

CQElement*
COrderedList::GetHead( ) {
	return	m_pHead ;
}

CQElement*
COrderedList::RemoveHead( ) {
	Assert( (m_pHead==0 && m_pTail==0) || (m_pHead!=0 && m_pTail!=0) ) ;
	CQElement*	p = 0 ;
	if( m_pHead ) {
		p = m_pHead ;
		m_pHead = p->m_pNext ;
		p->m_pNext = 0 ;
		if( p == m_pTail )
			m_pTail = 0 ;
	}
	Assert( (m_pHead==0 && m_pTail==0) || (m_pHead!=0 && m_pTail!=0) ) ;
	return	p ;
}

BOOL
COrderedList::IsEmpty(	)	{
	return	m_pHead == 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\queue.h ===
//
// Queue.h
// 
// This file defines two templates, one each for a standard
// stack and queue.  These templates take two classes parameters,
// one which specifies the base element type of the stack or
// queue (ie. a queue of Struct Junk{}) and another which 
// specifies an implementation class.   
// 
// It is intended that the base element type is always derived
// from CQElement.
//
// The net result is that the Templates provide a type safe 
// way to try out various methods of implementing stacks 
// and queues.
//
// 




#ifndef	_QUEUE_H_
#define	_QUEUE_H_

#ifdef	DEBUG
#define	QUEUE_DEBUG
#endif

#include	<windows.h>
#ifndef	UNIT_TEST
#include	<dbgtrace.h>
#endif

#include	"qbase.h"


class	COrderedList	{
private : 
	CQElement*	m_pHead ;
	CQElement*	m_pTail ;
public : 
	COrderedList() ;
	~COrderedList() ;

	void	Insert( CQElement *, BOOL (* pfnCompare)( CQElement *, CQElement *) ) ;
	void	Append(	CQElement *, BOOL (* pfnCompare)( CQElement *, CQElement *) ) ;
	BOOL	IsEmpty() ;
	CQElement*	GetHead( ) ;
	CQElement*	RemoveHead( ) ;
} ;


#ifndef	_NO_TEMPLATES_

template< class Element > 
class	TOrderedList : private COrderedList	{
private : 
	static	BOOL	Compare( CQElement *, CQElement * ) ;
public : 
	TOrderedList();
	void	Insert( Element * ) ;
	void	Append( Element * ) ;
	Element*	GetHead() ;
	Element*	RemoveHead() ;
	BOOL	IsEmpty() ;
} ;

#else


#define	DECLARE_ORDEREDLIST( Element )	\
class	TOrderedList ## Element : private COrderedList	{	\
private :	\
	static	BOOL	Compare( CQElement *, CQElement * ) ;	\
public :	\
	void	Insert( Element * ) ;	\
	void	Append( Element * ) ;	\
	Element*	GetHead() ;	\
	Element*	RemoveHead() ;	\
	BOOL	IsEmpty() ;	\
} ;

#define	INVOKE_ORDEREDLIST( Element )	TOrderedList ## Element


#endif

#include	"queue.inl"


#endif	// _QUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\persistc.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    persistc.h

Abstract:

    This module contains definitions for a persistent connection class.
	A persistent connection object handles all TCP/IP stream connection
	issues and is persistent in the sense that re-connects are handled
	transparently during the lifetime of the object.

Author:

    Rajeev Rajan (RajeevR)     17-May-1996

Revision History:

--*/

#ifndef _PERSISTC_H_
#define _PERSISTC_H_

#define MINUTES_TO_SECS                60
#define SECS_TO_MSECS                  1000
#define BLOCKING_RECV_TIMEOUT_IN_MSECS 1 * MINUTES_TO_SECS * SECS_TO_MSECS

class	CPersistentConnection	{
private : 

	//
	//	socket used by this object
	//
	SOCKET	m_Socket;

	//
	//	remote IP address
	//
	IN_ADDR m_RemoteIpAddress;

	//
	//	server port number
	//
	int		m_PortNumber;

    //
    //  initialized or not
    //
    BOOL    m_fInitialized;

    //
    //  recv timeout
    //
    DWORD   m_dwRecvTimeout;

protected:
	//
	//	connect() to server
	//
	BOOL	fConnect();

    //
    //  check to see if socket is connected to server
    //
    BOOL    IsConnected();

    //
    //  check to see if socket is readable
    //
    BOOL    IsReadable();

public : 
	CPersistentConnection();
	virtual ~CPersistentConnection(VOID);

	//
	//	Does a gethostbyname resolution and 
	//  establishes a connection
	//
	BOOL Init(IN LPSTR lpServer, int PortNumber);

	//
	//	Close the connection; cleanup
	//
	VOID Terminate(BOOL bGraceful);

    //
    //  check to see if object is initialized
    //
    BOOL    IsInitialized(){return m_fInitialized;}

	//
	//	Send a buffer of given len
	//
	DWORD fSend(IN LPCTSTR lpBuffer, int len);

	//
	//	TransmitFile
	//
	BOOL fTransmitFile(IN HANDLE hFile, DWORD dwOffset, DWORD dwLength);

	//
	//	Receive data from remote
	//
	BOOL fRecv(IN OUT LPSTR lpBuffer, DWORD& cbBytes);

	//
    // override new and delete to use HeapAlloc/Free
	//
    void *operator new( size_t cSize )
	{ return HeapAlloc( GetProcessHeap(), 0, cSize ); }
    void operator delete (void *pInstance)
	{ HeapFree( GetProcessHeap(), 0, pInstance ); }
};

#endif // _PERSISTC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\persistc.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    persistc.cpp

Abstract:

    This module contains the implementation for a persistent connection class.
	A persistent connection object handles all TCP/IP stream connection
	issues and is persistent in the sense that re-connects are handled
	transparently during the lifetime of the object.

Author:

    Rajeev Rajan (RajeevR)     17-May-1996

Revision History:

--*/

//
//	K2_TODO: move this into an independent lib
//
#define _TIGRIS_H_
#include "tigris.hxx"

#ifdef  THIS_FILE
#undef  THIS_FILE
#endif
static  char        __szTraceSourceFile[] = __FILE__;
#define THIS_FILE    __szTraceSourceFile

// system includes
#include <windows.h>
#include <stdio.h>
#include <winsock.h>

// user includes
#include <dbgtrace.h>
#include "persistc.h"

//
//  Constructor, Destructor
//
CPersistentConnection::CPersistentConnection()
{
	// zero out members
	m_Socket = INVALID_SOCKET;
	ZeroMemory (&m_RemoteIpAddress, sizeof (m_RemoteIpAddress));
	m_PortNumber = 0;
    m_fInitialized = FALSE;
    m_dwRecvTimeout = BLOCKING_RECV_TIMEOUT_IN_MSECS;
}

CPersistentConnection::~CPersistentConnection()
{

}

BOOL
CPersistentConnection::Init(
		IN LPSTR lpServer,
		int PortNumber
		)
/*++

Routine Description :

	If the lpServer param is not in IP address format (A.B.C.D), do
	a gethostbyname and store the IP address.

Arguemnts :

	IN LPSTR lpServer	-	Name or IP address of server
	int PortNumber		-	Port number of server

Return Value :
	TRUE if successful - FALSE otherwise !

--*/
{
	PHOSTENT pHost;

	TraceFunctEnter("CPersistentConnection::Init");

	//
	//	Do server name resolution if needed
	//	Assume host is specified by name
	//
	_ASSERT(lpServer);
    pHost = gethostbyname(lpServer);
    if (pHost == NULL)
    {
	    //
        // See if the host is specified in "dot address" form
        //
        m_RemoteIpAddress.s_addr = inet_addr (lpServer);
        if (m_RemoteIpAddress.s_addr == -1)
        {
           FatalTrace( (LPARAM)this, "Unknown remote host: %s", lpServer);
           return FALSE;
        }
    }
    else
    {
       CopyMemory ((char *) &m_RemoteIpAddress, pHost->h_addr, pHost->h_length);
    }

	// Note the port number for future re-connects
	m_PortNumber = PortNumber;

	// connect() to server
	BOOL fRet = fConnect();

    // mark as initialized
    if(fRet) m_fInitialized = TRUE;

    return fRet;
}

BOOL
CPersistentConnection::fConnect()
/*++

Routine Description :

	Establish a connection to the server at the specified port

Arguments :


Return Value :
	TRUE if successful - FALSE otherwise !

--*/
{
	SOCKADDR_IN remoteAddr;

	TraceFunctEnter("CPersistentConnection::fConnect");

	// get a socket descriptor
	m_Socket = socket(AF_INET, SOCK_STREAM, 0);
	if(INVALID_SOCKET == m_Socket)
	{
		FatalTrace( (LPARAM)this,"Failed to get socket descriptor: Error is %d",WSAGetLastError());
		return FALSE;
	}

    //
    // Set the recv() timeout on this socket
    //
    int err = setsockopt(m_Socket, SOL_SOCKET, SO_RCVTIMEO,
    				    (char *) &m_dwRecvTimeout, sizeof(m_dwRecvTimeout));

    if (err == SOCKET_ERROR)
    {
	    FatalTrace((LPARAM) this, "setsockopt(SO_RCVTIMEO) returns %d", err);
        closesocket(m_Socket);
        return FALSE;
    }

    //
	// Connect to an agreed upon port on the host.
	//
	ZeroMemory (&remoteAddr, sizeof (remoteAddr));

	remoteAddr.sin_family = AF_INET;
	remoteAddr.sin_port = htons ((WORD)m_PortNumber);
	remoteAddr.sin_addr = m_RemoteIpAddress;

	err = connect (m_Socket, (PSOCKADDR) & remoteAddr, sizeof (remoteAddr));
	if (err == SOCKET_ERROR)
	{
        DWORD dwError = WSAGetLastError();
		FatalTrace( (LPARAM)this, "connect failed: %ld\n", dwError);

		closesocket (m_Socket);
		return FALSE;
	}

	return TRUE;
}

VOID
CPersistentConnection::Terminate(BOOL bGraceful)
/*++

Routine Description :

	Close the connection; cleanup

Arguments :

	BOOL	bGraceful	: FALSE for hard disconnect	

Return Value :
	VOID
--*/
{
    LINGER lingerStruct;

    _ASSERT(m_fInitialized);

	if ( !bGraceful )
    {
		// hard disconnect
		lingerStruct.l_onoff = 1;
        lingerStruct.l_linger = 0;
		setsockopt( m_Socket, SOL_SOCKET, SO_LINGER,
                    (char *)&lingerStruct, sizeof(lingerStruct) );
	}

    closesocket( m_Socket );
    m_fInitialized = FALSE;
}

BOOL
CPersistentConnection::IsConnected()
/*++

Routine Description :

    Check if socket is connected. Uses select() on a read set to determine this.
    NOTE: assumption is that we have no outstanding reads.

Arguemnts :


Return Value :
	TRUE if socket is connected - FALSE if not

--*/
{
    fd_set  ReadSet;
    const struct timeval timeout = {0,0};   // select() should not block
    char szBuf [10];    // arbitrary size
    int flags = 0;

    TraceFunctEnter("CPersistentConnection::IsConnected");

    _ASSERT(m_fInitialized);

    FD_ZERO(&ReadSet);
    FD_SET(m_Socket, &ReadSet);

    // check if socket has been closed
    if(select(NULL, &ReadSet, NULL, NULL, &timeout) == SOCKET_ERROR)
    {
        DWORD dwError = WSAGetLastError();
        ErrorTrace( (LPARAM)this, "select failed: Last error is %d", dwError);
        return FALSE;
    }

    // If socket is in read set, recv() is guaranteed to return immediately
    if(FD_ISSET(m_Socket, &ReadSet))
    {
    	int nRecv = recv(m_Socket, szBuf, 10, flags);
        //_ASSERT(nRecv <= 0);  data unexpected at this time - disconnect
        closesocket(m_Socket);
        return FALSE;
    }
    else
        return TRUE;
}

BOOL
CPersistentConnection::IsReadable()
/*++

Routine Description :

    Check if socket has data to read. Uses select() on a read set to determine this.
    This can be used to avoid a potentially blocking read call.

    NOTE: this is not used. recv()'s are blocking with timeout

Arguments :


Return Value :
	TRUE if socket has data to read - FALSE if not

--*/
{
    fd_set  ReadSet;
    const struct timeval timeout = {0,0};   // select() should not block
    int flags = 0;

    TraceFunctEnter("CPersistentConnection::IsReadable");

    _ASSERT(m_fInitialized);

    FD_ZERO(&ReadSet);
    FD_SET(m_Socket, &ReadSet);

    // check socket for readability
    if(select(NULL, &ReadSet, NULL, NULL, &timeout) == SOCKET_ERROR)
    {
        DWORD dwError = WSAGetLastError();
        ErrorTrace( (LPARAM)this, "select failed: Last error is %d", dwError);
        return FALSE;
    }

    // If socket is in read set, recv() is guaranteed to return immediately
    return FD_ISSET(m_Socket, &ReadSet);
}

DWORD
CPersistentConnection::fSend(
		IN LPCTSTR lpBuffer,
		int len
		)
/*++

Routine Description :

	Send a buffer of given len

Arguemnts :

	IN LPCTSTR lpBuffer		: buffer to send
	int		   len			: length of buffer

Return Value :
	Number of actual bytes sent

--*/
{
	int		cbBytesSent = 0;
	int     cbTotalBytesSent = 0;
	int		flags = 0;

    _ASSERT(lpBuffer);
    _ASSERT(m_fInitialized);

	TraceFunctEnter("CPersistentConnection::fSend");

	// send the buffer till all data has been sent
	while(cbTotalBytesSent < len)
	{
		cbBytesSent = send(	m_Socket,
							(const char*)(lpBuffer+cbTotalBytesSent),
							len - cbTotalBytesSent,
							flags);

		if(SOCKET_ERROR == cbBytesSent)
		{
			// error sending data
			ErrorTrace( (LPARAM)this, "Error sending %d bytesto %s", len, inet_ntoa(m_RemoteIpAddress));
			ErrorTrace( (LPARAM)this, "WSAGetLastError is %d", WSAGetLastError());
			break;
		}

		cbTotalBytesSent += cbBytesSent;
	}

	return cbTotalBytesSent;
}

BOOL
CPersistentConnection::fTransmitFile(
		HANDLE hFile,
		DWORD dwOffset,
		DWORD dwLength
		)
/*++

Routine Description :

	TransmitFile over this connection

Arguemnts :

	HANDLE hFile		: handle to memory-mapped file
	DWORD dwOffset		: offset within file to transmit from
	DWORD dwLength		: number of bytes to transmit

Return Value :
	TRUE if successful - FALSE otherwise !

--*/
{
	BOOL fRet = TRUE;
	OVERLAPPED Overlapped;
	DWORD dwError;

    _ASSERT(m_fInitialized);

	TraceFunctEnter("CPersistentConnection::fTransmitFile");

	Overlapped.Internal = 0;
	Overlapped.InternalHigh = 0;
	Overlapped.Offset = dwOffset;		// offset within file
    Overlapped.OffsetHigh = 0;		
    Overlapped.hEvent = NULL;			// sync operation

	// else consecutive calls to TransmitFile fails!
	SetFilePointer(hFile, 0, 0, FILE_BEGIN);

	fRet = TransmitFile(	m_Socket,		// handle to a connected socket
							hFile,			// handle to an open file
							dwLength,		// number of bytes to transmit
							0,				// let winsock decide a default
							&Overlapped,	// pointer to overlapped I/O data structure
							NULL,			// pointer to data to send before and after file data
							0				// reserved; must be zero
						);

	dwError = GetLastError();

	if(!fRet)
	{
		if(ERROR_IO_PENDING == dwError)
		{
			// wait for socket to be signalled
			// TODO: make timeout configurable!!
			DWORD dwWait = WaitForSingleObject((HANDLE)m_Socket, INFINITE);
			if(WAIT_OBJECT_0 != dwWait)
			{
                ErrorTrace( (LPARAM)this,"Wait failed after TransmitFile: dwWait is %d", dwWait);
			    ErrorTrace( (LPARAM)this, "GetLastError is %d", GetLastError());

                return FALSE;
			}
		}
		else
		{
			ErrorTrace( (LPARAM)this, "TransmitFile error sending to %s", inet_ntoa(m_RemoteIpAddress));
			ErrorTrace( (LPARAM)this, "GetLastError is %d", dwError);

			return FALSE;
		}
	}

	return TRUE;
}

BOOL
CPersistentConnection::fRecv(
		IN OUT LPSTR  lpBuffer,
		IN OUT DWORD& cbBytes
		)
/*++

Routine Description :

	Receive data from remote

Arguemnts :

	IN OUT LPSTR  lpBuffer	:	buffer is allocated by caller
								data received is returned in lpBuffer
	IN OUT DWORD& cbBytes	:	IN - size of lpBuffer in bytes
								OUT - size of data returned in lpBuffer
								(what you get may be less than what you
								asked for)

Return Value :
	TRUE if successful - FALSE otherwise !

--*/
{
	int nRecv = 0;
	int flags = 0;
    DWORD dwError;

	TraceFunctEnter("CPersistentConnection::fRecv");

	_ASSERT(lpBuffer);
    _ASSERT(m_fInitialized);

    // blocking recv() with timeout
	nRecv = recv(m_Socket, lpBuffer, (int)cbBytes, flags);
	if(nRecv <= 0)
	{
        dwError = WSAGetLastError();
		ErrorTrace( (LPARAM)this, "Error receiving %d bytes from %s", cbBytes, inet_ntoa(m_RemoteIpAddress));
		ErrorTrace( (LPARAM)this, "WSAGetLastError is %d", dwError);
		cbBytes = 0;
		return FALSE;
	}

	// set the number of bytes actually received
	cbBytes = (DWORD)nRecv;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\queue.inl ===
//
// Queue.inl
//
//	This file contains Inline functions for the classes defined in queue.h
//

#ifndef	Assert
#define	Assert	_ASSERT
#endif

#ifndef _NO_TEMPLATES_

template< class	Element > 
TOrderedList< Element >::TOrderedList( ) {}

template< class	Element >
BOOL	TOrderedList< Element >::Compare( CQElement *pLHS, CQElement *pRHS ) {
	return	(*((Element*)pLHS)) < (*((Element*)pRHS)) ;
}

template< class Element > 
void	TOrderedList< Element >::Insert( Element *pElement ) {
	COrderedList::Insert( pElement,  TOrderedList< Element >::Compare ) ;
}

template< class Element > 
Element*	TOrderedList< Element >::GetHead( ) {
	return	(Element*)COrderedList::GetHead() ;
}

template< class Element > 
Element*	TOrderedList< Element >::RemoveHead( ) {
	return	(Element*)COrderedList::RemoveHead() ;
}

template< class	Element >
BOOL	TOrderedList< Element >::IsEmpty()	{
	return	COrderedList::IsEmpty() ;
}

template< class	Element >
void	TOrderedList< Element >::Append(	Element*	pElement	)	{
	COrderedList::Append( pElement, TOrderedList< Element >::Compare ) ;
}


#else

#define	DECLARE_ORDEREDLISTFUNC( Element )	\
BOOL	TOrderedList ## Element ::Compare( CQElement *pLHS, CQElement *pRHS ) {	\
	return	(*((Element*)pLHS)) < (*((Element*)pRHS)) ;	\
}	\
void	TOrderedList ## Element ::Insert( Element *pElement ) {	\
	COrderedList::Insert( pElement,  TOrderedList ## Element ::Compare ) ;	\
}	\
Element*	TOrderedList ## Element ::GetHead( ) {	\
	return	(Element*)COrderedList::GetHead() ;	\
}	\
Element*	TOrderedList ## Element ::RemoveHead( ) {	\
	return	(Element*)COrderedList::RemoveHead() ;	\
}	\
BOOL	TOrderedList ## Element ::IsEmpty()	{	\
	return	COrderedList::IsEmpty() ;	\
}	\
void	TOrderedList ## Element ::Append(	Element*	pElement	)	{	\
	COrderedList::Append( pElement, TOrderedList ## Element ::Compare ) ;	\
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\rebuild.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rebuild.cpp

Abstract:

    This module contains the rebuilding code for the chkhash

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

    Kangrong Yan ( KangYan )    22-Oct-1998
        Move them into rebuild object

--*/

#include "tigris.hxx"
#include <stdlib.h>
#include "chkhash.h"

#define MAX_KEY_LEN		32
#define MAX_GROUPNAME   1024
#define MAX_BUILD_THREADS 64

static char mszStarNullNull[3] = "*\0";

DWORD	__stdcall	RebuildThread( void	*lpv ) ;
DWORD	__stdcall	RebuildThreadEx( void	*lpv ) ;

void
CRebuild::StopServer()
/*++
Routine description:

    Stop the server, in case rebuild failed somewhere after the server is started, 
    we should set the server back to stopped state
    
Arguments:

    None.

Return value:

    None.
--*/
{
    TraceFunctEnter( "CRebuild::StopServer" );
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    DWORD   cSecs = 0;

    m_pInstance->m_BootOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL;
    if( mb.Open( m_pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE ) ) {
	    DebugTrace(0,"Stopping instance %d: Rebuild cancelled", m_pInstance->QueryInstanceId());
	    if(	!mb.SetDword( "", MD_SERVER_COMMAND, IIS_MD_UT_SERVER, MD_SERVER_COMMAND_STOP) )
	    {
    	    //
		    //	failed to set server state to stopped
		    //
		    _ASSERT( FALSE );
	    }
	    mb.Close();

        //
	    //	wait for instance to stop (timeout default is 2 min - reg config)
	    //

        cSecs = 0;
        while( m_pInstance->QueryServerState() != MD_SERVER_STATE_STOPPED ) {
		    Sleep( 1000 );
		    if( (((cSecs++)*1000) > dwStartupLatency) || (g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) )
                return;		    
	    }
	} else {
	    _ASSERT( FALSE && "Open mb to stop server failed" );
	}

	TraceFunctLeave();
}
    
BOOL
CRebuild::StartServer()
/*++
Routine description:

    Start the server

Arguments:

    None.

Return value:

    TRUE on success, FALSE otherwise
--*/
{
    TraceFunctEnter( "CCompleteRebuild::StartServer" );
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    DWORD   cSecs = 0;

    if( mb.Open( m_pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE ) ) {
        DebugTrace(0,"Starting instance %d before rebuild", m_pInstance->QueryInstanceId());
        if( !mb.SetDword(   "", 
                            MD_SERVER_COMMAND, 
                            IIS_MD_UT_SERVER, 
                            MD_SERVER_COMMAND_START) ) {
            //
            //  failed to set server state to started
            //
            _ASSERT( FALSE );
            ErrorTrace( 0, "Set start command in mb failed %d", GetLastError() );
            NntpLogEventEx( NNTP_REBUILD_FAILED,
                            0,
                            NULL,
                            GetLastError(),
                            m_pInstance->QueryInstanceId() ) ;

            TraceFunctLeave();
            return FALSE;
        }
        
        mb.Close();
    } else {
        ErrorTrace( 0, "Open mb for starting server failed %d", GetLastError() );
        TraceFunctLeave();
        return FALSE;
    }

    //
    // We should wait for the server to start: we'll time out in two minutes, since
    // starting the server without having to load group.lst should be fast, given 
    // that all the driver connections are asynchronous.
    //
    while( m_pInstance->QueryServerState() != MD_SERVER_STATE_STARTED ) {
        Sleep( 1000 );
        if( (((cSecs++)*1000) > dwStartupLatency ) || (g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) ) {
            ErrorTrace( 0, "Server can not be started" );   
            NntpLogEventEx( NNTP_REBUILD_FAILED,
                            0,
                            NULL,
                            GetLastError(),
                            m_pInstance->QueryInstanceId() ) ;

            SetLastError( ERROR_SERVICE_START_HANG );
            return FALSE;
	    }
	}

    //
    // Now we should wait until all the vroots get into stable state
    //
    if ( !m_pInstance->BlockUntilStable() ) {
        ErrorTrace( 0, "Block until stable failed %d", GetLastError() );
        TraceFunctLeave();
        StopServer();
        return FALSE;
    }

    //
    // If we care about all the vroots to be connected, we 'll check this
    //
    if ( !m_pInstance->m_BootOptions->SkipCorruptVRoot && 
            !m_pInstance->AllConnected() ) {
        ErrorTrace( 0, "Rebuild failed due to some vroots not connected" );
        NntpLogEventEx( NNTP_REBUILD_FAILED,
                        0,
                        NULL,
                        GetLastError(),
                        m_pInstance->QueryInstanceId() ) ;
        StopServer();
        TraceFunctLeave();
        return FALSE;
    }

    //
    // If we are cancelled, should return FALSE
    //
    if ( m_pBootOptions->m_dwCancelState == NNTPBLD_CMD_CANCEL_PENDING ||
        g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) {
        DebugTrace( 0, "Rebuild cancelled" );
        NntpLogEventEx( NNTP_REBUILD_FAILED,
                        0,
                        NULL,
                        GetLastError(),
                        m_pInstance->QueryInstanceId() ) ;

        SetLastError( ERROR_OPERATION_ABORTED );
        StopServer();
        TraceFunctLeave();
        return FALSE;
    }

    //
    // OK, we are sure that server is properly started as far as we are concerned
    //
    TraceFunctLeave();
    return TRUE;
}
   
BOOL
CRebuild::DeletePatternFiles(
	LPSTR			lpstrPath,
	LPSTR			lpstrPattern
	)
/*++

Routine Description : 

	This function deletes all files matching a pattern in the <nntpfile> directory.
	This should be used by nntpbld to clean up old feed queues, hdr files etc !

Arguments : 
	lpstrPath		- Path to a file in the <nntpfile> directory eg. article.hsh
	lpstrPattern	- Pattern to delete eg: *.fdq

Return Value : 
	TRUE if successfull, FALSE otherwise.

--*/
{
    char szFile [ MAX_PATH ];
	char szPath [ MAX_PATH ];
	WIN32_FIND_DATA FileStats;
	HANDLE hFind;
	BOOL fRet = TRUE;
	szFile[0] = '\0' ;

	if( lpstrPath == 0 || lpstrPath[0] == '\0'  )
		return FALSE;

	//
	//	Build the pattern search path
	//
	lstrcpy( szFile, lpstrPath );

	// strip the path of trailing filename
	char* pch = szFile+lstrlen(lpstrPath)-1;
	while( pch >= szFile && (*pch-- != '\\') );	// skip till we see a \
	if( pch == szFile ) return FALSE;
	*(pch+2) = '\0';		// null-terminate the path

	// tag on the pattern wildcard and save the path
	lstrcpy( szPath, szFile  );
	lstrcat( szFile, lpstrPattern );

	//
	//	Do a FindFirst/FindNext on this wildcard and delete any files found !
	//
	if( szFile[0] != '\0' ) 
    {
		hFind = FindFirstFile( szFile, &FileStats );

        if ( INVALID_HANDLE_VALUE == hFind )
		{
			// TODO: Check GetLastError()
			fRet = TRUE;
		}
		else
		{
    		do
			{
				// build the full filename
				wsprintf( szFile, "%s%s", szPath, FileStats.cFileName );

				if(!DeleteFile( szFile ))
				{
					m_pBootOptions->ReportPrint("Error deleting file %s: Error is %d\n", FileStats.cFileName, GetLastError());
					fRet = FALSE;
				}
				else
				{
					m_pBootOptions->ReportPrint("Deleted file %s \n", szFile);
				}
			
			} while ( FindNextFile( hFind, &FileStats ) );

			_ASSERT(GetLastError() == ERROR_NO_MORE_FILES);

			FindClose( hFind );
		}
	}

	return fRet;
}

VOID
CRebuild::DeleteSpecialFiles()
/*++
Routine description:

    Delete the message files in special directory ( slave ).
    They should have no nov-entries / map entries in hash 
    tables to be cleaned up

Arguments:

    None.

Return value:

    None.  Failure in deleting slave files are not fatal error for rebuild.
--*/
{
    TraceFunctEnter( "CRebuild::DeleteSpecialFiles" );

    CNNTPVRootTable  *pVRTable  = NULL;
    NNTPVROOTPTR    pVRoot      = NULL;
    HRESULT         hr          = S_OK;
    LPCWSTR         pwszVRConfig= NULL;
    DWORD           dwLen       = 0;
    CHAR            szVRPath[MAX_PATH+1];

    //
    // Get the vroot table and search for the slave vroot
    //

    _ASSERT( m_pInstance );
    pVRTable = m_pInstance->GetVRTable();
    
    hr = pVRTable->FindVRoot( "_slavegroup._slavegroup", &pVRoot );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "VRTable has no slave root: %x", hr );
        return;
    };

    //
    // Get MD config path from the vroot
    //

    strcpy( szVRPath, pVRoot->GetDirectory());

    //
    // Just to make DeletePatternFiles happy, if szVRPath is not "\\" 
    // terminated, we'll add it
    //

    dwLen = strlen( szVRPath );
    _ASSERT( dwLen < MAX_PATH );
    if ( dwLen == 0 || *(szVRPath + dwLen - 1) != '\\' ) {
        *(szVRPath + dwLen ) = '\\';
        *(szVRPath + dwLen + 1 ) = '\0';
    }

    //
    // Now delete all files under the vrpath
    //
        
    DeletePatternFiles( szVRPath, "*.nws" );

    TraceFunctLeave();
}

BOOL
CCompleteRebuild::DeleteServerFiles()
/*++
Routine description:

    Delete all the server files.

Arguments:

    None.

Reurn value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CCompleteRebuild::DeleteServerFiles" );
	CHAR szArticleTableFile [MAX_PATH+1];
	CHAR szFile [MAX_PATH+1];
	CHAR szVarFile[MAX_PATH+1];
	LPSTR   pch;
	BOOL fRet = TRUE ;
	MB   mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

	//
	//	Open the metabase to read file paths
	//
	if( !mb.Open( m_pInstance->QueryMDPath() ) ) {
		m_pBootOptions->ReportPrint(    "Failed to open mb path %s\n", 
			                            m_pInstance->QueryMDPath());
        TraceFunctLeave();
		return FALSE ;
	}

	DWORD dwSize = MAX_PATH ;
	if( !mb.GetString(	"",
						MD_ARTICLE_TABLE_FILE,
						IIS_MD_UT_SERVER,
						szArticleTableFile,
						&dwSize  ) )
	{
		m_pBootOptions->ReportPrint("Failed to get article table file from mb: %d \n", 
			                        GetLastError());
		fRet = FALSE ;
		goto Exit;
	}

	//
	//	delete all *.hdr files in the <database> folder
	//

	if (!DeletePatternFiles( szArticleTableFile, "*.hdr" ) )
	{
		m_pBootOptions->ReportPrint("Failed to delete hash table hdr files.\n");
		m_pBootOptions->ReportPrint("Please delete all *.hdr files before running nntpbld\n");
		fRet = FALSE ;
		goto Exit;
	}

	//
	//	delete the article table file
	//

    if (!DeleteFile(szArticleTableFile)) {
        if ( GetLastError()!=ERROR_FILE_NOT_FOUND ) {
            m_pBootOptions->ReportPrint("cannot delete %s. Error %d\n",
                szArticleTableFile, GetLastError());
			fRet = FALSE ;
			goto Exit;
        }
    }

	//
	//	Get and delete the xover table file
	//

	dwSize = MAX_PATH ;
	if( !mb.GetString(	"",
						MD_XOVER_TABLE_FILE,
						IIS_MD_UT_SERVER,
						szFile,
						&dwSize  ) )
	{
		m_pBootOptions->ReportPrint("Failed to get xover table file from mb: %d \n", 
			GetLastError());
		fRet = FALSE ;
		goto Exit;
	}

    if (!DeleteFile(szFile)) {
        if ( GetLastError()!=ERROR_FILE_NOT_FOUND ) {
            m_pBootOptions->ReportPrint("cannot delete %s. Error %d\n",
                szFile, GetLastError());
			fRet = FALSE ;
			goto Exit;
        }
    }

	//
	//	Get and delete the history table file
	//

	dwSize = MAX_PATH ;
	if( !mb.GetString(	"",
						MD_HISTORY_TABLE_FILE,
						IIS_MD_UT_SERVER,
						szFile,
						&dwSize  ) )
	{
		m_pBootOptions->ReportPrint("Failed to get history table file from mb: %d \n", 
			GetLastError());
		fRet = FALSE ;
		goto Exit;
	}

    if ( !m_pBootOptions->NoHistoryDelete && !DeleteFile(szFile)) {
        if ( GetLastError()!=ERROR_FILE_NOT_FOUND ) {
            m_pBootOptions->ReportPrint("cannot delete %s. Error %d\n",
                szFile, GetLastError());
			fRet = FALSE ;
			goto Exit;
        }
    }

	//
	//	Get and delete the group.lst file
	//

	dwSize = MAX_PATH ;
	if( !mb.GetString(	"",
						MD_GROUP_LIST_FILE,
						IIS_MD_UT_SERVER,
						szFile,
						&dwSize  ) )
	{
		m_pBootOptions->ReportPrint("Failed to get group.lst file from mb: %d \n", 
			GetLastError());
		fRet = FALSE ;
		goto Exit;
	}

	if( !DeleteFile( szFile ) ) {
		if( GetLastError() != ERROR_FILE_NOT_FOUND ) {
            m_pBootOptions->ReportPrint("cannot delete group file. Error %d\n", 
				GetLastError());
			fRet = FALSE ;
			goto Exit;
		}
	}

	//
	// Also delete group.lst.ord, if any
	//
	strcat( szFile, ".ord" );
	_ASSERT( strlen( szFile ) <= MAX_PATH );
	if( !DeleteFile( szFile ) ) {
	    if ( GetLastError() != ERROR_FILE_NOT_FOUND ) {
	        m_pBootOptions->ReportPrint("can not delete group.lst.ord. Error %d\n", 
	            GetLastError());
	        fRet = FALSE;
	        goto Exit;
	    }
	}

	//
	// Delete groupvar.lst
	//
	dwSize = MAX_PATH ;
	*szVarFile = 0;
	if( !mb.GetString(	"",
						MD_GROUPVAR_LIST_FILE,
						IIS_MD_UT_SERVER,
						szVarFile,
						&dwSize  ) || *szVarFile == 0 )
	{
		//
		// We know that it's at the same spot as group.lst
		//
		strcpy( szVarFile, szFile );
		pch = szVarFile + strlen( szFile ) - 8;    // get to "group"
		strcpy( pch, "var.lst" );               // now we get "groupvar.lst
		_ASSERT( strlen( szVarFile ) < MAX_PATH + 1 );
	}

	if( !DeleteFile( szVarFile ) ) {
		if( GetLastError() != ERROR_FILE_NOT_FOUND ) {
            m_pBootOptions->ReportPrint("cannot delete group file. Error %d\n", 
				GetLastError());
			fRet = FALSE ;
			goto Exit;
		}
	}

	//
	//	delete old feedq files lying around
	//	These files contain <groupid, articleid> pairs that are made obsolete by nntpbld !
	//

	if (!DeletePatternFiles( szArticleTableFile, "*.fdq" ) )
	{
		m_pBootOptions->ReportPrint("Failed to delete Feed Queue files.\n");
		m_pBootOptions->ReportPrint("Please delete all *.fdq files before running nntpbld\n");
		fRet = FALSE ;
		goto Exit;
	}

Exit:

	_VERIFY( mb.Close() );
	return fRet ;
}

BOOL
CCompleteRebuild::PrepareToStartServer()
/*++
Routine description:

    All the work done here should make the server bootable and readable.  
    Though the server will keep in non-posting mode

Arguments:

    None.

Return value:

    TRUE, if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CCompleteRebuild::PrepareToStartServer" );

    //
    // For complete rebuild ( clean rebuild ), we need to delete all the server
    // files, after which we are sure that the server will boot.  We should
    // still ask for the opinion of DoClean though
    //
    if ( m_pBootOptions->DoClean ) {

        if ( !DeleteServerFiles() ) {
            ErrorTrace( 0, "Delete server files failed with %d", GetLastError() );
            NntpLogEventEx( NNTP_REBUILD_FAILED,
                            0,
                            NULL,
                            GetLastError(),
                            m_pInstance->QueryInstanceId() ) ;

            TraceFunctLeave();
            return FALSE;
        }
    }

    //
    // OK, tell others that we are ready
    //
    m_pBootOptions->IsReady = TRUE;

    TraceFunctLeave();
    return TRUE;
}

DWORD WINAPI
CCompleteRebuild::RebuildThread( void	*lpv ) 
{

    TraceQuietEnter("CCompleteRebuild::RebuildThread");

    BOOL fRet = TRUE;

	PNNTP_SERVER_INSTANCE pInstance = (PNNTP_SERVER_INSTANCE)lpv;
	CBootOptions*	pOptions = pInstance->m_BootOptions;
	CGroupIterator* pIterator = pOptions->m_pIterator;

	_ASSERT( pInstance );
	_ASSERT( pOptions  );
	_ASSERT( pIterator );

	if( pOptions->m_fInitFailed ) {
		// initialization error - bail !
		return 0;
	}

	CNewsTree* ptree = pInstance->GetTree();
	CGRPPTR	pGroup;

	//
	//	All the worker threads share a global iterator; all threads are done
	//	when together they have iterated over the newstree. 
	//	NOTE: the lock ensures that no two threads will process the same group !
	//

	while( !ptree->m_bStoppingTree )	{

	    //
	    // If I am cancelled, should not continue
	    //
	    if ( pOptions->m_dwCancelState == NNTPBLD_CMD_CANCEL_PENDING ||
	         g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING)  {
	        SetLastError( ERROR_OPERATION_ABORTED );
	        pOptions->m_fInitFailed = TRUE;     // Should tell everybody else to stop
	        fRet = FALSE;
	        break;
	    }

		EnterCriticalSection( &pOptions->m_csIterLock );

		if( pIterator->IsEnd() ) {
			LeaveCriticalSection( &pOptions->m_csIterLock );
			break;
		} else {
			pGroup = pIterator->Current() ;	
			pIterator->Next() ;
		}

		LeaveCriticalSection( &pOptions->m_csIterLock );

        //
		// Delete any .XIX files that might be present for this group.
		//
		char szPath[MAX_PATH*2];
		char szFile[MAX_PATH];
		BOOL fFlatDir;
		if (pGroup->ComputeXoverCacheDir(szPath, fFlatDir)) {

		    // Make sure path has \ at the end, then append *.xix
		    DWORD dwLen = strlen( szPath );
            _ASSERT( dwLen < MAX_PATH );
            if ( dwLen == 0 || *(szPath + dwLen - 1) != '\\' ) {
                *(szPath + dwLen ) = '\\';
                *(szPath + dwLen + 1 ) = '\0';
            }

    	    WIN32_FIND_DATA FileStats;
	        HANDLE hFind;

            wsprintf(szFile, "%s%s", szPath, "*.xix");
		    hFind = FindFirstFile( szFile, &FileStats );

            if ( INVALID_HANDLE_VALUE == hFind ) {
                if (GetLastError() != ERROR_FILE_NOT_FOUND) {
		            ErrorTrace(0, "FindFirstFile failed on %s, error %d",
		                szFile, GetLastError());
		        }
		    } else {
    		    do {
				    // build the full filename
    				wsprintf( szFile, "%s%s", szPath, FileStats.cFileName );

	    			if(!DeleteFile( szFile ) && GetLastError() != ERROR_FILE_NOT_FOUND) {
		    			pOptions->ReportPrint("Error deleting file %s: Error is %d\n", szFile, GetLastError());
				    }
	    		} while ( FindNextFile( hFind, &FileStats ) );

		    	_ASSERT(GetLastError() == ERROR_NO_MORE_FILES);

			    FindClose( hFind );
		    }
		}

		// scan articles on disk and process them
		fRet = pGroup->RebuildGroup( NULL ) ;

		// bail out - CNewsgroup::ProcessGroup fails only on catastrophic errors
		// if this error is truly catastrophic, other threads will bail too !
		if(!fRet) {
		    ErrorTrace(0, "RebuildGroup failed, %x", GetLastError());
		    pOptions->m_fInitFailed = TRUE;
		    pOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL_PENDING;
		    break;
		}
	}

	return	fRet ;
} // RebuildThread

BOOL
CCompleteRebuild::RebuildGroupObjects()
/*++
Routine description:

    Create a pool of rebuild threads, each thread enumerates
    on the newstree and does RebuildGroup into driver.  This
    function is equivalent to "ProcessGroupFile" in MCIS2.0
    
Arguments:

    None.

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CCompleteRebuild::RebuildGroupObjects" );

	HANDLE rgBuildThreads [MAX_BUILD_THREADS];
	DWORD dwThreadId, cThreads;
	BOOL  fRet = TRUE;
	CNewsTree* ptree = NULL;

	CBootOptions* pOptions = m_pInstance->m_BootOptions ;
	ptree = m_pInstance->GetTree() ;
	_ASSERT( pOptions );

	pOptions->m_fInitFailed = FALSE;
	pOptions->m_pIterator = NULL;

	//
	//	Get the shared group iterator - this is used by all rebuild threads
	//
	if( !(pOptions->m_pIterator = ptree->GetIterator( mszStarNullNull, TRUE )) ) {
	    ErrorTrace(0, "GetIterator failed, %d", GetLastError());
		return FALSE;
	}

	//
	//	Lock to synchronize access to global iterator
	//
	InitializeCriticalSection( &pOptions->m_csIterLock );

	// validate num threads
	if( !pOptions->cNumThreads ||  pOptions->cNumThreads > MAX_BUILD_THREADS ) {
		SYSTEM_INFO si;
		GetSystemInfo( &si );
		pOptions->cNumThreads = si.dwNumberOfProcessors * 4;	// 4 threads per proc
	}

	for( cThreads = 0; cThreads < pOptions->cNumThreads; cThreads++ ) {
		rgBuildThreads [cThreads] = NULL;
	}

	//
	//	Multi-threaded nntpbld - spawn worker threads to scan the newstree
	//	Each worker thread picks a group and rebuilds it
	//
	for( cThreads = 0; cThreads < pOptions->cNumThreads; cThreads++ ) 
	{
		rgBuildThreads [cThreads] = CreateThread(
										NULL,				// pointer to thread security attributes
										0,					// initial thread stack size, in bytes
										RebuildThread,		// pointer to thread function
										(LPVOID)m_pInstance,// argument for new thread
										CREATE_SUSPENDED,	// creation flags
										&dwThreadId			// pointer to returned thread identifier
										) ;

		if( rgBuildThreads [cThreads] == NULL ) {
		    ErrorTrace(0, "CreateThread failed, %d", GetLastError());
			pOptions->ReportPrint("Failed to create rebuild thread %d: error is %d", cThreads+1, GetLastError() );
			pOptions->m_fInitFailed = TRUE;
			break;
		}
	}

	//
	//	Resume all threads and wait for threads to terminate
	//
	for( DWORD i=0; i<cThreads; i++ ) {
		_ASSERT( rgBuildThreads[i] );
		DWORD dwRet = ResumeThread( rgBuildThreads[i] );
		_ASSERT( 0xFFFFFFFF != dwRet );
	}

	//
	//	Wait for all rebuild threads to finish
	//
	DWORD dwWait = WaitForMultipleObjects( cThreads, rgBuildThreads, TRUE, INFINITE );

	if( WAIT_FAILED == dwWait ) {
	    ErrorTrace(0, "WaitForMultipleObjects failed: error is %d", GetLastError());
		pOptions->ReportPrint("WaitForMultipleObjects failed: error is %d", GetLastError());
		pOptions->m_fInitFailed = TRUE;
	}

	//
	//	Cleanup
	//
	for( i=0; i<cThreads; i++ ) {
		_VERIFY( CloseHandle( rgBuildThreads[i] ) );
		rgBuildThreads [i] = NULL;
	}
	XDELETE pOptions->m_pIterator;
	pOptions->m_pIterator = NULL;
	DeleteCriticalSection( &pOptions->m_csIterLock );

	//
    // None of the groups have been saved to group.lst or groupvar.lst yet
    // We'll call Savetree to save them
    //
    if ( pOptions->m_fInitFailed == FALSE ) {
        if ( !ptree->SaveTree( FALSE ) ) {
            ErrorTrace( 0, "Save tree failed during rebuild %d", GetLastError() );
            TraceFunctLeave();
            return FALSE;
        }
    }

	return !pOptions->m_fInitFailed;
}

BOOL
CStandardRebuild::PrepareToStartServer()
/*++
Routine description:

    All the work done here should make the server bootable and
    readable.  Though the server will keep in non-posting mode.

Arguments:

    None.

Return value:

    TRUE, if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CStandardRebuild::PrepareToStartServer" );

    CHAR szGroupListFile [MAX_PATH+1];
	CHAR szVarFile[MAX_PATH+1];
	BOOL fRet = TRUE ;
	MB   mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
	LPSTR   pch;

	//
	//	Open the metabase to read file paths
	//
	if( !mb.Open( m_pInstance->QueryMDPath() ) ) {
		m_pBootOptions->ReportPrint(    "Failed to open mb path %s\n", 
			                            m_pInstance->QueryMDPath());
        TraceFunctLeave();
		return FALSE ;
	}

	DWORD dwSize = MAX_PATH ;
	if( !mb.GetString(	"",
						MD_GROUP_LIST_FILE,
						IIS_MD_UT_SERVER,
						szGroupListFile,
						&dwSize  ) )
	{
		m_pBootOptions->ReportPrint("Failed to get article table file from mb: %d \n", 
			                        GetLastError());
		fRet = FALSE ;
		goto Exit;
	}

	//
	//	delete group.lst and group.lst.ord
	//
    if( !DeleteFile( szGroupListFile ) ) {
		if( GetLastError() != ERROR_FILE_NOT_FOUND ) {
            m_pBootOptions->ReportPrint("cannot delete group file. Error %d\n", 
				GetLastError());
			fRet = FALSE ;
			goto Exit;
		}
	}

	strcat( szGroupListFile, ".ord" );
	_ASSERT( strlen( szGroupListFile ) <= MAX_PATH );
	if( !DeleteFile( szGroupListFile ) ) {
	    if ( GetLastError() != ERROR_FILE_NOT_FOUND ) {
	        m_pBootOptions->ReportPrint("can not delete group.lst.ord. Error %d\n", 
	            GetLastError());
	        fRet = FALSE;
	        goto Exit;
	    }
	}

	//
	// Delete groupvar.lst
	//
	dwSize = MAX_PATH ;
	*szVarFile = 0;
	if( !mb.GetString(	"",
						MD_GROUPVAR_LIST_FILE,
						IIS_MD_UT_SERVER,
						szVarFile,
						&dwSize  ) || *szVarFile == 0 )
	{
		//
		// We know that it's at the same spot as group.lst
		//
		strcpy( szVarFile, szGroupListFile );
		pch = szVarFile + strlen( szGroupListFile ) - 8;    // get to "group"
		strcpy( pch, "var.lst" );               // now we get "groupvar.lst
		_ASSERT( strlen( szVarFile ) < MAX_PATH + 1 );

	}

	if( !DeleteFile( szVarFile ) ) {
		if( GetLastError() != ERROR_FILE_NOT_FOUND ) {
            m_pBootOptions->ReportPrint("cannot delete group file. Error %d\n", 
				GetLastError());
			fRet = FALSE ;
			goto Exit;
		}
	}

Exit:
	_VERIFY( mb.Close() );

	//
	// OK, tell others that we are ready
	//
	m_pBootOptions->IsReady = TRUE;
	
	return fRet;
}

BOOL
CStandardRebuild::RebuildGroupObjects()
/*++
Routine description:

    Rebuild group objects, adjust watermarks/article counts based on xover
    table.  We assume that each group is empty, since rebuild's 
    DecorateNewsTree should not have set article count / watermarks

Arguments:

    None.

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CStandardRebuild::RebuildGroupObjects" );

    //
    // Get the xover table pointer, we are sure that the server ( hence hash
    // table ) was properly started up, since we waited for the server to
    // start somewhere before
    //
    CXoverMap* pXoverTable = m_pInstance->XoverTable();
    _ASSERT( pXoverTable );

    //
    // Get the newstree, which is what we'll work against during the rest
    // of time
    //
    CNewsTree* pTree = m_pInstance->GetTree();
    _ASSERT( pTree );

    //
    // Now we'll enumerate the xover table
    //
    CXoverMapIterator*  pIterator = NULL;
    BOOL                f = FALSE;
    GROUPID             groupid;
    ARTICLEID           articleid;
    BOOL                fIsPrimary;
    CStoreId            storeid;
    DWORD               cGroups;
    CGRPPTR	            pGroup = NULL;
    DWORD               cMessages;

    //
    // We should not have to worry about the buffer size passed in because
    // the only thing we need is groupid/articleid, which are of fixed size
    //
	f = pXoverTable->GetFirstNovEntry(  pIterator,
	                                    groupid,
	                                    articleid,
	                                    fIsPrimary,
	                                    0,
	                                    NULL,
	                                    storeid,
	                                    0,
	                                    NULL,
	                                    cGroups );
    while( f ) {

        //
        // If I am told to cancel, I should not continue
        //
        if ( m_pBootOptions->m_dwCancelState == NNTPBLD_CMD_CANCEL_PENDING ||
             g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) {
            DebugTrace( 0, "Rebuild aborted" );
            XDELETE pIterator;
            SetLastError( ERROR_OPERATION_ABORTED );
            m_pInstance->SetRebuildLastError( ERROR_OPERATION_ABORTED );
            return FALSE;
        }

        //
        // Find the group from tree
        //
        pGroup = pTree->GetGroupById( groupid );
        if ( !pGroup ) {

            //
            // xover table is insonsistent with newstree, which is built from
            // store.  We'll have to fail the standard rebuild
            //
            ErrorTrace( 0, "xover table is inconsistent with newstree" );
            XDELETE pIterator;
            SetLastError( ERROR_FILE_CORRUPT );
            m_pInstance->SetRebuildLastError( ERROR_FILE_CORRUPT );
            return FALSE;
        }

        //
        // Adjust high watermark
        //
        if ( articleid > pGroup->GetHighWatermark() )
            pGroup->SetHighWatermark( articleid );

        //
        // Adjust low watermark: we should be careful with the first article
        //
        if ( pGroup->GetMessageCount() == 0 ) {

            //
            // We set us to be low watermark, others will update it if they
            // are unhappy with this
            //
            pGroup->SetLowWatermark( articleid );
        } else {
            if ( articleid < pGroup->GetLowWatermark() ) 
                pGroup->SetLowWatermark( articleid );
        }

        //
        // Adjust article count
        //
        cMessages = pGroup->GetMessageCount();
        pGroup->SetMessageCount( ++cMessages );
        _ASSERT(    pGroup->GetMessageCount() <= 
                    pGroup->GetHighWatermark() - pGroup->GetLowWatermark() + 1 );

        //
        // OK, find the next entry from xover table
        //
        f = pXoverTable->GetNextNovEntry(   pIterator,
                                            groupid,
                                            articleid,
                                            fIsPrimary,
                                            0,
                                            NULL,
                                            storeid,
                                            0,
                                            NULL,
                                            cGroups );
    }

    //
    // We are done with the iterator
    //
    XDELETE pIterator;

    //
    // None of the groups have been saved to group.lst or groupvar.lst yet
    // We'll call Savetree to save them
    //
    if ( !pTree->SaveTree( FALSE ) ) {
        ErrorTrace( 0, "Save tree failed during rebuild %d", GetLastError() );
        SetLastError( GetLastError() );
        m_pInstance->SetRebuildLastError( GetLastError() );
        TraceFunctLeave();
        return FALSE;
    }

    //
    // Ok, we are completely done
    //
    TraceFunctLeave();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\rebuild.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:        rebuild.h
//
//  Contents:    definitions of CRebuildThread class
//
//  Functions:  
//
//  History:     03/15/97     Rajeev Rajan (rajeevr)  Created
//               10/21/98     Kangrong Yan ( kangyan ) Added rebuild objects
//
//-----------------------------------------------------------------------------


//
//	CRebuildThread derives from CWorkerThread for work-thread semantics
//	The base class handles the details of creating the thread and queueing
//	work requests to the derived class
//
//	CRebuildThread just needs to implement a virtual member - WorkCompletion()
//	that is called when a virtual server instance needs to be rebuilt. Rebuild
//	requests are queued in on RPCs.
//
//	Note that multiple rebuild threads may be active at any time. A particular
//	rebuild thread's WorkCompletion() routine gets a virtual server instance
//	and a group iterator object. The group iterator object is shared between
//	all the rebuild threads, so access to it needs to be synchronized. Each
//	rebuild thread will pick a group using the group iterator and rebuild the
//	group. No two threads will rebuild the same group. The virtual server
//	instance is rebuilt when any one thread finishes with the iterator. If 
//	there are more instances to be rebuilt, these will have been queued by the
//	base class and will be picked up. else, the rebuild threads will block
//	on GetQueuedCompletionStatus().
//
//	NOTE: The server will not normally create any rebuild threads - the first
//	time it gets an RPC to rebuild an instance it will create N CRebuildThread
//	objects - these will hang off the NNTP_IIS_SERVICE object. The number of
//	such threads will be configurable and good values should be selected based
//	on performance tests. Also, with virtual servers, rebuild activity on one
//	instance can go on in parallel with normal NNTP activity on other instances
//	that are functional.
//

#ifndef _REBUILD_H_
#define _REBUILD_H_

//
//	clients of CRebuildThread will queue LPREBUILD_CONTEXTs
//
typedef struct _REBUILD_CONTEXT
{
	NNTP_SERVER_INSTANCE  pInstance;	// the virtual server instance being rebuilt
	CGroupIterator*		  pIterator;	// group iterator shared by rebuild thread
	CRITICAL_SECTION	  csGrpIterator;// crit sect for sync access to iterator
} REBUILD_CONTEXT, *LPREBUILD_CONTEXT;

class CRebuildThread : public CWorkerThread
{
public:
	CRebuildThread()  {}
	~CRebuildThread() {}

protected:
	virtual VOID WorkCompletion( PVOID pvRebuildContext );
};

//
// KangYan:
// The change defines rebuild classes in an attempt to have two types of rebuild
// share common code.  CRebuild is the base class that defines common data
// and operations; CStandardRebuild is the actual implementation for standard
// rebuild; CCompleteRebuild is the actual implementation for complete clean 
// rebuild.  Each virtual instance has pointer to a rebuild object, whose type
// is determined at run time based on rpc requirement.  One virtual instance can not
// have two rebuilds in progress at the same time.  When rebuild is completed,
// the rebuild object should be destroyed.
//
class CRebuild {

public:

    //
    // Constructors, destructors
    //
    CRebuild(   PNNTP_SERVER_INSTANCE pInstance,
                CBootOptions *pBootOptions ) :
        m_pInstance( pInstance ),
        m_pBootOptions( pBootOptions )
    {}

    //
    // Start the server
    //
    BOOL StartServer();

    //
    // Stop the server
    //
    void StopServer();

    //
    // Preparation for building a tree
    //
    virtual BOOL PrepareToStartServer() = 0;

    //
    // Rebuild group objects and hash tables if necessary
    //
    virtual BOOL RebuildGroupObjects() = 0;

    //
    // Delete slave files
    //
    VOID DeleteSpecialFiles();


protected:

    ///////////////////////////////////////////////////////////////
    // Member variables
    ///////////////////////////////////////////////////////////////

    //
    // Back pointer to the virtual server
    //
    PNNTP_SERVER_INSTANCE   m_pInstance;

    //
    // Boot options
    //
    CBootOptions*    m_pBootOptions;

    ////////////////////////////////////////////////////////////////
    // Methods
    ////////////////////////////////////////////////////////////////
    //
    // Never allow to be constructed in this way by others
    //
    CRebuild() {}
    
    //
    // Delete server files with certain pattern
    //
    BOOL DeletePatternFiles(    LPSTR			lpstrPath,
                        	    LPSTR			lpstrPattern );

private:
    
};

class CStandardRebuild : public CRebuild {

public:

    ////////////////////////////////////////////////////////////////
    // Member variables
    ////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////
    // Methods
    ////////////////////////////////////////////////////////////////
    
    //
    // Constructors, destructors
    //
    CStandardRebuild(   PNNTP_SERVER_INSTANCE pInstance,
                        CBootOptions *pBootOptions ) :
        CRebuild( pInstance, pBootOptions )
    {}
    
    virtual BOOL PrepareToStartServer();

    virtual BOOL RebuildGroupObjects();

private:

    //
    // Never allow to be constructed in this way
    //
    CStandardRebuild() {}
};

class CCompleteRebuild : public CRebuild {

public:

    /////////////////////////////////////////////////////////////////
    // Member variables
    /////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////
    // Methods
    /////////////////////////////////////////////////////////////////

    //
    // Constructors, destructors
    //
    CCompleteRebuild(   PNNTP_SERVER_INSTANCE pInstance,
                        CBootOptions *pBootOptions ) :
        CRebuild( pInstance, pBootOptions )
    {}

    virtual BOOL PrepareToStartServer();

    virtual BOOL RebuildGroupObjects();

    static DWORD WINAPI RebuildThread( void	*lpv );

private:

    /////////////////////////////////////////////////////////////////
    // Methods
    /////////////////////////////////////////////////////////////////

    //
    // Never allow to be constructed in this way
    //
    CCompleteRebuild() {}

    //
    // Delete all the server files
    //
    BOOL DeleteServerFiles();
};

#endif // _REBUILD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\resource.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    resource.h  (nturtl.h)

Abstract:

    Include file for NT runtime routines that are callable by only
    user mode code in various.

Author:

    Steve Wood (stevewo) 10-Aug-1989

Environment:

    These routines are statically linked in the caller's executable and
    are callable in only from user mode.  They make use of Nt system
    services.

Revision History:

    Johnson Apacible (johnsona)     25-Sep-1995
        ported to Win32

--*/

#ifndef _RESOURCE_
#define _RESOURCE_

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _JTL_CRITICAL_SECTION_DEBUG {
    USHORT Type;
    USHORT CreatorBackTraceIndex;
    struct _JTL_CRITICAL_SECTION *CriticalSection;
    LIST_ENTRY ProcessLocksList;
    ULONG EntryCount;
    ULONG ContentionCount;
    ULONG Spare[ 2 ];
} JTL_CRITICAL_SECTION_DEBUG, *PJTL_CRITICAL_SECTION_DEBUG;

typedef struct _JTL_CRITICAL_SECTION {
    PJTL_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;        // from the thread's ClientId->UniqueThread
    HANDLE LockSemaphore;
    ULONG Reserved;
} JTL_CRITICAL_SECTION, *PJTL_CRITICAL_SECTION;

//
//  Shared resource function definitions
//

typedef struct _JTL_RESOURCE_DEBUG {
    ULONG Reserved[ 5 ];    // Make it the same length as JTL_CRITICAL_SECTION_DEBUG

    ULONG ContentionCount;
    ULONG Spare[ 2 ];
} JTL_RESOURCE_DEBUG, *PJTL_RESOURCE_DEBUG;

typedef struct _RESOURCE_LOCK {

    //
    //  The following field controls entering and exiting the critical
    //  section for the resource
    //

    JTL_CRITICAL_SECTION CriticalSection;

    //
    //  The following four fields indicate the number of both shared or
    //  exclusive waiters
    //

    HANDLE SharedSemaphore;
    ULONG NumberOfWaitingShared;
    HANDLE ExclusiveSemaphore;
    ULONG NumberOfWaitingExclusive;

    //
    //  The following indicates the current state of the resource
    //
    //      <0 the resource is acquired for exclusive access with the
    //         absolute value indicating the number of recursive accesses
    //         to the resource
    //
    //       0 the resource is available
    //
    //      >0 the resource is acquired for shared access with the
    //         value indicating the number of shared accesses to the resource
    //

    LONG NumberOfActive;
    HANDLE ExclusiveOwnerThread;

    ULONG Flags;        // See JTL_RESOURCE_FLAG_ equates below.

    PJTL_RESOURCE_DEBUG DebugInfo;
} RESOURCE_LOCK, *PRESOURCE_LOCK;


BOOL
InitializeResource(
    PRESOURCE_LOCK Resource
    );

BOOL
AcquireResourceShared(
    PRESOURCE_LOCK Resource,
    BOOL Wait
    );

BOOL
AcquireResourceExclusive(
    PRESOURCE_LOCK Resource,
    BOOL Wait
    );

VOID
ReleaseResource(
    PRESOURCE_LOCK Resource
    );

VOID
DeleteResource (
    PRESOURCE_LOCK Resource
    );


#ifdef __cplusplus
}
#endif

#endif  // _RESOURCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\rpcex.cxx ===
/*++
   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        rpcex.cxx

   Abstract:

        This module defines K2 rpc support.
		These functions are NYI for now. Need to migrate service RPCs
		to this.

   Author:

        Johnson Apacible    (JohnsonA)      June-19-1996

--*/


#include "tigris.hxx"
#include <timer.h>
#include <time.h>

#include "iiscnfg.h"
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::StartInstance
//
//  Synopsis:   Called to start an instance
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

DWORD
NNTP_SERVER_INSTANCE::StartInstance()
{
	DWORD err = NO_ERROR ;
	BOOL  fFatal = FALSE ;
	CHAR	szDebugStr [MAX_PATH+1];
	MB mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

	TraceFunctEnter("NNTP_SERVER_INSTANCE::StartInstance");
	EnterCriticalSection( &m_critRebuildRpc ) ;

	if( m_BootOptions && !m_BootOptions->IsReady ) {
		//
		//	non-null m_BootOptions indicates a pending rebuild
		//	we will disable Start() till the nntpbld thread sets
		//	IsReady to TRUE. This is done after it
		//	has cleared the hash tables, so it is safe to start.
		//
		err = ERROR_INVALID_SERVICE_CONTROL ;
		ErrorTrace((LPARAM)this,"Attempting to start instance %d during rebuild",QueryInstanceId());
		LeaveCriticalSection( &m_critRebuildRpc ) ;
		return err ;
	}

	if( !Start( fFatal ) ) {
		ErrorTrace((LPARAM)this,"Failed to start instance %d Error is %s", QueryInstanceId(), fFatal ? "fatal" : "non-fatal" );
		err = ERROR_SERVICE_DISABLED ;
		goto Exit ;
	}

	//
	//	If a rebuild is pending, start the instance in no-posting mode
	//	when the rebuild is done, we will auto-revert to posting mode
	//

	if( m_BootOptions ) {
		SetPostingModes( mb, FALSE, FALSE, FALSE );
	}

	//
	//	Let the base class do its work !
	//

	err = IIS_SERVER_INSTANCE::StartInstance();

Exit:

	if( err != NO_ERROR ) {
		ErrorTrace((LPARAM)this,"StartInstance failed: err is %d", err );
		Stop();
		wsprintf( szDebugStr, "Instance %d(%p) Start() failed: rebuild needed \n", QueryInstanceId(), (DWORD_PTR)this );
		OutputDebugString( szDebugStr );
	} else {
		wsprintf( szDebugStr, "Instance %d(%p) boot success\n", QueryInstanceId(), (DWORD_PTR)this );
		OutputDebugString( szDebugStr );
	}

	LeaveCriticalSection( &m_critRebuildRpc ) ;
	TraceFunctLeave();

	return err ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::StopInstance
//
//  Synopsis:   Called to stop an instance
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

DWORD
NNTP_SERVER_INSTANCE::StopInstance()
{
	DWORD err ;
	CNewsTree* pTree = NULL ;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::StopInstance");
	EnterCriticalSection( &m_critRebuildRpc ) ;

	if( m_BootOptions && (m_BootOptions->m_dwCancelState != NNTPBLD_CMD_CANCEL ) ) {
		//
		//	non-null m_BootOptions indicates a pending rebuild
		//	we will handle Stop() by pending a cancel
		//
		
		m_BootOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL_PENDING;
		err = ERROR_INVALID_SERVICE_CONTROL ;
		goto Exit ;
	}

	//	Stop the newstree - this allows long-winded loops to bail
	pTree = GetTree() ;
	if( pTree ) {
		pTree->StopTree();
	}

	err = IIS_SERVER_INSTANCE::StopInstance();

	if( err == NO_ERROR )
	{
		if( !Stop() ) {
			ErrorTrace((LPARAM)this,"Failed to stop instance %d", QueryInstanceId());
			err = ERROR_SERVICE_DISABLED ;
			goto Exit ;
		}
	}

Exit:

	LeaveCriticalSection( &m_critRebuildRpc ) ;
	TraceFunctLeave();

	return err ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::PauseInstance
//
//  Synopsis:   Called to pause an instance
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

DWORD
NNTP_SERVER_INSTANCE::PauseInstance()
{
	DWORD err = NO_ERROR ;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::PauseInstance");
	EnterCriticalSection( &m_critRebuildRpc ) ;

	//
	//	pause is always valid
	//

	err = IIS_SERVER_INSTANCE::PauseInstance() ;

	LeaveCriticalSection( &m_critRebuildRpc ) ;
	TraceFunctLeave();

	return err ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::ContinueInstance
//
//  Synopsis:   Called to continue instance
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

DWORD
NNTP_SERVER_INSTANCE::ContinueInstance()
{
	DWORD err = NO_ERROR ;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::ContinueInstance");
	EnterCriticalSection( &m_critRebuildRpc ) ;

	//
	//	continue is always valid
	//

	err = IIS_SERVER_INSTANCE::ContinueInstance() ;

	LeaveCriticalSection( &m_critRebuildRpc ) ;
	TraceFunctLeave();

	return err ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::CloseInstance
//
//  Synopsis:   Called when an instance is deleted
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::CloseInstance()
{
	BOOL fRet ;
	TraceFunctEnter("NNTP_SERVER_INSTANCE::CloseInstance");
	
	EnterCriticalSection( &m_critRebuildRpc ) ;

	if( m_BootOptions ) {
		//
		//	non-null m_BootOptions indicates a pending rebuild
		//	we need to cancel the rebuild - this will cause the rebuild
		//  thread to bail..
		//
		m_BootOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL_PENDING;
	}

	fRet = IIS_SERVER_INSTANCE::CloseInstance();

	LeaveCriticalSection( &m_critRebuildRpc ) ;
	
	TraceFunctLeave();
	return fRet ;
}

BOOL
NNTP_SERVER_INSTANCE::SetServiceConfig(
    IN PCHAR pBuffer
    )
/*++

   Description

       Sets the common service admin information for the servers specified
       in dwServerMask.

   Arguments:

       pConfig - Admin information to set

   Note:

--*/
{

    return TRUE;

} // NNTP_SERVER_INSTANCE::SetServiceConfig


BOOL
NNTP_SERVER_INSTANCE::GetServiceConfig(
    IN  PCHAR   pBuffer,
    IN  DWORD   dwLevel
    )
/*++

   Description

       Retrieves the admin information

   Arguments:

       pBuffer - Buffer to fill up.
       dwLevel - info level of information to return.

   Note:

--*/
{

	return TRUE ;

} // NNTP_SERVER_INSTANCE::GetServiceConfig



BOOL
NNTP_SERVER_INSTANCE::EnumerateUsers(
    OUT PCHAR * pBuffer,
    OUT PDWORD  nRead
    )
/*++

   Description

       Enumerates the connected users.

   Arguments:

       pBuffer - Buffer to fill up.

--*/
{
    BOOL fRet = TRUE;

    return fRet;

} // EnumerateUsers

BOOL
NNTP_SERVER_INSTANCE::DisconnectUser(
                        IN DWORD dwIdUser
                        )
/*++

   Description

       Disconnect the user

   Arguments:

       dwIdUser - Identifies the user to disconnect.  If 0,
           then disconnect ALL users.

--*/
{
    BOOL fRet = TRUE;

    //
    //  Do it.
    //

    return fRet;

} // DisconnectUser

BOOL
NNTP_SERVER_INSTANCE::GetStatistics(
                        IN DWORD dwLevel,
                        OUT PCHAR* pBuffer
                        )
/*++

   Description

       Disconnect Queries the server statistics

   Arguments:

       dwLevel - Info level.  Currently only level 0 is
           supported.

       pBuffer - Will receive a pointer to the statistics
           structure.

--*/
{
    APIERR err = NO_ERROR;


	return TRUE ;

} // QueryStatistics
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\smtpcli.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    smtpcli.cpp

Abstract:

	This module contains the implementation of the CSmtpClient class.
	This class encapsulates the functionality of an SMTP client. It
	inherits from the CPersistentConnection class for winsock/connection
	functionality.

Author:

    Rajeev Rajan (RajeevR)     19-May-1996

Revision History:

--*/

//
//	K2_TODO: move this into an independent lib
//
#define _TIGRIS_H_
#include "tigris.hxx"

#ifdef  THIS_FILE
#undef  THIS_FILE
#endif
static  char        __szTraceSourceFile[] = __FILE__;
#define THIS_FILE    __szTraceSourceFile

// system includes
#include <windows.h>
#include <stdio.h>
#include <winsock.h>

// user includes
#include <dbgtrace.h>
#include "smtpcli.h"

// SMTP command strings
static char* HeloCommand = "HELO ";
static char* MailFromCommand = "MAIL FROM:";
static char* RcptToCommand = "RCPT TO: ";
static char* DataCommand = "DATA\r\n";
static char* CRLF = "\r\n";

// constructor
CSmtpClient::CSmtpClient(LPSTR lpComputerName)
{
	m_pRecvBuffer [0] = 0;
	m_lpComputerName = lpComputerName;
    m_fDirty = FALSE;
}

// destructor
CSmtpClient::~CSmtpClient()
{

}

int
CSmtpClient::fReceiveFullResponse()
/*++

Routine Description : 

	Receive a full response from the SMTP server. This involves 
	possibly issuing multiple recvs till the server sends a CRLF.

	NULL terminate the recv buffer

Arguments : 

Return Value : 
	Returns number of bytes received; -1 for error

--*/
{
	TraceFunctEnter("CSmtpClient::fReceiveFullResponse");

	_ASSERT(m_CliState != sError);

	DWORD dwOffset = 0;
	DWORD cbSize = MAX_RECV_BUFFER_LEN - dwOffset;
	BOOL  fSawCRLF = FALSE;

	// till we get a CRLF or our recv buffer is not enough
	while(!fSawCRLF)
	{
		BOOL fRet = fRecv(m_pRecvBuffer+dwOffset, cbSize);
		if(!fRet)
		{
			ErrorTrace( (LPARAM)this, "Error receiving data");
			return -1;
		}

		DebugTrace( (LPARAM)this,"Received %d bytes", cbSize);

		// adjust offset for next recv
		dwOffset += cbSize;
		cbSize = MAX_RECV_BUFFER_LEN - dwOffset;

		// search the recv buffer for CRLF
		// BUGBUG: should do this repeatedly till we dont find a CR!
		char* pch = (char*)memchr((LPVOID)m_pRecvBuffer, CR, dwOffset);
		if(pch)
		{
			if( (pch - m_pRecvBuffer) < (int)dwOffset)
			{
				// CR is not the last byte
				if(*pch == CR && *(pch+1) == LF)
				{
					// CRLF found
					fSawCRLF = TRUE;
					m_pRecvBuffer[dwOffset] = '\0';		// Only need one line
				}
			}
		}

		// No CRLF
		if(dwOffset >= MAX_RECV_BUFFER_LEN)
		{
			ErrorTrace( (LPARAM)this, "Buffer size too small for server response");
			return -1;
		}
	}	// end while

	return dwOffset;
}

int
CSmtpClient::GetThreeDigitCode(
			IN LPSTR lpBuffer, 
			DWORD cbBytes
			)
/*++

Routine Description : 

	Get the three digit return code in the receive buffer

Arguments : 

	IN LPSTR lpBuffer	-	Receive buffer
	DWORD cbBytes		-   size of buffer

Return Value : 
	3-digit code in receive buffer

--*/
{
	_ASSERT(cbBytes >= 3);
	_ASSERT(lpBuffer);

	int Num = 0;
	int iDig;
	
	for (iDig = 0; iDig < 3; iDig++)
	{
		if (lpBuffer[iDig] < '0' || lpBuffer[iDig] > '9')
			return -1;
		Num *= 10;
		Num += (lpBuffer[iDig] - '0');
	}
	
	return Num;
}

BOOL	
CSmtpClient::fReceiveGreeting()
/*++

Routine Description : 

	Receive greeting from server. Success if server 
	returns the 220 code, else failure.

Arguments : 


Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	TraceFunctEnter("CSmtpClient::fReceiveGreeting");

	// receive first line
	int nRet = fReceiveFullResponse();
	if(nRet == -1)
	{
		ErrorTrace( (LPARAM)this, "Error receiving greeting");
		return FALSE;
	}

	// validate response code
	int nCode = GetThreeDigitCode(m_pRecvBuffer, (DWORD)nRet);

	// server should return a 220 code
	if(nCode != 220)
	{
		ErrorTrace( (LPARAM)this,"greeting line: unexpected server code");
		return FALSE;
	}

	return TRUE;
}

BOOL	
CSmtpClient::fDoHeloCommand()
/*++

Routine Description : 

	Send HELO to the server. Receive response. Success if server 
	returns the 250 code, else failure.

Arguments : 


Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	_ASSERT(m_CliState == sInitialized);

	TraceFunctEnter("CSmtpClient::fDoHeloCommand");

    if(!IsConnected())
    {
		// the connection may have timed-out, try and re-connect
		// NOTE: this attempt is made only when the HELO command is
		// sent, because this is the first command of the series
		if(!fConnect())
		{
			ErrorTrace( (LPARAM)this, "Failed to connect");
			return FALSE;
		}

		// receive the greeting
		if(!fReceiveGreeting())
		{
			ErrorTrace( (LPARAM)this,"Failed to receive greeting");
			return FALSE;
		}
    }

	// send HELO command
    DWORD cbBytesToSend = lstrlen(HeloCommand);
	DWORD cbBytesSent = fSend(HeloCommand, cbBytesToSend);
	if(cbBytesSent < cbBytesToSend)
	{
		// no excuse here - we just re-connected!!
		ErrorTrace( (LPARAM)this,"Error sending HELO command");
		return FALSE;
    }

	// send local computer name
    cbBytesToSend = lstrlen(m_lpComputerName);
	cbBytesSent = fSend(m_lpComputerName, cbBytesToSend);
	if(cbBytesSent < cbBytesToSend)
	{
		ErrorTrace( (LPARAM)this,"Error sending local computer name");
		return FALSE;
	}

	// send CRLF
    cbBytesToSend = lstrlen(CRLF);
	cbBytesSent = fSend(CRLF, cbBytesToSend);
	if(cbBytesSent < cbBytesToSend)
	{
		ErrorTrace( (LPARAM)this,"Error sending CRLF");
		return FALSE;
	}

	// receive response
	int nRet = fReceiveFullResponse();
	if(nRet == -1)
	{
		ErrorTrace( (LPARAM)this, "Error receiving response to HELO command");
		return FALSE;
	}

	// validate response code
	int nCode = GetThreeDigitCode(m_pRecvBuffer, (DWORD)nRet);

	// server should return a 250 code
	if(nCode != 250)
	{
		ErrorTrace( (LPARAM)this,"HELO command: unexpected server code");
		return FALSE;
	}

	return TRUE;
}

BOOL	
CSmtpClient::fDoMailFromCommand( LPSTR lpFrom, DWORD cbFrom )
/*++

Routine Description : 

	Send MAIL FROM:<lpFrom> to the server. Receive response. Success 
	if server returns the 250 code, else failure.

Arguments : 


Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	char szMailFromLine [MAX_PATH+1];
	char* lpBuffer = szMailFromLine;
	DWORD cbBytesToSend = 0;

	_ASSERT(m_CliState == sHeloDone);

	TraceFunctEnter("CSmtpClient::fDoMailFromCommand");

	//
	// construct MAIL FROM line
	//

	// check size of from header 
	if( cbFrom && cbFrom > MAX_PATH-16) {
		// From header too large - use a <> from line
		lpFrom = NULL;
		cbFrom = 0;
	}

	if( !lpFrom ) {
		// NULL from header
		cbBytesToSend = wsprintf( lpBuffer, "%s<>\r\n", MailFromCommand );
	} else {
		// Format from header
		cbBytesToSend = wsprintf( lpBuffer, "%s<", MailFromCommand );
		CopyMemory( lpBuffer+cbBytesToSend, lpFrom, cbFrom);
		cbBytesToSend += cbFrom;
		*(lpBuffer+cbBytesToSend) = '\0';
		cbBytesToSend += wsprintf( lpBuffer+cbBytesToSend, ">\r\n");
	} 

	// send MAIL FROM command
	DWORD cbBytesSent = fSend(lpBuffer, cbBytesToSend);
	if(cbBytesSent < cbBytesToSend)
	{
		ErrorTrace( (LPARAM)this,"Error sending MAIL FROM command");
		return FALSE;
	}

	// receive response
	int nRet = fReceiveFullResponse();
	if(nRet == -1)
	{
		ErrorTrace( (LPARAM)this, "Error receiving response to MAIL FROM command");
		return FALSE;
	}

	// validate response code
	int nCode = GetThreeDigitCode(m_pRecvBuffer, (DWORD)nRet);

	// server should return a 250 code
	if(nCode != 250)
	{
		ErrorTrace( (LPARAM)this,"MAIL FROM command: unexpected server code");
		return FALSE;
	}

	return TRUE;
}

BOOL	
CSmtpClient::fMailArticle(	
			IN HANDLE	hFile,
			IN DWORD	dwOffset,
			IN DWORD	dwLength,
			IN char*	pchHead,
			IN DWORD	cbHead,
			IN char*	pchBody,
			IN DWORD	cbBody
			)
/*++

Routine Description : 

	If hFile != NULL, use TransmitFile to send the data else use send()

Arguments : 

	IN HANDLE	hFile			:	handle of file	
	IN DWORD	dwOffset		:	offset of article within file
	IN DWORD	dwLength		:	length of article
	IN char*	pchHead			:	pointer to article headers
	IN DWORD	cbHead			:	number of header bytes
	IN char*	pchBody			:	pointer to article body
	IN DWORD	cbBody			:	number of bytes in body

Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	TraceFunctEnter("CSmtpClient::fMailArticle");

	if ( hFile != INVALID_HANDLE_VALUE )	// Article is in file
	{
		_ASSERT( pchHead == NULL );
		_ASSERT( cbHead  == 0    );
		_ASSERT( pchBody == NULL );
		_ASSERT( cbBody  == 0    );

		DebugTrace((LPARAM)this,"Sending article via TransmitFile()");

		if(!this->fTransmitFile(hFile, dwOffset, dwLength))
		{
			ErrorTrace((LPARAM)this,"Error sending article via TransmitFile()");
			return FALSE;
		}
	}
	else			// Article is in memory buffer
	{
		_ASSERT( hFile == INVALID_HANDLE_VALUE );
		_ASSERT( pchHead );
		_ASSERT( cbHead  );

		DWORD cbBytesSent = this->fSend( (LPCTSTR)pchHead, (int)cbHead );
		if(cbBytesSent != cbHead)
		{
			ErrorTrace((LPARAM)this,"Error sending article header via send()");
			return FALSE;
		}

		if( cbBody )
		{
			_ASSERT( pchBody );

			cbBytesSent = this->fSend( (LPCTSTR)pchBody, (int)cbBody );
			if(cbBytesSent != cbBody)
			{
				ErrorTrace((LPARAM)this,"Error sending article body via send()");
				return FALSE;
			}
		}
	}

	TraceFunctLeave();
	return TRUE;
}

BOOL	
CSmtpClient::fDoRcptToCommand(LPSTR lpRcpt)
/*++

Routine Description : 

	Send RCPT TO to the server. Receive response. Success if server 
	returns the 250 code, else failure.

Arguments : 

	LPSTR lpRcpt		-	Recipient email addr

Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	_ASSERT(m_CliState == sMailFromSent);

	TraceFunctEnter("CSmtpClient::fDoRcptToCommand");

	// send RCPT TO command
    DWORD cbBytesToSend = lstrlen(RcptToCommand);
	DWORD cbBytesSent = fSend(RcptToCommand, cbBytesToSend);
	if(cbBytesSent < cbBytesToSend)
	{
		ErrorTrace( (LPARAM)this,"Error sending RCPT TO command");
		return FALSE;
	}

	// send recipient
    cbBytesToSend = lstrlen(lpRcpt);
	cbBytesSent = fSend(lpRcpt, cbBytesToSend);
	if(cbBytesSent < cbBytesToSend)
	{
		ErrorTrace( (LPARAM)this,"Error sending recipient");
		return FALSE;
	}

	// send CRLF
    cbBytesToSend = lstrlen(CRLF);
	cbBytesSent = fSend(CRLF, cbBytesToSend);
	if(cbBytesSent < cbBytesToSend)
	{
		ErrorTrace( (LPARAM)this,"Error sending CRLF");
		return FALSE;
	}

	// receive response
	int nRet = fReceiveFullResponse();
	if(nRet == -1)
	{
		ErrorTrace( (LPARAM)this, "Error receiving response to RCPT TO command");
		return FALSE;
	}

	// validate response code
	int nCode = GetThreeDigitCode(m_pRecvBuffer, (DWORD)nRet);

	// server should return a 250 or 251 code
	if(nCode != 250 && nCode != 251)
	{
		ErrorTrace( (LPARAM)this,"RCPT TO command: unexpected server code");
		return FALSE;
	}

	return TRUE;
}

BOOL	
CSmtpClient::fDoDataCommand()
/*++

Routine Description : 

	Send DATA to the server. Receive response. Success if server 
	returns the 354 code, else failure.

Arguments : 


Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	_ASSERT(m_CliState == sRcptTo);

	TraceFunctEnter("CSmtpClient::fDoDataCommand");

	// send DATA command
    DWORD cbBytesToSend = lstrlen(DataCommand);
	DWORD cbBytesSent = fSend(DataCommand, cbBytesToSend);
	if(cbBytesSent < cbBytesToSend)
	{
		ErrorTrace( (LPARAM)this,"Error sending DATA command");
		return FALSE;
	}

	// receive response
	int nRet = fReceiveFullResponse();
	if(nRet == -1)
	{
		ErrorTrace( (LPARAM)this, "Error receiving response to DATA command");
		return FALSE;
	}

	// validate response code
	int nCode = GetThreeDigitCode(m_pRecvBuffer, (DWORD)nRet);

	// server should return a 354 code
	if(nCode != 354)
	{
		ErrorTrace( (LPARAM)this,"DATA command: unexpected server code");
		return FALSE;
	}

	return TRUE;
}

BOOL	
CSmtpClient::fReceiveDataResponse()
/*++

Routine Description : 

	Receive response to data transmission. Success if server 
	returns the 250 code, else failure.

Arguments : 


Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	TraceFunctEnter("CSmtpClient::fReceiveDataResponse");

	// receive first line
	int nRet = fReceiveFullResponse();
	if(nRet == -1)
	{
		ErrorTrace( (LPARAM)this, "Error receiving data response");
		return FALSE;
	}

	// validate response code
	int nCode = GetThreeDigitCode(m_pRecvBuffer, (DWORD)nRet);

	// server should return a 250 code
	if(nCode != 250)
	{
		ErrorTrace( (LPARAM)this,"data response: unexpected server code");
		return FALSE;
	}

	return TRUE;
}

//
//	Constructor, Destructor
//
CSmtpClientPool::CSmtpClientPool()
{
	m_rgpSCList = NULL;
	m_cSlots = 0;
	m_rgAvailList = NULL;
	InitializeCriticalSection(&m_CritSect);	
}

CSmtpClientPool::~CSmtpClientPool()
{
	DeleteCriticalSection(&m_CritSect);
}

BOOL 
CSmtpClientPool::AllocPool(
		DWORD cNumInstances
		)
/*++

Routine Description : 

	Allocate X objects and initialize them. Set all to avail status

Arguments : 

	DWORD cNumInstances		-	Number of objects needed in pool

Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	DWORD cbSize = MAX_COMPUTERNAME_LENGTH+1;

	TraceFunctEnter("CSmtpClientPool::AllocPool");

	_ASSERT(!m_rgpSCList);
	_ASSERT(!m_rgAvailList);
	_ASSERT(!m_cSlots);

	m_rgpSCList = (CSmtpClient**)HeapAlloc(GetProcessHeap(), 0, sizeof(CSmtpClient*)*cNumInstances);
	if(!m_rgpSCList)
	{
		FatalTrace( (LPARAM)this,"Memory allocation failed");
		return FALSE;
	}

	// NULL all object pointers
	for(DWORD i=0; i<cNumInstances; i++)
	{
		m_rgpSCList [i] = NULL;
	}

	m_rgAvailList = (BOOL*) HeapAlloc(GetProcessHeap(), 0, sizeof(BOOL)*cNumInstances);
	if(!m_rgAvailList)
	{
		FatalTrace( (LPARAM)this,"Memory allocation failed");
		goto Pool_Cleanup;
	}

	// no object is available by default
	for(i=0; i<cNumInstances; i++)
	{
		m_rgAvailList [i] = FALSE;
	}

	// set total number of slots
	m_cSlots = cNumInstances;
	
    // needed for HELO command
	GetComputerName(m_szComputerName, &cbSize);

	for(i=0; i<cNumInstances; i++)
	{
		CSmtpClient* pSC = new CSmtpClient(m_szComputerName);
		if(!pSC)
		{
			ErrorTrace( (LPARAM)this,"Memory allocation failed");
			goto Pool_Cleanup;
		}

		// store in pool array and mark as available
		m_rgpSCList	  [i] = pSC;
		m_rgAvailList [i] = TRUE;
		pSC->SetClientState(sInitialized);
	}

	// Pool initialized successfully
	return TRUE;

Pool_Cleanup:

	// abnormal exit; cleanup
	for(i=0; i<cNumInstances; i++)
	{
		if(m_rgpSCList[i])
		{
			delete m_rgpSCList [i];
			m_rgpSCList [i] = NULL;
		}
	}

	if(m_rgpSCList)
	{
		HeapFree(GetProcessHeap(), 0, (LPVOID)m_rgpSCList);
		m_rgpSCList = NULL;
	}

	if(m_rgAvailList)
	{
		HeapFree(GetProcessHeap(), 0, (LPVOID)m_rgAvailList);
		m_rgAvailList = NULL;
	}

	return FALSE;
}

VOID 
CSmtpClientPool::FreePool()
/*++

Routine Description : 

	Free all objects

Arguments : 


Return Value : 
	VOID

--*/
{
	CSmtpClient* pSC;

	// terminate and delete all CSmtpClient objects in the pool
	for(DWORD i=0; i<m_cSlots; i++)
	{
		pSC = m_rgpSCList[i];
		if(pSC)
		{
            // terminate only if initialized
            if(pSC->IsInitialized())
			    pSC->Terminate(TRUE);
			delete pSC;
			m_rgpSCList [i] = NULL;
		}
	}

	// Now there are no objects in the pool
	m_cSlots = 0;

	// free the object array
	if(m_rgpSCList)
	{
		HeapFree(GetProcessHeap(), 0, (LPVOID)m_rgpSCList);
		m_rgpSCList = NULL;
	}

	// free the avail bool array
	if(m_rgAvailList)
	{
		HeapFree(GetProcessHeap(), 0, (LPVOID)m_rgAvailList);
		m_rgAvailList = NULL;
	}
}

CSmtpClient* 
CSmtpClientPool::AcquireSmtpClient(DWORD& dwIndex)
/*++

Routine Description : 

	Get an object from the pool

Arguments : 

	DWORD& dwIndex		-		Index of client is returned if
								a client object is available

Return Value : 
	Pointer to object if one is available, else NULL

--*/
{
	_ASSERT(m_rgpSCList);
	_ASSERT(m_rgAvailList);
	_ASSERT(m_cSlots);

	CSmtpClient* pSC = NULL;

	LockPool();

	for(DWORD i=0; i<m_cSlots; i++)
	{
		// if avail is TRUE, return this object
		if(m_rgAvailList[i])
		{
			pSC = m_rgpSCList[i];
			m_rgAvailList [i] = FALSE;	// mark as not avail
			dwIndex = i;				// return this index
			break;
		}
	}

	UnLockPool();

	return pSC;
}

VOID
CSmtpClientPool::ReleaseSmtpClient(DWORD dwIndex)
/*++

Routine Description : 

	Return an object to the pool; Index should be 
	same as that returned by GetSmtpClient

Arguments : 

	DWORD	dwIndex		-		Index of client to release

Return Value : 
	VOID

--*/
{
	_ASSERT(m_rgpSCList);
	_ASSERT(m_rgAvailList);
	_ASSERT(m_cSlots);

	LockPool();

	// mark as avail
	m_rgAvailList [dwIndex] = TRUE;

	UnLockPool();
}

VOID
CSmtpClientPool::MarkDirty()
/*++

Routine Description : 

	Mark pool objects dirty

Arguments : 

Return Value : 
	VOID

--*/
{
	CSmtpClient* pSC = NULL;

	LockPool();

	for(DWORD i=0; i<m_cSlots; i++)
	{
		pSC = m_rgpSCList[i];
        if(pSC->IsInitialized())
        {
            // this object has a persistent connection to an SMTP server
            // mark as dirty - this ensures a re-connect to the new SMTP server
            pSC->MarkDirty();
        }
	}

	UnLockPool();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\session.h ===
//
//	@doc	INTERNAL
//
//	@module	SESSION.H - Session Related Objects |
//
// This module defines those classes which encapsulate session information and
// state information for sessions.
//
//  The Classes which are defined in here are :
//
//      CSessionState
//      CLogon
//      CAcceptNNRPD
//      CExtendedCMD
//      CTransmitArticle
//      CAcceptArticle
//      CCollectNewnews
//      CCollectArticles
//      COfferArticles
//      CSocket
//      CSessionSocket
//      CSocketList
//
//	Each Active session to the server is represented by one CSessionSocket object.
//	The CSessionSocket object will have a pointer to an object derived from CSessionState
//	which will represent the current state of the object.  The CSessionState object
//	will be responsible for issuing IO's appropriate to the state.  In general the CSessionState
//	derived object is responsible for all synchronization issues if it has multiple IO's
//	outstanding at a time.
//
//	The CAcceptNNRPD state receives commands and issues the response for simple commands (ie. 'next').
//	This state generally has one async read outstanding always and will do synchronous sends to respond to commands.
//
//	The CExtendedCMD state can only be entered when the CAcceptNNRPD state receives any kind of
//	command that does not have a small response.  (ie.  newnews, list comp.*, etc....)
//	The CExtendedCMD state will generally have 1 async writes pending.  When processing an
//	extended command the CExtendedCMD computes the response untill it has filled a buffer, it then
//	issues an Async Write for this buffer.  Each time an async write completes, we will compute a
//	some more of the response and then send it.
//
//	The CTransmitArticle state will either issue a single TransmitFile IO or do multiple
//	writes depending on the security settings of the session.  No Reads are issued in this state.
//	CTransmitArticle state is enterred from the CAcceptNNRPD and COfferArticles states.
//
//	The CAcceptArticle state is used whenever an article is being transmitted to the server
//	and we wish to spool up the results.  The CAcceptArticle will always have 1 pending Read.
//	As each read completes this state will examine the buffer to determine whether we have
//	completed the article transfer.  Once the article is completely transferred, we will pass
//	the HFILE of the resulting file to the CInFeed object for the session.
//	(A session in CAcceptArticle state will go either to CCollectArticles or CAcceptNNRPD.
//	CCollectArticles if this is a feed we're pulling from another server, CAcceptNNRPD for any other session.)
//	
//	The CCollectNewnews state issues a single write of the appropriate newnews command and then
//	keeps 1 read pending until it has collect all responses.  As each read completes we will start
//	processing Message-Id's to determine which to accept/reject.	This will require a critical section
//	and if the other side sends Message-Id's faster then we can process them there may not be a read pending.
//
//	The CCollectArticles state issues single 'article <Msg-Id> commands and is entered after the CCollectNewnews
//	state.  This state uses a CInFeed object and will repeatedly change the state to the CAcceptArticle state
//	untill we have collected all the articles on the feed.
//
//	The COfferArticles issues 'Ihave' or 'xreplic' commands using a COutFeed object to generate each command.
//	Whenever we get a response asking for the article, we will enter the CTransmitArticle state and send the article.
//
//
//	Each IO operation is represented by a CIO object.  CIO objects will contain reference counting pointers
//	to the
//
//
//  Implementation Schedule for the classes :
//
//      CSessionSocket, CSocketList, CSocket, CAcceptArticle    1.5wk
//
//          CSessionSocket and CSocketList can be largely re-used from
//          code in the shuttle project.  CAcceptArticle will have to be
//          written from scratch.
//
//      Unit Testing  -
//          The above four classes will be unit tested as a whole -
//          The unit test will consist of accepting a socket,
//          placing it in the CAcceptArticle state and spooling up
//          one article and then closing the socket.            0.5wk
//
//      CCollectNewnews, CCollectArticles -                     1 wk.
//          These classes can be pulled from Exchange code.
//
//      Unit Testing -
//          The above two classes will be unit tested with the
//          previous four.  We will pull articles down from
//          an INN server using these classes.                  1 wk.
//
//
//      CAcceptNNRPD, CExtendedCMD, CTransmitArticle            1 wk.
//          These classes will need to be written from scratch.
//
//      Unit Testing -
//          These classes will be Unit Tested using Telnet,     1 wk.
//          and typing commands at the telnet prompt.
//
//
//      COfferArticles                                          1 wk.
//          This class issues IHave commands and must be implemented from
//          scratch.  This class depends on having a single working COutFeed object.
//
//      Unit Testing -                                          1 wk.
//          This class will be unit tested against another server which
//          has a working CAcceptNNRPD state engine going.
//
//
//



#ifndef	_SESSION_H_
#define	_SESSION_H_

#include	<winsock.h>
#include	"smartptr.h"
#include	"queue.h"
#include	"lockq.h"

#include	"io.h"

//
// CPool Signature
//

#define SESSION_SOCKET_SIGNATURE (DWORD)'1023'
#define SESSION_STATE_SIGNATURE (DWORD)'1516'

typedef	enum	LOG_DATA	{
	LOG_OPERATION,
	LOG_TARGET,
	LOG_PARAMETERS
} ;


class	CLogCollector	{
public : 
	char*		m_Logs[3] ;
	DWORD		m_LogSizes[3] ;

	DWORD		m_cbOptionalConsumed ;
	BYTE		m_szOptionalBuffer[256] ;
#ifdef	DEBUG
	//
	//	For debug - m_dwSignature follows the buffer immediately to detect overwrites !
	//
	DWORD		m_dwSignature ;
	DWORD		m_cAllocations ;
	DWORD		m_cCalls ;
#endif

	//
	//	Number of Bytes Sent/Recvd
	//
	STRMPOSITION	m_cbBytesSent ;
	DWORD			m_cbBytesRecvd ;

	//
	//	This function will copy data into the CLogCollector objects
	//	m_szOptionalBuffer and truncate the data if necessary.
	//	
	void	FillLogData(	LOG_DATA,	BYTE*	lpb,	DWORD cb ) ;

	//
	//	This function will place a pointer to log data into the 
	//	array (we assume it is NULL terminated).
	//
	void	ReferenceLogData(	LOG_DATA,	BYTE*	lpb ) ;

	//
	//	This function will reservce space in either the m_szOptionalBuffer
	//	or in the buffer pointer to in m_pBuffer for use to store log data.
	//	It is expected that hte call will later call ReferenceLogData with
	//	this address.
	//
	BYTE*	AllocateLogSpace( DWORD	cb ) ;

	//
	//	Return TRUE if we have recorded data for a transaction log !
	//
	BOOL	FLogRecorded()	{
		return	m_Logs[0] != 0 ; 
	}
	
	//
	//	Reset everything !
	//
	void	Reset()	{
#ifdef	DEBUG
		_ASSERT( m_dwSignature == 0xABCDEF12 ) ;
		m_cAllocations = 0 ;
		m_cCalls = 0 ;
#endif
		m_cbOptionalConsumed = 0 ;
		ASSIGNI( m_cbBytesSent, 0 );
		m_cbBytesRecvd = 0;

		ZeroMemory( m_Logs, sizeof( m_Logs ) ) ;
		ZeroMemory( m_LogSizes, sizeof( m_LogSizes ) ) ;
	}

	CLogCollector()	{	
#ifdef	DEBUG
		m_dwSignature = 0xABCDEF12 ;
#endif
		Reset() ;	
	}
} ;


//
//	Utility functions
//

//	Create a temp file name
BOOL	NNTPCreateTempFile( LPSTR	lpstrDir, LPSTR lpstrFile ) ;
//	Delete or rename a temporary file that we have processed
void	NNTPProcessTempFile(	
					BOOL	fGoodPost,	
					LPSTR	lpstrFile,
					LPSTR	lpstrErrorDirectory,
					NRC		nrcErrorCode, 
					LPSTR	lpstrErrorReason,
					HANDLE	hFile, 
					char*	pchArticle,
					DWORD	cbArticle
					) ;

//-------- Socket State Classes ----------------------------------------------
//
// All of the following classes represent a state a socket session can be in
// AFTER the session has been established (ie. this doesn't cover listening).
//
// CSessionState represents the state a session is in.  This is the base class
// from which various classes representing the particular states will derive from.
// This class defines a complete interface for Completing the IO operations that
// are performed while in this state.
//
// State objects should only override those virtual functions for which they will
// issue IO's.   (For instance the CAcceptArticle state should only override the
// Complete( CIORead*, .... ) function.)  The base implementation of these functions
// will do a DebugBreak().
//
//  In general CSessionState objects operate in this fashion :
//   1   The State is initialized and issues a first IO operation.
//   2   The IO operation (represented by a CIO object) executes until the IO is complete.
//      (For instance, a CIOReadLine will re-issue reads until it has received and EOL character.)
//   3   Once the IO completes, it call the appropriate Complete function on the
//      CSessionState object.  The CSessionState object processes the completed IO.
//   4   The State object issues another IO.
//
class	CSessionState : public CRefCount	{
protected :

    //
    // We should have a CPool object here for allocating CSessionState objects.
    //

	static	CPool	gStatePool ;

public :

    //
    //  operators new and delete will actually go to a CPool object to get the memory
    //  for state objects.
    //
    void    *operator   new( size_t size ) ;
    void    operator    delete( void * ) ;

	static	BOOL	InitClass() ;
	static	BOOL	TermClass() ;


    //
    //  Check that a CSessionState Object is valid.
    //

    // Virtual destructor as we are inherited from a lot.
	virtual	~CSessionState() ;

    //
	// This function should issue the first IO operation for this state.
	// Once the IO is issued, state objects will issue additional IO's on
	// each call of a Complete() function
    //
	virtual	BOOL	Start(	CSessionSocket*,	
							CDRIVERPTR&,	
							CIORead*&,	
							CIOWrite*&	
							) = 0 ;	// bugbug - get rid of CDRIVERPTR& !!

	//
    // Destroy everything we might be holding and move onto the Terminating State
	//	After calling this function no further IO operations will be issued.  The
	//	state object should destroy all of its internal structures in a thread safe
	//	way and then move onto the Terminating State.  The Terminating State will
	//	collect all outstanding IO's as they complete and destroy them.
    //
//    virtual void Shutdown( ) ;

    //
    //  Specify all possible IO Completions we may need to process.
    //  This base class will DebugBreak() on all of these, as all derived states
    //  should have a completion function for the IO's that they issue.
    //  NOTE :
    //  A derived class need not override a completion function for an IO it won't
    //  issue - it would be appropriate to DebugBreak() to find bugs.
    //
    //  NOTE :
    //  If the Complete function returns TRUE, the calling CIO object should
    //  call the sockets ReleaseState function with the pointer to the CSessionState object.
    //  (returning TRUE means the state has complete and will be destroyed by the CSessionSocket object.)
    //


	//
	//	When we have read a complete line, this will be called, 
	//	The line will be broken into an array of pointers to the 
	//	white space separated elements on the line.
	//	If there are too many arguments, then the last pointer 
	//	in the array of pszArgs will point at the last arguments, 
	//	and there will be no pointers for intermediate arguments.
	//	pchBegin points to the start of the usable buffer space
	//	that the called function can overwrite.
	//
	virtual	class CIO*	
	Complete( 
				class	CIOReadLine*, 
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver, 
				int	cArgs,	
				char	**pszArgs, 
				char* pchBegin 
				) ;

	//
	//	We have completed writing a line of text to the socket !
	//
	virtual	class CIO*	
	Complete( 
				class CIOWriteLine*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;

	//
	//	We have completed executing a CExecute derived command object,
	//	and all the bytes have been sent to the client !
	//
	virtual	class CIO*	
	Complete( 
				class CIOWriteCMD*, 
				class CSessionSocket*, 
				CDRIVERPTR&	pdriver,	
				class	CExecute*	pCmd, 
				class CLogCollector* pCollector 
				) ;


	//
	//	Signal completion of an asynchronous command - this is called
	//	when the final send to the client finishes !
	//
	virtual	class	CIO*	
	Complete(
				class	CIOWriteAsyncCMD*,
				class	CSessionSocket*,
				CDRIVERPTR&	pdriver, 
				class	CAsyncExecute*	pCmd,
				class	CLogCollector*	pCollector
				) ;

	//
	//
	//

	virtual	class CIO*	
	Complete(	class CIOMLWrite*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;



	//
	//	We have completed reading an article
	//
	virtual	void	
	Complete( 
				class CIOReadArticle*, 
				class CSessionSocket *,	
				CDRIVERPTR&,	
				CFileChannel&	pFileChannel, 
				DWORD	cbTransfer 
				) ;

	//
	//	We have completed transmitting an article to a client
	//
	virtual class CIO*	
	Complete( 
				class	CIOTransmit*,	
				class	CSessionSocket*, 
				CDRIVERPTR&,	
				TRANSMIT_FILE_BUFFERS*,
				unsigned cbBytes = 0
				) ;

	//
	//	We have read an entire article.
	//	nrcResult is an NNTP return code which indicates whether we successfully
	//	got the entire article. if nrcResult == nrcOK, then
	//	pchHeader will point to the head of the article.
	//	cbHeader will be the length of the article's header
	//	if cbArticle is not zero then it the entire article is in the 
	//	buffer we have been passed and hArticle will be iNVALID_HANDLE_VALUE
	//	if cbArticle is 0 then hArticle will be the handle to the file where
	//	the article has been saved.
	//	If a file handle is passed to the state, then the state is responsible
	//	for closing the handle in all circumstances.  The caller has relinquished
	//	the handle !!
	//
	virtual	void	
	Complete(
				class	CIOGetArticle*,
				class	CSessionSocket*,
				NRC		nrcResult,
				char*	pchHeader, 
				DWORD	cbHeader, 
				DWORD	cbArticle,
				DWORD	cbTotalBuffer,
				HANDLE	hArticle,
				DWORD	cbGap,
				DWORD	cbTotalTransfer
				) ;

	//
	//	This is the signature for a read that completes
	//	entirely in memory !
	//
	virtual	class	CIO*
	Complete(
				class		CIOGetArticleEx*,
				class		CSessionSocket*,
				//
				//	If fGoodMatch is TRUE then we matched the
				//	string we wanted to match - otherwise we 
				//	matched the error string !
				//
				BOOL		fGoodMatch,
				CBUFPTR&	pBuffer,
				DWORD		ibStart, 
				DWORD		cb
				) ;

	//
	//	This is the signature for a slurpy read where
	//	we just consume all the bytes off the socket !
	//
	virtual	class	CIO*
	Complete(	class	CIOGetArticleEx*,
				class	CSessionSocket*
				) ;

	//
	//	This is the completion that is called when we've 
	//	completed transferring an article to a file !
	//
	virtual	void
	Complete(	class	CIOGetArticleEx*,
				class	CSessionSocket*,
				FIO_CONTEXT*	pContext,
				DWORD	cbTransfer
				) ;

				
	virtual	void	
	Shutdown(	CIODriver&	driver,	
				CSessionSocket*	pSocket,	
				SHUTDOWN_CAUSE	cause,	
				DWORD	dw 
				) ;
} ;


#ifdef	_NO_TEMPLATES_

DECLARE_SMARTPTRFUNC( CSessionState ) 

#endif



/*++
	@class	Representing Socket which is issuing a Newnews command.

	@base public | CSessionState

	the CCollectNewnews represents a session in which we will isssue a newnews command to a
	NNTP Server.  We will use this state when pulling a feed from the other server.

--*/
class CCollectNewnews : public CSessionState {
private :
	CFILEPTR		m_pFileChannel ;
	CDRIVERPTR		m_pSessionDriver ;
	long			m_cCompletes ;
#if 0 
	long			m_cCommandCompletes ;
#endif

	BOOL	InternalComplete(	CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver ) ;

//	@access	Public	Members	
public :
	CCollectNewnews() ;
	~CCollectNewnews() ;

#if 0 
	BOOL	ModeReaderComplete( CSessionSocket*,	CDRIVERPTR&,	class	CIORead*&, class CIOWrite*& ) ;
#endif
	
	BOOL	Start(	CSessionSocket*,	CDRIVERPTR&,	class	CIORead*&,	class	CIOWrite*&	) ;

	class CIO*	Complete( class	CIOReadLine*, class	CSessionSocket *, CDRIVERPTR&	pdriver,
						int	cArgs,	char	**pszArgs,	char	*pchBegin ) ;
	class CIO*	Complete( class CIOWriteLine*,	class	CSessionSocket *, CDRIVERPTR&	pdriver ) ;
	void	Complete( class CIOReadArticle*, class CSessionSocket *,	CDRIVERPTR&	pdriver,	CFileChannel&	pFileChannel, DWORD cbTransfer ) ;
	void	Shutdown(	CIODriver&	driver,	CSessionSocket*	pSocket,	SHUTDOWN_CAUSE	cause,	DWORD	dw ) ;
} ;


/*++
	@class	State which should perform logons to remote servers for outbound sessions

	@base public | CSessionState

	the CCollectNewnews represents a session in which we will isssue a newnews command to a
	NNTP Server.  We will use this state when pulling a feed from the other server.

--*/
class	CNNTPLogonToRemote	:	public	CSessionState	{
private :
	CSTATEPTR	m_pNext ;		// After successfull logon the next state we should enter !
	class	CAuthenticator*	m_pAuthenticator ;
	BOOL	m_fComplete ;
	BOOL	m_fLoggedOn ;
	long	m_cReadCompletes ;

	class	CIO*	FirstReadComplete(	class	CIOReadLine*,	class	CSessionSocket*,	CDRIVERPTR&	pdriver,
						int	cArgs,	char	**pszArgs, char* pchBegin ) ;

	class	CIO*	StartAuthentication(	CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver	) ;

public :
	CNNTPLogonToRemote(	CSessionState*	pNext, class	CAuthenticator*	pAuthenticator ) ;
	~CNNTPLogonToRemote( ) ;

	BOOL	Start(	CSessionSocket*,	CDRIVERPTR&,	CIORead*&,	CIOWrite*& ) ;

	class	CIO*	Complete(	class	CIOReadLine*,	class	CSessionSocket*,	CDRIVERPTR&	pdriver,
						int	cArgs,	char	**pszArgs, char* pchBegin ) ;
	class	CIO*	Complete( class CIOWriteLine*,	class	CSessionSocket *, CDRIVERPTR&	pdriver ) ;
} ;


/*++
	@class	Representing Socket which is issuing a Newnews command.

	@base public | CSessionState

	the CCollectNewnews represents a session in which we will isssue a newnews command to a
	NNTP Server.  We will use this state when pulling a feed from the other server.

--*/
class	CSetupPullFeed	: public	CSessionState	{
private:
	CSTATEPTR		m_pNext ;		// State to follow after collecting all groups

	//
	//	States must use consecutive integers !
	//
	enum	ESetupStates	{
		eModeReader	= 0,
		eDate,
		eFinal
	}	;

	ESetupStates	m_state ;

	CIOWriteLine*
	BuildNextWrite(	CSessionSocket*	pSocket,
					CDRIVERPTR&		pdriver
					) ;

public :

	//
	//	We must be initialized with the pointer to the following state !
	//	
	CSetupPullFeed(	
				CSessionState*	pNext 
				)	;

	//
	//	Start setup operations - issue mode reader and then date commands !
	//	
	BOOL	
	Start(		CSessionSocket*,	
				CDRIVERPTR&	pdriver,	
				CIORead*&,	
				CIOWrite*& 
				) ;

	//
	//	Complete the write of a line to the remote end !
	//
	class	CIO*	
	Complete(	class CIOWriteLine*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;

	//
	//	Complete the read of the response to the last command !
	//
	class	CIO*	
	Complete(	class	CIOReadLine*,	
				class	CSessionSocket*,	
				CDRIVERPTR&	pdriver,
				int	cArgs,	
				char	**pszArgs,	
				char*	pchBegin 
				) ;
} ;




/*++
	@class	Representing Socket which is issuing a Newnews command.

	@base public | CSessionState

	the CCollectNewnews represents a session in which we will isssue a newnews command to a
	NNTP Server.  We will use this state when pulling a feed from the other server.

--*/
class	CCollectGroups : public	CSessionState	{
private:
	CSTATEPTR		m_pNext ;		// State to follow after collecting all groups
	BOOL			m_fReturnCode ;
	long			m_cCompletions ;
public :
	CCollectGroups(	CSessionState*	pNext )	;
	~CCollectGroups() ;
	
	BOOL	Start(	CSessionSocket*,	CDRIVERPTR&	pdriver,	CIORead*&,	CIOWrite*& ) ;
	class CIO*	Complete( class CIOWriteLine*,	class	CSessionSocket *, CDRIVERPTR&	pdriver ) ;
	class	CIO*	Complete(	class	CIOReadLine*,	class	CSessionSocket*,	CDRIVERPTR&	pdriver,
						int	cArgs,	char	**pszArgs,	char*	pchBegin ) ;
} ;




class	CCollectComplete : 	public	CNntpComplete	{
private : 
	class	CCollectArticles*	GetContainer() ;
public : 
	//
	//	This function is called when we start our work !
	//
	void
	StartPost(	) ;
	//
	//	This function gets called when the post completes !
	//
	void
	Destroy() ;
} ;



//	@class	- Class representing a session in which we are issuing successive article <Msg-Id> commands
//
//	@base public | CSessionState
//
// The CBatchDownload state represents a session in which we are pulling articles
// from another server based on the results previously acquired through CCollectNewnews.
//
class   CCollectArticles : public CSessionState  {
private :

	//
	//	This completion class is our friend !
	//
	friend	class	CCollectComplete ;

	BOOL				m_fFinished ;		//	Set to TRUE when we pull the last article we're gonna pull !
	SHUTDOWN_CAUSE		m_FinishCause ;		//	Why we are finished - pass this to UnsafeClose() !!

	long				m_cResets ;			// Counter used to prevent multiple calls to Reset() during
											// termination of this state due to error... whatever.

	CSessionSocket*		m_pSocket ;			// There are some shutdown situations where we
											// get notified and don't know who our owning socket
											// is through the call chain.  Hence we save a reference here !


	CFILEPTR			m_pFileChannel ;	// A channel to read our temp file from.
	CDRIVERPTR			m_inputId ;			// A channel identifier
	CDRIVERPTR			m_pSessionDriver ;
	BOOL				m_fReadArticleIdSent ;	// Tell's us whether we've issued the
											// m_pReadArticleId we're holding on to.
											// If we have, then we shouldn't destroy it, cause
											// it will get destroyed by the CIODriver we issued it to !
	CIOReadLine*		m_pReadArticleId ;	// The Readline we issued to get the next article-id

	//
	//	The feed context that we exchange with PostEarly() and PostCommit()
	//
	LPVOID				m_lpvFeedContext ;

	CIOGetArticleEx*	m_pReadArticle ;
	BOOL				m_fReadArticleInit ;	// TRUE if m_pReadArticle's Init function has successfully been called !
	// (Once a CIOReadArticle has been inited successfully it is responsible for destroying itelf !!)

	HANDLE				m_hArticleFile ;

	long				m_cAhead ;
	char*				m_pchNextArticleId ;
	char*				m_pchEndNextArticleId ;

	int					m_cArticlesCollected ;

	long				m_cCompletes ;

	//
	//	The structure we use to keep track of async post operations into our store drivers !
	//
	CCollectComplete	m_PostComplete ;

	static	const	char	szArticle[] ;

	static	void	ShutdownNotification(	void	*pv,	SHUTDOWN_CAUSE	cause,	DWORD	dw ) ;
	void				Reset() ;			// Get rid of everything pointed to by members !
public :

	CCollectArticles(	CSessionSocket*	pSocket,	
						CDRIVERPTR&	pdriver,	
						CFileChannel&	pFileChannel 
						) ;
	~CCollectArticles() ;
	
	BOOL	Init(	CSessionSocket*	pSocket	) ;
	BOOL	GetNextArticle(	CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver ) ;

	//
	//	Do what it takes to get another article on its way to us !
	//
	BOOL	StartTransfer(	CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver, 
							CIOWriteLine* pWriteNextArticleId 
							) ;

	//
	//	Initiate all the IO's appropriate for this state !
	//
	BOOL	Start(	CSessionSocket*,	
					CDRIVERPTR&,	
					CIORead*&,	
					CIOWrite*& 
					) ;
	
	class	CIO*	
	Complete(	class	CIOReadLine*,	
				class	CSessionSocket*,	
				CDRIVERPTR&	pdriver,
				int	cArgs,	
				char	**pszArgs,	
				char*	pchBegin 
				) ;
				
	class CIO*	
	Complete(	class CIOWriteLine*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;
	
//	void	Complete( class CIOReadArticle*, class CSessionSocket *,	CDRIVERPTR&	pdriver,	CFileChannel&	pFileChannel, DWORD cbTransfer ) ;

	//
	//	Handles the common cases for our CIOGetArticleEx completions !
	//
	void
	InternalComplete(	CSessionSocket*	pSocket,
						CDRIVERPTR&	pdriver
						) ;

	//
	//	This is the signature for a read that completes
	//	entirely in memory !
	//
	class	CIO*
	Complete(
				class		CIOGetArticleEx*,
				class		CSessionSocket*,
				//
				//	If fGoodMatch is TRUE then we matched the
				//	string we wanted to match - otherwise we 
				//	matched the error string !
				//
				BOOL		fGoodMatch,
				CBUFPTR&	pBuffer,
				DWORD		ibStart, 
				DWORD		cb
				) ;

	//
	//	This is the signature for a slurpy read where
	//	we just consume all the bytes off the socket !
	//
	class	CIO*
	Complete(	class	CIOGetArticleEx*,
				class	CSessionSocket*
				) ;

	//
	//	This is the completion that is called when we've 
	//	completed transferring an article to a file !
	//
	void
	Complete(	class	CIOGetArticleEx*,
				class	CSessionSocket*,
				FIO_CONTEXT*	pContext,
				DWORD	cbTransfer
				) ;

	
	void	Shutdown(	CIODriver&	driver,	CSessionSocket*	pSocket,	SHUTDOWN_CAUSE	cause,	DWORD	dw ) ;
} ;


//	@class	CSessionState derived class which represents the state where we are waiting for
//	client issued commands.
//
//	@base public | CSessionState
//
// the CAceptNNRPD represents a session awaiting a clients NNRPD command.
// In this state we read a line of information from a client and parse
// the line to determine what command the client has issued.
// Depennding on the command issued we may handle the command directly while in this
// state, or put the session into a new state (ie. CAcceptArticle if the client posts)
// Whether we go into another state will depend on how difficult it will be to process
// the request.
//
class CAcceptNNRPD : public CSessionState {
private :

	//
	//	Counts the IO's that have completed - we always issue pairs of IO's 
	//
	long	m_cCompletes ;

	//
	//	Buffer containing the command line !
	//
	CBUFPTR	m_pbuffer ;			// A reference we keep to the buffer containing the command arguments !

	//
	//	Do we wish to generate a transaction log for the current command ?
	//
	BOOL	m_fDoTransactionLog ;

	//
	//
	//
	LPSTR	m_lpstrLogString ;

public :

	CAcceptNNRPD() ;

	//	
	//	This function will issue a CIOReadLine IO operation.  When this read completes
	//	we will attempt to parse the NNTP command the user has sent us.
	//
	BOOL	
	Start(	CSessionSocket*,	
			CDRIVERPTR&,	
			CIORead*&,	
			CIOWrite*& 
			) ;

	//
	//	The only read's issued in this state are CIOReadLine's, in which we expect to get
	//	a buffer containing a single <CR><LF> terminated line containing an NNTP command.
	//
	class	CIO*	
	Complete(	class	CIOReadLine*,	
				class	CSessionSocket*,	
				CDRIVERPTR&	pdriver,
				int	cArgs,	
				char	**pszArgs,	
				char*	pchBegin 
				) ;


	//
	//	Both CAsyncExecute and CAsync command objects will eventually
	//	be handled by this function upon their completion !
	//
	class CIO*	
	InternalComplete(	
				class CSessionSocket*, 
				CDRIVERPTR&	pdriver,	
				class	CExecutableCommand*	pCmd, 
				class CLogCollector* pCollector 
				) ;

	//
	//	Each CExecute derived command we execute is controlled by 
	//	a CIOWriteCMD object which calls this completion function
	//	when the entire command is completed !
	//
	class CIO*	
	Complete(	class CIOWriteCMD*, 
				class CSessionSocket*, 
				CDRIVERPTR&	pdriver,	
				class	CExecute*	pCmd, 
				class CLogCollector* pCollector 
				) ;

	//
	//	Each CAsyncExecute derived command we execute is controlled by 
	//	a CIOWriteAsyncCMD object which calls this completion function
	//	when the entire command is completed !
	//
	class CIO*	
	Complete(	class CIOWriteAsyncCMD*, 
				class CSessionSocket*, 
				CDRIVERPTR&	pdriver,	
				class	CAsyncExecute*	pCmd, 
				class CLogCollector* pCollector 
				) ;



	//
	//	The only write's issued will be short responses to commands.  If a command would require
	//	a large response, we would be in a different state (CExtendedCMD).
	//	We only have 1 write pending ever.
	class CIO*	
	Complete(	class CIOWriteLine*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;

} ;



//-----------------------
//  Outgoing States - The following states occur only on sessions initiated by
//  this server.
//



class	CNegotiateStreaming	:	public	CSessionState	{
private :

	//
	//	Count the IO's we issue !	
	//
	long		m_cCompletions ;

	//
	//	When the read of the response completes we will set
	//	this to TRUE if streaming was negotiated !
	//
	BOOL		m_fStreaming ;

	//
	//	Start up the next state in a peer push feed !!!
	//
	BOOL		NextState(	
					CSessionSocket*	pSocket, 
					CDRIVERPTR&	pdriver, 
					CIORead*&	pRead, 
					CIOWrite*&	pWrite 
					) ;

public : 

	//
	//	Initialize ourselves - m_cCompletions must be -2 as we 
	//	will need to complete 2 IO's before we can move to the 
	//	next state !
	//
	CNegotiateStreaming( )	: 
		m_cCompletions( -2 ), m_fStreaming( FALSE ) {}

	//
	//	Issue our initial IO's !
	//
	BOOL	
	
	Start(	CSessionSocket*,	
			CDRIVERPTR&,	
			CIORead*&,	
			CIOWrite*& 
			) ;

	//
	//	Complete reading a line - did the other side have 
	//	streaming support ? ? 
	//
	//
	class CIO*	
	Complete(	
				class	CIOReadLine*,	
				class	CSessionSocket*,	
				CDRIVERPTR&	pdriver,
				int	cArgs,	
				char	**pszArgs,	
				char*	pchBegin 
				) ;

	//
	//	We write a line contianing 'mode stream' to find out 
	//	if the remote side supports streaming !
	//
	class CIO*	
	Complete(	class CIOWriteLine*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;



} ;


class	CStreamBase :	public	CSessionState	{
protected : 

	//
	//	Only derived classes should be able to create us 
	//
	CStreamBase() ;

	//
	//	ID of the article we've tried to send once already anyhow !
	//
	GROUPID		m_GroupIdRepeat ;
	ARTICLEID	m_ArticleIdRepeat ;

	//
	//	If this is true than all subsequent Remove requests will fail 
	//	as we have looped the queue.
	//
	BOOL		m_fDrain ;

	//
	//	Get an article from the queue.
	//	NOTE : this handles terminating feed loops
	//
	BOOL		
	Remove(	CNewsTree*	pTree,
			COutFeed*	pOutFeed,
			GROUPID&	groupId, 
			ARTICLEID&	articleId
			) ;

	//
	//	This queues an article to be sent again !
	//
	void
	ReSend(	COutFeed*	pOutFeed, 
			GROUPID		groupId, 
			ARTICLEID	articleId
			) ;

	//
	//
	//
	class	CIOWriteLine*
	BuildQuit(	CDRIVERPTR&	pdriver ) ;

	//
	//	Build the CIOTransmit object which sends the next article in the queue - 
	//	and handle the requeue issues if any failures occur !
	//
	CIOTransmit*
	NextTransmit(	GROUPID			GroupId, 
					ARTICLEID		ArticleId,
					CSessionSocket*	pSocket, 
					CDRIVERPTR&		pdriver,
					CTOCLIENTPTR&		pArticle
					) ;


} ;



//
//	This class manages the session when we are offering articles.
//	If at any point the remote end indicates it wants all of the
//	articles in a batch of 16 that we offer, we will send the
//	16 articles and then invoke the CStreamArticles state !
//
class	CCheckArticles :	public	CStreamBase	{
private : 


	//
	//	Are we completing Check commands !?
	//
	BOOL		m_fDoingChecks ;
	
	//
	//	List of articles we are checking if the remote site wants
	//
	CArticleRef	m_artrefCheck[16] ;

	//
	//	Number of check commands we fired off !
	//
	int			m_cChecks ;
	
	//
	//	Number of Check articles we have completed processing
	//
	int			m_iCurrentCheck ;

	//
	//	Article Refs of guys we are sending or about to send !
	//
	CArticleRef	m_artrefSend[16] ;

	//
	//	Number of articles we have sent !
	//
	int			m_cSends ;

	//
	//	The next slot we have for putting in a send request !
	//	
	int			m_iCurrentSend ;

	//
	//	The structure which represents all the check commands we have sent !
	//
	MultiLine	m_mlCheckCommands ;

	//
	//	The article we are currently transmitting !
	//
	CTOCLIENTPTR	m_pArticle ;

	BOOL
	FillCheckBuffer(	
						CNewsTree*	pTree,
						COutFeed*	pOutFeed, 
						BYTE*		lpb,
						DWORD		cb
						) ;

#if 0 
	CIOTransmit*
	NextTransmit(	GROUPID			groupId, 
					ARTICLEID		articleId,
					CSessionSocket*	pSocket, 
					CDRIVERPTR&		pdriver
					) ;
#endif

	int
	Match(	char*	szMessageId, 
			DWORD	cb 
			) ;

	CIOWrite*
	InternalStart(	CSessionSocket*	pSocket, 
					CDRIVERPTR&		pdriver
					) ;

	BOOL
	NextState(		CSessionSocket*	pSocket, 
					CDRIVERPTR&		pdriver, 
					CIORead*&		pRead, 
					CIOWrite*&		pWrite
					) ;

public : 

	//
	//	This constructor puts us into a state where 
	//	we will issue a bunch of check commands first !
	//
	CCheckArticles() ;

	//
	//	This constructor puts us into a state where 
	//	we will pick up a specified number of takethis 
	//	command responses !
	//
	CCheckArticles(	CArticleRef*	pArticleRefs, 
					DWORD			cSent ) ;
	

	//
	//	Issue our initial IO's 
	//
	BOOL	
	Start(	CSessionSocket*,	
			CDRIVERPTR&,	
			CIORead*&,	
			CIOWrite*& 
			) ;

	//
	//	Start sending those articles the remote 
	//	site decided it wanted to get !
	//
	BOOL	
	StartTransfer(	
			CSessionSocket*,	
			CDRIVERPTR&,	
			CIORead*&,	
			CIOWrite*& 
			) ;


	//
	//	collect up all of the 'check' responses
	//
	class CIO*	
	Complete(	
				class	CIOReadLine*,	
				class	CSessionSocket*,	
				CDRIVERPTR&	pdriver,
				int	cArgs,	
				char	**pszArgs,	
				char*	pchBegin 
				) ;

	//
	//	Complete the sending of a whole bunch of check commands !
	//
	class CIO*	
	Complete(	class CIOMLWrite*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;

	//
	//	Completes the sending of a 'quit' command !
	//
	class CIO*	
	Complete(	class CIOWriteLine*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;

	//
	//	Completes the transfer of an article to the remote server 
	//
	class CIO*	
	Complete(	CIOTransmit*	ptransmit,	
				CSessionSocket*	pSocket,	
				CDRIVERPTR&	pdriver,
				TRANSMIT_FILE_BUFFERS*	pbuffers, 
				unsigned cbBytes = 0 
				) ;

	//
	//	Cleans up any state we may have when our session is terminated
	//
	void	
	Shutdown(	CIODriver&	driver,	
				CSessionSocket*	pSocket,	
				SHUTDOWN_CAUSE	cause,	
				DWORD	dw 
				) ;

} ;



class	CStreamArticles :	public	CStreamBase	{
private : 

	//
	//	This constructor is private cause we don't want anybody
	//	using it !
	//
	CStreamArticles() ;

	//
	//	Article Refs of guys we are sending or about to send !
	//
	CArticleRef	m_artrefSend[16] ;

	//
	//	Number of articles we have sent !
	//
	int			m_cSends ;

	//
	//	Count the number of times the remote side failed 
	//	a 'takethis' command - if it becomes excessive 
	//	we will go back to the CCheckArticles state !
	//
	int			m_cFailedTransfers ;

	//
	//	Number of Consecutive failures
	//
	int			m_cConsecutiveFails ;

	//
	//	Total number of articles sent !
	//	
	int			m_TotalSends ;

	//
	//	The article currently being transmitted !
	//
	CTOCLIENTPTR	m_pArticle ;

	//
	//	Get the next article to transmit 
	//
	CIOTransmit*
	CStreamArticles::Next(	CSessionSocket*	pSocket, 
							CDRIVERPTR&		pdriver
							)  ;

	//
	//	Get next file to transmit 
	//
	CIOTransmit*
	CStreamArticles::NextTransmit(	GROUPID	groupid, 
									ARTICLEID	articleid, 
									CSessionSocket*	pSocket, 
									CDRIVERPTR&		pdriver
									) ;

public : 

	CStreamArticles(	CArticleRef*	pSent, 
						DWORD			nSent	) ;

	//
	//	Issue our initial IO's 
	//
	BOOL	
	Start(	CSessionSocket*,	
			CDRIVERPTR&,	
			CIORead*&,	
			CIOWrite*& 
			) ;


	//
	//	Read the response to a 'takethis' command 
	//
	class CIO*	
	Complete(	
				class	CIOReadLine*,	
				class	CSessionSocket*,	
				CDRIVERPTR&	pdriver,
				int	cArgs,	
				char	**pszArgs,	
				char*	pchBegin 
				) ;

	//
	//	Transmit a file to the remote side !
	//
	class CIO*	
	Complete(	CIOTransmit*	ptransmit,	
				CSessionSocket*	pSocket,	
				CDRIVERPTR&	pdriver,
				TRANSMIT_FILE_BUFFERS*	pbuffers, 
				unsigned cbBytes = 0 
				) ;

	//
	//	Completes the sending of a 'quit' command !
	//
	class CIO*	
	Complete(	class CIOWriteLine*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;



	void
	Shutdown(	CIODriver&	driver,
				CSessionSocket*	pSocket,
				SHUTDOWN_CAUSE	cause,
				DWORD	dw 
				) ;

} ;


	


//	@class	The COfferArticles class is used when we have a COutFeed object and we
//	wish to send articles to another server.
//
//	@base public | CSessionState
//
//	In this state, we may issue, Post, IHave or XREPLIC commands depending on the
//	outgoing Feed Object.
//
class   COfferArticles : public CSessionState   {
private :
	static	char		szQuit[] ;

	//
	//	We usually have 2 IO's pending - when they're both complete
	//	its time to cycle to the next article in the queue
	//
	long				m_cCompletions ;

	//
	//	Are we ready to send the next command !
	//
	long				m_cTransmitCompletions ;

	//
	//	Are we terminating because we have nothing more to send ? 
	//
	BOOL				m_fTerminating ;

	//
	//	The next read that completes - is it the response to a 'post' command
	//	or the result of a 'post' command ?
	//
	BOOL				m_fReadPostResult ;

	//
	//	Set to TRUE if we should send the next article in our queue.
	//
	BOOL				m_fDoTransmit ;

	//
	//	Identify the guy that we want to send ntext !
	//
	GROUPID				m_GroupidNext ;
	ARTICLEID			m_ArticleidNext ;
	CTOCLIENTPTR		m_pArticleNext ;

	CTOCLIENTPTR		m_pCurrentArticle ;

	//
	//	Identify the first guy that the other end tolds us to 
	//	retransmit.  We will kill the session when we pull this 
	//	off the queue so that we do retransmits on a new session !
	//
	GROUPID				m_GroupidTriedOnce ;
	ARTICLEID			m_ArticleidTriedOnce ;

	//
	//	Identify the guy who is currently being sent to the remote end
	//	so if the session drops while we're sending, we can retransmit !
	//
	GROUPID				m_GroupidInProgress ;
	ARTICLEID			m_ArticleidInProgress ;

	int				GetNextCommand(	
						CNewsTree*	pTree,
						COutFeed*	pOutFeed,	
						BYTE*	pb,	
						DWORD	cb,	
						DWORD&	ibOffset 
						) ;

	CIOTransmit*	BuildTransmit(	CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver,	GROUPID	groupid,	ARTICLEID	artid ) ;
	CIOWriteLine*	BuildWriteLine(	CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver,	GROUPID	groupid,	ARTICLEID	artid ) ;
	CIO*			Complete(	CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver ) ;

public :

	COfferArticles(	) ;

	BOOL	Start(	CSessionSocket*,	CDRIVERPTR&,	CIORead*&,	CIOWrite*& ) ;
	class	CIO*	Complete(	class	CIOReadLine*,	class	CSessionSocket*,	CDRIVERPTR&	pdriver,
						int	cArgs,	char	**pszArgs,	char*	pchBegin ) ;
	class	CIO*	Complete( class CIOWriteLine*,	class	CSessionSocket *, CDRIVERPTR&	pdriver ) ;
	class	CIO*	Complete( CIOTransmit*	ptransmit,	CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver,
						TRANSMIT_FILE_BUFFERS*	pbuffers, unsigned cbBytes = 0 ) ;
	void	Shutdown(	CIODriver&	driver,	CSessionSocket*	pSocket,	SHUTDOWN_CAUSE	cause,	DWORD	dw ) ;
} ;



//
// MAX_STATE_SIZE constant -
//
// This constant represents the maximum size of all of the CSessionState derived classes.
// This will be used with the CPool allocator to allocate CSessionState objects.
//
#define MAX_STATE_SIZE  max( sizeof( CSessionState ),	\
                        max( sizeof( CNNTPLogonToRemote ),	\
                        max( sizeof( CAcceptNNRPD ),	\
                        max( sizeof( CCollectGroups ),	\
                        max( sizeof( CCollectArticles ),	\
                        max( sizeof( COfferArticles ) ,	\
                        max( sizeof( CCheckArticles ) ,	\
                        max( sizeof( CStreamArticles ) ,	\
							 sizeof( CCollectNewnews ) ) ) ) ) ) ) ) )

extern	const	unsigned	cbMAX_STATE_SIZE ;



//--------- Socket Session Classes ---------------------------------------------

//
// The following classes represent a session that we control over a socket.
// There is a base class which contains static data which is generated during
// initialization.  There are two derived classes - one representing live sessions
// and another representing listens on a particular port.
//


//
// The ClientContext structure holds everything that we need to pass between states
// regarding a session.
//
struct  ClientContext   {

	//
	//	ptr to owning virtual server instance
	//
	PNNTP_SERVER_INSTANCE	m_pInstance ;

	//
	//	Did the client connect on a secure (SSL) port ?
	//
	BOOL				m_IsSecureConnection ;

	//
	//	The CInFeed derived objects for processing incoming articles - 
	//	This may be NULL if this is used with an outbound feed
	//
	CInFeed*			m_pInFeed ;

	//
	//	The outgoing feed object - this object will maintain a queue
	//	of articles which we are sending to the remote server
	//
	COutFeed*			m_pOutFeed ;

	//
	//	The currently selected group for the session - 
	//	this is set through the GROUP command
	//
	CGRPPTR             m_pCurrentGroup ; 
	
	//
	//	The 'Current Article pointer' this is advanced 
	//	and set through commands like next and last.
	//
	ARTICLEID			m_idCurrentArticle ;

	//
	//	The logong context of the current user
	//
    CSecurityCtx        m_securityCtx;
	
	//
	//	If we are doing any SSL/PCT stuff the CEncryptCtx
	//	maintains all of the sessions encryption key and SSPI stuff.
	//
	CEncryptCtx			m_encryptCtx;

	//
	//	This is where we will stuff return strings that we 
	//	send to clients when doing command processing.
	//
	CNntpReturn			m_return ;

	//
	//	The results of the last command !
	//
	NRC					m_nrcLast ;

	//
	//	The Win32 error code from the last command !
	//
	DWORD				m_dwLast ;

	//
	//	This is a buffer we use to build CCmd objects in place.
	//	Since there can only be one command in progress at a time
	//	we build them in place here to avoid memory alloc/frees
	//
	BYTE				m_rgbCommandBuff[348] ;	

	ClientContext( PNNTP_SERVER_INSTANCE pInstance, BOOL IsClient = FALSE, BOOL	IsSecurePort = FALSE ) ;
	~ClientContext() ;

	//
	// called when a user is authenticated to increment the relevant
	// perfmon and snmp statistic counters
	//
	void	IncrementUserStats( void );

	//
	// called when a user disconnects or starts an authentication session
	// to decrement the relevant perfmon and snmp statistic counters
	//
	void	DecrementUserStats( void );
} ;




//	Forward Declarations
class   CSocketList ;
class	CSessionSocket ;



//
//	CSessionSocket objects represent a live session to another server
//	or with a client.
//
class CSessionSocket : public CRefCount {
//
// CSessionSocket represents a live session to a client or server.
//	We keep these in a doubly linked list managed by a static CSocketList object.
//
private :

    //
    //  We will keep all CSessionSocket objects in a linked list
    //  so that we can easily enumerate all sessions.
    //
	static	CPool	gSocketAllocator ;

	//
	//	CSocketList is a friend so it can use our m_pNext and m_pPrev pointers
	//
	friend	class	CSocketList ;

	//
	//	TerminateGlobals() is a friend so it can look into our CPool during shutdown etc..
	//
	friend	VOID    TerminateGlobals();	

	//
	//	Next and Prev pointers - all CSessionSockets are in a doubly linked
	//	list while active.
	//
    CSessionSocket* m_pPrev ;
    CSessionSocket* m_pNext ;

	friend class	CIO ;

	//
	//	The following set of variables is used when forcing off sessions
	//	We want to allow only one call to Disconnect(), and then to 
	//	save the arguments so that we can figure out later why we disconnect'd
	//
	long			m_cCallDisconnect ;
	long			m_cTryDisconnect ;
	SHUTDOWN_CAUSE	m_causeDisconnect ;
	DWORD			m_dwErrorDisconnect ;

public :

	//
	//	The m_pHandleChannel points to the object which actually issues
	//	the reads and writes to Atq
	//
#ifdef	FILEIO
	CIOFileChannel	*m_pHandleChannel ;
#else
	CSocketChannel	*m_pHandleChannel ;
#endif

	//
	//	The m_pSink is the object which maintains the current state and
	//	manages all of our async IO.
	//
	CIODriverSink	*m_pSink ;

	//
	//	This function is called when every IO etc... associated with
	//	a socket has been destroyed - at this point we can release the
	//	CSessionSocket object.
	//
	static	void	ShutdownNotification( void*	pv,	SHUTDOWN_CAUSE	cause,	DWORD	dwOptional ) ;	

    //
    // time connection made
    //

    FILETIME   m_startTime;

    //
    // ip address of remote host
    //

    DWORD m_remoteIpAddress;

    //
    // IP address of the local host (us)
    //

    DWORD m_localIpAddress;

    //
    // NNTP Port used
    //
    DWORD m_nntpPort;

	//
	//	If the session timeouts, should we send a 502 Timeout message ? 
	//
	BOOL	m_fSendTimeout ;

	//
	//	All the clients 'state' info - current group article etc...
	//
	ClientContext	m_context ;

	//
	//	IP access check
	//

	METADATA_REF_HANDLER	m_rfAccessCheck; 
    ADDRESS_CHECK   		m_acAccessCheck;

	//
	//	The following functions are wrapped by Accept(), and 2 forms of ConnectSocket().
	//
	//	AcceptInternal() starts the state machine into the client processing state machine. (CAcceptNNRPD)
	//
	BOOL	AcceptInternal( HANDLE h, CInFeed*	pFeed, sockaddr_in *paddr, void* patqContext, BOOL	fSSL,	CSINKPTR&	pSink ) ;	
	//
	//	This ConnectSocketInternal() starts the state machine into the correct state for
	//	pull feeds.  This can be either CNNTPLogonToRemote, CCollectNewnews or CCollectGroups
	//	depedning on Feed settings.
	//
	BOOL	ConnectSocketInternal( sockaddr_in    *premote, CInFeed *infeed, CDRIVERPTR&	pSink, class	CAuthenticator*	pAuthenticator ) ;
	//
	//	This ConnectSocketInternal() starts the state machine into the correct state for 
	//	push feeds.  This can be either CNNTPLogonToRemote or COfferArticles depending on feed settings.
	//
	BOOL	ConnectSocketInternal( sockaddr_in    *premote, COutFeed *outfeed, CDRIVERPTR&	pSink, class	CAuthenticator*	pAuthenticator ) ;
	
	//
	//	Adjust perfmon counters.
	//
	void	BumpCountersUp() ;
	void	BumpCountersDown() ;
	void    BumpSSLConnectionCounter();

public :

	//
	//	This object is used to build up strings for Transaction Logging.
	//	Because for some commands we want all the arguments, whereas others we want a 
	//	mix of commands and response codes or even other stuff, Transaction Logging
	//	is not straight forward.	The m_Collector object holds an internal buffer
	//	we will use to catenate the transaction log strings.
	//
	CLogCollector	m_Collector ;


    //
    //  Class Initializer must be called absolutely first !
    //  Class Initializer will set up ATQ,
    //
    static  BOOL    InitClass( ) ;
	static	BOOL	TermClass( ) ;

	//
	//	Allocate and Free using are CPool.
	//
	inline	void*	operator	new( size_t	size ) ;
	inline	void	operator	delete( void*	pv ) ;

    //
    // Constructor/Destructor
    //

	CSessionSocket( PNNTP_SERVER_INSTANCE pInstance, DWORD LocalIP, DWORD Port, BOOL IsClient = FALSE ) ;
	~CSessionSocket() ;

    //--------------------------------------------------
    //  There are two mechanisms for creating a socket :
    //  Either accept an incoming call - in which case we will
    //  have to log the user on and then determine all the relevant
    //  state information - or initiate a socket for an outgoing feed.
    //
    //  Initialize a socket which on which we have recently completed an accept().
    //
	BOOL	Accept( HANDLE h, CInFeed*	pFeed, sockaddr_in *paddr, void* patqContext, BOOL	fSSL ) ;	

    //
    //  Start a socket connecting to a remote site to do some kind of feed.
	//	We will set the correct initial state (C
    //
    BOOL    ConnectSocket( sockaddr_in    *premote, class  COutFeed*,	class	CAuthenticator*	pAuthenticator = 0 ) ;

	//
	//	This version of ConnectSocket is used when we want start a socket for a PULL feed.
	//
	BOOL	ConnectSocket( sockaddr_in    *premote, CInFeed *inFeed, class	CAuthenticator*	pAuthenticator = 0  ) ;

    //
    // Write into transaction log
    //

    BOOL TransactionLog(	CLogCollector*	pCollector,	
							DWORD			dwProtocol = 0, 
							DWORD			dwWin32 = 0,
							BOOL fInBound = TRUE
							);

	//
	//	Another variation of TransactionLogging 
	//
	BOOL TransactionLog(	LPSTR	lpstrOperation,
							LPSTR	lpstrTarget,
							LPSTR	lpstrParameters,
							STRMPOSITION cbBytesSent,
							DWORD	cbBytesRecvd,
							DWORD	dwProtocol = 0, 
							DWORD	dwWin32 = 0,
							BOOL	fInBound = TRUE
							) ;

	//
	//	Variation of TransactionLogging without BytesSent/Recvd
	//
	BOOL TransactionLog(	LPSTR	lpstrOperation,
							LPSTR	lpstrTarget,
							LPSTR	lpstrParameters 
							);

    //
    // Check that the CSessionSocket object is Valid
    //
    BOOL    IsValid( ) ;

    //
    //  Blow off this session for whatever reason (we don't like user, or time out etc...)
    //
    void    Disconnect( SHUTDOWN_CAUSE = CAUSE_LEGIT_CLOSE,	DWORD	dwError = 0 ) ;

    //
    //  Get rid of Socket during server shutdown.
    //
    void    Terminate( void ) ;

    //
    // Get user name
    //

    LPSTR GetUserName( ) { return m_context.m_securityCtx.QueryUserName(); };

    //
    // get client ip address
    //

    DWORD GetClientIP( ) { return m_remoteIpAddress; };

    //
    // get port connected to
    //

    DWORD GetIncomingPort( ) { return m_nntpPort; };

    //
    // Get session start time
    //

    VOID GetStartTime( PFILETIME ft ) { *ft = m_startTime; };

	//
	//	Get a name for the remote end of the connection that we can use for event logs !
	//

	LPSTR	GetRemoteNameString() ;

	//
	//	Get a string we can use for event logs to specify the type of the session
	//

	LPSTR	GetRemoteTypeString() ;

    //
    // Enumerate Sessions
    //

    static DWORD EnumerateSessions( IN  PNNTP_SERVER_INSTANCE pInstance, LPNNTP_SESS_ENUM_STRUCT Buffer );

    //
    // Terminate Session
    //

    static DWORD TerminateSession(
						IN  PNNTP_SERVER_INSTANCE pInstance,
                        IN LPSTR UserName,
                        IN LPSTR IPAddress
                        );

    ADDRESS_CHECK*  QueryAccessCheck() { return &m_acAccessCheck; }
	BOOL  BindInstanceAccessCheck();
	VOID  UnbindInstanceAccessCheck();
} ;

#ifdef	_NO_TEMPLATES_

DECLARE_SMARTPTRFUNC( CSessionSocket ) 

#endif

typedef BOOL
(*ENUMSOCKET)(
    CSessionSocket* pSocket,
    DWORD dwParam,
    PVOID pParam
    );

//+---------------------------------------------------------------
//
//  Class:      CUserList
//
//  Synopsis:   Doubly linked list of currently active users
//
//  History:    gordm       Created         10 May 1995
//
//----------------------------------------------------------------
class CSocketList
{
    public:
        CSocketList() : m_pListHead( NULL ), m_cCount( 0 )
        {
            InitializeCriticalSection( &m_critSec );
        }

        ~CSocketList()
        {
            DeleteCriticalSection( &m_critSec );
        }

        inline void InsertSocket( CSessionSocket* pSocket );
        inline void RemoveSocket( CSessionSocket* pSocket );
        BOOL EnumClientSess(
                ENUMSOCKET pEnumSessFunc,
                DWORD dwParam1,
                PVOID pParam
                );
        BOOL EnumAllSess(
                ENUMSOCKET pEnumSessFunc,
                DWORD dwParam1,
                PVOID pParam
                );


    private:
        CRITICAL_SECTION    m_critSec;
        CSessionSocket*     m_pListHead;
        int                 m_cCount;

    public:
        DWORD   GetContentionCount()
                { return    m_critSec.DebugInfo->ContentionCount; }

        DWORD   GetEntryCount()
                { return    m_critSec.DebugInfo->EntryCount; }

        BOOL    IsEmpty()
                { return    m_pListHead == NULL; }

        //
        // debug only - cannot use to enum or check status of list
        //
        DWORD   GetListCount()
                { return    m_cCount; }

        friend class CSessionSocket ;
};

#include	"session.inl"

#endif	// _SESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\resource.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    reslock.c   (resource.c)

Abstract:

    This module implements the executive functions to acquire and release
    a shared resource.

Author:

    Mark Lucovsky       (markl)     04-Aug-1989

Environment:

    These routines are statically linked in the caller's executable and
    are callable in only from user mode.  They make use of Nt system
    services.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "resource.h"

BOOL
InitializeResource(
    IN PRESOURCE_LOCK Resource
    )

/*++

Routine Description:

    This routine initializes the input resource variable

Arguments:

    Resource - Supplies the resource variable being initialized

Return Value:

    None

--*/

{
    ASSERT( sizeof(RESOURCE_LOCK) == sizeof(RTL_RESOURCE) );

    try {
    	RtlInitializeResource((PRTL_RESOURCE)Resource);
    } except (EXCEPTION_EXECUTE_HANDLER) {
    	return FALSE;
    }

    return TRUE;

} // InitializeResourceLock

BOOL
AcquireResourceShared(
    IN PRESOURCE_LOCK Resource,
    IN BOOL Wait
    )

/*++

Routine Description:

    The routine acquires the resource for shared access.  Upon return from
    the procedure the resource is acquired for shared access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available for must return immediately

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise

--*/

{

    return((BOOL)RtlAcquireResourceShared((PRTL_RESOURCE)Resource,(BYTE)Wait));

} // AcquireResourceLockShared

BOOL
AcquireResourceExclusive(
    IN PRESOURCE_LOCK Resource,
    IN BOOL Wait
    )

/*++

Routine Description:

    The routine acquires the resource for exclusive access.  Upon return from
    the procedure the resource is acquired for exclusive access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available for must return immediately

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise

--*/

{
    return((BOOL)RtlAcquireResourceExclusive((PRTL_RESOURCE)Resource,(BYTE)Wait));
} // AcquireResourceLockExclusive


VOID
ReleaseResource(
    IN PRESOURCE_LOCK Resource
    )

/*++

Routine Description:

    This routine release the input resource.  The resource can have been
    acquired for either shared or exclusive access.

Arguments:

    Resource - Supplies the resource to release

Return Value:

    None.

--*/

{
    RtlReleaseResource((PRTL_RESOURCE)Resource);

} // ReleaseResource

VOID
DeleteResource (
    IN PRESOURCE_LOCK Resource
    )

/*++

Routine Description:

    This routine deletes (i.e., uninitializes) the input resource variable


Arguments:

    Resource - Supplies the resource variable being deleted

Return Value:

    None

--*/

{
    RtlDeleteResource((PRTL_RESOURCE)Resource);
    return;

} // DeleteResource


VOID
NTAPI
MyRtlAssert(
	PVOID	FailedAssertion,
	PVOID	FileName,
	ULONG	LineNumber, 
	PCHAR	Message
)	{

	DebugBreak() ;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\smtpcli.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    smtpcli.h

Abstract:

	This module contains the definition of the CSmtpClient class.
	This class encapsulates the functionality of an SMTP client. It
	inherits from the CPersistentConnection class for winsock/connection
	functionality.

	Also contains the definition of the CSmtpClientPool class. This
	represents a pool of CSmtpClient objects. Only one instance of this
	class will be created.

Author:

    Rajeev Rajan (RajeevR)     19-May-1996

Revision History:

--*/

#ifndef _SMTPCLI_H_
#define _SMTPCLI_H_

#define MAX_RECV_BUFFER_LEN		256
#define CR						0x0D
#define LF						0x0A
#define SMTP_SERVER_PORT		25

#include "persistc.h"

//
// Represents the states of a SMTP client
//

typedef enum _SMTP_STATE {
	sInitialized,				// Init state
	sHeloDone,					// HELO sent and 250 received
	sMailFromSent,				// MAIL FROM sent and 250 received
	sRcptTo,					// One or more RCPT TO sent
	sDataDone,					// DATA sent and 354 received
	sError,						// Error state
} SMTP_STATE;


class CSmtpClient : public CPersistentConnection {

private:
	//
	//	Local computer name - needed for HELO command
	//
	LPSTR	m_lpComputerName;

	//
	//	This clients state
	//
	SMTP_STATE	m_CliState;

    //
    //  dirty flag - set if the SMTP server changes
    //
    BOOL    m_fDirty;

	//
	//	Receive buffer
	//
	TCHAR	m_pRecvBuffer	[MAX_RECV_BUFFER_LEN+1];

	//
	//	Receive a full response from the SMTP server
	//  This involves possibly issuing multiple recvs
	//	till the server sends a CRLF
	//
	int 	fReceiveFullResponse();

	//
	//	Get 3-digit code from response buffer
	//
	int		GetThreeDigitCode(LPSTR lpBuffer, DWORD cbBytes);
	
public:
	//
	//	Construtor
	//
	CSmtpClient(LPSTR lpComputerName);

	//
	//	Destructor
	//
	~CSmtpClient();

	//
	//	get/set this clients state
	//
	SMTP_STATE	GetClientState(){ return m_CliState;}
	VOID		SetClientState(SMTP_STATE CliState){ m_CliState = CliState;}

    //
    //  IsDirty() returns TRUE if SMTP server has changed
    //  MarkDirty() marks this object as dirty ie. SMTP server has changed
    //  MarkClean() marks this object as current
    //
    BOOL    IsDirty(){ return m_fDirty;}
    VOID    MarkDirty(){ m_fDirty = TRUE;}
    VOID    MarkClean(){ m_fDirty = FALSE;}

	//
	//	receive SMTP server greeting
	//
	BOOL	fReceiveGreeting();

	//
	//	send HELO and check response for 250 code
	//
	BOOL	fDoHeloCommand();

	//
	//	send MAIL FROM and check response for 250 code
	//
	BOOL	fDoMailFromCommand( LPSTR lpFrom, DWORD cbFrom );

	//
	//	send RCPT TO and check response for 250 code
	//
	BOOL	fDoRcptToCommand(LPSTR lpRcpt);

	//
	//	send the article data either via socket send() or TransmitFile()
	//
	BOOL	fMailArticle(	
				IN HANDLE	hFile,
				IN DWORD	dwOffset,
				IN DWORD	dwLength,
				IN char*	pchHead,
				IN DWORD	cbHead,
				IN char*	pchBody,
				IN DWORD	cbBody
				);

	//
	//	send DATA and check response for 354 code
	//
	BOOL	fDoDataCommand();

	//
	//	receive and validate response to data transmission
	//
	BOOL	fReceiveDataResponse();
};

class CSmtpClientPool {

private:
	//
	//	Array of pointers to CSmtpClient objects
	//
	CSmtpClient**	m_rgpSCList;

	//
	//	Number of slots in pool
	//
	DWORD			m_cSlots;

	//
	//	Array of BOOLs indicating avail status
	//  TRUE means the object in this slot is available.
	//
	BOOL*			m_rgAvailList;

	//
	//	critical section to ensure that two threads 
	//  dont get the same object or mark the same object as avail
	//
	CRITICAL_SECTION	m_CritSect;	

	//
	//	Needed by each CSmtpClient object for the HELO command
	//
	TCHAR			m_szComputerName [MAX_COMPUTERNAME_LENGTH+1];

	//
	//	Synchronize access to pool
	//
	VOID LockPool() { EnterCriticalSection(&m_CritSect);}
	VOID UnLockPool(){ LeaveCriticalSection(&m_CritSect);}

	friend VOID DbgDumpPool( CSmtpClientPool* pSCPool );

public:

	//
	//	Constructor, Destructor
	//
	CSmtpClientPool();
	~CSmtpClientPool();

	//
	//	Allocate X objects and initialize them
	//  Set all to avail status
	//
	BOOL AllocPool(DWORD cNumInstances);

	//
	//	Free all objects
	//
	VOID FreePool();

	//
	//	Get an object from the pool
	//
	CSmtpClient* AcquireSmtpClient(DWORD& dwIndex);

	//
	//	Return an object to the pool; Index should be 
	//  same as that returned by GetSmtpClient
	//
	VOID ReleaseSmtpClient(DWORD dwIndex);

    //
    //  Mark all persistent objects as dirty
    //
    VOID MarkDirty();

    //
    //  Get computer name
    //
    LPSTR GetCachedComputerName(){return m_szComputerName;}
};

#endif	// _SMTPCLI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\session.inl ===
inline	void*
CSessionSocket::operator	new(	
							size_t	size 
							) {
/*++

Routine Description : 

	Allocate a new CSessionSocket object using a CPool object 
	reserved for that use.

Arguments : 

	size - size of CSessionSocket object.

Return Value : 

	Allocated memory.

--*/

	Assert( size <= sizeof( CSessionSocket ) ) ;
	void*	pv = gSocketAllocator.Alloc() ;
	return	pv ;
}

inline	void
CSessionSocket::operator	delete(	
							void*	pv 
							)	{
/*++

Routine Description : 

	Release the memory used by a CSessionSocket object back to the CPool

Arguments : 

	pv - memory to be released

Return Value : 

	None.

--*/
	gSocketAllocator.Free( pv ) ;
}

#if 0
inline	DWORD	
CSessionSocket::GetCurrentSessionCount()	{	
/*++

Routine Description : 

	Report the number of CSessionSockets which are handling live sessions
	right now.

Arguments : 

	None.

Return Value : 

	None.


--*/

	return	((m_context.m_pInstance)->m_pInUseList)->GetListCount() ;	
}
#endif


//+---------------------------------------------------------------
//
//  Function:   InsertUser
//
//  Synopsis:   Adds CSessionSocket instances to the InUse list
//
//  Arguments:  pUser:   ptr to CSessionSocket instance
//
//  Returns:    void
//
//  History:    gord        Created         10 Jul 1995
//
//----------------------------------------------------------------
inline void CSocketList::InsertSocket( CSessionSocket* pUser )
{
    pUser->m_pPrev = NULL;

    EnterCriticalSection( &m_critSec );

    if ( m_pListHead )
    {
        m_pListHead->m_pPrev = pUser;
    }
    pUser->m_pNext = m_pListHead;
    m_pListHead = pUser;

    m_cCount++;

    LeaveCriticalSection( &m_critSec );
}


//+---------------------------------------------------------------
//
//  Function:   RemoveUser
//
//  Synopsis:   Removes CSessionSocket instances to the InUse list
//
//  Arguments:  pUser:   ptr to CSessionSocket instance or NULL for m_pHeadList
//
//  Returns:    pUser:   ptr to the removed CSessionSocket instance
//
//  History:    gord        Created         10 Jul 1995
//
//----------------------------------------------------------------
inline void CSocketList::RemoveSocket( CSessionSocket* pUser )
{

    _ASSERT( pUser != NULL );

    EnterCriticalSection( &m_critSec );

    //
    // if we're not at the end set the next element's prev
    // pointer to our prev; including if our prev is NULL
    //
    if ( pUser->m_pNext )
    {
        pUser->m_pNext->m_pPrev = pUser->m_pPrev;
    }

    //
    // if we're not at the head set the prev element's next
    // pointer to our next; including if our next is NULL
    //
    if ( pUser->m_pPrev )
    {
        _ASSERT( m_pListHead != pUser );
        pUser->m_pPrev->m_pNext = pUser->m_pNext;
    }
    //
    // if we're at the head set the head pointer to our next;
    // including if our next is NULL
    //
    else
    {
        _ASSERT( m_pListHead == pUser );
        _ASSERT( pUser->m_pNext != NULL || m_cCount == 1 );

        m_pListHead = pUser->m_pNext;
    }

    m_cCount--;

    LeaveCriticalSection( &m_critSec );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\sslmsgs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sslmsgs.h

Abstract:

    Contains declarations from the ssl package

Author:

    Johnson Apacible (JohnsonA)     12-Sept-1995

Revision History:

--*/

#ifndef	_SSLMSGS_H_
#define	_SSLMSGS_H_

#define SSL_MAC_LENGTH              16

typedef struct _Ssl_Record_Header {
    UCHAR   Byte0;
    UCHAR   Byte1;
} Ssl_Record_Header, * PSsl_Record_Header;

typedef struct _Ssl_Record_Header_Ex {
    UCHAR   Byte0;
    UCHAR   Byte1;
    UCHAR   PaddingSize;
} Ssl_Record_Header_Ex, * PSsl_Record_Header_Ex;

typedef struct _Ssl_Message_Header {
    Ssl_Record_Header   Header;
    UCHAR               MacData[ SSL_MAC_LENGTH ];
} Ssl_Message_Header, * PSsl_Message_Header;

typedef struct _Ssl_Message_Header_Ex {
    Ssl_Record_Header_Ex    Header;
    UCHAR                   MacData[ SSL_MAC_LENGTH ];
} Ssl_Message_Header_Ex, * PSsl_Message_Header_Ex;

//
// SSL macros
//

#define COMBINEBYTES(Msb, Lsb)  \
            ((DWORD) (((DWORD) (Msb) << 8) | (DWORD) (Lsb)))

#define SIZEOF_MSG(pMessage)    \
            (SslRecordSize((PSsl_Record_Header) pMessage ) )


DWORD
SslRecordSize(
    PSsl_Record_Header  pHeader
    );

//
// PCT stuff
//

typedef struct _Pct_Record_Header {
    UCHAR   Byte0;
    UCHAR   Byte1;
} Pct_Record_Header, * PPct_Record_Header;

typedef struct _Pct_Record_Header_Ex {
    UCHAR   Byte0;
    UCHAR   Byte1;
    UCHAR   PaddingSize;
} Pct_Record_Header_Ex, * PPct_Record_Header_Ex;

#endif  // _SSLMSGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\sortlist.inl ===
template< class Data, class Key > 
CList< Data, Key >::CList( ) : m_cData( 0 ), m_cLimit( limit ), m_pData( 0 ) {
}

template< class Data, class Key > 
BOOL    CList< Data, Key >::Init( int limit ) {

    // ASSERT( m_pData == 0 ) ;

    m_cLimit = limit ;
    m_pData = new Data[ limit ] ;

    return  m_pData != 0 ;
}


template< class Data, class Key > 
BOOL    CList< Data, Key >::IsValid( ) {
    return  m_pData != 0 ;
}

template< class Data, class Key > 
BOOL    CList< Data, Key >::Grow( int cGrowth ) {
    // ASSERT( cGrowth != 0 ) ;

    DATA*   p = new Data[ m_cLimit + cGrowth ] ;
    if( p ) {
        CopyMemory( p, m_pData, sizeof( DATA ) * m_cData ) ;
        delete  m_pData ;
        m_pData = p l
        return  TRUE ;
    }
    return  FALSE ;
}

template< class Data, class Key > 
BOOL    CList< Data, Key >::Insert( Data&   entry ) {
    
    int insert = Search( entry->GetKey(), fFound ) ;

    if( m_cData == m_cLimit ) {
        if( !Grow( 10 ) ) 
            return  FALSE ;
    }
    if( insert < m_cData ) {
        MoveMemory( &m_pData[ insert+1 ], &m_pData[ insert ], 
            sizeof( Data ) * (m_cData - insert ) ) ;
    }
    m_pData[insert] = entry ;
    return  TRUE ;
}


template< class Data, class Key > 
BOOL    CList< Data, Key >::Search( Key& k, BOOL &fFound ) {

    int left = 0, right = m_cData ;

    while( left < right ) {
        int mid = (left + right) / 2 ;

        if( k > m_pData[mid].GetKey() ) 
            left = mid + 1;
        else
            right = mid ;
    }
    if( left < m_cData ) 
        fFound = (k == m_pData[ left ].GetKey()) ;
    else
        fFound = FALSE ;
    return  left ;
}

template< class Data, class Key > 
BOOL    CList< Data, Key >::Search( Key &k, Data& d ) {

    BOOL    fRtn ;
    int index = Search( k, fRtn ) ;
    if( fRtn ) {
        d = m_pData[index] ;
    }
    return  fRtn ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\smtpdll.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    smtpdll.cpp

Abstract:

	Implementation of the fPost interface

Author:

    Rajeev Rajan (RajeevR)     17-May-1996

Revision History:

--*/

#ifdef  THIS_FILE
#undef  THIS_FILE
#endif
static  char        __szTraceSourceFile[] = __FILE__;
#define THIS_FILE    __szTraceSourceFile

// local includes
#include "tigris.hxx"

#include <windows.h>
#include <stdio.h>
#include "smtpdll.h"
#include "smtpcli.h"

#define MAX_CLIENTPOOL_SIZE		5

// globals
CSmtpClientPool		g_SCPool;                       // pool of persistent connections
BOOL                g_fInitialized;                 // TRUE if provider layer is initialized
LONG				g_dwPickupFileId;				// starting id of pickup file
CRITICAL_SECTION	g_csIdLock;						// sync access to global id

#define LOCK_ID()	EnterCriticalSection(&g_csIdLock);
#define UNLOCK_ID()	LeaveCriticalSection(&g_csIdLock);

BOOL InitModeratedProvider()
/*++

Routine Description : 

	Initialize the mail interface for article posted to a moderated
	newsgroup. Initialize a pool of CSmtpClient objects. Each such 
	object has a persistent connection to the SMTP server. Requests
	to mail articles are made to the fPostArticle entry-point. When
	such a request is made, an object is taken from this pool and used
	to mail out the article. (If a connection is lost, it is
	re-established while sending the HELO command).

Arguments : 


Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	TraceFunctEnter("Init");

	if(!g_SCPool.AllocPool(MAX_CLIENTPOOL_SIZE))
	{
		ErrorTrace(0, "Failed to allocate client pool");
        g_fInitialized = FALSE;
		return FALSE;
	}

    g_fInitialized = TRUE;
	g_dwPickupFileId = 0;

	InitializeCriticalSection(&g_csIdLock);

	return TRUE;
}

BOOL TerminateModeratedProvider()
/*++

Routine Description : 

	Cleanup the mail interface for moderated newsgroups

Arguments : 

	None

Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
    if(g_fInitialized)
    {
	    // release all the pool objects
	    g_SCPool.FreePool();
    }

	DeleteCriticalSection(&g_csIdLock);

	return TRUE;
}

VOID SignalSmtpServerChange()
/*++

Routine Description : 

	Signal a change in the Smtp server

Arguments : 

	None

Return Value : 
	VOID

--*/
{
    g_SCPool.MarkDirty();
}

// Post an article to the moderator
BOOL fPostArticleEx(
		IN HANDLE	hFile,
        IN LPSTR	lpFileName,
		IN DWORD	dwOffset,
		IN DWORD	dwLength,
		IN char*	pchHead,
		IN DWORD	cbHead,
		IN char*	pchBody,
		IN DWORD	cbBody,
		IN LPSTR	lpModerator,
		IN LPSTR	lpSmtpAddress,
		IN DWORD	cbAddressSize,
		IN LPSTR	lpTempDirectory,
		IN LPSTR	lpFrom,
		IN DWORD	cbFrom
		)
/*++

Routine Description : 

	Send the article to an SMTP server via mail interface OR
	Create a file in the SMTP pickup directory

Arguments : 

	IN HANDLE	hFile			:	handle of file	
	IN LPSTR    lpFileName		:	file name
	IN DWORD	dwOffset		:	offset of article within file
	IN DWORD	dwLength		:	length of article
	IN char*	pchHead			:	pointer to article headers
	IN DWORD	cbHead			:	number of header bytes
	IN char*	pchBody			:	pointer to article body
	IN DWORD	cbBody			:	number of bytes in body
	IN LPSTR	lpModerator		:	moderator 
	IN LPSTR	lpSmtpAddress	:	SMTP server
	IN DWORD	cbAddressSize	:	sizeof server
	IN LPSTR	lpTempDirectory	:	temp dir for smtp pickup
	IN LPSTR	lpFrom			:	from header for mail envelope
	IN DWORD	cbFrom			:	length of from header

Return Value : 
	TRUE if successful - FALSE otherwise !

--*/

{
	BOOL  fUseSmtpPickup = FALSE;
	LPSTR lpSmtpPickupPath;             // UNC name of SMTP pickup path
	DWORD dwTrailLen = 3;

	TraceFunctEnter( "fPostArticle" ) ;

	_ASSERT( lpSmtpAddress && cbAddressSize > 0 );
	_ASSERT( lpTempDirectory );
	_ASSERT( lpModerator );

	// If there exists a '\' in szSmtpAddress this is a pickup dir
    if( strchr((LPCTSTR)lpSmtpAddress, '\\') )
    {
        // This is the UNC path of an SMTP server pickup directory
        fUseSmtpPickup = TRUE;
        lpSmtpPickupPath = lpSmtpAddress;
	}

	//
	//	SMTP pickup - drop a file in a dir and ISBUs SMTP server will pick it up
	//
	if( fUseSmtpPickup )
	{
		// get a unique id to construct a filename
		LOCK_ID();
		LONG dwPickupFileId = ++g_dwPickupFileId;
		UNLOCK_ID();

		// create a file to be picked up; generate a filename based on unique id, thread id etc
		char	szFile[ MAX_PATH+1 ] ;
		char	szPickupFile[ MAX_PATH+1 ] ;

		// temp file - this will be moved to the pickup dir eventually
		lstrcpy( szFile, lpTempDirectory ) ;
		wsprintf( szFile + lstrlen( szFile ), "\\%dP%dT%dC%d.mod", dwPickupFileId, GetCurrentProcessId(), GetCurrentThreadId(), GetTickCount() ) ;

		// final pickup filename
		lstrcpy( szPickupFile, lpSmtpPickupPath ) ;
		lstrcat( szPickupFile, szFile + lstrlen( lpTempDirectory ));

		//if( pSecurity ) {
		//	pSecurity->Impersonate() ;
		//}	

		DWORD	dwError = ERROR_SUCCESS ;
		BOOL	fSuccess = FALSE ;

		// Create a new temp file
		HANDLE	hPickupFile = CreateFile(	szFile, 
											GENERIC_READ | GENERIC_WRITE,
											0,	// No sharing of the file !!
											0, 	
											CREATE_NEW, 
											FILE_ATTRIBUTE_NORMAL,
											INVALID_HANDLE_VALUE
											) ;

		if(INVALID_HANDLE_VALUE == hPickupFile)
		{
			ErrorTrace(NULL,"Could not create file %s: GetLastError is %d", szFile, GetLastError());
			return FALSE;
		}

		//  WriteFile() the To: header
		DWORD	cbWritten = 0 ;	
		fSuccess = TRUE ;
			
		char szToHeader [MAX_MODERATOR_NAME+6+1];
		int cbBytes = wsprintf(szToHeader, "To: %s\r\n", lpModerator);
		fSuccess &= WriteFile(	hPickupFile, szToHeader, cbBytes, &cbWritten, 0 ) ;

		if( !fSuccess ) {
			_VERIFY( CloseHandle( hPickupFile ) );
			DeleteFile( szFile ) ;
			return FALSE;
		}

		// The article is either in a file or in a memory buffer
		if( hFile != INVALID_HANDLE_VALUE )
		{
			// Article data is in file - create file mapping and WriteFile() to pickup file
			CMapFile* pMapFile = XNEW CMapFile(lpFileName, hFile, FALSE, 0 );

			// map the file
			if (!pMapFile || !pMapFile->fGood())
			{
				_VERIFY( CloseHandle( hPickupFile ) );
				DeleteFile( szFile ) ;
				
				if( pMapFile ) {
					XDELETE pMapFile;
					pMapFile = NULL;
				}
				
				ErrorTrace(NULL,"Error mapping file %s GetLastError is %d", lpFileName, GetLastError());
				return FALSE;
			}

			DWORD cbArticle = 0;
			char* pchArticle = (char*)pMapFile->pvAddress( &cbArticle );
			pchArticle += dwOffset;

			// total file size should be equal to sum of initial gap + article length
			_ASSERT( cbArticle == (dwOffset + dwLength));

			// WriteFile() from the file mapping
			// Strip the trailing .CRLF so POP3 likes this message
			if( pchArticle != 0 ) {
				_ASSERT( pchArticle != 0 ) ;
				fSuccess &= WriteFile(	hPickupFile, pchArticle, dwLength-dwTrailLen, &cbWritten, 0 ) ;
			}

			if( !fSuccess ) {
				dwError = GetLastError() ;
				ErrorTrace(NULL,"Error writing to smtp pickup file: GetLastError is %d", dwError);
			}

			_VERIFY( CloseHandle( hPickupFile ) );
			
			if( pMapFile ) {
				XDELETE pMapFile;
				pMapFile = NULL;
			}

			if( !fSuccess ) {
				DeleteFile( szFile ) ;
				return FALSE;
			}
		}
		else
		{
			_ASSERT( hFile == INVALID_HANDLE_VALUE );

			// Article data is in memory buffers - just WriteFile() to the pickup file
			if( pchHead != 0 ) {
				_ASSERT( cbHead != 0 ) ;
				if( pchBody != 0 ) {
					dwTrailLen = 0;
				}
				fSuccess &= WriteFile(	hPickupFile, pchHead, cbHead-dwTrailLen, &cbWritten, 0 ) ;
			}
			if( fSuccess && pchBody != 0 ) {
				_ASSERT( cbBody != 0 ) ;
				fSuccess &= WriteFile(	hPickupFile, pchBody, cbBody-3, &cbWritten, 0 ) ;
			}

			if( !fSuccess ) {
				dwError = GetLastError() ;
				ErrorTrace(NULL,"Error writing to smtp pickup file: GetLastError is %d", dwError);
			}

			_VERIFY( CloseHandle( hPickupFile ) );

			if( !fSuccess ) {
				DeleteFile( szFile ) ;
				return FALSE;
			}
		}

		// Now move the file from the temp dir to the smtp pickup dir
		// NOTE: For the SMTP pickup feature to work, we need to create the file in a temp
		// directory and then do an atomic MoveFile to the pickup directory
		if(!MoveFile( szFile, szPickupFile ))
		{
			ErrorTrace(NULL,"SMTP pickup: Error moving file %s to %s: GetLastError is %d", szFile, szPickupFile, GetLastError() );
			return FALSE;
		}

		//if( pSecurity )	{
		//	pSecurity->RevertToSelf() ;
		//}
	}
	else
	{
		// send over persistent connection interface
		return fPostArticle(
					hFile,
					dwOffset,
					dwLength,
					pchHead,
					cbHead,
					pchBody,
					cbBody,
					lpModerator,
					lpSmtpAddress,
					cbAddressSize,
					lpFrom,
					cbFrom
					);
	}

	return TRUE;
}


BOOL fPostArticle(
		IN HANDLE	hFile,
		IN DWORD	dwOffset,
		IN DWORD	dwLength,
		IN char*	pchHead,
		IN DWORD	cbHead,
		IN char*	pchBody,
		IN DWORD	cbBody,
		IN LPSTR	lpModerator,
		IN LPSTR	lpSmtpAddress,
		IN DWORD	cbAddressSize,
		IN LPSTR	lpFrom,
		IN DWORD	cbFrom
		)
/*++

Routine Description : 

	Send the article to an SMTP server to be delivered to the moderator.

	Obtain a CSmtpClient object from the global pool. In the best case,
	this object already has a connection to the SMTP server. Use this to
	mail the article. If the connection is broken, re-establish the 
	connection while doing the HELO command.

	NOTE: The article contents are either in a memory buffer or in a file
	If hFile != NULL, use TransmitFile to send it else use regular sends()

Arguments : 

	IN HANDLE	hFile			:	handle of file	
	IN DWORD	dwOffset		:	offset of article within file
	IN DWORD	dwLength		:	length of article
	IN char*	pchHead			:	pointer to article headers
	IN DWORD	cbHead			:	number of header bytes
	IN char*	pchBody			:	pointer to article body
	IN DWORD	cbBody			:	number of bytes in body
	IN LPSTR	lpModerator		:	moderator 
	IN LPSTR	lpSmtpAddress	:	SMTP server
	IN DWORD	cbAddressSize	:	sizeof server
	IN LPSTR	lpFrom			:	from header of mail envelope
	IN DWORD	cbFrom			:	length of from header

Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
    // used only if the pool is used up
    CSmtpClient SCNew(g_SCPool.GetCachedComputerName());
    CSmtpClient* pSC;
    BOOL fRet = TRUE;
    BOOL fDone = FALSE;

	TraceFunctEnter("fPostArticle");

    // check to see that the provider is initialized
    if(!g_fInitialized)
    {
        ErrorTrace(0,"Provider not initialized");
        return FALSE;
    }

    _ASSERT(lpModerator);

	// get a client object from pool; allocate a new one if none is 
	// available in the pool.
	DWORD dwIndex;
	CSmtpClient* pSCpool = g_SCPool.AcquireSmtpClient(dwIndex);
	if(!pSCpool)
	{
        // use the local object on the stack
        // NOTE: this is used only if we run out of pool objects
	    SCNew.SetClientState(sInitialized);
        pSC = &SCNew;
	}
    else
    {
        // Use the pool object
        // NOTE: using a pool object is FAST because it is pre-connected
        // If the rate of requests to mail an article is high, we may run
        // out of pool objects. In this case, a local object is used.
        pSC = pSCpool;
    }

    //
    // If this object is not initialized, init it ie. connect() to server
    // and receive greeting. Once connected, the object will maintain the
    // connection, so the next time we avoid having to connect().
    //
    // If the SMTP server changes, we have to re-connect to the new server
    // pSC is checked to see if it is dirty ie. SMTP server has changed
    //
    if(!pSC->IsInitialized() || pSC->IsDirty())
    {
        // If dirty, close the connection and re-connect
        if(pSC->IsDirty())
        {
            if(pSC->IsInitialized())
                pSC->Terminate(TRUE);

            pSC->MarkClean();
        }

		// connect to SMTP server
		if(!pSC->Init(lpSmtpAddress, SMTP_SERVER_PORT))
		{
			ErrorTrace(0,"Failed to init CSmtpClient object");
			fRet = FALSE;
            goto fPostArticle_Exit;
		}

        // this may be in an sError state from a previous transaction
		pSC->SetClientState(sInitialized);

		// receive greeting from server
		if(!pSC->fReceiveGreeting())
		{
            pSC->Terminate(TRUE);
			ErrorTrace( 0,"Failed to receive greeting");
			fRet = FALSE;
            goto fPostArticle_Exit;
		}
    }

	// The client object should be in an initialized state
	_ASSERT(pSC->GetClientState() == sInitialized);

    //
    // At this point pSC points to either a pool object or a local object
	// SMTP client state machine
    //
	fDone = FALSE;
	while(!fDone)
	{
		SMTP_STATE state = pSC->GetClientState();

		switch(state)
		{
			case sInitialized:

				// send HELO
				if(!pSC->fDoHeloCommand())
					pSC->SetClientState(sError);
				else
					pSC->SetClientState(sHeloDone);

				break;

			case sHeloDone:

				// send MAIL FROM
				if(!pSC->fDoMailFromCommand(lpFrom, cbFrom))
					pSC->SetClientState(sError);
				else
					pSC->SetClientState(sMailFromSent);

				break;

			case sMailFromSent:

				// send RCPT TO
				if(!pSC->fDoRcptToCommand(lpModerator))
					pSC->SetClientState(sError);
				else
					pSC->SetClientState(sRcptTo);

				break;

			case sRcptTo:

				// send DATA
				if(!pSC->fDoDataCommand())
					pSC->SetClientState(sError);
				else
					pSC->SetClientState(sDataDone);

				break;

			case sDataDone:

				// mail the article
				if(!pSC->fMailArticle(hFile, dwOffset, dwLength, pchHead, cbHead, pchBody, cbBody))
					pSC->SetClientState(sError);
				else
				{
					if(!pSC->fReceiveDataResponse())
						pSC->SetClientState(sError);
					else
					{
						// ready for next article send
						pSC->SetClientState(sHeloDone);
						fDone = TRUE;
					}
				}

				break;

			case sError:

				ErrorTrace(0,"SmtpClient: invalid state");

                // error - close the connection if it is persistent
                // NOTE: if pSC is a stack object, it is terminated always
                //       if pSC is a pool object, it is terminated only on errors
                if(pSC != &SCNew)
                    pSC->Terminate(TRUE);   

                fDone = TRUE;           // exit while loop
                fRet  = FALSE;          // return failure

                break;

		}	// end switch
	}	// end while

    // if this is a local object, close the connection
    if(pSC == &SCNew)
        pSC->Terminate(TRUE);

fPostArticle_Exit:

	// release this object only if it is from the pool
    if(pSC != &SCNew)
	    g_SCPool.ReleaseSmtpClient(dwIndex);

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\sortlist.h ===
//
// sortlist.h
//
// This file contains stuff for building sorted lists.  The classes defined
//  here are templated in which the user can specify his own key and 
//  data element.  It is assumed by the templates that an element can
//  be copied using CopyMemory() or MoveMemory().
//
// Implementation Schedule for all classed defined by this file : 
//
//  0.5 week
//
//
// Unit Test Schedule for all classes defined by this file : 
//
//  0.5 week
//
//  Unit Testing will consist of the following : 
//
//  Build a standalone executable that uses these templates to build 
//  a sorted list.  This executable should do the following : 
//      Create a list and insert elements in sorted order
//      Create a list and insert elements in reverse sorted order
//      Create a list and insert elements in random order
//      Search for every element inserted in each list.
//      Search for elements not in the list.
//
//




#ifndef _SORTLIST_H_
#define _SORTLIST_H_

#include    "smartptr.h"

/*

The following defines the interface the classes used
with the template must support : 

class   Data    {
public : 
    Data() ;
    Key&     GetKey( ) ;
} ;

class   Key {
public : 
    BOOL    operator < ( Key& ) ;
    BOOL    operator== ( Key& ) ;
    BOOL    operator > ( Key& ) ;


} ;

*/

//----------------------------------------------------------------------
template< class Data, class Key >
class   CList : public  CRefCount   {
//
//  Template class CList - 
//  This template will maintain a sorted array of elements.
//  This will be an array of type Data (not Data*).
//  We will keep track of three things : 
//  a pointer to the array.
//  The Number of elements in use in the array.
//  The total number of elements in the array.
//
//  This class is derived from CRefCount and can be used with  Smart Pointers.
//
//  This Insert function of this class is not Multi-thread safe.  All other
//  functions are.
//
private : 
    friend  class   CListIterator< Data, Key > ;
    Data*       m_pData ;   // Array of Data objects
    int         m_cData ;   // Number of Data objects we are using in the array
    int         m_cLimit ;  // Total Number of Data objects in the array. The 
                            // last m_cLimit-m_cData objects are initialized with the
                            // default constructor and do not take place in any 
                            // searches.

    
    //
    // Private functions used to manage the size of the array.
    //
    BOOL        Grow( int cGrowth ) ;
    BOOL        Shrink( int cGap ) ;
    int         Search( Key&, BOOL& ) ;
public : 
    //
    // Because we want to be smart pointer enabled we have very
    // simple constructors.
    //
    CList( ) ;
    ~CList( ) ;

    //
    //  Initialization functions 
    //
    BOOL    Init( int limit ) ;             // Specify initial size, 
                                            // no elements in the list
    BOOL    Init( Data *p, int cData ) ;    // Specify an initial array
                                            // of elements which we will copy.
    
    BOOL    IsValid() ;                     // Test validity of this class

    BOOL    Insert( Data&   entry ) ;       
    BOOL    Search( Key&, Data& ) ;
    
    BOOL    Remove( Key&, Data& ) ;

} ;

#include    "sortlist.inl"

//-----------------------------------------------------------------------
template< class Data, class Key > 
//
//  Template class CListIterator - 
//  
//  This class is used by people who wish to enumerate a sorted list.
//
//  We will either enumerate everything in the list, or upon 
//  Initialization the user will specify a key, and we will enumerate
//  everything following that key.
//
//  This class is not intended to be multithread safe.  If two threads
//  wish to enumerate the same list they should create different CListIterator
//  objects.
//  
// 
class   CListIterator   {
public : 
    typedef CList< Data, Key >   TARGETLIST ;
private : 

    CRefPtr< TARGETLIST >   m_pList ;   // Smart pointer to original list
    int                     m_index ;   // current position
    int                     m_begin ;   // begin of the range we are enuming
    int                     m_end ;     // end of the range we are enuming
public : 
    //
    // Simple Constructor and Destructor.
    //
    CListIterator( ) ;
    ~CListIterator( ) ;

    //
    // Initialization functions.  User may specify an initial key 
    //  if they wish to enumerate only things larger than the key.
    //
    BOOL    Init( TARGETLIST    *p ) ;
    BOOL    Init( TARGETLIST    *p, Key k ) ;

    //
    // Worker functions.
    // These functions use m_index, m_begin and m_end to move through the list.
    //
    Data    Next( ) ;
    Data    Prev( ) ;
    BOOL    IsEnd( ) ;
    BOOL    IsBegin( ) ;
} ;

#include    "iterator.inl"

#endif  // _SORTLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\socket.cpp ===
/*++

	socket.cpp

	This file contains the implementation of the CSessionSocket class.
	Each CSessionSocket object represents a live TCP/IP session with another client or server.


--*/


#define	INCL_INETSRV_INCS
#include	"tigris.hxx"
#include    <lmerr.h>

BOOL
EnumSessInfo(
    IN CSessionSocket * pSess,
    IN DWORD dwParam,
    IN LPNNTP_SESS_ENUM_STRUCT Buffer
    );


// MOVED TO CService => CSocketList	CSessionSocket::InUseList ;
CPool	CSessionSocket::gSocketAllocator(SESSION_SOCKET_SIGNATURE) ;

BOOL
CSessionSocket::InitClass()		{
/*++

Routine Description :

	This function initializes the CSessionSocket pool.

Arguments :

	None.

Return Value :

	None.

--*/
	return	gSocketAllocator.ReserveMemory(	MAX_SESSIONS, sizeof( CSessionSocket ) ) ;
}	//	InitClass

BOOL
CSessionSocket::TermClass()	{
/*++

Routine Description :

	This function frees up the CSessionSocket Pool.

Arguments :

	None.

Return Value :

	None.

--*/
	Assert( gSocketAllocator.GetAllocCount() == 0 ) ;
	return	gSocketAllocator.ReleaseMemory( ) ;
}


ClientContext::ClientContext(
						PNNTP_SERVER_INSTANCE pInstance,
						BOOL	IsClient,
						BOOL	IsSecure
						) :
/*++

Routine Description :

	Initialize a ClientContext object.

Arguments :
	
	None.

Return Value :

	None.

--*/
	//
	//	ClientContext holds most of a clients state - ie the article they have
	//	currently selected, etc... Initialize stuff to be invalid.
	//
	m_idCurrentArticle( INVALID_ARTICLEID ),
	m_pInFeed( 0 ),
	m_encryptCtx( IsClient, pInstance->GetSslAccessPerms() ),
	m_pInstance( pInstance ),
	m_securityCtx(	pInstance,
					IsClient ?
					TCPAUTH_CLIENT|TCPAUTH_UUENCODE :
					TCPAUTH_SERVER|TCPAUTH_UUENCODE,
					pInstance->m_dwAuthorization,
					pInstance->QueryAuthentInfo() ),
	m_IsSecureConnection( IsSecure ),
	m_pOutFeed( 0 )
{
	if ( m_securityCtx.IsAuthenticated() )
	{
		IncrementUserStats();
	}

	pInstance->LockConfigRead();
	
	//
	//	Set SSPI package names for this sec context
	//
	
	m_securityCtx.SetInstanceAuthPackageNames(
					pInstance->GetProviderPackagesCount(),
					pInstance->GetProviderNames(),
					pInstance->GetProviderPackages());

	//
	// We want to set up the Cleartext authentication package
	// for this connection based on the instance configuration.
	// To enable MBS CTA,
	// MD_NNTP_CLEARTEXT_AUTH_PROVIDER must be set to the package name.
	// To disable it, the md value must be set to "".
	//
	
	m_securityCtx.SetCleartextPackageName(
		pInstance->GetCleartextAuthPackage(), pInstance->GetMembershipBroker());

#if 0		
	if (*pInstance->GetCleartextAuthPackage() == '\0' ||
		*pInstance->GetMembershipBroker() == '\0') {
		m_fUseMbsCta = FALSE;
	}
	else {
		m_fUseMbsCta = TRUE;
	}
#endif
	pInstance->UnLockConfigRead();

#ifdef	DEBUG
	FillMemory( m_rgbCommandBuff, sizeof( m_rgbCommandBuff ), 0xCC ) ;
#endif

}	//	ClientContext::ClientContext

ClientContext::~ClientContext()
{
	if ( m_securityCtx.IsAuthenticated() )
	{
		DecrementUserStats();
	}

	//
	//	Deref instance ref count - this was bumped up by IIS or
	//	in session socket constructor.
	//
	m_pInstance->DecrementCurrentConnections();
	m_pInstance->Dereference();

#ifdef	DEBUG
	//
	//	Ensure that the last command object was destroyed !
	//
	for( int i=0; i<sizeof(m_rgbCommandBuff) / sizeof( m_rgbCommandBuff[0]); i++ ) 	{
		_ASSERT( m_rgbCommandBuff[i] == 0xCC ) ;
	}
#endif

}	//	ClientContext::~ClientContext



VOID
ClientContext::IncrementUserStats(
						VOID
						)
/*++

Routine Description :

	Increment Perfmon/SNMP Stats once a user is authenticated

Arguments :
	
	None.

Return Value :

	None.

--*/
{
	if ( m_securityCtx.IsAnonymous() )
	{
		LockStatistics( m_pInstance );

		IncrementStat( m_pInstance, CurrentAnonymousUsers);
		IncrementStat( m_pInstance, TotalAnonymousUsers);
		if ( (m_pInstance->m_NntpStats).CurrentAnonymousUsers > (m_pInstance->m_NntpStats).MaxAnonymousUsers )
		{
			(m_pInstance->m_NntpStats).MaxAnonymousUsers = (m_pInstance->m_NntpStats).CurrentAnonymousUsers;
		}

		UnlockStatistics( m_pInstance );
	}
	else
	{
		LockStatistics( m_pInstance );

		IncrementStat( m_pInstance, CurrentNonAnonymousUsers);
		IncrementStat( m_pInstance, TotalNonAnonymousUsers);
		if ( (m_pInstance->m_NntpStats).CurrentNonAnonymousUsers > (m_pInstance->m_NntpStats).MaxNonAnonymousUsers )
		{
			(m_pInstance->m_NntpStats).MaxNonAnonymousUsers = (m_pInstance->m_NntpStats).CurrentNonAnonymousUsers;
		}

		UnlockStatistics( m_pInstance );
	}
}


VOID
ClientContext::DecrementUserStats(
						VOID
						)
/*++

Routine Description :

	Decrement Perfmon/SNMP Stats once a user disconnects or reauths

Arguments :
	
	None.

Return Value :

	None.

--*/
{
	if ( m_securityCtx.IsAnonymous() )
	{
		DecrementStat( m_pInstance, CurrentAnonymousUsers );
	}
	else
	{
		DecrementStat( m_pInstance, CurrentNonAnonymousUsers );
	}
}


CSessionSocket::CSessionSocket(
/*++

Routine Description :

	Initialize a CSessionSocket object.
	Place the CSessionSocket object into the InUseList.
	Because the socket is available in the InUseList before all of the necessary
	Init functions are called (either Accept() or ConnectSocket()) it is
	necessary to take some precautions with Disconnect().
	Consequently, we have a couple of counters we interlockIncrement to
	synchronize an Accept()'ing or Connect()'ing thread with anybody trying
	to disconnect.

Arguements :

	The local IP address, Port and a flag specifying whether this is a client session.

Return Value :

	None.

--*/
	IN PNNTP_SERVER_INSTANCE	pInstance,
    IN DWORD LocalIP,
    IN DWORD Port,
    IN BOOL IsClient
    ) :
	m_pPrev( 0 ),
	m_pNext( 0 ),
	m_pHandleChannel( 0 ),	
	m_pSink( 0 ),
	m_context( pInstance ),	//	set the owning virtual server instance in the client context
	m_cCallDisconnect( -1 ),
	m_cTryDisconnect( -2 ),
	m_causeDisconnect( CAUSE_UNKNOWN ),
	m_dwErrorDisconnect( 0 ),
	m_fSendTimeout( TRUE ) {

	TraceFunctEnter( "CSessionSocket::CSessionSocket" ) ;

	DebugTrace( (DWORD_PTR)this, "Insert self into list" ) ;

	//
	// If outbound connection, we need to bump a ref count on the instance
	// and bump current connections. Both are decremented by the client context destructor.
	//

	if( IsClient ) {
		pInstance->Reference();
		pInstance->IncrementCurrentConnections();
	}

	BumpCountersUp();

    //
    // init time
    //

    GetSystemTimeAsFileTime( &m_startTime );

    //
    // init members
    //

    m_remoteIpAddress = INADDR_NONE;
    m_localIpAddress = LocalIP;
    m_nntpPort = Port;

	(pInstance->m_pInUseList)->InsertSocket( this ) ;

}	//	CSessionSocket::CSessionSocket

CSessionSocket::~CSessionSocket()	{
	//
	//	Not much to do but remove ourselves from the list of active sockets.
	//
	TraceFunctEnter( "CSessionSocket::~CSessionSocket" ) ;
	((m_context.m_pInstance)->m_pInUseList)->RemoveSocket( this ) ;

	BumpCountersDown();

	DebugTrace( (DWORD_PTR)this, "Just removed self from list" ) ;

    //
    // We're done.  Log transaction
    //

    TransactionLog( 0 );

} //CSessionSocket::~CSessionSocket



void
CSessionSocket::BumpCountersUp()	{


	PNNTP_SERVER_INSTANCE pInst = m_context.m_pInstance ;
	LockStatistics( pInst ) ;

	IncrementStat( pInst, TotalConnections ) ;
	IncrementStat( pInst, CurrentConnections ) ;

	if( (pInst->m_NntpStats).MaxConnections < (pInst->m_NntpStats).CurrentConnections ) {
		(pInst->m_NntpStats).MaxConnections = (pInst->m_NntpStats).CurrentConnections ;	
	}

	UnlockStatistics( pInst ) ;

}

void
CSessionSocket::BumpSSLConnectionCounter() {

    PNNTP_SERVER_INSTANCE pInst = m_context.m_pInstance;
    LockStatistics( pInst );

    IncrementStat( pInst, TotalSSLConnections );

    UnlockStatistics( pInst );
}

void
CSessionSocket::BumpCountersDown()	{

	PNNTP_SERVER_INSTANCE pInst = m_context.m_pInstance ;

	LockStatistics( pInst ) ;

	DecrementStat(	pInst, CurrentConnections ) ;

	UnlockStatistics( pInst ) ;
}


LPSTR
CSessionSocket::GetRemoteTypeString( void )	{

	if( m_context.m_pInFeed != 0 ) {
		return	m_context.m_pInFeed->FeedType() ;
	}	else if( m_context.m_pOutFeed != 0 ) {
		return	m_context.m_pOutFeed->FeedType() ;
	}
	return	"DUMMY" ;
}

LPSTR
CSessionSocket::GetRemoteNameString( void ) {
	
	struct	in_addr	remoteAddr ;
	
	remoteAddr.s_addr = m_remoteIpAddress ;

	return	inet_ntoa( remoteAddr ) ;	


}

BOOL
CSessionSocket::Accept( HANDLE h,
						CInFeed*	pFeed,	
						sockaddr_in *paddr,
						void* patqContext,
						BOOL fSSL )	{
/*++

Routine Description :

	Initialize a socket into the appropriate state for an incoming call.
	AcceptInternal will do the brunt of the work - we will mainly check that
	somebody didn't try to Disconnect() us while we were setting up our
	state machine etc...

	WARNING :
	IO Errors while accepting the socket may cause the CSessionSocket to be
	destoyed before this function returns.
	Callers should not reference their pSocket again until they have safely
	lock the InUseList critical section which will guarantee them that things
	will not be destroyed from under their feet.


Arguments :

	h - Handle of the incoming socket
	pFeed - the Feed object appropriate for the incoming call.
	paddr - Address of the incoming call
	patqContext - optional Atq context if the connection was accepted through AcceptEx()
	fSSL - TRUE implies this is a SSL session.

Return Value :
	
	TRUE if successfull - if TRUE is returned callers must destroy us with a call
	to Disconnect().

	FALSE - unsuccessfull - callers must delete us.

--*/
	//
	//	We pass a refcounting pointer to AcceptInternal by reference.
	//	This will be used by AcceptInternal and essentially guarantees that
	//	if an error occurs on the very first IO and it happens to complete
	//	before this code is finished that the CSessionSocket etc... will not
	//	be destroyed from under us !!!
	//	In fact - the destructor of pSink may destroy the socket when we
	//	exit this function so callers should not reference the socket
	//	after calling us.
	//

	CSINKPTR	pSink ;

	if( AcceptInternal(	h,
						pFeed,
						paddr,
						patqContext,
						fSSL,
						pSink ) ) {

		if( InterlockedIncrement( &m_cTryDisconnect ) == 0 )	{

			m_pSink->UnsafeClose( this, m_causeDisconnect, m_dwErrorDisconnect ) ;

		}
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CSessionSocket::AcceptInternal( HANDLE h,
						CInFeed*	pFeed,	
						sockaddr_in *paddr,
						void* patqContext,
						BOOL fSSL,
						CSINKPTR&	pSink )	{
/*++

Routine Description :

	Initialize a socket into the appropriate state for an incoming call.
	We need to create the appropriate state objects etc... and start the
	initial IO operations.

Arguments :

	h - Handle of the incoming socket
	pFeed - the Feed object appropriate for the incoming call.
	paddr - Address of the incoming call
	patqContext - optional Atq context if the connection was accepted through AcceptEx()
	fSSL - TRUE implies this is a SSL session.
	pSink - a reference to a smart pointer which we will use to hold the
		CIODriver objects we may create.   This will guarantee the caller
		that nothing will be blown away from underneath them untill pSink
		is destroyed by the caller.

Return Value :
	
	TRUE if successfull - if TRUE is returned callers must destroy us with a call
	to Disconnect().

	FALSE - unsuccessfull - callers must delete us.

--*/


	//
	//	Somebody has connected to the server.
	//	We create this CSessionSocket for them, now we have to set it up
	//	to do stuff.
	//

	TraceFunctEnter( "CSessionSocket::AcceptInternal" ) ;


	//
	//	NOTE - once CIODriver::Init is called we should let sockets be destroyed
	//	through the regular shutdown process instead of having the caller destroy
	//	them - so in some failure cases we will return TRUE.  Initialize to FALSE
	//	for now.
	//

	BOOL	fFailureReturn = FALSE ;


    //
    // Get the source ip address
    //

    m_remoteIpAddress = paddr->sin_addr.s_addr;
    ErrorTrace(0,"Client IP is %s\n", inet_ntoa( paddr->sin_addr ));

	m_context.m_pInFeed = pFeed ;

	CSocketChannel*	pHandleChannel = new CSocketChannel() ;

	if (pHandleChannel == NULL) {
	    ErrorTrace((DWORD_PTR)this, "Out of memory");
	    return FALSE;
	}

	CIOPTR		pSSL = 0 ;
	CSTATEPTR	pStart = new CAcceptNNRPD() ;

	if (pStart == NULL) {
	    ErrorTrace((DWORD_PTR)this, "Out of memory");
	    goto Exit;
	}

	//
	//	Use reference counting temp pointer so that if the socket tears down while
	//	we're still trying to set it up we don't have to worry that our CIODriverSink()
	//	will destroy itself on another thread.
	//	
	m_pSink = pSink = new CIODriverSink( 0 ) ;

	if (pSink == NULL) {
	    ErrorTrace((DWORD_PTR)this, "Out of memory");
	    goto Exit;
	}

	if( fSSL ) {
		pSSL = new( *pSink ) CIOServerSSL( pStart, m_context.m_encryptCtx ) ;
		m_context.m_IsSecureConnection = TRUE ;
		if( pSSL == 0 )		{
	        ErrorTrace((DWORD_PTR)this, "Out of memory");
			goto Exit;
		}
		BumpSSLConnectionCounter();
	}	

	DebugTrace( (DWORD_PTR)this, "Accepted socket Sink %x HandleChannel %x", pSink, pHandleChannel ) ;

	if( pHandleChannel && pSink && pStart ) {
		DebugTrace( (DWORD_PTR)this, "All objects succesfully created !!" ) ;
		pHandleChannel->Init( h, this, patqContext ) ;

		if( pSink->Init( pHandleChannel, this, ShutdownNotification, this ) )	{
			fFailureReturn = TRUE ;
			m_pHandleChannel = pHandleChannel ;
			pHandleChannel = 0 ;
			if( pSSL == 0 ) {

				CIORead*	pRead = 0 ;
				CIOWrite*	pWrite = 0 ;
				if( pStart->Start( this, CDRIVERPTR( pSink ), pRead, pWrite ) ) {

					//
					//	When we call pSink->Start() errors can cause these
					//	CIO objects to have references even though the function failed.
					//	So we will make smart pointers of our own for these objects
					//	so that they get properly destroyed in error cases.
					//

					CIOPTR	pReadPtr = pRead ;
					CIOPTR	pWritePtr = pWrite ;

					if( pSink->Start( pReadPtr, pWritePtr, this ) ) {
						return	TRUE ;
					}	
				}	else	{
					ErrorTrace( (DWORD_PTR)this, "Failed to start state machine !" ) ;
					// Close down Sink and Channel
				}
			}	else	{
				if( pSink->Start( pSSL, pSSL, this ) )	{
					return	TRUE ;
				}
			}
		}
	}

Exit:
	if( pHandleChannel ) {
	    pHandleChannel->CloseSource(0);
		delete	pHandleChannel ;
	}
	return	fFailureReturn ;
}	//	CSessionSocket::Accept

BOOL
CSessionSocket::ConnectSocket(	sockaddr_in	*premote,	
								CInFeed* infeed,
								CAuthenticator*	pAuthenticator ) {
/*++

Routine Description :

	Connect to a remote server.
	This function will call ConnectSocketInternal to do the brunt of the work.
	We will ensure that if somebody tried to disconnect us before we were ready
	that we will actually eventually die.

Arguments :

	premote - The address to connect to
	peer -	The feed object to be used

Return Value :

	TRUE if successfully connected - caller must use Disconnect() to close us.
	FALSE otherwise - destroy this socket with delete().

--*/

	
	CDRIVERPTR	pSink ;

	if( ConnectSocketInternal( premote, infeed, pSink, pAuthenticator ) ) {

		if( InterlockedIncrement( &m_cTryDisconnect ) == 0 )	{

			_ASSERT( m_pSink != 0 ) ;

			m_pSink->UnsafeClose( this, m_causeDisconnect, m_dwErrorDisconnect ) ;

		}
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CSessionSocket::ConnectSocketInternal(
        sockaddr_in	*premote,
        CInFeed *infeed,
		CDRIVERPTR&	pSink,
		CAuthenticator*	pAuthenticator
        )	{
/*++

Routine Description :

	This function sets up the necessary state machines etc... to pull a feed from
	the remote server.

Arguments :

	premote - Address of the remote server.
	peer -	Feed object.
	pSInk - Reference to a smart pointer to the sink we create - this is done
		so that the caller can keep a reference and ensure that the CIODriverSink is
		not destroyed before the caller is ready
	pAuthenticator - object to handle authentication with remote server -
		WE ARE RESPONSIBLE FOR DESTRUCTION - whether we succeed or not we must
		ensure that this object gets destroyed. The caller is hands off !

Return Value :

	TRUE if succesfull, FALSE otherwise.


--*/

	//
	//	This function exists to initiate connections to other server.
	//	First, create a CSessionSocket, and then call us with the
	//	address and feed of the remote server.
	//

    ENTER("ConnectSocket")

	BOOL	fFailureReturn = FALSE ;
	m_context.m_pInFeed = infeed;

	m_remoteIpAddress = premote->sin_addr.s_addr ;

	//
	//	Do not send out timeout commands on these sessions !
	//
	m_fSendTimeout = FALSE ;

	//
	//	Try to create a socket
	//
	SOCKET	hSocket = 0 ;
	hSocket = socket( AF_INET, SOCK_STREAM, 0 ) ;
	if( hSocket == INVALID_SOCKET ) {
		DWORD dw = GetLastError() ;
		Assert( 1==0 ) ;
		if( pAuthenticator != 0 )
			delete	pAuthenticator ;
		return	FALSE ;
	}

	//
	//	Try to connect to the remote site
	//
	if( connect( hSocket, (struct sockaddr*)premote, sizeof( struct sockaddr ) ) != 0 ) {
		DWORD	dw = GetLastError() ;
		DWORD	dw2 = WSAGetLastError() ;
        ErrorTrace(0,"Error %d in connect\n",WSAGetLastError());
		closesocket( hSocket ) ;
		if( pAuthenticator != 0 )
			delete	pAuthenticator ;
		return	FALSE ;
	}

	//
	//	Get the name of the socket for our own use !
	//
	struct	sockaddr_in	sockName ;
	int		sockLength = sizeof( sockName ) ;
	if( !getsockname( hSocket, (sockaddr*)&sockName, &sockLength ) ) {
		m_localIpAddress = sockName.sin_addr.s_addr ;
	}
	

	//
	//	Allocate the objects we need to manage the session !
	//
	m_pHandleChannel = new CSocketChannel() ;

	if( m_pHandleChannel == 0 ) {
		closesocket( hSocket ) ;
		if( pAuthenticator != 0 )
			delete	pAuthenticator ;
		return	FALSE ;
	}

	m_pHandleChannel->Init( (HANDLE)hSocket, this ) ;


	pSink = m_pSink = new	CIODriverSink( 0 ) ;
	CCollectNewnews*	pNewnews = new CCollectNewnews( ) ;
	CSessionState*	pState = pNewnews ;
	if( m_context.m_pInFeed->fCreateAutomatically() )	{
		CCollectGroups*		pGroups = new CCollectGroups( pNewnews ) ;
		if( pGroups == 0 ) {
			delete	pNewnews ;
			if( pAuthenticator != 0 )
				delete	pAuthenticator ;
			return	FALSE ;
		}
		pState = pGroups ;
	}

	CSTATEPTR	ppull = new	CSetupPullFeed( pState ) ;
	if( ppull == 0 ) {
		if( pAuthenticator != 0 )
			delete	pAuthenticator ;
		return	FALSE ;
	}
	pState = ppull ;

	//
	//	NOW - plogon is a reference counting pointer - so any failure after
	//	this point will automatically destroy the CNNTPLogonToRemote object.
	//
	//	Additionally, all the state objects we have created so far are now
	//	pointed to by smart pointers in other state objects.  So we have no
	//	delete calls to make after this point regardless of failure conditions
	//	as the smart pointers will clean everything up automagically.
	//
	//	After passing pAuthenticator to the constructor of CNNTPLogonToRemote
	//	we are no longer responsible for its destruction - CNNTPLogonToRemote
	//	handles this in all cases, error or otherwise
	//


	CSTATEPTR	plogon = new CNNTPLogonToRemote( pState, pAuthenticator ) ;

	if( plogon == 0 ) {
		if( pAuthenticator != 0 )
			delete	pAuthenticator ;
	}

	if( pSink!= 0 && pNewnews != 0 && pState != 0 && plogon != 0 ) {
		if( m_pSink->Init( m_pHandleChannel, this, ShutdownNotification, this ) )	{
			fFailureReturn = TRUE ;

			CIORead*	pReadTemp = 0 ;
			CIOWrite*	pWriteTemp = 0 ;

			if( plogon->Start( this, pSink, pReadTemp, pWriteTemp ) )	{
	
				CIOPTR	pRead = pReadTemp ;
				CIOPTR	pWrite = pWriteTemp ;
			
				if( m_pSink->Start( pRead, pWrite, this) )	{
					return	TRUE ;
				}
			}
		}
	}

    LEAVE
	return	fFailureReturn ;
}	//	CSessionSocket::ConnectSocket


BOOL
CSessionSocket::ConnectSocket(	sockaddr_in	*premote,	
								COutFeed* pOutFeed,
								CAuthenticator*	pAuthenticator ) {
/*++

Routine Description :

	Connect to a remote server.
	This function will call ConnectSocketInternal to do the brunt of the work.
	We will ensure that if somebody tried to disconnect us before we were ready
	that we will actually eventually die.

Arguments :

	premote - The address to connect to
	peer -	The feed object to be used

Return Value :

	TRUE if successfully connected - caller must use Disconnect() to close us.
	FALSE otherwise - destroy this socket with delete().

--*/

	
	CDRIVERPTR	pSink ;

	if( ConnectSocketInternal( premote, pOutFeed, pSink, pAuthenticator ) ) {

		if( InterlockedIncrement( &m_cTryDisconnect ) == 0 )	{

			_ASSERT( m_pSink != 0 ) ;

			m_pSink->UnsafeClose( this, m_causeDisconnect, m_dwErrorDisconnect ) ;

		}
		return	TRUE ;
	}
	return	FALSE ;
}


BOOL
CSessionSocket::ConnectSocketInternal(
        sockaddr_in	*premote,
        COutFeed*	pOutFeed,
		CDRIVERPTR&	pSink,
		CAuthenticator*	pAuthenticator
        )	{
/*++

Routine Description :

	This function sets up the necessary state machines etc... to pull a feed from
	the remote server.

Arguments :

	premote - Address of the remote server.
	peer -	Feed object.
	pSInk - Reference to a smart pointer to the sink we create - this is done
		so that the caller can keep a reference and ensure that the CIODriverSink is
		not destroyed before the caller is ready
	pAuthenticator - object to handle authentication with remote server -
		WE ARE RESPONSIBLE FOR DESTRUCTION - whether we succeed or not we must
		ensure that this object gets destroyed. The caller is hands off !

Return Value :

	TRUE if succesfull, FALSE otherwise.


--*/

	//
	//	This function exists to initiate connections to other server.
	//	First, create a CSessionSocket, and then call us with the
	//	address and feed of the remote server.
	//

    ENTER("ConnectSocket")

	BOOL	fFailureReturn = FALSE ;

	m_remoteIpAddress = premote->sin_addr.s_addr ;

	//
	//	Do not send out timeout commands on these sessions !
	//
	m_fSendTimeout = FALSE ;

	//
	//	Try to create a socket
	//
	SOCKET	hSocket = 0 ;
	hSocket = socket( AF_INET, SOCK_STREAM, 0 ) ;
	if( hSocket == INVALID_SOCKET ) {
		DWORD dw = GetLastError() ;
		Assert( 1==0 ) ;
		if( pAuthenticator != 0 )
			delete	pAuthenticator ;
		return	FALSE ;
	}

	//
	//	Bind the socket so this virtual server's IP is found by remote end
	//
	DWORD localIpAddress = (m_context.m_pInstance)->QueryServerIP();
	if( localIpAddress ) {
    	SOCKADDR_IN localAddr;
	    localAddr.sin_family = AF_INET;
	    localAddr.sin_addr.s_addr = localIpAddress;
	    localAddr.sin_port = 0;

	    if( bind( hSocket, (const struct sockaddr FAR*) &localAddr, sizeof(sockaddr) )) {
		    DWORD	dw = GetLastError() ;
		    DWORD	dw2 = WSAGetLastError() ;
            ErrorTrace(0,"Error %d in connect WSA is %d \n",dw, dw2);
		    closesocket( hSocket ) ;
		    if( pAuthenticator != 0 )
			    delete	pAuthenticator ;
		    return	FALSE ;
        }

        PCHAR args [2];
        CHAR  szId [20];

        _itoa( (m_context.m_pInstance)->QueryInstanceId(), szId, 10 );
        args [0] = szId;
        args [1] = inet_ntoa( localAddr.sin_addr );
        NntpLogEvent( NNTP_OUTBOUND_CONNECT_BIND, 2, (const CHAR**) args, 0 );
	}
	
	//
	//	Try to connect to the remote site
	//
	if( connect( hSocket, (struct sockaddr*)premote, sizeof( struct sockaddr ) ) != 0 ) {
		DWORD	dw = GetLastError() ;
		DWORD	dw2 = WSAGetLastError() ;
        ErrorTrace(0,"Error %d in connect\n",WSAGetLastError());
		closesocket( hSocket ) ;
		if( pAuthenticator != 0 )
			delete	pAuthenticator ;
		return	FALSE ;
	}

	//
	//	Get the name of the socket for our own use !
	//
	struct	sockaddr_in	sockName ;
	int		sockLength = sizeof( sockName ) ;
	if( !getsockname( hSocket, (sockaddr*)&sockName, &sockLength ) ) {
		m_localIpAddress = sockName.sin_addr.s_addr ;
	}	else	{
		DWORD	dw = WSAGetLastError() ;
	}
	
	//
	//	Create the objects we need to manage the session !
	//
	m_pHandleChannel = new CSocketChannel() ;
	if( m_pHandleChannel == 0 ) {
		closesocket( hSocket ) ;
		if( pAuthenticator != 0 )
			delete	pAuthenticator ;
		return	FALSE ;
	}

	m_pHandleChannel->Init( (HANDLE)hSocket, this ) ;

	pSink = m_pSink = new	CIODriverSink( 0 ) ;
	m_context.m_pOutFeed = pOutFeed ;

	CSTATEPTR	pState ;
	if( pOutFeed->SupportsStreaming() ) {

		pState = new	CNegotiateStreaming() ;	
		
	}	else	{

		pState = new	COfferArticles(	) ;

	}
	
	//
	//	After passing pAuthenticator to the constructor of CNNTPLogonToRemote
	//	we are no longer responsible for its destruction - CNNTPLogonToRemote
	//	handles this in all cases, error or otherwise
	//
	CSTATEPTR	plogon = new CNNTPLogonToRemote( pState, pAuthenticator ) ;

	if( plogon == 0 ) {
		if( pAuthenticator == 0 )
			delete	pAuthenticator ;
	}

	if( pSink!= 0 && pState != 0 && plogon != 0 ) {
		if( m_pSink->Init( m_pHandleChannel, this, ShutdownNotification, this ) )	{
			fFailureReturn = TRUE ;

			CIORead*	pReadTemp = 0 ;
			CIOWrite*	pWriteTemp = 0 ;

			if( plogon->Start( this, pSink, pReadTemp, pWriteTemp ) )	{

				CIOPTR	pRead = pReadTemp ;	
				CIOPTR	pWrite = pWriteTemp ;

				if( m_pSink->Start( pRead, pWrite, this) )	{
					return	TRUE ;
				}
			}
			pState = 0 ;
			plogon = 0 ;
		}
	}

    LEAVE
	return	fFailureReturn ;
}	//	CSessionSocket::ConnectSocket



void
CSessionSocket::Disconnect( SHUTDOWN_CAUSE	cause,	
							DWORD	dwError )	{
	//
	//	This function should terminate a session !
	//
	//m_pHandleChannel->Close( ) ;

	if( cause == CAUSE_TIMEOUT &&
		!m_fSendTimeout ) {
		cause = CAUSE_SERVER_TIMEOUT ;
	}

	m_causeDisconnect = cause ;
	m_dwErrorDisconnect = dwError ;

	if( InterlockedIncrement( &m_cCallDisconnect ) == 0 ) {

		if( InterlockedIncrement( &m_cTryDisconnect ) == 0 )	{
			_ASSERT( m_pSink != 0 ) ;
			if( m_pSink != 0 )
				m_pSink->UnsafeClose( this, cause, dwError ) ;
		}
	}
}

BOOL
CSessionSocket::BindInstanceAccessCheck()
/*++

Routine Description:

    Bind IP/DNS access check for this request to instance data

Arguments:

    None

Returns:

    BOOL  - TRUE if success, otherwise FALSE.

--*/
{
    if ( m_rfAccessCheck.CopyFrom( (m_context.m_pInstance)->QueryMetaDataRefHandler() ) )
    {
        m_acAccessCheck.BindCheckList( (LPBYTE)m_rfAccessCheck.GetPtr(), m_rfAccessCheck.GetSize() );
        return TRUE;
    }
    return FALSE;
}

VOID
CSessionSocket::UnbindInstanceAccessCheck()
/*++

Routine Description:

    Unbind IP/DNS access check for this request to instance data

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_acAccessCheck.UnbindCheckList();
    m_rfAccessCheck.Reset( (IMDCOM*) g_pInetSvc->QueryMDObject() );
}

#ifdef	PROFILE
static	int count = 0 ;
#endif

void
CSessionSocket::ShutdownNotification(
        void    *pv,
        SHUTDOWN_CAUSE  cause,
        DWORD   dw
        )
{

	//
	//	This function is registered with all CIODriver's which control
	//	Socket IO completion.  This will be called when all activity
	//	related to a socket has completed and it can be safely destoyed !
	//

    CInFeed *peer;

    ENTER("ShutdownNotification")

    Assert( pv != 0 ) ;

    CSessionSocket*	pSocket = (CSessionSocket*)pv ;

    //
    // Call feed manager completion
    //

    peer = pSocket->m_context.m_pInFeed;

	if( peer != 0 ) {
		CompleteFeedRequest(
			(pSocket->m_context).m_pInstance,
			peer->feedCompletionContext(),
			peer->GetSubmittedFileTime(),
			(cause == CAUSE_LEGIT_CLOSE) ||
			(cause == CAUSE_USERTERM),
			cause == CAUSE_NODATA
			);
		delete peer;
	}

	if( pSocket->m_context.m_pOutFeed != 0 ) {

		FILETIME	ft ;
		ZeroMemory( &ft, sizeof( ft ) ) ;
	
		CompleteFeedRequest(	
			(pSocket->m_context).m_pInstance,
			pSocket->m_context.m_pOutFeed->feedCompletionContext(),
			ft,
			(cause == CAUSE_NODATA) ||
			(cause == CAUSE_LEGIT_CLOSE) ||
			(cause == CAUSE_USERTERM),
			cause == CAUSE_NODATA
			);
		delete	pSocket->m_context.m_pOutFeed ;
	}

			


    delete pSocket ;
}

DWORD
CSessionSocket::EnumerateSessions(
					IN  PNNTP_SERVER_INSTANCE pInstance,
                    OUT LPNNTP_SESS_ENUM_STRUCT Buffer
                    )
{
    DWORD err = NO_ERROR;
    LPNNTP_SESSION_INFO sessInfo;
    DWORD nEntries;

    ENTER("EnumerateSessions")

    //
    // grab the critsec so the number does not change
    //

    Buffer->EntriesRead = 0;
    Buffer->Buffer = NULL;

    ACQUIRE_LOCK( &(pInstance->m_pInUseList)->m_critSec );

    nEntries = (pInstance->m_pInUseList)->GetListCount();

    if ( nEntries > 0 ) {

        sessInfo = (LPNNTP_SESSION_INFO)
            MIDL_user_allocate(nEntries * sizeof(NNTP_SESSION_INFO));

        if ( sessInfo == NULL) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        ZeroMemory(sessInfo, nEntries * sizeof(NNTP_SESSION_INFO));

    } else {

        //
        // No sessions, exit
        //

        goto cleanup;
    }

    //
    //  dwEntriesRead must be set to 0 and it will be updated to the
    //  correct final value by EnumUsers call below
    //

    Buffer->Buffer = sessInfo;

    (VOID)(pInstance->m_pInUseList)->EnumClientSess((ENUMSOCKET)EnumSessInfo, 0, (PVOID)Buffer);
    _ASSERT(Buffer->EntriesRead <= nEntries);

cleanup:

    RELEASE_LOCK( &(pInstance->m_pInUseList)->m_critSec );
    LEAVE
    return  err;

} // EnumerateSessions

BOOL
EnumSessInfo(
    IN CSessionSocket * pSess,
    IN DWORD dwParam,
    IN LPNNTP_SESS_ENUM_STRUCT Buffer
    )
{
    LPNNTP_SESSION_INFO sessInfo;

    ENTER("EnumSessInfo");

    //
    // Point to correct location
    //

    sessInfo = Buffer->Buffer + Buffer->EntriesRead;

    //
    // Copy info to the buffer
    //

	LPSTR	lpstrUser = pSess->GetUserName() ;
	if( lpstrUser )
	    lstrcpy( sessInfo->UserName, lpstrUser );
	else
		sessInfo->UserName[0] = '\0' ;

    pSess->GetStartTime( &sessInfo->SessionStartTime );
    sessInfo->IPAddress = pSess->GetClientIP( );
    sessInfo->PortConnected = pSess->GetIncomingPort( );
    sessInfo->fAnonymous = ((pSess->m_context).m_securityCtx).IsAnonymous();

    Buffer->EntriesRead++;

    return(TRUE);

} // EnumSessInfo

BOOL
CSocketList::EnumClientSess(
    ENUMSOCKET pfnSess,
    DWORD dwParam,
    PVOID pParam
    )
{
    BOOL    bContinue = TRUE;

    ENTER("EnumSess");
    ACQUIRE_LOCK( &m_critSec );
    for ( CSessionSocket* pSess = m_pListHead;
          bContinue && pSess != (CSessionSocket*)NULL;
          ) {

        CSessionSocket*  pNext = pSess->m_pNext;

        //
        // Don't send outgoing connections
        //

        if ( pSess->GetClientIP( ) != INADDR_NONE ) {
            bContinue = (*pfnSess)( pSess, dwParam, pParam );
        }

        pSess = pNext;
    }

    RELEASE_LOCK( &m_critSec );

    return  bContinue;

} // EnumClientSess

BOOL
CSocketList::EnumAllSess(
    ENUMSOCKET pfnSess,
    DWORD dwParam,
    PVOID pParam
    )
{
    BOOL    bContinue = TRUE;

    ENTER("EnumSess");
    ACQUIRE_LOCK( &m_critSec );
    for ( CSessionSocket* pSess = m_pListHead;
          bContinue && pSess != (CSessionSocket*)NULL;
          ) {

        CSessionSocket*  pNext = pSess->m_pNext;

        bContinue = (*pfnSess)( pSess, dwParam, pParam );
        pSess = pNext;
    }

    RELEASE_LOCK( &m_critSec );

    return  bContinue;

} // EnumAllSess

BOOL
CloseSession(
    IN CSessionSocket * pSess,
    IN DWORD IPAddress,
    IN LPSTR UserName
    )
{
    ENTER("CloseSession");

    //
    // Do the ip addresses match?
    //

    if ( (IPAddress == INADDR_ANY) ||
         (IPAddress == pSess->GetClientIP()) ) {

        //
        // ip addresses match, check user name
        //
		LPSTR	lpstrUser = pSess->GetUserName() ;

        if ( (UserName == NULL) ||
             (lpstrUser != NULL && !lstrcmpi(UserName,lpstrUser)) ) {

            IN_ADDR addr;

            //
            // Terminate!
            //

            addr.s_addr = pSess->GetClientIP( );
            DebugTrace(0,"Closed session (user %s[%s])\n",
                pSess->GetUserName(), inet_ntoa(addr) );

            pSess->Disconnect(
                CAUSE_FORCEOFF,
                ERROR_VC_DISCONNECTED   // we might want to change this to
                );                      // something else.
        }
    }

    return(TRUE);

} // CloseSession

DWORD
CSessionSocket::TerminateSession(
					IN PNNTP_SERVER_INSTANCE pInstance,
                    IN LPSTR UserName,
                    IN LPSTR IPAddress
                    )
{
    DWORD ip;
    DWORD err = ERROR_SUCCESS;

    ENTER("TerminateSession")

	if( UserName != 0  &&
		*UserName == '\0' ) {
		UserName = 0 ;
	}

    //
    // Get IP Address
    //

    if ( IPAddress != NULL ) {

        ip = inet_addr(IPAddress);

        //
        // if this is not an ip address, then maybe this is a host name
        //

        if ( ip == INADDR_NONE ) {

            PHOSTENT hp;
            IN_ADDR addr;

            //
            // Ask the dns for the address
            //

            hp = gethostbyname( IPAddress );
            if ( hp == NULL ) {
                err = WSAGetLastError();
                ErrorTrace(0,"Error %d in gethostbyname(%s)\n",err,IPAddress);
                return(NERR_ClientNameNotFound);
            }

            addr = *((PIN_ADDR)*hp->h_addr_list);
            ip = addr.s_addr;
        }

    } else {

        //
        // delete on all ip
        //

        ip = INADDR_ANY;
    }

    (VOID)(pInstance->m_pInUseList)->EnumClientSess((ENUMSOCKET)CloseSession, ip, (PVOID)UserName);
    return(err);

} // TerminateSession

void
CLogCollector::FillLogData(	LOG_DATA	ld,	
							BYTE*		lpb,	
							DWORD		cb ) {

	_ASSERT( ld >= LOG_OPERATION && ld <= LOG_PARAMETERS ) ;
	_ASSERT( lpb != 0 ) ;
	_ASSERT( cb != 0 ) ;

	DWORD	cbAvailable = sizeof( m_szOptionalBuffer ) - m_cbOptionalConsumed ;
	DWORD	cbToCopy = min( cbAvailable, cb ) ;

	if( cbToCopy != 0 ) {

		m_Logs[ld] = (char*) m_szOptionalBuffer + m_cbOptionalConsumed ;
		m_LogSizes[ld] = cbToCopy ;

		//
		//	Do Some arithmetic to leave space for terminating NULL char
		//
		if( cbToCopy == cbAvailable ) {
			cbToCopy -- ;
		}

		CopyMemory( m_szOptionalBuffer + m_cbOptionalConsumed, lpb, cbToCopy ) ;
		m_cbOptionalConsumed += cbToCopy ;

		//
		//	Append a NULL char - space must have been reserved !
		//
		m_szOptionalBuffer[m_cbOptionalConsumed++] = '\0' ;
	}
}

void
CLogCollector::ReferenceLogData(	LOG_DATA	ld,
									BYTE*		lpb ) {

	_ASSERT( ld >= LOG_OPERATION && ld <= LOG_PARAMETERS ) ;
	_ASSERT( lpb != 0 ) ;

	m_Logs[ld]  = (char*) lpb ;

}

BYTE*
CLogCollector::AllocateLogSpace(	DWORD	cb )	{

	BYTE*	lpb = 0 ;

	if( cb < (sizeof( m_szOptionalBuffer ) - m_cbOptionalConsumed) )	{
    	_ASSERT( m_cAllocations ++ < 3 ) ;
		lpb = &m_szOptionalBuffer[m_cbOptionalConsumed] ;
		m_cbOptionalConsumed += cb ;
	}
	return	lpb ;
}

//
// Maximum length of an error msg (copied from w3)
//

#define     MAX_ERROR_MESSAGE_LEN   (500)
BOOL
CSessionSocket::TransactionLog(
                    CLogCollector*	pCollector,
					DWORD			dwProtocol,
					DWORD			dwWin32,
					BOOL			fInBound
                    )
{
	if( !pCollector ) {

		return	TransactionLog( NULL, (LPSTR)NULL, NULL ) ;

	}	else	{

		BOOL	fRtn = TransactionLog( pCollector->m_Logs[LOG_OPERATION],
						pCollector->m_Logs[LOG_TARGET],
						pCollector->m_Logs[LOG_PARAMETERS],
						pCollector->m_cbBytesSent,
						pCollector->m_cbBytesRecvd,
						dwProtocol,
						dwWin32,
						fInBound ) ;
		pCollector->Reset() ;
		return	fRtn ;

	}
} // TransactionLog

BOOL
CSessionSocket::TransactionLog(
					LPSTR	lpstrOperation,	
					LPSTR	lpstrTarget,
					LPSTR	lpstrParameters
					)
{
	STRMPOSITION cbJunk1;
	DWORD cbJunk2 = 0;
	ASSIGNI( cbJunk1, 0 );

	return TransactionLog( lpstrOperation, lpstrTarget, lpstrParameters, cbJunk1, cbJunk2 );
}

BOOL
CSessionSocket::TransactionLog(
					LPSTR	lpstrOperation,	
					LPSTR	lpstrTarget,
					LPSTR	lpstrParameters,
					STRMPOSITION	cbBytesSent,
					DWORD	cbBytesRecvd,
					DWORD	dwProtocol,
					DWORD	dwWin32,
					BOOL	fInBound
                    )
{
    INETLOG_INFORMATION request;
    CHAR ourIP[32];
    CHAR theirIP[32];
    CHAR pszError[MAX_ERROR_MESSAGE_LEN] = "";
    DWORD cchError= MAX_ERROR_MESSAGE_LEN;
	LPSTR lpUserName;
	LPSTR lpNull = "";
    static char szNntpVersion[]="NNTP";
    DWORD err;
    IN_ADDR addr;
    FILETIME now;
    ULARGE_INTEGER liStart;
    ULARGE_INTEGER liNow;

    ENTER("TransactionLog")

	//
	// see if we are only logging errors.
	//
	if (m_context.m_pInstance->GetCommandLogMask() & eErrorsOnly) {
		// make sure that this is an error (dwProtocol >= 400 and < 600)
		if (!(NNTPRET_IS_ERROR(dwProtocol))) return TRUE;
	}

    //
    // Fill out client information
    //

	ZeroMemory( &request, sizeof(request));
	
    addr.s_addr = m_remoteIpAddress;
    lstrcpy(theirIP, inet_ntoa( addr ));
    request.pszClientHostName = theirIP;
    request.cbClientHostName = strlen(theirIP);


    //
    // user logged on as?
    //

	if( fInBound ) {
		if( lpUserName = GetUserName() ) {
			request.pszClientUserName = lpUserName;
		} else {
			request.pszClientUserName = "<user>";
		}
	}	else	{
		request.pszClientUserName = "<feed>" ;
	}

    //
    // Who are we ?
    //

    addr.s_addr = m_localIpAddress;
    lstrcpy(ourIP,inet_ntoa( addr ));
    request.pszServerAddress = ourIP;

    //
    // How long were we processing this?
    //

    GetSystemTimeAsFileTime( &now );
    LI_FROM_FILETIME( &liNow, &now );
    LI_FROM_FILETIME( &liStart, &m_startTime );

    //
    // Get the difference of start and now.  This will give
    // us total 100 ns elapsed since the start.  Convert to ms.
    //

    liNow.QuadPart -= liStart.QuadPart;
    liNow.QuadPart /= (ULONGLONG)( 10 * 1000 );
    request.msTimeForProcessing = liNow.LowPart;

    //
    // Bytes sent/received
    //
	//CopyMemory( &request.liBytesSent, &cbBytesSent, sizeof(cbBytesSent) );
	request.dwBytesSent  = (DWORD)(LOW(cbBytesSent));
    request.dwBytesRecvd = cbBytesRecvd ;

    //
    // status
    //

    request.dwWin32Status = dwWin32;
	request.dwProtocolStatus = dwProtocol ;

	if( lpstrOperation ) {
		request.pszOperation = lpstrOperation ;
		request.cbOperation  = strlen(lpstrOperation);
	} else {
		request.pszOperation = lpNull;
		request.cbOperation  = 0;
	}

	if( lpstrTarget ) {
		request.pszTarget = lpstrTarget ;
		request.cbTarget = strlen(lpstrTarget) ;
	} else {
		request.pszTarget = lpNull;
		request.cbTarget  = 0;
	}

	if( lpstrParameters ) {
		request.pszParameters = lpstrParameters ;
	} else {
		request.pszParameters = lpNull;
	}

	request.cbHTTPHeaderSize = 0 ;
	request.pszHTTPHeader = NULL ;

	request.dwPort = m_nntpPort;
    request.pszVersion = szNntpVersion;

    //
    // Do the actual logging
    //

    err = ((m_context.m_pInstance)->m_Logging).LogInformation( &request );

    if ( err != NO_ERROR ) {
        ErrorTrace(0,"Error %d Logging information!\n",GetLastError());
        return(FALSE);
    }

    return(TRUE);

} // TransactionLog
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\state.cpp ===
/*++

	state.cpp

	This file contains all the source code for mosts states that we run in our state
	machines.

	Each state has a number of completion functions (one for each different kind of IO
	operation it may issue) and a Start function.

	The Start function is called when the state is entered in order to get the initial
	IO operation rolling.  After that, the Completion functions are called as each IO
	operation completes.  It is up to the state to handle transitions to other states
	and to know what the next state should be.

--*/



#include	<stdlib.h>
#include	"tigris.hxx"
#include	"commands.h"


const	unsigned	cbMAX_STATE_SIZE = MAX_STATE_SIZE ;

//
//	ALL CSessionState derived objects allocated from this Pool !!!!
//
CPool	CSessionState::gStatePool(SESSION_STATE_SIGNATURE) ;

BOOL
NNTPCreateTempFile(	LPSTR	lpstrDir,	LPSTR	lpstrFile ) {
	//
	//	This is a utility function used whereever we are creating temp files to save
	//	articles into.  if adds a couple more digits of randomness to the file name
	//	then ordinary GetTempFileName seems to provide.
	//
	char	szPrefix[12] ;
	
	wsprintf( szPrefix, "a%02d", GetTickCount() & 0x0000ffff ) ;
	szPrefix[3] = '\0' ;

	return	GetTempFileName( lpstrDir, szPrefix, 0, lpstrFile ) != 0 ;
}

BOOL
FGenerateErrorFile(	NRC	nrcCode ) {

	switch( nrcCode ) {
		case	nrcOpenFile :
		case	nrcPathLoop :
		case	nrcErrorReadingReg :
		case	nrcArticleInitFailed :
		case	nrcHashSetArtNumSetFailed :
		case	nrcHashSetXrefFailed :
		case	nrcArticleXoverTooBig :
		case	nrcCreateNovEntryFailed :
		case	nrcHashSetFailed :
		case	nrcArticleTableCantDel :
		case	nrcArticleTableError :
		case	nrcCantAddToQueue :
		case	nrcNotYetImplemented :
		case	nrcNewsgroupDescriptionTooLong :
		case	nrcGetGroupFailed : 		
			return	TRUE ;
			break ;
	}
	return	FALSE ;
}


void
NNTPProcessTempFile(	BOOL	fGoodPost,	
						LPSTR	lpstrFile,
						LPSTR	lpstrErrorDir,
						NRC		nrcErrorCode,
						LPSTR	lpstrErrorReason,
						HANDLE	hFile,
						char*	pchArticle,
						DWORD	cbArticle
						) {
	//
	//	If the article was succesfully posted, delete the temp file,
	//	otherwise rename it for later examination by testers etc...
	//

	TraceFunctEnter( "NNTPProcessTempFile" ) ;
	
	char	szErrorFile[ 2*MAX_PATH ] ;
	LPSTR	lpstrErrorFile = 0 ;

	if( !fGoodPost ) {

		if( fGenerateErrFiles  && FGenerateErrorFile( nrcErrorCode ) ) {
		
			//
			//	Use our message-id code to generate a unique file name for the .err file !
			//
			char	szUnique[cMaxMessageIDDate] ;	
			ZeroMemory( szUnique, sizeof( szUnique ) ) ;
			GetMessageIDDate( GetCurrentThreadId(), 1, szUnique ) ;
	
			lstrcpy( szErrorFile, lpstrErrorDir ) ;
			char*	pch = lstrlen( szErrorFile ) + szErrorFile ;
			wsprintf( pch, "\\%s.err", szUnique ) ;
			lpstrErrorFile = szErrorFile ;
		}

		if( hFile != INVALID_HANDLE_VALUE ) {

#ifdef	DEBUG
			_ASSERT( ValidateFileBytes( lpstrFile, FALSE ) ) ;
#endif		

			if( !lpstrErrorFile || !MoveFile( lpstrFile, szErrorFile ) ) {

				if( lpstrErrorFile ) {
					DWORD	dw = GetLastError() ;
					ErrorTrace( 0, "Move File of %s to %s failed cause of %d",
							lpstrFile, szErrorFile, dw ) ;
				}
				//
				//	If the move fails or we don't do it try to delete the old file !
				//
				DeleteFile( lpstrFile ) ;

			}	else	{

				//
				//	Log an event about the failed posting !
				//
				char*	pArgs[3] ;
				pArgs[0] = lpstrErrorFile ;
				pArgs[1] = lpstrErrorReason ;
				NntpLogEvent( NNTP_ARTICLE_REJECTED, 2, (const char**)&pArgs[0], 0 ) ;
			}

		}	else	{

			if( lpstrErrorFile ) {
				//
				//	IF the article is not in a file it must be in a buffer !
				//

				_ASSERT( pchArticle != 0 ) ;
				_ASSERT( cbArticle != 0 ) ;

				//
				//	Just in case we get bogus arguments ....
				//

				if( pchArticle != 0 ) {

					//
					//	Put the article into an error file !
					//

					hFile = CreateFile(	lpstrErrorFile,
										GENERIC_READ | GENERIC_WRITE,
										0,
										0,
										CREATE_ALWAYS,
										0,
										INVALID_HANDLE_VALUE
										) ;
					if( hFile != INVALID_HANDLE_VALUE ) {

						DWORD	cbJunk = 0 ;
						BOOL	fWritten = WriteFile(	hFile,
														pchArticle,
														cbArticle,
														&cbJunk,
														0 ) ;

						_VERIFY( CloseHandle( hFile ) );

						if( !fWritten ) {
							DeleteFile( lpstrErrorFile ) ;
						}	else	{
							//
							//	Log an event about the failed posting !
							//
							char*	pArgs[3] ;
							pArgs[0] = lpstrErrorFile ;
							pArgs[1] = lpstrErrorReason ;
							NntpLogEvent( NNTP_ARTICLE_REJECTED, 2, (const char**)&pArgs[0], 0 ) ;
						}

					}	else	{

						ErrorTrace( 0, "CreateFile of %s failed %d",
								szErrorFile, GetLastError() ) ;

					}
				}
			}
		}
	}
}


void
BuildCommandLogString(	int	cArgs, char **pszArgs, char	*szBuff, DWORD	cbBuff ) {

	for( int i=0; i<cArgs && cbBuff != 0;  i++ ) {

		DWORD	cb = lstrlen( pszArgs[i] ) ;
		DWORD	cbToCopy = min( cb, cbBuff-1 ) ;
		
		CopyMemory( szBuff, pszArgs[i], cbToCopy ) ;
		szBuff += cbToCopy ;
		*szBuff++ = ' ' ;
		cbBuff -= cbToCopy + 1 ;
	}
	if ( i != 0 ) szBuff[-1] = '\0' ;
}

void
OutboundLogFill(	CSessionSocket*	pSocket,
					LPBYTE	pb,
					DWORD	cb	
					)	{
/*++

Routine Description :

	Fill the transaction logging buffer in perparation for issuing a commmand !

Arguments :

	pSocket - Socket we are logging !
	pb - The Data to be written !
	cb - Length of Data, including CRLF.

Return Value :

	None

--*/

	//
	//	Exclude the CRLF !
	//
	cb -= 2 ;

	if( ((pSocket->m_context).m_pInstance)->GetCommandLogMask() & eOutPush )	{
		
		//
		//	Find a white space character to separate the command from its arguments !
		//
		_ASSERT( !isspace( pb[0] ) ) ;
		for( DWORD i=0; i<cb; i++ )	{
			if( isspace( pb[i] ) ) {
				pSocket->m_Collector.FillLogData( LOG_OPERATION, pb, i ) ;
				break ;
			}
		}

		if( i==cb ) {
			pSocket->m_Collector.FillLogData( LOG_OPERATION, pb, min( cb, 200 ) ) ;
		}	else	{
			pSocket->m_Collector.FillLogData( LOG_PARAMETERS, pb+i, min( cb-i, 200 ) ) ;	// -2 to exclude CRLF
		}
		ADDI( pSocket->m_Collector.m_cbBytesSent, cb );	
	}
}

void
OutboundLogResults(	CSessionSocket*	pSocket,
				    BOOL			fValidNRC,
				    NRC				nrc,
					int				cArgs,
					char**			pszArgs,
                    NRC             nrcWin32 = (NRC)0
					)	{

	if( ((pSocket->m_context).m_pInstance)->GetCommandLogMask() & eOutPush )	{
		char	szBuff[200] ;
		if( fValidNRC ) {
			_ASSERT( pszArgs != 0 ) ;
			// If args following nrc are missing, use nrc
			if( cArgs > 1 ) {
				cArgs -- ;
				pszArgs++ ;
			}
		}
        if( pszArgs ) {
		    BuildCommandLogString( cArgs, pszArgs, szBuff, sizeof( szBuff ) ) ;
		    pSocket->m_Collector.ReferenceLogData( LOG_TARGET, (LPBYTE)szBuff ) ;
        }
		pSocket->TransactionLog( &pSocket->m_Collector, nrc, nrcWin32, FALSE ) ;
	}
}

void
OutboundLogAll(	CSessionSocket*	pSocket,
				    BOOL			fValidNRC,
				    NRC				nrc,
					int				cArgs,
					char**			pszArgs,
					char*			lpstrCommand
					)	{

	if( ((pSocket->m_context).m_pInstance)->GetCommandLogMask() & eOutPush )	{

		pSocket->m_Collector.ReferenceLogData( LOG_OPERATION, (LPBYTE)lpstrCommand ) ;

		char	szBuff[200] ;
		szBuff[0] = '\0' ;
		if( fValidNRC ) {
			_ASSERT( cArgs >1 ) ;
			_ASSERT( pszArgs != 0 ) ;
			cArgs -- ;
			pszArgs++ ;
		}
		BuildCommandLogString( cArgs, pszArgs, szBuff, sizeof( szBuff ) ) ;
		pSocket->m_Collector.ReferenceLogData( LOG_TARGET, (LPBYTE)szBuff ) ;
		pSocket->TransactionLog( &pSocket->m_Collector, nrc, 0, FALSE ) ;
	}
}

static
BOOL
DeleteArticleById(CNewsTreeCore* pTree, GROUPID groupId, ARTICLEID articleId) {

    TraceQuietEnter("DeleteArticleById");

    CNntpSyncComplete scComplete;
    CNNTPVRoot* pVRoot = NULL;
    INNTPPropertyBag *pPropBag = NULL;
    BOOL fOK = FALSE;
    HRESULT hr;

    if (pTree == NULL || groupId == INVALID_GROUPID || articleId == INVALID_ARTICLEID) {
        ErrorTrace(0, "Invalid arguments");
        return FALSE;
    }

    CGRPCOREPTR pGroup = pTree->GetGroupById(groupId);
    if (pGroup == NULL) {
        ErrorTrace(0, "Could not GetGroupById");
        goto Exit;
    }

    pVRoot = pGroup->GetVRoot();
    if ( pVRoot == NULL ) {
        ErrorTrace( 0, "Vroot doesn't exist" );
        goto Exit;
    }

    //
    // Set vroot to completion object
    //
    scComplete.SetVRoot( pVRoot );

    // Get the property bag
    pPropBag = pGroup->GetPropertyBag();
    if ( NULL == pPropBag ) {
        ErrorTrace( 0, "Get group property bag failed" );
        goto Exit;
    }

    pVRoot->DeleteArticle(
	    pPropBag,           // Group property bag
	    1,                  // Number of articles
	    &articleId,
	    NULL,               // Store ID
	    NULL,               // Client Token
	    NULL,               // piFailed
	    &scComplete,
	    FALSE);             // anonymous

    // Wait for it to complete
    _ASSERT( scComplete.IsGood() );
    hr = scComplete.WaitForCompletion();

    // Property bag should have already been released
    pPropBag = NULL;

    if (SUCCEEDED(hr)) {
        fOK = TRUE;
    }

Exit:
    if (pVRoot) {
        pVRoot->Release();
    }
    if (pPropBag) {
        pPropBag->Release();
    }

    return fOK;

}

BOOL
CSessionState::InitClass()	{

	return	gStatePool.ReserveMemory( MAX_STATES, max( cbMAX_STATE_SIZE, cbMAX_CIOEXECUTE_SIZE ) ) ; 	

}

BOOL
CSessionState::TermClass()	{

	TraceFunctEnter( "CSessionState::TermClass()" ) ;
	DebugTrace( 0, "CSessionState - GetAllocCount %d", gStatePool.GetAllocCount() ) ;

	_ASSERT( gStatePool.GetAllocCount() == 0 ) ;
	return	gStatePool.ReleaseMemory() ;

}


CSessionState::~CSessionState()	{
	TraceFunctEnter( "CSessionState::~CSessionState" ) ;
	DebugTrace( (DWORD_PTR)this, "destroying myself" ) ;
}

CIO*	
CSessionState::Complete(	CIOReadLine*,		// The CIOReadLine object which completed
							CSessionSocket*,	// The socket on which the operation completed
							CDRIVERPTR&,		// The CIODriver object on which the operation completed
							int,				// The number of arguments on the line
							char **,			// Array of pointers to NULL separated arguments
							char* )	{			// Pointer to the beginning of the buffer we can use

	//
	//	ReadLine completion function.
	//
	//  Every state which issues a CIOReadLine operation will have a function
	//	identical to this one.
	//
	//	Every Completion function will have similar first 3 arguments -
	//	These are - The CIO derived object which completed its operation
	//	The Socket associated with the operation.
	//	The CIOdriver derived object through which all the IO happened.
	//	(Every Socket has a CIODriver, sometimes there are more then one CIODriver
	//	objects such as in states where we are copying from a socket to a file.)
	//	
	//	The completion functiosn in the base CIO function MUST BE OVERRIDDEN
	//	by any state which issues an IO of that type !!
	//
	//	With one exception all such Completion functions return a new CIO object
	//	which is to take the place of the just completed CIO object.
	//


	_ASSERT( 1==0 ) ;
	return	0 ;
}

CIO*
CSessionState::Complete(	CIOWriteLine*,	
							CSessionSocket*,	
							CDRIVERPTR& )	{

	//
	//	Completion function for writing a line of text.
	//	Nobody cares too much what was sent, just that it completed !
	//
	
	_ASSERT( 1==0 ) ;
	return	0 ;
}

CIO*
CSessionState::Complete(	CIOWriteCMD*,
							CSessionSocket*,
							CDRIVERPTR&,
							class	CExecute*,
							class	CLogCollector* ) {

	_ASSERT( 1==0 ) ;
	return	0 ;
}

CIO*
CSessionState::Complete(	CIOWriteAsyncCMD*,
							CSessionSocket*,
							CDRIVERPTR&,
							class	CAsyncExecute*,
							class	CLogCollector*
							)	{
	_ASSERT( 1==0 ) ;
	return	0 ;
}

void
CSessionState::Complete(	CIOReadArticle*,	
							CSessionSocket*,
							CDRIVERPTR&,	
							CFileChannel&,
							DWORD	)	{
	//
	//	Completion function for CIOReadArticle objects
	//	CIOReadArticle objects copy an entire file from a socket into a file handle.
	//
	//	THIS function does not return a new CIO object as we are called when the
	//	final WRITE to the file completes, instead of when the last socket read occurs.
	//	
	//
	_ASSERT( 1==0 ) ;
}

CIO*
CSessionState::Complete(	CIOTransmit*,	
							CSessionSocket *,
							CDRIVERPTR&,
							TRANSMIT_FILE_BUFFERS*,
							unsigned ) {
	//
	//	Completion function for CIOTransmit - which sends an entire file to a client.
	//
	_ASSERT( 1==0 ) ;
	return 0 ;
}

void
CSessionState::Complete(	CIOGetArticle*,
							CSessionSocket*,
							NRC	code,
							char*	header,
							DWORD	cbHeader,
							DWORD	cbArticle,
							DWORD	cbTotalBuffer,
							HANDLE	hFile,
							DWORD	cbGap,
							DWORD	cbTotalTransfer )	{

	_ASSERT( 1==0 ) ;
}

CIO*
CSessionState::Complete(	CIOGetArticleEx*,
							CSessionSocket*
							)	{
	_ASSERT( 1==0 ) ;
	return	0 ;
}

void
CSessionState::Complete(	CIOGetArticleEx*,
							CSessionSocket*,
							FIO_CONTEXT*	pFIOContext,
							DWORD	cbTransfer
							)	{
	_ASSERT( 1==0 ) ;
}


CIO*
CSessionState::Complete(	CIOGetArticleEx*,
							CSessionSocket*,
							BOOL		fGoodMatch,
							CBUFPTR&	pBuffer,
							DWORD		ibStart,
							DWORD		cb
							)	{
	_ASSERT( 1==0 ) ;
	return	0 ;
}






CIO*
CSessionState::Complete(	CIOMLWrite*,
							CSessionSocket*,
							CDRIVERPTR&	
							)	{

	_ASSERT( 1==0 ) ;
	return	0 ;
}

void
CSessionState::Shutdown(	CIODriver&	driver,	
							CSessionSocket*	pSocket,	
							SHUTDOWN_CAUSE	cause,
							DWORD		dwError ) {

	//
	//	States which have stuff that needs to be killed when a session dies
	//	should do so now.  It is important to kill anything which may
	//	have a circular reference to something or other.
	//
	//	This function can be called simultaneously as the completion functions
	//	so it is best not to zap member variables unless the state is designed
	//	explicitly to support that.  Instead start closing all objects.
	//	(ie. if you have a CIODriver call its UnsafeClose() method.
	//
}
	

CNNTPLogonToRemote::CNNTPLogonToRemote(	CSessionState*	pNext,
										class CAuthenticator* pAuthenticator ) :
	m_pNext( pNext ),
	m_pAuthenticator( pAuthenticator ),
	m_fComplete( FALSE ),
	m_fLoggedOn( FALSE ),
	m_cReadCompletes( 0 )	{
	
	//
	//	This state handles all logon stuff required to connect to a remote server
	//	Currently the only thing we hold is a pointer to the next state to execute.
	//

	TraceFunctEnter( "CNNTPLogonToRemote::CNNTPLogonToRemote" ) ;
	DebugTrace( (DWORD_PTR)this, "new CNNTPLogoToRemote" ) ;

	_ASSERT( m_pNext != 0 ) ;
}

CNNTPLogonToRemote::~CNNTPLogonToRemote()	{
	//
	//	Blow away the subsequent state - if we had wanted to transition to that
	//	state the m_pNext pointer would be NULL when we reached here.
	//

	TraceFunctEnter(	"CNNTPLogonToRemote::~CNNTPLogonToRemote" ) ;

	DebugTrace( (DWORD_PTR)this, "destroying CNNTPLogonToRemote object - m_pNext %x", m_pNext ) ;

	if( m_pAuthenticator ) {
		delete	m_pAuthenticator ;
	}
}

BOOL
CNNTPLogonToRemote::Start(	CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver,
							CIORead*&	pIORead,	
							CIOWrite*&	pIOWrite )	{

	//
	//	Create the initial CIO objects for the new connection.
	//	In our case, we want to read the remote servers welcome message first thing.
	//

	_ASSERT( pIORead == 0 ) ;
	_ASSERT( pIOWrite == 0 ) ;
	pIORead = 0 ;
	pIOWrite = 0 ;

	CIOReadLine*	pIOReadLine = new( *pdriver ) CIOReadLine( this ) ;

	if( pIOReadLine )	{
		pIORead = pIOReadLine ;
		return	TRUE ;
	}
	return	FALSE ;
}

CIO*
CNNTPLogonToRemote::FirstReadComplete(	CIOReadLine*	pReadLine,	
								CSessionSocket*	pSocket,	
								CDRIVERPTR&	pdriver,
								int	cArgs,	
								char	**pszArgs,	
								char	*pchBegin ) {

	//
	//	For now, only check that we got an OK message from the remote server,
	//	if we did, then start up the next state.
	//
	//

	_ASSERT( cArgs > 0 ) ;
	_ASSERT( pszArgs != 0 ) ;
	_ASSERT( pReadLine != 0 ) ;
	_ASSERT( pSocket != 0 ) ;

	CIORead*	pRead = 0 ;
	NRC			code ;

	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;
	DWORD			dwOptional = 0 ;

	if( ResultCode( pszArgs[0], code ) )
		if(	code == nrcServerReady || code == nrcServerReadyNoPosts )	{
			_ASSERT( m_pNext != 0 ) ;

			if( m_pAuthenticator == 0 ) {

				//
				//	If we aren't going to log on we can advance to the next state !
				//


				CIOWrite*	pWrite = 0 ;
				if( m_pNext->Start( pSocket,  pdriver,	pRead, pWrite ) ) {
					if( pWrite )	{
						if( !pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) )	{
							pWrite->DestroySelf() ;
							if( pRead != 0 ) {
								pRead->DestroySelf() ;
								pRead = 0 ;
							}
						}
					}	
					m_pNext = 0 ;	// Do this so destructor does not blow away next state !
					return	pRead ;
				}
				// If the function fails it should not return stuff !!
				_ASSERT( pWrite == 0 ) ;
				_ASSERT( pRead == 0 ) ;

			}	else	{

				return	StartAuthentication(	pSocket,	pdriver ) ;
			
			}
		}	else	{
			cause = CAUSE_PROTOCOL_ERROR ;
			dwOptional = (DWORD)code ;
	}	else	{
		cause = CAUSE_ILLEGALINPUT ;
	}

	PCHAR	args[2] ;
	args[0] = pSocket->GetRemoteNameString() ;
	args[1] = pSocket->GetRemoteTypeString();

	NntpLogEventEx(
			NNTP_CONNECTION_PROTOCOL_ERROR,
			2,
			(const char **)args,
			GetLastError(),
			((pSocket->m_context).m_pInstance)->QueryInstanceId()
			) ;

	pdriver->UnsafeClose( pSocket, cause, dwOptional ) ;
	_ASSERT( pRead == 0 ) ;
	return	0 ;
}

class	CIO*
CNNTPLogonToRemote::StartAuthentication(	CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver ) {

	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;
	DWORD			dwOptional = 0 ;

	//
	//	We need to advance start our logon protocol before advancing to the
	//	next state !
	//

	//
	//	Allocate a CIOWriteLine object so we can get the initial send to the
	//	remote server going !
	//
	CIOWriteLine*	pWriteLine = new( *pdriver ) CIOWriteLine( this ) ;
	if( pWriteLine && pWriteLine->InitBuffers( pdriver ) ) {
		
		unsigned	cbOut = 0 ;
		unsigned	cb = 0 ;
		BYTE*	pb = (BYTE*)pWriteLine->GetBuff( cb ) ;

		if( m_pAuthenticator->StartAuthentication( pb, cb, cbOut ) ) {
			
			_ASSERT( cbOut != 0 ) ;

			pWriteLine->AddText( cbOut ) ;

			if( pdriver->SendWriteIO( pSocket, *pWriteLine, TRUE ) )	{
				return	0 ;
			}
		}
	}	

	PCHAR	args[2] ;
	args[0] = pSocket->GetRemoteNameString() ;
	args[1] = pSocket->GetRemoteTypeString() ;

	NntpLogEventEx(	
			NNTP_INTERNAL_LOGON_FAILURE,
			2,
			(const char **)args,
			GetLastError(),
			((pSocket->m_context).m_pInstance)->QueryInstanceId()
			) ;

	if( pWriteLine != 0 )
		CIO::Destroy( pWriteLine, *pdriver ) ;
	cause = CAUSE_OOM ;
	dwOptional = 0 ;
	//
	//	exit here so we don't log an extra event !
	//
	pdriver->UnsafeClose( pSocket, cause, dwOptional ) ;
	return	0 ;
}


CIO*
CNNTPLogonToRemote::Complete(	CIOReadLine*	pReadLine,	
								CSessionSocket*	pSocket,	
								CDRIVERPTR&	pdriver,
								int	cArgs,	
								char	**pszArgs,	
								char	*pchBegin ) {

	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;
	DWORD			dwOptional = 0 ;

	m_cReadCompletes ++ ;
	if( m_cReadCompletes == 1 ) {
	
		return	FirstReadComplete(	pReadLine,	
									pSocket,
									pdriver,
									cArgs,
									pszArgs,
									pchBegin ) ;

	}	else	{

		//
		//	subsequent read completiongs are always the result of an attempt
		//	to logon to the remote server - and need to be processed !!
		//

		_ASSERT( m_pAuthenticator != 0 ) ;

		if( m_pAuthenticator != 0 ) {
			
			CIOWriteLine*	pWriteLine = new( *pdriver )	CIOWriteLine( this ) ;
			if( pWriteLine && pWriteLine->InitBuffers( pdriver ) ) {
				
				unsigned	cbOut = 0 ;
				unsigned	cb = 0 ;
				BYTE*	pb = (BYTE*)pWriteLine->GetBuff( cb ) ;

				//
				//	Make sure the arguemnts are nicely formatted MULTI SZ's
				//

				LPSTR	lpstr = ConditionArgs( cArgs, pszArgs ) ;
				if( m_pAuthenticator->NextAuthentication( lpstr, pb, cb, cbOut, m_fComplete, m_fLoggedOn ) ) {
					
					if( m_fComplete ) {
						
						// In this case we dont need to send another string !
						CIO::Destroy( pWriteLine, *pdriver ) ;
						pWriteLine = 0 ;

						if( m_fLoggedOn ) {

							// We can now advance to the next state !!
							_ASSERT( m_pNext != 0 ) ;

							CIORead*	pRead = 0 ;
							CIOWrite*	pWrite = 0 ;
							if( m_pNext->Start( pSocket,  pdriver,	pRead, pWrite ) ) {
								if( pWrite )	{
									if( !pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) )	{
										pWrite->DestroySelf() ;
										if( pRead != 0 ) {
											pRead->DestroySelf() ;
											pRead = 0 ;
										}
									}
								}	
								m_pNext = 0 ;	// Do this so destructor does not blow away next state !
								return	pRead ;
							}
							// If the function fails it should not return stuff !!
							_ASSERT( pWrite == 0 ) ;
							_ASSERT( pRead == 0 ) ;

						}	else	{
							PCHAR	args[2] ;
							args[0] = pSocket->GetRemoteNameString() ;
							args[1] = pSocket->GetRemoteTypeString() ;

							NntpLogEventEx(
									NNTP_FAILED_TO_LOGON,
									2,
									(const char **)args,
									GetLastError(),
									((pSocket->m_context).m_pInstance)->QueryInstanceId()
									) ;
							cause = CAUSE_LOGON_ERROR ;
						}

					}	else	{
						_ASSERT( cbOut != 0 ) ;
						pWriteLine->AddText( cbOut ) ;
						if( pdriver->SendWriteIO( pSocket, *pWriteLine, TRUE ) )	{
							return	0 ;
						}
					}
				}	
			}
			if( pWriteLine != 0 )
				CIO::Destroy( pWriteLine, *pdriver ) ;
		}
	}
	//
	//	In case of error we will fall through to here !!
	//
	pdriver->UnsafeClose( pSocket, cause, GetLastError() ) ;
	return	0 ;
}


CIO*
CNNTPLogonToRemote::Complete(	CIOWriteLine*	pWriteLine,
								CSessionSocket*	pSocket,
								CDRIVERPTR&		pdriver ) {

	//
	//	If we issued a write in this state then we must have a
	//	logon transaction going - the write completed so issue another read !
	//

	CIOReadLine*	pIOReadLine = new( *pdriver ) CIOReadLine( this ) ;

	if( pIOReadLine )	{
		if( pdriver->SendReadIO( pSocket, *pIOReadLine, TRUE ) ) {
			return	0 ;
		}	else	{
			CIO::Destroy( pIOReadLine, *pdriver ) ;
		}
	}

	pdriver->UnsafeClose(	pSocket,	CAUSE_OOM, 0 ) ;
	return	 0 ;
}

CSetupPullFeed::CSetupPullFeed(
	CSessionState*	pNext
	)	:
	m_pNext( pNext ),
	m_state( eModeReader )	{

	_ASSERT( m_pNext != 0 ) ;

}

CIOWriteLine*
CSetupPullFeed::BuildNextWrite(
		CSessionSocket*	pSocket,
		CDRIVERPTR&		pdriver
		)	{


	char*	szCommand = 0 ;

	switch( m_state ) {
	case	eModeReader :
		szCommand = "mode reader\r\n" ;
		break ;
	case	eDate :
		szCommand = "date\r\n" ;
		break ;
	default :
		_ASSERT( 1==0 ) ;
		return 0;
	}

	_ASSERT( szCommand != 0 ) ;

	DWORD	cb = lstrlen( szCommand ) ;

	OutboundLogFill( pSocket, (LPBYTE)szCommand, cb ) ;

	CIOWriteLine*		pIOWriteLine = new( *pdriver ) CIOWriteLine( this ) ;
	if( pIOWriteLine )	{
		
		if( pIOWriteLine->InitBuffers( pdriver, cb ) ) {
			CopyMemory( pIOWriteLine->GetBuff(), szCommand, cb ) ;
			pIOWriteLine->AddText(	cb ) ;
			return	pIOWriteLine ;
		}
	}
	return	0 ;
}


BOOL
CSetupPullFeed::Start(	CSessionSocket*	pSocket,	
						CDRIVERPTR&	pdriver,	
						CIORead*&	pRead,	
						CIOWrite*&	pWrite ) {

	pRead = 0 ;
	pWrite = 0 ;

	pWrite = BuildNextWrite( pSocket, pdriver ) ;

	return	pWrite != 0 ;
}



CIO*
CSetupPullFeed::Complete(	class	CIOWriteLine*	pWriteLine,
							class	CSessionSocket*	pSocket,
							CDRIVERPTR&	pdriver
					)	{
/*++

Routine Description :

	Complete the processing of a write - we just need to turn over
	a new read as all the work is done on the read completions !

Arguments :

	Standard for a CIOWriteLine completion

Return Value :

	NULL Always !

--*/

	CIOReadLine*	pReadLine = new( *pdriver ) CIOReadLine( this ) ;
	if( pReadLine )		{
		if( pdriver->SendReadIO( pSocket, *pReadLine, TRUE ) ) {
			return	0 ;
		}	else	{
			CIO::Destroy( pReadLine, *pdriver ) ;
		}
	}	

	pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0, TRUE ) ;
	return	0 ;
}


CIO*
CSetupPullFeed::Complete(	CIOReadLine*	pReadLine,	
							CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver,
							int	cArgs,	
							char	**pszArgs,	
							char*	pchBegin
							) {

	NRC	code ;
	BOOL	fLegal = ResultCode( pszArgs[0], code ) ;

	OutboundLogResults(	pSocket,
						fLegal,
						code,
						cArgs,
						pszArgs
						) ;

	if( fLegal ) {

		CIORead*	pRead = 0 ;
		CIOWrite*	pWrite = 0 ;

		switch( m_state ) {
		case	eModeReader :

			//
			//	Don't really care what happened - keep on moving !
			//

			m_state = eDate ;

			break ;
		case	eDate :

			//
			//	Got the date from the remote end - save for later use !
			//

			if( code == nrcDateFollows ) {

				SYSTEMTIME  systime ;
				int cScanned = 0 ;
				if( cArgs >= 2 && lstrlen( pszArgs[1] ) == 14) {
					cScanned = sscanf( pszArgs[1], "%4hd%2hd%2hd%2hd%2hd%2hd",
											&systime.wYear,
											&systime.wMonth,
											&systime.wDay,
											&systime.wHour,
											&systime.wMinute,
											&systime.wSecond
											) ;
				}

				FILETIME    localtime ;
				if( cScanned != 6 ||
					!SystemTimeToFileTime( &systime, &localtime)
					)  {

					GetSystemTimeAsFileTime( &localtime );

				}
				_ASSERT( pSocket->m_context.m_pInFeed != 0 ) ;
				pSocket->m_context.m_pInFeed->SubmitFileTime( localtime ) ;

			}	else	{
				fLegal = FALSE ;
			}

			m_state = eFinal ;

			break ;

		case	eFinal :
		default :
			_ASSERT( 1==0 ) ;
			break ;
		}
		
		//
		//	Get the next write to issue !
		//
		if( m_state != eFinal ) {
			pWrite	= BuildNextWrite(	pSocket, pdriver ) ;
			if( pWrite ) {
				if( !pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) ) {
					pWrite->DestroySelf() ;
				}	else	{
					return	0 ;
				}
			}
		}	else	{

			//
			//	Need to advance to the next state !!
			//

			if( m_pNext->Start( pSocket, pdriver, pRead, pWrite ) ) {
				if( pWrite )	{
					if( !pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) )	{
						pWrite->DestroySelf() ;
						if( pRead != 0 ) {
							pRead->DestroySelf() ;
							pRead = 0 ;
						}
						pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
						return 0 ;
					}
				}
				m_pNext = 0 ;	// Do this so our destructor doesn't blow him away !!
				return	pRead;
			}	
		}
	}

	//
	//	If we fall through to here an error occurred - drop the session !
	//
	pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
	return	0 ;
}

	

CCollectGroups::CCollectGroups(	CSessionState*	pNext )	:	
	m_pNext( pNext ),
	m_fReturnCode( TRUE ),
	m_cCompletions( 0 )	{

	//
	//	CCollectGroups initializer - record what the next state should be !
	//

	_ASSERT( pNext != 0 ) ;

	TraceFunctEnter( "CCollectGroups::CCollectGroups" ) ;
	DebugTrace( (DWORD_PTR)this, "New CCollectGroups" ) ;

}

CCollectGroups::~CCollectGroups() {
}

BOOL
CCollectGroups::Start(	CSessionSocket*	pSocket,	
						CDRIVERPTR&	pdriver,	
						CIORead*&	pRead,	
						CIOWrite*&	pWrite ) {

	//	
	//	We want to build up our list of newsgroups -
	//	send a command to the remote server to list all newsgroups !
	//	Then issue a CIOReadLine to get the response !
	//

	_ASSERT(	pSocket != 0 ) ;
	_ASSERT(	pdriver != 0 ) ;
	_ASSERT(	pRead == 0 ) ;
	_ASSERT(	pWrite == 0 ) ;
	_ASSERT(	m_fReturnCode ) ;
	_ASSERT(	m_pNext != 0 ) ;

	pRead = 0 ;
	pWrite = 0 ;

	CIOReadLine*	pIOReadLine = new( *pdriver ) CIOReadLine( this ) ;
	CIOWriteLine*		pIOWriteLine = new( *pdriver ) CIOWriteLine( this ) ;

	if( pIOReadLine && pIOWriteLine )	{
		static	char	szListString[] = "list\r\n" ;
		if( pIOWriteLine->InitBuffers( pdriver, sizeof( szListString)  ) ) {
			CopyMemory( pIOWriteLine->GetBuff(), szListString, sizeof( szListString ) ) ;
			pIOWriteLine->AddText(	sizeof( szListString )-1 ) ;
			pWrite = pIOWriteLine ;
			pRead = pIOReadLine ;
			m_cCompletions = -2 ;

			OutboundLogFill( pSocket, (LPBYTE)szListString, sizeof( szListString ) -1 ) ;

			return	TRUE ;
		}
	}	

	_ASSERT( 1==0 ) ;

	if( pIOReadLine )
		CIO::Destroy( pIOReadLine, *pdriver ) ;

	if( pIOWriteLine )
		CIO::Destroy( pIOWriteLine, *pdriver ) ;	
	
	// Start functions down do much error handling - other than to report the problem!
	return	FALSE ;
}

CIO*
CCollectGroups::Complete(	CIOWriteLine*	pWrite,	
							CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver )	{
	//
	//	We don't care how how our WriteLine completes !
	//
	//

	if( InterlockedIncrement( &m_cCompletions ) == 0 ) {
		CIORead*	pRead = 0 ;
		CIOWrite*	pWrite = 0 ;
		if( m_pNext->Start( pSocket, pdriver, pRead, pWrite ) ) {
			if( pRead )	{
				if( !pdriver->SendReadIO( pSocket, *pRead, TRUE ) )	{
					pRead->DestroySelf() ;
					if( pWrite != 0 ) {
						pWrite->DestroySelf() ;
						pWrite = 0 ;
					}
					pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
					return 0 ;
				}
			}
			m_pNext = 0 ;	// Do this so our destructor doesn't blow him away !!
			return	pWrite;
		}
	}	

	_ASSERT( pWrite != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	return	0 ;
}

CIO*
CCollectGroups::Complete(	CIOReadLine*	pReadLine,	
							CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver,
							int	cArgs,	
							char	**pszArgs,	
							char*	pchBegin ) {

	//
	//	The first readline we complete is the response to the command we issued.
	//	Subsequent readline's are the newsgroups we are being sent.
	//	If the first succeeds the rest will follow !!!
	//

	TraceFunctEnter( "CCollectGroups::Complete" ) ;

	_ASSERT( m_pNext != 0 ) ;
	_ASSERT( pReadLine != 0 ) ;
	_ASSERT(	pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	_ASSERT( cArgs != 0 ) ;
	_ASSERT( pszArgs != 0 ) ;
	_ASSERT( pszArgs[0] != 0 ) ;
	_ASSERT( pchBegin != 0 ) ;
	_ASSERT( pszArgs[0] >= pchBegin ) ;

	SHUTDOWN_CAUSE cause	= CAUSE_UNKNOWN ;
	DWORD	dwOptional = 0 ;

	if( m_fReturnCode )		{
		m_fReturnCode = FALSE ;
		NRC	code ;
		BOOL	fLegal = ResultCode( pszArgs[0], code ) ;

		OutboundLogResults(	pSocket,
							fLegal,
							code,
							cArgs,
							pszArgs
							) ;

		if( fLegal && code == nrcListGroupsFollows )	{
			//	Keep Reading Lines !!!
			return	pReadLine ;
		}	else	if( fLegal )	{
			//
			//	Command Failed !! - Bail Out
			//
			cause = CAUSE_PROTOCOL_ERROR ;
			dwOptional = (DWORD)code ;			
			//_ASSERT( 1==0 ) ;
		}	else	{
			cause = CAUSE_ILLEGALINPUT ;
			//
			//	Got JUNK  - Bail Out !
			//
			//_ASSERT(	1==0 ) ;
		}
	}	else	{
		if(	pszArgs[0][0] == '.' && pszArgs[0][1] == '\0' && cArgs == 1 )	{
			//
			//	Terminator - Move onto the next state !!
			//

			DebugTrace( (DWORD_PTR)this, "state complete - starting next one which is %x", m_pNext ) ;

			if( InterlockedIncrement( &m_cCompletions ) == 0 ) {
				CIORead*	pRead = 0 ;
				CIOWrite*	pWrite = 0 ;
				if( m_pNext->Start( pSocket, pdriver, pRead, pWrite ) ) {
					if( pWrite )	{
						if( !pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) )	{
							pWrite->DestroySelf() ;
							if( pRead != 0 ) {
								pRead->DestroySelf() ;
								pRead = 0 ;
							}
							pdriver->UnsafeClose( pSocket, cause, dwOptional ) ;
							return 0 ;
						}
					}
					m_pNext = 0 ;	// Do this so our destructor doesn't blow him away !!
					return	pRead ;
				}
				// if m_pNext->Start fails - these had better be NULL !!
				_ASSERT( pRead == 0 ) ;
				_ASSERT( pWrite == 0 ) ;

			}	else	{
				return	0 ;
			}
	
			// Don't know why we failed - try for error code
			dwOptional = GetLastError() ;

		}	else	{
			//
			//	Should have valid newsgroups here !
			//
			if( cArgs != 4 )	{
				// Illegally formatted line !
				// _ASSERT( 1==0 ) ;	
				cause = CAUSE_ILLEGALINPUT ;
			}	else	{

				DebugTrace( (DWORD_PTR)this, "Creating Group %s", pszArgs[0] ) ;

				LPMULTISZ	multisz = pSocket->m_context.m_pInFeed->multiszNewnewsPattern() ;
				CNewsTree* pTree = ((pSocket->m_context).m_pInstance)->GetTree() ;

				if( MatchGroup( multisz, pszArgs[0] ) ) {
					//_strlwr( pszArgs[0] ) ;
    				if( pTree->CreateGroup( pszArgs[0], FALSE, NULL, FALSE ) )	{
#if 0
						CGRPPTR p = pTree->GetGroup( pszArgs[0], lstrlen( pszArgs[0] ) + 1 );
						_ASSERT(p != NULL);
#endif

		    		}
				}

				if( pTree->m_bStoppingTree ) {
					// Instance is stopping - bail early
					cause = CAUSE_FORCEOFF ;
					pdriver->UnsafeClose( pSocket, cause, dwOptional );
					return 0 ;
				}
				
			    return	pReadLine ;
			}
		}
	}
	pdriver->UnsafeClose( pSocket, cause, dwOptional ) ;
	return	0 ;
}


CCollectNewnews::CCollectNewnews() :
	m_cCompletes( -2 )
#if 0
	,m_cCommandCompletes( -2 )
#endif
	{

	//
	//	We try to initialize some stuff here - everything we will be
	//	checked for legality in our Start() code !
	//

	TraceFunctEnter( "CCollectNewnews::CCollectNewnews" ) ;
	DebugTrace( (DWORD_PTR)this, "New CCollectNewnews" ) ;
}

CCollectNewnews::~CCollectNewnews()		{
	m_pSessionDriver = 0 ;
	if( m_pFileChannel != 0 )
		m_pFileChannel->CloseSource( 0 ) ;
}

void
CCollectNewnews::Shutdown(	CIODriver&	driver,
							CSessionSocket*	pSocket,
							SHUTDOWN_CAUSE	cause,
							DWORD			dwError ) {

	TraceFunctEnter( "CCollectNewnews::Shutdown" ) ;

	if( cause != CAUSE_NORMAL_CIO_TERMINATION && m_pFileChannel != 0 ) {
		m_pFileChannel->CloseSource( pSocket ) ;
		m_pFileChannel = 0 ;
		pSocket->Disconnect(	cause,	dwError ) ;
	}
}

BOOL
CCollectNewnews::Start(	CSessionSocket*	pSocket,	
						CDRIVERPTR&	pdriver,
						CIORead*&	pIORead,	
						CIOWrite*&	pIOWrite	)	{

	//
	//	Issue the newnews command to the remote server !
	//

	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	_ASSERT( pIORead == 0 ) ;
	_ASSERT( pIOWrite == 0 ) ;
	pIORead = 0 ;
	pIOWrite = 0 ;

	//
	//	The first things we want to issue are a Write which
	//	sends the newnews command to the remote server
	//	and a read which gets the response.
	//

	CIOWriteLine*	pIOWriteLine = new( *pdriver )	CIOWriteLine(	this ) ;
	CIOReadLine*	pIOReadLine = new( *pdriver ) CIOReadLine( this ) ;	

	m_pSessionDriver = pdriver ;

	if( pIOWriteLine && pIOReadLine )	{
		if( pIOWriteLine->InitBuffers( pdriver, 100 ) )	{

			CFromPeerFeed*	pFromPeer = (CFromPeerFeed*)pSocket->m_context.m_pInFeed ;
			LPSTR	lpstr	=	pFromPeer->GetCurrentGroupString() ;
			_ASSERT( lpstr != 0 ) ;
			_ASSERT( *lpstr != '\0' ) ;
			_ASSERT( *lpstr != '!' ) ;	

			LPSTR	lpstrBuff = pIOWriteLine->GetBuff() ;
            DWORD	cb = wsprintf(
							lpstrBuff,
							"newnews %s %s %s GMT\r\n",
							 lpstr,
							 pSocket->m_context.m_pInFeed->newNewsDate(),
							 pSocket->m_context.m_pInFeed->newNewsTime()
							 ) ;


			pIOWriteLine->AddText( cb ) ;

			OutboundLogFill( pSocket, (LPBYTE)lpstrBuff, cb ) ;

			char	szTempFile[ MAX_PATH ] ;
			unsigned	id = GetTempFileName( pSocket->m_context.m_pInFeed->szTempDirectory(), "new", 0, szTempFile ) ;
			HANDLE	hTempFile = CreateFile(	szTempFile,
										GENERIC_READ | GENERIC_WRITE,
										FILE_SHARE_READ,
										0,
										CREATE_ALWAYS,
										FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE,
										INVALID_HANDLE_VALUE
										) ;
			DWORD dw = GetLastError() ;
			if( hTempFile != INVALID_HANDLE_VALUE )	{

				//
				//	Now make an FIO_CONTEXT to deal with this file !
				//
				FIO_CONTEXT*	pFIOContext = AssociateFile( hTempFile ) ;
				if( pFIOContext ) 	{
					m_pFileChannel = new CFileChannel( ) ;
					if( m_pFileChannel->Init( pFIOContext, pSocket,	0,	FALSE ) )	{
						ReleaseContext( pFIOContext ) ;
						pIORead = pIOReadLine ;
						pIOWrite = pIOWriteLine ;
						return	TRUE ;
					}
					//
					//	In case of an error we fall through to here where we
					//	do our cleanup !
					//
					ReleaseContext( pFIOContext ) ;
				}
				//
				//	This dumps the handle in case of an error !
				//
				_VERIFY( CloseHandle( hTempFile ) ) ;
			}
		}
	}	
	//
	//	Some sort of failure occurred - clean up and return FALSE.
	//
	if( pIOWriteLine )	
		CIO::Destroy( pIOWriteLine, *pdriver ) ;
	if( pIOReadLine )
		CIO::Destroy( pIOReadLine, *pdriver ) ;
	pIOWrite = 0 ;
	pIORead = 0 ;
	if( m_pFileChannel != 0 ) {
		m_pFileChannel = 0 ;
	}
	
	pIOWrite = 0 ;
	pIORead = 0 ;
	return	FALSE ;
}

CIO*
CCollectNewnews::Complete(	CIOReadLine*	pReadLine,	
							CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver,	
							int	cArgs,	
							char	**pszArgs,
							char*	pchBegin )		{

	//
	//	We examine the reply to our newnews command - if things look good
	//	we issue a CIOReadArticle operation to get the list of message-ids into a file !
	//

	_ASSERT( pdriver == m_pSessionDriver ) ;
	_ASSERT(	pReadLine != 0 ) ;
	_ASSERT(	pSocket != 0 ) ;
	_ASSERT(	pdriver != 0 ) ;
	_ASSERT(	cArgs != 0 ) ;
	_ASSERT(	pszArgs != 0 ) ;
	_ASSERT(	pszArgs[0] != 0 ) ;
	
	//
	//	We only care about the first string !!
	//

	NRC	code ;
	SHUTDOWN_CAUSE	cause = CAUSE_PROTOCOL_ERROR ;

	//
	//	Only fall through to here if we have completed all processing of the
	//	mode reader command
	//
	BOOL	fResult = ResultCode( pszArgs[0], code ) ;

	OutboundLogResults( pSocket, fResult, code, cArgs, pszArgs ) ;

	if(	fResult && code == nrcNewnewsFollows )	{
		//
		//	We won't do any limit checking on the size of the temp file we create !
		//
		CIOReadArticle*	pread = new( *pdriver ) CIOReadArticle( this, pSocket, pdriver, m_pFileChannel, 0, TRUE ) ;
		if( pread &&  pread->Init( pSocket ) )	{
			return	pread ;
		}	else	{
			cause = CAUSE_IODRIVER_FAILURE ;
		}
	}
	// Only arive here if some kind of error occurred !!
	// We will close the IO Driver down and kill ourselves !!
	pdriver->UnsafeClose( pSocket, cause, (DWORD)code ) ;
	return	0 ;
}

BOOL
CCollectNewnews::InternalComplete(	CSessionSocket*	pSocket,	
									CDRIVERPTR&	pdriver ) {

	if( InterlockedIncrement( &m_cCompletes ) < 0 ) {
		return	TRUE ;
	}	else	{

		CCollectArticles	*pNext = new	CCollectArticles( pSocket, m_pSessionDriver, *m_pFileChannel ) ;
		m_pFileChannel = 0 ;
		if( pNext )	{
			if( pNext->Init( pSocket ) )	{
				CIORead*	pRead = 0 ;
				CIOWrite*	pWrite = 0 ;
				if( pNext->Start(	pSocket,	m_pSessionDriver,	pRead,	pWrite ) )	{
					// We happen to know that this start function shouldn't return any Read or Writes !
					_ASSERT( pRead == 0 ) ;
					_ASSERT( pWrite == 0 ) ;
					return TRUE	;	// Succesfully completion !!
				}
				_ASSERT( pRead == 0 ) ;
				_ASSERT( pWrite == 0 ) ;
			}
		}
	}
	return	FALSE ;	
}

CIO*
CCollectNewnews::Complete(	CIOWriteLine*,	
							class	CSessionSocket*	pSocket,
							CDRIVERPTR&	pdriver	)	{

	//
	//	Only fall through to here when completed processing of the mode reader command.
	//

	//
	//	Don't care how or when the newnews write completes !
	//

	if( !InternalComplete(	pSocket,	pdriver ) )		{
		pdriver->UnsafeClose(	pSocket,	CAUSE_UNKNOWN,	GetLastError() ) ;
	}	

	return	0 ;
}

void
CCollectNewnews::Complete(	CIOReadArticle*	pArticle,	
							class	CSessionSocket*	pSocket,	
							CDRIVERPTR&		pdriver,	
							CFileChannel&	pFileChannel,
							DWORD			cbTransfer	)	{

	//
	//	Completed reading all of the message-ids into a temp file -
	//	time to start the CCollectArticles state and start pulling those
	//	messages over !!
	//

	_ASSERT( pdriver != m_pSessionDriver ) ;
	_ASSERT(	pArticle != 0 ) ;
	_ASSERT(	pSocket != 0 ) ;
	_ASSERT(	pdriver != 0 ) ;
	_ASSERT(	&pFileChannel != 0 ) ;
	_ASSERT(	&pFileChannel == m_pFileChannel ) ;
		
	SHUTDOWN_CAUSE cause = CAUSE_UNKNOWN ;
	DWORD	dwOptional = 0 ;

	if( InternalComplete(	pSocket,	pdriver ) ) {
		return;
	}

	dwOptional = GetLastError() ;
	m_pSessionDriver->Close( pSocket, cause, dwOptional ) ;
}

const	char	CCollectArticles::szArticle[] = "article " ;

CCollectArticles::CCollectArticles(
									CSessionSocket*	pSocket,
									CDRIVERPTR&	pDriver,	
									CFileChannel&	pFileChannel
									) :	
	m_fFinished( FALSE ),
	m_FinishCause( CAUSE_UNKNOWN ),
	m_cResets( -1 ),
	m_pSocket( pSocket ),
	m_pFileChannel( &pFileChannel ),
	m_inputId(	new	CIODriverSink( 0 ) ),
	m_pSessionDriver( pDriver ),
	m_pReadArticle( 0 ),
	m_fReadArticleInit( FALSE ),
	m_pReadArticleId( 0 ),
	m_fReadArticleIdSent( FALSE ),
	m_cAhead( -1 ),
	m_pchNextArticleId( 0 ),
	m_pchEndNextArticleId( 0 ),
	m_hArticleFile( INVALID_HANDLE_VALUE ),
	m_cArticlesCollected( 0 ),
	m_cCompletes( -2 ),
	m_lpvFeedContext( 0 )
{
	TraceFunctEnter( "CCollectArticles::CCollectArticles" ) ;
	_ASSERT(	&pFileChannel != 0 ) ;
	_ASSERT( pDriver != 0 ) ;

	DebugTrace( (DWORD_PTR)this, "New CCollectArticles" ) ;

	m_pFileChannel->Reset( TRUE ) ;
}

void
CCollectArticles::Reset( )	{

	TraceFunctEnter( "CCollectArticles::Reset" ) ;

	//
	//	This function exists to get rid of all the references to anything we
	//	may be holding.  We can be called recursively so we must take extra care !!
	//

	//
	//	Only do Reset() once !
	//
	if( InterlockedIncrement( &m_cResets ) == 0 )	{


		DebugTrace( (DWORD_PTR)this, "m_pFileChannel %x m_inpuId %x m_pSessionDriver %x"
								" m_pchNextArticleId %x m_pchEndNextArticleId %x",
				m_pFileChannel, m_inputId, m_pSessionDriver, m_pchNextArticleId,
				m_pchEndNextArticleId ) ;

        //  12/23/98 : BINLIN - fix AV in PostCancel - Before we do "m_pSessionDriver = 0" below,
        //  need to do our PostCancel if needed.
        //  It's ok if we go through another PostCancel() code path in CCollectArticles::Complete()
        //  'cause we call InternalComplete() after that, which will set m_lpvFeedContext to NULL!
	    if( m_lpvFeedContext != 0 ) {
		    _ASSERT( m_pSocket != 0 ) ;
		    DWORD	dwReturn ;
		    CNntpReturn	nntpReturn ;
		    m_pSocket->m_context.m_pInFeed->PostCancel(	
					    m_lpvFeedContext,
					    dwReturn,
					    nntpReturn
					    ) ;
		    m_lpvFeedContext = 0;
	    }

		if( m_pFileChannel != 0 ) {
			m_pFileChannel = 0 ;
		}

		m_inputId = 0 ;
		m_pSessionDriver = 0 ;
		m_pchNextArticleId = 0 ;
		m_pchEndNextArticleId = 0 ;

		DebugTrace( (DWORD_PTR)this, "m_pReadArticleId %x", m_pReadArticleId ) ;
		if( m_pReadArticleId != 0 ) {
			CIOReadLine*	pTemp = m_pReadArticleId ;
			m_pReadArticleId = 0 ;
			if( !m_fReadArticleIdSent )
				pTemp->DestroySelf() ;
		}

		DebugTrace( (DWORD_PTR)this, "m_pReadArticle %x and m_fReadArticleInit %x", m_pReadArticle,
			m_fReadArticleInit ) ;

		if( m_pReadArticle != 0 )	{
			CIOGetArticleEx	*pReadArticleTemp = m_pReadArticle ;
			m_pReadArticle = 0 ;
			if( !m_fReadArticleInit ) {
				pReadArticleTemp->DestroySelf() ;
			}	else	{
				_ASSERT( m_pSocket != 0 ) ;
				pReadArticleTemp->Term( m_pSocket ) ;
			}
		}
	}
}

CCollectArticles::~CCollectArticles() {

	TraceFunctEnter( "CCollectArticles::~CCollectArticles" ) ;

	Reset() ;

}

BOOL
CCollectArticles::Init(	CSessionSocket*	pSocket )	{

	//
	//	If we can init the CIODriverSink for the message-id file we're ready to go !!
	//

	_ASSERT( pSocket != 0 ) ;
	_ASSERT( m_pReadArticleId == 0 ) ;
	_ASSERT(	m_cAhead == -1  ) ;
	_ASSERT(	m_pchNextArticleId == 0 ) ;

	BOOL	fRtn = FALSE ;
	CIODriverSink*	pInputSink = (CIODriverSink*) ((CIODriver*)m_inputId) ;
	if( m_inputId != 0 && pInputSink->Init( m_pFileChannel, pSocket,
			ShutdownNotification, this, sizeof( szArticle )*2 ) )	{
		fRtn = TRUE ;
	}		
	return	fRtn ;
}

void
CCollectArticles::Shutdown(	CIODriver&	driver,	
							CSessionSocket*	pSocket,	
							SHUTDOWN_CAUSE	cause,	
							DWORD	dw )	{

	TraceFunctEnter( "CCollectArticles::Shutdown" ) ;

	if( cause != CAUSE_NORMAL_CIO_TERMINATION ) {
		if( m_pSessionDriver != 0 )
			m_pSessionDriver->UnsafeClose( m_pSocket, cause, dw, TRUE ) ;
		if( m_inputId != 0 )
			m_inputId->UnsafeClose( (CSessionSocket*)this, cause, dw, TRUE ) ;
		Reset() ;
	}
}

void
CCollectArticles::ShutdownNotification( void	*pv,	
										SHUTDOWN_CAUSE	cause,	
										DWORD dw ) {

	//
	//	This functio will be called if there is a problem issuing IO's to any of our
	//	files !
	//

	_ASSERT( pv != 0 ) ;

}


BOOL
CCollectArticles::Start(	CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver,	
							CIORead*&	pRead,	
							CIOWrite*&	pWrite )	{

	//
	//	Start collecting articles from the remote server !
	//	First thing : read from the temp file to get a Message-Id !
	//	When that completes and we want the message, send a request
	//	to the remote server !
	//

	_ASSERT( pRead == 0 ) ;
	_ASSERT( pWrite == 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	_ASSERT( m_pReadArticleId == 0 ) ;
	_ASSERT(	m_cAhead == -1  ) ;
	_ASSERT(	m_pchNextArticleId == 0 ) ;


	TraceFunctEnter( "CCollectArticles::Start" ) ;

	pRead = 0 ;
	pWrite = 0 ;
	
	CIOReadLine*	pReadLine = new( *pdriver )	CIOReadLine( this, TRUE ) ;

	//
	//	Start things off by reading a line from our temp file.
	//	Should get a single Message-Id from this read !
	//

	DebugTrace( (DWORD_PTR)this, "Issing CIOReadLine %x", pReadLine ) ;

	if( pReadLine )	{
		m_pReadArticleId = pReadLine ;
		m_fReadArticleIdSent = TRUE ;
		if( !m_inputId->SendReadIO(	pSocket,	*pReadLine, TRUE ) ) {	

			ErrorTrace( (DWORD_PTR)this, "Error issuing CIOReadLine %x", pReadLine ) ;

			m_fReadArticleIdSent = FALSE ;
			m_pReadArticleId = 0 ;
			CIO::Destroy( pReadLine, *pdriver ) ;
			return	FALSE ;
		}
		return	TRUE ;
	}
	return	FALSE ;
}

CIO*
CCollectArticles::Complete(	CIOReadLine*	pReadLine,	
							CSessionSocket*	pSocket,
							CDRIVERPTR&	pdriver,	
							int	cArgs,	
							char	**pszArgs,	
							char	*pchBegin )	{

	//
	//	We read a line of text from somewhere - but where ?
	//	We need to check whether we got text from the network or from our temp
	//	file of message-ids.  If its from the temp file, process the message-id
	//	so we can send it to the remote server.
	//	If its from the network, its a response to an article command - so figure out
	//	whether we're going to get the article and issue a CIOReadArticle if so !
	//

	TraceFunctEnter( "CCollectArticles::Complete" ) ;

	_ASSERT( pReadLine != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	_ASSERT( cArgs != 0 ) ;
	_ASSERT( pszArgs[0] != 0 ) ;
	_ASSERT( pchBegin != 0 ) ;

	_ASSERT( pchBegin <= pszArgs[0] ) ;
	_ASSERT( pReadLine != m_pReadArticleId || (pszArgs[0] - pchBegin) >= sizeof( szArticle ) ) ;

	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;
	DWORD	dwOptional = 0 ;

	if( pReadLine == m_pReadArticleId )	{
		_ASSERT( pdriver != m_pSessionDriver ) ;
		unsigned	cb= lstrlen( pszArgs[0] ) ;

		DebugTrace( (DWORD_PTR)this, "checking for Message Id len %d string %s", cb, pszArgs[0] ) ;

		if( cArgs == 1 &&
			pszArgs[0][0] == '<' &&
			pszArgs[0][ cb-1 ] == '>' )	{

			//
			//	This appears to be a valid Message-Id !!! Send an article command !
			//


			ARTICLEID	artid ;
			GROUPID		groupid ;
			WORD		HeaderOffset ;
			WORD		HeaderLength ;
			CStoreId	storeid;

			PNNTP_SERVER_INSTANCE pInstance = (pSocket->m_context).m_pInstance ;
			if( pInstance->ArticleTable()->GetEntryArticleId(	pszArgs[0],
															HeaderOffset,
															HeaderLength,
															artid,
															groupid,
															storeid) ||
				pInstance->HistoryTable()->SearchMapEntry( pszArgs[0] ) ) {
				
				return	pReadLine ;

			}

			// Save away in case another thread will use it

			_ASSERT( m_pchNextArticleId == 0 ) ;

			DebugTrace( (DWORD_PTR)this, "Is A MessageId" ) ;

			m_pchNextArticleId = pszArgs[0] ;
			m_pchEndNextArticleId = m_pchNextArticleId + cb ;
			CIOWriteLine*	pWriteNextArticleId = new( *pdriver )	CIOWriteLine( this ) ;
			if( pWriteNextArticleId == 0 )	{
				//	FATAL Error - shut down session !
				cause = CAUSE_OOM ;
				dwOptional = GetLastError() ;
				_ASSERT( 1==0 ) ;
			}	else	{
				pWriteNextArticleId->InitBuffers( m_pSessionDriver, pReadLine ) ;

				//
				//	There is no other processing going on - we must initiate everything
				//

				DebugTrace( (DWORD_PTR)this, "Starting Transfer !!" ) ;

				if( !StartTransfer(	pSocket,	pdriver, pWriteNextArticleId	) )	{
					//	Fatal Error - shut down session !
					//	We will fall through to correct shutdown code !
					CIO::Destroy( pWriteNextArticleId, *pdriver ) ;
				}	else	{

					DebugTrace( (DWORD_PTR)this, "Call to StartTransfer failed" ) ;

					// Start Transfer must clean these up !!
					_ASSERT( m_pchNextArticleId == 0 ) ;
					_ASSERT( m_pchEndNextArticleId == 0 ) ;
					//	We will try to find the next Article ID to send
					//return	pReadLine ;
					return 0 ;
				}
			}
		}	else	if( cArgs == 1 && pszArgs[0][0] == '.' && pszArgs[0][1] == '\0' )	{


				DebugTrace( (DWORD_PTR)this, "At end of newnews list" ) ;

				// End of the list !!!
				//
				//	we can teminate this now !!
				//
				m_fFinished = TRUE ;


				m_pchNextArticleId = 0 ;
				m_pReadArticleId = 0 ;
				m_fReadArticleIdSent = FALSE ;

				m_pFileChannel->CloseSource( pSocket ) ;
				if( m_cArticlesCollected > 0 ) {
					cause = m_FinishCause = CAUSE_LEGIT_CLOSE ;
				}	else	{
					cause = m_FinishCause = CAUSE_NODATA ;
				}

				DebugTrace( (DWORD_PTR)this, "Closing Input driver %x", m_inputId ) ;


				//
				//	Send the quit command !!!
				//
				static	char	szQuit[] = "quit\r\n" ;

				CIOWriteLine*	pWrite = new( *pdriver ) CIOWriteLine( this ) ;

				DebugTrace( (DWORD_PTR)this, "built CIOWriteLine %x to send quit command", pWrite ) ;

				if( pWrite && pWrite->InitBuffers( m_pSessionDriver, sizeof( szQuit ) ) ) {
					CopyMemory( pWrite->GetBuff(), szQuit, sizeof( szQuit ) -1  ) ;
					pWrite->AddText(	sizeof( szQuit ) - 1) ;

					if( m_pSessionDriver->SendWriteIO( pSocket, *pWrite ) )	{
						DebugTrace( (DWORD_PTR)this, "Successfully sent pWrite %x", pWrite ) ;
						return	0 ;
					}
				}	

				//
				//	Some kind of error occurred - so close our input driver !
				//
				if( m_inputId != 0 )
					m_inputId->UnsafeClose( pSocket, cause, 0 ) ;


				//
				//	In case of problems, clean up here by terminating the session hard !
				//

				ErrorTrace( (DWORD_PTR)this, "some kind of error - will call UnsafeClose() pWrite %x", pWrite ) ;

				if( pWrite != 0 )
					CIO::Destroy( pWrite, *pdriver ) ;
				if( m_pSessionDriver != 0 )
					m_pSessionDriver->UnsafeClose( pSocket, cause, 0 ) ;
				return	0 ;	// No more reads here !!
				
		}	else	{

			ErrorTrace( (DWORD_PTR)this, "Junk in input stream" ) ;

			// WE GOT SENT garbage !!!!! What is this stuff -
			// blow off the session !
			//_ASSERT( 1==0 ) ;
			cause = CAUSE_ILLEGALINPUT ;
		}
	}	else	{
		//
		//	This is a readline from the network - in which case we must
		//  be looking for the response from an article command !!
		//

		DebugTrace( (DWORD_PTR)this, "received : %s", pszArgs[0] ) ;

		_ASSERT( pdriver == m_pSessionDriver ) ;
		NRC	code ;
		_ASSERT( m_pReadArticle != 0 ) ;

		BOOL fResult = ResultCode( pszArgs[0], code ) ;

		if( fResult )	{
			if( code == nrcArticleFollows )	{
				//
				// Fantastic - now read the whole article !!!!
				//
				DebugTrace( (DWORD_PTR)this, "Start reading article - %x", m_pReadArticle ) ;
				_ASSERT( m_pReadArticle != 0 ) ;
				m_fReadArticleInit = TRUE ;
				return	m_pReadArticle ;

			}	else	{

				DebugTrace( (DWORD_PTR)this, "Error - discard %x", m_pReadArticle ) ;
		        OutboundLogResults( pSocket, fResult, code, cArgs, pszArgs ) ;

				if( m_pReadArticle )	{
					if( m_fReadArticleInit )	{
						m_pReadArticle->Term( pSocket, FALSE ) ;
					}	else	{
						CIO::Destroy( m_pReadArticle, *pdriver ) ;
					}
					m_fReadArticleInit = FALSE ;
				}
				m_pReadArticle = 0 ;

				//
				//	Synchronize with the thread which completed the write of our
				//	command to the remote server - only one of us should call GetNextArticle() !
				//
				//	NOTE : in error cases we should fall through - in Success cases return 0 !
				//
				if( InterlockedIncrement( &m_cCompletes ) == 0 ) {
					m_cCompletes = -2 ;
					if( GetNextArticle( pSocket,	pdriver ) ) {
						return	0 ;
					}
				}	else	{
					return	0 ;
				}
			}
		}	else	{
			//
			//	Not a legal result code - blow off session !
			//

		    OutboundLogResults( pSocket, fResult, code, cArgs, pszArgs ) ;
			ErrorTrace( (DWORD_PTR)this, "bad error code - blow off session" ) ;

			_ASSERT( 1==0 ) ;
			cause = CAUSE_ILLEGALINPUT ;
		}
	}
	//
	//	If we were called by the m_pReadArticleId object we don't
	//	want it blown away by Reset - it can handle that itself !
	//
	if( pReadLine == m_pReadArticleId )	{
		m_pReadArticleId = 0 ;
		m_fReadArticleIdSent = FALSE ;
	}

	//
	//	Note - m_inputid can be Zero
	//
	Shutdown( *pdriver, pSocket, cause, dwOptional ) ;

	Reset() ;
	return	0 ;
}


BOOL
CCollectArticles::StartTransfer(	CSessionSocket*	pSocket,	
									CDRIVERPTR&	pdriver,
									CIOWriteLine*	pWriteNextArticleId
									)	{
/*++

Routine Description :

	This function issues a command to the remote server to ask for an article.
	Additionally, it issues the necessary IO's to get the response to the command.
	

Arguemtns :
	
	pSocket - Pointer to the CSessionSocket representing the session
	pdriver - The CIODriver which controls all IO for the session
	pWriteNextArticleId - a CIOWriteLine object which contains the text of the article Command.
		IMPORTANT NOTE - If the function fails the caller must delete pWriteNextArticleId on its own.
		If the function succeeds the caller is no longer responsible for freeing pWriteNextArticleID

Return Value :

	TRUE if successfull
	FALSE if otherwise.


--*/

	//
	//	Once we've figured out that we want a given message-id we call
	//	this function to create temp files etc... and issue a CIOreadArticle to
	//	receive the article into.
	//

	extern	char	szBodySeparator[] ;
	extern	char	szEndArticle[] ;
	extern	char	*szInitial ;

	TraceFunctEnter( "CCollectArticles::StartTransfer" ) ;

	DebugTrace( (DWORD_PTR)this, "m_pchNextArticleId %20s m_pchEndNextAritcleId %x", m_pchNextArticleId,
			m_pchEndNextArticleId ) ;

	_ASSERT( m_pchNextArticleId != 0 ) ;
	_ASSERT(	m_pchEndNextArticleId != 0 ) ;
	_ASSERT(	m_pchEndNextArticleId > m_pchNextArticleId ) ;
	_ASSERT(	m_pchNextArticleId + lstrlen( m_pchNextArticleId ) == m_pchEndNextArticleId ) ;
	_ASSERT(	pWriteNextArticleId != 0 ) ;
	_ASSERT(	pWriteNextArticleId->GetBuff() != 0 ) ;
	_ASSERT(	pWriteNextArticleId->GetBuff() < m_pchNextArticleId ) ;
	_ASSERT(	pWriteNextArticleId->GetTail() > m_pchNextArticleId ) ;
	_ASSERT(	m_pReadArticle == 0 ) ;

	DebugTrace( (DWORD_PTR)this, "pWriteNextArticleId %x m_pReadArticle %x", pWriteNextArticleId, m_pReadArticle ) ;

	char	*pchArticle = m_pchNextArticleId - sizeof( szArticle ) + 1 ;

	CopyMemory( pchArticle, szArticle, sizeof( szArticle ) - 1 ) ;
	*m_pchEndNextArticleId++ = '\r' ;
	*m_pchEndNextArticleId++ = '\n' ;

	OutboundLogFill(	pSocket,
						(LPBYTE)pchArticle,
						(DWORD)(m_pchEndNextArticleId - pchArticle)
						) ;

	pWriteNextArticleId->SetLimits( pchArticle, m_pchEndNextArticleId ) ;	

	CIOReadLine*	pNextReadLine = new( *pdriver )	CIOReadLine( this ) ;
	if( pNextReadLine == 0 )	{

		DebugTrace( (DWORD_PTR)this, "Memory Allocation Failure" ) ;
		// FATAL Error - shut down session !!
		CIO::Destroy( pWriteNextArticleId, *pdriver ) ;
		return	FALSE ;
	}

	PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
	m_pReadArticle = new( *pdriver )	CIOGetArticleEx(
											this,
											pSocket,
											m_pSessionDriver,
											pSocket->m_context.m_pInFeed->cbHardLimit( pInst->GetInstanceWrapper() ),
											szBodySeparator,
											szBodySeparator,
											szEndArticle,
											szInitial
											) ;
	if( m_pReadArticle )	{
		DebugTrace( (DWORD_PTR)this, "pNextReadLine %x m_pWriteNextAritcleId %x",
			pNextReadLine, pWriteNextArticleId ) ;

		if( !m_pSessionDriver->SendReadIO( pSocket, *pNextReadLine, TRUE ) )	{
			;
		}	else	{
			// if SendReadIO succeeds we are not responsible for deleting pNextReadLine
			// under any error circumstances !
			pNextReadLine = 0 ;
			if(	!m_pSessionDriver->SendWriteIO(	pSocket, *pWriteNextArticleId, TRUE ) )	{
				;	// caller should delete pWriteNextArticleId in error cases
			}	else	{
				pWriteNextArticleId = 0 ;	
				m_pchNextArticleId = 0 ;
				m_pchEndNextArticleId = 0 ;
				return	TRUE ;
			}
		}
	}

	DWORD	dw = GetLastError() ;
	//
	//	Some sort of error occurred - cleanup
	//
	if(	pNextReadLine != 0 )	{
		CIO::Destroy( pNextReadLine, *pdriver ) ;
	}
	return	FALSE ;
}



CCollectArticles*
CCollectComplete::GetContainer()	{
	return	CONTAINING_RECORD( this, CCollectArticles, m_PostComplete ) ;
}

void
CCollectComplete::StartPost(	)	{
	CCollectArticles*	pContainer = GetContainer() ;
	pContainer->AddRef() ;
}

void
CCollectComplete::Destroy()	{
	Reset() ;
	CCollectArticles*	pContainer = GetContainer() ;
	pContainer->InternalComplete( pContainer->m_pSocket, pContainer->m_inputId ) ;
	if( pContainer->RemoveRef() < 0 ) 	{
		delete	pContainer ;
	}
}




void
CCollectArticles::InternalComplete(	CSessionSocket*	pSocket,
									CDRIVERPTR&	pdriver
									)	{
/*++

Routine Description :

	This function contains all the common code for the various completions
	that CIOGetArticleEx can invoke.
	Basically, we ensure that we advance to the next stage of the state
	machine - retrieving the next article.

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter("CCollectArticles::InternalComplete" ) ;

	m_lpvFeedContext = 0 ;

	m_pReadArticle = 0 ;
	m_fReadArticleInit = FALSE ;

	m_cArticlesCollected ++ ;

	//
	//	Now we come to the logic where we issue our next write.
	//

	if( InterlockedIncrement( &m_cCompletes ) == 0 ) {
		m_cCompletes = -2 ;
		if( !GetNextArticle( pSocket,	pdriver ) ) {
			DebugTrace( (DWORD_PTR)this, "CLOSING Driver %x", m_pSessionDriver ) ;
			m_pSessionDriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
			m_pSessionDriver = 0 ;
		}
	}
}

CIO*
CCollectArticles::Complete(
			CIOGetArticleEx*	pGetArticle,
			CSessionSocket*		pSocket,
			BOOL				fGoodMatch,
			CBUFPTR&			pBuffer,
			DWORD				ibStart,
			DWORD				cb
			)	{
/*++

Routine Description :

	This function exists to process the results of receiving and
	article header during a pull feed.
	We give the incoming header to the CInFeed derived object to
	process then continue the reception of the article.

Arguments :
	pGetArticle - the CIOGetArticle operation that was issued !
	pSocket - the socket that we are doing the pull feed on !
	fGoodMatch - did we successfully match the header of the article
	pBuffer - the buffer containing the articles header
	ibStart - the offset to where the header bytes begin !
	cb -	the number of bytes in the header

Return Value :

	The next CIO operation - usually we just continue the current one !

--*/

	//
	//	If we get a bad match, then its just as if the article
	//	was totally tossed, and we can continue with our Internal
	//	Completion routines !
	//
	if( fGoodMatch ) 	{

		//
		//	The strings that we use to match the termination string of an article !
		//
		extern	char	szEndArticle[] ;
		extern	char	*szInitial ;
		//
		//	Keep track of how we use bytes in the output buffer of PostEarly !
		//
		DWORD	ibOut = 0 ;
		DWORD	cbOut = 0 ;
		//
		//	Stuff we need for PostEarly() to figure out how to handle the posting !
		//
		PNNTP_SERVER_INSTANCE pInstance = pSocket->m_context.m_pInstance;
		ClientContext*  pContext = &pSocket->m_context ;
		BOOL	fAnon = pSocket->m_context.m_pInFeed->fDoSecurityChecks() ;
		FIO_CONTEXT*	pFIOContext;

		//
		//	Now check some assumptions about our state !
		//
		//	Shouldn't have one of these things dangling around !
		//
		_ASSERT( m_lpvFeedContext == 0 ) ;

	    //
    	// Allocate room in the log buffer for the list of newsgroups
    	// (Max is 256 characters -- we'll grab 200 of them if we can)
    	// If we fail, we just pass NULL to PostEarly
    	//

        DWORD cbNewsgroups;
        BYTE* pszNewsgroups;
        for (cbNewsgroups=200; cbNewsgroups>0; cbNewsgroups--) {
            pszNewsgroups = pSocket->m_Collector.AllocateLogSpace(cbNewsgroups);
            if (pszNewsgroups) {
                break;
            }
   	    }

		//
		//	Let's see if we like the headers !
		//
		BOOL
		fSuccess = pSocket->m_context.m_pInFeed->PostEarly(
							pInstance->GetInstanceWrapper(),
							&pContext->m_securityCtx,
							&pContext->m_encryptCtx,
							pContext->m_securityCtx.IsAnonymous(),
							0,	//	No command provided !
							pBuffer,
							ibStart,
							cb,
							&ibOut,
							&cbOut,
							&pFIOContext,
							&m_lpvFeedContext,
							pSocket->m_context.m_dwLast,
							pSocket->GetClientIP(),
							pSocket->m_context.m_return,
							(char*)pszNewsgroups,
							cbNewsgroups
							) ;
        //
        // Add the list of newsgroups to the log structure
        //
        if (pszNewsgroups) {
            pSocket->m_Collector.ReferenceLogData(LOG_TARGET, pszNewsgroups);
        }

		//
		//	If it succeeded, then we should have a pFIOContext for retrieving the article !
		//
		_ASSERT( pFIOContext != NULL || !fSuccess ) ;
		pGetArticle->StartFileIO(
						pSocket,
						pFIOContext,
						pBuffer,
						ibOut,
						cbOut+ibOut,
						szEndArticle,
						szInitial
						) ;
		return	pGetArticle ;
	}
	//
	//	Fall through means article was bad -
	//	do the processing as if we'd done the entire transfer without
	//	posting the article !
	//
	InternalComplete(	pSocket,
						m_inputId
						) ;
	return	0 ;
}

CIO*
CCollectArticles::Complete(	
			CIOGetArticleEx*	pCIOGetArticle,
			CSessionSocket*		pSocket
			) 	{
/*++

Routine Description :

	Handle a complete when we've finished transferring the article
	but we had decided not to post it into our store.

Arguments :

	pCIOGetArticle - the CIOGetArticleEx operation that completed !
	pSocket - The socket we are transferring the article on !

Return Value :

	NULL - we will always go off and do other operations !

--*/
	InternalComplete( pSocket, m_inputId ) ;
	return	 0 ;
}

void
CCollectArticles::Complete(	
				CIOGetArticleEx*,
				CSessionSocket*	pSocket,
				FIO_CONTEXT*	pContext,
				DWORD	cbTransfer
				) 	{
/*++

Routine Description :

	This function handles the successfull transfer of an article
	that we want to commit into our stores.

Arguments :

	pSocket - the socket we are transferring articles on
	pContext - the FIO_CONTEXT that we spooled the article into !
	cbTransfer - the number of bytes we transferred !

Return Value :

	None.

--*/

	PNNTP_SERVER_INSTANCE pInstance = (pSocket->m_context).m_pInstance ;
	BOOL    fAnonymous = FALSE;
	
	if( cbTransfer < pSocket->m_context.m_pInFeed->cbSoftLimit( pInstance->GetInstanceWrapper() ) ||
		pSocket->m_context.m_pInFeed->cbSoftLimit( pInstance->GetInstanceWrapper() ) == 0  ) {
		ClientContext*  pContext = &pSocket->m_context ;
		HANDLE  hToken;
		// Due to some header file problems, I can only pass in
		// a hToken handle here.  Since the post component doens't have
		// type information for client context stuff.
		if ( pContext->m_encryptCtx.QueryCertificateToken() ) {
		    hToken = pContext->m_encryptCtx.QueryCertificateToken();
		} else {
		    hToken = pContext->m_securityCtx.QueryImpersonationToken();
		    fAnonymous = pContext->m_securityCtx.IsAnonymous();
		}
	
		m_PostComplete.StartPost() ;

		BOOL	fSuccess = pSocket->m_context.m_pInFeed->PostCommit(
		                        pSocket->m_context.m_pInstance->GetInstanceWrapper(),
								m_lpvFeedContext,
								hToken,
								pSocket->m_context.m_dwLast,
								pSocket->m_context.m_return,
								fAnonymous,
								&m_PostComplete
								) ;

		if( !fSuccess ) 	{
			m_PostComplete.Release() ;
		}	

	}	else	{
		BOOL	fSuccess = pSocket->m_context.m_pInFeed->PostCancel(	
								m_lpvFeedContext,
								pSocket->m_context.m_dwLast,
								pSocket->m_context.m_return
								) ;
		InternalComplete(	pSocket, m_inputId ) ;
	}
}

CIO*	
CCollectArticles::Complete(	CIOWriteLine*	pWrite,	
							CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver )	{

	//
	//	Just completed sending a 'article' command to the remote server !!
	//

	TraceFunctEnter( "CCollectArticles::Complete - CIOWriteLine" ) ;

	_ASSERT( pWrite != 0 ) ;
	_ASSERT(	pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;

	DebugTrace( (DWORD_PTR)this, "Processing CIOWriteLine %x - m_fFinished %x m_pSessionDriver %x",
			pWrite, m_fFinished, m_pSessionDriver ) ;

	if( m_fFinished ) {

		//
		//	All done - drop session !
		//

		OutboundLogAll(	pSocket,
				FALSE,
				NRC(0),
				0,
				0,
				"quit"
				) ;

		if( m_pSessionDriver )
			m_pSessionDriver->UnsafeClose( pSocket, m_FinishCause, 0 ) ;
		m_pSessionDriver = 0 ;
	
		if( m_inputId )
			m_inputId->UnsafeClose( pSocket, m_FinishCause, 0 ) ;

		return	0 ;
	}

	if( InterlockedIncrement( &m_cCompletes ) == 0 ) {
		m_cCompletes = -2 ;
		if( !GetNextArticle( pSocket,	pdriver ) ) {

			DebugTrace( (DWORD_PTR)this, "CLOSING Driver %x", m_pSessionDriver ) ;

			m_pSessionDriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
			m_pSessionDriver = 0 ;
		}
	}

	return	0 ;
}

BOOL
CCollectArticles::GetNextArticle(	CSessionSocket*	pSocket,	
									CDRIVERPTR&	pdriver	)	{

	//
	//	Issue the necessary IO's to get the next message-id we want to send !
	//
	//

	TraceFunctEnter( "CCollectArticles::GetNextArticle" ) ;
	//
	//	The thread reading from the temp file has got ahead of US !
	//
	CIOReadLine*	pTemp = m_pReadArticleId = new( *pdriver )	CIOReadLine( this, TRUE ) ;
	DebugTrace( (DWORD_PTR)this, "sending ReadArticleId %x", m_pReadArticleId ) ;
	m_fReadArticleIdSent = TRUE ;

	//
	//	Calling SendReadIO can result in our shutdown function being
	//	called, which may reset m_pReadArticleId to NULL.
	//	Hold onto pTemp so if this fails we can insure that the
	//	CIOReadLine is deleted !
	//

	if( !m_inputId->SendReadIO( pSocket, *m_pReadArticleId, TRUE ) ) {
		m_fReadArticleIdSent = FALSE ;
		CIO::Destroy( pTemp, *pdriver ) ;
		m_pReadArticleId = 0 ;
	}	
	DebugTrace( (DWORD_PTR)this, "Note sending a command m_pReadAritcleId %x", m_pReadArticleId ) ;
	return	TRUE ;
}

CAcceptNNRPD::CAcceptNNRPD() :
	m_cCompletes( -2 ),
	m_pbuffer( 0 )	{
}


BOOL
CAcceptNNRPD::Start(	CSessionSocket*	pSocket,	
						CDRIVERPTR&	pdriver,
						CIORead*&	pRead,	
						CIOWrite*&	pWrite )	{

	//
	//	This starts the Accept NNRPD state - the state from which we process all
	//	incoming commands !  we want to issue an 'ok' string to the client,
	//	and then start getting incoming commands !
	//

	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	_ASSERT( pRead == 0 ) ;
	_ASSERT( pWrite == 0 );
	
	CIOWriteLine*	pWriteLine = new( *pdriver ) CIOWriteLine( this ) ;
	if( pWriteLine ) {

		static	char	szConnectString[] = "200 Good Enough\r\n" ;
		DWORD	cb = 0 ;
		char*	szConnect = 0;


		//
		//	Figure out whether we are accepting posts right now.
		//
		PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
		if( pSocket->m_context.m_pInFeed->fAcceptPosts( pInst->GetInstanceWrapper() ) ) {

			szConnect = pInst->GetPostsAllowed( cb ) ;

		}	else	{

			szConnect = pInst->GetPostsNotAllowed( cb ) ;
			
		}
		
		if( !szConnect )	{
			szConnect = szConnectString ;
			cb = sizeof( szConnectString ) - 1 ;
		}

		if( pWriteLine->InitBuffers( pdriver, cb ) ) {
			CopyMemory( pWriteLine->GetBuff(), szConnect, cb ) ;
			pWriteLine->AddText(	cb) ;
			pWrite = pWriteLine ;
			return	TRUE ;
		}
	}
	if( pWriteLine )
		CIO::Destroy( pWriteLine, *pdriver ) ;
	return	FALSE ;
}

CIO*
CAcceptNNRPD::Complete( CIOReadLine*	pReadLine,	
						CSessionSocket*	pSocket,
						CDRIVERPTR&	pdriver,	
						int	cArgs,	
						char	**pszArgs,	
						char*	pchBegin
						)	{
	//
	//	Just completed a complete line of something from the client.
	//	Parse it into a command object which will be derived from one of
	//	two type - CExecute of CIOExecute.
	//	In the case of CExecute derived objects, we will build buffers
	//	in which we send the response to the client.
	//	CIOExecute derived objects are full blown states in them selves,
	//	and will have their own Start and Complete() functions. So we just
	//	record our state so that eventually we end up back here again.
	//

	TraceFunctEnter( "CAcceptNNRPD::Complete" ) ;

	_ASSERT( pReadLine != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	_ASSERT(	cArgs != 0 ) ;
	_ASSERT( pszArgs != 0 ) ;
	_ASSERT( pchBegin != 0 ) ;
	_ASSERT( pchBegin <= pszArgs[0] ) ;

	//
	//	Initialize these to report an error in case something goes wrong !
	//
	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;
	DWORD	dwOptional = 0 ;
	//
	//	If m_pbuffer is not NULL then we were holding a buffer for the sake of a CIOExecute
	//	object.  Now that we have been called from a read completion however, it is obvious
	//	that the CIOExecute object has completed whatever it was doing - in which case
	//	the reference m_pbuffer holds is not needed.  NOTE : Odds are good that most of the
	//	time m_pbuffer is 0 already !
	//
	m_pbuffer = 0 ;

	CExecutableCommand*	pExecute = 0 ;
	ECMD		ecmd ;
	BOOL		fIsLargeResponse = FALSE ;
	LPSTR		lpstrOperation = 0 ;
	char		szArgsBuffer[80] ;
	szArgsBuffer[0] = '\0' ;
	BuildCommandLogString( cArgs-1, pszArgs+1, szArgsBuffer, 80 ) ;

	//
	//	Set these to 0, they get set at some point while executing the command !
	//
	pSocket->m_context.m_nrcLast = (NRC)0 ;
	pSocket->m_context.m_dwLast = 0 ;

	//
	//	Build a command object which will process the client command !
	//

	CIOExecute*	pIOExecute = make(	cArgs,
									pszArgs,
									ecmd,
									pExecute,
									pSocket->m_context,
									fIsLargeResponse,
									*pdriver,
									lpstrOperation
									) ;

	CLogCollector*	pCollector = 0 ;
	if( ecmd & ((pSocket->m_context).m_pInstance)->GetCommandLogMask() ) {
		pCollector = &pSocket->m_Collector ;
		if( pCollector ) {
			_ASSERT( pCollector->m_cbBytesRecvd == 0 );
			_ASSERT( EQUALSI( pCollector->m_cbBytesSent, 0 ) );
			pCollector->m_cbBytesRecvd = pReadLine->GetBufferLen();
		}
	}

	//
	//	Get a hold of the buffer in which the command was sent !
	//  We keep a reference to this buffer untill we return to this state
	//	after executeing the CIOExecute derived state.
	//	We do this so that the buffer will not be discarded so that the
	//	CIOExecute object can keep pointers into the buffer's data if it needs to!
	//
	m_pbuffer = pReadLine->GetBuffer() ;

	//
	//	If we are collecting logging information use lpstrOperation if available -
	//	it is the canonicalized version of the command string and will always be the
	//	same case etc.... !
	//
	if( pCollector ) {
		if( lpstrOperation != 0 ) {
			pCollector->ReferenceLogData( LOG_OPERATION, (LPBYTE)lpstrOperation ) ;

			//
			//	The post commands set the LOG_PARAMETERS field themselves -
			//	don't do any allocations !
			//
			if( !(ecmd & (ePost | eIHave | eXReplic)) ) {
				char*	lpstr = (char*)pCollector->AllocateLogSpace( 80 ) ;
				*lpstr = '\0' ;
				CopyMemory( lpstr, szArgsBuffer, 80 ) ;
				pCollector->ReferenceLogData( LOG_PARAMETERS, (BYTE*)lpstr ) ;
			} else if( ecmd & eIHave && cArgs > 1 )	{
				pCollector->ReferenceLogData( LOG_PARAMETERS, (BYTE*)pszArgs[1] ) ;
			}

		}	else	{
			char*	lpstr = (char*)pCollector->AllocateLogSpace( 64 ) ;
			if (lpstr) {
    			*lpstr = '\0' ;
	    		BuildCommandLogString( cArgs, pszArgs, lpstr, 64 ) ;
		    	pCollector->ReferenceLogData( LOG_OPERATION, (BYTE*)lpstr ) ;
		    }
		}
	}

	if( pExecute != 0 || pIOExecute != 0 )	{
		if( pExecute )	{
			_ASSERT( pIOExecute == 0 ) ;

			m_cCompletes = -2 ;
			BOOL	f = pExecute->StartCommand(	this,
												fIsLargeResponse,
												pCollector,
												pSocket,
												*pdriver
												) ;

			//
			//	If this fails - we assume that StartCommand() makes the
			//	necessary calls to UnsafeClose() etc... to tear down the session !
			//	If this succeeds - then we check to see whether everythign has completed !
			//
			if( f ) {
				if( InterlockedIncrement( &m_cCompletes ) == 0 ) {
					return	pReadLine ;
				}	else	{
					return	0 ;
				}
			}

			return	0 ;
								
		}	else	{
			_ASSERT( pExecute == 0 ) ;
			_ASSERT( pIOExecute != 0 ) ;

			CIORead*	pRead = 0 ;
			CIOWrite*	pWrite = 0 ;

			if( pCollector ) {
				pIOExecute->DoTransactionLog( pCollector ) ;
			}

			CIOReadLine*	pReadLine = new( *pdriver ) CIOReadLine( this ) ;
			if( pReadLine )		{
				pIOExecute->SaveNextIO( pReadLine ) ;
				if( pIOExecute->StartExecute( pSocket, pdriver, pRead, pWrite ) )	{
					return	pRead ;
				}
			}
		}
	}	else	{

		cause = CAUSE_OOM ;
		dwOptional = GetLastError() ;

        // Don't block randfail testing
        //
		//_ASSERT( 1==0 ) ;
		// FATAL ERROR !! - Unable to create a command object !!

	}
	//
	//	Only reach here if some error has occurred !
	//
	pdriver->UnsafeClose( pSocket, cause,  dwOptional ) ;
	return	0 ;
}

CIO*
CAcceptNNRPD::InternalComplete(	
						CSessionSocket*			pSocket,
						CDRIVERPTR&				pdriver,
						CExecutableCommand*		pExecute,
						CLogCollector*			pCollector
						) {

	BOOL	fRead =  pExecute->CompleteCommand( pSocket, pSocket->m_context ) ;

	//
	//	Before destroying the CCmd object generate the transaction log - if requried
	//	This is because CCmd objects are allowed to put in references to their temp data
	//	etc... into the log data instead of copying all the strings around !
	//
	if( pCollector ) {
		pSocket->TransactionLog( pCollector, pSocket->m_context.m_nrcLast, pSocket->m_context.m_dwLast ) ;
	}

	//	Do it now before we try to another read or anything !!
	//	Because of the way these are allocated we must make sure
	//	this is destroyed before there's any potential of us wanting
	//	to use the memory this is allocated in when a read completes !!
	delete	pExecute ;

	if(	fRead ) {
		//
		//	Check whether this is the last thing to complete !!
		//
		if( InterlockedIncrement( &m_cCompletes ) == 0 ) {

			CIOReadLine*	pReadLine = new( *pdriver ) CIOReadLine( this ) ;
			if( !(pReadLine && pdriver->SendReadIO( pSocket, *pReadLine, TRUE )) )	{
				if( pReadLine )
					CIO::Destroy( pReadLine, *pdriver ) ;
				pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0, TRUE ) ;
			}								
		}
	}
	//
	//	Note : because we do not increment m_cCompletes when another Read is
	//	not requested there is NO chance that the CIOReadLine completion routing
	//	will mistakenly issue a read.
	//
	return 0 ;
}


CIO*
CAcceptNNRPD::Complete(	CIOWriteCMD*	pWriteCMD,
						CSessionSocket*	pSocket,
						CDRIVERPTR&		pdriver,
						CExecute*		pExecute,
						CLogCollector*	pCollector
						) {


	return	InternalComplete( pSocket, pdriver, pExecute, pCollector ) ;
}


CIO*
CAcceptNNRPD::Complete(	CIOWriteAsyncCMD*	pWriteCMD,
						CSessionSocket*		pSocket,
						CDRIVERPTR&			pdriver,
						CAsyncExecute*		pExecute,
						CLogCollector*		pCollector
						) {


	return	InternalComplete( pSocket, pdriver, pExecute, pCollector ) ;
}
						

						

CIO*
CAcceptNNRPD::Complete(	CIOWriteLine*	pioWriteLine,	
						CSessionSocket*	pSocket,	
						CDRIVERPTR&	pdriver ) {

	//
	//	Wrote a line of text to the remote server -
	//	This could be our very first write (the 200 ok string) or a write
	//	generated bu a CExecute derived object.
	//	If its from a CExecute derived object, we need to see whether we can
	//	generate more text to send.
	//

	TraceFunctEnter( "CAcceptNNRPD::Complete CIOWriteLine" ) ;

	_ASSERT( pioWriteLine != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;

	CIOReadLine*	pReadLine = new( *pdriver ) CIOReadLine( this ) ;
	if( pReadLine )		{
		if( !pdriver->SendReadIO( pSocket, *pReadLine, TRUE ) ) {
			pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0, TRUE ) ;
			CIO::Destroy( pReadLine, *pdriver ) ;
		}
	}	else	{
		ErrorTrace((DWORD_PTR)this, "Could not allocate CIOReadLine");
		pdriver->UnsafeClose(pSocket, CAUSE_OOM, 0, TRUE);
	}

	return	0 ;
}

COfferArticles::COfferArticles(	) :
	m_cCompletions( -2 ),
	m_cTransmitCompletions( -2 ),
	m_fTerminating( FALSE ),
	m_fDoTransmit( FALSE ),
	m_GroupidNext( INVALID_ARTICLEID ),
	m_ArticleidNext( INVALID_ARTICLEID ),
	m_GroupidTriedOnce( INVALID_ARTICLEID ),
	m_ArticleidTriedOnce( INVALID_ARTICLEID ),
	m_GroupidInProgress( INVALID_ARTICLEID ),
	m_ArticleidInProgress( INVALID_ARTICLEID ),
	m_fReadPostResult( FALSE )	{
}

char	COfferArticles::szQuit[] = "quit\r\n" ;

void
COfferArticles::Shutdown(	CIODriver&	driver,
							CSessionSocket*	pSocket,
							SHUTDOWN_CAUSE	cause,
							DWORD	dw )	{
/*++

Routine Description :

	This function is called when a session on which we are sending articles is terminated.
	If there is a transfer in progress, we will assume it failed and place the ID's of the
	article in transit back onto the end of the queue for the remote site.

Arguments :

	driver - the CIODriver	object running the session
	pSocket -	The CSessionSocket object associated with the session
	cause -	the reason for the termination of the session
	dw -	optional DWORD explaining the cause of termination

Return Value :

	None.

--*/

	TraceFunctEnter( "COfferArticles::Shutdown" ) ;


	DebugTrace( (DWORD_PTR)this, "m_GroupidInProgress %x m_ArticleIdInProgress %x",
		m_GroupidInProgress, m_ArticleidInProgress ) ;

	if( m_GroupidInProgress != INVALID_ARTICLEID && m_ArticleidInProgress != INVALID_ARTICLEID ) {
		if( pSocket != 0 && pSocket->m_context.m_pOutFeed != 0 ) {
			pSocket->m_context.m_pOutFeed->Append( m_GroupidInProgress, m_ArticleidInProgress) ;
		}
	}
}

int
COfferArticles::GetNextCommand(	
								CNewsTree*	pTree,
								COutFeed*	pOutFeed,
								BYTE*	lpb,	
								DWORD	cb,	
								DWORD&	ibOffset )	{
/*++

Routine Description :

	This function fills a buffer with the text of the next command we want to send to the
	remote server.  We keep pulling articles off a queue until we get a valid command to send.
	WE have to be carefull about how we terminate the session - if the remote server
	tells us to retry a send we will put a GROUPID ARTICLEID back in the queue.
	If we hit that retry pair again we will end the session - be carefull that that pair remainds
	on the queue.

Arguments :
	pTree -		The NewsTree for this virtual server - use to check for termination !
	pOutFeed -	The COutFeed derived object used to build commands
	lpb	-		Buffer in which to put command
	cb	-		number of bytes available in buffer
	ibOffset -	Offset in the buffer at which command was palced by us

Return Value :
	
	Number of bytes in buffer - 0 if failure

--*/

	TraceFunctEnter( "COfferArticles::GetNextCommand" ) ;


	ibOffset = 0 ;
	unsigned	cbOut = 0 ;
	do	{


		if( pTree->m_bStoppingTree ) {
			// Instance is stopping - bail early
			m_fTerminating = TRUE ;			
			ibOffset = 0 ;
			CopyMemory( lpb, szQuit, sizeof( szQuit ) - 1 ) ;
			cbOut = sizeof( szQuit ) - 1 ;
			return	cbOut ;
		}

		DebugTrace( (DWORD_PTR)this,
			"Top of loop - m_GroupidNext %x m_ArticleidNext %x m_GroupidTriedOnce %x m_ArticleidTriedOnce %x",
			m_GroupidNext, m_ArticleidNext, m_GroupidTriedOnce, m_ArticleidTriedOnce ) ;
		
		if(	!pOutFeed->Remove( m_GroupidNext, m_ArticleidNext ) ) {
			m_GroupidNext = INVALID_ARTICLEID ;
			m_ArticleidNext = INVALID_ARTICLEID ;
		}

		DebugTrace( (DWORD_PTR)this,
			"After Remove - m_GroupidNext %x m_ArticleidNext %x", m_GroupidNext, m_ArticleidNext ) ;
		
		if( m_GroupidNext != INVALID_ARTICLEID && m_ArticleidNext != INVALID_ARTICLEID &&
			!(m_GroupidNext == m_GroupidTriedOnce && m_ArticleidNext == m_ArticleidTriedOnce) )
			cbOut = pOutFeed->FormatCommand( lpb, cb, ibOffset, m_GroupidNext, m_ArticleidNext, m_pArticleNext ) ;
		else	{
			if( m_GroupidNext == m_GroupidTriedOnce && m_ArticleidNext == m_ArticleidTriedOnce )	{
				if( m_GroupidNext != INVALID_ARTICLEID && m_ArticleidNext != INVALID_ARTICLEID )	{
	
					DebugTrace( (DWORD_PTR)this, "Appending m_GroupidNext %x m_ArticleidNext %x",
						m_GroupidNext, m_ArticleidNext ) ;

					pOutFeed->Append( m_GroupidNext, m_ArticleidNext ) ;
				}
			}

			m_fTerminating = TRUE ;			
			ibOffset = 0 ;
			CopyMemory( lpb, szQuit, sizeof( szQuit ) - 1 ) ;
			cbOut = sizeof( szQuit ) - 1 ;
		}

	}	while( cbOut == 0 ) ;

	DebugTrace( (DWORD_PTR)this, "Returning cbOut %x bytes to caller", cbOut ) ;

	return	cbOut ;
}


CIOWriteLine*
COfferArticles::BuildWriteLine(	CSessionSocket*	pSocket,	
								CDRIVERPTR&	pdriver,	
								GROUPID	groupid,	
								ARTICLEID	artid ) {
/*++

Routine Description :

	This function builds the write we will send to the remote server containing the next command
	we wish to issue.

Arguments :

	pSocket - The socket on which the command will be sent
	pdriver	- The CIODriver managing IO for the socket

Return Value :

	A CIOWriteLine object to send to the remote server, NULL if failure.

--*/

	TraceFunctEnter( "COfferArticles::BuildWriteLing" ) ;

	CNewsTree* pTree = ((pSocket->m_context).m_pInstance)->GetTree() ;

	//
	//	Each time we prepare to issue a new command we check if we have recorded
	//	the information for the logging of a previous command - and if so we do it !
	//
	if( ((pSocket->m_context).m_pInstance)->GetCommandLogMask() & eOutPush ) {
		if( pSocket->m_Collector.FLogRecorded() ) {
			pSocket->TransactionLog( &pSocket->m_Collector, pSocket->m_context.m_nrcLast, 0, FALSE ) ;
		}
	}

	CIOWriteLine*	pWriteLine = new( *pdriver )	CIOWriteLine( this ) ;

	DebugTrace( (DWORD_PTR)this, "Built CIOWriteLine %x", pWriteLine ) ;

	if( pWriteLine && pWriteLine->InitBuffers( pdriver ) ) {

		DWORD		ibTextOffset = 0 ;
		unsigned	cb = 0 ;
		BYTE*	pb = (BYTE*)pWriteLine->GetBuff( cb ) ;

		cb = GetNextCommand(	pTree, pSocket->m_context.m_pOutFeed, pb, cb, ibTextOffset ) ;
		if( cb != 0 ) {

#if 0
			if( ((pSocket->m_context).m_pInstance)->GetCommandLogMask() & eOutPush )	{

				pSocket->m_Collector.FillLogData( LOG_OPERATION, pb, min( cb-2, 200 ) ) ;	// -2 to exclude CRLF
				ADDI( pSocket->m_Collector.m_cbBytesSent, cb );	

			}
#endif
			OutboundLogFill( pSocket, pb, cb ) ;

			pWriteLine->SetLimits( (char*)pb+ibTextOffset, (char*)pb+ibTextOffset+cb ) ;

			DebugTrace( (DWORD_PTR)this, "Successfully built CIOWriteLine %x", pWriteLine ) ;

			return	pWriteLine ;
		}
	}

	DebugTrace( (DWORD_PTR)this, "Error building command - delete pWriteLine %x", pWriteLine ) ;

	if( pWriteLine != 0 )
		CIO::Destroy( pWriteLine, *pdriver ) ;

	return	0 ;
}

CIOTransmit*
COfferArticles::BuildTransmit(	CSessionSocket*	pSocket,
								CDRIVERPTR&		pdriver,
								GROUPID			groupid,	
								ARTICLEID		articleid	
								)	{
/*++

Routine Description :

	This function builds a TransmitFile operation which will send the requested article to the
	remote server as well as the subsequent command.

Arguments :

	pSocket - The CSessionSocket object on which we will do the send
	pdriver - The CIODriver object managing IO completions for the socket
	groupid	- The groupid for the article being sent
	articleid -		The articleid for the article being sent.

Return Value :

	A CIOTransmit object if successfull, NULL otherwise.

--*/


	TraceFunctEnter( "COfferArticles::BuildTransmit" ) ;

	DWORD		cbOut = 0 ;
	CBUFPTR		pbuffer = 0 ;
	CIOTransmit*	pTransmit = 0 ;
	DWORD		ibTextOffset = 0 ;

	pTransmit = new( *pdriver ) CIOTransmit( this ) ;
	if( pTransmit != 0 ) {

		CGRPPTR	pGroup = ((pSocket->m_context).m_pInstance)->GetTree()->GetGroupById( groupid ) ;
		if(		pGroup != 0 )	{
			DebugTrace( (DWORD_PTR)this, "Got pTransmit %x and pGroup %x", pTransmit, pGroup ) ;

			if( m_pCurrentArticle == 0 )	{
				//
				//	If we don't have an m_pCurrentArticle, we need to go to the
				//	hashtables and get a storeid to use with the driver !
				//
				CStoreId	storeid ;

				FILETIME	ft ;
				BOOL		fPrimary ;
				WORD		HeaderOffset ;
				WORD		HeaderLength ;
				DWORD cStoreIds = 0;
				DWORD	DataLen = 0 ;

				if( ((pSocket->m_context).m_pInstance)->XoverTable()->ExtractNovEntryInfo(
						groupid,
						articleid,
						fPrimary,
						HeaderOffset,
						HeaderLength,
						&ft,
						DataLen,
						0,
						cStoreIds,
						&storeid,
						NULL))	{
					m_pCurrentArticle = pGroup->GetArticle(	
											articleid,
											storeid,
											0,
											0,
											!pSocket->m_context.m_IsSecureConnection
											) ;
				}
			}
					
			if( m_pCurrentArticle == 0 ) {

				ErrorTrace( (DWORD_PTR)this, "Unable to get Article" ) ;

				PCHAR	args[2] ;
				char	szArticleId[20] ;
				_itoa( articleid, szArticleId, 10 ) ;
				args[0] = szArticleId ;
				args[1] = pGroup->GetNativeName() ;

				NntpLogEventEx( NNTP_QUEUED_ARTICLE_FAILURE,
						2,
						(const char **)args,
						GetLastError(),
						((pSocket->m_context).m_pInstance)->QueryInstanceId()
						) ;

			}	else	{

				FIO_CONTEXT*	pFIOContext = 0 ;
				DWORD	ibOffset ;
				DWORD	cbLength ;

				if( (pFIOContext = m_pCurrentArticle->fWholeArticle( ibOffset, cbLength )) != 0 ) {
					if( pTransmit->Init( pdriver, pFIOContext, ibOffset, cbLength ) )	{
						m_GroupidInProgress = groupid ;
						m_ArticleidInProgress = articleid ;

						DebugTrace( (DWORD_PTR)this,
							"Ready to send article m_GroupidInProgress %x m_ArticleidInProgress %x",
							m_GroupidInProgress, m_ArticleidInProgress ) ;

						IncrementStat( ((pSocket->m_context).m_pInstance), ArticlesSent );

						return	pTransmit ;
					}
				}
			}
		}
	}

	ErrorTrace( (DWORD_PTR)this, "An error occurred - delete pTransmit %x", pTransmit ) ;

	if( pTransmit != 0 )
		CIO::Destroy( pTransmit, *pdriver ) ;
	return	0 ;
}


BOOL
COfferArticles::Start(	CSessionSocket*	pSocket,	
						CDRIVERPTR&	pdriver,
						CIORead*&	pRead,
						CIOWrite*&	pWrite	)	{
/*++

Routine Description :

	Start the COfferArticles State - we need to issue our first IO to the remote
	server which will be to write a command to the port.

Arguments :
	
	pSocket -	The data associated with this socket
	pdriver -	The CIODriver managing IO Completions for this socket
	pRead -		The pointer through which we return our first Read IO
	pWrite -	The pointer through which we return our first Write IO

Return Value :

	TRUE if successfull - FALSE otherwise

--*/

	pSocket->m_context.m_nrcLast = NRC(0);

	CIOReadLine*	pReadLine = new( *pdriver )	CIOReadLine( this ) ;

	if( pReadLine == 0 ) {
		return	FALSE ;
	}	else	{
		
		CIOWriteLine*	pWriteLine = BuildWriteLine(	pSocket,
														pdriver,
														m_GroupidNext,
														m_ArticleidNext ) ;
		if( pWriteLine != 0 ) {
			pRead = pReadLine ;
			pWrite = pWriteLine ;
			return	TRUE ;
		}
	}
	if( pReadLine != 0 )
		CIO::Destroy( pReadLine, *pdriver ) ;

	return	FALSE ;
}

CIO*
COfferArticles::Complete(	CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver
							)	{
/*++

Routine Description :

	For every article we wish to transfer we complete two IO's - a read which tells
	us whether the remote site wants the article and a write of the command which would
	send the article to the remote site.
	So we use InterlockedIncrement to make sure when the final of these IO's complete,
	we issue the next batch of IO's to do the next transfer.

Arguments :

	pSocket -	The socket on which we are sending
	pdriver -	The CIODriver managing IO completions

Return Value :
	
	The CIO object to execute next.	This is always a write.

--*/

	TraceFunctEnter( "COfferArticles::Complete" ) ;

	CIO*	pioNext ;

	SHUTDOWN_CAUSE	cause	= CAUSE_UNKNOWN ;
	DWORD	dwError = 0 ;
	
	if( InterlockedIncrement( &m_cCompletions ) < 0 ) {
		return	0 ;
	}	else	{

		DebugTrace( (DWORD_PTR)this, "GrpInProgress %x ArtInProg %x GrpNext %x ArtNext %x",
				m_GroupidInProgress, m_ArticleidInProgress, m_GroupidNext, m_ArticleidNext ) ;

		//	
		//	We know everything about how the last transfer completed - so NIL these out !
		//
		m_GroupidInProgress = INVALID_ARTICLEID ;
		m_ArticleidInProgress = INVALID_ARTICLEID ;

		//
		//	Free any Article objects we may have been holding !
		//
		m_pCurrentArticle = m_pArticleNext ;
		m_pArticleNext = 0 ;

		if( m_GroupidNext != INVALID_ARTICLEID && m_ArticleidNext != INVALID_ARTICLEID ) {

			GROUPID	groupid = m_GroupidNext ;
			ARTICLEID	articleid = m_ArticleidNext ;

			if(	m_fDoTransmit )	{
				pioNext = BuildTransmit( pSocket,	pdriver,	groupid, articleid ) ;		
			}	else	{
				pioNext = BuildWriteLine( pSocket,	pdriver,	m_GroupidNext,	m_ArticleidNext ) ;
			}

			DebugTrace( (DWORD_PTR)this, "Have build pioNext %x m_fDoTransmit %x", pioNext, m_fDoTransmit ) ;
		
			if( pioNext != 0 ) {
				if( m_fDoTransmit ) {
					m_fReadPostResult = TRUE ;
				}	else	{
					m_fReadPostResult = FALSE ;
				}
				m_cCompletions = -2 ;
				return	pioNext ;
			}	else	{
				cause = CAUSE_OOM ;
				dwError = GetLastError() ;
			}

		}	else	{
			// finished sending articles
			cause = CAUSE_NODATA ;
		}
	}	

	ErrorTrace( (DWORD_PTR)this, "Error Occurred m_GroupidNext %x m_ArticleidNext %x",
			m_GroupidNext, m_ArticleidNext ) ;

	if( m_GroupidNext != INVALID_ARTICLEID && m_ArticleidNext != INVALID_ARTICLEID )
		pSocket->m_context.m_pOutFeed->Append( m_GroupidNext, m_ArticleidNext ) ;
	pdriver->UnsafeClose( pSocket, cause, dwError ) ;
	return	0 ;
}

CIO*
COfferArticles::Complete(	CIOReadLine*	pReadLine,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							int				cArgs,
							char**			pszArgs,
							char*			pchBegin ) {
/*++

Routine Description :

	This function handles read completions when we are in the COfferArticles state.
	We use m_fReadPostResult to determine whether we are expecting to see the result of
	a post or the result of a command we issued.
	When looking at the result of a transfer - check if the transfer failed and needs to
	be requeued.
	When looking at the result of a command - check whether we want to go ahead and
	send the next article.

Arguments :

	pReadLine -		The CIOReadLine object which is completing the read
	pSocket -		The CSessionSocket object associated with the socket.
	pdriver -		The CIODriver managing IO completions for this socket.
	cArgs -			Number of arguments in the response
	pszArgs -		Array of pointers to the response strings
	pchBegin -		first byte of the response that we can destructively
					use if we desire (we dont)

Return Value ;

	Always the same CIOReadLine that called us, unless an error occurred and
	we're tearing down the session - in which case we'll return NULL.

--*/


	TraceFunctEnter( "COfferArticles::Complete - CIOReadline" ) ;

	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;
	DWORD	dwError = 0 ;

	NRC	code ;
	if(	ResultCode( pszArgs[0], code ) )	{

		pSocket->m_context.m_nrcLast = code ;

		DebugTrace( (DWORD_PTR)this, "Result - %d m_fReadPostResult %x",
			code, m_fReadPostResult ) ;

		// if the code is from posting a article on the remote server then
		// increment the appropriate feed counter for this article
		if (m_fReadPostResult) {
			pSocket->m_context.m_pOutFeed->IncrementFeedCounter(code);
		}

		if( m_fReadPostResult || m_fTerminating ) {

			//
			//	Have completed the final read of an article transfer, or we're terminating -
			//	issue a transaction log if appropriate !
			//
			if( ((pSocket->m_context).m_pInstance)->GetCommandLogMask() & eOutPush ) {

				pSocket->m_Collector.m_cbBytesRecvd += pReadLine->GetBufferLen();

				char*	lpstr = (char*)pSocket->m_Collector.AllocateLogSpace( 64 ) ;
				if( lpstr ) {
					BuildCommandLogString( cArgs-1, pszArgs+1, lpstr, 64 ) ;
					pSocket->m_Collector.ReferenceLogData( LOG_TARGET, (BYTE*)lpstr ) ;
				}	else	{
					pSocket->m_Collector.FillLogData( LOG_TARGET, (BYTE*)pszArgs[0], 4 ) ;
				}

			}

			//
			//	We don't really care about the result of the post command !!!
			//
			m_fReadPostResult = FALSE ;


			//
			//	Figure out whether we were to retry this post later !
			//
			if( pSocket->m_context.m_pOutFeed->RetryPost( code ) ) {

				DebugTrace( (DWORD_PTR)this, "Retry post later - grpInProg %x ArtInProg %x",
					m_GroupidInProgress, m_ArticleidInProgress ) ;

				if( m_GroupidInProgress != INVALID_ARTICLEID && m_ArticleidInProgress != INVALID_ARTICLEID ) {
					pSocket->m_context.m_pOutFeed->Append( m_GroupidInProgress, m_ArticleidInProgress ) ;
					if( m_GroupidTriedOnce == INVALID_ARTICLEID && m_ArticleidTriedOnce == INVALID_ARTICLEID ) {
						m_GroupidTriedOnce = m_GroupidInProgress ;
						m_ArticleidTriedOnce = m_ArticleidInProgress ;

						DebugTrace( (DWORD_PTR)this, "TriedOnce Group %x Art %x", m_GroupidTriedOnce,
							m_ArticleidTriedOnce ) ;

					}
				}
			}
	
			//
			//	No article is being transferred right now !
			//
			m_GroupidInProgress = INVALID_ARTICLEID ;
			m_ArticleidInProgress = INVALID_ARTICLEID ;

			if( InterlockedIncrement( &m_cTransmitCompletions ) < 0 ) {

				return	0 ;

			}	else	{

				m_cTransmitCompletions = -2 ;

				if( m_fTerminating ) {

					cause = CAUSE_USERTERM ;

					//
					//	Check if we need to do this here ??
					//
					if( (pSocket->m_context.m_pInstance)->GetCommandLogMask() & eOutPush ) {
						pSocket->TransactionLog( &pSocket->m_Collector, FALSE ) ;
					}

				}	else	{

					CIOWriteLine*	pWriteLine = BuildWriteLine(	pSocket,
																	pdriver,
																	m_GroupidNext,
																	m_ArticleidNext ) ;
					if( pWriteLine != 0 ) {
						if( pdriver->SendWriteIO( pSocket,	*pWriteLine, TRUE ) ) {
			
							DebugTrace( (DWORD_PTR)this, "SendWriteIO succeeded" ) ;

							//
							//	Successfully issued IO log it to the transaction log
							//
							

							//
							//	Successfully issued the command - read the response !
							//

							return	pReadLine ;
						}	else	{

							//
							//	Session is dropping - blow off anything we allocated !
							//

							ErrorTrace( (DWORD_PTR)this, "SendWriteIO failed" ) ;

							CIO::Destroy( pWriteLine, *pdriver ) ;
						}
					}
				}
			}
			//
			//	fall through into error code which blows off session !
			//

		}	else	{


			if( code == 340 || code == 341 || code == 342 || code == 335 ) {
				m_fDoTransmit = TRUE ;
			}	else	{
				m_fDoTransmit = FALSE ;
				pSocket->m_context.m_pOutFeed->IncrementFeedCounter(code);
			}

			//
			//	Do we wish to log the first response to our command ?
			//
			if( ((pSocket->m_context).m_pInstance)->GetCommandLogMask() & eOutPush ) {

				pSocket->m_Collector.m_cbBytesRecvd += pReadLine->GetBufferLen();

				char*	lpstr = (char*)pSocket->m_Collector.AllocateLogSpace( 64 ) ;
				if( lpstr ) {
					BuildCommandLogString( cArgs-1, pszArgs+1, lpstr, 64 ) ;
					pSocket->m_Collector.ReferenceLogData( LOG_TARGET, (BYTE*)lpstr ) ;
				}	else	{
					pSocket->m_Collector.FillLogData( LOG_TARGET, (BYTE*)pszArgs[0], 4 ) ;
				}
			}

			//
			//	Build the appropriate response to transmit back to remote site !
			//
			CIO*	pio = Complete(	pSocket,	pdriver	) ;

			DebugTrace( (DWORD_PTR)this, "About to send pio %x", pio ) ;

			if( pio != 0 ) {
				if( pdriver->SendWriteIO( pSocket,	*pio, TRUE ) ) {
	
					DebugTrace( (DWORD_PTR)this, "SendWriteIO succeeded" ) ;

					return	pReadLine ;
				}	else	{

					ErrorTrace( (DWORD_PTR)this, "SendWriteIO failed" ) ;

					CIO::Destroy( pio, *pdriver ) ;
				}
			}	else	{
				return	0 ;
			}
		}
	}	else	{
		cause = CAUSE_ILLEGALINPUT ;
	}

	ErrorTrace( (DWORD_PTR)this, "Closing session - unusual termination" ) ;

	pdriver->UnsafeClose( pSocket, cause, dwError ) ;
	return	0 ;
}

CIO*
COfferArticles::Complete(	CIOWriteLine*	pWriteLine,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver )	{


	CIO*	pio = Complete( pSocket, pdriver ) ;

	if( pio == 0 ) {
		return	pio ;
	}	else	{
		CIOReadLine*	pReadLine = new( *pdriver )	CIOReadLine( this ) ;
		if( pReadLine != 0 ) {
			if( pdriver->SendReadIO( pSocket, *pReadLine, TRUE ) )	{
				return	pio ;
			}	else	{
				CIO::Destroy( pReadLine, *pdriver ) ;
			}
		}
	}
	if( pio != 0 ) {
		CIO::Destroy( pio, *pdriver ) ;
	}
	pdriver->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
	return	0 ;
}

CIO*
COfferArticles::Complete(	CIOTransmit*	pTransmit,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							TRANSMIT_FILE_BUFFERS*	ptrans,
							unsigned cbBytes )	{

	//
	//	Do we wish to log the first response to our command ?
	//
	if( ((pSocket->m_context).m_pInstance)->GetCommandLogMask() & eOutPush ) {

		ADDI( pSocket->m_Collector.m_cbBytesSent, cbBytes );

	}

	SHUTDOWN_CAUSE	cause = CAUSE_OOM ;

	CIOWriteLine*	pWriteLine = 0 ;

	if( InterlockedIncrement( &m_cTransmitCompletions ) == 0 ) {

		m_cTransmitCompletions = -2 ;

		if( m_fTerminating ) {

			cause = CAUSE_USERTERM ;

		}	else	{

			//
			//	Read completed first - we should not be waiting to read
			//	the response to the posted article any longer !
			//
			_ASSERT( !m_fReadPostResult ) ;

			pWriteLine = BuildWriteLine(	pSocket,
											pdriver,
											m_GroupidNext,
											m_ArticleidNext
											) ;
			if( pWriteLine != 0 ) {

				CIOReadLine*	pReadLine = new( *pdriver )	CIOReadLine( this ) ;
				if( pReadLine != 0 ) {
					if( pdriver->SendReadIO( pSocket, *pReadLine, TRUE ) )	{
						return	pWriteLine ;
					}	else	{
						CIO::Destroy( pReadLine, *pdriver ) ;
					}
				}
			}
		}

	}	else	{

		return	0 ;
	}

	//
	//	In case of error fall through to here !
	//

	if( pWriteLine != 0 )
		CIO::Destroy( pWriteLine, *pdriver ) ;

	pdriver->UnsafeClose( pSocket, cause, 0 ) ;
	return	0 ;

}

BOOL
CNegotiateStreaming::Start(	CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							CIORead*&		pRead,
							CIOWrite*&		pWrite
							)	{

	CIOWriteLine*	pWriteLine = new( *pdriver ) CIOWriteLine( this ) ;
	CIOReadLine*	pReadLine = new( *pdriver )	CIOReadLine( this ) ;
	if( pWriteLine && pReadLine ) {

		static	char	szModeStream[] = "mode stream\r\n" ;
		DWORD	cb = sizeof( szModeStream ) - 1 ;

		if( pWriteLine->InitBuffers( pdriver, cb ) ) {
			CopyMemory( pWriteLine->GetBuff(), szModeStream, cb ) ;
			pWriteLine->AddText(	cb) ;
			pWrite = pWriteLine ;
			pRead = pReadLine ;

			OutboundLogFill( pSocket, (LPBYTE)szModeStream, sizeof( szModeStream ) - 1 ) ;

			return	TRUE ;
		}
	}


	if( pWriteLine )
		CIO::Destroy( pWriteLine, *pdriver ) ;

	if( pReadLine )
		CIO::Destroy( pReadLine, *pdriver ) ;

	return	FALSE ;
}

CIO*
CNegotiateStreaming::Complete(	CIOReadLine*	pReadLine,
								CSessionSocket*	pSocket,
								CDRIVERPTR&		pdriver,
								int				cArgs,
								char**			pszArgs,
								char*			pchBegin	
								)	{

	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;
	NRC	code ;

	BOOL	fResult = ResultCode( pszArgs[0], code ) ;

	OutboundLogResults( pSocket,
						fResult,
						code,
						cArgs,
						pszArgs
						) ;

	if( fResult )	{

		if( code == nrcModeStreamSupported )	{

			m_fStreaming = TRUE ;

		}	else	{

			m_fStreaming = FALSE ;
		}

		if( InterlockedIncrement( &m_cCompletions ) < 0 ) {
	
			return	0 ;

		}	else	{

			CIORead*	pRead = 0 ;
			CIOWrite*	pWrite = 0 ;

			if( NextState( pSocket, pdriver, pRead, pWrite ) ) {
				if( pWrite != 0 ) {
					if( pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) )	{
						return	pRead ;
					}	else	{
						CIO::Destroy( pWrite, *pdriver ) ;
						if( pRead )
							CIO::Destroy( pRead, *pdriver ) ;
					}
				}	else	{
					return	pRead ;
				}
			}
		}

	}	else	{

		cause	= CAUSE_ILLEGALINPUT ;

	}

	pdriver->UnsafeClose( pSocket, cause, 0	) ;
	return	0 ;
}

CIO*
CNegotiateStreaming::Complete(	CIOWriteLine*	pWriteLine,
								CSessionSocket*	pSocket,
								CDRIVERPTR&		pdriver
								)	{

	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;


	if( InterlockedIncrement( &m_cCompletions ) < 0 ) {

		return	0 ;

	}	else	{

		CIORead*	pRead = 0 ;
		CIOWrite*	pWrite = 0 ;

		if( NextState( pSocket, pdriver, pRead, pWrite ) ) {
			if( pRead != 0 ) {
				if( pdriver->SendReadIO( pSocket, *pRead, TRUE ) )	{
					return	pWrite ;
				}	else	{
					CIO::Destroy( pRead, *pdriver ) ;
					if( pWrite )
						CIO::Destroy( pWrite, *pdriver ) ;
				}
			}	else	{
				return	pWrite ;
			}
		}
	}

	pdriver->UnsafeClose( pSocket, cause, 0	) ;
	return	0 ;
}

BOOL
CNegotiateStreaming::NextState(
								CSessionSocket*	pSocket,
								CDRIVERPTR&		pdriver,
								CIORead*&	pRead,
								CIOWrite*&	pWrite
								) {

	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	_ASSERT( pRead == 0 ) ;
	_ASSERT( pWrite == 0 ) ;

	CSTATEPTR	pState ;
	if( m_fStreaming ) {
		pState = new	CCheckArticles() ;		
	}	else	{
		pState = new	COfferArticles() ;
	}

	if( pState ) {

		if( pState->Start(	pSocket,
							pdriver,
							pRead,
							pWrite ) ) {
			return	TRUE ;
		}
	}
	return	FALSE ;
}

CStreamBase::CStreamBase()	:
	m_GroupIdRepeat( INVALID_GROUPID ),
	m_ArticleIdRepeat( INVALID_ARTICLEID ),
	m_fDrain( FALSE )	{
}

BOOL
CStreamBase::Remove(	CNewsTree*	pTree,
						COutFeed*	pOutFeed,
						GROUPID&	groupId,
						ARTICLEID&	articleId	
						) {

	_ASSERT( pOutFeed != 0 ) ;

	if( pTree->m_bStoppingTree )
		m_fDrain = TRUE ;

	if( !m_fDrain ) {

		if( pOutFeed->Remove(	groupId,
								articleId ) )	{

			if( groupId == INVALID_GROUPID ||
				articleId == INVALID_ARTICLEID ) {

				m_fDrain = TRUE ;

			}	else	{

				if( groupId == m_GroupIdRepeat &&
					articleId == m_ArticleIdRepeat ) {
					
					m_fDrain = TRUE ;
					pOutFeed->Append( groupId, articleId ) ;
				}	else	{
					return	TRUE ;
				}
			}
		}	else	{

			m_fDrain = TRUE ;

		}
	}

	groupId = INVALID_GROUPID ;
	articleId = INVALID_ARTICLEID ;
	return	FALSE ;
}	



CIOWriteLine*
CStreamBase::BuildQuit(	CDRIVERPTR&	pdriver	)	{

	//
	//	Send the quit command !!!
	//
	static	char	szQuit[] = "quit\r\n" ;

	CIOWriteLine*	pWrite = new( *pdriver ) CIOWriteLine( this ) ;

	if( pWrite && pWrite->InitBuffers( pdriver, sizeof( szQuit ) ) ) {
		CopyMemory( pWrite->GetBuff(), szQuit, sizeof( szQuit ) -1  ) ;
		pWrite->AddText(	sizeof( szQuit ) - 1) ;

		return	pWrite ;
	}
	if( pWrite != 0 )
		CIO::Destroy( pWrite, *pdriver ) ;

	return	0 ;	
}

void
CStreamBase::ReSend(	COutFeed*	pOutFeed,
						GROUPID		groupId,
						ARTICLEID	articleId
						)	{

	_ASSERT( pOutFeed != 0 ) ;
	_ASSERT( groupId != INVALID_GROUPID ) ;
	_ASSERT( articleId != INVALID_ARTICLEID ) ;

	if( m_GroupIdRepeat == INVALID_GROUPID &&
		m_ArticleIdRepeat == INVALID_ARTICLEID ) {

		m_GroupIdRepeat = groupId ;
		m_ArticleIdRepeat = articleId ;

	}

	pOutFeed->Append( groupId, articleId ) ;
}
								

CCheckArticles::CCheckArticles()	:
	m_cChecks( 0 ),
	m_iCurrentCheck( 0 ),
	m_cSends( 0 ),
	m_iCurrentSend( 0 ),
	m_fDoingChecks( FALSE )	{

	for( int i=0; i<16; i++ ) {
		m_artrefCheck[i].m_groupId = INVALID_GROUPID ;
		m_artrefCheck[i].m_articleId = INVALID_ARTICLEID ;

		m_artrefSend[i].m_groupId = INVALID_GROUPID ;
		m_artrefSend[i].m_articleId = INVALID_ARTICLEID ;
	}
}


CCheckArticles::CCheckArticles(
		CArticleRef*	pArticleRef,
		DWORD			cSent
		) :
	m_fDoingChecks( FALSE ),
	m_cSends( cSent ),
	m_iCurrentSend( 0 ),
	m_cChecks( 0 ),
	m_iCurrentCheck( 0 )	{


	for( int i=0; i<16; i++ ) {
		m_artrefCheck[i].m_groupId = INVALID_GROUPID ;
		m_artrefCheck[i].m_articleId = INVALID_ARTICLEID ;

		m_artrefSend[i].m_groupId = INVALID_GROUPID ;
		m_artrefSend[i].m_articleId = INVALID_ARTICLEID ;
	}

	_ASSERT( cSent < 16 ) ;

	if( cSent != 0 )
		CopyMemory( &m_artrefSend[0], pArticleRef, sizeof( CArticleRef ) * min( cSent, 16 ) ) ;
}


BOOL
CCheckArticles::FillCheckBuffer(
					CNewsTree*		pTree,
					COutFeed*		pOutFeed,
					BYTE*			lpb,
					DWORD			cb
					)	{

	_ASSERT( pOutFeed != 0 ) ;
	_ASSERT( lpb !=  0 ) ;
	_ASSERT( cb != 0 ) ;

	DWORD	i = 0 ;
	m_mlCheckCommands.m_cEntries = 0 ;

	do	{	

		BOOL	fRemove = Remove(
							pTree,
							pOutFeed,
							m_artrefCheck[i].m_groupId,
							m_artrefCheck[i].m_articleId
							) ;

		if( !fRemove ||
			m_artrefCheck[i].m_groupId == INVALID_GROUPID ||
			m_artrefCheck[i].m_articleId == INVALID_ARTICLEID )	{
			break ;
		}

		DWORD	cbOut = pOutFeed->FormatCheckCommand(
								lpb + m_mlCheckCommands.m_ibOffsets[i],
								cb - m_mlCheckCommands.m_ibOffsets[i],
								m_artrefCheck[i].m_groupId,
								m_artrefCheck[i].m_articleId
								) ;

		if( cbOut == 0 ) {
			if( GetLastError() != ERROR_FILE_NOT_FOUND ) {
				ReSend(	pOutFeed,
						m_artrefCheck[i].m_groupId,
						m_artrefCheck[i].m_articleId
						) ;
				m_artrefCheck[i].m_groupId =  INVALID_GROUPID ;
				m_artrefCheck[i].m_articleId = INVALID_ARTICLEID ;
			}
		}	else	{
			m_mlCheckCommands.m_ibOffsets[i+1] =
				m_mlCheckCommands.m_ibOffsets[i]+cbOut ;
			cb -= cbOut ;
			i++ ;
			m_mlCheckCommands.m_cEntries = i ;
		}
	}	while(	cb > 20 && i < 16 ) ;

	return	i != 0 ;
}



CIOTransmit*
CStreamBase::NextTransmit(	GROUPID			GroupId,
							ARTICLEID		ArticleId,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							CTOCLIENTPTR&		pArticle
							)	{
				
	DWORD	cbOut = 0 ;
	SetLastError( NO_ERROR ) ;

	CIOTransmit*	pTransmit =		new( *pdriver )	CIOTransmit( this ) ;
	CBUFPTR	pbuffer = (pTransmit != 0) ? pdriver->AllocateBuffer( cbMediumBufferSize ) : 0 ;

	if( pbuffer != 0 ) {

		_ASSERT( pTransmit != 0 ) ;

		DWORD	ibStart = 0 ;
		DWORD	cbLength = 0 ;
		//LPTS_OPEN_FILE_INFO		pOpenFile ;

		FIO_CONTEXT*	pFIOContext = 0 ;

		cbOut =
			pSocket->m_context.m_pOutFeed->FormatTakethisCommand(
											(BYTE*)&pbuffer->m_rgBuff[0],
											pbuffer->m_cbTotal,
											GroupId,
											ArticleId,
											pArticle
											) ;

		if( cbOut != 0 ) {

			_ASSERT( pArticle != 0 ) ;

			FIO_CONTEXT*	pFIOContext = 0 ;

			if( (pFIOContext = pArticle->fWholeArticle( ibStart, cbLength )) != 0  ) {
				if( pTransmit->Init(	pdriver,
									pFIOContext,
									ibStart,
									cbLength,
									pbuffer,
									0,
									cbOut ) )	{
					return	pTransmit ;
				}
			}
		}	
	}

	//
	//	If for some reason we have not
	//	built a pTransmit Object to send then we need
	//	to requeue the article !
	//

	if( GetLastError() != ERROR_FILE_NOT_FOUND ) {

		ReSend(	pSocket->m_context.m_pOutFeed,
				GroupId,
				ArticleId
				) ;

	}

	if( pTransmit )
		CIO::Destroy( pTransmit, *pdriver ) ;
	
	return	0 ;
}



CIOWrite*
CCheckArticles::InternalStart(	
						CSessionSocket*	pSocket,
						CDRIVERPTR&		pdriver
						) {

	CIOWrite*	pWrite = 0 ;

	if( m_mlCheckCommands.m_pBuffer == 0 )	{
		m_mlCheckCommands.m_pBuffer =	
			pdriver->AllocateBuffer( cbMediumBufferSize ) ;
	}

	if( m_mlCheckCommands.m_pBuffer ) {

		CNewsTree* pTree = ((pSocket->m_context).m_pInstance)->GetTree() ;

		if( FillCheckBuffer(
						pTree,	
						pSocket->m_context.m_pOutFeed,
						(BYTE*)&m_mlCheckCommands.m_pBuffer->m_rgBuff[0],
						m_mlCheckCommands.m_pBuffer->m_cbTotal
						) ) {

			_ASSERT( m_mlCheckCommands.m_cEntries != 0 ) ;
			_ASSERT( m_mlCheckCommands.m_cEntries <= 16 ) ;

			m_cChecks = m_mlCheckCommands.m_cEntries ;

			pWrite = new( *pdriver ) CIOMLWrite(
											this,
											&m_mlCheckCommands,
											TRUE,
											0
											) ;
		}
	}
	return	pWrite ;
}


BOOL
CCheckArticles::Start(	
						CSessionSocket*	pSocket,
						CDRIVERPTR&		pdriver,
						CIORead*&		pRead,
						CIOWrite*&		pWrite
						) {

	pRead = 0 ;
	pWrite = 0 ;

	_ASSERT( m_iCurrentCheck == 0 ) ;
	_ASSERT( m_cChecks == 0 ) ;

	m_iCurrentCheck = 0 ;
	m_cChecks = 0 ;

	if( m_cSends == 0 ) {

		m_fDoingChecks = TRUE ;

	}	else	{

		m_fDoingChecks = FALSE ;

	}

	pWrite = InternalStart(	pSocket,
							pdriver
							) ;
	
	return	pWrite != 0 ;
}




int
CCheckArticles::Match(	char*	szMessageId,
						DWORD	cb ) {

	//
	//	Match up the response with the request block !
	//
	DWORD	cbMessageId = lstrlen( szMessageId ) ;
	int		iCheck = m_iCurrentCheck ;
	for( DWORD	i=0; i != 16; i++ ) {

		iCheck = (iCheck + i) % 16 ;

		BYTE*	lpbCheck = m_mlCheckCommands.Entry(iCheck) + cb ;
		DWORD	cbCheck = (DWORD)(m_mlCheckCommands.Entry(iCheck+1) - lpbCheck - 2) ;
	
		if( cbCheck == cbMessageId &&
			memcmp( lpbCheck, szMessageId, cbCheck ) == 0 ) {
			return	iCheck ;
		}
	}
	return	-1 ;
}

CIO*
CCheckArticles::Complete(	CIOWriteLine*	pWriteLine,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver
							)	{

	//
	//	All done - drop session !
	//

	OutboundLogAll(	pSocket,
			FALSE,
			NRC(0),
			0,
			0,
			"quit"
			) ;

	pdriver->UnsafeClose( pSocket, CAUSE_NODATA, 0	) ;
	return	0 ;
}

CIO*
CCheckArticles::Complete(	CIOReadLine*	pReadLine,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							int				cArgs,
							char**			pszArgs,
							char*			pchBegin
							)	{

	NRC	code ;
	BOOL	fCode = ResultCode( pszArgs[0], code ) ;
	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;

	CIO*		pReturn = pReadLine ;
	CIOTransmit*	pTransmit = 0 ;
	
	if( m_fDoingChecks ) {

		OutboundLogAll(	pSocket,
						fCode,
						code,
						cArgs,
						pszArgs,
						"check"
						) ;
		
		int	iMatch = DWORD(m_iCurrentCheck) ;
	
		if( cArgs >= 2 ) {
			iMatch = Match( pszArgs[1],
							pSocket->m_context.m_pOutFeed->CheckCommandLength() ) ;
		}	else	{
			iMatch = m_iCurrentCheck ;
		}

        // fix bug 33350: Its possible for remote to send 238 <junk-msg-id>
        // in which case Match fails and we hit this assert. However, this
        // is harmless and so it is better to not assert.
		// _ASSERT( iMatch == m_iCurrentCheck || pszArgs[1][0] != '<' ) ;
		iMatch = m_iCurrentCheck ;

		if( fCode )	{


			//
			//	Advance the counter of the check response we are waiting for for the next
			//	read to complete !
			//
			m_iCurrentCheck ++ ;

			if( m_iCurrentCheck == m_cChecks )	{
				//
				//	Reset the number of checks we are doing !
				//
				m_cChecks = 0 ;
				m_fDoingChecks = FALSE ;
				m_iCurrentCheck = 0 ;

			}

			_ASSERT( m_artrefCheck[iMatch].m_groupId != INVALID_GROUPID ) ;
			_ASSERT( m_artrefCheck[iMatch].m_articleId != INVALID_ARTICLEID ) ;

			if( code == nrcSWantArticle )	{

				pTransmit =
					NextTransmit(	m_artrefCheck[iMatch].m_groupId,
									m_artrefCheck[iMatch].m_articleId,
									pSocket,
									pdriver,
									m_pArticle
									) ;

				if( pTransmit ) {

					m_artrefSend[m_cSends].m_groupId = m_artrefCheck[iMatch].m_groupId ;
					m_artrefSend[m_cSends].m_articleId = m_artrefCheck[iMatch].m_articleId ;
					m_artrefCheck[iMatch].m_groupId = INVALID_GROUPID ;
					m_artrefCheck[iMatch].m_articleId = INVALID_ARTICLEID ;


					m_cSends ++ ;
					if( pdriver->SendWriteIO( pSocket, *pTransmit, TRUE ) ) {
						return	0 ;
					}	else	{
						m_cSends -- ;
						CIO::Destroy( pTransmit, *pdriver ) ;
						pdriver->UnsafeClose( pSocket, cause, 0 ) ;
						return	0 ;
					}

				}	else	{

					//pdriver->UnsafeClose( pSocket, cause, 0 ) ;
					//return	0 ;

					//
					//	In this case - just fall through !
					//	NOTE: NextTransmit() will requeue the article
					//	for later transmission if appropriate !
					//
				}


			}	else	if( code == nrcSTryAgainLater	)	{

				pSocket->m_context.m_pOutFeed->IncrementFeedCounter(code);

				ReSend(	pSocket->m_context.m_pOutFeed,
						m_artrefCheck[iMatch].m_groupId,
						m_artrefCheck[iMatch].m_articleId
						) ;

				m_artrefCheck[iMatch].m_articleId = INVALID_ARTICLEID ;
				m_artrefCheck[iMatch].m_groupId = INVALID_GROUPID ;

			}	else	if( code == nrcSNotAccepting || code != nrcSAlreadyHaveIt ) {

				pSocket->m_context.m_pOutFeed->IncrementFeedCounter(code);

				pdriver->UnsafeClose( pSocket, cause, 0 ) ;
				return	 0 ;

			}	else	{

				//
				//	This is the only other thing we should see here !
				//

				_ASSERT( code == nrcSAlreadyHaveIt ) ;

				pSocket->m_context.m_pOutFeed->IncrementFeedCounter(code);

				m_artrefCheck[iMatch].m_articleId = INVALID_ARTICLEID ;
				m_artrefCheck[iMatch].m_groupId = INVALID_GROUPID ;

			}
		
			//
			//	Here we are - did we ever send something to the remote side !
			//
			_ASSERT( m_iCurrentSend == 0 ) ;
		
			
			//
			//	We arrive here iff the remote server rejected an article we had offered through
			//	a check command !
			//


			if( m_fDoingChecks ) {
				//
				//	FALL Through into error handling which terminates session !
				//	
				return	pReturn ;

			}	else	{

				//
				//	State should have benn reset already !
				//
				_ASSERT( m_cChecks == 0 ) ;
				_ASSERT( m_iCurrentCheck == 0 ) ;

				//
				//	Do we continue in this state or can we go directly into
				//	a takethis only state !?
				//	
				if( m_cSends != 16 ) {

					if( m_cSends == 0 ) {
						m_fDoingChecks = TRUE ;
					}

					//
					//	Remain in this state - Note that there are responses
					//	to m_cSends 'takethis' commands that need to be collected !
					//

					//
					//	Fire off the next bunch of check commands -
					//	then let the write completions queue the
					//	necessary reads to collect all the takethis responses !
					//

					CIOWrite*	pWrite = InternalStart(	pSocket, pdriver ) ;

					//
					//	We should transmit a file if we have one lined up !
					//
					if( pWrite ) {

						//
						//	Verify our state !
						//
						_ASSERT( m_cChecks != 0 ) ;
						_ASSERT( m_iCurrentCheck == 0 ) ;
						//_ASSERT( !m_fDoingChecks ) ;
	
						if( pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) ) {
							return	0 ;
						}	else	{
							CIO::Destroy( pWrite, *pdriver ) ;
						}
					}	else	{


						//
						//	If we are doing checks then not having a Write Command
						//	should fall through into our error termination
						//

						if( !m_fDoingChecks ) {
							return	pReadLine ;
						}	else	{

							//
							//	No Data left to send - send a quit command !
							//
							pWrite = BuildQuit( pdriver ) ;
							if( pWrite ) {
								if( pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) )	{
									return	0 ;
								}	else	{
									CIO::Destroy( pWrite, *pdriver ) ;
								}
							}
							cause = CAUSE_NODATA ;
						}
					}
				}	else	{


					//
					//	We should initialize a 'takethis' only state now
					//	with the understanding that there are 16 takethis responses
					//	that need to be collected !!
					//
					CIOWrite*	pWrite = 0 ;
					CIORead*	pRead = 0 ;
					if( NextState(	pSocket,
									pdriver,
									pRead,
									pWrite	) )	{

						if( pWrite != 0 ) {
							if( pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) )	{
								return	pRead ;
							}	else	{
								if( pRead != 0 )
									CIO::Destroy( pRead, *pdriver ) ;
								CIO::Destroy( pWrite, *pdriver ) ;
							}
						}	else	{
							return	pRead;
						}
					}
				}
			}
		}
	}	else	{

		OutboundLogAll(	pSocket,
				fCode,
				code,
				cArgs,
				pszArgs,
				"takethis"
				) ;



		//
		//	Do we have a legal NNTP return code ??
		//
		if( fCode ) {

			//
			// increment the appropriate counter
			//
			pSocket->m_context.m_pOutFeed->IncrementFeedCounter(code);

			//
			//	Do we need to resubmit the article for any reason !
			//
			if( code == nrcSTryAgainLater ||
				(code != nrcSTransferredOK && code != nrcSArticleRejected) ) {

				ReSend(	pSocket->m_context.m_pOutFeed,
						m_artrefSend[m_iCurrentSend].m_groupId,
						m_artrefSend[m_iCurrentSend].m_articleId
						) ;

			} else {
			    // We have successfully transmitted the article.  If this
			    // came from _slavegroup, then we can delete the article.
			    CNewsTreeCore* pTree = ((pSocket->m_context).m_pInstance)->GetTree();
			    if (m_artrefSend[m_iCurrentSend].m_groupId == pTree->GetSlaveGroupid()) {
			        DeleteArticleById(pTree, 
			            m_artrefSend[m_iCurrentSend].m_groupId,
			            m_artrefSend[m_iCurrentSend].m_articleId);
			    }

			}

			//
			//	NIL this out so that Shutdown() does not unnecessarily requeue articles !
			//
			m_artrefSend[m_iCurrentSend].m_groupId = INVALID_GROUPID ;
			m_artrefSend[m_iCurrentSend].m_articleId = INVALID_ARTICLEID ;

			//
			//	Whats the next Send we're waiting for ??
			//
			m_iCurrentSend ++ ;

			if( m_iCurrentSend == m_cSends ) {

				m_iCurrentSend = 0 ;
				m_cSends = 0 ;
				m_fDoingChecks = TRUE ;

				if( m_cChecks == 0 ) {

					//
					//	No Data left to send - send a quit command !
					//
					CIOWrite*	pWrite = BuildQuit( pdriver ) ;
					if( pWrite ) {
						if( !pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) )	{
							CIO::Destroy( pWrite, *pdriver ) ;
							pdriver->UnsafeClose( pSocket, CAUSE_NODATA, 0 ) ;
							return	0 ;
						}	else	{
							return	0 ;
						}
					}
				}
			}	

			return	pReadLine ;
		}	
		//
		//	else Case falls through and terminates session !
		//
	}
	pdriver->UnsafeClose( pSocket, cause, 0	) ;
	return	0 ;
}

CIO*
CCheckArticles::Complete(	CIOMLWrite*	pWrite,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver
							) {

	_ASSERT( m_cChecks != 0 ) ;
	_ASSERT( m_iCurrentCheck == 0 ) ;
	
	CIOReadLine*	pReadLine = new( *pdriver ) 	CIOReadLine( this ) ;

	if( pdriver->SendReadIO( pSocket, *pReadLine, TRUE ) ) {
		return	0 ;
	}	else	{
		CIO::Destroy( pReadLine, *pdriver ) ;
	}
		
	//
	//	Fall through to fatal error handling code - drop the session !
	//
	pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
	return	0 ;		
}

CIO*
CCheckArticles::Complete(	CIOTransmit*	pTransmit,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							TRANSMIT_FILE_BUFFERS*,
							unsigned
							) {

	_ASSERT( m_pArticle != 0 ) ;
	_ASSERT( m_cSends != 0 ) ;

	m_pArticle = 0 ;

	if( m_fDoingChecks ) {
		//
		//	FALL Through into error handling which terminates session !
		//	
		CIOReadLine*	pReadLine = new( *pdriver ) 	CIOReadLine( this ) ;
		if( pdriver->SendReadIO( pSocket, *pReadLine, TRUE ) ) {
			return	0 ;
		}	else	{
			CIO::Destroy( pReadLine, *pdriver ) ;
		}

	}	else	{

		//
		//	State should have benn reset already !
		//
		_ASSERT( m_cChecks == 0 ) ;
		_ASSERT( m_iCurrentCheck == 0 ) ;

		//
		//	Do we continue in this state or can we go directly into
		//	a takethis only state !?
		//	
		if( m_cSends != 16 ) {
			//
			//	Remain in this state - Note that there are responses
			//	to m_cSends 'takethis' commands that need to be collected !
			//

			//
			//	Fire off the next bunch of check commands -
			//	then let the write completions queue the
			//	necessary reads to collect all the takethis responses !
			//

			CIOWrite*	pWrite = InternalStart(	pSocket, pdriver ) ;

			//
			//	We should transmit a file if we have one lined up !
			//
			if( pWrite ) {

				//
				//	Verify our state !
				//
				_ASSERT( m_cChecks != 0 ) ;
				_ASSERT( m_iCurrentCheck == 0 ) ;
				_ASSERT( !m_fDoingChecks ) ;
				return	pWrite ;

			}	else	{
				CIOReadLine*	pReadLine = new( *pdriver ) 	CIOReadLine( this ) ;
				if( pdriver->SendReadIO( pSocket, *pReadLine, TRUE ) ) {
					return	0 ;
				}	else	{
					CIO::Destroy( pReadLine, *pdriver ) ;
				}
			}

		}	else	{


			CIOWrite*	pWrite = 0 ;
			CIORead*	pRead = 0 ;
			if( NextState(	pSocket,
							pdriver,
							pRead,
							pWrite	) )	{

				if( pRead != 0 ) {
					if( pdriver->SendReadIO( pSocket, *pRead, TRUE ) )	{
						return	pWrite ;
					}	else	{
						CIO::Destroy( pRead, *pdriver ) ;
						if( pWrite )
							CIO::Destroy( pWrite, *pdriver ) ;
					}
				}	else	{
					return	pWrite ;
				}
			}
		}
	}

		
	//
	//	Fall through to fatal error handling code - drop the session !
	//
	pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
	return	0 ;		
}

void
CCheckArticles::Shutdown(	CIODriver&	driver,
							CSessionSocket*	pSocket,
							SHUTDOWN_CAUSE	cause,
							DWORD	dw )	{


	for( int i=0; i<16; i++ ) {
	
		if( m_artrefCheck[i].m_groupId != INVALID_GROUPID &&
			m_artrefCheck[i].m_articleId != INVALID_ARTICLEID ) {

			ReSend(	pSocket->m_context.m_pOutFeed,
					m_artrefCheck[i].m_groupId,
					m_artrefCheck[i].m_articleId
					) ;
		}

		if(	m_artrefSend[i].m_groupId != INVALID_GROUPID &&
			m_artrefSend[i].m_articleId != INVALID_ARTICLEID )	{

			ReSend(	pSocket->m_context.m_pOutFeed,
					m_artrefSend[i].m_groupId,
					m_artrefSend[i].m_articleId
					) ;

		}
	}
}

BOOL
CCheckArticles::NextState(	CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							CIORead*&		pRead,
							CIOWrite*&		pWrite
							)	{


	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	_ASSERT( pRead == 0 ) ;
	_ASSERT( pWrite == 0 ) ;
	_ASSERT( m_cSends != 0 ) ;
	_ASSERT( m_artrefSend[0].m_groupId != INVALID_GROUPID ) ;
	_ASSERT( m_artrefSend[0].m_articleId != INVALID_ARTICLEID ) ;

	CSTATEPTR	pState =	new	CStreamArticles(
									m_artrefSend,
									m_cSends
									) ;

	if( pState ) {

		if( pState->Start(	pSocket,
							pdriver,
							pRead,
							pWrite
							)	)	{
			return	TRUE ;

		}
	}
	return	FALSE ;
}


CStreamArticles::CStreamArticles(	CArticleRef*	pSent,
									DWORD			cSent ) :

	m_cSends( cSent ),
	m_cFailedTransfers( 0 ),
	m_cConsecutiveFails( 0 ),
	m_TotalSends( 0 )	{

	
	for( int i=0; i<16; i++ ) {

		m_artrefSend[i].m_groupId = INVALID_GROUPID ;
		m_artrefSend[i].m_articleId = INVALID_ARTICLEID ;

	}

	_ASSERT( cSent == 16 ) ;

	CopyMemory( &m_artrefSend, pSent, sizeof( CArticleRef ) * min( cSent, 16 ) ) ;
}

CIOTransmit*
CStreamArticles::Next(	CSessionSocket*	pSocket,
						CDRIVERPTR&		pdriver
						) {

	COutFeed*	pOutFeed = pSocket->m_context.m_pOutFeed ;
	CIOTransmit*	pTransmit = 0 ;

	_ASSERT( m_cSends < 16 ) ;

	do	{

		CNewsTree* pTree = ((pSocket->m_context).m_pInstance)->GetTree() ;

		BOOL	fRemove = Remove(
							pTree,
							pOutFeed,
							m_artrefSend[m_cSends].m_groupId,
							m_artrefSend[m_cSends].m_articleId
							) ;

		if( !fRemove ||
			m_artrefSend[m_cSends].m_groupId == INVALID_GROUPID ||
			m_artrefSend[m_cSends].m_articleId == INVALID_ARTICLEID )	{
			break ;
		}

		pTransmit = NextTransmit(	m_artrefSend[m_cSends].m_groupId,
									m_artrefSend[m_cSends].m_articleId,
									pSocket,
									pdriver
									) ;

	}	while( pTransmit == 0 ) ;


	//
	//	NextTransmit will requeue the article if appropriate -
	//	no need for us to do so !
	//

	if( pTransmit != 0 ) {

		m_cSends ++ ;

	}
	return	pTransmit ;
}

CIOTransmit*
CStreamArticles::NextTransmit(	GROUPID			GroupId,
								ARTICLEID		ArticleId,
								CSessionSocket*	pSocket,
								CDRIVERPTR&		pdriver
								)	{
				

	CIOTransmit*	pTransmit =		new( *pdriver )	CIOTransmit( this ) ;
	CBUFPTR	pbuffer = pdriver->AllocateBuffer( cbMediumBufferSize ) ;
	if( pTransmit == 0 || pbuffer == 0 ) {

		if( pTransmit != 0 )
			CIO::Destroy(	pTransmit, *pdriver ) ;

		return	0 ;
	}


	DWORD	ibStart = 0 ;
	DWORD	cbLength = 0 ;
	//LPTS_OPEN_FILE_INFO		pOpenFile ;


	DWORD	cbOut =
		pSocket->m_context.m_pOutFeed->FormatTakethisCommand(
										(BYTE*)&pbuffer->m_rgBuff[0],
										pbuffer->m_cbTotal,
										GroupId,
										ArticleId,
										m_pArticle
										) ;

	if( cbOut != 0 ) {

		_ASSERT( m_pArticle != 0 ) ;
		FIO_CONTEXT*	pFIOContext = 0 ;

		if( (pFIOContext = m_pArticle->fWholeArticle( ibStart, cbLength )) != 0  ) {

			if( pTransmit->Init(	pdriver,
								pFIOContext,
								ibStart,
								cbLength,
								pbuffer,
								0,
								cbOut ) )	{
				return	pTransmit ;
			}
		}
	}	

	//
	//	If for some reason we have not
	//	built a pTransmit Object to send then we need
	//	to requeue the article !
	//

	if( cbOut != 0 ||
		GetLastError() != ERROR_FILE_NOT_FOUND ) {

		ReSend(	pSocket->m_context.m_pOutFeed,
				GroupId,
				ArticleId
				) ;

	}

	if( pTransmit )
		CIO::Destroy( pTransmit, *pdriver ) ;
	
	return	0 ;
}


BOOL
CStreamArticles::Start(	CSessionSocket*	pSocket,
						CDRIVERPTR&		pdriver,
						CIORead*&		pRead,
						CIOWrite*&		pWrite )	{

	_ASSERT( pRead == 0 ) ;
	_ASSERT( pWrite == 0 ) ;

	pRead = 0 ;
	pWrite = 0 ;

	if( m_cSends < 16 ) {

		pWrite = Next( pSocket, pdriver ) ;	
	
		return	pWrite != 0 ;

	}	else	{

		pRead = new( *pdriver )	 CIOReadLine( this ) ;
		return	pRead != 0 ;

	}
}


CIO*
CStreamArticles::Complete(	CIOWriteLine*	pWriteLine,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver
							)	{

	//
	//	All done - drop session !
	//

	OutboundLogAll(	pSocket,
			FALSE,
			NRC(0),
			0,
			0,
			"quit"
			) ;

	pdriver->UnsafeClose( pSocket, CAUSE_NODATA, 0	) ;
	return	0 ;
}


CIO*
CStreamArticles::Complete(	CIOReadLine*	pReadLine,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							int				cArgs,
							char**			pszArgs,
							char*			pchBegin
							)	{


	NRC	code ;
	BOOL	fCode = ResultCode( pszArgs[0], code ) ;
	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;

	CIO*		pReturn = pReadLine ;
	CIOTransmit*	pTransmit = 0 ;

	OutboundLogAll(	pSocket,
		fCode,
		code,
		cArgs,
		pszArgs,
		"takethis"
		) ;

	//
	//	Do we have a legal NNTP return code ??
	//
	if( fCode ) {

		//
		//
		//
		_ASSERT(	m_artrefSend[0].m_groupId != INVALID_GROUPID &&
					m_artrefSend[0].m_articleId != INVALID_ARTICLEID ) ;		


		m_TotalSends ++ ;

		//
		// increment the appropriate feed counter
		//
		pSocket->m_context.m_pOutFeed->IncrementFeedCounter(code);

		//
		//	Do we need to resubmit the article for any reason !
		//
		if( code == nrcSTryAgainLater ||
			(code != nrcSTransferredOK && code != nrcSArticleRejected) ) {

			m_cFailedTransfers ++ ;
			m_cConsecutiveFails ++ ;

			ReSend(	pSocket->m_context.m_pOutFeed,
					m_artrefSend[0].m_groupId,
					m_artrefSend[0].m_articleId
					) ;

		}	else	if( code == nrcSTransferredOK ) {

			CNewsTreeCore* pTree = ((pSocket->m_context).m_pInstance)->GetTree();
			if (m_artrefSend[0].m_groupId == pTree->GetSlaveGroupid()) {
			    DeleteArticleById(pTree, 
			        m_artrefSend[0].m_groupId,
			        m_artrefSend[0].m_articleId);
			}

			m_cConsecutiveFails = 0 ;

		}	else	{

			m_cFailedTransfers ++ ;
			m_cConsecutiveFails ++ ;

		}
			

		MoveMemory( &m_artrefSend[0], &m_artrefSend[1], sizeof( m_artrefSend[0] ) * 15 ) ;
		m_artrefSend[15].m_groupId = INVALID_GROUPID ;
		m_artrefSend[15].m_articleId = INVALID_ARTICLEID ;
		
		m_cSends -- ;

		if( m_cConsecutiveFails == 3 ||
			(((m_cFailedTransfers * 10) > m_TotalSends) && m_TotalSends > 20))	{

			//	
			//	Switch to the other state !
			//
			CSTATEPTR	pState =	new	CCheckArticles(
												m_artrefSend,
												m_cSends
												) ;

			if( pState ) {

				CIOWrite*	pWrite = 0 ;
				CIORead*	pRead = 0 ;
				if( pState->Start(	pSocket,
									pdriver,
									pRead,
									pWrite ) )	{

					if( pWrite != 0 ) {
						if( pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) ) {
							return	pRead ;
						}	else	{
							CIO::Destroy( pWrite, *pdriver ) ;
							if( pRead != 0 )
								CIO::Destroy( pRead, *pdriver ) ;
						}
					}	else	{
						return	pRead ;
					}
				}

			}	else	{

				if( m_cSends != 0 )	{
					return	pReadLine ;
				}
			}

		}	else	{

			pTransmit = Next(	pSocket, pdriver ) ;

			if( pTransmit ) {
				if( pdriver->SendWriteIO( pSocket, *pTransmit, TRUE ) ) {
					return	 0 ;
				}	else	{
					CIO::Destroy( pTransmit, *pdriver ) ;
				}
			}	else	{

				if( m_cSends != 0 ) {
					return	pReadLine ;
				}	else	{

					//
					//	No more data to send or receive - send quit command and
					//	drop session !
					//
					CIOWrite*	pWrite = BuildQuit( pdriver ) ;
					if( pWrite ) {
						if( pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) ) {
							return 0 ;
						}	else	{
							CIO::Destroy( pWrite, *pdriver ) ;
						}
					}
				}
			}
		}
	}	
	//
	//	else Case falls through and terminates session !
	//
	pdriver->UnsafeClose( pSocket, cause, 0	) ;
	return	0 ;
}

CIO*
CStreamArticles::Complete(	CIOTransmit*	pTransmit,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							TRANSMIT_FILE_BUFFERS*,
							unsigned
							) {

	_ASSERT( m_pArticle != 0 ) ;
	_ASSERT( m_cSends != 0 ) ;

	m_pArticle = 0 ;

	CIOReadLine*	pReadLine = new( *pdriver ) 	CIOReadLine( this ) ;
	if( pdriver->SendReadIO( pSocket, *pReadLine, TRUE ) ) {
		return	0 ;
	}	else	{
		CIO::Destroy( pReadLine, *pdriver ) ;
	}
		
	//
	//	Fall through to fatal error handling code - drop the session !
	//
	pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
	return	0 ;		
}


void
CStreamArticles::Shutdown(	CIODriver&	driver,
							CSessionSocket*	pSocket,
							SHUTDOWN_CAUSE	cause,
							DWORD	dw
							)	{


	for( int i=0; i<16; i++ ) {
	
		if(	m_artrefSend[i].m_groupId != INVALID_GROUPID &&
			m_artrefSend[i].m_articleId != INVALID_ARTICLEID )	{

			ReSend(	pSocket->m_context.m_pOutFeed,
					m_artrefSend[i].m_groupId,
					m_artrefSend[i].m_articleId
					) ;

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\svcadm.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    svcadm.cpp

Abstract:

    This module contains code for doing admin stuff

Author:

    Johnson Apacible (JohnsonA)     12-Jan-1995

Revision History:

--*/

#define INCL_INETSRV_INCS
#include "tigris.hxx"
#include "nntpsvc.h"

void
LogAdminEvent(	
		IN PNNTP_SERVER_INSTANCE pInstance,
		IN LPI_NNTP_CONFIG_INFO pConfig
		)	;


NET_API_STATUS
NET_API_FUNCTION
NntprSetAdminInformation(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    IN LPI_NNTP_CONFIG_INFO pConfig,
    OUT LPDWORD pParmError OPTIONAL
    )
{
    APIERR err = NERR_Success;

	BOOL	fRtn = TRUE ;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    ENTER("NntprSetAdminInformation")

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

    if ( !mb.Open( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE ) ) {
		ErrorTrace(0,"Failed to open metabase key %s", pInstance->QueryMDPath());
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_OPEN_FAILED;
	}

	if( IsFieldSet( pConfig->FieldControl, FC_NNTP_POSTINGMODES ) ) {

		LogAdminEvent( pInstance, pConfig );

		if( !pInstance->SetPostingModes(	mb,
											pConfig->AllowClientPosting,
											pConfig->AllowFeedPosting ) )	{
			err = GetLastError() ;
		}

	}

	if( IsFieldSet( pConfig->FieldControl, FC_NNTP_POSTLIMITS ) ) {

		if( !pInstance->SetPostingLimits(	mb,
											pConfig->ServerPostHardLimit,
											pConfig->ServerPostSoftLimit ) ) {
			if( err == NERR_Success ) {
				err = GetLastError() ;
			}
		}
	}

	if( IsFieldSet( pConfig->FieldControl, FC_NNTP_FEEDLIMITS ) )	{

		if( !pInstance->SetFeedLimits(	mb,
										pConfig->ServerFeedHardLimit, 
										pConfig->ServerFeedSoftLimit ) )	{

			if( err == NERR_Success ) {
				err = GetLastError() ;
			}
		}
	}
		
	if( IsFieldSet( pConfig->FieldControl, FC_NNTP_CONTROLSMSGS ) ) {

		if( !pInstance->SetControlMessages( mb, pConfig->AllowControlMessages ) )
		{
			if( err == NERR_Success ) {
				err = GetLastError() ;
			}
		}
	}

	if( IsFieldSet( pConfig->FieldControl, FC_NNTP_SMTPADDRESS ) )	{

		if( !pInstance->SetSmtpAddress( mb, pConfig->SmtpServerAddress ) )
		{
			if( err == NERR_Success )
			{
				err = GetLastError() ;
			}
		}
	}
	
	if( IsFieldSet( pConfig->FieldControl, FC_NNTP_UUCPNAME ) )	{

		if( !pInstance->SetUucpName( mb, pConfig->UucpServerName ) )
		{
			if( err == NERR_Success )
			{
				err = GetLastError() ;
			}
		}
	}
	
	if( IsFieldSet( pConfig->FieldControl, FC_NNTP_DEFAULTMODERATOR ) )	{

		if( !pInstance->SetDefaultModerator( mb, pConfig->DefaultModerator ) )
		{
			if( err == NERR_Success )
			{
				err = GetLastError() ;
			}
		}
	}

	mb.Close();
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    return(err);

} // NntprSetAdminInformation

NET_API_STATUS
NET_API_FUNCTION
NntprGetAdminInformation(
    IN  LPWSTR pszServer OPTIONAL,
    IN	DWORD  InstanceId,
    OUT LPI_NNTP_CONFIG_INFO * pConfig
    )
{
    APIERR err = NERR_Success;

    ENTER("NntprGetAdminInformation")

	*pConfig = NULL ;
	DWORD	cb;
	DWORD	cbAddress;
	DWORD	cbUucpName;
	DWORD	cbDefaultModerator;
	LPBYTE	pAlloc;

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	cbAddress = (lstrlenW( pInstance->GetRawSmtpAddress() ) + 1) * sizeof(WCHAR);
	cbUucpName= (lstrlenW( pInstance->GetRawUucpName() ) + 1) * sizeof(WCHAR);
	cbDefaultModerator = (lstrlenW( pInstance->GetRawDefaultModerator() ) +1) * sizeof(WCHAR);

	cb = sizeof( I_NNTP_CONFIG_INFO ) + cbAddress + cbUucpName + cbDefaultModerator;
				
	pAlloc = (LPBYTE)MIDL_user_allocate( cb ) ;
	if( pAlloc ) {

		LPI_NNTP_CONFIG_INFO pLocal = *pConfig = (LPI_NNTP_CONFIG_INFO)pAlloc;
		LPWSTR pszAddress = (LPWSTR)(pAlloc + sizeof(I_NNTP_CONFIG_INFO));
		LPWSTR pszUucpName = (LPWSTR)(pAlloc + sizeof(I_NNTP_CONFIG_INFO) + cbAddress );
		LPWSTR pszDefaultModerator = (LPWSTR)(pAlloc + sizeof(I_NNTP_CONFIG_INFO) + cbAddress + cbUucpName );


		pLocal->FieldControl =	FC_NNTP_POSTINGMODES | 
								FC_NNTP_ORGANIZATION | 
								FC_NNTP_POSTLIMITS   |
								FC_NNTP_ENCRYPTCAPS  |
								FC_NNTP_SMTPADDRESS  |
								FC_NNTP_UUCPNAME     |
								FC_NNTP_CONTROLSMSGS |
								FC_NNTP_DEFAULTMODERATOR ;

		pLocal->AllowClientPosting =  pInstance->FAllowClientPosts() ;
		pLocal->AllowFeedPosting =	  pInstance->FAllowFeedPosts() ;
		pLocal->ServerPostHardLimit = pInstance->ServerHardLimit() ;
		pLocal->ServerPostSoftLimit = pInstance->ServerSoftLimit() ;
		pLocal->ServerFeedHardLimit = pInstance->FeedHardLimit() ;
		pLocal->ServerFeedSoftLimit = pInstance->FeedSoftLimit() ;
		pLocal->Organization = NULL ;

		CEncryptCtx::GetAdminInfoEncryptCaps( &pLocal->dwEncCaps );

		pLocal->SmtpServerAddress = pszAddress;
		CopyMemory( pszAddress, pInstance->GetRawSmtpAddress(), cbAddress );

		pLocal->UucpServerName = pszUucpName;
		CopyMemory( pszUucpName, pInstance->GetRawUucpName(), cbUucpName );

		pLocal->DefaultModerator = pszDefaultModerator;
		CopyMemory( pszDefaultModerator, pInstance->GetRawDefaultModerator(), cbDefaultModerator );

		pLocal->AllowControlMessages = pInstance->FAllowControlMessages();

	}	else	{

		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		return	ERROR_OUTOFMEMORY ;

	}

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    return(err);

} // NntprGetAdminInformation

void
LogAdminEvent(	
		IN PNNTP_SERVER_INSTANCE pInstance,
		IN LPI_NNTP_CONFIG_INFO pConfig
		)
{
	DWORD event = 0;
	PCHAR args[1];
	CHAR  szId[20];

	_itoa( pInstance->QueryInstanceId(), szId, 10 );
	args [0] = szId;

	// log an event if client/feed posting changes from enabled to disabled or vice versa
	if( pInstance->FAllowClientPosts() != pConfig->AllowClientPosting )
	{
		if( pConfig->AllowClientPosting )
			event = NNTP_EVENT_CLIENTPOSTING_ENABLED;
		else
			event = NNTP_EVENT_CLIENTPOSTING_DISABLED;
	}

	if( pInstance->FAllowFeedPosts() != pConfig->AllowFeedPosting )
	{
		if( pConfig->AllowFeedPosting )
			event = NNTP_EVENT_FEEDPOSTING_ENABLED;
		else
			event = NNTP_EVENT_FEEDPOSTING_DISABLED;
	}

	if( event )
	{
		NntpLogEvent(
				event,
				1,
				(const char**)args, 
				0 
				) ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\svcbuild.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    svcbuild.cpp

Abstract:

    This module contains implementation of RPCs for nntpbld

Author:

    Rajeev Rajan (rajeevr)     08-Mar-1997

Revision History:

--*/

#define INCL_INETSRV_INCS
#include "tigris.hxx"
#include "nntpsvc.h"

CBootOptions*
CreateBootOptions(
		LPI_NNTPBLD_INFO pBuildInfo,
		DWORD InstanceId
		);

NET_API_STATUS
NET_API_FUNCTION
NntprStartRebuild(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    IN LPI_NNTPBLD_INFO pBuildInfo,
    OUT LPDWORD pParmError OPTIONAL
	)
{
    APIERR err = NERR_Success;
	CRebuildThread* pRebuildThread = NULL ;
	BOOL	fRtn = TRUE ;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    ENTER("NntpStartRebuild")

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId, FALSE );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
    	pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	// rebuild rpc crit sect
	EnterCriticalSection( &pInstance->m_critRebuildRpc ) ;

	//
	//	Verify that the instance is in the stopped state.
	//	Also, check to see if the instance is being rebuilt !
	//
	if( pInstance->m_BootOptions )
	{
		// instance has a rebuild pending
		ErrorTrace(0,"Instance %d rebuild pending: cannot rebuild", InstanceId );
		err = (NET_API_STATUS)ERROR_SERVICE_DISABLED;
		goto Exit ;
	}

	if( pInstance->QueryServerState() != MD_SERVER_STATE_STOPPED )
	{
		// instance needs to be stopped for rebuild
		ErrorTrace(0,"Instance %d invalid state %d: cannot rebuild", InstanceId, pInstance->QueryServerState() );
		err = (NET_API_STATUS)ERROR_SERVICE_ALREADY_RUNNING;
		goto Exit ;
	}

	//
	//	create boot options for this instance - this will be deleted
	//	at the end of the rebuild. As long as the m_BootOptions is
	//	non-NULL, the instance is being rebuilt.
	//

	if ( !(pInstance->m_BootOptions = CreateBootOptions( pBuildInfo, InstanceId )) ) {
		ErrorTrace(0,"Failed to create boot options for instance %d", InstanceId );
		err = (NET_API_STATUS)ERROR_INVALID_PARAMETER;
		goto Exit ;
	}

	//
	//	Create a rebuild thread if one does not exist
	//

	if( !(pRebuildThread = g_pNntpSvc->m_pRebuildThread) ) {
		g_pNntpSvc->m_pRebuildThread = XNEW CRebuildThread ;
		pRebuildThread = g_pNntpSvc->m_pRebuildThread ;

		if( pRebuildThread == NULL ) {
			err = GetLastError();
			goto Exit;
		}
	}

    //
    //  Bump a ref count since we are adding the instance to
    //  the rebuild thread queue. This will be deref'd when the
    //  rebuild thread is done with this instance.
    //
    
	pInstance->Reference();
	pRebuildThread->PostWork( (PVOID) pInstance );

Exit:

	LeaveCriticalSection( &pInstance->m_critRebuildRpc ) ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    return(err);

} // NntprStartRebuild

NET_API_STATUS
NET_API_FUNCTION
NntprGetBuildStatus(
    IN  LPWSTR	pszServer OPTIONAL,
    IN  DWORD	InstanceId,
	IN	BOOL	fCancel,
    OUT LPDWORD pdwProgress
    )
{
    APIERR err = NERR_Success;
	*pdwProgress = 0 ;

    ENTER("NntpGetBuildStatus")

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId, FALSE );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
    	pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	EnterCriticalSection( &pInstance->m_critRebuildRpc ) ;

	if( pInstance->QueryServerState() != MD_SERVER_STATE_STARTED &&
		pInstance->QueryServerState() != MD_SERVER_STATE_STOPPED &&
		pInstance->QueryServerState() != MD_SERVER_STATE_PAUSED ) 
	{
		// invalid state for this RPC
		ErrorTrace(0,"Instance %d invalid state %d", InstanceId, pInstance->QueryServerState() );
		err = (NET_API_STATUS)ERROR_INVALID_PARAMETER;
		goto Exit;
	}

	if( !pInstance->m_BootOptions )
	{
		*pdwProgress = pInstance->GetRebuildProgress();
		if( *pdwProgress != 100 )
		{
			ErrorTrace(0,"Rebuild failed or not started - percent %d",*pdwProgress);
			/*
			if( (err = pInstance->GetRebuildLastError()) == 0) {
			    err = ERROR_OPERATION_ABORTED;
		    }*/
		    err = ERROR_OPERATION_ABORTED;
		}
	} else {
		*pdwProgress = min( pInstance->GetRebuildProgress(), 95 ) ;
		if( fCancel ) {
			DebugTrace(0,"Instance %d Setting cancel rebuild flag", InstanceId );
			pInstance->m_BootOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL_PENDING ;
		}
	}

	DebugTrace(0,"Progress percent is %d", *pdwProgress );

Exit:

	LeaveCriticalSection( &pInstance->m_critRebuildRpc ) ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    return(err);

} // NntprGetBuildStatus

CBootOptions*
CreateBootOptions(
		LPI_NNTPBLD_INFO pBuildInfo,
		DWORD dwInstanceId
		)
{
	CBootOptions* pBootOptions = NULL ;
	char szReportFile [MAX_PATH];

	if( pBuildInfo->cbReportFile == 0 ) {
		// TODO: generate a default name
		return NULL ;
	}

	pBootOptions = XNEW CBootOptions() ;
	if( pBootOptions == 0 )	{
		return	NULL ;
	}

	pBootOptions->DoClean = pBuildInfo->DoClean;
	pBootOptions->NoHistoryDelete = pBuildInfo->NoHistoryDelete;
	pBootOptions->ReuseIndexFiles = pBuildInfo->ReuseIndexFiles & 0x00000011;
	pBootOptions->OmitNonleafDirs = pBuildInfo->OmitNonleafDirs;
	pBootOptions->cNumThreads = pBuildInfo->NumThreads;
	pBootOptions->fVerbose = pBuildInfo->Verbose;
	pBootOptions->SkipCorruptGroup = pBuildInfo->ReuseIndexFiles & 0x00000100;

	
	pBootOptions->m_hOutputFile =
		CreateFileW(	pBuildInfo->szReportFile,
						GENERIC_READ | GENERIC_WRITE,
						FILE_SHARE_READ, 
						NULL, 
						OPEN_ALWAYS, 
						FILE_FLAG_SEQUENTIAL_SCAN, 
						NULL ) ;

	if( pBootOptions->m_hOutputFile == INVALID_HANDLE_VALUE ) {

		PCHAR	args[1] ;
		CopyUnicodeStringIntoAscii( szReportFile, pBuildInfo->szReportFile );
		args[0]  = szReportFile ;
		
		NntpLogEventEx(	NNTP_BAD_RECOVERY_PARAMETER, 
						1, 
						(const char **)args, 
						GetLastError(),
						dwInstanceId
					) ;

		goto Error ;
	}

	//
	//	If IsActiveFile, szGroupFile is an INN style active file, else
	//	either this is the filename to use for storing the groups while scanning
	//	the virtual roots !
	//

	if( pBuildInfo->cbGroupFile ) {
		CopyUnicodeStringIntoAscii(	pBootOptions->szGroupFile, pBuildInfo->szGroupFile ) ;
	} else {
		pBootOptions->szGroupFile [0] = '\0';
	}

	pBootOptions->IsActiveFile = pBuildInfo->IsActiveFile ;

	return pBootOptions;

Error:

	if( pBootOptions ) {
		XDELETE pBootOptions;
		pBootOptions = NULL;
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\svcstat.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    svcstat.cpp

Abstract:

    This module contains code for doing statistics rpcs

Author:

    Johnson Apacible (JohnsonA)     12-Nov-1995

Revision History:

--*/

#define INCL_INETSRV_INCS
#include "tigris.hxx"
#include "nntpsvc.h"
#include <time.h>

NET_API_STATUS
NET_API_FUNCTION
NntprQueryStatistics(
    IN NNTP_HANDLE pszServer,
	IN DWORD InstanceId,
    IN DWORD Level,
    IN LPNNTP_STATISTICS_0 *pBuffer
    )
{
    APIERR err;
    LPNNTP_STATISTICS_0 pstats0;

    _ASSERT( pBuffer != NULL );
    UNREFERENCED_PARAMETER(pszServer);
    ENTER("NntprQueryStatistics")

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheck( TCP_QUERY_STATISTICS );

    if( err != NO_ERROR ) {
        IF_DEBUG( RPC ) {
            ErrorTrace(0,"Failed access check, error %lu\n",err );
        }
        return (NET_API_STATUS)err;
    }

    if ( Level != 0 ) {
        return (NET_API_STATUS)ERROR_INVALID_LEVEL;
    }

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId, FALSE );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Return the proper statistics based on the infolevel.
    //

    pstats0 = (NNTP_STATISTICS_0 *)
        MIDL_user_allocate( sizeof(NNTP_STATISTICS_0) );

    if( pstats0 == NULL ) {
        err = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        LockStatistics( pInstance );
        CopyMemory( pstats0, &pInstance->m_NntpStats, sizeof(NNTP_STATISTICS_0) );
        UnlockStatistics( pInstance );

        //
        // Get hash table counts
        //

		if( pInstance->QueryServerState() == MD_SERVER_STATE_STARTED ) {
			_ASSERT( pInstance->ArticleTable() );
			pstats0->ArticleMapEntries = (pInstance->ArticleTable())->GetEntryCount();
			pstats0->HistoryMapEntries = (pInstance->HistoryTable())->GetEntryCount();
			pstats0->XoverEntries = (pInstance->XoverTable())->GetEntryCount();
		}

        *pBuffer = pstats0;
    }

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    return (NET_API_STATUS)err;

}   // NntprQueryStatistics

NET_API_STATUS
NET_API_FUNCTION
NntprClearStatistics(
    NNTP_HANDLE pszServer,
	IN DWORD    InstanceId
    )
{
    APIERR err;

    UNREFERENCED_PARAMETER(pszServer);
    ENTER("NntprClearStatistics")

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheck( TCP_CLEAR_STATISTICS );

    if( err != NO_ERROR ) {
        IF_DEBUG( RPC ) {
            ErrorTrace(0,"Failed access check, error %lu\n",err );
        }
        return (NET_API_STATUS)err;
    }

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Clear the statistics.
    //

    pInstance->ClearStatistics();
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();
    return (NET_API_STATUS)err;

}   // NntprClearStatistics
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\svcgroup.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name :

	svcgroup.cpp

Abstract :

	This module contains the server side support for newsgroup rpcs.

Author :

	Neil Kaethler

Revision History :

--*/

#define	INCL_INETSRV_INCS
#include	"tigris.hxx"
#include	"nntpsvc.h"

static BOOL
IsValidUnicodeString(LPCWSTR wszString, DWORD dwByteLen, DWORD dwMinLen, DWORD dwMaxLen) {

	DWORD dwCharLen = dwByteLen / sizeof(WCHAR);

	// Must be an even number of bytes
	if (dwByteLen & 1)
		return FALSE;

	if (dwMinLen != 0 && wszString == NULL)
		return FALSE;

	if (dwCharLen < dwMinLen || dwCharLen > dwMaxLen)
		return FALSE;

	// Make sure it's NULL terminated
	if (wszString != NULL && wszString[dwCharLen-1] != L'\0')
		return FALSE;

	return TRUE;
}



NET_API_STATUS
NET_API_FUNCTION
NntprGetNewsgroup(
	IN	NNTP_HANDLE			ServerName	OPTIONAL,
    IN	DWORD				InstanceId,
	IN OUT	LPI_NEWSGROUP_INFO	*pNewsgroupInfo
	)
{

	TraceFunctEnter( "NntprGetNewsgroup" ) ;

	APIERR	ss = STATUS_SUCCESS ;

	LPI_NEWSGROUP_INFO	NewsgroupInfo = *pNewsgroupInfo ;
	*pNewsgroupInfo = 0 ;

	if( NewsgroupInfo == 0 )	{
		return	ERROR_INVALID_PARAMETER ;
	}

	if( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {
		return	NERR_ServerNotStarted ;
	}

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Check for proper access.
    //

    DWORD	err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	unsigned	char	szGroup[MAX_PATH*2] ;
	unsigned	char	szDescription[MAX_DESCRIPTIVE_TEXT+1] ;
	unsigned	char	szModerator[MAX_MODERATOR_NAME+1] ;
	unsigned	char	szPrettyname[MAX_PRETTYNAME_TEXT+1] ;
	DWORD	cbDescription = 0 ;
	DWORD	cbModerator = 0 ;
	DWORD	cbPrettyname = 0 ;

	if( NewsgroupInfo->Newsgroup == 0  ||
		NewsgroupInfo->cbNewsgroup > (sizeof( szGroup ) / sizeof( szGroup[0] )) ) {
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		return	ERROR_INVALID_PARAMETER ;
	}

	CopyNUnicodeStringIntoAscii( (char*)szGroup, (LPWSTR)NewsgroupInfo->Newsgroup,
	    -1, MAX_PATH) ;

	CNewsTree*	ptree = pInstance->GetTree() ;

	EnterCriticalSection( &pInstance->m_critNewsgroupRPCs ) ;

	CGRPPTR	pGroup = ptree->GetGroup( (char*)szGroup, lstrlen( (char*)szGroup )+1 ) ;

	if( pGroup != 0 ) {

		cbDescription = pGroup->CopyHelpTextForRPC( (char*)szDescription, sizeof( szDescription )-1) ;
		cbModerator = pGroup->CopyModerator( (char*)szModerator, sizeof( szModerator )-1 ) ;
		cbPrettyname = pGroup->CopyPrettynameForRPC( (char*)szPrettyname, sizeof( szPrettyname )-1) ;
		szDescription[cbDescription++] = '\0' ;
		szModerator[cbModerator++] = '\0' ;
		szPrettyname[cbPrettyname++] = '\0' ;

		DWORD	cbAllocate =	sizeof( NNTP_NEWSGROUP_INFO ) +
										(cbDescription * sizeof(WCHAR)) +
										(cbModerator * sizeof(WCHAR)) +
										(cbPrettyname * sizeof(CHAR)) +
										NewsgroupInfo->cbNewsgroup ;

		PUCHAR	bufStart = (PUCHAR)MIDL_user_allocate(	cbAllocate ) ;

		if( bufStart == NULL ) {
			ss = ERROR_NOT_ENOUGH_MEMORY ;
		}	else	{

			PUCHAR	bufEnd = (bufStart + cbAllocate) ;
			LPI_NEWSGROUP_INFO	NewsgroupInfoOut = (LPI_NEWSGROUP_INFO)bufStart ;

			bufEnd -= NewsgroupInfo->cbNewsgroup ;
			CopyMemory( bufEnd, NewsgroupInfo->Newsgroup, NewsgroupInfo->cbNewsgroup ) ;
			NewsgroupInfoOut->Newsgroup = bufEnd ;
			NewsgroupInfoOut->cbNewsgroup = NewsgroupInfo->cbNewsgroup ;

			if( cbDescription != 0 ) {

				bufEnd -= (cbDescription * sizeof(WCHAR)) ;
				WCHAR*	dest = (WCHAR*)bufEnd ;

				WCHAR wcTemp[MAX_DESCRIPTIVE_TEXT];
				for( DWORD i=0; i<cbDescription; i++ ) {
					wcTemp[i] = (WCHAR)szDescription[i] ;
				}
				memcpy(dest,wcTemp,cbDescription*2);
				dest += cbDescription;

				NewsgroupInfoOut->cbDescription = cbDescription * sizeof(WCHAR) ;
				NewsgroupInfoOut->Description = bufEnd ;

			}

			if( cbModerator != 0 ) {

				bufEnd -= (cbModerator * sizeof(WCHAR)) ;
				WCHAR*	dest = (WCHAR*)bufEnd ;

				WCHAR wcTemp[MAX_MODERATOR_NAME];
				for( DWORD i=0; i<cbModerator; i++ ) {
					wcTemp[i] = (WCHAR)szModerator[i] ;
				}
				memcpy(dest,wcTemp,cbModerator*2);
				dest += cbModerator;

				NewsgroupInfoOut->cbModerator = cbModerator * sizeof( WCHAR ) ;
				NewsgroupInfoOut->Moderator = bufEnd ;
				if ( *(NewsgroupInfoOut->Moderator) != 0 )
				    NewsgroupInfoOut->fIsModerated = TRUE;
				else NewsgroupInfoOut->fIsModerated = FALSE;
			} else NewsgroupInfoOut->fIsModerated = FALSE;

			if( cbPrettyname != 0 ) {

				bufEnd -= (cbPrettyname * sizeof(CHAR)) ;
				CHAR*	dest = (CHAR*)bufEnd ;
				for( DWORD i=0; i<cbPrettyname; i++ ) {
					*dest++ = (CHAR)szPrettyname[i] ;
				}
				NewsgroupInfoOut->cbPrettyname = cbPrettyname * sizeof(CHAR) ;
				NewsgroupInfoOut->Prettyname = bufEnd ;
			}

			NewsgroupInfoOut->ReadOnly = pGroup->IsReadOnly() ;
			NewsgroupInfoOut->ftCreationDate = pGroup->GetGroupTime();

			*pNewsgroupInfo = NewsgroupInfoOut ;

			ss = STATUS_SUCCESS ;

		}
	}	else	{

		ss = NERR_ResourceNotFound ;

	}

	LeaveCriticalSection( &pInstance->m_critNewsgroupRPCs ) ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

	return	ss ;

}	//	NntpGetNewsgroup

NET_API_STATUS
NET_API_FUNCTION
NntprSetNewsgroup(
	IN	NNTP_HANDLE			ServerName	OPTIONAL,
    IN	DWORD				InstanceId,
	IN	LPI_NEWSGROUP_INFO	NewsgroupInfo
	)
{

	TraceFunctEnter( "NntprSetNewsgroup" ) ;

	APIERR	ss = STATUS_SUCCESS ;
	DWORD   cProperties = 0;
	DWORD   rgidProperties[MAX_GROUP_PROPERTIES];

	if( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {
		return	NERR_ServerNotStarted ;
	}

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	//
    //  Check for proper access.
    //

    DWORD	err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	//
	//	First validate the parameters
	//
	if(	!IsValidUnicodeString((LPCWSTR)NewsgroupInfo->Newsgroup, NewsgroupInfo->cbNewsgroup,
			1, MAX_NEWSGROUP_NAME-1) ||
		!IsValidUnicodeString((LPCWSTR)NewsgroupInfo->Description, NewsgroupInfo->cbDescription,
			0, MAX_DESCRIPTIVE_TEXT-1) ||
		!IsValidUnicodeString((LPCWSTR)NewsgroupInfo->Moderator, NewsgroupInfo->cbModerator,
			0, MAX_MODERATOR_NAME-1) ||
		NewsgroupInfo->cbPrettyname >= MAX_PRETTYNAME_TEXT ) {

		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		return	ERROR_INVALID_PARAMETER ;

	}

	char	szNewsgroup[MAX_NEWSGROUP_NAME] ;
	char	szModerator[MAX_MODERATOR_NAME] ;
	char	szDescription[MAX_DESCRIPTIVE_TEXT] ;
	char	szPrettyname[MAX_PRETTYNAME_TEXT] ;

	szNewsgroup[0] = '\0' ;
	szModerator[0] = '\0' ;
	szDescription[0] = '\0' ;
	szPrettyname[0] = '\0' ;

	CopyNUnicodeStringIntoAscii(szNewsgroup, (LPWSTR)NewsgroupInfo->Newsgroup,
		-1, MAX_NEWSGROUP_NAME);
	//CopyUnicodeStringIntoAscii( szNewsgroup, (LPWSTR)NewsgroupInfo->Newsgroup ) ;

	if( NewsgroupInfo->Moderator != 0 ) {
		CopyNUnicodeStringIntoAscii(szModerator, (LPWSTR)NewsgroupInfo->Moderator,
			-1, MAX_MODERATOR_NAME);
		//CopyUnicodeStringIntoAscii( szModerator, (LPWSTR)NewsgroupInfo->Moderator ) ;
	} else if( NewsgroupInfo->fIsModerated ) {
	    //
	    //  Newsgroup is moderated but no name supplied - use default !
	    //
		DWORD cbModeratorLen = MAX_MODERATOR_NAME;
		szModerator [0] = '\0';
		if( pInstance->GetDefaultModerator( szNewsgroup, szModerator, &cbModeratorLen ) ) {
			_ASSERT( !cbModeratorLen || (cbModeratorLen == (DWORD)lstrlen( szModerator )+1) );
		} else {
			ErrorTrace(0,"Error %d GetDefaultModerator", GetLastError());
			szModerator[0] = '\0';
			cbModeratorLen = 0;
		}
    }

	if( NewsgroupInfo->Description != 0 ) {
		CopyNUnicodeStringIntoAscii(szDescription, (LPWSTR)NewsgroupInfo->Description,
			-1, MAX_DESCRIPTIVE_TEXT);
		//CopyUnicodeStringIntoAscii( szDescription, (LPWSTR)NewsgroupInfo->Description ) ;
	}

	if( NewsgroupInfo->Prettyname != 0 ) {
		lstrcpyn( szPrettyname, (const char*)NewsgroupInfo->Prettyname, MAX_PRETTYNAME_TEXT);
	}

	EnterCriticalSection( &pInstance->m_critNewsgroupRPCs ) ;

	CNewsTree*	ptree = pInstance->GetTree() ;

	CGRPPTR	pGroup = ptree->GetGroup( szNewsgroup, lstrlen( szNewsgroup ) + 1 ) ;
	if( pGroup != 0 ) {
	    INNTPPropertyBag *pPropBag = pGroup->GetPropertyBag();
	    HRESULT hr = S_OK;
	    DWORD  dwLen = 0;
        dwLen = strlen( szModerator ) + 1 ;
        hr = pPropBag->PutBLOB( NEWSGRP_PROP_MODERATOR,
                                dwLen,
                                PBYTE( szModerator ));
        rgidProperties[cProperties++] = NEWSGRP_PROP_MODERATOR;

        if ( SUCCEEDED( hr ) ) {
            dwLen = strlen( szDescription ) + 1 ;
            hr = pPropBag->PutBLOB(  NEWSGRP_PROP_DESC,
                                     dwLen,
                                     PBYTE( szDescription ));
            rgidProperties[cProperties++] = NEWSGRP_PROP_DESC;
        }

        if ( SUCCEEDED( hr ) ) {
            dwLen = strlen( szPrettyname ) + 1;
            hr = pPropBag->PutBLOB( NEWSGRP_PROP_PRETTYNAME,
                                    dwLen,
                                    PBYTE( szPrettyname ));
            rgidProperties[cProperties++] = NEWSGRP_PROP_PRETTYNAME;
        }

        if ( SUCCEEDED( hr ) ) {
            hr = pPropBag->PutBool( NEWSGRP_PROP_READONLY, NewsgroupInfo->ReadOnly );
            rgidProperties[cProperties++] = NEWSGRP_PROP_READONLY;
        }

        if ( SUCCEEDED( hr ) ) {
            hr = pPropBag->PutDWord( NEWSGRP_PROP_DATELOW, NewsgroupInfo->ftCreationDate.dwLowDateTime );
        }

        if ( SUCCEEDED( hr ) ) {
            hr = pPropBag->PutDWord( NEWSGRP_PROP_DATEHIGH, NewsgroupInfo->ftCreationDate.dwHighDateTime );
        }

        if ( FAILED( hr ) ) {
            // what should I tell the client ?  Does he ever
            // know HRESULT ?
            ss = ERROR_INVALID_PARAMETER;
        }

        // Now set it to driver
      	if ( !pGroup->SetDriverStringProperty( cProperties, rgidProperties ) ) {
		    // BUGBUG: do I just return fail or roll back all changes
		    // to the newsgroup object ?
    	}

   		pPropBag->Release();
	}	else	{

		ss = ERROR_NOT_FOUND ;

	}

	LeaveCriticalSection( &pInstance->m_critNewsgroupRPCs ) ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

	return	 ss ;

}	//	NntpSetNewsgroup


NET_API_STATUS
NET_API_FUNCTION
NntprCreateNewsgroup(
	IN	NNTP_HANDLE			ServerName	OPTIONAL,
    IN	DWORD				InstanceId,
	IN	LPI_NEWSGROUP_INFO	NewsgroupInfo
	)
{

	TraceFunctEnter( "NntprCreateNewsgroup" ) ;

	APIERR	ss = STATUS_SUCCESS ;
	DWORD   cProperties = 0;
	DWORD   rgidProperties[MAX_GROUP_PROPERTIES];

	if( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {
		return	NERR_ServerNotStarted ;
	}

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	//
    //  Check for proper access.
    //

    DWORD	err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	//
	//	First validate the parameters
	//
	if(	!IsValidUnicodeString((LPCWSTR)NewsgroupInfo->Newsgroup, NewsgroupInfo->cbNewsgroup,
			1, MAX_NEWSGROUP_NAME-1) ||
		!IsValidUnicodeString((LPCWSTR)NewsgroupInfo->Description, NewsgroupInfo->cbDescription,
			0, MAX_DESCRIPTIVE_TEXT-1) ||
		!IsValidUnicodeString((LPCWSTR)NewsgroupInfo->Moderator, NewsgroupInfo->cbModerator,
			0, MAX_MODERATOR_NAME-1) ||
		NewsgroupInfo->cbPrettyname >= MAX_PRETTYNAME_TEXT ) {

		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		return	ERROR_INVALID_PARAMETER ;

	}

	char	szNewsgroup[MAX_NEWSGROUP_NAME] ;
	char	szModerator[MAX_MODERATOR_NAME] ;
	char	szDescription[MAX_DESCRIPTIVE_TEXT] ;
	char	szPrettyname[MAX_PRETTYNAME_TEXT] ;

	szNewsgroup[0] = '\0' ;
	szModerator[0] = '\0' ;
	szDescription[0] = '\0' ;
	szPrettyname[0] = '\0' ;

	CopyNUnicodeStringIntoAscii(szNewsgroup, (LPWSTR)NewsgroupInfo->Newsgroup,
		-1, MAX_NEWSGROUP_NAME);
	// CopyUnicodeStringIntoAscii( szNewsgroup, (LPWSTR)NewsgroupInfo->Newsgroup ) ;
	//_strlwr( szNewsgroup ) ;

	if( NewsgroupInfo->Moderator != 0 ) {
		//CopyUnicodeStringIntoAscii( szModerator, (LPWSTR)NewsgroupInfo->Moderator ) ;
		CopyNUnicodeStringIntoAscii(szModerator, (LPWSTR)NewsgroupInfo->Moderator,
			-1, MAX_MODERATOR_NAME);
	} else if( NewsgroupInfo->fIsModerated ) {
	    //
	    //  Newsgroup is moderated but no name supplied - use default !
	    //
		DWORD cbModeratorLen = MAX_MODERATOR_NAME;
		szModerator [0] = '\0';
		if( pInstance->GetDefaultModerator( szNewsgroup, szModerator, &cbModeratorLen ) ) {
			_ASSERT( !cbModeratorLen || (cbModeratorLen == (DWORD)lstrlen( szModerator )+1) );
		} else {
			ErrorTrace(0,"Error %d GetDefaultModerator", GetLastError());
			szModerator[0] = '\0';
			cbModeratorLen = 0;
		}
    }

	if( NewsgroupInfo->Description != 0 ) {
		//CopyUnicodeStringIntoAscii( szDescription, (LPWSTR)NewsgroupInfo->Description ) ;
		CopyNUnicodeStringIntoAscii(szDescription, (LPWSTR)NewsgroupInfo->Description,
			-1, MAX_DESCRIPTIVE_TEXT);
	}

	if( NewsgroupInfo->Prettyname != 0 ) {
		lstrcpyn( szPrettyname, (LPCSTR)NewsgroupInfo->Prettyname, MAX_PRETTYNAME_TEXT);
	}

	BOOL fReadOnly = NewsgroupInfo->ReadOnly ;
	_ASSERT( (fReadOnly == TRUE) || (fReadOnly == FALSE) );

	CNewsTree*	ptree = pInstance->GetTree() ;
	CGRPPTR	pGroup;

	EnterCriticalSection( &pInstance->m_critNewsgroupRPCs ) ;

	if( !ptree->CreateGroup( szNewsgroup, FALSE, NULL, FALSE ) ) {

		ss = GetLastError();

	}	else	{

		pGroup = ptree->GetGroup( szNewsgroup, lstrlen( szNewsgroup ) ) ;
		if( pGroup == 0 ) {

			ss = ERROR_INTERNAL_ERROR ;

		}	else	{

		    INNTPPropertyBag *pPropBag = pGroup->GetPropertyBag();
		    HRESULT hr = S_OK;
		    DWORD  dwLen = 0;
		    if ( NULL != pPropBag ) {
		        if ( *szModerator != 0 ) {
		            dwLen = strlen( szModerator ) + 1;
                    hr = pPropBag->PutBLOB( NEWSGRP_PROP_MODERATOR,
                                            dwLen,
                                            PBYTE( szModerator ));
                    rgidProperties[cProperties++] = NEWSGRP_PROP_MODERATOR;
                }

                if ( SUCCEEDED( hr ) && *szDescription != 0 ) {
                    dwLen = strlen( szDescription ) + 1;
                    hr = pPropBag->PutBLOB(  NEWSGRP_PROP_DESC,
                                            dwLen,
                                            PBYTE( szDescription ));
                    rgidProperties[cProperties++] = NEWSGRP_PROP_DESC;
                }

                if ( SUCCEEDED( hr ) && *szPrettyname != 0 ) {
                    dwLen = strlen( szPrettyname ) + 1;
                    hr = pPropBag->PutBLOB( NEWSGRP_PROP_PRETTYNAME,
                                            dwLen,
                                            PBYTE( szPrettyname ));
                    rgidProperties[cProperties++] = NEWSGRP_PROP_PRETTYNAME;
                }

                if ( SUCCEEDED( hr ) ) {
                    hr = pPropBag->PutBool( NEWSGRP_PROP_READONLY, fReadOnly );
                    rgidProperties[cProperties++] = NEWSGRP_PROP_READONLY;
                }

                if ( FAILED( hr ) ) {
                    // what should I tell the client ?  Does he ever
                    // know HRESULT ?
                    ss = ERROR_INTERNAL_ERROR;
                }

                // Now set it to driver
      	        if ( !pGroup->SetDriverStringProperty( cProperties, rgidProperties ) ) {
		            // BUGBUG: do I just return fail or roll back all changes
		            // to the newsgroup object ?
    	        }

                pPropBag->Release();
           } else ss = ERROR_INTERNAL_ERROR;
       }
	}

	if( STATUS_SUCCESS == ss )
	{
		PCHAR	args[2] ;
		CHAR    szId[20];
		_itoa( pInstance->QueryInstanceId(), szId, 10 );
		args[0] = szId;
		args[1] = pGroup->GetNativeName() ;

		NntpLogEvent(
				NNTP_EVENT_NEWGROUP_RPC_APPLIED,
				2,
				(const CHAR **)args,
				0 ) ;
	}

	LeaveCriticalSection( &pInstance->m_critNewsgroupRPCs ) ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

	return ss  ;
}	//	NntpCreateNewsgroup


NET_API_STATUS
NET_API_FUNCTION
NntprDeleteNewsgroup(
	IN	NNTP_HANDLE			ServerName	OPTIONAL,
    IN	DWORD				InstanceId,
	IN	LPI_NEWSGROUP_INFO	NewsgroupInfo
	)
{

	TraceFunctEnter( "NntprDeleteNewsgroup" ) ;

	APIERR	ss = STATUS_SUCCESS ;

	if( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {
		return	NERR_ServerNotStarted ;
	}

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	//
    //  Check for proper access.
    //

    DWORD	err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	//
	//	First validate the parameters
	//

	if (!IsValidUnicodeString((LPCWSTR)NewsgroupInfo->Newsgroup, NewsgroupInfo->cbNewsgroup,
			1, MAX_NEWSGROUP_NAME-1))
    {
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		return	ERROR_INVALID_PARAMETER ;
	}

	char	szNewsgroup[MAX_NEWSGROUP_NAME] ;
	szNewsgroup[0] = '\0' ;

	CopyNUnicodeStringIntoAscii(szNewsgroup, (LPWSTR)NewsgroupInfo->Newsgroup,
		-1, MAX_NEWSGROUP_NAME);

	// CopyUnicodeStringIntoAscii( szNewsgroup, (LPWSTR)NewsgroupInfo->Newsgroup ) ;
	_strlwr( szNewsgroup ) ;

	CNewsTree*	ptree = pInstance->GetTree() ;

	EnterCriticalSection( &pInstance->m_critNewsgroupRPCs ) ;

	CGRPPTR	pGroup = ptree->GetGroup( szNewsgroup, lstrlen( szNewsgroup ) ) ;
	if( pGroup == 0 )
    {
		ss = ERROR_INTERNAL_ERROR ;
	}
	else
    {
        if( !ptree->RemoveGroup( pGroup ) )
    		ss = ERROR_INVALID_NAME ;
	}

	if( STATUS_SUCCESS == ss )
	{
		PCHAR	args[2] ;
		CHAR    szId[20];
		_itoa( pInstance->QueryInstanceId(), szId, 10 );
		args[0] = szId;
		args[1] = pGroup->GetNativeName() ;

		NntpLogEvent(
				NNTP_EVENT_RMGROUP_RPC_APPLIED,
				2,
				(const CHAR **)args,
				0 ) ;
	}

	LeaveCriticalSection( &pInstance->m_critNewsgroupRPCs ) ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

	return ss;
}	//	NntprDeleteNewsgroup


NET_API_STATUS
NET_API_FUNCTION
NntprFindNewsgroup(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	NNTP_HANDLE			NewsgroupPrefix,
	IN	DWORD				MaxResults,
	OUT	LPDWORD				pdwResultsFound,
	OUT	LPNNTP_FIND_LIST	*ppFindList
	)

{
	LPNNTP_FIND_LIST	pFindList;
	APIERR	ss = STATUS_SUCCESS ;
	char szGroup [(MAX_PATH*2)+2];
	DWORD cbGroup;
	DWORD cbAlloc;
	DWORD	err ;

	TraceFunctEnter( "NntprFindNewsgroup" ) ;

	if (NewsgroupPrefix == 0)
	{
		ErrorTrace(0,"Newsgroup prefix: invalid pointer: NewsgroupPrefix" );
		return (NET_API_STATUS)ERROR_INVALID_PARAMETER;
	}
        
	*ppFindList = NULL;

	//
	//	Check service state
	//

	if( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {
		return	NERR_ServerNotStarted ;
	}

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	// validate newsgroup length
	DWORD cbPrefix = wcslen( (LPWSTR)NewsgroupPrefix );
	if(cbPrefix > (MAX_PATH*2) || cbPrefix == 0)
	{
        ErrorTrace(0,"Newsgroup prefix: invalid length: cbPrefix is %d", cbPrefix );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_BUFFER_OVERFLOW;
	}

	DebugTrace(NULL, "Find string is %ls", NewsgroupPrefix);
	CopyUnicodeStringIntoAscii( szGroup, (LPWSTR)NewsgroupPrefix ) ;

	// szGroup should be a multisz for the group iterator
	cbGroup = lstrlen( szGroup );
	_ASSERT(cbGroup <= (MAX_PATH*2));

	szGroup [cbGroup  ] = '\0';
	szGroup [cbGroup+1] = '\0';

	// Get the newstree object
	CNewsTree*  pTree = pInstance->GetTree() ;

	// allocate upto MaxResults entries
	// ensure that cbAlloc is within DWORD range (should restrict Max to a lower value than this)
	DWORD MaxPossibleResults = (DWORD)(ULONG_MAX-sizeof(NNTP_FIND_LIST))/sizeof(NNTP_FIND_ENTRY);
	if(MaxResults > MaxPossibleResults)
		MaxResults = MaxPossibleResults;

	cbAlloc = sizeof(NNTP_FIND_LIST) + MaxResults * sizeof(NNTP_FIND_ENTRY);
	pFindList = (LPNNTP_FIND_LIST)MIDL_user_allocate(cbAlloc);

	if( pFindList == NULL ) {
		ss = ERROR_NOT_ENOUGH_MEMORY ;
		ErrorTrace(NULL, "MIDL_user_allocate failed: GetLastError is %d", GetLastError());
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		TraceFunctLeave();
		return ss;
	}

	ZeroMemory(pFindList, cbAlloc);
	pFindList->cEntries = MaxResults;
	*pdwResultsFound = 0;

	if(!MaxResults)
	{
		// No hits
		*ppFindList = pFindList;
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		TraceFunctLeave();
		return ss;
	}

	CGroupIterator* pIterator = 0;

	// get the group names that match; *pdwResultsFound == number of hits
	for ( pIterator = pTree->GetIterator( (LPMULTISZ)szGroup, TRUE, FALSE );
		  pIterator && !pIterator->IsEnd() && !pTree->m_bStoppingTree;
		  pIterator->Next()
		)
    {
		if(*pdwResultsFound > (MaxResults-1))	// ie ResultsFound == MaxResults
			break;

		CGRPPTR  pGroup = pIterator->Current();

		if(pGroup == 0)
			continue;

		LPSTR lpGroupName = pGroup->GetNativeName();

		if (!ConvertStringToRpc(&(pFindList->aFindEntry[(*pdwResultsFound)++].lpszName), lpGroupName))
		{
			err = GetLastError();
			MIDL_user_free(pFindList);
			if( pIterator ) {
				XDELETE pIterator;
			}
			ErrorTrace(NULL, "Unable to convert %s to RPC string: %u", lpGroupName, err);
			pInstance->Dereference();
            RELEASE_SERVICE_LOCK_SHARED();
			return err;
		}
    }

	if( pIterator ) {
		XDELETE pIterator;
	}

	_ASSERT(*pdwResultsFound <= MaxResults);

	// return find list
	*ppFindList = pFindList;

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

	TraceFunctLeave();
	return	ss ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\svcfeeds.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    svcfeeds.cpp

Abstract:

    This module contains code for doing feed rpcs.

Author:

    Johnson Apacible (JohnsonA)     12-Nov-1995

Revision History:

    Kangrong Yan ( KangYan ) 28-Feb-1998
        Take out feed config rpcs by returning "not supported" error code.

--*/

#define INCL_INETSRV_INCS
#include "tigris.hxx"
#include "nntpsvc.h"
#include <time.h>

VOID
FillFeedInfoBuffer (
    IN PFEED_BLOCK FeedBlock,
    IN OUT LPSTR *FixedStructure,
    IN OUT LPWSTR *EndOfVariableData
    );

VOID
EnumerateFeeds(
		IN PNNTP_SERVER_INSTANCE pInstance,
        IN PCHAR Buffer,
        IN OUT PDWORD BuffSize,
        OUT PDWORD EntriesRead
        );


BOOL
AddFeedToMetabase(
    PFEED_BLOCK FeedBlock
    );

DWORD
DeleteFeedMetabase(
		IN PNNTP_SERVER_INSTANCE pInstance,
        IN PFEED_BLOCK FeedBlock
        );

// TODO: Clean up once the code is robust.
/*
DWORD
AllocateFeedId(
		PNNTP_SERVER_INSTANCE pInstance,
		char*	keyName,	
		DWORD	&feedId
		) ;
*/

/*
DWORD
DeleteFeedId(
		PNNTP_SERVER_INSTANCE pInstance,
        IN char	*keyName
        ) ;
*/

LPSTR
GetFeedTypeDescription(	
		IN	FEED_TYPE	feedType
		) ;

void
LogFeedAdminEvent(	
			DWORD		event,
			PFEED_BLOCK	feedBlock,
			DWORD       dwInstanceId
			)	;



NET_API_STATUS
NET_API_FUNCTION
NntprEnumerateFeeds(
    IN	NNTP_HANDLE ServerName,
    IN	DWORD		InstanceId,
    OUT LPNNTP_FEED_ENUM_STRUCT Buffer
    )
{
    APIERR err = NERR_Success;
    //PLIST_ENTRY listEntry;
    DWORD nbytes = 0;
    DWORD nRead;

    ENTER("NntprEnumerateFeeds")

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    // See if we are up and running
    //

    if ( !pInstance->m_FeedManagerRunning ) {
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return(NERR_ServerNotStarted);
    }

    //
    //  Check for proper access.
    //
    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	EnterCriticalSection( &pInstance->m_critFeedRPCs ) ;

	(pInstance->m_pPassiveFeeds)->ShareLock() ;
	(pInstance->m_pActiveFeeds)->ShareLock() ;

    //
    // Get the size needed
    //

    nbytes = 0;
    EnumerateFeeds( pInstance, NULL, &nbytes, &nRead );

    //
    //  Determine the necessary buffer size.
    //

    Buffer->EntriesRead = 0;
    Buffer->Buffer      = NULL;

    if( nbytes == 0 ) {
        goto exit;
    }

    //
    //  Allocate the buffer.
    //

    Buffer->Buffer =
        (LPI_FEED_INFO) MIDL_user_allocate( (unsigned int)nbytes );

    if ( Buffer->Buffer == NULL ) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // ok, do the right thing
    //

    EnumerateFeeds( pInstance, (PCHAR)Buffer->Buffer, &nbytes, &nRead );
    Buffer->EntriesRead = nRead;

exit:

	LeaveCriticalSection( &pInstance->m_critFeedRPCs ) ;

	(pInstance->m_pActiveFeeds)->ShareUnlock() ;
	(pInstance->m_pPassiveFeeds)->ShareUnlock() ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    LEAVE
    return (NET_API_STATUS)err;

} // NntprEnumerateFeeds

NET_API_STATUS
NET_API_FUNCTION
NntprGetFeedInformation(
    IN	NNTP_HANDLE ServerName,
    IN	DWORD		InstanceId,
    IN	DWORD FeedId,
    OUT LPI_FEED_INFO *Buffer
    )
{
    APIERR err = NERR_Success;
    //PLIST_ENTRY listEntry;
    DWORD nbytes = 0;
    //DWORD nRead;
    PCHAR bufStart;
    PWCHAR bufEnd;
    PFEED_BLOCK feedBlock;

    ENTER("NntprGetFeedInformation")

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    // See if we are up and running
    //

    if ( !pInstance->m_FeedManagerRunning ) {
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return(NERR_ServerNotStarted);
    }

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

    //
    // FeedId == 0 is invalid
    //

    *Buffer = NULL;
    if ( FeedId == 0 ) {
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return(ERROR_INVALID_PARAMETER);
    }

	EnterCriticalSection( &pInstance->m_critFeedRPCs ) ;


	CFeedList*	pList = pInstance->m_pPassiveFeeds ;
	feedBlock = pList->Search( FeedId ) ;
	if( feedBlock != NULL ) {
		goto	Found ;
	}

	pList = pInstance->m_pActiveFeeds ;
	feedBlock = pList->Search( FeedId ) ;
	if( feedBlock != NULL ) {
		goto	Found ;
	}

	LeaveCriticalSection( &pInstance->m_critFeedRPCs ) ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    return(NERR_ResourceNotFound);

Found:

    //
    // Get the size needed
    //

    nbytes = FEEDBLOCK_SIZE( feedBlock );

    //
    //  Allocate the buffer.
    //

    bufStart = (PCHAR)MIDL_user_allocate( (unsigned int)nbytes );

    if ( bufStart == NULL ) {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }	else	{

		//
		// ok, do the right thing
		//

		*Buffer = (LPI_FEED_INFO)bufStart;
		bufEnd = (PWCHAR)(bufStart + nbytes);

		FillFeedInfoBuffer( feedBlock, &bufStart, &bufEnd );
	}

	pList->FinishWith( pInstance, feedBlock ) ;

	LeaveCriticalSection( &pInstance->m_critFeedRPCs ) ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

//exit:

    LEAVE
    return (NET_API_STATUS)err;

} // NntprGetFeedInformation

NET_API_STATUS
NET_API_FUNCTION
NntprSetFeedInformation(
    IN	NNTP_HANDLE ServerName,
    IN	DWORD		InstanceId,
    IN	LPI_FEED_INFO FeedInfo,
    OUT PDWORD ParmErr OPTIONAL
    )
{
    APIERR err = ERROR_NOT_SUPPORTED; // not supported anymore

    return err;

} // NntprSetFeedInformation

NET_API_STATUS
NET_API_FUNCTION
NntprAddFeed(
    IN	NNTP_HANDLE ServerName,
    IN	DWORD		InstanceId,
    IN	LPI_FEED_INFO FeedInfo,
    OUT PDWORD ParmErr OPTIONAL,
	OUT LPDWORD pdwFeedId
    )
{
    APIERR err = ERROR_NOT_SUPPORTED;  // not supported anymore

    return err;

} // NntprAddFeed

NET_API_STATUS
NET_API_FUNCTION
NntprDeleteFeed(
    IN	NNTP_HANDLE ServerName,
    IN	DWORD		InstanceId,
    IN	DWORD FeedId
    )
{
    APIERR err = ERROR_NOT_SUPPORTED;  // not supported anymore

    return err;

} // NntprDeleteFeed

NET_API_STATUS
NET_API_FUNCTION
NntprEnableFeed(
    IN	NNTP_HANDLE ServerName,
    IN	DWORD		InstanceId,
    IN	DWORD FeedId,
	IN	BOOL	 Enable,
	IN	BOOL  Refill,
	IN	FILETIME	RefillTime
    )
{
    APIERR err = ERROR_NOT_SUPPORTED;  // not supported anymore

    return err;
}	// NntprEnableFeed

VOID
FillFeedInfoBuffer (
    IN PFEED_BLOCK FeedBlock,
    IN OUT LPSTR *FixedStructure,
    IN OUT LPWSTR *EndOfVariableData
    )

/*++

Routine Description:

    This routine puts a single fixed file structure and associated
    variable data, into a buffer.  Fixed data goes at the beginning of
    the buffer, variable data at the end.

    *** This routine assumes that ALL the data, both fixed and variable,
        will fit.

Arguments:

    FeedBlock - the FeedBlock from which to get information.

    FixedStructure - where the in the buffer to place the fixed structure.
        This pointer is updated to point to the next available
        position for a fixed structure.

    EndOfVariableData - the last position on the buffer that variable
        data for this structure can occupy.  The actual variable data
        is written before this position as long as it won't overwrite
        fixed structures.  It is would overwrite fixed structures, it
        is not written.

Return Value:

    None.

--*/

{
    DWORD i;
    PCHAR src;
    DWORD length;
    LPWSTR dest;
    LPNNTP_FEED_INFO feedInfo = (LPNNTP_FEED_INFO)(*FixedStructure);

    //
    // Update FixedStructure to point to the next structure location.
    //

    *FixedStructure = (PCHAR)*FixedStructure + sizeof(NNTP_FEED_INFO);
    _ASSERT( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)*FixedStructure );

    //
    // Fill up the structure
    //

    feedInfo->FeedType = FeedBlock->FeedType;
    feedInfo->FeedId = FeedBlock->FeedId;
    feedInfo->FeedInterval = FeedBlock->FeedIntervalMinutes;
	feedInfo->Enabled = FeedBlock->fEnabled ;
	feedInfo->MaxConnectAttempts = FeedBlock->MaxConnectAttempts ;
	feedInfo->ConcurrentSessions = FeedBlock->ConcurrentSessions ;
	feedInfo->SessionSecurityType = FeedBlock->SessionSecurityType ;
	feedInfo->AuthenticationSecurityType = FeedBlock->AuthenticationSecurity ;
	feedInfo->cbUucpName = 0 ;
	feedInfo->UucpName = 0 ;
	feedInfo->cbFeedTempDirectory = 0 ;
	feedInfo->FeedTempDirectory = 0 ;
	feedInfo->cbAccountName = 0 ;
	feedInfo->NntpAccountName = 0 ;
	feedInfo->cbPassword = 0 ;
	feedInfo->NntpPassword = 0 ;
	feedInfo->AutoCreate = FeedBlock->AutoCreate;
	feedInfo->fAllowControlMessages = FeedBlock->fAllowControlMessages;
	feedInfo->OutgoingPort = FeedBlock->OutgoingPort;
	feedInfo->FeedPairId = FeedBlock->FeedPairId;

    FILETIME_FROM_LI(
        &feedInfo->NextActiveTime,
        &FeedBlock->NextActiveTime
        );

    FILETIME_FROM_LI(
        &feedInfo->StartTime,
        &FeedBlock->StartTime,
        );

	if( FEED_IS_PULL( FeedBlock->FeedType ) )
	{
		feedInfo->PullRequestTime = FeedBlock->PullRequestTime;
	}

    //
    // Copy the server name to the output buffer.
    //

    CopyStringToBuffer(
        FeedBlock->ServerName,
        *FixedStructure,
        EndOfVariableData,
        &feedInfo->ServerName
        );

    //
    // go through the Newsgroups list
    //

    length = MultiListSize( FeedBlock->Newsgroups );
    *EndOfVariableData -= length;
    feedInfo->Newsgroups = *EndOfVariableData;
    feedInfo->cbNewsgroups = length * sizeof(WCHAR);

    dest = *EndOfVariableData;
    if ( length > 1 ) {

        src = FeedBlock->Newsgroups[0];
        for ( i = 0; i < length; i++ ) {
            *dest++ = (WCHAR)*((BYTE*)src++);
        }
    } else {

        *dest = L'\0';
    }

    //
    // go through the distribution list
    //

    length = MultiListSize( FeedBlock->Distribution );
    *EndOfVariableData -= length;
    feedInfo->Distribution = *EndOfVariableData;
    feedInfo->cbDistribution = length * sizeof(WCHAR);

    dest = *EndOfVariableData;
    if ( length > 1 ) {

        src = FeedBlock->Distribution[0];
        for ( i = 0; i < length; i++ ) {
            *dest++ = (WCHAR)*((BYTE*)src++);
        }
    } else {
        *dest = L'\0';
    }

	if( FeedBlock->NntpPassword != 0 ) {
		length = lstrlen( FeedBlock->NntpPassword ) + 1 ;
		*EndOfVariableData -= length ;
		feedInfo->NntpPassword = *EndOfVariableData ;
		feedInfo->cbPassword = length * sizeof(WCHAR) ;
		dest = *EndOfVariableData ;

		if( length > 1 ) {
			src = FeedBlock->NntpPassword ;
			for( i=0; i<length; i++ ) {
				*dest++ = (WCHAR)*((BYTE*)src++) ;
			}
		}	else	{
			*dest = L'\0' ;
		}
	}

	if( FeedBlock->NntpAccount!= 0 ) {
		length = lstrlen( FeedBlock->NntpAccount ) + 1 ;
		*EndOfVariableData -= length ;
		feedInfo->NntpAccountName = *EndOfVariableData ;
		feedInfo->cbAccountName = length * sizeof(WCHAR) ;
		dest = *EndOfVariableData ;

		if( length > 1 ) {
			src = FeedBlock->NntpAccount ;
			for( i=0; i<length; i++ ) {
				*dest++ = (WCHAR)*((BYTE*)src++) ;
			}
		}	else	{
			*dest = L'\0' ;
		}
	}

	if( FeedBlock->UucpName != 0 ) {
#if 0
		length = lstrlen( FeedBlock->UucpName ) + 1 ;
		*EndOfVariableData -= length ;
		feedInfo->UucpName = *EndOfVariableData ;
		feedInfo->cbUucpName = length * sizeof(WCHAR) ;
		dest = *EndOfVariableData ;

		if( length > 1 ) {
			src = FeedBlock->UucpName ;
			for( i=0; i<length; i++ ) {
				*dest++ = (WCHAR)*((BYTE*)src++) ;
			}
		}	else	{
			*dest = L'\0' ;
		}
#endif
		length = MultiListSize( FeedBlock->UucpName ) ;
		*EndOfVariableData -= length ;
		feedInfo->UucpName = *EndOfVariableData ;
		feedInfo->cbUucpName = length * sizeof(WCHAR) ;
		dest = *EndOfVariableData ;
		FillLpwstrFromMultiSzTable( FeedBlock->UucpName, dest ) ;
	}

	if( FeedBlock->FeedTempDirectory != 0 ) {
		length = lstrlen( FeedBlock->FeedTempDirectory ) + 1 ;
		*EndOfVariableData -= length ;
		feedInfo->FeedTempDirectory= *EndOfVariableData ;
		feedInfo->cbFeedTempDirectory = length * sizeof(WCHAR) ;
		dest = *EndOfVariableData ;

		if( length > 1 ) {
			src = FeedBlock->FeedTempDirectory ;
			for( i=0; i<length; i++ ) {
				*dest++ = (WCHAR)*((BYTE*)src++) ;
			}
		}	else	{
			*dest = L'\0' ;
		}
	}



    return;

} // FillFeedInfoBuffer

VOID
EnumerateFeeds(
		IN PNNTP_SERVER_INSTANCE pInstance,
        IN PCHAR Buffer OPTIONAL,
        IN OUT PDWORD BuffSize,
        OUT PDWORD EntriesRead
        )
{
    BOOL sizeOnly;
    DWORD nbytes = 0;
    PCHAR bufStart;
    PWCHAR bufEnd;
    PFEED_BLOCK feedBlock;

    *EntriesRead = 0;
    if ( Buffer == NULL ) {

        sizeOnly = TRUE;
    } else {

        _ASSERT(BuffSize != NULL);
        _ASSERT(*BuffSize != 0);

        sizeOnly = FALSE;
        bufStart = Buffer;
        bufEnd = (PWCHAR)(bufStart + *BuffSize);
    }


	CFeedList*	rgLists[2] ;
	rgLists[0] = pInstance->m_pActiveFeeds ;
	rgLists[1] = pInstance->m_pPassiveFeeds ;

	(pInstance->m_pActiveFeeds)->ShareLock() ;
	(pInstance->m_pPassiveFeeds)->ShareLock() ;

	for( int i=0; i<2; i++ ) {

		feedBlock = rgLists[i]->StartEnumerate() ;
		while( feedBlock != 0 ) {
			//
			// Compute the space needed
			//

			if ( sizeOnly ) {

				nbytes += FEEDBLOCK_SIZE(feedBlock);

			} else {

				FillFeedInfoBuffer(
							feedBlock,
							&bufStart,
							&bufEnd
							);
			}
			(*EntriesRead)++;
			feedBlock = rgLists[i]->NextEnumerate( feedBlock ) ;
        }
	}

	(pInstance->m_pActiveFeeds)->ShareUnlock() ;
	(pInstance->m_pPassiveFeeds)->ShareUnlock() ;

    //
    // return the size to the caller
    //

    if ( sizeOnly ) {
        *BuffSize = nbytes;
    }

} // EnumerateFeeds

// TODO: Clean up
/* this goes away
DWORD
AllocateFeedId(
		PNNTP_SERVER_INSTANCE pInstance,
		char	*keyName,	
		DWORD	&feedId
		)
{
	DWORD error;
	static	INT	i = 1 ;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

	TraceFunctEnter( "AllocateFeedId" ) ;

    _ASSERT(pInstance->QueryMDFeedPath() != NULL);

	if( !mb.Open( pInstance->QueryMDFeedPath(), METADATA_PERMISSION_WRITE ) ) {
		error = GetLastError();
		ErrorTrace(0,"Error %d opening %s\n",error,pInstance->QueryMDFeedPath());
		goto error_exit;
	}

	while( i > 0 ) {

		//
		// Find a name for this feed
		//

		feedId = i++;
		wsprintf(keyName,"Feed%d", feedId);

		DebugTrace(0,"Opening %s\n", keyName);
		if( !mb.AddObject( keyName ) ) {

			if( GetLastError() == ERROR_ALREADY_EXISTS ) {
				continue;	// try the next number
			}

			error = GetLastError();
			ErrorTrace(0,"Error %d adding %s\n", error, keyName);
			mb.Close();
			goto error_exit;
		} else {
			break ;	// success - added it !
		}
	}

	if( !mb.Close() || !mb.Save() ) {
		error = GetLastError();
		ErrorTrace(0,"Error %d closing %s\n", error, keyName);
		mb.Close();
        goto error_exit;
	}

	return NO_ERROR ;

error_exit:

	ZeroMemory( keyName, sizeof( keyName ) ) ;
	feedId = 0 ;
	return	error ;

}	// AllocateFeedId

DWORD
DeleteFeedId(
		IN PNNTP_SERVER_INSTANCE pInstance,
        IN char	*keyName
        )
{
    DWORD error;
    ENTER("DeleteFeedId")
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

	if( !mb.Open( pInstance->QueryMDFeedPath(), METADATA_PERMISSION_WRITE ) ) {
		error = GetLastError();
		ErrorTrace(0,"Error %d opening %s\n",error,pInstance->QueryMDFeedPath());
		return error;
	}

	if( !mb.DeleteObject( keyName ) ) {
		error = GetLastError();
		ErrorTrace(0,"Error %d deleting %s\n",error,keyName);
		mb.Close();
		return error;
	}

	_VERIFY( mb.Close() );
	_VERIFY( mb.Save()  );

	return NO_ERROR;

} // DeleteFeedMetabase
*/

BOOL
AddFeedToMetabase(
	IN PNNTP_SERVER_INSTANCE pInstance,
    IN PFEED_BLOCK FeedBlock
    )
{
    CHAR keyName[FEED_KEY_LENGTH+1];
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    static INT i = 1;
    DWORD feedId;
  	char	queueFile[MAX_PATH] ;
	queueFile[0] = '\0' ;
	CFeedQ*	pQueue = 0 ;


    ENTER("AddFeedToMetabase")

    _ASSERT(pInstance->QueryMDFeedPath() != NULL);

	if( !mb.Open( pInstance->QueryMDFeedPath(), METADATA_PERMISSION_WRITE ) ) {
		ErrorTrace(0,"Error %d opening %s\n",GetLastError(),pInstance->QueryMDFeedPath());
		goto error_exit;
	}

    //
    // Find a name for this feed
    //

	while( i > 0 ) {

		feedId = i++;
		wsprintf(keyName,"Feed%d", feedId);

		DebugTrace(0,"Opening %s\n", keyName);
		if( !mb.AddObject( keyName ) ) {

			if( GetLastError() == ERROR_ALREADY_EXISTS ) {
				continue;	// try the next number
			}

			ErrorTrace(0,"Error %d adding %s\n", GetLastError(), keyName);
			mb.Close();
			goto error_exit;
		} else {
			break ;	// success - added it !
		}
	}

	if( !mb.Close() || !mb.Save() ) {
		ErrorTrace(0,"Error %d closing %s\n", GetLastError(), keyName);
		mb.Close();
        goto error_exit;
	}

    //
    // store the key name
    //

    lstrcpy( FeedBlock->KeyName, keyName );
    FeedBlock->FeedId = feedId;
    DO_DEBUG(FEEDMGR) {
        DebugTrace(0,"Setting feed id of %s to %d\n",keyName, feedId);
    }

	if( FEED_IS_PUSH(FeedBlock->FeedType) && FeedBlock->KeyName != 0 ) {

		_ASSERT( FEED_IS_PUSH(FeedBlock->FeedType) ) ;

		// !! Should use the same directory as the other internal database files
		lstrcpy( queueFile, pInstance->m_PeerTempDirectory ) ;
		lstrcat( queueFile, FeedBlock->KeyName ) ;
		lstrcat( queueFile, ".fdq" ) ;

		pQueue= XNEW CFeedQ() ;
		if( pQueue == 0 )	{
			goto	error_exit ;
		}	else	{
			if( !pQueue->Init( queueFile ) )	{
				XDELETE	pQueue;
				goto	error_exit ;
			}
		}
	}

	FeedBlock->pFeedQueue = pQueue ;

    //
    //	Update the registry keys
	//	NOTE: we may want to optimize and not do a mb.Close() before calling
	//	UpdateFeedMetabaseValues() - in that case we should pass in mb.
    //

    if ( !UpdateFeedMetabaseValues( pInstance, FeedBlock, FEED_ALL_PARAMS ) ) {

        ErrorTrace(0,"Update Reg failed. Deleting %s\n",keyName);
		if( !mb.Open( pInstance->QueryMDFeedPath(), METADATA_PERMISSION_WRITE ) ) {
			ErrorTrace(0,"Error %d opening %s\n",GetLastError(),pInstance->QueryMDFeedPath());
			goto error_exit;
		}

		if( !mb.DeleteObject( keyName ) ) {
			ErrorTrace(0,"Error %d deleting %s\n",GetLastError(),keyName);
		}

		_VERIFY( mb.Close() );
		_VERIFY( mb.Save()  );

        goto error_exit;
    }

    return(TRUE);

error_exit:

    return(FALSE);

} // AddFeedToMetabase

BOOL
UpdateFeedMetabaseValues(
			IN PNNTP_SERVER_INSTANCE pInstance,
            IN PFEED_BLOCK FeedBlock,
            IN DWORD Mask
            )
{
    PCHAR regstr;
    //DWORD error;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    ENTER("UpdateFeedMetabaseValues")

    //
    // Open the metabase key
    //

    if ( !mb.Open( pInstance->QueryMDFeedPath(), METADATA_PERMISSION_WRITE ) )
	{
		ErrorTrace(0,"Error opening %s\n",FeedBlock->KeyName);
        return(FALSE);
	}

	//
	// Set the KeyType.
	//

	if( !mb.SetString(	FeedBlock->KeyName,
    					MD_KEY_TYPE,
						IIS_MD_UT_SERVER,
    					NNTP_ADSI_OBJECT_FEED,
    					METADATA_NO_ATTRIBUTES
						) )
	{
        regstr = "KeyType";
        goto error_exit;
	}

    //
    // set the type
    //

    if ( (Mask & FEED_PARM_FEEDTYPE) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_TYPE,
							IIS_MD_UT_SERVER,
							FeedBlock->FeedType
							) )
		{
            regstr = StrFeedType;
            goto error_exit;
		}
    }


    //
    // set the auto create option
    //

    if ( (Mask & FEED_PARM_AUTOCREATE) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_CREATE_AUTOMATICALLY,
							IIS_MD_UT_SERVER,
							FeedBlock->AutoCreate
							) )
		{
            regstr = StrFeedAutoCreate;
            goto error_exit;
		}
    }

    //
    // if this is not an active feed, interval and start time
    // are na
    //

    if ( !FEED_IS_PASSIVE(FeedBlock->FeedType) ) {

        //
        // set the Feed interval
        //

        if ( (Mask & FEED_PARM_FEEDINTERVAL) != 0 ) {
			if( !mb.SetDword(	FeedBlock->KeyName,
								MD_FEED_INTERVAL,
								IIS_MD_UT_SERVER,
								FeedBlock->FeedIntervalMinutes
								) )
			{
				regstr = StrFeedInterval;
				goto error_exit;
			}
        }

        //
        // set the interval time
        //

        if ( (Mask & FEED_PARM_STARTTIME) != 0 ) {
			if( !mb.SetDword(	FeedBlock->KeyName,
								MD_FEED_START_TIME_HIGH,
								IIS_MD_UT_SERVER,
								FeedBlock->StartTime.HighPart
								) )
			{
				regstr = StrFeedStartHigh;
				goto error_exit;
			}

			if( !mb.SetDword(	FeedBlock->KeyName,
								MD_FEED_START_TIME_LOW,
								IIS_MD_UT_SERVER,
								FeedBlock->StartTime.LowPart
								) )
			{
				regstr = StrFeedStartLow;
				goto error_exit;
			}
        }

        //
        // set the pull request  time
        //

        if ( (Mask & FEED_PARM_PULLREQUESTTIME) != 0 ) {
			if( !mb.SetDword(	FeedBlock->KeyName,
								MD_FEED_NEXT_PULL_HIGH,
								IIS_MD_UT_SERVER,
								FeedBlock->PullRequestTime.dwHighDateTime
								) )
			{
				regstr = StrFeedNextPullHigh;
				goto error_exit;
			}

			if( !mb.SetDword(	FeedBlock->KeyName,
								MD_FEED_NEXT_PULL_LOW,
								IIS_MD_UT_SERVER,
								FeedBlock->PullRequestTime.dwLowDateTime
								) )
			{
				regstr = StrFeedNextPullLow;
				goto error_exit;
			}
        }
    }

    //
    // set the server name
    //

    if ( (Mask & FEED_PARM_SERVERNAME) != 0 ) {
		if( !mb.SetString(	FeedBlock->KeyName,
							MD_FEED_SERVER_NAME,
							IIS_MD_UT_SERVER,
							FeedBlock->ServerName
							) )
		{
			regstr = StrServerName;
			goto error_exit;
		}
    }

    //
    //	set the newsgroups
	//	bug in metabase - need to calculate multisz size !
    //

    if ( (Mask & FEED_PARM_NEWSGROUPS) != 0 ) {
		if( !mb.SetData(	FeedBlock->KeyName,
							MD_FEED_NEWSGROUPS,
							IIS_MD_UT_SERVER,
							MULTISZ_METADATA,
							FeedBlock->Newsgroups[0],
							MultiListSize( FeedBlock->Newsgroups )
							) )
		{
			regstr = StrFeedNewsgroups;
			goto error_exit;
		}
    }

    //
    // set the distribution
    //

    if ( (Mask & FEED_PARM_DISTRIBUTION) != 0 ) {
		if( !mb.SetData(	FeedBlock->KeyName,
							MD_FEED_DISTRIBUTION,
							IIS_MD_UT_SERVER,
							MULTISZ_METADATA,
							FeedBlock->Distribution[0],
							MultiListSize( FeedBlock->Distribution )
							) )
		{
			regstr = StrFeedDistribution;
			goto error_exit;
		}
    }

	if( (Mask & FEED_PARM_ENABLED) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_DISABLED,
							IIS_MD_UT_SERVER,
							FeedBlock->fEnabled
							) )
		{
			regstr = StrFeedDisabled;
			goto error_exit;
		}
	}

	if( (Mask & FEED_PARM_UUCPNAME) != 0 && FeedBlock->UucpName != 0 ) {
	
		char	szTemp[4096] ;
		FillLpstrFromMultiSzTable( FeedBlock->UucpName,&szTemp[0] ) ;

		if( !mb.SetString(	FeedBlock->KeyName,
							MD_FEED_UUCP_NAME,
							IIS_MD_UT_SERVER,
							szTemp
							) )
		{
			regstr = StrFeedUucpName;
			goto error_exit;
		}
	}

	if( (Mask & FEED_PARM_TEMPDIR) != 0 && FeedBlock->FeedTempDirectory != 0 ) {
		if( !mb.SetString(	FeedBlock->KeyName,
							MD_FEED_TEMP_DIRECTORY,
							IIS_MD_UT_SERVER,
							FeedBlock->FeedTempDirectory
							) )
		{
			regstr = StrFeedTempDir;
			goto error_exit;
		}
	}

	if( (Mask & FEED_PARM_MAXCONNECT) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_MAX_CONNECTION_ATTEMPTS,
							IIS_MD_UT_SERVER,
							FeedBlock->MaxConnectAttempts
							) )
		{
			regstr = StrFeedMaxConnectAttempts;
			goto error_exit;
		}
	}

	if( (Mask & FEED_PARM_SESSIONSECURITY) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_SECURITY_TYPE,
							IIS_MD_UT_SERVER,
							FeedBlock->SessionSecurityType
							) )
		{
			regstr = StrFeedSecurityType;
			goto error_exit;
		}
	}

	if( (Mask & FEED_PARM_CONCURRENTSESSION) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_CONCURRENT_SESSIONS,
							IIS_MD_UT_SERVER,
							FeedBlock->ConcurrentSessions
							) )
		{
			regstr = StrFeedConcurrentSessions;
			goto error_exit;
		}
	}

	if( (Mask & FEED_PARM_AUTHTYPE) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_AUTHENTICATION_TYPE,
							IIS_MD_UT_SERVER,
							FeedBlock->AuthenticationSecurity
							) )
		{
			regstr = StrFeedAuthType;
			goto error_exit;
		}
	}

	if( (Mask & FEED_PARM_ACCOUNTNAME) != 0 && FeedBlock->NntpAccount != 0 ) {
		if( !mb.SetString(	FeedBlock->KeyName,
							MD_FEED_ACCOUNT_NAME,
							IIS_MD_UT_SERVER,
							FeedBlock->NntpAccount
							) )
		{
			regstr = StrFeedAuthAccount;
			goto error_exit;
		}
	}

	if( (Mask & FEED_PARM_PASSWORD) != 0 && FeedBlock->NntpPassword != 0 ) {
		if( !mb.SetString(	FeedBlock->KeyName,
							MD_FEED_PASSWORD,
							IIS_MD_UT_SERVER,
							FeedBlock->NntpPassword,
							METADATA_SECURE
							) )
		{
			regstr = StrFeedAuthPassword;
			goto error_exit;
		}
	}

    //
    // set the allow control message flag
    //

    if ( (Mask & FEED_PARM_ALLOW_CONTROL) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_ALLOW_CONTROL_MSGS,
							IIS_MD_UT_SERVER,
							FeedBlock->fAllowControlMessages
							) )
		{
			regstr = StrFeedAllowControl;
			goto error_exit;
		}
    }

    //
    // set the outgoing port
    //

    if ( (Mask & FEED_PARM_OUTGOING_PORT) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_OUTGOING_PORT,
							IIS_MD_UT_SERVER,
							FeedBlock->OutgoingPort
							) )
		{
			regstr = StrFeedOutgoingPort;
			goto error_exit;
		}
    }

    //
    // set the feed pair id
    //

    if ( (Mask & FEED_PARM_FEEDPAIR_ID) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_FEEDPAIR_ID,
							IIS_MD_UT_SERVER,
							FeedBlock->FeedPairId
							) )
		{
			regstr = StrFeedPairId;
			goto error_exit;
		}
    }

	_VERIFY( mb.Close() );
	_VERIFY( mb.Save()  );

    return(TRUE);

error_exit:

    mb.Close();
    ErrorTrace(0,"Error %d setting %s for %s\n", GetLastError(), regstr, FeedBlock->KeyName);

    return(FALSE);

} // UpdateFeedRegistryValue

DWORD
DeleteFeedMetabase(
		IN PNNTP_SERVER_INSTANCE pInstance,
        IN PFEED_BLOCK FeedBlock
        )
{
    DWORD error;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    ENTER("DeleteFeedMetabase")

	if( !mb.Open( pInstance->QueryMDFeedPath(), METADATA_PERMISSION_WRITE ) ) {
		error = GetLastError();
		ErrorTrace(0,"Error %d opening %s\n",error,pInstance->QueryMDFeedPath());
		return error;
	}

	if( !mb.DeleteObject( FeedBlock->KeyName ) ) {
		error = GetLastError();
		ErrorTrace(0,"Error %d deleting %s\n",error,FeedBlock->KeyName);
		mb.Close();
		return error;
	}

	_VERIFY( mb.Close() );
	_VERIFY( mb.Save()  );

	return NO_ERROR;

} // DeleteFeedMetabase


LPSTR
GetFeedTypeDescription(	
		IN	FEED_TYPE	feedType
		)
{

	LPSTR	lpstrReturn = "<Bad Feed Type>" ;

	if(	FEED_IS_PULL( feedType ) ) {

		lpstrReturn = "Pull" ;

	}	else	if( FEED_IS_PEER( feedType ) ) {

		if( FEED_IS_PUSH( feedType ) ) {

			lpstrReturn = "Push To Peer" ;
	
		}	else	if( FEED_IS_PASSIVE( feedType ) ) {

			lpstrReturn = "Incoming Peer" ;

		}

	}	else	if( FEED_IS_MASTER( feedType ) ) {

		if( FEED_IS_PUSH( feedType ) ) {

			lpstrReturn = "Push To Master" ;
	
		}	else	if( FEED_IS_PASSIVE( feedType ) ) {

			lpstrReturn = "Incoming Master" ;

		}

	}	else	if( FEED_IS_SLAVE( feedType ) ) {

		if( FEED_IS_PUSH( feedType ) ) {

			lpstrReturn = "Push To Slave" ;
	
		}	else	if( FEED_IS_PASSIVE( feedType ) ) {

			lpstrReturn = "Incoming Slave" ;

		}
	}

	return	lpstrReturn ;

}	//	GetFeedTypeDescription

void
LogFeedAdminEvent(	DWORD		event,
					PFEED_BLOCK	feedBlock,
					DWORD       dwInstanceId
					)	
{

	PCHAR	args[3] ;
	CHAR    szId[20];

	_itoa( dwInstanceId, szId, 10 );
	args[0] = szId ;
	args[1] = GetFeedTypeDescription( feedBlock->FeedType ) ;
	args[2] = feedBlock->ServerName ;

	NntpLogEvent(
			event,
			3,
			(const char**)args,
			0 ) ;

}	//	LogFeedAdminEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\svcsupp.cpp ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    svcsupp.cpp

Abstract:

    This module contains support routines for rpc calls

Author:

    Johnson Apacible (JohnsonA)     12-Nov-1995

Revision History:

--*/

//#ifdef	UNIT_TEST
//#include	<windows.h>
//#include	<dbgtrace.h>
//#include	<stdio.h>
//#include	"nntpmacr.h"
//#else
#include	<buffer.hxx>
#include "tigris.hxx"
#include "nntpsvc.h"
#include <time.h>
//#endif


VOID
CopyUnicodeStringIntoAscii(
        IN LPSTR AsciiString,
        IN LPWSTR UnicodeString
        )
{

    DWORD cbW = (wcslen( UnicodeString )+1) * sizeof(WCHAR);
    DWORD cbSize = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        (LPCWSTR)UnicodeString,
                        -1,
                        AsciiString,
                        cbW,
                        NULL,
                        NULL
                    );

    if( (int)cbSize >= 0 ) {
        AsciiString[cbSize] = '\0';
    }

    _ASSERT( cbW != 0 );

} // CopyUnicodeStringIntoAscii

VOID
CopyNUnicodeStringIntoAscii(
        IN LPSTR AsciiString,
        IN LPWSTR UnicodeString,
		IN DWORD cbUnicodeLen,
		IN DWORD cbAsciiLen
        )
{
	_ASSERT(cbUnicodeLen != 0);

    DWORD cbSize = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        (LPCWSTR)UnicodeString,
                        cbUnicodeLen,
                        AsciiString,
                        cbAsciiLen,
                        NULL,
                        NULL
                    );

    _ASSERT (cbSize > 0);

    if( (int)cbSize >= 0 ) {
        AsciiString[cbSize] = '\0';
    }

} // CopyNUnicodeStringIntoAscii

LPWSTR
CopyAsciiStringIntoUnicode(
        IN LPWSTR UnicodeString,
        IN LPSTR AsciiString
        )
{
    DWORD cbA = strlen( AsciiString )+1;

    DWORD cbSize = MultiByteToWideChar(
        CP_ACP,         // code page
        0,              // character-type options
        AsciiString,    // address of string to map
        -1,             // number of bytes in string
        UnicodeString,  // address of wide-character buffer
        cbA        // size of buffer
        );

    if ((int)cbSize >= 0) {
        UnicodeString[cbSize] = L'\0';
    }

    return UnicodeString + wcslen(UnicodeString) + 1;

} // CopyAsciiStringIntoUnicode

VOID
CopyNAsciiStringIntoUnicode(
        IN LPWSTR UnicodeString,
        IN LPSTR  AsciiString,
        IN DWORD  dwAsciiLen,
        IN DWORD  dwUnicodeLen)
{

    DWORD cbSize = MultiByteToWideChar(
        CP_ACP,         // code page
        0,              // character-type options
        AsciiString,    // address of string to map
        dwAsciiLen,     // number of bytes in string
        UnicodeString,  // address of wide-character buffer
        dwUnicodeLen    // size of buffer
        );

    _ASSERT(cbSize > 0);

    if ((int)cbSize >= 0) {
        UnicodeString[cbSize] = L'\0';
    }
}

DWORD
MultiListSize(
    LPSTR *List
    )
/*++

Routine Description:

    This routine computes the size of the multisz structure needed
    to accomodate a list.

Arguments:

    List - the list whose string lengths are to be computed

Return Value:

    Size of buffer needed to accomodate list.

--*/
{
    DWORD nBytes = 1;
    DWORD i = 0;

    if ( List != NULL ) {
        while ( List[i] != NULL ) {
            nBytes += lstrlen(List[i]) + 1;
            i++;
        }
    }
    return(nBytes);
} // MultiListSize

BOOL
VerifyMultiSzListW(
    LPBYTE List,
    DWORD cbList
    )
/*++

Routine Description:

    This routine verifies that the list is indeed a multisz

Arguments:

    List - the list to be verified
    cbList - size of the list

Return Value:

    TRUE, list is a multisz
    FALSE, otherwise

--*/
{
    PWCHAR wList = (PWCHAR)List;
    DWORD len;

    START_TRY

    //
    // null are considered no hits
    //

    if ( (List == NULL) || (*List == L'\0') ) {
        return(FALSE);
    }

    //
    // see if they are ok
    //

    for ( DWORD j = 0; j < cbList; ) {

        len = wcslen((LPWSTR)&List[j]);

        if ( len > 0 ) {

            j += ((len + 1) * sizeof(WCHAR));
        } else {

            //
            // all done
            //

            return(TRUE);
        }
    }

    TRY_EXCEPT
#ifndef	UNIT_TEST
        ErrorTraceX(0,"VerifyMultiSzListW: exception handled\n");
#endif
    END_TRY
    return(FALSE);

} // VerifyMultiSzList

VOID
CopyStringToBuffer (
    IN PCHAR String,
    IN PCHAR FixedStructure,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    )

/*++

Routine Description:

    This routine puts a single  string into a
    buffer.  The string data is converted to UNICODE as it is copied.  The
    string is not written if it would overwrite the last fixed structure
    in the buffer.

Arguments:

    String - a pointer to the string to copy into the buffer.  If String
        is null (Length == 0 || Buffer == NULL) then a pointer to a
        zero terminator is inserted.

    FixedStructure - a pointer to the end of the last fixed
        structure in the buffer.

    EndOfVariableData - the last position on the buffer that variable
        data for this structure can occupy.

    VariableDataPointer - a pointer to the place in the buffer where
        a pointer to the variable data should be written.

Return Value:

    None.

--*/

{
    ULONG length;

    //
    // Determine where in the buffer the string will go, allowing for a
    // zero-terminator.  (MB2WC returns length including null)
    //

    length = MultiByteToWideChar(CP_ACP, 0, String, -1, NULL, 0);
    *EndOfVariableData -= length;

    //
    // Will the string fit?  If no, just set the pointer to NULL.
    //

    if ( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)FixedStructure && length != 0) {

        //
        // It fits.  Set up the pointer to the place in the buffer where
        // the string will go.
        //

        *VariableDataPointer = *EndOfVariableData;

        //
        // Copy the string to the buffer if it is not null.
        //

		if (MultiByteToWideChar(CP_ACP, 0, String, -1, *EndOfVariableData, length) == 0) {
			_ASSERT(!"Not enough room for string");
			*VariableDataPointer = NULL;
		}

    } else {

        //
        // It doesn't fit.  Set the offset to NULL.
        //

        *VariableDataPointer = NULL;
        _ASSERT(FALSE);
    }

    return;

} // CopyStringToBuffer


DWORD
GetNumStringsInMultiSz(
    PCHAR Blob,
    DWORD BlobSize
    )
/*++

Routine Description:

    This routine returns the number of strings in the multisz

Arguments:

    Blob - the list to be verified
    BlobSize - size of the list

Return Value:

    number of entries in the multisz structure.

--*/
{
    DWORD entries = 0;
    DWORD len;
    DWORD j;

    for ( j = 0; j < BlobSize; ) {
        len = lstrlen(&Blob[j]);
        if ( len > 0 ) {
            entries++;
        }
        j += (len + 1);
        if( len == 0 ) {
            break;
        }
    }

    _ASSERT( j == BlobSize );
    return(entries);

} // GetNumStringsInMultiSz

LPSTR *
AllocateMultiSzTable(
            IN PCHAR List,
            IN DWORD cbList,
            IN BOOL IsUnicode
            )
{
    DWORD len;
    PCHAR buffer;
    DWORD entries = 0;
    LPSTR* table;
    PCHAR nextVar;
    CHAR tempBuff[4096];
    DWORD numItems;

    //
    // if this is in unicode, convert to ascii
    //

    if ( IsUnicode ) {

        cbList /= sizeof(WCHAR);

        _ASSERT(cbList <= 4096);

        CopyNUnicodeStringIntoAscii(tempBuff, (PWCHAR)List,
            cbList, sizeof(tempBuff) / sizeof(WCHAR));

        List = tempBuff;
    }

    numItems = GetNumStringsInMultiSz( List, cbList );
    if ( numItems == 0 ) {
        return(NULL);
    }

    buffer = (PCHAR)ALLOCATE_HEAP((numItems + 1) * sizeof(LPSTR) + cbList);
    if ( buffer == NULL ) {
        return(NULL);
    }

    table = (LPSTR *)buffer;
    nextVar = buffer + (numItems + 1)*sizeof(LPSTR);

    for ( DWORD j = 0; j < cbList; ) {

        len = lstrlen(&List[j]);
        if ( len > 0 ) {
            table[entries] = (LPSTR)nextVar;
            CopyMemory(nextVar,&List[j],len+1);
            (VOID)_strlwr(table[entries]);
            entries++;
            nextVar += (len+1);
        }
        j += (len + 1);
    }

    *nextVar = '\0';
    table[numItems] = NULL;
    return(table);

} // AllocateMultiSzTable

LPSTR*
CopyMultiList(
			LPSTR*	List
			) {

	LPSTR*	pListOut = 0 ;

	pListOut = AllocateMultiSzTable( *List, MultiListSize( List ), FALSE ) ;

	return	pListOut ;
}


LPSTR*
MultiSzTableFromStrA(
	LPCSTR	lpstr
	)	{

	_ASSERT( lpstr != 0 ) ;

	int	cb = lstrlen( lpstr ) ;

	int	cbRequired = 0 ;
	int	cPointerRequired = 0 ;

	for( int i=0; i < cb; i++ ) {

		for( int j=i; j<cb; j++ ) {
			if( !isspace( (BYTE)lpstr[j] ) ) break ;
		}

		if( j!=cb ) {
			cPointerRequired ++ ;
		}

		for( ; j<cb; j++ ) {
			cbRequired ++ ;
			if( isspace( (BYTE)lpstr[j] ) ) 	break ;
		}
		i=j ;
	}

	if( cPointerRequired == 0 ) {

		_ASSERT( cbRequired == 0 ) ;

		LPSTR	buffer = (PCHAR)ALLOCATE_HEAP(2*sizeof(LPSTR) + 2);
		if ( buffer == NULL ) {
			return(NULL);
		}
		ZeroMemory( buffer, 2*sizeof( LPSTR ) + 2 ) ;
		LPSTR*	table = (LPSTR*)buffer ;
		table[0] = &buffer[sizeof(table)*2] ;
		return	table ;
	}

    LPSTR	buffer = (PCHAR)ALLOCATE_HEAP((cPointerRequired + 1) * sizeof(LPSTR) + (cbRequired+2) * sizeof( char ) );
    if ( buffer == NULL ) {
        return(NULL);
    }

    LPSTR*	table = (LPSTR *)buffer;
    LPSTR	nextVar = buffer + (cPointerRequired + 1)*sizeof(LPSTR);

	int	k=0 ;

    for ( i = 0; i < cb; i++ ) {

		for( int j=i; j<cb; j++ ) {
			if( !isspace( (BYTE)lpstr[j] ) ) break ;
		}

		if( j!=cb ) {
			table[k++] = nextVar ;

			for( ; j<cb; j++ ) {
				if( isspace( (BYTE)lpstr[j] )	) break ;
				*nextVar++ = lpstr[j] ;
			}
			*nextVar++ = '\0' ;
		}
		i=j ;
	}

	*nextVar++ = '\0' ;

	_ASSERT( k==cPointerRequired ) ;

    table[k] = NULL;
    return(table);
}


LPSTR*
MultiSzTableFromStrW(
	LPWSTR	lpwstr
	)	{

	char	szTemp[4096] ;

	DWORD	cb = wcslen( lpwstr ) ;
	if( cb > sizeof( szTemp ) ) {
		return	0 ;
	}
    CopyUnicodeStringIntoAscii(szTemp, lpwstr);

	return	MultiSzTableFromStrA( szTemp ) ;
}


LPSTR
LpstrFromMultiSzTableA(
	LPSTR*	plpstr
	)	{

	DWORD	cb = MultiListSize( plpstr ) ;

    LPSTR	buffer = (PCHAR)ALLOCATE_HEAP(cb * sizeof( char ) );
    if ( buffer == NULL ) {
        return(NULL);
    }
	buffer[0] = '\0' ;

	LPSTR	lpstr = *plpstr++ ;
	while( lpstr != 0 ) {
		lstrcat( buffer, lpstr ) ;
		lpstr = *plpstr++ ;
		if( lpstr != 0 )
			lstrcat( buffer, " " ) ;
	}

	return	buffer ;
}

LPWSTR
LpwstrFromMultiSzTableA(
	LPSTR*	plpstr
	)	{

	LPSTR	lpstr = LpstrFromMultiSzTableA( plpstr ) ;
	LPWSTR	buffer = 0 ;
	if( lpstr != 0 ) {
		DWORD	cb = lstrlen( lpstr ) + 1 ;

		buffer = (LPWSTR)ALLOCATE_HEAP( cb * sizeof( WCHAR ) ) ;

		if( buffer != 0 ) {
			CopyAsciiStringIntoUnicode( buffer, lpstr ) ;
		}
		FREE_HEAP( lpstr ) ;
	}
	return	buffer ;
}

void
FillLpwstrFromMultiSzTable(
	LPSTR*	plpstr,
	LPWSTR	lpwstr
	)	{

	LPSTR	lpstr = *plpstr++ ;
	while( lpstr != 0 ) {

		lpwstr = CopyAsciiStringIntoUnicode( lpwstr, lpstr ) ;
		lpstr = *plpstr++ ;
		if( lpstr != 0 )
			lpwstr[-1] = L' ' ;
	}
}

void
FillLpstrFromMultiSzTable(
	LPSTR*	plpstr,
	LPSTR	lpstrFill
	)	{

	lpstrFill[0] = '\0' ;
	LPSTR	lpstr = *plpstr++ ;
	while( lpstr != 0 ) {

		lstrcat( lpstrFill, lpstr ) ;
		lpstr = *plpstr++ ;
		if( lpstr != 0 )
			lstrcat( lpstrFill, " " ) ;
	}
}


BOOL
MultiSzIntersect(
	LPSTR*	plpstr,
	LPSTR	szmulti
	) {

	if( plpstr == 0 || szmulti == 0 ) {
		return	FALSE ;
	}

	BOOL	fMatch = FALSE ;

	for(	LPSTR	lpstrTest = szmulti;
					*lpstrTest != '\0';
					lpstrTest += lstrlen( lpstrTest ) + 1 ) {

		for( LPSTR*	plpstrCur = plpstr; *plpstrCur != 0; plpstrCur ++ ) {

			if( lstrcmpi( lpstrTest, *plpstrCur ) == 0 ) {
				return	TRUE ;
			}
		}
	}
	return	FALSE ;
}


LPSTR	*
ReverseMultiSzTable(
	IN	LPSTR*	plpstr
	)
{

	DWORD	cbLength = 0 ;
	DWORD	numItems = 0 ;

	while( plpstr[numItems] != 0 )
		cbLength += lstrlen( plpstr[ numItems++ ] ) + 1 ;
	cbLength ++ ;	// for double NULL terminator

	if( numItems == 0 ) {
		return	plpstr ;
	}

	PCHAR	buffer = (PCHAR)ALLOCATE_HEAP((numItems+1)*sizeof(LPSTR) + cbLength ) ;

	if( buffer == NULL ) {
		return	NULL ;
	}

	LPSTR*	table = (LPSTR*)buffer ;
	LPSTR	nextVar = buffer + (numItems+1) * sizeof(LPSTR) ;

	table[numItems] = NULL ;
	for( int i=numItems-1, index=0; i >=0; i--, index++ ) {
		table[index] = nextVar ;
		lstrcpy( table[index], plpstr[i] ) ;
		nextVar += lstrlen( table[index] ) + 1 ;
	}
	*nextVar = '\0' ;
	return	table ;
}

#ifdef	UNIT_TEST

void
main( int	argc, char**	argv ) {


	unsigned	char	szTemp[4096] ;
	WCHAR	szwTemp[4096] ;

	InitAsyncTrace();

	for( int i=0; i<argc; i++ ) {

		printf( "argv - %s\n", argv[i] ) ;

		LPSTR*	table = MultiSzTableFromStrA( argv[i] ) ;

		for( int j=0; table[j] != '\0'; j++ ) {

			printf( "%d %s\n", j, table[j] ) ;

		}

		LPSTR	szSpace = LpstrFromMultiSzTableA( table ) ;
		printf( "szSpace = =%s=\n", szSpace ) ;

		FillMemory( szTemp, sizeof( szTemp ), 0xcc ) ;
		FillLpstrFromMultiSzTable( table, (char*)szTemp ) ;
		printf( "FillLpstrFromMultiSzTable =%s=\n", szTemp ) ;
		_ASSERT( szTemp[ MultiListSize( table ) ] == 0xCC ) ;

		FillMemory( szwTemp, sizeof( szwTemp ), 0xcc ) ;
		FillLpwstrFromMultiSzTable( table, szwTemp ) ;
		printf( "FillLpstrFromMultiSzTable =%ws=\n", szwTemp ) ;
		_ASSERT( szwTemp[ MultiListSize( table ) ] == 0xCCCC ) ;

	}

	LPSTR*	table = MultiSzTableFromStrA( "  \t\n\r  " ) ;

	_ASSERT( table != 0 ) ;
	_ASSERT( table[0][0] == '\0' ) ;

	LPSTR	szSpace = LpstrFromMultiSzTableA( table ) ;
	printf( "szSpace = =%s=\n", szSpace ) ;

	FillMemory( szTemp, sizeof( szTemp ), 0xcc ) ;
	FillLpstrFromMultiSzTable( table, (char*)szTemp ) ;
	printf( "FillLpstrFromMultiSzTable =%s=\n", szTemp ) ;
	_ASSERT( szTemp[ MultiListSize( table ) ] == 0xCC ) ;

	FillMemory( szwTemp, sizeof( szwTemp ), 0xcc ) ;
	FillLpwstrFromMultiSzTable( table, szwTemp ) ;
	printf( "FillLpstrFromMultiSzTable =%ws=\n", szwTemp ) ;
	_ASSERT( szwTemp[ MultiListSize( table ) ] == 0xCCCC ) ;

	table = MultiSzTableFromStrA( "" ) ;

	_ASSERT( table != 0 ) ;
	_ASSERT( table[0][0] == '\0' ) ;

	szSpace = LpstrFromMultiSzTableA( table ) ;
	printf( "szSpace = =%s=\n", szSpace ) ;

	FillMemory( szTemp, sizeof( szTemp ), 0xcc ) ;
	FillLpstrFromMultiSzTable( table, (char*)szTemp ) ;
	printf( "FillLpstrFromMultiSzTable =%s=\n", szTemp ) ;
	_ASSERT( szTemp[ MultiListSize( table ) ] == 0xCC ) ;

	FillMemory( szwTemp, sizeof( szwTemp ), 0xcc ) ;
	FillLpwstrFromMultiSzTable( table, szwTemp ) ;
	printf( "FillLpstrFromMultiSzTable =%ws=\n", szwTemp ) ;
	_ASSERT( szwTemp[ MultiListSize( table ) ] == 0xCCCC ) ;

	table = MultiSzTableFromStrA( 0 ) ;

	_ASSERT( table != 0 ) ;
	_ASSERT( table[0][0] == '\0' ) ;

	szSpace = LpstrFromMultiSzTableA( table ) ;
	printf( "szSpace = =%s=\n", szSpace ) ;

	FillMemory( szTemp, sizeof( szTemp ), 0xcc ) ;
	FillLpstrFromMultiSzTable( table, (char*)szTemp ) ;
	printf( "FillLpstrFromMultiSzTable =%s=\n", szTemp ) ;

	FillMemory( szwTemp, sizeof( szwTemp ), 0xcc ) ;
	FillLpwstrFromMultiSzTable( table, szwTemp ) ;
	printf( "FillLpstrFromMultiSzTable =%ws=\n", szwTemp ) ;
	_ASSERT( szwTemp[ MultiListSize( table ) ] == 0xCCCC ) ;


	char	*szTestString[]	= {	"abcd bcde bcdef fjfjj8 fjsdk sdfjks",
								"fjsdklf fjsdkl fdjs432 432j4kl 23k4jklj 23klj4",
								"fhsd f89ds8 fsd890 fmdsb s78df8 fmnsd f9f8s6 fsdh",
								"fsdk",
								"j",
								"abcd",
								"bcde fjdskl",
								"fjsdkfjkldsjf bcddef fjdskl",
								""
								} ;

	int	c = sizeof( szTestString ) / sizeof( szTestString[0] ) ;
	for( i=0; i<c; i++ ) {

		LPSTR*	table = MultiSzTableFromStrA( szTestString[i] ) ;
		for( int j=0; j<c; j++ ) {
			LPSTR*	table2 = MultiSzTableFromStrA( szTestString[j] ) ;

			if( MultiSzIntersect( table, *table2 ) ) {
				_ASSERT( MultiSzIntersect( table2, *table ) ) ;
			}	else	{
				_ASSERT( !MultiSzIntersect( table2, *table ) ) ;
			}
			FREE_HEAP( table2 ) ;
		}
		LPSTR*	copy = CopyMultiList( table ) ;


		FREE_HEAP( copy ) ;
		FREE_HEAP( table ) ;
	}
	_ASSERT( *szSpace == '\0' ) ;

	TermAsyncTrace();
}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\svcsess.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    svcsess.cpp

Abstract:

    This module contains code for doing feed rpcs.

Author:

    Johnson Apacible (JohnsonA)     12-Nov-1995

Revision History:

--*/

#define INCL_INETSRV_INCS
#include "tigris.hxx"
#include "nntpsvc.h"


NET_API_STATUS
NET_API_FUNCTION
NntprEnumerateSessions(
    IN	NNTP_HANDLE ServerName,
    IN	DWORD		InstanceId,
    OUT LPNNTP_SESS_ENUM_STRUCT Buffer
    )
{
    APIERR err = NERR_Success;

    ENTER("NntprEnumerateSessions")

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
    	pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

    //
    // Enumerate
    //

    err = CSessionSocket::EnumerateSessions( pInstance, Buffer );
    if ( err != NO_ERROR ) {
        ErrorTrace(0,"EnumerateSessions failed with %lu\n",err );
    }

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    return(err);

} // NntprEnumerateSessions

NET_API_STATUS
NET_API_FUNCTION
NntprTerminateSession(
    IN	NNTP_HANDLE ServerName,
    IN	DWORD		InstanceId,
    IN	LPSTR UserName,
    IN	LPSTR IPAddress
    )
{
    APIERR err = NERR_Success;

    ENTER("NntprTerminateSession")

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
	    pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

    //
    // Enumerate and find the session that meets description
    //

    err = CSessionSocket::TerminateSession( pInstance, UserName, IPAddress );
    if ( err != NO_ERROR ) {
        ErrorTrace(0,"TerminateSession failed with %lu\n",err );
    }
	else
	{
		PCHAR	args[3] ;
		CHAR    szId[20];
		_itoa( pInstance->QueryInstanceId(), szId, 10 );
		args[0] = szId;
		args[1] = UserName ;
		args[2] = IPAddress ;

		NntpLogEvent(		
				NNTP_EVENT_SESSION_TERMINATED,
				3,
				(const CHAR **)args, 
				0 ) ;
	}

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    return(err);

} // NntprTerminateSession
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\wildmat.h ===
//---[ wildmat.h ]-------------------------------------------------------------
//
//  Description:
//      Provides support for the "wildmat" wildcard matching standard. Info
//      on this standard comes from the internet draft:
//
//      draft-barber-nntp-imp-03.txt
//      S. Barber
//      April, 1996
//
//  Copyright (C) Microsoft Corp. 1996.  All Rights Reserved.
//
// ---------------------------------------------------------------------------

#ifndef _WILDMAT_H_
#define _WILDMAT_H_

//---[ Prototypes ]------------------------------------------------------------

HRESULT HrMatchWildmat( const char *pszText, const char *pszPattern );

#endif // _WILDMAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\tigris.cpp ===
#include "tigris.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\svcvroot.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name : 

	svcvroot.cpp

Abstract : 

	This module contains the server side support for vroot rpcs.

Author : 

	Kangrong Yan	

Revision History : 

--*/

#define	INCL_INETSRV_INCS
#include	"tigris.hxx"
#include	"nntpsvc.h"

NET_API_STATUS
NET_API_FUNCTION
NntprGetVRootWin32Error(
                    IN  LPWSTR              wszServerName,
                    IN  DWORD               InstanceId,
                    IN  LPWSTR              wszVRootPath,
                    OUT PDWORD              pdwWin32Error
                        ) 
{
	TraceFunctEnter( "NntprGetVRootWin32Error" ) ;

	APIERR	ss = STATUS_SUCCESS ;
	DWORD   cProperties = 0;
	DWORD   rgidProperties[MAX_GROUP_PROPERTIES];

	if( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {
		return	NERR_ServerNotStarted ;
	}

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	//
    //  Check for proper access.
    //

    DWORD	err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

    ss = pInstance->GetVRootWin32Error( wszVRootPath, pdwWin32Error );

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

	return ss  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\toclient.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    toclient.h

Abstract:

    This module contains class declarations/definitions for

		CToClientArticle

    **** Overview ****

	This derives a classe from CArticle that will be
	used to read the article from the disk and give
	it to a client (or peer).

Author:

    Carl Kadie (CarlK)     05-Dec-1995

Revision History:


--*/

#ifndef	_TOCLIENT_H_
#define	_TOCLIENT_H_


//
//
//
// CToClientArticle - class for reading an article from disk.
//

class	CToClientArticle  : public CArticle {
public:

	CToClientArticle() ;

	//
	//	Cleanup our data structures !
	//

	~CToClientArticle() ;

	BOOL
	fInit(
		FIO_CONTEXT*	pFIOContext,
		CNntpReturn & nntpReturn,
		CAllocator * pAllocator
		) ;

	BOOL fInit(
			const char * szFilename,
			CNntpReturn & nntpReturn,
			CAllocator * pAllocator,
			CNntpServerInstanceWrapper *pInstance,
			HANDLE hFile = INVALID_HANDLE_VALUE,
			DWORD	cBytesGapSize = cchUnknownGapSize,
			BOOL    fCacheCreate = FALSE
			) {
        return CArticle::fInit( szFilename,
                                nntpReturn,
                                pAllocator,
                                pInstance,
                                hFile,
                                cBytesGapSize,
                                fCacheCreate );
     }

	FIO_CONTEXT*
	GetContext() ;

	FIO_CONTEXT*
	fWholeArticle(	
			DWORD&	ibStart,
			DWORD&	cbLength
			) ;

	//
	// Validate the article (pretty much do nothing)
	//

	BOOL fValidate(
			CPCString& pcHub,
			const char * szCommand,
			CInFeed*	pInFeed,
			CNntpReturn & nntpReturn
			);

	//
	// Munge the headers (pretty much do nothing)
	//

	BOOL fMungeHeaders(
			 CPCString& pcHub,
			 CPCString& pcDNS,
			 CNAMEREFLIST & grouplist,
			 DWORD remoteIpAddress,
			 CNntpReturn & nntpr,
             PDWORD pdwLinesOffset = NULL
			 );

	//
	// Check the command line (do nothing)
	//

	BOOL fCheckCommandLine(
			char const * szCommand,
			CNntpReturn & nntpr)
		{
			return nntpr.fSetOK();
		}

	//
	// Asking this object for the message id is an error
	//

	const char * szMessageID(void) {
			_ASSERT(FALSE);
			return "";
			};

    // Asking this object for the control message is an error
	CONTROL_MESSAGE_TYPE cmGetControlMessage(void) {
			_ASSERT(FALSE);
			return (CONTROL_MESSAGE_TYPE)MAX_CONTROL_MESSAGES;    // guaranteed to NOT be a control message
			};

	//
	// Asking this object for the newsgroups is an error
	//

	const char * multiszNewsgroups(void) {
			_ASSERT(FALSE);
			return "";
			};

	//
	// Asking this object fo the number of newsgroups is an error
	//

	DWORD cNewsgroups(void) {
			_ASSERT(FALSE);
			return 0;
			};


	//
	// Asking this object for the Distribution is an error
	//

	const char * multiszDistribution(void) {
			_ASSERT(FALSE);
			return "";
			};

	//
	// Asking this object fo the number of Distribution is an error
	//

	DWORD cDistribution(void) {
			_ASSERT(FALSE);
			return 0;
			};

	//
	// Asking this object for the newsgroups is an error
	//

	const char * multiszPath(void) {
			_ASSERT(FALSE);
			return "";
			};

	//
	// Asking this object fo the number of Path is an error
	//

	DWORD cPath(void) {
			_ASSERT(FALSE);
			return 0;
			};

protected : 

	//
	// Open the file READ ONLY
	//

	BOOL fReadWrite(void) {
			return FALSE;
			}

	//
	// Check the body length (really, do nothing)
	//

	BOOL fCheckBodyLength(
			CNntpReturn & nntpReturn
			);

	//
	// require that the character following "Field Name:" is a space
	// This should not be called.
	//

	BOOL fCheckFieldFollowCharacter(
			char chCurrent)
		{
			return TRUE;
		}

	FIO_CONTEXT*	m_pFIOContext ;
	

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\tomaster.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    fromclnt.h

Abstract:

    This module contains class declarations/definitions for

!!!

    **** Overview ****

!!!
Author:

    Carl Kadie (CarlK)     05-Dec-1995

Revision History:


--*/

#ifndef	_TOMASTER_H_
#define	_TOMASTER_H_



//
//
//
// CToMasterFeed - for processing article to master (from slaves)
//

class	CToMasterFeed:	public CInFeed 	{

//
// Public Members
//

public :

	//
	// Constructor
	//

	CToMasterFeed(void){};

	//
	// Destructor
	//

	virtual ~CToMasterFeed(void) {};

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"To Master" ;
				}


protected:


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\svcxpire.cpp ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name :

	svcxpire.cpp

Abstract :

	This module contains the server side support for expiration rpcs.

Author :

	Neil Kaethler	

Revision History :

--*/

#define	INCL_INETSRV_INCS
#include	"tigris.hxx"
#include	"nntpsvc.h"
#include	<time.h>

NET_API_STATUS
NET_API_FUNCTION
NntprEnumerateExpires(
	IN	NNTP_HANDLE		ServerName,
    IN	DWORD			InstanceId,
	OUT	LPNNTP_EXPIRE_ENUM_STRUCT	Buffer
	)
{
	DWORD	dwError = NERR_Success ;
	DWORD	EntriesRead = 0 ;
	LPI_EXPIRE_INFO	pTemp = 0 ;

	Buffer->EntriesRead = 0 ;
	Buffer->Buffer = NULL ;

	TraceFunctEnter("NntprEnumerateExpires");

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	if( !(pInstance->ExpireObject())->m_FExpireRunning )	{
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		return	NERR_ServerNotStarted ;
	}	

    //
    //  Check for proper access.
    //
    dwError = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( dwError != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",dwError );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)dwError;
    }

	EnterCriticalSection( &(pInstance->ExpireObject())->m_CritExpireList ) ;

	//
	//	Make two passes through the expiration list - one to calculate the size
	//	the second to build the return buffer !
	//

	LPEXPIRE_BLOCK	expire = (pInstance->ExpireObject())->NextExpireBlock( 0 ) ;
	DWORD	cb = 0 ;
	while( expire != 0 ) {
		if( !expire->m_fMarkedForDeletion )
			cb += (pInstance->ExpireObject())->CalculateExpireBlockSize( expire ) ;
		expire = (pInstance->ExpireObject())->NextExpireBlock( expire ) ;
	}

	if( cb != 0 ) {

		PCHAR	bufStart = (PCHAR)MIDL_user_allocate( cb ) ;
		pTemp = (LPI_EXPIRE_INFO)bufStart ;

		if( bufStart ) 	{
			PWCHAR	bufEnd = (PWCHAR) (bufStart + cb) ;

			expire = (pInstance->ExpireObject())->NextExpireBlock( 0 ) ;
		
			while( expire != 0 ) {
				if( !expire->m_fMarkedForDeletion ) {
					EntriesRead ++ ;

					if( !FillExpireInfoBuffer(
										pInstance,
										expire,
										&bufStart,
										&bufEnd ) )	{

						MIDL_user_free( bufStart ) ;
						bufStart = 0 ;
						dwError = ERROR_NOT_ENOUGH_MEMORY ;
						break ;
					}
				}
				expire = (pInstance->ExpireObject())->NextExpireBlock( expire ) ;
			}
		}

		if( bufStart )	{
			Buffer->EntriesRead = EntriesRead ;
			Buffer->Buffer = pTemp ;
		}

	}

	LeaveCriticalSection( &(pInstance->ExpireObject())->m_CritExpireList ) ;

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

	return	dwError ;
}

NET_API_STATUS
NET_API_FUNCTION
NntprAddExpire(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	LPI_EXPIRE_INFO		ExpireInfo,
	OUT	LPDWORD				ParmErr	OPTIONAL,
	OUT LPDWORD				pdwExpireId
	)
{
	DWORD	error = NERR_Success;
	LPEXPIRE_BLOCK	expire = NULL ;
	BOOL fDidAlloc = FALSE;

	*pdwExpireId = 0;

	TraceFunctEnter("NntprAddExpire");

	if( ParmErr == 0 ) {
		ParmErr = &error ;
	}

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	if( !(pInstance->ExpireObject())->m_FExpireRunning )	{
		error =	NERR_ServerNotStarted ;
		goto Exit ;
	}	

    //
    //  Check for proper access.
    //
    error = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( error != NO_ERROR ) {
        ErrorTrace(0,"Failed access check error %lu\n",error );
		goto Exit ;
    }

	if( ExpireInfo->Newsgroups == 0 ||
        ExpireInfo->cbNewsgroups == 0 ) {
		*ParmErr = 1 ;
		error = ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	if( ExpireInfo->ExpireSizeHorizon == 0 ) {
		*ParmErr = 2 ;
		error =	ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	if( ExpireInfo->ExpireTime == 0 ) {
		*ParmErr = 3 ;
		error =	ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	if( !ExpireInfo->ExpirePolicy || *(ExpireInfo->ExpirePolicy) == L'\0' ) {
	    //
	    //  If no name is specified, use the newsgroups wildmat !
	    //

		// no expire policy was specified, so we use the newsgroups.  we copy
		// it into another buffer to verify that it is 0 terminated
		ExpireInfo->ExpirePolicy = (PWCHAR) LocalAlloc(LMEM_ZEROINIT, ExpireInfo->cbNewsgroups + 1);
		if (ExpireInfo->ExpirePolicy == NULL) {
			error = ERROR_NOT_ENOUGH_MEMORY;
			goto Exit;
		}
		fDidAlloc = TRUE;
	
		memcpy(ExpireInfo->ExpirePolicy, ExpireInfo->Newsgroups, ExpireInfo->cbNewsgroups);
	}

	expire = (pInstance->ExpireObject())->AllocateExpireBlock(	
												NULL,
												ExpireInfo->ExpireSizeHorizon,
												ExpireInfo->ExpireTime,
												(PCHAR)ExpireInfo->Newsgroups,
												ExpireInfo->cbNewsgroups,
												(PCHAR)ExpireInfo->ExpirePolicy,
												TRUE	// Is unicode !
												) ;

	if( expire == 0 ) {
		error =	GetLastError() ;
		goto Exit ;
	}

	if( !(pInstance->ExpireObject())->CreateExpireMetabase( expire ) ) {
		(pInstance->ExpireObject())->CloseExpireBlock( expire ) ;
		error =	NERR_InternalError ;		
		goto Exit ;
	}

	(pInstance->ExpireObject())->InsertExpireBlock( expire ) ;

	// grab the expire id allocated for this block
	*pdwExpireId = expire->m_ExpireId ;

	PCHAR args[1];
	CHAR  szId[20];

	_itoa( pInstance->QueryInstanceId(), szId, 10 );
	args[0] = szId;

	NntpLogEvent(		
			NNTP_EVENT_EXPIRE_ADDED,
			1,
			(const CHAR **)args,
			0 ) ;

Exit:

	if (fDidAlloc) LocalFree(ExpireInfo->ExpirePolicy);

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();
	return	error ;
}

NET_API_STATUS
NET_API_FUNCTION
NntprDeleteExpire(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	DWORD				ExpireId
	)	
{
	DWORD	dwError = NERR_Success ;
	LPEXPIRE_BLOCK	expire = NULL ;

	TraceFunctEnter("NntprDeleteExpire");

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	if( !(pInstance->ExpireObject())->m_FExpireRunning ) {
		dwError = NERR_ServerNotStarted ;
		goto Exit ;
	}

    //
    //  Check for proper access.
    //
    dwError = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( dwError != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",dwError );
		goto Exit ;
    }

	if( ExpireId == 0 ) {
		dwError = ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	expire = (pInstance->ExpireObject())->SearchExpireBlock( ExpireId ) ;

	if( !expire )	{
		dwError = NERR_ResourceNotFound ;
	}	else	{

		(pInstance->ExpireObject())->MarkForDeletion( expire ) ;
		(pInstance->ExpireObject())->CloseExpireBlock( expire ) ;

		PCHAR args [2];
		char  szTemp [22];
		CHAR  szId[20];

		_itoa( pInstance->QueryInstanceId(), szId, 10 );
		args[0] = szId;

		wsprintf( szTemp, "%d", ExpireId );
		args[1] = szTemp;

		NntpLogEvent(		
				NNTP_EVENT_EXPIRE_DELETED,
				2,
				(const CHAR **)args,
				0 ) ;
	}

Exit:

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();
	return	dwError ;
}

NET_API_STATUS
NET_API_FUNCTION
NntprGetExpireInformation(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	DWORD				ExpireId,
	OUT	LPNNTP_EXPIRE_ENUM_STRUCT	Buffer
	)
{
	Buffer->EntriesRead = 0 ;
	Buffer->Buffer = NULL ;
	DWORD	dwError = NERR_Success ;
	LPEXPIRE_BLOCK	expire = NULL ;

	TraceFunctEnter("NntprGetExpireInformation");

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	if( !(pInstance->ExpireObject())->m_FExpireRunning ) {
		dwError = NERR_ServerNotStarted ;
		goto Exit ;
	}

	if( ExpireId == 0 ) {
		dwError = ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

    //
    //  Check for proper access.
    //
    dwError = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( dwError != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",dwError );
		goto Exit ;
    }

	EnterCriticalSection( &(pInstance->ExpireObject())->m_CritExpireList ) ;

	expire = (pInstance->ExpireObject())->SearchExpireBlock( ExpireId ) ;

	if( !expire )	{
		dwError = NERR_ResourceNotFound ;
	}	else	{

		DWORD	cb = (pInstance->ExpireObject())->CalculateExpireBlockSize( expire ) ;

		PCHAR	bufStart = (PCHAR)MIDL_user_allocate( cb ) ;
		LPI_EXPIRE_INFO	pTemp = (LPI_EXPIRE_INFO)bufStart ;

		if( bufStart == NULL ) {
			dwError = ERROR_NOT_ENOUGH_MEMORY ;
		}	else	{
			PWCHAR	bufEnd = (PWCHAR)(bufStart + cb) ;

			if( !FillExpireInfoBuffer(
								pInstance,
								expire,
								&bufStart,
								&bufEnd ) )	{

				MIDL_user_free( bufStart ) ;
				dwError = ERROR_NOT_ENOUGH_MEMORY ;
			}	else	{

				Buffer->Buffer = pTemp ;
				Buffer->EntriesRead = 1 ;
			
			}
		}

		(pInstance->ExpireObject())->CloseExpireBlock( expire ) ;
	}

	LeaveCriticalSection( &(pInstance->ExpireObject())->m_CritExpireList ) ;

Exit:

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();
	return	dwError  ;
}

NET_API_STATUS
NET_API_FUNCTION
NntprSetExpireInformation(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	LPI_EXPIRE_INFO		ExpireInfo,
	OUT	LPDWORD				ParmErr	OPTIONAL
	)
{
	DWORD	dwError = NERR_Success ;
	LPEXPIRE_BLOCK	expire = NULL ;

	TraceFunctEnter("NntprSetExpireInformation");

	if( ParmErr == 0 ) {
		ParmErr = &dwError ;
	}

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	if( !(pInstance->ExpireObject())->m_FExpireRunning ) {
		dwError = NERR_ServerNotStarted ;
		goto Exit ;
	}

    //
    //  Check for proper access.
    //
    dwError = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( dwError != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",dwError );
		goto Exit ;
    }

	if( ExpireInfo->ExpireId == 0 ) {
		*ParmErr = 1 ;
		dwError = ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	if( ExpireInfo->Newsgroups == 0 ||
		ExpireInfo->cbNewsgroups == 0 ) {
		*ParmErr = 2 ;
		dwError = ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	if( ExpireInfo->ExpireSizeHorizon == 0 ) {
		*ParmErr = 3 ;
		dwError = ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	if( ExpireInfo->ExpireTime == 0 ) {
		*ParmErr = 4 ;
		dwError = ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	if( !ExpireInfo->ExpirePolicy || *(ExpireInfo->ExpirePolicy) == L'\0' ) {
		*ParmErr = 5 ;
		dwError = ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	EnterCriticalSection( &(pInstance->ExpireObject())->m_CritExpireList ) ;

	expire = (pInstance->ExpireObject())->SearchExpireBlock( ExpireInfo->ExpireId ) ;

	if( !expire )	{
		dwError = NERR_ResourceNotFound ;
	}	else	{

		LPSTR*	lpstrNewsgroups = AllocateMultiSzTable(	
												(char*)ExpireInfo->Newsgroups,
												ExpireInfo->cbNewsgroups,
												TRUE ) ;

		DWORD cbAsciiBuffer = (wcslen( ExpireInfo->ExpirePolicy ) + 1) * 2;
		LPSTR	ExpirePolicyAscii =
			(LPSTR)ALLOCATE_HEAP( cbAsciiBuffer ) ;
		if( ExpirePolicyAscii != 0 ) {
			WideCharToMultiByte(CP_ACP, 0, ExpireInfo->ExpirePolicy, -1,
				ExpirePolicyAscii, cbAsciiBuffer, NULL, NULL);
			//CopyUnicodeStringIntoAscii( ExpirePolicyAscii, ExpireInfo->ExpirePolicy ) ;
		}

		if( lpstrNewsgroups && ExpirePolicyAscii ) {
			// allocations succeeded - do the right thing.
			if( expire->m_Newsgroups != 0 ) {
				FREE_HEAP( expire->m_Newsgroups ) ;
			}
			if( expire->m_ExpirePolicy != 0 ) {
				FREE_HEAP( expire->m_ExpirePolicy ) ;
			}
			expire->m_Newsgroups = lpstrNewsgroups ;
			expire->m_ExpireSize = ExpireInfo->ExpireSizeHorizon ;
			expire->m_ExpireHours = ExpireInfo->ExpireTime ;
			expire->m_ExpirePolicy = ExpirePolicyAscii ;
			(pInstance->ExpireObject())->SaveExpireMetabaseValues( 0, expire ) ;
		} else {
			// free any stuff allocated
			if( lpstrNewsgroups ) {
				FREE_HEAP( lpstrNewsgroups );
			}
			if( ExpirePolicyAscii ) {
				FREE_HEAP( ExpirePolicyAscii );
			}
			dwError = ERROR_NOT_ENOUGH_MEMORY ;
		}

		(pInstance->ExpireObject())->CloseExpireBlock( expire ) ;
	}

	LeaveCriticalSection( &(pInstance->ExpireObject())->m_CritExpireList ) ;

Exit:

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();
	return	dwError ;
}


BOOL
FillExpireInfoBuffer(	IN	PNNTP_SERVER_INSTANCE pInstance,
						IN	LPEXPIRE_BLOCK	expire,
						IN OUT LPSTR*		FixedPortion,
						IN OUT LPWSTR*		EndOfVariableData )	{

	LPI_EXPIRE_INFO	expireInfo = (LPI_EXPIRE_INFO)(*FixedPortion) ;

	*FixedPortion = (*FixedPortion) + sizeof( NNTP_EXPIRE_INFO ) ;

	_ASSERT( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)*FixedPortion ) ;
	_ASSERT( expire->m_ExpireId != 0 ) ;

	LPSTR	lpstrNewsgroups = 0 ;
	DWORD	cbNewsgroups = 0 ;
    BOOL    fIsRoadKill = FALSE ;

	if( (pInstance->ExpireObject())->GetExpireBlockProperties(	
												expire,
												lpstrNewsgroups,
												cbNewsgroups,
												expireInfo->ExpireTime,
												expireInfo->ExpireSizeHorizon,
                                                TRUE,
												fIsRoadKill ) )	
	{
		//
		// Copy the expire policy to the output buffer
		//

		CopyStringToBuffer(
			expire->m_ExpirePolicy,
			*FixedPortion,
			EndOfVariableData,
			&expireInfo->ExpirePolicy
			);
		
		WCHAR*	dest = *EndOfVariableData - (cbNewsgroups/2) ;
		CopyMemory( dest, lpstrNewsgroups, cbNewsgroups ) ;
		*EndOfVariableData = *EndOfVariableData - (cbNewsgroups/2) ;

		expireInfo->cbNewsgroups = cbNewsgroups ;
		expireInfo->Newsgroups = (PUCHAR)dest ;
		expireInfo->ExpireId = expire->m_ExpireId ;

		FREE_HEAP( lpstrNewsgroups ) ;

		return	TRUE ;
	}

	return	FALSE ;
}

#if 0
NET_API_STATUS
NET_API_FUNCTION
NntprGetExpireInformation(
	IN	NNTP_HANDLE			ServerName,
	IN	DWORD				ExpireId,
	OUT	LPI_EXPIRE_INFO		*ExpireInfo
	)
{


	DWORD	dwError = NERR_Success ;

	if( !FExpireRunning )
		return	NERR_ServerNotStarted ;

	*ExpireInfo = NULL ;

	if( ExpireId == 0 ) {
		return	ERROR_INVALID_PARAMETER ;
	}

	EnterCriticalSection( &gCritExpireList ) ;

	LPEXPIRE_BLOCK	expire = SearchExpireBlock( ExpireId ) ;

	if( !expire )	{
		dwError = NERR_ResourceNotFound ;
	}	else	{

		DWORD	cb = CalculateExpireBlockSize( expire ) ;

		PCHAR	bufStart = (PCHAR)MIDL_user_allocate( cb ) ;
		LPI_EXPIRE_INFO	pTemp = (LPI_EXPIRE_INFO)bufStart ;

		if( bufStart == NULL ) {
			dwError = ERROR_NOT_ENOUGH_MEMORY ;
		}	else	{
			PWCHAR	bufEnd = (PWCHAR)(bufStart + cb) ;

			if( !FillExpireInfoBuffer( expire,
										&bufStart,
										&bufEnd ) )	{

				MIDL_user_free( bufStart ) ;
				dwError = ERROR_NOT_ENOUGH_MEMORY ;
			}	else	{

				*ExpireInfo = pTemp ;
			
			}

		}

		CloseExpireBlock( expire ) ;

	}

	LeaveCriticalSection( &gCritExpireList ) ;

	return	dwError  ;
	
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\toclient.cpp ===
/* Contains Infeed, Article, and Fields code specific to ToClient Infeeds */

#include "tigris.hxx"


BOOL
CToClientArticle::fInit(	FIO_CONTEXT*	pFIOContext,
							CNntpReturn&	nntpReturn,
							CAllocator*		pAllocator
							)	{

	m_pFIOContext = pFIOContext ;
	return	CArticleCore::fInit(	"DummyString",
									nntpReturn,
									pAllocator,
									pFIOContext->m_hFile 
									) ;
}

CToClientArticle::CToClientArticle()	: 
	m_pFIOContext( 0 ) 	{
}

CToClientArticle::~CToClientArticle()	{
	if( m_pFIOContext != 0 )	{
		m_hFile = INVALID_HANDLE_VALUE ;
		ReleaseContext( m_pFIOContext ) ;
	}
}

FIO_CONTEXT*
CToClientArticle::GetContext()	{
	return	m_pFIOContext ;
}

FIO_CONTEXT*
CToClientArticle::fWholeArticle(
						DWORD&	ibOffset, 
						DWORD&	cbLength
						)	{
	HANDLE	hTemp ;
	CArticleCore::fWholeArticle( hTemp, ibOffset, cbLength ) ;
	return	GetContext() ;
}


BOOL
CToClientArticle::fValidate(
							CPCString& pcHub,
							const char * szCommand,
							CInFeed*	pInFeed,
							CNntpReturn & nntpReturn
							)
/*++

Routine Description:

	No real validation is needed because this is one of
	our own articles, so just return TRUE.

Arguments:

	szCommand - IGNORED
	nntpReturn - The return value for this function call


Return Value:

	Always TRUE

--*/
{

	return nntpReturn.fSetOK();
}


BOOL
CToClientArticle::fMungeHeaders(
						CPCString& pcHub,
						CPCString& pcDNS,
						CNAMEREFLIST & grouplist,
						DWORD remoteIpAddress,
						CNntpReturn & nntpReturn,
                        PDWORD  pdwLinesOffset
			  )

/*++

Routine Description:

	No munging is needed because this article
	has already be processed.

Arguments:

	grouplist - IGNORED
	nntpReturn - The return value for this function call


Return Value:

	Always TRUE

--*/
{
    *pdwLinesOffset = INVALID_FILE_SIZE;
	return nntpReturn.fSetOK();
}



BOOL
CToClientArticle::fCheckBodyLength(
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Always return TRUE.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	Always TRUE

--*/
{

	return nntpReturn.fSetOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\buffer.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    buffer.cxx
    Implementation of the BUFFER class.

    FILE HISTORY:
        RustanL     03-Aug-1990     Created Windows implementation
        RustanL     02-Jan-1991     Adapted for BLT
        RustanL     08-Jan-1991     Moved into UI misc, and added OS/2
                                    and DOS implementation.
        BenG        30-Apr-1991     Uses lmui.hxx
        beng        19-Jun-1991     Inherits from BASE; uses UINT sizes;
                                    documentation corrected and moved
                                    into headers
        beng        19-Mar-1992     Removed OS/2 support
        MuraliK     27-Feb-1995  Modified to make it standalone.
        MuraliK     2-June-1995  Modified to make it into a library.
*/


//
// Normal includes only for this module
//

# include <buffer.hxx>


/*******************************************************************

    NAME:       BUFFER::BUFFER

    SYNOPSIS:   Construct a BUFFER object of the given size.

    ENTRY:
        cbRequested     indicates desired size of buffer object

    CAVEATS:
        Requesting a zero-length buffer returns an object which
        has no allocated storage.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        20-Jun-1991     Uses BASE; size UINT

********************************************************************/

#if 0  // Defined in header file
BUFFER::BUFFER( UINT cbRequested ) :
    _pb(NULL),
    _cb(0)
{
    if ( cbRequested == 0 )
        return;

    GetNewStorage(cbRequested);
}
#endif

/*******************************************************************

    NAME:       BUFFER::GetNewStorage

    SYNOPSIS:   Given an object with no allocated storage,
                allocate the initial memory.

    ENTRY:      cbRequested - amount of storage requested in bytes

    EXIT:       Either storage alloc'd, or error reported
                Sets _cb, _pb

    RETURNS:    TRUE if successful, FALSE for GetLastError()

    NOTES:
        Private member function.

    CAVEATS:
        This function will ReportError itself.

    HISTORY:
        beng        24-Jun-1991     Created (common code factored)
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

BOOL BUFFER::GetNewStorage( UINT cbRequested )
{
    _pb = (BYTE *) ::LocalAlloc( NONZEROLPTR, cbRequested );

    if ( !_pb )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    _cb = cbRequested;

    return TRUE;
}


/*******************************************************************

    NAME:       BUFFER::ReallocStorage

    SYNOPSIS:   Do a "hard" reallocation to the new size

    ENTRY:      cbNewRequested - new size, in bytes

    EXIT:       Storage realloc'd.
                _pb, _cb changed

    RETURNS:    TRUE if successful, FALSE for GetLastError()

    NOTES:
        Private member function.

    HISTORY:
        beng        24-Jun-1991     Created (common code factor)
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

BOOL BUFFER::ReallocStorage( UINT cbNewRequested )
{
    HANDLE hNewMem = ::LocalReAlloc( _pb, cbNewRequested, GMEM_MOVEABLE );

    if (hNewMem == 0)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    _pb = (BYTE *) hNewMem;

    _cb = cbNewRequested;

    return TRUE;
}

/*******************************************************************

    NAME:       BUFFER::~BUFFER

    SYNOPSIS:   Destroys buffer object, and deallocates any memory
                that it might have allocated.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

#if 0 // Defined in header

BUFFER::~BUFFER()
{
#if DBG
    VerifyState();
#endif

    if ( _pb )
    {
        ::LocalFree( (HANDLE) _pb );
    }

#if DBG
    _pb = NULL;
    _cb = 0;
#endif
}

#endif // 0

/*******************************************************************

    NAME:       BUFFER::VerifyState

    SYNOPSIS:   Verifies the state of the object.
                Asserts out if the state is invalid, i.e. if an
                internal error took place.

    NOTES:      This function does nothing in the retail version.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added

********************************************************************/

VOID BUFFER::VerifyState() const
{
}

/*******************************************************************

    NAME:       BUFFER::Resize

    SYNOPSIS:   Resizes the memory object

    ENTRY:
        cbNewRequested   - specifies the new size
        cbSlop           - If a realloc is needed, then cbSlop bytes are
                           added for the reallocation (not for an initial
                           allocation though)

    EXIT:
        _cb and _pb changed; possibly _pb resized

    RETURNS:
        TRUE if successful.  The next call to QueryPtr will then
            return a pointer to the newly allocated memory.
            The new buffer will contain as much of the contents
            of the old buffer as will fit.
        FALSE if unsuccessful.  The old piece of memory, if any,
            still exists.  The next call to QueryPtr will
            return a pointer to this memory.

    NOTES:
        After a call to this method, the caller can *not* rely on any
        pointer that QueryPtr has returned in the past, regardless of
        the success of this method.

        Reallocations to size 0 will always succeed.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        24-Jun-1991     Fold common code; fix bug seen in
                                    resize-to-0,resize-to-original sequence
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Remove OS/2 support

********************************************************************/

BOOL BUFFER::Resize( UINT cbNewRequested,
                     UINT cbSlop )
{
#if DBG
    VerifyState();
#endif

    if ( cbNewRequested != 0 )
    {
        if ( _pb != 0 )
        {
            if ( cbNewRequested > QuerySize() )
            {
                /*
                 * The requested memory exceeds the currently allocated memory.
                 * A reallocation is in order.
                 */
                return ReallocStorage(cbNewRequested + cbSlop);
            }

            return TRUE;
        }
        else
        {
            /*
             * There is no memory handle.  Previous size of buffer
             * must have been 0.
             *
             * The new memory request is allocated.
             */
            return GetNewStorage( cbNewRequested );
        }
    }
    else
    {
        /*
         * The requested memory size is 0.  This will always work.
         */
        if ( _pb )
            ::LocalFree( (HANDLE)_pb );

        _pb = NULL;
        _cb = 0;

        return TRUE;
    }

    return TRUE;
}


/*******************************************************************

    NAME:       BUFFER::Trim

    SYNOPSIS:   Reallocates the buffer so that the actual space alloc'd
                is minimally more than the size requested.

    EXIT:
        After making this call, the client can not rely on any pointer
        that QueryPtr has returned in the past, regardless of the success
        of this method.

    NOTES:
        The actual size of the buffer may be larger than the requested size.
        This method informs the system that only _cb is desired.

        This method is intended to be used only when optimization is key.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        15-Jul-1991     ReallocStorage changed return type
        beng        19-Mar-1992     Remove OS/2 support

********************************************************************/

VOID BUFFER::Trim()
{
#if DBG
    VerifyState();
#endif

    if ( _pb == 0 )
    {
        /*
         * No memory is allocated.
         */
        return;
    }

    if ( _cb == 0 )
    {
        /*
         * The requested size is 0.  Free the allocated memory.
         */
        return;
    }

    /*
     * (This should not fail, since we are reallocating to less
     * than current storage.)
     */
    NO_ERROR == ReallocStorage(_cb);
}

BOOL
BUFFER_CHAIN::AppendBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Adds a new buffer chain item to the end of the buffer chain

Arguments:

    pBCI - Chain item to append

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    InsertTailList( &_ListHead,
                    &pBCI->_ListEntry );

    return TRUE;
}

DWORD
BUFFER_CHAIN::DeleteChain(
    VOID
    )
/*++

Routine Description:

    Deletes all of the buffers in this chain

Return Value:

    Total number of allocated bytes freed by this call

--*/
{
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbFreed = 0;

    while ( !IsListEmpty( &_ListHead ))
    {
        pBCI = CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );

        RemoveEntryList( &pBCI->_ListEntry );

        cbFreed += pBCI->QuerySize();

        delete pBCI;
    }

    return cbFreed;
}

BUFFER_CHAIN_ITEM *
BUFFER_CHAIN::NextBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Returns the next buffer in the chain.  Start the enumeration by
    passing pBCI as NULL.  Continue it by passing the return value

Arguments:

    pBCI - Previous item in enumeration

Return Value:

    Pointer to next item in chain, NULL when done

--*/
{
    if ( pBCI != NULL )
    {
        if ( pBCI->_ListEntry.Flink != &_ListHead )
        {
            return CONTAINING_RECORD( pBCI->_ListEntry.Flink,
                                      BUFFER_CHAIN_ITEM,
                                      _ListEntry );
        }
        else
        {
            return NULL;
        }
    }

    if ( !IsListEmpty( &_ListHead ))
    {
        return CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );
    }

    return NULL;
}

DWORD
BUFFER_CHAIN::CalcTotalSize(
    BOOL fUsed
    ) const
/*++

Routine Description:

    Returns the total amount of memory allocated by this buffer chain
    excluding the size of the structures themselves


Arguments:

    fUsed - If FALSE, returns total allocated by chain, if TRUE returns
        total used by chain

Return Value:

    Total bytes allocated or total bytes used

--*/
{
    LIST_ENTRY *        pEntry;
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbRet = 0;

    for ( pEntry  = _ListHead.Flink;
          pEntry != &_ListHead;
          pEntry  = pEntry->Flink )
    {
        pBCI = CONTAINING_RECORD( pEntry, BUFFER_CHAIN_ITEM, _ListEntry );

        if ( fUsed == FALSE )
            cbRet += pBCI->QuerySize();
        else
            cbRet += pBCI->QueryUsed();
    }

    return cbRet;
}

VOID
NntpLogEvent(
    IN DWORD  idMessage,              // id for log message
    IN WORD   cSubStrings,            // count of substrings
    IN const CHAR * apszSubStrings[], // substrings in the message
    IN DWORD  errCode                 // error code if any
    )
{
    return;

} // NntpLogEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\article\arttest.cpp ===
#include "tigris.hxx"

int
__cdecl main(
			int argc,
			char *argv[ ]
	)
{

	
	CNntpReturn nntpReturn;

	if (!CArticle::InitClass() ) 
		return	-1;

	if (2 != argc)
	{
		printf("%s <name-of-article-file-to-parse>\n", argv[0]);
		return -1;
	}

	//
	// Create allocator for storing parsed header values
	//
	const DWORD cchMaxBuffer = 1 * 1024;
	char rgchBuffer[cchMaxBuffer];
	CAllocator allocator(rgchBuffer, cchMaxBuffer);

	CFromPeerArticle * pArticle = new CFromPeerArticle() ;
	__try{

	if (!pArticle->fInit( argv[1], nntpReturn, &allocator))
		__leave;

	CField * rgPFieldRequired [] = {
			&(pArticle->m_fieldDate),
			&(pArticle->m_fieldFrom),
			&(pArticle->m_fieldLines),
			&(pArticle->m_fieldMessageID),
			&(pArticle->m_fieldSubject),
			&(pArticle->m_fieldNewsgroups),
			&(pArticle->m_fieldPath)
				};

	DWORD cRequiredFields = sizeof(rgPFieldRequired)/sizeof(CField *);

	for (DWORD dwFields = 0; dwFields < cRequiredFields; dwFields++)
	{
		CField * pField = rgPFieldRequired[dwFields];
		if (!pField->fFindAndParse(*pArticle, nntpReturn))
			__leave;
	}

	HANDLE hFile;
	DWORD dwOffset;
	DWORD dwLength;

	pArticle->fHead(hFile, dwOffset, dwLength);
	printf("Head offset %d, length %d\n", dwOffset, dwLength);
	pArticle->fBody(hFile, dwOffset, dwLength);
	printf("Body offset %d, length %d\n", dwOffset, dwLength);
	pArticle->fWholeArticle(hFile, dwOffset, dwLength);
	printf("WholeArticle offset %d, length %d\n", dwOffset, dwLength);

	nntpReturn.fSetOK();
	}__finally{
		delete pArticle;
	}

	printf("%s: %d %s\n", argv[1], nntpReturn.m_nrc, nntpReturn.m_sz);
return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\article3\clnttest.cpp ===
#include "tigris.hxx"

int
__cdecl main(
			int argc,
			char *argv[ ]
    )
{

	
	if (!CArticle::InitClass() ) 
		return	-1;

	CNntpReturn nntpReturn;
	if (2 != argc)
	{
		printf("%s <name-of-article-file-to-parse>\n", argv[0]);
		return -1;
	}

	char * szFilename = argv[1];

	char * pchLine = NULL;

	//
	// Create a allocator object for processing the article
	//

	const DWORD cchMaxBuffer = 8 * 1024;
	char rgchBuffer[cchMaxBuffer];
	CAllocator allocator(rgchBuffer, cchMaxBuffer);

	CFromClientArticle *pArticle = new CFromClientArticle("primate") ;

	CPCString pcHub("baboon", 6);
	CNAMEREFLIST namereflist;
	namereflist.fInit(3, &allocator);

	__try{
	if (!pArticle->fInit(szFilename, nntpReturn,  &allocator))
		__leave;

	char chBad;
	if (!(pArticle->m_pcHeader).fCheckTextOrSpace(chBad))
	{
		nntpReturn.fSet(nrcArticleBadChar,  (BYTE) chBad, "header");
		__leave;
	}
	
   // Check required and optional fields
	CField * rgPFields [] = {
			&(pArticle->m_fieldSubject),
			&(pArticle->m_fieldNewsgroups),
			&(pArticle->m_fieldFrom),
			&(pArticle->m_fieldDate),
			&(pArticle->m_fieldLines),
			&(pArticle->m_fieldFollowupTo),
			&(pArticle->m_fieldReplyTo),
			&(pArticle->m_fieldApproved),
			&(pArticle->m_fieldSender),
			&(pArticle->m_fieldSummary),
			&(pArticle->m_fieldReferences),
			&(pArticle->m_fieldKeyword),
			&(pArticle->m_fieldExpires),
			&(pArticle->m_fieldOrganization)
				};
	DWORD cFields = sizeof(rgPFields)/sizeof(CField *);
	if (!pArticle->fFindAndParseList((CField * *)rgPFields, cFields, nntpReturn))
		__leave;

	NAME_AND_ARTREF Nameref;

	(Nameref.artref).m_groupId = 1;
	(Nameref.artref).m_articleId = 3;
	(Nameref.pcName).vInsert("sci.ssors");
	namereflist.AddTail(Nameref);

	(Nameref.artref).m_groupId = 2;
	(Nameref.artref).m_articleId = 4;
	(Nameref.pcName).vInsert("alt.itute");
	namereflist.AddTail(Nameref);

	(Nameref.artref).m_groupId = 123456789;
	(Nameref.artref).m_articleId = 123456789;
	(Nameref.pcName).vInsert("comp.atriot");
	namereflist.AddTail(Nameref);


	if (!(
	  		   (pArticle->m_fieldMessageID).fSet(*pArticle, pcHub, nntpReturn)
  			&& (pArticle->m_fieldNewsgroups).fSet(*pArticle, nntpReturn)
  			&& (pArticle->m_fieldDate).fSet(*pArticle, nntpReturn)
  			&& (pArticle->m_fieldLines).fSet(*pArticle, nntpReturn)
  			&& (pArticle->m_fieldOrganization).fSet(*pArticle, nntpReturn)
  			&& (pArticle->m_fieldPath).fSet(*pArticle, pcHub, nntpReturn)
			&& (pArticle->m_fieldNNTPPostingHost).fSet(*pArticle, nntpReturn)
			&& (pArticle->m_fieldXAuthLoginName).fSet(*pArticle, nntpReturn)
			&& (pArticle->m_fieldXref).fSet(pcHub, namereflist, *pArticle,
					pArticle->m_fieldNewsgroups, nntpReturn)
			&&  pArticle->fDeleteEmptyHeader(nntpReturn)
			&& pArticle->fSaveHeader(nntpReturn)

		))
		__leave;

	nntpReturn.fSetOK();

	}__finally{
		delete pArticle;
	}


	printf("%s: %d %s\n", szFilename, nntpReturn.m_nrc, nntpReturn.m_sz);
return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\article2\mangtest.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mangtest.cpp

Abstract:

    A unit test that tests article modification.

Author:

    Carl Kadie (CarlK)     18-Nov-1995

Revision History:

--*/

#include "tigris.hxx"

int
__cdecl main(
			int argc,
			char *argv[ ]
    )
/*++

Routine Description:

	Modifies an article.

Arguments:

	<name-of-article-to-parse>

Return Value:

	0, if OK.

--*/
{

	if (!CArticle::InitClass() ) 
		return	-1;
	
	CNntpReturn nntpReturn;
	if (2 != argc)
	{
		printf("%s <name-of-article-file-to-parse>\n", argv[0]);
		return -1;
	}

	char * szFilename = argv[1];

	char * pchLine = NULL;

	//
	// Create a allocator object for processing the article
	//

	const DWORD cchMaxBuffer = 8 * 1024;
	char rgchBuffer[cchMaxBuffer];
	CAllocator allocator(rgchBuffer, cchMaxBuffer);


	CFromPeerArticle *pArticle = new CFromPeerArticle() ;

	__try{
		
		
		if (!pArticle->fInit(szFilename, nntpReturn, &allocator))
		__leave;

	CField * rgPFieldRequired [] = {
			&(pArticle->m_fieldDate),
			&(pArticle->m_fieldLines),
			&(pArticle->m_fieldFrom),
			&(pArticle->m_fieldMessageID),
			&(pArticle->m_fieldSubject),
			&(pArticle->m_fieldNewsgroups),
			&(pArticle->m_fieldPath)
				};

	DWORD cRequiredFields = sizeof(rgPFieldRequired)/sizeof(CField *);

	for (DWORD dwFields = 0; dwFields < cRequiredFields; dwFields++)
	{
		CField * pField = rgPFieldRequired[dwFields];
		if (!pField->fFindAndParse(*pArticle, nntpReturn))
			__leave;
	}

	CNAMEREFLIST namereflist;
	namereflist.fInit(3, &allocator);

	NAME_AND_ARTREF Nameref;

	(Nameref.artref).m_groupId = 1;
	(Nameref.artref).m_articleId = 3;
	(Nameref.pcName).vInsert("alt.t");
	namereflist.AddTail(Nameref);

	(Nameref.artref).m_groupId = 2;
	(Nameref.artref).m_articleId = 4;
	(Nameref.pcName).vInsert("a.h");
	namereflist.AddTail(Nameref);

	(Nameref.artref).m_groupId = 123456789;
	(Nameref.artref).m_articleId = 123456789;
	(Nameref.pcName).vInsert("comp.st");
	namereflist.AddTail(Nameref);

	CPCString pcHub("baboon", 6);

	if (!(
  			pArticle->m_fieldPath.fSet(pcHub, *pArticle, nntpReturn)
  			&& pArticle->m_fieldLines.fSet(*pArticle, nntpReturn)
			&& (pArticle->m_fieldXref).fSet(pcHub, namereflist, *pArticle,
					pArticle->m_fieldNewsgroups, nntpReturn)
			&& pArticle->fSaveHeader(nntpReturn)
			))
		__leave;

	char rgBuf[1000];
	CPCString pcBuffer(rgBuf, 1000);
	if (!pArticle->fXOver(pcBuffer, nntpReturn))
		__leave;

	printf("XOVER: %s\n", rgBuf);

	nntpReturn.fSetOK();

	}__finally{
		delete pArticle;
	}


	printf("%s: %d %s\n", szFilename, nntpReturn.m_nrc, nntpReturn.m_sz);
return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\chkhash\chkhash.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    chkhash_H.h

Abstract:

    This module is the main include file for the chkhash

Author:

    Johnson Apacible (JohnsonA)     18-Dec-1995

Revision History:

--*/

#ifndef _CHKHASH_H_
#define _CHKHASH_H_


//
// table stats
//

typedef struct _HTABLE_TYPE {

    //
    // Description of the hash table
    //

    LPCSTR Description;

    //
    // file name the hash table uses
    //

    LPCSTR FileName;

    //
    // name of new table
    //

    LPCSTR NewFileName;


    //
    // hash table signature
    //

    DWORD  Signature;

    //
    // number of entries in the hash table
    //

    DWORD  Entries;

    //
    // total deletions and insertions
    //

    DWORD  TotDels;
    DWORD  TotIns;

    //
    // number of pages containing hash entries
    //

    DWORD  PagesUsed;

    //
    // current file size
    //

    DWORD  FileSize;

    //
    // depth of the directory
    //

    DWORD   DirDepth;

    //
    // list of problems discovered
    //

    DWORD  Flags;

} HTABLE, *PHTABLE;

//
// Flags
//

#define HASH_FLAG_BAD_LINK             0x00000001
#define HASH_FLAG_BAD_SIGN             0x00000002
#define HASH_FLAG_BAD_SIZE             0x00000004
#define HASH_FLAG_CORRUPT              0x00000008
#define HASH_FLAG_NOT_INIT             0x00000010
#define HASH_FLAG_BAD_HASH             0x00000020
#define HASH_FLAG_BAD_ENTRY_COUNT      0x00000040
#define HASH_FLAG_BAD_PAGE_COUNT       0x00000080
#define HASH_FLAG_BAD_DIR_DEPTH        0x00000100

#define HASH_FLAG_NO_FILE              0x00000200

//
// If this is set, then no rebuilding is to take place
// because of a fatal error.
//

#define HASH_FLAG_ABORT_SCAN           0x80000000

//
// These flags indicate that the file is corrupt and should
// be rebuilt
//

#define HASH_FLAGS_CORRUPT             (HASH_FLAG_BAD_LINK | \
                                        HASH_FLAG_BAD_SIGN | \
                                        HASH_FLAG_BAD_SIZE | \
                                        HASH_FLAG_CORRUPT |  \
                                        HASH_FLAG_NOT_INIT | \
                                        HASH_FLAG_BAD_HASH | \
                                        HASH_FLAG_BAD_ENTRY_COUNT)

//
// hash types
//

enum filetype {
        artmap = 0,
        histmap = 1,
        xovermap = 2
        };

//
// externs
//

extern BOOL Verbose;
extern BOOL Quiet;
extern HTABLE table[];
extern BOOL RebuildArtMapTable;
extern BOOL DoClean;

//
// function prototypes
//

BOOL
checklink(
    PHTABLE HTable
    );

BOOL
RebuildArtMapAndXover(
    VOID
    );

BOOL
RebuildArtMapFromXOver(
    VOID
    );

BOOL
diagnose(
    PHTABLE HTable
    );

#endif // _CHKHASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\chkhash\scan.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    scan.cpp

Abstract:

    This module contains the scanning code for the chkhash program.

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

--*/

#include "..\..\tigris.hxx"
#include "chkhash.h"

VOID
PrintHeadStats(
    PHASH_RESERVED_PAGE Head
    )
{

    if ( !Verbose ) {
        return;
    }

    printf("Signature [%x]\n",Head->Signature);

    printf("Pages %d",Head->NumPages);
    printf("\t\t\tDir depth %d\n",Head->DirDepth);
    printf("Insertions %d",Head->InsertionCount);
    printf("\t\tDeletions %d\n",Head->DeletionCount);
    printf("Searches %d",Head->SearchCount);
    printf("\t\tSplits %d\n",Head->PageSplits);
    printf("Dir expansions %d",Head->DirExpansions);
    printf("\tTable expansions %d\n",Head->TableExpansions);
    printf("Duplicate Inserts %d\n",Head->DupInserts);

} // PrintHeadStats

VOID
PrintPageStats(
    PHTABLE HTable,
    PMAP_PAGE Page
    )
{
    DWORD nDel = 0;
    DWORD nOk = 0;
    DWORD j;
    SHORT offset;

    if ( Verbose ) {
        printf("Hash prefix %x\t\tDepth %d\n",Page->HashPrefix,Page->PageDepth);
        printf("Entries %d",Page->EntryCount);
        printf("\t\tUndel Entries %d\n",Page->ActualCount);
        printf("Flag %x",Page->Flags);
        printf("\t\t\tBytes Available %d\n", Page->LastFree-Page->NextFree);

        if ( Page->FragmentedBytes != 0 ) {
            printf("Fragmented bytes %d\n", Page->FragmentedBytes);
        }
    }

    HTable->Entries += Page->EntryCount;

    //
    // Make sure entries are correct
    //

    for (j=0; j<MAX_LEAF_ENTRIES;j++ ) {

        offset = Page->ArtOffset[j];
        if ( offset != 0 ) {

            if ( offset < 0 ) {

                nDel++;
                continue;
            }

            nOk++;

            //
            // Make sure hash values are mapped to correct pages
            //

            if ( Page->PageDepth == 0 ) {

                //
                // if PageDepth is zero, then everything is ok.
                //

                continue;
            }

            if ( HTable->Signature == ART_HEAD_SIGNATURE ) {

                PART_MAP_ENTRY aEntry;
                aEntry = (PART_MAP_ENTRY)((PCHAR)Page + offset);
                if ( Page->HashPrefix !=
                    (aEntry->Header.HashValue >> (32 - Page->PageDepth)) ) {

                    printf("Invalid: HashValue %x\n",aEntry->Header.HashValue);
                    HTable->Flags |= HASH_FLAG_BAD_HASH;
                }

            } else if ( HTable->Signature == HIST_HEAD_SIGNATURE ) {

                PHISTORY_MAP_ENTRY hEntry;
                hEntry = (PHISTORY_MAP_ENTRY)((PCHAR)Page + offset);
                if ( Page->HashPrefix !=
                    (hEntry->Header.HashValue >> (32 - Page->PageDepth)) ) {

                    printf("Invalid: HashValue %x\n",hEntry->Header.HashValue);
                    HTable->Flags |= HASH_FLAG_BAD_HASH;
                }

            } else if ( HTable->Signature == XOVER_HEAD_SIGNATURE ) {

                PXOVER_MAP_ENTRY xEntry;
                xEntry = (PXOVER_MAP_ENTRY)((PCHAR)Page + offset);

                if ( Page->HashPrefix !=
                    (xEntry->Header.HashValue >> (32 - Page->PageDepth)) ) {

                    printf("Invalid: HashValue %x\n",xEntry->Header.HashValue);
                    HTable->Flags |= HASH_FLAG_BAD_HASH;
                }
            }
        }
    }

    //
    // Check to see that all numbers are consistent
    //

    if ( nDel + nOk != Page->EntryCount ) {
        printf("!!!!!!! counts don't match\n");
        HTable->Flags |= HASH_FLAG_BAD_ENTRY_COUNT;
    }

    if ( Verbose ) {
        printf("Deleted %d Ok %d Total %d\n\n",nDel,nOk,nDel+nOk);
    }

    HTable->TotDels += nDel;
    HTable->TotIns += nOk;

} // PrintPageStats

BOOL
checklink(
    PHTABLE HTable
    )
{

    DWORD fileSize = 0;
    DWORD nPages;
    HANDLE hFile = INVALID_HANDLE_VALUE, hMap = NULL;
    PMAP_PAGE   hashPages = NULL;
    PHASH_RESERVED_PAGE headPage = NULL;
    DWORD dirDepth;
    DWORD nEntries;
    PDWORD directory = NULL;
    PMAP_PAGE curPage;
    DWORD i;
    DWORD j;
    DWORD status;
    BOOL ret = FALSE;

    //
    // Open the hash file
    //

    hFile = CreateFile(
                       HTable->FileName,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                       NULL
                       );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            HTable->Flags |= HASH_FLAG_NO_FILE;
            if ( Verbose ) {
                printf("File not found\n");
            }
        } else {
            HTable->Flags |= HASH_FLAG_ABORT_SCAN;
            printf("Error %d in CreateFile.\n",status);
        }
        goto error;
    }

    //
    // Get the size of the file.  This will tell us how many pages
    // are currently filled.
    //

    fileSize = GetFileSize( hFile, NULL );
    if ( fileSize == 0xffffffff ) {
        status = GetLastError();
        printf("Error %d in GetFileSize\n",status);
        HTable->Flags |= HASH_FLAG_ABORT_SCAN;
        goto error;
    }

    if ( Verbose ) {
        printf("File size is %d\n",fileSize);
    }
    HTable->FileSize = fileSize;

    //
    // Make sure the file size is a multiple of a page
    //

    if ( (fileSize % HASH_PAGE_SIZE) != 0 ) {

        //
        // Not a page multiple! Corrupted!
        //

        printf("File size(%d) is not page multiple.\n",fileSize);
        HTable->Flags |= HASH_FLAG_BAD_SIZE;
        goto error;
    }

    nPages = fileSize / HASH_PAGE_SIZE;

    if ( Verbose ) {
        printf("pages allocated %d\n", nPages);
    }

    //
    // Create File Mapping
    //

    hMap = CreateFileMapping(
                        hFile,
                        NULL,
                        PAGE_READWRITE,
                        0,
                        0,
                        NULL
                        );

    if ( hMap == NULL ) {
        status = GetLastError();
        printf("Error %d in CreateFileMapping\n",status);
        HTable->Flags |= HASH_FLAG_ABORT_SCAN;
        goto error;
    }

    //
    // create our view
    //

    headPage = (PHASH_RESERVED_PAGE)MapViewOfFileEx(
                                            hMap,
                                            FILE_MAP_ALL_ACCESS,
                                            0,                      // offset high
                                            0,                      // offset low
                                            0,                      // bytes to map
                                            NULL                    // base address
                                            );

    if ( headPage == NULL ) {
        status = GetLastError();
        printf("Error %d in MapViewOfFile\n",status);
        HTable->Flags |= HASH_FLAG_ABORT_SCAN;
        goto error;
    }

    //
    // Print out the header stats
    //

    PrintHeadStats( headPage );

    //
    // Check the signature and the initialize bit
    //

    if ( headPage->Signature != HTable->Signature ) {

        //
        // Wrong signature
        //

        printf("Invalid signature %x (expected %x)\n",
            headPage->Signature, HTable->Signature);
        HTable->Flags |= HASH_FLAG_BAD_SIGN;
        goto error;
    }

    if ( !headPage->Initialized ) {

        //
        // Not initialized !
        //

        printf("Existing file uninitialized!!!!.\n");
        HTable->Flags |= HASH_FLAG_NOT_INIT;
        goto error;
    }

    if ( headPage->NumPages > nPages ) {

        //
        // bad count. Corrupt file.
        //

        printf("NumPages in Header(%d) more than actual(%d)\n",
            headPage->NumPages, nPages);
        HTable->Flags |= HASH_FLAG_BAD_PAGE_COUNT;
        goto error;
    }

    //
    // Create links and print stats for each page
    //

    nPages = headPage->NumPages;
    dirDepth = headPage->DirDepth;

    hashPages = (PMAP_PAGE)((PCHAR)headPage + HASH_PAGE_SIZE);

    //
    // OK, build the directory
    //

    nEntries = (DWORD)(1 << dirDepth);
    if ( nEntries <= nPages ) {
        printf("dir depth is not sufficient for pages\n");
        HTable->Flags |= HASH_FLAG_BAD_DIR_DEPTH;
        goto error;
    }

    if ( Verbose ) {
        printf("\nSetting up directory of %d entries\n",nEntries);
    }

    directory = (PDWORD)ALLOCATE_HEAP( nEntries * sizeof(DWORD) );
    if ( directory == NULL ) {
        printf("Cannot allocate directory of %d entries!!!\n",nEntries);
        HTable->Flags |= HASH_FLAG_ABORT_SCAN;
        goto error;
    }

    //
    // Initialize the directory to zero.
    //

    ZeroMemory( directory, nEntries * sizeof(DWORD) );

    //
    // Initialize the links.  Here we go through all the pages and update the directory
    // links
    //

    curPage = hashPages;
    for ( i = 1; i < nPages; i++ ) {

        //
        // Set the pointers for this page
        //

        DWORD startPage, endPage;
        DWORD j;

        if ( Verbose ) {
            printf("Processing page %d\n",i);
        }

        //
        // Get the range of directory entries that point to this page
        //

        startPage = curPage->HashPrefix << (dirDepth - curPage->PageDepth);
        endPage = ((curPage->HashPrefix+1) << (dirDepth - curPage->PageDepth));

        if ( Verbose ) {
            printf("\tDirectory ptrs <%d:%d>\n",startPage,endPage-1);
        }

        if ( (startPage > nEntries) ||
             (endPage > nEntries) ) {
            printf("Corrupt prefix for page %d\n",i);
            HTable->Flags |= HASH_FLAG_CORRUPT;
            goto error;
        }


        for ( j = startPage; j < endPage; j++ ) {
            directory[j] = i;
        }

        //
        // Print page stats
        //

        PrintPageStats( HTable, curPage );

        //
        // go to the next page
        //

        curPage = (PMAP_PAGE)((PCHAR)curPage + HASH_PAGE_SIZE);
    }

    //
    // Make sure all the links have been initialized.  If not, then something terrible
    // has happened.  Do a comprehensive rebuilt.
    //

    for (i=0;i<nEntries;i++) {
        if ( directory[i] == 0 ) {
            printf("Directory link check failed on %d\n",i);
            HTable->Flags |= HASH_FLAG_BAD_LINK;
            goto error;
        }
    }

    ret = TRUE;

error:

    //
    // Delete the Directory
    //

    if ( directory != NULL ) {
        FREE_HEAP(directory);
        directory = NULL;
    }

    //
    // Destroy the view
    //

    if ( headPage != NULL ) {

        //
        // Flush the hash table
        //

        (VOID)FlushViewOfFile( headPage, 0 );

        //
        // Close the view
        //

        (VOID) UnmapViewOfFile( headPage );
        headPage = NULL;
    }

    //
    // Destroy the file mapping
    //

    if ( hMap != NULL ) {

        CloseHandle( hMap );
        hMap = NULL;
    }

    //
    // Close the file
    //

    if ( hFile != INVALID_HANDLE_VALUE ) {
        CloseHandle( hFile );
        hFile = INVALID_HANDLE_VALUE;
    }

    return(ret);

} // chklink

BOOL
diagnose(
    PHTABLE HTable
    )
{
    DWORD flags = HTable->Flags;

    printf("Status: ");
    if ( flags == 0 ) {
        printf("Good.\n");
        return(TRUE);
    }

    //
    // Missing?
    //

    if ( flags & HASH_FLAG_NO_FILE ) {
        if ( !DoClean ) {
            printf("Missing File.\n");
        }
        goto exit;
    }

    if ( flags & HASH_FLAG_ABORT_SCAN ) {
        printf("Internal error occurred while processing.\n");
        goto exit;
    }

    printf("Corrupt. Diagnostic Code %x.\n",flags);

exit:
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\chkhash\rebuild.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rebuild.cpp

Abstract:

    This module contains the rebuilding code for the chkhash

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

--*/

#include "..\..\tigris.hxx"
#include <stdlib.h>
#include "chkhash.h"

CMsgArtMap artMap;
CXoverMap xMap;
CHistory histMap;
DWORD entriesAdded = 0;

BOOL
ParseXMapPage(
    IN PMAP_PAGE Page
    );

DWORD
Scan(
    PCHAR pchBegin,
    DWORD cb
    );

BOOL
ParseFile(
    PCHAR FileName,
    GROUPID GroupId,
    ARTICLEID ArticleId,
    PFILETIME CreationTime
    );

BOOL
ProcessGroup(
    PCHAR begin,
    DWORD cb
    );

BOOL
ProcessGroupFile(
    VOID
    );

BOOL
ParseXRefField(
    CArticle &article,
    CPCString &XRefLine,
    CNAMEREFLIST &NameRefList
    );

BOOL
RebuildArtMapFromXOver(
    VOID
    )
{
    DWORD nPages;
    HANDLE hFile = INVALID_HANDLE_VALUE, hMap = NULL;
    PMAP_PAGE   hashPages = NULL;
    PHASH_RESERVED_PAGE headPage = NULL;
    PMAP_PAGE curPage;
    DWORD i;
    DWORD status;
    BOOL retval = TRUE;

    //
    // Open the hash file
    //

    hFile = CreateFile(
                       table[xovermap].FileName,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                       NULL
                       );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        status = GetLastError();
        printf("RebuildArtMapFromXOver: Error %d in CreateFile.\n",status);
        retval = FALSE;
        goto error;
    }

    //
    // Create File Mapping
    //

    hMap = CreateFileMapping(
                        hFile,
                        NULL,
                        PAGE_READWRITE,
                        0,
                        0,
                        NULL
                        );

    if ( hMap == NULL ) {
        status = GetLastError();
        printf("Rebuild: Error %d in CreateFileMapping\n",status);
        retval = FALSE;
        goto error;
    }

    //
    // create our view
    //

    headPage = (PHASH_RESERVED_PAGE)MapViewOfFileEx(
                                            hMap,
                                            FILE_MAP_ALL_ACCESS,
                                            0,                      // offset high
                                            0,                      // offset low
                                            0,                      // bytes to map
                                            NULL                    // base address
                                            );

    if ( headPage == NULL ) {
        status = GetLastError();
        printf("Rebuild: Error %d in MapViewOfFile\n",status);
        retval = FALSE;
        goto error;
    }

    //
    // Scan each page
    //

    nPages = headPage->NumPages;
    hashPages = (PMAP_PAGE)((PCHAR)headPage + HASH_PAGE_SIZE);
    curPage = hashPages;

    //
    // Initialize article mapping
    //

    if ( !artMap.Initialize( ) ) {
        retval = FALSE;
        goto error;
    }

    for ( i = 1; i < nPages; i++ ) {

        //
        // Print page stats
        //

        if ( !ParseXMapPage( curPage ) ) {
            retval = FALSE;
            break;
        }

        //
        // go to the next page
        //

        curPage = (PMAP_PAGE)((PCHAR)curPage + HASH_PAGE_SIZE);
    }

    //
    // shutdown
    //

    artMap.Shutdown( );

    //
    // Touch the history file
    //

    if (histMap.Initialize( )) {
        histMap.Shutdown( );
    }

error:

    if ( headPage != NULL ) {

        //
        // Flush the hash table
        //

        (VOID)FlushViewOfFile( headPage, 0 );

        //
        // Close the view
        //

        (VOID) UnmapViewOfFile( headPage );
        headPage = NULL;
    }

    //
    // Destroy the file mapping
    //

    if ( hMap != NULL ) {

        CloseHandle( hMap );
        hMap = NULL;
    }

    //
    // Close the file
    //

    if ( hFile != INVALID_HANDLE_VALUE ) {
        CloseHandle( hFile );
        hFile = INVALID_HANDLE_VALUE;
    }

    return(retval);

} // RebuildArtMapFromXOver

BOOL
RebuildArtMapAndXover(
    VOID
    )
{
    BOOL deleteFiles = FALSE;
    BOOL ret = TRUE;

    if (!CNewsGroup::InitClass( )) {
        printf("unable to initialize news groups\n");
        return(FALSE);
    }

    if (!CNewsTree::InitCNewsTree( 0 )) {
        printf("unable to initialize news tree\n");
        return(FALSE);
    }

    //
    // Initialize tables
    //

    if ( RebuildArtMapTable ) {
        if ( !artMap.Initialize( ) ) {
            ret=FALSE;
            goto error;
        }
    }

    if ( !xMap.Initialize( ) ) {
        if ( RebuildArtMapTable ) {
            artMap.Shutdown( );
        }
        ret=FALSE;
        goto error;
    }

    //
    // Process the group.lst file
    //

    if (!ProcessGroupFile(  )) {
        ret=FALSE;
        deleteFiles = TRUE;
    }

    //
    // We're done. Shutdown the hash files neatly
    //

    if ( RebuildArtMapTable ) {
        artMap.Shutdown( );
    }

    xMap.Shutdown( );

    //
    // Touch the history file
    //

    if (histMap.Initialize( )) {
        histMap.Shutdown( );
    }

error:

    return(ret);
} // RebuildArtMapAndXover


//
// The ff routines are copied from tigris code.  So if you find a bug here,
// only change it in tigris (newsgrp.cpp)
//

BOOL
ProcessGroupFile(
    VOID
    )
{

    DWORD cb ;
    PCHAR begin;

    //
    // Open the group file.  If it's not there, there's nothing
    // else we can do.
    //

    printf( "scanning group.lst\n" );
    CMapFile map( "c:\\inetsrv\\server\\nntpfile\\group.lst", FALSE, 0 );
    if ( !map.fGood() )
    {

        printf( "Cannot open c:\\inetsrv\\server\\nntpfile\\group.lst\n" );
        return FALSE;
    }

    //
    // Go through the file line by line
    //

    begin = (char*)map.pvAddress( &cb );
    while( cb != 0 ) {

        DWORD cbUsed;
        cbUsed = ProcessGroup(begin, cb);

        if( cbUsed == 0 ) {
            // Fatal Error - blow out of here
            return FALSE;
        }

        begin += cbUsed;
        cb -= cbUsed;
    }

    printf("Entries processed %d\n",entriesAdded);
    return(TRUE);

} // ProcessGroupFile

#define     MAX_GROUPNAME   1024

BOOL
ProcessGroup(
    PCHAR pchBegin,
    DWORD cb
    )
{
	DWORD	cbScan = 0 ;
	DWORD	cbRead = 0 ;
    CHAR   groupName[MAX_GROUPNAME];
    CHAR   path[MAX_GROUPNAME];
    DWORD   artLow;
    DWORD   artHigh;
    DWORD   nArticles;
    DWORD   groupId;
    DWORD pathLength;

	if( (cbScan = Scan( pchBegin, cb )) == 0 ) {
		return	0 ;
	}	else	{
        if ( cbScan >= MAX_GROUPNAME ) {
            return(0);
        }
        CopyMemory( groupName, pchBegin, cbScan ) ;
		groupName[cbScan-1] = '\0' ;
	}

	cbRead+=cbScan ;

	if( (cbScan = Scan( pchBegin+cbRead, cb-cbRead )) == 0 ) {
		return	0 ;
	}	else	{
        if ( cbScan >= MAX_GROUPNAME ) {
            return(0);
        }
		CopyMemory( path, pchBegin+cbRead, cbScan ) ;
		path[cbScan-1] = '\0' ;
        pathLength = cbScan - 1;
	}

	cbRead += cbScan ;

	if( (cbScan = Scan( pchBegin + cbRead, cb-cbRead )) == 0 ) {
		return	0 ;
	}	else	{

		if( sscanf( pchBegin+cbRead, "%d", &artLow ) != 1 ) {
			return	0 ;
		}	
	}

	cbRead += cbScan ;

	if( (cbScan = Scan( pchBegin + cbRead, cb-cbRead )) == 0 )	{
		return	0 ;		
	}	else	{
		if( sscanf( pchBegin+cbRead, "%d", &artHigh ) != 1 ) {
			return	0 ;
		}
	}

	cbRead += cbScan ;

	if( (cbScan = Scan( pchBegin + cbRead, cb-cbRead )) == 0 )	{
		return	0 ;		
	}	else	{
		if( sscanf( pchBegin+cbRead, "%d", &nArticles ) != 1 ) {
			return	0 ;
		}
	}

	cbRead += cbScan ;

	if( (cbScan = Scan( pchBegin + cbRead, cb-cbRead )) == 0 )	{
		return	0 ;		
	}	else	{
		if( sscanf( pchBegin+cbRead, "%d", &groupId ) != 1 ) {
			return	0 ;
		}
	}

	cbRead += cbScan ;

	if( (cbScan = Scan( pchBegin + cbRead, cb-cbRead )) == 0 )	{
		return	0 ;		
	}

	cbRead += cbScan ;

	if( (cbScan = Scan( pchBegin + cbRead, cb-cbRead )) == 0 )	{
		return	0 ;		
	}

	cbRead += cbScan ;

    //
    // If the group has articles, parse them.
    //

    if ( nArticles > 0 ) {

        WIN32_FIND_DATA fData;
        DWORD nParsed = 0;
        HANDLE hFind;

        //
        // concatenate .a
        //

        lstrcat( path, "\\*.a" );

        //
        // Look for files with .a in the group
        //

        hFind = FindFirstFile( path, &fData );
        if ( hFind == INVALID_HANDLE_VALUE )
        {
            printf( "No files found in %s\n", path );
            goto exit;
        }

        if ( !Quiet ) {
            printf("Scanning %s\n",groupName);
        }

        do {

            ARTICLEID articleId;
            CHAR artFile[MAX_PATH];
            PCHAR p;

            //
            // Get the article ID
            //

            p=strtok(fData.cFileName,".");
            if ( p == NULL ) {
                printf("Cannot get article ID number from %s\n",fData.cFileName);
                break;
            }

            articleId = atoi(p);
            if ( articleId == 0 ) {
                printf("!!! Zero article ID from %s\n",p);
            }

            p[strlen(p)] = '.';
            CopyMemory(artFile,path,pathLength);
            artFile[pathLength] = '\\';
            artFile[pathLength+1] = '\0';
            lstrcat(artFile,fData.cFileName);

            (VOID)ParseFile(
                    artFile,
                    groupId,
                    articleId,
                    &fData.ftCreationTime
                    );

        } while ( FindNextFile(hFind,&fData) );

        FindClose(hFind);
    }

exit:

	if( pchBegin[cbRead-1] != '\n' ) {
		return 0 ;
	}
	return	cbRead ;
}

DWORD
Scan(
    PCHAR pchBegin,
    DWORD cb
    )
{

	for( DWORD	i=0; i < cb; i++ ) {
		if( pchBegin[i] == ' ' || pchBegin[i] == '\n' ) {
			return i+1 ;			
		}		
	}
	return	0 ;
}

BOOL
ParseFile(
    PCHAR FileName,
    GROUPID GroupId,
    ARTICLEID ArticleId,
    PFILETIME CreationTime
    )
{
    CNntpReturn nntpReturn;
    char buf[4000];
    CPCString pcBuf(buf,4000);
    CHAR msgId[512];
    DWORD i;
    PCHAR p;
    CNAMEREFLIST namereflist;
    POSITION pos;
    NAME_AND_ARTREF *pNameRef;
    CArticleRef *pArtref;

    if ( !Quiet ) {
        printf("Parsing %s\n",FileName);
    }

	//
	// Create allocator for storing parsed header values
	//
	const DWORD cchMaxBuffer = 1 * 1024;
	char rgchBuffer[cchMaxBuffer];
    HEADERS_STRINGS * pHeader;
	CAllocator allocator(rgchBuffer, cchMaxBuffer);

	CToClientArticle *pArticle = new CToClientArticle( );

    __try{

        if (!pArticle->fInit( FileName, nntpReturn,  &allocator)) {
            printf("Cannot parse %s\n",FileName);
            __leave;
        }

        //
        // Get the message id
        //

        if ( !pArticle->fFindOneAndOnly(
                                    szKwMessageID,
                                    pHeader,
                                    nntpReturn
                                    ) )  {
            printf("Error in parsing. %s\n",nntpReturn.m_sz);
            __leave;
	    }

        i = pHeader->pcValue.m_cch;
        CopyMemory(msgId,pHeader->pcValue.m_pch,i);
        msgId[i] = '\0';

        if (!pArticle->fXOver(pcBuf,nntpReturn)) {
            printf("cannot get xover data %s\n",nntpReturn.m_sz);
            __leave;
        }

        //
        // ok, read the xref line
        //

        if ( !pArticle->fFindOneAndOnly(szKwXref,pHeader,nntpReturn)) {
            printf("cannot find xref field (%s)\n",nntpReturn.m_sz);
            __leave;
        }

        //
        // Get the groupid/article id pair
        //

        if (!ParseXRefField( *pArticle, pHeader->pcValue, namereflist ) ) {

            printf("cannot parse xref field\n");
            __leave;
        }

        //
        // Insert in the article mapping table
        //

        if ( RebuildArtMapTable &&
             !artMap.InsertMapEntry(
                                msgId,
                                GroupId,
                                ArticleId
                                ) ) {

            printf("InsertMapEntry failed for %s (%d)\n",
                pArticle->szMessageID( ), GetLastError());

            _leave;
        }

        //
        // Insert in the XOver table
        //

        if ( !xMap.CreatePrimaryNovEntry(
                                GroupId,
                                ArticleId,
                                CreationTime,
                                buf,
                                pcBuf.m_cch,
                                &namereflist
                                ) ) {

            printf("CreateNovEntry failed for %d %d (%d)\n",
                GroupId, ArticleId, GetLastError());

            _leave;
        }

        //
        // Insert the cross posting entries
        //

        i= namereflist.GetCount() - 1;

        pos = namereflist.GetHeadPosition();
        pNameRef = namereflist.GetNext(pos);

        for (; i > 0 ;i--) {

            pNameRef = namereflist.GetNext(pos);
            pArtref = &(pNameRef->artref);

            //
            // Create xpost xover entries
            //

            xMap.CreateXPostNovEntry(
                                pArtref->m_groupId,
                                pArtref->m_articleId,
                                CreationTime,
                                GroupId,
                                ArticleId
                                );
        }

        entriesAdded++;
    	nntpReturn.fSetOK();

	}__finally{
		delete pArticle;
	}

    return(TRUE);
} // ParseFile

#define MAX_KEY_LEN 32

BOOL
ParseXMapPage(
    IN PMAP_PAGE Page
    )
{
    DWORD j;
    DWORD i;
    SHORT offset;
    PXOVER_MAP_ENTRY xEntry;
    CHAR xover[2048];

    for (j=0; j<MAX_LEAF_ENTRIES;j++ ) {

        offset = Page->ArtOffset[j];
        if ( offset != 0 ) {

            BOOL isPrimary;
            CHAR key[MAX_KEY_LEN];
            ARTICLEID  artId;
            GROUPID groupId;
            PCHAR p;
            PCHAR q;

            if ( offset < 0 ) {
                continue;
            }

            xEntry = (PXOVER_MAP_ENTRY)((PCHAR)Page + offset);

            //
            // Check if this is the primary group
            //

            isPrimary = ((xEntry->Flags & XOVER_MAP_PRIMARY) != 0);

            //
            // Crack the key into group id and article id
            //

            q=xEntry->Data + xEntry->NumberOfXPostings*sizeof(GROUP_ENTRY);
            lstrcpy( key, q);

            p=strtok(key,"!");
            if ( p == NULL ) {
                printf("cannot process key from %s\n",p);
                goto error;
            }

            groupId = atoi(p);
            p+=(strlen(p)+1);
            artId = atoi(p);

            //
            // Scan the xover data for the msg id
            //

            lstrcpy(xover,q+xEntry->KeyLen);

            p=strtok(xover,"\t");
            for (i=0; i < 3; i++) {
                if ( p == NULL ) {
                    printf("cannot extract msg id from %s\n",xover);
                    goto error;
                }
                p=strtok(NULL,"\t");
            }

            //
            // ok, insert into the article mapping table
            //

            if ( !artMap.InsertMapEntry(
                                p,
                                groupId,
                                artId
                                ) ) {

                printf("ParseXMapPage: InsertMapEntry failed for %s (%d)\n",
                    p, GetLastError());
                goto error;
            }
        }
    }

    return(TRUE);

error:
    return(FALSE);

} // ParseXMapPage

BOOL
ParseXRefField(
    CArticle &article,
    CPCString &XRefLine,
    CNAMEREFLIST &NameRefList
    )

 /*++

Routine Description:

  Parses the XRef field.


Arguments:


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
    DWORD numGroups = 0;
	CPCString pcValue = XRefLine;
	CPCString pcHubFromParse;
    CNewsTree * pNewsTree = CNewsTree::GetTree( );

	pcValue.vGetToken(szWSNLChars, pcHubFromParse);

	//
	// Count the number of ':''s so we know the number of slots needed
	//

	DWORD dwXrefCount = pcValue.dwCountChar(':');
	if (!NameRefList.fInit(dwXrefCount, article.pAllocator())) {
		return FALSE;
	}

	while (0 < pcValue.m_cch) {

		CPCString pcName;
		CPCString pcArticleID;
        CHAR xgroup[MAX_PATH];

		pcValue.vGetToken(":", pcName);
		pcValue.vGetToken(szWSNLChars, pcArticleID);

		if ((0 == pcName.m_cch) || (0 == pcArticleID.m_cch)) {
			return FALSE;
        }

        pcName.vCopyToSz( xgroup );
        CGRPPTR pGroup = pNewsTree->GetGroup(xgroup,0);
		NAME_AND_ARTREF Nameref;

        if ( pGroup != NULL ) {

		    //
    		// Convert string to number. Don't need to terminate with a '\0' any
	    	// nondigit will do.
		    //

		    (Nameref.artref).m_articleId = atoi(pcArticleID.m_pch);
		    (Nameref.artref).m_groupId = pGroup->GetGroupId();
		    Nameref.pcName.vInsert(pGroup->GetGroupName());
		    NameRefList.AddTail(Nameref);
            numGroups++;
        } else {
            if ( Verbose ) {
                printf("Cannot get group object for %s\n",xgroup);
            }
        }
	}

    if ( numGroups == 0 ) {
        return(FALSE);
    }
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\chkhash\main.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    This module contains the main function for the chkhash program.

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

--*/

#include "..\..\tigris.hxx"
#include "chkhash.h"

extern	class	TSVC_INFO*	g_pTsvcInfo ;

//
// Globals
//

BOOL Verbose = FALSE;
BOOL Quiet = FALSE;
BOOL RebuildArtMapTable = FALSE;
BOOL DoRebuild = FALSE;
BOOL DoClean = FALSE;
BOOL NoHistoryDelete = FALSE;

//
// Indicate whether both the article map table and the xover table
// have to be rebuilt if the xover table is hosed.
//

BOOL SynchronizeRebuilds = FALSE;

//
// information on hash tables
//

HTABLE table[] = {
    { "Article to MsgId Mapping", "c:\\inetsrv\\server\\nntpfile\\article.hsh", "c:\\inetsrv\\server\\nntpfile\\article.bad",
        ART_HEAD_SIGNATURE, 0, 0, 0, 0, 0 },
    { "History", "c:\\inetsrv\\server\\nntpfile\\history.hsh", "c:\\inetsrv\\server\\nntpfile\\history.bad",
        HIST_HEAD_SIGNATURE, 0, 0, 0, 0, 0 },
    { "XOver", "c:\\inetsrv\\server\\nntpfile\\xover.hsh", "c:\\inetsrv\\server\\nntpfile\\xover.bad",
        XOVER_HEAD_SIGNATURE, 0, 0, 0, 0, 0 }
    };

BOOL
RenameHashFile(
    filetype HashType
    );

BOOL
VerifyTable(
    filetype HashType
    );

void
usage( )
{
    printf("CHKHASH\n");
    printf("\t-v    verbose mode\n");
    printf("\t-r    rebuilds corrupted mapfiles\n");
    printf("\t-s    rebuilds article mapfile if xover file is bad\n");
    printf("\t-q    quiet mode\n");
    printf("\t-c    rebuild everything\n");
    printf("\t-h    don't delete history file\n");
    return;
}

int
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    g_pTsvcInfo = 0;
    INT cur = 1;
    PCHAR x;

    //
    // Parse command line
    //

    while ( cur < argc ) {

        x=argv[cur++];
        if ( *(x++) == '-' ) {

            switch (*x) {
            case 'v':
                Verbose = TRUE;
                break;

            case 'c':
                DoRebuild = TRUE;
                DoClean = TRUE;
                break;

            case 'q':
                Quiet = TRUE;
                break;

            case 'h':
                NoHistoryDelete = TRUE;
                break;

            case 'r':
                DoRebuild = TRUE;
                break;

            case 's':
                SynchronizeRebuilds = TRUE;
                break;

            default:
                usage( );
                return(1);
            }
        }
    }

    //
    // if clean build, then erase all files
    //

    if ( DoClean ) {
        if (!DeleteFile(table[artmap].FileName)) {
            if ( GetLastError()!=ERROR_FILE_NOT_FOUND ) {
                printf("cannot delete %s. Error %d\n",
                    table[artmap].FileName, GetLastError());
                goto exit;
            }

        }

        if (!DeleteFile(table[xovermap].FileName)) {
            if ( GetLastError()!=ERROR_FILE_NOT_FOUND ) {
                printf("cannot delete %s. Error %d\n",
                    table[xovermap].FileName, GetLastError());
                goto exit;
            }

        }

        if ( !NoHistoryDelete && !DeleteFile(table[histmap].FileName)) {
            if ( GetLastError()!=ERROR_FILE_NOT_FOUND ) {
                printf("cannot delete %s. Error %d\n",
                    table[histmap].FileName, GetLastError());
                goto exit;
            }
        }
    }

    if ( !DoRebuild ) {
        printf("Warning! r parameter not specified\nNo rebuilds will be attempted.\n");
    }

    InitAsyncTrace( );
    CArticle::InitClass( );

    VerifyTable(artmap);
    VerifyTable(histmap);
    VerifyTable(xovermap);

    if ( !DoRebuild ) {
        goto exit;
    }

    //
    // see if we hit an abort somewhere
    //

    printf("\n");

    if ( ((table[artmap].Flags & HASH_FLAG_ABORT_SCAN) != 0) &&
         ((table[histmap].Flags & HASH_FLAG_ABORT_SCAN) != 0) &&
         ((table[xovermap].Flags & HASH_FLAG_ABORT_SCAN) != 0) ) {

        printf("CHKHASH aborting due to an unrecoverable error\n");
        goto exit;
    }

    //
    // Do the history file
    //

    if ( table[histmap].Flags != 0 ) {

        //
        // If history map table is hosed, there's nothing we can do but
        // to zap it (well, let's just rename it to something else)
        //

        RenameHashFile( histmap );
    }

    //
    // Should we rename the xover and artmap file ?
    //

    if ( table[xovermap].Flags != 0 ) {

        RenameHashFile( xovermap );

        //
        // see if we need to rebuild the artmap table because of this
        //

        if ( SynchronizeRebuilds && (table[artmap].Flags == 0) ) {
            RebuildArtMapTable = TRUE;
            RenameHashFile( artmap );
        }
    }

    if ( table[artmap].Flags != 0 ) {
        RebuildArtMapTable = TRUE;
        RenameHashFile( artmap );
    }

    //
    // if xover file is hosed, we may need to redo both the xover and
    // the artmap table from scratch depending on user choice and whether
    // the artmap table is also hosed
    //

    if ( table[xovermap].Flags != 0 ) {

        printf("Rebuilding Article and XOver map table...");
        if ( RebuildArtMapAndXover( ) ) {
            printf("Done.\n");
        } else {
            printf("Failed.\n");
        }

    } else if ( table[artmap].Flags != 0 ) {

        //
        // Since the xover table is ok, only rebuild the article map
        // table
        //

        printf("Rebuilding Article from XOver map table...");
        if ( RebuildArtMapFromXOver( ) ) {
            printf("Done.\n");
        } else {
            printf("Failed.\n");
        }
    }

exit:
    TermAsyncTrace( );
    return(1);
}

BOOL
VerifyTable(
    filetype HashType
    )
{
    PHTABLE ourTable = &table[HashType];

    printf("\nProcessing %s table(%s)\n",
        ourTable->Description, ourTable->FileName);

    checklink( ourTable );
    diagnose( ourTable );
    return(TRUE);

} // VerifyTable

BOOL
RenameHashFile(
    filetype HashType
    )
{

    PHTABLE HTable = &table[HashType];

    if (!MoveFileEx(
            HTable->FileName,
            HTable->NewFileName,
            MOVEFILE_REPLACE_EXISTING
            ) ) {

        if ( GetLastError() != ERROR_FILE_NOT_FOUND ) {
            printf("Error %d in rename\n",GetLastError());
            return(FALSE);
        }

    } else {
        printf("Renaming from %s to %s\n",HTable->FileName, HTable->NewFileName);
    }

    return(TRUE);

} // RenameHashFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\cmap\addon.cpp ===
#include    <windows.h>
#include    <stdio.h>
#include    "rw.h"
#include    "mapfile.h"
#include	"addon.h"

#ifndef	_ASSERT
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
#endif

DWORD	
ScanWS(	char*	pchBegin,	DWORD	cb ) {
	//
	//	This is a utility used when reading a newsgroup
	//	info. from disk.
	//

	for( DWORD	i=0; i < cb; i++ ) {
		if( pchBegin[i] == ' ' || pchBegin[i] == '\t' ) {
			return i+1 ;			
		}		
	}
	return	0 ;
}

DWORD	
Scan(	char*	pchBegin,	char	ch,	DWORD	cb ) {
	//
	//	This is a utility used when reading a newsgroup
	//	info. from disk.
	//

	for( DWORD	i=0; i < cb; i++ ) {
		if( pchBegin[i] == ch ) {
			return i+1 ;			
		}		
	}
	return	0 ;
}

DWORD	
ScanEOL(	char*	pchBegin,	DWORD	cb ) {
	//
	//	This is a utility used when reading a newsgroup
	//	info. from disk.
	//

	for( DWORD	i=0; i < cb; i++ ) {
		if( pchBegin[i] == '\n' || pchBegin[i] == '\r' ) {
			i++ ;
			return i ;			
		}		
	}
	return	0 ;
}

DWORD	
Scan(	char*	pchBegin,	DWORD	cb ) {
	//
	//	This is a utility used when reading a newsgroup
	//	info. from disk.
	//

	for( DWORD	i=0; i < cb; i++ ) {
		if( pchBegin[i] == ' ' || pchBegin[i] == '\n' ) {
			return i+1 ;			
		}		
	}
	return	0 ;
}

DWORD	
ScanDigits(	char*	pchBegin,	DWORD	cb ) {
	//
	//	This is a utility used when reading a newsgroup
	//	info. from disk.
	//

	for( DWORD	i=0; i < cb; i++ ) {
		if( pchBegin[i] == ' ' || pchBegin[i] == '\n' || pchBegin[i] == '\r' ) {
			return i+1 ;			
		}
		if( !isdigit( pchBegin[i] ) && pchBegin[i] != '-' )	{
			return	0 ;
		}		
	}
	return	0 ;
}

DWORD
CountNonNulls(	char*	pchStart,	DWORD	cb ) {

	char*	pchEnd = pchStart + cb ;
	DWORD	count = 0 ;

	while( pchStart < pchEnd ) {
		if( *pchStart != '\0' ) {
			count++ ;
		}
		pchStart ++ ;
	}
	return	count ;
}
	


CAddon::CAddon() : 
	m_hFile( INVALID_HANDLE_VALUE ),
	m_pMapFile( 0 ),
	m_cbInuse( 0 ),
	m_cbAvailable( 0 ),
	m_cbDeleted( 0 )	{
}

void
CAddon::ReadData()	{

	m_Access.ShareLock() ;

}


void
CAddon::FinishReadData()	{

	m_Access.ShareUnlock() ;

}

void
CAddon::ExclusiveData()	{

	m_Access.ExclusiveLock() ;

}

void
CAddon::UnlockExclusiveData()	{

	m_Access.ExclusiveUnlock() ;

}


BOOL
CAddon::Init(	
			LPSTR	lpstrAddonFile,
			BOOL	fCompact,
			DWORD	cbGrow
			) {

	m_Access.ExclusiveLock() ;

	//
	//	User must provide some minimum amount of padding space.
	//
#ifdef	UNIT_TEST
	cbGrow = min( cbGrow, 128) ;
#else
	cbGrow = min( cbGrow, 8192 ) ;
#endif

#ifdef DEBUG
	cbGrow = min( cbGrow, 4096 ) ;
#endif

	//
	//	Open the file !
	//
	HANDLE	hFile = CreateFile(	lpstrAddonFile,
								GENERIC_READ | GENERIC_WRITE,
								FILE_SHARE_READ,
								NULL, 
								OPEN_ALWAYS, 
								FILE_FLAG_RANDOM_ACCESS, 
								INVALID_HANDLE_VALUE 
							) ;

	if( hFile == INVALID_HANDLE_VALUE ) {

		m_Access.ExclusiveUnlock() ;
		return	FALSE ;

	}
	
	BY_HANDLE_FILE_INFORMATION	fileInfo ;

	if( !GetFileInformationByHandle( hFile, &fileInfo ) )	{
		m_Access.ExclusiveUnlock() ;
		return	FALSE ;	
	}
	
#ifdef DEBUG	
	DWORD curSize = GetFileSize( hFile, NULL );
	DWORD cbNewSize = curSize + cbGrow;
	SYSTEM_INFO si;
	GetSystemInfo(&si);
	
	// ensure that the new size is a multiple of the page size
	DWORD cbExtra = cbNewSize % si.dwPageSize ;
	if( cbExtra )
		cbGrow += ( si.dwPageSize - cbExtra );
	cbNewSize = curSize + cbGrow;

	_ASSERT( (cbNewSize % si.dwPageSize) == 0 );

	m_pMapFile = new CMapFileEx( hFile, TRUE, FALSE, cbGrow ) ;	// use guard pages in debug build
#else
	m_pMapFile = new CMapFile( hFile, TRUE, FALSE, cbGrow ) ;
#endif

	if( !m_pMapFile->fGood() ) {

		delete	m_pMapFile ;
		m_pMapFile = 0 ;
		CloseHandle( hFile ) ;
		m_Access.ExclusiveUnlock() ;
		return	FALSE ;

	}

	m_cbInuse = fileInfo.nFileSizeLow ;
	m_cbAvailable = cbGrow ;

	if( fCompact ) {

		CompactImage() ;

#ifdef	DEBUG
		{
		DWORD	cbJunk ;
		char*	pchBegin = (char*)m_pMapFile->pvAddress( & cbJunk ) ;
		_ASSERT( CountNonNulls( pchBegin, m_cbInuse ) == m_cbInuse ) ;
		}
#endif

	}

	if( !ScanImage() ) {
		ResetAddons() ;
		delete	m_pMapFile ;
		m_pMapFile = 0 ;
		CloseHandle( hFile ) ;
		m_cbInuse = 0 ;
		m_cbAvailable = 0 ;
		m_Access.ExclusiveUnlock() ;
		return	FALSE ;
	}

	m_hFile = hFile ;

	m_Access.ExclusiveUnlock() ;

	return	TRUE ;
}

BOOL
CAddon::Close( 
			BOOL	fCompact 
			)	{
/*++

Routine Description : 

	Close a CAddon object.  We set ourselves to the state we 
	are in just after our constructor is called, so we can be 
	reused immediately.

Arguments : 

	fCompact - if TRUE the memory mapping is compressed before
		we close everything.

Return Value : 

	TRUE if successfull, false otherwise.

--*/


	m_Access.ExclusiveLock() ;

	if( m_pMapFile == 0 ) {
		m_Access.ExclusiveUnlock() ;
		return	FALSE ;
	}

	if( fCompact ) {

		CompactImage() ;
#ifdef	DEBUG
		{
		DWORD	cbJunk ;
		char*	pchBegin = (char*)m_pMapFile->pvAddress( & cbJunk ) ;

		_ASSERT( CountNonNulls( pchBegin, m_cbInuse ) == m_cbInuse ) ;
		}
#endif

	}

	if( m_cbInuse > 0 ) {
		DWORD	cb ;
		LPVOID	lpv = m_pMapFile->pvAddress( &cb ) ;
#ifndef DEBUG
		FlushViewOfFile( lpv, m_cbInuse ) ;
#endif
	}

	delete	m_pMapFile ;
	m_pMapFile = 0 ;

	//
	//	Set the file length to the number of bytes inuse !
	//
	if( SetFilePointer( m_hFile, m_cbInuse, NULL, FILE_BEGIN ) ==
		m_cbInuse ) {
		SetEndOfFile( m_hFile ) ;
	}

	CloseHandle( m_hFile ) ;
	m_hFile = INVALID_HANDLE_VALUE ;
	m_cbInuse = 0 ;
	m_cbDeleted = 0 ;
	m_cbAvailable = 0 ;

	m_Access.ExclusiveUnlock() ;
	return	TRUE ;
}



BOOL
CAddon::ScanImage()	{
/*++

Routine Description : 

	This function parses the input file and splits the lines up.
	As we split up each line, we call LookupFunction to let the 
	derived class figure out where to squirrel away the data pointer.

Arguments : 
	
	None.

Return Value :

	TRUE if Successfull, 
	FALSE otherwise	

--*/

	if( m_pMapFile == 0 ) {
		return	FALSE ;
	}

	DWORD	cb ;
	char*	pchBegin = (char*)(m_pMapFile->pvAddress( &cb )) ;
	char	szBuff[ 2*MAX_PATH ] ;

	_ASSERT( cb == m_cbInuse + m_cbAvailable ) ;
	_ASSERT( cb >= m_cbInuse ) ;

	cb = m_cbInuse ;

#ifdef DEBUG
	_ASSERT( m_pMapFile->UnprotectMapping() );
#endif

	while( cb != 0 ) {

		while( *pchBegin == '\0' && cb != 0 ) {
			pchBegin ++ ;
			cb -- ;
		}

		if( cb == 0 ) {
			break ;
		}

		DWORD	cbGroup = ScanWS( pchBegin, cb ) ;
		DWORD	cbEol = ScanEOL( pchBegin + cbGroup, cb - cbGroup ) ;

		if( cbGroup == 0 ||
			cbEol == 0 ) {

		#ifdef DEBUG
			_ASSERT( m_pMapFile->ProtectMapping() );
		#endif

			return	FALSE ;

		}

		CHAR	chTemp = pchBegin[cbGroup-1] ;
		pchBegin[cbGroup-1] = '\0' ;

		CHAR	chTemp2 = pchBegin[cbGroup-1+cbEol] ;
		pchBegin[cbGroup+cbEol-1] = '\0' ;

		LookupFunction(	pchBegin, 
						cbGroup-1, 
						pchBegin+cbGroup,
						cbEol-1,
						NULL ) ;

		pchBegin[cbGroup-1] = chTemp ;
		pchBegin[cbGroup+cbEol-1] = chTemp2 ;

		cb -= cbGroup ;
		pchBegin += cbGroup ;

		while( cbEol < cb ) {
			if( !(pchBegin[cbEol] == '\r' || pchBegin[cbEol] == '\n') )
				break ;
			cbEol++ ;
		}
		cb -= cbEol ;
		pchBegin += cbEol ;
	}

#ifdef DEBUG
	_ASSERT( m_pMapFile->ProtectMapping() );
#endif

	return	TRUE ;
}

BOOL
CAddon::AppendLine(
				LPSTR	lpstrGroup,
				DWORD	cbGroup,
				LPSTR	lpstrData,
				DWORD	cbData,
				void*	lpvContext
				) {
/*++

Routine Description : 

	This function adds a line of text to the memory mapping.
	If there is room within our current memory mapping, 
	we will append the text to the end.  Otherwise, we will
	try to grow the memory mapping.

Arguments : 

	lpstrGroup - Index string, starts the line of text in the file
					This line must not contain white space.
	cbGroup -	size of index string
	lpstrData -	 The data for the line.  May contain spaces and tabs.
	cbData -	Length of data string
	lpvContext - Context value to be passed to LookupFunction().

Return Value : 

	TRUE if successfull, FALSE otherwise.

--*/

	//
	//	Validate Arguments
	//
	_ASSERT( lpstrGroup != 0 ) ;
	_ASSERT( cbGroup != 0 ) ;
	_ASSERT( lpstrData != 0 ) ;
	_ASSERT( cbData != 0 ) ;
	_ASSERT( strcspn( lpstrGroup, "\t\r\n " ) >= cbGroup ) ;
	_ASSERT( strcspn( lpstrData, "\t\r\n" ) >= cbData ) ;

	m_Access.ExclusiveLock() ;

	if( m_pMapFile == 0 ) {
		m_Access.ExclusiveUnlock() ;
		return	FALSE ;
	}

	DWORD	cb ;

	//
	//	Check whether there is room to append the new string.
	//
	if(	m_cbAvailable <=	cbGroup +
						cbData +
						3 /* 3 chars for CRLF 1 for TAB separator*/ )	{


		//
		//	Get the old base address
		//
		LPVOID	lpv = m_pMapFile->pvAddress( &cb ) ;

		//
		//	Need to grow memory mapping !!
		//

		delete	m_pMapFile ;

		//
		//	Grow by 1 MB at a time.
		//
		DWORD	minGrow = min( 1000*(cbGroup + cbData + 3), 1024 * 1024 ) ;

#ifdef DEBUG
		DWORD curSize = GetFileSize( m_hFile, NULL );
		DWORD cbNewSize = curSize + minGrow;
		SYSTEM_INFO si;
		GetSystemInfo(&si);
	
		// ensure that the new size is a multiple of the page size
		DWORD cbExtra = cbNewSize % si.dwPageSize ;
		if( cbExtra )
			minGrow += ( si.dwPageSize - cbExtra );
		cbNewSize = curSize + minGrow;

		_ASSERT( (cbNewSize % si.dwPageSize) == 0 );

		m_pMapFile = new	CMapFileEx( m_hFile, TRUE, FALSE, minGrow ) ;
#else
		m_pMapFile = new	CMapFile( m_hFile, TRUE, FALSE, minGrow ) ;
#endif

		if( !m_pMapFile ) {
			m_Access.ExclusiveUnlock() ;
			return	FALSE ;

		}
		if( !m_pMapFile->fGood() ) {
		
			delete	m_pMapFile ;
			m_pMapFile = 0 ;	
			m_Access.ExclusiveUnlock() ;
			return	FALSE ;
	
		}

		m_cbAvailable += minGrow ;

		_ASSERT( (CountNonNulls( (char*)(m_pMapFile->pvAddress( &cb )), m_cbInuse ) + m_cbDeleted) 
					== m_cbInuse ) ;


		//
		//	Check whether the memory mapping moved - if it did we
		//	need to rescan the file.
		//
		if( lpv != m_pMapFile->pvAddress( &cb ) ) {
			ResetAddons() ;
			ScanImage() ;
		}

	}

	//
	//	Get the address where we wish to append.
	//
	CHAR*	pchBegin = (CHAR*)(m_pMapFile->pvAddress( &cb )) ;
	CHAR*	pchAppend = pchBegin + m_cbInuse ;

	_ASSERT( (CountNonNulls( pchBegin, m_cbInuse ) + m_cbDeleted) == m_cbInuse ) ;


	//
	//	There should always be room by the time we reach here !
	//
	_ASSERT( (cbGroup + cbData + 3) < m_cbAvailable ) ;
	_ASSERT( cb == m_cbInuse + m_cbAvailable ) ;

#ifdef DEBUG
	_ASSERT( m_pMapFile->UnprotectMapping() );
#endif

	//
	//	copy lpstrGroup in first and add a tab separator.
	//
	CopyMemory( pchAppend, lpstrGroup, cbGroup ) ;
	pchAppend[cbGroup] = '\0' ;

	//
	//	Copy in the data portion and terminate with CRLF
	//
	CopyMemory( pchAppend+cbGroup+1, lpstrData, cbData ) ;
	pchAppend[cbGroup+cbData+1 ] = '\0' ;
	

	m_cbInuse += cbGroup+cbData+3 ;
	m_cbAvailable -= (cbGroup+cbData+3) ;


	//
	//	Let derived class know of new data
	//
	LookupFunction(	pchAppend, 
					cbGroup, 
					pchAppend+cbGroup+1, 
					cbData, 
					lpvContext ) ;

	pchAppend[cbGroup] = '\t' ;
	pchAppend[cbGroup+cbData+1 ] = '\r' ;
	pchAppend[cbGroup+cbData+2 ] = '\n' ;


#ifdef DEBUG
	_ASSERT( m_pMapFile->ProtectMapping() );
#endif

	_ASSERT( cb == m_cbInuse + m_cbAvailable ) ;

	_ASSERT( (CountNonNulls( pchBegin, m_cbInuse ) + m_cbDeleted) == m_cbInuse ) ;

	m_Access.ExclusiveUnlock() ;

	return	TRUE ;
}

BOOL
CAddon::DeleteLine(	
			LPSTR	lpstrLine
			)	{
/*++

Routine Description : 

	Delete a line within the mapping.  We will fill the entry with NULL's.
	We may decide to Compact the image (using CompactImage()) if after the 
	deletion there is a substantial number of NULL's within the file.
	If that is the case, we will rescan the file using ScanImage(), and the 
	derived class's LookupFunction() may be called.

Arguments : 

	lpstrLine - A pointer anywhere into the line that needs to be deleted.
		We will find the beginning of the line and zero the line through to 
		the start of the next line.

Return Value : 

	TRUE if successfull, FALSE otherwise.

--*/

	BOOL	fRtn = TRUE ;

	if( lpstrLine == 0 ) {
		return	TRUE ;
	}

	m_Access.ExclusiveLock() ;

	if( m_pMapFile == 0 ) {
		m_Access.ExclusiveUnlock() ;
		return	FALSE ;
	}

	DWORD	cb = 0 ;
	CHAR*	pchBegin = (CHAR*) m_pMapFile->pvAddress( &cb ) ;

	_ASSERT( (CountNonNulls( pchBegin, m_cbInuse ) + m_cbDeleted) == m_cbInuse ) ;

	//
	//	Validate Arguments - insure that lpstrLine is actually in the 
	//	memory mapping.
	//
	_ASSERT( lpstrLine >= pchBegin && lpstrLine <= (pchBegin + cb) ) ;

	//
	//	Check that the member variables are legit.
	//
	_ASSERT( cb == m_cbInuse + m_cbAvailable ) ;


	//
	//	Find the beginning of the line.
	//
	while( lpstrLine > pchBegin &&
			*lpstrLine != '\n' &&
			*lpstrLine != '\0' ) {
		lpstrLine -- ;
	}

	//
	//	Either we are at the start of the mapping, or at the end 
	//	of the previous line - which may also have been deleted.
	//
	_ASSERT( *lpstrLine == '\n' || *lpstrLine == '\0' || lpstrLine == pchBegin ) ;

	//
	//	Advance if necessary and then zero out the line.
	//
	if( lpstrLine != pchBegin ) {
		lpstrLine ++ ;
	}

#ifdef DEBUG
	_ASSERT( m_pMapFile->UnprotectMapping() );
#endif

	while(	*lpstrLine != '\n' &&
			*lpstrLine != '\0' &&
			m_cbDeleted < m_cbInuse ) {
		*lpstrLine ++ = '\0'; 
		m_cbDeleted ++ ;
	}
	while( m_cbDeleted < m_cbInuse && 
			(*lpstrLine == '\n' ||
			 *lpstrLine == '\r')	)	{
		*lpstrLine ++ = '\0' ;
		m_cbDeleted ++ ;
	}

#ifdef DEBUG
	_ASSERT( m_pMapFile->ProtectMapping() );
#endif

	_ASSERT( (CountNonNulls( pchBegin, m_cbInuse ) + m_cbDeleted) == m_cbInuse ) ;

	//
	//	Make sure we don't go past the end.
	//
	_ASSERT( lpstrLine <= pchBegin + cb ) ;

	//
	//	Check to see if we've emptied the entire file !
	//
	if( m_cbDeleted == m_cbInuse ) {
		m_cbInuse = 0 ;
		m_cbAvailable += m_cbDeleted ;
		m_cbDeleted = 0 ;

	}	else if( m_cbDeleted > 16 * 1024) {

		//
		//	Lots of deleted space - compact it
		//
		CompactImage() ;
		fRtn = ScanImage() ;

	}		

	_ASSERT( (CountNonNulls( pchBegin, m_cbInuse ) + m_cbDeleted) == m_cbInuse ) ;

	m_Access.ExclusiveUnlock() ;
	return	fRtn ;
}

void
CAddon::CompactImage() {
/*++

Routine Description : 

	Remove dead space in the memory mapping.
	Assume that the lock is held exclusively.

Arguments : 

	None.

Return Value : 

	None.


--*/


	//
	//	Notify derived class that we are moving things around.
	//
	ResetAddons() ;

	DWORD	cb = 0 ;
	char*	pchBegin = (char*)m_pMapFile->pvAddress( &cb ) ;

	if( pchBegin == 0 ) {
		return ;
	}
	
	_ASSERT( cb == m_cbAvailable + m_cbInuse ) ;

	char*	pchEnd = pchBegin + m_cbInuse ;
	char*	pchDest = pchBegin ;

#ifdef DEBUG
	_ASSERT( m_pMapFile->UnprotectMapping() );
#endif

	while( pchBegin < pchEnd ) {

		if( *pchBegin != '\0' ) {
			*pchDest = *pchBegin ;
			if( pchBegin > pchDest )	{
				*pchBegin = '\0' ;
			}
			pchDest ++ ;
		}
		pchBegin ++ ;
	}

#ifdef DEBUG
	_ASSERT( m_pMapFile->ProtectMapping() );
#endif

	DWORD	cbDeleted = pchEnd - pchDest ;
	_ASSERT( cbDeleted == m_cbDeleted || m_cbDeleted == 0 ) ;

	m_cbInuse -= cbDeleted ;
	m_cbAvailable += cbDeleted ;
	if( m_cbDeleted != 0 ) 
		m_cbDeleted -= cbDeleted ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\cmap\rw.h ===
#ifndef	_CRW_H
#define	_CRW_H
						
#include	<limits.h>

//
// This class contains the meat - does actual locking etc...
//
class	CShareLock {
private : 
	long	cReadLock ;			// Number of Readers who have passed through the lock OR 
								// the number of readers waiting for the lock (will be negative).
								// A value of 0 means nobody in the lock
	long	cOutRdrs ;			// The number of readers remainin in the lock if 
								// there is a writer waiting.  This can become temporarily negative
	CRITICAL_SECTION	critWriters ; 	// Critical section to allow only one writer into the lock at a time
	HANDLE	hWaitingWriters ;	// Semaphore for waiting writers to block on (Only 1 ever, others will 
								// be queued on critWriters)
	HANDLE	hWaitingReaders ;	// Semaphore for waiting readers to block on 
public : 
	CShareLock( ) ;
	~CShareLock( ) ;

	void	ShareLock( ) ;
	void	ShareUnlock( ) ;
	void	ExclusiveLock( ) ;
	void	ExclusiveUnlock( ) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\cmap\mapfile.h ===
/* -------------------------------------------------------------------------
  mapfile.h
      (was bbmpfile.h)
  	Definitions for the mapped file class.

  Copyright (C) 1995   Microsoft Corporation.
  All Rights Reserved.

  Author
  	Lindsay Harris	- lindsayh

  History
	14:49 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, based on pvMapFile() and derivatives.

   ------------------------------------------------------------------------- */

/*
 *    Generic class to handle mapped files.  Part of the reason for
 *  turning this into a class is to allow tracking of mapping/unmapping
 *  and thus to handle clean up of dangling mappings in exception
 *  handling code.  Tracking is enabled if the fTrack parameter is
 *  specified.
 */

//   Bits used in the m_fFlags field below.
#define	MF_TRACKING		0x0001			// Tracking use of this item.
#define	MF_RELINQUISH	0x0002			// Someone else to free this item.


class  CMapFile
{
public:
	CMapFile( const char *pchFileName, HANDLE & hFile, BOOL fWriteEnable, DWORD cbIncrease = 0);
	CMapFile( const WCHAR *pwchFileName, BOOL fWriteEnable, BOOL fTrack );
	CMapFile( const char *pchFileName, BOOL fWriteEnable, BOOL fTrack, DWORD cbSizeIncrease = 0 );
	CMapFile( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD dwSizeIncrease = 0 );

	~CMapFile( void );

	//   Get the details of this item.
	void	*pvAddress( DWORD *pcb ) { if( pcb ) *pcb = m_cb; return m_pv; };

	//   Relinquish control (meaning someone else unmaps file).
	void	 Relinquish( void )  {  m_fFlags |= MF_RELINQUISH;  };

	//	Tells if mapping is OK.
	BOOL	fGood(void) {return NULL != m_pv; };

private:
	DWORD	 m_cb;			// Size of this file.
	void	*m_pv;			// Address to use.
	DWORD	 m_fFlags;		// See above for the bits used in here.
	WCHAR	 m_rgwchFileName[ MAX_PATH ];		// For error recording.

	void	 MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease );
};


/*
 *    For compatability with old code, the original functions remain.
 */

void *pvMapFile( DWORD *pdwSize, const char  *pchFileName, BOOL bWriteEnable );
void *pvMapFile( DWORD *pdwSize, const WCHAR *pwchFileName, BOOL bWriteEnable );

void *pvMapFile(const char  *pchFileName, BOOL bWriteEnable,
		 DWORD  *pdwSizeFinal = NULL, DWORD dwSizeIncrease = 0);

void * pvFromHandle( HANDLE hFile,	BOOL bWriteEnable,
		DWORD * pdwSizeFinal = NULL, DWORD dwSizeIncrease = 0);

#ifdef DEBUG
//
//	CMapFileEx: version with guard pages to be used only in DEBUG builds
//	to catch other threads writing into our memory !
//

class  CMapFileEx
{
public:
	CMapFileEx( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD dwSizeIncrease = 0 );
	~CMapFileEx( void );

	//   Get the details of this item.
	void	*pvAddress( DWORD *pcb ) { if( pcb ) *pcb = m_cb; return (void*)m_pv; };

	//   Relinquish control (meaning someone else unmaps file).
	void	 Relinquish( void )  {  m_fFlags |= MF_RELINQUISH;  };

	//	Tells if mapping is OK.
	BOOL	fGood(void) {return NULL != m_pv; };

	//	Protect and Unprotect mapping
	BOOL	ProtectMapping();
	BOOL	UnprotectMapping();

private:
	DWORD	 m_cb;								// Size of this file.
	LPBYTE	 m_pv;								// Address to use.
	DWORD	 m_fFlags;							// See above for the bits used in here.
	WCHAR	 m_rgwchFileName[ MAX_PATH ];		// For error recording.

	HANDLE	 m_hFile;							// handle to the mapped file
	LPBYTE	 m_pvFrontGuard;					// front guard page
	DWORD	 m_cbFrontGuardSize;				// front guard page size
	LPBYTE	 m_pvRearGuard;						// rear guard page
	DWORD	 m_cbRearGuardSize;					// rear guard page size
	CRITICAL_SECTION m_csProtectMap;			// crit sect to protect/unprotect mapping

	void	 MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease );
};

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\cmap\main.cpp ===
#include <windows.h>
#include <stdio.h>
#include "rw.h"
#include "mapfile.h"
#include "addon.h"
#include "moderatr.h"

CAddon* g_pModerators;
CNewsGroup g_Newsgroup;

char szFileName  [MAX_PATH];
char szModerator [MAX_PATH];
char szNewsgroup [MAX_PATH];
DWORD cIterations;
DWORD cWriters; 
LONG NumWriters;
DWORD cReaders; 
LONG NumReaders;
DWORD cErasers;
LONG NumErasers;
HANDLE hWriterEv, hReaderEv, hEraserEv;
CRITICAL_SECTION csGroup;

DWORD
WINAPI
WriterThreadFunct( LPVOID lpv );

DWORD
WINAPI
ReaderThreadFunct( LPVOID lpv );

DWORD
WINAPI
EraserThreadFunct( LPVOID lpv );

VOID
WINAPI
ShowUsage (
             VOID
);

VOID
WINAPI
ParseSwitch (
               CHAR chSwitch,
               int *pArgc,
               char **pArgv[]
);

int _CRTAPI1
main (
        int argc,
        char *argv[],
        char *envp[]
)
{

	char chChar, *pchChar;
	INT err;
	DWORD i;

	// defaults
	lstrcpy(szNewsgroup, "foo.bar" );
	cWriters = NumWriters = 0;
	cReaders = NumReaders = 0;
	cErasers = NumErasers = 0;

	while (--argc)
	{
		pchChar = *++argv;
		if (*pchChar == '/' || *pchChar == '-')
		{
			while (chChar = *++pchChar)
			{
				ParseSwitch (chChar, &argc, &argv);
			}
		}
	}


	g_Newsgroup.SetName( szNewsgroup );
	g_pModerators = new CModerator;
	g_pModerators->Init( szFileName );

	DWORD tid;
	HANDLE hWriterThread, hReaderThread, hEraserThread;

	if( cWriters)
		hWriterEv = CreateEvent( NULL, FALSE, FALSE, NULL );

	if( cReaders )
		hReaderEv = CreateEvent( NULL, FALSE, FALSE, NULL );

	if( cErasers )
		hEraserEv = CreateEvent( NULL, FALSE, FALSE, NULL );

	InitializeCriticalSection( &csGroup );

	for(i=0; i<cWriters; i++)
	{
		hWriterThread = CreateThread( 0, 0, WriterThreadFunct, 0, 0, &tid ) ;
		CloseHandle(hWriterThread);
	}

	for(i=0; i<cReaders; i++)
	{
		hReaderThread = CreateThread( 0, 0, ReaderThreadFunct, 0, 0, &tid ) ;
		CloseHandle(hReaderThread);
	}

	for(i=0; i<cErasers; i++)
	{
		hEraserThread = CreateThread( 0, 0, EraserThreadFunct, 0, 0, &tid ) ;
		CloseHandle(hEraserThread);
	}


	if( cWriters)
	{
		printf("Waiting for writers to terminate\n");
		WaitForSingleObject( hWriterEv, INFINITE );
	}

	if( cReaders )
	{
		printf("Waiting for readers to terminate\n");
		WaitForSingleObject( hReaderEv, INFINITE );
	}

	if( cErasers )
	{
		printf("Waiting for erasers to terminate\n");
		WaitForSingleObject( hEraserEv, INFINITE );
	}

	DeleteCriticalSection( &csGroup );

	CloseHandle( hWriterEv );
	CloseHandle( hReaderEv );
	CloseHandle( hEraserEv );

	g_pModerators->Close( TRUE );
	delete g_pModerators;

	return 1;
}


VOID
WINAPI
ShowUsage (
             VOID
)
{
   fputs ("usage: cmap [switches]\n"
	  "               [-?] show this message\n"
	  "               [-f] filename \n"
	  "               [-m] moderator \n"
	  "               [-n] newsgroup \n"
	  "               [-w] num writer thread \n"
	  "               [-r] num reader threads \n"
	  "               [-d] num eraser threads \n"
	  "               [-i] iterations \n"
          ,stderr);

   exit (1);
}


VOID
WINAPI
ParseSwitch (
               CHAR chSwitch,
               int *pArgc,
               char **pArgv[]
)
{
   switch (toupper (chSwitch))
   {

   case '?':
      ShowUsage ();
      break;

   case 'F':
      if (!--(*pArgc))
      {
         ShowUsage ();
      }
      (*pArgv)++;
      strcpy (szFileName, *(*pArgv));
      break;

   case 'M':
      if (!--(*pArgc))
      {
         ShowUsage ();
      }
      (*pArgv)++;
      strcpy (szModerator, *(*pArgv));
      break;

   case 'N':
      if (!--(*pArgc))
      {
         ShowUsage ();
      }
      (*pArgv)++;
      strcpy (szNewsgroup, *(*pArgv));
      break;

   case 'W':
      if (!--(*pArgc))
      {
         ShowUsage ();
      }
      (*pArgv)++;
      cWriters = strtoul (*(*pArgv), NULL, 10);
      break;

   case 'R':
      if (!--(*pArgc))
      {
         ShowUsage ();
      }
      (*pArgv)++;
      cReaders = strtoul (*(*pArgv), NULL, 10);
      break;

   case 'D':
      if (!--(*pArgc))
      {
         ShowUsage ();
      }
      (*pArgv)++;
      cErasers = strtoul (*(*pArgv), NULL, 10);
      break;

   case 'I':
      if (!--(*pArgc))
      {
         ShowUsage ();
      }
      (*pArgv)++;
      cIterations = strtoul (*(*pArgv), NULL, 10);
      break;

   default:
      fprintf (stderr, "cmap: Invalid switch - /%c\n", chSwitch);
      ShowUsage ();
      break;

   }
}

// append lines to the moderator object
DWORD
WINAPI
WriterThreadFunct( LPVOID lpv )
{
	InterlockedIncrement( &NumWriters );

	for(DWORD i=0; i<cIterations; i++)
	{
		EnterCriticalSection( &csGroup );

		AddModeratorInfo(	g_Newsgroup, 
							szModerator,
							lstrlen( szModerator ) 
							) ;

		LeaveCriticalSection( &csGroup );
	}

	InterlockedDecrement( &NumWriters );

	if( NumWriters == 0 ) SetEvent( hWriterEv );

	return 0;
}

// read lines from the moderator object
DWORD
WINAPI
ReaderThreadFunct( LPVOID lpv )
{
	char szMod [MAX_PATH];

	InterlockedIncrement( &NumReaders );

	for(DWORD i=0; i<cIterations; i++)
	{
		EnterCriticalSection( &csGroup );

		DWORD cbModerator = g_Newsgroup.CopyModerator( szMod, sizeof( szMod )-1 ) ;
		szMod[cbModerator++] = '\0' ;

		LeaveCriticalSection( &csGroup );
	}

	InterlockedDecrement( &NumReaders );

	if( NumReaders == 0 ) SetEvent( hReaderEv );

	return 0;
}

// delete lines from the moderator object
DWORD
WINAPI
EraserThreadFunct( LPVOID lpv )
{
	InterlockedIncrement( &NumErasers );

	for(DWORD i=0; i<cIterations; i++)
	{
		EnterCriticalSection( &csGroup );

		DeleteModeratorInfo( g_Newsgroup ) ;

		LeaveCriticalSection( &csGroup );
	}

	InterlockedDecrement( &NumErasers );

	if( NumErasers == 0 ) SetEvent( hEraserEv );

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\cmap\moderatr.cpp ===
#include <windows.h>
#include <stdio.h>
#include "rw.h"
#include "mapfile.h"
#include "addon.h"
#include "moderatr.h"

#ifndef	_ASSERT
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
#endif

extern CNewsGroup g_Newsgroup;

BOOL	
CModerator::LookupFunction(	
			LPSTR	lpstrGroup,
			DWORD	cbGroup, 
			LPSTR	lpstrModeratorData,
			DWORD	cbModeratorData,
			LPVOID	lpvContext
			)	{
/*++

Routine Description : 

	This function searches for the newsgroup found in the 
	moderators file, and if it is found we set the moderator
	of the newsgroup to be the moderator data.

Arguments : 

	lpstrGroup - The Group of this moderator
	cbGroup -	Length of the Group String
	lpstrModeratorData - The Moderator data in the file
	cbModeratorData - length of the moderator data
	lpv - Context Info, this will be NULL during boot 
		but will be a CNewsGroup* during adds/deletes of groups
		during normal operations.

Return Value : 

	TRUE if we found the moderator
	FALSE if we didn't - caller will delete moderator from file.

--*/

	BOOL	fRtn = FALSE ;

	_ASSERT( lpstrGroup != 0 ) ;
	_ASSERT( cbGroup != 0 ) ;
	_ASSERT( lpstrModeratorData != 0 ) ;
	_ASSERT( cbModeratorData != 0 ) ;
	
	if( lpvContext != 0 ) {

		CNewsGroup*	pGroup = (CNewsGroup*)lpvContext ;

		_ASSERT( lstrcmpi( pGroup->GetName(), lpstrGroup ) == 0 ) ;

		pGroup->SetModerator( lpstrModeratorData, cbModeratorData ) ;
	
		fRtn = TRUE ;

	}	else	{
	
		fRtn = FALSE;
	}

	return	fRtn ;
}

void
CModerator::ResetAddons()	{
/*++

Routine Description : 

	This function is called before shuffling data around in the 
	moderator file - which means that all of our pointers from LookupFunction
	calls are going to become invalid.  We will zero them all out.

Arguments : 

	None.

Return Value : 

	None.

--*/

	g_Newsgroup.SetModerator( 0, 0 ) ;
}

extern CAddon* g_pModerators;

DWORD
CNewsGroup::CopyModerator(	
		char*	pchDest,	
		DWORD	cbDest 
		)	{
/*++

Routine Description : 

	This function retrieves the name of the moderator for a newsgroup.
	If there is no moderator, we return 0, otherwise we return the 
	number of bytes copied into the provided buffer.

Arguments : 

	pchDest - Buffer to store moderator name
	cbDest -  Number of bytes in destination buffer

Return Value : 

	0 == No Moderator
	Non zero - number of bytes in moderator name

--*/

	_ASSERT( pchDest != 0 ) ;
	_ASSERT( cbDest > 0 ) ;

	LockModeratorText() ;

	DWORD	cbRtn = 0 ;
	if( cbDest >= m_cbModerator && 
		m_lpstrModerator != 0 ) {

		_ASSERT( m_cbModerator > 0 ) ;

		cbRtn = m_cbModerator ;
		CopyMemory( pchDest, m_lpstrModerator, cbRtn ) ;
	}

	UnlockModeratorText() ;
	
	return cbRtn ;
}

void
CNewsGroup::SetModerator(
		LPSTR	lpstrModerator,
		DWORD	cbModerator
		)	{
/*++

Routine Description : 

	Sets newsgroups moderator's fields.
	ASSUMES CALLER HOLDS NECESSARY LOCKS !!

Arguments : 

	lpstrModerator - moderator string we should use
	cbModerator -	number of bytes in string

Return Value : 

	None.


--*/

	//_ASSERT( lpstrModerator == 0 || 
	//					(strncmp( lpstrModerator - lstrlen( m_lpstrGroup ) - 1, 
	//					m_lpstrGroup, 
	//					lstrlen( m_lpstrGroup ) ) == 0) ) ;
	
	m_lpstrModerator = lpstrModerator ;
	m_cbModerator = cbModerator ;


}

void
LockModeratorText()	{

	g_pModerators->ReadData() ;

}

void
UnlockModeratorText()	{

	g_pModerators->FinishReadData() ;

}

BOOL	
AddModeratorInfo(	
		CNewsGroup&	group,	
		LPSTR	lpstrModerator,	
		DWORD	cbModerator 
		)	{
/*++

Routine Description : 

	This function calls a CModerator object to append 
	a new moderator string to a file.

Arguments : 

	group -		Reference to newsgroup to which the string is being added
	lpstrModerator - Moderator text to be added
	cbModerator - length of the moderator text

Return Value 

	TRUE if successfull, FALSE otherwise.

--*/


	return	g_pModerators->AppendLine(
						group.GetName(),
						lstrlen( group.GetName() ),
						lpstrModerator, 
						cbModerator, 
						(LPVOID)&group 
						) ;
}

BOOL	
DeleteModeratorInfo(	
		CNewsGroup&	group 
		)	{
/*++

Routine Description : 

	This function removes the text of a moderator entry from the 
	moderator file.

Arguments : 

	group -		Newsgroup from which we wish to remove the string

Return Value : 

	TRUE if successfull
	FALSE	otherwise

--*/

	g_pModerators->ExclusiveData() ;

	LPSTR	lpstrData = group.m_lpstrModerator ;
	group.m_lpstrModerator = 0 ;
	group.m_cbModerator =0 ;

	_ASSERT( lpstrData == 0 ||
						(strncmp( lpstrData - lstrlen( group.GetName() ) - 1, 
						group.GetName(), 
						lstrlen( group.GetName() ) ) == 0) ) ;

	g_pModerators->UnlockExclusiveData() ;


	return	g_pModerators->DeleteLine(
							lpstrData
							) ;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\cmap\moderatr.h ===
class   CNewsGroup {
public:
	//
	//	Moderator informatiion
	//
	char*		m_lpstrModerator ;
	char        m_lpstrGroup [128];

	//
	//	Length of moderator text
	//
	DWORD		m_cbModerator ;

	CNewsGroup() { lstrcpy(m_lpstrGroup, "foo.bar"); }
	~CNewsGroup(){}

	//
	//	Copy moderator's name into a buffer - returns number
	//	of bytes copied.
	//	This function will try to grab a lock before copying the
	//	data
	//
	DWORD	CopyModerator(	char*	lpbDestination,	DWORD	cbSize ) ;
	LPSTR	GetName() { return m_lpstrGroup; }
	void    SetName(LPSTR lpName) { lstrcpy(m_lpstrGroup, lpName); }

	//
	//	This function sets the moderator string to point into some data 
	//	somewhere.
	//	Grabs no locks - assumes caller has them.
	//
	void	SetModerator(	char*	lpstrModerator,	DWORD	cbModerator ) ;

};

class	CModerator :	public	CAddon	{
//
//	The CModerator class provides support for saving moderator
//	information into a file that we can append to etc... and 
//	that should be human readable.
//
protected : 

	//
	//	The LookupFunction is called whenever new moderator info
	//	is added to the moderators file, and it lets us modify
	//	the correct CNewsGroup object to reference the moderator data.
	//
	BOOL	LookupFunction(	
						LPSTR	lpstrGroup,
						DWORD	cbGroup, 
						LPSTR	lpstrModeratorData,
						DWORD	cbModeratorData,
						LPVOID	lpv
						) ;

	//
	//	The ResetAddons() function is called whenever we are going to 
	//	move around all the contents in the moderators file - gives
	//	us a chance to go remove all of our references
	//
	void	ResetAddons() ;

public : 

	//
	//	No public functions - these are all provided by our
	//	base class CAddon !
	//

} ;

void
LockModeratorText();

void
UnlockModeratorText();

BOOL	
AddModeratorInfo(	
		CNewsGroup&	group,	
		LPSTR	lpstrModerator,	
		DWORD	cbModerator 
		);

BOOL	
DeleteModeratorInfo(	
		CNewsGroup&	group 
		);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\cmap\mapfile.cpp ===
/* ------------------------------------------------------------------------
  mapfile.cpp
     (was bbmpfile.cpp)
  	A wrapper function to perform the cook book type operations required
  	to map a file into memory.  Maps the whole file, and nothing but the
  	file, so help me God.  Returns a pointer to void;  NULL on error.
  	An error also results in an entry in the event log, unless the error
  	is "file not found" during CreateFile().

  Copyright (C)  1994, 1995  Microsoft Corporation.
  All Rights Reserved.

  Author
  	Lindsay Harris	- lindsayh

   ------------------------------------------------------------------------ */

#include	<windows.h>
#include	"mapfile.h"

#ifndef	_ASSERT
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
#endif

/* ------------------------------------------------------------------------
  CMapFile::CMapFile
  	Constructor for unicode mapping.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:11 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, to support tracking of objects in exception handling.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( const WCHAR *pwchFileName, BOOL fWriteEnable, BOOL fTrack )
{

    HANDLE   hFile;				// Ditto.

	// Set default values corresponding to no mapping happened.
    //
	m_pv = NULL;
	m_cb = 0;
	m_fFlags = 0;			// Until later.

    hFile = CreateFileW( pwchFileName,
                 fWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
           && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
			// Error case
            //
			m_pv = NULL;
    	}
        return;				// Default values are failure.
    }
    wcsncpy( m_rgwchFileName, pwchFileName, MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, 0 );

	BOOL	fClose = CloseHandle( hFile );
	_ASSERT( fClose ) ;

	return;
}


/* ------------------------------------------------------------------------
  CMapFile::CMapFile
  	Constructor for ascii file name version.

  Author
  	Lindsay Harris	- lindsayh

  History:
	16:13 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to handle tracking of objects for exception handling.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( const char *pchFileName, BOOL fWriteEnable, BOOL fTrack, DWORD cbIncrease )
{
    HANDLE   hFile;				// Ditto.

	//    Set default values corresponding to no mapping happened.
	m_pv = NULL;
	m_cb = 0;
	m_fFlags = 0;				// None set yet.

    hFile = CreateFile( pchFileName,
                 fWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
		   && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
			// Error case
            //
			m_pv = NULL;
    	}
        return;
    }

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pchFileName, -1,
												 m_rgwchFileName, MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease );

	BOOL	fClose = CloseHandle( hFile );
	_ASSERT( fClose ) ;

	return;
}


/* ------------------------------------------------------------------------
  CMapFile::CMapFile.
  	Constructor for ascii file name version.

  Note: Creates file handle if necessary. Does not close file handle.

  Author
  	Lindsay Harris	- lindsayh


  History:
	16:13 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to handle tracking of objects for exception handling.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( const char *pchFileName, HANDLE & hFile, BOOL fWriteEnable, DWORD cbIncrease )
{
	// Set default values corresponding to no mapping happened.
    //
	m_pv = NULL;
	m_cb = 0;
	m_fFlags = 0;				// None set yet.

	if ( INVALID_HANDLE_VALUE == hFile )
	{
		hFile = CreateFile( pchFileName,
					 fWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
					 FILE_SHARE_READ, NULL, OPEN_EXISTING,
					 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

		if ( INVALID_HANDLE_VALUE == hFile )
		{
			//  Only legitimate reason for coming here is non-existent file.
            //
			if (  GetLastError() != ERROR_FILE_NOT_FOUND
               && GetLastError() != ERROR_PATH_NOT_FOUND )
			{
				// Error case
                //
				m_pv = NULL;
			}
			return;
		}
	}

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pchFileName, -1,
												 m_rgwchFileName, MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease );

	return;
}

/* ------------------------------------------------------------------------
  CMapFile::CMapFile
  	Constructor when a file handle is available rather than a name.
	Note that it does not closes the handle

  Author
  	Lindsay Harris	- lindsayh

  History
	16:14 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to allow object tracking.  Based on CarlK's function.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD cbIncrease )
{
	m_pv = NULL;
	m_cb = 0;				// Set defaults.
	m_fFlags = 0;			// None set yet.
	wcsncpy( m_rgwchFileName, L"<name unavailable - from handle>", MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease );

	return;
}


/* ------------------------------------------------------------------------
  CMapFile::~CMapFile
  	Destructor.  Two purposes, being to unmap the file, and optionally
  	remove it from the track data.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:22 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	Numero Uno.

   ------------------------------------------------------------------------ */

CMapFile::~CMapFile( void )
{
    //
	// Unmap the file, if we succeeded in mapping it first!
	//

	if ( !(m_fFlags & MF_RELINQUISH) )
	{
		//   We're still controlling this file, so stick with it.
        //
		if ( m_pv )
		{
			UnmapViewOfFile( m_pv );
		}
	}
	return;
}



/* ------------------------------------------------------------------------
  CMapFile::MapFromHandle
  	Does the real work of mapping.  Given a handle to the file, go through
  	the motions of mapping, and recording what happens.  Reports errors
  	as needed.  Also adjusts file size if requested.

  Author
  	Lindsay Harris	- lindsayh
  	Carl Kadie		- carlk

  History
	16:30 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, based on older code with CarlK enhancements.

   ------------------------------------------------------------------------ */

void
CMapFile::MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease )
{

	if ( !fWriteEnable && cbIncrease != 0 )
		return;				// This is non-sensical.

	m_cb = GetFileSize( hFile, NULL );

	DWORD	cbNewSize = 0;

	//
	// Determine if the file is to grow.  Only pass a non-zero size
	// to the system if the size is growing - it's probably faster, and
	// the most likely common case.
	//
	if ( cbIncrease )
	{
		cbNewSize = m_cb += cbIncrease;
	}
	else
	{
		if ( m_cb == 0 )
			return;				// Nothing there.
	}

#if 1
    if ( cbIncrease )
    {
        _ASSERT(fWriteEnable);

        //
        // Make sure the file is the correct size.
        //
        DWORD fpos;
        BOOL  fSetEnd;
        if ( (DWORD)-1 == ( fpos = SetFilePointer( hFile, cbNewSize, NULL, FILE_BEGIN ))
           || !(fSetEnd = SetEndOfFile( hFile ))
           )
        {
            //
            // Error case
            //
            m_pv = NULL;
            return;
        }
    }
#endif

    //
    // Create the mapping object.
    //
	HANDLE hFileMap;				// Intermediate step.

    hFileMap = CreateFileMapping( hFile, NULL,
                                 fWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, cbNewSize, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
		m_pv = NULL;
        return;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    m_pv = MapViewOfFile( hFileMap,
                                 fWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !m_pv )
	{
        // Error case
        //
		m_pv = NULL;
		m_cb = 0;			// Also set to zero, just in case.

	}

    //
    // Now that we have our pointer, we can close the mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose );
	

    return;

}

/* -------------------------------------------------------------------------
  pvMapFile
  	Map a file into memory and return the base address, NULL on failure.

  Author
  	Lindsay Harris	- lindsayh

  History
	14:21 on Mon 20 Feb 1995    -by-    Lindsay Harris   [lindsayh]
  	Amended to use unicode file name.

	10:18 on Tue 29 Nov 1994    -by-    Lindsay Harris   [lindsayh]
  	Made a separately compiled module.

	10:55 on Mon 10 Oct 1994    -by-    Lindsay Harris   [lindsayh]
  	Added FILE_FLAG_SEQUENTIAL_SCAN to speed up directory reading.

	17:38 on Wed 06 Jul 1994    -by-    Lindsay Harris   [lindsayh]
    Make write enable code functional; clean up some old ideas.

    15:35 on Wed 06 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	Adding this comment, written some time back.

   ------------------------------------------------------------------------- */

void *
pvMapFile( DWORD  *pdwSize, const  WCHAR  *pwchFileName, BOOL bWriteEnable )
{
	//
	// Cook book formula.
	//
    VOID    *pvRet;				// Returned to caller
    HANDLE   hFileMap;			// Used during operations, closed before return
    HANDLE   hFile;				// Ditto.


    hFile = CreateFileW( pwchFileName,
                 bWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
           && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
		    // Error case
    	}
        return NULL;
    }

    //
    // If the caller wants to know the size (usually does) then get it now.
    //
    if ( pdwSize )
		*pdwSize = GetFileSize( hFile, NULL );


    //
    // Create the mapping object.
    //
    hFileMap = CreateFileMapping( hFile, NULL,
                                 bWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, 0, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
        BOOL fClose = CloseHandle( hFile );           // No handle leaks.
		_ASSERT( fClose ) ;

        return NULL;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    pvRet = MapViewOfFile( hFileMap,
                                 bWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !pvRet )
	{
		// Error case
        //
	}

    //
    // Now that we have our pointer, we can close the file and the
    // mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose || hFileMap == 0 ) ;
	fClose = CloseHandle( hFile );
	_ASSERT( fClose || hFile == INVALID_HANDLE_VALUE ) ;

    return pvRet;
}

/* -------------------------------------------------------------------------
  pvMapFile
  	Map a file into memory and return the base address, NULL on failure.

  Author
  	Lindsay Harris	- lindsayh

  History
	10:18 on Tue 29 Nov 1994    -by-    Lindsay Harris   [lindsayh]
  	Made a separately compiled module.

	10:55 on Mon 10 Oct 1994    -by-    Lindsay Harris   [lindsayh]
  	Added FILE_FLAG_SEQUENTIAL_SCAN to speed up directory reading.

	17:38 on Wed 06 Jul 1994    -by-    Lindsay Harris   [lindsayh]
    Make write enable code functional; clean up some old ideas.

    15:35 on Wed 06 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	Adding this comment, written some time back.

   ------------------------------------------------------------------------- */

void *
pvMapFile( DWORD  *pdwSize, const  char  *pchFileName, BOOL bWriteEnable )
{
	//
	// Cook book formula.
	//

    VOID    *pvRet;				/* Returned to caller */
    HANDLE   hFileMap;			// Used during operations, closed before return
    HANDLE   hFile;				// Ditto.


    hFile = CreateFile( pchFileName,
                 bWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
           && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
			// Error case
            //
		}
        return NULL;
    }

    //
    // If the caller wants to know the size (usually does) then get it now.
    //
    if ( pdwSize )
		*pdwSize = GetFileSize( hFile, NULL );


    //
    // Create the mapping object.
    //
    hFileMap = CreateFileMapping( hFile, NULL,
                                 bWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, 0, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
        BOOL fClose = CloseHandle( hFile );           // No handle leaks.
		_ASSERT( fClose ) ;

        return NULL;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    pvRet = MapViewOfFile( hFileMap,
                                 bWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !pvRet )
	{
		// Error case
        //
	}

    //
    // Now that we have our pointer, we can close the file and the
    // mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose || hFileMap == 0 ) ;
	fClose = CloseHandle( hFile );
	_ASSERT( fClose || hFile == INVALID_HANDLE_VALUE ) ;

    return  pvRet;

}



/* -------------------------------------------------------------------------
  pvFromHandle
  	Creates a mapped file from an file handle. Does not close that handle.

  History

  	21 Dec 1994 	-by-	Carl Kadie		 [carlk]
	Based on pvMapFile code by Lindsay Harris   [lindsayh]

   ------------------------------------------------------------------------- */

void *
pvFromHandle( HANDLE hFile,
              BOOL bWriteEnable,        // If the file is to be writeable
              DWORD  * pdwSizeFinal,    // If not Null, returns the final size of the file
              DWORD dwSizeIncrease )    // Use 0 if the size is not to increase
{
	DWORD dwSize;
    VOID    *pvRet;				/* Returned to caller */
    HANDLE   hFileMap;


	dwSize = GetFileSize( hFile, NULL ) + dwSizeIncrease;
    if ( pdwSizeFinal )
	{
		*pdwSizeFinal = dwSize;
	}

	// If the ultimate size of the file is 0, then return NULL. The
	// calling program may decide that this is OK.
    //
	if ( !dwSize)
	{
		return NULL;
	}

#if 1
    if ( dwSizeIncrease )
    {
        _ASSERT(bWriteEnable);

        //
        // Make sure the file is the correct size.
        //
        DWORD fpos;
        BOOL  fSetEnd;
        if ( (DWORD)-1 == (fpos = SetFilePointer( hFile, dwSize, NULL, FILE_BEGIN ))
           || !(fSetEnd = SetEndOfFile( hFile ))
           )
        {
            //
            // Error case
            //
            BOOL fClose = CloseHandle( hFile );           // No handle leaks.
            return NULL;
        }
    }
#endif

    //
    // Create the mapping object.
    //								
    hFileMap = CreateFileMapping( hFile, NULL,
                                 bWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, dwSize, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
        BOOL fClose = CloseHandle( hFile );           // No handle leaks.
        return NULL;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    pvRet = MapViewOfFile( hFileMap,
                                 bWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !pvRet )
	{
		//  Log the error,  but continue, which returns the error.
        //
#if 0
		char	rgchErr[ MAX_PATH + 32 ];
		wsprintf( rgchErr, "MapViewOfFile" );
		LogErrorEvent( MSG_GEN_FAIL, rgchErr, "pvFromHandle" );
#endif
	}

    //
    // Now that we have our pointer, we can close the file and the
    // mapping object.
    //

    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose ) ;

	return pvRet;
}

/* -------------------------------------------------------------------------
  pvMapFile
  	Map a file into memory and return the base address, NULL on failure.
	Also, allows the file to be grown.

  History

  	11:08 on Tue 18 Oct 1994	-by-	Carl Kadie		 [carlk]
	Generalize pvMapFile to add support for adding to the file

	10:55 on Mon 10 Oct 1994    -by-    Lindsay Harris   [lindsayh]
  	Added FILE_FLAG_SEQUENTIAL_SCAN to speed up directory reading.

	17:38 on Wed 06 Jul 1994    -by-    Lindsay Harris   [lindsayh]
    Make write enable code functional; clean up some old ideas.

    15:35 on Wed 06 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	Adding this comment, written some time back.

   ------------------------------------------------------------------------- */

void *
pvMapFile(	const char  * pchFileName,		// The name of the file
			BOOL bWriteEnable,		// If the file is to be writeable
 			DWORD  * pdwSizeFinal, // If not Null, returns the final size of the file
			DWORD dwSizeIncrease )     // Use 0 if the size is not to increase
{
	//
	// Cook book formula.
	//
    HANDLE   hFile;
    VOID    *pvRet;				/* Returned to caller */
	
	// If the file is to grow, it only makes sense to open it read/write.
    //
	if (0 != dwSizeIncrease && !bWriteEnable)
	{
		return NULL;
	}

    hFile = CreateFile( pchFileName,
                 bWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_ALWAYS,  //changed from open_existing
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
        return  NULL;
    }

    //
    // If the caller wants to know the size (usually does) then get it now.
    //
	pvRet = pvFromHandle(hFile, bWriteEnable, pdwSizeFinal, dwSizeIncrease);

	BOOL fClose = CloseHandle( hFile );
	_ASSERT( fClose ) ;

    return  pvRet;
}

#ifdef DEBUG
//
//	CMapFileEx: version with guard pages to be used only in DEBUG builds
//	to catch other threads writing into our memory !
//

/* ------------------------------------------------------------------------
  CMapFileEx::CMapFileEx
  	Constructor when a file handle is available rather than a name.
	Note that it does not closes the handle

  Author
  	Lindsay Harris	- lindsayh

  History
	16:14 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to allow object tracking.  Based on CarlK's function.

   ------------------------------------------------------------------------ */

CMapFileEx::CMapFileEx( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD cbIncrease )
{
	m_pv = NULL;
	m_cb = 0;				// Set defaults.
	m_fFlags = 0;			// None set yet.
	m_hFile = INVALID_HANDLE_VALUE;
	m_pvFrontGuard = NULL;
	m_cbFrontGuardSize = 0;
	m_pvRearGuard = NULL;
	m_cbRearGuardSize = 0;
	InitializeCriticalSection(&m_csProtectMap);

	wcsncpy( m_rgwchFileName, L"<name unavailable - from handle>", MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease );

	m_hFile = hFile;

	return;
}


/* ------------------------------------------------------------------------
  CMapFileEx::~CMapFileEx
  	Destructor.  Two purposes, being to unmap the file, and optionally
  	remove it from the track data.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:22 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	Numero Uno.

   ------------------------------------------------------------------------ */

CMapFileEx::~CMapFileEx( void )
{
    //
	// Unmap the file, if we succeeded in mapping it first!
	//

	//   Lock
	EnterCriticalSection(&m_csProtectMap);

	if ( !(m_fFlags & MF_RELINQUISH) )
	{
		//   We're still controlling this file, so stick with it.
        //
		if ( m_pvFrontGuard )
		{
			// get rid of guard pages
			DWORD dwOldProtect = PAGE_READONLY | PAGE_GUARD;
			if(!VirtualProtect(
						(LPVOID)m_pvFrontGuard,
						m_cbFrontGuardSize,
						PAGE_READWRITE,
						&dwOldProtect
						))
			{
				_ASSERT( 1==0 );
				goto CMapFileEx_Exit ;
			}

			if(!VirtualProtect(
						(LPVOID)m_pv,
						m_cb,
						PAGE_READWRITE,
						&dwOldProtect
						))
			{
				_ASSERT( 1==0 );
				goto CMapFileEx_Exit ;
			}

			if(!VirtualProtect(
						(LPVOID)m_pvRearGuard,
						m_cbRearGuardSize,
						PAGE_READWRITE,
						&dwOldProtect
						))
			{
				_ASSERT( 1== 0 );
				goto CMapFileEx_Exit ;
			}

			MoveMemory( m_pvFrontGuard, m_pv, m_cb );

			FlushViewOfFile( m_pvFrontGuard, m_cb ) ;

			UnmapViewOfFile( (LPVOID)m_pvFrontGuard );

			if( INVALID_HANDLE_VALUE != m_hFile )
			{
				if( SetFilePointer( m_hFile, m_cb, NULL, FILE_BEGIN ) == m_cb ) 
				{
					SetEndOfFile( m_hFile ) ;
				}
			}

			m_pvFrontGuard = m_pvRearGuard = m_pv = NULL ;
		}
	}

CMapFileEx_Exit:

	LeaveCriticalSection(&m_csProtectMap);

	DeleteCriticalSection(&m_csProtectMap);

	return;
}



/* ------------------------------------------------------------------------
  CMapFileEx::MapFromHandle
  	Does the real work of mapping.  Given a handle to the file, go through
  	the motions of mapping, and recording what happens.  Reports errors
  	as needed.  Also adjusts file size if requested.

  Author
  	Lindsay Harris	- lindsayh
  	Carl Kadie		- carlk

  History
	16:30 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, based on older code with CarlK enhancements.

   ------------------------------------------------------------------------ */

void
CMapFileEx::MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease )
{

	if ( !fWriteEnable && cbIncrease != 0 )
		return;				// This is non-sensical.

	m_cb = GetFileSize( hFile, NULL );

	DWORD	cbNewSize = 0;

	//
	// Determine if the file is to grow.  Only pass a non-zero size
	// to the system if the size is growing - it's probably faster, and
	// the most likely common case.
	//
	if ( cbIncrease )
	{
		cbNewSize = m_cb += cbIncrease;
	}
	else
	{
		if ( m_cb == 0 )
			return;				// Nothing there.
	}

    if ( cbIncrease )
    {
        _ASSERT(fWriteEnable);

        //
        // Make sure the file is the correct size.
        //
        DWORD fpos;
        BOOL  fSetEnd;
        if ( (DWORD)-1 == ( fpos = SetFilePointer( hFile, cbNewSize, NULL, FILE_BEGIN ))
           || !(fSetEnd = SetEndOfFile( hFile ))
           )
        {
            //
            // Error case
            //
            m_pv = NULL;
            return;
        }
    }

	//
	// Add guard page logic
	//
	SYSTEM_INFO si;
	GetSystemInfo(&si);
	DWORD dwPageSize = si.dwPageSize ;
	DWORD dwGuardPageSize = si.dwAllocationGranularity;

	// GuardPageSize should be > cbNewSize
	while( cbNewSize > dwGuardPageSize )
	{
		dwGuardPageSize += si.dwAllocationGranularity;
	}

	// cbNewSize should be a multiple of dwPageSize, to ensure rear guard page is properly aligned
	_ASSERT( (cbNewSize % dwPageSize) == 0 ) ;

	DWORD cbAllocSize = (2 * (dwGuardPageSize)) + cbNewSize;
	DWORD dwOldProtect = PAGE_READWRITE ;
	DWORD dwError;

    //
    // Create the mapping object.
    //
	HANDLE hFileMap;				// Intermediate step.

    hFileMap = CreateFileMapping( 
							hFile, 
							NULL,
                            fWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                            0, 
							cbAllocSize,	// NOTE: this is greater than cbNewSize by 2*GuardPageSize
							NULL 
							);

    if ( !hFileMap )
    {
		// Error case
        //
		m_pv = NULL;
		m_cb = 0;
        return;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    m_pvFrontGuard = (LPBYTE)MapViewOfFile( 
									hFileMap,
									fWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
									0, 0, 0
									);

	if ( !m_pvFrontGuard )
	{
        // Error case
        //
		m_pv = NULL;
		m_cb = 0;			// Also set to zero, just in case.
		goto MapFromHandle_Exit;
	}

	// front guard page of size (64KB)
	m_cbFrontGuardSize = dwGuardPageSize ;

	// actual memory-mapping
	m_pv = m_pvFrontGuard + m_cbFrontGuardSize ;
	MoveMemory( m_pv, m_pvFrontGuard, cbNewSize );

	// rear guard page of size (64KB)
	m_pvRearGuard  = m_pv + cbNewSize ;
	m_cbRearGuardSize = m_cbFrontGuardSize ;

	// make front page a guard page
	if(!VirtualProtect(
				(LPVOID)m_pvFrontGuard,
				m_cbFrontGuardSize,
				PAGE_READONLY | PAGE_GUARD,
				&dwOldProtect
				))
	{
		m_pv = NULL;
		m_cb = 0;
		goto MapFromHandle_Exit ;
	}

	// make mapping read-only; users of CMapFileEx will need to use the
	// UnprotectMapping() / ProtectMapping() calls to write to this mapping.
	if(!VirtualProtect(
				(LPVOID)m_pv,
				cbNewSize,
				PAGE_READONLY,
				&dwOldProtect
				))
	{
		m_pv = NULL;
		m_cb = 0;
		goto MapFromHandle_Exit ;
	}

	// make rear page a guard page
	if(!VirtualProtect(
				(LPVOID)m_pvRearGuard,
				m_cbRearGuardSize,
				PAGE_READONLY | PAGE_GUARD,
				&dwOldProtect
				))
	{
		m_pv = NULL;
		m_cb = 0;
		goto MapFromHandle_Exit ;
	}


MapFromHandle_Exit:

	dwError = GetLastError();

    //
    // Now that we have our pointer, we can close the mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose );
	

    return;
}

/* ------------------------------------------------------------------------
  CMapFileEx::UnprotectMapping

	Change mapping from READONLY to READWRITE when a write is necessary
	**** NOTE: Calls to UnprotectMapping() and ProtectMapping() should be matched ***
	eg:
		{
			UnprotectMapping();

			//
			//	 code to write to the mapping
			//

			ProtectMapping();
		}

	Returns TRUE on success, FALSE on failure
	Lock is held only if returns TRUE

   ------------------------------------------------------------------------ */

BOOL	
CMapFileEx::UnprotectMapping()
{
	DWORD dwOldProtect = PAGE_READONLY;

	// *** This is released in ProtectMapping() ***
	EnterCriticalSection(&m_csProtectMap);

	// enable writes
	if(!VirtualProtect(
				(LPVOID)m_pv,
				m_cb,
				PAGE_READWRITE,
				&dwOldProtect
				))
	{
		LeaveCriticalSection(&m_csProtectMap);
		return FALSE;
	}

	return TRUE;
}

/* ------------------------------------------------------------------------
  CMapFileEx::UnprotectMapping

	This is called to revert the mapping protection back to READONLY
	**** The thread calling this function should have the protect lock *****

	Returns TRUE on success, FALSE on failure
	Lock is released in either case

   ------------------------------------------------------------------------ */

BOOL	
CMapFileEx::ProtectMapping()
{
	DWORD dwOldProtect = PAGE_READWRITE;
	BOOL  fRet = TRUE;

	// disable writes
	if(!VirtualProtect(
				(LPVOID)m_pv,
				m_cb,
				PAGE_READONLY,
				&dwOldProtect
				))
	{
		fRet = FALSE ;
	}

	LeaveCriticalSection(&m_csProtectMap);
	return fRet;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\cmap\addon.h ===
#ifndef	_ADDON_H_
#define	_ADDON_H_

class	CAddon	{
//
//	This class manages files which contains data with the following format : 
//
//	Name<TAB or SPACE>String with Spaces<CRLF>
//
//	Examples of such files are active.txt files and descript.txt files.
//	In these files the 'Name' is the newsgroup name, and the following
//	character contains strings which CNewsGroup objects will reference.
//	(For instance - descript.txt the extra text is the descriptive string provided
//	in response to the list newsgroups command.
//
//	This base class handles memory mapping the file, and handles insert, 
//	deletion and compaction of the data file.  Insertions are appended to the
//	end, there is no attempt to order the data.  Deletions will just overwrite
//	portions of the file with NULL's.  When we compact, we shift all the data
//	around.
//
//	The function LookupFunction() should be overridden by derived classes
//	so as we parse the file they can learn where the content is.
//	The ReadData() and FinishReadData() must be used before any pointer
//	which points into the memory mapping is used, this ensures that 
//	there are not synchronization problems as we compact or grow the file.
//

protected : 

	//	
	//	Handle to the source file 
	//
	HANDLE		m_hFile ;

	//
	//	Memory mapping of the data file !
	//
#ifdef DEBUG
	CMapFileEx* m_pMapFile ;
#else
	CMapFile*	m_pMapFile ;
#endif

	//
	//	Number of bytes of the file In use - that contain original or appended data.
	//
	DWORD		m_cbInuse ;

	//
	//	Number of bytes that we have overwritten with NULLs due to deletions
	//
	DWORD		m_cbDeleted ;

	//
	//	Number of bytes at the end of the file available for 'stuff'
	//
	DWORD		m_cbAvailable ;

	//
	//	Reader/Writer lock for accessing the data.
	//
	CShareLock	m_Access ;

	//
	//	This function is called for each string in the file - the derived class
	//	should determine whether this string is still needed !
	//	Each line of our data file contains a string followed by a space followed by 
	//	a bunch of text (which may contain spaces).  
	//	The first string will typically be a newsgroup name.  The derived class
	//	should lookup the newsgroup, and set its member pointers to point into our 
	//	data area.  we will notify the derived class if we have to move the data 
	//	around so that the newsgroup pointers can be adjusted.
	//
	virtual		BOOL	LookupFunction( 
							LPSTR	lpstrString, 
							DWORD	cbString, 
							LPSTR	lpstrData, 
							DWORD	cbData,
							LPVOID	lpv ) = 0 ;

	//
	//	This lets the derived class know that all of the data strings are moving around - 
	//	it should delete all of its pointers into our data when this called.
	//	After this is called we will start calling LookupFunction() with the new positions.
	//	This kind of thing happens when we need to grow and shrink our memory mapping.
	//
	virtual		void	ResetAddons() = 0 ;

	//
	//	This function will remove the NULL's that we leave in the data file as we 
	//	remove entries
	//
	void		CompactImage() ;

	//
	//	This function will parse the file and call LookupFunction for each 
	//	entry as we come across it.
	//
	BOOL		ScanImage() ;

public : 

	//
	//	Constructor - set us in an empty state
	//
	CAddon(	) ;

	//
	//	lpstrAddonFile - A file containing newsgroup names followed by space followed by data.
	//	We will get a memory mapping and parse the file, and calll LookupFunction as we 
	//	separate out the distinct newsgroups.
	//	During init we will call LookupFunction with the lpvContext set to NULL.
	//
	BOOL	Init(	
				LPSTR	lpstrAddonFile,	
				BOOL	fCompact = TRUE, 
				DWORD cbGrow = 65536 
				) ;
	
	//
	//	Add a newsgroup and data to the data file.
	//	We may have to muck with the memory mapping, which may result in a call
	//	to ResetAddons().
	//	Once we have completed appending the line, we will call LookupFunction for the newly 
	//	added line, and pass lpvContext through.
	//
	BOOL	AppendLine( 
					LPSTR	lpstrName,	
					DWORD	cbName,	
					LPSTR	lpstrText,	
					DWORD	cbText, 
					LPVOID lpvContext 
					) ;

	//
	//	Remove a line from the file.  We will fill the line in with NULLs.
	//	When we are close'd we will compact the file removing the NULL's, or we may do 
	//	this during an AppendLine() if we figure we'll recover enough space to make it worth while.
	//
	BOOL	DeleteLine(	
					LPSTR	lpstrName
					) ;

	//
	//	Close all of our memory mappings etc...
	//
	BOOL	Close(	
					BOOL	fCompact 
					) ;

	//
	//	Anybody who has stored a pointer as a result of a call to LookupFunction should call 
	//	ReadData() before using that pointer.
	//	This will synchronize all the things that may happen during Append's etc...
	//	(Basically this grabs a Reader/Writer Lock)
	//
	void	ReadData() ;

	//
	//	To be paired with ReadData() - releases locks.
	//
	void	FinishReadData() ;

	//
	//
	//
	void	ExclusiveData() ;

	void	UnlockExclusiveData() ;

} ; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\cmap\rw.cpp ===
//
// This file contains test implmentations of reader and writer locks.
// These are intended to be used with the template class in rw.h so that
// different implementations can be plugged in and tested.
// 
// The semantics of the read/write classes should be as follows : 
//	Functions CAN NOT be recursively called,
//	Multiple Readers should be able to enter the lock 
//	Only a single writer may execute at a time.
//



#include	<windows.h>
#include	<limits.h>
#include	"rw.h"

long	const	BlockValue = (-LONG_MAX) / 2; 
							// Large in magnitude, negative value.  Used to 
							// indicate a waiting writer in cReadLock


CShareLock::CShareLock( ) : cReadLock( 0  ), cOutRdrs( 0 )	{
	InitializeCriticalSection( &critWriters ) ;
	hWaitingWriters = CreateSemaphore( NULL, 0, 1, NULL ) ;
	hWaitingReaders = CreateSemaphore( NULL, 0, LONG_MAX, NULL ) ;
}

CShareLock::~CShareLock( ) {
	CloseHandle( hWaitingWriters ) ;
	CloseHandle( hWaitingReaders ) ;
	DeleteCriticalSection( &critWriters ) ;
}


void
CShareLock::ShareLock( ) {
	long	sign = InterlockedIncrement( &cReadLock ) ;
	if( sign > 0 ) {
		return ;
	}	else 	{
		// There must be a writer in the lock.  Wait for him to leave.
		// The InterlockedIncrement recorded our presence so that the writer
		// can later release the correct number of threads.
		WaitForSingleObject( hWaitingReaders, INFINITE ) ;
	}
}

void
CShareLock::ShareUnlock( ) {
	//
	// Leave the lock.  The return value will be negative if there is a writer
	// waiting.
	BOOL fWriterWaiting = InterlockedDecrement( &cReadLock ) < 0 ;

	if( fWriterWaiting ) {
		//
		// The following increment occurs when there is writer waiting, but
		// readers own the lock.  So although cReadLock is temporarily inaccurate
		// about the number of readers waiting for the lock, it is not inaccurate 
		// when it matters in WriteUnlock (which assumes a writer owns the lock.)
		//
		long junk = InterlockedIncrement( &cReadLock ) ;	// restore the value in cReadLock, so that we
												// end up with an accurate count of readers waiting
												// for entry.  

		long sign = InterlockedDecrement( &cOutRdrs ) ;	// Make sure we don't lose track of the 
												// number for readers who have left the lock.
		//
		// Are we the last reader out of the lock ?
		//
		if( sign == 0 ) {
			//
			// Definately the last reader out !
			//
			ReleaseSemaphore( hWaitingWriters, 1, &junk ) ;
		}
	}
}

void
CShareLock::ExclusiveLock( ) {
	// Only one writer allowed to try for the lock at a time.
	//
	EnterCriticalSection( &critWriters ) ;

	//
	// Need to track the number of readers who leave the lock while we 
	// are trying to grab it.
	//
	cOutRdrs = 0 ;
	// Grab the lock 
 	long	oldsign = InterlockedExchange( &cReadLock, BlockValue ) ;
	// How many readers left while we grabbed the lock ??
	long	oldval = InterlockedExchange( &cOutRdrs, oldsign ) ;

	//
	// Accurately track all the readers who left the lock.
	//
	long	cursign = 1 ;	// Initialize to 1 so that if while loop not executed
							// following if statement works correctly.
	while( oldval++ ) 
		cursign = InterlockedDecrement( &cOutRdrs ) ; 

	//
	// Do we own the lock ?  Only if there were no readers, or they have all left already.
	//
	if( oldsign == 0 || cursign == 0 ) {
		// We have the lock
	}	else	{
		// Wait for a reader to signal us.
		WaitForSingleObject( hWaitingWriters, INFINITE ) ;
	}
}



void
CShareLock::ExclusiveUnlock( ) 	{

	// Estimate how many readers are waiting for the lock
	long	cWaiting = cReadLock - BlockValue ;

	// This Exchange allows any readers who have just arrived to grab the lock.
	// Also, it accounts for cWaiting of the blocked readers.
	long	cNewWaiting = InterlockedExchange( &cReadLock, cWaiting ) - BlockValue ;
	
	// cNewWaiting is the EXACT number of blocked readers - we will increment cReadLock
	// until we have accounted for the difference between our estimate and the correct
	// number !
	long	cTotal = cNewWaiting ;	// Save cNewWaiting for later use
	while( cNewWaiting-- > cWaiting ) 
		InterlockedIncrement( &cReadLock ) ;

	if( cTotal > 0 ) {
		long	junk = 0 ;
		ReleaseSemaphore( hWaitingReaders, cTotal, &junk ) ;	// let all those readers go!
	}
	// Let the next writer take his shot at the lock!
	LeaveCriticalSection( &critWriters ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\inc\sec.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sec.h

Abstract:

    This is header file for security unit tests.

Author:

    Johnson Apacible (JohnsonA)     05-Nov-1995

Revision History:

--*/

#ifndef _SEC_H_
#define _SEC_H_

typedef struct _NEG_BLOCK {

    DWORD Flags;

} NEG_BLOCK, *PNEG_BLOCK;

#define NEG_FLAG_AUTH   0x00000001
#define NEG_FLAG_ACK    0x80000000

#endif // _SEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\delaux\main.cpp ===
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
}

void
_CRTAPI1
main(  int argc,  char * argv[] )
{
    char theFile[MAX_PATH];

    if ( argc != 2 ) {
        printf("usage: delaux <filename>\n");
        return;
    }

    strcpy(theFile,"\\\\?\\");
    strcat(theFile, argv[1]);

    if ( !DeleteFile(theFile) ) {
        if ( !RemoveDirectory(theFile)) {
            printf("error %d deleting %s\n",GetLastError(),theFile);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\drvstrs\stress.cpp ===
#include <windows.h>
#include <propbag.h>
#include <tflist.h>
#include <stdio.h>
#include <crchash.h>
#include <dbgtrace.h>
#include <nntpdrv.h>
#include <nntpfs.h>
#include <nntpfs_i.c>
#include <nntpex.h>
#include <nntpex_i.c>
#include <syncomp.h>
#include <iadmw.h>
#include <tigtypes.h>
#include <nntptype.h>
#include <nntpvr.h>
#include <nntperr.h>



typedef char* LPMULTISZ;
#include <nwstree.h>

#define _ASSERTE( x ) _ASSERT( x )
#include <atlbase.h>

CComModule _Module;
#include <atlcom.h>
#include <atlimpl.cpp>

typedef char * LPMULTISZ;
#include <group.h>

#define MAX_VROOT_COUNT 128
#define MAX_TOKEN_BUFFER    512
#define MAX_ARGS    16
#define MAX_ARG_LEN 512
#define MAX_THREAD_POOL 50
#define MAX_VROOT_TABLE 64

enum OP_CODE {
    INVALID,    // Invalid instruction
    NOOP,       // No operation
    SCRIPTBEGIN,// Beginning of the whole script
    SCRIPTEND,  // End of the whole script
    THREADBEGIN,// It's a thread's begin
    THREADEND,  // It's a thread's end
    CONNECT,    // Connect to a driver
    DISCONNECT, // Disconnect a driver
    MOVE,       // Assigment
    SUB,        // Subtraction
    JUMP,       // Jump to another instruction
    WAIT,       // Wait for other thread's instruction to complete
    NEWGROUP,   // Allocate a news group object
    SLEEP,      // Sleep
    FREEGROUP,  // Free group object in variable bag
    RMGROUP,    // Remove a group, physically
    XOVER,      // Xover
};

enum DRIVER {
    NTFS,       // FS Driver
    EXCHANGE    // Exchange Driver
};

// Global variable bag ( mainly for NntpPropertyBag )
CPropBag g_VariableBag;
CRITICAL_SECTION g_critVarBag;  // for synchronizing access to the variable bag

void StartHintFunction( void )
{}

DWORD INNHash( PBYTE pb, DWORD )
{ return 0; }

VOID
InitGlobalVarBag()
{
    InitializeCriticalSection( &g_critVarBag );
}

VOID
DeInitGlobalVarBag()
{
    DeleteCriticalSection( &g_critVarBag );
}

VOID
LockGlobalVarBag()
{
    EnterCriticalSection( &g_critVarBag );
}

VOID
UnlockGlobalVarBag()
{
    LeaveCriticalSection( &g_critVarBag );
}

VOID
CopyAsciiStringIntoUnicode(
        IN LPWSTR UnicodeString,
        IN LPCSTR AsciiString
        )
{
    while ( (*UnicodeString++ = (WCHAR)*AsciiString++) != (WCHAR)'\0');

} // CopyAsciiStringIntoUnicode

VOID
CopyUnicodeStringIntoAscii(
        IN LPSTR AsciiString,
        IN LPWSTR UnicodeString
        )
{
    while ( (*AsciiString++ = (CHAR)*UnicodeString++) != '\0');

} // CopyUnicodeStringIntoAscii


GET_DEFAULT_DOMAIN_NAME_FN pfnGetDefaultDomainName = NULL;

/*BOOL
GetDefaultDomainName( PCHAR pch, DWORD dw )
{
    return TRUE;
}*/

HANDLE g_hProcessImpersonationToken;

// Get the process Token
HANDLE  GetProcessToken()
{
    HANDLE  hAccToken;
    HANDLE  hImpersonate;
    
    if ( !OpenProcessToken( GetCurrentProcess(),
                            TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY,
                            &hAccToken ) ) {
            return NULL;
    } else {
        // Dup the token to get an impersonation token
        _ASSERT( hAccToken );
        if ( !DuplicateTokenEx(   hAccToken,
                                  0,
                                  NULL,
                                  SecurityImpersonation,
                                  TokenImpersonation,
                                  &hImpersonate ) ) {
           CloseHandle( hAccToken );
           return NULL;
        }
    }

    // Here we have got the right token
    CloseHandle( hAccToken );
    return hImpersonate;
}

class CNntpServer : public INntpServer {
public:

	// Constructor, destructor
	CNntpServer() : m_cRef( 1 ) {}
	~CNntpServer(){}

	LONG GetRef() { return m_cRef; }

	VOID STDMETHODCALLTYPE
	FindPrimaryArticle( INNTPPropertyBag *pPropBag,
						DWORD idArtSecond,
						INNTPPropertyBag **ppPropBag,
						DWORD *pidArtPrimary,
						INntpComplete *pICompletion ) {
		HRESULT hr = S_OK;

		_ASSERT( pPropBag );
		_ASSERT( ppPropBag );

		hr = pPropBag->QueryInterface( IID_INNTPPropertyBag, (void**)ppPropBag );
		*pidArtPrimary = idArtSecond;

		pICompletion->SetResult( hr );
		pICompletion->Release();
	}

	void STDMETHODCALLTYPE
	CreatePostEntries(     char                *pszMessageId,
                               DWORD               iHeaderLength,
                                STOREID             *pStoreId,
                                BYTE                cGroups,
                                INNTPPropertyBag    **rgpGroups,
                                  DWORD               *rgArticleIds,
                                INntpComplete       *pCompletion)
    {}                          
                       

	// IUnknown implementation
	HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
	{
	    if ( iid == IID_IUnknown ) {
	        *ppv = static_cast<INntpServer*>(this);
	    } else if ( iid == IID_INntpServer ) {
	        *ppv = static_cast<INntpServer*>(this);
	    } else {
	        *ppv = NULL;
	        return E_NOINTERFACE;
	    }
	    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	    return S_OK;
	}

	ULONG __stdcall AddRef()
	{
		    return InterlockedIncrement( &m_cRef );
	}

	ULONG __stdcall Release()
	{
	    InterlockedDecrement( &m_cRef );
	    return m_cRef;
	}

private:

	LONG	m_cRef;
};

class CFakeNewsTree : public INewsTree {
public:

	// Constructor, destructor
	CFakeNewsTree() : m_cRef( 1 ) {}
	~CFakeNewsTree(){}

	LONG GetRef() { return m_cRef; }

	// IUnknown implementation
	HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
	{
	    if ( iid == IID_IUnknown ) {
	        *ppv = static_cast<INewsTree*>(this);
	    } else if ( iid == IID_INewsTree ) {
	        *ppv = static_cast<INewsTree*>(this);
	    } else {
	        *ppv = NULL;
	        return E_NOINTERFACE;
	    }
	    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	    return S_OK;
	}

	ULONG __stdcall AddRef()
	{
		    return InterlockedIncrement( &m_cRef );
	}

	ULONG __stdcall Release()
	{
	    InterlockedDecrement( &m_cRef );
	    return m_cRef;
	}

	HRESULT __stdcall FindGroupByID( DWORD dw, INNTPPropertyBag **bag ) {
		return E_NOTIMPL;
	}

	HRESULT __stdcall FindOrCreateGroupByName( LPSTR lpstr, int i, INNTPPropertyBag **bag)
	{ return E_NOTIMPL; }

	HRESULT __stdcall CommitGroup( INNTPPropertyBag *bag ) {
		return E_NOTIMPL;
	}

	HRESULT __stdcall RemoveGroupByID( DWORD ) { return E_NOTIMPL; }

	HRESULT __stdcall RemoveGroupByName( const char** ) { return E_NOTIMPL; }

	HRESULT __stdcall GetIterator( INewsTreeIterator ** piter ) 
	{ return E_NOTIMPL; }

	HRESULT __stdcall LookupVRoot( char* ch, INntpDriver ** pDriver )
	{ return E_NOTIMPL; }

	HRESULT __stdcall GetNntpServer( INntpServer **pserver )
	{ return E_NOTIMPL; }

private:

	LONG	m_cRef;
};

CFakeNewsTree *g_pDummyTree = NULL;
CNNTPVRoot *g_pDummyVroot = NULL;


class CThread;
class CVroot;

CThread *g_rgThreadPool[MAX_THREAD_POOL];
DWORD   g_cThread = 0;
BOOL    g_bVerbal = FALSE;

CVroot *g_rgpVrootTable[MAX_VROOT_TABLE];

IMSAdminBaseW *g_pMB;

CNntpServer *g_pServer = NULL;
CNewsTreeCore *g_pNewsTree = NULL;
CNNTPVRootTable *g_pVRTable = NULL;

class CInstruction {    // in

public:

    // Linked list pointers
    CInstruction *m_pNext;
    CInstruction *m_pPrev;

    CInstruction( OP_CODE OpCode, DWORD dwIndex ) : 
                                     m_OpCode ( OpCode ),
                                     m_dwIndex( dwIndex ),
                                     m_pNext( NULL ),
                                     m_pPrev( NULL ) {}
    ~CInstruction() {}
    OP_CODE GetOpCode() { return m_OpCode; }
    DWORD   GetIndex() { return m_dwIndex; }

    // Interface to pass command parameters out
    virtual BOOL Parse( int argc, char**argv ) = 0;
    virtual BOOL Execute( PVOID pvContext ) = 0;

protected:

    DWORD       m_dwVrootId;    // which vroot the inst is applied to
    
private:

    OP_CODE m_OpCode;       // operation
    DWORD   m_dwIndex;      // instruction index
};
    
class CConnect : public CInstruction {  // cn

public:
    CConnect( OP_CODE opcode, DWORD dwIndex ) : 
        CInstruction( opcode, dwIndex ) {
        *m_szPrefix = 0;
    }
    ~CConnect() {}

    virtual BOOL Parse( int argc, char** argv );
    virtual BOOL Execute( PVOID );

private:

    DRIVER  m_DriverType;   // driver type
    DWORD   m_idVroot;      // vroot id
    CHAR    m_szPrefix[MAX_PATH];   // newsgroup prefix

    CConnect();
};

class CDisconnect : public CInstruction {   // ds

public:
    CDisconnect( OP_CODE opcode, DWORD dwIndex ) :
        CInstruction( opcode, dwIndex ) {}
    ~CDisconnect() {}

    virtual BOOL Parse( int argc, char** argv );
    virtual BOOL Execute( PVOID );

private:

    DWORD   m_idVroot;  // vroot id
};

class CEnd : public CInstruction {  // ed

public:

    CEnd( OP_CODE opcode, DWORD dwIndex ) :
        CInstruction( opcode, dwIndex ) {}
    ~CEnd() {}
    
    virtual BOOL Parse( int argc, char**argv ) { return TRUE; }
    virtual BOOL Execute( PVOID pvContext ) { return TRUE; }
};

class CMove : public CInstruction { //mv

public:
    CMove( OP_CODE opcode, DWORD dwIndex ) :
        CInstruction( opcode, dwIndex ) {}
    ~CMove() {}

    virtual BOOL Parse( int argc, char** argv );
    virtual BOOL Execute( PVOID pvContext );

private:

    DWORD   m_idVar;    // variable id
    DWORD   m_dwVal;    // value
};

class CSubtract : public CInstruction { //sb

public:
    CSubtract( OP_CODE opcode, DWORD dwIndex ) :
        CInstruction( opcode, dwIndex ) {}
    ~CSubtract() {}

    virtual BOOL Parse( int argc, char** argv );
    virtual BOOL Execute( PVOID pvContext );

private:

    DWORD   m_idVar;        // variable id
    DWORD   m_dwOperand;    // subtraction operand
};

class CJump : public CInstruction { // jp

public:
    CJump( OP_CODE opcode, DWORD dwIndex ) :
        CInstruction( opcode, dwIndex ) {}
    ~CJump() {}

    virtual BOOL Parse( int argc, char** argv );
    virtual BOOL Execute( PVOID pvContext );

private:

    DWORD   m_dwInstruction;    // instruction index to jump to
    DWORD   m_idVal;            // control varaible id
};

class CWait : public CInstruction { //wt

public:
    CWait( OP_CODE opcode, DWORD dwIndex ) :
        CInstruction ( opcode, dwIndex ) {}
    ~CWait() {}

    virtual BOOL Parse( int argc, char** argv );
    virtual BOOL Execute( PVOID pvContext );

private:

    DWORD   m_dwThreadId;   // which thread shall I wait for
    DWORD   m_iInst;        // which instruction within that thread shall I wait for
};

class CNewGroup : public CInstruction { //ng

public:
    CNewGroup( OP_CODE opcode, DWORD dwIndex ) :
        CInstruction( opcode, dwIndex ) {}
    ~CNewGroup() {}

    virtual BOOL Parse( int argc, char** argv );
    virtual BOOL Execute( PVOID pvContext );

private:

    BOOL    m_bGlobal;  // Global or local variable
    BOOL    m_bCreatePhysical;  // Do you want me to create physical folder ?
    DWORD   m_idVar;    // Id of variable in variable bag
    CHAR    m_szGroupName[MAX_PATH+1];
};

class CSleep : public CInstruction { // sl

public:
    CSleep( OP_CODE opcode, DWORD dwIndex ) :
        CInstruction( opcode, dwIndex ) {}
    ~CSleep() {}

    virtual BOOL Parse( int argc, char** argv );
    virtual BOOL Execute( PVOID pvContext );

private:

    DWORD m_dwMilliSeconds;
};

class CFreeGroup : public CInstruction {    //fg

public:
    CFreeGroup( OP_CODE opcode, DWORD dwIndex ) :
        CInstruction( opcode, dwIndex ) {}
    ~CFreeGroup() {}

    virtual BOOL Parse( int argc, char**argv );
    virtual BOOL Execute( PVOID pvContext );

private:

    DWORD   m_idVar;
    BOOL    m_bGlobal;
};

class CRmGroup : public CInstruction {  //rg

public:
    CRmGroup( OP_CODE opcode, DWORD dwIndex ) :
        CInstruction( opcode, dwIndex ) {}
    ~CRmGroup() {}

    virtual BOOL Parse( int argc, char** argv );
    virtual BOOL Execute( PVOID pvContext );

private:

    DWORD   m_idVar;
    BOOL    m_bGlobal;
};

class CXover : public CInstruction {    //xv

public:
    CXover( OP_CODE opcode, DWORD dwIndex ) :
        CInstruction( opcode, dwIndex ) {}
    ~CXover() {}

    virtual BOOL Parse( int argc, char** argv );
    virtual BOOL Execute( PVOID pvContext );

private:

    DWORD   m_idVar;
    BOOL    m_bGlobal;
    DWORD   m_dwLow;
    DWORD   m_dwHigh;
    DWORD   m_dwBufSize;
};

class CVroot {  //vr

public:

    CVroot() {
        InitializeCriticalSection( &m_critLock );
        m_lRef = 0;
        m_pDriver = NULL;
        m_DriverType = NTFS;
        m_pNewsTree = new CFakeNewsTree;
        _ASSERT( m_pNewsTree );
        m_pServer = new CNntpServer;
        _ASSERT( m_pServer );
    }
    ~CVroot() {
        DeleteCriticalSection( &m_critLock );
        _ASSERT( NULL == m_pDriver );
        _ASSERT( m_lRef == 0 );
        _VERIFY( m_pNewsTree->Release() == 0 );
        _VERIFY( m_pServer->Release() == 0 );
        delete m_pNewsTree;
        delete m_pServer;
    }
    void Lock() {
        EnterCriticalSection( &m_critLock );
    }
    void Unlock() {
        LeaveCriticalSection( &m_critLock );
    }

    BOOL Connect( DRIVER DriverType, LPSTR szPrefix, CDriverSyncComplete *pComplete );
    BOOL Disconnect();
    BOOL CreateGroup( INNTPPropertyBag *, LPSTR, CDriverSyncComplete * );
    BOOL RemoveGroup( INNTPPropertyBag *, LPSTR, CDriverSyncComplete * );
    BOOL Xover( INNTPPropertyBag *, LPSTR, DWORD, DWORD, DWORD, CDriverSyncComplete * );

    LPSTR GetPrefix() { return m_szPrefix; }

private:

    LONG                m_lRef;         // ref count
    DRIVER              m_DriverType;   // driver type
    CRITICAL_SECTION    m_critLock;     // for synchronization
    INntpDriver         *m_pDriver;     // Driver pointer
    CFakeNewsTree       *m_pNewsTree;   // dummy newstree pointer
    CNntpServer         *m_pServer;     // dummy server pointer
    CHAR                m_szPrefix[MAX_PATH];   // vroot prefix
};

DWORD
VrootTableLookup( LPSTR szGroupName )
{
    for ( int i = 0; i < MAX_VROOT_TABLE; i++ ) {
        if ( strlen( szGroupName ) >= strlen( g_rgpVrootTable[i]->GetPrefix() ) &&
             _strnicmp( szGroupName, g_rgpVrootTable[i]->GetPrefix(), strlen( 
                            g_rgpVrootTable[i]->GetPrefix() ) ) == 0)
            return i;
    }

    return 0xffffffff;
}


class CThread {

public:

    CThread::CThread( DWORD dwThreadId ) :
        m_InstructionList( &CInstruction::m_pPrev, &CInstruction::m_pNext ),
        m_PC( &m_InstructionList ),
        m_dwThreadId( dwThreadId )
        {
            m_hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
            _ASSERT( m_hEvent );
            m_Complete.SetEventHandle( m_hEvent );
        }

    CThread::~CThread() { 
        CInstruction *pInstruction;
        
        CloseHandle( m_hThread );
        CloseHandle( m_hEvent );
        while ( pInstruction = m_InstructionList.PopBack() ) {
            delete pInstruction;
        }

        _ASSERT( m_Complete.GetRef() == 0 );
    }

    void Advance() { m_PC.Next(); }

    void Execute();
    void Jump( DWORD    idInstruction );
    BOOL SetDWord( DWORD dwId, DWORD dwVal );
    BOOL DecDWord( DWORD dwId, DWORD dwVal );
    BOOL GetDWord( DWORD dwId, PDWORD pdwVal );
    BOOL RemoveDWord( DWORD dwId );
    void PushInstruction( CInstruction *pInstruction );
    BOOL Over( DWORD dwInst );
    VOID KickOff();
    VOID Create();
    VOID BlockForCompletion() { WaitForSingleObject( m_hThread, INFINITE ); }
    DWORD GetThreadId() { return m_dwThreadId; }
    CDriverSyncComplete *GetCompletionObject() { return &m_Complete; }

    static DWORD WINAPI 
    ThreadProc(  LPVOID pvContext );
   
private:

    DWORD   m_dwThreadId;   // thread id

    // List of instructions for this thread
    TFList<CInstruction>    m_InstructionList;

    // Program counter
    TFList<CInstruction>::Iterator m_PC;

    // dword variables that this thread owns
    CPropBag    m_VariableBag;  

    // Thread handle
    HANDLE  m_hThread;

    // completion object
    CDriverSyncComplete m_Complete;

    // Event handle
    HANDLE  m_hEvent;
};

class CParser { //ps

public:

    CParser();
    ~CParser();

    BOOL Init( LPSTR szFileName );
    BOOL Parse();

private:

    HANDLE  m_hMap;
    HANDLE  m_hFile;
    LPSTR   m_lpstrContent;
    LPSTR   m_lpstrCursor;
    DWORD   m_dwLine;

    OP_CODE GetNextLine( int& argc, char**argv );
    BOOL GetNextToken( char *pchBuffer );
    OP_CODE Interpret( int argc, LPSTR szCmd );
    void AllocBuffer( char **&argv );
    void DeallocBuffer( char **argv );
    CInstruction *CreateInstruction( OP_CODE, DWORD, int, char ** );
};

CParser::CParser()
{
    m_hMap = INVALID_HANDLE_VALUE;
    m_hFile = INVALID_HANDLE_VALUE;
    m_lpstrContent = NULL;
    m_dwLine = 0;
}


//
// Parse arguments for connect instruction
BOOL
CConnect::Parse( int argc, char**argv )
{
    // argument should be in format of "connect [prefix ] [vroot id] [driver name]"
    // where [vroot id] is an integer and [driver name] is "exchange" or "ntfs"
    // and where [prefix] is the newsgroup prefix name
    _ASSERT( argc == 4 );
    _ASSERT( _stricmp( "connect", argv[0] ) == 0 );

    strcpy( m_szPrefix, argv[1] );
    if ( _stricmp( m_szPrefix, "root" ) == 0 )
        strcpy( m_szPrefix, "" );

    m_idVroot = atol( argv[2] );
    _ASSERT( m_idVroot < MAX_VROOT_COUNT );
    if ( m_idVroot >= MAX_VROOT_COUNT ) return FALSE;

    if ( _stricmp( argv[3], "exchange" ) == 0 ) {
        m_DriverType = EXCHANGE;
    } else if ( _stricmp( argv[3], "ntfs" ) == 0 ) {
        m_DriverType = NTFS;
    } else {
        _ASSERT( 0 );
        return FALSE;
    }

    return TRUE;
}

BOOL
CConnect::Execute( PVOID pvContext )
{
    CThread *pThread = (CThread *)pvContext;

    if ( g_bVerbal ) {
        printf( "[%d]connect %d %d\n", 
                pThread->GetThreadId(),
                m_idVroot, 
                m_DriverType );
    }

    _ASSERT( m_idVroot < MAX_VROOT_TABLE );
    if ( g_rgpVrootTable[m_idVroot]->Connect( m_DriverType, m_szPrefix, pThread->GetCompletionObject()) ) {
        pThread->Advance();
        return TRUE;
    } 

    if ( GetLastError() == HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS ) ) {
        printf( "[%d]Driver already created\n", pThread->GetThreadId() );
        return TRUE;
    }

    return FALSE;
}

BOOL
CDisconnect::Parse( int argc, char**argv )
{
    // argument should be in format of "disconnect [vroot id]"
    // where [vroot id] is an integer
    _ASSERT( argc == 2 );
    _ASSERT( _stricmp( "disconnect", argv[0] ) == 0 );

    m_idVroot = atol( argv[1] );
    _ASSERT( m_idVroot < MAX_VROOT_COUNT );
    if ( m_idVroot >= MAX_VROOT_COUNT ) return FALSE;

    return TRUE;
}

BOOL
CDisconnect::Execute( PVOID pvContext )
{
    CThread *pThread = (CThread *)pvContext;

    if ( g_bVerbal ) {
        printf( "[%d]disconnect %d\n", 
                pThread->GetThreadId(),
                m_idVroot );
    }

    _ASSERT( m_idVroot < MAX_VROOT_TABLE );
    if ( g_rgpVrootTable[m_idVroot]->Disconnect() ) {
        pThread->Advance();
        return TRUE;
    }

    if ( GetLastError() == HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS ) ) {
        printf( "[%d]Driver already released\n", pThread->GetThreadId() );
        return TRUE;
    }
    
    return FALSE;
}

BOOL
CMove::Parse( int argc, char**argv )
{
    // argument should be in format of "move $[n] [m]"
    // where [n] is the variable id and [m] is the value
    _ASSERT( argc == 3 );
    _ASSERT( _stricmp( "move", argv[0] ) == 0 );

    _ASSERT( *argv[1] == '$' );
    if ( '$' != *argv[1] ) return FALSE;

    m_idVar = atol( argv[1] + sizeof( CHAR ) );
    m_dwVal = atol( argv[2] );

    return TRUE;
}

BOOL
CMove::Execute( PVOID pvContext )
{
    _ASSERT( pvContext );
    CThread *pThread = (CThread *)pvContext;

    if ( g_bVerbal ) {
        printf (    "[%d] move $%d %d\n", 
                    pThread->GetThreadId(),
                    m_idVar,
                    m_dwVal );
    }
    
    if ( !pThread->SetDWord( m_idVar, m_dwVal ) ) 
        return FALSE;

    pThread->Advance();

    return TRUE;
}

BOOL
CSubtract::Parse( int argc, char**argv )
{
    // should be in format of "sub $[n] [m]"
    // where [n] is variable id and m is the operand
    _ASSERT( argc == 3 );
    _ASSERT( _stricmp( "sub", argv[0] ) == 0 );

    _ASSERT( *argv[1] == '$' );
    if ( '$' != *argv[1] ) return FALSE;

    m_idVar = atol( argv[1] + sizeof( CHAR ) );
    m_dwOperand = atol( argv[2] );

    return TRUE;
}

BOOL
CSubtract::Execute( PVOID pvContext )
{
    _ASSERT( pvContext );
    CThread *pThread = (CThread *)pvContext;

    if ( g_bVerbal ) {
        printf (    "[%d] sub $%d %d\n",
                    pThread->GetThreadId(),
                    m_idVar,
                    m_dwOperand );
    }
    
    if ( !pThread->DecDWord( m_idVar, m_dwOperand ) )
        return FALSE;

    pThread->Advance();

    return TRUE;
}

BOOL
CJump::Parse( int argc, char**argv )
{
    // should be in the format of "jump [n] [m]"
    // where [n] is the line ( instruction ) number inside
    // this thread and [m] is the control variable id
    _ASSERT( argc == 3 );
    _ASSERT( _stricmp( argv[0], "jump" ) == 0 );

    m_dwInstruction = atol( argv[1] );

    if ( *(argv[2]) != '$' ) {
        printf( "Command \"jump %s %s\" syntax error\n", argv[1], argv[2] );
        return FALSE;
    }
    
    m_idVal = atol( argv[2] + 1  );

    return TRUE;
}

BOOL
CJump::Execute( PVOID pvContext )
{
    CThread *pThread = (CThread *)pvContext;

    DWORD   dwVal;

    if ( g_bVerbal ) {
        printf (    "[%d]jump %d $%d\n",
                    pThread->GetThreadId(),
                    m_dwInstruction,
                    m_idVal );
    }
    
    if ( pThread->GetDWord( m_idVal, &dwVal ) ) {
        if ( dwVal > 0 ) {
            pThread->Jump( m_dwInstruction );
        } else pThread->Advance();

        return TRUE;
    } 

    printf( "[%d]Variable %d in thread %d undefined\n", pThread->GetThreadId(), m_idVal, pThread->GetThreadId() );
    return FALSE;
}

BOOL
CWait::Parse( int argc, char** argv )
{
    // it should be in the format of "wait [n] [m]"
    // where [n] is the thread id and [m] is the instruction No.
    _ASSERT( argc == 3 );
    _ASSERT( _stricmp( argv[0], "wait" ) == 0 );

    m_dwThreadId = atol( argv[1] );
    m_iInst = atol( argv[2] ) ;

    return TRUE;
}

BOOL
CWait::Execute( PVOID pvContext )
{
    _ASSERT( pvContext );
    CThread *pThread = (CThread *)pvContext;
    CThread *pThreadToWait = g_rgThreadPool[m_dwThreadId];

    if ( g_bVerbal ) {
        printf( "[%d]wait %d %d\n",
                pThread->GetThreadId(),
                m_dwThreadId,
                m_iInst );
    }
    
    _ASSERT( pThreadToWait );
    if ( pThreadToWait->Over( m_iInst ) ) 
        pThread->Advance();

    return TRUE;
}

BOOL
CNewGroup::Parse( int argc, char**argv )
{
    // it should be in the format of "newgroup [group name] [$/#]id [create/nocreate]" 
    // where [group name] is the name of the newsgroup to create
    // $id means creating the group object locally, #id means creating the group
    // object globally.  [create/nocreate] tells if we need to create physical folder
    // in the store
    _ASSERT( argc == 4 );
    _ASSERT( _stricmp( argv[0], "newgroup" ) == 0 );

    strcpy( m_szGroupName, argv[1] );
    _ASSERT( strlen( m_szGroupName ) < MAX_PATH );

    if ( *(argv[2]) == '$' ) m_bGlobal = FALSE;
    else if ( *(argv[2]) == '#' ) m_bGlobal = TRUE;
    else _ASSERT( 0 );

    m_idVar = atol( argv[2] + 1 );

    if ( _stricmp( "create", argv[3] ) == 0 ) 
        m_bCreatePhysical = TRUE;
    else if ( _stricmp( "nocreate", argv[3] ) == 0 ) 
        m_bCreatePhysical = FALSE;
    else _ASSERT( 0 );

    return TRUE;
}

BOOL
CNewGroup::Execute( PVOID pvContext )
{
    _ASSERT( pvContext );
    CThread *pThread = (CThread *)pvContext;
    INNTPPropertyBag *pPropBag = NULL;
    CHAR    ch = ( m_bGlobal ?  '#' : '$' );
    CHAR    szBuffer[MAX_PATH+1];
    if ( m_bCreatePhysical ) strcpy( szBuffer, "create" );
    else strcpy( szBuffer, "nocreate" );

    if ( g_bVerbal ) {
        printf( "[%d]newgroup %s %c%d %s\n",
                pThread->GetThreadId(),
                m_szGroupName,
                ch,
                m_idVar,
                szBuffer );
    }

    // Create the group object
    CNewsGroupCore *pGroup = new CNewsGroupCore( g_pNewsTree );
    _ASSERT( pGroup );
    pGroup->Init(   m_szGroupName,
                    m_szGroupName,
                    1,  // fake group id
                    NULL );

    // If asked to create the physical folder, create it
    if ( m_bCreatePhysical ) {
        _ASSERT( pGroup->GetRefCount() == 1 );
        pPropBag = pGroup->GetPropertyBag();
        _ASSERT( pGroup->GetRefCount() == 2 );
        DWORD i = VrootTableLookup( m_szGroupName );
        _ASSERT( i != 0xffffffff );

        if ( !g_rgpVrootTable[i]->CreateGroup( pPropBag, m_szGroupName, pThread->GetCompletionObject() ) ) {
            delete pGroup;
            if ( GetLastError() == HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS ) ||
                    GetLastError() == HRESULT_FROM_WIN32( NNTP_E_DRIVER_NOT_INITIALIZED )) {
                pThread->Advance();
                return TRUE;
            }
            else return FALSE;
        }

        _ASSERT( pGroup->GetRefCount() == 1 );

    }
    
    // Now insert the group object into variable bag
    if ( m_bGlobal ) {
        LockGlobalVarBag();
        g_VariableBag.PutDWord( m_idVar, (DWORD)pGroup );
        UnlockGlobalVarBag();
    } else {
        pThread->SetDWord( m_idVar, (DWORD)pGroup );
    }

    pThread->Advance();
    return TRUE;
}

BOOL
CSleep::Parse( int argc, char **argv )
{
    // it should be of foramt "sleep [n]", 
    // where [n] is time to sleep in terms of milliseconds
    _ASSERT( argc == 2 );
    _ASSERT( _stricmp( "sleep", argv[0] ) == 0 );

    m_dwMilliSeconds = atol( argv[1] );

    return TRUE;
}

BOOL
CSleep::Execute( PVOID pvContext )
{
    _ASSERT( pvContext );
    CThread *pThread = (CThread *)pvContext;
    
    Sleep( m_dwMilliSeconds );
    pThread->Advance();
    return TRUE;
}

BOOL
CFreeGroup::Parse( int argc, char** argv )
{
    // should be in the format of "freegroup $/#[n]"
    // where '$' or '#' tells whether it's global or
    // local variable and [n] is the variable id
    _ASSERT( argc == 2 );
    _ASSERT( _stricmp( "freegroup", argv[0] ) == 0 );

    if ( *argv[1] == '$' ) m_bGlobal = FALSE;
    else if ( *argv[1] == '#' ) m_bGlobal = TRUE;
    else _ASSERT( 0 );
    
    m_idVar = atol( argv[1]+1 );
    return TRUE;
}

BOOL
CFreeGroup::Execute( PVOID pvContext )
{
    _ASSERT( pvContext );
    CThread *pThread = (CThread *)pvContext;

    CNewsGroupCore *pGroup;
    HRESULT     hr = S_OK;
    CHAR        ch = (m_bGlobal? '#' : '$' );

    if ( g_bVerbal ) {
        printf( "[%d]freegroup %c%d\n",
                pThread->GetThreadId(),
                ch,
                m_idVar );
    }

    if ( m_bGlobal ) {
        LockGlobalVarBag();
        hr = g_VariableBag.GetDWord( m_idVar, (PDWORD)&pGroup );
        UnlockGlobalVarBag();
        if ( FAILED( hr ) ) {
            if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) ) {
                printf( "Group #%d does not exist\n", m_idVar );
                pThread->Advance();
                return TRUE;
            }

            SetLastError( hr );
            return FALSE;
        }
        LockGlobalVarBag();
        g_VariableBag.RemoveProperty( m_idVar );
        UnlockGlobalVarBag();
    } else {
        hr = pThread->GetDWord( m_idVar, (PDWORD)&pGroup );
        if ( FAILED( hr ) ) {
            if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) ) {
                printf( "Group #%d does not exist\n", m_idVar );
                pThread->Advance();
                return TRUE;
            }

            SetLastError( hr );
            return FALSE;
        }
        pThread->RemoveDWord( m_idVar );
    }

    delete pGroup;

    pThread->Advance();

    return TRUE;
}

BOOL
CRmGroup::Parse( int argc, char** argv )
{
    // should be in the format of "rmgroup $/#[n]"
    // where '$' or '#' tells whether it's global or
    // local variable and [n] is the variable id
    _ASSERT( argc == 2 );
    _ASSERT( _stricmp( "rmgroup", argv[0] ) == 0 );

    if ( *argv[1] == '$' ) m_bGlobal = FALSE;
    else if ( *argv[1] == '#' ) m_bGlobal = TRUE;
    else _ASSERT( 0 );
    
    m_idVar = atol( argv[1]+1 );
    return TRUE;
}

BOOL
CRmGroup::Execute( PVOID pvContext )
{
    _ASSERT( pvContext );
    CThread *pThread = (CThread*)pvContext;
    CNewsGroupCore *pGroup = NULL;
    INNTPPropertyBag *pPropBag = NULL;
    CHAR    szGroupName[MAX_PATH+1];
    DWORD   dwLen = MAX_PATH;
    HRESULT hr = S_OK;
    CHAR    ch = m_bGlobal ? '#' : '$';

    if ( g_bVerbal ) {
        printf( "[%d]rmgroup %c%d\n",
                pThread->GetThreadId(),
                ch,
                m_idVar );
    }


    // Get the group object
    if ( m_bGlobal ) {
        LockGlobalVarBag();
        hr = g_VariableBag.GetDWord( m_idVar, PDWORD(&pGroup) );
        UnlockGlobalVarBag();
    }
    else hr = pThread->GetDWord( m_idVar, PDWORD(&pGroup) );

    if ( FAILED( hr ) ) {
        if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) ) {
            printf ("Group object %d not defined\n", m_idVar );
            pThread->Advance();
            return TRUE;
        }

        printf( "rm group failed with %x\n", hr );
        return FALSE;
    }

    _ASSERT( pGroup );
    if ( !m_bGlobal ) _ASSERT( pGroup->GetRefCount() == 1 );

    pPropBag = pGroup->GetPropertyBag();

    // get group name and do a vroot table lookup
    hr = pPropBag->GetBLOB( NEWSGRP_PROP_NAME, PBYTE(szGroupName), &dwLen );
    if ( FAILED( hr ) ) {
        printf ( "How come group has no name %x\n", hr);
        _ASSERT( 0 );
        return FALSE;
    }

    DWORD i = VrootTableLookup( szGroupName );
    _ASSERT( i != 0xffffffff );

    if ( !g_rgpVrootTable[i]->RemoveGroup( pPropBag, szGroupName, pThread->GetCompletionObject() ) ) {
        if ( GetLastError() != HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) &&
                GetLastError() != HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) &&
                GetLastError() != HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) &&
                GetLastError() != NNTP_E_DRIVER_NOT_INITIALIZED ) {
            printf( "Remove group %s failed %x\n", szGroupName, GetLastError() );
            return FALSE;
        }
    }

    if ( !m_bGlobal ) _ASSERT( pGroup->GetRefCount() == 1 );
    pThread->Advance();
    return TRUE;
}

BOOL
CXover::Parse( int argc, char** argv )
{
    // It should be in the format of "xover $/#[n] [i] [j] [k]"
    // where $ or # specifies a group variable, i is the low range,
    // j is the high range, k is the buffer size
    _ASSERT( argc == 5 );
    _ASSERT( _stricmp( argv[0], "xover" ) == 0 );

    if ( *argv[1] == '$' ) m_bGlobal = FALSE;
    else if ( *argv[1] == '#' ) m_bGlobal = TRUE;
    else _ASSERT( 0 );

    m_idVar = atol( argv[1] + 1 );
    m_dwLow = atol( argv[2] );
    m_dwHigh = atol( argv[3] );
    _ASSERT( m_dwHigh >= m_dwLow );
    m_dwBufSize = atol( argv[4] );

    return TRUE;
}

BOOL
CXover::Execute( PVOID pvContext )
{
    _ASSERT( pvContext );
    CThread *pThread = (CThread *)pvContext;

    // Get the group object
    HRESULT hr = S_OK;
    CNewsGroupCore *pGroup = NULL;
    INNTPPropertyBag *pPropBag = NULL;
    DWORD   i;
    CHAR    szGroupName[MAX_PATH+1];
    DWORD   dwLen = MAX_PATH;

    if ( m_bGlobal ) {
        LockGlobalVarBag();
        hr = g_VariableBag.GetDWord( m_idVar, (PDWORD)&pGroup );
        UnlockGlobalVarBag();
    } else {
        hr = pThread->GetDWord( m_idVar, (PDWORD)&pGroup );
    }

    if ( FAILED( hr ) ) {
        if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) ) {
            printf( "Group object %d not defined\n", m_idVar );
            pThread->Advance();
            return TRUE;
        }

        printf( "Fatal error when looking for group object %x\n", hr );
        SetLastError( hr );
        return FALSE;
    }

    _ASSERT( pGroup );
    if ( !m_bGlobal ) _ASSERT( pGroup->GetRefCount() == 1 );
    pPropBag = pGroup->GetPropertyBag();

    // Get group name
    hr = pPropBag->GetBLOB( NEWSGRP_PROP_NAME, PBYTE(szGroupName), &dwLen );
    if ( FAILED( hr ) ) {
        printf( "How come a group has no name %x\n", hr );
        pPropBag->Release();
        SetLastError( hr );
        return FALSE;
    }

    _ASSERT( strlen( szGroupName ) <= MAX_PATH );
    i = VrootTableLookup( szGroupName );
    _ASSERT( i != 0xffffffff );

    if ( !g_rgpVrootTable[i]->Xover(    pPropBag, 
                                        szGroupName, 
                                        m_dwLow, 
                                        m_dwHigh, 
                                        m_dwBufSize,
                                        pThread->GetCompletionObject() ) &&
        GetLastError() != HRESULT_FROM_WIN32( NNTP_E_DRIVER_NOT_INITIALIZED )) {

        printf( "Get Xover failed %x\n", GetLastError() );
        return FALSE;
    }

    if ( !m_bGlobal ) _ASSERT( pGroup->GetRefCount() == 1 );
    pThread->Advance();

    return TRUE;
}
    
CParser::~CParser()
{
    if ( m_lpstrContent )
        UnmapViewOfFile( m_lpstrContent );
        
    if ( INVALID_HANDLE_VALUE != m_hMap )
        _VERIFY(CloseHandle( m_hMap ));

    if ( INVALID_HANDLE_VALUE != m_hFile )
        _VERIFY(CloseHandle( m_hFile ) );
}

BOOL
CParser::Init( LPSTR szFileName )
{
    m_hFile = CreateFile(   szFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );
    if ( INVALID_HANDLE_VALUE != m_hFile ) {
        m_hMap = CreateFileMapping( m_hFile,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    0,
                                    NULL );
        if ( INVALID_HANDLE_VALUE != m_hMap ) {
            m_lpstrContent = (char*)MapViewOfFile(  m_hMap,
                                                    FILE_MAP_READ,
                                                    0,0,0);
            if ( m_lpstrContent == NULL ) {
                printf( "MapViewOfFile failed on script file %d\n", GetLastError() ); 
            }
        } else printf ( "CreateFileMapping failed on script file %d\n", GetLastError() );
    } else printf ( "Open script file failed %d\n", GetLastError() );

    m_lpstrCursor = m_lpstrContent;
    return ( NULL != m_lpstrContent );
}

OP_CODE
CParser::GetNextLine( int& argc, char **argv )
{
    _ASSERT( argv );

    char pbBuffer[MAX_TOKEN_BUFFER+1];

    BOOL bMore = TRUE;

    argc = 0;
    bMore = GetNextToken( pbBuffer );

    // skip line number, if it is
    if (  *pbBuffer >= '0' && *pbBuffer <= '9' )
        bMore = GetNextToken( pbBuffer );

    if ( *pbBuffer != 0 )
        strcpy( argv[argc++], pbBuffer );
        
    while ( bMore ) {
        bMore = GetNextToken( pbBuffer );
        if ( *pbBuffer != 0 )
            strcpy( argv[argc++], pbBuffer );
    }

    m_dwLine++;
    return Interpret( argc, argv[0] );
}

OP_CODE
CParser::Interpret( int argc, LPSTR szCmd )
{
    _ASSERT( szCmd );

    if ( argc == 0 ) return NOOP;

    if ( _stricmp( szCmd, "scriptbegin" ) == 0 )
        return SCRIPTBEGIN;
    else if ( _stricmp( szCmd, "scriptend" ) == 0 )
        return SCRIPTEND;
    else if ( _stricmp( szCmd, "threadbegin" ) == 0 )
        return THREADBEGIN;
    else if ( _stricmp( szCmd, "threadend" ) == 0 )
        return THREADEND;
    else if ( _stricmp( szCmd, "connect" ) == 0 )
        return CONNECT;
    else if ( _stricmp( szCmd, "disconnect" ) == 0 )
        return DISCONNECT;
    else if ( _stricmp( szCmd, "move" ) == 0 ) 
        return MOVE;
    else if ( _stricmp( szCmd, "sub" ) == 0 )
        return SUB;
    else if ( _stricmp( szCmd, "jump" ) == 0 )
        return JUMP;
    else if ( _stricmp( szCmd, "wait" ) == 0 )
        return WAIT;
    else if ( _stricmp( szCmd, "sleep" ) == 0 )
        return SLEEP;
    else if ( _stricmp( szCmd, "newgroup" ) == 0 )
        return NEWGROUP;
    else if ( _stricmp( szCmd, "rmgroup" ) == 0 )
        return RMGROUP;
    else if ( _stricmp( szCmd, "freegroup" ) == 0 )
        return FREEGROUP;
    else if ( _stricmp( szCmd, "xover" ) == 0 )
        return XOVER;
    else return INVALID;
}

BOOL
CParser::GetNextToken( LPSTR pbBuffer )
{
    _ASSERT( pbBuffer );
    *pbBuffer = 0;

    while ( *m_lpstrCursor == '\t' ||
            *m_lpstrCursor == ' ' )
        *m_lpstrCursor++;

    LPSTR lpstrOld = m_lpstrCursor;

    while ( *m_lpstrCursor != '\t' && 
            *m_lpstrCursor != ' ' && 
            *m_lpstrCursor != '\r' &&
            *m_lpstrCursor != '\n' &&
            *m_lpstrCursor != 0 )
        m_lpstrCursor++;

    DWORD   dwLen = m_lpstrCursor - lpstrOld;
    _ASSERT( dwLen >= 0 );


    CopyMemory( pbBuffer, lpstrOld, dwLen );
    *(pbBuffer + dwLen ) = 0;

    if (    *m_lpstrCursor == '\r' ) {
        m_lpstrCursor++;
        if ( *m_lpstrCursor == '\n' )
            m_lpstrCursor++;
        return FALSE;
    }

    if ( *m_lpstrCursor == '\n' ) {
        m_lpstrCursor++;
        return FALSE;
    }

    if ( *m_lpstrCursor == 0 )
        return FALSE;

    return TRUE;
}

void
CParser::AllocBuffer( char**& argv )
{
    argv = (char**)new DWORD[MAX_ARGS];
    _ASSERT( argv );

    _ASSERT( argv );
    for ( int j = 0; j < MAX_ARGS; j++ ) {
        argv[j] = new char[MAX_ARG_LEN];
        _ASSERT( argv[j] );
    }
}

void
CParser::DeallocBuffer( char **argv )
{
    for ( int i = 0; i < MAX_ARGS; i++ )
        delete[] argv[i];

    delete[] argv;
}

BOOL
CParser::Parse()
{
    OP_CODE opcode;
    char **argv;
    int argc;
    CThread *pThread = NULL;
    CInstruction *pInstruction = NULL;
    DWORD   iInstruction = 0;

    AllocBuffer( argv );

    opcode = GetNextLine( argc, argv );
    while ( opcode != SCRIPTEND ) {
        if ( INVALID == opcode ) {
            printf( "Line %d has invalid command\n", m_dwLine );
            DeallocBuffer( argv );
            return FALSE;
        }

        // If it's a new thread, I need to create a thread object
        if ( THREADBEGIN == opcode ) {
            _ASSERT( pThread == NULL );
            if ( argc != 2 ) {
                printf( "Line %d thread command needs one argument\n", m_dwLine );
                DeallocBuffer( argv );
                return FALSE;
            }

            if ( g_cThread == MAX_THREAD_POOL ) {
                printf ("Sorry, you can not have more than %d threads\n", MAX_THREAD_POOL );
                DeallocBuffer( argv );
                return FALSE;
            }
            
            pThread = new CThread( atol( argv[1] ) );
            if ( NULL == pThread ) {
                printf( "Create thread object failed on new\n" );
                DeallocBuffer( argv );
                return FALSE;
            }

            iInstruction = 0;
            goto GetNext;
        }

        // If it's noop ( mostly blank lines ), continue
        if ( NOOP == opcode || SCRIPTBEGIN == opcode) {
            goto GetNext;
        }
        
        
        // Now we should create normal instruction objects
        pInstruction = CreateInstruction ( opcode, iInstruction++, argc, argv );
        if ( NULL == pInstruction ) {
            DeallocBuffer( argv );
            return FALSE;
        }

        _ASSERT( pThread );
        pThread->PushInstruction( pInstruction );

        // If it's end of thread, push it to the global thread list and clean the 
        // thread pointer
        if ( THREADEND == opcode ) {
            _ASSERT( pThread );
            g_rgThreadPool[g_cThread++] = pThread;
            pThread = NULL;
        }

GetNext:
        opcode = GetNextLine( argc, argv );
    }

    return TRUE;
}

CInstruction *
CParser::CreateInstruction( OP_CODE opcode, DWORD iInstruction, int argc, char **argv )
{
    _ASSERT( argc > 0 );
    _ASSERT( argv );

    CInstruction *pInstruction = NULL;
  
    switch( opcode ) {

        case CONNECT:
            pInstruction = new CConnect( opcode, iInstruction );
            break;

        case DISCONNECT:
            pInstruction = new CDisconnect( opcode, iInstruction );
            break;

        case SUB:
            pInstruction = new CSubtract( opcode, iInstruction );
            break;

        case JUMP:
            pInstruction = new CJump( opcode, iInstruction );
            break;

        case MOVE:
            pInstruction = new CMove( opcode, iInstruction );
            break;

        case WAIT:
            pInstruction = new CWait( opcode, iInstruction );
            break;

        case NEWGROUP:
            pInstruction = new CNewGroup( opcode, iInstruction );
            break;

        case SLEEP:
            pInstruction = new CSleep( opcode, iInstruction );
            break;

        case RMGROUP:
            pInstruction = new CRmGroup( opcode, iInstruction );
            break;

        case FREEGROUP:
            pInstruction = new CFreeGroup( opcode, iInstruction );
            break;

        case XOVER:
            pInstruction = new CXover( opcode, iInstruction );
            break;
            
        case THREADEND:
            pInstruction = new CEnd( opcode, iInstruction );
            break;
    }

    if ( NULL == pInstruction ) {
        return NULL;
    }
    
    if ( !pInstruction->Parse( argc, argv ) ) {
        delete pInstruction;
        return NULL;
    }

    return pInstruction;
}

//
// Execute instructions that belong to a thread
//
void
CThread::Execute()
{
    OP_CODE opcode;
    CInstruction *pInstruction;

    m_PC.Front();
    pInstruction = m_PC.Current();
    opcode = pInstruction->GetOpCode();
    while ( opcode != THREADEND ) {
        pInstruction->Execute( this ); 
        pInstruction = m_PC.Current();
        opcode = pInstruction->GetOpCode();
    }
}

//
// Jump to another instruction
//
void
CThread::Jump( DWORD    dwInstruction )
{
    // Set iterator to list head
    m_PC.Front();

    for ( int i = 0; i < dwInstruction; i++ ) {
        m_PC.Next();
        _ASSERT( !m_PC.AtEnd() );
    }
}

BOOL
CThread::SetDWord( DWORD dwId, DWORD dwVal )
{
    HRESULT hr = S_OK;
   
    hr = m_VariableBag.PutDWord( dwId, dwVal );
    SetLastError( hr );
    
    return SUCCEEDED( hr );
}

BOOL
CThread::DecDWord( DWORD dwId, DWORD dwVal )
{
    HRESULT hr = S_OK;
 
    DWORD dwOldVal = 0xffffffff;

    hr = m_VariableBag.GetDWord( dwId, &dwOldVal );
    if ( FAILED( hr ) ) {
        SetLastError( hr );
        printf( "Variable %d for thread %d undefined\n", dwId, m_dwThreadId );
        return FALSE;
    }

    _ASSERT( dwOldVal != 0xffffffff );

    dwOldVal -= dwVal;

    hr = m_VariableBag.PutDWord( dwId, dwOldVal );
    SetLastError( hr );

    return SUCCEEDED( hr );
}

BOOL
CThread::GetDWord( DWORD dwId, PDWORD pdwVal )
{
    HRESULT hr = S_OK;

    hr = m_VariableBag.GetDWord( dwId, pdwVal );
    SetLastError( hr );

    return SUCCEEDED( hr );
}

BOOL
CThread::RemoveDWord( DWORD dwId )
{
    HRESULT hr = S_OK;

    hr = m_VariableBag.RemoveProperty( dwId );
    SetLastError( hr );

    return SUCCEEDED( hr );
}

void
CThread::PushInstruction( CInstruction *pInstruction )
{
    _ASSERT( pInstruction );
    m_InstructionList.PushBack( pInstruction );
}

// 
// Test if a thread has done the specified instruction
//
BOOL
CThread::Over( DWORD dwIndex )
{
    CInstruction *pInstruction;
    
    if ( m_PC.AtEnd() ) return TRUE;

    pInstruction = m_PC.Current();

    if ( pInstruction == NULL ) return FALSE;
    else    return ( dwIndex < pInstruction->GetIndex() );
}
 
DWORD WINAPI 
CThread::ThreadProc(  LPVOID pvContext )
{
    _ASSERT( pvContext );
    
    
    // cast context back to thread object
    CThread *pThread = (CThread *)pvContext;

    printf( "[%d]Begins to execute\n", pThread->GetThreadId() );
    pThread->Execute();
    printf( "[%d]Exists\n", pThread->GetThreadId() ); 

    return NO_ERROR;
}

void
CThread::Create()
{
    DWORD   dwThreadId;
    
    // Create a thread
    m_hThread = CreateThread(  NULL,
                               0,
                               ThreadProc,
                               this,
                               CREATE_SUSPENDED,
                               &dwThreadId );
    if ( NULL == m_hThread ) {
        _ASSERT( 0 );
    }
}

void
CThread::KickOff()
{
    ResumeThread( m_hThread );
}

BOOL 
CVroot::Connect( DRIVER DriverType, LPSTR szPrefix, CDriverSyncComplete *pComplete )
{
    HRESULT hr;
    WCHAR   wszMBVroot[MAX_PATH];
    WCHAR   wszPrefix[MAX_PATH];
    INntpDriverPrepare *pPrepare;
    
    Lock();
    if ( m_pDriver ) {
        Unlock();
        SetLastError( HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)  );
        return FALSE;
    }

    _ASSERT( m_lRef == 0 );
    if ( DriverType == NTFS ) {
        hr = CoCreateInstance(  (REFCLSID)CLSID_CNntpFSDriverPrepare,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                (REFIID)IID_INntpDriverPrepare,
                                (void**)&pPrepare );
    }
    else if ( DriverType == EXCHANGE ) {
        hr = CoCreateInstance(  (REFCLSID)CLSID_CNntpExDriverPrepare,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                (REFIID)IID_INntpDriverPrepare,
                                (void**)&pPrepare );
    } else {
        _ASSERT( 0 );
    }

    if ( FAILED( hr ) ) {
        Unlock();
        printf( "CoCreate Driver failed %x\n", hr );
        SetLastError( hr );
        return FALSE;
    }

    CopyAsciiStringIntoUnicode( wszPrefix, szPrefix );
    m_pNewsTree->AddRef();
    _ASSERT( m_pNewsTree->GetRef() == 2 );
    m_pServer->AddRef();
    _ASSERT( m_pServer->GetRef() == 2 );
    pComplete->AddRef();
    pComplete->AddRef();
    _ASSERT( pComplete->GetRef() == 2 );
    swprintf( wszMBVroot, L"/LM/nntpsvc/1/root/%s", wszPrefix );
    g_pMB->AddRef();
    pPrepare->Connect(  wszMBVroot, 
                        szPrefix, 
                        g_pMB, 
                        m_pServer, 
                        m_pNewsTree, 
                        &m_pDriver, 
                        pComplete,
                        g_hProcessImpersonationToken );
    pComplete->WaitForCompletion();
    _ASSERT( pComplete->GetRef() == 0 );
    _ASSERT( m_pNewsTree->GetRef() == 2 );
    _ASSERT( m_pServer->GetRef() == 2 );
    _VERIFY( pPrepare->Release() == 0 );
    
    hr = pComplete->GetResult();
    if ( FAILED( hr ) ) {
        SetLastError( hr );
        return FALSE;
    }

    strcpy( m_szPrefix, szPrefix );
    m_lRef++;
    Unlock();
    return TRUE;
}

BOOL
CVroot::Disconnect()
{
    Lock();
    if ( NULL == m_pDriver ) {
        _ASSERT( m_lRef == 0 );
        Unlock();
        SetLastError( HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS ) );
        return FALSE;
    }

    m_lRef--;
    if ( m_lRef == 0 ) {
        _VERIFY( 0 == m_pDriver->Release() );
        _ASSERT( m_pNewsTree->GetRef() == 1 );
        _ASSERT( m_pServer->GetRef() == 1 );
        m_pDriver = NULL;
    }

    Unlock();
    return TRUE;
}

BOOL
CVroot::CreateGroup( INNTPPropertyBag *pPropBag, LPSTR szGroupName, CDriverSyncComplete *pComplete )
{
    Lock();

    if ( NULL == m_pDriver ||
            strlen( szGroupName ) < strlen( m_szPrefix ) ||
            _strnicmp( szGroupName, m_szPrefix, strlen( m_szPrefix ) ) != 0 ) {
        _ASSERT( m_lRef == 0 );
        pPropBag->Release();
        Unlock();
        SetLastError( HRESULT_FROM_WIN32( NNTP_E_DRIVER_NOT_INITIALIZED ) );
        return FALSE;
    }
    m_lRef++;
    Unlock();

    pComplete->AddRef();
    pComplete->AddRef();
    _ASSERT( pComplete->GetRef() == 2 );
    m_pDriver->CreateGroup( pPropBag, g_hProcessImpersonationToken, pComplete );
    pComplete->WaitForCompletion();
    _ASSERT( pComplete->GetRef() == 0 );

    HRESULT hr = pComplete->GetResult();
    SetLastError( hr );
    InterlockedDecrement( &m_lRef );
    return SUCCEEDED( hr );
}

BOOL
CVroot::RemoveGroup( INNTPPropertyBag *pPropBag, LPSTR szGroupName, CDriverSyncComplete *pComplete )
{
    Lock();

    if ( NULL == m_pDriver ||
            strlen( szGroupName ) < strlen( m_szPrefix ) ||
            _strnicmp( szGroupName, m_szPrefix, strlen( m_szPrefix ) ) != 0 ) {
        _ASSERT( m_lRef == 0 );
        pPropBag->Release();
        Unlock();
        SetLastError( HRESULT_FROM_WIN32( NNTP_E_DRIVER_NOT_INITIALIZED ) );
        return FALSE;
    }
    m_lRef++;
    Unlock();

    pComplete->AddRef();
    pComplete->AddRef();
    _ASSERT( pComplete->GetRef() == 2 );
    m_pDriver->RemoveGroup( pPropBag, g_hProcessImpersonationToken, pComplete );
    pComplete->WaitForCompletion();
    _ASSERT( pComplete->GetRef() == 0 );

    HRESULT hr = pComplete->GetResult();
    SetLastError( hr );
    InterlockedDecrement( &m_lRef );
    return SUCCEEDED( hr );
}

BOOL
CVroot::Xover( INNTPPropertyBag *pPropBag, LPSTR szGroupName, DWORD dwLow, DWORD dwHigh, DWORD dwBufSize, CDriverSyncComplete *pComplete )
{
    Lock();

    if ( NULL == m_pDriver ||
            strlen( szGroupName ) < strlen( m_szPrefix ) ||
            _strnicmp( szGroupName, m_szPrefix, strlen( m_szPrefix ) ) != 0 ) {
        _ASSERT( m_lRef == 0 );
        pPropBag->Release();
        Unlock();
        SetLastError( HRESULT_FROM_WIN32( NNTP_E_DRIVER_NOT_INITIALIZED ) );
        return FALSE;
    }
    m_lRef++;
    Unlock();

    LPSTR   lpstrBuf = new char[dwBufSize+1];
    DWORD   dwAct = dwLow;
    DWORD   dwMin ;
    DWORD   dwSize;
    HRESULT hr = S_OK;

    while ( dwAct <= dwHigh  ) {
        pPropBag->AddRef();
        dwMin = dwAct;
        pComplete->AddRef();
        pComplete->AddRef();
        _ASSERT( pComplete->GetRef() == 2 );
        m_pDriver->GetXover(    pPropBag,
                                dwMin,
                                dwHigh,
                                &dwAct,
                                lpstrBuf,
                                dwBufSize,
                                &dwSize,
                                g_hProcessImpersonationToken,
                                pComplete );
        pComplete->WaitForCompletion();
        _ASSERT( pComplete->GetRef() == 0 );
        hr = pComplete->GetResult();
        if ( hr == S_OK ||
                hr == S_FALSE && dwAct <= dwHigh ) {    // need print
            *(lpstrBuf + dwSize) = 0;
            printf( "%s", lpstrBuf );
        }

        if ( hr == S_OK ) break;

        if ( hr == S_FALSE && dwAct <= dwHigh ||
                hr == HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER )) {   //buffer too small
            if ( hr == HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) ) { // need change buf
                delete[] lpstrBuf;
                dwBufSize *= 2;
                lpstrBuf = new char[dwBufSize + 1];
            }

            continue;
        }

        if ( hr == S_FALSE && dwAct > dwHigh ) break;   // no article in the group
    
        // fatal error
        printf( "Fatal error when xover %x\n", hr );
        SetLastError( hr );
        pPropBag->Release();
        delete[] lpstrBuf;
        InterlockedDecrement( &m_lRef );
        return FALSE;
    }

    pPropBag->Release();
    delete[] lpstrBuf;
    InterlockedDecrement( &m_lRef );
    return TRUE;
}

void InitTreeStuff()
{
    BOOL fFatal;
    
    g_pServer = new CNntpServer();
    _ASSERT( g_pServer );

    g_pNewsTree = new CNewsTreeCore( g_pServer );
    _ASSERT( g_pNewsTree );

    g_pVRTable = new CNNTPVRootTable(   g_pNewsTree->GetINewsTree(),
                                        CNewsTreeCore::VRootRescanCallback );
    _ASSERT( g_pVRTable );

    if ( !g_pNewsTree->Init( g_pVRTable, fFatal, 100, FALSE ) || fFatal ) {
        _ASSERT( 0 );
    }
}

void TermTreeStuff()
{
    delete g_pNewsTree;
    delete g_pVRTable;
    delete g_pServer;
}

int __cdecl main( int argc, char **argv )
{
    CParser parser;
    int i;
    HRESULT hr = S_OK;

    CoInitializeEx ( NULL, COINIT_MULTITHREADED );;
    
    if ( argc != 3 && argc != 2) {
        printf ( "Usage: drvstrs [script file name] [-v]\n" );
        exit( 0 );
    }

    if ( argc == 3 ) g_bVerbal = TRUE;
    else g_bVerbal = FALSE;

    if ( ! parser.Init( argv[1] ) ) {
        printf ( "Parse init failed somehow %d\n", GetLastError() );
        exit( 0 );
    }

    if ( ! parser.Parse() ) {
        printf ( "Parse failed somehow %d\n", GetLastError() );
        exit( 0 );
    }

    for ( i = 0; i < MAX_VROOT_TABLE; i++ ) {
        g_rgpVrootTable[i] = new CVroot;
        _ASSERT( g_rgpVrootTable[i] );
    }

    // Create the metabase object
    hr = CoCreateInstance( CLSID_MSAdminBase, NULL, CLSCTX_ALL,
                            IID_IMSAdminBase, (LPVOID *)&g_pMB );
    if ( FAILED( hr ) ) {
        printf( "Create metabase object failed %x\n", hr );
        goto FreeVroot;
    }

    // Get process htoken
    g_hProcessImpersonationToken = GetProcessToken();
    if ( NULL == g_hProcessImpersonationToken ) {
        printf( "Get system token failed %d\n", GetLastError() );
        goto FreeVroot;
    }

    InitGlobalVarBag();

    InitTreeStuff();

    // start the threads
    for ( i = 0; i < g_cThread; i++ )
        g_rgThreadPool[i]->Create();

    for ( i = 0; i < g_cThread; i++ )
        g_rgThreadPool[i]->KickOff();


    // wait for them to complete
    for ( i = 0; i < g_cThread; i++ ) {
        g_rgThreadPool[i]->BlockForCompletion();
        delete g_rgThreadPool[i];
    }

FreeVroot:
    for ( i = 0; i < MAX_VROOT_TABLE; i++ ) {
        delete g_rgpVrootTable[i];
    }

    TermTreeStuff();

    DeInitGlobalVarBag();
    CoUninitialize();
    
     // OK, done
    printf( "Goodbye\n" );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\hashadd\main.cpp ===
#include "..\..\tigris.hxx"
#include <stdlib.h>

VOID
CleanupMsgFile( );

BOOL
SetupMsgFile(
    VOID
    );

enum filetype {
        artmap,
        histmap
        };

PCHAR filelist[] = {
                "c:\\afile",
                "c:\\hfile"
                };

HANDLE hFile;
HANDLE hMap;
PCHAR Buffer;

CMsgArtMap *AMap;
CHistory *HMap;
CNntpHash *Map;

DWORD groups[12] = { 0xa1,0xa2,0x0,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac };
DWORD blob[15];
DWORD nGroup;

DWORD Items = 100;
enum filetype hashtype=artmap;

CHAR srcmsgid[MAX_PATH];
PCHAR xoverData="\tThis os the best subject ever\tjohnsona@microsofot.com\t<akjhasdkhasdjkhasdkhasdkhsda>\tsss\t123\t321";
DWORD xoverLen;

VOID
addentries()
{

    DWORD entries = 0;
    DWORD target = Items;
    CHAR msgId[512];
    DWORD len;
    PCHAR p;
    DWORD fileSize;
    FILETIME beginTime, endTime;
    DWORD realTime;
    DWORD groupid = 0;
    DWORD artid = (DWORD)-1;

    printf("Adding...\n");

    p=Buffer;
    GetSystemTimeAsFileTime( &beginTime );

    do {

        len = 0;

        //
        // Get head
        //

        while ( *p != '<' ) p++;

        do {

            msgId[len++] = *p;

        } while ( *p++ != '>' );

        msgId[len] = '\0';
        if (len == 2 ) {
            printf("end of file.  Entries %d\n",entries);
            break;
        }

        if ( hashtype == artmap ) {
            if ( !AMap->InsertMapEntry(
                                msgId,
                                0, 
                                0,
                                0x11223344,
                                0x22334455
                                ) ) {
                printf("cannot insert %s\n",msgId);
                continue;
            }
        } else if (hashtype == histmap) {

            if ( !HMap->InsertMapEntry(
                                msgId,
                                &beginTime
                                ) ) {

                printf("cannot insert %s\n",msgId);
                continue;
            }
        }

        entries++;

    } while ( entries < target ) ;

    GetSystemTimeAsFileTime( &endTime );

    endTime.dwLowDateTime -= beginTime.dwLowDateTime;
    realTime = endTime.dwLowDateTime / 10000;
    printf("time is %d ms\n", realTime);
    printf("entries is %d\n",entries);
    if ( realTime != 0 ) {
        printf("entries/sec is %d\n", entries*1000/realTime);
    }
}

void
search()
{

    DWORD entries = 0;
    DWORD target = Items;
    CHAR msgId[512];
    DWORD len;
    PCHAR p;
    FILETIME beginTime, endTime;
    DWORD realTime;
    DWORD groupid = 0;
    DWORD artid = (DWORD)-1;

    printf("Searching...\n");

    p=Buffer;
    GetSystemTimeAsFileTime( &beginTime );
    do {

        len = 0;

        //
        // Get head
        //

        while ( *p != '<' ) p++;

        do {

            msgId[len++] = *p;

        } while ( *p++ != '>' );

        msgId[len] = '\0';
        if ( len == 2 ) {
            printf("end of file.  Entries %d\n",entries);
            break;
        }

        if ( !Map->SearchMapEntry(msgId) ) {
            printf("can't find %s!!!\n",msgId);
        }
        entries++;

    } while ( entries < target ) ;
    GetSystemTimeAsFileTime( &endTime );

    endTime.dwLowDateTime -= beginTime.dwLowDateTime;
    realTime = endTime.dwLowDateTime / 10000;
    printf("time is %d ms\n", realTime);
    printf("entries is %d\n",entries);
    if ( realTime != 0 ) {
        printf("entries/sec is %d\n", entries*1000/realTime);
    }
}

void
usage( )
{
    printf("hashadd\n");
    printf("\t-n <entries>  specify# of entries to add (Def 100)\n");
    printf("\t-d            delete old hash file\n");
    printf("\t-m            msgid file to use (def c:\\msgid)\n");
    printf("\t-h            do history map (def artmap)\n");
    return;
}

int
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    int cur = 1;
    PCHAR x;
    BOOL delOldHash = FALSE;
    BOOL haveMsgFile = FALSE;

    if ( argc == 1 ) {
        usage( );
        return 1;
    }

    while ( cur < argc ) {

        x=argv[cur++];
        if ( *(x++) == '-' ) {

            switch (*x) {
            case 'n':
                if ( cur > argc ) {
                    usage( );
                    return 1;
                }
                Items = atoi(argv[cur++]);
                break;
            case 'h':
                hashtype = histmap;
                break;
            case 'm':
                if ( cur > argc ) {
                    usage( );
                    return 1;
                }
                lstrcpy( srcmsgid, argv[cur++]);
                haveMsgFile = TRUE;
                break;
            case 'd':
                delOldHash = TRUE;
                break;
            default:
                usage( );
                return 1;
            }
        }
    }

    xoverLen = strlen(xoverData)+1;

    if (!haveMsgFile) {
        lstrcpy(srcmsgid,"c:\\msgid");
    }

    printf("Items %d hashfile %s msgfile %s hashtype ",
        Items, filelist[hashtype], srcmsgid);

    if ( hashtype == artmap ) {
        printf("Article Map\n");
        AMap = new CMsgArtMap;
        Map = AMap;
    } else if (hashtype == histmap) {
        printf("History\n");
        HMap = new CHistory;
        Map = HMap;
    }

    if ( Map == NULL ) {
        printf("cannot allocate map object\n");
        return 1;
    }

    if ( delOldHash ) {
        if ( !DeleteFile(filelist[hashtype]) ) {
            if ( GetLastError() != ERROR_FILE_NOT_FOUND ) {
                printf("cannot delete hash file %s. Error %d\n",filelist[hashtype],
                    GetLastError());
            }
        } else {
            printf("Hash file %s deleted\n",filelist[hashtype]);
        }
    }

    InitAsyncTrace( );
    if ( !SetupMsgFile( ) ) {
       goto exit;
    }

    if( hashtype == artmap ) 
        AMap->Initialize( );
    else
        HMap->Initialize( FALSE ) ;
    addentries( );

    search( );
    Map->Shutdown( );

    CleanupMsgFile( );
exit:
    delete Map;
    TermAsyncTrace( );
    return(1);
}

BOOL
SetupMsgFile(
    VOID
    )
{
    printf("Opening %s\n",srcmsgid);
    hFile = CreateFile(
                    srcmsgid,
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        printf("createfile error %d\n",GetLastError());
        return FALSE;
    }

    //
    // Map it
    //

    hMap = CreateFileMapping(
                        hFile,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );

    if ( hMap == NULL ) {
        CloseHandle(hFile);
        printf("mapping error %d\n",GetLastError());
        return FALSE;
    }

    //
    // create a view
    //

    Buffer = (PCHAR)MapViewOfFile(
                        hMap,
                        FILE_MAP_READ,
                        0,
                        0,
                        0
                        );

    if ( Buffer == NULL ) {
        CloseHandle(hMap);
        CloseHandle(hFile);
        printf("view error %d\n",GetLastError());
        return FALSE;
    }
    return(TRUE);
}

VOID
CleanupMsgFile( )
{
    UnmapViewOfFile( Buffer );
    CloseHandle(hMap);
    CloseHandle(hFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\ddroplst\main.cpp ===
#include <stdio.h>
#include <windows.h>
#include "dbgtrace.h"
DWORD __stdcall ComputeDropHash( const  LPCSTR&	lpstrIn );
#include "ddroplst.h"

#define PRINTBOOL(__string__, __func__) printf("%s %s\n", __string__, __func__ ? "true" : "false");

DWORD __stdcall ComputeDropHash( const  LPCSTR&	lpstrIn ) {
	//
	//	Compute a hash value for the newsgroup name
	//
	LPCSTR	lpstr = lpstrIn ;
	DWORD	sum = 0 ;
	while( *lpstr ) {
		sum += *lpstr++ ;
	}
	return	sum ;
}

int __cdecl main(int argc, char **argv) {
	CDDropGroupSet groupset;

	PRINTBOOL("init", groupset.Init(ComputeDropHash));

	PRINTBOOL("add test1", groupset.AddGroup("test1"));
	PRINTBOOL("add test2", groupset.AddGroup("test2"));
	PRINTBOOL("add test1", groupset.AddGroup("test1"));
	PRINTBOOL("is? test1", groupset.IsGroupMember("test1"));
	PRINTBOOL("is? test2", groupset.IsGroupMember("test2"));
	PRINTBOOL("is? test3", groupset.IsGroupMember("test3"));
	PRINTBOOL("del test1", groupset.RemoveGroup("test1"));
	PRINTBOOL("is? test1", groupset.IsGroupMember("test1"));
	PRINTBOOL("is? test2", groupset.IsGroupMember("test2"));
	PRINTBOOL("is? test3", groupset.IsGroupMember("test3"));
	PRINTBOOL("del test2", groupset.RemoveGroup("test2"));
	PRINTBOOL("del test2", groupset.RemoveGroup("test2"));
	PRINTBOOL("is? test1", groupset.IsGroupMember("test1"));
	PRINTBOOL("is? test2", groupset.IsGroupMember("test2"));
	PRINTBOOL("is? test3", groupset.IsGroupMember("test3"));

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\hashme\main.cpp ===
#include "..\..\tigris.hxx"
#include <stdlib.h>

DWORD groups[12] = { 0xa1,0xa2,0x0,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac };
DWORD Iter = 1000;
BOOL Verbose = FALSE;
DWORD nThreads = 1;
HANDLE hTerminate;
LONG activeThreads;

LPCSTR target = "<438b49$ja6@hecate.umd.edu>";
DWORD targetnum = 0;

#define NUM_ENTRIES     100000
#define MAX_MSG_ID      128
#define NUM_LOCKS       32

enum filetype {
        artmap,
        histmap
        };

PCHAR filelist[] = {
                "c:\\afile",
                "c:\\hfile"
                };

typedef struct _entry {

    CHAR MsgId[MAX_MSG_ID];
    BOOL Inserted;
} ENTRY2, *PENTRY2;

CRITICAL_SECTION Locks[NUM_LOCKS];

ENTRY2 table[NUM_ENTRIES];
CMsgArtMap *AMap;
CHistory *HMap;
CNntpHash *Map;

enum filetype hashtype=artmap;
CHAR srcmsgid[MAX_PATH];

BOOL
setuplookup()
{

    DWORD entries = 0;
    HANDLE hFile;
    CHAR msgId[512];
    DWORD len;
    HANDLE hMap;
    PCHAR buffer;
    PCHAR p;

    printf("Creating table...\n");
    hFile = CreateFile(
                    srcmsgid,
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        printf("createfile error %d\n",GetLastError());
        return(FALSE);
    }

    //
    // Map it
    //

    hMap = CreateFileMapping(
                        hFile,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );

    if ( hMap == NULL ) {
        printf("mapping error %d\n",GetLastError());
        return FALSE;
    }

    CloseHandle(hFile);

    //
    // create a view
    //

    buffer = (PCHAR)MapViewOfFile(
                        hMap,
                        FILE_MAP_READ,
                        0,
                        0,
                        0
                        );

    if ( buffer == NULL ) {
        printf("view error %d\n",GetLastError());
        return FALSE;
    }

    p=buffer;

    for (entries=0; entries < NUM_ENTRIES;) {

        len = 0;

        //
        // Get head
        //

        while ( *p != '<' ) p++;

        do {
            msgId[len++] = *p;
        } while ( *p++ != '>' );

        msgId[len] = '\0';

        if (len >= MAX_MSG_ID ) {
            continue;
        }

        CopyMemory(table[entries].MsgId,msgId,len+1);
        if ( strcmp(msgId,target) == 0 ) {
            printf("found %s at %d\n",target,entries);
            targetnum = entries;
        }
        table[entries].Inserted = FALSE;
        if ( Verbose) {
            printf("msg id %s\n",table[entries].MsgId);
        }
        entries++;
    }

    for ( DWORD i=0; i<NUM_LOCKS; i++) {
        InitializeCriticalSection(&Locks[i]);
    }

    UnmapViewOfFile( buffer );
    CloseHandle(hMap);
    return(TRUE);
}

DWORD
WINAPI
ChaCha(
    PVOID Context
    )
{
    DWORD val;
    DWORD i;
    DWORD myNum = (DWORD)Context;
    DWORD nDels = 0;
    DWORD nAdds = 0;
    DWORD lockNum;
    FILETIME beginTime;

    USHORT  HeaderOffsetJunk = 0 ;
    USHORT  HeaderLengthJunk = 0  ;

    printf("Thread %d: Doing %d iterations\n",myNum,Iter);
    GetSystemTimeAsFileTime( &beginTime );

    for (i=0; i<Iter; i++) {

        BOOL fok;
        val = rand( ) % NUM_ENTRIES;
        lockNum = val % NUM_LOCKS;
        EnterCriticalSection(&Locks[lockNum]);

        if ( table[val].Inserted ) {

            if ( val == targetnum ) {
                printf("verifying inserted %d: %s \n",val,table[val].MsgId);
            }

            if (!Map->SearchMapEntry(table[val].MsgId)) {
                printf("!!! cannot find inserted entry %s error %d\n",
                            table[val].MsgId,GetLastError());
                goto cont;
            }

            if ( hashtype == artmap ) {
                fok = AMap->InsertMapEntry(
                            table[val].MsgId,
                            HeaderOffsetJunk,
                            HeaderLengthJunk,
                            i,
                            val
                            );

            } else {

                fok = HMap->InsertMapEntry(
                                table[val].MsgId,
                                &beginTime
                                );
            }

            if (fok) {
                nAdds++;
                printf("Huh!!! inserted already inserted entry %s\n",
                            table[val].MsgId);
                goto cont;
            }

            if ( (i % 2) == 0 ) {

                if ( val == targetnum ) {
                    printf("deleting %d: %s \n",val,table[val].MsgId);
                }
                if (!Map->DeleteMapEntry(
                                table[val].MsgId
                                )) {

                    printf("cannot delete entry %s\n",table[val].MsgId);
                    goto cont;
                } else {
                    if (Map->SearchMapEntry(table[val].MsgId)) {
                        DebugBreak() ;
                        printf(" found deleted entry %s error %d\n",
                                    table[val].MsgId,GetLastError());

                        
                    } else if( GetLastError() != ERROR_FILE_NOT_FOUND ) {
                        DebugBreak() ;
                    } 

                    table[val].Inserted = FALSE;
                    nDels++;
                    if ( Verbose) {
                        printf("deleted %s\n",table[val].MsgId);
                    }
                }
            }

        } else {

            if ( hashtype == artmap ) {
                fok = AMap->InsertMapEntry(
                            table[val].MsgId,
                            HeaderOffsetJunk,
                            HeaderLengthJunk,
                            i,
                            val
                            );

            } else {

                fok = HMap->InsertMapEntry(
                                table[val].MsgId,
                                &beginTime
                                );
            }
            DWORD   dw = GetLastError() ;

            if ( fok ) {
                table[val].Inserted = TRUE;
                nAdds++;
                if ( val == targetnum ) {
                    printf("inserted %d: %s \n",val,table[val].MsgId);
                }
                if ( Verbose) {
                    printf("inserted %s\n",table[val].MsgId);
                }
            } else {
                if( dw != ERROR_ALREADY_EXISTS ) 
                    DebugBreak() ;
                printf("cannot insert %s error %x\n",table[val].MsgId, dw);
            }
        }
cont:
        LeaveCriticalSection( &Locks[lockNum] );
    }

    if ( InterlockedDecrement( &activeThreads ) == 0 ) {
        SetEvent(hTerminate);
    }

    printf("%d: Deletes %d Inserts %d\n",myNum,nDels, nAdds);

    return(1);
}

void
usage( )
{
    printf("hashme\n");
    printf("\t-i <iterations>  # of iterations to run (Def 1000)\n");
    printf("\t-v            verbose mode\n");
    printf("\t-t <threads>  number of threads (def 1)\n");
    printf("\t-m <msgid>    msg id file (def c:\\msgid)\n");
    printf("\t-d            delete old hash file\n");
    printf("\t-h            change type to History (def Artmap)\n");
    return;
}

int
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    int cur = 1;
    PCHAR x;
    BOOL delOldHash = FALSE;
    BOOL haveMsgFile = FALSE;

    if ( argc == 1 ) {
        usage( );
        return 1;
    }

    while ( cur < argc ) {

        x=argv[cur++];
        if ( *(x++) == '-' ) {

            switch (*x) {
            case 'i':
                if ( cur > argc ) {
                    usage( );
                    return 1;
                }
                Iter = atoi(argv[cur++]);
                break;
            case 'v': Verbose = TRUE;
                break;
            case 't':
                if ( cur > argc ) {
                    usage( );
                    return 1;
                }
                nThreads=atoi(argv[cur++]);
                if ( nThreads < 1 ) {
                    nThreads = 1;
                }
                break;
            case 'h':
                hashtype = histmap;
                break;
            case 'm':
                if ( cur > argc ) {
                    usage( );
                    return 1;
                }
                lstrcpy( srcmsgid, argv[cur++]);
                haveMsgFile = TRUE;
                break;
            case 'd':
                delOldHash = TRUE;
                break;
            default:
                usage( );
                return 1;
            }
        }
    }

    lstrcpy( ArticleTableFile, "c:\\afile" ) ;

    if (!haveMsgFile) {
        lstrcpy(srcmsgid,"c:\\msgid");
    }

    printf("Iters %d hashfile %s msgfile %s hashtype ",
        Iter, filelist[hashtype], srcmsgid);

    if ( hashtype == artmap ) {
        printf("Article Map\n");
        AMap = new CMsgArtMap;
        Map = AMap;
    } else {
        printf("History\n");
        HMap = new CHistory;
        Map = HMap;
    }

    if ( Map == NULL ) {
        printf("cannot allocate map object\n");
        return 1;
    }

    if ( delOldHash ) {
        if ( !DeleteFile(filelist[hashtype]) ) {
            printf("cannot delete hash file %s. Error %d\n",filelist[hashtype],
                GetLastError());
        } else {
            printf("Hash file %s deleted\n",filelist[hashtype]);
        }
    }

    printf("Iter %d Threads %d\n",Iter,nThreads);

    InitAsyncTrace( );
    if( hashtype == artmap ) {
        AMap->Initialize( );
    }   else    {
        HMap->Initialize( FALSE ) ;
    }
    if (!setuplookup( )) {
       goto exit;
    }

    hTerminate = CreateEvent( NULL, TRUE, FALSE, NULL );
    if ( hTerminate == NULL ) {
        printf("Error %d on CreateEvent\n",GetLastError());
        goto exit;
    }

    activeThreads = nThreads;

    if ( nThreads > 1 ) {

        HANDLE hThread;
        DWORD threadId;
        DWORD i;

        for (i=1;i<nThreads ;i++ ) {

            hThread = CreateThread(
                        NULL,               // attributes
                        0,                  // stack size
                        ChaCha,             // thread start
                        (PVOID)i,           // param
                        0,                  // creation params
                        &threadId
                        );

            if ( hThread != NULL ) {
                CloseHandle(hThread);
            }
        }
    }

    (VOID)ChaCha( 0 );

    printf("waiting for threads to terminate\n");
    WaitForSingleObject(hTerminate,INFINITE);

exit:
    Map->Shutdown( );
    delete Map;
    TermAsyncTrace( );
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\hashview\main.cpp ===
#include "..\..\tigris.hxx"

enum filetype {
        artmap,
        histmap,
        xmap
        };

PCHAR filelist[] = {
                "c:\\afile",
                "c:\\hfile",
                "c:\\xfile"
                };


int
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE hFile;
    DWORD status;
    DWORD fileSize;
    DWORD nbytes;
    DWORD nPagesUsed;
    PHASH_RESERVED_PAGE head;
    CHAR buffer[HASH_PAGE_SIZE];
    DWORD totalEntries= 0;
    PMAP_PAGE page;
    DWORD i,j;
    DWORD totDel = 0;
    DWORD totIns = 0;
    DWORD nDel,nOk;
    int cur = 1;
    PCHAR x;
    enum filetype hashtype = artmap;

    while ( cur < argc ) {

        x=argv[cur++];
        if ( *(x++) == '-' ) {

            switch (*x) {
            case 'h':
                hashtype = histmap;
                break;
            case 'x':
                hashtype = xmap;
                break;
            }
        }
    }

    printf("Scanning %s\n",filelist[hashtype]);

    hFile = CreateFile(
                   filelist[hashtype],
                   GENERIC_READ,
                   0,
                   NULL,
                   OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                   NULL
                   );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        status = GetLastError();
        goto error;
    }

    //
    // Get the size of the file.  This will tell us how many pages are currently filled.
    //

    fileSize = GetFileSize( hFile, NULL );
    if ( fileSize == 0xffffffff ) {
        status = GetLastError();
        goto error;
    }

    printf("file size %d pages %d\n",fileSize,fileSize/HASH_PAGE_SIZE);

    if (!ReadFile(
                hFile,
                buffer,
                HASH_PAGE_SIZE,
                &nbytes,
                NULL
                ) ) {

        goto error;
    }

    head = (PHASH_RESERVED_PAGE)buffer;

    printf("Header Info\n");
    printf("Signature %x\n",head->Signature);
    if ( head->Initialized ) {
        printf("initialized\n");
    } else {
        printf("not initialized\n");
    }
    printf("Pages %d\n",head->NumPages);
    printf("dir depth %d\n",head->DirDepth);
    printf("Insertions %d\n",head->InsertionCount);
    printf("Deletions %d\n",head->DeletionCount);
    printf("Searches %d\n",head->SearchCount);
    printf("Splits %d\n",head->PageSplits);
    printf("Dir expansions %d\n",head->DirExpansions);
    printf("Table expansions %d\n",head->TableExpansions);
    printf("Duplicate Inserts %d\n",head->DupInserts);

    printf("\n\n");
    nPagesUsed = head->NumPages;

    for (i=1;i<nPagesUsed ;i++ ) {

        SHORT offset;
        nDel = 0;
        nOk = 0;

        if (!ReadFile(
                    hFile,
                    buffer,
                    HASH_PAGE_SIZE,
                    &nbytes,
                    NULL
                    ) ) {

            goto error;
        }

        page = (PMAP_PAGE)buffer;
        printf("Page %d information\n",i);
        printf("Hash prefix %x  Depth %d\n",page->HashPrefix,page->PageDepth);
        printf("Entries %d\n",page->EntryCount);
        printf("Undel Entries %d\n",page->ActualCount);
        printf("Flag %x \n",page->Flags);
        //printf("Next free %x  Last Free %x\n",page->NextFree,page->LastFree);
        printf("Bytes Available %d\n", page->LastFree-page->NextFree);
        if ( page->FragmentedBytes != 0 ) {
            printf("Fragmented bytes %d\n", page->FragmentedBytes);
        }
        totalEntries += page->EntryCount;

        //
        // Make sure entries are correct
        //

        __try {

        for (j=0; j<MAX_LEAF_ENTRIES;j++ ) {

            offset = page->ArtOffset[j];
            if ( offset != 0 ) {

                if ( offset < 0 ) {

                    nDel++;

                } else {

                    nOk++;
                    if ( hashtype == artmap ) {

                        PART_MAP_ENTRY aEntry;
                        aEntry = (PART_MAP_ENTRY)((PCHAR)page + offset);
                        if ( (page->PageDepth > 0) &&
                            (page->HashPrefix !=
                            (aEntry->Header.HashValue >> (32 - page->PageDepth))) ) {

                            printf("invalid: HashValue %x %x\n",
                                aEntry->Header.HashValue);
                        }
                    } else if ( hashtype == histmap) {

                        PHISTORY_MAP_ENTRY hEntry;
                        hEntry = (PHISTORY_MAP_ENTRY)((PCHAR)page + offset);
                        if ( (page->PageDepth > 0) &&
                             (page->HashPrefix !=
                            (hEntry->Header.HashValue >> (32 - page->PageDepth))) ) {

                            printf("invalid: HashValue %x\n",
                            hEntry->Header.HashValue);
                        }

                    } else {

                        PXOVER_MAP_ENTRY hEntry;
                        hEntry = (PXOVER_MAP_ENTRY)((PCHAR)page + offset);
                        if ( (page->PageDepth > 0) &&
                            (page->HashPrefix !=
                            (hEntry->Header.HashValue >> (32 - page->PageDepth))) ) {

                            printf("invalid: HashValue %x\n",
                            hEntry->Header.HashValue);
                        }
                    }
                }
            }
        }

        if ( nDel + nOk != page->EntryCount ) {
            printf("!!!!!!! counts don't match\n");
        }

        printf("Deleted %d Ok %d Total %d\n\n",nDel,nOk,nDel+nOk);
        totDel += nDel;
        totIns += nOk;

        } __except( 1 ) {
            printf("Hash file corrupted!!!\n");
        }
    }

    printf("Dels %d Ins %d total entries %d\n",totDel,totIns,totalEntries);
    CloseHandle(hFile);
    return 1;

error:

    if ( hFile != INVALID_HANDLE_VALUE ) {
        CloseHandle( hFile );
        hFile = INVALID_HANDLE_VALUE;
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\memtest\memtest.cpp ===
#include "tigris.hxx"

//
// Memory unit test
//

int
__cdecl main(
			int argc,
			char *argv[ ]
	)
{
	const DWORD cchMaxPrivateBytesCAlloc = 200;
	char rgchBuffer[cchMaxPrivateBytesCAlloc];
	const DWORD cchSmall = 10;

	CAllocator allocator(rgchBuffer, cchMaxPrivateBytesCAlloc);

	// Alloc from buffer

	char * rgbuff = (char *) allocator.Alloc(cchSmall);
	printf("There are %d allocations outstanding\n", allocator.cNumberOfAllocs());
	wsprintf(rgbuff, "123456789");

	allocator.Free(rgbuff);
	
	printf("There are %d allocations outstanding\n", allocator.cNumberOfAllocs());

	// Alloc using "new"

	rgbuff = (char *) allocator.Alloc(cchMaxPrivateBytesCAlloc);
	printf("There are %d allocations outstanding\n", allocator.cNumberOfAllocs());
	wsprintf(rgbuff, "123456789");

	// Alloc using the rest of the buffer
	char * rgbuff2 = (char *) allocator.Alloc(cchMaxPrivateBytesCAlloc - cchSmall);
	printf("There are %d allocations outstanding\n", allocator.cNumberOfAllocs());
	wsprintf(rgbuff2, "123456789");

	allocator.Free(rgbuff);
	printf("There are %d allocations outstanding\n", allocator.cNumberOfAllocs());

	allocator.Free(rgbuff2);
	printf("There are %d allocations outstanding\n", allocator.cNumberOfAllocs());

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\instssl\main.cpp ===
extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <ntsam.h>
#include <ntlsa.h>

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winsock.h>
#include "..\..\nntpcons.h"
}

NTSTATUS
ReadBinaryData(
        LPCSTR Filename,
        LPBYTE Buffer,
        PDWORD bufLen
        );

#define MAX_JUNK    4096




//
//  We have to squirt a record into the decoded stream
//

#define CERT_RECORD            13
#define CERT_SIZE_HIBYTE        2       //  Index into record of record size
#define CERT_SIZE_LOBYTE        3

unsigned char abCertHeader[] = {0x30, 0x82,           // Record
                                0x00, 0x00,           // Size of cert + buff
                                0x04, 0x0b, 0x63, 0x65,// Cert record data
                                0x72, 0x74, 0x69, 0x66,
                                0x69, 0x63, 0x61, 0x74,
                                0x65 };

const int pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};


VOID uudecode_cert(char   * bufcoded,
                   DWORD  * pcbDecoded )
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout = (LPBYTE)bufcoded;
    unsigned char *pbuf;
    int nprbytes;
    char * beginbuf = bufcoded;

    /* Strip leading whitespace. */

    while(*bufcoded==' ' ||
          *bufcoded == '\t' ||
          *bufcoded == '\r' ||
          *bufcoded == '\n' )
    {
          bufcoded++;
    }

    //
    //  If there is a beginning '---- ....' then skip the first line
    //

    if ( bufcoded[0] == '-' && bufcoded[1] == '-' )
    {
        bufin = strchr( bufcoded, '\n' );

        if ( bufin )
        {
            bufin++;
            bufcoded = bufin;
        }
        else
        {
            bufin = bufcoded;
        }
    }
    else
    {
        bufin = bufcoded;
    }

    //
    //  Strip all cr/lf from the block
    //

    pbuf = (LPBYTE)bufin;
    while ( *pbuf )
    {
        if ( *pbuf == '\r' || *pbuf == '\n' )
        {
            memmove( pbuf, pbuf+1, strlen( (LPCTSTR)pbuf + 1) + 1 );
        }
        else
        {
            pbuf++;
        }
    }

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */

    while(pr2six[*(bufin++)] <= 63);
    nprbytes = bufin - bufcoded - 1;
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    bufin  = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    //
    //  Now we need to add a new wrapper sequence around the certificate
    //  indicating this is a certificate
    //

    memmove( beginbuf + sizeof(abCertHeader),
             beginbuf,
             nbytesdecoded );

    memcpy( beginbuf,
            abCertHeader,
            sizeof(abCertHeader) );

    //
    //  The beginning record size is the total number of bytes decoded plus
    //  the number of bytes in the certificate header
    //

    beginbuf[CERT_SIZE_HIBYTE] = (BYTE) (((USHORT)nbytesdecoded+CERT_RECORD) >> 8);
    beginbuf[CERT_SIZE_LOBYTE] = (BYTE) ((USHORT)nbytesdecoded+CERT_RECORD);

    nbytesdecoded += sizeof(abCertHeader);

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;
}





void _CRTAPI1
main(  int argc,  char * argv[] )
{
    LSA_UNICODE_STRING string1;
    LSA_UNICODE_STRING string2;
    PLSA_UNICODE_STRING newstring;
    LSA_OBJECT_ATTRIBUTES ob;
    LSA_HANDLE        hPolicy;
    NTSTATUS          ntStatus;
    DWORD nbytes;
    BYTE            buffer[MAX_JUNK];

    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ob,
                                NULL,
                                0L,
                                NULL,
                                NULL );


    ntStatus = LsaOpenPolicy( NULL,
                              &ob,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS(ntStatus)) {
        printf("error %x\n",ntStatus);
        return;
    }

    RtlInitUnicodeString( &string1, NNTP_SSL_CERT_SECRET);
    ntStatus = ReadBinaryData(
                        "servercert.der",
                        buffer,
                        &nbytes
                        );


    //
    //  Zero terminate so we can uudecode
    //

    buffer[nbytes] = '\0';

    uudecode_cert( (LPSTR)buffer, &nbytes );

    string2.Length = (USHORT)nbytes;
    string2.MaximumLength = (USHORT)nbytes;
    string2.Buffer = (PWSTR)buffer;

    ntStatus = LsaStorePrivateData(
                                hPolicy,
                                &string1,
                                &string2
                                );

    if ( !NT_SUCCESS(ntStatus)) {
        printf("cert store error %x\n",ntStatus);
        LsaClose(hPolicy);
        return;
    }

    RtlInitUnicodeString( &string1, NNTP_SSL_PKEY_SECRET);
    ntStatus = ReadBinaryData(
                        "serverkey.der",
                        buffer,
                        &nbytes
                        );

    string2.Length = (USHORT)nbytes;
    string2.MaximumLength = (USHORT)nbytes;
    string2.Buffer = (PWSTR)buffer;

    ntStatus = LsaStorePrivateData(
                                hPolicy,
                                &string1,
                                &string2
                                );

    if ( !NT_SUCCESS(ntStatus)) {
        printf("pkey store error %x\n",ntStatus);
        LsaClose(hPolicy);
        return;
    }

    RtlInitUnicodeString( &string1, NNTP_SSL_PWD_SECRET);
    string2.Length = (USHORT)(strlen("peteo_mips")+1);
    string2.MaximumLength = (USHORT)string2.Length;
    string2.Buffer = (PWSTR)"peteo_mips";

    ntStatus = LsaStorePrivateData(
                                hPolicy,
                                &string1,
                                &string2
                                );

    if ( !NT_SUCCESS(ntStatus)) {
        printf("pkey store error %x\n",ntStatus);
    }
    LsaClose(hPolicy);
} // main()

NTSTATUS
ReadBinaryData(
        LPCSTR Filename,
        LPBYTE Buffer,
        PDWORD bufLen
        )
{
    HANDLE hFile;

    hFile = CreateFile(
                    Filename,
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        printf("createfile error %d\n",GetLastError());
        return FALSE;
    }

    if (!ReadFile(
            hFile,
            Buffer,
            MAX_JUNK,
            bufLen,
            NULL
            )) {
        printf("read file error %d\n",GetLastError());
        return(FALSE);
    }

    printf("read %d bytes\n",*bufLen);
    CloseHandle(hFile);
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\rcancel\main.cpp ===
# include <windows.h>
# include <lm.h>
# include <stdio.h>
# include <stdlib.h>
# include <inetinfo.h>
# include <norminfo.h>
# include "apiutil.h"
# include "nntptype.h"
# include "nntpapi.h"

HINSTANCE	hModuleInstance = 0 ;

void
usage( )
{
    printf("rcancel\n");
    printf("\t-s <server>\n");
    printf("\t-m <messageid>\n");
	printf("\t-v <virtual server>\n");
    return;
}

WCHAR ServerName[256];

void
__cdecl
main(  int argc,  char * argv[] )
{
    NET_API_STATUS err;
    CHAR op = ' ';
    INT cur = 1;
    PCHAR x;
    DWORD i;
    BOOL isNull;
    PCHAR szMessageID = NULL;
	PWCHAR szServer = NULL;
	DWORD dwInstanceId = 1;
	PCHAR server;
	
    if ( argc == 1 ) {
        usage( );
        return;
    }

    while ( cur < argc ) {

        x=argv[cur++];
        if ( *(x++) == '-' ) {

            switch (*x) {
            case 'm':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }

				szMessageID = argv[cur++];
                break;

            case 'v':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }

                dwInstanceId = atoi(argv[cur++]);
                break;

            case 's':
                if ( cur >= argc ) {
                    usage();
                    return;
                }

                server = argv[cur++];
                for (i=0; server[i] != '\0' ;i++ ) {
                    ServerName[i] = (WCHAR)server[i];
                }
                ServerName[i]=L'\0';
                szServer = ServerName;
                break;

            default:
				if( cur >= 1 ) printf("bad argument found\n\n");

                usage( );
                return;
            }
        }
    }

	if( szMessageID == NULL ) {
		printf("Message ID of article to cancel must be supplied\n");
		usage() ;
		return ;
	}

	err = NntpCancelMessageID(szServer, dwInstanceId, szMessageID);
	if (err != NO_ERROR) {
		printf("RPC failed with 0x%x\n", err);
	}

    return;

} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\install\main.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <ntsam.h>
#include <ntlsa.h>

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winsock.h>
#include <nspapi.h>
#include "..\..\nntpcons.h"

#define     NNTP_SERVER     "NntpSvc"
LPCSTR NntpKey = "SYSTEM\\CurrentControlSet\\Services\\NntpSvc";

VOID
InstallServiceRegKeys(
    VOID
    );


//
// For each service create a GUID using uuidgen and store it in static
//  variable for further use below.
//   Gopher Service GUID: 62388f10-58a2-11ce-bec8-00aa0047ae4e
//

static GUID    g_NntpGuid   = { 0x051eef10, 0x0e24, 0x11cf, 0x90, 0x9e,
                                0x00, 0x80, 0x5f, 0x48, 0xa1, 0x35 };

//
// For each of the service make an entry in the following list of services
//
//  Format for each service info is:
//   ServiceInfo( SymbolicName, ServiceName, DisplayName,  SapId, TcpPort,
//                pointer-to-guid-for-the-service)
//
//  This is a macro. Please be considerate to use a terminating "\"
//

# define AllServicesInfo()   \
                                                         \
  ServiceInfo( NNTP_SERVICE_NAME, "NntpSvc",             \
               "Microsoft NNTP Service",                 \
               ( 0 ), (119), &g_NntpGuid,                \
               NNTP_ANONYMOUS_SECRET_W,                  \
               NNTP_ROOT_SECRET_W)                       \

//
// Few convenience macros
//

// For setting up the Values in ServiceTypeValue structure.
# define SetServiceTypeValues( pSvcTypeValue, dwNS, dwType, dwSize, lpValName, lpVal)   \
       ( pSvcTypeValue)->dwNameSpace = ( dwNS);           \
       ( pSvcTypeValue)->dwValueType = ( dwType);         \
       ( pSvcTypeValue)->dwValueSize = ( dwSize);         \
       ( pSvcTypeValue)->lpValueName = ( lpValName);      \
       ( pSvcTypeValue)->lpValue     = (PVOID ) ( lpVal); \

# define SetServiceTypeValuesDword( pSvcTypeValue, dwNS, lpValName, lpVal) \
   SetServiceTypeValues( (pSvcTypeValue), (dwNS), REG_DWORD, sizeof( DWORD), \
                         ( lpValName), ( lpVal))



typedef struct  _ServiceSetupInfo {

    char *      m_pszServiceName;
    char *      m_pszDisplayName;
    DWORD       m_sapId;              // Id for SAP ( for SPX/IPX)
    DWORD       m_tcpPort;            // TCP/IP port number
    LPGUID      m_lpGuid;
    WCHAR *     m_pszAnonPwdSecret;   // Anonymous password secret name
    WCHAR *     m_pszRootPwdSecret;   // Virtual roots password secret name

} ServiceSetupInfo;

//
// Macro to be used for defining a value for ServiceSetupInfo structure
//
# define ServiceInfoValue( svcName, dispName, sapId, tcpPort, lpGuid, AnonPwd, RootPwd)  \
   {  svcName, dispName, sapId, tcpPort, lpGuid, AnonPwd, RootPwd }


//
// Form an enumerated list of the service names. These form the
//   index into the array of service setup information structures.
//

# define ServiceInfo( sym, svc, disp, sap, tcpport, lpGuid, AnonPwd, RootPwd)  \
   i ## sym,

typedef enum  {

    AllServicesInfo()
    iMaxService

  } eServiceInfo;

# undef ServiceInfo


//
// Form the array of ServiceSetyupInfo objects.
//

# define ServiceInfo( sym, svc, disp, sap, tcpport, lpGuid, AnonPwd, RootPwd)   \
   ServiceInfoValue( svc, disp, sap, tcpport, lpGuid, AnonPwd, RootPwd),

static ServiceSetupInfo   g_svcSetupInfo[] =  {

    AllServicesInfo()
      { NULL, NULL, 0, 0, NULL, NULL, NULL}         //  a sentinel for the array
};

# undef ServiceInfo

//  end_unmodifiable_code


/************************************************************
 *    Functions
 ************************************************************/

//
// Local functions
//


static BOOL
CreateServiceEntry( IN char * pszServiceName,
                    IN char * pszDisplayName,
                    IN char * pszPath);

static BOOL
CreateEventLogEntry( IN char *   pszServiceName,
                     IN char *   pszServicePath
                    );

static VOID PrintUsageMessage( IN char * pszProgramName);

static BOOL
PerformSetService( IN const ServiceSetupInfo * pSvcSetupInfo,
                   IN DWORD svcOperation);

DWORD
SetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    IN  LPWSTR       pSecret,
    IN  DWORD        cbSecret
    );



int _CRTAPI1
main(  int argc,  char * argv[] )
{
    BOOL fRet = TRUE;

    char *  pszProgram = argv[ 0];
    char *  pszOperation;
    char *  pszSvc;

    int  i;
    ServiceSetupInfo * pSvcSetupInfo = NULL;
    DWORD    svcOperation = SERVICE_ADD_TYPE;

    //
    //  Parse the command line arguments.
    //

    if ( argc != 2) {

        PrintUsageMessage( argv[ 0]);
        return ( 1);
    }

    pszSvc = "NntpSvc";
    pszOperation = argv[1];

    //
    // Lookup the service setup info structure from the array
    //  command line argument 1 is the service name.
    // Find the associated service setup info structure.
    //

    pSvcSetupInfo = g_svcSetupInfo;

    //
    //  Identify the operation to be performed and execute the same.
    //

    if ( _strnicmp( pszOperation, "/path:", 5) == 0) {

        fRet = CreateServiceEntry( pSvcSetupInfo->m_pszServiceName,
                                   pSvcSetupInfo->m_pszDisplayName,
                                  strchr( pszOperation, ':') + 1);

    } else {

        PrintUsageMessage( pszProgram);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRet = FALSE;
    }


    fRet = fRet && PerformSetService( pSvcSetupInfo, svcOperation);

    return ( (fRet) ? NO_ERROR : GetLastError());
} // main()





VOID
PrintUsageMessage( IN char * pszProgramName)
/*++
  Prints the usage message along with possible list of services allowed.
--*/
{
    fprintf( stderr,
            "Usage:\n  %s  /path:<path of inetinfo.exe (incl inetinfo.exe)>\n",
            pszProgramName);

    return;
} // PrintUsageMessge()


/************************************************************
 *  Following are general functions usable by other Internet services
 ************************************************************/




static BOOL
PerformSetService( IN const ServiceSetupInfo * pSvcSetupInfo,
                   IN DWORD svcOperation)
{
    int err;

    WSADATA  WsaData;

    SERVICE_INFO serviceInfo;
    LPSERVICE_TYPE_INFO_ABS lpServiceTypeInfo ;
    LPSERVICE_TYPE_VALUE_ABS lpServiceTypeValues ;
    BYTE serviceTypeInfoBuffer[sizeof(SERVICE_TYPE_INFO) + 1024];
             // Buffer large enough for 3 values ( SERVICE_TYPE_VALUE_ABS)

    DWORD Value1 = 1 ;
    DWORD SapValue = pSvcSetupInfo->m_sapId;
    DWORD TcpPortValue = pSvcSetupInfo->m_tcpPort;
    DWORD statusFlags;

    //
    // Initialize Windows Sockets DLL
    //

    err = WSAStartup( 0x0101, & WsaData);
    if ( err == SOCKET_ERROR) {

        fprintf( stderr, " WSAStartup() Failed. Error = %ld\n",
                GetLastError());
        return ( FALSE);
    }


    //
    // Setup the service information to be passed to SetService() for adding
    //   or deleting this service. Most of the SERVICE_INFO fields are not
    //   required for add or delete operation. The main things of interests are
    //  GUIDs and ServiceSpecificInfo structure.
    //

    memset( (PVOID ) & serviceInfo, 0, sizeof( serviceInfo)); //null all fields

    serviceInfo.lpServiceType     =  pSvcSetupInfo->m_lpGuid;

    //
    // The "Blob" will contain the service specific information.
    // In this case, fill it with a SERVICE_TYPE_INFO_ABS structure
    //  and associated information.
    //
    serviceInfo.ServiceSpecificInfo.pBlobData = serviceTypeInfoBuffer;
    serviceInfo.ServiceSpecificInfo.cbSize    = sizeof( serviceTypeInfoBuffer);


    lpServiceTypeInfo = (LPSERVICE_TYPE_INFO_ABS ) serviceTypeInfoBuffer;

    //
    //  There are totally 3 values associated with this service if we're doing
    //  both SPX and TCP, there's only one value if TCP.
    //

    if ( pSvcSetupInfo->m_sapId )
    {
        lpServiceTypeInfo->dwValueCount = 3;
    }
    else
    {
        lpServiceTypeInfo->dwValueCount = 1;
    }

    lpServiceTypeInfo->lpTypeName   = pSvcSetupInfo->m_pszServiceName;

    lpServiceTypeValues = lpServiceTypeInfo->Values;


    if ( pSvcSetupInfo->m_sapId )
    {
        //
        // 1st value: tells the SAP that this is a connection oriented service.
        //

        SetServiceTypeValuesDword( ( lpServiceTypeValues + 0),
                                  NS_SAP,                    // Name Space
                                  SERVICE_TYPE_VALUE_CONN,   // ValueName
                                  &Value1                    // actual value
                                  );

        //
        // 2nd Value: tells SAP about object type to be used for broadcasting
        //   the service name.
        //

        SetServiceTypeValuesDword( ( lpServiceTypeValues + 1),
                                  NS_SAP,
                                  SERVICE_TYPE_VALUE_SAPID,
                                  &SapValue);

        //
        // 3rd value: tells TCPIP name-space provider about TCP/IP port to be used.
        //
        SetServiceTypeValuesDword( ( lpServiceTypeValues + 2),
                                  NS_DNS,
                                  SERVICE_TYPE_VALUE_TCPPORT,
                                  &TcpPortValue);
    }
    else
    {
        SetServiceTypeValuesDword( ( lpServiceTypeValues + 0),
                                  NS_DNS,
                                  SERVICE_TYPE_VALUE_TCPPORT,
                                  &TcpPortValue);
    }

    //
    // Finally, call SetService to actually perform the operation.
    //

    err = SetService(
                     NS_DEFAULT,             // all default name spaces
                     svcOperation,           // either ADD or DELETE
                     0,                      // dwFlags not used
                     &serviceInfo,           // the service info structure
                     NULL,                   // lpServiceAsyncInfo
                     &statusFlags            // additional status information
                     );

    if ( err != NO_ERROR ) {

        fprintf( stderr, "SetService failed: %ld\n", GetLastError( ) );

    } else {

        printf( "SetService( %s) succeeded, status flags = %ld\n",
               pSvcSetupInfo->m_pszServiceName, statusFlags );
    }

    //
    //  Create the LSA secrets for the anonymous user password and the virtual
    //  root passwords
    //

    if ( !SetSecret( NULL,
                     pSvcSetupInfo->m_pszAnonPwdSecret,
                     L"",
                     sizeof(WCHAR) ) ||
         !SetSecret( NULL,
                     pSvcSetupInfo->m_pszRootPwdSecret,
                     L"",
                     sizeof(WCHAR) ))
    {
        err = GetLastError();

        fprintf( stderr,
                "SetService( %s ) failed to create Lsa Secrets for anonymous\n"
                "username password or virtual root passwords.  Error = %d\n",
                pSvcSetupInfo->m_pszServiceName,
                err);

    }

    return ( err != NO_ERROR);

} // PerformSetService()





static BOOL
CreateServiceEntry( IN char * pszServiceName,
                    IN char * pszDisplayName,
                    IN char * pszPath)
/*++

  This function calls the service controller to create a new service.

  Arguments:
    pszServiceName  pointer to service name
    pszDisplayName  pointer to Display name
    pszPath    pointer to null-terminated string containing the path for
                 the service DLL.

  Returns:

    TRUE on success and FALSE if there is any failure.
    Use GetLastError() to get further error code on failure.

--*/
{
    BOOL fReturn = FALSE;
    SC_HANDLE hServiceManager;

    if ( strstr( pszPath,"inetinfo.exe") == NULL ) {
        printf("ERROR: path must include inetinfo.exe\n");
        SetLastError(ERROR_BAD_PATHNAME);
        return(FALSE);
    }

    //
    //  Create the service.
    //

    hServiceManager = OpenSCManager( NULL,       // machine name
                                    NULL,       // database name
                                    STANDARD_RIGHTS_REQUIRED
                                    | SC_MANAGER_CREATE_SERVICE );

    if ( hServiceManager != NULL) {

        SC_HANDLE   hService;

        //
        // create the service itself.
        //

        hService = CreateService( hServiceManager,
                                 pszServiceName,
                                 pszDisplayName,
                                 GENERIC_READ | GENERIC_WRITE,
                                 SERVICE_WIN32_SHARE_PROCESS,
                                 SERVICE_DEMAND_START,
                                 SERVICE_ERROR_NORMAL,
                                 pszPath,
                                 NULL,      // lpszLoadOrderGroup
                                 NULL,      // lpdwTagId
                                 NULL,      // lpszDependencies
                                 NULL,      // lpszStartUserName
                                 NULL );    // lpszPassword


        if( hService != NULL ) {

            fReturn = TRUE;
            CloseServiceHandle( hService);
        }

        CloseServiceHandle( hServiceManager);

        //
        // Setup reg keys
        //

        InstallServiceRegKeys( );

    } else {

        fprintf( stderr,  "OpenSCManager failed: %ld\n", GetLastError() );

    }


    fprintf( stderr, " %s created with path %s. Return %d ( Error = %ld)\n",
            pszServiceName, pszPath,
            fReturn, ( fReturn) ? NO_ERROR : GetLastError());


    return ( fReturn);
} // CreateServiceEntry()







# define EVENT_LOG_REG_KEY   \
            "System\\CurrentControlSet\\Services\\EventLog\\System"

# define LEN_EVENT_LOG_REG_KEY  ( sizeof( EVENT_LOG_REG_KEY))



static BOOL
CreateEventLogEntry( IN char *   pszServiceName,
                     IN char *   pszServicePath
                    )
/*++

  This function creates an entry for a service in the Eventlog registry
   so that the messages of the service may be decoded.

  Arguments:
    pszServiceName     pointer to string containing the service name.
    pszServicePath     pointer to string containing the path for the service
                         dll with the embedded messages.

  Returns:
    TRUE on success and FALSE if there are any errors. Use GetLastError()
      to get detailed error message.

--*/
{
    char rgchKeyName[ LEN_EVENT_LOG_REG_KEY + 100];
    HKEY hkeyReg;
    LONG err;
    DWORD Disposition;


    if ( strlen( pszServiceName) >= 100) {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return ( FALSE);
    }

    wsprintf( rgchKeyName, "%s\\%s", EVENT_LOG_REG_KEY, pszServiceName);

    //
    //  Add the data to the EventLog's registry key so that the
    //  log insertion strings may be found by the Event Viewer.
    //

    err = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                          rgchKeyName,
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_WRITE,
                          NULL,
                          &hkeyReg,
                          &Disposition );

    if( err != 0 ) {

        fprintf( stderr, "RegCreateKeyEx failed: %ld\n", err );

        SetLastError( err);
        return ( FALSE);
    }

    err = RegSetValueEx( hkeyReg,
                         "EventMessageFile",
                         0,
                         REG_EXPAND_SZ,
                         pszServicePath,
                         strlen( pszServicePath ) + 1 );

    if( err == 0 ) {

        DWORD Value;

        Value = ( EVENTLOG_ERROR_TYPE  |
                 EVENTLOG_WARNING_TYPE |
                 EVENTLOG_INFORMATION_TYPE
                 );

        err = RegSetValueEx( hkeyReg,
                            "TypesSupported",
                             0,
                             REG_DWORD,
                             (CONST BYTE *)&Value,
                             sizeof(Value) );
    }

    RegCloseKey( hkeyReg );

    if( err != 0 ) {

        fprintf( stderr, "RegSetValueEx failed: %ld\n", err );
        SetLastError( err);
    }

    return ( err == 0);

}  // CreateEventLogEntry()

DWORD
SetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    IN  LPWSTR       pSecret,
    IN  DWORD        cbSecret
    )
/*++

   Description

     Sets the specified LSA secret

   Arguments:

     Server - Server name (or NULL) secret lives on
     SecretName - Name of the LSA secret
     pSecret - Pointer to secret memory
     cbSecret - Size of pSecret memory block

   Note:

--*/
{
    LSA_HANDLE        hPolicy;
    UNICODE_STRING    unicodePassword;
    UNICODE_STRING    unicodeServer;
    NTSTATUS          ntStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE        hSecret;
    UNICODE_STRING    unicodeSecret;


    RtlInitUnicodeString( &unicodeServer,
                          Server );

    //
    //  Initialize the unicode string by hand so we can handle '\0' in the
    //  string
    //

    unicodePassword.Buffer        = pSecret;
    unicodePassword.Length        = (USHORT) cbSecret;
    unicodePassword.MaximumLength = (USHORT) cbSecret;

    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( &unicodeServer,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
    {
        SetLastError( RtlNtStatusToDosError( ntStatus ) );
        return FALSE;
    }

    //
    //  Create or open the LSA secret
    //

    RtlInitUnicodeString( &unicodeSecret,
                          SecretName );

    ntStatus = LsaCreateSecret( hPolicy,
                                &unicodeSecret,
                                SECRET_ALL_ACCESS,
                                &hSecret );

    if ( !NT_SUCCESS( ntStatus ))
    {

        //
        //  If the secret already exists, then we just need to open it
        //

        if ( ntStatus == STATUS_OBJECT_NAME_COLLISION )
        {
            ntStatus = LsaOpenSecret( hPolicy,
                                      &unicodeSecret,
                                      SECRET_ALL_ACCESS,
                                      &hSecret );
        }

        if ( !NT_SUCCESS( ntStatus ))
        {
            LsaClose( hPolicy );
            SetLastError( RtlNtStatusToDosError( ntStatus ) );
            return FALSE;
        }
    }

    //
    //  Set the secret value
    //

    ntStatus = LsaSetSecret( hSecret,
                             &unicodePassword,
                             &unicodePassword );

    LsaClose( hSecret );
    LsaClose( hPolicy );

    if ( !NT_SUCCESS( ntStatus ))
    {
        return RtlNtStatusToDosError( ntStatus );
    }

    return TRUE;
}

VOID
InstallServiceRegKeys(
    VOID
    )
{
    DWORD error;
    DWORD disp;
    HKEY pKey = NULL, sKey = NULL;

    //
    // Create the reg key templates
    //

    error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                NntpKey,
                0,
                KEY_QUERY_VALUE,
                &sKey
                );

    if ( error != NO_ERROR ) {
        printf("InstallService: error %d opening %s\n",error,NntpKey);
        goto error;
    }

    error = RegCreateKeyEx(
                        sKey,
                        "Parameters",
                        0,
                        "",
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &pKey,
                        &disp
                        );

    if ( error != NO_ERROR ) {
        printf("Error %d creating Parameters key\n",error);
        goto error;
    }


    {
        LPCSTR tmpString;

        tmpString = "admin@corp.com";
        error = RegSetValueEx(
                            pKey,
                            "AdminEmail",
                            0,
                            REG_SZ,
                            (CONST BYTE*)tmpString,
                            strlen(tmpString)+1
                            );

        tmpString = "administrator";
        error = RegSetValueEx(
                            pKey,
                            "AdminName",
                            0,
                            REG_SZ,
                            (CONST BYTE*)tmpString,
                            strlen(tmpString)+1
                            );

        tmpString = "InternetGuest";
        error = RegSetValueEx(
                            pKey,
                            "AnonymousUserName",
                            0,
                            REG_SZ,
                            (CONST BYTE*)tmpString,
                            strlen(tmpString)+1
                            );

    }

error:

    if ( pKey != NULL ) {
        RegCloseKey( pKey );
    }

    if ( sKey != NULL ) {
        RegCloseKey( sKey );
    }

    return;

} // InstallService
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\random\good.cpp ===
#include	<windows.h>
#include	<stdio.h>


void	
usage()		{


	printf(	"This program evaluates hash functions \n"
			"random <testfil> <depth> <number newsgroups>\n"
			) ;



}



WORD
MyRand(
    IN DWORD& seed,
	IN DWORD	val
    )
{
    DWORD next = seed;
    next = (seed*val) * 1103515245 + 12345;   // magic!!
	seed = next ;
    return (WORD)((next/65536) % 32768);
}

DWORD
IDHash(
    IN DWORD Key1,
    IN DWORD Key2
    )
/*++

Routine Description:

    Used to find the hash value given 2 numbers. (Used for articleid + groupId)

Arguments:

    Key1 - first key to hash.  MS bit mapped to LSb of hash value
    Key2 - second key to hash.  LS bit mapped to MS bit of hash value.

Return Value:

    Hash value

--*/
{
    DWORD	val1 = 0, val2 = 0;


    //
    // Do Key1 first
    //

	DWORD	seed1 = Key2 << (Key1 & 0xf) ;


    val1 = MyRand(seed1, Key1);

	DWORD	seed2 = val1 << (Key2 & 0xf) ;
    val2 = MyRand(seed2, Key2);

    val1 |= ( MyRand(seed1, Key1+val2) << 15);
    val1 |= ( MyRand(seed1, Key1+val2) << 30);

    //
    // ok, now do Key2
    //

    val2 ^= ( MyRand(seed2, Key2+val1) << 15);
    val2 ^= ( MyRand(seed2, Key2+val1) << 30);

	DWORD	val = val1 + val2 ;
    return(val);

} // IDHash



void
ComputeStatistics(	
				DWORD	*pdw,
				DWORD	cdw,
				DWORD&	MaxHits, 
				DWORD&	MedianHits, 
				DWORD&	cBeyond4K,
				double&	AverageHits, 
				double	Tries
				)	{


	DWORD	rgdw[4*1024] ;

	ZeroMemory( rgdw, sizeof( rgdw ) ) ;

	cBeyond4K = 0 ;
	MaxHits = 0 ;
	MedianHits = 0 ;
	AverageHits = 0 ;
	
	for( DWORD	i=0; i<cdw; i++ ) {

		
		if( pdw[i] > MaxHits ) 
			MaxHits = pdw[i] ;

		if( pdw[i] > (4*1024) ) {
			
			cBeyond4K ++ ;

		}	else	{

			rgdw[ pdw[i] ] ++ ;

		}

		AverageHits += (double)pdw[i] ;

	}

	AverageHits /= Tries ;

	DWORD	TempMax = 0 ;
	DWORD	iMax = 0 ;
	for( i=0; i < 4*1024; i++ ) {

		if( rgdw[i] > TempMax ) {
			TempMax = rgdw[i] ;
			iMax = i ;
		}
	}
	MedianHits = iMax ;
}

int
main( int argc, char *argv[] ) {

	if( argc != 4 ) {

		usage() ;

	}

	LPSTR	lpstrFile = argv[1] ;

	HANDLE	hFile = CreateFile(	lpstrFile,
								GENERIC_READ | GENERIC_WRITE,
								0,
								0,
								CREATE_ALWAYS, 
								FILE_FLAG_DELETE_ON_CLOSE,
								INVALID_HANDLE_VALUE 
								) ;

	if( hFile == INVALID_HANDLE_VALUE ) {
		printf( "Can't create file %s error %d\n",
			lpstrFile, GetLastError() ) ;
		return	1 ;
	}

	if( !isdigit( *argv[2] ) ) {

		usage() ;
		CloseHandle( hFile ) ;
		return	1 ;
	}

	if( !isdigit( *argv[3] ) ) {

		usage() ;
		CloseHandle( hFile ) ;
		return	1 ; 
	}

	DWORD	depth = atoi( argv[2] ) ;

	DWORD	limit = atoi( argv[3] ) ;

	if( depth > 29 ) {

		printf( "depth too large \n" ) ;
		usage() ;
		return	1 ;
	}

	DWORD	MapSize =  (0x1 << depth) * sizeof( DWORD ) ;

	HANDLE	hMap = CreateFileMapping(
								hFile, 
								0,
								PAGE_READWRITE, 
								0,
								MapSize,
								0 
								) ;

	if( hMap == 0 ) {

		printf( "Unable to create mapping - error %d", GetLastError() ) ;
		usage() ;
		CloseHandle( hFile ) ;
		return	 1 ;
	
	}

	DWORD	*pdwMap = (DWORD*)MapViewOfFile(
								hMap,
								FILE_MAP_ALL_ACCESS,
								0,
								0,
								0 
								) ;


	if( pdwMap == 0 ) {

		printf( "Unable to MapViewOfFile %d\n", pdwMap ) ;
		usage() ;
		CloseHandle( hMap ) ;
		CloseHandle( hFile ) ;
		return	1 ;
	
	}

	DWORD	ShiftAmount = 32 - depth ;

	for( DWORD i=0; i < limit; i ++ ) {
	
		for( DWORD	j=0; j < 64 * 1024; j++ ) {

			DWORD	value = IDHash( i, j ) ;

			value >>= ShiftAmount ;

			pdwMap[value] ++ ;
		}
		if( i%16 == 0 ) {
			printf( "advancing to group ids %d\n", i ) ;
		}
	}
	

	//
	//	Compute Statistics
	//

	DWORD	MaxHits = 0 ;
	DWORD	MedianHits = 0 ;
	DWORD	Beyond4K = 0 ;

	double	AverageHits = 0 ;
	double	Tries = limit * 64 * 1024 ;

	ComputeStatistics(	pdwMap,
						(0x1 << depth),
						MaxHits, 
						MedianHits,
						Beyond4K,
						AverageHits,
						Tries
						) ;

	printf( "Report : \n"
			"\tAverage Hits - %f \n"
			"\tMax Hits - %d\n"
			"\tMedian Hits - %d\n"
			"\tNumber with more that 4096 hits - %d\n",
				AverageHits,
				MaxHits,
				MedianHits,
				Beyond4K	) ;
				
	return	0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\random\main.cpp ===
#include	<windows.h>
#include	<stdio.h>


void	
usage()		{


	printf(	"This program evaluates hash functions \n"
			"random <testfil> <depth> <number newsgroups> <K articles per group>\n"
			) ;

}

DWORD	
MyRand2(
	IN	DWORD&	seed,
	IN	DWORD	val
	)
{
	__int64	next = seed ;
	const	__int64	mult = 0x8000000 ;

	next = (seed * val) * 1103515245 + 12345 ;
	seed = (DWORD) (next >> 16) ;
	return	(DWORD) ((next / mult) % (mult/2)) ;
}


WORD
MyRand(
    IN DWORD& seed,
	IN DWORD	val
    )
{
    DWORD next = seed;
    next = (seed*val) * 1103515245 + 12345;   // magic!!
	seed = next ;
    return (WORD)((next/65536) % 32768);
}

DWORD
IDHash(
    IN DWORD Key1,
    IN DWORD Key2
    )
/*++

Routine Description:

    Used to find the hash value given 2 numbers. (Used for articleid + groupId)

Arguments:

    Key1 - first key to hash.  MS bit mapped to LSb of hash value
    Key2 - second key to hash.  LS bit mapped to MS bit of hash value.

Return Value:

    Hash value

--*/
{
    DWORD	val1 = 0x80000000, val2 = 0x80000000;


    //
    // Do Key1 first
    //

	DWORD	lowBits = Key2 & 0xf ;

	DWORD	TempKey2 = Key2 & (~0xf) ;
	DWORD	seed1 = (Key2 << (Key1 & 0x7)) - Key1 ;

	Key1 = (0x80000000 - ((67+Key1)*(19+Key1)*(7+Key1)+12345)) ^ (((3+Key1)*(5+Key1)+12345) << ((Key1&0xf)+8)) ;
	TempKey2 = (0x80000000 - ((67+TempKey2)*(19+TempKey2)*(7+TempKey2)*(1+TempKey2)+12345)) ^ ((TempKey2+12345) << (((TempKey2>>4)&0x7)+8)) ;
	
	val1 -=	(MyRand( seed1, Key1 ) << (Key1 & 0xf)) ;
	val1 += MyRand( seed1, Key1 ) << (((TempKey2 >> 4) & 0x3)+4) ;
	val1 ^=	MyRand( seed1, Key1 ) << 17 ;

	DWORD	seed2 = val1 - TempKey2 ;

	val2 -= MyRand( seed2, TempKey2 >> 1 ) << (((Key1 << 3)^Key1) &0xf) ; 
	val2 =  val2 + MyRand( seed2, TempKey2 ) << (13 ^ Key1) ;
	val2 ^= MyRand( seed2, TempKey2 ) << 15 ;

	
	//DWORD	val = val1 + val2 ; 

	DWORD	val = (val1 + val2 + 67) * (val1 - val2 + 19) * (val1 % (val2 + 67)) ;

	val += (MyRand( seed2, lowBits ) >> 3) ;
	

#if 0 
	DWORD	seed1 = (Key2 << (Key1 & 0x3f)) ^ Key1 ;

    val1 = MyRand(seed1, Key1);
	val1 |= MyRand(seed1, Key1) << 16;

	DWORD	seed2 = (val1 << (Key2 & 0xf)) + Key2 ;
    val2 = MyRand(seed2, Key2+val1);
	val2 |= MyRand(seed2, val2) << 16 ;

	seed1 += val2 ;
    val1 |= ( MyRand(seed1, Key1) << 14);
	val1 ^= ( MyRand(seed1, Key1) << 20);
	val1 |= ( MyRand(seed1, Key1) << 30);

    //
    // ok, now do Key2
    //

	seed2 += val1 ;
    val2 |= ( MyRand(seed2, Key2+seed1) << 15);
    val2 ^= ( MyRand(seed2, Key2+seed1) << 19);
    val2 |= ( MyRand(seed2, Key2+seed2) << 29);

	DWORD	val = val1 + val2 ;

	val += (MyRand( seed2, lowBits ) >> 3) ;
#endif
    return(val);

} // IDHash


int	__cdecl	Compare( const void *pv1, const void *pv2 ) {

	DWORD	*pdw1 = (DWORD*)pv1 ;
	DWORD	*pdw2 = (DWORD*)pv2 ;

	if( *pdw1 < *pdw2 ) {
		return	-1 ;
	}	else if( *pdw1 == *pdw2 ) {
		return	0 ;
	}	else	{
		return 1 ;
	}	
}


void
ComputeStatistics(	
				DWORD	*pdw,
				DWORD	cdw,
				DWORD	cBits,
				DWORD&	MaxHits, 
				DWORD&	MedianHits, 
				DWORD&	cBeyond4K,
				double&	AverageHits, 
				double	Tries
				)	{


	DWORD	rgdw[8*1024] ;

	DWORD	rgdwTopTen[20] ;

	ZeroMemory( rgdwTopTen, sizeof( rgdwTopTen ) ) ;
	ZeroMemory( rgdw, sizeof( rgdw ) ) ;

	cBeyond4K = 0 ;
	MaxHits = 0 ;
	MedianHits = 0 ;
	AverageHits = 0 ;

	for( DWORD	l=0; l<4*1024; l++ ) {
		rgdw[(l*2)+1] = l ;
	}
	
	for( DWORD	i=0; i<cdw; i++ ) {

		DWORD	dwTemp = pdw[i] ;

		for( DWORD j=1; j < (1<<(cBits-1)); j++ ) {
			dwTemp += pdw[i++] ;
		}
		
		if( dwTemp > MaxHits ) 
			MaxHits = dwTemp ;

		if( dwTemp > (4*1024) ) {
			
			cBeyond4K ++ ;

		}	else	{

			rgdw[ 2*dwTemp] ++ ;

		}

		AverageHits += (double)dwTemp ;

	}

	AverageHits /= Tries ;

	DWORD	TempMax = 0 ;
	DWORD	iMax = 0 ;
	for( i=0; i < 4*1024; i++ ) {

		if( rgdw[i*2] > TempMax ) {
			TempMax = rgdw[i*2] ;
			iMax = i ;
		}
	}
	MedianHits = iMax ;

	qsort( rgdw, 4*1024, 2*sizeof( DWORD ), Compare ) ;

	printf( "Sorted number of hits \n" ) ;
	for( int k=0; k<4*1024; k++ ) {

		if( rgdw[2*k] != 0 ) {
			printf( "\tNumber Occurrences - %d Number Hits - %d\n", rgdw[2*k], rgdw[(2*k)+1] ) ;
		}
	}
}

int
main( int argc, char *argv[] ) {

	if( argc != 5 ) {

		usage() ;

	}

	LPSTR	lpstrFile = argv[1] ;

	HANDLE	hFile = CreateFile(	lpstrFile,
								GENERIC_READ | GENERIC_WRITE,
								0,
								0,
								CREATE_ALWAYS, 
								FILE_FLAG_DELETE_ON_CLOSE,
								INVALID_HANDLE_VALUE 
								) ;

	if( hFile == INVALID_HANDLE_VALUE ) {
		printf( "Can't create file %s error %d\n",
			lpstrFile, GetLastError() ) ;
		return	1 ;
	}

	if( !isdigit( *argv[2] ) ) {

		usage() ;
		CloseHandle( hFile ) ;
		return	1 ;
	}

	if( !isdigit( *argv[3] ) ) {

		usage() ;
		CloseHandle( hFile ) ;
		return	1 ; 
	}

	DWORD	depth = atoi( argv[2] ) ;

	DWORD	limit = atoi( argv[3] ) ;

	DWORD	kperGroup = atoi( argv[4] ) ;

	if( depth > 29 ) {

		printf( "depth too large \n" ) ;
		usage() ;
		return	1 ;
	}

	DWORD	MapSize =  (0x1 << depth) * sizeof( DWORD ) ;

	HANDLE	hMap = CreateFileMapping(
								hFile, 
								0,
								PAGE_READWRITE, 
								0,
								MapSize,
								0 
								) ;

	if( hMap == 0 ) {

		printf( "Unable to create mapping - error %d", GetLastError() ) ;
		usage() ;
		CloseHandle( hFile ) ;
		return	 1 ;
	
	}

	DWORD	*pdwMap = (DWORD*)MapViewOfFile(
								hMap,
								FILE_MAP_ALL_ACCESS,
								0,
								0,
								0 
								) ;


	if( pdwMap == 0 ) {

		printf( "Unable to MapViewOfFile %d\n", pdwMap ) ;
		usage() ;
		CloseHandle( hMap ) ;
		CloseHandle( hFile ) ;
		return	1 ;
	
	}

	DWORD	ShiftAmount = 32 - depth ;

	for( DWORD i=0; i < limit; i ++ ) {
	
		for( DWORD	j=0; j < kperGroup * 1024; j++ ) {

			DWORD	value = IDHash( i, j ) ;

			value >>= ShiftAmount ;

			pdwMap[value] ++ ;
		}
		if( (i*j)%(16 * 64 * 1024)  == 0 ) {
			printf( "advancing to group ids %d\n", i ) ;
		}
	}
	

	for( DWORD	cBits = 1; cBits < 4; cBits ++ ) {

		//
		//	Compute Statistics
		//

		DWORD	MaxHits = 0 ;
		DWORD	MedianHits = 0 ;
		DWORD	Beyond4K = 0 ;

		double	AverageHits = 0 ;
		double	Tries = limit * 64 * 1024 ;

		ComputeStatistics(	pdwMap,
							(0x1 << depth),
							cBits,
							MaxHits, 
							MedianHits,
							Beyond4K,
							AverageHits,
							Tries
							) ;

		printf( "Report : \n"
				"\tAverage Hits - %f \n"
				"\tMax Hits - %d\n"
				"\tMedian Hits - %d\n"
				"\tNumber with more that 4096 hits - %d\n\n\n",
					AverageHits,
					MaxHits,
					MedianHits,
					Beyond4K	) ;

	}
				
	return	0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\rdrop\main.cpp ===
# include <windows.h>
# include <lm.h>
# include <stdio.h>
# include <stdlib.h>
# include <inetinfo.h>
# include <norminfo.h>
# include "apiutil.h"
# include "nntptype.h"
# include "nntpapi.h"

DWORD
DelDropGroup(
    LPWSTR Server,
	DWORD  InstanceId,
    LPCSTR	newsgroup
    );

DWORD
AddDropGroup(
    LPWSTR Server,
	DWORD  InstanceId,
    LPCSTR	newsgroup
    );

char	StringBuff[4096] ;

HINSTANCE	hModuleInstance = 0 ;

void
usage( )
{
    printf("rdrop\n");
    printf("\t-t <operation>\n");
    printf("\t\t a      add group to drop list\n");
    printf("\t\t d      del group from drop list\n");
    printf("\t-s <server>\n");
    printf("\t-g <group>\n");
	printf("\t-v <virtual server>\n");
    return;
}

WCHAR ServerName[256];

void
_CRTAPI1
main(  int argc,  char * argv[] )
{
    NET_API_STATUS err;
    CHAR op = ' ';
    INT cur = 1;
    PCHAR x;
    DWORD i;
    BOOL isNull;
    PCHAR szNewsgroup = NULL;
	PWCHAR szServer = NULL;
	DWORD dwInstanceId = 1;
	PCHAR server;
	
    if ( argc == 1 ) {
        usage( );
        return;
    }

    while ( cur < argc ) {

        x=argv[cur++];
        if ( *(x++) == '-' ) {

            switch (*x) {
            case 'g':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }

				szNewsgroup = argv[cur++];
                break;

            case 'v':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }

                dwInstanceId = atoi(argv[cur++]);
                break;

            case 's':
                if ( cur >= argc ) {
                    usage();
                    return;
                }

                server = argv[cur++];
                for (i=0; server[i] != '\0' ;i++ ) {
                    ServerName[i] = (WCHAR)server[i];
                }
                ServerName[i]=L'\0';
                szServer = ServerName;
                break;

            case 't':
				if( cur >= argc )	{
					usage() ;
					return ;
				}

                op = *(argv[cur++]);
                break;

            default:
				if( cur >= 1 ) printf("bad argument found\n\n");

                usage( );
                return;
            }
        }
    }

	if( szNewsgroup == NULL ) {
		printf("newsgroup to be added or removed must be supplied\n");
		usage() ;
		return ;
	}

    switch (op) {
    case 'a':
		err = AddDropGroup(szServer, dwInstanceId, szNewsgroup);
		break;

    case 'd':
        err = DelDropGroup(szServer, dwInstanceId, szNewsgroup);
        break;

    default:
        usage( );
    }

    return;

} // main()

DWORD 
AddDropGroup(
    LPWSTR szServer,
	DWORD  dwInstanceId,
    LPCSTR  szNewsgroup
    )
{
    DWORD err;
    DWORD parm = 0;

	printf( "Attempting to add group %s to drop list\n", szNewsgroup ) ;

    err = NntpAddDropNewsgroup(
                    szServer,
					dwInstanceId,
					szNewsgroup
                    );

    if( err != NO_ERROR ) {
		printf("RPC failed with 0x%x\n", err);
    }
    return err;
}

DWORD 
DelDropGroup(
    LPWSTR szServer,
	DWORD  dwInstanceId,
    LPCSTR  szNewsgroup
    )
{
    DWORD err;
    DWORD parm = 0;

	printf( "Attempting to remove group %s from the drop list\n", szNewsgroup ) ;

    err = NntpRemoveDropNewsgroup(
                    szServer,
					dwInstanceId,
					szNewsgroup
                    );

    if( err != NO_ERROR ) {
		printf("RPC failed with 0x%x\n", err);
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\rexpire\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rexpire.rc
//
#define IDS_HELPTEXT                    1
#define	IDS_NEWSGROUPS_ERROR			2
#define	IDS_NULLNEWSGROUP_ERROR			3
#define	IDS_DELETE_ACTION				4
#define	IDS_RPC_ERROR					5
#define	IDS_PARM_ERROR					6
#define	IDS_DISPLAY						7
#define	IDS_NEWSGROUPS					8
#define	IDS_ADD_ACTION					9
#define IDS_EXPIRE_POLICY				10


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\rexpire\main.cpp ===
# include <windows.h>
# include <lm.h>
# include <stdio.h>
# include <stdlib.h>
# include <inetinfo.h>
# include <norminfo.h>
# include "apiutil.h"
# include "nntptype.h"
# include "nntpapi.h"
# include "resource.h"

DWORD
DelExpire(
    LPWSTR	Server,
	DWORD	InstanceId,
    DWORD	FeedId
    );

DWORD
AddExpire(
    LPWSTR Server,
	DWORD	InstanceId,
    LPNNTP_EXPIRE_INFO	ExpireInfo
    );

DWORD
GetInformation(
    LPWSTR Server,
	DWORD	InstanceId,
    DWORD ExpireId,
    LPNNTP_EXPIRE_INFO	 *ExpireInfo
    );

DWORD
Enumerate(
    LPWSTR Server,
	DWORD	InstanceId,
    LPNNTP_EXPIRE_INFO	*ExpireInfo
    );

DWORD
SetInformation(
    LPWSTR Server,
	DWORD	InstanceId,
    LPNNTP_EXPIRE_INFO	ExpireInfo
    );

VOID
PrintInfo(
    LPNNTP_EXPIRE_INFO	ExpireInfo
    );

//
// defaults
//

FEED_TYPE FeedType = 0;
DWORD ExpireSizeHorizon = 500;	// Megabytes
DWORD	ExpireTime = 0xFFFFFFFF ;	// infinite
LPWSTR RemServerW = (PWCH)NULL;
WCHAR ServerName[256];
LPWSTR ExpirePolicyW = (PWCH)NULL;
WCHAR ExpirePolicy[256];

char	StringBuff[4096] ;

HINSTANCE	hModuleInstance ;

void
usage( )
{
	
	LoadString( hModuleInstance, IDS_HELPTEXT, StringBuff, sizeof( StringBuff ) ) ;
	printf( StringBuff ) ;

#if 0 
    printf("rfeed\n");
    printf("\t-t <operation>\n");
    printf("\t\t a      add\n");
    printf("\t\t d      del\n");
    printf("\t\t g      get\n");
    printf("\t\t s      set\n");
    printf("\t\t e      enum\n");
    printf("\t-s <server>\n");
    printf("\t-i <expire id>\n");
    printf("\t-h <expire hours>\n");
    printf("\t-d <megabytes expire size> (default = 500)\n");
    printf("\t-n <newsgroups>\n");
#endif
    return;
}

void
__cdecl
main(  int argc,  char * argv[] )
{
    NET_API_STATUS err;
    LPNNTP_EXPIRE_INFO	expireInfo = 0 ;
    NNTP_EXPIRE_INFO	myExpire;
    DWORD expireId= 0;
    CHAR op = ' ';
    INT cur = 1;
    PCHAR x;
    PCHAR p;
    DWORD i;
    PCHAR server;
	PCHAR policy;
    BOOL isNull;
    DWORD numNews = 1;
    WCHAR tempNews[2048];
    PCHAR newsgroups = NULL;
	DWORD InstanceId = 1;

	hModuleInstance = GetModuleHandle( NULL ) ;

    if ( argc == 1 ) {
        usage( );
        return;
    }

    while ( cur < argc ) {

        x=argv[cur++];
        if ( *(x++) == '-' ) {

            switch (*x) {
            case 'i':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                expireId = atoi(argv[cur++]);
                break;

            case 'v':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                InstanceId = atoi(argv[cur++]);
                break;

            case 'n':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                newsgroups = argv[cur++];
                break;

            case 'd':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                ExpireSizeHorizon = atoi(argv[cur++]);
                break;

            case 'h':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                ExpireTime = atoi(argv[cur++]);
                break;

            case 's':
                if ( cur >= argc ) {
                    usage();
                    return;
                }

                server = argv[cur++];
                for (i=0; server[i] != '\0' ;i++ ) {
                    ServerName[i] = (WCHAR)server[i];
                }
                ServerName[i]=L'\0';
                RemServerW = ServerName;
                break;

            case 'p':
                if ( cur >= argc ) {
                    usage();
                    return;
                }

                policy = argv[cur++];
                for (i=0; policy[i] != '\0' ;i++ ) {
                    ExpirePolicy[i] = (WCHAR)policy[i];
                }
                ExpirePolicy[i]=L'\0';
                ExpirePolicyW = ExpirePolicy;
                break;

            case 't':
				if( cur >= argc )	{
					usage() ;
					return ;
				}
                op = *(argv[cur++]);
                break;


            default:

				if( cur >= 1 ) 
					printf( "unrecognized argument : %s\n", argv[cur-1] ) ;

                usage( );
                return;
            }
        }
    }

    switch (op) {
    case 'a':

        ZeroMemory(&myExpire,sizeof(myExpire));
        myExpire.ExpireSizeHorizon = ExpireSizeHorizon ;
        myExpire.ExpireTime = ExpireTime ;
        myExpire.Newsgroups = (PUCHAR)tempNews;
		myExpire.ExpirePolicy = ExpirePolicyW;

        //
        // fill the newsgroups
        //

        if ( (newsgroups == NULL) ) {
		
			LoadString( hModuleInstance, IDS_NEWSGROUPS_ERROR, StringBuff, sizeof( StringBuff ) ) ;
			printf( StringBuff ) ;
            usage();
            return;
		}

        p=newsgroups;
        isNull = TRUE;
        for (i=0; (i<1024) && (*p!='\0') ; i++ ) {
            if ( *p == ';' ) {
                if ( isNull ) {
					LoadString( hModuleInstance, IDS_NULLNEWSGROUP_ERROR, StringBuff, sizeof( StringBuff ) ) ;
					printf( StringBuff ) ;
                    usage();
                    return;
                }
                isNull = TRUE;
                tempNews[i] = L'\0';
            } else {
                isNull = FALSE;
                tempNews[i] = (WCHAR)*p;
            }
            p++;
        }

        if ( *p == '\0' ) {

            if ( !isNull ) {
                tempNews[i++] = L'\0';
            }
            tempNews[i++] = L'\0';
        }

        myExpire.cbNewsgroups = i * 2;

        err = AddExpire(
                    RemServerW,
					InstanceId,
                    &myExpire
                    );
        break;

    case 'd':
		LoadString( hModuleInstance, IDS_DELETE_ACTION, StringBuff, sizeof( StringBuff ) ) ;
		printf( StringBuff, expireId  ) ;
        err = DelExpire(
                    RemServerW,
					InstanceId,
                    expireId
                    );
        break;

    case 'e':
        err = Enumerate(
                    RemServerW,
					InstanceId,
                    &expireInfo
                    );
        goto free_buf;

    case 's':
        ZeroMemory(&myExpire,sizeof(myExpire));
        myExpire.ExpireSizeHorizon = ExpireSizeHorizon ;
        myExpire.ExpireTime = ExpireTime ;
        myExpire.Newsgroups = (PUCHAR)tempNews;
		myExpire.ExpireId = expireId ;
		myExpire.ExpirePolicy = ExpirePolicyW;

        //
        // fill the newsgroups
        //

        if ( (newsgroups == NULL) ) {
			LoadString( hModuleInstance, IDS_NEWSGROUPS_ERROR, StringBuff, sizeof( StringBuff ) ) ;
			printf( StringBuff ) ;
            usage();
            return;
		}

        p=newsgroups;
        isNull = TRUE;
        for (i=0; (i<1024) && (*p!='\0') ; i++ ) {
            if ( *p == ';' ) {
                if ( isNull ) {
					LoadString( hModuleInstance, IDS_NULLNEWSGROUP_ERROR, StringBuff, sizeof( StringBuff ) ) ;
					printf( StringBuff ) ;
                    usage();
                    return;
                }
                isNull = TRUE;
                tempNews[i] = L'\0';
            } else {
                isNull = FALSE;
                tempNews[i] = (WCHAR)*p;
            }
            p++;
        }

        if ( *p == '\0' ) {

            if ( !isNull ) {
                tempNews[i++] = L'\0';
            }
            tempNews[i++] = L'\0';
        }

        myExpire.cbNewsgroups = i * 2;

        err = SetInformation(
                    RemServerW,
					InstanceId,
                    &myExpire
                    );
        break;

    case 'g':
        err = GetInformation(
                        RemServerW,
						InstanceId,
                        expireId,
                        &expireInfo
                        );
        goto free_buf;

    default:
        usage( );
    }

    return;

free_buf:
    MIDL_user_free(expireInfo);
    return;
} // main()

DWORD
GetInformation(
    LPWSTR	Server,
	DWORD	InstanceId,
    DWORD	ExpireId,
    LPNNTP_EXPIRE_INFO	*ExpireInfo
    )
{
    DWORD err;
    err = NntpGetExpireInformation(
                            Server,
							InstanceId,
                            ExpireId,
                            ExpireInfo
                            );

    if ( err == NO_ERROR ) {
        PrintInfo(*ExpireInfo);
    } else {
		LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
		printf( StringBuff, err ) ;
    }
    return err;
}

VOID
PrintInfo(
    LPNNTP_EXPIRE_INFO	ExpireInfo
    )
{

    PWCH p;

	LoadString( hModuleInstance, IDS_DISPLAY, StringBuff, sizeof( StringBuff ) ) ;
	printf( StringBuff, ExpireInfo->ExpireId, ExpireInfo->ExpireSizeHorizon, ExpireInfo->ExpireTime ) ;

	LoadString( hModuleInstance, IDS_NEWSGROUPS, StringBuff, sizeof( StringBuff ) ) ;

    p=(PWCH)ExpireInfo->Newsgroups;
    while ( *p != L'\0') {
        printf(StringBuff, p);
        p += (wcslen(p)+1);
    }

	LoadString( hModuleInstance, IDS_EXPIRE_POLICY, StringBuff, sizeof( StringBuff ) );
	printf( StringBuff, ExpireInfo->ExpirePolicy );
}

DWORD
Enumerate(
    LPWSTR	Server,
	DWORD	InstanceId,
    LPNNTP_EXPIRE_INFO	*ExpireInfo
    )
{
    DWORD err;
    DWORD nRead = 0;
    LPNNTP_EXPIRE_INFO	expire;
    DWORD i;

    err = NntpEnumerateExpires(
                            Server,
							InstanceId,
                            &nRead,
                            ExpireInfo
                            );

    if ( err == NO_ERROR) {

        expire = *ExpireInfo;
        for (i=0; i<nRead;i++ ) {
            PrintInfo( expire );
            expire++;
        }
    } else {
		LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
		printf( StringBuff, err ) ;
    }
    return(err);
}

DWORD
SetInformation(
    LPWSTR	Server,
	DWORD	InstanceId,
    LPNNTP_EXPIRE_INFO	ExpireInfo
    )
{
    DWORD err;
	DWORD parm = 0;
    err = NntpSetExpireInformation(
                            Server,
							InstanceId,
                            ExpireInfo,
                            &parm
                            );

	if( err != NO_ERROR ) {
		LoadString( hModuleInstance, IDS_PARM_ERROR, StringBuff, sizeof( StringBuff ) ) ;
		printf( StringBuff, err, parm ) ;
	}
    return err;
}

DWORD
AddExpire(
    LPWSTR	Server,
	DWORD	InstanceId,
    LPNNTP_EXPIRE_INFO	ExpireInfo
    )
{
    DWORD err;
    DWORD parm = 0;
	DWORD expireId = 0;

	LoadString( hModuleInstance, IDS_ADD_ACTION, StringBuff, sizeof( StringBuff ) ) ;
	printf( StringBuff ) ;

    err = NntpAddExpire(
                    Server,
					InstanceId,
                    ExpireInfo,
                    &parm,
					&expireId
                    );

	ExpireInfo->ExpireId = expireId;
	PrintInfo( ExpireInfo ) ;

	LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
	printf( StringBuff, err ) ;
    if ( err == ERROR_INVALID_PARAMETER ) {
		LoadString( hModuleInstance, IDS_PARM_ERROR, StringBuff, sizeof( StringBuff ) ) ;
		printf( StringBuff, err, parm ) ;
    }
    return err;
}

DWORD
DelExpire(
    LPWSTR	Server,
	DWORD	InstanceId,
    DWORD	ExpireId
    )
{
    DWORD err;
    err = NntpDeleteExpire(
                    Server,
					InstanceId,
                    ExpireId
                    );

	if( err != NO_ERROR ) {
		LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
		printf( StringBuff, err ) ;
	}
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\rfind\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rexpire.rc
//
#define IDS_HELPTEXT                    1
#define	IDS_ARG_ERROR       			2
#define	IDS_NEWSGROUPS_ERROR			3
#define	IDS_NOT_FOUND   				4
#define	IDS_DISPLAY						7
#define	IDS_BAD_RESULTS					8
#define IDS_RPC_ERROR                   9


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\rfind\main.cpp ===
# include <windows.h>
# include <lm.h>
# include <stdio.h>
# include <stdlib.h>
# include <inetinfo.h>
# include <norminfo.h>
# include "apiutil.h"
# include "nntptype.h"
# include "nntpapi.h"
# include "resource.h"

VOID
PrintInfo(
    LPNNTP_FIND_LIST    pList,
    DWORD ResultsFound
    );


char	StringBuff[4096] ;

HINSTANCE	hModuleInstance ;

void
usage( )
{
	
	LoadString( hModuleInstance, IDS_HELPTEXT, StringBuff, sizeof( StringBuff ) ) ;
	printf( StringBuff ) ;

#if 0 
    printf("rfind\n");
    printf("\t-t <operation>\n");
    printf("\t\t f     find\n");
    printf("\t-s <server>\n");
    printf("\t-g <group prefix>\n");
    printf("\t-n <number-of-results\n>");
    return;
#endif
}

LPWSTR RemServerW = (PWCH)NULL;
WCHAR ServerName[256];
WCHAR tempNews[2048];
LPWSTR NewsgroupW = (PWCH)NULL;

void
__cdecl
main(  int argc,  char * argv[] )
{
    NET_API_STATUS err;
    CHAR op = 'f';
    INT cur = 1;
    PCHAR x;
    PCHAR p;
    DWORD i;
    PCHAR server;
    BOOL isNull;
    DWORD numResults = 10, ResultsFound = 0;
    DWORD numNews = 1;
    BOOL    NewsPresent = TRUE ;
	DWORD   InstanceId = 1;
    
    if ( argc == 1 ) {
        usage( );
        return;
    }

    while ( cur < argc ) {

        x=argv[cur++];
        if ( *(x++) == '-' ) {

            switch (*x) {
            case 'g':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }

                for( i=0; argv[cur][i] != '\0' ; i++ ) {
                    tempNews[i] = (WCHAR)argv[cur][i] ;
                }
                tempNews[i] = L'\0' ;
                NewsgroupW = tempNews;
                NewsPresent = TRUE ;
                break;

            case 'n':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                numResults = atoi(argv[cur++]);
                break;

            case 'v':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                InstanceId = atoi(argv[cur++]);
                break;

            case 's':
                if ( cur >= argc ) {
                    usage();
                    return;
                }

                server = argv[cur++];
                for (i=0; server[i] != '\0' ;i++ ) {
                    ServerName[i] = (WCHAR)server[i];
                }
                ServerName[i]=L'\0';
                RemServerW = ServerName;
                break;

            case 't':
                if( cur >= argc )   {
                    usage() ;
                    return ;
                }
                op = *(argv[cur++]);
                break;

            default:

                if( cur >= 1 )  {

                	LoadString( hModuleInstance, IDS_ARG_ERROR, 
                        StringBuff, sizeof( StringBuff ) ) ;
                	printf( StringBuff , x[-1] ) ;

                }

                usage( );
                return;
            }
        }
    }


    if( NewsgroupW == NULL ) {
       	LoadString( hModuleInstance, IDS_NEWSGROUPS_ERROR, 
                       StringBuff, sizeof( StringBuff ) ) ;
       	printf( StringBuff ) ;
        usage() ;
        return ;
    }

    LPNNTP_FIND_LIST pList = NULL;

    switch (op) {
    case 'f':

        err = NntpFindNewsgroup(    RemServerW, 
									InstanceId,
                                    NewsgroupW,
                                    numResults,
                                    &ResultsFound,
                                    &pList ) ;
        if ( err == NO_ERROR ) 
        {
            if( pList ) 
            {
                PrintInfo(pList, ResultsFound);
            }   
            else    
            {
               	LoadString( hModuleInstance, IDS_NOT_FOUND, 
                       StringBuff, sizeof( StringBuff ) ) ;
            	printf( StringBuff ) ;
            }
        } 
        else 
        {
           	LoadString( hModuleInstance, IDS_RPC_ERROR, 
                   StringBuff, sizeof( StringBuff ) ) ;
          	printf( StringBuff, err ) ;
        }

        break;

    default:
        usage( );
    }

    return;

#if 0 
free_buf:
    //MIDL_user_free(feedInfo);
    return;
#endif
} // main()

VOID
PrintInfo(
    LPNNTP_FIND_LIST    pList,
    DWORD ResultsFound
    )
{

   	LoadString( hModuleInstance, IDS_DISPLAY, 
                   StringBuff, sizeof( StringBuff ) ) ;
   	printf( StringBuff, ResultsFound ) ;

    if(ResultsFound > pList->cEntries)
    {
       	LoadString( hModuleInstance, IDS_BAD_RESULTS, 
                   StringBuff, sizeof( StringBuff ) ) ;
    	printf( StringBuff, ResultsFound , pList->cEntries ) ;
        return;
    }

    for(DWORD i=0; i<ResultsFound; i++)
    {
        printf("%S\n", (LPWSTR)pList->aFindEntry[i].lpszName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\rgroup\main.cpp ===
# include <windows.h>
# include <lm.h>
# include <stdio.h>
# include <stdlib.h>
# include <inetinfo.h>
# include <norminfo.h>
# include "apiutil.h"
# include "nntptype.h"
# include "nntpapi.h"
# include "resource.h"

DWORD
DelGroup(
    LPWSTR Server,
	DWORD  InstanceId,
    LPNNTP_NEWSGROUP_INFO	newsgroup
    );

DWORD
AddGroup(
    LPWSTR Server,
	DWORD  InstanceId,
    LPNNTP_NEWSGROUP_INFO	newsgroup
    );

DWORD
GetInformation(
    LPWSTR Server,
	DWORD  InstanceId,
    LPNNTP_NEWSGROUP_INFO	*newsgroup
    );

DWORD
SetInformation(
    LPWSTR Server,
	DWORD  InstanceId,
    LPNNTP_NEWSGROUP_INFO	newsgroup
    );

VOID
PrintInfo(
    LPNNTP_NEWSGROUP_INFO	newsgroup
    );


char	StringBuff[4096] ;

HINSTANCE	hModuleInstance = 0 ;

void
usage( )
{
	
	LoadString( hModuleInstance, IDS_HELPTEXT, StringBuff, sizeof( StringBuff ) ) ;
	printf( StringBuff ) ;

#if 0 
    printf("rgroup\n");
    printf("\t-t <operation>\n");
    printf("\t\t a      add\n");
    printf("\t\t d      del\n");
    printf("\t\t g      get\n");
    printf("\t\t s      set\n");
    printf("\t-s <server>\n");
    printf("\t-g <group>\n");
    printf("\t-m <moderator\n>");
    printf("\t-d <description>\n");
    printf("\t-r == READ ONLY\n");
    return;
#endif
}

LPWSTR RemServerW = (PWCH)NULL;
WCHAR ServerName[256];

void
__cdecl
main(  int argc,  char * argv[] )
{
    NET_API_STATUS err;
	NNTP_NEWSGROUP_INFO	newsgroup ;
	LPNNTP_NEWSGROUP_INFO	lpnewsgroup ;
    DWORD feedId = 0;
    CHAR op = ' ';
    INT cur = 1;
    PCHAR x;
    PCHAR p;
    DWORD i;
    PCHAR server;
    BOOL isNull;
    DWORD numNews = 1;
    WCHAR tempNews[2048];
    PCHAR newsgroupName = NULL;
	WCHAR tempDescription[2048] ;
	WCHAR tempModerator[2048] ;
	CHAR  tempPrettyname[70] ;
	PCHAR	Moderator = NULL ;
	PCHAR	Description = NULL ;
	PCHAR   Prettyname = NULL ;
	BOOL	ModeratorPresent = FALSE ;
	BOOL	DescriptionPresent = FALSE ;
	BOOL	PrettynamePresent = FALSE ;
	BOOL	ReadOnly = FALSE ;
	BOOL	NewsPresent = TRUE ;
	BOOL	ReadOnlyPresent = FALSE ;
	DWORD	InstanceId = 1;
	BOOL    fIsModerated = FALSE ;
	
    if ( argc == 1 ) {
        usage( );
        return;
    }

    while ( cur < argc ) {

        x=argv[cur++];
        if ( *(x++) == '-' ) {

            switch (*x) {
            case 'g':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }

				for( i=0; argv[cur][i] != '\0' ; i++ ) {
					tempNews[i] = (WCHAR)argv[cur][i] ;
				}
				tempNews[i] = '\0' ;
                newsgroupName = (PCHAR)&tempNews[0] ;
				NewsPresent = TRUE ;
                break;

			case 'm' : 
				if( cur >= argc )	{
					usage( ) ;
					return ;
				}

				for( i=0; argv[cur][i] != '\0' ; i++ ) {
					tempModerator[i] = (WCHAR)argv[cur][i] ;
				}
				tempModerator[i] = L'\0' ;
				Moderator = (PCHAR)&tempModerator[0] ;
				ModeratorPresent = TRUE ;
				break ;

            case 'd':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                server = argv[cur++];
                for (i=0; server[i] != '\0' ;i++ ) {
                    tempDescription[i] = (WCHAR)server[i] ;
                }
                tempDescription[i]=L'\0';
				Description = (PCHAR)&tempDescription[0] ;
				DescriptionPresent = TRUE ;
                break;

            case 'p':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                server = argv[cur++];
                for (i=0; server[i] != '\0' ;i++ ) {
                    tempPrettyname[i] = server[i] ;
                }
                tempPrettyname[i]='\0';
				Prettyname = (PCHAR)&tempPrettyname[0] ;
				PrettynamePresent = TRUE ;
                break;

            case 'r':
				ReadOnly = TRUE ;
				ReadOnlyPresent = TRUE ;
                break;

            case 'u':
                fIsModerated = TRUE ;
                break;

            case 'v':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                InstanceId = atoi(argv[cur++]);
                break;

            case 's':
                if ( cur >= argc ) {
                    usage();
                    return;
                }

                server = argv[cur++];
                for (i=0; server[i] != '\0' ;i++ ) {
                    ServerName[i] = (WCHAR)server[i];
                }
                ServerName[i]=L'\0';
                RemServerW = ServerName;
                break;

            case 't':
				if( cur >= argc )	{
					usage() ;
					return ;
				}
                op = *(argv[cur++]);
                break;

            default:

				if( cur >= 1 )  {

                	LoadString( hModuleInstance, IDS_BAD_ARG, StringBuff, sizeof( StringBuff ) ) ;
                	printf( StringBuff ) ;
                }

                usage( );
                return;
            }
        }
    }



    ZeroMemory(&newsgroup,sizeof(newsgroup));

	if( newsgroupName == NULL ) {
       	LoadString( hModuleInstance, IDS_NEWSGROUPS_ERROR, StringBuff, sizeof( StringBuff ) ) ;
       	printf( StringBuff ) ;
		usage() ;
		return ;
	}

	newsgroup.Newsgroup = (PUCHAR)newsgroupName ;
	newsgroup.cbNewsgroup = (wcslen( (LPWSTR)newsgroupName ) + 1 ) * sizeof(WCHAR) ;

	if( Moderator ) {

		newsgroup.Moderator = (PUCHAR)Moderator ;
		newsgroup.cbModerator = (wcslen( (LPWSTR)Moderator ) + 1 ) * sizeof( WCHAR ) ;

	}

	if( Description ) {

		newsgroup.Description = (PUCHAR)Description ;
		newsgroup.cbDescription = (wcslen( (LPWSTR)Description ) + 1 ) * sizeof( WCHAR ) ;

	}

	if( Prettyname ) {

		newsgroup.Prettyname = (PUCHAR)Prettyname ;
		newsgroup.cbPrettyname = (lstrlen( Prettyname ) + 1 ) * sizeof( CHAR ) ;

	}

	newsgroup.ReadOnly = ReadOnly ;
    newsgroup.fIsModerated = fIsModerated ;
    
    switch (op) {
    case 'a':

		err = AddGroup(	RemServerW, 
						InstanceId,
						&newsgroup ) ;
        break;

    case 'd':
        err = DelGroup(
                    RemServerW,
					InstanceId,
                    &newsgroup
                    );
        break;

    case 's':

		err = SetInformation(
					RemServerW,
					InstanceId,
					&newsgroup
					) ;
		break ;

    case 'g':
		lpnewsgroup = &newsgroup ;
        err = GetInformation(
                        RemServerW,
						InstanceId,
                        &lpnewsgroup
                        );
        break ;

    default:
        usage( );
    }

    return;

#if 0 
free_buf:
    //MIDL_user_free(feedInfo);
    return;
#endif
} // main()

DWORD
GetInformation(
    LPWSTR Server,
	DWORD  InstanceId,
	LPNNTP_NEWSGROUP_INFO*	newsgroup
    )
{
    DWORD err;
    err = NntpGetNewsgroup(
                            Server,
							InstanceId,
							newsgroup
                            );

    if ( err == NO_ERROR ) {
		if( *newsgroup )	{
			PrintInfo(*newsgroup);
		}	else	{
			printf( "newsgroup not found \n" ) ;	
           	LoadString( hModuleInstance, IDS_NOT_FOUND, StringBuff, sizeof( StringBuff ) ) ;
        	printf( StringBuff ) ;
		}
    } else {
       	LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
      	printf( StringBuff, err ) ;
    }
    return err;
}

VOID
PrintInfo(
    LPNNTP_NEWSGROUP_INFO	newsgroup
    )
{

    PWCH p;

    char    ReadOnlyBuff[512] ;
    if( newsgroup->ReadOnly ) {
      	LoadString( hModuleInstance, IDS_READONLY, ReadOnlyBuff, sizeof( ReadOnlyBuff ) ) ;
    }   else    {
      	LoadString( hModuleInstance, IDS_READWRITE, ReadOnlyBuff, sizeof( ReadOnlyBuff ) ) ;
    }
        
  	LoadString( hModuleInstance, IDS_DISPLAY, StringBuff, sizeof( StringBuff ) ) ;
   	printf( StringBuff, newsgroup->Newsgroup, ReadOnlyBuff, 
            newsgroup->Description, newsgroup->Moderator, newsgroup->Prettyname ) ;
}

DWORD
SetInformation(
    LPWSTR Server,
	DWORD  InstanceId,
	LPNNTP_NEWSGROUP_INFO	newsgroup
    )
{
    DWORD err;
    err = NntpSetNewsgroup(
                            Server,
							InstanceId,
							newsgroup
                            );

    if( err != NO_ERROR ) {
       	LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
      	printf( StringBuff, err ) ;
    }
    return err;
}

DWORD
AddGroup(
    LPWSTR Server,
	DWORD  InstanceId,
    LPNNTP_NEWSGROUP_INFO	newsgroup
    )
{
    DWORD err;
    DWORD parm = 0;

	printf( "Attempting to add group : \n" ) ;
	PrintInfo( newsgroup ) ;

    err = NntpCreateNewsgroup(
                    Server,
					InstanceId,
					newsgroup
                    );

    if( err != NO_ERROR ) {
       	LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
      	printf( StringBuff, err ) ;
        if ( err == ERROR_INVALID_PARAMETER ) {
           	LoadString( hModuleInstance, IDS_PARM_ERROR, StringBuff, sizeof( StringBuff ) ) ;
           	printf( StringBuff, parm ) ;
        }
    }
    return err;
}

DWORD
DelGroup(
    LPWSTR Server,
	DWORD  InstanceId,
    LPNNTP_NEWSGROUP_INFO	newsgroup
    )
{
    DWORD err;
    err = NntpDeleteNewsgroup(
                    Server,
					InstanceId,
                    newsgroup
                    );

    if( err != NO_ERROR ) {
       	LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
      	printf( StringBuff, err ) ;
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\rgroup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rexpire.rc
//
#define IDS_HELPTEXT                    1
#define IDS_BAD_ARG                     2
#define IDS_NEWSGROUPS_ERROR            3
#define IDS_NOT_FOUND                   4
#define IDS_NULLNEWSGROUP_ERROR         5
#define IDS_RPC_ERROR                   6
#define IDS_PARM_ERROR                  7
#define IDS_DISPLAY                     8
#define IDS_READONLY                    9
#define IDS_READWRITE                   10


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\rfeed\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rexpire.rc
//
#define IDS_HELPTEXT                    1
#define	IDS_NEWSGROUPS_ERROR			2
#define	IDS_NULLNEWSGROUP_ERROR			3
#define	IDS_DELETE_ACTION				4
#define	IDS_RPC_ERROR					5
#define	IDS_PARM_ERROR					6
#define	IDS_DISPLAY						7
#define	IDS_NEWSGROUPS					8
#define	IDS_ADD_ACTION					9
#define IDS_UNRECOGNIZED_ARG            10
#define IDS_FEED_SERVER_SPEC            11
#define IDS_WARN_PULL_DATE              12
#define IDS_ACCOUNTANDPASS              15
#define IDS_ENABLE_ACTION               17
#define IDS_DISABLE_ACTION              18
#define IDS_CANT_SET_PULL_TIME          19
#define IDS_INVALIDDATE                 20
#define IDS_SYSTEMTIMEFAIL              21
#define	IDS_PORT						22
#define IDS_FEEDPAIR					23

#define IDS_PULL                        30
#define IDS_TO_MASTER                   31
#define IDS_TO_SLAVE                    32
#define IDS_TO_PEER                     33
#define IDS_FROM_MASTER                 34
#define IDS_FROM_PEER                   35
#define IDS_FROM_SLAVE                  36

#define IDS_NULL                        37

#define IDS_ENABLED                     40
#define IDS_DISABLED                    41

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\rfeed\main.cpp ===
# include <windows.h>
# include <lm.h>
# include <stdio.h>
# include <stdlib.h>
# include <inetinfo.h>
# include <norminfo.h>
# include "apiutil.h"
# include "nntptype.h"
# include "nntpapi.h"
# include "resource.h"

DWORD
DelFeed(
    LPWSTR Server,
	DWORD InstanceId,
    DWORD FeedId
    );

DWORD
AddFeed(
    LPWSTR Server,
	DWORD InstanceId,
    LPNNTP_FEED_INFO FeedInfo
    );

DWORD
GetInformation(
    LPWSTR Server,
	DWORD InstanceId,
    DWORD FeedId,
    LPNNTP_FEED_INFO *FeedInfo
    );

DWORD
Enumerate(
    LPWSTR Server,
	DWORD InstanceId,
    LPNNTP_FEED_INFO *FeedInfo
    );

DWORD
SetInformation(
    LPWSTR Server,
	DWORD InstanceId,
    LPNNTP_FEED_INFO FeedInfo
    );

VOID
PrintInfo(
    LPNNTP_FEED_INFO FeedInfo
    );

BOOL
ConvertToFiletime(
	char* pszTime,
	FILETIME* pftFiletime
	);

//
// defaults
//

FEED_TYPE FeedType = 0;
DWORD FeedInterval = 32;
LPWSTR RemServerW = (PWCH)NULL;
WCHAR ServerName[256];
WCHAR FeedServer[2048];
BOOL autoCreate = FALSE;
BOOL fAllowControlMessages = TRUE;

char	*rgszType[] =		{
	"tm",
	"ts",
	"tp",
	"fm",
	"fs",
	"fp",
	"p"
} ;

DWORD	rgFeedType[] = {
	FEED_TYPE_MASTER | FEED_TYPE_PUSH,
	FEED_TYPE_SLAVE | FEED_TYPE_PUSH,
	FEED_TYPE_PEER | FEED_TYPE_PUSH,
	FEED_TYPE_MASTER | FEED_TYPE_PASSIVE,
	FEED_TYPE_SLAVE | FEED_TYPE_PASSIVE,
	FEED_TYPE_PEER | FEED_TYPE_PASSIVE,
	FEED_TYPE_PULL
} ;

FEED_TYPE
TypeFromString( LPSTR	lpstr ) {

	for( int i=0; i<sizeof(rgszType) / sizeof( char*); i++ ) {
		if( lstrcmpi( rgszType[i], lpstr ) == 0 ) {
			return	rgFeedType[ i ] ;
		}
	}
	return	(FEED_TYPE) 0xFFFFFFFF ;
}
	


char	StringBuff[4096] ;

HINSTANCE	hModuleInstance ;

void
usage( )
{
	
	LoadString( hModuleInstance, IDS_HELPTEXT, StringBuff, sizeof( StringBuff ) ) ;
	printf( StringBuff ) ;

#if 0 
    printf("rfeed\n");
    printf("\t-t <operation>\n");
    printf("\t\t a      add\n");
    printf("\t\t d      del\n");
    printf("\t\t g      get\n");
    printf("\t\t s      set\n");
    printf("\t\t e      enum\n");
	printf("\t\t p		pause (disable)\n");
	printf("\t\t u		unpause (enable)\n");
    printf("\t-s <server>\n");
    printf("\t-i <feed id>\n");
    printf("\t-f <tm=tomaster>,<ts=toslave>,<tp=topeer>,<fm=frommaster>,<fs=fromslave>,<fp=frompeer>,<p=pull>\n");
    printf("\t-x <feed interval>\n");
    printf("\t-r <feed server>\n");
    printf("\t-n <newsgroups>\n");
    printf("\t-d <distributions>\n");
	printf("\t-u <uucpname> (default=server)\n") ;
	printf("\t-p <temp directory path>\n");
	printf("\t-m <Max Connection Attempts> default=INFINITE\n");
	printf("\t-a <authinfo account>\n") ;
	printf("\t-b <authinfo password>\n" ) ;
    printf("\t-c        set CreateAutomatically\n");
    printf("\t-z <Disable control messages>\n");
	printf("\t-o <Pull feed date in yyyymmdd>\n");
#endif
    return;
}

void
__cdecl
main(  int argc,  char * argv[] )
{
    NET_API_STATUS err;
    LPNNTP_FEED_INFO feedInfo;
    NNTP_FEED_INFO myFeed;
    DWORD feedId = 0;
    CHAR op = ' ';
    INT cur = 1;
    PCHAR x;
    PCHAR p;
    DWORD i;
    PCHAR server;
    BOOL isNull;
    DWORD numNews = 1;
    DWORD numDist = 1;
    WCHAR tempNews[2048];
    WCHAR tempDist[2048];
    PCHAR newsgroups = NULL;
    PCHAR dists = NULL;
	PCHAR uucpname = NULL;
	DWORD	dwAuthentication = AUTH_PROTOCOL_NONE ;
	PCHAR	account = NULL ;
	PCHAR	password = NULL ;
	PCHAR	feeddir = NULL ;
	WCHAR	tempAccount[2048];
	WCHAR	tempPassword[2048] ;
	WCHAR	tempDir[2048] ;
	WCHAR	tempUucp[2048] ;
	DWORD	MaxConnectAttempts = 0 ;
	BOOL	FeedIdPresent = FALSE ;
	BOOL	NewsPresent = FALSE ;
	BOOL	DistPresent = FALSE ;
	BOOL	MaxConnectPresent = FALSE ;
	BOOL	FeedServerPresent = FALSE ;
	BOOL	IntervalPresent = FALSE ;
	BOOL	UucpNamePresent = FALSE ;
	BOOL	TempDirPresent = FALSE ;
	BOOL	SecurityPresent = FALSE ;	
	BOOL	AutoCreatePresent = FALSE ;
	BOOL	AllowControlPresent = FALSE ;
	DWORD	OutgoingPort = 119 ;
	DWORD   FeedPairId = 0;
	BOOL	PullRequestTimePresent = FALSE;
	FILETIME	ftPullRequestTime;
	DWORD	InstanceId = 1;

    if ( argc == 1 ) {
        usage( );
        return;
    }

    //
    // def feed server
    //

    // wcscpy(FeedServer,L"157.55.99.99");

    while ( cur < argc ) {

        x=argv[cur++];
        if ( *(x++) == '-' ) {

            switch (*x) {
            case 'i':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                feedId = atoi(argv[cur++]);
				FeedIdPresent = TRUE ;
                break;

            case 'v':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                InstanceId = atoi(argv[cur++]);
                break;

            case 'q':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                OutgoingPort = atoi(argv[cur++]);
                break;

            case 'y':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                FeedPairId = atoi(argv[cur++]);
                break;

            case 'n':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }

				if( NewsPresent ) {
					usage();
					return;
				}

                newsgroups = argv[cur++];
				NewsPresent = TRUE ;
                break;

			case 'u' : 
				if( cur >= argc )	{
					usage( ) ;
					return ;
				}
				UucpNamePresent = TRUE ;
				for( i=0; argv[cur][i] != '\0' ; i++ ) {
					tempUucp[i] = (WCHAR)argv[cur][i] ;
				}
				tempUucp[i] = '\0' ;
				uucpname = (PCHAR)&tempUucp[0] ;
				break ;

            case 'r':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                server = argv[cur++];
                for (i=0; server[i] != '\0' ;i++ ) {
                    FeedServer[i] = (WCHAR)server[i];
                }
                FeedServer[i]=L'\0';
				FeedServerPresent = TRUE ;
                break;

#if 0 
            case 'd':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }

				if( DistPresent ) {
					usage();
					return;
				}

                dists = argv[cur++];
				DistPresent = TRUE ;
                break;
#endif

			case 'm' : 
                if ( cur > argc ) {
                    usage( );
                    return;
                }
                MaxConnectAttempts = atoi(argv[cur++]);
				MaxConnectPresent = TRUE ;
                break;

            case 'x':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                FeedInterval = atoi(argv[cur++]);
				IntervalPresent = TRUE ;
                break;

            case 'o':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }

				if( !ConvertToFiletime( argv[cur++], &ftPullRequestTime ) )
					return;

				PullRequestTimePresent = TRUE ;
                break;

            case 'f':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                FeedType = TypeFromString( argv[cur++] ) ;
                break;

            case 'c':
                autoCreate = TRUE;
				AutoCreatePresent = TRUE ;
                break;

            case 'd':
                autoCreate = FALSE ;
				AutoCreatePresent = TRUE ;
                break;

            case 'z':
                fAllowControlMessages = FALSE;
				AllowControlPresent = TRUE ;
                break;

			case 'a' : 
				dwAuthentication = AUTH_PROTOCOL_CLEAR ;
				if( cur >= argc ) {
					usage() ;
					return ;
				}
				account = argv[cur++] ;
				SecurityPresent = TRUE ;
				break ;

			case 'b' : 
				dwAuthentication = AUTH_PROTOCOL_CLEAR ;
				if( cur >= argc ) {
					usage() ;
					return	 ;
				}
				password = argv[cur++] ;
				SecurityPresent = TRUE ;
				break ;

            case 's':
                if ( cur >= argc ) {
                    usage();
                    return;
                }

                server = argv[cur++];
                for (i=0; server[i] != '\0' ;i++ ) {
                    ServerName[i] = (WCHAR)server[i];
                }
                ServerName[i]=L'\0';
                RemServerW = ServerName;
                break;

			case 'p' : 
				if( cur >= argc ) {
					usage() ;
					return	;
				}
				for( i=0; argv[cur][i] != '\0' ; i++ ) {
					tempDir[i] = (WCHAR)argv[cur][i] ;
				}
				tempDir[i] = '\0' ;
				feeddir = (PCHAR)&tempDir[0] ;
				TempDirPresent = TRUE ;
				break ;


            case 't':
				if( cur >= argc )	{
					usage() ;
					return ;
				}
                op = *(argv[cur++]);
                break;
            default:

				if( cur >= 1 )  {
                	LoadString( hModuleInstance, IDS_UNRECOGNIZED_ARG, 
                        StringBuff, sizeof( StringBuff ) ) ;
                	printf( StringBuff ) ;
                }

                usage( );
                return;
            }
        }
    }


	BOOL	Enable = TRUE ;

    switch (op) {
    case 'a':

        if ( !FeedServerPresent ) {
        	LoadString( hModuleInstance, IDS_FEED_SERVER_SPEC, StringBuff, sizeof( StringBuff ) ) ;
        	printf( StringBuff ) ;
            usage();
            return;
        }

		if( PullRequestTimePresent ) {
			if( FEED_TYPE_PULL != FeedType ) {
            	LoadString( hModuleInstance, IDS_WARN_PULL_DATE, 
                    StringBuff, sizeof( StringBuff ) ) ;
            	printf( StringBuff ) ;
				PullRequestTimePresent = FALSE;
			}
		}

        ZeroMemory(&myFeed,sizeof(NNTP_FEED_INFO));
        myFeed.ServerName = FeedServer;
        myFeed.FeedId = 0;
        myFeed.FeedType = FeedType;
        myFeed.FeedInterval = FeedInterval;
        myFeed.Newsgroups = tempNews;
        myFeed.Distribution = tempDist;
        myFeed.AutoCreate = autoCreate;
        myFeed.fAllowControlMessages = fAllowControlMessages;
		myFeed.OutgoingPort = OutgoingPort;
		myFeed.FeedPairId = FeedPairId;

		myFeed.MaxConnectAttempts = MaxConnectAttempts ;

		myFeed.cbAccountName = 0 ;
		myFeed.NntpAccountName = 0 ;
		myFeed.cbPassword = 0 ;
		myFeed.NntpPassword = 0 ;

		myFeed.Enabled = TRUE ;

		// set pull request time for pull feeds
		if( PullRequestTimePresent ) {
			myFeed.PullRequestTime = ftPullRequestTime;
		}

        //
        // fill the newsgroups
        //

        if ( (newsgroups == NULL) ) {
        	LoadString( hModuleInstance, IDS_NEWSGROUPS_ERROR, StringBuff, sizeof( StringBuff ) ) ;
        	printf( StringBuff ) ;
            usage();
            return;
        }

        p=newsgroups;
        isNull = TRUE;
        for (i=0; (i<1024) && (*p!='\0') ; i++ ) {
            if ( *p == ';' ) {
                if ( isNull ) {
                	LoadString( hModuleInstance, IDS_NULLNEWSGROUP_ERROR, 
                        StringBuff, sizeof( StringBuff ) ) ;
                	printf( StringBuff ) ;
                    usage();
                    return;
                }
                isNull = TRUE;
                tempNews[i] = L'\0';
            } else {
                isNull = FALSE;
                tempNews[i] = (WCHAR)*p;
            }
            p++;
        }

        if ( *p == '\0' ) {

            if ( !isNull ) {
                tempNews[i++] = L'\0';
            }
            tempNews[i++] = L'\0';
        }

        myFeed.cbNewsgroups = i * 2;

        i = 0 ;
        isNull = FALSE ;
        if( dists == 0 ) {
            dists = "world" ;
        }

        if( dists != 0 ) {
	        p=dists;
	        isNull = TRUE;
	        for (i=0; (i<1024) && (*p!='\0') ; i++ ) {
	            if ( *p == ';' ) {
	                if ( isNull ) {
	                    usage();
	                    return;
	                }
	                isNull = TRUE;
	                tempDist[i] = L'\0';
	            } else {
	                isNull = FALSE;
	                tempDist[i] = (WCHAR)*p;
	            }
	            p++;
	        }
        }

        if ( p==0 ||  *p == '\0' ) {

            if ( !isNull ) {
                tempDist[i++] = L'\0';
            }
            tempDist[i++] = L'\0';
        }

        myFeed.cbDistribution = i * 2;


		if( dwAuthentication == AUTH_PROTOCOL_NONE ) {

		}	else if( (dwAuthentication == AUTH_PROTOCOL_CLEAR &&
			(account == 0 || password == 0)) ) {

        	LoadString( hModuleInstance, IDS_ACCOUNTANDPASS, StringBuff, sizeof( StringBuff ) ) ;
        	printf( StringBuff ) ;
            usage();
            return;
        }	else	{

			myFeed.AuthenticationSecurityType = dwAuthentication ;

			myFeed.NntpAccountName = tempAccount ;
			myFeed.NntpPassword = tempPassword ;

			p=account;
			isNull = TRUE;
			for (i=0; (i<1024) && (*p!='\0') ; i++ ) {
				if ( *p == ';' ) {
					if ( isNull ) {
						usage();
						return;
					}
					isNull = TRUE;
					tempAccount[i] = L'\0';
				} else {
					isNull = FALSE;
					tempAccount[i] = (WCHAR)*p;
				}
				p++;
			}

			if ( *p == '\0' ) {

				if ( !isNull ) {
					tempAccount[i++] = L'\0';
				}
				tempAccount[i++] = L'\0';
			}

			myFeed.cbAccountName = i * 2;

			p=password;
			isNull = TRUE;
			for (i=0; (i<1024) && (*p!='\0') ; i++ ) {
				if ( *p == ';' ) {
					if ( isNull ) {
						usage();
						return;
					}
					isNull = TRUE;
					tempPassword[i] = L'\0';
				} else {
					isNull = FALSE;
					tempPassword[i] = (WCHAR)*p;
				}
				p++;
			}

			if ( *p == '\0' ) {

				if ( !isNull ) {
					tempPassword[i++] = L'\0';
				}
				tempPassword[i++] = L'\0';
			}

			myFeed.cbPassword = i * 2;
			//printf("len %d\n", myFeed.cbDistribution);
		}


		if( feeddir != 0 ) {

			myFeed.cbFeedTempDirectory = (wcslen( tempDir ) + 1 ) * sizeof(WCHAR) ;
			myFeed.FeedTempDirectory = tempDir ;
		}

		if( uucpname != 0 ) {

			myFeed.cbUucpName = (wcslen( tempUucp ) + 1 ) * sizeof( WCHAR ) ;
			myFeed.UucpName = tempUucp ;

		}

        err = AddFeed(
                    RemServerW,
					InstanceId,
                    &myFeed
                    );
        break;

    case 'd':
    	LoadString( hModuleInstance, IDS_DELETE_ACTION, StringBuff, sizeof( StringBuff ) ) ;
    	printf( StringBuff, feedId ) ;
        err = DelFeed(
                    RemServerW,
					InstanceId,
                    feedId
                    );
        break;

    case 'e':
        err = Enumerate(
                    RemServerW,
					InstanceId,
                    &feedInfo
                    );
        goto free_buf;

    case 's':

		if( PullRequestTimePresent ) {
        	LoadString( hModuleInstance,IDS_CANT_SET_PULL_TIME, StringBuff, sizeof( StringBuff ) ) ;
        	printf( StringBuff ) ;
			return;
		}

		ZeroMemory( &myFeed, sizeof( myFeed ) ) ;

		if( FeedServerPresent ) {
			myFeed.ServerName = FeedServer ;
		}	else	{
			myFeed.ServerName = FEED_STRINGS_NOCHANGE ;
		}

		myFeed.FeedId = feedId ;
		myFeed.FeedType = FEED_FEEDTYPE_NOCHANGE ;

		myFeed.StartTime.dwHighDateTime = FEED_STARTTIME_NOCHANGE ;
		myFeed.AutoCreate = FEED_AUTOCREATE_NOCHANGE ;
        myFeed.fAllowControlMessages = fAllowControlMessages;
		myFeed.FeedInterval = FEED_FEEDINTERVAL_NOCHANGE ;
		myFeed.MaxConnectAttempts = FEED_MAXCONNECTS_NOCHANGE ;
		myFeed.OutgoingPort = OutgoingPort ;
		myFeed.FeedPairId = FeedPairId ;

        if( MaxConnectPresent ) 
            myFeed.MaxConnectAttempts = MaxConnectAttempts ;

        if( AutoCreatePresent ) 
            myFeed.AutoCreate = autoCreate ;

		if( !IntervalPresent ) {
			myFeed.FeedInterval = FEED_FEEDINTERVAL_NOCHANGE ;
		}	else	{
			myFeed.FeedInterval = FeedInterval ;
		}

		if( NewsPresent ) {
			myFeed.Newsgroups = tempNews ;
			p=newsgroups;
			isNull = TRUE;
			for (i=0; (i<1024) && (*p!='\0') ; i++ ) {
				if ( *p == ';' ) {
					if ( isNull ) {
                    	LoadString( hModuleInstance, IDS_NULLNEWSGROUP_ERROR, 
                            StringBuff, sizeof( StringBuff ) ) ;
	                    printf( StringBuff ) ;
						usage();
						return;
					}
					isNull = TRUE;
					tempNews[i] = L'\0';
				} else {
					isNull = FALSE;
					tempNews[i] = (WCHAR)*p;
				}
				p++;
			}

			if ( *p == '\0' ) {

				if ( !isNull ) {
					tempNews[i++] = L'\0';
				}
				tempNews[i++] = L'\0';
			}

			myFeed.cbNewsgroups = i * 2;
		}	else	{
			myFeed.cbNewsgroups = 0 ;
			myFeed.Newsgroups = FEED_STRINGS_NOCHANGE ;
		}

		if( DistPresent ) {
			myFeed.Distribution = tempDist ;				
			p=dists;
			isNull = TRUE;
			for (i=0; (i<1024) && (*p!='\0') ; i++ ) {
				if ( *p == ';' ) {
					if ( isNull ) {
						usage();
						return;
					}
					isNull = TRUE;
					tempDist[i] = L'\0';
				} else {
					isNull = FALSE;
					tempDist[i] = (WCHAR)*p;
				}
				p++;
			}

			if ( *p == '\0' ) {

				if ( !isNull ) {
					tempDist[i++] = L'\0';
				}
				tempDist[i++] = L'\0';
			}

			myFeed.cbDistribution = i * 2;
		}	else	{
			myFeed.cbDistribution = 0 ;
			myFeed.Distribution = FEED_STRINGS_NOCHANGE ;
		}

		if( TempDirPresent ) {
			if( feeddir != 0 ) {
				myFeed.cbFeedTempDirectory = (wcslen( tempDir ) + 1 ) * sizeof(WCHAR) ;
				myFeed.FeedTempDirectory = tempDir ;
			}
		}

		if( UucpNamePresent ) {
			if( uucpname != 0 ) {

				myFeed.cbUucpName = (wcslen( tempUucp ) + 1 ) * sizeof( WCHAR ) ;
				myFeed.UucpName = tempUucp ;

			}
		}

		if( dwAuthentication == AUTH_PROTOCOL_NONE ) {

		}	else if( (dwAuthentication == AUTH_PROTOCOL_CLEAR &&
			(account == 0 || password == 0)) ) {

           	LoadString( hModuleInstance, IDS_ACCOUNTANDPASS, StringBuff, sizeof( StringBuff ) ) ;
           	printf( StringBuff ) ;
            usage();

            return;
        }	else	{

			myFeed.AuthenticationSecurityType = dwAuthentication ;

			myFeed.NntpAccountName = tempAccount ;
			myFeed.NntpPassword = tempPassword ;

			p=account;
			isNull = TRUE;
			for (i=0; (i<1024) && (*p!='\0') ; i++ ) {
				if ( *p == ';' ) {
					if ( isNull ) {
						usage();
						return;
					}
					isNull = TRUE;
					tempAccount[i] = L'\0';
				} else {
					isNull = FALSE;
					tempAccount[i] = (WCHAR)*p;
				}
				p++;
			}

			if ( *p == '\0' ) {

				if ( !isNull ) {
					tempAccount[i++] = L'\0';
				}
				tempAccount[i++] = L'\0';
			}

			myFeed.cbAccountName = i * 2;

			p=password;
			isNull = TRUE;
			for (i=0; (i<1024) && (*p!='\0') ; i++ ) {
				if ( *p == ';' ) {
					if ( isNull ) {
						usage();
						return;
					}
					isNull = TRUE;
					tempPassword[i] = L'\0';
				} else {
					isNull = FALSE;
					tempPassword[i] = (WCHAR)*p;
				}
				p++;
			}

			if ( *p == '\0' ) {

				if ( !isNull ) {
					tempPassword[i++] = L'\0';
				}
				tempPassword[i++] = L'\0';
			}

			myFeed.cbPassword = i * 2;
		}

		
		err = SetInformation(
						RemServerW,
						InstanceId,
						&myFeed
						);		
        break;

    case 'g':
        err = GetInformation(
                        RemServerW,
						InstanceId,
                        feedId,
                        &feedInfo
                        );
        goto free_buf;

	case	'p' : 

		Enable = FALSE ;

		//	fall through 

	case	'u' : 

		// default - Enable == FALSE !!

		if( !FeedIdPresent ) {
			usage() ;
			return ;
		}

		FILETIME	filetime ;

		err = NntpEnableFeed(
					RemServerW, 
					InstanceId,
					feedId,
					Enable,
					FALSE,
					filetime
					) ;

		if( err == 0 ) {

            if( Enable ) {

        	    LoadString( hModuleInstance, IDS_ENABLE_ACTION, 
                    StringBuff, sizeof( StringBuff ) ) ;

            }   else    {

        	    LoadString( hModuleInstance, IDS_DISABLE_ACTION, 
                    StringBuff, sizeof( StringBuff ) ) ;

            }
            printf( StringBuff, feedId  ) ;
		}	else	{
        	LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
        	printf( StringBuff, err ) ;
		}
		break ;

    default:
        usage( );
    }

    return;

free_buf:
    MIDL_user_free(feedInfo);
    return;
} // main()

DWORD
GetInformation(
    LPWSTR	Server,
	DWORD	InstanceId,
    DWORD FeedId,
    LPNNTP_FEED_INFO *FeedInfo
    )
{
    DWORD err;
    err = NntpGetFeedInformation(
                            Server,
							InstanceId,
                            FeedId,
                            FeedInfo
                            );

    if ( err == NO_ERROR ) {
        PrintInfo(*FeedInfo);
    } else {
       	LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
       	printf( StringBuff, err ) ;
    }
    return err;
}

VOID
PrintInfo(
    LPNNTP_FEED_INFO FeedInfo
    )
{

    PWCH p;

	char	*lpstrFeedType = 0 ;

    DWORD   dwIDSType = IDS_PULL ;
    char    TypeBuff[512] ;
    char    EnableBuff[256] ;
    char    NullBuff[256] ;
    char    CreateAutoBuff[256] ;
    char    ProcessControlBuff[256] ;

	if( FeedInfo->FeedType == 0 ) {
        dwIDSType = IDS_PULL ;
	}	else	{
        if( FEED_IS_PASSIVE( FeedInfo->FeedType ) ) {
			if( FEED_IS_MASTER( FeedInfo->FeedType ) ) {
                dwIDSType = IDS_FROM_MASTER ;
			}	else if( FEED_IS_SLAVE( FeedInfo->FeedType ) ) {
			    dwIDSType = IDS_FROM_SLAVE ;
			}	else	{
			    dwIDSType = IDS_FROM_PEER ;	
			}
        }   else    {
			if( FEED_IS_MASTER( FeedInfo->FeedType ) ) {
                dwIDSType = IDS_TO_MASTER ;
			}	else if( FEED_IS_SLAVE( FeedInfo->FeedType ) ) {
			    dwIDSType = IDS_TO_SLAVE ;
			}	else	{
			    dwIDSType = IDS_TO_PEER ;	
			}
        }
	}

  	LoadString( hModuleInstance, dwIDSType, TypeBuff, sizeof( StringBuff ) ) ;
    LoadString( hModuleInstance, IDS_NULL, NullBuff, sizeof( NullBuff ) ) ;

    if( FeedInfo->Enabled ) {
        LoadString( hModuleInstance, IDS_ENABLED, EnableBuff, sizeof( EnableBuff ) ) ;
    }   else    {
        LoadString( hModuleInstance, IDS_DISABLED, EnableBuff, sizeof( EnableBuff ) ) ;
    }

    if( FeedInfo->AutoCreate ) {
        LoadString( hModuleInstance, IDS_ENABLED, CreateAutoBuff, sizeof( EnableBuff ) ) ;
    }   else    {
        LoadString( hModuleInstance, IDS_DISABLED, CreateAutoBuff, sizeof( EnableBuff ) ) ;
    }

    if( FeedInfo->fAllowControlMessages ) {
        LoadString( hModuleInstance, IDS_ENABLED, ProcessControlBuff,sizeof(EnableBuff)) ;
    }   else    {
        LoadString( hModuleInstance, IDS_DISABLED, ProcessControlBuff,sizeof(EnableBuff)) ;
    }
	
	SYSTEMTIME	systime ;
	FileTimeToSystemTime( &FeedInfo->NextActiveTime, &systime ) ;

		
    SYSTEMTIME  pulltime ;
    ZeroMemory( &pulltime, sizeof( pulltime ) ) ;
	if( FEED_IS_PULL( FeedInfo->FeedType ) )
	{
		FileTimeToSystemTime( &FeedInfo->PullRequestTime, &pulltime ) ;
	}

   	LoadString( hModuleInstance, IDS_DISPLAY, StringBuff, sizeof( StringBuff ) ) ;
  	printf( StringBuff,  FeedInfo->ServerName,
                        FeedInfo->FeedId,  
                        TypeBuff, 
                        EnableBuff, 
						FeedInfo->FeedInterval,
                        systime.wYear, systime.wMonth, systime.wDay, 
                        systime.wHour, systime.wMinute, systime.wSecond,
                        pulltime.wYear, pulltime.wMonth, pulltime.wDay, 
                        pulltime.wHour, pulltime.wMinute, pulltime.wSecond,
                        FeedInfo->UucpName,
                        FeedInfo->FeedTempDirectory,
                        FeedInfo->MaxConnectAttempts, 
                        FeedInfo->NntpAccountName,
                        FeedInfo->NntpPassword,
                        CreateAutoBuff,
                        ProcessControlBuff 
                        ) ;

    if( !FEED_IS_PASSIVE( FeedInfo->FeedType ) ) {
   		LoadString( hModuleInstance, IDS_PORT, StringBuff, sizeof( StringBuff ) ) ;
		printf( StringBuff, FeedInfo->OutgoingPort );
	}

	LoadString( hModuleInstance, IDS_FEEDPAIR, StringBuff, sizeof( StringBuff ) ) ;
	printf( StringBuff, FeedInfo->FeedPairId );

	LoadString( hModuleInstance, IDS_NEWSGROUPS, StringBuff, sizeof( StringBuff ) ) ;

    p=(PWCH)FeedInfo->Newsgroups;
    while ( *p != L'\0') {
        printf(StringBuff, p);
        p += (wcslen(p)+1);
    }
}

DWORD
Enumerate(
    LPWSTR	Server,
	DWORD	InstanceId,
    LPNNTP_FEED_INFO *FeedInfo
    )
{
    DWORD err;
    DWORD nRead = 0;
    LPNNTP_FEED_INFO feed;
    DWORD i;

    err = NntpEnumerateFeeds(
                            Server,
							InstanceId,
                            &nRead,
                            FeedInfo
                            );

    if ( err == NO_ERROR) {

        feed = *FeedInfo;
        for (i=0; i<nRead;i++ ) {
            PrintInfo( feed );
            feed++;
        }
    } else {

       	LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
       	printf( StringBuff, err ) ;
    }
    return(err);
}

DWORD
SetInformation(
    LPWSTR	Server,
	DWORD	InstanceId,
    LPNNTP_FEED_INFO FeedInfo
    )
{
    DWORD err;
    err = NntpSetFeedInformation(
                            Server,
							InstanceId,
                            FeedInfo,
                            NULL
                            );

    if( err != NO_ERROR ) {
       	LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
       	printf( StringBuff, err ) ;
    }
    return err;
}

DWORD
AddFeed(
    LPWSTR	Server,
	DWORD	InstanceId,
    LPNNTP_FEED_INFO FeedInfo
    )
{
    DWORD err;
    DWORD parm = 0;
	DWORD feedId = 0;

    err = NntpAddFeed(
                    Server,
					InstanceId,
                    FeedInfo,
                    &parm,
					&feedId
                    );

	FeedInfo->FeedId = feedId;
	PrintInfo( FeedInfo ) ;

    if( err != NO_ERROR ) {
       	LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
       	printf( StringBuff, err ) ;
        if ( err == ERROR_INVALID_PARAMETER ) {
    	    LoadString( hModuleInstance, IDS_PARM_ERROR, StringBuff, sizeof( StringBuff ) ) ;
        	printf( StringBuff, parm ) ;
        }
    }
    return err;
}

DWORD
DelFeed(
    LPWSTR	Server,
	DWORD	InstanceId,
    DWORD	FeedId
    )
{
    DWORD err;
    err = NntpDeleteFeed(
                    Server,
					InstanceId,
                    FeedId
                    );

    if( err != NO_ERROR ) {
       	LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
       	printf( StringBuff, err ) ;
    }

    return err;
}

/* convert a 8 digit string in yyyymmdd format to a filetime struct */
BOOL
ConvertToFiletime(
	char* pszTime,
	FILETIME* pftFiletime
	)
{
	SYSTEMTIME stTime;
	char szYear [5], szMonth [3], szDay [3];

	// validate args
	DWORD len = lstrlen( pszTime );

	// len should be 8
	if( len != 8 )
	{
    	LoadString( hModuleInstance, IDS_INVALIDDATE, StringBuff, sizeof( StringBuff ) ) ;
	    printf( StringBuff, pszTime ) ;
		return FALSE;
	}

	// all 8 chars should be digits
	for(DWORD i=0; i<len; i++)
	{
		if( !isdigit( pszTime[i] ) )
		{
    	    LoadString( hModuleInstance, IDS_INVALIDDATE, StringBuff, sizeof( StringBuff ) ) ;
    	    printf( StringBuff, pszTime ) ;
			return FALSE;
		}
	}

	// extract the char fields
	memcpy( szYear, pszTime, 4 );
	szYear [4] = '\0';

	memcpy( szMonth, pszTime+4, 2 );
	szMonth [2] = '\0';

	memcpy( szDay, pszTime+4+2, 2 );
	szDay [2] = '\0';

	stTime.wYear = atoi( szYear );
	stTime.wMonth = atoi( szMonth );
	stTime.wDay = atoi( szDay );
	stTime.wHour = 0;
	stTime.wMinute = 0;
	stTime.wSecond = 0;
	stTime.wMilliseconds = 0;

	if( !SystemTimeToFileTime( (CONST SYSTEMTIME*) &stTime, pftFiletime ) )
	{
    	LoadString( hModuleInstance, IDS_SYSTEMTIMEFAIL, StringBuff, sizeof( StringBuff ) ) ;
    	printf( StringBuff, GetLastError() ) ;
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\rserver\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rexpire.rc
//
#define IDS_HELPTEXT                    1
#define IDS_BAD_ARG                     2
#define IDS_NEWSGROUPS_ERROR            3
#define IDS_NOT_FOUND                   4
#define IDS_NULLNEWSGROUP_ERROR         5
#define IDS_RPC_ERROR                   6
#define IDS_PARM_ERROR                  7
#define IDS_DISPLAY                     8
#define IDS_ENABLED                     9
#define IDS_DISABLED                   10


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\rsess\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rexpire.rc
//
#define IDS_HELPTEXT                    1
#define IDS_BAD_ARG                     2
#define IDS_RPC_ERROR                   3
#define IDS_PARM_ERROR                  4
#define IDS_LOCAL_MACHINE               5
#define IDS_DISPLAY                     6
#define IDS_NUM_SESSIONS                7
#define IDS_ANON_STRING                 8


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\rsess\main.cpp ===
# include <windows.h>
# include <lm.h>
# include <stdio.h>
# include <stdlib.h>
# include <inetinfo.h>
# include <norminfo.h>
# include "apiutil.h"
# include "nntptype.h"
# include "nntpapi.h"
# include "resource.h"

DWORD
Enumerate(
    LPWSTR Server,
	DWORD  InstanceId
    );

DWORD
Terminate(
    LPWSTR Server,
	DWORD  InstanceId,
    LPSTR UserName,
    LPSTR IPAddress
    );

VOID
PrintInfo(
    LPNNTP_SESSION_INFO SessInfo
    );

char	StringBuff[4096] ;

HINSTANCE	hModuleInstance = 0 ;

void
usage( )
{
	
	LoadString( hModuleInstance, IDS_HELPTEXT, StringBuff, sizeof( StringBuff ) ) ;
	printf( StringBuff ) ;

#if 0 
    printf("rsess\n");
    printf("\t\t -e      enum\n");
    printf("\t\t -d      del\n");
    printf("\t\t -u <username> Username to delete\n");
    printf("\t\t -i <ipaddress> IP or hostname to delete\n");
    printf("\t\t -s <server>\n");
    return;
#endif
}

void
__cdecl
main(  int argc,  char * argv[] )
{
    NET_API_STATUS err;
    LPWSTR server = NULL;
    WCHAR srvBuffer[32];
    PWCHAR q;
    PCHAR p;
    INT cur = 1;
    PCHAR x;
    BOOL doDelete = FALSE;
    LPSTR ip = NULL;
    LPSTR user = NULL;
	DWORD InstanceId = 1;

    if ( argc == 1 ) {
        usage( );
        return;
    }

    while ( cur < argc ) {

        x=argv[cur++];
        if ( *(x++) == '-' ) {

            switch (*x) {
            case 'e':
                break;

            case 'i':
                ip = argv[cur++];
                break;

            case 'v':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                InstanceId = atoi(argv[cur++]);
                break;

            case 'u':
                user = argv[cur++];
                break;

            case 's':
                p=argv[cur++];
                q=srvBuffer;
                while ( *q++ = (WCHAR)*p++ );
                server = srvBuffer;
                break;

            case 'd':
                doDelete = TRUE;
                break;

            default:
                usage( );
                return;
            }
        }
    }

    if ( server == NULL ) {
    	LoadString( hModuleInstance, IDS_LOCAL_MACHINE, StringBuff, sizeof( StringBuff ) ) ;
	    printf( StringBuff ) ;
    } else if ( *server != L'\\') {
    	LoadString( hModuleInstance, IDS_BAD_ARG, StringBuff, sizeof( StringBuff ) ) ;
	    printf( StringBuff ) ;
        return;
    }

    if ( doDelete ) {
       Terminate( server, InstanceId, user, ip );
    } else {
        Enumerate( server, InstanceId );
    }

    return;
} // main()

VOID
PrintInfo(
    LPNNTP_SESSION_INFO SessInfo
    )
{
    IN_ADDR addr;
    addr.s_addr = SessInfo->IPAddress;

#if 0 
    printf("UserName %s\n", SessInfo->UserName);
    printf("Port used %d\n",SessInfo->PortConnected);
    printf("IP Address %s\n",inet_ntoa(addr));
#endif

   	LoadString( hModuleInstance, IDS_DISPLAY, StringBuff, sizeof( StringBuff ) ) ;
    printf( StringBuff, SessInfo->UserName, SessInfo->PortConnected, inet_ntoa(addr) ) ;

    if( SessInfo->fAnonymous ) {
	LoadString( hModuleInstance, IDS_ANON_STRING, StringBuff, sizeof( StringBuff ) );
	printf( StringBuff );
    }
}

DWORD
Enumerate(
    LPWSTR Server,
	DWORD  InstanceId
    )
{
    DWORD err;
    DWORD nRead = 0;
    LPNNTP_SESSION_INFO sess;
    DWORD i;
    LPNNTP_SESSION_INFO SessInfo;

    err = NntpEnumerateSessions(
                            Server,
							InstanceId,
                            &nRead,
                            &SessInfo
                            );

    if ( err == NO_ERROR) {

       	LoadString( hModuleInstance, IDS_NUM_SESSIONS, StringBuff, sizeof( StringBuff ) ) ;
        printf( StringBuff, nRead ) ; 

        sess = SessInfo;
        for (i=0; i<nRead;i++ ) {
            PrintInfo( sess );
            sess++;
        }

        MIDL_user_free(SessInfo);

    } else {
    	LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
	    printf( StringBuff ) ;
    }
    return(err);
}

DWORD
Terminate(
    LPWSTR Server,
	DWORD  InstanceId,
    LPSTR UserName,
    LPSTR IPAddress
    )
{
    DWORD err;

    err = NntpTerminateSession(
                            Server,
							InstanceId,
                            UserName,
                            IPAddress
                            );


    if( err != NO_ERROR ) {
    	LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
	    printf( StringBuff ) ;
    }
    return(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\rserver\main.cpp ===
# include <windows.h>
# include <lm.h>
# include <stdio.h>
# include <stdlib.h>
# include <inetinfo.h>
# include <norminfo.h>
# include "apiutil.h"
# include "nntptype.h"
# include "nntpapi.h"
# include "resource.h"

DWORD
GetInformation(
    LPWSTR Server,
	DWORD  InstanceId,
    LPNNTP_CONFIG_INFO		*config
    );

DWORD
SetInformation(
    LPWSTR Server,
	DWORD  InstanceId,
    LPNNTP_CONFIG_INFO		config
    );

VOID
PrintInfo(
    LPNNTP_CONFIG_INFO		config
    );


char	StringBuff[4096] ;

HINSTANCE	hModuleInstance = 0 ;

void
usage( )
{
	
	LoadString( hModuleInstance, IDS_HELPTEXT, StringBuff, sizeof( StringBuff ) ) ;
	printf( StringBuff ) ;

#if 0 
    printf("rserver\n");
    printf("\t-t <operation>\n");
    printf("\t\t g      get\n");
    printf("\t\t s      set\n");
    printf("\t-l soft post limit (default = 64K)\n");
    printf("\t-h hard post limit (default = 1MB)\n");
    printf("\t-i soft feed limit (default = 128K)\n");
    printf("\t-j hard feed limit (default = 100MB)\n");
    printf("\t-m SMTP address for moderated newsgroup postings\n");
    printf("\t-d Default domain-name for moderators \n");
    printf("\t-u UUCP name for this server\n");
    printf("\t-c 'y'(yes) or 'n'(no) - client posts allowed (Default = y)\n");
    printf("\t-f 'y'(yes) or 'n'(no) - feed posts allowed (Default = y)\n");
    printf("\t-x 'y'(yes) or 'n'(no) - control messages processed (Default = y)\n");
	printf("\t-s <server>\n" ) ;
    return;
#endif
}

LPWSTR RemServerW = (PWCH)NULL;
LPWSTR RemSmtpAddressW = (PWCH)NULL;
LPWSTR RemUucpNameW = (PWCH)NULL;
LPWSTR RemDefaultModeratorW = (PWCH)NULL;

WCHAR ServerName[256];
WCHAR SmtpAddress[ MAX_PATH ];
WCHAR UucpName[ MAX_PATH ];
WCHAR DefaultModerator[ 512 ];

void
__cdecl
main(  int argc,  char * argv[] )
{
    NET_API_STATUS err;
	NNTP_CONFIG_INFO		config;
	LPNNTP_CONFIG_INFO		lpconfig;
    CHAR op = ' ';
    INT cur = 1;
    DWORD i;
	PCHAR	x ;
	char	ch ;
    PCHAR server, moderator;

	DWORD	SoftLimit = 64 * 1024 ;
	DWORD	HardLimit = 1024 * 1024 ;
	DWORD	FeedSoftLimit = 128 * 1024 ;
	DWORD	FeedHardLimit = 100 * 1024 * 1024 ;
	BOOL	LimitPresent = FALSE ;
	BOOL	FeedLimitPresent = FALSE ;
	BOOL	ClientPosts = TRUE ;
	BOOL	FeedPosts = TRUE ;
	BOOL	ModePresent = FALSE ;
	BOOL	ControlMessages = TRUE ;
	BOOL	ControlPresent = FALSE ;
	BOOL	SmtpPresent = FALSE ;
	BOOL	UucpPresent = FALSE ;
	BOOL	DefaultModeratorPresent = FALSE;
	DWORD	InstanceId = 1;
	
    if ( argc == 1 ) {
        usage( );
        return;
    }

    while ( cur < argc ) {

        x=argv[cur++];
        if ( *(x++) == '-' ) {

            switch (*x) {
            case 'l':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }

				SoftLimit = atoi( argv[cur++] ) ;
				LimitPresent = TRUE ;
                break;

			case 'h' : 
				if( cur >= argc )	{
					usage( ) ;
					return ;
				}

				HardLimit = atoi( argv[cur++] ) ;
				LimitPresent = TRUE ;
				break ;

			case 'i' : 
				if( cur >= argc )	{
					usage( ) ;
					return ;
				}

				FeedSoftLimit = atoi( argv[cur++] ) ;
				FeedLimitPresent = TRUE ;
				break ;

			case 'j' : 
				if( cur >= argc )	{
					usage( ) ;
					return ;
				}

				FeedHardLimit = atoi( argv[cur++] ) ;
				FeedLimitPresent = TRUE ;
				break ;

            case 'v':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                InstanceId = atoi(argv[cur++]);
                break;

            case 'c':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }

				ch = argv[cur++][0] ;
				if( ch == 'y' || ch == 'Y' ) {
					ClientPosts = TRUE ;
				}	else	if( ch =='n' || ch == 'N' ) {
					ClientPosts = FALSE ;
				}	else	{
					usage() ;
					return ;
				}
				ModePresent = TRUE ;
	            break;

            case 'f':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }

				ch = argv[cur++][0] ;
				if( ch == 'y' || ch == 'Y' ) {
					FeedPosts = TRUE ;
				}	else	if( ch =='n' || ch == 'N' ) {
					FeedPosts = FALSE ;
				}	else	{
					usage() ;
					return ;
				}
				ModePresent = TRUE ;
	            break;

            case 's':
                if ( cur >= argc ) {
                    usage();
                    return;
                }

                server = argv[cur++];
                for (i=0; server[i] != '\0' ;i++ ) {
                    ServerName[i] = (WCHAR)server[i];
                }
                ServerName[i]=L'\0';
                RemServerW = ServerName;
                break;

            case 'm':
                if ( cur >= argc ) {
                    usage();
                    return;
                }

                server = argv[cur++];
                for (i=0; server[i] != '\0' ;i++ ) {
                    SmtpAddress[i] = (WCHAR)server[i];
                }
                SmtpAddress[i]=L'\0';
                RemSmtpAddressW = SmtpAddress;
				SmtpPresent = TRUE;
                break;

            case 'd':
                if ( cur >= argc ) {
                    usage();
                    return;
                }

                moderator = argv[cur++];
                for (i=0; moderator[i] != '\0' ;i++ ) {
                    DefaultModerator[i] = (WCHAR)moderator[i];
                }
                DefaultModerator[i]=L'\0';
                RemDefaultModeratorW = DefaultModerator;
				DefaultModeratorPresent = TRUE;
                break;

            case 'u':
                if ( cur >= argc ) {
                    usage();
                    return;
                }

                server = argv[cur++];
                for (i=0; server[i] != '\0' ;i++ ) {
                    UucpName[i] = (WCHAR)server[i];
                }
                UucpName[i]=L'\0';
                RemUucpNameW = UucpName;
				UucpPresent = TRUE;
                break;

            case 't':
				if( cur >= argc )	{
					usage() ;
					return ;
				}
                op = *(argv[cur++]);
                break;

            case 'x':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }

				ch = argv[cur++][0] ;
				if( ch == 'y' || ch == 'Y' ) {
					ControlMessages = TRUE ;
				}	else	if( ch =='n' || ch == 'N' ) {
					ControlMessages = FALSE ;
				}	else	{
					usage() ;
					return ;
				}
				ControlPresent = TRUE ;
	            break;

            default:

				if( cur >= 1 )  {
                	LoadString( hModuleInstance, IDS_BAD_ARG, StringBuff, sizeof( StringBuff ) ) ;
                	printf( StringBuff ) ;
                }

                usage( );
                return;
            }
        }
    }



    ZeroMemory(&config,sizeof(config));
	if( LimitPresent ) {

		config.FieldControl |= FC_NNTP_POSTLIMITS ;
		config.ServerPostHardLimit = HardLimit ;
		config.ServerPostSoftLimit = SoftLimit ;

	}

	if( ModePresent ) {
		config.FieldControl |= FC_NNTP_POSTINGMODES ;
		config.AllowClientPosting = ClientPosts ;
		config.AllowFeedPosting = FeedPosts ;
	}

	if( FeedLimitPresent ) {
		config.FieldControl |= FC_NNTP_FEEDLIMITS ;
		config.ServerFeedHardLimit = FeedHardLimit ;
		config.ServerFeedSoftLimit = FeedSoftLimit ;
	}

	if( SmtpPresent ) {
		config.FieldControl |= FC_NNTP_SMTPADDRESS ;
		config.SmtpServerAddress = SmtpAddress;
	}

	if( UucpPresent ) {
		config.FieldControl |= FC_NNTP_UUCPNAME ;
		config.UucpServerName = UucpName;
	}

	if( ControlPresent ) {
		config.FieldControl |= FC_NNTP_CONTROLSMSGS ;
		config.AllowControlMessages = ControlMessages;
	}

	if( DefaultModeratorPresent ) {
		config.FieldControl |= FC_NNTP_DEFAULTMODERATOR ;
		config.DefaultModerator = DefaultModerator;
	}

    switch (op) {
    case 's':

		err = SetInformation(
					RemServerW,
					InstanceId,
					&config
					) ;
		break ;

    case 'g':
        err = GetInformation(
                        RemServerW,
						InstanceId,
                        &lpconfig
                        );
        break ;

    default:
        usage( );
    }

    return;

#if 0 
free_buf:
    //MIDL_user_free(feedInfo);
    return;
#endif
} // main()

DWORD
GetInformation(
    LPWSTR	Server,
	DWORD	InstanceId,
	LPNNTP_CONFIG_INFO*	config
    )
{
    DWORD err;
    err = NntpGetAdminInformation(
                            Server,
							InstanceId,
							config
                            );

    if ( err == NO_ERROR ) {
        PrintInfo(*config);
    } else {
    	LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
	    printf( StringBuff, err ) ;
    }
    return err;
}

VOID
PrintInfo(
    LPNNTP_CONFIG_INFO	config
    )
{

    PWCH p;

	char	*lpstrFeedType = 0 ;

    char    PostEnabled[256] ;
    char    FeedEnabled[256] ;
    char    ControlEnabled[256] ;

    if( config->AllowClientPosting ) {
    	LoadString( hModuleInstance, IDS_ENABLED, PostEnabled, sizeof( PostEnabled ) ) ;
    }   else    {
    	LoadString( hModuleInstance, IDS_DISABLED, PostEnabled, sizeof( PostEnabled ) ) ;
    }

    if( config->AllowFeedPosting ) {
    	LoadString( hModuleInstance, IDS_ENABLED, FeedEnabled, sizeof( FeedEnabled ) ) ;
    }   else    {
    	LoadString( hModuleInstance, IDS_DISABLED, FeedEnabled, sizeof( FeedEnabled ) ) ;
    }

    if( config->AllowControlMessages ) {
    	LoadString( hModuleInstance, IDS_ENABLED, ControlEnabled, sizeof( ControlEnabled ) ) ;
    }   else    {
    	LoadString( hModuleInstance, IDS_DISABLED, ControlEnabled, sizeof( ControlEnabled ) ) ;
    }

   	LoadString( hModuleInstance, IDS_DISPLAY, StringBuff, sizeof( StringBuff ) ) ;
	printf( StringBuff, config->ServerPostSoftLimit,
                        config->ServerPostHardLimit,
                        config->ServerFeedSoftLimit,
                        config->ServerFeedHardLimit,
                        PostEnabled,
                        FeedEnabled,
                        ControlEnabled,
                        config->SmtpServerAddress,
                        config->DefaultModerator,
                        config->UucpServerName ) ;
    

}

DWORD
SetInformation(
    LPWSTR	Server,
	DWORD	InstanceId,
	LPNNTP_CONFIG_INFO	config
    )
{
    DWORD err;
	DWORD	ParmErr ;
    err = NntpSetAdminInformation(
                            Server,
							InstanceId,
							config,
							&ParmErr
                            );
    if( err != NO_ERROR ) {
    	LoadString( hModuleInstance, IDS_RPC_ERROR, StringBuff, sizeof( StringBuff ) ) ;
	    printf( StringBuff, err ) ;
    }   
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\secsrv\main.cpp ===
#include <buffer.hxx>
#include "..\..\tigris.hxx"
extern "C" {
#define SECURITY_WIN32
#include <rpc.h>
#include <sspi.h>
#include <sslsp.h>
#include <spseal.h>
#include <issperr.h>
}
#include "..\..\security.h"
#include "..\inc\sec.h"

#define IO_BUFFER_SIZE 4096

WSADATA WsaData;
CHAR ourArticle[1024];

CSecurityCtx *NntpServer = NULL;

VOID
NNTPProcess(
    SOCKET s,
    BOOL isSSL
    );

DWORD
WINAPI
DoSSLServer(
    PVOID Context
    );

DWORD
WINAPI
SSPIServer(
    PVOID Context
    );

BOOL
DoNtLm(
    SOCKET s,
    BOOL IsSSL
    );


BOOL fNtlm = FALSE;

BOOL
ReadOurArticle(
    )
{
    HANDLE hFile;
    DWORD nbytes;

    hFile = CreateFile(
                   "c:\\nntproot\\junk",
                   GENERIC_READ,
                   0,
                   NULL,
                   OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                   NULL
                   );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        goto error;
    }

    if (!ReadFile(
                hFile,
                ourArticle,
                1024,
                &nbytes,
                NULL
                ) ) {

        goto error;
    }
    CloseHandle(hFile);
    ourArticle[nbytes] = '\0';
    return(TRUE);
error:
    return(FALSE);
}


void
_CRTAPI1
main(  int argc,  char * argv[] )
{
    INT err;
    err = WSAStartup( 0x0101, &WsaData );
    if ( err == SOCKET_ERROR ) {
        return;
    }

    InitAsyncTrace( );
    NntpInitializeSecurity( );

    if ( argc > 1 ) {
        printf("enable ntlm\n");
        fNtlm = TRUE;
    }

    //
    // read out article
    //

    if (!ReadOurArticle( ))
        return;

    {
        HANDLE hThread;
        DWORD threadId;

        hThread = CreateThread(
                    NULL,               // attributes
                    0,                  // stack size
                    DoSSLServer,          // thread start
                    (PVOID)0,           // param
                    0,                  // creation params
                    &threadId
                    );

        if ( hThread != NULL ) {
            CloseHandle(hThread);
        }

    }

    SSPIServer( NULL );
    NntpTerminateSecurity( );
    TermAsyncTrace( );
    WSACleanup( );

} // main()
VOID
NntpReply(
    SOCKET s,
    PCHAR Reply,
    BOOL isSSL
    )
{
    INT err;
    BUFFER out;
    DWORD nbytes;

    //
    // reseal it and give it back
    //

    if ( isSSL ) {
        err = strlen(Reply);
        if (!NntpServer->SealMessage(
                (LPBYTE)Reply,
                err,
                &out,
                &nbytes
                )) {
            return;
        }

    } else {
        nbytes = strlen(Reply);
    }

    err = send(s,(PCHAR)out.QueryPtr(),nbytes,0);
    if ( err == SOCKET_ERROR ) {
        printf("hello send failed\n");
        return;
    }
}

DWORD
WINAPI
DoSSLServer(
    PVOID Context
    )
{
    SOCKET listenSocket;
    SOCKET acceptSocket;
    SOCKADDR_IN address;
    INT err;
    SOCKADDR_IN remoteAddress;
    INT remoteSockaddrLength;
    BOOL authInProgress;
    BOOL authFailed;
    CHAR IoBuffer[IO_BUFFER_SIZE];
    BUFFER out;
    NEG_BLOCK neg;
    PCHAR msg;
    DWORD nbytes;

    //
    // Set up a socket listening on the SSL port 563
    //

    listenSocket = socket( AF_INET, SOCK_STREAM, 0 );
    if ( listenSocket == INVALID_SOCKET ) {
        printf( "socket() failed for listenSocket: %ld\n", GetLastError( ) );
        return 1;
    }

    RtlZeroMemory( &address, sizeof(address) );
    address.sin_family = AF_INET;
    address.sin_port = htons( NNTP_SSL_PORT );

    err = bind( listenSocket, (PSOCKADDR)&address, sizeof(address) );
    if ( err == SOCKET_ERROR ) {
        printf( "bind failed: %ld\n", GetLastError( ) );
        return 1;
    }

    err = listen( listenSocket, 5 );
    if ( err == SOCKET_ERROR ) {
        printf( "listen failed: %ld\n", GetLastError( ) );
        return 1;
    }

    //
    // Loop processing connections.
    //

    while (TRUE ) {

        //
        // First accept an incoming connection.
        //

        remoteSockaddrLength = sizeof(remoteAddress);

        printf("Waiting for SSL connection\n");

        acceptSocket = accept( listenSocket, (LPSOCKADDR)&remoteAddress,
                               &remoteSockaddrLength );
        if ( acceptSocket == INVALID_SOCKET ) {
            printf( "accept() failed: %ld\n", GetLastError( ) );
            return 1;
        }

        authInProgress = TRUE;
        authFailed = FALSE;

        NntpServer = new CSecurityCtx;
        if ( (NntpServer == NULL) ||
             !NntpServer->Initialize( FALSE )) {

            printf("cannot initialize sec ctx\n");
            closesocket(acceptSocket);
            delete NntpServer;
            continue;
        }

        do {

            BOOL moredata;

            err = recv( acceptSocket, IoBuffer, IO_BUFFER_SIZE, 0 );

            if ( err == SOCKET_ERROR ) {

                printf(" recv failed: %d\n", GetLastError() );
                closesocket( acceptSocket );
                break;

            } else {
                printf("recv auth data, %d bytes\n", err );
            }

            if ( !NntpServer->Converse(
                                IoBuffer,
                                err,
                                &out,
                                &nbytes,
                                &moredata,
                                AuthProtocolSSL30
                                ) ) {

                printf("converse failed %x\n",GetLastError());
                authFailed = TRUE;
                break;
            }

            printf("Sending %d bytes auth data\n",nbytes);
            if ( nbytes > 0 ) {
                err = send(
                        acceptSocket,
                        (PCHAR)out.QueryPtr( ),
                        nbytes,
                        0
                        );

                if ( err == SOCKET_ERROR ) {
                    printf("send failed\n");
                    authFailed = TRUE;
                    break;

                } else if ( !moredata ) {

                    //
                    // We completed the auth exchanges!
                    //

                    authInProgress = FALSE ;
                }
            } else {
                break;
            }

        } while ( authInProgress );

        if ( authFailed ) {
            printf("auth failed\n");
        } else {

            printf("successful!\n");
        }

        if ( fNtlm) {
            DoNtLm( acceptSocket, TRUE );
        }

        NNTPProcess( acceptSocket, TRUE );

        closesocket( acceptSocket );
        delete NntpServer;
        NntpServer = NULL;
    } // while

    closesocket(listenSocket);
    return 1;

} // SSLServer

DWORD
WINAPI
SSPIServer(
    PVOID Context
    )
{
    SOCKET listenSocket;
    SOCKET acceptSocket;
    SOCKADDR_IN address;
    SOCKADDR_IN remoteAddress;
    INT remoteSockaddrLength;
    INT err;

    //
    // Set up a socket listening on the SSL port 563
    //

    listenSocket = socket( AF_INET, SOCK_STREAM, 0 );
    if ( listenSocket == INVALID_SOCKET ) {
        printf( "socket() failed for listenSocket: %ld\n", GetLastError( ) );
        return 1;
    }

    RtlZeroMemory( &address, sizeof(address) );
    address.sin_family = AF_INET;
    address.sin_port = htons( NNTP_PORT );

    err = bind( listenSocket, (PSOCKADDR)&address, sizeof(address) );
    if ( err == SOCKET_ERROR ) {
        printf( "bind failed: %ld\n", GetLastError( ) );
        return 1;
    }

    err = listen( listenSocket, 5 );
    if ( err == SOCKET_ERROR ) {
        printf( "listen failed: %ld\n", GetLastError( ) );
        return 1;
    }

    while (TRUE ) {

        //
        // First accept an incoming connection.
        //

        remoteSockaddrLength = sizeof(remoteAddress);

        printf("Waiting for SSPI connection\n");

        acceptSocket = accept( listenSocket, (LPSOCKADDR)&remoteAddress,
                               &remoteSockaddrLength );
        if ( acceptSocket == INVALID_SOCKET ) {
            printf( "accept() failed: %ld\n", GetLastError( ) );
            return 1;
        }

        if ( fNtlm) {
            DoNtLm( acceptSocket, FALSE );
        }

        NNTPProcess( acceptSocket, FALSE );
        closesocket(acceptSocket);
    }

    closesocket(listenSocket);
    return 1;

} // SSPIServer

BOOL
DoNtLm(
    SOCKET s,
    BOOL IsSSL
    )
{
    BOOL authFailed;
    BOOL authInProgress;
    CHAR IoBuffer[IO_BUFFER_SIZE];
    INT err;
    BUFFER out;

    printf("Doing NTLM\n");

    printf("Allocating a new ctx\n");
    if ( NntpServer == NULL ) {
        NntpServer = new CSecurityCtx;
        if ( (NntpServer == NULL) ||
             (!NntpServer->Initialize(FALSE)) ) {

            delete NntpServer;
            NntpServer = NULL;
            printf("Cannot initialize ntlm\n");
            return(FALSE);
        }
    }

    authFailed = FALSE;
    authInProgress = TRUE;

    do {

        BOOL moredata;
        DWORD nbytes;

        err = recv( s, IoBuffer, IO_BUFFER_SIZE, 0 );
        if ( err == SOCKET_ERROR ) {

            printf(" recv failed: %d\n", GetLastError() );
            closesocket( s );
            break;

        } else {
            printf("NTLM:recv %d bytes\n", err );
        }

        if ( IsSSL ) {

            // unseal


        }


        if ( !NntpServer->Converse(
                            IoBuffer,
                            err,
                            &out,
                            &nbytes,
                            &moredata,
                            AuthProtocolNtLm
                            ) ) {

            printf("converse failed %x\n",GetLastError());
            authFailed = TRUE;
            break;
        }

        printf("NTLM: Sending %d bytes\n",nbytes);
        if ( nbytes > 0 ) {

#if 0
            if ( isSSL ) {
                SSLCtx->SealMessage(


            }
#endif
            err = send(
                    s,
                    (PCHAR)out.QueryPtr( ),
                    nbytes,
                    0
                    );

            if ( err == SOCKET_ERROR ) {
                printf("send failed\n");
                authFailed = TRUE;
                break;

            } else if ( !moredata ) {

                //
                // We completed the auth exchanges!
                //

                authInProgress = FALSE ;
            }
        } else {
            break;
        }

    } while ( authInProgress );

    if ( authFailed ) {
        printf("auth failed\n");
        return(FALSE);
    } else {

        printf("successful!\n");
        return(TRUE);
    }

} // DoNtLm

VOID
NNTPProcess(
    SOCKET s,
    BOOL isSSL
    )
{
    CHAR buffer[4096];
    PCHAR start;
    DWORD nbytes;
    INT err;
    PCHAR msg;
    BUFFER out;
    INT i;
    PCHAR p;

    //
    // Send Hello
    //

    msg = "200 Johnson's cool SNEWS server Ready\r\n";

    //
    // reseal it and give it back
    //

    NntpReply(s,msg,isSSL);

    printf("processing command\n");

    for (; ; ) {

        err = recv(s,buffer,4096,0);
        if ( err == SOCKET_ERROR ) {

            printf(" recv failed: %d\n", GetLastError() );
            break;

        } else {
            printf("PROCESS:recv %d bytes\n", err );
        }

        buffer[err] = '\0';
        if ( isSSL ) {

            if (!NntpServer->UnsealMessage(
                                (LPBYTE)buffer,
                                err,
                                (LPBYTE*)&start,
                                &nbytes
                                )) {
                printf("unseal failed\n");
            }

        } else {
            start = buffer;
        }
        printf("Command %s\n", start);

        //
        // try to get the first token
        //

        if ( (p = strtok(start," \r\t\n")) == NULL) {
            NntpReply(s,"501 eeee",isSSL);
            continue;
        }

        if(!_stricmp(p,"MODE")) {

            NntpReply(s,"201 Hello, you can't post\r\n",isSSL);
        } else if(!_stricmp(p,"LIST")) {

            NntpReply(s,
                "215 Newsgroups are\r\ncomp.tigris 1 1 n\r\n.\r\n",
                isSSL
                );

        } else if(!_stricmp(p,"NEWGROUPS")) {

            NntpReply(s,
                "231 Newsgroups are\r\n.\r\n",
                isSSL
                );
        } else if(!_stricmp(p,"GROUP")) {

            NntpReply(s,
                "211 1 1 1 comp.tigris\r\n",
                isSSL
                );
        } else if(!_stricmp(p,"XOVER")) {

            NntpReply(s,
"224 Info follows\r\n1\ttest1\tmole@msn.com\t8 Nov 95\t123123@jasdk\t3818923\t437\t34\r\n.\r\n",
                isSSL
                );
        } else if(!_stricmp(p,"ARTICLE")) {

            NntpReply(s,
                ourArticle,
                isSSL
                );
        }
    }

} // NNTPProcess
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\ssl\buffer.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    buffer.cxx
    Implementation of the BUFFER class.

    FILE HISTORY:
        RustanL     03-Aug-1990     Created Windows implementation
        RustanL     02-Jan-1991     Adapted for BLT
        RustanL     08-Jan-1991     Moved into UI misc, and added OS/2
                                    and DOS implementation.
        BenG        30-Apr-1991     Uses lmui.hxx
        beng        19-Jun-1991     Inherits from BASE; uses UINT sizes;
                                    documentation corrected and moved
                                    into headers
        beng        19-Mar-1992     Removed OS/2 support
        MuraliK     27-Feb-1995  Modified to make it standalone.
        MuraliK     2-June-1995  Modified to make it into a library.
*/


//
// Normal includes only for this module
//

# include <buffer.hxx>


/*******************************************************************

    NAME:       BUFFER::BUFFER

    SYNOPSIS:   Construct a BUFFER object of the given size.

    ENTRY:
        cbRequested     indicates desired size of buffer object

    CAVEATS:
        Requesting a zero-length buffer returns an object which
        has no allocated storage.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        20-Jun-1991     Uses BASE; size UINT

********************************************************************/

#if 0  // Defined in header file
BUFFER::BUFFER( UINT cbRequested ) :
    _pb(NULL),
    _cb(0)
{
    if ( cbRequested == 0 )
        return;

    GetNewStorage(cbRequested);
}
#endif

/*******************************************************************

    NAME:       BUFFER::GetNewStorage

    SYNOPSIS:   Given an object with no allocated storage,
                allocate the initial memory.

    ENTRY:      cbRequested - amount of storage requested in bytes

    EXIT:       Either storage alloc'd, or error reported
                Sets _cb, _pb

    RETURNS:    TRUE if successful, FALSE for GetLastError()

    NOTES:
        Private member function.

    CAVEATS:
        This function will ReportError itself.

    HISTORY:
        beng        24-Jun-1991     Created (common code factored)
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

BOOL BUFFER::GetNewStorage( UINT cbRequested )
{
    _pb = (BYTE *) ::LocalAlloc( NONZEROLPTR, cbRequested );

    if ( !_pb )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    _cb = cbRequested;

    return TRUE;
}


/*******************************************************************

    NAME:       BUFFER::ReallocStorage

    SYNOPSIS:   Do a "hard" reallocation to the new size

    ENTRY:      cbNewRequested - new size, in bytes

    EXIT:       Storage realloc'd.
                _pb, _cb changed

    RETURNS:    TRUE if successful, FALSE for GetLastError()

    NOTES:
        Private member function.

    HISTORY:
        beng        24-Jun-1991     Created (common code factor)
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

BOOL BUFFER::ReallocStorage( UINT cbNewRequested )
{
    HANDLE hNewMem = ::LocalReAlloc( _pb, cbNewRequested, GMEM_MOVEABLE );

    if (hNewMem == 0)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    _pb = (BYTE *) hNewMem;

    _cb = cbNewRequested;

    return TRUE;
}

/*******************************************************************

    NAME:       BUFFER::~BUFFER

    SYNOPSIS:   Destroys buffer object, and deallocates any memory
                that it might have allocated.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

#if 0 // Defined in header

BUFFER::~BUFFER()
{
#if DBG
    VerifyState();
#endif

    if ( _pb )
    {
        ::LocalFree( (HANDLE) _pb );
    }

#if DBG
    _pb = NULL;
    _cb = 0;
#endif
}

#endif // 0

/*******************************************************************

    NAME:       BUFFER::VerifyState

    SYNOPSIS:   Verifies the state of the object.
                Asserts out if the state is invalid, i.e. if an
                internal error took place.

    NOTES:      This function does nothing in the retail version.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added

********************************************************************/

VOID BUFFER::VerifyState() const
{
}

/*******************************************************************

    NAME:       BUFFER::Resize

    SYNOPSIS:   Resizes the memory object

    ENTRY:
        cbNewRequested   - specifies the new size
        cbSlop           - If a realloc is needed, then cbSlop bytes are
                           added for the reallocation (not for an initial
                           allocation though)

    EXIT:
        _cb and _pb changed; possibly _pb resized

    RETURNS:
        TRUE if successful.  The next call to QueryPtr will then
            return a pointer to the newly allocated memory.
            The new buffer will contain as much of the contents
            of the old buffer as will fit.
        FALSE if unsuccessful.  The old piece of memory, if any,
            still exists.  The next call to QueryPtr will
            return a pointer to this memory.

    NOTES:
        After a call to this method, the caller can *not* rely on any
        pointer that QueryPtr has returned in the past, regardless of
        the success of this method.

        Reallocations to size 0 will always succeed.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        24-Jun-1991     Fold common code; fix bug seen in
                                    resize-to-0,resize-to-original sequence
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Remove OS/2 support

********************************************************************/

BOOL BUFFER::Resize( UINT cbNewRequested,
                     UINT cbSlop )
{
#if DBG
    VerifyState();
#endif

    if ( cbNewRequested != 0 )
    {
        if ( _pb != 0 )
        {
            if ( cbNewRequested > QuerySize() )
            {
                /*
                 * The requested memory exceeds the currently allocated memory.
                 * A reallocation is in order.
                 */
                return ReallocStorage(cbNewRequested + cbSlop);
            }

            return TRUE;
        }
        else
        {
            /*
             * There is no memory handle.  Previous size of buffer
             * must have been 0.
             *
             * The new memory request is allocated.
             */
            return GetNewStorage( cbNewRequested );
        }
    }
    else
    {
        /*
         * The requested memory size is 0.  This will always work.
         */
        if ( _pb )
            ::LocalFree( (HANDLE)_pb );

        _pb = NULL;
        _cb = 0;

        return TRUE;
    }

    return TRUE;
}


/*******************************************************************

    NAME:       BUFFER::Trim

    SYNOPSIS:   Reallocates the buffer so that the actual space alloc'd
                is minimally more than the size requested.

    EXIT:
        After making this call, the client can not rely on any pointer
        that QueryPtr has returned in the past, regardless of the success
        of this method.

    NOTES:
        The actual size of the buffer may be larger than the requested size.
        This method informs the system that only _cb is desired.

        This method is intended to be used only when optimization is key.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        15-Jul-1991     ReallocStorage changed return type
        beng        19-Mar-1992     Remove OS/2 support

********************************************************************/

VOID BUFFER::Trim()
{
#if DBG
    VerifyState();
#endif

    if ( _pb == 0 )
    {
        /*
         * No memory is allocated.
         */
        return;
    }

    if ( _cb == 0 )
    {
        /*
         * The requested size is 0.  Free the allocated memory.
         */
        return;
    }

    /*
     * (This should not fail, since we are reallocating to less
     * than current storage.)
     */
    NO_ERROR == ReallocStorage(_cb);
}

BOOL
BUFFER_CHAIN::AppendBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Adds a new buffer chain item to the end of the buffer chain

Arguments:

    pBCI - Chain item to append

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    InsertTailList( &_ListHead,
                    &pBCI->_ListEntry );

    return TRUE;
}

DWORD
BUFFER_CHAIN::DeleteChain(
    VOID
    )
/*++

Routine Description:

    Deletes all of the buffers in this chain

Return Value:

    Total number of allocated bytes freed by this call

--*/
{
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbFreed = 0;

    while ( !IsListEmpty( &_ListHead ))
    {
        pBCI = CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );

        RemoveEntryList( &pBCI->_ListEntry );

        cbFreed += pBCI->QuerySize();

        delete pBCI;
    }

    return cbFreed;
}

BUFFER_CHAIN_ITEM *
BUFFER_CHAIN::NextBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Returns the next buffer in the chain.  Start the enumeration by
    passing pBCI as NULL.  Continue it by passing the return value

Arguments:

    pBCI - Previous item in enumeration

Return Value:

    Pointer to next item in chain, NULL when done

--*/
{
    if ( pBCI != NULL )
    {
        if ( pBCI->_ListEntry.Flink != &_ListHead )
        {
            return CONTAINING_RECORD( pBCI->_ListEntry.Flink,
                                      BUFFER_CHAIN_ITEM,
                                      _ListEntry );
        }
        else
        {
            return NULL;
        }
    }

    if ( !IsListEmpty( &_ListHead ))
    {
        return CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );
    }

    return NULL;
}

DWORD
BUFFER_CHAIN::CalcTotalSize(
    BOOL fUsed
    ) const
/*++

Routine Description:

    Returns the total amount of memory allocated by this buffer chain
    excluding the size of the structures themselves


Arguments:

    fUsed - If FALSE, returns total allocated by chain, if TRUE returns
        total used by chain

Return Value:

    Total bytes allocated or total bytes used

--*/
{
    LIST_ENTRY *        pEntry;
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbRet = 0;

    for ( pEntry  = _ListHead.Flink;
          pEntry != &_ListHead;
          pEntry  = pEntry->Flink )
    {
        pBCI = CONTAINING_RECORD( pEntry, BUFFER_CHAIN_ITEM, _ListEntry );

        if ( fUsed == FALSE )
            cbRet += pBCI->QuerySize();
        else
            cbRet += pBCI->QueryUsed();
    }

    return cbRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\secsrv\buffer.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    buffer.cxx
    Implementation of the BUFFER class.

    FILE HISTORY:
        RustanL     03-Aug-1990     Created Windows implementation
        RustanL     02-Jan-1991     Adapted for BLT
        RustanL     08-Jan-1991     Moved into UI misc, and added OS/2
                                    and DOS implementation.
        BenG        30-Apr-1991     Uses lmui.hxx
        beng        19-Jun-1991     Inherits from BASE; uses UINT sizes;
                                    documentation corrected and moved
                                    into headers
        beng        19-Mar-1992     Removed OS/2 support
        MuraliK     27-Feb-1995  Modified to make it standalone.
        MuraliK     2-June-1995  Modified to make it into a library.
*/


//
// Normal includes only for this module
//

# include <buffer.hxx>


/*******************************************************************

    NAME:       BUFFER::BUFFER

    SYNOPSIS:   Construct a BUFFER object of the given size.

    ENTRY:
        cbRequested     indicates desired size of buffer object

    CAVEATS:
        Requesting a zero-length buffer returns an object which
        has no allocated storage.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        20-Jun-1991     Uses BASE; size UINT

********************************************************************/

#if 0  // Defined in header file
BUFFER::BUFFER( UINT cbRequested ) :
    _pb(NULL),
    _cb(0)
{
    if ( cbRequested == 0 )
        return;

    GetNewStorage(cbRequested);
}
#endif

/*******************************************************************

    NAME:       BUFFER::GetNewStorage

    SYNOPSIS:   Given an object with no allocated storage,
                allocate the initial memory.

    ENTRY:      cbRequested - amount of storage requested in bytes

    EXIT:       Either storage alloc'd, or error reported
                Sets _cb, _pb

    RETURNS:    TRUE if successful, FALSE for GetLastError()

    NOTES:
        Private member function.

    CAVEATS:
        This function will ReportError itself.

    HISTORY:
        beng        24-Jun-1991     Created (common code factored)
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

BOOL BUFFER::GetNewStorage( UINT cbRequested )
{
    _pb = (BYTE *) ::LocalAlloc( NONZEROLPTR, cbRequested );

    if ( !_pb )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    _cb = cbRequested;

    return TRUE;
}


/*******************************************************************

    NAME:       BUFFER::ReallocStorage

    SYNOPSIS:   Do a "hard" reallocation to the new size

    ENTRY:      cbNewRequested - new size, in bytes

    EXIT:       Storage realloc'd.
                _pb, _cb changed

    RETURNS:    TRUE if successful, FALSE for GetLastError()

    NOTES:
        Private member function.

    HISTORY:
        beng        24-Jun-1991     Created (common code factor)
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

BOOL BUFFER::ReallocStorage( UINT cbNewRequested )
{
    HANDLE hNewMem = ::LocalReAlloc( _pb, cbNewRequested, GMEM_MOVEABLE );

    if (hNewMem == 0)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    _pb = (BYTE *) hNewMem;

    _cb = cbNewRequested;

    return TRUE;
}

/*******************************************************************

    NAME:       BUFFER::~BUFFER

    SYNOPSIS:   Destroys buffer object, and deallocates any memory
                that it might have allocated.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

#if 0 // Defined in header

BUFFER::~BUFFER()
{
#if DBG
    VerifyState();
#endif

    if ( _pb )
    {
        ::LocalFree( (HANDLE) _pb );
    }

#if DBG
    _pb = NULL;
    _cb = 0;
#endif
}

#endif // 0

/*******************************************************************

    NAME:       BUFFER::VerifyState

    SYNOPSIS:   Verifies the state of the object.
                Asserts out if the state is invalid, i.e. if an
                internal error took place.

    NOTES:      This function does nothing in the retail version.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added

********************************************************************/

VOID BUFFER::VerifyState() const
{
}

/*******************************************************************

    NAME:       BUFFER::Resize

    SYNOPSIS:   Resizes the memory object

    ENTRY:
        cbNewRequested   - specifies the new size
        cbSlop           - If a realloc is needed, then cbSlop bytes are
                           added for the reallocation (not for an initial
                           allocation though)

    EXIT:
        _cb and _pb changed; possibly _pb resized

    RETURNS:
        TRUE if successful.  The next call to QueryPtr will then
            return a pointer to the newly allocated memory.
            The new buffer will contain as much of the contents
            of the old buffer as will fit.
        FALSE if unsuccessful.  The old piece of memory, if any,
            still exists.  The next call to QueryPtr will
            return a pointer to this memory.

    NOTES:
        After a call to this method, the caller can *not* rely on any
        pointer that QueryPtr has returned in the past, regardless of
        the success of this method.

        Reallocations to size 0 will always succeed.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        24-Jun-1991     Fold common code; fix bug seen in
                                    resize-to-0,resize-to-original sequence
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Remove OS/2 support

********************************************************************/

BOOL BUFFER::Resize( UINT cbNewRequested,
                     UINT cbSlop )
{
#if DBG
    VerifyState();
#endif

    if ( cbNewRequested != 0 )
    {
        if ( _pb != 0 )
        {
            if ( cbNewRequested > QuerySize() )
            {
                /*
                 * The requested memory exceeds the currently allocated memory.
                 * A reallocation is in order.
                 */
                return ReallocStorage(cbNewRequested + cbSlop);
            }

            return TRUE;
        }
        else
        {
            /*
             * There is no memory handle.  Previous size of buffer
             * must have been 0.
             *
             * The new memory request is allocated.
             */
            return GetNewStorage( cbNewRequested );
        }
    }
    else
    {
        /*
         * The requested memory size is 0.  This will always work.
         */
        if ( _pb )
            ::LocalFree( (HANDLE)_pb );

        _pb = NULL;
        _cb = 0;

        return TRUE;
    }

    return TRUE;
}


/*******************************************************************

    NAME:       BUFFER::Trim

    SYNOPSIS:   Reallocates the buffer so that the actual space alloc'd
                is minimally more than the size requested.

    EXIT:
        After making this call, the client can not rely on any pointer
        that QueryPtr has returned in the past, regardless of the success
        of this method.

    NOTES:
        The actual size of the buffer may be larger than the requested size.
        This method informs the system that only _cb is desired.

        This method is intended to be used only when optimization is key.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        15-Jul-1991     ReallocStorage changed return type
        beng        19-Mar-1992     Remove OS/2 support

********************************************************************/

VOID BUFFER::Trim()
{
#if DBG
    VerifyState();
#endif

    if ( _pb == 0 )
    {
        /*
         * No memory is allocated.
         */
        return;
    }

    if ( _cb == 0 )
    {
        /*
         * The requested size is 0.  Free the allocated memory.
         */
        return;
    }

    /*
     * (This should not fail, since we are reallocating to less
     * than current storage.)
     */
    NO_ERROR == ReallocStorage(_cb);
}

BOOL
BUFFER_CHAIN::AppendBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Adds a new buffer chain item to the end of the buffer chain

Arguments:

    pBCI - Chain item to append

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    InsertTailList( &_ListHead,
                    &pBCI->_ListEntry );

    return TRUE;
}

DWORD
BUFFER_CHAIN::DeleteChain(
    VOID
    )
/*++

Routine Description:

    Deletes all of the buffers in this chain

Return Value:

    Total number of allocated bytes freed by this call

--*/
{
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbFreed = 0;

    while ( !IsListEmpty( &_ListHead ))
    {
        pBCI = CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );

        RemoveEntryList( &pBCI->_ListEntry );

        cbFreed += pBCI->QuerySize();

        delete pBCI;
    }

    return cbFreed;
}

BUFFER_CHAIN_ITEM *
BUFFER_CHAIN::NextBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Returns the next buffer in the chain.  Start the enumeration by
    passing pBCI as NULL.  Continue it by passing the return value

Arguments:

    pBCI - Previous item in enumeration

Return Value:

    Pointer to next item in chain, NULL when done

--*/
{
    if ( pBCI != NULL )
    {
        if ( pBCI->_ListEntry.Flink != &_ListHead )
        {
            return CONTAINING_RECORD( pBCI->_ListEntry.Flink,
                                      BUFFER_CHAIN_ITEM,
                                      _ListEntry );
        }
        else
        {
            return NULL;
        }
    }

    if ( !IsListEmpty( &_ListHead ))
    {
        return CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );
    }

    return NULL;
}

DWORD
BUFFER_CHAIN::CalcTotalSize(
    BOOL fUsed
    ) const
/*++

Routine Description:

    Returns the total amount of memory allocated by this buffer chain
    excluding the size of the structures themselves


Arguments:

    fUsed - If FALSE, returns total allocated by chain, if TRUE returns
        total used by chain

Return Value:

    Total bytes allocated or total bytes used

--*/
{
    LIST_ENTRY *        pEntry;
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbRet = 0;

    for ( pEntry  = _ListHead.Flink;
          pEntry != &_ListHead;
          pEntry  = pEntry->Flink )
    {
        pBCI = CONTAINING_RECORD( pEntry, BUFFER_CHAIN_ITEM, _ListEntry );

        if ( fUsed == FALSE )
            cbRet += pBCI->QuerySize();
        else
            cbRet += pBCI->QueryUsed();
    }

    return cbRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\seccli\main.cpp ===
#include <buffer.hxx>
#include "..\..\tigris.hxx"
extern "C" {
#define SECURITY_WIN32
#include <rpc.h>
#include <sspi.h>
#include <sslsp.h>
#include <spseal.h>
#include <issperr.h>
}
#include "..\..\security.h"
#include "..\inc\sec.h"
#define IO_BUFFER_SIZE 4096

WSADATA WsaData;
CHAR Target[256];
PCHAR target = NULL;

BOOL DoSSL = FALSE;
BOOL DoPCT = FALSE;
BOOL DoNTLM = FALSE;
PCHAR Username = NULL;
PCHAR Password = NULL;
BOOL Verbose = FALSE;
CHAR IoBuffer[IO_BUFFER_SIZE];

SOCKET
SetupSocket(
    VOID
    );

VOID
DoNtLmAuth(
    SOCKET s,
    CSecurityCtx *Sec
    );

DWORD
Resolve(
    char *  Target
    );

VOID
RunSSL(
    SOCKET s
    );

void
usage( )
{
    printf("seccli\n");
    printf("\t-t <remote server>\n");
    printf("\t-1            do ssl\n");
    printf("\t-2            do pct\n");
    printf("\t-l            do ntlm authentication\n");
    printf("\t-u            username\n");
    printf("\t-p            password\n");
    return;
}

int
_CRTAPI1
main(  int argc,  char * argv[] )
{
    INT cur = 1;
    PCHAR x;
    SOCKET s;
    INT err;

    if ( argc < 2 ) {
        usage( );
        return 1;
    }

    while ( cur < argc ) {

        x=argv[cur++];
        if ( *(x++) == '-' ) {

            switch (*x) {
            case '1':
                DoSSL = TRUE;
                break;
            case '2':
                DoPCT = TRUE;
                break;
            case 'l':
                DoNTLM = TRUE;
                break;
            case 'v': Verbose = TRUE;
                break;
            case 'u':
                if ( cur > argc ) {
                    usage( );
                    return 1;
                }
                Username = argv[cur++];
                break;
            case 'p':
                if ( cur > argc ) {
                    usage( );
                    return 1;
                }
                Password = argv[cur++];
                break;
            case 't':
                if ( cur > argc ) {
                    usage( );
                    return 1;
                }
                target = argv[cur++];
                break;
            default:
                usage( );
                return 1;
            }
        }
    }

    if ( target == NULL ) {
        gethostname( Target, 256);
        target = Target;
    }

    if ( !DoPCT && !DoSSL && !DoNTLM ) {
        printf("One of PCT, SSL or NTLM should be enabled\n");
        return 1;
    }

    if (DoNTLM) {

        if ((Username == NULL) || (Password == NULL)) {
            printf("Must specify user name and password\n");
            return 1;
        }
        printf("Username %s  Password %s\n",Username, Password);
    }

    printf("Server %s\n",target);

    err = WSAStartup( 0x0101, &WsaData );
    if ( err == SOCKET_ERROR ) {
        return 1;
    }

    InitAsyncTrace( );
    NntpInitializeSecurity( );

    s = SetupSocket( );
    if ( s != INVALID_SOCKET ) {
        if ( DoSSL || DoPCT ) {
            RunSSL( s );
        } else {
            DoNtLmAuth( s , NULL );
        }
        closesocket(s);
    }
    NntpTerminateSecurity( );
    WSACleanup( );
    return 1;

} // main()

VOID
RunSSL(
    SOCKET s
    )
{

    CSecurityCtx *SSLClient;
    INT err;
    BOOL firstPass = TRUE;
    BUFFER out;
    DWORD nbytes;
    BOOL moredata;
    NEG_BLOCK neg;
    AUTH_PROTOCOL protocol;

    //
    // Loop processing connections.
    //

    BOOL authInProgress = TRUE;
    BOOL authFailed = FALSE;

    if ( DoPCT ) {
        protocol = AuthProtocolPCT;
    printf("Using the PCT protocol\n");
    } else {
        protocol = AuthProtocolSSL30;
    printf("Using the SSL protocol\n");
    }

    SSLClient = new CSecurityCtx;
    if ( (SSLClient == NULL) ||
         !SSLClient->Initialize( TRUE )) {

        printf("cannot initialize sec ctx\n");
        goto exit;
    }

    do {

        if ( !firstPass ) {
            err = recv( s, IoBuffer, IO_BUFFER_SIZE, 0 );

            if ( err == SOCKET_ERROR ) {

                printf(" recv failed: %d\n", GetLastError() );
                goto exit;

            } else {
                printf("SSL: recv %d bytes\n", err );
            }
        }

        if ( !SSLClient->Converse(
                            firstPass ? NULL : IoBuffer,
                            firstPass ? 0: err,
                            &out,
                            &nbytes,
                            &moredata,
                            protocol
                            ) ) {

            printf("converse failed %x\n",GetLastError());
            authFailed = TRUE;
            break;
        }

        firstPass = FALSE;
        if ( nbytes > 0 ) {
            printf("SSL: sending %d\n",nbytes);
            err = send(
                    s,
                    (PCHAR)out.QueryPtr( ),
                    nbytes,
                    0
                    );

            if ( err == SOCKET_ERROR ) {
                printf("send failed\n");
                authFailed = TRUE;
                break;

            } else if ( !moredata ) {

                //
                // We completed the auth exchanges!
                //

                printf("complete!\n");
                authInProgress = FALSE ;
            }
        } else {
            break;
        }

    } while ( authInProgress );

    if ( authFailed ) {
        printf("SSL auth failed\n");
        goto exit;
    } else {
        printf("SSL successful!\n");
    }

    neg.Flags = 0;

    if ( DoNTLM ) {
        neg.Flags |= NEG_FLAG_AUTH;
    }

    err = send(s,(PCHAR)&neg,sizeof(neg),0);
    if ( err == SOCKET_ERROR ) {
        printf("negotiate send failed\n");
        goto exit;
    }

    if ( !DoNTLM ) {

        CHAR buffer[1024];
        PCHAR buf="ThisIsAVeryLongString";
        LPBYTE start;

        //
        // Send greetings
        //

        if (! SSLClient->SealMessage(
                        (LPBYTE)buf,
                        strlen(buf)+1,
                        &out,
                        &nbytes
                        ) ) {

            printf("Seal message failed\n");
            goto exit;
        }

        printf("send %d\n",nbytes);
        err = send(s,(PCHAR)out.QueryPtr(),nbytes,0);
        if ( err == SOCKET_ERROR ) {
            printf("send encrypted hello\n");
            goto exit;
        }

        err = recv(s,(PCHAR)buffer,1024,0);
        if ( err == SOCKET_ERROR ) {
            printf("negotiate recv failed\n");
            goto exit;
        }
        buffer[err]='\0';

        SSLClient->UnsealMessage(
                            (LPBYTE)buffer,
                            err,
                            &start,
                            &nbytes
                            );

        printf("Got back %s %d\n",start, nbytes);
        goto exit;
    }

    err = recv(s,(PCHAR)&neg,sizeof(neg),0);
    if ( err == SOCKET_ERROR ) {
        printf("negotiate recv failed\n");
        goto exit;
    }

    if ( (neg.Flags & NEG_FLAG_ACK) == 0 ) {
        printf("server did not ack\n");
        goto exit;
    }

    DoNtLmAuth( s, SSLClient );

exit:
    delete SSLClient;
    return;

} // SSLClient

DWORD
Resolve(
    char *  T)
{
    struct hostent *    h;

    if ( inet_addr(T) != INADDR_NONE ) {
        return( inet_addr(T) );
    }

    h = gethostbyname(T);
    if (h) {
        return(*((DWORD *)h->h_addr));
    }

    printf("Could not resolve '%s', %d\n", T, WSAGetLastError() );
    return(INADDR_NONE);
}

VOID
DoNtLmAuth(
    SOCKET s,
    CSecurityCtx *SSLCtx
    )
{
    CSecurityCtx *NtLmClient;
    INT err;
    BUFFER out;
    PCHAR buf;
    DWORD nbytes;
    BOOL moredata;
    BOOL authInProgress = TRUE;
    BOOL authFailed = FALSE;
    BOOL firstPass = TRUE;

    printf("NTLM\n");

    if ( SSLCtx == NULL ) {
        NtLmClient = new CSecurityCtx;
        if ( (NtLmClient == NULL) ||
             !NtLmClient->Initialize( TRUE )) {

            printf("cannot initialize sec ctx\n");
            goto exit;
        }
    } else {
        NtLmClient = SSLCtx;
    }

    //
    // Let's see if it talks NTLM
    //

    buf = "AUTHINFO TRANSACT NTLM\r\n";
    err = send(s,(PCHAR)buf,strlen(buf),0);
    err = recv( s, IoBuffer, IO_BUFFER_SIZE, 0 );

    do {

        if ( !firstPass ) {
            err = recv( s, IoBuffer, IO_BUFFER_SIZE, 0 );

            if ( err == SOCKET_ERROR ) {
                printf(" recv failed: %d\n", GetLastError() );
                goto exit;

            } else {
                printf("NTLM: recv %d bytes\n", err );
            }
        }

        if ( !NtLmClient->Converse(
                            firstPass ? NULL : IoBuffer+4,
                            firstPass ? 0: err,
                            &out,
                            &nbytes,
                            &moredata,
                            AuthProtocolNtLm,
                            firstPass ? Username: NULL,
                            firstPass ? Password:NULL
                            ) ) {

            printf("converse failed %x\n",GetLastError());
            authFailed = TRUE;
            break;
        }

        firstPass = FALSE;
        if ( nbytes > 0 ) {
            buf = "AUTHINFO TRANSACT ";

            err = send(
                    s,
                    (PCHAR)buf,
                    strlen(buf),
                    0
                    );

            printf("NTLM: Sending %d bytes \n",nbytes);

            err = send(
                    s,
                    (PCHAR)out.QueryPtr( ),
                    nbytes,
                    0
                    );

            buf = "\r\n";
            err = send(
                    s,
                    (PCHAR)buf,
                    strlen(buf),
                    0
                    );

            if ( err == SOCKET_ERROR ) {
                printf("send failed\n");
                authFailed = TRUE;
                break;

            } else if ( !moredata ) {

                //
                // We completed the auth exchanges!
                //

                printf("complete!\n");
                authInProgress = FALSE ;
            }
        } else {
            break;
        }

    } while ( authInProgress );

    if ( authFailed ) {
        printf("NTLM auth failed\n");
    } else {

        printf("NTLM successful!\n");
    }
exit:
    if (SSLCtx == NULL ) {
        delete NtLmClient;
    }
}

SOCKET
SetupSocket(
    VOID
    )
{

    SOCKET s;
    SOCKADDR_IN address;
    INT err;
    CHAR buffer[1024];

    s = socket( AF_INET, SOCK_STREAM, 0 );
    if ( s == INVALID_SOCKET ) {
        printf( "socket() failed for listenSocket: %ld\n", GetLastError( ) );
        return(INVALID_SOCKET);
    }

    address.sin_family = AF_INET;
    if ( DoSSL || DoPCT ) {
        printf("Using SSL port\n");
        address.sin_port = htons( NNTP_SSL_PORT );
    } else {
        address.sin_port = htons( NNTP_PORT );
    }
    address.sin_addr.s_addr = Resolve(target);

    err = connect(s, (PSOCKADDR)&address, sizeof(SOCKADDR_IN));
    if ( err == SOCKET_ERROR ) {
        printf("Connect failed %d\n", WSAGetLastError());
        closesocket(s);
        return(INVALID_SOCKET);
    }

    if ( !DoSSL && !DoPCT ) {

        //
        // Get the hello message
        //

        err = recv(s,buffer,sizeof(buffer),0);
        buffer[err]='\0';

        printf("hello is %s\n",buffer);
    }

    return(s);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\ssl\main.cpp ===
#include <buffer.hxx>
#include "..\..\tigris.hxx"
extern "C" {
#define SECURITY_WIN32
#include <rpc.h>
#include <sspi.h>
#include <sslsp.h>
#include <spseal.h>
#include <issperr.h>
}
#include "..\..\security.h"

CSecurityCtx cliCtx, srvCtx;

void
_CRTAPI1
main(  int argc,  char * argv[] )
{
    BOOL ok;
    BUFFER out;
    BUFFER srv;
    DWORD nbytes;
    BOOL more;
    CHAR junk[512];

    CHAR xact[]="TRANSACT ";
    LPSTR reply;
    DWORD nreply;
    DWORD len;
    PCHAR blob;

    InitAsyncTrace( );
    NntpInitializeSecurity( );

    ok = cliCtx.Initialize( TRUE,FALSE);
    if ( !ok ) {
        printf("cli Initialize failed\n");
        return;
    }

    ok = srvCtx.Initialize( FALSE,FALSE);
    if ( !ok ) {
        printf("srv Initialize failed\n");
        return;
    }

    printf("initializing client blob\n");
    ok = cliCtx.Converse(
                    NULL,
                    0,
                    &out,
                    &nbytes,
                    &more,
                    AuthProtocolSSL30
                    );

    if ( ok ) {
        printf("bytes %d\n",nbytes);
        if ( more ) {
            printf("more coming\n");
        }
    } else {
        return;
    }

    printf("process client HELLO\n");
    ok = srvCtx.Converse(
                    out.QueryPtr(),
                    nbytes,
                    &srv,
                    &nbytes,
                    &more,
                    AuthProtocolSSL30
                    );

    if ( ok ) {
        printf("bytes %d\n",nbytes);
        if ( more ) {
            printf("more coming\n");
        }
    } else {
        return;
    }

    printf("process server HELLO\n");
    ok = cliCtx.Converse(
                    srv.QueryPtr( ),
                    nbytes,
                    &out,
                    &nbytes,
                    &more,
                    AuthProtocolSSL30
                    );

    if ( ok ) {
        printf("bytes %d\n",nbytes);
        if ( more ) {
            printf("more coming\n");
        }
    } else {
        return;
    }

    printf("process client MK\n");
    ok = srvCtx.Converse(
                    out.QueryPtr(),
                    nbytes,
                    &srv,
                    &nbytes,
                    &more,
                    AuthProtocolSSL30
                    );

    if ( ok ) {
        printf("bytes %d\n",nbytes);
        if ( more ) {
            printf("more coming\n");
        }
    } else {
        return;
    }

    printf("process server VFY\n");
    ok = cliCtx.Converse(
                    srv.QueryPtr( ),
                    nbytes,
                    &out,
                    &nbytes,
                    &more,
                    AuthProtocolSSL30
                    );

    if ( ok ) {
        printf("bytes %d\n",nbytes);
        if ( more ) {
            printf("more coming\n");
        }
    } else {
        return;
    }

    printf("processing client FINISH\n");
    ok = srvCtx.Converse(
                    out.QueryPtr(),
                    nbytes,
                    &srv,
                    &nbytes,
                    &more,
                    AuthProtocolSSL30
                    );

    if ( ok ) {
        printf("bytes %d\n",nbytes);
        if ( more ) {
            printf("more coming\n");
        }
    } else {
        return;
    }

    printf("process server FINISH\n");
    ok = cliCtx.Converse(
                    srv.QueryPtr( ),
                    nbytes,
                    &out,
                    &nbytes,
                    &more,
                    AuthProtocolSSL30
                    );

    if ( ok ) {
        printf("bytes %d\n",nbytes);
        if ( more ) {
            printf("more coming\n");
        }
    } else {
        return;
    }

    NntpTerminateSecurity( );
    TermAsyncTrace( );
} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\tigstart\mapfile.h ===
/* -------------------------------------------------------------------------
  mapfile.h
      (was bbmpfile.h)
  	Definitions for the mapped file class.

  Copyright (C) 1995   Microsoft Corporation.
  All Rights Reserved.

  Author
  	Lindsay Harris	- lindsayh

  History
	14:49 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, based on pvMapFile() and derivatives.

   ------------------------------------------------------------------------- */

/*
 *    Generic class to handle mapped files.  Part of the reason for
 *  turning this into a class is to allow tracking of mapping/unmapping
 *  and thus to handle clean up of dangling mappings in exception
 *  handling code.  Tracking is enabled if the fTrack parameter is
 *  specified.
 */

//   Bits used in the m_fFlags field below.
#define	MF_TRACKING		0x0001			// Tracking use of this item.
#define	MF_RELINQUISH	0x0002			// Someone else to free this item.


class  CMapFile
{
public:
	CMapFile( const char *pchFileName, HANDLE & hFile, BOOL fWriteEnable, DWORD cbIncrease = 0);
	CMapFile( const WCHAR *pwchFileName, BOOL fWriteEnable, BOOL fTrack );
	CMapFile( const char *pchFileName, BOOL fWriteEnable, BOOL fTrack, DWORD cbSizeIncrease = 0 );
	CMapFile( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD dwSizeIncrease = 0, BOOL fZero = FALSE );

	~CMapFile( void );

	//   Get the details of this item.
	void	*pvAddress( DWORD *pcb ) { if( pcb ) *pcb = m_cb; return m_pv; };

	//   Relinquish control (meaning someone else unmaps file).
	void	 Relinquish( void )  {  m_fFlags |= MF_RELINQUISH;  };

	//	Tells if mapping is OK.
	BOOL	fGood(void) {return NULL != m_pv; };

private:
	DWORD	 m_cb;			// Size of this file.
	void	*m_pv;			// Address to use.
	DWORD	 m_fFlags;		// See above for the bits used in here.
	WCHAR	 m_rgwchFileName[ MAX_PATH ];		// For error recording.

	void	 MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease, BOOL fZero = FALSE );
};


/*
 *    For compatability with old code, the original functions remain.
 */

void *pvMapFile( DWORD *pdwSize, const char  *pchFileName, BOOL bWriteEnable );
void *pvMapFile( DWORD *pdwSize, const WCHAR *pwchFileName, BOOL bWriteEnable );

void *pvMapFile(const char  *pchFileName, BOOL bWriteEnable,
		 DWORD  *pdwSizeFinal = NULL, DWORD dwSizeIncrease = 0);

void * pvFromHandle( HANDLE hFile,	BOOL bWriteEnable,
		DWORD * pdwSizeFinal = NULL, DWORD dwSizeIncrease = 0);

#ifdef DEBUG
//
//	CMapFileEx: version with guard pages to be used only in DEBUG builds
//	to catch other threads writing into our memory !
//

class  CMapFileEx
{
public:
	CMapFileEx( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD dwSizeIncrease = 0 );
	~CMapFileEx( void );

	//   Get the details of this item.
	void	*pvAddress( DWORD *pcb ) { if( pcb ) *pcb = m_cb; return (void*)m_pv; };

	//   Relinquish control (meaning someone else unmaps file).
	void	 Relinquish( void )  {  m_fFlags |= MF_RELINQUISH;  };

	//	Tells if mapping is OK.
	BOOL	fGood(void) {return NULL != m_pv; };

	//	Protect and Unprotect mapping
	BOOL	ProtectMapping();
	BOOL	UnprotectMapping();

private:
	DWORD	 m_cb;								// Size of this file.
	LPBYTE	 m_pv;								// Address to use.
	DWORD	 m_fFlags;							// See above for the bits used in here.
	WCHAR	 m_rgwchFileName[ MAX_PATH ];		// For error recording.

	HANDLE	 m_hFile;							// handle to the mapped file
	LPBYTE	 m_pvFrontGuard;					// front guard page
	DWORD	 m_cbFrontGuardSize;				// front guard page size
	LPBYTE	 m_pvRearGuard;						// rear guard page
	DWORD	 m_cbRearGuardSize;					// rear guard page size
	CRITICAL_SECTION m_csProtectMap;			// crit sect to protect/unprotect mapping

	void	 MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease );
};

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\tigstart\buffer.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    buffer.cxx
    Implementation of the BUFFER class.

    FILE HISTORY:
        RustanL     03-Aug-1990     Created Windows implementation
        RustanL     02-Jan-1991     Adapted for BLT
        RustanL     08-Jan-1991     Moved into UI misc, and added OS/2
                                    and DOS implementation.
        BenG        30-Apr-1991     Uses lmui.hxx
        beng        19-Jun-1991     Inherits from BASE; uses UINT sizes;
                                    documentation corrected and moved
                                    into headers
        beng        19-Mar-1992     Removed OS/2 support
        MuraliK     27-Feb-1995  Modified to make it standalone.
        MuraliK     2-June-1995  Modified to make it into a library.
*/


//
// Normal includes only for this module
//

# include <buffer.hxx>


/*******************************************************************

    NAME:       BUFFER::BUFFER

    SYNOPSIS:   Construct a BUFFER object of the given size.

    ENTRY:
        cbRequested     indicates desired size of buffer object

    CAVEATS:
        Requesting a zero-length buffer returns an object which
        has no allocated storage.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        20-Jun-1991     Uses BASE; size UINT

********************************************************************/

#if 0  // Defined in header file
BUFFER::BUFFER( UINT cbRequested ) :
    _pb(NULL),
    _cb(0)
{
    if ( cbRequested == 0 )
        return;

    GetNewStorage(cbRequested);
}
#endif

/*******************************************************************

    NAME:       BUFFER::GetNewStorage

    SYNOPSIS:   Given an object with no allocated storage,
                allocate the initial memory.

    ENTRY:      cbRequested - amount of storage requested in bytes

    EXIT:       Either storage alloc'd, or error reported
                Sets _cb, _pb

    RETURNS:    TRUE if successful, FALSE for GetLastError()

    NOTES:
        Private member function.

    CAVEATS:
        This function will ReportError itself.

    HISTORY:
        beng        24-Jun-1991     Created (common code factored)
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

BOOL BUFFER::GetNewStorage( UINT cbRequested )
{
    _pb = (BYTE *) ::LocalAlloc( NONZEROLPTR, cbRequested );

    if ( !_pb )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    _cb = cbRequested;

    return TRUE;
}


/*******************************************************************

    NAME:       BUFFER::ReallocStorage

    SYNOPSIS:   Do a "hard" reallocation to the new size

    ENTRY:      cbNewRequested - new size, in bytes

    EXIT:       Storage realloc'd.
                _pb, _cb changed

    RETURNS:    TRUE if successful, FALSE for GetLastError()

    NOTES:
        Private member function.

    HISTORY:
        beng        24-Jun-1991     Created (common code factor)
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

BOOL BUFFER::ReallocStorage( UINT cbNewRequested )
{
    HANDLE hNewMem = ::LocalReAlloc( _pb, cbNewRequested, GMEM_MOVEABLE );

    if (hNewMem == 0)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    _pb = (BYTE *) hNewMem;

    _cb = cbNewRequested;

    return TRUE;
}

/*******************************************************************

    NAME:       BUFFER::~BUFFER

    SYNOPSIS:   Destroys buffer object, and deallocates any memory
                that it might have allocated.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

#if 0 // Defined in header

BUFFER::~BUFFER()
{
#if DBG
    VerifyState();
#endif

    if ( _pb )
    {
        ::LocalFree( (HANDLE) _pb );
    }

#if DBG
    _pb = NULL;
    _cb = 0;
#endif
}

#endif // 0

/*******************************************************************

    NAME:       BUFFER::VerifyState

    SYNOPSIS:   Verifies the state of the object.
                Asserts out if the state is invalid, i.e. if an
                internal error took place.

    NOTES:      This function does nothing in the retail version.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added

********************************************************************/

VOID BUFFER::VerifyState() const
{
}

/*******************************************************************

    NAME:       BUFFER::Resize

    SYNOPSIS:   Resizes the memory object

    ENTRY:
        cbNewRequested   - specifies the new size
        cbSlop           - If a realloc is needed, then cbSlop bytes are
                           added for the reallocation (not for an initial
                           allocation though)

    EXIT:
        _cb and _pb changed; possibly _pb resized

    RETURNS:
        TRUE if successful.  The next call to QueryPtr will then
            return a pointer to the newly allocated memory.
            The new buffer will contain as much of the contents
            of the old buffer as will fit.
        FALSE if unsuccessful.  The old piece of memory, if any,
            still exists.  The next call to QueryPtr will
            return a pointer to this memory.

    NOTES:
        After a call to this method, the caller can *not* rely on any
        pointer that QueryPtr has returned in the past, regardless of
        the success of this method.

        Reallocations to size 0 will always succeed.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        24-Jun-1991     Fold common code; fix bug seen in
                                    resize-to-0,resize-to-original sequence
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Remove OS/2 support

********************************************************************/

BOOL BUFFER::Resize( UINT cbNewRequested,
                     UINT cbSlop )
{
#if DBG
    VerifyState();
#endif

    if ( cbNewRequested != 0 )
    {
        if ( _pb != 0 )
        {
            if ( cbNewRequested > QuerySize() )
            {
                /*
                 * The requested memory exceeds the currently allocated memory.
                 * A reallocation is in order.
                 */
                return ReallocStorage(cbNewRequested + cbSlop);
            }

            return TRUE;
        }
        else
        {
            /*
             * There is no memory handle.  Previous size of buffer
             * must have been 0.
             *
             * The new memory request is allocated.
             */
            return GetNewStorage( cbNewRequested );
        }
    }
    else
    {
        /*
         * The requested memory size is 0.  This will always work.
         */
        if ( _pb )
            ::LocalFree( (HANDLE)_pb );

        _pb = NULL;
        _cb = 0;

        return TRUE;
    }

    return TRUE;
}


/*******************************************************************

    NAME:       BUFFER::Trim

    SYNOPSIS:   Reallocates the buffer so that the actual space alloc'd
                is minimally more than the size requested.

    EXIT:
        After making this call, the client can not rely on any pointer
        that QueryPtr has returned in the past, regardless of the success
        of this method.

    NOTES:
        The actual size of the buffer may be larger than the requested size.
        This method informs the system that only _cb is desired.

        This method is intended to be used only when optimization is key.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        15-Jul-1991     ReallocStorage changed return type
        beng        19-Mar-1992     Remove OS/2 support

********************************************************************/

VOID BUFFER::Trim()
{
#if DBG
    VerifyState();
#endif

    if ( _pb == 0 )
    {
        /*
         * No memory is allocated.
         */
        return;
    }

    if ( _cb == 0 )
    {
        /*
         * The requested size is 0.  Free the allocated memory.
         */
        return;
    }

    /*
     * (This should not fail, since we are reallocating to less
     * than current storage.)
     */
    NO_ERROR == ReallocStorage(_cb);
}

BOOL
BUFFER_CHAIN::AppendBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Adds a new buffer chain item to the end of the buffer chain

Arguments:

    pBCI - Chain item to append

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    InsertTailList( &_ListHead,
                    &pBCI->_ListEntry );

    return TRUE;
}

DWORD
BUFFER_CHAIN::DeleteChain(
    VOID
    )
/*++

Routine Description:

    Deletes all of the buffers in this chain

Return Value:

    Total number of allocated bytes freed by this call

--*/
{
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbFreed = 0;

    while ( !IsListEmpty( &_ListHead ))
    {
        pBCI = CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );

        RemoveEntryList( &pBCI->_ListEntry );

        cbFreed += pBCI->QuerySize();

        delete pBCI;
    }

    return cbFreed;
}

BUFFER_CHAIN_ITEM *
BUFFER_CHAIN::NextBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Returns the next buffer in the chain.  Start the enumeration by
    passing pBCI as NULL.  Continue it by passing the return value

Arguments:

    pBCI - Previous item in enumeration

Return Value:

    Pointer to next item in chain, NULL when done

--*/
{
    if ( pBCI != NULL )
    {
        if ( pBCI->_ListEntry.Flink != &_ListHead )
        {
            return CONTAINING_RECORD( pBCI->_ListEntry.Flink,
                                      BUFFER_CHAIN_ITEM,
                                      _ListEntry );
        }
        else
        {
            return NULL;
        }
    }

    if ( !IsListEmpty( &_ListHead ))
    {
        return CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );
    }

    return NULL;
}

DWORD
BUFFER_CHAIN::CalcTotalSize(
    BOOL fUsed
    ) const
/*++

Routine Description:

    Returns the total amount of memory allocated by this buffer chain
    excluding the size of the structures themselves


Arguments:

    fUsed - If FALSE, returns total allocated by chain, if TRUE returns
        total used by chain

Return Value:

    Total bytes allocated or total bytes used

--*/
{
    LIST_ENTRY *        pEntry;
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbRet = 0;

    for ( pEntry  = _ListHead.Flink;
          pEntry != &_ListHead;
          pEntry  = pEntry->Flink )
    {
        pBCI = CONTAINING_RECORD( pEntry, BUFFER_CHAIN_ITEM, _ListEntry );

        if ( fUsed == FALSE )
            cbRet += pBCI->QuerySize();
        else
            cbRet += pBCI->QueryUsed();
    }

    return cbRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\xover\buffer.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    buffer.cxx
    Implementation of the BUFFER class.

    FILE HISTORY:
        RustanL     03-Aug-1990     Created Windows implementation
        RustanL     02-Jan-1991     Adapted for BLT
        RustanL     08-Jan-1991     Moved into UI misc, and added OS/2
                                    and DOS implementation.
        BenG        30-Apr-1991     Uses lmui.hxx
        beng        19-Jun-1991     Inherits from BASE; uses UINT sizes;
                                    documentation corrected and moved
                                    into headers
        beng        19-Mar-1992     Removed OS/2 support
        MuraliK     27-Feb-1995  Modified to make it standalone.
        MuraliK     2-June-1995  Modified to make it into a library.
*/


//
// Normal includes only for this module
//

# include <buffer.hxx>


/*******************************************************************

    NAME:       BUFFER::BUFFER

    SYNOPSIS:   Construct a BUFFER object of the given size.

    ENTRY:
        cbRequested     indicates desired size of buffer object

    CAVEATS:
        Requesting a zero-length buffer returns an object which
        has no allocated storage.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        20-Jun-1991     Uses BASE; size UINT

********************************************************************/

#if 0  // Defined in header file
BUFFER::BUFFER( UINT cbRequested ) :
    _pb(NULL),
    _cb(0)
{
    if ( cbRequested == 0 )
        return;

    GetNewStorage(cbRequested);
}
#endif

/*******************************************************************

    NAME:       BUFFER::GetNewStorage

    SYNOPSIS:   Given an object with no allocated storage,
                allocate the initial memory.

    ENTRY:      cbRequested - amount of storage requested in bytes

    EXIT:       Either storage alloc'd, or error reported
                Sets _cb, _pb

    RETURNS:    TRUE if successful, FALSE for GetLastError()

    NOTES:
        Private member function.

    CAVEATS:
        This function will ReportError itself.

    HISTORY:
        beng        24-Jun-1991     Created (common code factored)
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

BOOL BUFFER::GetNewStorage( UINT cbRequested )
{
    _pb = (BYTE *) ::LocalAlloc( NONZEROLPTR, cbRequested );

    if ( !_pb )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    _cb = cbRequested;

    return TRUE;
}


/*******************************************************************

    NAME:       BUFFER::ReallocStorage

    SYNOPSIS:   Do a "hard" reallocation to the new size

    ENTRY:      cbNewRequested - new size, in bytes

    EXIT:       Storage realloc'd.
                _pb, _cb changed

    RETURNS:    TRUE if successful, FALSE for GetLastError()

    NOTES:
        Private member function.

    HISTORY:
        beng        24-Jun-1991     Created (common code factor)
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

BOOL BUFFER::ReallocStorage( UINT cbNewRequested )
{
    HANDLE hNewMem = ::LocalReAlloc( _pb, cbNewRequested, GMEM_MOVEABLE );

    if (hNewMem == 0)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    _pb = (BYTE *) hNewMem;

    _cb = cbNewRequested;

    return TRUE;
}

/*******************************************************************

    NAME:       BUFFER::~BUFFER

    SYNOPSIS:   Destroys buffer object, and deallocates any memory
                that it might have allocated.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

#if 0 // Defined in header

BUFFER::~BUFFER()
{
#if DBG
    VerifyState();
#endif

    if ( _pb )
    {
        ::LocalFree( (HANDLE) _pb );
    }

#if DBG
    _pb = NULL;
    _cb = 0;
#endif
}

#endif // 0

/*******************************************************************

    NAME:       BUFFER::VerifyState

    SYNOPSIS:   Verifies the state of the object.
                Asserts out if the state is invalid, i.e. if an
                internal error took place.

    NOTES:      This function does nothing in the retail version.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added

********************************************************************/

VOID BUFFER::VerifyState() const
{
}

/*******************************************************************

    NAME:       BUFFER::Resize

    SYNOPSIS:   Resizes the memory object

    ENTRY:
        cbNewRequested   - specifies the new size
        cbSlop           - If a realloc is needed, then cbSlop bytes are
                           added for the reallocation (not for an initial
                           allocation though)

    EXIT:
        _cb and _pb changed; possibly _pb resized

    RETURNS:
        TRUE if successful.  The next call to QueryPtr will then
            return a pointer to the newly allocated memory.
            The new buffer will contain as much of the contents
            of the old buffer as will fit.
        FALSE if unsuccessful.  The old piece of memory, if any,
            still exists.  The next call to QueryPtr will
            return a pointer to this memory.

    NOTES:
        After a call to this method, the caller can *not* rely on any
        pointer that QueryPtr has returned in the past, regardless of
        the success of this method.

        Reallocations to size 0 will always succeed.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        24-Jun-1991     Fold common code; fix bug seen in
                                    resize-to-0,resize-to-original sequence
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Remove OS/2 support

********************************************************************/

BOOL BUFFER::Resize( UINT cbNewRequested,
                     UINT cbSlop )
{
#if DBG
    VerifyState();
#endif

    if ( cbNewRequested != 0 )
    {
        if ( _pb != 0 )
        {
            if ( cbNewRequested > QuerySize() )
            {
                /*
                 * The requested memory exceeds the currently allocated memory.
                 * A reallocation is in order.
                 */
                return ReallocStorage(cbNewRequested + cbSlop);
            }

            return TRUE;
        }
        else
        {
            /*
             * There is no memory handle.  Previous size of buffer
             * must have been 0.
             *
             * The new memory request is allocated.
             */
            return GetNewStorage( cbNewRequested );
        }
    }
    else
    {
        /*
         * The requested memory size is 0.  This will always work.
         */
        if ( _pb )
            ::LocalFree( (HANDLE)_pb );

        _pb = NULL;
        _cb = 0;

        return TRUE;
    }

    return TRUE;
}


/*******************************************************************

    NAME:       BUFFER::Trim

    SYNOPSIS:   Reallocates the buffer so that the actual space alloc'd
                is minimally more than the size requested.

    EXIT:
        After making this call, the client can not rely on any pointer
        that QueryPtr has returned in the past, regardless of the success
        of this method.

    NOTES:
        The actual size of the buffer may be larger than the requested size.
        This method informs the system that only _cb is desired.

        This method is intended to be used only when optimization is key.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        15-Jul-1991     ReallocStorage changed return type
        beng        19-Mar-1992     Remove OS/2 support

********************************************************************/

VOID BUFFER::Trim()
{
#if DBG
    VerifyState();
#endif

    if ( _pb == 0 )
    {
        /*
         * No memory is allocated.
         */
        return;
    }

    if ( _cb == 0 )
    {
        /*
         * The requested size is 0.  Free the allocated memory.
         */
        return;
    }

    /*
     * (This should not fail, since we are reallocating to less
     * than current storage.)
     */
    NO_ERROR == ReallocStorage(_cb);
}

BOOL
BUFFER_CHAIN::AppendBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Adds a new buffer chain item to the end of the buffer chain

Arguments:

    pBCI - Chain item to append

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    InsertTailList( &_ListHead,
                    &pBCI->_ListEntry );

    return TRUE;
}

DWORD
BUFFER_CHAIN::DeleteChain(
    VOID
    )
/*++

Routine Description:

    Deletes all of the buffers in this chain

Return Value:

    Total number of allocated bytes freed by this call

--*/
{
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbFreed = 0;

    while ( !IsListEmpty( &_ListHead ))
    {
        pBCI = CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );

        RemoveEntryList( &pBCI->_ListEntry );

        cbFreed += pBCI->QuerySize();

        delete pBCI;
    }

    return cbFreed;
}

BUFFER_CHAIN_ITEM *
BUFFER_CHAIN::NextBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Returns the next buffer in the chain.  Start the enumeration by
    passing pBCI as NULL.  Continue it by passing the return value

Arguments:

    pBCI - Previous item in enumeration

Return Value:

    Pointer to next item in chain, NULL when done

--*/
{
    if ( pBCI != NULL )
    {
        if ( pBCI->_ListEntry.Flink != &_ListHead )
        {
            return CONTAINING_RECORD( pBCI->_ListEntry.Flink,
                                      BUFFER_CHAIN_ITEM,
                                      _ListEntry );
        }
        else
        {
            return NULL;
        }
    }

    if ( !IsListEmpty( &_ListHead ))
    {
        return CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );
    }

    return NULL;
}

DWORD
BUFFER_CHAIN::CalcTotalSize(
    BOOL fUsed
    ) const
/*++

Routine Description:

    Returns the total amount of memory allocated by this buffer chain
    excluding the size of the structures themselves


Arguments:

    fUsed - If FALSE, returns total allocated by chain, if TRUE returns
        total used by chain

Return Value:

    Total bytes allocated or total bytes used

--*/
{
    LIST_ENTRY *        pEntry;
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbRet = 0;

    for ( pEntry  = _ListHead.Flink;
          pEntry != &_ListHead;
          pEntry  = pEntry->Flink )
    {
        pBCI = CONTAINING_RECORD( pEntry, BUFFER_CHAIN_ITEM, _ListEntry );

        if ( fUsed == FALSE )
            cbRet += pBCI->QuerySize();
        else
            cbRet += pBCI->QueryUsed();
    }

    return cbRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\ssltest\main.cpp ===
#define INITGUID

#include <windows.h>
#include <winsock.h>
#include <stdlib.h>
#include <stdio.h>

extern "C" {
#define SECURITY_WIN32
#include <rpc.h>
#include <sspi.h>
#include <spseal.h>
#include <issperr.h>
}

#include <iiscnfg.h>
#include <ole2.h>
#include <iadm.h>
#include <imd.h>
#include <dbgutil.h>

#include <mapctxt.h>
#include <simssl2.h>

#include <cpool.h>
#include <dbgtrace.h>

DECLARE_DEBUG_PRINTS_OBJECT();

#ifdef	THIS_FILE
#undef	THIS_FILE
#endif
static char	__szTraceSourceFile[]= __FILE__;
#define	THIS_FILE	__szTraceSourceFile

#define VERBOSE_PRINTF(ARG_IN_PARENS) { if (fVerbose) printf ARG_IN_PARENS ; }

#define DEFAULT_COMPLETION_TIMEOUT	(5 * 1000)	// 5 seconds


#define	MAX_THREADS		64
#define	MAX_ITERATIONS	32000
#define	MAX_CLIENTS		32000
#define	MAX_BUFFER_SIZE	32000
#define	MAX_SEAL_SIZE	32000 - 200
#define MAX_WRITES_IN_GROUP	64000


HANDLE	hStartEvent;

long	nTerminated;
int		nThreads = 1;
int		nClients = 1;
int		nIters = 1;
int		cbBuffer = 1024;
DWORD	cbSealSize = 400;
BOOL	fVerbose = FALSE;
DWORD	dwSslCertFlags = 0;
USHORT	usPort = 995;
IN_ADDR	RemoteIpAddress;

DWORD	g_nGroupWrites = 1;
BOOL	g_fSleepAfterEachWrite = FALSE;
DWORD	g_nSleepAfterEachWrite = 0;

BOOL	g_fLogReceivedBytes = FALSE;
LPSTR	g_pszReceivedFilePrefix = NULL;

LPSTR	pszServer = "127.0.0.1";
LPSTR	pszFileName = NULL;

HANDLE	hFile;
HANDLE	hFileMapping;
LPBYTE	pFile;
DWORD	dwFileSize = 0;
HANDLE	hCompletionPort = NULL;
IMSAdminBaseW * g_pAdminBase = NULL;

#define	SSL_SIGNATURE	(DWORD)'TlsS'


enum STATE {
	CONNECTING,
	CONVERSE_STATE,
	SEAL_STATE
};

class CSslTest {

	public:
		static	CPool	Pool;
		static	DWORD	cClients;

		CSslTest( int nClientNum );
		~CSslTest();

		//
		// override mem functions to use CPool functions
		//
		void* operator new( size_t cSize )
							{ return	Pool.Alloc(); }

		void operator delete( void *pInstance )
							{ Pool.Free( pInstance ); }


		BOOL	CompletionRoutine(
							DWORD dwBytes,
							DWORD dwStatus,
							LPOVERLAPPED lpOverlapped
						);

		BOOL	Connect( void );
		VOID	Reset( void );

		DWORD	m_dwSignature;


	private:

		//
		// simplified WriteFile
		//
		BOOL WriteFile( DWORD dwBytes );

		//
		// simplified ReadFile
		//
		BOOL ReadFile( DWORD dwOffset );

		void ProcessRead( DWORD dwBytes );
		void ProcessWrite( DWORD dwBytes );

		//
		// simplified closesocket routine
		//
		void Disconnect( void )
		{
			SOCKET	s;

			s = (SOCKET)InterlockedExchangePointer((void**)&m_hSocket, (void*)INVALID_HANDLE_VALUE );

			if ( s != (SOCKET)INVALID_HANDLE_VALUE )
			{
				closesocket( s );
			}
		}

		BOOL Converse( DWORD	dwBytes );

		int			m_nClientNum;
		OVERLAPPED	m_InOverlapped;
		OVERLAPPED	m_OutOverlapped;
		HANDLE		m_hSocket;
		CEncryptCtx	m_encrypt;
		DWORD		m_cbReceived;
		DWORD		m_dwFileOffset;
		DWORD		m_dwBytesWritten;
		STATE		m_eState;
		LONG		m_IoRefCount;
		LPBYTE		m_OutBuffer;
		LPBYTE		m_InBuffer;
		LPBYTE		m_nIterations;

		HANDLE		m_hReceivedLog;
		//
		// provided for example only
		//
		DWORD		m_cbParsable;

	public:
		BYTE		Buffer[1];

};

CPool	CSslTest::Pool( SSL_SIGNATURE );
DWORD	CSslTest::cClients = 0;


CSslTest::CSslTest( int nClientNum ) :
	m_nClientNum ( nClientNum ),
	m_hSocket( INVALID_HANDLE_VALUE ),
	m_encrypt( TRUE, dwSslCertFlags ),
	m_dwSignature( SSL_SIGNATURE ),
	m_cbReceived( 0 ),
	m_dwFileOffset( 0 ),
	m_IoRefCount( 0 ),
	m_cbParsable( 0 ),
	m_dwBytesWritten( 0 ),
	m_nIterations( 0 ),
	m_hReceivedLog( INVALID_HANDLE_VALUE ),
	m_eState( CONNECTING )
{
	InterlockedIncrement( (LPLONG)&cClients );

	m_OutBuffer = Buffer;
	m_InBuffer = Buffer + cbBuffer;

	if ( g_pszReceivedFilePrefix ) {
		char szReceivedFileName[MAX_PATH];

		wsprintf ( szReceivedFileName, 
					"%s%d.log",
					g_pszReceivedFilePrefix,
					m_nClientNum 
					);

		m_hReceivedLog = CreateFile ( szReceivedFileName,
									GENERIC_WRITE,
									FILE_SHARE_READ,
									NULL,
									CREATE_ALWAYS,
									FILE_FLAG_SEQUENTIAL_SCAN,
									NULL
									);

		if ( m_hReceivedLog == INVALID_HANDLE_VALUE ) {
			VERBOSE_PRINTF ( ( 
				"Unable to open log file for client[%d]'s output\n",
				m_nClientNum ) );
		}
	}
}


//
// simply decs an overal count
//
CSslTest::~CSslTest( void )
{
	InterlockedDecrement( (LPLONG)&cClients );
	if ( m_hReceivedLog != INVALID_HANDLE_VALUE ) {
		CloseHandle ( m_hReceivedLog );
	}
}

VOID
CSslTest::Reset( void )
{
	Disconnect();		// m_hSocket = INVALID_HANDLE_VALUE;

	m_encrypt.Reset();

	m_dwSignature = SSL_SIGNATURE;
	m_cbReceived = 0;
	m_dwFileOffset = 0;
	m_IoRefCount = 0;
	m_cbParsable = 0;
	m_dwBytesWritten = 0;
	m_eState = CONNECTING;

	m_OutBuffer = Buffer;
	m_InBuffer = Buffer + cbBuffer;

	//
	// don't reset the number of iterations
	//
	m_nIterations = 0;
}


//
// routine that wraps the Converse method
//
BOOL
CSslTest::Converse( DWORD dwBytes )
{
	TraceFunctEnterEx( (LPARAM)this, "CSslTest::Converse" );
				
	DWORD	cbWriteBytes = cbBuffer;
	BYTE	pTemp[1024];
	BOOL	fMore;
	DWORD	dw;

	dw = m_encrypt.Converse(m_InBuffer,
							m_cbReceived,
							pTemp,
							&cbWriteBytes,
							&fMore,
							NULL,
							NULL,
							NULL,
							0 );

	if ( dw == NO_ERROR )
	{
		//
		// reset the read offset into out buffer
		//
		m_cbReceived = 0;

		//
		// set the state before issuing any necessary writes
		//
		m_eState = fMore ? CONVERSE_STATE : SEAL_STATE ;

		//
		// send any bytes required for the client
		//
		if ( cbWriteBytes != 0 )
		{
			CopyMemory( m_OutBuffer, pTemp, cbWriteBytes );
			if ( WriteFile( cbWriteBytes ) == FALSE )
			{
				DebugTrace( (LPARAM)this,
							"WriteFile failed: 0x%08X",
							GetLastError() );
				return	FALSE;
			}
		}

		if ( !fMore )
		{
			char	szTemp[1024];

			lstrcpyn( szTemp, pszServer, sizeof(szTemp) );

			VERBOSE_PRINTF ( ( "Client[%d] finished with Converse Phase\n", m_nClientNum ) );

			VERBOSE_PRINTF ( ( "Client[%d] cert %s match %s and %s expired\n",
								m_nClientNum,
								m_encrypt.CheckCertificateCommonName( szTemp ) ?
								"does" : "does not",
								pszServer,
								m_encrypt.CheckCertificateExpired() ?
								"has not" : "has" ) );

		}

		if ( fMore )
		{
			//
			// more handshaking required send the output synchronously
			// and repost the read
			//
			_ASSERT( cbWriteBytes != 0 );
		}
		else if ( cbWriteBytes == 0 )
		{
			//
			// in this case we didn't have anything to write to the client
			// and therefore no writes will complete triggering our xfer
			// of the file. therefore we need to start the process here
			//
			ProcessWrite( m_dwBytesWritten = 0 );
		}
	}
	else if ( dw == SEC_E_INCOMPLETE_MESSAGE )
	{
		//
		// haven't received the full packet from the client
		//
		_ASSERT( cbWriteBytes == 0 );

		DebugTrace( (LPARAM)this, "Insufficient Buffer" );
	}
	else
	{
		DebugTrace( (LPARAM)this,
					"Converse failed: 0x%08X\n", dw );

		Disconnect();
		return FALSE;
	}

	return	ReadFile( m_cbReceived );
}



BOOL
CSslTest::ReadFile( DWORD dwOffset )
{
	TraceFunctEnterEx( (LPARAM)this, "CSslTest::ReadFile" );

	DWORD	dwBytes = cbBuffer - dwOffset;

	if ( dwBytes == 0 || dwBytes > (DWORD)cbBuffer )
	{
		ErrorTrace( (LPARAM)this,
					"Expected bytes (%d) to read is out of range (%d). ",
					dwBytes, cbBuffer );

		return	FALSE;
	}	

	DebugTrace( (LPARAM)this,
				"ReadFile %d bytes",
				dwBytes );

	ZeroMemory( (LPVOID)&m_InOverlapped, sizeof(m_InOverlapped) );

	InterlockedIncrement( &m_IoRefCount );
	if (::ReadFile(	m_hSocket,
					m_InBuffer + dwOffset,
					dwBytes,
					&dwBytes,
					&m_InOverlapped ) == FALSE )
						
	{
		DWORD	err = GetLastError();

		if ( err == ERROR_IO_PENDING )
		{
			return	TRUE;
		}

		ErrorTrace( (LPARAM)this, "ReadFile failed: %d", err );
		InterlockedDecrement( &m_IoRefCount );

		return	FALSE;
	}
	else
	{
		return	TRUE;
	}
}



BOOL
CSslTest::WriteFile( DWORD dwBytes )
{
	TraceFunctEnterEx( (LPARAM)this, "CSslTest::WriteFile" );

	ZeroMemory( (LPVOID)&m_OutOverlapped, sizeof(m_OutOverlapped) );

	DebugTrace( (LPARAM)this,
				"WriteFile %d bytes",
				dwBytes );

	MessageTrace((LPARAM)this, m_OutBuffer, dwBytes );

	DWORD	cbToSendAsync = dwBytes;
	DWORD	ibCurrent = 0 ;

	if ( g_nGroupWrites > 1 /* && m_eState != CONVERSE_STATE */ ) {
		DWORD	nSyncWrites = g_nGroupWrites - 1;
		DWORD	cbBytesPerSyncWrite;
		DWORD	cbRemaining;

		if ( nSyncWrites >= dwBytes ) {
			nSyncWrites = dwBytes - 1;
		}

		_ASSERT ( nSyncWrites > 0 );

		cbBytesPerSyncWrite = dwBytes / g_nGroupWrites;
		cbRemaining = cbBytesPerSyncWrite * nSyncWrites;
		cbToSendAsync = dwBytes - cbRemaining;

		_ASSERT ( cbToSendAsync > 0 );

		while( cbRemaining != 0 ) {
			DWORD dw;
			int err;

			err = ::send( (SOCKET)m_hSocket, 
					(char*)m_OutBuffer + ibCurrent, 
					cbBytesPerSyncWrite, 
					0 ) ;

			if ( err == SOCKET_ERROR ) {
				ErrorTrace ( (LPARAM)this, "Socket error = %d\n", WSAGetLastError () );
			}

			ibCurrent += cbBytesPerSyncWrite;
			cbRemaining -= cbBytesPerSyncWrite;

			if ( g_fSleepAfterEachWrite ) {
				Sleep ( g_nSleepAfterEachWrite );
			}
		}
	}
	
	m_dwBytesWritten = cbToSendAsync;
	InterlockedIncrement( &m_IoRefCount );
	if ( ::WriteFile(m_hSocket,
					m_OutBuffer+ibCurrent,
					cbToSendAsync,
					&dwBytes,
					&m_OutOverlapped ) == FALSE )
	{
		DWORD	err = GetLastError();

		if ( err == ERROR_IO_PENDING )
		{
			return	TRUE;
		}

		ErrorTrace( (LPARAM)this, "WriteFile failed: %d", err );
		InterlockedDecrement( &m_IoRefCount );

		return	FALSE;
	}
	else
	{
		return	TRUE;
	}
}


//
// deals with completing reads when we're in the SEAL_STATE
//
void
CSslTest::ProcessRead( DWORD dwBytes )
{
	TraceFunctEnterEx( (LPARAM)this, "CSslTest::ProcessRead" );

	DWORD	cbExpected;
	DWORD	cbReceived;
	DWORD	cbParsable;

	DebugTrace( (LPARAM)this,
				"ReadFile complete %d bytes",
				dwBytes );

	MessageTrace( (LPARAM)this, m_InBuffer + m_cbReceived, dwBytes );

	m_cbReceived += dwBytes;

	if ( m_eState == CONVERSE_STATE )
	{
		Converse( dwBytes );
		return;
	}

	m_encrypt.DecryptInputBuffer(m_InBuffer + m_cbParsable,
								m_cbReceived - m_cbParsable,
								&cbReceived,
								&cbParsable,
								&cbExpected );

	//
	// new total received size is the residual from last processing
	// and whatever is left in the current decrypted read buffer
	//
	m_cbReceived = m_cbParsable + cbReceived;


	//
	// new total parsable size is the residual from last processing
	// and whatever was decrypted from this read io operation
	//
	m_cbParsable += cbParsable;

	//
	// if we're single threaded then printf after null terminating
	// other need to do more code work on the data upto m_cbParsable
	//

	if ( nThreads == 1 && m_cbParsable )
	{
		LPBYTE	pCopy = (LPBYTE)LocalAlloc( 0, m_cbParsable + 1 );

		if ( pCopy )
		{
			CopyMemory( pCopy, m_InBuffer, m_cbParsable );
			pCopy[ m_cbParsable ] = 0;

			printf( (const char *)pCopy );

			LocalFree( pCopy );
		}
	}

	if ( m_cbParsable && m_hReceivedLog != INVALID_HANDLE_VALUE ) {

		BOOL	fSuccess;
		DWORD	cbWrit;

		fSuccess = ::WriteFile ( m_hReceivedLog, 
								m_InBuffer, 
								m_cbParsable,
								&cbWrit,
								NULL );

		if ( !fSuccess || (cbWrit != m_cbParsable) ) {
			ErrorTrace ( (LPARAM) this, 
				"Unable to write to client[%d]'s log file (err = %d)", 
				m_nClientNum,
				GetLastError ()
				);
		}
	}

	MoveMemory( m_InBuffer,
				m_InBuffer + m_cbParsable,
				m_cbReceived - m_cbParsable );

	m_cbReceived -= m_cbParsable;
	m_cbParsable = 0;

	//
	// repost the read
	//
	ReadFile( m_cbReceived );
}


//
// deals with completing writes when we're in the SEAL_STATE
//
void
CSslTest::ProcessWrite( DWORD dwBytes )
{
	TraceFunctEnterEx( (LPARAM)this, "CSslTest::ProcessWrite" );

	DWORD	dw = min( dwFileSize - m_dwFileOffset, cbSealSize );
				
	DebugTrace( (LPARAM)this,
				"WriteFile complete %d bytes",
				dwBytes );

	if ( m_dwBytesWritten != dwBytes )
	{
		ErrorTrace( (LPARAM)this,
					"Unexpected number of bytes: %d, expected: %d",
					dwBytes, m_dwBytesWritten );

		Disconnect();
		return;
	}

	//
	// nothing to do in the converse state
	//
	if ( m_eState == CONVERSE_STATE )
	{
		return;
	}

	//
	// check to see if we've completed transmitting the file
	//

	if ( m_dwFileOffset == dwFileSize )
	{
		//
		// do nothing since the server will whether or not to close
		// the socket
		//

		VERBOSE_PRINTF ( ( "Client[%d] finished transmitting the file\n", m_nClientNum ) );
		return;
	}

	if ( m_encrypt.SealMessage(	pFile + m_dwFileOffset,
								dw,
								m_OutBuffer,
								&dwBytes ) )
	{
		m_dwFileOffset += dw;

		if ( WriteFile( dwBytes ) )
		{
			//
			// success
			//
			return;
		}
		else
		{
			ErrorTrace( (LPARAM)this,
						"WriteFile failed: %d", GetLastError() );
		}
	}
	else
	{
		ErrorTrace( (LPARAM)this,
					"SealMessage failed: 0x%08X", GetLastError() );
	}

	//
	// if we get here for any reason disconnect and as a result shutdown
	//
	Disconnect();
}


//
// gets us connected to the remote server
//
BOOL
CSslTest::Connect( void )
{
	int			err;
	SOCKET		s;
	SOCKADDR_IN remoteAddr;

	// Open a socket using the Internet Address family and TCP
	s = socket (AF_INET, SOCK_STREAM, 0);
	if (s == INVALID_SOCKET)
	{       
		printf ("Shutsrv: socket failed: %ld\n", WSAGetLastError ());
		return	FALSE;
	}

	// Connect to an agreed upon port on the host.  
	ZeroMemory( &remoteAddr, sizeof (remoteAddr) );

	remoteAddr.sin_family = AF_INET;
	remoteAddr.sin_port = htons (usPort);
	remoteAddr.sin_addr = RemoteIpAddress;

	err = connect (s, (PSOCKADDR) & remoteAddr, sizeof (remoteAddr));
	if (err == SOCKET_ERROR)
	{
		printf( "SSLTEST: connect failed: %ld\n", WSAGetLastError());
		closesocket( s );
		return	FALSE;
	}

	m_hSocket = (HANDLE)s;

	//
	// associate this socket with the completion port
	//
	hCompletionPort = CreateIoCompletionPort(
								m_hSocket,
								hCompletionPort,
								(DWORD)this,
								0 );

	if ( hCompletionPort == NULL ) 
	{
		printf("CreateIoCompletionPort failed..Error = %d\n", GetLastError() );
		return FALSE;
	}


	//
	// need to wrap the converse call in inc/dec calls to avoid tearing down
	// failed converses with pending IOs
	//
	InterlockedIncrement( &m_IoRefCount );
	Converse( 0 );
	return	InterlockedDecrement( &m_IoRefCount ) > 0;
}


//
// per instance completion routine
//
BOOL
CSslTest::CompletionRoutine(
			DWORD dwBytes,
			DWORD dwStatus,
			LPOVERLAPPED lpOverlapped )
{
	TraceFunctEnterEx( (LPARAM)this, "CSslTest::CompletionRoutine" );

	_ASSERT( m_dwSignature == SSL_SIGNATURE );
	_ASSERT(lpOverlapped == &m_InOverlapped ||
			lpOverlapped == &m_OutOverlapped );

	if ( dwStatus != 0 || dwBytes == 0 )
	{
		ErrorTrace( (LPARAM)this,
					"Completion err: %d, bytes: %d",
					dwStatus, dwBytes );

		Disconnect();
	}
	else switch( m_eState )
	{
	case CONNECTING:
		_ASSERT( FALSE );
		break;

	case CONVERSE_STATE:
	case SEAL_STATE:
		if ( lpOverlapped == &m_InOverlapped )
		{
			ProcessRead( dwBytes );
		}
		else if ( lpOverlapped == &m_OutOverlapped )
		{
			ProcessWrite( dwBytes );
		}
		else
		{
			_ASSERT( FALSE );
		}
		break;

	default:
		_ASSERT( FALSE );
	}

	BOOL	bContinue = InterlockedDecrement( &m_IoRefCount ) > 0;

	if ( bContinue == FALSE )
	{
		DebugTrace( (LPARAM)this, "Going down. ref: %d", m_IoRefCount );
		_ASSERT( m_IoRefCount == 0 );
	}
	else
	{
		DebugTrace( (LPARAM)this, "Continuing... ref: %d", m_IoRefCount );
	}
	return	bContinue;
}



//
// worker thread for servicing the completion port
//
DWORD CompletionThread( LPDWORD lpdw )
{
	DWORD		dwThreadId = GetCurrentThreadId();
	DWORD		dwBytes;
	CSslTest*	lpClient;
	DWORD		nConsecutiveTimeouts = 0;

	LPOVERLAPPED lpOverlapped;


	TraceFunctEnter( "TraceThread" );

	//
	// initialize the pool tracker array
	//
	WaitForSingleObject( hStartEvent, INFINITE );

	if ( hCompletionPort == NULL ) {
		ErrorTrace ( NULL,
			"hCompletionPort is NULL, terminating worker thread #%d",
			dwThreadId );

		goto Exit;
	}

	while( TRUE )
	{
		BOOL bSuccess;

		bSuccess = GetQueuedCompletionStatus(
										hCompletionPort,
										&dwBytes,
										(LPDWORD)&lpClient,
										&lpOverlapped,
										DEFAULT_COMPLETION_TIMEOUT );

		if ( bSuccess || lpOverlapped )
		{
			nConsecutiveTimeouts = 0;

			if ( lpClient == NULL )
			{
				printf ( "Shutdown\n" );
				//
				// signal to shutdown
				//
				break;
			}

			if ( lpClient->CompletionRoutine(
									dwBytes,
									bSuccess ? NO_ERROR : GetLastError(),
									lpOverlapped ) == FALSE )
			{
				delete	lpClient;
			}
		}
		else
		{
			if ( CSslTest::cClients == 0 ) {
				break;
			}

			nConsecutiveTimeouts++;

			if ( nConsecutiveTimeouts % 10 == 0 ) {

				DebugTrace( (LPARAM)NULL,
						"Thread[%d]: Warning %d Consecutive Timeouts waiting on completion port\n",
						dwThreadId,
						nConsecutiveTimeouts
						);

				VERBOSE_PRINTF ( (
					"Thread[%d]: Warning %d Consecutive Timeouts waiting on completion port\n",
					dwThreadId,
					nConsecutiveTimeouts
					) );

				ErrorTrace( (LPARAM)lpClient,
							"GetQueuedCompletionStatus failed: %d",
							GetLastError() );
			}
		}
	}

Exit:
	InterlockedIncrement( &nTerminated );
	VERBOSE_PRINTF ( ("Exiting Thread: 0x%X, nTerminated: %d\n", dwThreadId, nTerminated ) );

	TraceFunctLeave();
	return	0;
}



void WINAPI ShowUsage( void )
{
	puts ("usage: SSLTEST [switches] filename\n"
			"\t[-?] show this message\n"
			"\t[-v] verbose output\n"
			"\t[-t number-of-threads] specify the number of worker threads\n"
			"\t[-i number-of-iterations] specify the number of interations\n"
			"\t[-c number-of-clients] specify the number of client sessions\n"
			"\t[-g number-of-writes] group write operations\n"
			"\t[-l sleep-time] sleep time between grouped writes\n"
			"\t[-b IO buffer size] specify the size of the IO buffer\n"
			"\t[-x SSL Seal size] specify the size of the Seal buffer\n"
			"\t[-s servername] specify the server to connect to\n"
			"\t[-p port number] specify the port number to connect to\n"
			"\t[-f filename] file to transmit to the server\n"
			"\t[-o filename prefix] log each client's output to a file (eg. client -> client[n].txt)\n"
			"\t[-k] use cert installed by key manager \n"
			 );

	_exit(1);
}


VOID
WINAPI
ParseSwitch (
					CHAR chSwitch,
					int *pArgc,
					char **pArgv[]
)
{
	switch (toupper (chSwitch))
	{

	case '?':
		ShowUsage ();
		break;

	case 'T':
		if (!--(*pArgc))
		{
			ShowUsage ();
		}
		(*pArgv)++;
		nThreads = strtoul (*(*pArgv), NULL, 10);
		if (nThreads > MAX_THREADS)
		{
			nThreads = MAX_THREADS;
		}
		break;

	case 'C':
		if (!--(*pArgc))
		{
			ShowUsage ();
		}
		(*pArgv)++;
		nClients = strtoul (*(*pArgv), NULL, 10);
		if (nClients > MAX_CLIENTS)
		{
			nClients = MAX_CLIENTS;
		}
		break;

	case 'I':
		if (!--(*pArgc))
		{
			ShowUsage ();
		}
		(*pArgv)++;
		nIters = strtoul (*(*pArgv), NULL, 10);
		if (nIters > MAX_ITERATIONS)
		{
			nIters = MAX_ITERATIONS;
		}
		break;

	case 'G':
		if (!--(*pArgc))
		{
			ShowUsage ();
		}
		(*pArgv)++;
		g_nGroupWrites = strtoul (*(*pArgv), NULL, 10 );
		if ( g_nGroupWrites > MAX_WRITES_IN_GROUP ) {
			g_nGroupWrites = MAX_WRITES_IN_GROUP;
		}
		break;

	case 'L':
		if (!--(*pArgc))
		{
			ShowUsage ();
		}
		(*pArgv)++;
		g_fSleepAfterEachWrite = TRUE;
		g_nSleepAfterEachWrite = strtoul (*(*pArgv), NULL, 10 );
		break;

	case 'B':
		if (!--(*pArgc))
		{
			ShowUsage ();
		}
		(*pArgv)++;
		cbBuffer = strtoul (*(*pArgv), NULL, 10);
		if (cbBuffer > MAX_BUFFER_SIZE)
		{
			cbBuffer = MAX_BUFFER_SIZE;
		}
		break;

	case 'X':
		if (!--(*pArgc))
		{
			ShowUsage ();
		}
		(*pArgv)++;
		cbSealSize = (DWORD)strtoul (*(*pArgv), NULL, 10);
		if (cbSealSize > MAX_SEAL_SIZE)
		{
			cbSealSize = MAX_SEAL_SIZE;
		}
		break;

	case 'P':
		if (!--(*pArgc))
		{
			ShowUsage ();
		}
		(*pArgv)++;
		usPort = (USHORT)strtoul (*(*pArgv), NULL, 10);
		break;

	case 'S':
		if (!--(*pArgc))
		{
			ShowUsage ();
		}
		(*pArgv)++;

		pszServer = *(*pArgv);
		break;

	case 'F':
		if (!--(*pArgc))
		{
			ShowUsage ();
		}
		(*pArgv)++;
		pszFileName = *(*pArgv);
		break;

	case 'O':
		if (!--(*pArgc))
		{
			ShowUsage ();
		}
		(*pArgv)++;
		g_fLogReceivedBytes = TRUE;
		g_pszReceivedFilePrefix = *(*pArgv);
		break;

	case 'V':
		fVerbose = TRUE;
		break;

	case 'K':
		dwSslCertFlags |= MD_ACCESS_NEGO_CERT;
		break;

	default:
		printf ("TEST: Invalid switch - /%c\n", chSwitch);
		ShowUsage ();
		break;

	}
}

BOOL
ResolveServerName( void )
{
	PHOSTENT host;

	//
	// Assumed host is specified by name
	//
	host = gethostbyname ( pszServer );
	if (host == NULL)
	{
		//
		// See if the host is specified in "dot address" form
		//
		RemoteIpAddress.s_addr = inet_addr( pszServer );
		if (RemoteIpAddress.s_addr == -1)
		{
			printf ("Unknown remote host: %s\n", pszServer );
			return	FALSE;
		}
	}
	else
	{
		CopyMemory ((char *) &RemoteIpAddress, host->h_addr, host->h_length);
	}
	return	TRUE;
}

HRESULT
InitAdminBase()
{
    HRESULT hRes = S_OK;

    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hRes)) {
        hRes = CoCreateInstance(
                   CLSID_MSAdminBase_W,
                   NULL,
                   CLSCTX_SERVER,
                   IID_IMSAdminBase_W,
                   (void**) &g_pAdminBase
                   );
    }
    else {
        CoUninitialize();
    }

    return hRes;
}

VOID
UninitAdminBase()
{
    if (g_pAdminBase != NULL) {
        g_pAdminBase->Release();
        CoUninitialize();
        g_pAdminBase = NULL;
    }
}

int __cdecl main ( int argc, char *argv[], char *envp[] )
{
	DWORD	 dw;
	int		 i;
	HANDLE	 hThreads[MAX_THREADS];
	char	 chChar, *pchChar;
	DWORD	 StartTime, EndTime;
	LPHANDLE pThread;
	BOOL	 fResult;
	WSADATA	 wsa;
    HRESULT  hresErr;

	InitAsyncTrace();
	TraceFunctEnter( "main" );

    hresErr = InitAdminBase();
    if( FAILED(hresErr) )
    {
    	printf("Failed to create metabase object\n");
    	exit(0);
    }

	WSAStartup( MAKEWORD(1,1), &wsa );
	CEncryptCtx::Initialize( "Nntpsvc", (IMDCOM*)NULL, NULL, (LPVOID)g_pAdminBase );

	while (--argc)
	{
		pchChar = *++argv;
		if (*pchChar == '/' || *pchChar == '-')
		{
			while (chChar = *++pchChar)
			{
				ParseSwitch (chChar, &argc, &argv);
			}
		}
	}

	if ( pszFileName == NULL )
	{
		ShowUsage();
		return	-1;
	}

	if ( ResolveServerName() == FALSE )
	{
		ShowUsage();
		return	-4;
	}


	hFile = CreateFile(	pszFileName,
						GENERIC_READ,
						FILE_SHARE_READ,
						NULL,
						OPEN_EXISTING,
						FILE_ATTRIBUTE_NORMAL,
						NULL );

	if ( hFile == INVALID_HANDLE_VALUE )
	{
		printf( "Failed to open %s with the following error: %d",
				pszFileName, GetLastError() );
		return	-2;
	}

	dwFileSize = GetFileSize( hFile, NULL );

	hFileMapping = CreateFileMapping(
						hFile,
						NULL,
						PAGE_READONLY,
						0, 0,
						NULL );

	if ( hFile == NULL )
	{
		printf( "Failed to create mapping for %s with the following error: %d",
				pszFileName, GetLastError() );
		return	-3;
	}


	pFile = (LPBYTE)MapViewOfFile(
						hFileMapping,
						FILE_MAP_READ,
						0, 0, 0 );

	if ( pFile == NULL )
	{
		printf( "Failed to map %s with the following error: %d",
				pszFileName, GetLastError() );
		return	-4;
	}



	//
	// Initialize the pool
	//

	fResult = CSslTest::Pool.ReserveMemory(
							nClients,
							FIELD_OFFSET( CSslTest, Buffer ) + cbBuffer*2 );
	if( !fResult )
	{
		printf("\n.Pool Init failure.");
		DebugTrace( 0, "HCTEST2 ending.");
		TraceFunctLeave();
		TermAsyncTrace();
		exit(1);
	}


	hStartEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

	if ( hStartEvent == NULL )
	{
		printf( "CreateEvent failed: Error: 0x%X\n", GetLastError() );
		return	-2;
	}

	for ( i=0, pThread=hThreads; i<nThreads; i++, pThread++ )
	{
		*pThread = CreateThread(NULL,
								0,
								(LPTHREAD_START_ROUTINE)CompletionThread,
								NULL,
								0,
								&dw );

		if ( *pThread == NULL )
		{
			printf( "CreateThread failed: Error: 0x%X\n", GetLastError() );
			return	-1;
		}

//		printf( "Created Thread: 0x%X\n", dw );
	}

	for ( i=0; i<nClients; i++ )
	{
		CSslTest* pClient = new CSslTest ( i );

		if ( pClient && pClient->Connect() == FALSE )
		{
			delete	pClient;
		}
	}

	//
	// hack;  sleep this thread until background threads get to the starting line
	//
	Sleep( 100 );

	VERBOSE_PRINTF ( ( 
		"%d Threads created for %d iterations. Starting the test.\n", 
		nThreads, 
		nIters ) 
		);

	DebugTrace( 0, "%d Threads created for %d iterations. Starting the test.", nThreads, nIters );

	StartTime = GetTickCount();
	SetEvent( hStartEvent );
	
#if FALSE

	do 
	{
		Sleep( 1000 );
	} while( CSslTest::cClients > 0 );

#else
	
	dw = WaitForMultipleObjects(nThreads,
								hThreads,
								TRUE,
								INFINITE );

#endif

	EndTime = GetTickCount();

	VERBOSE_PRINTF ( ( "Test complete. Number of ticks: %d\n", EndTime - StartTime ) );

	DebugTrace( 0, "Test complete. Number of ticks: %d", EndTime - StartTime );

	_ASSERT( CSslTest::Pool.GetAllocCount() == 0 );

	CSslTest::Pool.ReleaseMemory();

	UnmapViewOfFile( pFile );
	CloseHandle( hFileMapping );
	CloseHandle( hFile );

	CEncryptCtx::Terminate();
	WSACleanup();
	UninitAdminBase();

	TraceFunctLeave();
	TermAsyncTrace();
	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\tigstart\mapfile.cpp ===
/* ------------------------------------------------------------------------
  mapfile.cpp
     (was bbmpfile.cpp)
  	A wrapper function to perform the cook book type operations required
  	to map a file into memory.  Maps the whole file, and nothing but the
  	file, so help me God.  Returns a pointer to void;  NULL on error.
  	An error also results in an entry in the event log, unless the error
  	is "file not found" during CreateFile().

  Copyright (C)  1994, 1995  Microsoft Corporation.
  All Rights Reserved.

  Author
  	Lindsay Harris	- lindsayh

   ------------------------------------------------------------------------ */

#include	<windows.h>
#include	"mapfile.h"

#ifndef	_ASSERT
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
#endif

/* ------------------------------------------------------------------------
  CMapFile::CMapFile
  	Constructor for unicode mapping.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:11 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, to support tracking of objects in exception handling.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( const WCHAR *pwchFileName, BOOL fWriteEnable, BOOL fTrack )
{

    HANDLE   hFile;				// Ditto.

	// Set default values corresponding to no mapping happened.
    //
	m_pv = NULL;
	m_cb = 0;
	m_fFlags = 0;			// Until later.

    hFile = CreateFileW( pwchFileName,
                 fWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
           && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
			// Error case
            //
			m_pv = NULL;
    	}
        return;				// Default values are failure.
    }
    wcsncpy( m_rgwchFileName, pwchFileName, MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, 0 );

	BOOL	fClose = CloseHandle( hFile );
	_ASSERT( fClose ) ;

	return;
}


/* ------------------------------------------------------------------------
  CMapFile::CMapFile
  	Constructor for ascii file name version.

  Author
  	Lindsay Harris	- lindsayh

  History:
	16:13 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to handle tracking of objects for exception handling.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( const char *pchFileName, BOOL fWriteEnable, BOOL fTrack, DWORD cbIncrease )
{
    HANDLE   hFile;				// Ditto.

	//    Set default values corresponding to no mapping happened.
	m_pv = NULL;
	m_cb = 0;
	m_fFlags = 0;				// None set yet.

    hFile = CreateFile( pchFileName,
                 fWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
		   && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
			// Error case
            //
			m_pv = NULL;
    	}
        return;
    }

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pchFileName, -1,
												 m_rgwchFileName, MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease );

	BOOL	fClose = CloseHandle( hFile );
	_ASSERT( fClose ) ;

	return;
}


/* ------------------------------------------------------------------------
  CMapFile::CMapFile.
  	Constructor for ascii file name version.

  Note: Creates file handle if necessary. Does not close file handle.

  Author
  	Lindsay Harris	- lindsayh


  History:
	16:13 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to handle tracking of objects for exception handling.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( const char *pchFileName, HANDLE & hFile, BOOL fWriteEnable, DWORD cbIncrease )
{
	// Set default values corresponding to no mapping happened.
    //
	m_pv = NULL;
	m_cb = 0;
	m_fFlags = 0;				// None set yet.

	if ( INVALID_HANDLE_VALUE == hFile )
	{
		hFile = CreateFile( pchFileName,
					 fWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
					 FILE_SHARE_READ, NULL, OPEN_EXISTING,
					 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

		if ( INVALID_HANDLE_VALUE == hFile )
		{
			//  Only legitimate reason for coming here is non-existent file.
            //
			if (  GetLastError() != ERROR_FILE_NOT_FOUND
               && GetLastError() != ERROR_PATH_NOT_FOUND )
			{
				// Error case
                //
				m_pv = NULL;
			}
			return;
		}
	}

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pchFileName, -1,
												 m_rgwchFileName, MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease );

	return;
}

/* ------------------------------------------------------------------------
  CMapFile::CMapFile
  	Constructor when a file handle is available rather than a name.
	Note that it does not closes the handle

  Author
  	Lindsay Harris	- lindsayh

  History
	16:14 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to allow object tracking.  Based on CarlK's function.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD cbIncrease, BOOL fZero )
{
	m_pv = NULL;
	m_cb = 0;				// Set defaults.
	m_fFlags = 0;			// None set yet.

	wcsncpy( m_rgwchFileName, L"<name unavailable - from handle>", MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease, fZero );

	return;
}


/* ------------------------------------------------------------------------
  CMapFile::~CMapFile
  	Destructor.  Two purposes, being to unmap the file, and optionally
  	remove it from the track data.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:22 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	Numero Uno.

   ------------------------------------------------------------------------ */

CMapFile::~CMapFile( void )
{
    //
	// Unmap the file, if we succeeded in mapping it first!
	//

	if ( !(m_fFlags & MF_RELINQUISH) )
	{
		//   We're still controlling this file, so stick with it.
        //
		if ( m_pv )
		{
			UnmapViewOfFile( m_pv );
		}
	}
	return;
}



/* ------------------------------------------------------------------------
  CMapFile::MapFromHandle
  	Does the real work of mapping.  Given a handle to the file, go through
  	the motions of mapping, and recording what happens.  Reports errors
  	as needed.  Also adjusts file size if requested.

  Author
  	Lindsay Harris	- lindsayh
  	Carl Kadie		- carlk

  History
	16:30 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, based on older code with CarlK enhancements.

   ------------------------------------------------------------------------ */

void
CMapFile::MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease, BOOL fZero )
{

	if ( !fWriteEnable && cbIncrease != 0 )
		return;				// This is non-sensical.

	m_cb = GetFileSize( hFile, NULL );

	DWORD	cbNewSize = 0;

	//
	// Determine if the file is to grow.  Only pass a non-zero size
	// to the system if the size is growing - it's probably faster, and
	// the most likely common case.
	//
	if ( cbIncrease )
	{
		cbNewSize = m_cb += cbIncrease;
	}
	else
	{
		if ( m_cb == 0 )
			return;				// Nothing there.
	}

#if 1
    if ( cbIncrease )
    {
        _ASSERT(fWriteEnable);

        //
        // Make sure the file is the correct size.
        //
        DWORD fpos;
        BOOL  fSetEnd;
        if ( (DWORD)-1 == ( fpos = SetFilePointer( hFile, cbNewSize, NULL, FILE_BEGIN ))
           || !(fSetEnd = SetEndOfFile( hFile ))
           )
        {
            //
            // Error case
            //
            m_pv = NULL;
            return;
        }
    }
#endif

    //
    // Create the mapping object.
    //
	HANDLE hFileMap;				// Intermediate step.

    hFileMap = CreateFileMapping( hFile, NULL,
                                 fWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, cbNewSize, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
		m_pv = NULL;
        return;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    m_pv = MapViewOfFile( hFileMap,
                                 fWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !m_pv )
	{
        // Error case
        //
		m_pv = NULL;
		m_cb = 0;			// Also set to zero, just in case.

	}

	if( fZero && cbIncrease )
	{
		// zero out the part grown
		DWORD cbOldSize = cbNewSize - cbIncrease;
		ZeroMemory( (LPVOID)((LPBYTE)m_pv + cbOldSize), cbNewSize - cbOldSize );
	}

    //
    // Now that we have our pointer, we can close the mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose );
	

    return;

}




/* -------------------------------------------------------------------------
  pvMapFile
  	Map a file into memory and return the base address, NULL on failure.

  Author
  	Lindsay Harris	- lindsayh

  History
	14:21 on Mon 20 Feb 1995    -by-    Lindsay Harris   [lindsayh]
  	Amended to use unicode file name.

	10:18 on Tue 29 Nov 1994    -by-    Lindsay Harris   [lindsayh]
  	Made a separately compiled module.

	10:55 on Mon 10 Oct 1994    -by-    Lindsay Harris   [lindsayh]
  	Added FILE_FLAG_SEQUENTIAL_SCAN to speed up directory reading.

	17:38 on Wed 06 Jul 1994    -by-    Lindsay Harris   [lindsayh]
    Make write enable code functional; clean up some old ideas.

    15:35 on Wed 06 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	Adding this comment, written some time back.

   ------------------------------------------------------------------------- */

void *
pvMapFile( DWORD  *pdwSize, const  WCHAR  *pwchFileName, BOOL bWriteEnable )
{
	//
	// Cook book formula.
	//
    VOID    *pvRet;				// Returned to caller
    HANDLE   hFileMap;			// Used during operations, closed before return
    HANDLE   hFile;				// Ditto.


    hFile = CreateFileW( pwchFileName,
                 bWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
           && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
		    // Error case
    	}
        return NULL;
    }

    //
    // If the caller wants to know the size (usually does) then get it now.
    //
    if ( pdwSize )
		*pdwSize = GetFileSize( hFile, NULL );


    //
    // Create the mapping object.
    //
    hFileMap = CreateFileMapping( hFile, NULL,
                                 bWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, 0, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
        BOOL fClose = CloseHandle( hFile );           // No handle leaks.
		_ASSERT( fClose ) ;

        return NULL;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    pvRet = MapViewOfFile( hFileMap,
                                 bWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !pvRet )
	{
		// Error case
        //
	}

    //
    // Now that we have our pointer, we can close the file and the
    // mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose || hFileMap == 0 ) ;
	fClose = CloseHandle( hFile );
	_ASSERT( fClose || hFile == INVALID_HANDLE_VALUE ) ;

    return pvRet;
}

/* -------------------------------------------------------------------------
  pvMapFile
  	Map a file into memory and return the base address, NULL on failure.

  Author
  	Lindsay Harris	- lindsayh

  History
	10:18 on Tue 29 Nov 1994    -by-    Lindsay Harris   [lindsayh]
  	Made a separately compiled module.

	10:55 on Mon 10 Oct 1994    -by-    Lindsay Harris   [lindsayh]
  	Added FILE_FLAG_SEQUENTIAL_SCAN to speed up directory reading.

	17:38 on Wed 06 Jul 1994    -by-    Lindsay Harris   [lindsayh]
    Make write enable code functional; clean up some old ideas.

    15:35 on Wed 06 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	Adding this comment, written some time back.

   ------------------------------------------------------------------------- */

void *
pvMapFile( DWORD  *pdwSize, const  char  *pchFileName, BOOL bWriteEnable )
{
	//
	// Cook book formula.
	//

    VOID    *pvRet;				/* Returned to caller */
    HANDLE   hFileMap;			// Used during operations, closed before return
    HANDLE   hFile;				// Ditto.


    hFile = CreateFile( pchFileName,
                 bWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
           && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
			// Error case
            //
		}
        return NULL;
    }

    //
    // If the caller wants to know the size (usually does) then get it now.
    //
    if ( pdwSize )
		*pdwSize = GetFileSize( hFile, NULL );


    //
    // Create the mapping object.
    //
    hFileMap = CreateFileMapping( hFile, NULL,
                                 bWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, 0, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
        BOOL fClose = CloseHandle( hFile );           // No handle leaks.
		_ASSERT( fClose ) ;

        return NULL;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    pvRet = MapViewOfFile( hFileMap,
                                 bWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !pvRet )
	{
		// Error case
        //
	}

    //
    // Now that we have our pointer, we can close the file and the
    // mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose || hFileMap == 0 ) ;
	fClose = CloseHandle( hFile );
	_ASSERT( fClose || hFile == INVALID_HANDLE_VALUE ) ;

    return  pvRet;

}



/* -------------------------------------------------------------------------
  pvFromHandle
  	Creates a mapped file from an file handle. Does not close that handle.

  History

  	21 Dec 1994 	-by-	Carl Kadie		 [carlk]
	Based on pvMapFile code by Lindsay Harris   [lindsayh]

   ------------------------------------------------------------------------- */

void *
pvFromHandle( HANDLE hFile,
              BOOL bWriteEnable,        // If the file is to be writeable
              DWORD  * pdwSizeFinal,    // If not Null, returns the final size of the file
              DWORD dwSizeIncrease )    // Use 0 if the size is not to increase
{
	DWORD dwSize;
    VOID    *pvRet;				/* Returned to caller */
    HANDLE   hFileMap;


	dwSize = GetFileSize( hFile, NULL ) + dwSizeIncrease;
    if ( pdwSizeFinal )
	{
		*pdwSizeFinal = dwSize;
	}

	// If the ultimate size of the file is 0, then return NULL. The
	// calling program may decide that this is OK.
    //
	if ( !dwSize)
	{
		return NULL;
	}

#if 1
    if ( dwSizeIncrease )
    {
        _ASSERT(bWriteEnable);

        //
        // Make sure the file is the correct size.
        //
        DWORD fpos;
        BOOL  fSetEnd;
        if ( (DWORD)-1 == (fpos = SetFilePointer( hFile, dwSize, NULL, FILE_BEGIN ))
           || !(fSetEnd = SetEndOfFile( hFile ))
           )
        {
            //
            // Error case
            //
            BOOL fClose = CloseHandle( hFile );           // No handle leaks.
            return NULL;
        }
    }
#endif

    //
    // Create the mapping object.
    //								
    hFileMap = CreateFileMapping( hFile, NULL,
                                 bWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, dwSize, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
        BOOL fClose = CloseHandle( hFile );           // No handle leaks.
        return NULL;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    pvRet = MapViewOfFile( hFileMap,
                                 bWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !pvRet )
	{
		//  Log the error,  but continue, which returns the error.
        //
#if 0
		char	rgchErr[ MAX_PATH + 32 ];
		wsprintf( rgchErr, "MapViewOfFile" );
		LogErrorEvent( MSG_GEN_FAIL, rgchErr, "pvFromHandle" );
#endif
	}

    //
    // Now that we have our pointer, we can close the file and the
    // mapping object.
    //

    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose ) ;

	return pvRet;
}

/* -------------------------------------------------------------------------
  pvMapFile
  	Map a file into memory and return the base address, NULL on failure.
	Also, allows the file to be grown.

  History

  	11:08 on Tue 18 Oct 1994	-by-	Carl Kadie		 [carlk]
	Generalize pvMapFile to add support for adding to the file

	10:55 on Mon 10 Oct 1994    -by-    Lindsay Harris   [lindsayh]
  	Added FILE_FLAG_SEQUENTIAL_SCAN to speed up directory reading.

	17:38 on Wed 06 Jul 1994    -by-    Lindsay Harris   [lindsayh]
    Make write enable code functional; clean up some old ideas.

    15:35 on Wed 06 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	Adding this comment, written some time back.

   ------------------------------------------------------------------------- */

void *
pvMapFile(	const char  * pchFileName,		// The name of the file
			BOOL bWriteEnable,		// If the file is to be writeable
 			DWORD  * pdwSizeFinal, // If not Null, returns the final size of the file
			DWORD dwSizeIncrease )     // Use 0 if the size is not to increase
{
	//
	// Cook book formula.
	//
    HANDLE   hFile;
    VOID    *pvRet;				/* Returned to caller */
	
	// If the file is to grow, it only makes sense to open it read/write.
    //
	if (0 != dwSizeIncrease && !bWriteEnable)
	{
		return NULL;
	}

    hFile = CreateFile( pchFileName,
                 bWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_ALWAYS,  //changed from open_existing
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
        return  NULL;
    }

    //
    // If the caller wants to know the size (usually does) then get it now.
    //
	pvRet = pvFromHandle(hFile, bWriteEnable, pdwSizeFinal, dwSizeIncrease);

	BOOL fClose = CloseHandle( hFile );
	_ASSERT( fClose ) ;

    return  pvRet;
}

#ifdef DEBUG
//
//	CMapFileEx: version with guard pages to be used only in DEBUG builds
//	to catch other threads writing into our memory !
//

/* ------------------------------------------------------------------------
  CMapFileEx::CMapFileEx
  	Constructor when a file handle is available rather than a name.
	Note that it does not closes the handle

  Author
  	Lindsay Harris	- lindsayh

  History
	16:14 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to allow object tracking.  Based on CarlK's function.

   ------------------------------------------------------------------------ */

CMapFileEx::CMapFileEx( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD cbIncrease )
{
	m_pv = NULL;
	m_cb = 0;				// Set defaults.
	m_fFlags = 0;			// None set yet.
	m_hFile = INVALID_HANDLE_VALUE;
	m_pvFrontGuard = NULL;
	m_cbFrontGuardSize = 0;
	m_pvRearGuard = NULL;
	m_cbRearGuardSize = 0;
	InitializeCriticalSection(&m_csProtectMap);

	wcsncpy( m_rgwchFileName, L"<name unavailable - from handle>", MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease );

	m_hFile = hFile;

	return;
}


/* ------------------------------------------------------------------------
  CMapFileEx::~CMapFileEx
  	Destructor.  Two purposes, being to unmap the file, and optionally
  	remove it from the track data.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:22 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	Numero Uno.

   ------------------------------------------------------------------------ */

CMapFileEx::~CMapFileEx( void )
{
    //
	// Unmap the file, if we succeeded in mapping it first!
	//

	//   Lock
	EnterCriticalSection(&m_csProtectMap);

	if ( !(m_fFlags & MF_RELINQUISH) )
	{
		//   We're still controlling this file, so stick with it.
        //
		if ( m_pvFrontGuard )
		{
			// get rid of guard pages
			DWORD dwOldProtect = PAGE_READONLY | PAGE_GUARD;
			if(!VirtualProtect(
						(LPVOID)m_pvFrontGuard,
						m_cbFrontGuardSize,
						PAGE_READWRITE,
						&dwOldProtect
						))
			{
				_ASSERT( 1==0 );
				goto CMapFileEx_Exit ;
			}

			if(!VirtualProtect(
						(LPVOID)m_pv,
						m_cb,
						PAGE_READWRITE,
						&dwOldProtect
						))
			{
				_ASSERT( 1==0 );
				goto CMapFileEx_Exit ;
			}

			if(!VirtualProtect(
						(LPVOID)m_pvRearGuard,
						m_cbRearGuardSize,
						PAGE_READWRITE,
						&dwOldProtect
						))
			{
				_ASSERT( 1== 0 );
				goto CMapFileEx_Exit ;
			}

			MoveMemory( m_pvFrontGuard, m_pv, m_cb );

			FlushViewOfFile( m_pvFrontGuard, m_cb ) ;

			UnmapViewOfFile( (LPVOID)m_pvFrontGuard );

			if( INVALID_HANDLE_VALUE != m_hFile )
			{
				if( SetFilePointer( m_hFile, m_cb, NULL, FILE_BEGIN ) == m_cb ) 
				{
					SetEndOfFile( m_hFile ) ;
				}
			}

			m_pvFrontGuard = m_pvRearGuard = m_pv = NULL ;
		}
	}

CMapFileEx_Exit:

	LeaveCriticalSection(&m_csProtectMap);

	DeleteCriticalSection(&m_csProtectMap);

	return;
}



/* ------------------------------------------------------------------------
  CMapFileEx::MapFromHandle
  	Does the real work of mapping.  Given a handle to the file, go through
  	the motions of mapping, and recording what happens.  Reports errors
  	as needed.  Also adjusts file size if requested.

  Author
  	Lindsay Harris	- lindsayh
  	Carl Kadie		- carlk

  History
	16:30 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, based on older code with CarlK enhancements.

   ------------------------------------------------------------------------ */

void
CMapFileEx::MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease )
{

	if ( !fWriteEnable && cbIncrease != 0 )
		return;				// This is non-sensical.

	m_cb = GetFileSize( hFile, NULL );

	DWORD	cbNewSize = 0;
	DWORD	cbOldSize = 0;

	//
	// Determine if the file is to grow.  Only pass a non-zero size
	// to the system if the size is growing - it's probably faster, and
	// the most likely common case.
	//
	if ( cbIncrease )
	{
		cbNewSize = m_cb += cbIncrease;
	}
	else
	{
		if ( m_cb == 0 )
			return;				// Nothing there.
	}

	//
	// Add guard page logic
	//
	SYSTEM_INFO si;
	GetSystemInfo(&si);
	DWORD dwPageSize = si.dwPageSize ;
	DWORD dwGuardPageSize = si.dwAllocationGranularity;

	// GuardPageSize should be > cbNewSize
	while( cbNewSize > dwGuardPageSize )
	{
		dwGuardPageSize += si.dwAllocationGranularity;
	}

	// cbNewSize should be a multiple of dwPageSize, to ensure rear guard page is properly aligned
	_ASSERT( (cbNewSize % dwPageSize) == 0 ) ;

	DWORD cbAllocSize = (2 * (dwGuardPageSize)) + cbNewSize;
	DWORD dwOldProtect = PAGE_READWRITE ;
	DWORD dwError;

	//
	//	Grow the file to match the size of memory mapping
	//

    if ( cbIncrease )
    {
        _ASSERT(fWriteEnable);

        //
        // Make sure the file is the correct size.
        //
        DWORD fpos;
        BOOL  fSetEnd;
        if ( (DWORD)-1 == ( fpos = SetFilePointer( hFile, cbAllocSize, NULL, FILE_BEGIN ))
           || !(fSetEnd = SetEndOfFile( hFile ))
           )
        {
            //
            // Error case
            //
            m_pv = NULL;
            return;
        }
    }

    //
    // Create the mapping object.
    //
	HANDLE hFileMap;				// Intermediate step.

    hFileMap = CreateFileMapping( 
							hFile, 
							NULL,
                            fWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                            0, 
							cbAllocSize,	// NOTE: this is greater than cbNewSize by 2*GuardPageSize
							NULL 
							);

    if ( !hFileMap )
    {
		// Error case
        //
		m_pv = NULL;
		m_cb = 0;
        return;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    m_pvFrontGuard = (LPBYTE)MapViewOfFile( 
									hFileMap,
									fWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
									0, 0, 0
									);

	if ( !m_pvFrontGuard )
	{
        // Error case
        //
		m_pv = NULL;
		m_cb = 0;			// Also set to zero, just in case.
		goto MapFromHandle_Exit;
	}

	// zero out the part grown
	cbOldSize = cbNewSize - cbIncrease;
	ZeroMemory( m_pvFrontGuard + cbOldSize, cbAllocSize - cbOldSize );

	// front guard page of size (64KB)
	m_cbFrontGuardSize = dwGuardPageSize ;

	// actual memory-mapping
	m_pv = m_pvFrontGuard + m_cbFrontGuardSize ;
	MoveMemory( m_pv, m_pvFrontGuard, cbNewSize );

	// rear guard page of size (64KB)
	m_pvRearGuard  = m_pv + cbNewSize ;
	m_cbRearGuardSize = m_cbFrontGuardSize ;

	// zero out the front and rear guard pages
	ZeroMemory( m_pvFrontGuard, m_cbFrontGuardSize );
	ZeroMemory( m_pvRearGuard,  m_cbRearGuardSize );

	// make front page a guard page
	if(!VirtualProtect(
				(LPVOID)m_pvFrontGuard,
				m_cbFrontGuardSize,
				PAGE_READONLY | PAGE_GUARD,
				&dwOldProtect
				))
	{
		m_pv = NULL;
		m_cb = 0;
		goto MapFromHandle_Exit ;
	}

	// make mapping read-only; users of CMapFileEx will need to use the
	// UnprotectMapping() / ProtectMapping() calls to write to this mapping.
	if(!VirtualProtect(
				(LPVOID)m_pv,
				cbNewSize,
				PAGE_READONLY,
				&dwOldProtect
				))
	{
		m_pv = NULL;
		m_cb = 0;
		goto MapFromHandle_Exit ;
	}

	// make rear page a guard page
	if(!VirtualProtect(
				(LPVOID)m_pvRearGuard,
				m_cbRearGuardSize,
				PAGE_READONLY | PAGE_GUARD,
				&dwOldProtect
				))
	{
		m_pv = NULL;
		m_cb = 0;
		goto MapFromHandle_Exit ;
	}


MapFromHandle_Exit:

	dwError = GetLastError();

    //
    // Now that we have our pointer, we can close the mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose );
	

    return;
}

/* ------------------------------------------------------------------------
  CMapFileEx::UnprotectMapping

	Change mapping from READONLY to READWRITE when a write is necessary
	**** NOTE: Calls to UnprotectMapping() and ProtectMapping() should be matched ***
	eg:
		{
			UnprotectMapping();

			//
			//	 code to write to the mapping
			//

			ProtectMapping();
		}

	Returns TRUE on success, FALSE on failure
	Lock is held only if returns TRUE

   ------------------------------------------------------------------------ */

BOOL	
CMapFileEx::UnprotectMapping()
{
	DWORD dwOldProtect = PAGE_READONLY;

	// *** This is released in ProtectMapping() ***
	EnterCriticalSection(&m_csProtectMap);

	// enable writes
	if(!VirtualProtect(
				(LPVOID)m_pv,
				m_cb,
				PAGE_READWRITE,
				&dwOldProtect
				))
	{
		LeaveCriticalSection(&m_csProtectMap);
		return FALSE;
	}

	return TRUE;
}

/* ------------------------------------------------------------------------
  CMapFileEx::UnprotectMapping

	This is called to revert the mapping protection back to READONLY
	**** The thread calling this function should have the protect lock *****

	Returns TRUE on success, FALSE on failure
	Lock is released in either case

   ------------------------------------------------------------------------ */

BOOL	
CMapFileEx::ProtectMapping()
{
	DWORD dwOldProtect = PAGE_READWRITE;
	BOOL  fRet = TRUE;

	// disable writes
	if(!VirtualProtect(
				(LPVOID)m_pv,
				m_cb,
				PAGE_READONLY,
				&dwOldProtect
				))
	{
		fRet = FALSE ;
	}

	LeaveCriticalSection(&m_csProtectMap);
	return fRet;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\tigstart\main.cpp ===
#define NNTP_CLIENT_ONLY
#include <tigris.hxx>
#include <lmcons.h>
#include <nntpapi.h>
extern "C" {
#include <rpcutil.h>
#include <stdlib.h>
}

#include "mapfile.h"

//
//	Function prototypes
//

BOOL
CreateGroupsFromFile(
	LPSTR lpstrGroupFile
	);

BOOL
CreateGroupFromBuffer(	
	char	*pchBegin, 
	DWORD	cb,	
	DWORD	&cbOut
	);

BOOL
SetModeratorsFromFile(
	LPSTR lpstrModeratorsFile
	);

BOOL
SetDescriptionsFromFile(
	LPSTR lpstrDescriptionsFile
	);

BOOL
SetDescriptionsFromBuffer(	
				char	*pchBegin, 
				DWORD	cb,	
				DWORD	&cbOut
				);

BOOL
ExpandModeratorBuffer(	
	char	*pchBegin, 
	DWORD	cb,	
	DWORD	&cbOut
	);

DWORD
AddGroup(
    LPWSTR Server,
    LPNNTP_NEWSGROUP_INFO	newsgroup
    );

DWORD
GetInformation(
    LPWSTR Server,
    LPNNTP_NEWSGROUP_INFO	*newsgroup
    );

DWORD
SetInformation(
    LPWSTR Server,
    LPNNTP_NEWSGROUP_INFO	newsgroup
    );

VOID
PrintInfo(
    LPNNTP_NEWSGROUP_INFO	newsgroup
    );

DWORD
SkipWS( char* pchBegin, DWORD cb ) {

	// skip whitespace
	for( DWORD i=0; i < cb; i++ ) {
		if( pchBegin[i] != ' ' && pchBegin[i] != '\t' ) {
			return i;
		}
	}
	return 0;
}

DWORD	
ScanWS(	char*	pchBegin,	DWORD	cb ) {
	//
	//	This is a utility used when reading a newsgroup
	//	info. from disk.
	//

	for( DWORD	i=0; i < cb; i++ ) {
		if( pchBegin[i] == ' ' || pchBegin[i] == '\t' ) {
			return i+1 ;			
		}		
	}
	return	0 ;
}

DWORD	
Scan(	char*	pchBegin,	char	ch,	DWORD	cb ) {
	//
	//	This is a utility used when reading a newsgroup
	//	info. from disk.
	//

	for( DWORD	i=0; i < cb; i++ ) {
		if( pchBegin[i] == ch ) {
			return i+1 ;			
		}		
	}
	return	0 ;
}

DWORD	
ScanEOL(	char*	pchBegin,	DWORD	cb ) {
	//
	//	This is a utility used when reading a newsgroup
	//	info. from disk.
	//

	for( DWORD	i=0; i < cb; i++ ) {
		if( pchBegin[i] == '\n' || pchBegin[i] == '\r' ) {
			i++ ;
			return i ;			
		}		
	}
	return	0 ;
}

DWORD	
Scan(	char*	pchBegin,	DWORD	cb ) {
	//
	//	This is a utility used when reading a newsgroup
	//	info. from disk.
	//

	for( DWORD	i=0; i < cb; i++ ) {
		if( pchBegin[i] == ' ' || pchBegin[i] == '\n' ) {
			return i+1 ;			
		}		
	}
	return	0 ;
}

DWORD	
ScanDigits(	char*	pchBegin,	DWORD	cb ) {
	//
	//	This is a utility used when reading a newsgroup
	//	info. from disk.
	//

	for( DWORD	i=0; i < cb; i++ ) {
		if( pchBegin[i] == ' ' || pchBegin[i] == '\n' || pchBegin[i] == '\r' ) {
			return i+1 ;			
		}
		if( !isdigit( pchBegin[i] ) && pchBegin[i] != '-' )	{
			return	0 ;
		}		
	}
	return	0 ;
}

VOID
AsciiToUnicode( LPSTR lpSrc, WCHAR* pwchDst )
{
	if( !lpSrc || !pwchDst )
		return;

	for( int i=0; lpSrc[i] != '\0' ; i++ ) 
	{
		pwchDst[i] = (WCHAR)lpSrc[i] ;
	}
	pwchDst[i] = L'\0' ;
}

VOID
UnicodeToAscii( WCHAR* pwchSrc, LPSTR lpDst )
{
	if( !pwchSrc || !lpDst )
		return;

	for( int i=0; pwchSrc[i] != '\0' ; i++ ) 
	{
		lpDst[i] = (CHAR)pwchSrc[i] ;
	}
	lpDst[i] = '\0' ;
}

VOID
HiphenateGroupName( LPSTR szGroup, LPSTR lpstrModerator )
{
	if( !szGroup || !lpstrModerator )
		return;

	if ( lpstrModerator [0] == '%' && lpstrModerator [1] == 's' )
	{
		// convert all dots in the group name to dashes
		for( int i=0; szGroup[i] != '\0'; i++)
		{
			if( szGroup [i] == '.' ) szGroup [i] = '-';
		}

		lstrcat( szGroup, lpstrModerator+2 );
	}
	else
	{
		lstrcpy( szGroup, lpstrModerator );
	}
}

void
usage( )
{
	printf("tigstart takes a list of groups and moderators/descriptions for those\n");
	printf("groups and creates them by making RPCs to the server.\n");
	
    printf("tigstart\n");
    printf("\t-v verbose\n");
	printf("\t-s server name\n");
    printf("\t-g group file\n");
    printf("\t-m INN style moderators file\n");
    printf("\t-d descriptions file\n");

    return;
}

//
//	Globals
//
BOOL	fVerbose = FALSE;
DWORD	nGroupCount = 0;
char	szGroupFile [MAX_PATH+1];
char	szModeratorsFile [MAX_PATH+1];
char	szDescripFile [MAX_PATH+1];

LPWSTR RemServerW = (PWCH)NULL;
WCHAR ServerName[256];

void
_CRTAPI1
main(  int argc,  char * argv[] )
{
    NET_API_STATUS err;
    INT cur = 1;
    PCHAR x;
    DWORD i;
    PCHAR server;
    BOOL    GroupFilePresent = FALSE, ModeratorsFilePresent = FALSE, DescripFilePresent = FALSE;
    
    if ( argc == 1 ) {
        usage( );
        return;
    }

    while ( cur < argc ) {

        x=argv[cur++];
        if ( *(x++) == '-' ) {

            switch (*x) {

            case 'g':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }

                for( i=0; argv[cur][i] != '\0' ; i++ ) {
                    szGroupFile[i] = argv[cur][i] ;
                }
                szGroupFile[i] = '\0' ;
                GroupFilePresent = TRUE ;
                break;

            case 'd':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }

                for( i=0; argv[cur][i] != '\0' ; i++ ) {
                    szDescripFile[i] = argv[cur][i] ;
                }
                szDescripFile[i] = '\0' ;
                DescripFilePresent = TRUE ;
                break;

            case 'm':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }

                for( i=0; argv[cur][i] != '\0' ; i++ ) {
                    szModeratorsFile[i] = argv[cur][i] ;
                }
                szModeratorsFile[i] = '\0' ;
                ModeratorsFilePresent = TRUE ;
                break;

            case 'v':
                if ( cur >= argc ) {
                    usage( );
                    return;
                }
                fVerbose = TRUE;
                break;

            case 's':
                if ( cur >= argc ) {
                    usage();
                    return;
                }

                server = argv[cur++];
                for (i=0; server[i] != '\0' ;i++ ) {
                    ServerName[i] = (WCHAR)server[i];
                }
                ServerName[i]=L'\0';
                RemServerW = ServerName;
                break;

            default:

                if( cur >= 1 ) 
                    printf( "unrecognized argument : %s\n", argv[cur-1] ) ;

                usage( );
                return;
            }
        }
    }

	// validate arguments
    if( !GroupFilePresent || !DescripFilePresent || !ModeratorsFilePresent ) {
        printf( "One or more required files not specified \n") ;
        usage() ;
        return ;
    }

	//
	//	do pass1 - create groups listed in GroupFile
	//
	if( !CreateGroupsFromFile( szGroupFile ) )
	{
		printf(" Failed to process %s\n", szGroupFile);
		return;
	}

	printf(" Successfully created groups listed in file %s\n", szGroupFile);

	//
	//	do pass2 - set moderator properties described in ModeratorsFile
	//
	if( !SetModeratorsFromFile( szModeratorsFile ) )
	{
		printf(" Failed to process %s\n", szModeratorsFile);
		return;
	}

	printf(" Successfully set moderator properties from %s\n", szModeratorsFile);

	//
	//	do pass3 - set description properties described in DescripFile
	//
	if( !SetDescriptionsFromFile( szDescripFile ) )
	{
		printf(" Failed to process %s\n", szDescripFile);
		return;
	}

	printf(" Successfully set description properties from %s\n", szDescripFile);

} // main()

BOOL
CreateGroupsFromFile(
	LPSTR lpstrGroupFile
	)
/*++

Routine description : 

	Read a file containing a list of newsgroups - one per line - and make
	rgroup RPCs to the server to create them.

	TODO: parse active file symbols like y/n/m to set read-only properties

Arguments : 

	lpstrGroupFile	-	Name of file containing list of newsgroups

Return Value : 

	TRUE if successful, FALSE otherwise.

--*/
{
	//
	//	Memory-map the file to read the data
	//
	CMapFile	map( lpstrGroupFile,  FALSE, 0 ) ;

	if( !map.fGood() )
	{
		printf(" Failed to map file %s \n", lpstrGroupFile);
		return FALSE;
	}

	DWORD	cb ;
	char*	pchBegin = (char*)map.pvAddress( &cb ) ;

	while( cb != 0 ) 
	{
		DWORD	cbUsed = 0 ;
		BOOL	fInit = CreateGroupFromBuffer( pchBegin, cb, cbUsed ) ;
		if( cbUsed == 0 ) 
		{
			// Fatal Error - blow out of here
			printf(" Error parsing %s\n", lpstrGroupFile);
			return	FALSE ;
		}	

		if( fInit )
		{
			if( fVerbose )
				printf(" Successfully created group from buffer \n");

			nGroupCount++;
		}
		else
		{
			printf(" error creating group from buffer \n");
		}


		// advance to next group
		pchBegin += cbUsed ;
		cb -= cbUsed ;
	}

	return	TRUE ;
}

BOOL
CreateGroupFromBuffer(	
				char	*pchBegin, 
				DWORD	cb,	
				DWORD	&cbOut
				) {
/*++

Routine description : 

	Read a line that starts with a newsgroup name. Create the group by doing an
	admin RPC to the server. 

	TODO: parse additional properties like y/n/m flags after the group name

Arguments : 

	pchBegin - buffer containing article data
	cb - Number of bytes to the end of the buffer
	&cbOut - Out parameter, number of bytes read to make up one group

Return Value : 

	TRUE if successful, FALSE otherwise.

--*/

	//
	//	We are intentionally unforgiving, extra
	//	spaces, missing args etc.... will cause us to return
	//	cbOut as 0.  This should be used by the caller to 
	//	entirely bail processing of the newsgroup data file.
	//

	//
	//	cbOut should be the number of bytes we consumed -
	//	we will only return non 0 if we successfully read every field from the file !
	//
	cbOut = 0 ;
	BOOL	fReturn = TRUE ;
	LPSTR   lpstrGroup;
	NNTP_NEWSGROUP_INFO	newsgroup ;
	WCHAR tempNews[2048];
    PCHAR newsgroupName = NULL;

	DWORD	cbScan = 0 ;
	DWORD	cbRead = 0 ;
	DWORD	cbGroupName = 0 ;

	if( (cbScan = Scan( pchBegin+cbRead, cb-cbRead )) == 0 ) {
		printf(" expected newsgroup \n");
		return	FALSE ;
	}	
	
	lpstrGroup = new char[cbScan] ;
	cbGroupName = cbScan ;

	if( !lpstrGroup ) {
		printf(" memory allocation failed ! \n");
		return FALSE;
	}

	CopyMemory( lpstrGroup, pchBegin, cbScan ) ;
	lpstrGroup[cbScan-1] = '\0' ;

	ZeroMemory(&newsgroup,sizeof(newsgroup));

	AsciiToUnicode( lpstrGroup, tempNews );
    newsgroupName = (PCHAR)&tempNews[0] ;

	newsgroup.Newsgroup = (PUCHAR)newsgroupName ;
	newsgroup.cbNewsgroup = (wcslen( (LPWSTR)newsgroupName ) + 1 ) * sizeof(WCHAR) ;
	newsgroup.ReadOnly = FALSE;
	newsgroup.Descriptor = 0 ;
	newsgroup.cbDescriptor = 0 ;

	// RPC to the server !
	DWORD err = AddGroup(	RemServerW, 
							&newsgroup ) ;

	if( err != NO_ERROR )
	{
		printf(" err %d in AddGroup \n", err);
		fReturn = FALSE;
	}

	delete [] lpstrGroup;
	lpstrGroup = NULL;

	// advance by amount scanned
	cbRead += cbScan ;

	// skip till EOL
	DWORD cbEol = ScanEOL( pchBegin+cbRead, cb-cbRead );
	cbRead += cbEol+1;

	//
	//	Return to the caller the number of bytes consumed
	//	We may still fail - but with this info the caller can continue reading the file !
	//	
	cbOut = cbRead ;

	return	fReturn ;
}

BOOL
SetModeratorsFromFile(
	LPSTR lpstrModeratorsFile
	)
/*++

Routine description : 

	Read an INN style file containing moderator names for wildmat group patterns.
	Expand the wildmat to set moderator properties for each group.

Arguments : 

	lpstrModeratorsFile	-	INN style file containing moderator names

Return Value : 

	TRUE if successful, FALSE otherwise.

--*/
{
	CMapFile	map( lpstrModeratorsFile,  FALSE, 0 ) ;

	if( !map.fGood() )
	{
		printf(" Failed to map file %s \n", lpstrModeratorsFile);
		return FALSE;
	}

	DWORD	cb ;
	char*	pchBegin = (char*)map.pvAddress( &cb ) ;

	while( cb != 0 ) 
	{
		DWORD	cbUsed = 0 ;
		BOOL	fInit = ExpandModeratorBuffer( pchBegin, cb, cbUsed ) ;
		if( cbUsed == 0 ) 
		{
			// Fatal Error - blow out of here
			printf(" error parsing line in file %s \n", lpstrModeratorsFile);
			return	FALSE ;
		}	
		else	
		{
			if( fInit ) 
			{
				if( fVerbose )
					printf(" Successfully expanded moderator buffer \n");
			}	
			else	
			{
				//	
				// How should we handle an error 
				//
			}
		}

		pchBegin += cbUsed ;
		cb -= cbUsed ;
	}

	return	TRUE ;
}

BOOL
ExpandModeratorBuffer(	
				char	*pchBegin, 
				DWORD	cb,	
				DWORD	&cbOut
				) {
/*++

Routine description : 

	Process a line in an INN style moderator file. The line should have the following 
	strict format: <newsgroup wildmat>:<moderator string>

Arguments : 

	pchBegin - buffer containing moderator data
	cb - Number of bytes to the end of the buffer
	&cbOut - Out parameter, number of bytes read to make up one line

Return Value : 

	TRUE if successful, FALSE otherwise.

--*/

	cbOut = 0 ;
	BOOL	fReturn = TRUE ;
	LPSTR   lpstrGroup, lpstrModerator;
	NNTP_NEWSGROUP_INFO	newsgroup ;
	WCHAR tempNews[2048];
	CHAR  szGroup [1024];
	LPWSTR NewsgroupW = (PWCH)NULL;
    PCHAR newsgroupName = NULL;
    LPNNTP_FIND_LIST pList = NULL;
	WCHAR tempModerator[2048] ;
	PCHAR	Moderator = NULL ;

	DWORD	cbScan = 0 ;
	DWORD	cbRead = 0 ;
	DWORD	cbGroupName = 0 ;
	DWORD   cbModerator = 0;
	DWORD   cbEol = 0;

	// scan for newsgroup wildmat
	if( (cbScan = Scan( pchBegin+cbRead, ':', cb-cbRead )) == 0 ) {
		printf(" expected : following wildmat \n");
		return	FALSE ;
	}	
	
	lpstrGroup = new char[cbScan] ;
	cbGroupName = cbScan ;

	if( !lpstrGroup ) {
		printf(" memory allocation failed !\n");
		return FALSE;
	}

	CopyMemory( lpstrGroup, pchBegin, cbScan ) ;
	lpstrGroup[cbScan-1] = '\0' ;

	// scan the moderator string
	cbRead += cbScan ;
	if( (cbEol = ScanEOL( pchBegin+cbRead, cb-cbRead )) == 0 ) {
		printf(" no moderator string \n");
		delete [] lpstrGroup;
		return FALSE;
	}

	lpstrModerator = new char[cbEol];

	if( !lpstrModerator ) {
		printf(" memory allocation failed !\n");
		delete [] lpstrGroup;
		return FALSE;
	}

	CopyMemory( lpstrModerator, pchBegin+cbScan, cbEol );
	lpstrModerator [cbEol-1] = '\0';
	cbRead += cbEol+1;

	// newsgroup wildmat
	AsciiToUnicode( lpstrGroup, tempNews );
    NewsgroupW = tempNews;

	DWORD numResults = nGroupCount;
	DWORD ResultsFound;

	DWORD err = NntpFindNewsgroup(    RemServerW, 
									  NewsgroupW,
									  numResults,
									  &ResultsFound,
									  &pList ) ;

	if ( err != NO_ERROR ) {
		printf("err %d in Find\n",err);
		fReturn = FALSE;
	} else {
		if( pList ) 
		{
			// Iterate over groups in wildmat expansion
		    for(DWORD iGroup=0; iGroup<ResultsFound; iGroup++)
			{
				//printf("%S\n", (LPWSTR)pList->aFindEntry[i].lpszName);
				ZeroMemory(&newsgroup,sizeof(newsgroup));

				newsgroupName = (PCHAR)(pList->aFindEntry[iGroup].lpszName) ;

				newsgroup.Newsgroup = (PUCHAR)newsgroupName ;
				newsgroup.cbNewsgroup = (wcslen( (LPWSTR)newsgroupName ) + 1 ) * sizeof(WCHAR) ;

				UnicodeToAscii( (WCHAR*)newsgroupName, szGroup );
				HiphenateGroupName( szGroup, lpstrModerator );

				AsciiToUnicode( szGroup, tempModerator );
				Moderator = (PCHAR)&tempModerator[0] ;

				if( Moderator ) {

					newsgroup.Moderator = (PUCHAR)Moderator ;
					newsgroup.cbModerator = (wcslen( (LPWSTR)Moderator ) + 1 ) * sizeof( WCHAR ) ;
				}

				newsgroup.ReadOnly = FALSE;
				newsgroup.Descriptor = 0 ;
				newsgroup.cbDescriptor = 0 ;

				err = SetInformation(
								RemServerW,
								&newsgroup
								) ;

				if( err != NO_ERROR ) {
					fReturn = FALSE;
				}
			}
		}   
		else    
		{
			printf( "%s newsgroup does not exist \n", lpstrGroup ) ;    
			fReturn = FALSE;
		}
	} 

	// cleanup !
	delete [] lpstrGroup;
	lpstrGroup = NULL;

	delete [] lpstrModerator;
	lpstrModerator = NULL;

	if( pList )
	    MIDL_user_free(pList);

	//
	//	Return to the caller the number of bytes consumed
	//	We may still fail - but with this info the caller can continue reading the file !
	//	
	cbOut = cbRead ;

	return	fReturn ;
}

BOOL
SetDescriptionsFromFile(
	LPSTR lpstrDescriptionsFile
	)
/*++

Routine description : 

	Read a file containing a list of <group> <description> one per line.
	Make RPCs to the server to set these descriptions.

Arguments : 

	lpstrDescriptionsFile	-	File containing descriptions

Return Value : 

	TRUE if successful, FALSE otherwise.

--*/
{
	CMapFile	map( lpstrDescriptionsFile,  FALSE, 0 ) ;

	if( !map.fGood() )
	{
		printf(" Failed to map file %s \n", lpstrDescriptionsFile);
		return FALSE;
	}

	DWORD	cb ;
	char*	pchBegin = (char*)map.pvAddress( &cb ) ;

	while( cb != 0 ) 
	{
		DWORD	cbUsed = 0 ;
		BOOL	fInit = SetDescriptionsFromBuffer( pchBegin, cb, cbUsed ) ;
		if( cbUsed == 0 ) 
		{
			// Fatal Error - blow out of here
			printf(" error parsing line in file %s \n", lpstrDescriptionsFile);
			return	FALSE ;
		}	
		else	
		{
			if( fInit ) 
			{
				if( fVerbose )
					printf(" Successfully set descriptions from buffer \n");
			}	
			else	
			{
				//	
				// How should we handle an error 
				//
			}
		}

		pchBegin += cbUsed ;
		cb -= cbUsed ;
	}

	return	TRUE ;
}

BOOL
SetDescriptionsFromBuffer(	
				char	*pchBegin, 
				DWORD	cb,	
				DWORD	&cbOut
				) {
/*++

Routine description : 

	Read a line that contains a newsgroup name and description. Make an
	admin RPC to the server to set the description.

Arguments : 

	pchBegin - buffer containing article data
	cb - Number of bytes to the end of the buffer
	&cbOut - Out parameter, number of bytes read to make up one group

Return Value : 

	TRUE if successful, FALSE otherwise.

--*/

	//
	//	cbOut should be the number of bytes we consumed -
	//	we will only return non 0 if we successfully read every field from the file !
	//
	cbOut = 0 ;
	BOOL	fReturn = TRUE ;
	LPSTR   lpstrGroup, lpstrDescription;
	LPNNTP_NEWSGROUP_INFO	lpnewsgroup ;
	NNTP_NEWSGROUP_INFO	newsgroup ;
	WCHAR tempNews[2048];
    PCHAR newsgroupName = NULL;
	WCHAR tempDescription[2048] ;
	PCHAR	Description = NULL ;
	PCHAR	Moderator = NULL ;

	DWORD	cbScan = 0 ;
	DWORD	cbRead = 0 ;
	DWORD	cbGroupName = 0 ;
	DWORD   cbWS = 0;
	DWORD   cbEol = 0;

	// scan the newsgroup name
	if( (cbScan = ScanWS( pchBegin+cbRead, cb-cbRead )) == 0 ) {
		printf(" expected newsgroup \n");
		return	FALSE ;
	}	
	
	lpstrGroup = new char[cbScan] ;
	cbGroupName = cbScan ;

	if( !lpstrGroup ) {
		printf(" memory allocation failed ! \n");
		return FALSE;
	}

	CopyMemory( lpstrGroup, pchBegin, cbScan ) ;
	lpstrGroup[cbScan-1] = '\0' ;

	// scan the description string
	cbRead += cbScan ;
	if( (cbWS = SkipWS( pchBegin+cbRead, cb-cbRead )) == 0 ) {
		printf(" no description string \n");
		delete [] lpstrGroup;
		return FALSE;
	}
	cbRead += cbWS;

	if( (cbEol = ScanEOL( pchBegin+cbRead, cb-cbRead )) == 0 ) {
		printf(" no description string \n");
		delete [] lpstrGroup;
		return	FALSE ;
	}	

	lpstrDescription = new char[cbEol];

	if( !lpstrDescription ) {
		printf(" memory allocation failed !\n");
		delete [] lpstrGroup;
		return FALSE;
	}

	CopyMemory( lpstrDescription, pchBegin+cbRead, cbEol );
	lpstrDescription [cbEol-1] = '\0';
	cbRead += cbEol+1;

	// description
	AsciiToUnicode( lpstrDescription, tempDescription );
    Description = (PCHAR)&tempDescription[0];

	//
	//	Retrieve the moderator info so we can preserve it !
	//
	ZeroMemory(&newsgroup,sizeof(newsgroup));

	AsciiToUnicode( lpstrGroup, tempNews );
    newsgroupName = (PCHAR)&tempNews[0] ;

	newsgroup.Newsgroup = (PUCHAR)newsgroupName ;
	newsgroup.cbNewsgroup = (wcslen( (LPWSTR)newsgroupName ) + 1 ) * sizeof(WCHAR) ;
	newsgroup.ReadOnly = FALSE;
	newsgroup.Descriptor = 0 ;
	newsgroup.cbDescriptor = 0 ;

	// RPC to the server !
	lpnewsgroup = &newsgroup ;
	DWORD err = GetInformation(	RemServerW, 
								&lpnewsgroup ) ;

	if( err != NO_ERROR )
	{
		printf(" err %d in GetInformation \n", err);
		fReturn = FALSE;
	}

	// get the old moderator
	Moderator = (PCHAR)(*lpnewsgroup).Moderator;

	//
	//	Now set the moderator and descrip info !
	//
	ZeroMemory(&newsgroup,sizeof(newsgroup));

	AsciiToUnicode( lpstrGroup, tempNews );
    newsgroupName = (PCHAR)&tempNews[0] ;

	newsgroup.Newsgroup = (PUCHAR)newsgroupName ;
	newsgroup.cbNewsgroup = (wcslen( (LPWSTR)newsgroupName ) + 1 ) * sizeof(WCHAR) ;

	if( Moderator ) {

		newsgroup.Moderator = (PUCHAR)Moderator ;
		newsgroup.cbModerator = (wcslen( (LPWSTR)Moderator ) + 1 ) * sizeof( WCHAR ) ;

	}

	if( Description ) {

		newsgroup.Description = (PUCHAR)Description ;
		newsgroup.cbDescription = (wcslen( (LPWSTR)Description ) + 1 ) * sizeof( WCHAR ) ;

	}

	newsgroup.ReadOnly = FALSE;
	newsgroup.Descriptor = 0 ;
	newsgroup.cbDescriptor = 0 ;

	// RPC to the server !
	err = SetInformation(	RemServerW, 
							&newsgroup ) ;

	if( err != NO_ERROR )
	{
		printf(" err %d in SetInformation \n", err);
		fReturn = FALSE;
	}

	delete [] lpstrGroup;
	lpstrGroup = NULL;

	delete [] lpstrDescription;
	lpstrDescription = NULL;

	//
	//	Return to the caller the number of bytes consumed
	//	We may still fail - but with this info the caller can continue reading the file !
	//	
	cbOut = cbRead ;

	return	fReturn ;
}

DWORD
SetInformation(
    LPWSTR Server,
	LPNNTP_NEWSGROUP_INFO	newsgroup
    )
{
    DWORD err;
    err = NntpSetNewsgroup(
                            Server,
							newsgroup
                            );

    printf("err %d in SetInfo\n",err);
    return err;
}

DWORD
AddGroup(
    LPWSTR Server,
    LPNNTP_NEWSGROUP_INFO	newsgroup
    )
{
    DWORD err;
    DWORD parm = 0;

	printf( "Attempting to add group : \n" ) ;
	PrintInfo( newsgroup ) ;

    err = NntpCreateNewsgroup(
                    Server,
					newsgroup
                    );

    printf("err %d in AddInfo\n",err);
    if ( err == ERROR_INVALID_PARAMETER ) {
        printf("parm error %d\n",parm);
    }
    return err;
}

DWORD
GetInformation(
    LPWSTR Server,
	LPNNTP_NEWSGROUP_INFO*	newsgroup
    )
{
    DWORD err;
    err = NntpGetNewsgroup(
                            Server,
							newsgroup
                            );

    if ( err == NO_ERROR ) {
		if( *newsgroup )	{
			PrintInfo(*newsgroup);
		}	else	{
			printf( "newsgroup not found \n" ) ;	
		}
    } else {
        printf("err %d in GetInfo\n",err);
    }
    return err;
}

VOID
PrintInfo(
    LPNNTP_NEWSGROUP_INFO	newsgroup
    )
{
    PWCH p;

    printf("Newsgroup  %S\n", newsgroup->Newsgroup);
	printf("Newsgroup is %s\n", newsgroup->ReadOnly ? "Read Only" : "Read Write" ) ;

	printf("Description %S\n", newsgroup->Description ? (LPWSTR)newsgroup->Description : (LPWSTR)L"<NULL>" ) ;
	printf("Moderator %S\n", newsgroup->Moderator ? (LPWSTR)newsgroup->Moderator : (LPWSTR)L"<NULL>" ) ;
    printf("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\utest\xover\main.cpp ===
#include "..\..\tigris.hxx"
#include <stdlib.h>

CXoverMap XMap;

int
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    CHAR buf[512];
    DWORD bufLen = 512;
    PCHAR xxx;

    InitAsyncTrace( );

    XMap.Initialize( );
    
    FILETIME    filetime ;

    GetSystemTimeAsFileTime( &filetime ) ;

    xxx = "\tThisisthedata\tandhereitis";
    XMap.CreateNovEntry(
                    123,
                    555,
                    filetime,
                    xxx,
                    strlen(xxx),
                    TRUE
                    );

    if (XMap.CreateNovEntry(
                    123,
                    555,
                    filetime,
                    xxx,
                    strlen(xxx),
                    FALSE
                    )) {

        printf("!!!Inserted twice!\n");
        goto exit;
    }

    //
    // Delete
    //
#if 0
    if (!XMap.DeleteNovEntry(
                    123,
                    555
                    )) {

        printf("Cannot delete!\n");
        goto exit;
    }
#endif

    if (XMap.SearchNovEntry(
                    123,
                    555,
                    buf,
                    &bufLen
                    ) ) {

        printf("bufLen %d buf %s\n",bufLen,buf);
    } else {
        printf("not found!\n");
    }
exit:
    XMap.Shutdown( );

    TermAsyncTrace( );
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\xover\src\xoverimp.h ===
/*++

	xoveridx.h

	This file contains the class definitions for the objects which manage
	Xover Data.

	Xover Data is stored in index files with the following format : 

		(32BIT) OFFSET
		(32BIT)	LENGTH
			.
			.
			.
		XOVER ENTRY - LENGTH SPECIFIED IN HEADER
			.
			.
			.

	For our purposes we don't care what is in the Xover Entry.
	
	Each file will contains ENTRIES_PER_FILE entries.
	

	In memory, a file will be represented by a CXoverIndex object.
	A CXoverIndex keeps a copy of the OFFSET & LENGTH information
	in memory.  CXoverIndex objects are multi-thread accessible
	and use reader/writer synchronization to allow multiple clients
	to query.

	The CXoverCache object MUST ensure that a given file is represented
	by only one CXoverIndex object, or we'll become confused about
	where to append data when entries are made.
		
	


--*/

#pragma	warning(disable:4786)

#include	"xmemwrpr.h"
#include    "cpool.h"
#include    "refptr2.h"
#include    "rwnew.h"
#include	"cache2.h"
#include	"tigtypes.h"
#include	"nntptype.h"
#include	"vroot.h"
#include	"nntpvr.h"


#ifndef	_ASSERT
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
#endif

extern	DWORD	cMaxCacheEntries ;


#include	"xover.h"

//
//	Define a list of our pending requests !
//
typedef	TDListHead<	CXoverCacheCompletion, &CXoverCacheCompletion::PendDLIST >	PENDLIST ;
//
//	Define a way to iterate these things !
//
typedef	TDListIterator<	PENDLIST >	PENDITER ;

class	CCacheFillComplete :	public	CNntpComplete	{
private : 

	enum	{
		SIGNATURE = 'CFaC'
	} ;

	//
	//	Looking good in the debugger !
	//
	DWORD			m_dwSignature ;

	//
	//	back pointer to the CXoverIndex object we are to fill !
	//
	class	CXoverIndex*	m_pIndex ;
	
	//
	//	Did we steal the IO buffer from a client ?
	//
	BOOL			m_fStolen ;

	//
	//	pointer to where we receive our results !
	//
	LPBYTE			m_lpbBuffer ;

	//
	//	size of the buffer we're using !
	//
	DWORD			m_cbBuffer ;

	//
	//	Where we capture the resultant fill info !
	//
	DWORD			m_cbTransfer ;

	//
	//	Where we capture the high number we got to !
	//
	ARTICLEID		m_articleIdLast ;
	//
	//	The original request that spurred us to do work !
	//
	CXoverCacheCompletion*	m_pComplete ;
public : 

	CCacheFillComplete(	) : 
		m_dwSignature( SIGNATURE ),
		m_pIndex( 0 ),
		m_fStolen( FALSE ),
		m_lpbBuffer( 0 ),
		m_cbBuffer( 0 ),
		m_cbTransfer( 0 ), 
		m_pComplete( 0 )	{
	}

	//
	//	This is called when a driver drops its final reference - we will then
	//	go and write the data into the file !
	//	
	//	We don't call delete because we're usually embedded into other objects !
	//
	void	
	Destroy() ;

	//
	//	Go off and fill our with data !
	//
	BOOL
	StartFill(	CXoverIndex*	pIndex, 
				CXoverCacheCompletion*	pComplete, 
				BOOL			fStealBuffers
				) ;
				


} ;



//
//	This struct is used to represent the first bytes of each
//	xover index file.
//
struct	XoverIndex	{
	DWORD	m_XOffset ;
	DWORD	m_XLength ;
} ;

//
//	Maximum number of Xover entries in a single file !
//
#define	ENTRIES_PER_FILE	128


//
//	Class which represents one file containing Xover data.
//	These objects are built to be cacheable and accessed by 
//	multiple threads.
//
class	CXoverIndex	{
private : 

	friend	class	CCacheFillComplete ;

	//
	//	CPool to be used for allocating memory blocks for the 
	//	Cache Data !
	//
	static	CPool			gCacheAllocator ;

	//
	//	CPool used to allocate CXoverIndex objects
	//
	static	CPool			gXoverIndexAllocator ;

	//
	//	These our constants for putting special bits into the lengths
	//	of XOVER records !
	//
	enum	{
		XOVER_HIGHWATER = 0x80000000,
		XOVER_HIGHWATERMASK = 0x7fffffff
	} ;

	static	DWORD	inline
	ComputeLength(	XoverIndex&	xi )	{
		return	xi.m_XLength & XOVER_HIGHWATERMASK ;
	}

	static	void	inline
	MarkAsHighwater(	XoverIndex&	xi )	{
		xi.m_XLength |= XOVER_HIGHWATER ;
	}

	inline	void
	UpdateHighwater( DWORD	index )		{
		if( index + m_Start.m_articleId+1 > m_artidHighWater ) {
			m_artidHighWater = index+m_Start.m_articleId+1 ;
		}
	}

	inline	BOOL
	IsWatermark( XoverIndex& xi )	{
		return	xi.m_XLength != 0 ;
	}
	

	//
	//	The lock that protects this object !
	//
	class	CShareLockNH	m_Lock ;

	//
	//	Are we in a complete state or not ? 
	//
	BOOL	m_fInProgress ;

	//
	//	What is the high water mark for valid XOVER entries within this file ?
	//
	ARTICLEID	m_artidHighWater ;

	//
	//	List of pending requests !
	//
	PENDLIST	m_PendList ;

	//
	//	Is the contents of this index file sorted ? 
	//
	BOOL		m_IsSorted ;

	//
	//	Handle to the file containing the Xover information
	//
	HANDLE		m_hFile ;

	//
	//	Is the cached index data dirty ??
	//
	BOOL		m_IsCacheDirty ;

	//
	//	Next offset we can use when appending an entry !!
	//
	DWORD		m_ibNextEntry ;

	//
	//	Number of entries in the index which are in use !
	//
	long		m_cEntries ;

	//
	//	the object which we use to issue async operations against
	//	store drivers !
	//
	CCacheFillComplete	m_FillComplete ;

	//
	//	Pointer to a page containing the Xover data
	//
	XoverIndex	m_IndexCache[ENTRIES_PER_FILE] ;

	//
	//	Determine whether we need to put the Async Xover
	//	request in a queue for later processing !
	//
	BOOL
	FQueueRequest(	
			IN	CXoverCacheCompletion*	pAsyncComplete
			) ;


	//
	//	After some kind of error blow everything off
	//	and put us back to an 'illegal' state.
	//
	void
	Cleanup() ;

	//
	//	Check if the Xover data is in sorted order !
	//
	BOOL
	SortCheck(	
				IN	DWORD	cbLength,
				OUT	long&	cEntries,
				OUT	BOOL&	fSorted
				) ;

	//
	//	Does the meat of copying data from the xover index
	//	file into a buffer.
	//
	DWORD
	FillBufferInternal(
				IN	BYTE*	lpb,
				IN	DWORD	cb,
				IN	ARTICLEID	artidStart, 
				IN	ARTICLEID	artidFinish,
				OUT	ARTICLEID	&artidLast
				) ;

	//
	//	Does the meat of copying data from the xover index
	//	file into a buffer.
	//
	DWORD
	ListgroupFillInternal(
				IN	BYTE*	lpb,
				IN	DWORD	cb,
				IN	ARTICLEID	artidStart, 
				IN	ARTICLEID	artidFinish,
				OUT	ARTICLEID	&artidLast
				) ;

	//
	//	Does the meat of sorting xover data 
	//
	BOOL
	SortInternal(
				IN	LPSTR	szPathTemp,
				IN	LPSTR	szPathFile,
				OUT	char	(&szTempOut)[MAX_PATH*2],
				OUT	char	(&szFileOut)[MAX_PATH*2]
				) ;

public : 

	//
	//	GroupId and Article Id of the first entry in this Xover index file !
	//
	CArticleRef	m_Start ;

	//
	//	This is a back pointer for the cache !
	//
	ICacheRefInterface*	m_pCacheRefInterface ;

	//
	//	I am an orphan when there is no hash table (CXCacheTable) referencing me, 
	//	but I continue to exist serving client requests !  How can this
	//	happen you ask ?  Only when somebody changes virtual root
	//	directories while I am serving a client request !!!
	//
	BOOL		m_fOrphaned ;

	//
	//	Class initialization - setup our CPool's etc....
	//
	static	BOOL	InitClass() ;

	//
	//	Class termination - release our CPool's etc...
	//
	static	BOOL	TermClass() ;

	//
	//	override operator new to use our CPool
	//
	void*	operator	new( size_t	size )	{
					return	gCacheAllocator.Alloc() ;
					}
	
	//
	//	override operator delete to use our CPool
	//
	void	operator	delete( void* pv )	{
					gCacheAllocator.Free( pv ) ;
					}

	//
	//	Figure out what the file name is we want to open
	//	for this portion of the Xover data !	
	//
	static
	void
	ComputeFileName(	
				IN	class	CArticleRef&	ref,
				IN	LPSTR	szPath,	
				OUT	char	(&szOutputPath)[MAX_PATH*2],
				IN	BOOL	fFlatDir,
				IN	LPSTR	szExtension = ".xix"
				) ;



	//
	//	Create a CXoverIndex object by specifying the group
	//	and articleid that the object will contain.
	//	Also specify the directory in which the index file will
	//	reside.
	//
	CXoverIndex(
			IN	class	CArticleRef&	start,	
			IN	class	CXIXConstructor&	constructor
			) ;

	//
	//	Destructor - close handles
	//
	~CXoverIndex() ;

	//
	//	Do all of the expensive initialization we need to do !
	//
	BOOL
	Init(	IN	CArticleRef&		pKey, 
			IN	CXIXConstructor&	constructor, 
			IN	LPVOID				lpv
			) ;

	//
	//	Get the key being used to lookup these guys
	//
	CArticleRef&	
	GetKey()	{	
			return	m_Start ;	
	}

	//
	//	Compare a key to the key in m_pXoverIndex we are using 
	//
	int				
	MatchKey( class	CArticleRef&	ref )	{	
			return	ref.m_groupId == m_Start.m_groupId &&
					ref.m_articleId == m_Start.m_articleId ;	
	}

	static
	int	
	CompareKeys(	class	CArticleRef*	prefLeft, 
					class	CArticleRef*	prefRight
					)	{

		if( prefLeft->m_groupId == prefRight->m_groupId )	{
			return	prefLeft->m_articleId - prefRight->m_articleId ;
		}
		return	prefLeft->m_groupId - prefRight->m_groupId ;
	}

	//
	//	Check that creation was successfull !
	//
	BOOL	
	IsGood()	{
		return	m_hFile != INVALID_HANDLE_VALUE ;
	}

	//
	//	Given a buffer fill it with Xover data, starting from 
	//	the specified
	//
	DWORD
	FillBuffer(	
			IN	BYTE*		lpb,
			IN	DWORD		cb,
			IN	ARTICLEID	artidStart, 
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast
			) ;

	//
	//	Given a buffer fill it with Listgroup data, starting from 
	//	the specified article id
	//
	DWORD
	ListgroupFill(	
			IN	BYTE*		lpb,
			IN	DWORD		cb,
			IN	ARTICLEID	artidStart, 
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast
			) ;

	//
	//	NOW - issue an async Cache operation !
	//
	void
	AsyncFillBuffer(	
			IN	CXoverCacheCompletion*	pAsyncComplete,
			IN	BOOL	fIsEdge
			) ;

	//
	//	Now - given an async request actually do the work !
	//
	void
	PerformXover(	
			IN	CXoverCacheCompletion*	pAsyncComplete
			) ;

	//
	//	NOW - we've completed updating the Cache to the latest
	//	state of the underlying storage - so go ahead and complete
	//	pending XOVER operations !
	//
	void
	CompleteFill(
			IN	BOOL	fSuccess
			) ;



	//
	//	Add an Xover entry to this indexfile !
	//	
	BOOL
	AppendEntry(	
			IN	BYTE*		lpb,
			IN	DWORD		cb,
			IN	ARTICLEID	artid
			) ;

	//
	//	Append several entries to the XOVER results !
	//
	BOOL
	AppendMultiEntry(
			IN	BYTE*		lpb,
			IN	DWORD		cb, 
			IN	ARTICLEID	artidNextAvail
			) ;

	//
	//	Given an ARTICLEID remove it from the xover index - 
	//	This does nothing but NULL out the header offsets
	//
	void
	ExpireEntry(
			IN	ARTICLEID	artid
			) ;

	//
	//	Return TRUE if this index is already sorted !
	//
	BOOL	
	IsSorted() ;

	//
	//	Sort the index !
	//
	BOOL	
	Sort(	
			IN	LPSTR	pathTemp,
			IN	LPSTR	pathFile,
			OUT	char	(&szTempOut)[MAX_PATH*2],
			OUT	char	(&szFileOut)[MAX_PATH*2]
			) ;

	//
	//	Flush the contents to disk and save the file !
	//
	BOOL	
	Flush() ;

} ;

class	CXIXConstructor	{

	friend	class	CXoverIndex ;
	friend	class	CXoverCacheImplementation ;

	//
	//	Path to the directory which contains the necessary
	//	.xix files !
	//
	LPSTR		m_lpstrPath ;

	//
	//	If TRUE then we don't want to create a new file !
	//
	BOOL		m_fQueryOnly ;

	//
	//	If TRUE then we are keeping a whole bunch of newsgroups in 
	//	one directory, and have a different naming scheme !
	//
	BOOL		m_fFlatDir ;

	//
	//	This is the request object that originated our request !
	//	
	//	We will sneak off and use his buffer to do work !
	//
	CXoverCacheCompletion*	m_pOriginal ;

public : 

	class	CXoverIndex*
	Create(	CArticleRef&	key, 
			LPVOID&			percachedata 
			) ;

	void
	Release(	class	CXoverIndex*, 
				LPVOID	percachedata
				) ;

	static	void
	StaticRelease(	class	CXoverIndex*, 
					LPVOID	percachedata 
					) ;

} ;



//
//	forward definition
//
class	CXoverIndex ;

//
//	Maximum number of entries in our cache per CXCacheTable
//
#ifndef	DEBUG
#define	MAX_PER_TABLE		96
#else
#define	MAX_PER_TABLE		4
#endif

#ifndef	DEBUG
#define	SORT_FREQ			25
#else
#define	SORT_FREQ			1
#endif

//
//	Maximum number of CXoverIndex objects we will ever create !
//
#define	MAX_XOVER_INDEX		(1024*16)


//
//	This is the initial 'age' for newly created Xover entries
//	in our cache !
//
#define	START_AGE			3



typedef	MultiCacheEx< CXoverIndex, CArticleRef, CXIXConstructor >	CXIXCache ;

//typedef	CacheCallback< CXoverIndex >	CXIXCallbackBase ;

typedef	CXIXCache::EXPUNGEOBJECT	CXIXCallbackBase ;

class	CXoverCacheImplementation : public	CXoverCache	{
private : 
	//
	//
	//
	DWORD			m_cMaxPerTable ; 
	
	//
	//
	//
	DWORD			m_TimeToLive ;
	

	//
	//	This object handles all of the caching of CXoverIndex objects.
	//	What we need to do is present the appropriate interface !
	//
	CXIXCache		m_Cache ;

	//
	//	This counts the number of smart pointers we have returned
	//	to callers.  We return smart pointers to callers
	//
	long			m_HandleLimit ;

	DWORD
	MemberFillBuffer(
					IN  DWORD	(CXoverIndex::*pfn)( BYTE *, DWORD, ARTICLEID, ARTICLEID, ARTICLEID&),
					IN	BYTE*	lpb,
					IN	DWORD	cb,
					IN	DWORD	groupid,
					IN	LPSTR	szPath,
					IN	BOOL	fFlatDir,
					IN	ARTICLEID	artidStart,
					IN	ARTICLEID	artidFinish,
					OUT	ARTICLEID&	artidLast,
					OUT	HXOVER&		hXover
					);

public : 

	//
	//	Create a CXoverCache object !
	//
	CXoverCacheImplementation() ;

	//
	//	destructor
	//
	virtual ~CXoverCacheImplementation() {}

	//
	//	Canonicalize the Article id 
	//
	ARTICLEID	
	Canonicalize(	
			ARTICLEID	artid 
			) ;

	//
	//	Initialize the Xover Cache
	//
	BOOL
	Init(		
#ifndef	DEBUG
		long	cMaxHandles = MAX_HANDLES,
#else
		long	cMaxHandles = 5,
#endif
		PSTOPHINT_FN pfnStopHint = NULL
		) ;

	//
	//	Shutdown the background thread and kill everything !
	//
	BOOL
	Term() ;

#if 0 
	//
	//	Add an Xover entry to the appropriate file !
	//
	BOOL
	AppendEntry(		
				IN	GROUPID	group,
				IN	LPSTR	szPath,
				IN	ARTICLEID	article,
				IN	LPBYTE	lpbEntry,
				IN	DWORD	Entry
				) ;

	//
	//	Given a buffer fill it up with the specified xover data !
	//
	DWORD
	FillBuffer(	
			IN	BYTE*		lpb,
			IN	DWORD		cb,
			IN	DWORD		groupid,
			IN	LPSTR		szPath,
			IN	BOOL		fFlatDir,
			IN	ARTICLEID	artidStart, 
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast,
			OUT	HXOVER		&hXover
			) ;

	//
	//	Given a buffer fill it up with the specified 
	//	Listgroup data !
	//
	DWORD
	ListgroupFillBuffer(	
			IN	BYTE*		lpb,
			IN	DWORD		cb,
			IN	DWORD		groupid,
			IN	LPSTR		szPath,
			IN	BOOL		fFlatDir,
			IN	ARTICLEID	artidStart, 
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast,
			OUT	HXOVER		&hXover
			) ;
#endif


	//
	//	This issues the asynchronous version of the XOVER request !
	//
	BOOL
	FillBuffer(
			IN	CXoverCacheCompletion*	pRequest,
			IN	LPSTR	szPath, 
			IN	BOOL	fFlatDir, 
			OUT	HXOVER&	hXover
			) ;

	//
	//	Dump everything out of the cache !
	//
	BOOL	
	EmptyCache() ;

	//
	//	Dump all Cache entries for specified group from the cache !
	//	Note : when articleTop is 0 ALL cache entries are dropped, 
	//	whereas when its something else we will drop only cache entries
	//	which fall below articleTop
	//
	BOOL	
	FlushGroup(	
			IN	GROUPID	group,
			IN	ARTICLEID	articleTop = 0,
			IN	BOOL	fCheckInUse = TRUE
			) ;

	//
	//	Delete all Xover index files for the specified group
	//	to the specified article -id
	//
	BOOL	
	ExpireRange(
			IN	GROUPID	group,
			IN	LPSTR	szPath,
			IN	BOOL	fFlatDir,
			IN	ARTICLEID	articleLow, 
			IN	ARTICLEID	articleHigh,
			OUT	ARTICLEID&	articleNewLow
			) ;

	//
	//	Remove an Xover entry !
	//
	BOOL
	RemoveEntry(
			IN	GROUPID	group,
			IN	LPSTR	szPath,
			IN	BOOL	fFlatDir,
			IN	ARTICLEID	article
			) ;
	
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\watchci\utest\main.cpp ===
#include <windows.h>
#include <dbgtrace.h>
#include <stdio.h>
#include <ole2.h>
#include <tflist.h>
#include <rwnew.h>
#include <xmemwrpr.h>
#include "watchci.h"


int __cdecl main(int argc, char **argv) {
	CWatchCIRoots wci;
	HRESULT hr;
	BOOL fHeapCreated;

    _VERIFY( fHeapCreated = CreateGlobalHeap( NUM_EXCHMEM_HEAPS, 0, 65536, 0 ) );
    if ( !fHeapCreated ) {
        printf( "Failed to initialize exchmem \n" );
		return 1;
	}

	hr = wci.Initialize(TEXT("System\\CurrentControlSet\\Control\\ContentIndex"));
	if (FAILED(hr)) {
		printf("initialize failed with 0x%08x\n", hr);
		return 0;
	}
	for (int cnt=0; cnt<5; cnt++) {
		for (int i=0; i<4; i++) {
			WCHAR buf[_MAX_PATH];
			buf[0] = L'\0';
			hr = wci.GetCatalogName(i, _MAX_PATH, buf);
			printf ("%.2d: %S (%#x)\n", i, buf, hr);
		}
		printf ("\n");

		hr = wci.CheckForChanges(INFINITE);
		if (FAILED(hr)) {
			printf("initialize failed with 0x%08x\n", hr);
			return 0;
		}

	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\xover\src\makefile.inc ===
$(O)\mailmsg.h : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\xover\src\xoveridx.cpp ===
/*++

	xoveridx.cpp -

	This file implements the CXoverIndex class.
	We provide all the supported needed to read and write xover
	data to xover index files.


--*/

#ifdef	UNIT_TEST
#ifndef	_VERIFY	
#define	_VERIFY( f )	if( (f) ) ; else DebugBreak()
#endif

#ifndef	_ASSERT
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
#endif

#endif

#include	<windows.h>
#include    <stdlib.h>
#include	"nntptype.h"
#include	"nntpvr.h"
#include	"xoverimp.h"


CPool	CXoverIndex::gCacheAllocator ;

CXoverIndex*
CXIXConstructor::Create(	CArticleRef&	key,	
							LPVOID&			percachedata
							)	{
	return	new	CXoverIndex(	key,	*this ) ;
}

void
CXIXConstructor::StaticRelease(	CXoverIndex*	pIndex,
								LPVOID			percachedata
								)	{
	delete	pIndex ;
}

void
CXIXConstructor::Release(	CXoverIndex*	pIndex,
							LPVOID			percachedata
							)	{
	delete	pIndex ;
}





BOOL
CXoverIndex::InitClass()	{
/*++

Routine Description :

	This function initializes the CPool's we use to do all our allocations

Arguments :

	None.

Returns :

	TRUE if successfull, FALSE otherwise !

--*/


	return	gCacheAllocator.ReserveMemory(	
								MAX_XOVER_INDEX,
								sizeof( CXoverIndex )
								) ;
}

BOOL
CXoverIndex::TermClass()	{
/*++

Routine Description :
	
	This function release all of our CPool memory.

Arguments :

	None.
	
Return Value :

	TRUE if successfull,
	FALSE otherwise.

--*/

	_ASSERT( gCacheAllocator.GetAllocCount() == 0 ) ;

	return	gCacheAllocator.ReleaseMemory() ;
}

void
CXoverIndex::Cleanup()	{
/*++

Routine Description :
	
	This function is used after fatal errors occur during Construction-
	we will release everything and return ourselves to a clearly invalid
	state.

Arguments :

	None.

Return Value :

	None.

--*/

	if( m_hFile != INVALID_HANDLE_VALUE ) {
		_VERIFY(	CloseHandle( m_hFile ) ) ;
	}

	m_hFile = INVALID_HANDLE_VALUE ;

}

void
CXoverIndex::ComputeFileName(
				IN	CArticleRef&	ref,
				IN	LPSTR	szPath,
				OUT	char	(&szOutputPath)[MAX_PATH*2],
				IN	BOOL	fFlatDir,
				IN	LPSTR	szExtension
				)	{
/*++

Routine Description :
	
	This function will build the filename to use for an xover index file.

Arguments :

	szPath - Directory containing the newsgroup
	szOutputPath - buffer which will get the file name

Return Value :

	None :

--*/


	DWORD	dw = ref.m_articleId ;

	WORD	w = LOWORD( dw ) ;
	BYTE	lwlb = LOBYTE( w ) ;
	BYTE	lwhb = HIBYTE( w ) ;

	w = HIWORD( dw ) ;
	BYTE	hwlb = LOBYTE( w ) ;
	BYTE	hwhb = HIBYTE( w ) ;

	DWORD	dwTemp = MAKELONG( MAKEWORD( hwhb, hwlb ), MAKEWORD( lwhb, lwlb )  ) ;

	lstrcpy( szOutputPath, szPath ) ;
	char*	pch = szOutputPath + lstrlen( szPath ) ;
	*pch++ = '\\' ;
	_itoa( dwTemp, pch, 16 ) ;

	if( fFlatDir )	{
		char	szTemp[32] ;
		ZeroMemory( szTemp, sizeof( szTemp ) ) ;
		szTemp[0] = '_' ;
		_itoa( ref.m_groupId, szTemp+1, 16 ) ;
		lstrcat( pch, szTemp ) ;
	}
	lstrcat( pch, szExtension ) ;
}


BOOL
CXoverIndex::SortCheck(		
				IN	DWORD	cbLength,
				OUT	long&	cEntries,
				OUT	BOOL&	fSorted
				)	{
/*++

Routine Description :

	Given that we have read into memory the index portion of
	the index file this function will check the validity of the
	index data AS WELL AS Determining whether the contents are
	sorted.

Arguments :

	cbLength - Number of bytes of data in the file
	fSorted - Out parameter we will set to TRUE if the data is sorted.

Return Value :

	TRUE if data is valid. FALSE if file is corrupt

--*/

	DWORD	cbStart = sizeof( XoverIndex ) * ENTRIES_PER_FILE ;
	DWORD	cbMax = sizeof( XoverIndex ) * ENTRIES_PER_FILE ;

	cEntries = 0 ;
	fSorted = TRUE ;

	for( int i=0; i < ENTRIES_PER_FILE; i++ ) {
		
		if( m_IndexCache[i].m_XOffset != 0 )	{
			if( cbStart != m_IndexCache[i].m_XOffset ) {
				fSorted = FALSE ;				
			}	else if( m_IndexCache[i].m_XOffset < (sizeof(XoverIndex) * ENTRIES_PER_FILE) )	{
				return	FALSE ;
			}	else	{
				cbStart += ComputeLength( m_IndexCache[i] ) ;
			}
			cEntries ++ ;
		}	else	if( ComputeLength( m_IndexCache[i] ) != 0 ) {
			return	FALSE ;
		}
		if(	IsWatermark( m_IndexCache[i] ) )	{
			UpdateHighwater( i ) ;
		}
	
		DWORD	cbTemp = m_IndexCache[i].m_XOffset + ComputeLength( m_IndexCache[i] ) ;
		cbMax = max( cbMax, cbTemp ) ;
	}

	if( cbLength != 0 &&
		cbMax > cbLength )
		return	FALSE ;
	return	TRUE ;
}	



CXoverIndex::CXoverIndex(	
				IN	CArticleRef&	start,
				IN	CXIXConstructor&	constructor
				) :
	m_fInProgress( FALSE ),
	m_Start( start ),
	m_artidHighWater( start.m_articleId ),
	m_IsSorted( FALSE ),
	m_hFile( INVALID_HANDLE_VALUE ),
	m_cEntries( 0 ),
	m_IsCacheDirty( FALSE ),
	m_fOrphaned( FALSE ),
	m_pCacheRefInterface( 0 )	{
/*++

Routine Description :

	Construct a valid CXoverIndex object from a file.
	If the file is empty than this is an empty CXoverIndex object.

Arguments :

	start -		GROUPID and Article Id of first entry in the index file
	path -		Path to the newsgroup containg the index file !
	pLock -		Lock to be used for access to CXoverIndex object !

Return Value :

	None.

--*/



	ZeroMemory( &m_IndexCache, sizeof( m_IndexCache ) ) ;
}


BOOL
CXoverIndex::Init(	
				IN	CArticleRef&		key,
				IN	CXIXConstructor&	constructor,
				IN	LPVOID				lpv
				)	{
/*++

Routine Description :

	Construct a valid CXoverIndex object from a file.
	If the file is empty than this is an empty CXoverIndex object.

Arguments :

	start -		GROUPID and Article Id of first entry in the index file
	path -		Path to the newsgroup containg the index file !
	pLock -		Lock to be used for access to CXoverIndex object !

Return Value :

	None.

--*/


	char	szFileName[MAX_PATH*2] ;

	BOOL	fReturn = FALSE ;

	_ASSERT( key.m_groupId == m_Start.m_groupId ) ;
	_ASSERT( key.m_articleId == m_Start.m_articleId ) ;

	ComputeFileName(	key,
						constructor.m_lpstrPath,
						szFileName,
						constructor.m_fFlatDir
						) ;

	m_hFile = CreateFile(	szFileName,
							GENERIC_READ | GENERIC_WRITE,
							FILE_SHARE_READ,
							0,
							!constructor.m_fQueryOnly ? OPEN_EXISTING : OPEN_ALWAYS,
    						FILE_FLAG_WRITE_THROUGH | FILE_ATTRIBUTE_NORMAL, 	
							INVALID_HANDLE_VALUE
							) ;

	if( m_hFile == INVALID_HANDLE_VALUE ) {

		Cleanup() ;

	}	else	{

		DWORD	cb = GetFileSize( m_hFile, 0 ) ;
		if( cb != 0 ) {

			//
			//	Pre-existing file - lets examine the contents !
			//
			if( cb < sizeof( XoverIndex[ENTRIES_PER_FILE] ) ) {

				//
				//	This file is BOGUS ! - clean up !
				//
				Cleanup() ;

			}	else	{

				m_ibNextEntry = cb ;

				DWORD	cbRead ;
				BOOL	fRead ;
				fRead = ReadFile(	
							m_hFile,
							&m_IndexCache,
							sizeof( m_IndexCache ),
							&cbRead,
							0
							) ;

				//
				//	Unable to read the file - cleanup and fail the call
				//
				if( !fRead ) {

					Cleanup() ;

				}	else	{

					_ASSERT( cbRead == sizeof( m_IndexCache ) ) ;

					if( !SortCheck(
								cb,
								m_cEntries,
								m_IsSorted
								)	)	{

						Cleanup() ;
		
					}	else	{

						fReturn = TRUE ;

					}
				}
			}
		}	else	{

			if( constructor.m_fQueryOnly )	{
				//
				//	This is a brand spanking new file
				//	We don't have to do anything in this case !
				//

				m_ibNextEntry = sizeof( m_IndexCache ) ;
				m_IsSorted = TRUE ;

				//
				//	go ahead and issue the necessary async operations that will
				//	fill this item up !
				//
				m_fInProgress = TRUE ;
				if( m_FillComplete.StartFill(	this, constructor.m_pOriginal, TRUE ) )	{
					//
					//	The user only want to read things - in which case we should
					//	issue an operation to start this thing going !
					//
					fReturn = TRUE ;
				}	else	{
					Cleanup() ;
				}

			}	else	{
				Cleanup() ;
			}
		}
	}
	return	fReturn ;
}



CXoverIndex::~CXoverIndex()	{
/*++

Routine Description :

	This function is called when we are destroying a CXoverIndex object.

	******** Does not grab locks *************

	We assume only one thread can be calling our destructor ever !


Arguments :

	None.

Return Value :

	None.


--*/

	if( IsGood() ) {
		Flush() ;
	}

	Cleanup() ;
}


DWORD
CXoverIndex::FillBuffer(
			IN	BYTE*	lpb,
			IN	DWORD	cb,
			IN	ARTICLEID	artidStart,
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast
			) {
/*++

Routine Description  :

	Read some xover data from the index file.
	We will call FillBufferInternal to do the actual work,
	we will just grab the necessary locks !

Arguments :

	lpb - Buffer to hold data
	cb -  Number of bytes available in buffer
	artidStart - Starting article id
	artidFinish - Last Article id
	artidLast - Out parameter gets the article id of the last
		entry we were able to read !

Return Value :

	Number of bytes read !

--*/


	m_Lock.ShareLock() ;
	
	DWORD	cbReturn = FillBufferInternal(
								lpb,
								cb,	
								artidStart,
								artidFinish,
								artidLast
								) ;

	m_Lock.ShareUnlock() ;

	return	cbReturn ;
}

DWORD
CXoverIndex::FillBufferInternal(
			IN	BYTE*	lpb,
			IN	DWORD	cb,
			IN	ARTICLEID	artidStart,
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast
			) {
/*++

Routine Description :

	We are to fill up a provided buffer with Xover information from
	the index file.  We will fill it with complete entries only, we
	won't put in a partial entry.

	******* ASSUMES LOCK IS HELD *************

Arguments :

	lpb - Buffer to put data into
	cb -  Size of buffer
	artidStart - Article id of the first entry we are to put into the buffer
	artidFinish - Article id of the last entry we are to put into the buffer
		(inclusive - if artidFinish is in the file we will pass it !)
	artidLast - Out parameter which gets the last article id we were able
		to stuff into the buffer !

Return Value :

	Number of bytes put into the buffer !

--*/

	DWORD	cbReturn = 0 ;

	OVERLAPPED	ovl ;
	ZeroMemory( &ovl, sizeof( ovl ) ) ;
	

	//
	//	Validate that our arguments are in the correct range
	//

	_ASSERT( artidStart >= m_Start.m_articleId ) ;
	_ASSERT( artidFinish >= artidStart ) ;
	_ASSERT( artidStart < m_Start.m_articleId + ENTRIES_PER_FILE ) ;

	if( artidFinish >= m_Start.m_articleId + ENTRIES_PER_FILE ) {
		//
		//	Make the finish point a boundary within our data
		//
		artidFinish = m_Start.m_articleId + (ENTRIES_PER_FILE-1) ;
	}
	//
	//	However, for the caller, the next point they should
	//	start should be in the next block of data, unless we are unable
	//	to fill their buffer with what we have in our data !
	//
	artidLast = artidFinish + 1 ;


	//
	//	Use pointers in all that follows instead of indices !
	//
	XoverIndex*	pStart = &m_IndexCache[artidStart - m_Start.m_articleId] ;
	XoverIndex*	pFinish = &m_IndexCache[artidFinish - m_Start.m_articleId] ;

	//
	//	find the true endpoints ! - skip all the 0 entries !
	//
	while( pStart->m_XOffset == 0 &&
			pStart <= pFinish )
		pStart ++ ;

	while( pFinish->m_XOffset == 0 &&
			pFinish >= pStart )
		pFinish -- ;

	//
	//	Well, is there really anything for us to do ??
	//
	if( pStart > pFinish ) {

		SetLastError( ERROR_NO_DATA ) ;
		return	0 ;	


	}

	_ASSERT( pStart->m_XOffset != 0 ) ;
	_ASSERT( ComputeLength( *pStart ) != 0 ) ;

#if 0
	if(	m_IsSorted ) {

		//
		//	If the data is sorted, just do a readfile
		//	at the right boundaries for the buffer we have !
		//

		ovl.Offset = pStart->m_XOffset ;
		DWORD	cbRead ;
	
	
		DWORD	cbTemp = 0 ;
		for( ; pStart <= pFinish; pStart++ ) {

			if( (cbTemp + pStart->m_XLength) > cb ) {

				break ;

			}
			cbTemp += pStart->m_XLength ;
		}

		if( ReadFile(	
					m_hFile,
					(LPVOID)lpb,
					cbTemp,
					&cbRead,
					&ovl
					)	)	{

			_ASSERT( cbRead == cbTemp ) ;

			if( pStart <= pFinish )
				artidLast = (pStart - &m_IndexCache[0]) + m_Start.m_articleId ;
			return	cbRead ;
		}	else	{

			return	 0 ;

		}

	}	else	{
#endif

		//
		//	The data is not sorted - we need to go and read each
		//	entry individually - we will do this by building
		//	runs of entries which are sorted and reading them in blocks
		//
		BYTE	*lpbRemaining = lpb ;
		DWORD	cbTemp = 0 ;
		DWORD	ibNext = 0 ;
		XoverIndex*	pSuccessfull = pStart ;

		while(	(pStart <= pFinish) &&
				(ComputeLength( *pStart ) + cbReturn) < cb ) {

			OVERLAPPED	ovl ;
			ZeroMemory( &ovl, sizeof( ovl ) ) ;

			DWORD	cbRemaining = cb - cbReturn ;
			ovl.Offset = pStart->m_XOffset ;
			DWORD	cbTemp = ComputeLength( *pStart ) ;

			ibNext = ovl.Offset + cbTemp ;

			//
			//	Roll up consecutive entries that will fit in the input
			//	buffer into a single read !
			//

			for( pStart++;	pStart <= pFinish &&
					((ComputeLength( *pStart ) + cbTemp) < cbRemaining) &&
					(pStart->m_XOffset == 0 ||
						pStart->m_XOffset == ibNext)  ;
							pStart ++) {
				
				cbTemp += ComputeLength( *pStart ) ;
				ibNext += ComputeLength( *pStart ) ;

				_ASSERT( cbTemp < cbRemaining ) ;
			}

			DWORD	cbRead ;

			if( !ReadFile(	
						m_hFile,
						lpbRemaining,
						cbTemp,
						&cbRead,
						&ovl
						) )		{
				break ;
			}	

			pSuccessfull = pStart ;

			lpbRemaining += cbTemp ;
			cbRemaining -= cbTemp ;
			cbReturn += cbTemp ;

			_ASSERT( cbReturn < cb ) ;
		}

		if( pStart <= pFinish )
			artidLast = (ARTICLEID)((pSuccessfull - &m_IndexCache[0]) + m_Start.m_articleId) ;
#if 0
	}
#endif
	_ASSERT( cbReturn < cb ) ;

	return	cbReturn ;
}

DWORD
CXoverIndex::ListgroupFill(
			IN	BYTE*	lpb,
			IN	DWORD	cb,
			IN	ARTICLEID	artidStart,
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast
			) {
/*++

Routine Description  :

	Read some xover data from the index file.
	We will call FillBufferInternal to do the actual work,
	we will just grab the necessary locks !

Arguments :

	lpb - Buffer to hold data
	cb -  Number of bytes available in buffer
	artidStart - Starting article id
	artidFinish - Last Article id
	artidLast - Out parameter gets the article id of the last
		entry we were able to read !

Return Value :

	Number of bytes read !

--*/


	m_Lock.ShareLock() ;
	
	DWORD	cbReturn = ListgroupFillInternal(
								lpb,
								cb,	
								artidStart,
								artidFinish,
								artidLast
								) ;

	m_Lock.ShareUnlock() ;

	return	cbReturn ;
}



DWORD
CXoverIndex::ListgroupFillInternal(
			IN	BYTE*	lpb,
			IN	DWORD	cb,
			IN	ARTICLEID	artidStart,
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast
			) {
/*++

Routine Description :

	We are to fill up a provided buffer with Xover information from
	the index file.  We will fill it with complete entries only, we
	won't put in a partial entry.

	******* ASSUMES LOCK IS HELD *************

Arguments :

	lpb - Buffer to put data into
	cb -  Size of buffer
	artidStart - Article id of the first entry we are to put into the buffer
	artidFinish - Article id of the last entry we are to put into the buffer
		(inclusive - if artidFinish is in the file we will pass it !)
	artidLast - Out parameter which gets the last article id we were able
		to stuff into the buffer !

Return Value :

	Number of bytes put into the buffer !

--*/

	DWORD	cbReturn = 0 ;

	OVERLAPPED	ovl ;
	ZeroMemory( &ovl, sizeof( ovl ) ) ;
	

	//
	//	Validate that our arguments are in the correct range
	//

	_ASSERT( artidStart >= m_Start.m_articleId ) ;
	_ASSERT( artidFinish >= artidStart ) ;
	_ASSERT( artidStart < m_Start.m_articleId + ENTRIES_PER_FILE ) ;

	if( artidFinish >= m_Start.m_articleId + ENTRIES_PER_FILE ) {
		//
		//	Make the finish point a boundary within our data
		//
		artidFinish = m_Start.m_articleId + (ENTRIES_PER_FILE-1) ;
	}
	//
	//	However, for the caller, the next point they should
	//	start should be in the next block of data, unless we are unable
	//	to fill their buffer with what we have in our data !
	//
	artidLast = artidFinish + 1 ;


	//
	//	Use pointers in all that follows instead of indices !
	//
	XoverIndex*	pStart = &m_IndexCache[artidStart - m_Start.m_articleId] ;
	XoverIndex*	pFinish = &m_IndexCache[artidFinish - m_Start.m_articleId] ;
	XoverIndex* pBegin = &m_IndexCache[0] ;

	//
	//	find the true endpoints ! - skip all the 0 entries !
	//
	while( pStart->m_XOffset == 0 &&
			pStart <= pFinish )
		pStart ++ ;

	while( pFinish->m_XOffset == 0 &&
			pFinish >= pStart )
		pFinish -- ;

	//
	//	Well, is there really anything for us to do ??
	//
	if( pStart > pFinish ) {

		SetLastError( ERROR_NO_DATA ) ;
		return	0 ;	


	}

	_ASSERT( pStart->m_XOffset != 0 ) ;
	_ASSERT( ComputeLength( *pStart ) != 0 ) ;

	BYTE	*lpbRemaining = lpb ;
	DWORD	cbTemp = 0 ;
	DWORD	ibNext = 0 ;
	XoverIndex*	pSuccessfull = pStart ;

	while(	(pStart <= pFinish) &&
			(22 + cbReturn) < cb ) {

		DWORD	cbRemaining = cb - cbReturn ;
		DWORD	cbTemp = ComputeLength( *pStart ) ;

		_itoa( (int)(m_Start.m_articleId + (pStart-pBegin)),
				(char*)lpb+cbReturn,
				10
				) ;
				
		cbReturn += lstrlen( (char*)lpb + cbReturn ) ;
		lpb[cbReturn++] = '\r' ;
		lpb[cbReturn++] = '\n' ;

		pStart++ ;
		while( pStart->m_XOffset == 0 &&
			pStart <= pFinish )
			pStart ++ ;

		pSuccessfull = pStart ;
		_ASSERT( cbReturn < cb ) ;
	}

	if( pStart <= pFinish )
		artidLast = (ARTICLEID)((pSuccessfull - &m_IndexCache[0]) + m_Start.m_articleId) ;
	_ASSERT( cbReturn < cb ) ;

	return	cbReturn ;
}

BOOL
CXoverIndex::AppendEntry(	
				IN	BYTE*	lpb,
				IN	DWORD	cb,
				IN	ARTICLEID	artid	)	{
/*++

Routine Description :

	This function will enter some data into the xover index file.

Arguments :

	lpb	-	Pointer to the data to put into xover table
	cb	-	Number of bytes of data to place into xover table
	artid -	Article Id.  We must convert this to a number within our range !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	BOOL	fSuccess = TRUE ;

	_ASSERT( artid >= m_Start.m_articleId ) ;
	_ASSERT( artid < m_Start.m_articleId + ENTRIES_PER_FILE ) ;
	
	int	artOffset = artid - m_Start.m_articleId ;

	_ASSERT( artOffset >= 0 ) ;

	//
	//	Use a Shared Lock while we append the data,
	//	we can safely use InterlockedExchangeAdd() to compute
	//	the offset at which we append !
	//
	m_Lock.ShareLock() ;

	if( m_IndexCache[artOffset].m_XOffset != 0 ) {

		m_Lock.ShareUnlock() ;
		SetLastError( ERROR_ALREADY_EXISTS ) ;
		fSuccess = FALSE ;

	}	else	{

		OVERLAPPED	ovl ;
		ZeroMemory(	&ovl, sizeof( ovl ) ) ;	

		DWORD	ibOffset = InterlockedExchangeAdd( (long*)&m_ibNextEntry, (long)cb ) ;
		ovl.Offset = ibOffset ;
		DWORD	dw ;

		fSuccess = WriteFile(
						m_hFile,
						lpb,
						cb,
						&dw,
						&ovl
						)  ;

		_ASSERT( !fSuccess || dw == cb ) ;

		m_Lock.ShareUnlock() ;

		if( fSuccess ) {
			//
			//	Now we will right out the newly modified entry we have made !
			//

			m_Lock.ExclusiveLock() ;
		
			XoverIndex*	pTemp = &m_IndexCache[artOffset] ;
			if( InterlockedExchange( (long*)&pTemp->m_XOffset, ibOffset ) != 0 ) {

				//
				//	Although we handle the error, the caller should not be reusing
				//	article id's
				//
				//_ASSERT( FALSE ) ;
	
				fSuccess = FALSE ;

			}	else	{

				pTemp->m_XLength = cb ;
				UpdateHighwater( artOffset ) ;

				ZeroMemory( &ovl, sizeof( ovl ) ) ;
		
				ovl.Offset = artOffset * sizeof( XoverIndex ) ;

				fSuccess &=
					WriteFile(
							m_hFile,
							pTemp,
							sizeof( XoverIndex ),
							&dw,
							&ovl
							) ;

				_ASSERT( !fSuccess || dw == sizeof( XoverIndex ) ) ;

				if( fSuccess ) {

					m_IsCacheDirty = TRUE ;
					_VERIFY( InterlockedIncrement( &m_cEntries ) > 0 ) ;

				}

				_ASSERT( !fSuccess || dw == sizeof( XoverIndex ) ) ;
			}

			//
			//	If we were successfull, and we were sorted then we should be
			//	able to figure out whether we are still sorted !
			//

			if( fSuccess && m_IsSorted )	{

				_ASSERT( m_IndexCache[artOffset].m_XOffset == ibOffset ) ;
				_ASSERT( ComputeLength( m_IndexCache[artOffset] ) == cb ) ;
				_ASSERT( m_cEntries <= ENTRIES_PER_FILE ) ;

				//
				//	If we were already in sorted order, go check if we
				//	still are !
				//
				if( m_IsSorted ) {

					//
					//	The only question is whether the guy which precedes us logically
					//	is also the previous entry physically !
					//
					while( --artOffset > 0 ) {	
		
						if( m_IndexCache[artOffset].m_XOffset != 0 ) {
							if( m_IndexCache[artOffset].m_XOffset +
								ComputeLength( m_IndexCache[artOffset] ) !=
								ibOffset  )		{
								
								m_IsSorted = FALSE ;

							}	
							break ;
						}	
					}
					if( artOffset <= 0 &&
						m_cEntries != 0 ) {
						m_IsSorted = FALSE ;
					}
				}

				BOOL	fSorted ;
				long	cEntries ;
				//	
				//	All the entries must still look valid !
				//
				_ASSERT( SortCheck( 0, cEntries, fSorted ) )  ;

				//
				//	Number of entries better jive !
				//
				_ASSERT( m_cEntries == cEntries ) ;		

				//
				//	If we think things are sorted then SortCheck() better confirm that!
				//
				_ASSERT( !m_IsSorted || fSorted ) ;

				//
				//	Make sure we track the file size correctly !
				//
				_ASSERT( (m_ibNextEntry == GetFileSize( m_hFile, 0 )) || (0xFFFFFFFF == GetFileSize( m_hFile, 0 )) ) ;
			}

			m_Lock.ExclusiveUnlock() ;
		}

	}

	return	fSuccess ;
}

void
CXoverIndex::ExpireEntry(
		IN	ARTICLEID	artid
		)	{
/*++

Routine Description :

	This function deletes the xover entry of a specified article
	from the index file.  We do nothing to delete the information
	immediately - we just clear out the index information.

Arguments :

	artid - Article id of the entry to be removed !

Return Value :

	None.

--*/

	m_Lock.ExclusiveLock() ;

	_ASSERT( artid >= m_Start.m_articleId ) ;
	_ASSERT( artid < m_Start.m_articleId + ENTRIES_PER_FILE ) ;

	DWORD	artOffset = artid - m_Start.m_articleId ;

	if( m_IndexCache[artOffset].m_XOffset != 0 ) {

		m_IndexCache[artOffset].m_XOffset = 0 ;
		m_IndexCache[artOffset].m_XLength = 0 ;
		MarkAsHighwater( m_IndexCache[artOffset] ) ;
		m_IsSorted = FALSE ;
		m_IsCacheDirty = TRUE ;
		_VERIFY( InterlockedDecrement( &m_cEntries ) >= 0 ) ;

	}

	m_Lock.ExclusiveUnlock() ;
}

BOOL
CXoverIndex::IsSorted()	{
/*++

Routine Description :

	Tell the caller whether the index file is currently sorted.

Arguments :

	None.

Return Value :

	TRUE if sorted, FALSE otherwise

--*/

	return	m_IsSorted ;

}


#if 0
BOOL
CXoverIndex::Sort(
		IN	LPSTR	szPathTemp,
		IN	LPSTR	szPathFile,
		OUT	char	(&szTempOut)[MAX_PATH*2],
		OUT	char	(&szFileOut)[MAX_PATH*2]
		)	{
/*++

Routine Description :

	This function exists to sort xover index files.
	We grab the Index lock exclusively and call SortInternal
	to do the brunt of the work !

Arguments :

	szPath - Newsgroup path

Return Value :

	TRUE if successfull, FALSE otherwise

	If the function fails the CXoverIndex may no longer be usable,
	the user should call IsGood() to check !

--*/

	_ASSERT( IsGood() ) ;

	m_Lock.ExclusiveLock() ;

	BOOL	fReturn = SortInternal( szPathTemp, szPathFile, szTempOut, szFileOut ) ;

	m_Lock.ExclusiveUnlock() ;

	return	fReturn ;
}

BOOL
CXoverIndex::SortInternal(
		IN	LPSTR	szPathTemp,
		IN	LPSTR	szPathFile,
		OUT	char	(&szTempOut)[MAX_PATH*2],
		OUT	char	(&szFileOut)[MAX_PATH*2]
		)	{
/*++

Routine Description :

	This function exists to take an Xover Index file and generate
	a file containing the data in sorted order.

	******* ASSUMES LOCKS HELD EXCLUSIVELY **********
	
Arguments :

	szPath - Path of the newsgroup containing the index file !

Return Value :

	TRUE if successfull, FALSE otherwise .

--*/

	DWORD	status = ERROR_SUCCESS ;

	//
	//Write out the file if necessary !
	//
	if( m_IsCacheDirty ) {

		OVERLAPPED	ovl ;
		ZeroMemory( &ovl, sizeof( ovl ) ) ;
		DWORD	dwWrite ;

		if( !WriteFile(	m_hFile,
							(LPVOID)&m_IndexCache,
							sizeof( m_IndexCache ),
							&dwWrite,
							&ovl ) ) {

			return	FALSE ;

		}	else	{

			m_IsCacheDirty = FALSE ;

		}
	}

	XoverIndex*	pIndexCache = new	XoverIndex[ENTRIES_PER_FILE] ;
	if( pIndexCache == 0 ) {

		SetLastError( ERROR_OUTOFMEMORY ) ;			
		return	FALSE ;
	
	}

	ZeroMemory( pIndexCache, sizeof(XoverIndex)*ENTRIES_PER_FILE ) ;

	ComputeFileName( m_Start, szPathTemp, szTempOut, FALSE, ".xtp" ) ;
	ComputeFileName( m_Start, szPathFile, szFileOut, FALSE ) ;

	HANDLE	hFile = CreateFile(	szTempOut,
								GENERIC_READ | GENERIC_WRITE,
								FILE_SHARE_READ,
								0,
								CREATE_ALWAYS,
								FILE_FLAG_SEQUENTIAL_SCAN,
								INVALID_HANDLE_VALUE
								) ;

	if( hFile == INVALID_HANDLE_VALUE ) {

		status = GetLastError() ;
		return	FALSE ;

	}	else	{
		BYTE	rgbTemp[4096] ;
		DWORD	ibOut = sizeof( XoverIndex[ ENTRIES_PER_FILE ] ) ;
		DWORD	dwRead ;
		OVERLAPPED	ovl ;

		
		for( int i=0; i < ENTRIES_PER_FILE; i++ ) {

			ZeroMemory( &ovl, sizeof( ovl ) ) ;

			ovl.Offset = m_IndexCache[i].m_XOffset ;
			if( ovl.Offset != 0 ) {

				_ASSERT( m_IndexCache[i].m_XLength < sizeof( rgbTemp ) ) ;

				if( !ReadFile(	m_hFile,
								(LPVOID)rgbTemp,
								m_IndexCache[i].m_XLength,
								&dwRead,
								&ovl ) )	{

					status = GetLastError() ;
					break ;

				}	else	{

					_ASSERT( dwRead == m_IndexCache[i].m_XLength ) ;

					ZeroMemory( &ovl, sizeof( ovl ) ) ;
					ovl.Offset = ibOut ;
					_ASSERT( dwRead == m_IndexCache[i].m_XLength ) ;

					if( !WriteFile(	hFile,
									(LPVOID)rgbTemp,
									dwRead,
									&dwRead,
									&ovl ) ) {

						status = GetLastError() ;
						break ;
			
					}		
					_ASSERT( dwRead == m_IndexCache[i].m_XLength ) ;

					pIndexCache[i].m_XOffset = ibOut ;
					pIndexCache[i].m_XLength = dwRead ;
					ibOut += dwRead ;
					
				}
			}
		}

		if( i != ENTRIES_PER_FILE ) {

			status = GetLastError() ;
			
		}	else	{

			ZeroMemory( &ovl, sizeof( ovl ) ) ;
			DWORD	dwWrite ;

			if( WriteFile(	hFile,
								(LPVOID)pIndexCache,
								ENTRIES_PER_FILE * sizeof( XoverIndex ),
								&dwWrite,
								&ovl ) ) {

				SetFilePointer( hFile, ibOut, 0, FILE_BEGIN ) ;
				SetEndOfFile( hFile ) ;
                _VERIFY( FlushFileBuffers( hFile ) ) ;

			}
		}
		_VERIFY( CloseHandle( hFile ) ) ;

	}

	if( status != ERROR_SUCCESS ) {
		_VERIFY( DeleteFile( szTempOut ) ) ;
	}

	if( pIndexCache != 0 )
		delete[]	pIndexCache ;

	SetLastError( status ) ;

	return	status == ERROR_SUCCESS ;
}
#endif


BOOL
CXoverIndex::Flush()	{
/*++

Routine Description :

	This function dumps any cached content to disk !

Arguments :

	None.

REturn Value :

	TRUE if successfull, FALSE otherwise !


--*/

	_ASSERT( IsGood() ) ;

	BOOL	fSuccess = TRUE ;

	m_Lock.ExclusiveLock() ;

	if( m_IsCacheDirty ) {

		OVERLAPPED	ovl ;
		ZeroMemory( &ovl, sizeof( ovl ) ) ;
		DWORD	dwWrite ;

		if( (fSuccess = WriteFile(	m_hFile,
							(LPVOID)&m_IndexCache,
							ENTRIES_PER_FILE * sizeof( XoverIndex ),
							&dwWrite,
							&ovl ) )  ) {

			m_IsCacheDirty = FALSE ;
		}
	}
	m_Lock.ExclusiveUnlock() ;

	return	fSuccess ;
}


void
CXoverIndex::AsyncFillBuffer(	
					IN	CXoverCacheCompletion*	pAsyncComplete,
					IN	BOOL	fIsEdge
					)	{
/*++

Routine Description :

	This function determines whether we can perform the requested
	XOVER operation right now, or whether we should wait a while.

Arguments :

	pAsyncCompletion - the object representing the XOVER request !
	fIsEdge - if TRUE then this element of the XOVER cache is right
		where articles are being added !

Return Value :

	None.

--*/

	_ASSERT( pAsyncComplete != 0 ) ;

	m_Lock.ShareLock() ;

	BOOL fQueue = FQueueRequest( pAsyncComplete ) ;	
	if( fQueue )	{
		//
		//	Convert to Exclusive and check again	
		//
		if( !m_Lock.SharedToExclusive() ) {
			m_Lock.ShareUnlock() ;
			m_Lock.ExclusiveLock() ;
			fQueue = FQueueRequest( pAsyncComplete ) ;
		}
		if( fQueue )	{
			//
			//	Put the item on the queue !
			//
			m_PendList.PushFront( pAsyncComplete ) ;
			//
			//	Check to see whether we need to start a fill operation going !
			//
			if( !m_fInProgress ) {
				//
				//	Mark us as in progress with a Cache fill operation !
				//
				m_fInProgress = TRUE ;
				//
				//	This could lead to us re-entering the lock - we got to drop it here !
				//
				m_Lock.ExclusiveUnlock() ;
				if( !m_FillComplete.StartFill( this, pAsyncComplete, TRUE ) ) {
					fQueue = FALSE ;
				}
			}	else	{
				m_Lock.ExclusiveUnlock() ;
			}
			return ;
		}	else	{
			m_Lock.ExclusiveToShared() ;
		}
	}
	m_Lock.ShareUnlock() ;

	//
	//	If we arrive here we have the object locked shared ! - now we can
	//	go ahead and do the work !	
	//
	PerformXover( pAsyncComplete ) ;	
}

BOOL
CXoverIndex::FQueueRequest(	
						IN	CXoverCacheCompletion*	pAsyncComplete
						)	{
/*++

Routine Description :

	This function determines whether we should queue an XOVER request
	behind a cache file operation !

Arguments :

	pAsyncComplete - the object representing the request !

Return Value :

	TRUE if we should Queue - FALSE otherwise !

--*/

	//
	//	if we have an operation in progress, we always wait !
	//
	if( m_fInProgress )		{
		return	TRUE ;
	}	else	{

		if( m_artidHighWater >= m_Start.m_articleId + ENTRIES_PER_FILE )	{
			return	FALSE ;
		}	else	{
			GROUPID	groupId ;
			ARTICLEID	articleIdLow ;
			ARTICLEID	articleIdHigh ;
			ARTICLEID	articleIdGroupHigh ;

			pAsyncComplete->GetRange(	groupId,
										articleIdLow,
										articleIdHigh,
										articleIdGroupHigh
										) ;

			_ASSERT( articleIdHigh >= articleIdLow ) ;
			_ASSERT( articleIdGroupHigh >= articleIdHigh  ) ;
			_ASSERT( groupId != INVALID_GROUPID && articleIdLow != INVALID_ARTICLEID &&
						articleIdHigh != INVALID_ARTICLEID && articleIdGroupHigh != INVALID_ARTICLEID ) ;

			if( articleIdGroupHigh >= m_artidHighWater )	{
				return	TRUE ;	
			}
		}
	}
	return	FALSE ;
}

void
CXoverIndex::CompleteFill(	
						BOOL	fSuccess
						)	{
/*++

Routine Description :

	This function is called when we've completed a cache fill.
	We take all pending requests and complete them !

Arguments :

	fSuccess - whether the cache fill was completed successfully !

Return Value :

	None.

--*/

	//
	//	Grab the lock and copy the pending list into our own private list !
	//
	PENDLIST	pendComplete ;
	m_Lock.ExclusiveLock() ;
	pendComplete.Join( m_PendList ) ;
	m_fInProgress = FALSE ;
	m_Lock.ExclusiveUnlock() ;

	for(	CXoverCacheCompletion*	pComplete = pendComplete.PopFront();
			pComplete != 0 ;
			pComplete = pendComplete.PopFront() )	{

		PerformXover( pComplete ) ;

	}
}

void
CXoverIndex::PerformXover(		
					IN	CXoverCacheCompletion*	pAsyncComplete
					)	{
/*++

Routine Description :

	This function takes an async XOVER request and processes
	it from the cached information.

Arguments :

	pAsyncComplete - the async XOVER operation we are to process

Return Value :

	None

--*/

	//
	//	Get the arguments we need to perform the XOVER operation !
	//
	ARTICLEID	articleIdLow ;
	ARTICLEID	articleIdHigh ;
	ARTICLEID	articleIdGroupHigh ;
	LPBYTE		lpbBuffer ;
	DWORD		cbBuffer ;

	pAsyncComplete->GetArguments(	articleIdLow,
									articleIdHigh,
									articleIdGroupHigh,
									lpbBuffer,
									cbBuffer
									) ;

	_ASSERT( lpbBuffer != 0 ) ;
	_ASSERT( cbBuffer != 0 ) ;
	_ASSERT( articleIdLow != INVALID_ARTICLEID ) ;
	_ASSERT( articleIdHigh != INVALID_ARTICLEID ) ;

	m_Lock.ShareLock() ;
	
	ARTICLEID	articleIdLast ;
	DWORD		cbTransfer = FillBufferInternal(	
											lpbBuffer,
											cbBuffer,
											articleIdLow,
											articleIdHigh,
											articleIdLast
											) ;
	m_Lock.ShareUnlock() ;

	pAsyncComplete->Complete(	TRUE,
								cbTransfer,
								articleIdLast
								) ;

	//
	//	Now return the request to the cache !
	//
	CXIXCache::CheckIn( this ) ;

}

BOOL
CXoverIndex::AppendMultiEntry(
						IN	LPBYTE	lpb,
						IN	DWORD	cb,
						ARTICLEID	artidNextAvail
						)	{
/*++

Routine Description :

	Our job is to process some XOVER data, and insert it into our cache.
	We're going to do some extra checking to ensure that :
		1) The data we get is ordered correctly
		2) The data we get doesn't overlap with something we alread have
	Both these conditions should be guaranteed by the way we fill our
	cache item !

Arguments :

	LPBYTE	lpb - buffer containing XOVER data !
	DWORD	cb - number of bytes of interesting stuff in the buffer !

Return Value :

	TRUE if successfull - FALSE otherwise !

--*/

	_ASSERT( lpb != 0 ) ;
	_ASSERT( cb != 0 ) ;
	
	//
	//	check that our buffer is properly terminated with a CRLF !
	//
	_ASSERT( lpb[cb-2] == '\r' ) ;
	_ASSERT( lpb[cb-1] == '\n' ) ;

	m_Lock.ExclusiveLock() ;

	LPBYTE	lpbEnd = lpb+cb ;
	LPBYTE	lpbBegin = lpb ;
	ARTICLEID	artidLast = m_Start.m_articleId ;

	DWORD	ibNextEntry = m_ibNextEntry ;

	while( lpbBegin < lpbEnd )	{

		//
		//	check that the entry is well formatted !
		//
		if( !isdigit( lpbBegin[0] ) )	{
			SetLastError( ERROR_INVALID_DATA ) ;
			return	FALSE ;
		}
		//
		//	FIRST - determine what number the current entry is !
		//
		ARTICLEID	artid = atoi( (const char*)lpbBegin ) ;

		//
		//	We should only be picking up entries that are below our high water mark !
		//
		_ASSERT( artid >= m_artidHighWater ) ;
		if (artid < m_artidHighWater ) {
			_ASSERT( FALSE );
		}

		//
		//	XOVER entries should arrive in strictly increasing order !
		//
		if( artid < artidLast ||
				(artid >= m_Start.m_articleId + ENTRIES_PER_FILE))	{
			SetLastError( ERROR_INVALID_DATA ) ;
			_ASSERT( FALSE );
			m_Lock.ExclusiveUnlock();
			return	FALSE ;
		}
		artidLast = artid ;

		//
		//	Now - determine how big the entry is !
		//
		for( LPBYTE	lpbTerm = lpbBegin; *lpbTerm != '\n'; lpbTerm ++ ) ;
		lpbTerm++ ;
		_ASSERT( lpbTerm <= lpbEnd ) ;

		//
		//	So far everything looks good - so update our entry !
		//
		DWORD	index = artid - m_Start.m_articleId ;
	
		if( m_IndexCache[index].m_XOffset != 0 ) {
			SetLastError( ERROR_INVALID_DATA ) ;
			_ASSERT( FALSE );
			m_Lock.ExclusiveUnlock();
			return	FALSE ;
		}

		_ASSERT( index < ENTRIES_PER_FILE ) ;

		//
		//	Now update everything we need to track this XOVER entry !
		//
		m_IndexCache[index].m_XOffset = ibNextEntry ;
		m_IndexCache[index].m_XLength = (DWORD)(lpbTerm - lpbBegin) ;
		UpdateHighwater( index ) ;
		ibNextEntry += (DWORD)(lpbTerm-lpbBegin) ;
		lpbBegin = lpbTerm ;	
		_VERIFY( InterlockedIncrement( &m_cEntries ) > 0 ) ;
		_ASSERT( m_cEntries <= ENTRIES_PER_FILE ) ;

	}

	//
	//	check to see if we have captured all the XOVER entries in this range !
	//
	if( artidNextAvail >= m_Start.m_articleId + ENTRIES_PER_FILE ) {
		//
		//	Mark the last entry in the file as a high water mark !
		//
		MarkAsHighwater( m_IndexCache[ENTRIES_PER_FILE-1] ) ;
		UpdateHighwater( ENTRIES_PER_FILE-1 ) ;
	}
	
	//
	//	If we reach this point - everything has gone well - do some IO's
	//	to put this stuff down on disk !
	//

	OVERLAPPED	ovl ;
	ZeroMemory(	&ovl, sizeof( ovl ) ) ;	
	ovl.Offset = m_ibNextEntry ;
	m_ibNextEntry = ibNextEntry ;
	DWORD	dw ;

	BOOL	fSuccess = WriteFile(	
								m_hFile,
								lpb,
								cb,
								&dw,
								&ovl
								) ;

	if( fSuccess )	{
		
		_ASSERT( dw == cb ) ;

		ZeroMemory( &ovl, sizeof( ovl ) ) ;

		//
		//	Now - write out the header !
		//
		fSuccess = WriteFile(	m_hFile,
								(LPVOID)&m_IndexCache,
								sizeof( m_IndexCache ),
								&dw,
								&ovl
								) ;
	}
	m_Lock.ExclusiveUnlock() ;
	return	fSuccess ;
}



BOOL
CCacheFillComplete::StartFill(	CXoverIndex*	pIndex,
								CXoverCacheCompletion*	pComplete,
								BOOL			fStealBuffers							
								)	{
/*++

Routine Description :

	This function starts issuing XOVER operations against the underlying
	store driver and fills our cache file !

Arguments :

	pIndex - the CXoverIndex object we are to fill !
	pComplete - the original request that started this operation off !
	fStealBuffers - if TRUE we use the buffers from the original operation
		as our temp buffers !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	_ASSERT( pIndex != 0 ) ;
	_ASSERT( pComplete != 0 ) ;
	
	m_pIndex = pIndex ;
	m_pComplete = pComplete ;

	ARTICLEID	articleIdInLow ;
	ARTICLEID	articleIdInHigh ;
	ARTICLEID	articleIdGroupHigh ;

	pComplete->GetArguments(	articleIdInLow,
								articleIdInHigh,
								articleIdGroupHigh,
								m_lpbBuffer,
								m_cbBuffer
								) ;

	_ASSERT( m_lpbBuffer != 0 ) ;
	_ASSERT( m_cbBuffer != 0 ) ;
	_ASSERT( articleIdInLow >= pIndex->m_Start.m_articleId ) ;
	_ASSERT( articleIdInLow < pIndex->m_Start.m_articleId + ENTRIES_PER_FILE ) ;

	//
	//	should we allocate our own buffer ?
	//
	if( fStealBuffers )	{

		m_fStolen = TRUE ;

	}	else	{

		//
		//	get a big buffer !
		//
		m_cbBuffer = 32 * 1024 ;
		m_lpbBuffer = new	BYTE[m_cbBuffer] ;
		m_fStolen = FALSE ;
	}

	if( m_lpbBuffer )	{
		//
		//	Go ahead and issue a request !
		//	NOTE : the range is INCLUSIVE so we must be carefull !
		//
		m_pComplete->DoXover(	pIndex->m_artidHighWater,
							min( pIndex->m_Start.m_articleId+ENTRIES_PER_FILE-1, articleIdGroupHigh ),
							&m_articleIdLast,
							m_lpbBuffer,
							m_cbBuffer,
							&m_cbTransfer,
							this
							) ;
		return	TRUE ;
	}
	return	FALSE ;
}

void
CCacheFillComplete::Destroy()	{
/*++

Routine Description :

	This function is called when we have gotten some data from the underlying
	store driver - we will now write give this to the CXoverIndex object to process !

Arguments :

	None.

Return Value :

	None !

--*/


	//
	//	Assume we will need to continue
	//
	BOOL	fComplete = FALSE ;
	//
	//	Assume everything is working !
	//
	BOOL	fSuccess = TRUE ;

	
	GROUPID		groupId = INVALID_GROUPID ;
	ARTICLEID	articleIdInLow = INVALID_ARTICLEID ;
	ARTICLEID	articleIdInHigh = INVALID_ARTICLEID ;
	ARTICLEID	articleIdGroupHigh = INVALID_ARTICLEID ;

	//
	//	Did this operation succeed !
	//
	if( SUCCEEDED(GetResult()) )	{

		//
		//	We need to tell the CXoverIndex to save these bytes away !
		//
		_ASSERT( m_pIndex != 0 ) ;

		if( m_cbTransfer != 0 ) {
			m_pIndex->AppendMultiEntry(	m_lpbBuffer,
										m_cbTransfer,
										m_articleIdLast
										) ;
		}

		m_pComplete->GetRange(		groupId,
									articleIdInLow,
									articleIdInHigh,
									articleIdGroupHigh
									) ;

		//
		//	Now figure out if we are finished, or whether we
		//	should have another go around !
		//
		fComplete = (m_articleIdLast >=
			m_pIndex->m_Start.m_articleId + ENTRIES_PER_FILE) ||
			(m_articleIdLast >= articleIdGroupHigh) ||
			(m_cbTransfer == 0) ;

	}	else	{

		//
		//	In failure cases, we finish immediately !
		//
		fComplete = TRUE ;
		fSuccess = FALSE ;
	}

	//
	//	reset our state so we can be re-used !
	//
	Reset() ;

	//
	//	Continue to execute if need be !
	//
	if( !fComplete )	{

		//
		//	Go ahead and issue a request !
		//	NOTE : the range is INCLUSIVE so we must be carefull !
		//
		m_pComplete->DoXover(	m_articleIdLast,
							min( m_pIndex->m_Start.m_articleId+ENTRIES_PER_FILE-1, articleIdGroupHigh ),
							&m_articleIdLast,
							m_lpbBuffer,
							m_cbBuffer,
							&m_cbTransfer,
							this
							) ;


	}	else	{
		//
		//	Polish our state to brand new !
		//
		if( !m_fStolen )	{
			delete[]	m_lpbBuffer ;
		}
		m_lpbBuffer = 0 ;
		m_cbBuffer = 0 ;
		m_cbBuffer = 0 ;
		m_fStolen = FALSE ;
		m_pComplete = 0 ;
		CXoverIndex*	pIndex = m_pIndex ;
		m_pIndex = 0 ;
		//
		//	reset the completion object's vroot pointer to release our reference !
		//
		SetVRoot( 0 ) ;

		//
		//	Indicate that everything is done !
		//	
		pIndex->CompleteFill(	fSuccess
								) ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\wildmat\src\newwild.cpp ===
#include <windows.h>
#include <dbgtrace.h>
#include "wildmat.h"

//---[ Description of the Wildmat standard ]-----------------------------------
//
//  Taken from:
//
//  INTERNET-DRAFT                                               S. Barber
//  Expires: September 1, 1996                  Academ Consulting Services
//                                                              April 1996
//                           Common NNTP Extensions
//                        draft-barber-nntp-imp-03.txt
//  
//      The WILDMAT format was first developed by Rich Salz to provide
//      a uniform mechanism for matching patterns in the same manner
//      that the UNIX shell matches filenames. There are five pattern
//      matching operations other than a strict one-to-one match
//      between the pattern and the source to be checked for a match.
//      The first is an asterisk (*) to match any sequence of zero or
//      more characters. The second is a question mark (?) to match any
//      single character. The third specifies a specific set of
//      characters. The set is specified as a list of characters, or as
//      a range of characters where the beginning and end of the range
//      are separated by a minus (or dash) character, or as any
//      combination of lists and ranges. The dash can also be included
//      in the range as a character it if is the beginning or end of
//      the range. This set is enclosed in square brackets. The close
//      square bracket (]) may be used in a range if it is the first
//      character in the set. The fourth operation is the same as the
//      logical not of the third operation and is specified the same
//      way as the third with the addition of a caret character (^) at
//      the beginning of the test string just inside the open square
//      bracket. The final operation uses the backslash character to
//      invalidate the special meaning of the a open square bracket ([),
//      the asterisk, or the question mark.
//  
//  3.3.1 Examples
//  
//      a. [^]-] -- matches any character other than a close square bracket
//                  or a minus sign/dash.
//  
//      b. *bdc  -- matches any string that ends with the string "bdc"
//                  including the string "bdc" (without quotes).
//  
//      c. [0-9a-zA-Z] -- matches any string containing any alphanumeric string
//                  in English.
//  
//      d. a??d  --  matches any four character string which begins
//                   with a and ends with d.
//  
//-----------------------------------------------------------------------------



//----[ NOTES ]----------------------------------------------------------------
//                                                                            
// 		This function will raise an invalid access exception if either pszText                                                     
// 		or pszPattern is invalid or not null terminated while dereferencing the                                                    
// 		string. If this is possible, surround the call in a try-except block.                                                      
//  
//-----------------------------------------------------------------------------



//---[ Defines ]---------------------------------------------------------------

#define STACK_SIZE      256



//---[ HrMatchWildmat ]--------------------------------------------------------
//
//  Description:
//
//      Provides support for the "Wildmat" wild-card matching standard. See
//      description above.
//
//  Params:
//
//      pszText         String to test
//      pszPattern      Pattern to test against
//
//  Returns:
//      
//      ERROR_SUCCESS               If function succeeded, and match was found
//      ERROR_INVALID_PARAMETER     Text or pattern string is invalid
//      
//      ERROR_CAN_NOT_COMPLETE      Some other error occurred.
//
//  
//-----------------------------------------------------------------------------


HRESULT HrMatchWildmat(const char* pszText, const char* pszPattern)
{


	_ASSERT(pszText != NULL && pszPattern != NULL);



	BOOL fCharSet = FALSE;	// TRUE if currently parsing a character set in a pattern
	BOOL fNegated = FALSE;	// TRUE if there is a '^' at the beginning of the set
	BOOL fInSet   = FALSE;  // indicates when matching of a character set has completed
				// used to short-circuit character set evaluation
	int iStackPtr = 0;	// stack pointer
    
	const char* textStack[STACK_SIZE];	// stack of text pointers
	const char* patternStack[STACK_SIZE];	// stack of pattern pointers


	// If the pattern consists solely of a * then any text will match
	if (strcmp(pszPattern, "*") == 0)
		return ERROR_SUCCESS;


	while (TRUE) 
    {
		switch (*pszPattern) 
        {
		    case '*':
		    	if (fCharSet) 
                    goto DEFAULT;	// according to unix solution this is not an error
                    

				// If there is a * at the end of the pattern then at this point we are
				// sure that we got a match
				if (pszPattern[1] == '\0')
					return ERROR_SUCCESS;


				// We could write a simpler recursive wildmat function. Here we would
				// recursively call wildmat. Instead, for performance reasons this
				// solution is iterative.
				// Here we save the current values of the text pointer and stack pointer
				// on a stack and we leave the * in the pattern, with the effect of
				// matching one character with the *. The next time through the while
				// loop, the * will still be in the pattern, thus we will try to match
				// the rest of the input with this *. If it turns to fail, we go back
				// one character.
				// See the comments right before the BACK label below.
		    	if (*pszText != '\0') 
                {
		    		if (iStackPtr == STACK_SIZE) 
                        return ERROR_CAN_NOT_COMPLETE;			// stack overflow
                        
		    		textStack[iStackPtr] = pszText;			// save current text pointer
		    		patternStack[iStackPtr] = pszPattern;	// save current pattern pointer
		    		iStackPtr++;
		    		pszPattern--;	// leave * in the input pattern and match one character
		    	}
		    	break;

		    case '?':
		    	if (fCharSet) 
                    goto DEFAULT;	// according to unix solution this is not an error
		    	if (*pszText == '\0') 
                    goto BACK;
		    	break;

		    case '[':
		    	if (fCharSet) 
                    return ERROR_INVALID_PARAMETER;
                    
		    	fCharSet = TRUE;		    // beginning a character set
		    	fNegated = FALSE;			// so far we haven't seen a '^'
		    	fInSet = FALSE;				// used to short-circuit the evaluation of
		    						// membership to the character set

		    	// treat '^', '-' and ']' as special cases if they are
		    	// at the beginning of the character set (also "[^-a]" and "[^]a]")
		    	if (pszPattern[1] == '^') 
                {
		    		fNegated = TRUE;
		    		pszPattern++;
		    	}
		    	// '-' and ']' are literals if they appear at the beggining of the set
		    	if (pszPattern[1] == '-' || pszPattern[1] == ']') 
                {
		    		fInSet = (*pszText == pszPattern[1]);
		    		pszPattern++;
		    	}
		    	break;
		    		
		    case ']':
		    	if (fCharSet) 
                {
		    		if ((!fNegated && !fInSet) || (fNegated && fInSet)) 
                        goto BACK;
                        
		    		fCharSet = FALSE;		// this marks the end of a character set
		    	} 
                else 
                {
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	}
		    	break;

		    case '-':
		    	if (fCharSet) 
                {
		    		unsigned char startRange = pszPattern[-1];	// we use unsigned char
					unsigned char endRange;						// to support extended
					unsigned char ch;							// characters

		    		if (pszPattern[1] == '\0')
		    			return ERROR_INVALID_PARAMETER;
		    		else 
                    {
                        if (pszPattern[1] == ']')		// a dash at the end of the set is
		    			    fInSet = (*pszText == '-');	// treated as a literal
		    		    else 
                        {							    // we have a range
		    		    	if (pszPattern[1] == '\\')  // escape character, skip it
                            {	
		    		    		pszPattern++;
		    		    		if (pszPattern[1] == '\0') 
                                    return ERROR_INVALID_PARAMETER;
		    		    	}
							ch = *pszText;
							endRange = pszPattern[1];

							if (startRange > endRange)
								return ERROR_INVALID_PARAMETER;
							// here is where we could need unsigned characters
		    		    	fInSet = (ch >= startRange && ch <= endRange);
		    		    	pszPattern++;
		    		    	break;
		    		    }
                    }
		    	} 
                else 
                {						// outside a character set '-' has no special meaning
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	}
		    	break;

		    case '\0':					// end of the pattern
		    	if (fCharSet) 
                    return ERROR_INVALID_PARAMETER;
		    	if (*pszText == '\0')
		    		return ERROR_SUCCESS;
		    	else
		    		goto BACK;
		    	break;

		    default:				
DEFAULT:    	
                if (*pszPattern == '\\') 
                {
		    		pszPattern++;		// escape character, treat the next character as a literal
		    		if (*pszPattern == '\0') 
                        return ERROR_INVALID_PARAMETER;
		    	}
		    	if (!fCharSet) 
                {						// any other character is treated as a literal
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	} 
                else 
                {
		    		// the following if takes care of the two "special" cases:
		    		//		[c-a]       (we don't want to accept c), and
		    		//		[c-]		(we want to accept c)
		    		if (!(pszPattern[1] == '-' && pszPattern[2] != ']'))
		    			fInSet = (*pszText == *pszPattern);
		    	}
		    	break;
		} // switch

		pszPattern++;
		
        if (!fCharSet) 
        {
			if (*pszText != '\0') 
                pszText++;
		} 
        else 
        {               			// code to short-circuit character set evaluation
			if (fInSet) 			// skip the rest of the character set
            {		
				while (*pszPattern != '\0' && *pszPattern != ']') 
                {
					if (*pszPattern == '\\')
                    {				// escape character, treat the next character as a literal
						pszPattern++;
						if (*pszPattern == '\0') 
                            return ERROR_INVALID_PARAMETER;
					}
					pszPattern++;
				}
			}
		}
		continue;	// the continue statement is to jump to the beginning of the loop,
					// we could have used used goto some label but that's what continue's
					// are for.


		// This is only reached by jumping to BACK.
		// This is equivalent to returning from a recursive solution of wildmat.
		// If the stack pointer is zero then the bottommost "recursive call" failed,
		// otherwise we "unwind one stack frame" and resume execution of the previous
		// call at the top of the while loop. Notice that since "recursive calls" are
		// only done when we find a '*' in the pattern outside a character set, the
		// value of fCharSet has to be set to false.
BACK:	
        if (iStackPtr == 0)                     	// we exhausted all possibilities
            return ERROR_FILE_NOT_FOUND;
            
		iStackPtr--;						    	// try matching no characters with the '*'
		pszText = textStack[iStackPtr];
		pszPattern = patternStack[iStackPtr] + 1;	// eat the '*' matching no input characters
		fCharSet = FALSE;				        	// this has to be the case
	} // while

    // should never get here
	_ASSERT(FALSE);						
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\xover\src\xcache.cpp ===
/*++

	xcache.cpp

	This file contains the code which caches CXoverIndex 
	objects, and wraps the interfaces so that the user 
	is hidden from the details of CXoverIndex objects etc...


--*/

#ifdef	UNIT_TEST
#ifndef	_VERIFY	
#define	_VERIFY( f )	if( (f) ) ; else DebugBreak() 
#endif

#ifndef	_ASSERT
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak() 
#endif


extern	char	PeerTempDirectory[] ;

#endif

#include	<windows.h>
#include	"xoverimp.h"

static BOOL     g_IndexClassInitialized = FALSE ;
static DWORD    g_cNumXixObjectsPerTable = 256  ;


DWORD	
HashFunction(	CArticleRef*	pRef ) {

	DWORD	seed = pRef->m_groupId ;
	DWORD	val = pRef->m_articleId ;

    return	((seed-val)*(seed * (val>>3))*(seed+val)) * 1103515245 + 12345;   // magic!!
}

HXOVER&
HXOVER::operator =( class	CXoverIndex*	pRight	)	{
	if( pRight != m_pIndex )	{
		CXoverIndex	*pTemp = m_pIndex;
		m_pIndex = pRight ;
		if (pTemp) CXIXCache::CheckIn( pTemp ) ;
	}
	return	*this ;
}

HXOVER::~HXOVER()	{
	if( m_pIndex )	{
		CXIXCache::CheckIn( m_pIndex ) ;
		m_pIndex = 0 ;
	}
}

CXoverCache*
CXoverCache::CreateXoverCache()	{

	return	new	CXoverCacheImplementation() ;

}


BOOL	XoverCacheLibraryInit(DWORD cNumXixObjectsPerTable)	{

    if( cNumXixObjectsPerTable ) {
        g_cNumXixObjectsPerTable = cNumXixObjectsPerTable ;
    }

	if( !CXoverIndex::InitClass( ) )	{
		return	FALSE ;
	}

	g_IndexClassInitialized = TRUE ;

	return	CacheLibraryInit() ;

}

BOOL	XoverCacheLibraryTerm()	{

	if( g_IndexClassInitialized ) {
		CXoverIndex::TermClass() ;
	}

	return	CacheLibraryTerm() ;

}


CXoverCacheImplementation::CXoverCacheImplementation()	 : 
	m_cMaxPerTable( g_cNumXixObjectsPerTable ),
	m_TimeToLive( 3 ) {

}

BOOL
CXoverCacheImplementation::Init(
				long	cMaxHandles,
				PSTOPHINT_FN pfnStopHint
				 )	{
/*++

Routine Description : 

	Initialize the Cache - create all our child subobjects
	and start up the necessary background thread !

Arguments : 

	cMaxHandles - Maximum number of 'handles' or CXoverIndex
		we will allow clients to reference.
	pfnStopHint - call back function for sending stop hints during lengthy shutdown loops

Return Value : 

	TRUE if successfull, FALSE otherwise.

--*/

	m_HandleLimit = cMaxHandles;
	if( m_Cache.Init(	HashFunction, 
						CXoverIndex::CompareKeys,
						60*30, 
						m_cMaxPerTable * 16,
						16, 
						0,
						pfnStopHint ) ) {

		return	TRUE ;
	}						
	return	FALSE ;
}

BOOL
CXoverCacheImplementation::Term()	{
/*++



--*/


	EmptyCache() ;

#if 0
	if( m_IndexClassInitialized ) {
		CXoverIndex::TermClass() ;
	}
#endif

	return	TRUE ;
}

ARTICLEID	
CXoverCacheImplementation::Canonicalize(
	ARTICLEID	artid 
	)	{
/*++

Routine Description : 

	This function figures out what file a particular Article ID
	will fall into.

Arguments : 

	artid - Id of the article we are interested in !

Return Value : 

	lowest article id within the file we are interested in !

--*/

	return	artid & ((~ENTRIES_PER_FILE)+1) ;
}

#if 0 
BOOL
CXoverCacheImplementation::AppendEntry(
					IN	GROUPID	group,
					IN	LPSTR	szPath,
					IN	ARTICLEID	article,
					IN	LPBYTE	lpbEntry,
					IN	DWORD	cbEntry
					) {
/*++

Routine Description : 

	This function adds an entry to an Xover file.
	We will get a hold of a CXoverIndex object
	which will actually save the data away for us !

Arguments : 

	group - The id of the group getting the xover entry
	szPath - Path to the newsgroups directory
	article - The id of the article within the group !
	lpbEntry - Pointer to the Xover data 
	cbEntry - size of the xover data

Return Value : 

	TRUE if successfull, FALSE otherewise !

--*/


	ARTICLEID	artidBase = Canonicalize( article ) ;
	CArticleRef	artRef ;
	artRef.m_groupId = group ;
	artRef.m_articleId = artidBase ;


	CXIXConstructor	constructor ;

	constructor.m_lpstrPath = szPath ;
	constructor.m_fQueryOnly = FALSE ;
	
	CXoverIndex*	pXoverIndex ;
	BOOL	fReturn = FALSE ;

	if( (pXoverIndex = m_Cache.FindOrCreate(	
							artRef, 
							constructor,
							FALSE
							)) != 0  	)	{

		fReturn = pXoverIndex->AppendEntry(
									lpbEntry,
									cbEntry,
									article
									) ;
		m_Cache.CheckIn( pXoverIndex ) ;
	}
	return	FALSE;
}
#endif


BOOL
CXoverCacheImplementation::RemoveEntry(
					IN	GROUPID	group,
					IN	LPSTR	szPath,
					IN	BOOL	fFlatDir,
					IN	ARTICLEID	article
					) {
/*++

Routine Description : 

	This function will remove an entry for an article from
	an xover index file !

Arguments : 

	group - The id of the group getting the xover entry
	szPath - Path to the newsgroups directory
	article - The id of the article within the group !

Return Value : 

	TRUE if successfull, FALSE otherewise !

--*/

	ARTICLEID	artidBase = Canonicalize( article ) ;
	CArticleRef	artRef ;
	artRef.m_groupId = group ;
	artRef.m_articleId = artidBase ;


	CXIXConstructor	constructor ;

	constructor.m_lpstrPath = szPath ;
	constructor.m_fQueryOnly = FALSE ;
	constructor.m_fFlatDir = fFlatDir ;
	constructor.m_pOriginal = 0 ;
	
	CXoverIndex*	pXoverIndex ;

	if( (pXoverIndex = m_Cache.FindOrCreate(	
								artRef, 
								constructor,
								FALSE)) != 0  	)	{

		_ASSERT( pXoverIndex != 0 ) ;

		pXoverIndex->ExpireEntry(
								article
								) ;
		m_Cache.CheckIn( pXoverIndex ) ;
		return	TRUE ;
	}
	return	FALSE;
}

BOOL
CXoverCacheImplementation::FillBuffer(
		IN	CXoverCacheCompletion*	pRequest,
		IN	LPSTR	szPath, 
		IN	BOOL	fFlatDir,
		OUT	HXOVER&	hXover
		)	{

	_ASSERT( pRequest != 0 ) ;
	_ASSERT( szPath != 0 ) ;

	GROUPID		groupId ;
	ARTICLEID	articleIdRequestLow ;
	ARTICLEID	articleIdRequestHigh ;
	ARTICLEID	articleIdGroupHigh ;
	
	pRequest->GetRange(	groupId, 
						articleIdRequestLow,
						articleIdRequestHigh,
						articleIdGroupHigh
						) ;

	_ASSERT( articleIdRequestLow != INVALID_ARTICLEID ) ;
	_ASSERT( articleIdRequestHigh != INVALID_ARTICLEID ) ;
	_ASSERT( groupId != INVALID_GROUPID ) ;
	_ASSERT( articleIdRequestLow <= articleIdRequestHigh ) ;

	ARTICLEID	artidBase = Canonicalize( articleIdRequestLow ) ;
	CArticleRef	artRef ;
	artRef.m_groupId = groupId ;
	artRef.m_articleId = artidBase ;


	CXIXConstructor	constructor ;

	constructor.m_lpstrPath = szPath ;
	constructor.m_fQueryOnly = TRUE ;
	constructor.m_fFlatDir = fFlatDir ;
	constructor.m_pOriginal = pRequest ;
	
	CXoverIndex*	pXoverIndex ;

	if( (pXoverIndex = m_Cache.FindOrCreate(	
								artRef, 
								constructor,
								FALSE)) != 0  	)	{

		_ASSERT( pXoverIndex != 0 ) ;

		pXoverIndex->AsyncFillBuffer(
								pRequest,
								TRUE
								) ;
		//m_Cache.CheckIn( pXoverIndex ) ;
		return	TRUE ;
	}
	return	FALSE;

}


#if 0 
DWORD
CXoverCacheImplementation::FillBuffer(
					IN	BYTE*	lpb,
					IN	DWORD	cb,
					IN	DWORD	groupid,
					IN	LPSTR	szPath,
					IN	BOOL	fFlatDir,
					IN	ARTICLEID	artidStart,
					IN	ARTICLEID	artidFinish,
					OUT	ARTICLEID&	artidLast,
					OUT	HXOVER&		hXover
					)	{
/*++

Routine Description : 

	This function will fill up a users buffer with consecutive
	Xover entries in the range specified.
	We give no guarantees that there are any entries
	between artidStart and artidFinish.
	We will always return through artidLast the next entry at which
	the caller should continue to make queries.  This may be larger
	than artidLast.

Arguments : 

	lpb - Buffer to fill with Xover data
	cb -  Number of bytes to place in buffer
	groupid - Group for which we want xover data
	szPath - directory containing newsgroup files
	artidStart - first article the caller wants
	artidFinish - last article the caller wants
	artidLast - REturn the next articleid the caller	
		should query at.  The only guarantee is that this
		is larger than artidStart
	hXover - Handle to Xover data - the caller should not touch
		this, we will use it to optimize consecutive queries.

Return Value : 

	Number of bytes placed in the buffer
	Zero bytes returned is a valid result.

--*/

	DWORD	dwReturn = MemberFillBuffer(
						&(CXoverIndex::FillBuffer),
						lpb, 
						cb, 
						groupid, 
						szPath, 
						fFlatDir,
						artidStart, 
						artidFinish, 
						artidLast, 
						hXover 
						) ;

	return	dwReturn ;

}


DWORD
CXoverCacheImplementation::ListgroupFillBuffer(
					IN	BYTE*	lpb,
					IN	DWORD	cb,
					IN	DWORD	groupid,
					IN	LPSTR	szPath,
					IN	BOOL	fFlatDir,
					IN	ARTICLEID	artidStart,
					IN	ARTICLEID	artidFinish,
					OUT	ARTICLEID&	artidLast,
					OUT	HXOVER&		hXover
					)	{
/*++

Routine Description : 

	This function will fill the buffer with 'listgroup'
	entries - that is article numbers.
	We give no guarantees that there are any entries
	between artidStart and artidFinish.
	We will always return through artidLast the next entry at which
	the caller should continue to make queries.  This may be larger
	than artidLast.

Arguments : 

	lpb - Buffer to fill with Xover data
	cb -  Number of bytes to place in buffer
	groupid - Group for which we want xover data
	szPath - directory containing newsgroup files
	artidStart - first article the caller wants
	artidFinish - last article the caller wants
	artidLast - REturn the next articleid the caller	
		should query at.  The only guarantee is that this
		is larger than artidStart
	hXover - Handle to Xover data - the caller should not touch
		this, we will use it to optimize consecutive queries.

Return Value : 

	Number of bytes placed in the buffer
	Zero bytes returned is a valid result.

--*/

	DWORD	dwReturn = MemberFillBuffer(
						&(CXoverIndex::ListgroupFill),
						lpb, 
						cb, 
						groupid, 
						szPath, 
						fFlatDir,
						artidStart, 
						artidFinish, 
						artidLast, 
						hXover 
						) ;

	return	dwReturn ;

}



DWORD
CXoverCacheImplementation::MemberFillBuffer(
					IN  DWORD	(CXoverIndex::*pfn)( BYTE *, DWORD, ARTICLEID, ARTICLEID, ARTICLEID&),
					IN	BYTE*	lpb,
					IN	DWORD	cb,
					IN	DWORD	groupid,
					IN	LPSTR	szPath,
					IN	BOOL	fFlatDir,
					IN	ARTICLEID	artidStart,
					IN	ARTICLEID	artidFinish,
					OUT	ARTICLEID&	artidLast,
					OUT	HXOVER&		hXover
					)	{
/*++

Routine Description : 

	This function will fill buffers with different kinds of 
	data (listgroup or xover) depending on the member function pointer pfn
	We give no guarantees that there are any entries
	between artidStart and artidFinish.
	We will always return through artidLast the next entry at which
	the caller should continue to make queries.  This may be larger
	than artidLast.

Arguments : 

	lpb - Buffer to fill with Xover data
	cb -  Number of bytes to place in buffer
	groupid - Group for which we want xover data
	szPath - directory containing newsgroup files
	artidStart - first article the caller wants
	artidFinish - last article the caller wants
	artidLast - REturn the next articleid the caller	
		should query at.  The only guarantee is that this
		is larger than artidStart
	hXover - Handle to Xover data - the caller should not touch
		this, we will use it to optimize consecutive queries.

Return Value : 

	Number of bytes placed in the buffer
	Zero bytes returned is a valid result.

--*/

	DWORD	cbReturn = 0 ;
	ARTICLEID	article = artidStart ;
	ARTICLEID	artidBase ;
	BOOL	fGiveHandleOut = FALSE ;
	BOOL	fBail = FALSE ;

	CXIXConstructor	constructor ;

	constructor.m_lpstrPath = szPath ;
	constructor.m_fQueryOnly = TRUE ;

#ifdef	DEBUG
	//
	//	This will be used to check that we don't overrun
	//	our buffers !!  In debug builds the following byte
	//	is always accessible !
	//
	BYTE	chCheck = lpb[cb] ;
#endif

	if( hXover != 0 ) {

		InterlockedIncrement( &m_HandleLimit ) ;

		if( Canonicalize( artidStart != hXover->m_Start.m_articleId ) ) {
			//
			//	This handle is no longer usefull - so set it to zero
			//	and increment our handle limit !
			//	
			hXover = 0 ;
		}
	}

	do	{

		//
		//	Figure out whether we have to search for another handle !
		//
		if( hXover == 0 ||
			Canonicalize( article ) != hXover->m_Start.m_articleId ) {

			artidBase = Canonicalize( article ) ;
			
			CArticleRef	artRef( groupid, artidBase ) ;

			hXover = m_Cache.FindOrCreate(	
									artRef,
									constructor
									) ;
		}

		if( hXover != 0 ) {

			DWORD cbFill = ((hXover.Pointer())->*pfn)(
											lpb+cbReturn,
											cb-cbReturn,
											article,
											artidFinish,
											artidLast
											) ;

			cbReturn += cbFill ;

			//
			//	This _ASSERT must be true, either FillBuffer makes progress
			//	and advances artidLast OR it returns 0 bytes because theres
			//	not enough room in the buffer !
			//
			_ASSERT( artidLast > article || cbFill == 0 ) ;

			//
			//	This if should break our loop if we are not making progress 
			//	We must be carefull not to break the loop unnecessarily - 
			//	ie. cancels or something could result in a lot of missing 
			//	.xix files, which results in cbFill==0 frequently, however as long as 
			//	article is moving towards artidLast this should be o.k.
			//
			if( article == artidLast &&
				cbFill == 0 ) {
				fBail = TRUE ;
			}
			
			article = artidLast ;

#ifdef	DEBUG
			//
			//	Check for overruns of our buffer !
			//
			_ASSERT( chCheck == lpb[cb] ) ;
#endif

		}	else	{
	
			//
			//	For whatever reason, we can't get the user is Xover data
			//	so he should not bother to try another query
			//	that would fall into the same file !
			//
			article = artidBase + ENTRIES_PER_FILE ;
			artidLast = article ;

		}

		//
		//	We must not put in more bytes than caller wanted !
		//	
		_ASSERT( cbReturn <= cb ) ;
						
	}	while( cbReturn < (cb-100) &&
				article <= artidFinish && 
				Canonicalize( article ) != artidBase &&
				!fBail
				) ;


	_ASSERT( artidLast > artidStart || (artidLast == artidStart && cbReturn == 0) ) ;

	//
	//	If we have a handle that we are considering returning to the caller
	//	check whether it will be usefull, and make sure we don't exceed our
	//	limit of outstanding handles !
	//
	if( hXover != 0 ) {
		if( Canonicalize( artidLast ) != hXover->m_Start.m_articleId )	{
			hXover = 0 ;
		}	else	if( InterlockedDecrement( &m_HandleLimit ) < 0 ) {
			hXover = 0 ;
			InterlockedIncrement( &m_HandleLimit ) ;
		}
	}

#ifdef	DEBUG
	//
	//	Check for overruns !
	//
	_ASSERT( chCheck == lpb[cb] ) ;
#endif

	return	cbReturn ;

}
#endif




class	CXIXCallbackClass : public	CXIXCallbackBase {
public :

	GROUPID		m_groupId ;
	ARTICLEID	m_articleId ;

	BOOL	fRemoveCacheItem(	
					CArticleRef*	pKey,
					CXoverIndex*	pData 
					)	{

		return	pKey->m_groupId == m_groupId && 
					(m_articleId == 0 || pKey->m_articleId <= m_articleId) ;
	}
}	;


BOOL
CXoverCacheImplementation::FlushGroup(
				IN	GROUPID	group,
				IN	ARTICLEID	articleTop,
				IN	BOOL	fCheckInUse
				) {
/*++

Routine Description : 

	This function will get rid of any cache'd CXoverIndex objects
	we may have around that meet the specifications.
	(ie. they are for the specified group and contains articles
	lower in number than articleTop)

Arguments : 

	group - Group Id of the group we want to get rid of.
	articleTop - discard any thing have articleid's less than this
	fCheckInUse - if TRUE then don't discard CXoverIndex objects
		which are being used on another thread
		
	NOTE : Only pass FALSE for this parameter when you are CERTAIN
		that the CXoverIndex files will not be re-used - ie.
		due to a virtual root directory change !!!! 
		Otherwise the Xover Index files can become corrupted !!!

Return Value : 

	TRUE if successfull, 
	FALSE otherwise

--*/

	CXIXCallbackClass	callback ;

	callback.m_groupId = group ;
	callback.m_articleId = articleTop ;

	return	m_Cache.ExpungeItems( &callback ) ;
}

class	CXIXCallbackClass2 : public	CXIXCallbackBase {
public :

	BOOL	fRemoveCacheItem(	
					CArticleRef*	pKey,
					CXoverIndex*	pData 
					)	{
		return	TRUE ;
	}
}	;



BOOL
CXoverCacheImplementation::EmptyCache() {
/*++

Routine Description : 

	This function will get rid of all cache'd CXoverIndex objects
	We're called during shutdown when we want to get rid of everything !

Arguments : 

	None.

Return Value : 

	TRUE if successfull, 
	FALSE otherwise

--*/

	CXIXCallbackClass2	callback ;

	return	m_Cache.ExpungeItems( &callback ) ;
}


BOOL
CXoverCacheImplementation::ExpireRange(
				IN	GROUPID	group,
				IN	LPSTR	szPath,
				IN	BOOL	fFlatDir,
				IN	ARTICLEID	articleLow, 
				IN	ARTICLEID	articleHigh,
				OUT	ARTICLEID&	articleNewLow
				)	{
/*++

Routine Description : 

	This function deletes all of the xover index files that 
	contain article information in the range between ArticleLow
	and ArticleHigh inclusive.  
	We may not erase the file containing ArticleHigh if ArticleHigh
	is not the last entry within that file.

Arguments : 

	group -	ID of the group for which we are deleting Xover information
	szPath -	Directory containing newsgroup information
	articleLow - Low articleid of the expired articles
	articleHigh - Highest expired article number
	articleNewLog - Returns the new 'low' articleid.
		This is done so that we can insure that if we fail
		to delete an index file on one attempt, we will try again
		later !

Return Value : 

	TRUE if no errors occurred
	FALSE if an error occurred.
		If an error occurs articleNewLow will be set so that
		if we are called again with articleNewLow as our articleLow
		parameter we will try to delete the problem index file again !	

--*/


	articleNewLow = articleLow ;

	_ASSERT( articleHigh >= articleLow ) ;

	if( articleHigh < articleLow )		{
		SetLastError( ERROR_INVALID_PARAMETER ) ;
		return	FALSE ;
	}

	ARTICLEID	articleLowCanon = Canonicalize( articleLow ) ;
	ARTICLEID	articleHiCanon = Canonicalize( articleHigh ) ;

	DWORD	status = ERROR_SUCCESS ;
	BOOL	fSuccessfull = FALSE ;

	//
	//	If the Low and Hi ends of the expired range are 
	//	in the bounds of the index file, then we won't delete ANY 
	//	files, as there can still be usefull entries within
	//	this file.
	//
	if( articleLowCanon != articleHiCanon ) {

		fSuccessfull = TRUE ;
		BOOL	fAdvanceNewLow = TRUE ;

		FlushGroup( group, articleHigh ) ;

		ARTICLEID	article = articleLowCanon ;

		while( article < articleHiCanon )	{
		
			char	szFile[MAX_PATH*2] ;
			CXoverIndex::ComputeFileName(	
									CArticleRef( group, article ),
									szPath,
									szFile,
									fFlatDir
									) ;

			article += ENTRIES_PER_FILE ;

			_ASSERT( article <= articleHiCanon ) ;

			if( !DeleteFile(	szFile ) )	{
				
				if( GetLastError() != ERROR_FILE_NOT_FOUND )	{

					//
					//	Some serious kind of problem occurred - 
					//	make sure we no longer advance articleNewLow 
					//
					fSuccessfull &= FALSE ;

					fAdvanceNewLow = FALSE ;
					if( status == ERROR_SUCCESS )	{
						status = GetLastError() ;
					}
				}
			}
			if( fAdvanceNewLow )	{
				articleNewLow = article ;
			}
		}
	}
	SetLastError( status ) ;
	return	fSuccessfull ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\watchci\src\watchci.cpp ===
#include <windows.h>
#include <dbgtrace.h>
#include <stdlib.h>
#include <tflist.h>
#include <rwnew.h>
#include <xmemwrpr.h>
#include "watchci.h"

CWatchCIRoots::CWatchCIRoots() :
	m_CIRootList (&CCIRoot::m_pPrev, &CCIRoot::m_pNext),
	m_dwUpdateLock(-1),
	m_dwTicksLastUpdate(0) {
	TraceFunctEnter("WatchCIRoots::CWatchCIRoots");
	
	m_heRegNot = NULL;
	m_hkCI = NULL;
	
	TraceFunctLeave();
}

CWatchCIRoots::~CWatchCIRoots() {
	TraceFunctEnter("CWatchCIRoots::~CWatchCIRoots");

	Terminate();

	TraceFunctLeave();
}

HRESULT CWatchCIRoots::Terminate() {
	TraceFunctEnter("CWatchCIRoots::Terminate");

	m_Lock.ExclusiveLock();

	if (m_hkCI != NULL)
		_VERIFY(RegCloseKey(m_hkCI) == ERROR_SUCCESS);
	m_hkCI = NULL;

	if (m_heRegNot != NULL)
		_VERIFY(CloseHandle(m_heRegNot));
	m_heRegNot = NULL;

	EmptyList();

	m_Lock.ExclusiveUnlock();

	TraceFunctLeave();

	return S_OK;
}

HRESULT CWatchCIRoots::Initialize(WCHAR *pwszCIRoots) {
	TraceFunctEnter("CWatchCIRoots::Initialize");

	_ASSERT(m_heRegNot == NULL);
	_ASSERT(m_hkCI == NULL);

	if (m_hkCI != NULL || m_heRegNot != NULL) {
		ErrorTrace((DWORD_PTR)this, "Already initialized");
		return E_FAIL;
	}

	m_Lock.ExclusiveLock();

	DWORD ec = ERROR_SUCCESS;
	HRESULT hr = S_OK;
	do {
		// this event will get signalled whenever the CI registry changes
		m_heRegNot = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (m_heRegNot == NULL) { ec = GetLastError(); break; }

		// open the registry pointing to the content index information
		ec = RegOpenKey(HKEY_LOCAL_MACHINE, pwszCIRoots, &m_hkCI);
		if (ec != ERROR_SUCCESS) break;

		// register to get notified on changes
		ec = RegNotifyChangeKeyValue(m_hkCI, TRUE,
									 REG_NOTIFY_CHANGE_NAME |
									 REG_NOTIFY_CHANGE_LAST_SET,
									 m_heRegNot,
									 TRUE);
		if (ec != ERROR_SUCCESS) break;

		// Load the initial values
		ec = ReadCIRegistry();
		if (ec != ERROR_SUCCESS) break;

	} while (0);

	// handle error conditions
	if (ec != ERROR_SUCCESS || hr != S_OK) {
		// if hr is still S_OK then an error code is in ec
		if (hr == S_OK) hr = HRESULT_FROM_WIN32(ec);

		// free up any resources we might have created
		if (m_hkCI != NULL) {
			_VERIFY(RegCloseKey(m_hkCI) == ERROR_SUCCESS);
			m_hkCI = NULL;
		}

		if (m_heRegNot != NULL) {
			_VERIFY(CloseHandle(m_heRegNot));
			m_heRegNot = NULL;
		}
	}

	m_Lock.ExclusiveUnlock();

	return hr;
}

void CWatchCIRoots::EmptyList() {
	TFList<CCIRoot>::Iterator it(&m_CIRootList);

	while (!it.AtEnd()) {
		CCIRoot *pRoot = it.Current();
		XDELETE pRoot->m_pwszPath;
		it.RemoveItem();
		XDELETE pRoot;
	}
}

HRESULT CWatchCIRoots::CheckForChanges(DWORD cTimeout) {
	TraceFunctEnter("CWatchCIRoots::CheckForChanges");

	DWORD hr;
	DWORD w = WaitForSingleObject(m_heRegNot, cTimeout);
	switch (w) {
		case WAIT_OBJECT_0:
			DebugTrace(0, "WatchCI: registry changes");
			m_Lock.ExclusiveLock();
			hr = ReadCIRegistry();
			m_Lock.ExclusiveUnlock();
			// register to get notified on changes
			RegNotifyChangeKeyValue(m_hkCI, TRUE,
									REG_NOTIFY_CHANGE_NAME |
									REG_NOTIFY_CHANGE_LAST_SET,
									m_heRegNot,
									TRUE);
			break;
		case WAIT_TIMEOUT:
			hr = S_OK;
			break;
		default:
			hr = HRESULT_FROM_WIN32(GetLastError());
			break;
	}

	TraceFunctLeave();
	return hr;
}

//
// this function allows us to query a content index value.  if it isn't
// found in the hkPrimary key then it will be looked for in the hkSecondary
// key.
//
// parameters:
//	hkPrimary - the primary key to look in
// 	hkSecondary - the secondary key to look in
//	szValueName - the value to look up
//	pResultType - pointer to receive the type of the data
//	pbResult - pointer to receive the data itself
//	pcbResult - the number of bytes in lpByte
// returns:
//	S_FALSE - the value doesn't exist
//	S_OK - the value exists
//	any other - a error code as an HRESULT
//
HRESULT CWatchCIRoots::QueryCIValue(HKEY hkPrimary, HKEY hkSecondary,
								    LPCTSTR szValueName, LPDWORD pResultType,
									LPBYTE pbResult, LPDWORD pcbResult)
{
	TraceFunctEnter("CWatchCIRoots::QueryCIValue");

	DWORD ec;
	DWORD hr = S_FALSE;
	DWORD i;
	HKEY hkArray[2] = { hkPrimary, hkSecondary };

	for (i = 0; i < 2 && hr == S_FALSE; i++) {
		ec = RegQueryValueEx(hkArray[i], szValueName, NULL, pResultType,
						 	 pbResult, pcbResult);
		switch (ec) {
			case ERROR_SUCCESS:
				hr = S_OK;
				break;
			case ERROR_FILE_NOT_FOUND:
				hr = S_FALSE;
				break;
			default:
				hr = HRESULT_FROM_WIN32(ec);
				break;
		}
	}

	return hr;
}

HRESULT CWatchCIRoots::QueryCIValueDW(HKEY hkPrimary, HKEY hkSecondary,
								      LPCTSTR szValueName, LPDWORD pdwResult)
{
	TraceFunctEnter("CWatchCIRoots::QueryCIValueDW");
	
	DWORD hr;
	DWORD dwType, cbResult = 4;

	hr = QueryCIValue(hkPrimary, hkSecondary, szValueName,
		&dwType, (LPBYTE) pdwResult, &cbResult);
	if (hr == S_OK && dwType != REG_DWORD) {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE);
	}

	TraceFunctLeave();
	return hr;
}

HRESULT CWatchCIRoots::QueryCIValueSTR(HKEY hkPrimary, HKEY hkSecondary,
								       LPCTSTR szValueName, LPCTSTR pszResult,
									   PDWORD pchResult)
{
	TraceFunctEnter("CWatchCIRoots::QueryCIValueSTR");
	
	DWORD hr;
	DWORD dwType;

	hr = QueryCIValue(hkPrimary, hkSecondary, szValueName,
		&dwType, (LPBYTE) pszResult, pchResult);
	if (hr == S_OK && dwType != REG_SZ) {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE);
	}

	TraceFunctLeave();
	return hr;
}

HRESULT CWatchCIRoots::ReadCIRegistry(void) {

	// Assume we have an exclusive lock upon entry to this routine
	
	TraceFunctEnter("CWatchCIRoots::ReadCIRegistry");
	
	HKEY hkCatalogs;
	DWORD ec;
	DWORD hr;

	// open the key to the catalogs
	ec = RegOpenKey(m_hkCI, REGCI_CATALOGS, &hkCatalogs);
	if (ec != ERROR_SUCCESS) {
		TraceFunctLeave();
		return HRESULT_FROM_WIN32(ec);
	}

	EmptyList();

	// enumerate the catalogs
	TCHAR szSubkey[_MAX_PATH];
	DWORD iSubkey = 0, cbSubkey;
	for (iSubkey = 0; ec != ERROR_NO_MORE_ITEMS; iSubkey++) {
		cbSubkey = _MAX_PATH;
		ec = RegEnumKeyEx(hkCatalogs, iSubkey, szSubkey, &cbSubkey, NULL,
						  NULL, NULL, NULL);
		if (ec == ERROR_NO_MORE_ITEMS) break;
		if (ec != ERROR_SUCCESS) {
			_VERIFY(RegCloseKey(hkCatalogs) == ERROR_SUCCESS);
			TraceFunctLeave();
			return HRESULT_FROM_WIN32(ec);
		}

		DebugTrace(0, "looking at catalog %S", szSubkey);

		// open this subkey
		HKEY hkThisCatalog = 0;
		ec = RegOpenKey(hkCatalogs, szSubkey, &hkThisCatalog);
		if (ec != ERROR_SUCCESS) {
			_VERIFY(RegCloseKey(hkCatalogs) == ERROR_SUCCESS);
			TraceFunctLeave();
			return HRESULT_FROM_WIN32(ec);
		}

		// see if this catalog is being indexed
		DWORD dwIsIndexed;
		hr = QueryCIValueDW(hkThisCatalog, m_hkCI, REGCI_ISINDEXED,
							&dwIsIndexed);
		if (FAILED(hr)) {
			_VERIFY(RegCloseKey(hkCatalogs) == ERROR_SUCCESS);
			_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
			TraceFunctLeave();
			return HRESULT_FROM_WIN32(ec);
		}
		if (hr == S_FALSE || dwIsIndexed != 0x1) {
			_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
			continue;
		}
		DebugTrace(0, "this catalog is being indexed");

		// find the location of this catalog
		TCHAR szLocation[_MAX_PATH];
		DWORD cLocation = sizeof(szLocation);
		hr = QueryCIValueSTR(hkThisCatalog, m_hkCI, REGCI_LOCATION,
							 szLocation, &cLocation);
		if (FAILED(hr)) {
			_VERIFY(RegCloseKey(hkCatalogs) == ERROR_SUCCESS);
			_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
			TraceFunctLeave();
			return HRESULT_FROM_WIN32(ec);
		}
		if (hr == S_FALSE) {
			_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
			continue;
		}
		DebugTrace(0, "catalog location = %S", szLocation);

		// find out which NNTP instance is being indexed
		DWORD dwInstance = sizeof(szLocation);
		hr = QueryCIValueDW(hkThisCatalog, m_hkCI, REGCI_NNTPINSTANCE,
							&dwInstance);
		if (FAILED(hr)) {
			_VERIFY(RegCloseKey(hkCatalogs) == ERROR_SUCCESS);
			_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
			TraceFunctLeave();
			return HRESULT_FROM_WIN32(ec);
		}
		if (hr == S_FALSE) {
			_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
			continue;
		}
		DebugTrace(0, "dwInstance = %lu", dwInstance);

		WCHAR *pwszLocation = XNEW WCHAR [lstrlenW(szLocation)+1];
		if (!pwszLocation) {
			_VERIFY(RegCloseKey(hkCatalogs) == ERROR_SUCCESS);
			_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
			TraceFunctLeave();
			return E_OUTOFMEMORY;
		}

		lstrcpyW(pwszLocation, szLocation);
		
		CCIRoot *pRoot = XNEW CCIRoot(dwInstance, pwszLocation);
		if (!pRoot) {
			XDELETE pwszLocation;
			_VERIFY(RegCloseKey(hkCatalogs) == ERROR_SUCCESS);
			_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
			TraceFunctLeave();
			return E_OUTOFMEMORY;
		}

		m_CIRootList.PushBack(pRoot);

		_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
	}

	_VERIFY(RegCloseKey(hkCatalogs) == ERROR_SUCCESS);

	TraceFunctLeave();
	return S_OK;
}

// don't read the catalogs more than once per second
#define CATALOG_UPDATE_RATE 1000

void CWatchCIRoots::UpdateCatalogInfo(void) {
    long sign = InterlockedIncrement(&m_dwUpdateLock);
    if (sign == 0) {
        DWORD dwTicks = GetTickCount();
        if (dwTicks - m_dwTicksLastUpdate > CATALOG_UPDATE_RATE)
            CheckForChanges();
    }
    InterlockedDecrement(&m_dwUpdateLock);
}

HRESULT CWatchCIRoots::GetCatalogName(
	DWORD dwInstance, DWORD cbSize, WCHAR *pwszBuffer) {

	HRESULT hr = S_FALSE;

	// If we don't have a handle to the registry key or an event watching
	// the key, then content indexing must not be installed.  Fail.
	if (m_heRegNot == NULL || m_hkCI == NULL)
		return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);

	UpdateCatalogInfo();

	m_Lock.ShareLock();

	TFList<CCIRoot>::Iterator it(&m_CIRootList);
	while (!it.AtEnd()) {
		CCIRoot *pRoot = it.Current();
		it.Next();
		if (pRoot->m_dwInstance == dwInstance) {
			_ASSERT ((DWORD)lstrlenW(pRoot->m_pwszPath) < cbSize);
			if ((DWORD)lstrlenW(pRoot->m_pwszPath) < cbSize) {
				lstrcpyW(pwszBuffer, pRoot->m_pwszPath);
				hr = S_OK;
			} else {
				pwszBuffer[0] = L'\0';
				hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
			}
			break;
		}
	}


	m_Lock.ShareUnlock();

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\restart\iisrsta\dcomperm.cpp ===
#include "windows.h"

#include <stdio.h>
#include <tchar.h>
#include <string.h>
#include <conio.h>
#include "dcomperm.h"

#define _WIN32_DCOM
#include <objbase.h>

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    LPVOID                ace;
    ACE_HEADER            *aceHeader;
    ULONG                 i;

    GetAclInformation (OldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (aclSizeInfo), AclSizeInformation);

    //
    // Copy all of the ACEs to the new ACL
    //

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        //
        // Get the ACE and header info
        //

        if (!GetAce (OldACL, i, &ace))
            return GetLastError();

        aceHeader = (ACE_HEADER *) ace;

        //
        // Add the ACE to the new list
        //

        if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
            return GetLastError();
    }

    return ERROR_SUCCESS;
}

DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  oldACL, newACL;
    BOOL                  bWellKnownSID = FALSE;
    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_DENIED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    if (!AddAccessDeniedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    *Acl = newACL;

cleanup:
    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  oldACL, newACL;
    BOOL                  bWellKnownSID = FALSE;

    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if (!AddAccessAllowedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    *Acl = newACL;

cleanup:
    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION    aclSizeInfo;
    ULONG                   i;
    LPVOID                  ace;
    ACCESS_ALLOWED_ACE      *accessAllowedAce;
    ACCESS_DENIED_ACE       *accessDeniedAce;
    SYSTEM_AUDIT_ACE        *systemAuditAce;
    PSID                    principalSID = NULL;
    DWORD                   returnValue = ERROR_SUCCESS;
    ACE_HEADER              *aceHeader;
    BOOL                    bWellKnownSID = FALSE;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (Acl, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce (Acl, i, &ace))
        {
            returnValue = GetLastError();
            break;
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        }
    }

    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
GetCurrentUserSID (
    PSID *Sid
    )
{
    DWORD dwReturn = ERROR_SUCCESS;
    TOKEN_USER  *tokenUser = NULL;
    HANDLE      tokenHandle = NULL;
    DWORD       tokenSize;
    DWORD       sidLength;

    if (OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
    {
        GetTokenInformation (tokenHandle, TokenUser, tokenUser, 0, &tokenSize);

        tokenUser = (TOKEN_USER *) malloc (tokenSize);

        if (tokenUser == NULL) {
            dwReturn = E_OUTOFMEMORY;
        }
        else if (GetTokenInformation (tokenHandle, TokenUser, tokenUser, tokenSize, &tokenSize))
        {
            sidLength = GetLengthSid (tokenUser->User.Sid);
            *Sid = (PSID) malloc (sidLength);

            if (*Sid == NULL) {
                dwReturn = E_OUTOFMEMORY;
            }
            else {
                memcpy (*Sid, tokenUser->User.Sid, sidLength);
                CloseHandle (tokenHandle);
            }
        } 
        else {
            dwReturn = GetLastError();
        }

        if (tokenUser)
            free(tokenUser);

    } else
        dwReturn = GetLastError();

    return dwReturn;
}

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    )
{
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
    BYTE Count;
    DWORD dwRID[8];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));
    //_strlwr( Principal);
    if ( !_tcscmp( Principal,TEXT("administrators")) ) {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
    } else if ( !_tcscmp( Principal, TEXT("system")) ) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;
    } else if ( !_tcscmp( Principal,TEXT("interactive")) ) {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;
    } else if ( !_tcscmp( Principal,TEXT("everyone")) ) {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;
    } else {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority, 
                                    (BYTE)Count, 
		                            dwRID[0], 
		                            dwRID[1], 
		                            dwRID[2], 
		                            dwRID[3], 
		                            dwRID[4], 
		                            dwRID[5], 
		                            dwRID[6], 
		                            dwRID[7], 
                                    Sid) )
        return GetLastError();
    } else {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256];
        DWORD        refDomainSize;
        DWORD        returnValue;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           Principal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();
        if (returnValue != ERROR_INSUFFICIENT_BUFFER)
            return returnValue;

        *Sid = (PSID) malloc (sidSize);
        refDomainSize = 255;

        if (!LookupAccountName (NULL,
                                Principal,
                                *Sid,
                                &sidSize,
                                refDomain,
                                &refDomainSize,
                                &snu))
        {
            return GetLastError();
        }
    }

    return ERROR_SUCCESS;
}

DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    )
{
    PACL    dacl;
    DWORD   sidLength;
    PSID    sid = NULL;
    PSID    groupSID;
    PSID    ownerSID;
    DWORD   returnValue;

    *SD = NULL;

    returnValue = GetCurrentUserSID (&sid);
    if (returnValue != ERROR_SUCCESS) {
        if (sid)
            free(sid);
        return returnValue;
    }

    sidLength = GetLengthSid (sid);

    *SD = (SECURITY_DESCRIPTOR *) malloc (
        (sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength) +
        (2 * sidLength) +
        sizeof (SECURITY_DESCRIPTOR));

    if (*SD == NULL) 
        return E_OUTOFMEMORY;

    groupSID = (SID *) (*SD + 1);
    ownerSID = (SID *) (((BYTE *) groupSID) + sidLength);
    dacl = (ACL *) (((BYTE *) ownerSID) + sidLength);

    if (!InitializeSecurityDescriptor (*SD, SECURITY_DESCRIPTOR_REVISION))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!InitializeAcl (dacl,
                        sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength,
                        ACL_REVISION2))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!AddAccessAllowedAce (dacl,
                              ACL_REVISION2,
                              COM_RIGHTS_EXECUTE,
                              sid))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!SetSecurityDescriptorDacl (*SD, TRUE, dacl, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    memcpy (groupSID, sid, sidLength);
    if (!SetSecurityDescriptorGroup (*SD, groupSID, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    memcpy (ownerSID, sid, sidLength);
    if (!SetSecurityDescriptorOwner (*SD, ownerSID, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (sid)
        free(sid);
    return ERROR_SUCCESS;
}


DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    )
{
    PSECURITY_DESCRIPTOR  sd = NULL;
    DWORD                 descriptorSize;
    DWORD                 daclSize;
    DWORD                 saclSize;
    DWORD                 ownerSIDSize;
    DWORD                 groupSIDSize;
    PACL                  dacl = NULL;
    PACL                  sacl = NULL;
    PSID                  ownerSID = NULL;
    PSID                  groupSID = NULL;
    BOOL                  present;
    BOOL                  systemDefault;

    //
    // Get SACL
    //

    if (!GetSecurityDescriptorSacl (OldSD, &present, &sacl, &systemDefault))
        return GetLastError();

    if (sacl && present)
    {
        saclSize = sacl->AclSize;
    } else saclSize = 0;

    //
    // Get DACL
    //

    if (!GetSecurityDescriptorDacl (OldSD, &present, &dacl, &systemDefault))
        return GetLastError();

    if (dacl && present)
    {
        daclSize = dacl->AclSize;
    } else daclSize = 0;

    //
    // Get Owner
    //

    if (!GetSecurityDescriptorOwner (OldSD, &ownerSID, &systemDefault))
        return GetLastError();

    ownerSIDSize = GetLengthSid (ownerSID);

    //
    // Get Group
    //

    if (!GetSecurityDescriptorGroup (OldSD, &groupSID, &systemDefault))
        return GetLastError();

    groupSIDSize = GetLengthSid (groupSID);

    //
    // Do the conversion
    //

    descriptorSize = 0;

    MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                    &saclSize, ownerSID, &ownerSIDSize, groupSID,
                    &groupSIDSize);

    sd = (PSECURITY_DESCRIPTOR) new BYTE [SECURITY_DESCRIPTOR_MIN_LENGTH];
    if (sd == NULL)
        return E_OUTOFMEMORY;
    if (!InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION))
        return GetLastError();

    if (!MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                         &saclSize, ownerSID, &ownerSIDSize, groupSID,
                         &groupSIDSize))
        return GetLastError();

    *NewSD = sd;
    return ERROR_SUCCESS;
}

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    )
{
    DWORD   returnValue;
    DWORD   disposition;
    HKEY    registryKey;

    //
    // Create new key or open existing key
    //

    returnValue = RegCreateKeyEx (RootKey, KeyName, 0, _T(""), 0, KEY_ALL_ACCESS, NULL, &registryKey, &disposition);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    //
    // Write the security descriptor
    //

    returnValue = RegSetValueEx (registryKey, ValueName, 0, REG_BINARY, (LPBYTE) SD, GetSecurityDescriptorLength (SD));
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD
    )
{
    DWORD               returnValue;
    HKEY                registryKey;
    DWORD               valueType;
    DWORD               valueSize = 0;

    *NewSD = FALSE;

    //
    // Get the security descriptor from the named value. If it doesn't
    // exist, create a fresh one.
    //

    returnValue = RegOpenKeyEx (RootKey, KeyName, 0, KEY_ALL_ACCESS, &registryKey);

    if (returnValue != ERROR_SUCCESS)
    {
        if (returnValue == ERROR_FILE_NOT_FOUND)
        {
            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD)
                    free(*SD);
                return returnValue;
            }

            *NewSD = TRUE;
            return ERROR_SUCCESS;
        } else
            return returnValue;
    }

    returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, NULL, &valueSize);

    if (returnValue && returnValue != ERROR_INSUFFICIENT_BUFFER)
    {
        *SD = NULL;
        returnValue = CreateNewSD (SD);
        if (returnValue != ERROR_SUCCESS) {
            if (*SD)
                free(*SD);
            return returnValue;
        }

        *NewSD = TRUE;
    } else
    {
        *SD = (SECURITY_DESCRIPTOR *) malloc (valueSize);

        if (*SD != NULL)
            returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, (LPBYTE) *SD, &valueSize);
        if ((*SD == NULL) || returnValue)
        {
            if (*SD)
                free (*SD);

            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD)
                    free(*SD);
                return returnValue;
            }

            *NewSD = TRUE;
        }
    }

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;


    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("system"));
#if 0
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("INTERACTIVE"));
#endif
    }

    //
    // Add the Principal that the caller wants added
    //

    if (Permit)
        returnValue = AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, Principal); 
    else
        returnValue = AddAccessDeniedACEToACL (&dacl, GENERIC_ALL, Principal);

    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute); 
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute) 
        free (sdAbsolute);

    return returnValue;
}

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl = NULL;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;

    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // If the security descriptor is new, add the required Principals to it
    //

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("system"));
#if 0
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("INTERACTIVE"));
#endif
    }

    //
    // Remove the Principal that the caller wants removed
    //

    returnValue = RemovePrincipalFromACL (dacl, Principal);
    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute); 
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute)
        free (sdAbsolute);

    return returnValue;
}

DWORD
ChangeAppIDAccessACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256];
    DWORD   err;

    if (AppID [0] == _T('{'))
        _stprintf (keyName, _T("APPID\\%s"), AppID); 
    else
        _stprintf (keyName, _T("APPID\\{%s}"), AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal, Permit);
    } else
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal);

     return err;
}

DWORD
ChangeAppIDLaunchACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256];
    DWORD   err;

    if (AppID [0] == _T('{'))
        _stprintf (keyName, _T("APPID\\%s"), AppID); 
    else
        _stprintf (keyName, _T("APPID\\{%s}"), AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal, Permit);
    } else
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal);

    return err;
}

DWORD
ChangeDCOMAccessACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256] = _T("Software\\Microsoft\\OLE");
    DWORD   err;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal, Permit);
    } else
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal);
    
    return err;
}

DWORD
ChangeDCOMLaunchACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256] = _T("Software\\Microsoft\\OLE");
    DWORD   err;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal, Permit);
    } else
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal);
    
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\restart\iisrsta\common.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*		  Copyright (C) 1994-1998 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

#define TITLE_SIZE          64
#define PROCESS_SIZE        MAX_PATH


#if defined(__cplusplus)
extern "C" {
#endif

//
// task list structure
//
typedef struct _TASK_LIST {
    DWORD       dwProcessId;
    DWORD       dwInheritedFromProcessId;
    BOOL        flags;
    HANDLE      hwnd;
    TCHAR       ProcessName[PROCESS_SIZE];
    TCHAR       WindowTitle[TITLE_SIZE];
} TASK_LIST, *PTASK_LIST;

typedef struct _TASK_LIST_ENUM {
    PTASK_LIST  tlist;
    DWORD       numtasks;
} TASK_LIST_ENUM, *PTASK_LIST_ENUM;


//
// Function pointer types for accessing platform-specific functions
//
typedef HRESULT (*LPGetTaskList)(PTASK_LIST, DWORD, LPTSTR, LPDWORD, BOOL, LPSTR);
typedef BOOL  (*LPEnableDebugPriv)(VOID);


//
// Function prototypes
//

HRESULT
GetTaskListNT(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks,
    LPTSTR      pName,
    LPDWORD     pdwNumTasks,
    BOOL        fKill,
    LPSTR       pszMandatoryModule
    );


BOOL
EnableDebugPrivNT(
    VOID
    );

HRESULT
KillProcess(
    PTASK_LIST tlist,
    BOOL       fForce
    );

VOID
GetPidFromTitle(
    LPDWORD     pdwPid,
    HWND*       phwnd,
    LPCTSTR     pExeName
    );

#if 0

DWORD
GetTaskList95(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks,
    LPTSTR      pName
    );

BOOL
EnableDebugPriv95(
    VOID
    );

VOID
GetWindowTitles(
    PTASK_LIST_ENUM te
    );

BOOL
MatchPattern(
    TCHAR* String,
    TCHAR* Pattern
    );

#endif

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nsepm\refb.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    refb.cxx

Abstract:

    Reference counting blob class

Author:

    Philippe Choquier (phillich)    11-sep-1996

--*/

#include <windows.h>

#include <refb.hxx>


RefBlob::RefBlob(
    ) 
/*++
    Description:

        Constructor for RefBlob

    Arguments:
        None

    Returns:
        Nothing

--*/
{ 
    m_lRef = 0; 
    m_pvBlob = 0; 
    m_dwSize = 0; 
    m_pfnFree = NULL;
}


RefBlob::~RefBlob(
    ) 
/*++
    Description:

        Destructor for RefBlob

    Arguments:
        None

    Returns:
        Nothing

--*/
{
}


BOOL 
RefBlob::Init( 
    LPVOID          pv, 
    DWORD           sz,
    PFN_FREE_BLOB   pFn
    ) 
/*++
    Description:

        Initialize a RefBlob
        ownership of buffer pointed to by pv is transferred
        to this object. buffer must have been allocated using
        LocalAlloc( LMEM_FIXED, )

    Arguments:
        pv - pointer to blob
        sz - size of blob
        pFn - ptr to function to call to free blob

    Returns:
        TRUE if success, otherwise FALSE

--*/
{ 
    m_pvBlob = pv; 
    m_dwSize = sz; 
    m_pfnFree = pFn;
    AddRef(); 
    return TRUE; 
}


VOID 
RefBlob::AddRef(
    VOID
    ) 
/*++
    Description:

        Add a reference to this object

    Arguments:
        None

    Returns:
        Nothing

--*/
{ 
    InterlockedIncrement( &m_lRef ); 
}


VOID 
RefBlob::Release(
    VOID
    )
/*++
    Description:

        Remove a reference to this object
        When the reference count drops to zero
        the object is destroyed, blob memory freed

    Arguments:
        None

    Returns:
        Nothing

--*/
{
    if ( !InterlockedDecrement( &m_lRef ) )
    {
        if ( m_pfnFree )
        {
            (m_pfnFree)( m_pvBlob );
        }
        else
        {
            LocalFree( m_pvBlob );
        }
        delete this;
    }
}


LPVOID 
RefBlob::QueryPtr(
    ) 
/*++
    Description:

        Returns a ptr to blob

    Arguments:
        None

    Returns:
        ptr to blob

--*/
{ 
    return m_pvBlob; 
}


DWORD
RefBlob::QuerySize(
    ) 
/*++
    Description:

        Returns a blob size

    Arguments:
        None

    Returns:
        size of blob

--*/
{ 
    return m_dwSize; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nsepm\map.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    map.hxx

Abstract:

    Name Space Extension Provider ( NSEP ) for mapping

Author:

    Philippe Choquier (phillich)    25-Nov-1996

--*/

#define dllexp __declspec( dllexport )

//
//  System include files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>
#include <lm.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#include <iis64.h>
#include <dbgutil.h>
#include <buffer.hxx>
#include <string.hxx>
#include <refb.hxx>

//
//  Project include files.
//

#define SECURITY_WIN32
#include <sspi.h>           // Security Support Provider APIs
#include <schnlsp.h>

#include <xbf.hxx>
#include <iismap.hxx>
#include <iiscmr.hxx>

#include <ole2.h>
#include <imd.h>
#include <mb.hxx>
#include <iiscnfgp.h>
#include <nsepname.hxx>
#include "map.hxx"


//
// Private prototypes
//

#define DWORDALIGNCOUNT(a)  (((a)+3)&0xfffffffc)

CNseInstance*
LocateObject(
    LPSTR*          ppszPath,
    BOOL            fIncludeLastSegment,
    LPDWORD         pdwIndex = NULL,
    CNseMountPoint**ppMP = NULL
    );

VOID WINAPI FreeIisAcctMapper(
    LPVOID  pvMap
    )
{
    delete (CIisAcctMapper*)pvMap;
}

VOID WINAPI FreeIisRuleMapper(
    LPVOID  pvMap
    )
{
    delete (CIisRuleMapper*)pvMap;
}

//
// Globals
//

CRITICAL_SECTION    CNseMountPoint::m_csList;
LIST_ENTRY          CNseMountPoint::m_ListHead;
BOOL                g_fPathOpened = FALSE;
DWORD               g_dwCurrentThreadId = NULL;
PFN_MAPPER_TOUCHED  g_pfnCert11Touched = NULL;
BOOL                g_fCert11Touched;

//
// cert 1:1

CNseFieldMapperId g_f1 = CNseFieldMapperId(NULL, MD_MAPCERT, FALSE, NULL, 0, IISMDB_INDEX_CERT11_CERT, BINARY_METADATA);
CNseFieldMapperId g_f2 = CNseFieldMapperId(NULL, MD_MAPNTACCT, FALSE, NULL, 0, IISMDB_INDEX_CERT11_NT_ACCT, STRING_METADATA);
CNseFieldMapperId g_f3 = CNseFieldMapperId(NULL, MD_MAPNAME, FALSE, NULL, 0, IISMDB_INDEX_CERT11_NAME, STRING_METADATA);
CNseFieldMapperId g_f4 = CNseFieldMapperId(NULL, MD_MAPENABLED, FALSE, NULL, 0, IISMDB_INDEX_CERT11_ENABLED, STRING_METADATA);
CNseFieldMapperId g_f4b = CNseFieldMapperId(NULL, MD_MAPNTPWD, FALSE, NULL, 0, IISMDB_INDEX_CERT11_NT_PWD, STRING_METADATA);

CNseFieldMapperId* g_amiCert11[] =
{
        &g_f1,
        &g_f2,
        &g_f3,
        &g_f4,
        &g_f4b,
} ;

CNseCert11Mapping g_c11Mappings = CNseCert11Mapping("%u", NULL, TRUE, (CNseObj**)g_amiCert11, sizeof(g_amiCert11)/sizeof(CNseFieldMapperId*), NULL);
CNseCert11Mapping* g_ac11Mappings[] = {
    &g_c11Mappings,
} ;

CNseObj g_c11Params = CNseObj("Parameters", NULL, FALSE, NULL, 0 );
CNseObj g_c11Maps = CNseObj("Mappings", NULL, FALSE, (CNseObj**)g_ac11Mappings, 1 );
CNoCppObj g_c11CppObj = CNoCppObj(NULL, MD_CPP_CERT11, FALSE, NULL, 0 );
CAccessByAccount g_c11AccessAccount = CAccessByAccount(NULL, MD_NSEPM_ACCESS_ACCOUNT, FALSE, NULL, 0 );
CAccessByCert g_c11AccessCert = CAccessByCert(NULL, MD_NSEPM_ACCESS_CERT, FALSE, NULL, 0 );
CAccessByName g_c11AccessName = CAccessByName(NULL, MD_NSEPM_ACCESS_NAME, FALSE, NULL, 0 );
CSerialAllObj g_c11SerialAllObj = CSerialAllObj( NULL, MD_SERIAL_ALL_CERT11, FALSE, NULL, 0 );

// container for iterated list of mappings

CNseObj* g_c11Mapper_Children[]= {
    &g_c11Params,
    &g_c11Maps,
    &g_c11CppObj,
    &g_c11SerialAllObj,
    &g_c11AccessAccount,
    &g_c11AccessCert,
    &g_c11AccessName,
} ;

CNseCert11Mapper g_c11Mapper= CNseCert11Mapper(NSEPM_CERT11_OBJ, NULL, FALSE, g_c11Mapper_Children, sizeof(g_c11Mapper_Children)/sizeof(CNseObj*), MD_SERIAL_CERT11 );

//
// Digest

CNseFieldMapperId g_f5 = CNseFieldMapperId(NULL, MD_MAPREALM, FALSE, NULL, 0, IISMMDB_INDEX_IT_REALM, STRING_METADATA);
CNseFieldMapperId g_f6 = CNseFieldMapperId(NULL, MD_ITACCT, FALSE, NULL, 0, IISMMDB_INDEX_IT_ACCT, STRING_METADATA);
CNseFieldMapperId g_f7 = CNseFieldMapperId(NULL, MD_MAPPWD, FALSE, NULL, 0, IISMMDB_INDEX_IT_MD5PWD, STRING_METADATA);
CNseFieldMapperId g_f8 = CNseFieldMapperId(NULL, MD_MAPNTACCT, FALSE, NULL, 0, IISMMDB_INDEX_NT_ACCT, STRING_METADATA);
CNseFieldMapperId g_f8b = CNseFieldMapperId(NULL, MD_MAPNTPWD, FALSE, NULL, 0, IISMMDB_INDEX_NT_PWD, STRING_METADATA);

CNseFieldMapperId* g_amiDigest[] =
{
        &g_f5,
        &g_f6,
        &g_f7,
        &g_f8,
        &g_f8b,
} ;

CNseDigestMapping g_digestMappings = CNseDigestMapping("%u", NULL, TRUE, (CNseObj**)g_amiDigest, sizeof(g_amiDigest)/sizeof(CNseFieldMapperId*), NULL);
CNseDigestMapping* g_adigestMappings[] = {
    &g_digestMappings,
} ;

CNseObj g_digestParams = CNseObj("Parameters", NULL, FALSE, NULL, 0 );
CNseObj g_digestMaps = CNseObj("Mappings", NULL, FALSE, (CNseObj**)g_adigestMappings, 1 );
CNoCppObj g_digestCppObj = CNoCppObj(NULL, MD_CPP_DIGEST, FALSE, NULL, 0 );
CSerialAllObj g_digestSerialAllObj = CSerialAllObj( NULL, MD_SERIAL_ALL_DIGEST, FALSE, NULL, 0 );

// container for iterated list of mappings

CNseObj* g_digestMapper_Children[]= {
    &g_digestParams,
    &g_digestMaps,
    &g_digestCppObj,
    &g_digestSerialAllObj,
} ;

CNseDigestMapper g_digestMapper= CNseDigestMapper(NSEPM_DIGEST_OBJ, NULL, FALSE, g_digestMapper_Children, sizeof(g_digestMapper_Children)/sizeof(CNseObj*), MD_SERIAL_DIGEST );

//
// Ita

CNseFieldMapperId g_f9= CNseFieldMapperId(NULL, MD_ITACCT, FALSE, NULL, 0, IISIMDB_INDEX_IT_ACCT, STRING_METADATA);
CNseFieldMapperId g_f10= CNseFieldMapperId(NULL, MD_MAPPWD, FALSE, NULL, 0, IISIMDB_INDEX_IT_PWD, STRING_METADATA);
CNseFieldMapperId g_f11 = CNseFieldMapperId(NULL, MD_MAPNTACCT, FALSE, NULL, 0, IISIMDB_INDEX_NT_ACCT, STRING_METADATA);
CNseFieldMapperId g_f11b = CNseFieldMapperId(NULL, MD_MAPNTPWD, FALSE, NULL, 0, IISIMDB_INDEX_NT_PWD, STRING_METADATA);

CNseFieldMapperId* g_amiIta[] =
{
        &g_f9,
        &g_f10,
        &g_f11,
        &g_f11b,
} ;

CNseItaMapping g_itaMappings = CNseItaMapping("%u", NULL, TRUE, (CNseObj**)g_amiIta, sizeof(g_amiIta)/sizeof(CNseFieldMapperId*), NULL);
CNseItaMapping* g_aitaMappings[] = {
    &g_itaMappings,
} ;

CNseObj g_itaParams = CNseObj("Parameters", NULL, FALSE, NULL, 0 );
CNseObj g_itaMaps = CNseObj("Mappings", NULL, FALSE, (CNseObj**)g_aitaMappings, 1 );
CNoCppObj g_itaCppObj = CNoCppObj(NULL, MD_CPP_ITA, FALSE, NULL, 0 );

// container for iterated list of mappings

CNseObj* g_itaMapper_Children[]= {
    &g_itaParams,
    &g_itaMaps,
    &g_itaCppObj,
} ;

CNseItaMapper g_itaMapper= CNseItaMapper(NSEPM_BASIC_OBJ, NULL, FALSE, g_itaMapper_Children, sizeof(g_itaMapper_Children)/sizeof(CNseObj*), MD_SERIAL_ITA );

//
// Cert wildcard

CNoCwSerObj g_cwSerObj = CNoCwSerObj(NULL, MD_SERIAL_CERTW, FALSE, NULL, 0 );
CNoCppObj g_cwCppObj = CNoCppObj(NULL, MD_CPP_CERTW, FALSE, NULL, 0 );

// container for iterated list of mappings

CNseObj* g_cwMapper_Children[]= {
    &g_cwSerObj,
    &g_cwCppObj,
} ;

CNseCwMapper g_cwMapper= CNseCwMapper(NSEPM_CERTW_OBJ, NULL, FALSE, g_cwMapper_Children, sizeof(g_cwMapper_Children)/sizeof(CNseObj*), MD_SERIAL_CERTW );

//
// Issuers

CNoIsSerObj g_isSerObj = CNoIsSerObj(NULL, MD_SERIAL_ISSUERS, FALSE, NULL, 0 );

// container for iterated list of mappings

CNseObj* g_isChildren[]= {
    &g_isSerObj,
} ;

CNseIssuers g_Issuers= CNseIssuers(NSEPM_ISSUER_OBJ, NULL, FALSE, g_isChildren, sizeof(g_isChildren)/sizeof(CNseObj*), MD_SERIAL_ISSUERS );

//
// list of mapper types

CNseObj* g_cMappers[]= {
    &g_c11Mapper,
    &g_digestMapper,
    &g_itaMapper,
    &g_cwMapper,
    &g_Issuers,
} ;

//
// top object, must load sub-objects from metabase

CNoList g_NoList = CNoList("<>", NULL, FALSE, g_cMappers, sizeof(g_cMappers)/sizeof(CNseObj*)) ;

//
// Member Functions
//

BOOL
CNoList::Load(
    CNseInstance*   pI,
    LPSTR           pszPath
    )
/*++

Routine Description:

    Load a subtree of the current instance

Arguments:

    pI - current instance
    pszPath - path in metabase where current instance object is stored

Returns:

    TRUE on success, FALSE on failure

--*/
{
    UINT            i;
    CNseInstance*   pNI;

    pI->m_pTemplateObject = this;

    for ( i = 0 ; i < m_cnoChildren ; ++i )
    {
        if ( pNI = new CNseInstance( m_pnoChildren[i], pI ) )
        {
            if ( pNI->m_pTemplateObject->Load( pNI, pszPath ) )
            {
                if ( !pI->AddChild( pNI ) )
                {
                    return FALSE;
                }
            }
            else
            {
                delete pNI;
            }
        }
        else
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
CNseObj::Release(
    CNseInstance* pI,
    DWORD
    )
/*++

Routine Description:

    Release a subtree of the current instance

Arguments:

    pI - current instance
    DWORD - ignored

Returns:

    TRUE on success, FALSE on failure

--*/
{
    UINT    i;

    for ( i = 0 ;i < pI->GetNbChildren() ; ++i )
    {
        // continue processing even if error
        pI->GetChild(i)->m_pTemplateObject->Release( pI->GetChild(i), 0 );
        delete pI->GetChild(i);
    }

    return TRUE;
}


BOOL
CNseFldMap::Release(
    CNseInstance* pI,
    DWORD dwIndex
    )
/*++

Routine Description:

    Release memory associated with current instance RefBlob object

Arguments:

    pI - current instance
    DWORD - ignored

Returns:

    TRUE on success, FALSE on failure

--*/
{
    CNseObj::Release( pI, dwIndex );

    if ( pI->m_pvParam )
    {
        ((RefBlob*)pI->m_pvParam)->Release();
        pI->m_pvParam = NULL;
    }

    return TRUE;
}


BOOL
CNseFldMap::Delete(
    LPSTR           pszPath,
    CNseInstance*   pI,
    DWORD           dwIndex
    )
/*++

Routine Description:

    Delete a mapper object

Arguments:

    pszPath - path where mapper exists in tree
    pI - current instance
    dwIndex - mapper index, ignored : mapper object is not iterated

Returns:

    TRUE on success, FALSE on failure

--*/
{
    BOOL    fSt = FALSE;
    BOOL    fStUpd = FALSE;

    if ( pI->m_pvParam )
    {
        CIisAcctMapper* pM = (CIisAcctMapper*)((RefBlob*)pI->m_pvParam)->QueryPtr();
        if ( pM )
        {
            pM->Delete();
        }
    }

    //
    // update metabase
    //

    MB                  mb( IMDCOM_PTR );

    if ( mb.Open( pszPath, METADATA_PERMISSION_WRITE ) )
    {
        mb.DeleteData( "", GetDwParam(), IIS_MD_UT_SERVER, BINARY_METADATA );
        mb.Save();
        mb.Close();
        fStUpd = TRUE;
    }

    //
    // delete object even if metabase update not successful
    //

    if ( pI->m_pniParent->m_pTemplateObject->RemoveFromChildren( pI->m_pniParent, pI ) )
    {
        if ( Release( pI, dwIndex ) )
        {
            fSt = fStUpd;
        }
    }

    return fSt;
}


DWORD
CNseFldMap::GetCount(
    CNseInstance*   pI,
    DWORD           dwIndex
    )
/*++

Routine Description:

    Retrive count of mappings in mapper object

Arguments:

    pI - current instance
    dwIndex - mapper index, ignored : mapper object is not iterated

Returns:

    TRUE on success, FALSE on failure

--*/
{
    CIisAcctMapper *pM = (CIisAcctMapper*)((RefBlob*)pI->m_pvParam)->QueryPtr();

    return pM ? pM->GetNbMapping( TRUE ) : 0;
}


DWORD
CNseAllMappings::GetCount(
    CNseInstance*   pI,
    DWORD           dwIndex
    )
/*++

Routine Description:

    Retrive count of mappings in mapper object from a mapping instance

Arguments:

    pI - current instance
    dwIndex - mapper index, ignored : mapper object is not iterated

Returns:

    TRUE on success, FALSE on failure

--*/
{
    CIisAcctMapper *pM = (CIisAcctMapper*)((RefBlob*)pI->m_pniParent->m_pniParent->m_pvParam)->QueryPtr();

    return pM ? pM->GetNbMapping( TRUE ) : 0;
}


BOOL
CNseFldMap::AddMapper(
    CNseInstance* pFather,
    CIisAcctMapper* pM
    )
/*++

Routine Description:

    Add a mapper object in father instance.
    Will create mapper children hierarchy

Arguments:

    pFather - instance where to insert new mapper instance as child
    pM - mapper object

Returns:

    TRUE on success, FALSE on failure

--*/
{
    CNseInstance*   pI = NULL;
    RefBlob*        pB = NULL;

	// BugFix: 57660, 57661, 57662 Whistler
	//         Prefix bug accessing NULL pointer
	//         If the caller has passed a NULL pointer
	//         do not do the call, just return an error.
	//         EBK 5/5/2000		
	if (pM)
	{
		if ( pM->Create() &&
			 (pI = new CNseInstance) &&
			 (pB = new RefBlob) )
		{
			pB->Init( pM, sizeof(CIisAcctMapper*), FreeIisAcctMapper );
			pI->m_pvParam = pB;
			pI->m_pniParent = pFather;
			pI->m_pTemplateObject = this;
			pI->m_fModified = TRUE;

			if ( pFather->AddChild( pI ) )
			{
				return pI->CreateChildrenInstances( TRUE );
			}
		}

		if ( pI )
		{
			delete pI;
		}

		if ( pB )
		{
			delete pB;
		}
	}

    return FALSE;
}


BOOL
CNseFldMap::EndTransac(
    LPSTR           pszPath,
    CNseInstance*   pI,
    BOOL            fApplyChanges
    )
/*++

Routine Description:

    Metabase close on mapper : ask mapper object to synchronize std and alternate list

Arguments:

    pszPath - path where mapper exists in tree
    pI - current instance
    fApplyChanges - TRUE to commit changes

Returns:

    TRUE on success, FALSE on failure

--*/
{
    BOOL                fSt = TRUE;
    CIisAcctMapper *    pM;

    if ( pI->m_pvParam )
    {
        pM = (CIisAcctMapper*) ((RefBlob*)pI->m_pvParam)->QueryPtr();

        if ( pI->m_fModified )
        {
            pM->Lock();

            if ( fApplyChanges )
            {
                fSt = pM->FlushAlternate( TRUE );
            }
            else
            {
                fSt = pM->FlushAlternate( FALSE );
                pI->m_fModified = FALSE;
            }

            pM->Unlock();
        }
    }

    return fSt;
}


BOOL
CNseFldMap::SaveMapper(
    LPSTR           pszPath,
    CNseInstance*   pI,
    DWORD           dwId,
    LPBOOL          pfModified
    )
/*++

Routine Description:

    Save a mapper object on persistance storage
    First save mappings in file then store reference to file in metabase

Arguments:

    pszPath - path where mapper exists in tree
    pI - current instance
    dwId - ignored, mapper objects are not iterated
    pfModified - updated with TRUE if metabase modified

Returns:

    TRUE on success, FALSE on failure

--*/
{
    BOOL                fSt = TRUE;
    CIisAcctMapper *    pM;
    BOOL                f;
    HANDLE              hnd;

    if ( pI->m_pvParam )
    {
        pM = (CIisAcctMapper*) ((RefBlob*)pI->m_pvParam)->QueryPtr();

        pM->Lock();

        if ( pI->m_fModified )
        {
            CStoreXBF xbf;
            fSt = FALSE;
            MB                  mb( IMDCOM_PTR );
            if ( mb.Open( pszPath, METADATA_PERMISSION_WRITE ) )
            {
                if ( dwId == MD_SERIAL_CERT11 )
                {
                    g_fCert11Touched = TRUE;
                }

                // must revert to process identity before saving mapping, as we are
                // using crypto storage

                if ( OpenThreadToken( GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &hnd ) )
                {
                    RevertToSelf();
                }
                else
                {
                    hnd = NULL;
                }

                f = pM->FlushAlternate( TRUE ) && pM->Save() && pM->Serialize( &xbf );

                if ( hnd )
                {
                    HANDLE hThread = GetCurrentThread();
                    SetThreadToken( &hThread, hnd );
                    CloseHandle( hnd );
                }

                if ( f )
                {
                    // save to metabase

                    if ( mb.SetData( "", dwId, IIS_MD_UT_SERVER, BINARY_METADATA, xbf.GetBuff(), xbf.GetUsed(), 0 ) )
                    {
                        fSt = TRUE;
                        *pfModified = TRUE;
                    }
                }

                mb.Close();

                pI->m_fModified = FALSE;
            }
        }
        else
        {
            pM->FlushAlternate( FALSE );
        }

        pM->Unlock();
    }

    return fSt;
}


BOOL
CNseFldMap::LoadAndUnserialize(
    CNseInstance* pI,
    CIisAcctMapper* pM,
    LPSTR pszPath,
    DWORD dwId
    )
/*++

Routine Description:

    Instantiate a mapper object from persistent storage
    First load reference to file in metabase, then load mappings from file

Arguments:

    pI - current instance
    pM - ptr to mapper object
    pszPath - path where mapper exists in tree
    dwId - ignored, mapper objects are not iterated

Returns:

    TRUE on success, FALSE on failure

--*/
{
    MB                  mb( (IMDCOM*) IMDCOM_PTR );
    BYTE                abUnser[1024];
    LPBYTE              pUnser;
    DWORD               cUnser;
    BOOL                fSt = FALSE;
    RefBlob*            pB = NULL;

    if ( !pM )
    {
        return FALSE;
    }

    // load from metabase

    if ( mb.Open( pszPath) )
    {
        cUnser = sizeof(abUnser);
        if ( mb.GetData( "", dwId, IIS_MD_UT_SERVER, BINARY_METADATA, abUnser, &cUnser, 0) )
        {
            pUnser = abUnser;
            if ( pM->Unserialize( &pUnser, &cUnser ) && pM->Load() )
            {
                if ( pB = new RefBlob() )
                {
                    pB->Init( pM, sizeof(CIisAcctMapper*), FreeIisAcctMapper );
                    pI->m_pvParam = (LPVOID)pB;
                    // create sub-instances in pI : from template
                    fSt =  pI->CreateChildrenInstances( TRUE );
                }
            }
        }
        mb.Close();
    }

    return fSt;
}


BOOL
CNseCwMapper::Release(
        CNseInstance* pI,
        DWORD dwIndex
        )
/*++

Routine Description:

    Release memory used by a certificate wildcard mapper
    not including ptr to current instance

Arguments:

    pI - current instance
    dwIndex - ignored, mapper objects are not iterated

Returns:

    TRUE on success, FALSE on failure

--*/
{
    CNseObj::Release( pI, dwIndex );

    if ( pI->m_pvParam )
    {
        ((RefBlob*)pI->m_pvParam)->Release();
        pI->m_pvParam = NULL;
    }

    return TRUE;
}


BOOL
CNseCwMapper::Add(
    CNseInstance*   pFather,
    DWORD           dwId
    )
/*++

Routine Description:

    Add a certificate wildcard mapper object in father instance.
    Will create mapper children hierarchy

Arguments:

    pFather - instance where to insert new mapper instance as child
    dwId - ignored, mapper objects are not iterated

Returns:

    TRUE on success, FALSE on failure

--*/
{
    CNseInstance*       pI = NULL;
    RefBlob*            pB = NULL;
    CIisRuleMapper *    pM = NULL;
    BOOL                fSt = FALSE;

    if ( (pM = new CIisRuleMapper) &&
         (pI = new CNseInstance) &&
         (pB = new RefBlob) )
    {
        pB->Init( pM, sizeof(CIisRuleMapper*), FreeIisRuleMapper );
        pI->m_pvParam = pB;
        pI->m_pniParent = pFather;
        pI->m_pTemplateObject = this;
        pI->m_fModified = TRUE;

        if ( pI->CreateChildrenInstances( TRUE ) )
        {
            fSt = pFather->AddChild( pI );
        }
    }

    if ( !fSt )
    {
        if ( pI )
        {
            delete pI;
        }

        if ( pB )
        {
            delete pB;
        }

        if ( pM )
        {
            delete pM;
        }
    }

    return fSt;
}


BOOL
CNseCwMapper::Save(
    LPSTR           pszPath,
    CNseInstance*   pI,
    LPBOOL          pfModified
    )
/*++

Routine Description:

    Save a certificate wildcard mapper object on persistance storage

Arguments:

    pszPath - path where mapper exists in tree
    pI - current instance
    pfModified - updated with TRUE if metabase modified

Returns:

    TRUE on success, FALSE on failure

--*/
{
    BOOL                fSt = TRUE;
    CIisRuleMapper *    pM;

    if ( pI->m_pvParam )
    {
        pM = (CIisRuleMapper*) ((RefBlob*)pI->m_pvParam)->QueryPtr();

        pM->LockRules();

        if ( pI->m_fModified )
        {
            CStoreXBF xbf;
            fSt = FALSE;
            if ( pM->Serialize( &xbf ) )
            {
                MB                  mb( IMDCOM_PTR );
                // save to metabase

                if ( mb.Open( pszPath, METADATA_PERMISSION_WRITE ) )
                {
                    if ( mb.SetData( "", GetDwParam(), IIS_MD_UT_SERVER, BINARY_METADATA, xbf.GetBuff(), xbf.GetUsed(), METADATA_SECURE ) )
                    {
                        fSt = TRUE;
                        *pfModified = TRUE;
                    }
                    mb.Close();
                }

            }
            pI->m_fModified = FALSE;
        }

        pM->UnlockRules();
    }

    return fSt;
}


BOOL
CNseCwMapper::Load(
    CNseInstance*   pI,
    LPSTR           pszPath
    )
/*++

Routine Description:

    Load a certificate wildcard mapper object from persistance storage

Arguments:

    pI - current instance
    pszPath - path where mapper exists in tree

Returns:

    TRUE on success, FALSE on failure

--*/
{
    MB                  mb( (IMDCOM*) IMDCOM_PTR );
    BYTE                abUnser[4096];
    LPBYTE              pUnser;
    LPBYTE              pU;
    DWORD               cUnser;
    BOOL                fSt = FALSE;
    RefBlob*            pB = NULL;
    CIisRuleMapper *    pM = NULL;

    pM = new CIisRuleMapper;

    if ( !pM )
    {
        return FALSE;
    }

    pUnser = abUnser;
    cUnser = sizeof(abUnser);

    // load from metabase

    if ( mb.Open( pszPath) )
    {
ag:
        if ( mb.GetData( "", GetDwParam(), IIS_MD_UT_SERVER, BINARY_METADATA, pUnser, &cUnser, METADATA_SECURE) )
        {
            pU = pUnser;
            if ( pM->Unserialize( &pU, &cUnser ) )
            {
                if ( pB = new RefBlob() )
                {
                    pB->Init( pM, sizeof(CIisRuleMapper*), FreeIisRuleMapper );
                    pI->m_pvParam = (LPVOID)pB;
                    // create sub-instances in pI : from template
                    fSt =  pI->CreateChildrenInstances( TRUE );
                }
            }
        }
        else if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            if ( pUnser = (LPBYTE)LocalAlloc( LMEM_FIXED, cUnser ) )
            {
                goto ag;
            }
        }
        mb.Close();
    }

    if ( !fSt )
    {
        delete pM;
    }

    if ( pUnser != abUnser )
    {
        LocalFree( pUnser );
    }

    return fSt;
}


BOOL
CNseIssuers::Load(
    CNseInstance* pI,
    LPSTR pszPath
    )
/*++

Routine Description:

    Initialize instance for Issuer list

Arguments:

    pI - current instance
    pszPath - path where issuer exists in tree

Returns:

    TRUE on success, FALSE on failure

--*/
{
    return pI->CreateChildrenInstances( TRUE );
}


BOOL
CNseObj::RemoveFromChildren(
        CNseInstance*   pI,
        CNseInstance*   pChild
    )
/*++

Routine Description:

    Remove instance from children list

Arguments:

    pI - current instance
    pChild - instance to delete from pI

Returns:

    TRUE on success, FALSE on failure

--*/
{
    UINT    i;

    for ( i = 0 ; i < pI->GetNbChildren() ; ++i )
    {
        if ( pI->GetChild(i) == pChild )
        {
            return pI->DeleteChild( i );
        }
    }

    return FALSE;
}


BOOL
CNseCwMapper::Delete(
    LPSTR           pszPath,
    CNseInstance*   pI,
    DWORD           dwIndex
    )
/*++

Routine Description:

    Delete a cert wildcard mapper

Arguments:

    pszPath - path where mapper exists in tree
    pI - current instance
    dwIndex - ignored, mapper object is not iterated

Returns:

    TRUE on success, FALSE on failure

--*/
{
    BOOL fSt = FALSE;

    //
    // update metabase
    //

    MB                  mb( IMDCOM_PTR );

    if ( mb.Open( pszPath, METADATA_PERMISSION_WRITE ) )
    {
        fSt = mb.DeleteData( "", GetDwParam(), IIS_MD_UT_SERVER, BINARY_METADATA ) &&
              mb.Save();
        mb.Close();
    }

    //
    // Update instance hierarchy
    //

    if ( pI->m_pniParent->m_pTemplateObject->RemoveFromChildren( pI->m_pniParent, pI ) )
    {
        if ( !Release( pI, dwIndex ) )
        {
            fSt = FALSE;
        }
    }
    else
    {
        fSt = FALSE;
    }

    return fSt;
}


BOOL
CNseAllMappings::GetAll(
    CNseInstance*   pWalk,
    DWORD           dwIndex,
    LPDWORD         pdwMDNumDataEntries,
    DWORD           dwMDBufferSize,
    LPBYTE          pbBuffer,
    LPDWORD         pdwMDRequiredBufferSize
    )
/*++

Routine Description:

    Handle GetAll request for cert11, digest & ita

Arguments:

    pWalk - mapping entry instance
    dwIndex - mapping entry index ( 0 based )
    pdwMDNumDataEntries - updated with count of properties
    pbBuffer - updated with properties if size sufficient
    pdwMDRequiredBufferSize - pbBuffer size on input, updated with minimum size to handle
        all properties on output

Returns:

    TRUE on success, FALSE on failure
    returns FALSE, error ERROR_INSUFFICIENT_BUFFER if pbBuffer not big enough

--*/
{
    UINT                    i;
    DWORD                   cId = 0;
    DWORD                   cReq = 0;
    DWORD                   cNeed;
    DWORD                   cRem;
    BOOL                    fSt = TRUE;
    METADATA_RECORD         MD;
    PMETADATA_GETALL_RECORD pGA;
    LPBYTE                  pB;

    //
    // Count # properties, compute needed size
    //

    for ( i = 0 ; i < pWalk->GetNbChildren() ; ++i )
    {
        if ( pWalk->GetChild(i)->m_pTemplateObject->GetId() )
        {
            ++cId;
            cReq += sizeof(METADATA_GETALL_RECORD);
            cNeed = 0;
            MD.dwMDDataLen = 0;
            MD.pbMDData = NULL;
            MD.dwMDIdentifier = pWalk->GetChild(i)->m_pTemplateObject->GetId();
            if ( GetByIndex( pWalk, dwIndex, &MD, i, &cNeed ) ||
                 GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                cReq += cNeed;
            }
            else
            {
                fSt = FALSE;
                break;
            }
        }
    }

    *pdwMDNumDataEntries = cId;
    *pdwMDRequiredBufferSize = cReq;

    if ( fSt && cId )
    {
        if ( dwMDBufferSize >= cReq )
        {
            pGA = (PMETADATA_GETALL_RECORD)pbBuffer;
            pB = pbBuffer + sizeof(METADATA_GETALL_RECORD) * cId;
            cRem = cReq - sizeof(METADATA_GETALL_RECORD) * cId;

            for ( i = 0 ; i < pWalk->GetNbChildren() ; ++i, ++pGA )
            {
                if ( pWalk->GetChild(i)->m_pTemplateObject->GetId() )
                {
                    memset( &MD, '\0', sizeof(METADATA_RECORD) );
                    MD.dwMDDataLen = cRem;
                    MD.pbMDData = pbBuffer ? pB : NULL;
                    MD.dwMDIdentifier = pWalk->GetChild(i)->m_pTemplateObject->GetId();
                    if ( MD.dwMDIdentifier == MD_MAPNTPWD )
                    {
                        MD.dwMDAttributes |= METADATA_SECURE;
                    }

                    if (!GetByIndex( pWalk, dwIndex, &MD, i, &cNeed ) )
                    {
                        fSt = FALSE;
                        break;
                    }
                    pGA->dwMDIdentifier = MD.dwMDIdentifier;
                    pGA->dwMDAttributes = MD.dwMDAttributes;
                    pGA->dwMDUserType = MD.dwMDUserType;
                    pGA->dwMDDataType = MD.dwMDDataType;
                    pGA->dwMDDataLen = MD.dwMDDataLen;
                    pGA->dwMDDataOffset = DIFF(pB - pbBuffer);
                    pGA->dwMDDataTag = 0;

                    pB += pGA->dwMDDataLen;
                    cRem -= pGA->dwMDDataLen;
                }
            }
        }
        else
        {
            SetLastError( ERROR_INSUFFICIENT_BUFFER );
            fSt = FALSE;
        }
    }

    return fSt;
}


BOOL
CNseCert11Mapper::Add(
    CNseInstance*   pFather,
    DWORD
    )
/*++

Routine Description:

    Add a cert 1:1 mapper to instance hierarchy

Arguments:

    pFather - instance where to add new cert 1:1 instance

Returns:

    TRUE on success, FALSE on failure

--*/
{
    return AddMapper( pFather, (CIisAcctMapper*)new CIisCert11Mapper() );
}


BOOL
CNseCert11Mapper::Load(
    CNseInstance*   pI,
    LPSTR           pszPath
    )
/*++

Routine Description:

    Load a certificate 1:1 mapper object from persistance storage

Arguments:

    pI - current instance
    pszPath - path where mapper exists in tree

Returns:

    TRUE on success, FALSE on failure

--*/
{
    CIisAcctMapper* pM = new CIisCert11Mapper;

    if ( pM )
    {
        if ( LoadAndUnserialize( pI, pM, pszPath, MD_SERIAL_CERT11 ) )
        {
            return TRUE;
        }
        delete pM;
    }

    return FALSE;
}


BOOL
CNseDigestMapper::Add(
    CNseInstance* pFather,
    DWORD
    )
/*++

Routine Description:

    Add a digest auth mapper to instance hierarchy

Arguments:

    pFather - instance where to add new digest auth mapper instance

Returns:

    TRUE on success, FALSE on failure

--*/
{
    return AddMapper( pFather, (CIisAcctMapper*)new CIisMd5Mapper() );
}


BOOL
CNseDigestMapper::Load(
    CNseInstance* pI,
    LPSTR pszPath
    )
/*++

Routine Description:

    Load a digest auth mapper object from persistance storage

Arguments:

    pI - current instance
    pszPath - path where mapper exists in tree

Returns:

    TRUE on success, FALSE on failure

--*/
{
    CIisAcctMapper* pM = new CIisMd5Mapper;

    if ( pM )
    {
            if ( LoadAndUnserialize( pI, pM, pszPath, MD_SERIAL_DIGEST ) )
        {
            return TRUE;
        }
        delete pM;
    }

    return FALSE;
}


BOOL
CNseItaMapper::Add(
    CNseInstance*   pFather,
    DWORD
    )
/*++

Routine Description:

    Add an internet acct mapper to instance hierarchy

Arguments:

    pFather - instance where to add new internet acct mapper instance

Returns:

    TRUE on success, FALSE on failure

--*/
{
    return AddMapper( pFather, (CIisAcctMapper*)new CIisItaMapper() );
}


BOOL
CNseItaMapper::Load(
    CNseInstance*   pI,
    LPSTR           pszPath
    )
/*++

Routine Description:

    Load an internet acct mapper object from persistance storage

Arguments:

    pI - current instance
    pszPath - path where mapper exists in tree

Returns:

    TRUE on success, FALSE on failure

--*/
{
    CIisAcctMapper* pM = new CIisItaMapper;

    if ( pM )
    {
            if ( LoadAndUnserialize( pI, pM, pszPath, MD_SERIAL_ITA ) )
        {
            return TRUE;
        }
        delete pM;
    }

    return FALSE;
}


BOOL
CNseFldMap::Save(
    LPSTR           pszPath,
    CNseInstance*   pI,
    LPBOOL          pfModified
    )
/*++

Routine Description:

    Save a mapper ( cert11, digest, ita ) instance

Arguments:

    pszPath - path where mapper exists in tree
    pI - current instance
    pfModified - updated with TRUE if metabase storage modified

Returns:

    TRUE on success, FALSE on failure

--*/
{
    return SaveMapper( pszPath, pI, GetDwParam(), pfModified );
}


CNseInstance*
CNseObj::Locate(
    CNseInstance*       pI,
    PMETADATA_RECORD    pMD
    )
/*++

Routine Description:

    Locate a metadata record based on its ID in current instance

Arguments:

    pI - current instance
    pMD - metadata record, only ID is used

Returns:

    ptr to child instance if success, otherwise NULL

--*/
{
    UINT i;

    for ( i = 0 ; i < pI->GetNbChildren() ; ++i )
    {
        if ( pI->GetChild(i)->m_pTemplateObject->GetId() == pMD->dwMDIdentifier )
        {
            return pI->GetChild(i);
        }
    }

    return NULL;
}


BOOL
CNseObj::Set(
    CNseInstance*       pI,
    DWORD               dwIndex,
    PMETADATA_RECORD    pMD
    )
/*++

Routine Description:

    set property in the child matching the specified property

Arguments:

    pI - current instance
    dwIndex - instance index
    pMD - metadata record, only ID is used

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CNseInstance*   pL;
    BOOL            fSt = FALSE;

    if ( pL = Locate( pI, pMD ) )
    {
        return pL->m_pTemplateObject->Set( pL, dwIndex, pMD );
    }

    return fSt;
}


BOOL
CNseObj::Get(
    CNseInstance*       pI,
    DWORD               dwIndex,
    PMETADATA_RECORD    pMD,
    LPDWORD             pdwRequiredLen
    )
/*++

Routine Description:

    get property from the child matching the specified property

Arguments:

    pI - current instance
    dwIndex - instance index
    pMD - metadata record, only ID is used
    pdwRequiredLen - updated with required length if length specified in pMD is not
        sufficient

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CNseInstance*   pL;
    BOOL            fSt = FALSE;

    if ( pL = Locate( pI, pMD ) )
    {
        return pL->m_pTemplateObject->Get( pL, dwIndex, pMD, pdwRequiredLen );
    }

    return fSt;
}


BOOL
CNseAllMappings::Set(
    CNseInstance*       pI,
    DWORD               dwIndex,
    PMETADATA_RECORD    pMD
    )
/*++

Routine Description:

    set property in the child matching the specified property

Arguments:

    pI - current instance
    dwIndex - instance index
    pMD - metadata record, only ID is used

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CNseInstance*   pL;
    BOOL            fSt = FALSE;

    if ( pL = Locate( pI, pMD ) )
    {
        CIisAcctMapper *pM = (CIisAcctMapper*)((RefBlob*)pI->m_pniParent->m_pniParent->m_pvParam)->QueryPtr();
        CIisMapping* pG;
        if ( pM )
        {
            pM->Lock();
            if ( pM->GetMapping( dwIndex, &pG, TRUE, TRUE ) )
            {
                if ( pMD->dwMDDataType == STRING_METADATA )
                {
                    fSt = pG->MappingSetField( pL->m_pTemplateObject->GetDwParam(),
                                               (LPSTR)pMD->pbMDData );
                }
                else
                {
                    fSt = pG->MappingSetField( pL->m_pTemplateObject->GetDwParam(),
                                               (LPSTR)pMD->pbMDData,
                                               pMD->dwMDDataLen,
                                               FALSE );
                }
            }
            else
            {
                SetLastError( ERROR_INVALID_NAME );
            }
            pM->Unlock();
            pI->m_pniParent->m_pniParent->m_fModified = TRUE;
        }
    }

    return fSt;
}


BOOL
CNseAllMappings::Get(
    CNseInstance*       pI,
    DWORD               dwIndex,
    PMETADATA_RECORD    pMD,
    LPDWORD             pdwReq
    )
/*++

Routine Description:

    get property from the child matching the specified property

Arguments:

    pI - current instance
    dwIndex - instance index
    pMD - metadata record, only ID is used
    pdwRequiredLen - updated with required length if length specified in pMD is not
        sufficient

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CNseInstance*   pL;
    BOOL            fSt = FALSE;

    if ( pL = Locate( pI, pMD ) )
    {
        fSt = Get( pI, dwIndex, pMD, pL, pdwReq );
    }

    return fSt;
}


BOOL
CNseAllMappings::GetByIndex(
    CNseInstance*       pI,
    DWORD               dwIndex,
    PMETADATA_RECORD    pMD,
    DWORD               dwI,
    LPDWORD             pdwReq
    )
/*++

Routine Description:

    get property from child based on child index

Arguments:

    pI - current instance
    dwIndex - instance index
    pMD - metadata record, only ID is used
    dwI - child index in child list
    pdwReq - updated with required length if length specified in pMD is not
        sufficient

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CNseInstance*   pL;
    BOOL            fSt = FALSE;

    if ( dwI < pI->GetNbChildren() )
    {
                fSt = Get( pI, dwIndex, pMD, pI->GetChild(dwI), pdwReq );
    }

    return fSt;
}


BOOL
CNseAllMappings::Get(
    CNseInstance*       pI,
    DWORD               dwIndex,
    PMETADATA_RECORD    pMD,
    CNseInstance*       pL,
    LPDWORD             pdwReq
    )
/*++

Routine Description:

    get property from specified child instance

Arguments:

    pI - current instance
    dwIndex - instance index
    pMD - metadata record, only ID is used
    pL - instance where property is defined
    pdwReq - updated with required length if length specified in pMD is not
        sufficient

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CIisAcctMapper*     pM = (CIisAcctMapper*)((RefBlob*)pI->m_pniParent->m_pniParent->m_pvParam)->QueryPtr();
    CIisMapping*        pG;
    LPSTR               pData;
    DWORD               cData;
    BOOL                fSt = FALSE;

    if ( pM )
    {
        pM->Lock();

        if ( pM->GetMapping( dwIndex, &pG, TRUE, FALSE ) &&
             pG->MappingGetField( pL->m_pTemplateObject->GetDwParam(), &pData, &cData, FALSE ) )
        {
            if ( pMD->dwMDDataLen >= cData )
            {
                if ( pMD->pbMDData )
                {
                    memcpy( pMD->pbMDData, pData, cData );
                }
                pMD->dwMDDataLen = cData;
                fSt = TRUE;
            }
            else
            {
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
            }
            pMD->dwMDDataType = pL->m_pTemplateObject->GetDwParam2();
            pMD->dwMDDataTag = NULL;
            if ( pMD->dwMDIdentifier == MD_MAPNTPWD )
            {
                pMD->dwMDAttributes |= METADATA_SECURE;
            }
            *pdwReq = cData;
        }

        pM->Unlock();
    }

        return fSt;
}


BOOL
CNseAllMappings::Add(
    CNseInstance*   pI,
    DWORD           dwIndex
    )
/*++

Routine Description:

    add a mapping entry

Arguments:

    pI - current instance
    dwIndex - ignored

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CIisAcctMapper* pM = (CIisAcctMapper*)((RefBlob*)pI->m_pniParent->m_pvParam)->QueryPtr();
    CIisMapping*    pG;
    BOOL            fSt = FALSE;

    if ( pM )
    {
        pM->Lock();

        if ( dwIndex == pM->GetNbMapping( TRUE ) ||
             dwIndex == (DWORD)-1 )
        {
            if ( pG = pM->CreateNewMapping() )
            {
                if ( !pM->Add( pG, TRUE ) )
                {
                    delete pG;
                }
                else
                {
                    pI->m_pniParent->m_dwParam = pM->GetNbMapping( TRUE );
                    fSt = TRUE;
                }
            }
        }
        else
        {
            SetLastError( ERROR_INVALID_NAME );
        }

        pM->Unlock();

        pI->m_pniParent->m_fModified = TRUE;
    }

    return fSt;
}


BOOL
CNseAllMappings::Delete(
    LPSTR           pszPath,
    CNseInstance*   pI,
    DWORD           dwIndex
    )
/*++

Routine Description:

    delete a mapping entry

Arguments:

    pszPath - path where mapper exists in tree
    pI - current instance
    dwIndex - mapping entry index ( 0 based )

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CIisAcctMapper *pM = (CIisAcctMapper*)((RefBlob*)pI->m_pniParent->m_pniParent->m_pvParam)->QueryPtr();
    BOOL            fSt = FALSE;

    if ( pM )
    {
        pM->Lock();

        fSt = pM->Delete( dwIndex, TRUE );

        pM->Unlock();

        pI->m_pniParent->m_pniParent->m_fModified = TRUE;
    }

    return fSt;
}


BOOL
CNoCppObj::Get(
    CNseInstance*       pI,
    DWORD,
    PMETADATA_RECORD    pM,
    LPDWORD             pdwRequiredLen
    )
/*++

Routine Description:

    get ptr to c++ mapper object ( as a RefBlob )
    returned data is ptr to RefBlob pointing to c++ mapper object
    RefBlob refcount is incremented

Arguments:

    pI - current instance
    pM - metadata record, ID ignored, updated with ID, data type & length
    pdwRequiredLen - ignored, length is assumed to be sufficient

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    if ( pI->m_pniParent->m_pvParam )
    {
        *(LPVOID*)pM->pbMDData = pI->m_pniParent->m_pvParam;       // ptr to RefBlob
        pM->dwMDDataLen = sizeof(pI->m_pniParent->m_pvParam);
        pM->dwMDDataType = BINARY_METADATA;
        pM->dwMDIdentifier = m_dwId;
        ((RefBlob*)pI->m_pniParent->m_pvParam)->AddRef();

        return TRUE;
    }

    return FALSE;
}


BOOL
CSerialAllObj::Get(
    CNseInstance*       pI,
    DWORD,
    PMETADATA_RECORD    pMD,
    LPDWORD             pdwRequiredLen
    )
/*++

Routine Description:

    serialize all mappings

Arguments:

    pI - current instance
    pM - metadata record, ID ignored, updated with ID, data type & length
    pdwRequiredLen - ignored, length is assumed to be sufficient

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CIisAcctMapper *pM = (CIisAcctMapper*)((RefBlob*)pI->m_pniParent->m_pvParam)->QueryPtr();
    BOOL            fSt = TRUE;

    if ( pM )
    {
        // serial format : list [(DWORD)elem, elem]

        CIisMapping*    pG;
        LPSTR           pData;
        DWORD           cData;
        UINT            cM;
        UINT            iM;
        DWORD           cF;
        UINT            iF;
        LPSTR *         pFields;
        LPDWORD         pcFields;
        DWORD           cLen = 0;
        LPBYTE          pD;
        IISMDB_Fields*  pFld;

        pM->Lock();

        pM->MappingGetFieldList( &pFld, &cF );

        cM = pM->GetNbMapping();

        pD = pMD->pbMDData;

        for ( iM = 0 ; iM < cM ; ++iM )
        {
            if ( pM->GetMapping( iM, &pG, FALSE, FALSE ) )
            {
                for ( iF = 0 ; iF < cF ; ++iF )
                {
                    if ( !pG->MappingGetField( iF, &pData, &cData, FALSE ) )
                    {
                        fSt = FALSE;
                        SetLastError( ERROR_INVALID_NAME );
                        goto ExitIterMappings;
                    }
                    cLen += sizeof(DWORD) + DWORDALIGNCOUNT(cData);
                    if ( cLen <= pMD->dwMDDataLen )
                    {
                        *(LPDWORD)pD = cData;
                        memcpy( pD + sizeof(DWORD), pData, cData );
                        pD += sizeof(DWORD) + DWORDALIGNCOUNT(cData);
                    }
                }
            }
            else
            {
                SetLastError( ERROR_INVALID_NAME );
                fSt = FALSE;
                break;
            }
        }

ExitIterMappings:

        pM->Unlock();

        if ( fSt )
        {
            if ( cLen > pMD->dwMDDataLen )
            {
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                *pdwRequiredLen = cLen;
                fSt = FALSE;
            }
            else
            {
                pMD->dwMDDataLen = cLen;
                pMD->dwMDAttributes |= METADATA_SECURE;
            }
        }
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        fSt = FALSE;
    }

    return fSt;
}


BOOL
CSerialAllObj::Set(
    CNseInstance*       pI,
    DWORD,
    PMETADATA_RECORD    pMD
    )
/*++

Routine Description:

    deserialize all mappings

Arguments:

    pI - current instance
    pM - metadata record, ID ignored

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CIisAcctMapper *pM = (CIisAcctMapper*)((RefBlob*)pI->m_pniParent->m_pvParam)->QueryPtr();
    BOOL            fSt = TRUE;

    if ( pM )
    {
        // serial format : list [(DWORD)elem, elem]

        CIisMapping*    pG;
        DWORD           cData;
        UINT            cM;
        UINT            iM;
        DWORD           cF;
        UINT            iF;
        LPSTR *         pFields;
        LPDWORD         pcFields;
        DWORD           cLen = pMD->dwMDDataLen;
        LPBYTE          pD;
        IISMDB_Fields*  pFld;

        pM->Lock();

        pM->MappingGetFieldList( &pFld, &cF );
        cM = pM->GetNbMapping();

        //
        // delete all existing mappings
        //

        for ( iM = 0 ; iM < cM ; ++iM )
        {
            pM->Delete( 0 );
        }

        pD = pMD->pbMDData;

        //
        // Iterate on buffer
        //

        while ( cLen )
        {
            if ( pG = pM->CreateNewMapping() )
            {
                //
                // get all fields for this entry from buffer
                //

                for ( iF = 0 ; iF < cF ; ++iF )
                {
                    cData = *(LPDWORD)pD;

                    if ( cLen >= sizeof(DWORD) + cData )
                    {
                        if ( !pG->MappingSetField( iF, (LPSTR)pD+sizeof(DWORD), cData, FALSE ) )
                        {
                            fSt = FALSE;
                            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                            goto ExitIterMappings;
                        }
                    }
                    else
                    {
                        fSt = FALSE;
                        SetLastError( ERROR_INVALID_PARAMETER );
                        goto ExitIterMappings;
                    }

                    cLen -= sizeof(DWORD) + DWORDALIGNCOUNT(cData);
                    pD += sizeof(DWORD) + DWORDALIGNCOUNT(cData);
                }

                if ( !pM->Add( pG, FALSE ) )
                {
                    delete pG;
                    fSt = FALSE;
                    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                    break;
                }
                else
                {
                    pI->m_pniParent->m_fModified = TRUE;
                }
            }
            else
            {
                fSt = FALSE;
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                break;
            }
        }

ExitIterMappings:

        pM->Unlock();
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        fSt = FALSE;
    }

    return fSt;
}


BOOL
CKeyedAccess::Get(
    CNseInstance*       pI,
    DWORD,
    PMETADATA_RECORD    pMD,
    LPDWORD             pdwRequiredLen
    )
/*++

Routine Description:

    get index set by previous successfull CKeyedAccess::Set

Arguments:

    pI - current instance
    pM - metadata record, ID ignored, updated with ID, data type & length
    pdwRequiredLen - ignored, length is assumed to be sufficient

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL fSt;

    if ( sizeof(DWORD) > pMD->dwMDDataLen )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        *pdwRequiredLen = sizeof(DWORD);
        fSt = FALSE;
    }
    else if ( pMD->dwMDDataType != DWORD_METADATA )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        fSt = FALSE;
    }
    else
    {
        pMD->dwMDDataLen = sizeof(DWORD);
        *pdwRequiredLen = sizeof(DWORD);
        *(LPDWORD)pMD->pbMDData = pI->m_pniParent->m_dwParam;
        fSt = TRUE;
    }

    return fSt;
}


BOOL
CKeyedAccess::Set(
    CNseInstance*       pI,
    DWORD,
    PMETADATA_RECORD    pMD,
    DWORD               dwType
    )
/*++

Routine Description:

    Find a mapping based on key

Arguments:

    pI - current instance
    pM - metadata record, ID ignored
    dwType - type of access : by cert, account, name

Returns:

    TRUE if success, otherwise FALSE
    error set to ERROR_PATH_NOT_FOUND if key not found in mappings

--*/
{
    CIisAcctMapper *pM = (CIisAcctMapper*)((RefBlob*)pI->m_pniParent->m_pvParam)->QueryPtr();
    BOOL            fSt = FALSE;

    if ( pM )
    {
        // serial format : list [(DWORD)elem, elem]

        CIisMapping*    pG;
        DWORD           cData;
        LPSTR           pData;
        UINT            cM;
        UINT            iM;
        UINT            iF;

        switch ( dwType )
        {
            case NSEPM_ACCESS_CERT:
                iF = IISMDB_INDEX_CERT11_CERT;
                break;

            case NSEPM_ACCESS_ACCOUNT:
                iF = IISMDB_INDEX_CERT11_NT_ACCT;
                break;

            case NSEPM_ACCESS_NAME:
                iF = IISMDB_INDEX_CERT11_NAME;
                break;

            default:
                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
        }

        pM->Lock();

        cM = pM->GetNbMapping();

        for ( iM = 0 ; iM < cM ; ++iM )
        {
            if ( pM->GetMapping( iM, &pG, TRUE, FALSE ) )
            {
                if ( !pG->MappingGetField( iF, &pData, &cData, FALSE ) )
                {
                    SetLastError( ERROR_INVALID_NAME );
                    break;
                }
                if ( cData == pMD->dwMDDataLen &&
                     !memcmp( pData, pMD->pbMDData, cData ) )
                {
                    fSt = TRUE;
                    pI->m_pniParent->m_dwParam = iM + 1;
                    break;
                }
            }
            else
            {
                SetLastError( ERROR_INVALID_NAME );
                break;
            }
        }

        if ( iM == cM )
        {
            SetLastError( ERROR_PATH_NOT_FOUND );
        }

        pM->Unlock();
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        fSt = FALSE;
    }

    return fSt;
}


BOOL
CNoCwSerObj::Get(
    CNseInstance*       pI,
    DWORD,
    PMETADATA_RECORD    pMD,
    LPDWORD             pdwRequiredLen
    )
/*++

Routine Description:

    get serialized representation of cert wildcard mapper
    to be deserialized in CIisRuleMapper

Arguments:

    pI - current instance
    pMD - metadata record, ID ignored & type , updated with length
    pdwRequiredLen - updated with required length if pMD length is not sufficient

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL                fSt = FALSE;
    CIisRuleMapper *    pM;

    if ( pI->m_pniParent->m_pvParam )
    {
        pM = (CIisRuleMapper*) ((RefBlob*)pI->m_pniParent->m_pvParam)->QueryPtr();

        pM->LockRules();

        CStoreXBF xbf;
        if ( pM->Serialize( &xbf ) )
        {
            *pdwRequiredLen = xbf.GetUsed();
            if ( pMD->dwMDDataLen >= xbf.GetUsed() )
            {
                memcpy( pMD->pbMDData, xbf.GetBuff(), xbf.GetUsed() );
                pMD->dwMDDataLen = xbf.GetUsed();
                fSt = TRUE;
            }
            else
            {
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
            }
        }

        pM->UnlockRules();
    }

    return fSt;
}


BOOL
CNoCwSerObj::Set(
    CNseInstance*       pI,
    DWORD,
    PMETADATA_RECORD    pMD
    )
/*++

Routine Description:

    set cert wildcard mapper from serialized representation

Arguments:

    pI - current instance
    pMD - metadata record, ID ignored & type , updated with length

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL                fSt = TRUE;
    CIisRuleMapper *    pM;

    if ( pI->m_pniParent->m_pvParam )
    {
        pM = (CIisRuleMapper*) ((RefBlob*)pI->m_pniParent->m_pvParam)->QueryPtr();

        pM->LockRules();

        LPBYTE  pB = pMD->pbMDData;
        DWORD   dwB = pMD->dwMDDataLen;

        if ( pM->Unserialize( &pB, &dwB ) )
        {
            pI->m_pniParent->m_fModified = TRUE;
        }

        pM->UnlockRules();
    }

    return fSt;
}


BOOL
CNoIsSerObj::Get(
    CNseInstance*       pI,
    DWORD,
    PMETADATA_RECORD    pMD,
    LPDWORD             pdwRequiredLen
    )
/*++

Routine Description:

    get serialized representation of issuer list
    to be deserialized in CIssuerStore

Arguments:

    pI - current instance
    pMD - metadata record, ID ignored & type , updated with length
    pdwRequiredLen - updated with required length if pMD length is not sufficient

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL                fSt = FALSE;
    CIssuerStore        is;
    CStoreXBF           xbf;

    if ( is.LoadServerAcceptedIssuers() && is.Serialize( &xbf ) )
    {
        *pdwRequiredLen = xbf.GetUsed();
        if ( pMD->dwMDDataLen >= xbf.GetUsed() )
        {
            memcpy( pMD->pbMDData, xbf.GetBuff(), xbf.GetUsed() );
            pMD->dwMDDataLen = xbf.GetUsed();
            fSt = TRUE;
        }
        else
        {
            SetLastError( ERROR_INSUFFICIENT_BUFFER );
        }
    }

    return fSt;
}


CNseInstance::CNseInstance(
    CNseObj* pTemp,
    CNseInstance* pFather
    )
/*++

Routine Description:

    CNseInstance constructor

Arguments:

    pTemp - ptr to template object
    pFather - ptr to father instance

Returns:

    Nothing

--*/
{
        m_fModified = FALSE;
        m_pvParam = NULL;
        m_pniParent = pFather;
        m_pTemplateObject = pTemp;
}


BOOL
CNseInstance::CreateChildrenInstances(
    BOOL    fRecursive
    )
/*++

Routine Description:

    Create children instance objects

Arguments:

    fRecursive - TRUE for recursive creation

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CNseInstance*   pI;
    UINT            i;

    // create all object ( not property ) children

    for ( i = 0 ; i < m_pTemplateObject->m_cnoChildren ; ++i )
    {
        if ( !(pI = new CNseInstance) )
        {
            return FALSE;
        }
        pI->m_pTemplateObject = m_pTemplateObject->m_pnoChildren[i];
        pI->m_pniParent = this;
        if ( !AddChild( pI ) )
        {
			// BugFix: 57659 Whistler
			//         Prefix bug leaking memory in error condition.
			//         If we were not able to add the child to the list
			//         than we should delete the memory it takes instead
			//         of just orphaning it.
			//         EBK 5/5/2000		
			delete pI;
			pI = NULL;
            return FALSE;
        }
        if ( fRecursive && !pI->CreateChildrenInstances( fRecursive ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}


CNseMountPoint::CNseMountPoint(
    )
/*++

Routine Description:

    CNseMountPoint constructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_pTopTemp = NULL;
}


BOOL
CNseMountPoint::Release(
    )
/*++

Routine Description:

    Free children instances of this mount point

Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    UINT    i;

    for ( i = 0 ;i < m_pTopInst.GetNbChildren() ; ++i )
    {
        m_pTopInst.GetChild(i)->m_pTemplateObject->Release( m_pTopInst.GetChild(i), 0 );
    }

    return TRUE;
}


BOOL
CNseMountPoint::Save(
    LPBOOL      pfModified
    )
/*++

Routine Description:

    Save changes made children instances of this mount point on persistent storage

Arguments:

    pfModified - updated with TRUE if metadata modified

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    UINT    i;
    BOOL    fRet = TRUE;

    for ( i = 0 ;i < m_pTopInst.GetNbChildren() ; ++i )
    {
        if ( !m_pTopInst.GetChild(i)->m_pTemplateObject->Save( m_pszPath.Get(), m_pTopInst.GetChild(i), pfModified ) )
        {
            fRet = FALSE;
        }
    }

    return fRet;
}


BOOL
CNseMountPoint::EndTransac(
    BOOL fApplyChanges
    )
/*++

Routine Description:

    Signal a close operation to mount poinr

Arguments:

    fApplyChanges - TRUE to commit changes

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    UINT    i;
    BOOL    fRet = TRUE;

    for ( i = 0 ;i < m_pTopInst.GetNbChildren() ; ++i )
    {
        if ( !m_pTopInst.GetChild(i)->m_pTemplateObject->EndTransac( m_pszPath.Get(), m_pTopInst.GetChild(i), fApplyChanges ) )
        {
            fRet = FALSE;
        }
    }

    return fRet;
}


//
// Global functions
//

CNseInstance*
LocateObject(
    LPSTR*          ppszPath,
    BOOL            fIncludeLastSegment,
    LPDWORD         pdwIndex,
    CNseMountPoint**ppMP
    )
/*++

Routine Description:

    Return instance matching path

Arguments:

    ppszPath - ptr to path, updated with name of last path element
        if fIncludeLastSegment is FALSE
    fIncludeLastSegment - TRUE to use full path, FALSE to stop before last
        path element
    pdwIndex - updated with index for iterated instance
    ppMP - updated with ptr to mount point

Returns:

    ptr to instance if success, otherwise NULL

--*/
{
    LPSTR           p;
    LPSTR           pN;
    LPSTR           p2;
    LPSTR           pNx;
    LPSTR           pS;
    LPSTR           pszPath = *ppszPath;
    LIST_ENTRY*     pEntry;
    CNseMountPoint* pMount = NULL;
    CNseObj*        pTemp;
    CNseInstance*   pWalk;
    UINT            i;
    UINT            iM;

    //
    // leading path delimiter is not mandatory, so skip it if present to consider
    // both formats as equivalent.
    //

    if ( *pszPath == '/' || *pszPath == '\\' )
    {
        ++pszPath;
    }

    // delimit to NSEP, find MountPoint ( create one if not exist )

    if ( (pS = strchr( pszPath, '<' )) &&
         (p = strchr( pszPath, '>' ))  &&
         (pS < p) &&
         (pS > pszPath) &&
         (p[1]=='\0' || p[1]=='/' || p[1]=='\\') )
    {
        if ( p[1] )
        {
            p[1] = '\0';
            p += 2;
        }
        else
        {
            ++p;
        }

        pS[-1] = '\0';

        EnterCriticalSection( &CNseMountPoint::m_csList );

        for ( pEntry = CNseMountPoint::m_ListHead.Flink;
              pEntry != &CNseMountPoint::m_ListHead ;
              pEntry = pEntry->Flink )
        {
            pMount = CONTAINING_RECORD( pEntry,
                                        CNseMountPoint,
                                        CNseMountPoint::m_ListEntry );

            if ( !_stricmp( pMount->m_pszPath.Get(), pszPath ) )
            {
                break;
            }
            else
            {
                pMount = NULL;
            }
        }

        if( pMount == NULL )
        {
            if ( (pMount = new CNseMountPoint()) &&
                 pMount->Init( pszPath ) )
            {
                InsertHeadList( &CNseMountPoint::m_ListHead,
                                &pMount->m_ListEntry );
                pMount->m_pTopTemp = &g_NoList;
                pMount->m_pTopTemp->Load( &pMount->m_pTopInst, pszPath );
            }
            else
            {
                if ( pMount )
                {
                    delete pMount;
                    pMount = NULL;
                }
            }
        }

        LeaveCriticalSection( &CNseMountPoint::m_csList );

        if( pMount == NULL )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return NULL;
        }

        // delimit before last elem in path, find partial path

        pWalk = &pMount->m_pTopInst;

        for ( ; *p ; p = pNx )
        {
            pN = strchr( p, '/' );
            p2 = strchr( p, '\\' );
            if ( !pN || (p2 && p2 < pN ) )
            {
                pN = p2;
            }
            if ( !pN )
            {
                if ( fIncludeLastSegment )
                {
                    pN = p + strlen( p );
                    pNx = pN;
                }
                else
                {
                    break;
                }
            }
            else
            {
                pNx = pN + 1;
            }

            *pN = '\0';

            // find in pWalk
            for ( i = 0, iM = pWalk->GetNbChildren(); i < iM ; ++i )
            {
                if ( pWalk->GetChild( i )->m_pTemplateObject->GetIterated() )
                {
                    pWalk = pWalk->GetChild( i );
                    if ( (UINT)atoi(p)-1 < pWalk->m_pTemplateObject->GetCount( pWalk, 0 ) )
                    {
                        if ( pdwIndex )
                        {
                            *pdwIndex = atoi( p )-1;
                        }
                        break;
                    }
                }
                if ( pdwIndex )
                {
                    *pdwIndex = 0;
                }
                if ( pWalk->GetChild( i )->m_pTemplateObject->m_pszName &&
                     !_stricmp( pWalk->GetChild( i )->m_pTemplateObject->m_pszName,
                     p ) )
                {
                    pWalk = pWalk->GetChild( i );
                    break;
                }
            }
            if ( i == iM )
            {
                SetLastError( ERROR_PATH_NOT_FOUND );
                return NULL;
            }
        }

        *ppszPath = p;
        if ( ppMP )
        {
            *ppMP = pMount;
        }
        return pWalk;
    }

    SetLastError( ERROR_PATH_NOT_FOUND );
    return NULL;
}


BOOL
NseAddObj(
    LPSTR pszPath
    )
/*++

Routine Description:

    Handle Add Object operation

Arguments:

    pszPath - absolute path of object to create

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CNseObj*        pTemp;
    CNseInstance*   pWalk;
    UINT            i;
    DWORD           dwIndex;
    BOOL            fSt = FALSE;

    EnterCriticalSection( &CNseMountPoint::m_csList );

    if ( pWalk = LocateObject( &pszPath, FALSE, &dwIndex ) )
    {
        // add object instance ( check not already exist first )

        for ( i = 0 ; i < pWalk->GetNbChildren() ; ++i )
        {
            if ( pWalk->GetChild(i)->m_pTemplateObject->m_pszName &&
                 !_stricmp( pWalk->GetChild(i)->m_pTemplateObject->m_pszName, pszPath ) )
            {
                SetLastError( ERROR_ALREADY_EXISTS );

                LeaveCriticalSection( &CNseMountPoint::m_csList );

                return FALSE;
            }
        }

        // find in template

        pTemp = pWalk->m_pTemplateObject;
        for ( i = 0 ; i < pTemp->m_cnoChildren; ++i )
        {
            if ( pTemp->m_pnoChildren[i]->GetIterated() ||
                 !_stricmp( pszPath, pTemp->m_pnoChildren[i]->m_pszName ) )
            {
                break;
            }
        }

        if ( i < pTemp->m_cnoChildren )
        {
            fSt = pTemp->m_pnoChildren[i]->Add( pWalk,
                                                pTemp->m_pnoChildren[i]->GetIterated()
                                                   ? strtoul(pszPath,NULL,10)-1 : 0
                                              );
        }
    }

    LeaveCriticalSection( &CNseMountPoint::m_csList );

    return fSt;
}


BOOL
NseDeleteObj(
    LPSTR pszPath
    )
/*++

Routine Description:

    Handle Delete Object operation

Arguments:

    pszPath - absolute path of object to delete

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CNseInstance*   pWalk;
    DWORD           dwIndex;
    BOOL            fSt = FALSE;
    CNseMountPoint* pMP;

    EnterCriticalSection( &CNseMountPoint::m_csList );

    if ( pWalk = LocateObject( &pszPath, TRUE, &dwIndex, &pMP ) )
    {
        fSt = pWalk->m_pTemplateObject->Delete( pMP->GetPath(), pWalk, dwIndex );
    }

    LeaveCriticalSection( &CNseMountPoint::m_csList );

    return fSt;
}


BOOL
NseGetProp(
    LPSTR               pszPath,
    PMETADATA_RECORD    pMD,
    LPDWORD             pdwReq
    )
/*++

Routine Description:

    Handle Get Property operation

Arguments:

    pszPath - absolute path of object where property is to be queried
    pMD - metadata descriptor
    pdwReq - updated with required length of buffer

Returns:

    TRUE if success, otherwise FALSE
    error is ERROR_INSUFFICIENT_BUFFER if supplied buffer too small

--*/
{
    CNseObj*        pTemp;
    CNseInstance*   pWalk;
    UINT            i;
    DWORD           dwIndex;
    BOOL            fSt = FALSE;

    EnterCriticalSection( &CNseMountPoint::m_csList );

    if ( pWalk = LocateObject( &pszPath, TRUE, &dwIndex ) )
    {
        fSt = pWalk->m_pTemplateObject->Get( pWalk, dwIndex, pMD, pdwReq );
    }

    LeaveCriticalSection( &CNseMountPoint::m_csList );

    return fSt;
}


BOOL
NseGetPropByIndex(
    LPSTR               pszPath,
    PMETADATA_RECORD    pMD,
    DWORD               dwI,
    LPDWORD             pdwReq
    )
/*++

Routine Description:

    Handle Get Property operation, based on property index ( 0 based )

Arguments:

    pszPath - absolute path of object where property is to be queried
    pMD - metadata descriptor
    dwI - index of property in property list for this object
    pdwReq - updated with required length of buffer

Returns:

    TRUE if success, otherwise FALSE
    error is ERROR_INSUFFICIENT_BUFFER if supplied buffer too small

--*/
{
    CNseObj*        pTemp;
    CNseInstance*   pWalk;
    UINT            i;
    DWORD           dwIndex;
    BOOL            fSt = FALSE;

    EnterCriticalSection( &CNseMountPoint::m_csList );

    if ( pWalk = LocateObject( &pszPath, TRUE, &dwIndex ) )
    {
        fSt = pWalk->m_pTemplateObject->GetByIndex( pWalk, dwIndex, pMD, dwI, pdwReq );
    }

    LeaveCriticalSection( &CNseMountPoint::m_csList );

    return fSt;
}


BOOL
NseGetAllProp(
    LPSTR           pszPath,
    DWORD           dwMDAttributes,
    DWORD           dwMDUserType,
    DWORD           dwMDDataType,
    DWORD *         pdwMDNumDataEntries,
    DWORD *         pdwMDDataSetNumber,
    DWORD           dwMDBufferSize,
    unsigned char * pbBuffer,
    DWORD *         pdwMDRequiredBufferSize
    )
/*++

Routine Description:

    Handle Get All Properties operation

Arguments:

    pszPath - absolute path of object where properties are to be queried
    dwMDAttributes - metadata attribute, ignored
    dwMDUserType - metadata user type, ignored
    dwMDDataType - metadata data type, ignored
    pdwMDNumDataEntries - updated with count of properties
    pdwMDDataSetNumber - ignored
    dwMDBufferSize - size of pbBuffer
    pbBuffer - buffer where to store properties descriptor and values
    pdwMDRequiredBufferSize - updated with required length of buffer

Returns:

    TRUE if success, otherwise FALSE
    error is ERROR_INSUFFICIENT_BUFFER if supplied buffer too small

--*/
{
    CNseInstance*   pWalk;
    UINT            i;
    DWORD           dwReq;
    DWORD           dwIndex;
    BOOL            fSt = FALSE;

    EnterCriticalSection( &CNseMountPoint::m_csList );

    if ( pWalk = LocateObject( &pszPath, TRUE, &dwIndex ) )
    {
        fSt = pWalk->m_pTemplateObject->GetAll( pWalk, dwIndex, pdwMDNumDataEntries, dwMDBufferSize, pbBuffer, pdwMDRequiredBufferSize);
    }

    LeaveCriticalSection( &CNseMountPoint::m_csList );

    return fSt;
}


BOOL
NseEnumObj(
    LPSTR   pszPath,
    LPBYTE  pszMDName,
    DWORD   dwMDEnumObjectIndex
    )
/*++

Routine Description:

    Handle Enumerate object operation

Arguments:

    pszPath - absolute path where to enumerate objects
    pszMDName - updated with object name
    dwMDEnumObjectIndex - index of object ( 0 based ) in path

Returns:

    TRUE if success, otherwise FALSE
    ERROR_NO_MORE_ITEMS if index out of range

--*/
{
    CNseInstance*   pWalk;
    UINT            i;
    DWORD           dwReq;
    DWORD           dwIndex;
    DWORD           dwN;
    BOOL            fSt = FALSE;

    EnterCriticalSection( &CNseMountPoint::m_csList );

    if ( pWalk = LocateObject( &pszPath, TRUE, &dwIndex ) )
    {
        for ( i = 0 ; i < pWalk->GetNbChildren() ; )
        {
            if ( pWalk->GetChild(i)->m_pTemplateObject->m_pszName )
            {
                if ( pWalk->GetChild(i)->m_pTemplateObject->GetIterated() )
                {
                    dwN = pWalk->GetChild(i)->m_pTemplateObject->GetCount( pWalk->GetChild(i), 0 );
                    if ( dwMDEnumObjectIndex < dwN )
                    {
                        if ( pszMDName )
                        {
                            wsprintf( (LPSTR)pszMDName,
                                      pWalk->GetChild(i)->m_pTemplateObject->m_pszName,
                                      dwMDEnumObjectIndex + 1);
                        }
                        fSt = TRUE;
                    }
                    break;
                }
                if ( !dwMDEnumObjectIndex-- )
                {
                    if ( pszMDName )
                    {
                        strcpy( (LPSTR)pszMDName, pWalk->GetChild(i)->m_pTemplateObject->m_pszName );
                    }
                    fSt = TRUE;
                    break;
                }
            }
        }
    }

    if ( !fSt )
    {
        SetLastError( ERROR_NO_MORE_ITEMS );
    }

    LeaveCriticalSection( &CNseMountPoint::m_csList );

    return fSt;
}


BOOL
NseSetProp(
    LPSTR               pszPath,
    PMETADATA_RECORD    pMD
    )
/*++

Routine Description:

    Handle Set Property operation

Arguments:

    pszPath - absolute path of object where property is to be set
    pMD - metadata descriptor

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    CNseObj*        pTemp;
    CNseInstance*   pWalk;
    UINT            i;
    DWORD           dwReq;
    DWORD           dwIndex;
    BOOL            fSt = FALSE;


    EnterCriticalSection( &CNseMountPoint::m_csList );

    if ( *pszPath == '\0' &&
         pMD->dwMDIdentifier == MD_NOTIFY_CERT11_TOUCHED &&
         pMD->dwMDDataType == BINARY_METADATA )          // Funky fix for Sundown
    {
        PVOID p = *(PVOID *)pMD->pbMDData;
        
        g_pfnCert11Touched = (PFN_MAPPER_TOUCHED)p;
        
        fSt = TRUE;
    }
    else if ( pWalk = LocateObject( &pszPath, TRUE, &dwIndex ) )
    {
        if ( pMD->dwMDDataType == STRING_METADATA )
        {
            pMD->dwMDDataLen = strlen( (LPSTR)pMD->pbMDData ) + 1;
        }
        fSt = pWalk->m_pTemplateObject->Set( pWalk, dwIndex, pMD );
    }

    LeaveCriticalSection( &CNseMountPoint::m_csList );

    return fSt;
}


BOOL
NseReleaseObjs(
    )
/*++

Routine Description:

    Free memory allocated by all instances

Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    LIST_ENTRY*     pEntry;
    LIST_ENTRY*     pNext;
    CNseMountPoint* pMount;

    EnterCriticalSection( &CNseMountPoint::m_csList );

    for ( pEntry = CNseMountPoint::m_ListHead.Flink;
          pEntry != &CNseMountPoint::m_ListHead ;
          pEntry = pNext )
    {
        pMount = CONTAINING_RECORD( pEntry,
                                    CNseMountPoint,
                                    CNseMountPoint::m_ListEntry );


        pNext = pEntry->Flink;
        RemoveEntryList( pEntry );

        pMount->Release();
        delete pMount;
    }

    LeaveCriticalSection( &CNseMountPoint::m_csList );

    return TRUE;
}


BOOL
NseOpenObjs(
    LPSTR pszPath
    )
/*++

Routine Description:

    Initialize access to objects

Arguments:

    pszPath - ignored

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL    fSt = FALSE;
    DWORD   dwIndex;

    EnterCriticalSection( &CNseMountPoint::m_csList );

    if ( g_fPathOpened && GetCurrentThreadId() != g_dwCurrentThreadId )
    {
        SetLastError( ERROR_PATH_BUSY );
        fSt = FALSE;
    }
    else if ( strchr( pszPath, '<' ) == NULL
         || LocateObject( &pszPath, TRUE, &dwIndex ) )
    {
        fSt = TRUE;
        g_fPathOpened = TRUE;
        g_dwCurrentThreadId = GetCurrentThreadId();
    }

    LeaveCriticalSection( &CNseMountPoint::m_csList );

    return fSt;
}


BOOL
NseCloseObjs(
    BOOL    fApplyChanges
    )
/*++

Routine Description:

    Signal close called to objects

Arguments:

    fApplyChanges - TRUE to commit changes

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    LIST_ENTRY*     pEntry;
    CNseMountPoint* pMount;

    EnterCriticalSection( &CNseMountPoint::m_csList );

    g_fPathOpened = FALSE;
    g_dwCurrentThreadId = NULL;

    for ( pEntry = CNseMountPoint::m_ListHead.Flink;
          pEntry != &CNseMountPoint::m_ListHead ;
          pEntry = pEntry->Flink )
    {
        pMount = CONTAINING_RECORD( pEntry,
                                    CNseMountPoint,
                                    CNseMountPoint::m_ListEntry );

        pMount->EndTransac( fApplyChanges );
    }

    LeaveCriticalSection( &CNseMountPoint::m_csList );

    return TRUE;
}


BOOL
NseSaveObjs(
    )
/*++

Routine Description:

    Save all objects

Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    LIST_ENTRY*     pEntry;
    CNseMountPoint* pMount;
    BOOL            fModified = FALSE;
    BOOL            fCert11Touched;

    EnterCriticalSection( &CNseMountPoint::m_csList );

    g_fCert11Touched = FALSE;

    for ( pEntry = CNseMountPoint::m_ListHead.Flink;
          pEntry != &CNseMountPoint::m_ListHead ;
          pEntry = pEntry->Flink )
    {
        pMount = CONTAINING_RECORD( pEntry,
                                    CNseMountPoint,
                                    CNseMountPoint::m_ListEntry );

        pMount->Save( &fModified );
    }

#if 0
    if ( fModified )
    {
        IMDCOM_PTR->ComMDSaveData();
    }
#endif

    fCert11Touched = g_fCert11Touched;

    LeaveCriticalSection( &CNseMountPoint::m_csList );

    if ( fCert11Touched && g_pfnCert11Touched )
    {
        __try
        {
            (g_pfnCert11Touched)();
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
        }
    }

    return TRUE;
}


BOOL
NseMappingInitialize(
    )
/*++

Routine Description:

    Initialize access to NSE for mapping

Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    INITIALIZE_CRITICAL_SECTION( &CNseMountPoint::m_csList );
    InitializeListHead( &CNseMountPoint::m_ListHead );

    g_fPathOpened = FALSE;

    return TRUE;
}


BOOL
NseMappingTerminate(
    )
/*++

Routine Description:

    Terminate access to NSE for mapping

Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    NseReleaseObjs();

    DeleteCriticalSection( &CNseMountPoint::m_csList );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\restart\iisrsta\dcomperm.h ===
DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    );

DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    );

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    );

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD
    );

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    );

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal
    );

DWORD
GetCurrentUserSID (
    PSID *Sid
    );

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    );

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    );

DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    );

DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    );

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal
    );

DWORD
ChangeAppIDAccessACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\xover\test\xidxtest.cpp ===
char	PeerTempDirectory[] = "c:\\temp" ;

#include	<windows.h>
#include	<stdio.h>
#include    <stdlib.h>
#include	"rwnew.h"
#include    "cpool.h"
#include    "smartptr.h"
#include    "tigtypes.h"
#include	"xover.h"

#if 0 
void	DoCXoverIndexTest( int order )		{

	CArticleRef	start ;
	start.m_groupId = 1 ;
	start.m_articleId = 0 ;

	BYTE	rgBuff[1024] ;
	ZeroMemory( rgBuff, sizeof( rgBuff ) ) ;

	CXoverIndex	testIdx(	FALSE,
							start,
							"c:\\temp"
							) ;

	if( !testIdx.IsGood() ) {
		DebugBreak() ;
	}

	ARTICLEID	artidLast ;

	DWORD	cb = 
		testIdx.FillBuffer(	rgBuff, 
					sizeof( rgBuff ),
					0,
					128,
					artidLast ) ;

	if( cb != 0 ) {

		printf( "Read %d bytes - %s\n", cb, rgBuff ) ;

	}

	ARTICLEID	artid = rand() % 128 ;

	static	char	szTest[] = "artid %d order %d Test Entry - This is a very long string"
								"Which we intend to look like valid Xover data however we don't give a damng"
								"Whether the string really makes it in there or not \n" ;

	char	szBuffer[1024] ;
	DWORD	cbInput = wsprintf( szBuffer, szTest, artid, order ) ;

	if( !testIdx.AppendEntry(	(BYTE*)&szBuffer[0], 
						cbInput,
						artid ) ) {

		printf( "Append failed - cause %x\n", GetLastError() ) ;

	}	else	{

		printf( "appended entry %d\n", artid ) ;

	}

	ZeroMemory( rgBuff, sizeof( rgBuff ) ) ;
	cb	= testIdx.FillBuffer( rgBuff, 
						sizeof( rgBuff ),
						0, 
						128,
						artidLast ) ;

	printf( "Read %d bytes -=%s=\n", cb, rgBuff ) ;
	
		
	if( !testIdx.Flush() )	{
		printf( "Flush failed - %x", GetLastError() ) ;
	}

	char	Path[MAX_PATH*2] ;
	char	Path2[MAX_PATH*2] ;
	if( !testIdx.Sort( "c:\\temp", "c:\\temp", Path, Path2 ) ) {
		printf( "Sort failed - %x", GetLastError() ) ;
	}

	testIdx.Flush() ;			
}



void	DoCXoverIndexTest(	CXIDXPTR	pIndex, 
							ARTICLEID	artidBase, 
							int order )		{

	CArticleRef	start ;
	start.m_groupId = 1 ;
	start.m_articleId = 0 ;
	CShareLockNH	testLock ;

	BYTE	rgBuff[1024] ;
	ZeroMemory( rgBuff, sizeof( rgBuff ) ) ;

	if( !pIndex->IsGood() ) {
		DebugBreak() ;
	}

	ARTICLEID	artidLast ;

	DWORD	cb = 
		pIndex->FillBuffer(	rgBuff, 
					sizeof( rgBuff ),
					artidBase,
					artidBase+128,
					artidLast ) ;

	if( cb != 0 ) {

		printf( "Read %d bytes - %s\n", cb, rgBuff ) ;

	}

	ARTICLEID	artid = artidBase + (rand() % 128) ;

	static	char	szTest[] = "artid %d order %d Test Entry - This is a very long string"
								"Which we intend to look like valid Xover data however we don't really care"
								"Whether the string really makes it in there or not \n" ;

	char	szBuffer[1024] ;
	DWORD	cbInput = wsprintf( szBuffer, szTest, artid, order ) ;

	if( !pIndex->AppendEntry(	(BYTE*)&szBuffer[0], 
						cbInput,
						artid ) ) {

		printf( "Append failed - cause %x\n", GetLastError() ) ;

	}	else	{

		printf( "appended entry %d\n", artid ) ;

	}

	ZeroMemory( rgBuff, sizeof( rgBuff ) ) ;
	cb	= pIndex->FillBuffer( rgBuff, 
						sizeof( rgBuff ),
						artidBase, 
						artidBase+128,
						artidLast ) ;

	printf( "Read %d bytes -=%s=\n", cb, rgBuff ) ;
	
		
	if( !pIndex->Flush() )	{
		printf( "Flush failed - %x", GetLastError() ) ;
	}

	char	Path[MAX_PATH*2] ;
	char	Path2[MAX_PATH*2] ;
	if( !pIndex->Sort( "c:\\temp", "c:\\temp", Path, Path2 ) ) {
		printf( "Sort failed - %x", GetLastError() ) ;
	}

	pIndex->Flush() ;			
}



void
DOCXCacheTest()	{

	CXCacheTable	TestTable ;
	DWORD	order = 0 ;

	if( TestTable.Init( 100 ) ) {

		for( int	cIterations = 0; cIterations < 20; cIterations ++ ) {
			for( ARTICLEID articleid = 0; articleid < 8000; articleid += 128 ) {

				CXIDXPTR	pXindex ;
				CArticleRef	temp ;
				temp.m_groupId = 1 ;
				temp.m_articleId = articleid ;

				TestTable.FindEntry(
						FALSE, 	
						temp,
						pXindex, 
						5, 
						"c:\\temp" ) ;

				if( pXindex != 0 ) {

					DoCXoverIndexTest(	pXindex, 
										articleid, 
										order ++ 
										) ;

				}

				TestTable.AgeEntries(   2 + (rand() %10), FALSE ) ;

											
				TestTable.AgeEntries(	2 +	(rand() % 20), TRUE ) ;
				
			}
		}
	}	
}
#endif


CRITICAL_SECTION	OutputCrit ;



void
DumpEntries(	
				CXoverCache&	testCache,
				GROUPID	group,
				char*	szDirectory,
				ARTICLEID	artLow,
				ARTICLEID	artHigh ) {

	char	Buff[4001] ;
	ARTICLEID	articleNext ;
	ARTICLEID	articleCheck = artLow ;

	HXOVER	hXover ;

	while( artLow <= artHigh ) {

		ZeroMemory( Buff, sizeof( Buff ) ) ;
		DWORD	cbOut = 
				testCache.FillBuffer(	(BYTE*)&Buff[0],
										sizeof( Buff )-1,
										group,
										szDirectory,
										artLow,
										artHigh,
										articleNext,
										hXover ) ;

		EnterCriticalSection( &OutputCrit ) ;
		printf( "Thread %x RETRIEVED %d bytes Low %d High %d Next %d\n%s\n", 
			GetCurrentThreadId(), cbOut, artLow, artHigh, articleNext, Buff ) ;
		LeaveCriticalSection( &OutputCrit ) ;


		DWORD	cRead = 0 ;
		DWORD	cbRead = 0 ;
		while( cbRead < cbOut ) {

			DWORD	testGroup = 0 ;
			DWORD	testArticle = 0 ;
			LPSTR	pString = 0  ;
			cRead = sscanf( Buff+cbRead, "%d %d %s", &testGroup, &testArticle, &pString ) ;

			_ASSERT( cRead == 3 ) ;
			_ASSERT( testGroup == group ) ;
			_ASSERT( testArticle >= articleCheck ) ;
			_ASSERT( pString != 0 ) ;
			
			char*	pchEnd = strchr( Buff + cbRead, '\n' ) ;

			cbRead += strchr( Buff+cbRead, '\n' ) - (Buff+cbRead) ;
			cbRead ++ ;

			articleCheck = testArticle ;
		}

		artLow = articleNext ;

	}
}


static	char*	szDirs[] =	
						{	
							"d:\\temp\\group1",
							"d:\\temp\\group2",
							"d:\\temp\\group3",
							"d:\\temp\\group4",
							"d:\\temp\\group5",	
							"d:\\temp\\group6",	
							"d:\\temp\\group7",	
							"d:\\temp\\group8",	
							"d:\\temp\\group9",	
							"d:\\temp\\group10",	
							"d:\\temp\\group11",
							"d:\\temp\\group12",
							"d:\\temp\\group13",
							"d:\\temp\\group14",	
							"d:\\temp\\group15",
							"d:\\temp\\group16",
							"d:\\temp\\group17",
							"d:\\temp\\group18",
							"d:\\temp\\group19",
							"d:\\temp\\group20",
							"d:\\temp\\group21",
							"d:\\temp\\group22",
							"d:\\temp\\group23",
							"d:\\temp\\group24",
							"d:\\temp\\group25",
							"d:\\temp\\group26",
							"d:\\temp\\group27",
							"d:\\temp\\group28",
							"d:\\temp\\group29",
							"d:\\temp\\group30",
							"d:\\temp\\group31",
							"d:\\temp\\group32",
							"d:\\temp\\group33",
							"d:\\temp\\group34",
							"d:\\temp\\group35",
							"d:\\temp\\group36",
							"d:\\temp\\group37",
							"d:\\temp\\group38",
							"d:\\temp\\group39",
							"d:\\temp\\group40",
							"d:\\temp\\group41",
							"d:\\temp\\group42",
							"d:\\temp\\group43",
							"d:\\temp\\group44",
							"d:\\temp\\group45",
							"d:\\temp\\group46",
							"d:\\temp\\group47",
							"d:\\temp\\group48",
							"d:\\temp\\group49",

						} ;


CXoverCache*	ptestCache ;


DWORD	WINAPI
FlushThread(	LPVOID	)	{

	for( int i=1; i < 3600; i++ ) {


		Sleep( 1000 ) ;

		BOOL	CheckInUse = i & 1 ;
		
		for( GROUPID	group = 1; group < 12; group ++ ) {

			printf( "Flushing group %d CheckInUse %x\n", group, CheckInUse ) ;
			ptestCache->FlushGroup( group, 0, CheckInUse ) ;

		}
	}
	return	0 ;
}


DWORD	WINAPI
DOCacheTest(	LPVOID lpv	)	{
	static	char	szString[] = "%d %d This is a relatively short xover entry which we do not care too much about other than that we can see the whole huge line on retrieval \n" ;
	BYTE	buff[4096] ;
	BYTE	buffOut[4096] ;

	DWORD	dwThreadId = GetCurrentThreadId() ;

	HXOVER	hXover ;

	for( GROUPID	group = ((DWORD)lpv) % 11; group < 10; group ++ ) {

		CreateDirectory( szDirs[group], 0 ) ;

		ARTICLEID	articleLow = 1 ;
		for( ARTICLEID	article = 15; article < 10000; article += ((rand() %15)-6) ) {

			EnterCriticalSection( &OutputCrit ) ;
			printf( "Thread %x Inserting Group %d article %d\n", dwThreadId, group, article ) ;
			LeaveCriticalSection( &OutputCrit ) ;

			DWORD	cb = wsprintf( (char*)&buff[0], szString, group, article ) ;

			if( article == 0xff ) {
				printf("Thread %x Buggy article number \n", dwThreadId ) ;
			}

			ptestCache->AppendEntry(	group, 
												szDirs[group], 
												article,
												buff,
												cb ) ;

			ZeroMemory( buffOut, sizeof( buffOut ) ) ;
			ARTICLEID	articleNext ;
			DWORD	cbOut = 
					ptestCache->FillBuffer(	buffOut,
											sizeof( buffOut ),
											group,
											szDirs[group],
											article,
											article,
											articleNext,
											hXover ) ;

			//_ASSERT( cbOut == cb ) ;
			_ASSERT( articleNext > article ) ;

			if( article > 200 ) {
				for( DWORD j=1; j < 100; j+=30 ) {

					ARTICLEID	start = (j>article) ? 0 : (article-j) ;

					DumpEntries(	*ptestCache,
									group,
									szDirs[group],
									start,
									article
									) ;

				}
			}

			ARTICLEID	OldArticleLow = articleLow ;
			BOOL	fExpire = ptestCache->ExpireRange(	
											group,
											szDirs[group],
											articleLow,
											articleLow + ((article - articleLow) / 2), 
											articleLow 
											) ;
			EnterCriticalSection( &OutputCrit ) ;
			printf( "Thread %x fExpire %d article %d article / 2 %d articleLow %d err %x\n", 
						dwThreadId,
						fExpire, 
						article, 
						article / 2,
						articleLow, 
						GetLastError() 
						) ;
			LeaveCriticalSection( &OutputCrit ) ;

			if( OldArticleLow != articleLow  ) {

				DumpEntries(	*ptestCache,
								group,
								szDirs[group],
								0,
								OldArticleLow 
								) ;

				DumpEntries(	*ptestCache,
								group,
								szDirs[group],
								OldArticleLow,
								articleLow
								) ;

				DumpEntries(	*ptestCache,
								group,
								szDirs[group],
								OldArticleLow,
								article / 2
								) ;

			}
										
			EnterCriticalSection( &OutputCrit ) ;
			printf( "Thread %x Retrieved Entry %d %d =%s=\n", dwThreadId, group, article, buffOut ) ;
			LeaveCriticalSection( &OutputCrit ) ;
												
		}
	}

	return	0 ;
}


int __cdecl
main(	int	argc,	char*	argv[] ) {


	XoverCacheLibraryInit() ;

	ptestCache = CXoverCache::CreateXoverCache() ;


	HANDLE	rgh[65] ;

	InitializeCriticalSection( &OutputCrit ) ;

	_VERIFY( ptestCache->Init( ) ) ;

	DWORD	dwJunk ;

	for( int j=1; j<20; j++ ) {

		rgh[j] = CreateThread(	0,
								0,	
								DOCacheTest,
								(LPVOID)j,
								0,
								&dwJunk ) ;

	}

	rgh[j++] = CreateThread(	0,
								0,
								FlushThread,
								0,
								0,
								&dwJunk
								) ;

	WaitForMultipleObjects( j-1, rgh+1, TRUE, INFINITE ) ;

	_VERIFY( ptestCache->Term() ) ;


#if 0 
	DOCXCacheTest() ;
	

	DOCacheTest( 0 ) ;
	for( int i=0; i<100; i++ ) {
		DoCXoverIndexTest( i ) ;	
	}
#endif

	DeleteCriticalSection( &OutputCrit ) ;

	XoverCacheLibraryTerm() ;

	return	 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nsepm\nsepm.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :
      nsepm.cxx

   Abstract:
      This module defines Name Space Extension for mapping

   Author:

       Philippe Choquier    29-Nov-1996
--*/

#define INITGUID
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <dbgutil.h>
#include <ole2.h>
#include <imd.h>
#include <windows.h>

#include <xbf.hxx>
#include "nsepimp.hxx"
#include "nsepm.hxx"
#include <stringau.hxx>

//#define TEST_ADMACL
#if defined(TEST_ADMACL)
#include <admacl.hxx>
#endif

#define NSEPM_NOISY 0   // set to 1 for really noisy debug output

#if NSEPM_NOISY
#define NOISYPRINTF(x) DBGPRINTF(x)
#else
#define NOISYPRINTF(x)
#endif

OPEN_CTX**        OPEN_CTX::sm_pHandleTable;
CRITICAL_SECTION  OPEN_CTX::sm_csHandleTableLock;
DWORD             OPEN_CTX::sm_cHandleEntries;
DWORD             OPEN_CTX::sm_cMaxHandleEntries;

DWORD
OPEN_CTX::InitializeHandleTable(
    VOID
)
/*++

Routine Description:

    Initialize Handle Table.  This table maps DWORD handles to pointers to 
    OPEN_CTX objects.  This is an Sundown-ism

Arguments:

    None

Returns:

    Returns ERROR_SUCCESS if successful, else Win32 Error

--*/
{
    INITIALIZE_CRITICAL_SECTION( &sm_csHandleTableLock );
    
    sm_cHandleEntries = 0;
    sm_cMaxHandleEntries = INITIAL_HANDLE_TABLE_SIZE;
    
    sm_pHandleTable = (POPEN_CTX*) LocalAlloc( LPTR, 
                                               sizeof( POPEN_CTX ) *
                                               sm_cMaxHandleEntries );
    if ( sm_pHandleTable == NULL )
    {
        return GetLastError();
    }
    
    return ERROR_SUCCESS;
}

DWORD
OPEN_CTX::TerminateHandleTable(
    VOID
)
/*++

Routine Description:

    Destroy Handle Table. 

Arguments:

    None

Returns:

    Returns ERROR_SUCCESS if successful, else Win32 Error

--*/
{
    EnterCriticalSection( &OPEN_CTX::sm_csHandleTableLock );
    
    sm_cHandleEntries = 0;
    sm_cMaxHandleEntries = 0;
    
    if ( sm_pHandleTable )
    {
        LocalFree( sm_pHandleTable );
        sm_pHandleTable = NULL;
    }
    
    LeaveCriticalSection( &OPEN_CTX::sm_csHandleTableLock );
    
    DeleteCriticalSection( &OPEN_CTX::sm_csHandleTableLock );
    
    return ERROR_SUCCESS;
}

POPEN_CTX
OPEN_CTX::MapHandleToContext(
    IN DWORD               dwHandle
)
{
    POPEN_CTX               pOpenCtx = NULL;
    
    EnterCriticalSection( &OPEN_CTX::sm_csHandleTableLock );
    
    if ( dwHandle &&
         dwHandle <= OPEN_CTX::sm_cMaxHandleEntries )
    {
        pOpenCtx = OPEN_CTX::sm_pHandleTable[ dwHandle - 1 ]; 
    }

    LeaveCriticalSection( &OPEN_CTX::sm_csHandleTableLock );
    
    return pOpenCtx;
}

OPEN_CTX::OPEN_CTX( DWORD dwAccess )
    : m_dwAccess( dwAccess ),
      m_dwHandle( 0 )
/*++

Routine Description:

    Constructor for OPEN_CTX objects.  Responsible for generating a DWORD
    handle to be passed back to caller of NSEPM.  

Arguments:

    dwAccess - Access required for NSEPM call

Returns:

    None.  Successful if GetHandle() selector returns non-zero handle

--*/
{
    DWORD               cNewCount;
    DWORD               iCounter;
    
    EnterCriticalSection( &OPEN_CTX::sm_csHandleTableLock );
    
    cNewCount = sm_cHandleEntries + 1;
    if ( cNewCount > sm_cMaxHandleEntries )
    {
        sm_cMaxHandleEntries += HANDLE_TABLE_REALLOC_JUMP;
        
        sm_pHandleTable = (POPEN_CTX*) LocalReAlloc( sm_pHandleTable,
                                                     sm_cMaxHandleEntries *
                                                     sizeof( POPEN_CTX ),
                                                     LMEM_MOVEABLE );
        if ( sm_pHandleTable == NULL )
        {
            LeaveCriticalSection( &OPEN_CTX::sm_csHandleTableLock );
            return;
        }
    }
    sm_cHandleEntries = cNewCount;
    
    for( iCounter = 0;
         iCounter < sm_cMaxHandleEntries;
         iCounter++ )
    {
        if ( sm_pHandleTable[ iCounter ] == NULL )
        {
            sm_pHandleTable[ iCounter ] = this;
        
            // Handle is index+1, so that 0 can represent failure.

            m_dwHandle = iCounter + 1;
            break;
        }
    }
    
    LeaveCriticalSection( &OPEN_CTX::sm_csHandleTableLock );
}

OPEN_CTX::~OPEN_CTX()
/*++

Routine Description:

    Destructor for OPEN_CTX object

Arguments:

Returns:

    None

--*/
{
    DWORD               iCounter;

    EnterCriticalSection( &OPEN_CTX::sm_csHandleTableLock );
   
    if ( m_dwHandle )
    {
        sm_pHandleTable[ m_dwHandle - 1 ] = NULL;
        sm_cHandleEntries--;
    } 
    
    LeaveCriticalSection( &OPEN_CTX::sm_csHandleTableLock );
}

//
// Local class
//

class CDirPath : public CAllocString {
public:
    BOOL Append( LPSTR );
private:
} ;


CDirPath::Append(
    LPSTR   pszPath
    )
{
    LPSTR   pCur = Get();
    int     ch;

    if ( pCur && *pCur && (ch=pCur[strlen(pCur)-1])!='/' && ch!='\\' &&
         pszPath && *pszPath && *pszPath != '/' && *pszPath != '\\' )
    {
        if ( !CAllocString::Append( "\\" ) )
        {
            return FALSE;
        }
    }

    return CAllocString::Append( pszPath );
}


//
// Globals
//

#include <initguid.h>
DEFINE_GUID(IisNsepmGuid, 
0x784d8916, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

DECLARE_DEBUG_PRINTS_OBJECT();
IMDCOM* g_pMdIf = NULL;
DWORD   g_dwInitialized = 0;
ULONG   g_dwRefCount = 0;
ULONG   g_dwLockCount = 0;
CRITICAL_SECTION    g_csInitCritSec;

class CInitNsep {
public:
#ifndef _NO_TRACING_
    CInitNsep() { CREATE_DEBUG_PRINT_OBJECT( "NSEPM", IisNsepmGuid ); INITIALIZE_CRITICAL_SECTION( &g_csInitCritSec ); }
#else
    CInitNsep() { CREATE_DEBUG_PRINT_OBJECT( "NSEPM" ); INITIALIZE_CRITICAL_SECTION( &g_csInitCritSec ); }
#endif
    ~CInitNsep() { DELETE_DEBUG_PRINT_OBJECT(); DeleteCriticalSection( &g_csInitCritSec ); }
} g_cinitnsep;

//
// Class factory
//

class NSEPCOMSrvFactory : public IClassFactory {
public:

    NSEPCOMSrvFactory();
    ~NSEPCOMSrvFactory();

    HRESULT _stdcall
    QueryInterface(REFIID riid, void** ppObject);

    ULONG _stdcall
    AddRef();

    ULONG _stdcall
    Release();

    HRESULT _stdcall
    CreateInstance(IUnknown *pUnkOuter, REFIID riid,
                   void ** pObject);

    HRESULT _stdcall
    LockServer(BOOL fLock);

private:
    ULONG   m_dwRefCount;
    NSEPCOM m_mdcObject;
};



NSEPCOMSrvFactory::NSEPCOMSrvFactory(
    )
    :m_mdcObject()
/*++

Routine Description:

    Class factory constructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_dwRefCount = 0;
}


NSEPCOMSrvFactory::~NSEPCOMSrvFactory(
    )
/*++

Routine Description:

    Class factory destructor

Arguments:

    None

Returns:

    Nothing

--*/
{
}


HRESULT
NSEPCOMSrvFactory::CreateInstance(
    IUnknown *  pUnkOuter,
    REFIID      riid,
    void **     ppObject
    )
/*++

Routine Description:

    Create NSECOM instance

Arguments:

    pUnkOuter - controlling unknown
    riid - interface ID
    ppObject - updated with interface ptr if success

Returns:

    status

--*/
{
    NOISYPRINTF( (DBG_CONTEXT, "[NSEPCOMSrvFactory::CreateInstance]\n" ) );

    NSEPCOM*    pC = new NSEPCOM;
    if ( pC == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    if (FAILED( pC->QueryInterface(riid, ppObject)))
    {
        DBGPRINTF( (DBG_CONTEXT, "[NSEPCOMSrvFactory::CreateInstance] no I/F\n" ) );

        delete pC;

        return E_NOINTERFACE;
    }

    InterlockedIncrement((long *)&g_dwRefCount);

    return NO_ERROR;
}


HRESULT
NSEPCOMSrvFactory::LockServer(
    BOOL fLock
    )
/*++

Routine Description:

    Lock server

Arguments:

    fLock - TRUE to lock server, FALSE to unlock it

Returns:

    status

--*/
{
    if (fLock)
    {
        InterlockedIncrement((long *)&g_dwLockCount);
    }
    else
    {
        InterlockedDecrement((long *)&g_dwLockCount);
    }

    return NO_ERROR;
}


HRESULT
NSEPCOMSrvFactory::QueryInterface(
    REFIID riid,
    void **ppObject
    )
/*++

Routine Description:

    Lock server

Arguments:

    None

Returns:

    status

--*/
{
    NOISYPRINTF( (DBG_CONTEXT, "[NSEPCOMSrvFactory::QueryInterface]\n" ) );
    if (riid==IID_IUnknown || riid == IID_IClassFactory)
    {
        *ppObject = (IMDCOM *) this;
    }
    else
    {
        DBGPRINTF( (DBG_CONTEXT, "[NSEPCOMSrvFactory::QueryInterface] no I/F\n") );

        return E_NOINTERFACE;
    }
    AddRef();

    return NO_ERROR;
}


ULONG
NSEPCOMSrvFactory::AddRef(
    )
/*++

Routine Description:

    Increment refcount to class factory

Arguments:

    None

Returns:

    >0 if new refcount >0, 0 if new refcount is 0, otherwise <0

--*/
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);

    return dwRefCount;
}


ULONG
NSEPCOMSrvFactory::Release(
    )
/*++

Routine Description:

    Decrement refcount to class factory

Arguments:

    None

Returns:

    >0 if new refcount >0, 0 if new refcount is 0, otherwise <0

--*/
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0)
    {
        NOISYPRINTF( (DBG_CONTEXT, "[NSEPCOMSrvFactory::Release] delete object\n" ) );
        delete this;
    }

    return dwRefCount;
}


STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    void** ppObject
    )
/*++

Routine Description:

    Create instance of class factory

Arguments:

    rclsid - class ID
    riid - interface ID
    ppObject - updated with ptr to interface if success

Returns:

    status

--*/
{
    NOISYPRINTF( (DBG_CONTEXT, "[NSEPCOMSrvFactory::DllGetClassObject]\n" ) );
    if ( rclsid != CLSID_NSEPMCOM )
    {
        DBGPRINTF( (DBG_CONTEXT, "[NSEPCOMSrvFactory::DllGetClassObject] bad class\n" ) );
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    NSEPCOMSrvFactory *pFactory = new NSEPCOMSrvFactory;
    if (FAILED(pFactory->QueryInterface(riid, ppObject)))
    {
        delete pFactory;
        *ppObject = NULL;
        DBGPRINTF( (DBG_CONTEXT, "[NSEPCOMSrvFactory::DllGetClassObject] no I/F\n" ) );
        return E_INVALIDARG;
    }
    return NO_ERROR;
}


HRESULT _stdcall
DllCanUnloadNow(
    )
/*++

Routine Description:

    return S_OK if dll can be unloaded

Arguments:

    None

Returns:

    S_OK if OK to unload, otherwise S_FALSE

--*/
{
    if ( g_dwRefCount || g_dwLockCount )
    {
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}


STDAPI
DllRegisterServer(
    void
    )
/*++

Routine Description:

    Register NSECOM class & interface in registry

Arguments:

    None

Returns:

    status

--*/
{
    HKEY hKeyCLSID, hKeyInproc32;
    HKEY hKeyIF, hKeyStub32;
    DWORD dwDisposition;
    HMODULE hModule;

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    TEXT("CLSID\\{05dc3bb0-4337-11d0-a5c8-00a0c922e752}"),
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("NSEPM COM Server"), sizeof(TEXT("NSEPM COM Server")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    if (RegCreateKeyEx(hKeyCLSID,
                    "InprocServer32",
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyInproc32, &dwDisposition)!=ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    hModule=GetModuleHandle("NSEPM.DLL");
    if (!hModule) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    TCHAR szName[MAX_PATH+1];
    if (GetModuleFileName(hModule, szName, sizeof(szName))==0) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }
    if (RegSetValueEx(hKeyInproc32, TEXT(""), NULL, REG_SZ, (BYTE*) szName, sizeof(TCHAR)*(lstrlen(szName)+1))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyInproc32, TEXT("ThreadingModel"), NULL, REG_SZ, (BYTE*) "Both", sizeof("Both")-1 )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyInproc32);
    RegCloseKey(hKeyCLSID);

    //
    // Register Interface, proxy is IMDCOM
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    TEXT("Interface\\{4810a750-4318-11d0-a5c8-00a0c922e752}"),
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyIF, &dwDisposition)!=ERROR_SUCCESS) {
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyIF, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("NSECOM"), sizeof(TEXT("NSECOM")))!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegCreateKeyEx(hKeyIF,
                    "ProxyStubClsid32",
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyStub32, &dwDisposition)!=ERROR_SUCCESS) {
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    if (RegSetValueEx(hKeyStub32, TEXT(""), NULL, REG_SZ, (BYTE*)"{C1AA48C0-FACC-11cf-9D1A-00AA00A70D51}", sizeof("{C1AA48C0-FACC-11cf-9D1A-00AA00A70D51}") )!=ERROR_SUCCESS) {
            RegCloseKey(hKeyStub32);
            RegCloseKey(hKeyIF);
            return E_UNEXPECTED;
            }

    RegCloseKey(hKeyStub32);
    RegCloseKey(hKeyIF);

    return NOERROR;
}


STDAPI
DllUnregisterServer(
    void
    )
/*++

Routine Description:

    Unregister NSECOM class & interface from registry

Arguments:

    None

Returns:

    status

--*/
{
    if (RegDeleteKey(HKEY_CLASSES_ROOT,
                    TEXT("CLSID\\{05dc3bb0-4337-11d0-a5c8-00a0c922e752}\\InprocServer32"))!=ERROR_SUCCESS)
    {
        return E_UNEXPECTED;
    }
    if (RegDeleteKey(HKEY_CLASSES_ROOT,
                    TEXT("CLSID\\{05dc3bb0-4337-11d0-a5c8-00a0c922e752}"))!=ERROR_SUCCESS)
    {
        return E_UNEXPECTED;
    }
    if (RegDeleteKey(HKEY_CLASSES_ROOT,
                    TEXT("Interface\\{4810a750-4318-11d0-a5c8-00a0c922e752}\\ProxyStubClsid32"))!=ERROR_SUCCESS)
    {
        return E_UNEXPECTED;
    }
    if (RegDeleteKey(HKEY_CLASSES_ROOT,
                    TEXT("Interface\\{4810a750-4318-11d0-a5c8-00a0c922e752}"))!=ERROR_SUCCESS)
    {
        return E_UNEXPECTED;
    }
    return NOERROR;
}



//
// NSEPCOM implementation
//


NSEPCOM::NSEPCOM(
    )
/*++

Routine Description:

    NSEPCOM constructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_dwRefCount = 0;
}


NSEPCOM::~NSEPCOM(
    )
/*++

Routine Description:

    NSEPCOM destructor

Arguments:

    None

Returns:

    Nothing

--*/
{
}


HRESULT
NSEPCOM::QueryInterface(
    REFIID riid,
    void **ppObject
    )
/*++

Routine Description:

    NSEPCOM query interface
    recognize IID_IUnknown & IID_NSECOM

Arguments:

    riid - interface ID
    ppObject - updated with ptr to interface if success

Returns:

    status

--*/
{
    NOISYPRINTF( (DBG_CONTEXT, "[NSEPCOM::QueryInterface]\n" ) );
    if (riid==IID_IUnknown || riid==IID_NSECOM)
    {
        *ppObject = (NSEPCOM *) this;
    }
    else
    {
        DBGPRINTF( (DBG_CONTEXT, "[NSEPCOM::QueryInterface] no I/F\n" ) );
        return E_NOINTERFACE;
    }

    AddRef();

    return NO_ERROR;
}


ULONG
NSEPCOM::AddRef(
    )
/*++

Routine Description:

    Add reference to NSECOM interface

Arguments:

    None

Returns:

    >0 if new refcount >0, 0 if new refcount is 0, otherwise <0

--*/
{
    DWORD dwRefCount;

    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);

    return dwRefCount;
}


ULONG
NSEPCOM::Release(
    )
/*++

Routine Description:

    Remove reference to NSECOM interface

Arguments:

    None

Returns:

    >0 if new refcount >0, 0 if new refcount is 0, otherwise <0

--*/
{
    DWORD dwRefCount;

    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);

    if ( !dwRefCount )
    {
        delete this;
        InterlockedDecrement((long *)&g_dwRefCount);
    }

    return dwRefCount;
}

HRESULT
NSEPCOM::ComMDInitialize(
    )
/*++

Routine Description:

    Initialize access to NSE for mappings

Arguments:

    None

Returns:

    status

--*/
{
    DWORD       RetCode = ERROR_SUCCESS;
    HRESULT     hRes = S_OK;

    EnterCriticalSection( &g_csInitCritSec );

    if ( g_dwInitialized++ == 0 )
    {
        hRes = CoCreateInstance(CLSID_MDCOM, NULL, CLSCTX_INPROC_SERVER, IID_IMDCOM, (void**) &g_pMdIf);

        if (FAILED(hRes))
        {
            g_pMdIf = NULL;
        }
        else
        {
            hRes = ReturnCodeToHresult( OPEN_CTX::InitializeHandleTable() );
            if ( SUCCEEDED( hRes ) )
            {
                hRes = g_pMdIf->ComMDInitialize();
                if ( SUCCEEDED( hRes ) )
                {
                    hRes = NseMappingInitialize() ? S_OK : ReturnCodeToHresult( GetLastError() );
                }
            }
        }
    }

    if ( FAILED( hRes ) )
    {
        --g_dwInitialized;
    }
    
    LeaveCriticalSection( &g_csInitCritSec );

    return hRes;
}


HRESULT
NSEPCOM::ComMDTerminate(
    IN BOOL bSaveData
    )
/*++

Routine Description:

    Terminate access to NSE for mappings

Arguments:

    bSaveData - TRUE to save data on persistent storage

Returns:

    status

--*/
{
    DWORD       RetCode = ERROR_SUCCESS;
    HRESULT     hRes = S_OK;

    EnterCriticalSection( &g_csInitCritSec );

    if ( g_dwInitialized && (--g_dwInitialized == 0) )
    {
        if ( bSaveData )
        {
            NseSaveObjs();
        }

        hRes = NseMappingTerminate() ? S_OK : ReturnCodeToHresult( GetLastError() );

        if ( g_pMdIf )
        {
            g_pMdIf->ComMDTerminate(TRUE);
            g_pMdIf->Release();
            g_pMdIf = NULL;
        }
        
        DBG_REQUIRE( OPEN_CTX::TerminateHandleTable() == ERROR_SUCCESS );
    }

    LeaveCriticalSection( &g_csInitCritSec );

    return hRes;
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDShutdown( void)
{

    return ReturnCodeToHresult(ERROR_NOT_SUPPORTED);

}

HRESULT
NSEPCOM::ComMDAddMetaObjectA(
    IN METADATA_HANDLE hMDHandle,
    IN PBYTE pszMDPath
    )
/*++

Routine Description:

    Add object

Arguments:

    hMDHandle - open handle
    pszMDPath - path of object to add

Returns:

    status

--*/
{
    DWORD                       RetCode;
    CDirPath                    asPath;
    POPEN_CTX                   pOpenCtx;
    
    pOpenCtx = OPEN_CTX::MapHandleToContext( hMDHandle );

 	// BugFix: 117734 Whistler
	//         Prefix bug pOpenCtx being used when it could be null
	//         EBK 5/15/2000
	if (pOpenCtx == NULL) 
	{
		RetCode = ERROR_INVALID_PARAMETER;
	}
    else if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((LPSTR)pszMDPath == NULL) || (*(LPSTR)pszMDPath == (TCHAR)'\0'))
    {
        RetCode = ERROR_INVALID_PARAMETER;
    }
    else if ( !(pOpenCtx->GetAccess() & METADATA_PERMISSION_WRITE) )
    {
        RetCode = ERROR_ACCESS_DENIED;
    }
    else
    {
        if ( asPath.Set( pOpenCtx->GetPath() ) &&
                 asPath.Append( (LPSTR)pszMDPath ) )
        {
            RetCode = NseAddObj( asPath.Get() ) ? ERROR_SUCCESS : GetLastError();
        }
        else
        {
            RetCode = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return ReturnCodeToHresult(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDAddMetaObjectW(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ LPCWSTR pszMDPath)
{
    STRAU   strauPath;
    LPSTR   pszPathA = NULL;

    if ( pszMDPath )
    {
        if ( !strauPath.Copy( (LPWSTR)pszMDPath ) )
        {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }

        pszPathA = strauPath.QueryStrA();

        if (pszPathA == NULL) {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return ComMDAddMetaObjectA( hMDHandle, (LPBYTE)pszPathA );
}

HRESULT
NSEPCOM::ComMDDeleteMetaObjectA(
    IN METADATA_HANDLE hMDHandle,
    IN PBYTE pszMDPath
    )
/*++

Routine Description:

    Delete object

Arguments:

    hMDHandle - open handle
    pszMDPath - path of object to delete

Returns:

    status

--*/
{
    DWORD           RetCode;
    CDirPath        asPath;
    POPEN_CTX       pOpenCtx;
    
    pOpenCtx = OPEN_CTX::MapHandleToContext( hMDHandle );

	// BugFix: 117747 Whistler
	//         Prefix bug pOpenCtx being used when it could be null
	//         EBK 5/15/2000
	if (pOpenCtx == NULL) 
	{
		RetCode = ERROR_INVALID_PARAMETER;
	}
    else if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((LPSTR)pszMDPath == NULL)
    {
       RetCode = ERROR_INVALID_PARAMETER;
    }
    else if ( !(pOpenCtx->GetAccess() & METADATA_PERMISSION_WRITE) )
    {
        RetCode = ERROR_ACCESS_DENIED;
    }
    else
    {
        if ( asPath.Set( pOpenCtx->GetPath() ) &&
                 asPath.Append( (LPSTR)pszMDPath ) )
        {
            RetCode = NseDeleteObj( asPath.Get() ) ? ERROR_SUCCESS : GetLastError();
        }
        else
        {
            RetCode = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    return ReturnCodeToHresult(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDDeleteMetaObjectW(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ LPCWSTR pszMDPath)
{
    STRAU   strauPath;
    LPSTR   pszPathA = NULL;

    if ( pszMDPath )
    {
        if ( !strauPath.Copy( (LPWSTR)pszMDPath ) )
        {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }

        pszPathA = strauPath.QueryStrA();

        if (pszPathA == NULL) {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return ComMDDeleteMetaObjectA( hMDHandle, (LPBYTE)pszPathA );
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDDeleteChildMetaObjectsA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath
    )
/*++

Routine Description:

    Not supported

Arguments:

Returns:

    error : either NSE not initialized or not supported

--*/
{
    DWORD RetCode;

    if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else
    {
        RetCode = ERROR_NOT_SUPPORTED;
    }

    return ReturnCodeToHresult(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDDeleteChildMetaObjectsW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath)
{
    STRAU   strauPath;
    LPSTR   pszPathA = NULL;

    if ( pszMDPath )
    {
        if ( !strauPath.Copy( (LPWSTR)pszMDPath ) )
        {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }

        pszPathA = strauPath.QueryStrA();

        if (pszPathA == NULL) {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return ComMDDeleteChildMetaObjectsA( hMDHandle, (LPBYTE)pszPathA );
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDEnumMetaObjectsA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [size_is][in] */ unsigned char __RPC_FAR *pszMDPath,
    /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
    /* [in] */ DWORD dwMDEnumObjectIndex
    )
/*++

Routine Description:

    Enumerate objects in path

Arguments:

    hMDHandle - open handle
    pszMDPath - path where to enumerate objects
    pszMDName - updated with object name
    dwMDEnumObjectIndex - object index ( 0 based )

Returns:

    status

--*/
{
    DWORD           RetCode;
    LPSTR           pszPath = (LPSTR)pszMDPath;
    CDirPath        asPath;
    POPEN_CTX       pOpenCtx;
    
    pOpenCtx = OPEN_CTX::MapHandleToContext( hMDHandle );
    
	// BugFix: 117725 Whistler
	//         Prefix bug pOpenCtx being used when it could be null
	//         EBK 5/15/2000
	if (pOpenCtx == NULL) 
	{
		RetCode = ERROR_INVALID_PARAMETER;
	}
    else if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((LPSTR)pszMDName == NULL)
    {
        RetCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        if ( asPath.Set( pOpenCtx->GetPath() ) &&
                 asPath.Append( (LPSTR)pszMDPath ) )
        {
            RetCode = NseEnumObj( asPath.Get(), pszMDName, dwMDEnumObjectIndex )
                    ? ERROR_SUCCESS : GetLastError();
        }
        else
        {
            RetCode = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return ReturnCodeToHresult(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDEnumMetaObjectsW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [size_is][out] */ LPWSTR pszMDName,
    /* [in] */ DWORD dwMDEnumObjectIndex)
{
    STRAU   strauPath;
    STRAU   strauName;
    LPSTR   pszPathA = NULL;
    CHAR    achNameA[METADATA_MAX_NAME_LEN];
    HRESULT hres;

    if ( pszMDPath )
    {
        if ( !strauPath.Copy( (LPWSTR)pszMDPath ) )
        {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }

        pszPathA = strauPath.QueryStrA();

        if (pszPathA == NULL) {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    hres = ComMDEnumMetaObjectsA( hMDHandle, (LPBYTE)pszPathA, (LPBYTE)achNameA, dwMDEnumObjectIndex );

    if ( SUCCEEDED(hres) )
    {
        if ( (!strauName.Copy( achNameA )) || (strauName.QueryStrW() == NULL))
        {
            hres = ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }
        else
        {

            memcpy( pszMDName, strauName.QueryStrW(), strauName.QueryCBW() + sizeof(WCHAR) );
        }
    }

    return hres;
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDCopyMetaObjectA(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
    /* [in] */ BOOL bOverwriteFlag,
    /* [in] */ BOOL bCopyFlag
    )
/*++

Routine Description:

    Not supported

Arguments:

Returns:

    error : either NSE not initialized or not supported

--*/
{
    DWORD RetCode = ERROR_SUCCESS;

    if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else
    {
        RetCode = ERROR_NOT_SUPPORTED;
    }
    return ReturnCodeToHresult(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDCopyMetaObjectW(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ LPCWSTR pszMDDestPath,
    /* [in] */ BOOL bMDOverwriteFlag,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ReturnCodeToHresult(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDRenameMetaObjectA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName)
{
    DWORD RetCode = ERROR_SUCCESS;

    if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else
    {
        RetCode = ERROR_NOT_SUPPORTED;
    }
    return ReturnCodeToHresult(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDRenameMetaObjectW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [string][in][unique] */ LPCWSTR pszMDNewName)
{
    return ReturnCodeToHresult(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDSetMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [size_is][in] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData
    )
/*++

Routine Description:

    Set property of object

Arguments:

    hMDHandle - open handle
    pszMDPath - path to object
    pmdrMDData - metadata descriptor

Returns:

    status

--*/
{
    DWORD           RetCode;
    LPSTR           pszPath = (LPSTR)pszMDPath;
    CDirPath        asPath;
    POPEN_CTX       pOpenCtx;
    
    pOpenCtx = OPEN_CTX::MapHandleToContext( hMDHandle );

	// BugFix: 117743 Whistler
	//         Prefix bug pOpenCtx being used when it could be null
	//         EBK 5/15/2000
	if (pOpenCtx == NULL) 
	{
		RetCode = ERROR_INVALID_PARAMETER;
	}
    else if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else if ( !( pOpenCtx->GetAccess() & METADATA_PERMISSION_WRITE) )
    {
        RetCode = ERROR_ACCESS_DENIED;
    }
    else
    {

#if defined(TEST_ADMACL)

    METADATA_HANDLE hMB;
    HRESULT         hRes;

    hRes = g_pMdIf->ComMDOpenMetaObject( METADATA_MASTER_ROOT_HANDLE,
                                         (BYTE *) "/LM/W3SVC/1",
                                         METADATA_PERMISSION_READ,
                                         5000,
                                         &hMB );

    AdminAclNotifyOpen( hMB, (LPBYTE)"/LM/W3SVC/1", FALSE );

    if ( SUCCEEDED( hRes ) )
    {
        BOOL fSt = AdminAclAccessCheck(
                hMB,
                pszMDPath,
                pmdrMDData->dwMDIdentifier,
                METADATA_PERMISSION_WRITE
                );

        AdminAclNotifyClose( hMB );

        g_pMdIf->ComMDCloseMetaObject( hMB );

        if ( !fSt )
        {
            return ReturnCodeToHresult( ERROR_ACCESS_DENIED );
        }
    }

    AdminAclNotifyOpen( hMDHandle, (LPBYTE)"/LM/W3SVC/1/<nsepm>/", TRUE );
    AdminAclAccessCheck(
            hMDHandle,
            pszMDPath,
            pmdrMDData->dwMDIdentifier,
            METADATA_PERMISSION_WRITE
            );
    AdminAclNotifyClose( hMDHandle );
#endif

        if ( asPath.Set( pOpenCtx->GetPath() ) &&
                 asPath.Append( (LPSTR)pszMDPath ) )
        {
            RetCode = NseSetProp( asPath.Get(), pmdrMDData )
                    ? ERROR_SUCCESS : GetLastError();
        }
        else
        {
            RetCode = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return ReturnCodeToHresult(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDSetMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData)
{
    STRAU   strauPath;
    LPSTR   pszPathA = NULL;

    if ( pszMDPath )
    {
        if ( !strauPath.Copy( (LPWSTR)pszMDPath ) )
        {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }

        pszPathA = strauPath.QueryStrA();

        if (pszPathA == NULL) {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return ComMDSetMetaDataA( hMDHandle, (LPBYTE)pszPathA, pmdrMDData );
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDGetMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen
    )
/*++

Routine Description:

    Get property of object

Arguments:

    hMDHandle - open handle
    pszMDPath - path to object
    pmdrMDData - metadata descriptor
    pdwMDRequiredDataLen - updated with required length to get property

Returns:

    status

--*/
{
    DWORD           RetCode;
    CDirPath        asPath;
    LPSTR           pszPath = (LPSTR)pszMDPath;
    POPEN_CTX       pOpenCtx;
    
    pOpenCtx = OPEN_CTX::MapHandleToContext( hMDHandle );

	// BugFix: 117745 Whistler
	//         Prefix bug pOpenCtx being used when it could be null
	//         EBK 5/15/2000
	if (pOpenCtx == NULL) 
	{
		RetCode = ERROR_INVALID_PARAMETER;
	}
    else if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((pmdrMDData == NULL) ||
        ((pmdrMDData->dwMDDataLen != 0) && (pmdrMDData->pbMDData == NULL)) ||
        ((pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH) &&
            !(pmdrMDData->dwMDAttributes & METADATA_INHERIT)))
    {
        RetCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        if ( asPath.Set( hMDHandle ? pOpenCtx->GetPath() : "" ) &&
             asPath.Append( pszMDPath ? (LPSTR)pszMDPath : "" ))
        {
            RetCode = NseGetProp( asPath.Get(), pmdrMDData, pdwMDRequiredDataLen )
                    ? ERROR_SUCCESS : GetLastError();
        }
        else
        {
            RetCode = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return ReturnCodeToHresult(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDGetMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    STRAU   strauPath;
    LPSTR   pszPathA = NULL;

    if ( pszMDPath )
    {
        if ( !strauPath.Copy( (LPWSTR)pszMDPath ) )
        {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }

        pszPathA = strauPath.QueryStrA();

        if (pszPathA == NULL) {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return ComMDGetMetaDataA( hMDHandle, (LPBYTE)pszPathA, pmdrMDData, pdwMDRequiredDataLen );
}



HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDEnumMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen
    )
/*++

Routine Description:

    Enumerate properties of object

Arguments:

    hMDHandle - open handle
    pszMDPath - path to object
    pmdrMDData - metadata descriptor
    dwMDEnumDataIndex - index to property
    pdwMDRequiredDataLen - updated with required length to get property

Returns:

    status

--*/
{
    DWORD           RetCode;
    LPSTR           pszPath = (LPSTR)pszMDPath;
    CDirPath        asPath;
    POPEN_CTX       pOpenCtx;
    
    pOpenCtx = OPEN_CTX::MapHandleToContext( hMDHandle );

	// BugFix: 117715 Whistler
	//         Prefix bug pOpenCtx being used when it could be null
	//         EBK 5/15/2000
	if (pOpenCtx == NULL) 
	{
		RetCode = ERROR_INVALID_PARAMETER;
	}
    else if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((pmdrMDData == NULL) ||
        ((pmdrMDData->dwMDDataLen != 0) && (pmdrMDData->pbMDData == NULL)) ||
        ((pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH) &&
            !(pmdrMDData->dwMDAttributes & METADATA_INHERIT)))
    {
        RetCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        if ( asPath.Set( pOpenCtx->GetPath() ) &&
                 asPath.Append( (LPSTR)pszMDPath ) )
        {
            RetCode = NseGetPropByIndex( asPath.Get(), pmdrMDData, dwMDEnumDataIndex, pdwMDRequiredDataLen )
                    ? ERROR_SUCCESS : GetLastError();
        }
        else
        {
            RetCode = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return ReturnCodeToHresult(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDEnumMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    STRAU   strauPath;
    LPSTR   pszPathA = NULL;

    if ( pszMDPath )
    {
        if ( !strauPath.Copy( (LPWSTR)pszMDPath ) )
        {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }

        pszPathA = strauPath.QueryStrA();

        if (pszPathA == NULL) {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return ComMDEnumMetaDataA( hMDHandle, (LPBYTE)pszPathA, pmdrMDData, dwMDEnumDataIndex, pdwMDRequiredDataLen );
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDDeleteMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType
    )
/*++

Routine Description:

    Not supported

Arguments:

Returns:

    error : either NSE not initialized or not supported

--*/
{
    DWORD   RetCode;
    LPSTR   pszPath = (LPSTR)pszMDPath;

    if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else
    {
        RetCode = ERROR_NOT_SUPPORTED;
    }

    return ReturnCodeToHresult(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDDeleteMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType)
{
    STRAU   strauPath;
    LPSTR   pszPathA = NULL;

    if ( pszMDPath )
    {
        if ( !strauPath.Copy( (LPWSTR)pszMDPath ) )
        {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }

        pszPathA = strauPath.QueryStrA();

        if (pszPathA == NULL) {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return ComMDDeleteMetaDataA( hMDHandle, (LPBYTE)pszPathA, dwMDIdentifier, dwMDDataType );
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDGetAllMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize
    )
/*++

Routine Description:

    Get all properties of object

Arguments:

    hMDHandle - open handle
    pszMDPath - path to object
    dwMDAttributes - metadata attribute, ignored
    dwMDUserType - metadata user type, ignored
    dwMDDataType - metadata data type, ignored
    pdwMDNumDataEntries - updated with count of properties
    pdwMDDataSetNumber - ignored
    dwMDBufferSize - size of pbBuffer
    pbBuffer - buffer where to store properties descriptor and values
    pdwMDRequiredBufferSize - updated with required length of buffer

Returns:

    status

--*/
{
    DWORD           RetCode;
    CDirPath        asPath;
    POPEN_CTX       pOpenCtx;
    
    pOpenCtx = OPEN_CTX::MapHandleToContext( hMDHandle );

	// BugFix: 117707 Whistler
	//         Prefix bug pOpenCtx being used when it could be null
	//         EBK 5/15/2000
	if (pOpenCtx == NULL) 
	{
		RetCode = ERROR_INVALID_PARAMETER;
	}
    else if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((pdwMDNumDataEntries == NULL) || ((dwMDBufferSize != 0) && (pbBuffer == NULL)) ||
        ((dwMDAttributes & METADATA_PARTIAL_PATH) && !(dwMDAttributes & METADATA_INHERIT)))
    {
        RetCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        if ( asPath.Set( pOpenCtx->GetPath() ) &&
                 asPath.Append( (LPSTR)pszMDPath ) )
        {
            RetCode = NseGetAllProp( asPath.Get(),
                    dwMDAttributes,
                    dwMDUserType,
                    dwMDDataType,
                    pdwMDNumDataEntries,
                    pdwMDDataSetNumber,
                    dwMDBufferSize,
                    pbBuffer,
                    pdwMDRequiredBufferSize
                    )
                    ? ERROR_SUCCESS : GetLastError();
        }
        else
        {
            RetCode = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return ReturnCodeToHresult(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDGetAllMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    STRAU   strauPath;
    LPSTR   pszPathA = NULL;

    if ( pszMDPath )
    {
        if ( !strauPath.Copy( (LPWSTR)pszMDPath ) )
        {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }

        pszPathA = strauPath.QueryStrA();

        if (pszPathA == NULL) {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return ComMDGetAllMetaDataA( hMDHandle,
                                 (LPBYTE)pszPathA,
                                 dwMDAttributes,
                                 dwMDUserType,
                                 dwMDDataType,
                                 pdwMDNumDataEntries,
                                 pdwMDDataSetNumber,
                                 dwMDBufferSize,
                                 pbBuffer,
                                 pdwMDRequiredBufferSize );
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDDeleteAllMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType
    )
/*++

Routine Description:

    Not supported

Arguments:

Returns:

    error : either NSE not initialized or not supported

--*/
{
    DWORD RetCode;

    if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else
    {
        RetCode = ERROR_NOT_SUPPORTED;
    }

    return ReturnCodeToHresult(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDDeleteAllMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType)
{
    return ReturnCodeToHresult(ERROR_NOT_SUPPORTED);
}


HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDCopyMetaDataA(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in] */ unsigned char __RPC_FAR *pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in] */ unsigned char __RPC_FAR *pszMDDestPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ BOOL bCopyFlag
    )
/*++

Routine Description:

    Not supported

Arguments:

Returns:

    error : either NSE not initialized or not supported

--*/
{
    DWORD RetCode;

    if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((!bCopyFlag) && (dwMDAttributes & METADATA_INHERIT)) ||
        ((dwMDAttributes & METADATA_PARTIAL_PATH) && !(dwMDAttributes & METADATA_INHERIT)))
    {
        RetCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        RetCode = ERROR_NOT_SUPPORTED;
    }

    return ReturnCodeToHresult(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDCopyMetaDataW(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ LPCWSTR pszMDDestPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ReturnCodeToHresult(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDGetMetaDataPathsA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pszMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    return ReturnCodeToHresult(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDGetMetaDataPathsW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ LPWSTR pszMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize)
{
    return ReturnCodeToHresult(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDOpenMetaObjectA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDAccessRequested,
    /* [in] */ DWORD dwMDTimeOut,
    /* [out] */ PMETADATA_HANDLE phMDNewHandle
    )
/*++

Routine Description:

    Open access to metadata

Arguments:

    hMDHandle - open handle where to open
    pszMDPath - path to open
    dwMDAccessRequested - access rights, ignored
    dwMDTimeOut - ignored
    phMDNewHandle - updated with new handle

Returns:

    status

--*/
{
    DWORD               RetCode;
    POPEN_CTX           pOpCtx;

    if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((phMDNewHandle == NULL) || ((dwMDAccessRequested & (METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE)) == 0))
    {
        RetCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        if ( pOpCtx = new OPEN_CTX(dwMDAccessRequested) )
        {
            if ( pOpCtx->GetHandle() &&
                 pOpCtx->SetPath( "" ) &&
                 pOpCtx->AppendPath( pszMDPath ? (LPSTR)pszMDPath : "") )
            {
                CDirPath     asTemp;

                asTemp.Set( pOpCtx->GetPath() );

                for ( ;; )
                {	
					// BugFix: 117700 Whistler
					//         Prefix bug asTemp.Get being null
					//         EBK 5/15/2000

					if (asTemp.Get() == NULL)
					{
						RetCode = ERROR_NOT_ENOUGH_MEMORY;
						break;
					}

                    if ( NseOpenObjs( asTemp.Get() ) )
                    {
                        *phMDNewHandle = pOpCtx->GetHandle();
                        RetCode = ERROR_SUCCESS;
                        break;
                    }
                    else
                    {
                        RetCode = GetLastError();
                        if ( RetCode == ERROR_PATH_BUSY &&
                             dwMDTimeOut )
                        {
                            DWORD dwDelay = min( dwMDTimeOut, 100 );
                            Sleep( dwDelay );
                            dwMDTimeOut -= dwDelay;
                        }
                        else
                        {
                            break;
                        }
                    }
                }

                if ( RetCode != ERROR_SUCCESS )
                {
                    delete pOpCtx;
                }
            }
            else
            {
                delete pOpCtx;
                RetCode = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else
        {
            RetCode = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return ReturnCodeToHresult(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDOpenMetaObjectW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAccessRequested,
    /* [in] */ DWORD dwMDTimeOut,
    /* [out] */ PMETADATA_HANDLE phMDNewHandle)
{
    STRAU   strauPath;
    LPSTR   pszPathA = NULL;

    if ( pszMDPath )
    {
        if ( !strauPath.Copy( (LPWSTR)pszMDPath ) )
        {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }

        pszPathA = strauPath.QueryStrA();

        if (pszPathA == NULL) {
            return ReturnCodeToHresult(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return ComMDOpenMetaObjectA( hMDHandle,
                                 (LPBYTE)pszPathA,
                                 dwMDAccessRequested,
                                 dwMDTimeOut,
                                 phMDNewHandle );
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDCloseMetaObject(
    /* [in] */ METADATA_HANDLE hMDHandle
    )
/*++

Routine Description:

    Close access to metadata

Arguments:

    hMDHandle - open handle to close

Returns:

    status

--*/
{
    DWORD RetCode;
    BOOL bPulseWrite = FALSE;
    BOOL bPulseRead = FALSE;

    if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else
    {
        NseCloseObjs( TRUE );
        delete OPEN_CTX::MapHandleToContext( hMDHandle );
        RetCode = ERROR_SUCCESS;
    }

    return ReturnCodeToHresult(RetCode);
}


HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDChangePermissions(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [in] */ DWORD dwMDTimeOut,
    /* [in] */ DWORD dwMDAccessRequested
    )
/*++

Routine Description:

    Not supported

Arguments:

Returns:

    error : either NSE not initialized or not supported

--*/
{
    DWORD RetCode = ERROR_SUCCESS;

    if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else
    {
        RetCode = ERROR_NOT_SUPPORTED;
    }

    return ReturnCodeToHresult(RetCode);
}


HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDSaveData(
    METADATA_HANDLE hMDHandle
    )
/*++

Routine Description:

    Save data to persistent storage

Arguments:

    None

Returns:

    status

--*/
{
    DWORD RetCode = ERROR_SUCCESS;
    if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else
    {
        if ( !NseSaveObjs() )
        {
            RetCode = GetLastError();
        }
    }

    return ReturnCodeToHresult(RetCode);
}


HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDGetHandleInfo(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [out] */ PMETADATA_HANDLE_INFO pmdhiInfo
    )
/*++

Routine Description:

    Not supported

Arguments:

Returns:

    error : either NSE not initialized or not supported

--*/
{
    DWORD RetCode = ERROR_SUCCESS;

    if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pmdhiInfo == NULL)
    {
        RetCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        RetCode = ERROR_NOT_SUPPORTED;
    }

    return ReturnCodeToHresult(RetCode);
}


HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDGetSystemChangeNumber(
    /* [out] */ DWORD __RPC_FAR *pdwSystemChangeNumber
    )
/*++

Routine Description:

    Not supported

Arguments:

Returns:

    error : either NSE not initialized or not supported

--*/
{
    DWORD RetCode = ERROR_SUCCESS;

    if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pdwSystemChangeNumber == NULL)
    {
        RetCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        RetCode = ERROR_NOT_SUPPORTED;
    }

    return ReturnCodeToHresult(RetCode);
}


HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDGetDataSetNumberA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber
    )
/*++

Routine Description:

    Not supported

Arguments:

Returns:

    error : either NSE not initialized or not supported

--*/
{
    DWORD RetCode;
    LPSTR pszPath = (LPSTR)pszMDPath;

    if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else if (pdwMDDataSetNumber == NULL)
    {
        RetCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        RetCode = ERROR_NOT_SUPPORTED;
    }

    return ReturnCodeToHresult(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDGetDataSetNumberW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber)
{
    return ReturnCodeToHresult(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDAddRefReferenceData(
    /* [in] */ DWORD dwMDDataTag
    )
/*++

Routine Description:

    Not supported

Arguments:

Returns:

    error : either NSE not initialized or not supported

--*/
{
    DWORD RetCode = ERROR_SUCCESS;

    if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataTag == 0)
    {
        RetCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        RetCode = ERROR_NOT_SUPPORTED;
    }

    return ReturnCodeToHresult(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDReleaseReferenceData(
    /* [in] */ DWORD dwMDDataTag
    )
/*++

Routine Description:

    Not supported

Arguments:

Returns:

    error : either NSE not initialized or not supported

--*/
{
    DWORD RetCode = ERROR_SUCCESS;

    if (g_dwInitialized == 0)
    {
        RetCode = MD_ERROR_NOT_INITIALIZED;
    }
    else if (dwMDDataTag == 0)
    {
        RetCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        RetCode = ERROR_NOT_SUPPORTED;
    }

    return ReturnCodeToHresult(RetCode);
}

inline HRESULT
NSEPCOM::ReturnCodeToHresult(
    DWORD dwReturnCode
    )
/*++

Routine Description:

    Convert NT error code to HRESULT

Arguments:

    dwReturnCode - NT Error code

Return Value:

    HRESULT

--*/
{
    DWORD hrReturn;

    if (dwReturnCode < 0x10000)
    {
        hrReturn = HRESULT_FROM_WIN32(dwReturnCode);
    }
    else
    {
        hrReturn = (DWORD)E_FAIL;
    }

    return(hrReturn);
}


HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDSetLastChangeTimeA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ PFILETIME pftMDLastChangeTime
    )
/*++

Routine Description:

    Set the last change time associated with a Meta Object.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the affected meta object, relative to the path of Handle.

    LastChangeTime - The new change time for the meta object.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_NOT_SUPPORTED

Notes:
Last change times are also updated whenever data or child objects are set, added, or deleted.
--*/
{
    DWORD RetCode = ERROR_NOT_SUPPORTED;

    return RETURNCODETOHRESULT(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDSetLastChangeTimeW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PFILETIME pftMDLastChangeTime)
{
    return ReturnCodeToHresult(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDGetLastChangeTimeA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out] */ PFILETIME pftMDLastChangeTime
    )
/*++

Routine Description:

    Set the last change time associated with a Meta Object.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the affected meta object, relative to the path of Handle.

    LastChangeTime - Place to return the change time for the meta object.

Return Value:
    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_NOT_SUPPORTED

Notes:
Last change times are also updated whenever data or child objects are set, added, or deleted.
--*/
{
    DWORD RetCode = ERROR_NOT_SUPPORTED;

    return RETURNCODETOHRESULT(RetCode);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDGetLastChangeTimeW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out] */ PFILETIME pftMDLastChangeTime)
{
    return ReturnCodeToHresult(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDBackupA(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ReturnCodeToHresult(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDBackupW(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ReturnCodeToHresult(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDRestoreA(
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    return ComMDRestoreW( (LPCWSTR)pszMDBackupLocation, dwMDVersion, dwMDFlags );
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDRestoreW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags)
{
    //
    // disregard current in-memory changes
    //
    // Any open handle ( should be at most one, as NSEPM reject Open request
    // if an open handle exist ) will cause a small memory leak ( the open context )
    // because ADMCOM disable handles w/o closing them.
    //

    NseCloseObjs( FALSE );

    return S_OK;
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDEnumBackupsA(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [out] */ DWORD *pdwMDVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex)
{
    return ReturnCodeToHresult(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDEnumBackupsW(
            /* [size_is (MD_BACKUP_MAX_LEN)][in, out] */ LPWSTR pszMDBackupLocation,
            /* [out] */ DWORD *pdwVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex)
{
    return ReturnCodeToHresult(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDDeleteBackupA(
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion)
{
    return ReturnCodeToHresult(ERROR_NOT_SUPPORTED);
}

HRESULT STDMETHODCALLTYPE
NSEPCOM::ComMDDeleteBackupW(
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion)
{
    return ReturnCodeToHresult(ERROR_NOT_SUPPORTED);
}

#if 0

HRESULT
NSEPCOM::SetMdIf(
    LPBYTE pMd
    )
/*++

Routine Description:

    Set the metadata interface to be used by NSE

Arguments:

    pMD - ptr to IMDCOM interface

Return Value:

    status

--*/
{
    m_pMdIf = (IMDCOM*)pMd;
    g_pMdIf = (IMDCOM*)pMd;

#if defined(TEST_ADMACL)
    InitializeAdminAcl( g_pMdIf );
#endif

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\restart\iisrsta\common.c ===
/*++

Module Name:

    common.c

Abstract:

    This module contains common apis used by tlist & kill.

--*/



/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1994-1998 Microsoft Corporation.
*       All rights reserved.
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

#include <windows.h>
#include <winperf.h>   // for Windows NT
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if 0
#include <tlhelp32.h>  // for Windows 95
#endif

#include "common.h"

#include "inetdbgp.h"

//
// RETURNCODETOHRESULT() maps a return code to an HRESULT. If the return
// code is a Win32 error (identified by a zero high word) then it is mapped
// using the standard HRESULT_FROM_WIN32() macro. Otherwise, the return
// code is assumed to already be an HRESULT and is returned unchanged.
//

#define RETURNCODETOHRESULT(rc)                             \
            (((rc) < 0x10000)                               \
                ? HRESULT_FROM_WIN32(rc)                    \
                : (rc))
//
// manifest constants
//
#define INITIAL_SIZE        51200
#define EXTEND_SIZE         25600
#define REGKEY_PERF         _T("software\\microsoft\\windows nt\\currentversion\\perflib")
#define REGSUBKEY_COUNTERS  _T("Counters")
#define PROCESS_COUNTER     _T("process")
#define PROCESSID_COUNTER   _T("id process")
#define UNKNOWN_TASK        _T("unknown")
#define KILL_VERIFY_TIMEOUT (10*1000)
#define KILL_VERIFY_DELAY   100

typedef struct _SearchWin {
    LPCTSTR pExeName;
    LPDWORD pdwPid ;
    HWND*   phwnd;
} SearchWin ;


typedef struct _SearchMod {
    LPSTR   pExeName;
    LPBOOL  pfFound;
} SearchMod ;


//
// prototypes
//

BOOL CALLBACK
EnumWindowsProc2(
    HWND    hwnd,
    LPARAM   lParam
    );

HRESULT
IsDllInProcess( 
    DWORD   dwProcessId,
    LPSTR   pszName,
    LPBOOL  pfFound
    );

#if 0

//
// Function pointer types for accessing Toolhelp32 functions dynamically.
// By dynamically accessing these functions, we can do so only on Windows
// 95 and still run on Windows NT, which does not have these functions.
//
typedef BOOL (WINAPI *PROCESSWALK)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
typedef HANDLE (WINAPI *CREATESNAPSHOT)(DWORD dwFlags, DWORD th32ProcessID);


//
// prototypes
//
BOOL CALLBACK
EnumWindowsProc(
    HWND    hwnd,
    DWORD   lParam
    );



DWORD
GetTaskList95(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks,
    LPTSTR      pName
    )

/*++

Routine Description:

    Provides an API for getting a list of tasks running at the time of the
    API call.  This function uses Toolhelp32to get the task list and is 
    therefore straight WIN32 calls that anyone can call.

Arguments:

    dwNumTasks       - maximum number of tasks that the pTask array can hold

Return Value:

    Number of tasks placed into the pTask array.

--*/

{
   CREATESNAPSHOT pCreateToolhelp32Snapshot = NULL;
   PROCESSWALK    pProcess32First           = NULL;
   PROCESSWALK    pProcess32Next            = NULL;

   HANDLE         hKernel        = NULL;
   HANDLE         hProcessSnap   = NULL;
   PROCESSENTRY32 pe32           = {0};
   DWORD          dwTaskCount    = 0;


   // Guarantee to the code later on that we'll enum at least one task.
   if (dwNumTasks == 0)
      return 0;

    // Obtain a module handle to KERNEL so that we can get the addresses of
    // the 32-bit Toolhelp functions we need.
    hKernel = GetModuleHandle(_T("KERNEL32.DLL"));

    if (hKernel)
    {
        pCreateToolhelp32Snapshot =
          (CREATESNAPSHOT)GetProcAddress(hKernel, "CreateToolhelp32Snapshot");

        pProcess32First = (PROCESSWALK)GetProcAddress(hKernel,
                                                      "Process32First");
        pProcess32Next  = (PROCESSWALK)GetProcAddress(hKernel,
                                                      "Process32Next");
    }
    
    // make sure we got addresses of all needed Toolhelp functions.
    if (!(pProcess32First && pProcess32Next && pCreateToolhelp32Snapshot))
       return 0;
       

    // Take a snapshot of all processes currently in the system.
    hProcessSnap = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hProcessSnap == (HANDLE)-1)
        return 0;

    // Walk the snapshot of processes and for each process, get information
    // to display.
    dwTaskCount = 0;
    pe32.dwSize = sizeof(PROCESSENTRY32);   // must be filled out before use
    if (pProcess32First(hProcessSnap, &pe32))
    {
        do
        {
            LPTSTR pCurChar;

            // strip path and leave executabe filename splitpath
            for (pCurChar = (pe32.szExeFile + lstrlen (pe32.szExeFile));
                 *pCurChar != _T('\\') && pCurChar != pe32.szExeFile; 
                 --pCurChar)

            lstrcpy(pTask -> ProcessName, pCurChar);
            pTask -> flags = 0;
            pTask -> dwProcessId = pe32.th32ProcessID;

            ++dwTaskCount;   // keep track of how many tasks we've got so far
            ++pTask;         // get to next task info block.
        }
        while (dwTaskCount < dwNumTasks && pProcess32Next(hProcessSnap, &pe32));
    }
    else
        dwTaskCount = 0;    // Couldn't walk the list of processes.

    // Don't forget to clean up the snapshot object...
    CloseHandle (hProcessSnap);

    return dwTaskCount;
}

#endif


HRESULT
GetTaskListNT(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks,
    LPTSTR      pName,
    LPDWORD     pdwNumTasks,
    BOOL        fKill,
    LPSTR       pszMandatoryModule
    )
/*++

Routine Description:

    Provides an API for getting a list of tasks running at the time of the
    API call.  This function uses the registry performance data to get the
    task list and is therefore straight WIN32 calls that anyone can call.

Arguments:

    pTask - updated with array of tasks if fKill is FALSE
    dwNumTasks - maximum number of tasks that the pTask array can hold
    pName - process name to look for
    pdwNumTasks - updated with count of tasks in pTask if fKill is FALSE
    fKill - TRUE to kill process instead of populating pTask
    pszMandatoryModule - if non NULL then this module must be loaded in the process space
        for it to be killed.

Return Value:

    Status

--*/
{
    DWORD                        rc;
    HKEY                         hKeyNames;
    DWORD                        dwType;
    DWORD                        dwSize;
    LPBYTE                       buf = NULL;
    TCHAR                        szSubKey[1024];
    LANGID                       lid;
    LPTSTR                       p;
    LPTSTR                       p2;
    PPERF_DATA_BLOCK             pPerf;
    PPERF_OBJECT_TYPE            pObj;
    PPERF_INSTANCE_DEFINITION    pInst;
    PPERF_COUNTER_BLOCK          pCounter;
    PPERF_COUNTER_DEFINITION     pCounterDef;
    DWORD                        i;
    DWORD                        dwProcessIdTitle;
    DWORD                        dwProcessIdCounter;
    TCHAR                        szProcessName[MAX_PATH];
//    DWORD                        dwLimit = dwNumTasks;
    DWORD                        dwNumMatchTasks = 0;
    BOOL                         fMatch;
    HRESULT                      hres = S_OK;



    //
    // Look for the list of counters.  Always use the neutral
    // English version, regardless of the local language.  We
    // are looking for some particular keys, and we are always
    // going to do our looking in English.  We are not going
    // to show the user the counter names, so there is no need
    // to go find the corresponding name in the local language.
    //
    lid = MAKELANGID( LANG_ENGLISH, SUBLANG_NEUTRAL );
    wsprintf( szSubKey, _T("%s\\%03x"), REGKEY_PERF, lid );
    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       szSubKey,
                       0,
                       KEY_READ,
                       &hKeyNames
                     );

    if (rc != ERROR_SUCCESS) 
    {
        hres = RETURNCODETOHRESULT( rc );
        goto exit;
    }

    //
    // get the buffer size for the counter names
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          NULL,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) 
    {
        hres = RETURNCODETOHRESULT( rc );
        goto exit;
    }

    //
    // allocate the counter names buffer
    //
    buf = (LPBYTE) malloc( dwSize );
    if (buf == NULL) 
    {
        hres = RETURNCODETOHRESULT( GetLastError() );
        goto exit;
    }
    memset( buf, 0, dwSize );

    //
    // read the counter names from the registry
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          buf,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) 
    {
        hres = RETURNCODETOHRESULT( GetLastError() );
        goto exit;
    }

    //
    // now loop thru the counter names looking for the following counters:
    //
    //      1.  "Process"           process name
    //      2.  "ID Process"        process id
    //
    // the buffer contains multiple null terminated strings and then
    // finally null terminated at the end.  the strings are in pairs of
    // counter number and counter name.
    //

    p = (LPTSTR)buf;
    while (*p) 
    {
        if (p > (LPTSTR)buf) 
        {
            for( p2=p-2; _istdigit(*p2); p2--) ;
        }
        if (lstrcmpi(p, PROCESS_COUNTER) == 0) 
        {
            //
            // look backwards for the counter number
            //
            for( p2=p-2; _istdigit(*p2); p2--) ;
            lstrcpy( szSubKey, p2+1 );
        }
        else if (lstrcmpi(p, PROCESSID_COUNTER) == 0) 
        {
            //
            // look backwards for the counter number
            //
            for( p2=p-2; _istdigit(*p2); p2--) ;
            dwProcessIdTitle = _ttol( p2+1 );
        }
        //
        // next string
        //
        p += (lstrlen(p) + 1);
    }

    //
    // free the counter names buffer
    //
    free( buf );


    //
    // allocate the initial buffer for the performance data
    //
    dwSize = INITIAL_SIZE;
    buf = malloc( dwSize );
    if (buf == NULL) 
    {
        hres = RETURNCODETOHRESULT( GetLastError() );
        goto exit;
    }
    memset( buf, 0, dwSize );


    while (TRUE) 
    {
        rc = RegQueryValueEx( HKEY_PERFORMANCE_DATA,
                              szSubKey,
                              NULL,
                              &dwType,
                              buf,
                              &dwSize
                            );

        pPerf = (PPERF_DATA_BLOCK) buf;

        //
        // check for success and valid perf data block signature
        //
        if ((rc == ERROR_SUCCESS) &&
            (dwSize > 0) &&
            (pPerf)->Signature[0] == (WCHAR)'P' &&
            (pPerf)->Signature[1] == (WCHAR)'E' &&
            (pPerf)->Signature[2] == (WCHAR)'R' &&
            (pPerf)->Signature[3] == (WCHAR)'F' ) 
        {
            break;
        }

        //
        // if buffer is not big enough, reallocate and try again
        //
        if (rc == ERROR_MORE_DATA) 
        {
            dwSize += EXTEND_SIZE;
            buf = realloc( buf, dwSize );
            memset( buf, 0, dwSize );
        }
        else 
        {
            goto exit;
        }
    }

    //
    // set the perf_object_type pointer
    //
    pObj = (PPERF_OBJECT_TYPE) ((LPBYTE)pPerf + pPerf->HeaderLength);

    //
    // loop thru the performance counter definition records looking
    // for the process id counter and then save its offset
    //
    pCounterDef = (PPERF_COUNTER_DEFINITION) ((DWORD_PTR)pObj + pObj->HeaderLength);
    for (i=0; i<(DWORD)pObj->NumCounters; i++) 
    {
        if (pCounterDef->CounterNameTitleIndex == dwProcessIdTitle) 
        {
            dwProcessIdCounter = pCounterDef->CounterOffset;
            break;
        }
        pCounterDef++;
    }

//    dwNumTasks = (DWORD)pObj->NumInstances;

    pInst = (PPERF_INSTANCE_DEFINITION) ((LPBYTE)pObj + pObj->DefinitionLength);

    //
    // loop thru the performance instance data extracting each process name
    // and process id
    //
    for (i=0; i<(DWORD)pObj->NumInstances; i++) 
    {

        //
        // pointer to the process name
        //
        p = (LPTSTR) ((LPBYTE)pInst + pInst->NameOffset);

#if !defined(_UNICODE)

        //
        // convert it to ascii
        //
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  (LPCWSTR)p,
                                  -1,
                                  szProcessName,
                                  sizeof(szProcessName),
                                  NULL,
                                  NULL
                                );

        p = szProcessName;

        if (!rc) 
        {
            //
	        // if we cant convert the string then use a default value
            //

            p = UNKNOWN_TASK;
        }
        else
#endif

        if ( lstrcmpi( p, pName ) == 0 
             && (fKill || dwNumMatchTasks < dwNumTasks) )
        {
            fMatch = TRUE;
        }
        else
        {
            fMatch = FALSE;
        }

        //
        // get the process id
        //

        pCounter = (PPERF_COUNTER_BLOCK) ((LPBYTE)pInst + pInst->ByteLength);

        if ( fMatch )
        {
            if ( fKill )
            {
                //
                // Kill process now, do not update pTask array
                //

                TASK_LIST   task;
                BOOL        fIsInProcess;
                
                task.dwProcessId = *((LPDWORD) ((LPBYTE)pCounter + dwProcessIdCounter));

                if ( pszMandatoryModule == NULL ||
                     ( SUCCEEDED( hres = IsDllInProcess( task.dwProcessId, pszMandatoryModule, &fIsInProcess ) ) &&
                       fIsInProcess ) )
                {
                    if ( FAILED(hres = KillProcess( &task, TRUE ) ) )
                    {
                        break;
                    }
                }
            }
            else
            {
                if (lstrlen(p)+1*sizeof(TCHAR) <= sizeof(pTask->ProcessName)) 
                {
                    lstrcpy( pTask->ProcessName, p );
#if 0
                    lstrcat( pTask->ProcessName, _T(".exe") );
#endif
                }
                else
                {
                    pTask->ProcessName[0] = '\0';
                }
                pTask->flags = 0;
                pTask->dwProcessId = *((LPDWORD) ((LPBYTE)pCounter + dwProcessIdCounter));
                if (pTask->dwProcessId == 0) 
                {
                    pTask->dwProcessId = (DWORD)-2;
                }
                pTask++;
            }

            ++dwNumMatchTasks;
        }

        //
        // next process
        //

        pInst = (PPERF_INSTANCE_DEFINITION) ((LPBYTE)pCounter + pCounter->ByteLength);
    }

 exit:
    if (buf) 
    {
        free( buf );
    }

    RegCloseKey( hKeyNames );
    RegCloseKey( HKEY_PERFORMANCE_DATA );

    *pdwNumTasks =  dwNumMatchTasks;

    return hres;
}


#if 0
BOOL
EnableDebugPriv95(
    VOID
    )

/*++

Routine Description:

    Changes the process's privilege so that kill works properly.

Arguments:


Return Value:

    TRUE             - success
    FALSE            - failure

Comments: 
    Always returns TRUE

--*/

{
   return TRUE;
}
#endif


BOOL
EnableDebugPrivNT(
    VOID
    )

/*++

Routine Description:

    Changes the process's privilege so that kill works properly.

Arguments:


Return Value:

    TRUE             - success
    FALSE            - failure

--*/

{
    HANDLE hToken;
    LUID DebugValue;
    TOKEN_PRIVILEGES tkp;


    //
    // Retrieve a handle of the access token
    //
    if (!OpenProcessToken(GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &hToken)) 
    {
        return FALSE;
    }

    //
    // Enable the SE_DEBUG_NAME privilege
    //
    if (!LookupPrivilegeValue((LPTSTR) NULL,
            SE_DEBUG_NAME,
            &DebugValue)) 
    {
        return FALSE;
    }

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = DebugValue;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges(hToken,
        FALSE,
        &tkp,
        sizeof(TOKEN_PRIVILEGES),
        (PTOKEN_PRIVILEGES) NULL,
        (PDWORD) NULL);

    //
    // The return value of AdjustTokenPrivileges can't be tested
    //

    if (GetLastError() != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
EnumModulesCallback(
    LPVOID          pParam,
    PMODULE_INFO    pModuleInfo
    )
/*++

Routine Description:

    Called by module enumerator with info on current module

Arguments:

    pParam - as specified in the call to EnumModules()
    pModuleInfo - module information

Return Value:

    TRUE to continue enumeration, FALSE to stop it

--*/
{
#if defined(VERBOSE_DEBUG)
    OutputDebugStringA( pModuleInfo->BaseName );
#endif

    if ( !_strcmpi( pModuleInfo->BaseName, ((SearchMod*)pParam)->pExeName ) )
    {
        *((SearchMod*)pParam)->pfFound = TRUE;

#if defined(VERBOSE_DEBUG)
        OutputDebugString( _T("found!") );
#endif

        return FALSE;   // stop enumeration
    }

    return TRUE;
}


HRESULT
IsDllInProcess( 
    DWORD   dwProcessId,
    LPSTR   pszName,
    LPBOOL  pfFound
    )
/*++

Routine Description:

    Check if a module ( e.g. DLL ) exists in specified process

Arguments:

    dwProcessId - process ID to scan for module pszName
    pszName - module name to look for, e.g. "wam.dll"
    pfFound - updated with TRUE if pszName found in process dwProcessId
              valid only if functions succeed.

Return Value:

    Status. 

--*/
{
    HANDLE              hProcess;
    HRESULT             hres = S_OK;
    SearchMod           sm;

    hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, dwProcessId );

    if ( hProcess == NULL )
    {
        return RETURNCODETOHRESULT( GetLastError() );
    }

    sm.pExeName = pszName;
    sm.pfFound= pfFound;
    *pfFound = FALSE;

    if ( !EnumModules( hProcess, EnumModulesCallback, (LPVOID)&sm ) )
    {
        hres = E_FAIL;
    }

    CloseHandle( hProcess );

    return hres;
}


HRESULT
KillProcess(
    PTASK_LIST tlist,
    BOOL       fForce
    )
{
    HANDLE              hProcess;
    HRESULT             hres = S_OK;
    DWORD               dwRetry;


    hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, tlist->dwProcessId );

    if ( hProcess == NULL )
    {
#if defined(VERBOSE_DEBUG)
        OutputDebugString(_T("KillProcess: can't open process"));
#endif
        hres = RETURNCODETOHRESULT( GetLastError() );
    }

    if ( SUCCEEDED(hres) )
    {
        if (fForce || !tlist->hwnd) 
        {
            if (!TerminateProcess( hProcess, 1 )) 
            {
                //
                // If error code is access denied then this is likely due to debugger being attached to process
                // so change error code to reflect that. Otherwise error message would be confusing
                //

                if ( GetLastError() == ERROR_ACCESS_DENIED )
                {
                    hres = RETURNCODETOHRESULT( ERROR_SERVICE_CANNOT_ACCEPT_CTRL );
                }
                else
                {
                    hres = RETURNCODETOHRESULT( GetLastError() );
                }
#if defined(VERBOSE_DEBUG)
                OutputDebugString(_T("TerminateProcess failed"));
#endif
            }
            else
            {
#if defined(VERBOSE_DEBUG)
                OutputDebugString(_T("TerminateProcess OK"));
#endif
                hres = S_OK;
            }
        }
        else
        {
#if defined(VERBOSE_DEBUG)
            OutputDebugString(_T("KillProcess: post message"));
#endif
            PostMessage( tlist->hwnd, WM_CLOSE, 0, 0 );

            if ( WaitForSingleObject( hProcess, 5*1000 ) != WAIT_OBJECT_0 )
            {
                if (!TerminateProcess( hProcess, 1 )) 
                {
                    hres = RETURNCODETOHRESULT( GetLastError() );
                }
                else
                {
                    //
                    // Verify process is signaled terminated
                    //

                    if ( WaitForSingleObject( hProcess, 1*1000 ) != WAIT_OBJECT_0 )
                    {
                        hres = RETURNCODETOHRESULT( GetLastError() );
                    }
                    else
                    {
                        hres = S_OK;
                    }
                }
            }
        }
    }

    CloseHandle( hProcess );

    if ( SUCCEEDED( hres ) )
    {
        for ( dwRetry = 0 ; dwRetry < KILL_VERIFY_TIMEOUT ; )
        {
            //
            // Verify process is really terminated by checking we can't open it anymore
            // Necessary because killing process while debugger or system exception window is used
            // will cause TerminateProcess() to return TRUE even if process not really terminated.
            //

		    Sleep( KILL_VERIFY_DELAY );
            dwRetry += KILL_VERIFY_DELAY;

            hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, tlist->dwProcessId );

            if ( hProcess == NULL )
            {
                break;
            }
            else
            {
                CloseHandle( hProcess );
            }
        }

        if ( dwRetry >= KILL_VERIFY_TIMEOUT )
        {
#if defined(VERBOSE_DEBUG)
            OutputDebugString(_T("Can reopen process!"));
#endif
            hres = RETURNCODETOHRESULT( ERROR_SERVICE_REQUEST_TIMEOUT );
        }
    }

#if defined(VERBOSE_DEBUG)
    if ( FAILED(hres) )
    {
        OutputDebugString(_T("KillProcess failed"));
    }
#endif

    return hres;
}


VOID
GetPidFromTitle(
    LPDWORD     pdwPid,
    HWND*       phwnd,
    LPCTSTR     pExeName
    )
/*++

Routine Description:

    Callback function for window enumeration.

Arguments:

    pdwPid - updated with process ID of window matching window name or 0 if window not found
    phwnd - updated with window handle matching searched window name
    pExeName - window name to look for. Only the # of char present in this name will be 
               used during checking for a match ( e.g. "inetinfo.exe" will match "inetinfo.exe - Application error"

Return Value:

    None. *pdwPid will be 0 if no match is found

--*/
{
    SearchWin   sw;

    sw.pdwPid = pdwPid;
    sw.phwnd = phwnd;
    sw.pExeName = pExeName;
    *pdwPid = 0;

    //
    // enumerate all windows
    //
    EnumWindows( (WNDENUMPROC)EnumWindowsProc2, (LPARAM) &sw );
}



BOOL CALLBACK
EnumWindowsProc2(
    HWND    hwnd,
    LPARAM   lParam
    )
/*++

Routine Description:

    Callback function for window enumeration.

Arguments:

    hwnd             - window handle
    lParam           - ptr to SearchWin

Return Value:

    TRUE  - continues the enumeration

--*/
{
    DWORD             pid = 0;
    DWORD             i;
    TCHAR             buf[TITLE_SIZE];
    SearchWin*        psw = (SearchWin*)lParam;

    //
    // get the processid for this window
    //

    if (!GetWindowThreadProcessId( hwnd, &pid )) 
    {
#if defined(VERBOSE_DEBUG)
        OutputDebugString(_T("can't get pid"));
#endif
        return TRUE;
    }

    if (GetWindowText( hwnd, buf, sizeof(buf)/sizeof(TCHAR) ))
    {
        if ( lstrlen( buf ) > lstrlen( psw->pExeName ) )
        {
            buf[lstrlen( psw->pExeName )] = _T('\0');
        }

#if defined(VERBOSE_DEBUG)
        OutputDebugString(buf);
#endif

        if ( !lstrcmpi( psw->pExeName, buf ) )
        {
#if defined(VERBOSE_DEBUG)
            OutputDebugString(_T("Found it!"));
#endif
            *psw->phwnd = hwnd;
            *psw->pdwPid = pid;
        }
    }

    return TRUE;
}


#if 0

VOID
GetWindowTitles(
    PTASK_LIST_ENUM te
    )
{
    //
    // enumerate all windows
    //
    EnumWindows( (WNDENUMPROC)EnumWindowsProc, (LPARAM) te );
}



BOOL CALLBACK
EnumWindowsProc(
    HWND    hwnd,
    DWORD   lParam
    )

/*++

Routine Description:

    Callback function for window enumeration.

Arguments:

    hwnd             - window handle
    lParam           - ** not used **

Return Value:

    TRUE  - continues the enumeration

--*/

{
    DWORD             pid = 0;
    DWORD             i;
    TCHAR             buf[TITLE_SIZE];
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    PTASK_LIST        tlist = te->tlist;
    DWORD             numTasks = te->numtasks;


    //
    // get the processid for this window
    //
    if (!GetWindowThreadProcessId( hwnd, &pid )) 
    {
        return TRUE;
    }

    //
    // look for the task in the task list for this window
    //
    for (i=0; i<numTasks; i++) 
    {
        if (tlist[i].dwProcessId == pid) 
        {
            tlist[i].hwnd = hwnd;
            //
	    // we found the task so lets try to get the
            // window text
            //
            if (GetWindowText( tlist[i].hwnd, buf, sizeof(buf)/sizeof(TCHAR) )) 
            {
                //
		        // got it, so lets save it
                //
                lstrcpy( tlist[i].WindowTitle, buf );
            }
            break;
        }
    }

    //
    // continue the enumeration
    //
    return TRUE;
}


#if defined(_UNICODE)
//#define _totupper(a) towupper(a)
#else
//#define _totupper(a) _toupper(a)
#endif

BOOL
MatchPattern(
    TCHAR* String,
    TCHAR* Pattern
    )
{
    TCHAR   c, p, l;

    for (; ;) {
        switch (p = *Pattern++) {
            case 0:                             // end of pattern
                return *String ? FALSE : TRUE;  // if end of string TRUE

            case _T('*'):
                while (*String) {               // match zero or more char
                    if (MatchPattern (String++, Pattern))
                        return TRUE;
                }
                return MatchPattern (String, Pattern);

            case _T('?'):
                if (*String++ == 0)             // match any one char
                    return FALSE;                   // not end of string
                break;

            case _T('['):
                if ( (c = *String++) == 0)      // match char set
                    return FALSE;                   // syntax

                c = _totupper(c);
                l = 0;
                while (p = *Pattern++) {
                    if (p == _T(']'))               // if end of char set, then
                        return FALSE;           // no match found

                    if (p == _T('-')) {             // check a range of chars?
                        p = *Pattern;           // get high limit of range
                        if (p == 0  ||  p == _T(']'))
                            return FALSE;           // syntax

                        if (c >= l  &&  c <= p)
                            break;              // if in range, move on
                    }

                    l = p;
                    if (c == p)                 // if char matches this element
                        break;                  // move on
                }

                while (p  &&  p != _T(']'))         // got a match in char set
                    p = *Pattern++;             // skip to end of set

                break;

            default:
                c = *String++;
                if (_totupper(c) != p)            // check for exact char
                    return FALSE;                   // not a match

                break;
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\restart\cmdline\iisrsta.cxx ===
/*
    IisRsta.cxx

    Command line utility for access to IIisServiceControl

    FILE HISTORY:
        Phillich    06-Oct-1998     Created

*/

#define INITGUID
#include    <windows.h>
#include    <tchar.h>
#include    <stdio.h>
#include    <ole2.h>
#include    <locale.h>
#include    "iisrsta.h"
#include    "iisrstam.h"

typedef BOOL (*PFNQUERYSERVICECONFIG2)(SC_HANDLE,DWORD,LPBYTE,DWORD,LPDWORD) ;
typedef BOOL (*PFNCHANGESERVICECONFIG2)(SC_HANDLE,DWORD,LPVOID);

//
// HRESULTTOWIN32() maps an HRESULT to a Win32 error. If the facility code
// of the HRESULT is FACILITY_WIN32, then the code portion (i.e. the
// original Win32 error) is returned. Otherwise, the original HRESULT is
// returned unchagned.
//

#define HRESULTTOWIN32(hres)                                \
            ((HRESULT_FACILITY(hres) == FACILITY_WIN32)     \
                ? HRESULT_CODE(hres)                        \
                : (hres))


//
// RETURNCODETOHRESULT() maps a return code to an HRESULT. If the return
// code is a Win32 error (identified by a zero high word) then it is mapped
// using the standard HRESULT_FROM_WIN32() macro. Otherwise, the return
// code is assumed to already be an HRESULT and is returned unchanged.
//

#define RETURNCODETOHRESULT(rc)                             \
            (((rc) < 0x10000)                               \
                ? HRESULT_FROM_WIN32(rc)                    \
                : (rc))

//
// Helper functions
//


VOID
DisplayErrorMessage(
    DWORD   dwErr
    )
/*++

    DisplayErrorMessage

        Display error message associated with error code

    Arguments:

        dwErr  - Win32 error code

    Returns:

        Nothing

--*/
{
    LPTSTR  pErr;

    if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPTSTR)&pErr,
            0,
            NULL ) )
    {
        LPTSTR   p;

        if ( p = _tcschr( pErr, TEXT('\r') ) )
        {
            *p = TEXT('\0');
        }
        _fputts( pErr, stdout );

        LocalFree( pErr );
    }
}


VOID
PrintMessage(
    DWORD   dwId,
    DWORD   dwParams,
    LPVOID* pParams
    )
/*++

    PrintMessage

        Print message ( from message file ) with optional parameters

    Arguments:

        dwId - message ID
        dwParams - # of params in pParams
        pParams - ptr to array of parameters

    Returns:

        Nothing

--*/
{
    LPTSTR  pBuf;

    if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        (LPCVOID)NULL,  //GetModuleHandle(NULL),
                        dwId,
                        0,
                        (LPTSTR)&pBuf,
                        dwParams,
                        (va_list *)pParams ) )
    {
        _fputts( pBuf, stdout );

        LocalFree( pBuf );
    }
}


VOID
CmdError( 
    DWORD   dwId,
    HRESULT hRes 
    )
/*++

    CmdError

        Display message followed by error description ( error message + numerical code )

    Arguments:

        dwId - message ID
        hRes - error code

    Returns:

        Nothing

--*/
{
    TCHAR   achBuf[128];

    PrintMessage( dwId, 0, NULL );

    if ( hRes == RETURNCODETOHRESULT( ERROR_RESOURCE_DISABLED ) )
    {
        PrintMessage( IRSTASTR_REMOTE_DISABLED, 0, NULL );
    }
    else if ( hRes == RETURNCODETOHRESULT( ERROR_ACCESS_DENIED ) )
    {
        PrintMessage( IRSTASTR_ACCESS_DENIED, 0, NULL );
    }
    else if ( hRes == RETURNCODETOHRESULT( ERROR_SERVICE_NOT_ACTIVE ) )
    {
        PrintMessage( IRSTASTR_IISADMIN_DISABLED, 0, NULL );
    }
    else
    {
        DisplayErrorMessage( HRESULTTOWIN32( hRes ) );
        wsprintf( achBuf, _T(" (%u, %x)\n"), (DWORD)hRes, (DWORD)hRes );
        _fputts( achBuf, stdout );
    }
}


LPTSTR
GetString(
    DWORD   dwId
    )
/*++

    GetString

        Retrieve message content

    Arguments:

        dwId - message ID

    Returns:

        Ptr to message. Must be freed using LocalFree()

--*/
{
#if 0
    TCHAR   aBuf[32];

    aBuf[0] = TEXT('#');
    _ultot( dwId, aBuf + 1, 10 );

    return (LPTSTR)LoadResource( NULL, FindResourceEx( NULL, RT_MESSAGETABLE, aBuf, MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL) ) );
#else
    LPTSTR  pBuf;

    if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE,
                        (LPCVOID)NULL,
                        dwId,
                        0,
                        (LPTSTR)&pBuf,
                        0,
                        NULL ) )
    {
        LPTSTR   p;

        if ( p = _tcschr( pBuf, TEXT('\r') ) )
        {
            *p = TEXT('\0');
        }
        return pBuf;
    }

    return NULL;
#endif
}



HRESULT
DeserializeEnumServiceBuffer( 
    LPBYTE                          pbInBuffer,
    DWORD                           dwNumServices,
    LPBYTE                          pbBuffer,
    DWORD                           dwBufferSize,
    LPDWORD                         pdwMDRequiredBufferSize 
    )
/*++

    DeserializeEnumServiceBuffer

        Deserialize array of SERIALIZED_ENUM_SERVICE_STATUS to buffer,
        replacing offset in buffer by ptr

    Arguments:
        
        pbInBuffer - buffer containing serialized status as array of SERIALIZED_ENUM_SERVICE_STATUS
        dwNumServices - # of entries in pbInBuffer
        pbBuffer - buffer filled with deserialized status as array of ENUM_SERVICE_STATUS
        dwBufferSize - maximum size of pbBuffer
        pdwMDRequiredBufferSize - updated with required size if dwBufferSize too small

    Returns:
        ERROR_INSUFFICIENT_BUFFER if dwBufferSize too small
        otherwise COM status

--*/
{
    HRESULT                         hresReturn = S_OK;
    DWORD                           dwMinSize = 0;
    UINT                            i;
    SERIALIZED_ENUM_SERVICE_STATUS* pessDependentServices = (SERIALIZED_ENUM_SERVICE_STATUS*)pbInBuffer;

    if ( !pbBuffer )
    {
        dwBufferSize = 0;
    }

    dwMinSize = sizeof(ENUM_SERVICE_STATUS) * dwNumServices;

    for ( i = 0 ;
          i < dwNumServices ; 
          ++i )
    {
        UINT    cServiceName = _tcslen( (TCHAR*)(pbInBuffer + pessDependentServices[i].iServiceName) ) + 1;
        UINT    cDisplayName = _tcslen( (TCHAR*)(pbInBuffer + pessDependentServices[i].iDisplayName) ) + 1;

        if ( dwBufferSize >= dwMinSize + ( cServiceName + cDisplayName ) * sizeof(TCHAR) )
        {
            ((LPENUM_SERVICE_STATUS)pbBuffer)[i].ServiceStatus =
                    pessDependentServices[i].ServiceStatus;

            memcpy( pbBuffer + dwMinSize, pbInBuffer + pessDependentServices[i].iServiceName, cServiceName * sizeof(TCHAR) ); 
            ((LPENUM_SERVICE_STATUS)pbBuffer)[i].lpServiceName = (TCHAR*)(pbBuffer + dwMinSize);

            memcpy( pbBuffer + dwMinSize + cServiceName * sizeof(TCHAR), pbInBuffer + pessDependentServices[i].iDisplayName, cDisplayName * sizeof(TCHAR) );
            ((LPENUM_SERVICE_STATUS)pbBuffer)[i].lpDisplayName = (TCHAR*)(pbBuffer + dwMinSize) + cServiceName;
        }

        dwMinSize += ( cServiceName + cDisplayName ) * sizeof(TCHAR);
    }

    if ( dwBufferSize < dwMinSize )
    {
        *pdwMDRequiredBufferSize = dwMinSize;

        hresReturn = RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );
    }

    return hresReturn;
}


HRESULT
SetEnableRemote(
    DWORD   dwValue
    )
/*++

    SetEnableRemote

        set restart I/F enabled flag in registry
        ( HKLM\SOFTWARE\Microsoft\INetStp::EnableRestart::REG_DWORD )

    Arguments:
        
        dwValue - 0 to disable I/F, !0 to enable

    Returns:
        status

--*/
{
    DWORD   dwSt = NO_ERROR;
    HKEY    hKey;

    
    //
    // Check admin privilege by accessing IISADMIN key for write
    //

    if ( ( dwSt = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                                TEXT("SYSTEM\\CurrentControlSet\\Services\\IISADMIN"), 
                                0, 
                                KEY_WRITE, 
                                &hKey ) ) == ERROR_SUCCESS )
    {
        RegCloseKey( hKey );

        //
        // Set IISCTL interface access flag in registry
        //

        if ( ( dwSt = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                                    TEXT("SOFTWARE\\Microsoft\\INetStp"), 
                                    0, 
                                    KEY_WRITE, 
                                    &hKey ) ) == ERROR_SUCCESS )
        {
            if ( ( dwSt = RegSetValueEx( hKey, 
                                         TEXT("EnableRestart"),
                                         0, 
                                         REG_DWORD, 
                                         (const BYTE*)&dwValue, 
                                         sizeof(DWORD) ) ) == ERROR_SUCCESS )
            {
            }

            RegCloseKey( hKey );
        }
    }

    return RETURNCODETOHRESULT( dwSt );
}


BOOL
GetNumeric( 
    LPSTR   pszNumArg,
    LPDWORD pdwVal
    )
{
    if ( !isdigit( (UCHAR)(*pszNumArg) ) )
    {
        return FALSE;
    }

    *pdwVal = atoi( pszNumArg );

    return TRUE;
}

BOOL 
IsIIS6orGreater(
    )
/*++

    IsIIS6orGreater

        According to Aaron we are guaranteed to have
        the appropriate keys in the registry by the
        time iisreset /scm is called.

    Arguments:
        
        None

    Returns:
        TRUE = IIS 6 or greater;
        FALSE = anything below IIS 6;

--*/
{
    // Assume it is not IIS 6.
    BOOL IsIIS6 = FALSE;

    HKEY        hKey;
    DWORD       dwValue;
    DWORD       dwType;
    DWORD       dwSize;

    // Check the registry of the major version setup number.
    // If it is not there we assume it is not a 6.0 machine,
    // since it's better to setup a 6.0 machine in 5.0 state
    // instead of a 5.0 machine in 6.0 state.
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                       TEXT("System\\CurrentControlSet\\Services\\W3SVC\\Parameters"), 
                       0, 
                       KEY_READ, 
                       &hKey ) == ERROR_SUCCESS )
    {
        if ( RegQueryValueEx( hKey, 
                              TEXT("MajorVersion"),
                              0, 
                              &dwType, 
                              (LPBYTE)&dwValue, 
                              &dwSize ) == ERROR_SUCCESS )
        {
            
            if ( dwType == REG_DWORD )
            {
                if ( dwValue >= 6 ) 
                {
                    // were are running on a system that does not
                    // have atleast IIS 6 on it

                    IsIIS6 = TRUE;
                }

            }

        }

        RegCloseKey( hKey );

    }


    return IsIIS6;

}

HRESULT
SetSCM(
    LPCTSTR pszCmdline,
	BOOL	fEnable
	)
/*++

    SetSCM

        set SCM Recovery configuration for IISADMIN service.
        Does nothing on pre Windows 2000 systems.

    Arguments:
        
        pszCmdline - command line to invoke on service failure ( for IISAdmin ), can be NULL to invoke current EXE ( i.e. IISRESET )
        fEnable - TRUE to enable IISRESET invocation on service failure, FALSE to disable

    Returns:
        status

--*/
{
    PFNQUERYSERVICECONFIG2  pfnQueryServiceConfig2 = NULL;
    PFNCHANGESERVICECONFIG2 pfnChangeServiceConfig2 = NULL;
    SERVICE_FAILURE_ACTIONS sfaAction;
    SC_ACTION               saCmdline[3];
    SC_HANDLE               schSCM;
    SC_HANDLE               schSrv;
    HRESULT                 hres = S_OK;
    TCHAR                   achModuleName[MAX_PATH];
    TCHAR                   achFailureCommand[MAX_PATH+32];
    HINSTANCE               hAdvapi;


    if ( hAdvapi = LoadLibrary(_T("ADVAPI32.DLL")) )
    {
        pfnQueryServiceConfig2 = (PFNQUERYSERVICECONFIG2)GetProcAddress( hAdvapi, "QueryServiceConfig2W" );
        pfnChangeServiceConfig2 = (PFNCHANGESERVICECONFIG2)GetProcAddress( hAdvapi, "ChangeServiceConfig2W" );
    }

    if ( pfnQueryServiceConfig2 
         && pfnChangeServiceConfig2 )
    {
        if ( pszCmdline == NULL )
        {
            if ( !GetModuleFileName( NULL, 
                                     achModuleName, 
                                     sizeof(achModuleName)/sizeof(TCHAR) ) )
            {
                hres = RETURNCODETOHRESULT( GetLastError() );
            }
            else
            {
                pszCmdline = achModuleName;
            }
        }

        if ( SUCCEEDED( hres ) )
        {
            schSCM = OpenSCManager(NULL,
                                   NULL,
                                   SC_MANAGER_ALL_ACCESS);
            if ( schSCM == NULL )
	        {
                hres = RETURNCODETOHRESULT( GetLastError() );
            }
            else 
	        {

                // We need to determine what IIS version we are running on
                // in order to know the correct way to setup the server.

                BOOL fIIS6orGreater = IsIIS6orGreater();

                //
                // In IIS 5.1 we want to use the default /restart 
                // setting of iisreset.  In IIS 6 or greater we
                // want to use the /start option.  A customer
                // can configure it to use the /restart option, but
                // that is not the default for the scm.
                //
                if ( fIIS6orGreater )
                {
                    wsprintf( achFailureCommand, _T("\"%s\" /start /fail=%%1%%"), pszCmdline );
                }
                else
                {
                    wsprintf( achFailureCommand, _T("\"%s\" /fail=%%1%%"), pszCmdline );
                }

                sfaAction.lpCommand = achFailureCommand;
                sfaAction.lpRebootMsg = _T("");
                sfaAction.dwResetPeriod = 24 * 60 * 60;

                if ( fEnable )
                {
                    sfaAction.cActions = 3;
                    sfaAction.lpsaActions = saCmdline;
                    saCmdline[0].Type = SC_ACTION_RUN_COMMAND;
                    saCmdline[0].Delay = 1;
                    saCmdline[1].Type = SC_ACTION_RUN_COMMAND;
                    saCmdline[1].Delay = 1;
                    saCmdline[2].Type = SC_ACTION_RUN_COMMAND;
                    saCmdline[2].Delay = 1;
                }
                else
                {
                    sfaAction.cActions = 3;
                    sfaAction.lpsaActions = saCmdline;
                    saCmdline[0].Type = SC_ACTION_NONE;
                    saCmdline[0].Delay = 0;
                    saCmdline[1].Type = SC_ACTION_NONE;
                    saCmdline[1].Delay = 0;
                    saCmdline[2].Type = SC_ACTION_NONE;
                    saCmdline[2].Delay = 0;
                }

                schSrv = OpenService( schSCM,
                                      _T("IISADMIN"),
                                      SERVICE_ALL_ACCESS);

                if ( schSrv )
                {
                    if ( !pfnChangeServiceConfig2( schSrv, 
                                                   SERVICE_CONFIG_FAILURE_ACTIONS, 
                                                   &sfaAction ) )
                    {
                        hres = RETURNCODETOHRESULT( GetLastError() );
                    }

                    CloseServiceHandle( schSrv );
                }
                else
                {
                    hres = RETURNCODETOHRESULT( GetLastError() );
                }

                //
                // Now that we have configured IISAdmin correctly, we also need to 
                // configure W3SVC.
                //

                if ( fIIS6orGreater )
                {

                    sfaAction.lpCommand = NULL;
                    sfaAction.lpRebootMsg = _T("");
                    sfaAction.dwResetPeriod = 24 * 60 * 60;

                    if ( fEnable )
                    {
                        sfaAction.cActions = 3;
                        sfaAction.lpsaActions = saCmdline;
                        saCmdline[0].Type = SC_ACTION_RESTART;
                        saCmdline[0].Delay = 1;
                        saCmdline[1].Type = SC_ACTION_RESTART;
                        saCmdline[1].Delay = 1;
                        saCmdline[2].Type = SC_ACTION_RESTART;
                        saCmdline[2].Delay = 1;
                    }
                    else
                    {
                        sfaAction.cActions = 3;
                        sfaAction.lpsaActions = saCmdline;
                        saCmdline[0].Type = SC_ACTION_NONE;
                        saCmdline[0].Delay = 0;
                        saCmdline[1].Type = SC_ACTION_NONE;
                        saCmdline[1].Delay = 0;
                        saCmdline[2].Type = SC_ACTION_NONE;
                        saCmdline[2].Delay = 0;
                    }

                    schSrv = OpenService( schSCM,
                                          _T("W3SVC"),
                                          SERVICE_ALL_ACCESS);

                    if ( schSrv )
                    {
                        if ( !pfnChangeServiceConfig2( schSrv, 
                                                       SERVICE_CONFIG_FAILURE_ACTIONS, 
                                                       &sfaAction ) )
                        {
                            hres = RETURNCODETOHRESULT( GetLastError() );
                        }

                        CloseServiceHandle( schSrv );
                    }
                    else
                    {
                        hres = RETURNCODETOHRESULT( GetLastError() );
                    }
                } // end of setting up restart on w3svc.
                

                CloseServiceHandle( schSCM );
            }
        }

    }

    if ( hAdvapi )
    {
        FreeLibrary( hAdvapi );
    }

    return hres;
}


enum CMDS { CMD_NONE, CMD_START, CMD_STOP, CMD_REBOOT, CMD_RESTART, CMD_KILL };


int __cdecl 
main( 
    int argc, 
    char*argv[] 
    )
/*++

    main

        main function

    Arguments:
        
        argc
        argv

    Returns:

        0 if no error, otherwise error code

--*/
{
    IIisServiceControl* pIf;
    int                 iA;
    int                 Status = 0;
    HRESULT             hRes;
    CMDS                iCmd = CMD_NONE;
    DWORD               dwStopTimeout = 60 * 1000;
    DWORD               dwRestartTimeout = 20 * 1000;
    DWORD               dwStartTimeout = 60 * 1000;
    LPBYTE              pbBuffer;
    BYTE                abBuffer[4096];
    LPBYTE              pbOutBuffer;
    BYTE                abOutBuffer[4096];
    DWORD               dwRequired;
    DWORD               dwNumServices;
    LPVOID              apvParams[8];
    UINT                i;
    BOOL                fNoCmd = FALSE;
    BOOL                fRebootOnError = FALSE;
    BOOL                fKillOnError = TRUE;
    BOOL                fForce = TRUE;
    BOOL                fRebootRestart = FALSE;
    BOOL                fStatus = FALSE;
    COSERVERINFO        csiMachineName;
    MULTI_QI            rgmq;
    WCHAR               awchComputer[64];
    LPSTR               pszMachineName = NULL;
    BOOL                fErrDisplayed = FALSE;
    DWORD               dwFailCount;

    //
    // Make sure international versions display text ok - RonaldM
    //
    _tsetlocale( LC_ALL, _T(".OCP") );

    _fputts( _T("\n"), stdout );

    //
    // scan command line
    //

    for ( iA = 1 ; 
          iA < argc ; 
          ++iA )
    {
        if ( argv[iA][0] == '-' || argv[iA][0] == '/' )
        {
            if ( !lstrcmpiA( argv[iA]+1, "ENABLE" ) )
            {
                hRes = SetEnableRemote( 1 );

                if ( FAILED( hRes ) )
                {
                    if ( hRes == RETURNCODETOHRESULT( ERROR_ACCESS_DENIED ) )
                    {
                        PrintMessage( IRSTASTR_ACCESS_DENIED, 0, NULL );
                    }
                    else
                    {
                        DisplayErrorMessage( HRESULTTOWIN32( hRes ) );
                    }

                    Status = HRESULTTOWIN32( hRes );
                }
                else
                {
                    PrintMessage( IRSTASTR_ENABLED, 0, NULL );
                }

                fNoCmd = TRUE;
            }
            else if ( !lstrcmpiA( argv[iA]+1, "DISABLE" ) )
            {
                hRes = SetEnableRemote( 0 );

                if ( FAILED( hRes ) )
                {
                    if ( hRes == RETURNCODETOHRESULT( ERROR_ACCESS_DENIED ) )
                    {
                        PrintMessage( IRSTASTR_ACCESS_DENIED, 0, NULL );
                    }
                    else
                    {
                        DisplayErrorMessage( HRESULTTOWIN32( hRes ) );
                    }

                    Status = HRESULTTOWIN32( hRes );
                }
                else
                {
                    PrintMessage( IRSTASTR_DISABLED, 0, NULL );
                }

                fNoCmd = TRUE;
            }
            else if ( !_strnicmp( argv[iA]+1, "SCM", sizeof("SCM")-1 ) )
            {
                if ( FAILED( hRes = SetSCM( NULL, TRUE ) ) )
                {
                    DisplayErrorMessage( HRESULTTOWIN32( hRes ) );

                    Status = HRESULTTOWIN32( hRes );
                }
                goto Exit;
            }
            else if ( !_strnicmp( argv[iA]+1, "NOSCM", sizeof("NOSCM")-1 ) )
            {
                if ( FAILED( hRes = SetSCM( NULL, FALSE ) ) )
                {
                    DisplayErrorMessage( HRESULTTOWIN32( hRes ) );

                    Status = HRESULTTOWIN32( hRes );
                }
                goto Exit;
            }
            else if ( !_strnicmp( argv[iA]+1, "STOPTIMEOUT:", sizeof("STOPTIMEOUT:")-1 ) )
            {
                if ( !GetNumeric( argv[iA]+ 1 + sizeof("STOPTIMEOUT:") - 1, &dwStopTimeout ) )
                {
                    goto invalid_param;
                }
                dwStopTimeout *= 1000;
            }
            else if ( !_strnicmp( argv[iA]+1, "TIMEOUT:", sizeof("TIMEOUT:")-1 ) )
            {
                if ( !GetNumeric( argv[iA]+ 1 + sizeof("TIMEOUT:") - 1, &dwStopTimeout ) )
                {
                    goto invalid_param;
                }
                dwStopTimeout *= 1000;
                dwRestartTimeout = dwStopTimeout;
            }
            else if ( !_strnicmp( argv[iA]+1, "STARTTIMEOUT:", sizeof("STARTTIMEOUT:")-1 ) )
            {
                if ( !GetNumeric( argv[iA]+ 1 + sizeof("STARTTIMEOUT:") - 1, &dwStartTimeout ) )
                {
                    goto invalid_param;
                }
                dwStartTimeout *= 1000;
            }
            else if ( !_strnicmp( argv[iA]+1, "RESTARTTIMEOUT:", sizeof("RESTARTTIMEOUT:")-1 ) )
            {
                if ( !GetNumeric( argv[iA]+ 1 + sizeof("RESTARTTIMEOUT:") - 1, &dwRestartTimeout ) )
                {
                    goto invalid_param;
                }
                dwRestartTimeout *= 1000;
            }
            else if ( !_strnicmp( argv[iA]+1, "fail=", sizeof("fail=")-1 ) )
            {
                //
                // SCM flag to control restart threshold. We restart only 
                // 50 times per SCM restart period.
                //
                // ...  The SCM UI already has a way to address this: they add
                //  a "/fail=N" parameter to the command line 
                // of the restarter app for each time they fail within the time 
                // period and leave it up to the restarter app to interpret 
                // this parameter and throttle restarts approprately.  
                // So...(here's the change request) we need to capture this 
                // value, and if "N" is greater than our limit for 1 day of
                // restarting (hardcoded to 50), we should just exit the 
                // command line app with a success code without doing anything,
                // i.e. "IISRESET.EXE /fail=50" should restart IIS,
                // but "IISRESET.EXE /fail=51" should be a no-op.
                // For simplicity, we should hardcode this value of 50 in 
                // our app-- if a user wants a different value, he can write
                // a batch file wrapper to do it!  You can see 
                // the SCM recovery tab for more info.
                //

                dwFailCount = atoi( argv[iA]+ 1 + sizeof("fail=") - 1 );

                if ( dwFailCount > 50 )
                {
                    return 0;
                }
            }
            else if ( !lstrcmpiA( argv[iA]+1, "START" ) )
            {
                if ( fRebootRestart )
                {
                }
                else if ( iCmd == CMD_STOP )
                {
                    iCmd = CMD_RESTART;
                }
                else
                {
                    iCmd = CMD_START;
                }
            }
            else if ( !lstrcmpiA( argv[iA]+1, "STOP" ) )
            {
                if ( fRebootRestart )
                {
                }
                if ( iCmd == CMD_START )
                {
                    iCmd = CMD_RESTART;
                }
                else
                {
                    iCmd = CMD_STOP;
                }
            }
            else if ( !lstrcmpiA( argv[iA]+1, "REBOOT" ) )
            {
                iCmd = CMD_REBOOT;
                fRebootRestart = TRUE;
            }
            else if ( !lstrcmpiA( argv[iA]+1, "KILL" ) )
            {
                iCmd = CMD_KILL;
                fRebootRestart = TRUE;
            }
            else if ( !lstrcmpiA( argv[iA]+1, "RESTART" ) )
            {
                iCmd = CMD_RESTART;
                fRebootRestart = TRUE;
            }
            else if ( !lstrcmpiA( argv[iA]+1, "STATUS" ) )
            {
                fStatus = TRUE;
            }
            else if ( !lstrcmpiA( argv[iA]+1, "REBOOTONERROR" ) )
            {
                fRebootOnError = TRUE;
                fKillOnError = FALSE;
            }
            else if ( !lstrcmpiA( argv[iA]+1, "NOFORCE" ) )
            {
                fKillOnError = FALSE;
                fForce = FALSE;
            }
            else if ( !lstrcmpiA( argv[iA]+1, "HELP" ) )
            {
                PrintMessage( IRSTASTR_USAGE, 0, NULL );

                return 0;
            }
            else
            {
invalid_param:
                PrintMessage( IRSTASTR_USAGE, 0, NULL );

                return ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            pszMachineName = argv[iA];
        }
    }

    if ( iCmd == CMD_NONE && !fNoCmd && !fStatus )
    {
        iCmd = CMD_RESTART;
    }

    //
    //fill the structure for CoCreateInstanceEx
    //

    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );

    if ( pszMachineName )
    {
        if ( !MultiByteToWideChar( CP_ACP,
                                   MB_PRECOMPOSED,
                                   pszMachineName,
                                   -1,
                                   awchComputer,
                                   sizeof(awchComputer) / sizeof(WCHAR)) )
        {
            return GetLastError();
        }

        csiMachineName.pwszName =  awchComputer;
    }
    else
    {
        csiMachineName.pwszName =  NULL;
    }

    if ( fNoCmd )
    {
        iCmd = CMD_NONE;
        fStatus = FALSE;
    }

    if ( iCmd != CMD_NONE || fStatus )
    {

        BOOL  fCoInitialized = true;
        //
        // call method
        //

        rgmq.pIID = &IID_IIisServiceControl;
        rgmq.pItf = NULL;
        rgmq.hr = 0;

        if (FAILED(hRes = CoInitializeEx( NULL, COINIT_MULTITHREADED ))) {

            fCoInitialized = false;
        }
        else if ( SUCCEEDED( hRes = CoCreateInstanceEx( CLSID_IisServiceControl,
                                                   NULL,
                                                   CLSCTX_SERVER,
                                                   &csiMachineName,
                                                   1,
                                                   &rgmq ) ) &&
             SUCCEEDED( hRes = rgmq.hr ) )
        {
            pIf = (IIisServiceControl*)rgmq.pItf;

            switch ( iCmd )
            {
                case CMD_START:
                    PrintMessage( IRSTASTR_START_ATTEMPT, 0, NULL );
                    hRes = pIf->Start( dwStartTimeout );
                    if ( SUCCEEDED( hRes ) )
                    {
                        PrintMessage( IRSTASTR_START_SUCCESS, 0, NULL );
                    }
                    else
                    {
                        CmdError( IRSTASTR_START_FAILED, hRes );
                        fErrDisplayed = TRUE;
                    }
                    break;

                case CMD_STOP:
                    PrintMessage( IRSTASTR_STOP_ATTEMPT, 0, NULL );
                    hRes = pIf->Stop( dwStopTimeout, fKillOnError );
                    if ( SUCCEEDED( hRes ) )
                    {
                        PrintMessage( IRSTASTR_STOP_SUCCESS, 0, NULL );
                    }
                    else
                    {
                        CmdError( IRSTASTR_STOP_FAILED, hRes );
                        fErrDisplayed = TRUE;
                    }
                    break;

                case CMD_REBOOT:
                    PrintMessage( IRSTASTR_REBOOT_ATTEMPT, 0, NULL );
                    hRes = pIf->Reboot( dwRestartTimeout, fForce );
                    if ( SUCCEEDED( hRes ) )
                    {
                        PrintMessage( IRSTASTR_REBOOT_SUCCESS, 0, NULL );
                    }
                    else
                    {
                        CmdError( IRSTASTR_REBOOT_FAILED, hRes );
                        fErrDisplayed = TRUE;
                    }
                    break;

                case CMD_KILL:
                    PrintMessage( IRSTASTR_KILL_ON_ERROR, 0, NULL );
                    hRes = pIf->Kill();
                    if ( SUCCEEDED( hRes ) )
                    {
                        PrintMessage( IRSTASTR_KILL_SUCCESS, 0, NULL );
                    }
                    else
                    {
                        CmdError( IRSTASTR_KILL_FAILED, hRes );
                        fErrDisplayed = TRUE;
                    }
                    break;

                case CMD_RESTART:

                    PrintMessage( IRSTASTR_STOP_ATTEMPT, 0, NULL );
                    hRes = pIf->Stop( dwRestartTimeout, fKillOnError );

                    if ( SUCCEEDED( hRes ) )
                    {
                        PrintMessage( IRSTASTR_STOP_SUCCESS, 0, NULL );

                        PrintMessage( IRSTASTR_START_ATTEMPT, 0, NULL );
                        hRes = pIf->Start( dwStartTimeout );

                        if ( SUCCEEDED( hRes ) )
                        {
                            PrintMessage( IRSTASTR_RESTART_SUCCESS, 0, NULL );
                        }
                    }
                    if ( FAILED( hRes ) )
                    {
                        CmdError( IRSTASTR_RESTART_FAILED, hRes );
                        fErrDisplayed = TRUE;
                    }
                    break;
            }

            if ( fStatus )
            {
                pbBuffer = NULL;
                fErrDisplayed = FALSE;

                if ( FAILED( hRes = pIf->Status( sizeof(abBuffer), 
                                                 abBuffer, 
                                                 &dwRequired, 
                                                 &dwNumServices ) ) )
                {
                    if ( RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER ) == hRes )
                    {
                        if ( (pbBuffer = (LPBYTE)LocalAlloc( LMEM_FIXED, dwRequired )) == NULL )
                        {
                            hRes = RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
                        }
                        else
                        {
                            hRes = pIf->Status( dwRequired, 
                                                pbBuffer, 
                                                &dwRequired, 
                                                &dwNumServices );
                        }
                    }
                }
                else
                {
                    pbBuffer = abBuffer;
                }

                if ( SUCCEEDED( hRes ) )
                {
                    pbOutBuffer = NULL;

                    if ( FAILED( hRes = DeserializeEnumServiceBuffer( pbBuffer, 
                                                                      dwNumServices, 
                                                                      abOutBuffer, 
                                                                      sizeof(abOutBuffer), 
                                                                      &dwRequired ) ) )
                    {
                        if ( RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER ) == hRes )
                        {
                            if ( (pbOutBuffer = (LPBYTE)LocalAlloc( LMEM_FIXED, dwRequired )) == NULL )
                            {
                                hRes = RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
                            }
                            else
                            {
                                hRes = DeserializeEnumServiceBuffer( pbBuffer, 
                                                                     dwNumServices, 
                                                                     pbOutBuffer, 
                                                                     dwRequired, 
                                                                     &dwRequired );
                            }
                        }
                    }
                    else
                    {
                        pbOutBuffer = abOutBuffer;
                    }
                }

                if ( SUCCEEDED( hRes ) )
                {
                    for ( i = 0 ; i < dwNumServices ; ++i )
                    {
                        apvParams[0] = ((LPENUM_SERVICE_STATUS)pbOutBuffer)[i].lpDisplayName;
                        apvParams[1] = ((LPENUM_SERVICE_STATUS)pbOutBuffer)[i].lpServiceName;

                        switch ( ((LPENUM_SERVICE_STATUS)pbOutBuffer)[i].ServiceStatus.dwCurrentState )
                        {
                            case SERVICE_STOPPED:
                                apvParams[2] = GetString(IRSTASTR_SERVICE_STOPPED); break;

                            case SERVICE_START_PENDING:
                                apvParams[2] = GetString(IRSTASTR_SERVICE_START_PENDING); break;

                            case SERVICE_STOP_PENDING:
                                apvParams[2] = GetString(IRSTASTR_SERVICE_STOP_PENDING); break;

                            case SERVICE_RUNNING:
                                apvParams[2] = GetString(IRSTASTR_SERVICE_RUNNING); break;

                            case SERVICE_CONTINUE_PENDING:
                                apvParams[2] = GetString(IRSTASTR_SERVICE_CONTINUE_PENDING); break;

                            case SERVICE_PAUSE_PENDING:
                                apvParams[2] = GetString(IRSTASTR_SERVICE_PAUSE_PENDING); break;

                            case SERVICE_PAUSED:
                                apvParams[2] = GetString(IRSTASTR_SERVICE_PAUSED); break;

                            default:
                                apvParams[2] = GetString(IRSTASTR_SERVICE_DEFAULT); break;
                        }

                        PrintMessage( IRSTASTR_STATUS_ITEM, 3, apvParams );
                    }
                }

                if ( pbBuffer != NULL && pbBuffer != abBuffer )
                {
                    LocalFree( pbBuffer );
                }

                if ( pbOutBuffer != NULL && pbOutBuffer != abOutBuffer )
                {
                    LocalFree( pbOutBuffer );
                }

            }

            if ( FAILED( hRes ) && fRebootOnError
                 && ( iCmd == CMD_STOP || iCmd == CMD_RESTART ) )
            {
                fErrDisplayed = FALSE;
                PrintMessage( IRSTASTR_REBOOT_ON_ERROR, 0, NULL );

                hRes = pIf->Reboot( 0, fForce );

                if ( SUCCEEDED( hRes ) )
                {
                    PrintMessage( IRSTASTR_REBOOT_SUCCESS, 0, NULL );
                }
            }
#if 0
            if ( FAILED( hRes ) && fKillOnError
                 && ( iCmd == CMD_STOP || iCmd == CMD_RESTART ) )
            {
                fErrDisplayed = FALSE;
                PrintMessage( IRSTASTR_KILL_ON_ERROR, 0, NULL );

                hRes = pIf->Kill();

                if ( SUCCEEDED( hRes ) )
                {
                    PrintMessage( IRSTASTR_KILL_SUCCESS, 0, NULL );
                }
            }
#endif
            pIf->Release();

            if ( FAILED( hRes ) )
            {
                if ( !fErrDisplayed )
                {
                    if ( hRes == RETURNCODETOHRESULT( ERROR_RESOURCE_DISABLED ) )
                    {
                        PrintMessage( IRSTASTR_REMOTE_DISABLED, 0, NULL );
                    }
                    else if ( hRes == RETURNCODETOHRESULT( ERROR_ACCESS_DENIED ) )
                    {
                        PrintMessage( IRSTASTR_ACCESS_DENIED, 0, NULL );
                    }
                    else
                    {
                        DisplayErrorMessage( HRESULTTOWIN32( hRes ) );
                    }
                }

                Status = HRESULTTOWIN32( hRes );
            }
        }
        else
        {
            if ( hRes == RETURNCODETOHRESULT( ERROR_ACCESS_DENIED ) )
            {
                PrintMessage( IRSTASTR_ACCESS_DENIED, 0, NULL );
            }
            else
            {
                DisplayErrorMessage( HRESULTTOWIN32( hRes ) );
            }

            Status = HRESULTTOWIN32( hRes );
        }
        if (fCoInitialized) {
            CoUninitialize();
        }
    }

Exit:

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\restart\iisrsta\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\restart\iisrsta\iisrestart.h ===
// IisRestart.h : Declaration of the CIisRestart

#ifndef __IISRESTART_H_
#define __IISRESTART_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CIisRestart
class ATL_NO_VTABLE CIisRestart : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CIisRestart, &CLSID_IisServiceControl>,
	public IDispatchImpl<IIisServiceControl, &IID_IIisServiceControl, &LIBID_IISRSTALib>
{
public:
	CIisRestart()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_IISRESTART)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CIisRestart)
	COM_INTERFACE_ENTRY(IIisServiceControl)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IIisRestart
public:
	STDMETHOD(Status)(/*[IN]*/ DWORD dwBufferSize, /*[out, size_is(dwBufferSize)]*/ unsigned char *pbBuffer, /*[out]*/ DWORD *pdwMDRequiredBufferSize, /*[out]*/ DWORD *pdwNumServices);
	STDMETHOD(Reboot)( DWORD dwTimeoutMsecs, DWORD dwForceAppsClosed );
	STDMETHOD(Start)(DWORD dwTimeoutMsecs);
	STDMETHOD(Stop)(DWORD dwTimeoutMsecs, DWORD dwForce);
	STDMETHOD(Kill)();
};

#endif //__IISRESTART_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\restart\iisrsta\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__E8FB8617_588F_11D2_9D61_00C04F79C5FE__INCLUDED_)
#define AFX_STDAFX_H__E8FB8617_588F_11D2_9D61_00C04F79C5FE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
};
extern CExeModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E8FB8617_588F_11D2_9D61_00C04F79C5FE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\restart\iisrsta\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iisrsta.rc
//
#define IDS_PROJNAME                    100
#define IDR_Iisrsta                     100
#define IDR_IISRESTART                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\restart\iisrsta\inetdbgp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    inetdbgp.h

Abstract:

    Common header file for NTSDEXTS component source files.

Author:

    Murali Krishnan (MuraliK) 22-Aug-1996

Revision History:

--*/

# ifndef _INETDBGP_H_
# define _INETDBGP_H_

//
// Module enumerator.
//

typedef struct _MODULE_INFO {
    ULONG_PTR DllBase;
    ULONG_PTR EntryPoint;
    ULONG SizeOfImage;
    CHAR BaseName[MAX_PATH];
    CHAR FullName[MAX_PATH];
} MODULE_INFO, *PMODULE_INFO;

typedef
BOOLEAN
(CALLBACK * PFN_ENUMMODULES)(
    IN PVOID Param,
    IN PMODULE_INFO ModuleInfo
    );

BOOLEAN
EnumModules(
    IN HANDLE ExtensionCurrentProcess,
    IN PFN_ENUMMODULES EnumProc,
    IN PVOID Param
    );

# endif //  _INETDBGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\restart\iisrsta\iisrsta.cpp ===
/*
    IisRsta.cpp

    Implementation of WinMain for COM IIisServiceControl handler

    FILE HISTORY:
        Phillich    06-Oct-1998     Created

*/


#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "iisrsta.h"
#include "dcomperm.h"

//#include "..\interfac\iisrsta_i.c"
#include "IisRestart.h"


const DWORD dwTimeOut = 5000; // time for EXE to be idle before shutting down
const DWORD dwPause = 1000; // time to wait for threads to finish up

// Passed to CreateThread to monitor the shutdown event
static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }
    return l;
}

//Monitors the shutdown event
void CExeModule::MonitorShutdown()
{
    while (1)
    {
        WaitForSingleObject(hEventShutdown, INFINITE);
        DWORD dwWait=0;
        do
        {
            bActivity = false;
            dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
        } while (dwWait == WAIT_OBJECT_0);
        // timed out
        if (!bActivity && m_nLockCnt == 0) // if no activity let's really bail
        {
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
            CoSuspendClassObjects();
            if (!bActivity && m_nLockCnt == 0)
#endif
                break;
        }
    }
    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

bool CExeModule::StartMonitor()
{
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    return (h != NULL);
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_IisServiceControl, CIisRestart)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//

#if 0

extern "C" int WINAPI wWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
    HRESULT hRes = CoInitialize(NULL);
#endif
    _ASSERTE(SUCCEEDED(hRes));
    _Module.Init(ObjectMap, hInstance/*, &LIBID_IISRSTALib*/);
    _Module.dwThreadID = GetCurrentThreadId();
    TCHAR szTokens[] = _T("-/");

    int nRet = 0;
    BOOL bRun = TRUE;
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_IISRESTART, FALSE);
            bRun = FALSE;
            break;
        }
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_IISRESTART, TRUE);
            //
            // Assign ACL to CLSID ( a la dcomcnfg ) granting access only to admins, current user
            // and system
            //

            ChangeAppIDAccessACL( _T("{E8FB8615-588F-11D2-9D61-00C04F79C5FE}"),
                                  _T("administrators"),
                                  TRUE,
                                  TRUE );
            bRun = FALSE;
            break;
        }
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    if (bRun)
    {
        _Module.StartMonitor();
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
        _ASSERTE(SUCCEEDED(hRes));
        hRes = CoResumeClassObjects();
#else
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);
#endif
        _ASSERTE(SUCCEEDED(hRes));

        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);

        _Module.RevokeClassObjects();
        Sleep(dwPause); //wait for any threads to finish
    }

    _Module.Term();
    CoUninitialize();
    return nRet;
}

#endif

int _cdecl 
main(
    int argc, 
    char **argv
    ) 
{

//    FreeConsole();

	LPTSTR lpCmdLine = GetCommandLine();	// necessary for minimal CRT
//	HRESULT hRes = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//	instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
	HRESULT hRes;
    
    hRes = CoInitializeEx(NULL,COINIT_MULTITHREADED);

    if (FAILED(hRes)) {
        return 1;
    }

    hRes = CoInitializeSecurity(
	  				NULL,
					-1,
					NULL,
					NULL,
					RPC_C_AUTHN_LEVEL_CONNECT,
					RPC_C_IMP_LEVEL_DELEGATE,
					NULL,
					EOAC_STATIC_CLOAKING,
					NULL );

    if (FAILED(hRes)) {
        return 1;
    }

	_ASSERTE(SUCCEEDED(hRes));
	_Module.Init(ObjectMap,GetModuleHandle(NULL));
	_Module.dwThreadID = GetCurrentThreadId();
	TCHAR szTokens[] = _T("-/");

	int nRet = 0;
	BOOL bRun = TRUE;
	LPCTSTR lpszToken = FindOneOf(lpCmdLine,szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            //_Module.UpdateRegistryFromResource(IDR_Iisrsta, FALSE);
            //nRet = _Module.UnregisterServer(&LIBID_IISRSTALib/*TRUE*/);
            _Module.UpdateRegistryFromResource(IDR_IISRESTART, FALSE);
            bRun = FALSE;
            break;
        }
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_IISRESTART, TRUE);
            //_Module.UpdateRegistryFromResource(IDR_Iisrsta, TRUE);
            //nRet = _Module.RegisterServer(TRUE);

            //
            // Assign access ACL to CLSID granting access only to admins, current user
            // and system
            //

            ChangeAppIDAccessACL( _T("{E8FB8615-588F-11D2-9D61-00C04F79C5FE}"),
                                  _T("administrators"),
                                  TRUE,
                                  TRUE );

            bRun = FALSE;
            break;
        }
        lpszToken = FindOneOf(lpszToken, szTokens);
    }


	if (bRun) {
        _Module.StartMonitor();
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
        _ASSERTE(SUCCEEDED(hRes));
        hRes = CoResumeClassObjects();
#else
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);
#endif
		_ASSERTE(SUCCEEDED(hRes));

        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
        {
            DispatchMessage(&msg);
        }

		_Module.RevokeClassObjects();
        Sleep(dwPause); //wait for any threads to finish
	}

    _Module.Term();
	CoUninitialize();
	return (nRet);
}

#if 0

#define SPACECHAR   _T(' ')
#define DQUOTECHAR  _T('\"')

#ifdef _UNICODE
//extern "C" void wWinMainCRTStartup()
#else // _UNICODE
//extern "C" void WinMainCRTStartup()
#endif // _UNICODE
extern "C" void mainCRTStartup(VOID)
{
	LPTSTR lpszCommandLine = ::GetCommandLine();
	if(lpszCommandLine == NULL)
		::ExitProcess((UINT)-1);

	// Skip past program name (first token in command line).
	// Check for and handle quoted program name.
	if(*lpszCommandLine == DQUOTECHAR)
	{
		// Scan, and skip over, subsequent characters until
		// another double-quote or a null is encountered.
		do
		{
			lpszCommandLine = ::CharNext(lpszCommandLine);
		}
		while((*lpszCommandLine != DQUOTECHAR) && (*lpszCommandLine != _T('\0')));

		// If we stopped on a double-quote (usual case), skip over it.
		if(*lpszCommandLine == DQUOTECHAR)
			lpszCommandLine = ::CharNext(lpszCommandLine);
	}
	else
	{
		while(*lpszCommandLine > SPACECHAR)
			lpszCommandLine = ::CharNext(lpszCommandLine);
	}

	// Skip past any white space preceeding the second token.
	while(*lpszCommandLine && (*lpszCommandLine <= SPACECHAR))
		lpszCommandLine = ::CharNext(lpszCommandLine);

	STARTUPINFO StartupInfo;
	StartupInfo.dwFlags = 0;
	::GetStartupInfo(&StartupInfo);

	int nRet = _tWinMain(::GetModuleHandle(NULL), NULL, lpszCommandLine,
		(StartupInfo.dwFlags & STARTF_USESHOWWINDOW) ?
		StartupInfo.wShowWindow : SW_SHOWDEFAULT);

	::ExitProcess((UINT)nRet);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\restart\iisrsta\enummod.c ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    enummod.c

Abstract:

    This module implements a remote module enumerator.

Author:

    Keith Moore (keithmo) 16-Sep-1997

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef IF_DEBUG

#include <windows.h>
//#include <ntsdexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
# include <stdlib.h>

#include "inetdbgp.h"

#define ReadMemory(a,b,c,d)     ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) )
#define WriteMemory(a,b,c,d)    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) )


//
// Globals
//



BOOLEAN
EnumModules(
    IN HANDLE ExtensionCurrentProcess,
    IN PFN_ENUMMODULES EnumProc,
    IN PVOID Param
    )

/*++

Routine Description:

    Enumerates all loaded modules in the debugee.

Arguments:

    EnumProc - An enumeration proc that will be invoked for each module.

    Param - An uninterpreted parameter passed to the enumeration proc.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    PROCESS_BASIC_INFORMATION basicInfo;
    NTSTATUS status;
    PPEB peb;
    PPEB_LDR_DATA ldr;
    PLIST_ENTRY ldrHead, ldrNext;
    PLDR_DATA_TABLE_ENTRY ldrEntry;
    LDR_DATA_TABLE_ENTRY ldrEntryData;
    WCHAR tmpName[MAX_PATH];
    MODULE_INFO moduleInfo;

    //
    // Get the process info.
    //

    status = NtQueryInformationProcess(
                 ExtensionCurrentProcess,
                 ProcessBasicInformation,
                 &basicInfo,
                 sizeof(basicInfo),
                 NULL
                 );

    if( !NT_SUCCESS(status) ) {
        return FALSE;
    }

    peb = basicInfo.PebBaseAddress;

    if( peb == NULL ) {
        return FALSE;
    }

    //
    // ldr = peb->Ldr
    //

    if( !ReadMemory(
            (ULONG_PTR)&peb->Ldr,
            &ldr,
            sizeof(ldr),
            NULL
            ) ) {
        return FALSE;
    }

    ldrHead = &ldr->InMemoryOrderModuleList;

    //
    // ldrNext = ldrHead->Flink;
    //

    if( !ReadMemory(
            (ULONG_PTR)&ldrHead->Flink,
            &ldrNext,
            sizeof(ldrNext),
            NULL
            ) ) {
        return FALSE;
    }

    while( ldrNext != ldrHead ) {
#if 0
        if( CheckControlC() ) {
            break;
        }
#endif
        //
        // Read the LDR_DATA_TABLE_ENTRY structure and the module name.
        //

        ldrEntry = CONTAINING_RECORD(
                       ldrNext,
                       LDR_DATA_TABLE_ENTRY,
                       InMemoryOrderLinks
                       );

        if( !ReadMemory(
                (ULONG_PTR)ldrEntry,
                &ldrEntryData,
                sizeof(ldrEntryData),
                NULL
                ) ) {
            return FALSE;
        }

        if( !ReadMemory(
                (ULONG_PTR)ldrEntryData.BaseDllName.Buffer,
                tmpName,
                ldrEntryData.BaseDllName.MaximumLength,
                NULL
                ) ) {
            return FALSE;
        }

        wsprintfA(
            moduleInfo.BaseName,
            "%ws",
            tmpName
            );

        if( !ReadMemory(
                (ULONG_PTR)ldrEntryData.FullDllName.Buffer,
                tmpName,
                ldrEntryData.FullDllName.MaximumLength,
                NULL
                ) ) {
            return FALSE;
        }

        wsprintfA(
            moduleInfo.FullName,
            "%ws",
            tmpName
            );

        moduleInfo.DllBase = (ULONG_PTR)ldrEntryData.DllBase;
        moduleInfo.EntryPoint = (ULONG_PTR)ldrEntryData.EntryPoint;
        moduleInfo.SizeOfImage = (ULONG)ldrEntryData.SizeOfImage;

        //
        // Invoke the callback.
        //

        if( !(EnumProc)(
                Param,
                &moduleInfo
                ) ) {
            break;
        }

        ldrNext = ldrEntryData.InMemoryOrderLinks.Flink;

    }

    return TRUE;

}   // EnumModules
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\restart\iisrsta\iisrestart.cpp ===
/*
    IisRestart.cpp

    Implementation of CIisRestart ( IIisServiceControl )

    FILE HISTORY:
        Phillich    06-Oct-1998     Created

*/


#include "stdafx.h"
#include "IisRsta.h"
#include "IisRstam.h"
#include "IisRestart.h"
#include "common.h"

#define MAX_TASKS 8
//#define VERBOSE_DEBUG 

//
// RETURNCODETOHRESULT() maps a return code to an HRESULT. If the return
// code is a Win32 error (identified by a zero high word) then it is mapped
// using the standard HRESULT_FROM_WIN32() macro. Otherwise, the return
// code is assumed to already be an HRESULT and is returned unchanged.
//

#define RETURNCODETOHRESULT(rc)                             \
            (((rc) < 0x10000)                               \
                ? HRESULT_FROM_WIN32(rc)                    \
                : (rc))


typedef BOOL (*PFNQUERYSERVICECONFIG2)(SC_HANDLE,DWORD,LPBYTE,DWORD,LPDWORD) ;
typedef BOOL (*PFNCHANGESERVICECONFIG2)(SC_HANDLE,DWORD,LPVOID);


//
// sample code for remote shutdown:
// \\orville\razzle\src\ntreskit\source\shutgui\reboot.c
//

//
// Global functions
//
BOOL
W3SVCandW3SSL(
    DWORD currentIndex, 
    ENUM_SERVICE_STATUS* pessRoot,
    DWORD dwNumServices
    );

VOID EnableShutdownPrivilege(
    VOID
    );

HRESULT
EnumStartServices(
    SC_HANDLE   schSCM,
    LPTSTR      pszRoot,
    DWORD       dwTargetState,
    LPBYTE      abServiceList,
    DWORD       dwInitializeServiceListSize,
    LPBYTE*     ppbServiceList,
    LPDWORD     pdwNumServices,
    BOOL        fAddIisadmin
    );

HRESULT
SerializeEnumServiceBuffer( 
    LPENUM_SERVICE_STATUS   pessDependentServices,
    DWORD                   dwNumServices,
    LPBYTE                  pbBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwMDRequiredBufferSize 
    );

BOOL
IsEnableRemote(
    );

HRESULT
StopIIsAdmin(
	DWORD	dwTimeoutMsecs
	);

HRESULT
StartStopAll(
    LPTSTR  pszRoot,
    BOOL    fStart,
    DWORD   dwTimeoutMsecs
    );

BOOL
WaitForServiceStatus(
	SC_HANDLE   schDependent, 
	DWORD       dwDesiredServiceState,
	DWORD	    dwTimeoutMsecs
	);

HRESULT
KillTaskByName(
    LPTSTR  pname,
    LPSTR   pszMandatoryModule
    );

VOID
ReportStatus(
    DWORD   dwId,
    DWORD   dwStatus
    );

HRESULT
SendControlToService( 
    SC_HANDLE   hServiceHandle,
    DWORD       dwCmd,
    LPDWORD     pdwTimeoutOutMsecs
    );

StartStopAllRecursive(
    SC_HANDLE               schSCM,
    ENUM_SERVICE_STATUS*    pessRoot,
    DWORD                   dwNumServices,
    BOOL                    fStart,
    BOOL                    fForceDemandStart,
    LPDWORD                 pdwTimeoutMsecs
    );

HRESULT
WhoAmI(
    LPTSTR* pPrincipal
    );

BOOL
CloseSystemExceptionHandler(
    LPCTSTR     pszWindowName
    );

/////////////////////////////////////////////////////////////////////////////
// CIisRestart


STDMETHODIMP 
CIisRestart::Stop(
    DWORD   dwTimeoutMsecs,
    DWORD   dwForce
    )
/*++

    Stop

        Stop all internet services ( services dependent on IISADMIN )
        first using SCM then optionaly using TerminateProcess if failure

    Arguments:

        dwTimeoutMsecs  - timeout for status check ( in ms )
        dwForce - !0 to force TerminateProcess if failure to stop services using SCM

    Returns:
        ERROR_RESOURCE_DISABLED if remote access to IIisRestart disabled
        ERROR_SERVICE_REQUEST_TIMEOUT if timeout waiting for all internet services status
            to be stopped
        otherwise COM status

--*/
{
	HRESULT	hres = S_OK;

    if ( !IsEnableRemote() )
    {
        hres = RETURNCODETOHRESULT( ERROR_RESOURCE_DISABLED );
    }
    else 
    {
#if defined(VERBOSE_DEBUG)
        OutputDebugString(_T("Attempt to kill dr watson\n"));
#endif
        //
        // Always kill Dr Watson, as the Dr Watson window may be still present after inetinfo process
        // was terminated after an exception, and in this case the Dr Watson process apparently still owns
        // some sockets resources preventing inetinfo to properly restart ( specifically binding TCP/IP sockets 
        // fails during inetinfo restart )
        //

        KillTaskByName(_T("drwtsn32"), NULL);

        hres = StartStopAll( _T("IISADMIN"), FALSE, dwTimeoutMsecs );
        if ( dwForce && FAILED( hres ) )
        {
            hres = Kill();
        }
    }

    ReportStatus( IRSTAM_STOP, hres );

	return hres;
}


STDMETHODIMP 
CIisRestart::Start(
    DWORD   dwTimeoutMsecs
    )
/*++

    Start

        Start all internet services ( services dependent on IISADMIN )
        using SCM

    Arguments:

        dwTimeoutMsecs  - timeout for status check ( in ms )

    Returns:
        ERROR_RESOURCE_DISABLED if remote access to IIisRestart disabled
        ERROR_SERVICE_REQUEST_TIMEOUT if timeout waiting for all internet services status
            to be started
        otherwise COM status

--*/
{
	HRESULT	hres = S_OK;

    if ( !IsEnableRemote() )
    {
        hres = RETURNCODETOHRESULT( ERROR_RESOURCE_DISABLED );
    }
    else
    {
        //
        // In 6.0 we will use IIS Reset /Start to bring up the
        // service again without stopping the services that can
        // keep running.  We still want to kill any dr watson's 
        // thou.  This should be harmless on a regular start.
        //

#if defined(VERBOSE_DEBUG)
        OutputDebugString(_T("Attempt to kill dr watson\n"));
#endif
        //
        // Always kill Dr Watson, as the Dr Watson window may be still present after inetinfo process
        // was terminated after an exception, and in this case the Dr Watson process apparently still owns
        // some sockets resources preventing inetinfo to properly restart ( specifically binding TCP/IP sockets 
        // fails during inetinfo restart )
        //

        KillTaskByName(_T("drwtsn32"), NULL);

        hres = StartStopAll( _T("IISADMIN"), TRUE, dwTimeoutMsecs );
    }

    ReportStatus( IRSTAM_START, hres );

	return hres;
}


STDMETHODIMP 
CIisRestart::Reboot(
    DWORD   dwTimeoutMsecs, 
    DWORD   dwForceAppsClosed
    )
/*++

    Reboot

        Reboot the computer

    Arguments:

        dwTimeoutMsecs  - timeout for apps to be closed by user ( in ms )
        dwForceAppsClosed - force apps to be closed if hung

    Returns:
        ERROR_RESOURCE_DISABLED if remote access to IIisRestart disabled
        otherwise COM status

--*/
{
	HRESULT	hres = S_OK;

    if ( !IsEnableRemote() )
    {
        hres =  RETURNCODETOHRESULT( ERROR_RESOURCE_DISABLED );
    }
    else
    {
        //
        // If this fails then we will get an error back from ExitWindowsEx()
        //

	    EnableShutdownPrivilege();
    
        //
        // Make sure we will always reboot even if process(es) stuck
        //

#if 1

        TCHAR*  pPrincipal;
        TCHAR*  pBuf;

        //
        // Format message to operator, includes name of user requesting shutdown.
        //

        if ( SUCCEEDED( hres = WhoAmI( &pPrincipal ) ) )
        {
            if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                (LPCVOID)NULL,  //GetModuleHandle(NULL),
                                IRSTAM_SYSSHUT,
                                0,
                                (LPTSTR)&pBuf,
                                1,
                                (va_list *)&pPrincipal ) )
            {
                if (InitiateSystemShutdown( NULL, 
                                            pBuf, 
                                            dwTimeoutMsecs/1000,    // timeout in seconds
                                            dwForceAppsClosed, 
                                            TRUE ) == 0)
                {
                    hres = RETURNCODETOHRESULT( GetLastError() );
                }
                LocalFree( (LPVOID)pBuf );
            }

            LocalFree( pPrincipal );
        }

#else

	    if ( !ExitWindowsEx( EWX_REBOOT|EWX_FORCE, 0 ) )
	    {
		    hres = RETURNCODETOHRESULT( GetLastError() );
	    }

#endif
    }

    ReportStatus( IRSTAM_REBOOT, hres );

	return hres;
}


STDMETHODIMP 
CIisRestart::Kill(
    )
/*++

    Kill

        Kill all internet services ( services dependent on IISADMIN )
        using TerminateProcess()

    Arguments:

        None

    Returns:
        ERROR_RESOURCE_DISABLED if remote access to IIisRestart disabled
        otherwise COM status

--*/
{
	HRESULT	                hres = S_OK;
	HRESULT	                hresReapply;
    BYTE                    abServiceList[2048];
    LPBYTE                  pbServiceList = NULL;
    DWORD                   dwNumServices = 0;
    SC_HANDLE               schSCM = NULL;
    SC_HANDLE               schSrv;
    LPBYTE*                 ppInfo = NULL;
    LPENUM_SERVICE_STATUS   pessDependentServices;
    DWORD                   dwNeeded;
    HINSTANCE               hAdvapi;
    PFNQUERYSERVICECONFIG2  pfnQueryServiceConfig2 = NULL;
    PFNCHANGESERVICECONFIG2 pfnChangeServiceConfig2 = NULL;
    SERVICE_FAILURE_ACTIONS sfaNoAction;
    SC_ACTION               saNoAction[3];
    DWORD                   i;
    BYTE                    abTemp[64];     // work-around for NT5 bug

    if ( !IsEnableRemote() )
    {
        return  RETURNCODETOHRESULT( ERROR_RESOURCE_DISABLED );
    }

    //
    // Take a snapshot of Restart configuration
    // If unable to get ptr to service config2 API then consider this a success:
    // there is nothing to preserve.
    //

    if ( hAdvapi = LoadLibrary(_T("ADVAPI32.DLL")) )
    {
        pfnQueryServiceConfig2 = (PFNQUERYSERVICECONFIG2)GetProcAddress( hAdvapi, "QueryServiceConfig2W" );
        pfnChangeServiceConfig2 = (PFNCHANGESERVICECONFIG2)GetProcAddress( hAdvapi, "ChangeServiceConfig2W" );
    }

    if ( pfnQueryServiceConfig2 
         && pfnChangeServiceConfig2 )
    {
        schSCM = OpenSCManager(NULL,
                               NULL,
                               SC_MANAGER_ALL_ACCESS);
        if ( schSCM == NULL )
	    {
            hres = RETURNCODETOHRESULT( GetLastError() );
        }
        else 
	    {
            //
            // Setup control block for no restart action.
            // We will replace existing actions with this control block
            //

            sfaNoAction.dwResetPeriod = INFINITE;
            sfaNoAction.lpCommand = _T("");
            sfaNoAction.lpRebootMsg = _T("");
            sfaNoAction.cActions = 3;
            sfaNoAction.lpsaActions = saNoAction;

            saNoAction[0].Type = SC_ACTION_NONE;
            saNoAction[0].Delay = 0;
            saNoAction[1].Type = SC_ACTION_NONE;
            saNoAction[1].Delay = 0;
            saNoAction[2].Type = SC_ACTION_NONE;
            saNoAction[2].Delay = 0;

            //
            // Enumerate all services dependent on IISADMIN ( including itself )
            //

            hres = EnumStartServices( schSCM,
                                      _T("IISADMIN"),
                                      SERVICE_STATE_ALL,
                                      abServiceList, 
                                      sizeof(abServiceList), 
                                      &pbServiceList, 
                                      &dwNumServices,
                                      TRUE );

            if ( SUCCEEDED( hres ) )
            {
                //
                // Store existing info in ppInfo array
                //

                ppInfo = (LPBYTE*)LocalAlloc( LMEM_FIXED|LMEM_ZEROINIT, sizeof(LPBYTE) * dwNumServices );

                if ( ppInfo )
                {
                    pessDependentServices = (LPENUM_SERVICE_STATUS)pbServiceList;

                    for ( i = 0 ; 
                          (i < dwNumServices) && SUCCEEDED(hres) ;
                          ++i )
                    {
                        schSrv = OpenService( schSCM,
                                              pessDependentServices[i].lpServiceName,
                                              SERVICE_ALL_ACCESS);

                        if ( schSrv )
                        {
                            //
                            // 1st query config size, then alloc buffer and retrieve
                            // config. Note than ppInfo[] may be NULL is no config
                            // associated with this service.
                            //
                            // WARNING: must specify ptr to writable buffer even if specified
                            // buffer size is 0 due to bug in NT5 implementation of
                            // QueryServiceConfig2. Not sure about minimum buffer size
                            // ( sizeof(SERVICE_FAILURE_ACTIONS) ) ?
                            //

                            if ( !pfnQueryServiceConfig2( schSrv, 
                                                          SERVICE_CONFIG_FAILURE_ACTIONS, 
                                                          (LPBYTE)abTemp, 
                                                          0, 
                                                          &dwNeeded ) )
                            {
                                if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
                                {
                                    if ( ppInfo[i] = (LPBYTE)LocalAlloc( LMEM_FIXED, dwNeeded ) )
                                    {
                                        if ( !pfnQueryServiceConfig2( schSrv, 
                                                                      SERVICE_CONFIG_FAILURE_ACTIONS, 
                                                                      ppInfo[i], 
                                                                      dwNeeded, 
                                                                      &dwNeeded ) )
                                        {
                                            hres = RETURNCODETOHRESULT( GetLastError() );
                                        }
                                    }
                                    else
                                    {
                                        hres = RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
                                    }
                                }
                                else
                                {
                                    hres = RETURNCODETOHRESULT( GetLastError() );
                                }
                            }

                            if ( SUCCEEDED( hres ) )
                            {
#if defined(VERBOSE_DEBUG)
                                OutputDebugString(_T("Got config for "));
                                OutputDebugString(pessDependentServices[i].lpServiceName);
                                OutputDebugString(_T("\n"));
#endif
                                if ( !pfnChangeServiceConfig2( schSrv, 
                                                               SERVICE_CONFIG_FAILURE_ACTIONS, 
                                                               &sfaNoAction ) )
                                {
                                    hres = RETURNCODETOHRESULT( GetLastError() );
                                }
                            }

                            CloseServiceHandle( schSrv );
                        }
                        else
                        {
                            hres = RETURNCODETOHRESULT( GetLastError() );
                        }
                    }
                }
                else
                {
                    hres = RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
                }
            }

            CloseServiceHandle( schSCM );
        }
    }

    //
    // Graceful exit failed, kill the IIS processes.
    // First, kill inetinfo, then kill the WAM instances.
    //

    CloseSystemExceptionHandler( _T("inetinfo.exe") );

    //
    // Always kill Dr Watson, as the Dr Watson window may be still present after inetinfo process
    // was terminated after an exception, and in this case the Dr Watson process apparently still owns
    // some sockets resources preventing inetinfo to properly restart ( specifically binding TCP/IP sockets 
    // fails during inetinfo restart )
    //

    KillTaskByName(_T("drwtsn32"), NULL);

    if ( SUCCEEDED( hres ) )
    {
#if defined(VERBOSE_DEBUG)
        OutputDebugString(_T("Attempt to kill INETINFO\n"));
#endif
        hres = KillTaskByName(_T("INETINFO"), NULL);
    }

    if ( SUCCEEDED( hres ) )
    {
#if defined(VERBOSE_DEBUG)
        OutputDebugString(_T("Attempt to kill svhost\n"));
#endif
        hres = KillTaskByName(_T("SVCHOST"), "iisw3adm.dll");   // MTS WAM containers
    }

    if ( SUCCEEDED( hres ) )
    {
#if defined(VERBOSE_DEBUG)
        OutputDebugString(_T("Attempt to kill w3wp\n"));
#endif
        hres = KillTaskByName(_T("W3WP"), NULL);   // MTS WAM containers
    }

    if ( SUCCEEDED( hres ) )
    {
#if defined(VERBOSE_DEBUG)
        OutputDebugString(_T("Attempt to kill MTX\n"));
#endif
        hres = KillTaskByName(_T("MTX"), "wam.dll");   // MTS WAM containers
    }

    if ( SUCCEEDED( hres ) )
    {
#if defined(VERBOSE_DEBUG)
        OutputDebugString(_T("Attempt to kill DLLHOST\n"));
#endif
        hres = KillTaskByName(_T("DLLHOST"),"wam.dll");   // COM+ WAM Containers
    }

    if ( SUCCEEDED( hres ) )
    {
#if defined(VERBOSE_DEBUG)
        OutputDebugString(_T("Attempt to kill XSPWP\n"));
#endif
        hres = KillTaskByName(_T("XSPWP"), NULL);   // ASP+ processes
    }

    // the following code will check the IISAdmin registry parameters for
    // a KillProcsOnFailure MULTI_SZ.  Any process names in this list will
    // be killed.

    if ( SUCCEEDED( hres ) )
    {
        HKEY        hKey;
        DWORD       dwValue;
        DWORD       dwType;
        DWORD       dwSize;
        TCHAR       achBuffer[1024];

        if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                           TEXT("system\\CurrentControlSet\\services\\IISAdmin"), 
                           0, 
                           KEY_READ, 
                           &hKey ) == ERROR_SUCCESS )
        {
            dwSize = sizeof( achBuffer );
            if ( RegQueryValueEx( hKey, 
                                  TEXT("KillProcsOnFailure"),
                                  0, 
                                  &dwType, 
                                  (LPBYTE)achBuffer, 
                                  &dwSize ) != ERROR_SUCCESS )
            {
                RegCloseKey( hKey );

                return FALSE;
            }

            TCHAR *pT = achBuffer;

            // parse the multisz.  The format is NULL Terminated strings
            // with an extra null terminator after the list.

            while ((dwSize > 0) && *pT) {

#if defined(VERBOSE_DEBUG)
                OutputDebugString(_T("Attempt to kill\n"));
                OutputDebugString(pT);
#endif
                hres = KillTaskByName(pT, NULL);
                
                dwSize -= _tcsnbcnt(pT,_tcslen(pT)) + sizeof(TCHAR);

                pT += _tcslen(pT) + 1;

            }
        }
    }

#if defined(VERBOSE_DEBUG)
    if ( FAILED(hres) )
    {
        OutputDebugString(_T("Kill failed\n"));
    }
#endif

    hresReapply = S_OK;

    //
    // Reapply restart configuration
    //

    if ( ppInfo )
    {
        schSCM = OpenSCManager(NULL,
                               NULL,
                               SC_MANAGER_ALL_ACCESS);
        if ( schSCM == NULL )
	    {
            hresReapply = RETURNCODETOHRESULT( GetLastError() );
        }
        else 
	    {
            for ( i = 0 ; i < dwNumServices ; ++i )
            {
                if ( ppInfo[i] )
                {
                    schSrv = OpenService( schSCM,
                                          pessDependentServices[i].lpServiceName,
                                          SERVICE_ALL_ACCESS);

                    if ( schSrv )
                    {
                        if ( !pfnChangeServiceConfig2( schSrv, 
                                                       SERVICE_CONFIG_FAILURE_ACTIONS, 
                                                       ppInfo[i] ) )
                        {
                            hresReapply = RETURNCODETOHRESULT( GetLastError() );
                        }
                        else
                        {
#if defined(VERBOSE_DEBUG)
                            OutputDebugString(_T("Reapply config for "));
                            OutputDebugString(pessDependentServices[i].lpServiceName);
                            OutputDebugString(_T(" : "));
                            TCHAR achErr[80];
                            wsprintf( achErr, _T("%d actions "), ((SERVICE_FAILURE_ACTIONS*)ppInfo[i])->cActions );
                            OutputDebugString(achErr);
                            OutputDebugString(_T("\n"));
#endif
                        }

                        CloseServiceHandle( schSrv );
                    }
                    else
                    {
                        hresReapply = RETURNCODETOHRESULT( GetLastError() );
                    }
                }
            }

            CloseServiceHandle( schSCM );
        }
    }

    if ( SUCCEEDED(hres) && FAILED(hresReapply) )
    {
        hres = hresReapply;
    }

    ReportStatus( IRSTAM_KILL, hres );

    if ( hAdvapi )
    {
        FreeLibrary( hAdvapi );
    }

    //
    // cleanup
    //

    if ( ppInfo )
    {
        for ( i = 0 ; i < dwNumServices ; ++i )
        {
            if ( ppInfo[i] )
            {
                LocalFree( ppInfo[i] );
            }
        }
        LocalFree( ppInfo );
    }

    if ( pbServiceList != NULL 
         && pbServiceList != abServiceList )
    {
        LocalFree( pbServiceList );
    }

    return hres;
}


//
// Helper functions
//

VOID 
EnableShutdownPrivilege(
    VOID
    )
/*++

    EnableShutdownPrivilege

        Enable shutdown privilege ( required to call ExitWindowsEx )

    Arguments:

        None

    Returns:
        Nothing. If error enabling the privilege the dependent operation
        will fail.

--*/
{
    HANDLE ProcessHandle;
    HANDLE TokenHandle = NULL;
    BOOL Result;
    LUID ShutdownValue;
    TOKEN_PRIVILEGES * TokenPrivileges;
    CHAR buf[ 5 * sizeof(TOKEN_PRIVILEGES) ];

    ProcessHandle = OpenProcess(
                        PROCESS_QUERY_INFORMATION,
                        FALSE,
                        GetCurrentProcessId()
                        );

    if ( ProcessHandle == NULL ) {

        //
        // This should not happen
        //

        goto Cleanup;
    }


    Result = OpenProcessToken (
                 ProcessHandle,
                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                 &TokenHandle
                 );

    if ( !Result ) {

        //
        // This should not happen
        //

        goto Cleanup;

    }

    //
    // Find out the value of Shutdown privilege
    //


    Result = LookupPrivilegeValue(
                 NULL,
                 SE_SHUTDOWN_NAME,
                 &ShutdownValue
                 );

    if ( !Result ) {

        goto Cleanup;
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges = (TOKEN_PRIVILEGES *) buf;

    TokenPrivileges->PrivilegeCount = 1;
    TokenPrivileges->Privileges[0].Luid = ShutdownValue;
    TokenPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                TokenPrivileges,
                sizeof(buf),
                NULL,
                NULL
                );
Cleanup:

    if ( TokenHandle )
    {
        CloseHandle( TokenHandle );
    }

    if ( ProcessHandle )
    {
        CloseHandle( ProcessHandle );
    }
}


#define SLEEP_INTERVAL	1000

#if 0

HRESULT
StopIIsAdmin(
	DWORD	dwTimeoutMsecs
	)
/*++

    StopIIsAdmin

        Stop the IISADMIN service using SCM

    Arguments:

        dwTimeoutMsecs  - timeout for status check ( in ms )

    Returns:
        COM status

--*/
{
    SC_HANDLE       schSCM = NULL;
    SC_HANDLE       schIISADMIN = NULL;
    HRESULT         hresReturn = S_OK;
    SERVICE_STATUS  ssServiceStop;


    schSCM = OpenSCManager( NULL,
                            NULL,
                            SC_MANAGER_ALL_ACCESS );

    if ( schSCM == NULL )
	{
        hresReturn = RETURNCODETOHRESULT( GetLastError() );
    }
    else 
	{
        schIISADMIN = OpenService( schSCM,
                                   TEXT("IISADMIN"),
                                   SERVICE_ALL_ACCESS);

        if (schIISADMIN != NULL)
        {
            ControlService( schIISADMIN, SERVICE_CONTROL_STOP, &ssServiceStop );

            if ( !WaitForServiceStatus(schIISADMIN, SERVICE_STOPPED, dwTimeoutMsecs) )
            {
                hresReturn = RETURNCODETOHRESULT( ERROR_SERVICE_REQUEST_TIMEOUT );
            }

            CloseServiceHandle( schIISADMIN );
        }
        else
        {
            hresReturn = RETURNCODETOHRESULT( GetLastError() );
        }

        CloseServiceHandle( schSCM );
    }

	return hresReturn;
}


BOOL
WaitForServiceStatus(
	SC_HANDLE   schDependent, 
	DWORD       dwDesiredServiceState,
	DWORD	    dwTimeoutMsecs
	)
/*++

    WaitForServiceStatus

        Wait for given state using timeout

    Arguments:
        
        schDependent - service to check
        dwDesiredServiceState - target state
        dwTimeoutMsecs  - timeout for status check ( in ms )

    Returns:
        COM status

--*/
{
    DWORD dwSleepTotal = 0;
	DWORD dwSleepInterval = SLEEP_INTERVAL;
    SERVICE_STATUS ssDependent;
	BOOL fSt = FALSE;

	if ( dwTimeoutMsecs < dwSleepInterval && dwTimeoutMsecs )
	{
		dwSleepInterval = dwTimeoutMsecs;
	}

	for ( ;; )
	{
        if ( QueryServiceStatus(schDependent, &ssDependent) )
		{
            if ( ssDependent.dwCurrentState == dwDesiredServiceState )
			{
				fSt = TRUE;
                break;
            }
            else 
			{
                //
                // Still pending...
                //

				if ( dwSleepTotal + dwSleepInterval > dwTimeoutMsecs )
				{
					break;
				}

                Sleep( dwSleepInterval );

                dwSleepTotal += dwSleepInterval;
            }
        }
        else 
		{
            break;
        }
	 }

	return fSt;
}

#endif

HRESULT
StartStopAll(
    LPTSTR  pszRoot,
    BOOL    fStart,
    DWORD   dwTimeoutMsecs
    )
/*++

    StartStopAll

        start or stop services dependency tree starting with specified root service

    Arguments:
        
        pszRoot - root of the service tree
        fStart - TRUE to start services, FALSE to stop
        dwTimeoutMsecs  - timeout for status check ( in ms )

    Returns:
        COM status

--*/
{
    SC_HANDLE               schSCM = NULL;
    SC_HANDLE               schRoot = NULL;
    HRESULT                 hresReturn = S_OK;
    ENUM_SERVICE_STATUS     ess;
    SERVICE_STATUS          ServiceStatus;


    schSCM = OpenSCManager(NULL,
                           NULL,
                           SC_MANAGER_ALL_ACCESS);
    if ( schSCM == NULL )
	{
        hresReturn = RETURNCODETOHRESULT( GetLastError() );
    }
    else 
	{
        if ( schRoot = OpenService( schSCM, pszRoot, SERVICE_ALL_ACCESS ) )
        {
            if ( !QueryServiceStatus( schRoot, &ess.ServiceStatus ) )
            {
                hresReturn = RETURNCODETOHRESULT( GetLastError() );
            }

            CloseServiceHandle( schRoot );

            if ( SUCCEEDED( hresReturn ) 
                    && ( fStart 
                         || ess.ServiceStatus.dwCurrentState != SERVICE_STOPPED) )
		    {
                ess.lpServiceName = pszRoot;

                // if it's stopped, then whack the dllhosts that have wam.dll loaded

                if (ess.ServiceStatus.dwCurrentState == SERVICE_STOPPED) 
                {
#if defined(VERBOSE_DEBUG)
                    OutputDebugString(_T("Attempt to kill MTX\n"));
#endif
                    KillTaskByName(_T("MTX"), "wam.dll");   // MTS WAM containers
#if defined(VERBOSE_DEBUG)
                    OutputDebugString(_T("Attempt to kill DLLHOST\n"));
#endif
                    KillTaskByName(_T("DLLHOST"),"wam.dll");   // COM+ WAM Containers
                }

                hresReturn = StartStopAllRecursive( schSCM, &ess, 1, fStart, TRUE, &dwTimeoutMsecs );

            }

            // check out the current state of the service

            if ( schRoot = OpenService( schSCM, pszRoot, SERVICE_ALL_ACCESS ) )
            {
                if ( QueryServiceStatus( schRoot, &ess.ServiceStatus ) )
                {
                    // if it's stopped, then whack the dllhosts that have wam.dll loaded

                    if (ess.ServiceStatus.dwCurrentState == SERVICE_STOPPED)
                    {
#if defined(VERBOSE_DEBUG)
                        OutputDebugString(_T("Attempt to kill MTX\n"));
#endif
                        KillTaskByName(_T("MTX"), "wam.dll");   // MTS WAM containers
#if defined(VERBOSE_DEBUG)
                        OutputDebugString(_T("Attempt to kill DLLHOST\n"));
#endif
                        KillTaskByName(_T("DLLHOST"),"wam.dll");   // COM+ WAM Containers
                    }
                }

                CloseServiceHandle( schRoot );
            }        
        }
        else
        {
            hresReturn = RETURNCODETOHRESULT( GetLastError() );
        }

        CloseServiceHandle( schSCM );
    }

    return hresReturn;
}



StartStopAllRecursive(
    SC_HANDLE               schSCM,
    ENUM_SERVICE_STATUS*    pessRoot,
    DWORD                   dwNumServices,
    BOOL                    fStart,
    BOOL                    fForceDemandStart,
    LPDWORD                 pdwTimeoutMsecs
    )
/*++

    StartStopAllRecursive

        start or stop services dependency tree starting with specified root service

    Arguments:
        
        schSCM - handle to SCM
        pessRoot - list of services to start/stop recursively
        fStart - TRUE to start services, FALSE to stop
        fForceDemandStart - for start requests: TRUE to force start
                if SERVICE_DEMAND_START. Otherwise only start if service
                is auto start ( including boot & system start )
        dwTimeoutMsecs  - timeout for status check ( in ms )

    Returns:
        COM status

--*/
{
    DWORD                   dwBytesNeeded;
    DWORD                   dwNumRecServices = 0;
    HRESULT                 hresReturn = S_OK;
    BYTE                    abServiceList[2048];
    LPBYTE                  pbServiceList = NULL;
    BYTE                    abServiceConfig[1024];
    LPQUERY_SERVICE_CONFIG  pServiceConfig = NULL;
    SC_HANDLE*              phServiceHandle = NULL;
    DWORD                   i;
    DWORD                   dwServiceConfigSize;
    SERVICE_STATUS          ServiceStatus;
    DWORD                   dwSleepTotal = 0;
	DWORD                   dwSleepInterval = SLEEP_INTERVAL;
    LPENUM_SERVICE_STATUS   pessDependentServices;


    if ( (phServiceHandle = (SC_HANDLE*)LocalAlloc( LMEM_FIXED|LMEM_ZEROINIT,
                                                    dwNumServices * sizeof(SC_HANDLE) )) == NULL ) 
	{
        hresReturn = RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
    }

    if ( SUCCEEDED(hresReturn) )
	{
        //
        // All services will be started/stopped at once
        // then periodically checked for status until all of them are running/stopped
        // or some error occured or timeout
        //

        if ( dwNumServices != 0 ) 
		{
            pServiceConfig = (LPQUERY_SERVICE_CONFIG)abServiceConfig;
            dwServiceConfigSize = sizeof( abServiceConfig );

            //
            // Open handles and send service control start command
            //

            for ( i = 0 ;
                  i < dwNumServices && SUCCEEDED(hresReturn) ; 
                  i++) 
			{
                //
                // Send command to Services
                //

#if defined(VERBOSE_DEBUG)

                WCHAR buffer[200];

                _snwprintf(buffer, 200, L"Working on the '%s' service\n", pessRoot[i].lpServiceName );

                buffer[199] = L'\0';

                OutputDebugString( buffer );
#endif

                phServiceHandle[i] = OpenService( schSCM,
                                                  pessRoot[i].lpServiceName,
                                                  SERVICE_ALL_ACCESS );

                if ( phServiceHandle[i] != NULL )
                {
                    if ( fStart )
                    {
                        //
                        // Query service config to check if service should be started
                        // based on its Start Type.
                        //

                        if ( !QueryServiceConfig( phServiceHandle[i], 
                                                  (LPQUERY_SERVICE_CONFIG)&abServiceConfig, 
                                                  dwServiceConfigSize, 
                                                  &dwBytesNeeded ) )
                        {
                            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) 
				            {
                                if ( (pServiceConfig = (LPQUERY_SERVICE_CONFIG)LocalAlloc( 
                                            LMEM_FIXED, 
                                            dwBytesNeeded )) == NULL ) 
					            {
                                    hresReturn = RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
                                }
                                else 
					            {
                                    dwServiceConfigSize = dwBytesNeeded;

                                    if ( !QueryServiceConfig( phServiceHandle[i], 
                                                              (LPQUERY_SERVICE_CONFIG)pServiceConfig, 
                                                              dwServiceConfigSize, 
                                                              &dwBytesNeeded ) )
                                    {
                                        hresReturn = RETURNCODETOHRESULT( GetLastError() );
                                    }
                                }
                            }
                            else
                            {
                                hresReturn = RETURNCODETOHRESULT( GetLastError() );
                            }
                        }

                        if ( SUCCEEDED(hresReturn) )
                        {
                            //
                            // Check if service auto start except if fForceDemandStart
                            // specified.  ForceDemandStart will only be specified for 
                            // the service that the command is directly issued on.  This 
                            // means that it will only be specified for IISADMIN.
                            //

                            if ( ( fForceDemandStart && pServiceConfig->dwStartType == SERVICE_DEMAND_START )
                                 || ( pServiceConfig->dwStartType == SERVICE_BOOT_START ||
                                      pServiceConfig->dwStartType == SERVICE_SYSTEM_START ||
                                      pServiceConfig->dwStartType == SERVICE_AUTO_START ) )
                            {
                                StartService( phServiceHandle[i], 0, NULL );

                                //
                                // Ask for only the services that are inactive.  So, for instance, 
                                // if we are attempting to restart the iisadmin service,
                                // and W3SVC is still active, we won't send it a command to restart.
                                //
                                hresReturn = EnumStartServices( schSCM,
                                                                pessRoot[i].lpServiceName,
                                                                SERVICE_INACTIVE,
                                                                abServiceList, 
                                                                sizeof(abServiceList), 
                                                                &pbServiceList, 
                                                                &dwNumRecServices,
                                                                FALSE );

                                if ( SUCCEEDED( hresReturn ) )
                                {
                                    hresReturn = StartStopAllRecursive( schSCM,
                                                                        (ENUM_SERVICE_STATUS*)pbServiceList,
                                                                        dwNumRecServices,
                                                                        fStart,
                                                                        FALSE,
                                                                        pdwTimeoutMsecs );

                                    if ( pbServiceList != NULL 
                                         && pbServiceList != abServiceList )
                                    {
                                        LocalFree( pbServiceList );
                                    }
                                }
                            }
                            else
                            {
                                //
                                // Don't want to start this service, so mark it
                                // as already running
                                //

                                if (wcscmp(pessRoot[i].lpServiceName,_T("IISADMIN")) == 0)
                                {
                                    hresReturn = RETURNCODETOHRESULT(ERROR_SERVICE_NOT_ACTIVE);
                                }
                                else
                                {
                                    pessRoot[i].ServiceStatus.dwCurrentState = SERVICE_RUNNING;
                                }
                            }
                        }
                    }
                    else  // handle stopping the service
                    {
                        if ( W3SVCandW3SSL(i, pessRoot, dwNumServices) )
                        {
                            continue;
                        }

                        // Remember if the service was stopped to start with.
                        BOOL fServiceWasStoppedToStartWith = ( pessRoot[i].ServiceStatus.dwCurrentState == SERVICE_STOPPED );
                        
                        // We will also need to stop dependent services if the are started all ready.
                        BOOL fHasDependentServices = FALSE;

                        if ( !fServiceWasStoppedToStartWith )
                        {
                            //
                            // if the service was not stopped to start with 
                            // we need to tell the service to stop.
                            //

#if defined(VERBOSE_DEBUG)

                            WCHAR buffer[200];

                            _snwprintf(buffer, 200, L"Sending a stop to %s\n", pessRoot[i].lpServiceName );

                            buffer[199] = L'\0';

                            OutputDebugString( buffer );
#endif

                            hresReturn = SendControlToService( phServiceHandle[i],
                                                               SERVICE_CONTROL_STOP,
                                                               pdwTimeoutMsecs );

                            if ( hresReturn == RETURNCODETOHRESULT( ERROR_SERVICE_REQUEST_TIMEOUT ) )
                            {
                                //
                                // WARNING!
                                //
                                // We're in trouble. Service did not respond in a timely fashion,
                                // and further attempt to use this handle ( including closing it )
                                // will also hang, so cancel the handle and leak it
                                //

                                phServiceHandle[i] = NULL;
                            }
                            else if ( hresReturn == RETURNCODETOHRESULT( ERROR_DEPENDENT_SERVICES_RUNNING ) )
                            {
                                fHasDependentServices = TRUE;
                            }
                        }

                        //
                        // If it was stopped to start with, or if it was not but it couldn't
                        // be stopped because it has dependent services.  Go ahead and stop
                        // the dependent services.
                        //
                        if ( fHasDependentServices || fServiceWasStoppedToStartWith )
                        {

#if defined(VERBOSE_DEBUG)

                            WCHAR buffer[200];

                            _snwprintf(buffer, 200, L"Enuming services for %s\n", pessRoot[i].lpServiceName );

                            buffer[199] = L'\0';

                            OutputDebugString( buffer );
#endif

                            //
                            // Get the services that are active because we 
                            // are only interested in stopping services that
                            // are actually running.
                            //
                            hresReturn = EnumStartServices( schSCM,
                                                            pessRoot[i].lpServiceName,
                                                            SERVICE_ACTIVE,
                                                            abServiceList, 
                                                            sizeof(abServiceList), 
                                                            &pbServiceList, 
                                                            &dwNumRecServices,
                                                            FALSE );

                            if ( SUCCEEDED( hresReturn ) )
                            {
                                hresReturn = StartStopAllRecursive( schSCM,
                                                                    (ENUM_SERVICE_STATUS*)pbServiceList,
                                                                    dwNumRecServices,
                                                                    fStart,
                                                                    FALSE,
                                                                    pdwTimeoutMsecs );

                                if ( pbServiceList != NULL 
                                     && pbServiceList != abServiceList )
                                {
                                    LocalFree( pbServiceList );
                                }
                            }

                            if ( SUCCEEDED( hresReturn ) )
                            {
                                //
                                // If the service itself is not all ready stopped, then stop
                                // the service.  It could be that it is stopped ( due to a crash )
                                // and the other services that were dependent on them are still
                                // running.
                                //
                                if ( !fServiceWasStoppedToStartWith )
                                {

#if defined(VERBOSE_DEBUG)

                                    WCHAR buffer[200];

                                    _snwprintf(buffer, 200, L"Sending a 2nd stop to %s\n", pessRoot[i].lpServiceName );

                                    buffer[199] = L'\0';

                                    OutputDebugString( buffer );
#endif

                                    hresReturn = SendControlToService( phServiceHandle[i],
                                                                       SERVICE_CONTROL_STOP,
                                                                       pdwTimeoutMsecs );
                                }
                            }
                        }

                        if ( FAILED( hresReturn ) )
                        {

#if defined(VERBOSE_DEBUG)

                            WCHAR buffer[200];

                            _snwprintf(buffer, 200, L"Failed to stop service %s with %x hresult\n", pessRoot[i].lpServiceName, hresReturn );

                            buffer[199] = L'\0';

                            OutputDebugString( buffer );
#endif

                            break;
                        }
                    }  // end of stopping code
                }  // end of valid service handle
            }  // end of loop

            //
            // Check service running
            //

	        if ( (*pdwTimeoutMsecs < dwSleepInterval) && *pdwTimeoutMsecs )
	        {
		        dwSleepInterval = *pdwTimeoutMsecs;
	        }

            for ( ;
                  SUCCEEDED( hresReturn );
                )
            {
                for ( i = 0 ;
                      i < dwNumServices; 
                      i++) 
				{
                    //
                    // Only query status for services known to be not running
                    //

                    if ( pessRoot[i].ServiceStatus.dwCurrentState 
                                != (DWORD)(fStart ? SERVICE_RUNNING : SERVICE_STOPPED) )
                    {
                        if ( QueryServiceStatus( phServiceHandle[i], &ServiceStatus ) )
		                {
                            //
                            // remember status
                            //

                            pessRoot[i].ServiceStatus.dwCurrentState = ServiceStatus.dwCurrentState;

                            if ( fStart && ServiceStatus.dwCurrentState == SERVICE_STOPPED )
                            {
                                //
                                // Service died during startup. no point keeping polling
                                // for service state : return an error
                                //

                                hresReturn = RETURNCODETOHRESULT( ERROR_SERVICE_NOT_ACTIVE );
                                break;
                            }

                            if ( ServiceStatus.dwCurrentState != (DWORD)(fStart ? SERVICE_RUNNING : SERVICE_STOPPED) )
                            {
                                //
                                // will keep looping waiting for target service state
                                //

                                break;
                            }
                        }
                        else
                        {
                            hresReturn = RETURNCODETOHRESULT( GetLastError() );
                            break;
                        }
                    }
                }

                //
                // if we did not checked all services then at least one of them
                // is not running ( or some error occured )
                //

                if ( SUCCEEDED( hresReturn ) && i != dwNumServices )
                {
				    if ( dwSleepInterval > *pdwTimeoutMsecs )
				    {
                        hresReturn = RETURNCODETOHRESULT( ERROR_SERVICE_REQUEST_TIMEOUT );
				    }
                    else
                    {
                        Sleep( dwSleepInterval );

                        *pdwTimeoutMsecs -= dwSleepInterval;
                    }
                }
                else
                {
                    break;
                }
            }

            //
            // close service handles
            //

            for ( i = 0 ;
                  i < dwNumServices; 
                  i++) 
			{
                if ( phServiceHandle[i] != 0 )
                {
                    CloseServiceHandle( phServiceHandle[i] );
                }
            }
        }

        LocalFree( phServiceHandle );
    }

    if ( pServiceConfig != NULL 
         && pServiceConfig != (LPQUERY_SERVICE_CONFIG)abServiceConfig )
    {
        LocalFree( pServiceConfig );
    }

    return hresReturn;
}

//
// control block for control command requests
//

typedef struct {
    HRESULT     hres;
    LONG        lRefCount;
    DWORD       dwCmd;
    SC_HANDLE   hServiceHandle;
} SERVICE_COMMAND_CONTROL_BLOCK;


extern "C"
DWORD WINAPI
ControlServiceThread(
    LPVOID  p
    )
/*++

    ControlServiceThread

        Send a command to a service

    Arguments:
        
        p - ptr to SERVICE_COMMAND_CONTROL_BLOCK

    Returns:
        0

--*/
{
    SERVICE_STATUS                  ssStatus;
    SERVICE_COMMAND_CONTROL_BLOCK*  pCB = (SERVICE_COMMAND_CONTROL_BLOCK*)p;


    if ( !ControlService( pCB->hServiceHandle, pCB->dwCmd, &ssStatus ) )
    {
        pCB->hres = RETURNCODETOHRESULT( GetLastError() );
    }
    else
    {
        pCB->hres = S_OK;
    }

    if ( InterlockedDecrement( &pCB->lRefCount ) == 0 )
    {
        delete pCB;
    }

    return 0;
}


HRESULT
SendControlToService( 
    SC_HANDLE   hServiceHandle,
    DWORD       dwCmd,
    LPDWORD     pdwTimeoutMsecs
    )
/*++

    ControlServiceThread

        Send a command to a service with timeout

    Arguments:
        
        hServiceHandle - service to control
        dwCmd - command to send to service
        pdwTimeoutMsecs - timeout ( in ms ). updated on output based on time
                spent waiting for service status

    Returns:
        ERROR_SERVICE_REQUEST_TIMEOUT if timeout
        otherwise COM status

--*/
{
    HANDLE                          hT;
    DWORD                           dwID;
    DWORD                           dwBefore;
    DWORD                           dwAfter;
    SERVICE_COMMAND_CONTROL_BLOCK*  pCB;
    DWORD                           dwTimeoutMsecs = *pdwTimeoutMsecs;
    HRESULT                         hres;


    //
    // Default timeout for ControlService is 120s, which is too long for us
    // so we create a thread to call ControlService and wait for thread
    // termination.
    // Communication between threads is handled by a refcounted control block 
    //

    if ( pCB = new SERVICE_COMMAND_CONTROL_BLOCK )
    {
        pCB->lRefCount = 2;     // 1 for caller, 1 for callee
        pCB->dwCmd = dwCmd;
        pCB->hServiceHandle = hServiceHandle;
        pCB->hres = S_OK;

        dwBefore = GetTickCount();

        if ( hT = CreateThread( NULL, 
                                0, 
                                (LPTHREAD_START_ROUTINE)ControlServiceThread, 
                                (LPVOID)pCB, 
                                0, 
                                &dwID ) )
        {
            if ( WaitForSingleObject( hT, dwTimeoutMsecs ) == WAIT_OBJECT_0 )
            {
                hres = pCB->hres;
            }
            else
            {
                hres = RETURNCODETOHRESULT( ERROR_SERVICE_REQUEST_TIMEOUT );
            }

            CloseHandle( hT );

            if ( InterlockedDecrement( &pCB->lRefCount ) == 0 )
            {
                delete pCB;
            }

            //
            // Update caller's timeout
            //

            dwAfter = GetTickCount();

            if ( dwAfter > dwBefore )
            {
                if ( dwAfter - dwBefore <= dwTimeoutMsecs )
                {
                    *pdwTimeoutMsecs -= dwAfter - dwBefore;
                }
                else
                {
                    *pdwTimeoutMsecs = 0;
                }
            }
        }
        else
        {
            delete pCB;

            hres = RETURNCODETOHRESULT( GetLastError() );
        }
    }
    else
    {
        hres = RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
    }

    return hres;
}


HRESULT
SerializeEnumServiceBuffer( 
    LPENUM_SERVICE_STATUS   pessDependentServices,
    DWORD                   dwNumServices,
    LPBYTE                  pbBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwMDRequiredBufferSize 
    )
/*++

    SerializeEnumServiceBuffer

        Serialize array of ENUM_SERVICE_STATUS to buffer,
        replacing ptr by offset in buffer

    Arguments:
        
        pessDependentServices - array of ENUM_SERVICE_STATUS to serialize
        dwNumServices - # of entries in pessDependentServices
        pbBuffer - buffer filled with serialized status as array of SERIALIZED_ENUM_SERVICE_STATUS
        dwBufferSize - maximum size of pbBuffer
        pdwMDRequiredBufferSize - updated with required size if dwBufferSize too small

    Returns:
        ERROR_INSUFFICIENT_BUFFER if dwBufferSize too small
        otherwise COM status

--*/
{
    HRESULT     hresReturn = S_OK;
    DWORD       dwMinSize = 0;
    UINT        i;

    if ( !pbBuffer )
    {
        dwBufferSize = 0;
    }

    //
    // size of output buffer is based on size of array of SERIALIZED_ENUM_SERVICE_STATUS
    // plus size of all strings : service name & display name for each entry
    //

    dwMinSize = sizeof(SERIALIZED_ENUM_SERVICE_STATUS) * dwNumServices;

    for ( i = 0 ;
          i < dwNumServices ; 
          ++i )
    {
        UINT    cServiceName = _tcslen( pessDependentServices[i].lpServiceName ) + 1;
        UINT    cDisplayName = _tcslen( pessDependentServices[i].lpDisplayName ) + 1;

        //
        // do not update if output buffer is too small, but keep looping to determine
        // total size
        //

        if ( dwBufferSize >= dwMinSize + (cServiceName + cDisplayName) * sizeof(TCHAR)  )
        {
            //
            // copy service status as is
            //

            ((SERIALIZED_ENUM_SERVICE_STATUS*)pbBuffer)[i].ServiceStatus =
                    pessDependentServices[i].ServiceStatus;

            //
            // copy string and convert ptr to string to index in output buffer
            //

            memcpy( pbBuffer + dwMinSize, pessDependentServices[i].lpServiceName, cServiceName * sizeof(TCHAR) ); 
            ((SERIALIZED_ENUM_SERVICE_STATUS*)pbBuffer)[i].iServiceName = dwMinSize ;

            memcpy( pbBuffer + dwMinSize + cServiceName * sizeof(TCHAR), pessDependentServices[i].lpDisplayName, cDisplayName * sizeof(TCHAR)  );
            ((SERIALIZED_ENUM_SERVICE_STATUS*)pbBuffer)[i].iDisplayName = dwMinSize + cServiceName * sizeof(TCHAR) ;
        }

        dwMinSize += (cServiceName + cDisplayName) * sizeof(TCHAR) ;
    }

    if ( dwBufferSize < dwMinSize )
    {
        *pdwMDRequiredBufferSize = dwMinSize;

        hresReturn = RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );
    }

    return hresReturn;
}



STDMETHODIMP 
CIisRestart::Status(
    DWORD           dwBufferSize, 
    unsigned char * pbBuffer, 
    DWORD *         pdwMDRequiredBufferSize, 
    DWORD *         pdwNumServices
    )
/*++

    Status

        Return status of all internet services as array of ENUM_SERVICE_STATUS

    Arguments:
        
        dwBufferSize - maximum size of pbBuffer
        pbBuffer - buffer filled with serialized status as array of SERIALIZED_ENUM_SERVICE_STATUS
        pdwMDRequiredBufferSize - updated with required size if dwBufferSize too small
        pdwNumServices - updated with number of entries stored in pbBuffer

    Returns:
        ERROR_RESOURCE_DISABLED if access to restart commands disabled
        ERROR_INSUFFICIENT_BUFFER if dwBufferSize too small
        otherwise COM status

--*/
{
    SC_HANDLE               schSCM = NULL;
    DWORD                   dwBytesNeeded;
    DWORD                   dwNumServices = 0;
    HRESULT                 hresReturn = E_FAIL;
    BYTE                    abServiceList[2048];
    LPBYTE                  pbServiceList = NULL;
    LPENUM_SERVICE_STATUS   pessDependentServices;


    if ( !IsEnableRemote() )
    {
        hresReturn = RETURNCODETOHRESULT( ERROR_RESOURCE_DISABLED );
    }
    else
    {
        schSCM = OpenSCManager(NULL,
                               NULL,
                               SC_MANAGER_ALL_ACCESS);
        if ( schSCM == NULL )
	    {
            hresReturn = RETURNCODETOHRESULT( GetLastError() );
        }
        else 
	    {
            hresReturn = EnumStartServices( schSCM,
                                            _T("IISADMIN"),
                                            SERVICE_STATE_ALL,
                                            abServiceList, 
                                            sizeof(abServiceList), 
                                            &pbServiceList, 
                                            pdwNumServices,
                                            FALSE );

            if ( SUCCEEDED(hresReturn) )
		    {
                pessDependentServices = (LPENUM_SERVICE_STATUS)pbServiceList;

                hresReturn = SerializeEnumServiceBuffer( (LPENUM_SERVICE_STATUS)pbServiceList,
                                                         *pdwNumServices,
                                                         pbBuffer,
                                                         dwBufferSize,
                                                         pdwMDRequiredBufferSize );

                if ( pbServiceList != NULL 
                     && pbServiceList != abServiceList )
                {
                    LocalFree( pbServiceList );
                }
            }

            CloseServiceHandle(schSCM);
        }
    }

	return hresReturn;
}


HRESULT
EnumStartServices(
    SC_HANDLE   schSCM,
    LPTSTR      pszRoot,
    DWORD       dwTargetState,
    LPBYTE      abServiceList,
    DWORD       dwInitializeServiceListSize,
    LPBYTE*     ppbServiceList,
    LPDWORD     pdwNumServices,
    BOOL        fAddIisadmin
    )
/*++

    EnumStartServices

        Enumerate dependent services to output buffer as array of ENUM_SERVICE_STATUS

    Arguments:
        
        schSCM - handle to SCM
        pszRoot - service for which to enumerate dependencies
        dwTargetState - dwServiceState for call to EnumDependentServices()
        abServiceList - initial output buffer
        dwInitializeServiceListSize - maximum size of abServiceList
        ppbServiceList - updated with output buffer, may be abServiceList if long enough
                otherwise returned buffer is to be freed using LocalFree()
        pdwNumServices - updated with number of entries stored in pbBuffer
        fAddIisadmin - TRUE to add IISADMIN to list of dependent services

    Returns:
        COM status

--*/
{
    HRESULT     hresReturn = S_OK;
    SC_HANDLE   schIISADMIN = NULL;
    DWORD       dwBytesNeeded;
    DWORD       dwAddSize = 0;
    DWORD       dwOffsetSize = 0;


    *ppbServiceList = NULL;

    schIISADMIN = OpenService(schSCM,
                              pszRoot,
                              STANDARD_RIGHTS_REQUIRED | SERVICE_ENUMERATE_DEPENDENTS);
    if (schIISADMIN == NULL) 
	{
        hresReturn = RETURNCODETOHRESULT(GetLastError());
    }
    else 
	{
        if ( fAddIisadmin )
        {
            //
            // if initial size too small for Iisadmin description then fail
            //

            dwOffsetSize = sizeof(ENUM_SERVICE_STATUS );
            dwAddSize = dwOffsetSize;
            if ( dwAddSize > dwInitializeServiceListSize )
            {
                hresReturn = RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
                goto Cleanup;
            }

            //
            // Use global static name for IISADMIN, no need to copy it to output buffer
            //

            ((LPENUM_SERVICE_STATUS)abServiceList)->lpDisplayName = _T("IISADMIN");
            ((LPENUM_SERVICE_STATUS)abServiceList)->lpServiceName = _T("IISADMIN");

            //
            // don't want to check service status at this point as it may be stuck
            // so assume RUNNING. 
            //

            ((LPENUM_SERVICE_STATUS)abServiceList)->ServiceStatus.dwCurrentState = SERVICE_RUNNING;
        }

        if (!EnumDependentServices( schIISADMIN,
                                    dwTargetState,
                                    (LPENUM_SERVICE_STATUS)(abServiceList + dwOffsetSize),
                                    dwInitializeServiceListSize - dwAddSize,
                                    &dwBytesNeeded,
                                    pdwNumServices)) 
		{
            if (GetLastError() == ERROR_MORE_DATA)
			{
                if ( (*ppbServiceList = (LPBYTE)LocalAlloc( LMEM_FIXED, 
                                                            dwBytesNeeded + dwAddSize )) == NULL ) 
				{
                    hresReturn = RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
                }
                else 
				{
                    memcpy( *ppbServiceList, abServiceList, dwOffsetSize );

                    if (!EnumDependentServices( schIISADMIN,
                                                SERVICE_INACTIVE,
                                                (LPENUM_SERVICE_STATUS)(*ppbServiceList + dwOffsetSize),
                                                dwBytesNeeded,
                                                &dwBytesNeeded,
                                                pdwNumServices)) 
					{
                        hresReturn = RETURNCODETOHRESULT( GetLastError() );
                        LocalFree( *ppbServiceList );
                        *ppbServiceList = NULL;
                    }
                }
            }
            else 
			{
                hresReturn = RETURNCODETOHRESULT( GetLastError() );
            }
        }
        else
        {
            *ppbServiceList = abServiceList;
        }
    }

Cleanup:

    if ( schIISADMIN ) 
    {
        CloseServiceHandle( schIISADMIN );
    }

    if ( fAddIisadmin && SUCCEEDED( hresReturn ) )
    {
        ++*pdwNumServices;
    }

    return hresReturn;
}


BOOL
IsEnableRemote(
    )
/*++

    IsEnableRemote

        Check if restart I/F enabled
        ( based on HKLM\SOFTWARE\Microsoft\INetStp::EnableRestart::REG_DWORD )

    Arguments:
        
        None

    Returns:
        TRUE if enabled, otherwise FALSE

--*/
{
    BOOL    fSt = FALSE;
    HKEY    hKey;
    DWORD   dwValue;
    DWORD   dwType;
    DWORD   dwSize;


    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                       TEXT("SOFTWARE\\Microsoft\\INetStp"), 
                       0, 
                       KEY_READ, 
                       &hKey ) == ERROR_SUCCESS )
    {
        dwSize = sizeof( dwValue );
        if ( RegQueryValueEx( hKey, 
                              TEXT("EnableRestart"),
                              0, 
                              &dwType, 
                              (LPBYTE)&dwValue, 
                              &dwSize ) == ERROR_SUCCESS )
        {
            fSt = dwValue == 1;
        }
        else
        {
            fSt = TRUE;
        }

        RegCloseKey( hKey );
    }

    return fSt;
}


BOOL
CloseSystemExceptionHandler(
    LPCTSTR     pszWindowName
    )
/*++

    CloseSystemExceptionHandler

        Send a close ( e.g. terminate apps without debugging ) command to the window
        created by NT when a debugger is not configured to automatically start after app exception.
        This window stays on screen until interactive user select either OK or debug app, which is
        a problem for automated restart.
        So we locate this window and send it a command requesting stop w/o debugging.
        We locate the window by enumerating all windows and checking for window name beginning with the name
        of the application that raised an exception, e.g. "inetinfo.exe"

    Arguments:
        
        pszWindowName - window name where to send terminate command

    Returns:
        TRUE if SUCCESS, otherwise FALSE

--*/
{
    BOOL        fSt = TRUE;
    HKEY        hKey;
    DWORD       dwValue;
    DWORD       dwType;
    DWORD       dwSize;
    TASK_LIST   tl;
    TCHAR       achBuffer[MAX_PATH];

    GetPidFromTitle( &tl.dwProcessId, (HWND*)&tl.hwnd, pszWindowName );

    if ( tl.dwProcessId )
    {
#if 0
        //
        // Original idea was to close the exception window, but this fires up the debugger, so I attempted
        // to disable the debugger before closing the window, but this does not work as this setting is 
        // apparently not dynamic, i.e. you have to restart NT for this to take effect.
        //

        if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                           TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug"), 
                           0, 
                           KEY_READ|KEY_WRITE, 
                           &hKey ) == ERROR_SUCCESS )
        {
            dwSize = sizeof( achBuffer );
            if ( RegQueryValueEx( hKey, 
                                  TEXT("Debugger"),
                                  0, 
                                  &dwType, 
                                  (LPBYTE)achBuffer, 
                                  &dwSize ) != ERROR_SUCCESS )
            {
                RegCloseKey( hKey );

                return FALSE;
            }

            if ( RegSetValueEx( hKey, 
                           TEXT("Debugger"),
                           0, 
                           REG_SZ, 
                           (const BYTE*)TEXT(""),
                           sizeof(TCHAR) ) != ERROR_SUCCESS )
            {
            }

            RegCloseKey( hKey );
        }
        else
        {
            return FALSE;
        }
#endif

#if defined(VERBOSE_DEBUG)
        OutputDebugString(_T("located exception window, try to close it\n"));
#endif

        //PostMessage( (HWND)tl.hwnd, WM_CLOSE, 0, 0 );

        //
        // WARNING: major hack: turns out that WM_COMMAND 1 is the command to send to
        // the exception handler to ask it to close application w/o debugging
        // This works for NT5, may change in the future...
        //

        PostMessage( (HWND)tl.hwnd, WM_COMMAND, 1, 0 );

        Sleep( 1000 );

#if 0
        if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                           TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug"), 
                           0,
                           KEY_WRITE, 
                           &hKey ) == ERROR_SUCCESS )
        {
            if ( RegSetValueEx( hKey, 
                                TEXT("Debugger"),
                                0, 
                                REG_SZ, 
                                (const BYTE*)achBuffer, 
                                dwSize ) == ERROR_SUCCESS )
            {
                fSt = TRUE;
            }

            RegCloseKey( hKey );
        }
#endif
    }
    else
    {
        fSt = TRUE;
    }

    return fSt;
}


HRESULT
KillTaskByName(
    LPTSTR  pname,
    LPSTR   pszMandatoryModule
    )
/*++

    KillTaskByName

        Kill a process by name
        Most of the code was taken from the Platform SDK kill,c sample, and
        utilizes the common.c module included in this project.
        Works only on NT platforms ( NOT Win 9x )

    Arguments:
        
        pname - name of process to kill ( name of executable w/o extension )
        pszMandatoryModule - module name to look for, e.g. "wam.dll"
            can be NULL for unconditional kill

    Returns:
        COM status

--*/
{
	TASK_LIST         tlist[MAX_TASKS];
    DWORD             i;
    DWORD             numTasks;
    TASK_LIST_ENUM    te;
    TCHAR             tname[PROCESS_SIZE];
    LPTSTR            p;
    OSVERSIONINFO     verInfo = {0};
    LPGetTaskList     GetTaskList;
    LPEnableDebugPriv EnableDebugPriv;
	BOOL              fSuccess = TRUE;
    HRESULT           hres = S_OK;

    //
    // Determine what system we're on and do the right thing
    //

    verInfo.dwOSVersionInfoSize = sizeof (verInfo);
    GetVersionEx(&verInfo);

    switch (verInfo.dwPlatformId)
    {
        case VER_PLATFORM_WIN32_NT:
           GetTaskList     = GetTaskListNT;
           EnableDebugPriv = EnableDebugPrivNT;
           break;
#if 0
        case VER_PLATFORM_WIN32_WINDOWS:
           GetTaskList = GetTaskList95;
           EnableDebugPriv = EnableDebugPriv95;
           break;
#endif
        default:
           return RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }

    //
    // Obtain the ability to manipulate other processes
    //

    EnableDebugPriv();

    //
    // get the task list for the system
    //

    hres = GetTaskList( tlist, MAX_TASKS, pname, &numTasks, TRUE, pszMandatoryModule );

#if 0
    //
    // enumerate all windows and try to get the window
    // titles for each task
    //
    
	te.tlist = tlist;
    te.numtasks = numTasks;
    GetWindowTitles( &te );

    for (i=0; i<numTasks; i++)
	{
        tname[0] = 0;
        lstrcpy( tname, tlist[i].ProcessName );
        p = _tcschr( tname, _T('.') );
        if (p) 
        {
            p[0] = _T('\0');
        }

        if (MatchPattern( tname, pname )) 
        {
            tlist[i].flags = TRUE;
        } 
        else if (MatchPattern( tlist[i].ProcessName, pname )) 
        {
            tlist[i].flags = TRUE;
        } 
        else if (MatchPattern( tlist[i].WindowTitle, pname )) 
        {
            tlist[i].flags = TRUE;
        }
    }
#endif

#if 0
    for (i=0; i<numTasks; i++) 
    {
        if (tlist[i].flags) 
        {
            if ( FAILED( hres = KillProcess( &tlist[i], TRUE ) ) )
            {
                break;
            }
        }
    }
#endif

	return hres;
}


VOID
ReportStatus(
    DWORD   dwId,
    DWORD   dwStatus
    )
/*++

    ReportStatus

        Log status event

    Arguments:
        
        dwId - ID of event to log ( source is "IISCTLS" , SYSTEM log )
        dwStatus - status of operation ( HRESULT )

    Returns:
        Nothing

--*/
{
    HANDLE  hLog;
    LPTSTR  aParams[1];

    if ( (hLog = RegisterEventSource( NULL, _T("IISCTLS") )) != NULL )
    {
        if ( SUCCEEDED( WhoAmI( aParams + 0 ) ) )
        {
            ReportEvent( hLog, 
                         EVENTLOG_INFORMATION_TYPE, 
                         0, 
                         dwId, 
                         NULL, 
                         1, 
                         sizeof(DWORD), 
                         (LPCTSTR*)aParams, 
                         &dwStatus );
            LocalFree( aParams[0] );
        }

        DeregisterEventSource( hLog );
    }
}


HRESULT
WhoAmI(
    LPTSTR* ppPrincipal
    )
/*++

    WhoAmI

        Return currently impersonated user
        As this is a COM server running under the identity of the invoker
        this means we access the process token. So we might end up getting
        the wrong user name if the object is invoked in close succession 
        ( within the 5s server exit timeout ) by different users.

    Arguments:
        
        ppPrincipal - update with ptr to string containing user name ( domain\acct )
                      must be freed using LocalFree()

    Returns:
        Error status

--*/
{
    TCHAR*          pPrincipal;
    TCHAR           achUserName[512];
    TCHAR           achDomain[512];
    DWORD           dwLen;
    DWORD           dwDomainLen;
	DWORD           SIDsize = 256;
	SID_NAME_USE    SIDtype = SidTypeUser;
	LPSTR           lpszUsr;
    HRESULT         hres = E_FAIL;


#if 0
    //
    // naive attempt to retrieve user name and domain.
    // Unfortunately a LookupAccountName() followed by LookupAccountSid always return
    // the local domain ( typically the local computer name )
    // even if the account is a domain account.
    // So we can't use this...
    //

	PSID            pUserSID = (PSID)LocalAlloc( LMEM_FIXED, SIDsize);
    if ( !GetUserName( achUserName, &dwLen ) )
        wcscpy(achUserName, _T("Unknown user"));

	LookupAccountName(NULL, achUserName, pUserSID, &SIDsize,
		achDomain, &dwDomainLen, &SIDtype);

    dwLen = sizeof( achUserName );
    dwDomainLen = sizeof(achDomain);
	LookupAccountSid(NULL, pUserSID, achUserName, &dwLen,
		achDomain, &dwDomainLen, &SIDtype);

	_wcsupr(achDomain);

	wcscat(szMsg,achDomain);
	wcscat(szMsg,_T("\\"));
	wcscat(szMsg,achUserName);
#else

#if 0
    //
    // Attempt to retrieve the thread token instead of the process token.
    // doesn't work for COM servers
    //

    IServerSecurity* pSec;

    if ( SUCCEEDED( CoGetCallContext( IID_IServerSecurity, 
                                      (void**)&pSec ) ) )
    {
        DWORD       AuthnSvc;
        DWORD       AuthzSvc;
        OLECHAR*    pServerPrincName;
        DWORD       AuthnLevel;
        DWORD       ImpLevel;
        void*       pPrivs;
        DWORD       Capabilities = 0;
        //if ( FAILED(pSec->QueryBlanket( &AuthnSvc, &AuthzSvc, &pServerPrincName, &AuthnLevel, &ImpLevel, &pPrivs, &Capabilities)) )
        if ( FAILED(pSec->ImpersonateClient()) )
        {
        }
        else
        {
#endif
            //
            // So we have to access the process token and retrieve account & user name
            // by using LookupAccountSid()
            //

            HANDLE          hAccTok = NULL;

            if ( OpenProcessToken( GetCurrentProcess(),
                                   TOKEN_EXECUTE|TOKEN_QUERY,
                                   &hAccTok ) )
            {
                BYTE    abSidAndInfo[512];
                DWORD   dwReq;

                //
                // provide a reasonably sized buffer. If this fails we don't
                // retry with a bigger one.
                //

                if ( GetTokenInformation( hAccTok, 
                                          TokenUser, 
                                          (LPVOID)abSidAndInfo, 
                                          sizeof(abSidAndInfo), 
                                          &dwReq) )
                {
                    dwLen = sizeof( achUserName ) / sizeof(TCHAR);
                    dwDomainLen = sizeof(achDomain) / sizeof(TCHAR);

                    //
                    // provide a reasonably sized buffer. If this fails we don't
                    // retry with a bigger one.
                    //

	                if ( LookupAccountSid( NULL, 
                                           ((SID_AND_ATTRIBUTES*)abSidAndInfo)->Sid, 
                                           achUserName, 
                                           &dwLen,
		                                   achDomain, 
                                           &dwDomainLen, 
                                           &SIDtype) )
                    {
                        //
                        // We return a LocalAlloc'ed buffer
                        //

                        dwLen = _tcslen( achUserName );
                        dwDomainLen = _tcslen( achDomain );

                        if ( pPrincipal = (LPTSTR)LocalAlloc( LMEM_FIXED, 
                                                              (dwLen + 1 + dwDomainLen + 1 ) * sizeof(TCHAR) ) )
                        {
                            memcpy( pPrincipal, 
                                    achDomain, 
                                    sizeof(TCHAR)*dwDomainLen );
                            pPrincipal[dwDomainLen] = '\\';
                            memcpy( pPrincipal + dwDomainLen + 1, 
                                    achUserName, 
                                    sizeof(TCHAR)*(dwLen+1) );
                            *ppPrincipal = pPrincipal;

                            hres = S_OK;
                        }
                        else
                        {
    		                hres = RETURNCODETOHRESULT( ERROR_NOT_ENOUGH_MEMORY );
                        }
                    }
                    else
                    {
    		            hres = RETURNCODETOHRESULT( GetLastError() );
                    }
                }
                else
                {
    		        hres = RETURNCODETOHRESULT( GetLastError() );
                }

                CloseHandle( hAccTok );
            }
            else
            {
    		    hres = RETURNCODETOHRESULT( GetLastError() );
            }
#if 0
        }

        pSec->Release();
    }
    else
    {
        OutputDebugString(_T("fail to get call context"));
    }
#endif

#endif

    return hres;
}

BOOL
W3SVCandW3SSL(
    DWORD currentIndex, 
    ENUM_SERVICE_STATUS* pessRoot,
    DWORD dwNumServices
    )
{
/*++

    W3SVCandW3SSL

        Return currently impersonated user
        As this is a COM server running under the identity of the invoker
        this means we access the process token. So we might end up getting
        the wrong user name if the object is invoked in close succession 
        ( within the 5s server exit timeout ) by different users.

    Arguments:
        
        DWORD currentIndex - index of the service we are deciding if we should process.
        ENUM_SERVICE_STATUS* pessRoot - the set of services we are working on.
        DWORD dwNumServices - the number of services in the set.

    Returns:
        TRUE if we found the w3svc and w3ssl on the same line and we are looking at the w3svc


--*/

    BOOL bResult = FALSE;

    // check if we are looking at the w3svc.  If we are find out if the
    // w3ssl is on the same level.  Note the w3ssl will always be listed
    // after the w3svc.
    if ( _wcsicmp( pessRoot[currentIndex].lpServiceName, L"w3svc" ) == 0 )
    {
        for ( DWORD i = currentIndex + 1;
              ( i < dwNumServices ) && ( bResult == FALSE );
              i++ )
        {
            if ( _wcsicmp( pessRoot[i].lpServiceName, L"w3ssl" ) == 0 )
            {
                bResult = TRUE;
            }
        }
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\restart\interfac\main.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    DLL startup routine.

Author:

    Keith Moore (keithmo)       17-Feb-1997

Revision History:

--*/


extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbgutil.h>

}   // extern "C"

#include <iisrsta.h>


//
// Private globals.
//

//DECLARE_DEBUG_PRINTS_OBJECT();


//
// Private prototypes.
//


//
// DLL Entrypoint.
//

extern "C" {

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    BOOL status = TRUE;

    switch( dwReason ) {

    case DLL_PROCESS_ATTACH :
//        CREATE_DEBUG_PRINT_OBJECT( "iisrstap" );
        DisableThreadLibraryCalls( hDll );
        break;

    case DLL_PROCESS_DETACH :
//        DELETE_DEBUG_PRINT_OBJECT();
        break;

    }

    return status;

}   // DLLEntry

}   // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\admin.cpp ===
// admin.cpp : Implementation of CsmtpadmApp and DLL registration.

#include "stdafx.h"
#include "metautil.h"

#include "smtpadm.h"
#include "smtpcmn.h"
#include "smtpprop.h"
#include "admin.h"
#include "version.h"
#include "oleutil.h"

#include "metakey.h"

#define SMTP_DEF_SERVICE_VERSION	( 0 )	//  MCIS

// Must define THIS_FILE_* macros to use NntpCreateException()

#define THIS_FILE_HELP_CONTEXT          0
#define THIS_FILE_PROG_ID                       _T("Smtpadm.Admin.1")
#define THIS_FILE_IID                           IID_ISmtpAdmin

/////////////////////////////////////////////////////////////////////////////
//

CSmtpAdmin::CSmtpAdmin () :
	m_dwServiceInstance		( 0 )
	// CComBSTR's are initialized to NULL by default.
{
	m_dwServiceVersion	= SMTP_DEF_SERVICE_VERSION;
}

CSmtpAdmin::~CSmtpAdmin ()
{
	// All CComBSTR's are freed automatically.
}

STDMETHODIMP CSmtpAdmin::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ISmtpAdmin,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CSmtpAdmin::get_ServiceAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	BSTR						bstrT = _T("");
	CComPtr<ISmtpAdminService>	pISmtpAdminService;

	hr = StdPropertyHandoffIDispatch (
		CLSID_CSmtpAdminService,
		IID_ISmtpAdminService,
		&pISmtpAdminService, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pISmtpAdminService->put_Server ( m_strServer ? m_strServer : bstrT );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pISmtpAdminService
}

STDMETHODIMP CSmtpAdmin::get_VirtualServerAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	BSTR								bstrT = _T("");
	CComPtr<ISmtpAdminVirtualServer>	pISmtpAdminVirtualServer;

	hr = StdPropertyHandoffIDispatch (
		CLSID_CSmtpAdminVirtualServer,
		IID_ISmtpAdminVirtualServer,
		&pISmtpAdminVirtualServer, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pISmtpAdminVirtualServer->put_Server ( m_strServer ? m_strServer : bstrT );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pISmtpAdminVirtualServer->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pISmtpAdminVirtualServer
}

STDMETHODIMP CSmtpAdmin::get_SessionsAdmin ( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	BSTR						bstrT = _T("");
	CComPtr<ISmtpAdminSessions>	pISmtpAdminSessions;

	hr = StdPropertyHandoffIDispatch (
		CLSID_CSmtpAdminSessions,
		IID_ISmtpAdminSessions,
		&pISmtpAdminSessions, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pISmtpAdminSessions->put_Server ( m_strServer ? m_strServer : bstrT );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pISmtpAdminSessions->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pISmtpAdminSessions
}


STDMETHODIMP CSmtpAdmin::get_AliasAdmin( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	BSTR						bstrT = _T("");
	CComPtr<ISmtpAdminAlias>	pISmtpAdminAlias;

	hr = StdPropertyHandoffIDispatch (
		CLSID_CSmtpAdminAlias,
		IID_ISmtpAdminAlias,
		&pISmtpAdminAlias, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pISmtpAdminAlias->put_Server ( m_strServer ? m_strServer : bstrT );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pISmtpAdminAlias->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pISmtpAdminAlias
}


STDMETHODIMP CSmtpAdmin::get_UserAdmin( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	BSTR					bstrT = _T("");
	CComPtr<ISmtpAdminUser>	pISmtpAdminUser;

	hr = StdPropertyHandoffIDispatch (
		CLSID_CSmtpAdminUser,
		IID_ISmtpAdminUser,
		&pISmtpAdminUser, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pISmtpAdminUser->put_Server ( m_strServer ? m_strServer : bstrT );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pISmtpAdminUser->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pISmtpAdminUser


}

STDMETHODIMP CSmtpAdmin::get_DLAdmin( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	BSTR					bstrT = _T("");
	CComPtr<ISmtpAdminDL>	pISmtpAdminDL;

	hr = StdPropertyHandoffIDispatch (
		CLSID_CSmtpAdminDL,
		IID_ISmtpAdminDL,
		&pISmtpAdminDL, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pISmtpAdminDL->put_Server ( m_strServer ? m_strServer : bstrT );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pISmtpAdminDL->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pISmtpAdminDL
}

STDMETHODIMP CSmtpAdmin::get_DomainAdmin( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	BSTR						bstrT = _T("");
	CComPtr<ISmtpAdminDomain>	pISmtpAdminDomain;

	hr = StdPropertyHandoffIDispatch (
		CLSID_CSmtpAdminDomain,
		IID_ISmtpAdminDomain,
		&pISmtpAdminDomain, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pISmtpAdminDomain->put_Server ( m_strServer ? m_strServer : bstrT );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pISmtpAdminDomain->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pISmtpAdminDomain
}

STDMETHODIMP CSmtpAdmin::get_VirtualDirectoryAdmin( IDispatch ** ppIDispatch )
{
	HRESULT	hr = NOERROR;

	BSTR								bstrT = _T("");
	CComPtr<ISmtpAdminVirtualDirectory>	pISmtpAdminVirtualDirectory;

	hr = StdPropertyHandoffIDispatch (
		CLSID_CSmtpAdminVirtualDirectory,
		IID_ISmtpAdminVirtualDirectory,
		&pISmtpAdminVirtualDirectory, 
		ppIDispatch 
		);
	if ( FAILED(hr) ) {
		goto Error;
	}

	// Set default properties:
	hr = pISmtpAdminVirtualDirectory->put_Server ( m_strServer ? m_strServer : bstrT );
	if ( FAILED (hr) ) {
		goto Error;
	}
	
	hr = pISmtpAdminVirtualDirectory->put_ServiceInstance ( m_dwServiceInstance );
	if ( FAILED (hr) ) {
		goto Error;
	}

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatch );
	*ppIDispatch = NULL;

	return hr;

	// Destructor releases pISmtpAdminVirtualDirectory
}


// Which service to configure:
	
STDMETHODIMP CSmtpAdmin::get_Server ( BSTR * pstrServer )
{
	return StdPropertyGet ( m_strServer, pstrServer );
}

STDMETHODIMP CSmtpAdmin::put_Server ( BSTR strServer )
{
	return StdPropertyPutServerName ( &m_strServer, strServer );
}

STDMETHODIMP CSmtpAdmin::get_ServiceInstance ( long * plServiceInstance )
{
	return StdPropertyGet ( m_dwServiceInstance, plServiceInstance );
}

STDMETHODIMP CSmtpAdmin::put_ServiceInstance ( long lServiceInstance )
{
	return StdPropertyPut ( &m_dwServiceInstance, lServiceInstance );
}

// Versioning:

STDMETHODIMP CSmtpAdmin::get_HighVersion ( long * plHighVersion )
{
	*plHighVersion = HIGH_VERSION;
	return NOERROR;
}

STDMETHODIMP CSmtpAdmin::get_LowVersion ( long * plLowVersion )
{
	*plLowVersion = LOW_VERSION;
	return NOERROR;
}

STDMETHODIMP CSmtpAdmin::get_BuildNum ( long * plBuildNumber )
{
	*plBuildNumber = BUILD_NUM;
	return NOERROR;
}

STDMETHODIMP CSmtpAdmin::get_ServiceVersion ( long * plServiceVersion )
{
	*plServiceVersion = m_dwServiceVersion;
	return NOERROR;
}


//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

//$-------------------------------------------------------------------
//
//	CSmtpAdmin::EnumerateInstances
//
//	Description:
//
//		Returns a list of the virtual servers on the given machine.
//
//	Parameters:
//
//		ppsaInstances - Returned SAFEARRAY of instance IDs.  
//			Must be freed by caller.
//
//	Returns:
//
//
//--------------------------------------------------------------------

STDMETHODIMP CSmtpAdmin::EnumerateInstances ( SAFEARRAY ** ppsaInstances )
{
	TraceFunctEnter ( "CSmtpAdmin::EnumerateInstances" );

	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;
	SAFEARRAY * 		psaEmpty	= NULL;
	SAFEARRAYBOUND		sabound[1];

	// Check parameters:
	_ASSERT ( ppsaInstances != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppsaInstances ) );

	if ( ppsaInstances == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );

		hr = E_POINTER;
		goto Exit;
	}

	// Zero the out parameters:
	*ppsaInstances	= NULL;

	// Set the return array to an empty array:
	sabound[0].lLbound = 0;
	sabound[0].cElements = 0;

	psaEmpty = SafeArrayCreate ( VT_I4, 1, sabound );
	if ( psaEmpty == NULL ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	*ppsaInstances = psaEmpty;

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
    BAIL_ON_FAILURE(hr);

	// Enumerate the instances:
	hr = QueryMetabaseInstances ( pMetabase, ppsaInstances );

Exit:
	if ( FAILED(hr) ) {
		_VERIFY ( SUCCEEDED (SafeArrayDestroy ( psaEmpty )) );
        if (ppsaInstances)
            *ppsaInstances = NULL;
	}

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CSmtpAdmin::EnumerateInstancesVariant ( SAFEARRAY ** ppsaInstances )
{
	TraceFunctEnter ( "CSmtpAdmin::EnumerateInstancesVariant" );

	HRESULT                 hr;
	SAFEARRAY       *       psaInstances    = NULL;

	hr = EnumerateInstances ( &psaInstances );
	BAIL_ON_FAILURE(hr);

	hr = LongArrayToVariantArray ( psaInstances, ppsaInstances );
	BAIL_ON_FAILURE(hr);

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CSmtpAdmin::CreateInstance
//
//	Description:
//
//		Creates a new SMTP virtual server on the given machine.
//
//	Parameters:
//
//		plInstanceId - The new virtual server ID.
//
//	Returns:
//
//
//--------------------------------------------------------------------

STDMETHODIMP CSmtpAdmin::CreateInstance ( BSTR pstrMailRoot, long * plInstanceId )
{
	TraceFunctEnter ( "CSmtpAdmin::CreateInstance" );

	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;

	// Check parameters:
	_ASSERT ( plInstanceId != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( plInstanceId ) );

	if ( plInstanceId == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );

		hr = E_POINTER;
		goto Exit;
	}

	// Zero the out parameter:
	*plInstanceId 	= 0;

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Create a new instance:
	hr = CreateNewInstance ( pMetabase, plInstanceId, pstrMailRoot );

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CSmtpAdmin::DestroyInstance
//
//	Description:
//
//		Removes the given virtual server.
//
//	Parameters:
//
//		lInstanceId - The ID of the virtual server to delete.
//
//	Returns:
//
//
//--------------------------------------------------------------------

STDMETHODIMP CSmtpAdmin::DestroyInstance ( long lInstanceId )
{
	TraceFunctEnter ( "CSmtpAdmin::DestroyInstance" );

	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;

	// Get the metabase pointer:
	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Delete the instance:
	hr = DeleteInstance ( pMetabase, lInstanceId );

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CSmtpAdmin::ErrorToString
//
//	Description:
//
//		Translates an SMTP_ERROR_CODE to a readable string.
//
//	Parameters:
//
//		lErrorCode 	- Win32 error code.
//		pstrError	- the readable error string.
//
//	Returns:
//
//		The error string in *pstrError.
//
//--------------------------------------------------------------------

STDMETHODIMP CSmtpAdmin::ErrorToString ( DWORD lErrorCode, BSTR * pstrError )
{
	TraceFunctEnter ( "CSmtpAdmin::ErrorToString" );

	_ASSERT ( IS_VALID_OUT_PARAM ( pstrError ) );

	HRESULT		hr = NOERROR;
	DWORD		dwFormatFlags;
	WCHAR		wszError [ 1024 ];

	if ( pstrError == NULL ) {
		FatalTrace ( (LPARAM) this, "Bad return pointer" );

		TraceFunctLeave ();
		return E_POINTER;
	}

	//----------------------------------------------------------------
	//
	//	Map error codes here:
	//

	//
	//----------------------------------------------------------------

	dwFormatFlags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS;

	if ( !FormatMessage ( dwFormatFlags, NULL, lErrorCode, 0,      // Lang ID - Should be nonzero?
			wszError, 1024, NULL ) ) {

		// Didn't work, so put in a default message:

		WCHAR   wszFormat [ 256 ];

		wszFormat[0] = L'\0';
		if ( !LoadStringW ( _Module.GetResourceInstance (), IDS_UNKNOWN_ERROR, wszFormat, 256 ) ||
			!*wszFormat ) {

			wcscpy ( wszFormat, L"Unknown Error (%1!d!)" );
		}

		FormatMessage (
			FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
			wszFormat, 
			IDS_UNKNOWN_ERROR, 
			0, 
			wszError, 
			1024,
			(va_list *) &lErrorCode
			);
	}
	//
	// We need to strip out any " from the string, because
	// Javascript will barf.
	//

	LPWSTR  pch;

	for ( pch = wszError; *pch; pch++ ) {

		if ( *pch == L'\"' ) {
			*pch = L'\'';
		}
	}

	//
	// Strip off any trailing control characters.
	//
	for (pch = &wszError[wcslen(wszError) - 1];
		pch >= wszError && iswcntrl(*pch);
		pch --) {

		*pch = 0;
	}

	*pstrError = ::SysAllocString( wszError );

	if ( *pstrError == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}


//$-------------------------------------------------------------------
//
//	CSmtpAdmin::Tokenize
//
//	Description:
//
//		Makes the given string safe for HTML & Javascript
//
//	Parameters:
//
//		strIn - the input string
//		strOut - the resulting string with appropriate escape sequences.
//
//--------------------------------------------------------------------
STDMETHODIMP CSmtpAdmin::Tokenize ( BSTR strIn, BSTR * pstrOut )
{
	TraceFunctEnter ( "CSmtpAdmin::Tokenize" );

	_ASSERT ( IS_VALID_STRING ( strIn ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( pstrOut ) );

	HRESULT		hr		= NOERROR;
	PWCHAR		pSrc	= strIn;
	PWCHAR		pSrcCur	= NULL;
	PWCHAR		pDstCur	= NULL;
	PWCHAR		pDst	= NULL;

	*pstrOut = NULL;

	pDst = new WCHAR [ 3 * lstrlen ( strIn ) + 1 ];
	if ( pDst == NULL ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

    for ( pSrcCur = pSrc, pDstCur = pDst; *pSrcCur; pSrcCur++ ) {
        switch ( *pSrcCur ) {
            case L'\\':
                *(pDstCur++) = L'%';
                *(pDstCur++) = L'5';
                *(pDstCur++) = L'c';
                break;

            case L' ':
                *(pDstCur++) = L'+';
                break;

            case L':':
                *(pDstCur++) = L'%';
                *(pDstCur++) = L'3';
                *(pDstCur++) = L'a';
                break;

            case L'/':
                *(pDstCur++) = L'%';
                *(pDstCur++) = L'2';
                *(pDstCur++) = L'f';
                break;

            default:
                *(pDstCur++) = *pSrcCur;
        }
    }
    *pDstCur = L'\0';

	*pstrOut = ::SysAllocString ( pDst );
	if ( *pstrOut == NULL ) {
		FatalTrace ( (LPARAM) this, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	delete pDst;

	if ( FAILED(hr) && hr != DISP_E_EXCEPTION ) {
		hr = SmtpCreateExceptionFromHresult ( hr );
	}

	TraceFunctLeave ();
	return hr;
}


//$-------------------------------------------------------------------
//
//	CSmtpAdmin::QueryMetabaseInstances
//
//	Description:
//
//		Retrieves the list of virtual servers from the metabase
//
//	Parameters:
//
//		pMetabase		- the metabase object
//		ppsaInstances	- resulting array of instance ids.
//
//	Returns:
//
//
//--------------------------------------------------------------------

HRESULT CSmtpAdmin::QueryMetabaseInstances ( IMSAdminBase * pMetabase, SAFEARRAY ** ppsaInstances )
{
	TraceFunctEnter ( "CSmtpAdmin::QueryMetabaseInstances" );

	_ASSERT ( IS_VALID_IN_PARAM ( pMetabase ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppsaInstances ) );

	HRESULT			hr				= NOERROR;
	CMetabaseKey	mkeySmtp ( pMetabase );
	SAFEARRAY *		psaResult		= NULL;
	DWORD			cValidInstances	= 0;
	SAFEARRAYBOUND	rgsaBound[1];
	DWORD			i;
	TCHAR			szName[ METADATA_MAX_NAME_LEN ];
	long			index[1];
	DWORD			dwInstance;

	hr = mkeySmtp.Open ( SMTP_MD_ROOT_PATH );

	if ( FAILED(hr) ) {
		goto Exit;
	}

	//	pickup the service version number:
	hr = mkeySmtp.GetDword ( _T(""), MD_SMTP_SERVICE_VERSION, &m_dwServiceVersion );
	if ( FAILED(hr) ) {
		m_dwServiceVersion	= SMTP_DEF_SERVICE_VERSION;
	}

	hr = mkeySmtp.GetIntegerChildCount ( &cValidInstances );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Allocate the array:
	rgsaBound[0].lLbound	= 0;
	rgsaBound[0].cElements	= cValidInstances;
	
	psaResult	= SafeArrayCreate ( VT_I4, 1, rgsaBound );

	if ( psaResult == NULL ) {
		FatalTrace ( 0, "Out of memory" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	mkeySmtp.BeginChildEnumeration ();

	for ( i = 0; i < cValidInstances; i++ ) {
		hr = mkeySmtp.NextIntegerChild ( &dwInstance, szName );
		_ASSERT ( SUCCEEDED(hr) );

		index[0]	= i;
		hr			= SafeArrayPutElement ( psaResult, index, &dwInstance );
		_ASSERT ( SUCCEEDED(hr) );
	}

	*ppsaInstances = psaResult;
	_ASSERT ( SUCCEEDED(hr) );

Exit:
	if ( FAILED (hr) ) {
		SafeArrayDestroy ( psaResult );
	}

	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CSmtpAdmin::CreateNewInstance
//
//	Description:
//
//		Creates a new virtual server in the metabase.
//
//	Parameters:
//
//		pMetabase		- The metabase object
//		plInstanceId	- The new instance ID.
//
//	Returns:
//
//
//--------------------------------------------------------------------

HRESULT CSmtpAdmin::CreateNewInstance (
	IMSAdminBase * pMetabase,
	long * plInstanceId,
	BSTR bstrMailRoot
	)
{
	TraceFunctEnter ( "CSmtpAdmin::CreateNewInstance" );

	_ASSERT ( IS_VALID_IN_PARAM ( pMetabase ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( plInstanceId ) );

	HRESULT			hr				= NOERROR;
	CMetabaseKey	mkeySmtp ( pMetabase );
	DWORD			dwInstance;
	TCHAR			szInstance [ METADATA_MAX_NAME_LEN ];
	TCHAR			szPath [ METADATA_MAX_NAME_LEN ];
	TCHAR			szDir [512];
	DWORD			cb;

	// Zero the out parameters:
	*plInstanceId	= NULL;

	hr = mkeySmtp.Open ( SMTP_MD_ROOT_PATH, METADATA_PERMISSION_WRITE );

	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open SmtpSvc key, %x", GetLastError() );
		goto Exit;
	}

	hr = mkeySmtp.CreateIntegerChild ( &dwInstance, szInstance );
	if ( FAILED (hr) ) {
		goto Exit;
	}

	wsprintf( szPath, _T("%s/Root"), szInstance );
	hr = mkeySmtp.CreateChild( szPath );
	if ( FAILED (hr) ) {
		goto Exit;
	}

	wsprintf( szPath, _T("%s/Root/MailRoot"), szInstance );
	hr = mkeySmtp.CreateChild( szPath );
	if ( FAILED (hr) ) {
		goto Exit;
	}

	//  create mail root virtual directory
	if( bstrMailRoot && bstrMailRoot[0] )
	{
		// get rid of '\' at the end
		cb = lstrlen( bstrMailRoot );
		if( cb > 0 && bstrMailRoot[cb-1] == _T('\\') )
			bstrMailRoot[cb-1] = _T('\0');

		wsprintf( szPath, _T("%s/Root/MailRoot"), szInstance );
		cb = wsprintf( szDir, _T("%s\\Mailbox"), bstrMailRoot );
		mkeySmtp.SetString( szPath, MD_VR_PATH, szDir);

		// set badmail, drop, pickup, queue keys
		wsprintf( szPath, _T("%s"), szInstance );

		cb = wsprintf( szDir, _T("%s\\Badmail"), bstrMailRoot );
		mkeySmtp.SetString( szPath, MD_BAD_MAIL_DIR, szDir);

		// K2 only has drop doamin
		if( SERVICE_IS_K2(m_dwServiceVersion) )
		{
			cb = wsprintf( szDir, _T("%s\\Drop"), bstrMailRoot );
			mkeySmtp.SetString( szPath, MD_MAIL_DROP_DIR, szDir );
		}


		cb = wsprintf( szDir, _T("%s\\Pickup"), bstrMailRoot );
		mkeySmtp.SetString( szPath, MD_MAIL_PICKUP_DIR, szDir );

		cb = wsprintf( szDir, _T("%s\\Queue"), bstrMailRoot );
		mkeySmtp.SetString( szPath, MD_MAIL_QUEUE_DIR, szDir );

		// set the routing sources, it's MultiSZ
		cb = wsprintf( szDir, _T("szDataDirectory=%s\\Route"), bstrMailRoot );
		szDir[cb] = szDir[cb+1] = _T('\0');
		mkeySmtp.SetMultiSz( szPath, MD_ROUTING_SOURCES, szDir, (cb+2) * sizeof(TCHAR) );

        // MCIS needs SendNDRTo and SendBadTo as "Postmaster", setup should set it on service level
        if( SERVICE_IS_MCIS(m_dwServiceVersion) )
        {
            mkeySmtp.SetString( szPath, MD_SEND_NDR_TO, TSTR_POSTMASTR_NAME );
            mkeySmtp.SetString( szPath, MD_SEND_BAD_TO, TSTR_POSTMASTR_NAME );
        }
	}

	//
	//  Initialize the server state:
	//

	mkeySmtp.SetDword ( szInstance, MD_SERVER_COMMAND, MD_SERVER_COMMAND_STOP );
	mkeySmtp.SetDword ( szInstance, MD_SERVER_STATE, MD_SERVER_STATE_STOPPED );
	mkeySmtp.SetDword ( szInstance, MD_SERVER_AUTOSTART, FALSE );

	// hr = mkeySmtp.Close();
	// BAIL_ON_FAILURE(hr);
	mkeySmtp.Close();

	hr = pMetabase->SaveData ( );
	if ( FAILED (hr) ) {
		goto Exit;
	}

	*plInstanceId = dwInstance;

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CSmtpAdmin::DeleteInstance
//
//	Description:
//
//		Removes a virtual server from the metabase
//
//	Parameters:
//
//		pMetabase	- The metabase object
//		lInstanceId	- The ID of the virtual server to delete.
//
//	Returns:
//
//
//--------------------------------------------------------------------

HRESULT CSmtpAdmin::DeleteInstance ( IMSAdminBase * pMetabase, long lInstanceId )
{
	TraceFunctEnter ( "CSmtpAdmin::CreateNewInstance" );

	_ASSERT ( IS_VALID_IN_PARAM ( pMetabase ) );

	HRESULT			hr				= NOERROR;
	CMetabaseKey	mkeySmtp ( pMetabase );

    //
    //  Tell U2 to delete any mappings associated with this virtual server:
    //

    ::DeleteMapping ( m_strServer, (BSTR) MD_SERVICE_NAME, lInstanceId );

    //
    //  Delete the virtual server from the metabase:
    //

	hr = mkeySmtp.Open ( SMTP_MD_ROOT_PATH, METADATA_PERMISSION_WRITE );

	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open SmtpSvc key, %x", GetLastError() );
		goto Exit;
	}

	hr = mkeySmtp.DestroyIntegerChild ( (DWORD) lInstanceId );
	if ( FAILED (hr) ) {
		goto Exit;
	}

	// hr = mkeySmtp.Close();
	// BAIL_ON_FAILURE(hr);
	mkeySmtp.Close();

	hr = pMetabase->SaveData ( );
	if ( FAILED (hr) ) {
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\alias.h ===
// alias.h : Declaration of the CSmtpAdminAlias


#include "resource.h"       // main symbols

#include "smtptype.h"
#include "smtpapi.h"

/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdminAlias : 
	public ISmtpAdminAlias,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdminAlias,&CLSID_CSmtpAdminAlias>
{
public:
	CSmtpAdminAlias();
	virtual ~CSmtpAdminAlias();

BEGIN_COM_MAP(CSmtpAdminAlias)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(ISmtpAdminAlias)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdminAlias) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdminAlias, _T("Smtpadm.Alias.1"), _T("Smtpadm.Alias"), IDS_SMTPADMIN_ALIAS_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_SMTPADMLib
	#define THIS_IID	IID_ISmtpAdminAlias
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// ISmtpAdminAlias
public:
    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// enumeration
	STDMETHODIMP    get_Count			( long* plCount  );


	// The current alias's properties:

	STDMETHODIMP	get_EmailId	( BSTR * pstrEmailId );
	STDMETHODIMP	put_EmailId	( BSTR strEmailId );

	STDMETHODIMP	get_Domain	( BSTR * pstrDomain );
	STDMETHODIMP	put_Domain	( BSTR strDomain );

	STDMETHODIMP	get_Type	( long * plType );
	STDMETHODIMP	put_Type	( long lType );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Find	( BSTR strWildmat,
							  long cMaxResults
							);

	STDMETHODIMP	GetNth	( long dwIndex );


	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

    CIADsImpl   m_iadsImpl;

	LONG		m_lCount;

	// current alias
	long		m_lType;

	CComBSTR	m_strEmailId;
	CComBSTR	m_strDomain;

	// Todo: add a list of alias
	LPSMTP_NAME_LIST		m_pSmtpNameList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtp.inc ===
# Global settings for SMTP subprojects

!IFNDEF IISBASEDIR
IISBASEDIR=$(PROJECT_ROOT)\iis
!ENDIF

!IFNDEF STAXINCDIR
STAXINCDIR=staxinc
!ENDIF

!IFNDEF SMTPDIR
SMTPDIR=smtp
!ENDIF

!INCLUDE $(IISBASEDIR)\$(STAXINCDIR)\build\paths.inc

STAXSMTP=$(STAXBASE)\$(SMTPDIR)
STAXSMTPTARGET=$(STAXSMTP)\$(_OBJ_DIR)
STAXSMTPLIBPATH=$(STAXSMTPTARGET)\$(TARGET_DIRECTORY)

# Hack to create the lib directory
!if [mkdir $(STAXSMTPTARGET)\$(TARGET_DIRECTORY)]
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\import.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    import.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/

#include <windef.h>
#include <winbase.h>
#include <lmcons.h>

#ifdef MIDL_PASS
#define LPWSTR      [string] wchar_t*
#define BOOL        DWORD
#endif

#include <smtptype.h>
#include <smtpapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\admin.h ===
// admin.h : Declaration of the CSmtpAdmin

// Dependencies:

#include "resource.h"       // main symbols

#include "metafact.h"

struct IMSAdminBase;

//  Service Versioning:

#define SERVICE_IS_K2(dwVersion)        ((dwVersion) == 1)
#define SERVICE_IS_MCIS(dwVersion)      ((dwVersion) == 0)


/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdmin : 
	public CComDualImpl<ISmtpAdmin, &IID_ISmtpAdmin, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdmin,&CLSID_CSmtpAdmin>
{
public:
	CSmtpAdmin();
	virtual ~CSmtpAdmin ();

BEGIN_COM_MAP(CSmtpAdmin)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISmtpAdmin)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdmin) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdmin, _T("Smtpadm.Admin.1"), _T("Smtpadm.Admin"), IDS_SMTPADMIN_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ISmtpAdmin
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	// Pointers to other ISmtpAdmin interfaces:
		
	STDMETHODIMP	get_ServiceAdmin		( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_VirtualServerAdmin	( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_SessionsAdmin	( IDispatch ** ppIDispatch );

	STDMETHODIMP	get_AliasAdmin		( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_UserAdmin		( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_DLAdmin			( IDispatch ** ppIDispatch );
	STDMETHODIMP	get_DomainAdmin		( IDispatch ** ppIDispatch );

	STDMETHODIMP	get_VirtualDirectoryAdmin		( IDispatch ** ppIDispatch );


	// Which service to configure:

	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// Versioning:

	STDMETHODIMP	get_HighVersion		( long * plHighVersion );
	STDMETHODIMP	get_LowVersion		( long * plLowVersion );
	STDMETHODIMP	get_BuildNum		( long * plBuildNumber );
	STDMETHODIMP	get_ServiceVersion	( long * plServiceVersion );


	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	EnumerateInstances	( SAFEARRAY ** ppsaInstances );
	STDMETHODIMP    EnumerateInstancesVariant ( SAFEARRAY ** ppsaInstances );
	STDMETHODIMP	CreateInstance		( BSTR pstrMailRoot, long * plInstanceId );
	STDMETHODIMP	DestroyInstance		( long lInstanceId );
	STDMETHODIMP	ErrorToString		( DWORD dwErrorCode, BSTR * pstrError );
    STDMETHODIMP    Tokenize            ( BSTR strIn, BSTR * pstrOut );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	CComBSTR	m_strServer;
	DWORD		m_dwServiceInstance;

	DWORD		m_dwServiceVersion;

	// Metabase:
	CMetabaseFactory	m_mbFactory;

	HRESULT			QueryMetabaseInstances	( IMSAdminBase * pMetabase, SAFEARRAY ** ppsaInstances );
	HRESULT			CreateNewInstance		( IMSAdminBase * pMetabase, long * plInstanceId, BSTR pstrMailRoot );
	HRESULT			DeleteInstance			( IMSAdminBase * pMetabase, long lInstanceId );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\alias.cpp ===
// groups.cpp : Implementation of CsmtpadmApp and DLL registration.

#include "stdafx.h"
#include "smtpadm.h"
#include "alias.h"
#include "oleutil.h"
#include "smtpapi.h"

#include <lmapibuf.h>

#include "smtpcmn.h"

// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Smtpadm.Alias.1")
#define THIS_FILE_IID				IID_ISmtpAdminAlias

#define DEFAULT_NEWSGROUP_NAME			_T("")
#define DEFAULT_NEWSGROUP_DESCRIPTION	_T("")
#define DEFAULT_NEWSGROUP_MODERATOR		_T("")
#define DEFAULT_NEWSGROUP_READONLY		FALSE

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(SmtpAdminAlias, CSmtpAdminAlias, IID_ISmtpAdminAlias)

STDMETHODIMP CSmtpAdminAlias::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ISmtpAdminAlias,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CSmtpAdminAlias::CSmtpAdminAlias () :
	m_lCount				( 0 ),
	m_lType					( NAME_TYPE_USER )
	// CComBSTR's are initialized to NULL by default.
{
    InitAsyncTrace ( );

    m_pSmtpNameList		= NULL;

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("Alias") );
    m_iadsImpl.SetClass ( _T("IIsSmtpAlias") );
}

CSmtpAdminAlias::~CSmtpAdminAlias ()
{
	if ( m_pSmtpNameList ) {
		::NetApiBufferFree ( m_pSmtpNameList );
	}
	// All CComBSTR's are freed automatically.
}


//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CSmtpAdminAlias,m_iadsImpl)


//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CSmtpAdminAlias::get_Count ( long* plCount )
{
	return StdPropertyGet ( m_lCount, plCount );
}

	// The current alias's properties:

STDMETHODIMP CSmtpAdminAlias::get_EmailId ( BSTR * pstrEmailId )
{
	return StdPropertyGet ( m_strEmailId, pstrEmailId );
}

STDMETHODIMP CSmtpAdminAlias::put_EmailId ( BSTR strEmailId )
{
	return StdPropertyPut ( &strEmailId, strEmailId );
}

STDMETHODIMP CSmtpAdminAlias::get_Domain ( BSTR * pstrDomain )
{
	return StdPropertyGet ( m_strDomain, pstrDomain );
}

STDMETHODIMP CSmtpAdminAlias::put_Domain ( BSTR strDomain )
{
	return StdPropertyPut ( &m_strDomain, strDomain );
}

STDMETHODIMP CSmtpAdminAlias::get_Type ( long* plType )
{
	return StdPropertyGet ( m_lType, plType );
}

STDMETHODIMP CSmtpAdminAlias::put_Type ( long lType )
{
	return StdPropertyPut ( &m_lType, lType );
}


//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CSmtpAdminAlias::Find ( 
	BSTR strWildmat,
	long cMaxResults
	)
{
	TraceFunctEnter ( "CSmtpAdminAlias::Find" );

	HRESULT			hr		= NOERROR;
	DWORD			dwErr	= NOERROR;

	// Free the old newsgroup list:
	if ( m_pSmtpNameList ) {
		::NetApiBufferFree ( m_pSmtpNameList );
		m_pSmtpNameList		= NULL;
	}
	m_lCount	= 0;

	dwErr = SmtpGetNameList ( 
					m_iadsImpl.QueryComputer(),  
					strWildmat, 
					NAME_TYPE_ALL,
					cMaxResults, 
					TRUE, 
					&m_pSmtpNameList,
					m_iadsImpl.QueryInstance());

	if ( dwErr != 0 ) {
		ErrorTraceX ( (LPARAM) this, "Failed to find alias: %x", dwErr );
		SetLastError( dwErr );
		hr = SmtpCreateExceptionFromWin32Error ( dwErr );
		goto Exit;
	}

	m_lCount = m_pSmtpNameList->cEntries;

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CSmtpAdminAlias::GetNth( long lIndex )
{
	_ASSERT( lIndex >=0 && lIndex < m_lCount );

	WCHAR*					pchStartOfDomain = NULL;
	WCHAR*					p = NULL;
	LPSMTP_NAME_ENTRY		pNameEntry;

	if( !m_pSmtpNameList )
	{
		return SmtpCreateException (IDS_SMTPEXCEPTION_DIDNT_ENUMERATE);
	}

	if( lIndex < 0 || lIndex >= m_lCount )
	{
		return SmtpCreateException (IDS_SMTPEXCEPTION_INVALID_INDEX);
	}

	//_ASSERT( CAddr::ValidateEmailName(m_pSmtpNameList[lIndex].lpszName) );

	pNameEntry = &m_pSmtpNameList->aNameEntry[lIndex];
	p = pNameEntry->lpszName;

	while( *p && *p != '@' ) p++;
	_ASSERT( *p );

	if( !*p )
	{
		return SmtpCreateException (IDS_SMTPEXCEPTION_INVALID_ADDRESS);
	}

	pchStartOfDomain = p+1;

	m_lType = pNameEntry->dwType;

	m_strDomain = (LPCWSTR) pchStartOfDomain;

	*(pchStartOfDomain-1) = '\0';
	m_strEmailId = pNameEntry->lpszName; // converted to UNICODE
	*(pchStartOfDomain-1) = '@';	// turn it back

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\binding.cpp ===
// binding.cpp : Implementation of CServerBinding & CServerBindings.

#include "stdafx.h"
#include "smtpadm.h"
#include "cmultisz.h"
#include "binding.h"
#include "oleutil.h"
#include "smtpcmn.h"


HRESULT	CBinding::SetProperties ( 
	BSTR	strIpAddress, 
	long	dwTcpPort,
	long	dwSslPort
	)
{
	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );

	m_strIpAddress	= strIpAddress;
	m_dwTcpPort		= dwTcpPort;
	m_dwSslPort		= dwSslPort;

	if ( !m_strIpAddress ) {
		return E_OUTOFMEMORY;
	}

	return NOERROR;
}

// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Smtpadm.VirtualServer.1")
#define THIS_FILE_IID				IID_IServerBinding

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CServerBinding::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IServerBinding,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CServerBinding::CServerBinding ()
	// CComBSTR's are initialized to NULL by default.
{
}

CServerBinding::~CServerBinding ()
{
	// All CComBSTR's are freed automatically.
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CServerBinding::get_IpAddress ( BSTR * pstrIpAddress )
{
	return StdPropertyGet ( m_binding.m_strIpAddress, pstrIpAddress );
}

STDMETHODIMP CServerBinding::put_IpAddress ( BSTR strIpAddress )
{
	return StdPropertyPut ( &m_binding.m_strIpAddress, strIpAddress );
}

STDMETHODIMP CServerBinding::get_TcpPort ( long * pdwTcpPort )
{
	return StdPropertyGet ( m_binding.m_dwTcpPort, pdwTcpPort );
}

STDMETHODIMP CServerBinding::put_TcpPort ( long dwTcpPort )
{
	return StdPropertyPut ( &m_binding.m_dwTcpPort, dwTcpPort );
}

STDMETHODIMP CServerBinding::get_SslPort ( long * plSslPort )
{
	return StdPropertyGet ( m_binding.m_dwSslPort, plSslPort );
}

STDMETHODIMP CServerBinding::put_SslPort ( long lSslPort )
{
	return StdPropertyPut ( &m_binding.m_dwSslPort, lSslPort );
}

//
// Must define THIS_FILE_* macros to use SmtpCreateException()
//

#undef THIS_FILE_HELP_CONTEXT
#undef THIS_FILE_PROG_ID
#undef THIS_FILE_IID

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("smtpadm.VirtualServer.1")
#define THIS_FILE_IID				IID_IServerBindings

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CServerBindings::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IServerBindings,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CServerBindings::CServerBindings () :
	m_dwCount			( 0 ),
	m_rgBindings		( NULL )
	// CComBSTR's are initialized to NULL by default.
{
}

CServerBindings::~CServerBindings ()
{
	// All CComBSTR's are freed automatically.

	delete [] m_rgBindings;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CServerBindings::get_Count ( long * pdwCount )
{
	return StdPropertyGet ( m_dwCount, pdwCount );
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CServerBindings::Item ( 
	long index, 
	IServerBinding ** ppBinding 
	)
{
	TraceFunctEnter ( "CServerBindings::Item" );

	_ASSERT ( IS_VALID_OUT_PARAM ( ppBinding ) );

	*ppBinding = NULL;

	HRESULT								hr			= NOERROR;
	CComObject<CServerBinding> *	pBinding	= NULL;

	if ( index < 0 || index >= m_dwCount ) {
		hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	hr = CComObject<CServerBinding>::CreateInstance ( &pBinding );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( pBinding );
	hr = pBinding->SetProperties ( m_rgBindings[index] );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pBinding->QueryInterface ( IID_IServerBinding, (void **) ppBinding );
	_ASSERT ( SUCCEEDED(hr) );

Exit:
	if ( FAILED(hr) && hr != DISP_E_EXCEPTION ) {
		hr = SmtpCreateExceptionFromHresult ( hr );
	}

	if ( FAILED(hr) ) {
		delete pBinding;
	}

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CServerBindings::ItemDispatch ( long index, IDispatch ** ppDispatch )
{
	HRESULT						hr;
	CComPtr<IServerBinding>	pBinding;

	hr = Item ( index, &pBinding );
	BAIL_ON_FAILURE ( hr );

	hr = pBinding->QueryInterface ( IID_IDispatch, (void **) ppDispatch );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CServerBindings::Add ( 
	BSTR strIpAddress, 
	long dwTcpPort,
	long dwSslPort
	)
{
	TraceFunctEnter ( "CServerBindings::Add" );

	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );

	HRESULT		hr	= NOERROR;
	CBinding *	rgNewBindings	= NULL;
	long		i;

	//
	//	Validate the new binding:
	//

	//
	//	See if we can merge this binding with an existing one:
	//
	if ( dwTcpPort == 0 || dwSslPort == 0 ) {
		for ( i = 0; i < m_dwCount; i++ ) {

			if ( (dwTcpPort == 0 && m_rgBindings[i].m_dwSslPort == 0) ||
				 (dwSslPort == 0 && m_rgBindings[i].m_dwTcpPort == 0) ) {

				if ( lstrcmpi ( m_rgBindings[i].m_strIpAddress, strIpAddress ) == 0 ) {

					if ( m_rgBindings[i].m_dwSslPort == 0 ) {
						m_rgBindings[i].m_dwSslPort = dwSslPort;
					}
					else {
						m_rgBindings[i].m_dwTcpPort = dwTcpPort;
					}
					hr = NOERROR;
					goto Exit;
				}
			}
		}
	}

	//	Allocate the new binding array:
	rgNewBindings	= new CBinding [ m_dwCount + 1 ];
	if ( !rgNewBindings ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	//	Copy the old bindings to the new array:
	for ( i = 0; i < m_dwCount; i++ ) {
		hr = rgNewBindings[i].SetProperties ( m_rgBindings[i] );
		if ( FAILED (hr) ) {
			goto Exit;
		}
	}

	//	Add the new binding to the end of the array:
	hr = rgNewBindings[m_dwCount].SetProperties ( strIpAddress, dwTcpPort, dwSslPort );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( SUCCEEDED(hr) );
	delete [] m_rgBindings;
	m_rgBindings = rgNewBindings;
	rgNewBindings = NULL;
	m_dwCount++;

Exit:
	if (FAILED(hr) && rgNewBindings)
		delete [] rgNewBindings;

	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CServerBindings::ChangeBinding ( 
	long index, 
	IServerBinding * pBinding 
	)
{
	TraceFunctEnter ( "CServerBindings::ChangeBinding" );

	HRESULT		hr	= NOERROR;

	CComBSTR	strIpAddress;
	long		dwTcpPort;
	long		dwSslPort;

	if ( index < 0 || index >= m_dwCount ) {
		hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	hr = pBinding->get_IpAddress ( &strIpAddress );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pBinding->get_TcpPort ( &dwTcpPort );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pBinding->get_SslPort ( &dwSslPort );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = m_rgBindings[index].SetProperties ( strIpAddress, dwTcpPort, dwSslPort );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CServerBindings::ChangeBindingDispatch ( long index, IDispatch * pDispatch )
{
	HRESULT						hr;
	CComPtr<IServerBinding>	pBinding;

	hr = pDispatch->QueryInterface ( IID_IServerBinding, (void **) &pBinding );
	BAIL_ON_FAILURE ( hr );

	hr = ChangeBinding ( index, pBinding );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CServerBindings::Remove ( long index )
{
	TraceFunctEnter ( "CServerBindings::Remove" );

	HRESULT		hr	= NOERROR;
	CBinding	temp;
	long		cPositionsToSlide;

	if ( index < 0 || index >= m_dwCount ) {
		hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	//	Slide the array down by one position:

	_ASSERT ( m_rgBindings );

	cPositionsToSlide	= (m_dwCount - 1) - index;

	_ASSERT ( cPositionsToSlide < m_dwCount );

	if ( cPositionsToSlide > 0 ) {
		// Save the deleted binding in temp:
		CopyMemory ( &temp, &m_rgBindings[index], sizeof ( CBinding ) );

		// Move the array down one:
		MoveMemory ( &m_rgBindings[index], &m_rgBindings[index + 1], sizeof ( CBinding ) * cPositionsToSlide );

		// Put the deleted binding on the end (so it gets destructed):
		CopyMemory ( &m_rgBindings[m_dwCount - 1], &temp, sizeof ( CBinding ) );

		// Zero out the temp binding:
		ZeroMemory ( &temp, sizeof ( CBinding ) );
	}

	m_dwCount--;

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CServerBindings::Clear ( )
{
	delete [] m_rgBindings;
	m_rgBindings 	= NULL;
	m_dwCount		= 0;

	return NOERROR;
}

//////////////////////////////////////////////////////////////////////
//
//	Useful routines to go from IServerBindings to 
//	Metabase data types.
//
//////////////////////////////////////////////////////////////////////

static DWORD CountBindingChars ( LPCWSTR strIpAddress, DWORD dwPort )
{
	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );

	DWORD		cchResult	= 0;
	WCHAR		wszPort [256];

	wsprintf ( wszPort, _T("%u"), dwPort );

	cchResult += lstrlen ( strIpAddress );	// <IPADDRESS>
	cchResult += 1;							// :
	cchResult += lstrlen ( wszPort );		// <PORT>
	cchResult += 1;							// :
//	cchResult += lstrlen ( strPathHeader );	// <PATHHEADER>

	cchResult += 1;		// For the terminating NULL

	return cchResult;
}

static void ToBindingString ( LPCWSTR strIpAddress, DWORD dwPort, LPWSTR wszBinding )
{
	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );
	_ASSERT ( dwPort != 0 );

	_ASSERT ( !IsBadWritePtr ( wszBinding, CountBindingChars ( strIpAddress, dwPort ) ) );

	wsprintf ( wszBinding, _T("%s:%u:"), strIpAddress, dwPort );
}

static HRESULT FromBindingString ( LPCWSTR wszBinding, LPWSTR wszIpAddressOut, DWORD * pdwPort )
{
	HRESULT	hr	= NOERROR;

	LPWSTR	pchFirstColon;
	LPWSTR	pchSecondColon;

	WCHAR	wszIpAddress	[ 256 ];
	WCHAR	wszPort			[ 256 ];
	long	dwPort;

	LPWSTR	pchColon;

	wszIpAddress[0]	= NULL;
	wszPort[0]		= NULL;

	pchFirstColon = wcschr ( wszBinding, _T(':') );
	if ( pchFirstColon ) {
		pchSecondColon = wcschr ( pchFirstColon + 1, _T(':') );
	}

	if ( !pchFirstColon || !pchSecondColon ) {
		hr = E_FAIL;
		goto Exit;
	}

	lstrcpyn ( wszIpAddress, wszBinding, 250 );
	lstrcpyn ( wszPort, pchFirstColon + 1, 250 );

	// Get the Port:
	dwPort	= _wtoi ( wszPort );

	// Cutoff the IpAddress at the colon:
	pchColon = wcschr ( wszIpAddress, _T(':') );
	if ( pchColon ) {
		*pchColon = NULL;
	}

	lstrcpy ( wszIpAddressOut, wszIpAddress );
	*pdwPort		= dwPort;

Exit:
	return hr;
}

HRESULT 
MDBindingsToIBindings ( 
	CMultiSz *				pmsz, 
	BOOL					fTcpBindings,
	IServerBindings *	pBindings 
	)
{
	HRESULT		hr	= NOERROR;
	DWORD		cBindings;
	DWORD		i;
	LPCWSTR		pchCurrent;
	CBinding	binding;

	cBindings = pmsz->Count ();

	for ( 
			i = 0, pchCurrent = *pmsz; 
			i < cBindings; 
			i++, pchCurrent += lstrlen ( pchCurrent ) + 1 
		) {

		WCHAR	wszIpAddress[512];
		DWORD	dwPort;

		hr = FromBindingString ( pchCurrent, wszIpAddress, &dwPort );
		if ( FAILED(hr) ) {
			// Skip bad binding strings:
			hr = NOERROR;
			continue;
		}

		if ( fTcpBindings ) {
			hr = pBindings->Add ( wszIpAddress, dwPort, 0 );
		}
		else {
			hr = pBindings->Add ( wszIpAddress, 0, dwPort );
		}
		BAIL_ON_FAILURE(hr);
	}

Exit:
	return hr;
}

HRESULT IBindingsToMDBindings ( 
	IServerBindings *	pBindings,
	BOOL					fTcpBindings,
	CMultiSz *				pmsz
	)
{
	HRESULT		hr	= NOERROR;
	long		cBindings;
	long		i;
	DWORD		cbCount		= 0;
	LPWSTR		wszBindings	= NULL;

	// Count the characters of the regular bindings list:
	cbCount	= 0;
	pBindings->get_Count ( &cBindings );

	for ( i = 0; i < cBindings; i++ ) {
		CComPtr<IServerBinding>	pBinding;
		CComBSTR					strIpAddress;
		long						lTcpPort;
		long						lSslPort;

		hr = pBindings->Item ( i, &pBinding );
		BAIL_ON_FAILURE(hr);

		pBinding->get_IpAddress	( &strIpAddress );
		pBinding->get_TcpPort	( &lTcpPort );
		pBinding->get_SslPort	( &lSslPort );

		if ( fTcpBindings ) {
			if ( lTcpPort != 0 ) {
				cbCount += CountBindingChars ( strIpAddress, lTcpPort );
			}
		}
		else {
			if ( lSslPort != 0 ) {
				cbCount += CountBindingChars ( strIpAddress, lSslPort );
			}
		}
	}

	if ( cbCount == 0 ) {
		cbCount		= 2;
		wszBindings	= new WCHAR [ cbCount ];

		if ( !wszBindings ) {
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		wszBindings[0]	= NULL;
		wszBindings[1]	= NULL;
	}
	else {
		cbCount++;	// For double null terminator

		wszBindings	= new WCHAR [ cbCount ];
		if ( !wszBindings ) {
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}

		LPWSTR		pchCurrent	= wszBindings;

		for ( i = 0; i < cBindings; i++ ) {
			CComPtr<IServerBinding>	pBinding;
			CComBSTR					strIpAddress;
			long						lTcpPort;
			long						lSslPort;

			hr = pBindings->Item ( i, &pBinding );
			BAIL_ON_FAILURE(hr);

			pBinding->get_IpAddress	( &strIpAddress );
			pBinding->get_TcpPort	( &lTcpPort );
			pBinding->get_SslPort	( &lSslPort );

			if ( fTcpBindings ) {
				if ( lTcpPort != 0 ) {
					ToBindingString ( strIpAddress, lTcpPort, pchCurrent );
					pchCurrent += lstrlen ( pchCurrent ) + 1;
				}
			}
			else {
				if ( lSslPort != 0 ) {
					ToBindingString ( strIpAddress, lSslPort, pchCurrent );
					pchCurrent += lstrlen ( pchCurrent ) + 1;
				}
			}
		}

		*pchCurrent = NULL;
	}

	_ASSERT ( wszBindings[cbCount - 1] == NULL );
	_ASSERT ( wszBindings[cbCount - 2] == NULL );

	pmsz->Attach ( wszBindings );

Exit:
	return hr;
}

#if 0
	
DWORD CBinding::SizeInChars ( )
{
	DWORD		cchResult	= 0;
	WCHAR		wszTcpPort [256];

	wsprintf ( wszTcpPort, _T("%d"), m_dwTcpPort );

	cchResult += lstrlen ( m_strIpAddress );	// <IPADDRESS>
	cchResult += 1;								// :
	cchResult += lstrlen ( wszTcpPort );		// <TCPPORT>
	cchResult += 1;								// :
//	cchResult += lstrlen ( m_strPathHeader );	// <PATHHEADER>

	return cchResult;
}

void CBinding::ToString	( LPWSTR wszBinding )
{
	wsprintf ( wszBinding, _T("%s:%d:"), m_strIpAddress, m_dwTcpPort );
}

HRESULT CBinding::FromString ( LPCWSTR wszBinding )
{
	HRESULT	hr	= NOERROR;

	LPWSTR	pchFirstColon;
	LPWSTR	pchSecondColon;

	WCHAR	wszIpAddress 	[ 256 ];
	WCHAR	wszTcpPort		[ 256 ];
	long	dwTcpPort;

	LPWSTR	pchColon;

	wszIpAddress[0]		= NULL;
	wszTcpPort[0]		= NULL;

	pchFirstColon = wcschr ( wszBinding, _T(':') );
	if ( pchFirstColon ) {
		pchSecondColon = wcschr ( pchFirstColon + 1, _T(':') );
	}

	if ( !pchFirstColon || !pchSecondColon ) {
		hr = E_FAIL;
		goto Exit;
	}

	lstrcpyn ( wszIpAddress, wszBinding, 250 );
	lstrcpyn ( wszTcpPort, pchFirstColon + 1, 250 );

	// Get the TcpPort:
	dwTcpPort = _wtoi ( wszTcpPort );

	// Cutoff the IpAddress at the colon:
	pchColon = wcschr ( wszIpAddress, _T(':') );
	if ( pchColon ) {
		*pchColon = NULL;
	}

	m_strIpAddress	= wszIpAddress;
	m_dwTcpPort		= dwTcpPort;

	if ( !m_strIpAddress ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	return hr;
}

HRESULT CServerBindings::FromMultiSz ( CMultiSz * pmsz )
{
	HRESULT		hr;
	DWORD		cBindings;
	DWORD		i;
	LPCWSTR		pchCurrent;
	CBinding	binding;

	hr = Clear ();
	_ASSERT ( SUCCEEDED(hr) );

	cBindings = pmsz->Count ();

	for ( 
			i = 0, pchCurrent = *pmsz; 
			i < cBindings; 
			i++, pchCurrent += lstrlen ( pchCurrent ) + 1 
		) {

		hr = binding.FromString ( pchCurrent );
		if ( FAILED(hr) ) {
			if ( hr == E_FAIL ) {
				// Skip the bad binding strings.
				continue;
			}
			else {
				goto Exit;
			}
		}

		hr = Add ( binding.m_strIpAddress, binding.m_dwTcpPort );
		if ( FAILED(hr) ) {
			goto Exit;
		}
	}

Exit:
	return hr;
}

HRESULT CServerBindings::ToMultiSz ( CMultiSz * pmsz )
{
	HRESULT	hr	= NOERROR;
	DWORD	cchSize;
	long	i;
	LPWSTR	wszBindings;
	LPWSTR	pchCurrent;

	// Special case - the empty binding list:
	if ( m_dwCount == 0 ) {
		cchSize		= 2;
		wszBindings	= new WCHAR [ cchSize ];

		if ( !wszBindings ) {
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		wszBindings[0]	= NULL;
		wszBindings[1]	= NULL;
	}
	else {

		cchSize = 0;

		for ( i = 0; i < m_dwCount; i++ ) {
			cchSize += m_rgBindings[i].SizeInChars ( ) + 1;
		}
		// Add the size of the final terminator:
		cchSize += 1;

		wszBindings = new WCHAR [ cchSize ];
		if ( !wszBindings ) {
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		for ( i = 0, pchCurrent = wszBindings; i < m_dwCount; i++ ) {

			m_rgBindings[i].ToString ( pchCurrent );
			pchCurrent += lstrlen ( pchCurrent ) + 1;
		}

		// Add the final NULL terminator:
		*pchCurrent = NULL;
	}

	_ASSERT ( wszBindings[cchSize - 1] == NULL );
	_ASSERT ( wszBindings[cchSize - 2] == NULL );

	pmsz->Attach ( wszBindings );

	_ASSERT ( pmsz->Count () == (DWORD) m_dwCount );

Exit:
	return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\binding.h ===
// binding.h : Declaration of the CServerBinding & CServerBindings classes.


#include "resource.h"       // main symbols

//
//	Dependencies:
//

class CMultiSz;

//
//	A simple binding class:
//

class CBinding
{
public:
	CBinding () : 
		m_dwTcpPort ( 0 ),
		m_dwSslPort ( 0 )
		{ }

	CComBSTR	m_strIpAddress;
	long		m_dwTcpPort;
	long		m_dwSslPort;

	HRESULT	SetProperties ( BSTR strIpAddress, long dwTcpPort, long dwSslPort );
	inline HRESULT	SetProperties ( const CBinding & binding )
	{
		return SetProperties ( 
			binding.m_strIpAddress, 
			binding.m_dwTcpPort,
			binding.m_dwSslPort
			);
	}

private:
	// Don't call this:
	const CBinding & operator= ( const CBinding & );
};

/////////////////////////////////////////////////////////////////////////////
// The Binding Object

class CServerBinding : 
	public CComDualImpl<IServerBinding, &IID_IServerBinding, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
	friend class CServerBindings;
	//friend class CVirtualServer;

public:
	CServerBinding();
	virtual ~CServerBinding ();
BEGIN_COM_MAP(CServerBinding)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IServerBinding)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CServerBinding) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IServerBinding
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_IpAddress	( BSTR * pstrIpAddress );
	STDMETHODIMP	put_IpAddress	( BSTR strIpAddress );

	STDMETHODIMP	get_TcpPort	( long * pdwTcpPort );
	STDMETHODIMP	put_TcpPort	( long dwTcpPort );

	STDMETHODIMP	get_SslPort	( long * plSslPort );
	STDMETHODIMP	put_SslPort	( long lSslPort );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	inline HRESULT	SetProperties	( const CBinding & binding )
	{
		return m_binding.SetProperties ( binding );
	}

	// Property variables:
	CBinding	m_binding;
};

/////////////////////////////////////////////////////////////////////////////
// The Bindings Object

class CServerBindings : 
	public CComDualImpl<IServerBindings, &IID_IServerBindings, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
	friend class CServerBinding;
	//friend class CVirtualServer;

public:
	CServerBindings();
	virtual ~CServerBindings ();
BEGIN_COM_MAP(CServerBindings)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IServerBindings)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CServerBindings) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IServerBindings
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_Count	( long * pdwCount );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Item			( long index, IServerBinding ** ppBinding );
	STDMETHODIMP	ItemDispatch	( long index, IDispatch ** ppBinding );
	STDMETHODIMP	Add				( BSTR strIpAddress, long dwTcpPort, long dwSslPort );
	STDMETHODIMP	ChangeBinding	( long index, IServerBinding * pBinding );
	STDMETHODIMP	ChangeBindingDispatch	( long index, IDispatch * pBinding );
	STDMETHODIMP	Remove			( long index );
	STDMETHODIMP	Clear			( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	// Property variables:
	long			m_dwCount;
	CBinding *		m_rgBindings;
};

//////////////////////////////////////////////////////////////////////
//
//	Useful routines to go from IServerBindings to 
//	Metabase data types.
//
//////////////////////////////////////////////////////////////////////

HRESULT 
MDBindingsToIBindings ( 
	CMultiSz *				pmszBindings, 
	BOOL					fTcpBindings,
	IServerBindings *	    pBindings 
	);

HRESULT IBindingsToMDBindings ( 
	IServerBindings *	    pBindings,
	BOOL					fTcpBindings,
	CMultiSz *				pmszBindings
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\guids.cpp ===
#include "stdafx.h"

#define INITGUIDS
#include "initguid.h"

// #include "iadm.h"


//
//	SMTP guids
//
#include "smtpadm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\domain.cpp ===
// domain.cpp : Implementation of CsmtpadmApp and DLL registration.

#include "stdafx.h"
#include "iadm.h"
#include "iiscnfg.h"

#include "smtpadm.h"
#include "domain.h"
#include "oleutil.h"
#include "metautil.h"

#include "listmacr.h"
#include <lmapibuf.h>

#include "smtpcmn.h"
#include "smtpprop.h"

// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT      0
#define THIS_FILE_PROG_ID           _T("Smtpadm.Domain.1")
#define THIS_FILE_IID               IID_ISmtpAdminDomain


#define UNASSIGNED_DOMAIN_ID            ( DWORD( -1 ) )

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(SmtpAdminDomain, CSmtpAdminDomain, IID_ISmtpAdminDomain)

STDMETHODIMP CSmtpAdminDomain::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] =
    {
        &IID_ISmtpAdminDomain,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

CSmtpAdminDomain::CSmtpAdminDomain () 
    // CComBSTR's are initialized to NULL by default.
{
    m_lCount        = 0;
    m_dwActionType    = SMTP_DELIVER;
    m_fAllowEtrn    = FALSE;
    m_dwDomainId    = UNASSIGNED_DOMAIN_ID;

    m_dwMaxDomainId    = 0;
    m_fEnumerated    = FALSE;

    m_pCurrentDomainEntry    = NULL;
    m_pDefaultDomainEntry    = NULL;

    InitializeListHead( &m_list );

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("Domain") );
    m_iadsImpl.SetClass ( _T("IIsSmtpDomain") );
}

CSmtpAdminDomain::~CSmtpAdminDomain ()
{
    EmptyList();
    // All CComBSTR's are freed automatically.
}

void CSmtpAdminDomain::EmptyList()
{
    PLIST_ENTRY            pHead;
    PLIST_ENTRY            pEntry;
    DomainEntry*        pDomainEntry;

    for( pHead=&m_list, pEntry=pHead->Flink; pEntry!=pHead; pEntry=pHead->Flink )
    {
        pDomainEntry = CONTAINING_RECORD(pEntry, DomainEntry, list);
        RemoveEntryList(pEntry);
        delete pDomainEntry;
    }
}


//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CSmtpAdminDomain,m_iadsImpl)


//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

// enumeration

STDMETHODIMP CSmtpAdminDomain::get_Count ( long * plCount )
{
    return StdPropertyGet ( m_lCount, plCount );
}


// current Domain Properties:

STDMETHODIMP CSmtpAdminDomain::get_DomainName ( BSTR * pstrDomainName )
{
    return StdPropertyGet ( m_strDomainName, pstrDomainName );
}

STDMETHODIMP CSmtpAdminDomain::put_DomainName ( BSTR strDomainName )
{
    return StdPropertyPut ( &m_strDomainName, strDomainName );
}


STDMETHODIMP CSmtpAdminDomain::get_ActionType( long * plActionType )
{
    return StdPropertyGet ( m_dwActionType, plActionType );
}

STDMETHODIMP CSmtpAdminDomain::put_ActionType( long lActionType )
{
    return StdPropertyPut ( &m_dwActionType, lActionType );
}


    // drop IsDefault!!
STDMETHODIMP CSmtpAdminDomain::get_IsDefault ( BOOL * pfIsDefault )
{
    *pfIsDefault = m_dwActionType == SMTP_DEFAULT;
    return NOERROR;
}

STDMETHODIMP CSmtpAdminDomain::put_IsDefault ( BOOL fIsDefault )
{
    return E_NOTIMPL;
}


STDMETHODIMP CSmtpAdminDomain::get_IsLocal ( BOOL * pfIsLocal )
{
    return E_NOTIMPL;
}

STDMETHODIMP CSmtpAdminDomain::put_IsLocal ( BOOL fIsLocal )
{
    return E_NOTIMPL;
}

    // if local

STDMETHODIMP CSmtpAdminDomain::get_LDAPServer ( BSTR * pstrLDAPServer )
{
    return E_NOTIMPL;
    //return StdPropertyGet ( m_strLDAPServer, pstrLDAPServer );
}

STDMETHODIMP CSmtpAdminDomain::put_LDAPServer ( BSTR strLDAPServer )
{
    return E_NOTIMPL;
    //return StdPropertyPut ( &m_strLDAPServer, strLDAPServer );
}


STDMETHODIMP CSmtpAdminDomain::get_Account ( BSTR * pstrAccount )
{
    return E_NOTIMPL;
    //return StdPropertyGet ( m_strAccount, pstrAccount );
}

STDMETHODIMP CSmtpAdminDomain::put_Account ( BSTR strAccount )
{
    return E_NOTIMPL;
    //return StdPropertyPut ( &m_strAccount, strAccount );
}


STDMETHODIMP CSmtpAdminDomain::get_Password ( BSTR * pstrPassword )
{
    return E_NOTIMPL;
    //return StdPropertyGet ( m_strPassword, pstrPassword );
}

STDMETHODIMP CSmtpAdminDomain::put_Password ( BSTR strPassword )
{
    return E_NOTIMPL;
    //return StdPropertyPut ( &m_strPassword, strPassword );
}


STDMETHODIMP CSmtpAdminDomain::get_LDAPContainer ( BSTR * pstrLDAPContainer )
{
    return E_NOTIMPL;
    //return StdPropertyGet ( m_strLDAPContainer, pstrLDAPContainer );
}

STDMETHODIMP CSmtpAdminDomain::put_LDAPContainer ( BSTR strLDAPContainer )
{
    return E_NOTIMPL;
    //return StdPropertyPut ( &m_strLDAPContainer, strLDAPContainer );
}

    // if remote

STDMETHODIMP CSmtpAdminDomain::get_UseSSL ( BOOL * pfUseSSL )
{
    return E_NOTIMPL;
}

STDMETHODIMP CSmtpAdminDomain::put_UseSSL ( BOOL fUseSSL )
{
    return E_NOTIMPL;
}


STDMETHODIMP CSmtpAdminDomain::get_EnableETRN ( BOOL * pfEnableETRN )
{
    return E_NOTIMPL;
}

STDMETHODIMP CSmtpAdminDomain::put_EnableETRN ( BOOL fEnableETRN )
{
    return E_NOTIMPL;
}


STDMETHODIMP CSmtpAdminDomain::get_DropDir ( BSTR * pstrDropDir )
{
    return StdPropertyGet ( m_strActionString, pstrDropDir );
}

STDMETHODIMP CSmtpAdminDomain::put_DropDir ( BSTR strDropDir )
{
    return StdPropertyPut ( &m_strActionString, strDropDir );
}


STDMETHODIMP CSmtpAdminDomain::get_RoutingDomain ( BSTR * pstrRoutingDomain )
{
    return StdPropertyGet ( m_strActionString, pstrRoutingDomain );
}

STDMETHODIMP CSmtpAdminDomain::put_RoutingDomain ( BSTR strRoutingDomain )
{
    return StdPropertyPut ( &m_strActionString, strRoutingDomain );
}


//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CSmtpAdminDomain::Default ( )
{
    TraceFunctEnter ( "CSmtpAdminDomain::Default" );

    m_dwActionType    = SMTP_DELIVER;
    m_fAllowEtrn    = FALSE;
    m_dwDomainId    = UNASSIGNED_DOMAIN_ID;

    m_strDomainName.Empty();
    m_strActionString.Empty();

    m_pCurrentDomainEntry    = NULL;

    TraceFunctLeave ();
    return NOERROR;
}

STDMETHODIMP CSmtpAdminDomain::Add ( )
{
    TraceFunctEnter ( "CSmtpAdminDomain::Add" );

    HRESULT            hr        = NOERROR;
    DomainEntry*    pOldDef = NULL;

    DomainEntry*    pNewDomain = new DomainEntry;
    if( !pNewDomain )
    {
        ErrorTrace ( (LPARAM) this, "Out of memory" );
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = GetFromMetabase();
    if( FAILED(hr) )
    {
        goto Exit;
    }

    lstrcpyW( pNewDomain-> m_strDomainName, (LPCWSTR)m_strDomainName );
    lstrcpyW( pNewDomain-> m_strActionString, (LPCWSTR)m_strActionString );
    pNewDomain-> m_dwActionType = m_dwActionType;
    pNewDomain-> m_fAllowEtrn = m_fAllowEtrn;

    // deal with default domain
    if( m_dwActionType == SMTP_DEFAULT )
    {
        pOldDef = m_pDefaultDomainEntry;
        pOldDef-> m_dwActionType = pOldDef->m_strActionString[0] ? SMTP_DROP : SMTP_DELIVER;

        InsertHeadList( &m_list, &pNewDomain->list );
        m_pDefaultDomainEntry = pNewDomain;
    }
    else
    {
        InsertTailList( &m_list, &pNewDomain->list );
    }

    hr = SaveToMetabase();
    if( FAILED(hr) )
    {
        RemoveEntryList( &pNewDomain->list );
        ErrorTrace ( (LPARAM) this, "Failed to remove domain: %x", hr );
        delete pNewDomain;
        goto Exit;
    }

    m_pCurrentDomainEntry = pNewDomain;
    m_lCount++;

Exit:
    TraceFunctLeave ();
    return hr;
}



STDMETHODIMP CSmtpAdminDomain::Remove ( )
{
    TraceFunctEnter ( "CSmtpAdminDomain::Remove" );

    HRESULT            hr        = NOERROR;

    // need to call get() first
    _ASSERT( m_pCurrentDomainEntry );
    _ASSERT( !lstrcmpiW( m_strDomainName, m_pCurrentDomainEntry->m_strDomainName ) );

    if( !m_pCurrentDomainEntry || 
        lstrcmpiW( m_strDomainName, m_pCurrentDomainEntry->m_strDomainName ) )
    {
        hr = SmtpCreateException (IDS_SMTPEXCEPTION_DIDNT_CALL_GET);
        goto Exit;
    }

    //Can't remove default domain
    if( m_pCurrentDomainEntry == m_pDefaultDomainEntry )
    {
        hr = SmtpCreateException (IDS_SMTPEXCEPTION_CANT_DEL_DEFAULT_DOMAIN);
        goto Exit;
    }

    RemoveEntryList( &m_pCurrentDomainEntry->list );
    hr = SaveToMetabase();

Exit:
    TraceFunctLeave ();
    return hr;
}


STDMETHODIMP CSmtpAdminDomain::Get ( )
{
    TraceFunctEnter ( "CSmtpAdminDomain::Get" );

    HRESULT            hr        = NOERROR;

    hr = GetFromMetabase();
    if( FAILED(hr) )
    {
        goto Exit;
    }

    // given domain name, find the entry
    m_pCurrentDomainEntry = FindDomainEntry( m_strDomainName );

    if( !m_pCurrentDomainEntry )
    {
        hr = SmtpCreateException( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
        goto Exit;
    }

    LoadDomainProperty( m_pCurrentDomainEntry );

Exit:
    TraceFunctLeave ();
    return hr;
}



STDMETHODIMP CSmtpAdminDomain::Set ( )
{
    TraceFunctEnter ( "CSmtpAdminDomain::Set" );

    HRESULT            hr        = NOERROR;
    DomainEntry*    pOldDef = NULL;

    // need to call get() first
    _ASSERT( m_pCurrentDomainEntry );

    if( !m_pCurrentDomainEntry )
    {
        hr = SmtpCreateException (IDS_SMTPEXCEPTION_DIDNT_CALL_GET);
        goto Exit;
    }

    lstrcpyW( m_pCurrentDomainEntry->m_strDomainName, m_strDomainName );
    lstrcpyW( m_pCurrentDomainEntry->m_strActionString, m_strActionString );
    m_pCurrentDomainEntry-> m_dwActionType = m_dwActionType;
    m_pCurrentDomainEntry-> m_fAllowEtrn = m_fAllowEtrn;

    // deal with default domain
    if( m_dwActionType == SMTP_DEFAULT && m_pDefaultDomainEntry != m_pCurrentDomainEntry )
    {
        pOldDef = m_pDefaultDomainEntry;
        pOldDef-> m_dwActionType = pOldDef->m_strActionString[0] ? SMTP_DROP : SMTP_DELIVER;

        m_pDefaultDomainEntry = m_pCurrentDomainEntry;
        RemoveEntryList( &m_pCurrentDomainEntry->list );
        InsertHeadList( &m_list, &m_pCurrentDomainEntry->list );
    }

    hr = SaveToMetabase();

Exit:
    TraceFunctLeave ();
    return hr;
}



STDMETHODIMP CSmtpAdminDomain::Enumerate ( )
{
    TraceFunctEnter ( "CSmtpAdminDomain::EnumDomains" );
    HRESULT        hr = NOERROR;

    hr = GetFromMetabase();
    m_fEnumerated = TRUE;

    TraceFunctLeave ();
    return hr;
}


STDMETHODIMP CSmtpAdminDomain::GetNth( long lIndex )
{
    TraceFunctEnter ( "CSmtpAdminDomain::GetNth" );
    HRESULT        hr = NOERROR;

    PLIST_ENTRY    pEntry;

    if( !m_fEnumerated )
    {
        hr = SmtpCreateException( IDS_SMTPEXCEPTION_DIDNT_ENUMERATE );
        goto Exit;
    }

    if( lIndex < 0 || lIndex >= m_lCount )
    {
        hr = SmtpCreateException( IDS_SMTPEXCEPTION_INVALID_INDEX );
        goto Exit;
    }

    pEntry = m_list.Flink;
    while( lIndex -- )
    {
        pEntry = pEntry-> Flink;
        _ASSERT( pEntry != &m_list );
    }

    m_pCurrentDomainEntry = CONTAINING_RECORD(pEntry, DomainEntry, list);
    LoadDomainProperty( m_pCurrentDomainEntry );

Exit:
    TraceFunctLeave ();
    return hr;
}

STDMETHODIMP CSmtpAdminDomain::GetDefaultDomain ( )
{
    TraceFunctEnter ( "CSmtpAdminDomain::GetDefaultDomain" );

    HRESULT        hr = NOERROR;

    if( !m_pDefaultDomainEntry )
    {
        hr = GetFromMetabase();
        if( FAILED(hr) )
        {
            goto Exit;
        }
    }

    LoadDomainProperty( m_pDefaultDomainEntry );

Exit:
    TraceFunctLeave ();
    return hr;
}


DomainEntry* CSmtpAdminDomain::FindDomainEntry( LPCWSTR lpName )
{
    TraceFunctEnter ( "CSmtpAdminDomain::FindDomainEntry" );

    DomainEntry*    pDomainEntry = NULL;
    PLIST_ENTRY        pHead;
    PLIST_ENTRY        pEntry;

    for( pHead=&m_list, pEntry=pHead->Flink; pEntry!=pHead; pEntry=pEntry->Flink )
    {
        pDomainEntry = CONTAINING_RECORD(pEntry, DomainEntry, list);
        if( !lstrcmpiW( pDomainEntry->m_strDomainName, lpName ) )
        {
            TraceFunctLeave ();
            return pDomainEntry;
        }
    }

    TraceFunctLeave ();
    return NULL;
}

STDMETHODIMP CSmtpAdminDomain::SetAsDefaultDomain ( )
{
    TraceFunctEnter ( "CSmtpAdminDomain::SetAsDefaultDomain" );
    HRESULT        hr = NOERROR;

    if( !m_pDefaultDomainEntry )
    {
        hr = GetFromMetabase();
        if( FAILED(hr) )
        {
            goto Exit;
        }
    }

    // not in the list
    if( m_dwDomainId == UNASSIGNED_DOMAIN_ID )
    {
        hr = Add();
        if( FAILED(hr) )
        {
            goto Exit;
        }
    }

    _ASSERT( m_dwDomainId == m_pCurrentDomainEntry->m_dwDomainId );

    m_pDefaultDomainEntry = m_pCurrentDomainEntry;

    hr = SaveToMetabase();

Exit:
    TraceFunctLeave ();
    return hr;
}

BOOL CSmtpAdminDomain::LoadDomainProperty(DomainEntry* pDomainEntry)
{
    TraceFunctEnter ( "CSmtpAdminDomain::LoadDomainProperty" );
    _ASSERT( pDomainEntry );

    m_strDomainName        = pDomainEntry-> m_strDomainName;
    m_dwActionType        = pDomainEntry-> m_dwActionType;

    m_strActionString    = pDomainEntry-> m_strActionString;
    m_fAllowEtrn        = pDomainEntry-> m_fAllowEtrn;
    m_dwDomainId        = pDomainEntry-> m_dwDomainId;

    m_pCurrentDomainEntry = pDomainEntry;

    TraceFunctLeave ();
    return TRUE;
}


BOOL CSmtpAdminDomain::ConstructListFromMetabaseValues()
{
    TraceFunctEnter ( "CSmtpAdminDomain::ConstructListFromMetabaseValues" );

    DomainEntry*    pDomainEntry;
    TCHAR*            pCh;
    TCHAR*            wszCurrent;

    DWORD            i;
    DWORD            cCount = m_mszDomainRouting.Count( );

    EmptyList();
    m_lCount = 0;

    pCh = (TCHAR*)(LPCWSTR)m_mszDomainRouting;

    for( wszCurrent = pCh, i = 0; 
        i < cCount; 
        i++, wszCurrent += lstrlen (wszCurrent) + 1 ) 
    {
        pDomainEntry = new DomainEntry;
        
        if( NULL == pDomainEntry )
        {
            goto Exit;
        }

        pDomainEntry-> FromString( wszCurrent );
        InsertHeadList( &m_list, &pDomainEntry->list );
    }

    m_lCount += cCount;

    if( !m_strDefaultDomain.m_str || !m_strDefaultDomain.m_str[0] )
    {
        _ASSERT( FALSE );
        goto Exit;
    }

    m_pDefaultDomainEntry = new DomainEntry;
    
    if( NULL == m_pDefaultDomainEntry )
    {
        goto Exit;
    }

    lstrcpy( m_pDefaultDomainEntry-> m_strDomainName, m_strDefaultDomain.m_str );

    if( !m_strDropDir )
    {
        m_pDefaultDomainEntry-> m_strActionString[0] = _T('\0');
    }
    else
    {
        lstrcpy( m_pDefaultDomainEntry-> m_strActionString, m_strDropDir.m_str );
    }

    m_pDefaultDomainEntry-> m_dwActionType = SMTP_DEFAULT;

    InsertHeadList( &m_list, &m_pDefaultDomainEntry->list );
    m_lCount ++;

Exit:
    TraceFunctLeave ();
    return TRUE;
}


BOOL CSmtpAdminDomain::ParseListToMetabaseValues()        // called by SaveData()
{
    TraceFunctEnter ( "CSmtpAdminDomain::ParseListToMetabaseValues" );

    BOOL        fRet = TRUE;

    // change string list to multisz
    DomainEntry*    pDomainEntry = NULL;
    PLIST_ENTRY        pHead;
    PLIST_ENTRY        pEntry;
    DWORD            cb = 0;
    WCHAR*            pBuf;
    WCHAR*            p;

    // the first one is default domain
    _ASSERT( CONTAINING_RECORD( m_list.Flink, DomainEntry, list ) == m_pDefaultDomainEntry );

    for( pHead=&m_list, pEntry=pHead->Flink->Flink; pEntry!=pHead; pEntry=pEntry->Flink )
    {
        pDomainEntry = CONTAINING_RECORD(pEntry, DomainEntry, list);
        cb += lstrlenW( pDomainEntry-> m_strDomainName );
        cb += lstrlenW( pDomainEntry-> m_strActionString );
        cb += sizeof(DWORD)*2;
        cb += 10;    // 4 commas and NULL
    }

    // two more NULL's
    cb += 4;
    pBuf = new WCHAR[cb];

    if( !pBuf )
    {
        ErrorTrace ( (LPARAM) this, "Out of memory" );
        fRet = FALSE;
        goto Exit;
    }

    p = pBuf;

    // Note: the first entry is the default domain
    for( pHead=&m_list, pEntry=pHead->Flink->Flink; pEntry!=pHead; pEntry=pEntry->Flink )
    {
        pDomainEntry = CONTAINING_RECORD(pEntry, DomainEntry, list);
        pDomainEntry->ToString( p );

        p += lstrlenW(p);
        p ++;
    }

    // add two more NULL
    *p = L'\0';
    *(p+1) = L'\0';

    m_mszDomainRouting.Empty();
    m_mszDomainRouting.Attach( pBuf );

Exit:
    TraceFunctLeave ();
    return fRet;
}


HRESULT CSmtpAdminDomain::GetFromMetabase()
{
    TraceFunctEnter ( "CSmtpAdminDomain::GetFromMetabase" );

    HRESULT    hr    = NOERROR;
    BOOL    fRet = TRUE;
    CComPtr<IMSAdminBase>    pmetabase;

    TCHAR        szPath[METADATA_MAX_NAME_LEN+2] = {0};
    TCHAR        szDropDir[256] = {0};
    TCHAR        szBuf[256] = {0};

    hr = m_mbFactory.GetMetabaseObject ( m_iadsImpl.QueryComputer(), &pmetabase );
    if ( FAILED(hr) ) {
        return hr;
    }

    CMetabaseKey        hMB( pmetabase );
    GetMDInstancePath( szPath, m_iadsImpl.QueryInstance() );

    hr = hMB.Open( szPath, METADATA_PERMISSION_READ );
    if( FAILED(hr) )
    {
        hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
        goto Exit;
    }

    m_strDefaultDomain.Empty();
    m_strDropDir.Empty();
    m_mszDomainRouting.Empty();

    fRet = StdGetMetabaseProp ( &hMB, MD_DOMAIN_ROUTING,        DEFAULT_DOMAIN_ROUTING,    &m_mszDomainRouting);
    fRet = StdGetMetabaseProp ( &hMB, MD_DEFAULT_DOMAIN_VALUE,    DEFAULT_DEFAULT_DOMAIN, &m_strDefaultDomain )   && fRet;
    fRet = StdGetMetabaseProp ( &hMB, MD_MAIL_DROP_DIR,            DEFAULT_DROP_DIR,        &m_strDropDir ) && fRet;

    if( !fRet )
    {
        hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
        goto Exit;
    }

    ConstructListFromMetabaseValues();

Exit:
    TraceFunctLeave ();
    return hr;
}

HRESULT CSmtpAdminDomain::SaveToMetabase()
{
    TraceFunctEnter ( "CSmtpAdminDomain::SaveToMetabase" );

    ParseListToMetabaseValues();

    // these two are for default domain,
    // default domain needs special care,
    // by default, it's computed by smtpsvc from TCP/IP configuration,
    // don't set this key if not changed
    BOOL        fDefChanged        = FALSE;
    BOOL        fDropChanged    = FALSE;

    _ASSERT( m_pDefaultDomainEntry && m_pDefaultDomainEntry-> m_dwActionType == SMTP_DEFAULT );
    if( m_pDefaultDomainEntry )
    {
        fDefChanged        = lstrcmpiW( m_strDefaultDomain, m_pDefaultDomainEntry-> m_strDomainName );
        fDropChanged    = lstrcmpiW( m_strActionString, m_pDefaultDomainEntry-> m_strActionString );

        if( fDefChanged )
        {
            m_strDefaultDomain.Empty();
            m_strDefaultDomain    = m_pDefaultDomainEntry-> m_strDomainName;
        }

        if( fDropChanged )
        {
            m_strDropDir.Empty();
            m_strDropDir    = m_pDefaultDomainEntry-> m_strActionString;
        }
    }


    HRESULT    hr    = NOERROR;
    BOOL    fRet = TRUE;

    CComPtr<IMSAdminBase>    pmetabase;

    TCHAR        szPath[METADATA_MAX_NAME_LEN+2] = {0};
    TCHAR        szDropDir[256] = {0};
    TCHAR        szBuf[256] = {0};

    hr = m_mbFactory.GetMetabaseObject ( m_iadsImpl.QueryComputer(), &pmetabase );
    if ( FAILED(hr) ) {
        return hr;
    }

    CMetabaseKey        hMB( pmetabase );
    GetMDInstancePath( szPath, m_iadsImpl.QueryInstance() ); 

    hr = hMB.Open( szPath, METADATA_PERMISSION_WRITE );
    if( FAILED(hr) )
    {
        hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
        goto Exit;
    }

    if( fDefChanged )
    {
        fRet = StdPutMetabaseProp ( &hMB, MD_DEFAULT_DOMAIN_VALUE, m_pDefaultDomainEntry-> m_strDomainName ) && fRet;
    }

    if( fDropChanged )
    {
        fRet = StdPutMetabaseProp ( &hMB, MD_MAIL_DROP_DIR,    m_pDefaultDomainEntry-> m_strActionString ) && fRet;
    }

    fRet = StdPutMetabaseProp ( &hMB, MD_DOMAIN_ROUTING,    &m_mszDomainRouting)        && fRet;

    if( !fRet )
    {
        hr = SmtpCreateExceptionFromWin32Error( GetLastError() );
        goto Exit;
    }

    // hr = hMB.Close();
    // BAIL_ON_FAILURE(hr);
    hMB.Close();

    hr = pmetabase-> SaveData();
    BAIL_ON_FAILURE(hr);

Exit:
    TraceFunctLeave ();
    return hr;
}


BOOL DomainEntry::FromString( LPCTSTR lpDomainString )
{
    TraceFunctEnter ( "DomainEntry::FromString" );

    TCHAR       szT[256] = {0};

    WCHAR*      pCh = (WCHAR*)lpDomainString;
    WCHAR*      pT;

    m_dwDomainId = UNASSIGNED_DOMAIN_ID;
    m_fAllowEtrn = FALSE;

    ZeroMemory( szT, sizeof(szT) );
    pT = szT;
    while( *pCh )   //
    {
        if( iswdigit( *pCh ) )
        {
            *pT++ = *pCh;
            pCh ++;
            continue;
        }

        if( *pCh == ',' )
        {
            pCh ++;
            break;
        }

        return FALSE;
    }

    if( !*pCh )
        return FALSE;

    m_dwActionType = (DWORD) _wtoi( szT );

/*
    if( m_dwActionType >= LAST_SMTP_ACTION )
    {
        _ASSERT( FALSE );
        m_dwActionType = SMTP_DROP;     // assume local drop domain
    }
*/

    ZeroMemory( m_strDomainName, sizeof(m_strDomainName) );
    pT = m_strDomainName;
    while( *pCh )
    {
        if( *pCh == ',' )
        {
            pCh ++;
            break;
        }

        *pT++ = *pCh++;
    }

    if( !*pCh )
        return FALSE;

    ZeroMemory( m_strActionString, sizeof(m_strActionString) );
    pT = m_strActionString;
    while( *pCh )
    {
        if( *pCh == ',' )
        {
            pCh ++;
            break;
        }

        *pT++ = *pCh++;
    }

    if( !*pCh )
        return FALSE;

    ZeroMemory( szT, sizeof(szT) );
    pT = szT;
    while( *pCh )   //
    {
        if( iswdigit( *pCh ) )
        {
            *pT++ = *pCh;
            pCh ++;
            continue;
        }

        if( *pCh == ',' )
        {
            pCh ++;
            break;
        }

        return FALSE;
    }

    m_fAllowEtrn = !! ((DWORD) _wtoi( szT ));

    if( !*pCh )
    {
        return FALSE;
    }

    ZeroMemory( szT, sizeof(szT) );
    pT = szT;
    while( *pCh )   //
    {
        if( iswdigit( *pCh ) )
        {
            *pT++ = *pCh;
            pCh ++;
            continue;
        }

        if( *pCh == ',' )
        {
            pCh ++;
            break;
        }

        return FALSE;
    }

    m_dwDomainId = (DWORD) _wtoi( szT );

    // ignore any other chars

    TraceFunctLeave ();
    return TRUE;
}


BOOL DomainEntry::ToString( LPTSTR lpDomainString )
{
    TraceFunctEnter ( "DomainEntry::FromString" );

    wsprintfW( lpDomainString, L"%d,%s,%s,%d",m_dwActionType, m_strDomainName,
        m_strActionString, m_fAllowEtrn);

    TraceFunctLeave ();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\dl.cpp ===
// dl.cpp : Implementation of CsmtpadmApp and DLL registration.

#include "stdafx.h"
#include "smtpadm.h"
#include "dl.h"
#include "oleutil.h"
#include "smtpapi.h"

#include <lmapibuf.h>

#include "smtpcmn.h"

// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Smtpadm.DL.1")
#define THIS_FILE_IID				IID_ISmtpAdminDL

#define DEFAULT_NEWSGROUP_NAME			_T("")
#define DEFAULT_NEWSGROUP_DESCRIPTION	_T("")
#define DEFAULT_NEWSGROUP_MODERATOR		_T("")
#define DEFAULT_NEWSGROUP_READONLY		FALSE

/////////////////////////////////////////////////////////////////////////////
//

//
// Use a macro to define all the default methods
//
DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(SmtpAdminDL, CSmtpAdminDL, IID_ISmtpAdminDL)

STDMETHODIMP CSmtpAdminDL::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ISmtpAdminDL,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CSmtpAdminDL::CSmtpAdminDL ()
	// CComBSTR's are initialized to NULL by default.
{
	m_pSmtpNameList = NULL;
	m_lType			= NAME_TYPE_LIST_NORMAL;
	m_lCount		= 0;
	m_lMemberType	= NAME_TYPE_USER;

    m_iadsImpl.SetService ( MD_SERVICE_NAME );
    m_iadsImpl.SetName ( _T("DL") );
    m_iadsImpl.SetClass ( _T("IIsSmtpDL") );
}

CSmtpAdminDL::~CSmtpAdminDL ()
{
	if ( m_pSmtpNameList ) {
		::NetApiBufferFree ( m_pSmtpNameList );
		m_pSmtpNameList		= NULL;
	}
	// All CComBSTR's are freed automatically.
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

//
//  IADs methods:
//

DECLARE_SIMPLE_IADS_IMPLEMENTATION(CSmtpAdminDL,m_iadsImpl)


// DL property

STDMETHODIMP CSmtpAdminDL::get_DLName ( BSTR * pstrDLName )
{
	return StdPropertyGet ( m_strDLName, pstrDLName );
}

STDMETHODIMP CSmtpAdminDL::put_DLName ( BSTR strDLName )
{
	return StdPropertyPut ( &m_strDLName, strDLName );
}

STDMETHODIMP CSmtpAdminDL::get_Domain ( BSTR * pstrDomain )
{
	return StdPropertyGet ( m_strDomain, pstrDomain );
}

STDMETHODIMP CSmtpAdminDL::put_Domain ( BSTR strDomain )
{
	return StdPropertyPut ( &m_strDomain, strDomain );
}


STDMETHODIMP CSmtpAdminDL::get_Type ( long * plType )
{
	return StdPropertyGet ( m_lType, plType );
}

STDMETHODIMP CSmtpAdminDL::put_Type ( long lType )
{
	return StdPropertyPut ( &m_lType, lType );
}


STDMETHODIMP CSmtpAdminDL::get_MemberName ( BSTR * pstrMemberName )
{
	return StdPropertyGet ( m_strMemberName, pstrMemberName );
}

STDMETHODIMP CSmtpAdminDL::put_MemberName ( BSTR strMemberName )
{
	return StdPropertyPut ( &m_strMemberName, strMemberName );
}


STDMETHODIMP CSmtpAdminDL::get_MemberDomain ( BSTR * pstrMemberDomain )
{
	return StdPropertyGet ( m_strMemberDomain, pstrMemberDomain );
}

STDMETHODIMP CSmtpAdminDL::put_MemberDomain ( BSTR strMemberDomain )
{
	return StdPropertyPut ( &m_strMemberDomain, strMemberDomain );
}


STDMETHODIMP CSmtpAdminDL::get_MemberType( long * plMemberType )
{
	return StdPropertyGet ( m_lMemberType, plMemberType );
}


// enumeration
STDMETHODIMP CSmtpAdminDL::get_Count ( long * plCount )
{
	return StdPropertyGet ( m_lCount, plCount );
}


//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////


STDMETHODIMP CSmtpAdminDL::Create ( )
{
	TraceFunctEnter ( "CSmtpAdminDL::Create" );

	HRESULT			hr		= NOERROR;
	DWORD			dwErr	= NOERROR;

	if( !m_strDLName || !m_strDomain )
	{
		hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
		goto Exit;
	}

	WCHAR			szFullName[512];
	wsprintfW( szFullName, L"%s@%s", (LPWSTR) m_strDLName, (LPWSTR) m_strDomain );

	dwErr = SmtpCreateDistList( 
				m_iadsImpl.QueryComputer(),
				szFullName,
				m_lType,
				m_iadsImpl.QueryInstance() );

	if ( dwErr != NOERROR ) {
		ErrorTrace ( (LPARAM) this, "Failed to create DL: %x", dwErr );
		hr = SmtpCreateExceptionFromWin32Error ( dwErr );
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CSmtpAdminDL::Delete ( )
{
	TraceFunctEnter ( "CSmtpAdminDL::Delete" );

	HRESULT			hr		= NOERROR;
	DWORD			dwErr	= NOERROR;

	if( !m_strDLName || !m_strDomain )
	{
		hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
		goto Exit;
	}

	WCHAR			szFullName[512];
	wsprintfW( szFullName, L"%s@%s", (LPWSTR) m_strDLName, (LPWSTR) m_strDomain );

	dwErr = SmtpDeleteDistList( 
				m_iadsImpl.QueryComputer(),
				szFullName,
				m_iadsImpl.QueryInstance() );

	if ( dwErr != NOERROR ) {
		ErrorTrace ( (LPARAM) this, "Failed to delete DL: %x", dwErr );
		hr = SmtpCreateExceptionFromWin32Error ( dwErr );
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}



STDMETHODIMP CSmtpAdminDL::AddMember ( )
{
	TraceFunctEnter ( "CSmtpAdminDL::AddMember" );

	HRESULT			hr		= NOERROR;
	DWORD			dwErr	= NOERROR;

	if( !m_strDLName || !m_strDomain || !m_strMemberName || !m_strMemberDomain )
	{
		hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
		goto Exit;
	}

	WCHAR			szFullDLName[512];
	WCHAR			szFullMemName[512];

	wsprintfW( szFullDLName, L"%s@%s", (LPWSTR) m_strDLName, (LPWSTR) m_strDomain );
	wsprintfW( szFullMemName, L"%s@%s", (LPWSTR) m_strMemberName, (LPWSTR) m_strMemberDomain );

	dwErr = SmtpCreateDistListMember( 
				m_iadsImpl.QueryComputer(),
				szFullDLName,
				szFullMemName,
				m_iadsImpl.QueryInstance() );

	if ( dwErr != NOERROR ) {
		ErrorTrace ( (LPARAM) this, "Failed to add DL member: %x", dwErr );
		hr = SmtpCreateExceptionFromWin32Error ( dwErr );
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CSmtpAdminDL::RemoveMember ( )
{
	TraceFunctEnter ( "CSmtpAdminDL::RemoveMember" );

	HRESULT			hr		= NOERROR;
	DWORD			dwErr	= NOERROR;

	if( !m_strDLName || !m_strDomain || !m_strMemberName || !m_strMemberDomain )
	{
		hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
		goto Exit;
	}

	WCHAR			szFullDLName[512];
	WCHAR			szFullMemName[512];

	wsprintfW( szFullDLName, L"%s@%s", (LPWSTR) m_strDLName, (LPWSTR) m_strDomain );
	wsprintfW( szFullMemName, L"%s@%s", (LPWSTR) m_strMemberName, (LPWSTR) m_strMemberDomain );

	dwErr = SmtpDeleteDistListMember( 
				m_iadsImpl.QueryComputer(),
				szFullDLName,
				szFullMemName,
				m_iadsImpl.QueryInstance() );

	if ( dwErr != NOERROR ) {
		ErrorTrace ( (LPARAM) this, "Failed to remove DL member: %x", dwErr );
		hr = SmtpCreateExceptionFromWin32Error ( dwErr );
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}


STDMETHODIMP CSmtpAdminDL::FindMembers(	BSTR strWildmat,
										long cMaxResults
										)
{
	TraceFunctEnter ( "CSmtpAdminDL::FindMembers" );

	HRESULT			hr		= NOERROR;
	DWORD			dwErr	= NOERROR;

	if( !m_strDLName || !m_strDomain )
	{
		hr = SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_ADDRESS );
		goto Exit;
	}

	// Free the old name list:
	if ( m_pSmtpNameList ) {
		::NetApiBufferFree ( m_pSmtpNameList );
		m_pSmtpNameList		= NULL;
	}
	m_lCount	= 0;

	WCHAR			szFullDLName[512];
	wsprintfW( szFullDLName, L"%s@%s", (LPWSTR) m_strDLName, (LPWSTR) m_strDomain );

	dwErr = SmtpGetNameListFromList ( 
					m_iadsImpl.QueryComputer(),  
					szFullDLName,
					strWildmat, 
					NAME_TYPE_ALL,
					cMaxResults, 
					TRUE, 
					&m_pSmtpNameList,
					m_iadsImpl.QueryInstance());

	if ( dwErr != 0 ) {
		ErrorTraceX ( (LPARAM) this, "Failed to find alias: %x", dwErr );
		SetLastError( dwErr );
		hr = SmtpCreateExceptionFromWin32Error ( dwErr );
		goto Exit;
	}

	m_lCount = m_pSmtpNameList->cEntries;

Exit:
	TraceFunctLeave ();
	return hr;
}


STDMETHODIMP CSmtpAdminDL::GetNthMember	( long lIndex )
{
	TraceFunctEnter ( "CSmtpAdminDL::GetNthMember" );

	WCHAR*					pchStartOfDomain = NULL;
	WCHAR*					p = NULL;
	LPSMTP_NAME_ENTRY		pNameEntry;

	if( !m_pSmtpNameList )
	{
		return SmtpCreateException (IDS_SMTPEXCEPTION_DIDNT_ENUMERATE);
	}

	if( lIndex < 0 || lIndex >= m_lCount )
	{
		return SmtpCreateException (IDS_SMTPEXCEPTION_INVALID_INDEX);
	}

	//_ASSERT( CAddr::ValidateEmailName(m_pSmtpNameList[lIndex].lpszName) );

	pNameEntry = &m_pSmtpNameList->aNameEntry[lIndex];
	p = pNameEntry->lpszName;

	while( *p && *p != '@' ) p++;
	_ASSERT( *p );

	if( !*p )
	{
		return SmtpCreateException (IDS_SMTPEXCEPTION_INVALID_ADDRESS);
	}

	pchStartOfDomain = p+1;

	m_lMemberType = pNameEntry->dwType;

	m_strMemberDomain = (LPCWSTR) pchStartOfDomain;

	*(pchStartOfDomain-1) = '\0';
	m_strMemberName = pNameEntry->lpszName; // converted to UNICODE
	*(pchStartOfDomain-1) = '@';	// turn it back

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\domain.h ===
// domain.h : Declaration of the CSmtpAdminDomain


#include "resource.h"       // main symbols

#include "smtptype.h"
#include "smtpapi.h"
#include "cmultisz.h"
#include "metafact.h"
#include "smtpadm.h"
#include "listmacr.h"

struct DomainEntry
{
	TCHAR		m_strDomainName[256];	// current domain's name
	DWORD		m_dwActionType;
	TCHAR		m_strActionString[256];
	BOOL		m_fAllowEtrn;
	DWORD		m_dwDomainId;

	LIST_ENTRY	list;

	BOOL		FromString( LPCTSTR lpDomainString );
	BOOL		ToString( LPTSTR lpDomainString );		// big enough to hold the entry

	DomainEntry()
	{
		ZeroMemory( m_strDomainName, sizeof(m_strDomainName) );
		ZeroMemory( m_strActionString, sizeof(m_strActionString) );

		m_dwActionType = SMTP_DELIVER;
		m_fAllowEtrn = FALSE;
		m_dwDomainId = (DWORD)-1;
		InitializeListHead( &list );
	}
};


/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdminDomain : 
	public ISmtpAdminDomain,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdminDomain,&CLSID_CSmtpAdminDomain>
{
public:
	CSmtpAdminDomain();
	virtual ~CSmtpAdminDomain();
BEGIN_COM_MAP(CSmtpAdminDomain)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(ISmtpAdminDomain)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdminDomain) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdminDomain, _T("Smtpadm.Domain.1"), _T("Smtpadm.Domain"), IDS_SMTPADMIN_DOMAIN_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_SMTPADMLib
	#define THIS_IID	IID_ISmtpAdminDomain
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// ISmtpAdminDomain
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	// Which service to configure:
	
	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// enumeration
	STDMETHODIMP	get_Count			( long* plCount  );

	// Domain Properties:

	STDMETHODIMP	get_DomainName		( BSTR * pstrDomainName );
	STDMETHODIMP	put_DomainName		( BSTR strDomainName );

	STDMETHODIMP	get_ActionType		( long * plActionType );
	STDMETHODIMP	put_ActionType		( long lActionType );

	// drop IsDefault!!
	STDMETHODIMP	get_IsDefault		( BOOL * pfIsDefault );
	STDMETHODIMP	put_IsDefault		( BOOL fIsDefault );

	STDMETHODIMP	get_IsLocal			( BOOL * pfIsLocal );
	STDMETHODIMP	put_IsLocal			( BOOL fIsLocal );

	// if local
	STDMETHODIMP	get_LDAPServer		( BSTR * pstrLDAPServer );
	STDMETHODIMP	put_LDAPServer		( BSTR strLDAPServer );

	STDMETHODIMP	get_Account			( BSTR * pstrAccount );
	STDMETHODIMP	put_Account			( BSTR strAccount );

	STDMETHODIMP	get_Password		( BSTR * pstrPassword );
	STDMETHODIMP	put_Password		( BSTR strPassword );

	STDMETHODIMP	get_LDAPContainer	( BSTR * pstrLDAPContainer );
	STDMETHODIMP	put_LDAPContainer	( BSTR strLDAPContainer );

	// if remote
	STDMETHODIMP	get_UseSSL			( BOOL * pfUseSSL );
	STDMETHODIMP	put_UseSSL			( BOOL fUseSSL );

	STDMETHODIMP	get_EnableETRN		( BOOL * pfEnableETRN );
	STDMETHODIMP	put_EnableETRN		( BOOL fEnableETRN );

	STDMETHODIMP	get_DropDir			( BSTR * pstrDropDir );
	STDMETHODIMP	put_DropDir			( BSTR strDropDir );

	STDMETHODIMP	get_RoutingDomain	( BSTR * pstrRoutingDomain );
	STDMETHODIMP	put_RoutingDomain	( BSTR strRoutingDomain );


	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Default		( );

	STDMETHODIMP	Add			( );
	STDMETHODIMP	Remove		( );

	STDMETHODIMP	Get			( );
	STDMETHODIMP	Set			( );

	STDMETHODIMP	Enumerate	( );

	STDMETHODIMP	GetNth		( long lIndex );

	STDMETHODIMP	GetDefaultDomain ( );

	STDMETHODIMP	SetAsDefaultDomain ( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

    CIADsImpl   m_iadsImpl;

	long		m_lCount;

	// metabase key values, these shouldn't be changed before Set()
	CMultiSz    m_mszDomainRouting;
	CComBSTR	m_strDefaultDomain;
	CComBSTR	m_strDropDir;

	// current domain's property
	CComBSTR	m_strDomainName;	// current domain's name
	DWORD		m_dwActionType;
	CComBSTR	m_strActionString;
	BOOL		m_fAllowEtrn;
	DWORD		m_dwDomainId;

	// if local
	CComBSTR	m_strLDAPServer;
	CComBSTR	m_strAccount;
	CComBSTR	m_strPassword;
	CComBSTR	m_strLDAPContainer;

	// Metabase:
	CMetabaseFactory	m_mbFactory;

	// add a list of domains
	LIST_ENTRY	m_list;
	DWORD		m_dwMaxDomainId;

	BOOL		m_fEnumerated;

	// DWORD			m_dwCurrentIndex;	// optimization
	DomainEntry*		m_pCurrentDomainEntry;

	DomainEntry*	m_pDefaultDomainEntry;

	// private method
	HRESULT		SaveData();

	BOOL		LoadDomainProperty(DomainEntry* pDomainEntry);

	DomainEntry*	FindDomainEntry( LPCWSTR lpName );

	BOOL		ConstructListFromMetabaseValues();
	BOOL		ParseListToMetabaseValues();		// called by SaveData()

	HRESULT		GetFromMetabase();
	HRESULT		SaveToMetabase();

	void		EmptyList();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\dl.h ===
// dl.h : Declaration of the CSmtpAdminDL


#include "resource.h"       // main symbols

#include "smtptype.h"
#include "smtpapi.h"

/////////////////////////////////////////////////////////////////////////////
// smtpadm

class CSmtpAdminDL : 
	public ISmtpAdminDL,
	public IPrivateUnknown,
	public IPrivateDispatch,
	public IADsExtension,
	public INonDelegatingUnknown,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CSmtpAdminDL,&CLSID_CSmtpAdminDL>
{
public:
	CSmtpAdminDL();
	virtual ~CSmtpAdminDL();
BEGIN_COM_MAP(CSmtpAdminDL)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IADs)
	COM_INTERFACE_ENTRY(ISmtpAdminDL)
	COM_INTERFACE_ENTRY(IADsExtension)
	COM_INTERFACE_ENTRY(IPrivateUnknown)
	COM_INTERFACE_ENTRY(IPrivateDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CSmtpAdminDL) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CSmtpAdminDL, _T("Smtpadm.DL.1"), _T("Smtpadm.DL"), IDS_SMTPADMIN_DL_DESC, THREADFLAGS_BOTH)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	//
	// This declares methods for the following:
	// IADsExtension
	// IUnknown
	// IDispatch
	// IPrivateUnknown
	// IPrivateDispatch
	//
	#define THIS_LIBID	LIBID_SMTPADMLib
	#define THIS_IID	IID_ISmtpAdminDL
	#include "adsimp.inl"
	#undef	THIS_LIBID
	#undef	THIS_IID

// ISmtpAdminDL
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

    //
    //  IADs methods:
    //

    DECLARE_IADS_METHODS()

	// Which service to configure:

	STDMETHODIMP	get_Server		( BSTR * pstrServer );
	STDMETHODIMP	put_Server		( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	// DL Properties:

	STDMETHODIMP	get_DLName		( BSTR * pstrDLName );
	STDMETHODIMP	put_DLName		( BSTR strDLName );

	STDMETHODIMP	get_Domain		( BSTR * pstrDomain );
	STDMETHODIMP	put_Domain		( BSTR strDomain );

	STDMETHODIMP	get_Type		( long * plType );
	STDMETHODIMP	put_Type		( long lType  );

	STDMETHODIMP	get_MemberName		( BSTR * pstrMemberName );
	STDMETHODIMP	put_MemberName		( BSTR strMemberName );

	STDMETHODIMP	get_MemberDomain		( BSTR * pstrMemberDomain );
	STDMETHODIMP	put_MemberDomain		( BSTR strMemberDomain );

	STDMETHODIMP	get_MemberType		( long * plMemberType );

	// enumeration
	STDMETHODIMP	get_Count		( long* plCount  );


	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Create			( );

	STDMETHODIMP	Delete			( );

	STDMETHODIMP	AddMember		( );

	STDMETHODIMP	RemoveMember	( );

	STDMETHODIMP	FindMembers		(	BSTR strWildmat,
										long cMaxResults
										);

	STDMETHODIMP	GetNthMember	( long lIndex );


	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

    CIADsImpl   m_iadsImpl;

	CComBSTR	m_strDLName;
	CComBSTR	m_strDomain;
	long		m_lType;

	CComBSTR	m_strMemberName;
	CComBSTR	m_strMemberDomain;
	long		m_lMemberType;

	LONG		m_lCount;

	// list of members
	LPSMTP_NAME_LIST		m_pSmtpNameList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\metafact.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metafact.h

Abstract:

	Defines the CMetabaseFactory class.  This class deals with creating
	metabase objects, on either the local machine or a remote machine.

	The class provides a simple caching scheme where it will keep the name of
	the server the object was created on.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _METAFACT_INCLUDED_
#define _METAFACT_INCLUDED_

class CMetabaseFactory
{
public:
	CMetabaseFactory ();
	~CMetabaseFactory ();

	HRESULT	GetMetabaseObject	( LPCWSTR wszServer, IMSAdminBase ** ppMetabase );
	// You must call (*ppMetabase)->Release() after using the metabase object.

private:
	BOOL	IsCachedMetabase	( LPCWSTR wszServer );
	BOOL	SetServerName		( LPCWSTR wszServer );
	void	DestroyMetabaseObject	( );
	
	LPWSTR		m_wszServerName;
	IMSAdminBase *	m_pMetabase;
};

#endif // _METAFACT_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\oleutil.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	oleutil.h

Abstract:

	Defines some useful functions for dealing with OLE.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _OLEUTIL_INCLUDED_
#define _OLEUTIL_INCLUDED_

// Dependencies:

class CMultiSz;

// Common Property Operations:

HRESULT StdPropertyGet			( const BSTR strProperty, BSTR * ppstrOut );
HRESULT StdPropertyGet			( long lProperty, long * plOut );
HRESULT StdPropertyGet			( DATE dateProperty, DATE * pdateOut );
inline HRESULT StdPropertyGet	( DWORD lProperty, DWORD * pdwOut );
inline HRESULT StdPropertyGet	( BOOL fProperty, BOOL * plOut );
HRESULT StdPropertyGet			( const CMultiSz * pmszProperty, SAFEARRAY ** ppsaStrings );
HRESULT	StdPropertyGetBit		( DWORD bvBitVector, DWORD dwBit, BOOL * pfOut );

HRESULT StdPropertyPut			( BSTR * pstrProperty, const BSTR strNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
HRESULT StdPropertyPut			( long * plProperty, long lNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
HRESULT StdPropertyPut			( DATE * pdateProperty, DATE dateNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
inline HRESULT StdPropertyPut	( DWORD * plProperty, long lNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
inline HRESULT StdPropertyPut	( BOOL * pfProperty, BOOL fNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
HRESULT StdPropertyPut			( CMultiSz * pmszProperty, SAFEARRAY * psaStrings, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );
HRESULT	StdPropertyPutBit		( DWORD * pbvBitVector, DWORD dwBit, BOOL fIn );
inline HRESULT StdPropertyPutServerName	( BSTR * pstrProperty, const BSTR strNew, DWORD * pbvChangedProps = NULL, DWORD dwBitMask = 0 );

HRESULT LongArrayToVariantArray ( SAFEARRAY * psaLongs, SAFEARRAY ** ppsaVariants );
HRESULT StringArrayToVariantArray ( SAFEARRAY * psaStrings, SAFEARRAY ** ppsaVariants );
HRESULT VariantArrayToStringArray ( SAFEARRAY * psaVariants, SAFEARRAY ** ppsaStrings );

// Property Field Validation: (based on the mfc DDV_ routines)
// These routines return FALSE if the validation fails.

BOOL PV_MaxChars	( const BSTR strProperty,	DWORD nMaxChars );
BOOL PV_MinMax		( int nProperty,			int nMin,		int nMax );
BOOL PV_MinMax		( DWORD dwProperty,			DWORD dwMin,	DWORD dwMax );
BOOL PV_Boolean		( BOOL fProperty );

// Handing off IDispatch pointers:

template<class T> HRESULT StdPropertyHandoffIDispatch ( 
	REFCLSID clisd, 
	REFIID riid, 
	T ** ppIAdmin, 
	IDispatch ** ppIDispatchResult 
	);

HRESULT StdPropertyGetIDispatch ( REFCLSID clsid, IDispatch ** ppIDispatchResult );

// Internet addresses <-> Strings

BOOL InetAddressToString ( DWORD dwAddress, LPWSTR wszAddress, DWORD cAddress );
BOOL StringToInetAddress ( LPCWSTR wszAddress, DWORD * pdwAddress );

//--------------------------------------------------------------------
// Inlined functions:
//--------------------------------------------------------------------

inline HRESULT StdPropertyGet ( DWORD lProperty, DWORD * pdwOut )
{
	return StdPropertyGet ( (long) lProperty, (long *) pdwOut );
}

inline HRESULT StdPropertyGet ( BOOL fProperty, BOOL * plOut )
{
	// Make sure it's our kind of boolean:
	fProperty = !!fProperty;

	return StdPropertyGet ( (long) fProperty, (long *) plOut );
}

inline HRESULT StdPropertyPut ( DWORD * plProperty, long lNew, DWORD * pbvChangedProps, DWORD dwBitMask )
{
	return StdPropertyPut ( (long *) plProperty, lNew, pbvChangedProps, dwBitMask );
}

inline HRESULT StdPropertyPut ( BOOL * pfProperty, BOOL fNew, DWORD * pbvChangedProps, DWORD dwBitMask )
{
	// Make sure it's our kind of boolean:
	fNew = !!fNew;

	return StdPropertyPut ( (long *) pfProperty, (long) fNew, pbvChangedProps, dwBitMask );
}

inline HRESULT StdPropertyPutServerName ( BSTR * pstrProperty, const BSTR strNew, DWORD * pbvChangedProps, DWORD dwBitMask )
{
    if ( strNew && lstrcmpi ( strNew, _T("localhost") ) == 0 ) {
        // Special case: localhost => ""

        return StdPropertyPut ( pstrProperty, _T(""), pbvChangedProps, dwBitMask );
    }

    return StdPropertyPut ( pstrProperty, strNew, pbvChangedProps, dwBitMask );
}

template<class T>
HRESULT StdPropertyHandoffIDispatch ( REFCLSID clsid, REFIID riid, T ** ppIAdmin, IDispatch ** ppIDispatchResult )
{
	// Validate parameters:
	_ASSERT ( ppIAdmin != NULL );
	_ASSERT ( ppIDispatchResult != NULL );

	if ( ppIAdmin == NULL || ppIDispatchResult == NULL ) {
		return E_POINTER;
	}

	// Variables:
	HRESULT	hr = NOERROR;
	CComPtr<T>	pIAdmin;

	// Zero the out parameters:
	*ppIAdmin 			= NULL;
	*ppIDispatchResult	= NULL;

	// Get the IDispatch pointer to return:
	hr = StdPropertyGetIDispatch ( 
		clsid, 
		ppIDispatchResult
		);
	if ( FAILED (hr) ) {
		goto Error;
	}

	// Get the specific interface pointer:
	hr = (*ppIDispatchResult)->QueryInterface ( riid, (void **) &pIAdmin );
	if ( FAILED (hr) ) {
		goto Error;
	}

	*ppIAdmin = pIAdmin;
	pIAdmin->AddRef ();

	return hr;

Error:
	SAFE_RELEASE ( *ppIDispatchResult );
	*ppIDispatchResult = NULL;

	return hr;

	// Destructor releases pINntpAdminExpiration
}

#endif // _OLEUTIL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\makefile.inc ===
$(O)\smtpadm.h $(O)\smtpadm_i.c : $(STAXINC)\export\smtpadm.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpadm_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpadm_i.c \
    -header $@ \
    -tlb $(O)\smtpadm.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\ipaccess.cpp ===
// ipaccess.cpp : Implementation of CTcpAccess & CTcpAccessExceptions.

#include "stdafx.h"

#include "pudebug.h"
#define _RDNS_STANDALONE
#include <rdns.hxx>

DECLARE_DEBUG_PRINTS_OBJECT()

#include "smtpadm.h"
#include "smtpcmn.h"
#include "cmultisz.h"
#include "ipaccess.h"
#include "oleutil.h"
#include "metautil.h"
#include "metakey.h"

// Must define THIS_FILE_* macros to use SmtpCreateException()

#define THIS_FILE_HELP_CONTEXT		0
#define THIS_FILE_PROG_ID			_T("Smtpadm.TcpAccess.1")
#define THIS_FILE_IID				IID_ITcpAccess

//
//	Useful macros:
//

#define MAKEIPADDRESS(b1,b2,b3,b4) (((DWORD)(b1)<<24) +\
                                    ((DWORD)(b2)<<16) +\
                                    ((DWORD)(b3)<< 8) +\
                                    ((DWORD)(b4)))

#define GETIP_FIRST(x)             ((x>>24) & 0xff)
#define GETIP_SECOND(x)            ((x>>16) & 0xff)
#define GETIP_THIRD(x)             ((x>> 8) & 0xff)
#define GETIP_FOURTH(x)            ((x)     & 0xff)

inline void 
DWORDtoLPBYTE ( 
	IN	DWORD	dw, 
	OUT	LPBYTE	lpBytes 
	)
{
	_ASSERT ( !IsBadWritePtr ( lpBytes, 4 * sizeof ( BYTE ) ) ); 

	lpBytes[0] = (BYTE)GETIP_FIRST(dw);
	lpBytes[1] = (BYTE)GETIP_SECOND(dw);
	lpBytes[2] = (BYTE)GETIP_THIRD(dw);
	lpBytes[3] = (BYTE)GETIP_FOURTH(dw);
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CTcpAccess::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITcpAccess,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CTcpAccess::CTcpAccess ()
	// CComBSTR's are initialized to NULL by default.
{
	m_pGrantList		= NULL;
	m_pDenyList			= NULL;
}

CTcpAccess::~CTcpAccess ()
{
	// All CComBSTR's are freed automatically.

    if ( m_pGrantList ) {
        m_pGrantList->Release ();
    }
    if ( m_pDenyList ) {
        m_pDenyList->Release ();
    }
}

HRESULT CTcpAccess::GetAddressCheckFromMetabase ( CMetabaseKey * pMB, ADDRESS_CHECK * pAC )
{
	HRESULT				hr		= NOERROR;
	DWORD				dwDummy	= 0;
	DWORD				cbIpSec	= 0;
	BYTE *				pIpSec	= NULL;

	hr = pMB->GetDataSize ( _T(""), MD_IP_SEC, BINARY_METADATA, &cbIpSec, METADATA_INHERIT, IIS_MD_UT_FILE );
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {
		hr = NOERROR;
		cbIpSec = 0;
	}
	BAIL_ON_FAILURE ( hr );

	if ( cbIpSec != 0 ) {
		pIpSec = new BYTE [ cbIpSec ];
		if ( !pIpSec ) {
			BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
		}

		hr = pMB->GetBinary ( MD_IP_SEC, pIpSec, cbIpSec, METADATA_INHERIT, IIS_MD_UT_FILE );
		BAIL_ON_FAILURE (hr);

		pAC->BindCheckList ( pIpSec, cbIpSec );
	}

Exit:
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Private admin object interface:
//////////////////////////////////////////////////////////////////////

HRESULT CTcpAccess::GetFromMetabase ( CMetabaseKey * pMB )
{
    HRESULT     	hr	= NULL;
	CComObject<CTcpAccessExceptions> *	pGrantList	= NULL;
	CComObject<CTcpAccessExceptions> *	pDenyList	= NULL;

    ADDRESS_CHECK	ac;

	hr = GetAddressCheckFromMetabase ( pMB, &ac );
	BAIL_ON_FAILURE ( hr );

	hr = CComObject<CTcpAccessExceptions>::CreateInstance ( &pGrantList );
	BAIL_ON_FAILURE(hr);

	hr = CComObject<CTcpAccessExceptions>::CreateInstance ( &pDenyList );
	BAIL_ON_FAILURE(hr);

	//
	//	Copy each list into our object:
	//

	hr = pGrantList->FromAddressCheck ( &ac, TRUE );
	BAIL_ON_FAILURE(hr);

	hr = pDenyList->FromAddressCheck ( &ac, FALSE );
	BAIL_ON_FAILURE(hr);

	//
	//	Replace the old grant & deny lists with the new ones:
	//

    if ( m_pGrantList ) {
        m_pGrantList->Release ();
        m_pGrantList = NULL;
    }
    if ( m_pDenyList ) {
        m_pDenyList->Release ();
        m_pDenyList = NULL;
    }

    m_pGrantList    = pGrantList;
    m_pDenyList     = pDenyList;

    m_pGrantList->AddRef ();
    m_pDenyList->AddRef ();

Exit:
	ac.UnbindCheckList ();

	if ( FAILED(hr) ) {
		delete pGrantList;
		delete pDenyList;
	}

	return hr;
}

HRESULT CTcpAccess::SendToMetabase ( CMetabaseKey * pMB )
{
	HRESULT			hr;
	ADDRESS_CHECK	ac;
	BYTE *			pIpSec	= NULL;
	DWORD			cbIpSec	= 0;

	_ASSERT ( m_pGrantList );
	_ASSERT ( m_pDenyList );

	ac.BindCheckList ();

	hr = m_pGrantList->ToAddressCheck ( &ac, TRUE );
	BAIL_ON_FAILURE(hr);

	hr = m_pDenyList->ToAddressCheck ( &ac, FALSE );
	BAIL_ON_FAILURE(hr);

	cbIpSec	= ac.QueryCheckListSize ();
	pIpSec	= ac.QueryCheckListPtr ();

	hr = pMB->SetBinary ( MD_IP_SEC, pIpSec, cbIpSec, METADATA_INHERIT | METADATA_REFERENCE, IIS_MD_UT_FILE );

Exit:
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CTcpAccess::get_GrantedList ( ITcpAccessExceptions ** ppGrantedList )
{
	return m_pGrantList->QueryInterface ( IID_ITcpAccessExceptions, (void **) ppGrantedList );
}

STDMETHODIMP CTcpAccess::get_DeniedList ( ITcpAccessExceptions ** ppDeniedList )
{
	return m_pDenyList->QueryInterface ( IID_ITcpAccessExceptions, (void **) ppDeniedList );
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CTcpAccessExceptions::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITcpAccessExceptions,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CTcpAccessExceptions::CTcpAccessExceptions () :
	m_cCount	( 0 ),
	m_rgItems	( NULL )
	// CComBSTR's are initialized to NULL by default.
{
}

CTcpAccessExceptions::~CTcpAccessExceptions ()
{
	// All CComBSTR's are freed automatically.
}

HRESULT 
CTcpAccessExceptions::FromAddressCheck ( 
	ADDRESS_CHECK * pAC, 
	BOOL fGrantList 
	)
{
	HRESULT		hr	= NOERROR;
	DWORD		cNames;
	DWORD		cAddresses;
	DWORD		i;

	cNames		= pAC->GetNbName ( fGrantList );
	cAddresses	= pAC->GetNbAddr ( fGrantList );

	//
	//	Copy the Dns Names:
	//

	for ( i = 0; i < cNames; i++ ) {
		DWORD		dwFlags	= 0;
		LPSTR		lpName	= NULL;
		CComBSTR	strDomain;

		if ( pAC->GetName ( fGrantList, i, &lpName, &dwFlags ) ) {

			if ( !(dwFlags & DNSLIST_FLAG_NOSUBDOMAIN) ) {
				strDomain = _T("*.");

				strDomain.Append ( lpName );
			}
			else {
				strDomain = lpName;
			}

			hr = AddDnsName ( strDomain );
			BAIL_ON_FAILURE(hr);
		}
	}

	//
	//	Copy the IpAddresses:
	//

	for ( i = 0; i < cAddresses; i++ ) {
		DWORD		dwFlags	= 0;
		LPBYTE		lpMask	= NULL;
		LPBYTE		lpAddr	= NULL;
		DWORD		dwIpAddress;
		DWORD		dwIpMask;

		if ( pAC->GetAddr ( fGrantList, i, &dwFlags, &lpMask, &lpAddr ) ) {

			dwIpAddress	= MAKEIPADDRESS( lpAddr[0], lpAddr[1], lpAddr[2], lpAddr[3] );
			dwIpMask	= MAKEIPADDRESS( lpMask[0], lpMask[1], lpMask[2], lpMask[3] );

			hr = AddIpAddress ( (long) dwIpAddress, (long) dwIpMask );
			BAIL_ON_FAILURE(hr);
		}
	}

Exit:
	return hr;
}

HRESULT 
CTcpAccessExceptions::ToAddressCheck ( 
	ADDRESS_CHECK * pAC, 
	BOOL fGrantList
	)
{
	HRESULT		hr	= NOERROR;
	long		i;

	for ( i = 0; i < m_cCount; i++ ) {
		BOOL	fIsName	= FALSE;
		BOOL	fIsAddr	= FALSE;

		m_rgItems[i]->get_IsDnsName		( &fIsName );
		m_rgItems[i]->get_IsIpAddress	( &fIsAddr );

		if ( fIsName ) {
			CComBSTR	strDnsName;
			DWORD		cchName		= 0;
			LPSTR		szAnsiName	= NULL;

			DWORD		dwFlags		= 0;
			LPSTR		lpName		= NULL;

			hr = m_rgItems[i]->get_DnsName ( &strDnsName );
			BAIL_ON_FAILURE(hr);

			cchName = strDnsName.Length ( );

			szAnsiName = new char [ cchName + 1 ];
			if ( !szAnsiName ) {
				BAIL_WITH_FAILURE( hr, E_OUTOFMEMORY );
			}

			WideCharToMultiByte ( CP_ACP, 0, strDnsName, -1, szAnsiName, cchName + 1, NULL, NULL );

			if ( strncmp ( szAnsiName, "*.", 2 ) == 0 ) {
				dwFlags	= 0;
				lpName	= szAnsiName + 2;
			}
			else {
				dwFlags |= DNSLIST_FLAG_NOSUBDOMAIN;
				lpName	= szAnsiName;
			}
			pAC->AddName ( fGrantList, lpName, dwFlags );

			delete szAnsiName;
		}
		else if ( fIsAddr ) {
			long	lIpAddress	= 0;
			long	lIpMask		= 0;
			BYTE	bIp[4];
			BYTE	bMask[4];

			m_rgItems[i]->get_IpAddress ( &lIpAddress );
			m_rgItems[i]->get_IpMask	( &lIpMask );

			DWORDtoLPBYTE ( (DWORD) lIpAddress, bIp );
			DWORDtoLPBYTE ( (DWORD) lIpMask, bMask );

			pAC->AddAddr ( fGrantList, AF_INET, bMask, bIp );
		}
	}

Exit:
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CTcpAccessExceptions::get_Count ( long * pcCount )
{
	return StdPropertyGet ( m_cCount, pcCount );
}

STDMETHODIMP CTcpAccessExceptions::AddDnsName ( BSTR strDnsName )
{
	HRESULT							hr					= NOERROR;
	CComPtr<ITcpAccessException>	pNew;

	hr = CTcpAccessException::CreateNew ( strDnsName, &pNew );
	BAIL_ON_FAILURE ( hr );

	hr = AddItem ( pNew );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CTcpAccessExceptions::AddIpAddress ( long lIpAddress, long lIpMask )
{
	HRESULT							hr					= NOERROR;
	CComPtr<ITcpAccessException>	pNew;

	hr = CTcpAccessException::CreateNew ( lIpAddress, lIpMask, &pNew );
	BAIL_ON_FAILURE ( hr );

	hr = AddItem ( pNew );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

HRESULT CTcpAccessExceptions::AddItem ( ITcpAccessException * pNew )
{
	HRESULT							hr			= NOERROR;
	CComPtr<ITcpAccessException> *	rgNewItems	= NULL;
	long							i;

	rgNewItems = new CComPtr<ITcpAccessException> [ m_cCount + 1 ];
	if ( !rgNewItems ) {
		BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
	}

	for ( i = 0; i < m_cCount; i++ ) {
		rgNewItems[i] = m_rgItems[i];
	}
	rgNewItems[m_cCount] = pNew;

	delete [] m_rgItems;
	m_rgItems = rgNewItems;
	m_cCount++;

Exit:
	return hr;
}

STDMETHODIMP CTcpAccessExceptions::Item ( long index, ITcpAccessException ** ppTcpAccessException )
{
	HRESULT		hr;

	if ( index < 0 || index >= m_cCount ) {
		return SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
	}

	hr = m_rgItems[index]->QueryInterface ( IID_ITcpAccessException, (void **) ppTcpAccessException );
	return hr;
}

STDMETHODIMP CTcpAccessExceptions::Remove ( long index )
{
	HRESULT					hr		= NOERROR;
	CComPtr<ITcpAccessException>	pTemp;
	long					i;

	if ( index < 0 || index >= m_cCount ) {
		return SmtpCreateException ( IDS_SMTPEXCEPTION_INVALID_INDEX );
	}

	for ( i = index + 1; i < m_cCount; i++ ) {
		m_rgItems[i - 1] = m_rgItems[i];
	}

	m_rgItems[m_cCount - 1].Release ();
	m_cCount--;

	return hr;
}

STDMETHODIMP 
CTcpAccessExceptions::FindDnsIndex (
	BSTR	strDnsNameToFind,
	long *	pIndex 
	)
{
	long		lResult	= -1;
	long		i;

	for ( i = 0; i < m_cCount; i++ ) {
		HRESULT		hr1;
		CComBSTR	strDnsName;
		BOOL		fIsDnsName	= FALSE;

		hr1 = m_rgItems[i]->get_IsDnsName ( &fIsDnsName );
		if ( !fIsDnsName ) {
			continue;
		}

		hr1 = m_rgItems[i]->get_DnsName ( &strDnsName );

		if ( SUCCEEDED(hr1) &&
			!lstrcmpi ( strDnsName, strDnsNameToFind ) ) {

			lResult = i;
			break;
		}
	}

	*pIndex = lResult;
	return NOERROR;
}

STDMETHODIMP 
CTcpAccessExceptions::FindIpIndex (
	long	lIpAddressToFind,
	long	lIpMaskToFind,
	long *	pIndex 
	)
{
	long		lResult	= -1;
	long		i;

	for ( i = 0; i < m_cCount; i++ ) {
		BOOL		fIsIpAddress	= FALSE;
		long		lIpAddress;
		long		lIpMask;

		m_rgItems[i]->get_IsIpAddress ( &fIsIpAddress );
		if ( !fIsIpAddress ) {
			continue;
		}

		m_rgItems[i]->get_IpAddress ( &lIpAddress );
		m_rgItems[i]->get_IpMask ( &lIpMask );

		if ( lIpAddress == lIpAddressToFind && lIpMask == lIpMaskToFind ) {
			lResult = i;
			break;
		}
	}

	*pIndex = lResult;
	return NOERROR;
}

STDMETHODIMP CTcpAccessExceptions::Clear ( )
{
	delete [] m_rgItems;
	m_rgItems	= NULL;
	m_cCount		= 0;

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CTcpAccessException::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITcpAccessException,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CTcpAccessException::CTcpAccessException () :
	m_fIsDnsName	( FALSE ),
	m_fIsIpAddress	( FALSE ),
	m_dwIpAddress	( 0 ),
	m_dwIpMask		( 0 )
	// CComBSTR's are initialized to NULL by default.
{
}

CTcpAccessException::~CTcpAccessException ()
{
	// All CComBSTR's are freed automatically.
}

HRESULT 
CTcpAccessException::CreateNew ( 
	LPWSTR strDnsName, 
	ITcpAccessException ** ppNew 
	)
{
	HRESULT		hr;
	CComObject<CTcpAccessException> *	pNew	= NULL;

	hr = CComObject<CTcpAccessException>::CreateInstance ( &pNew );
	BAIL_ON_FAILURE(hr);

	hr = pNew->put_DnsName ( strDnsName );
	BAIL_ON_FAILURE(hr);

	hr = pNew->QueryInterface ( IID_ITcpAccessException, (void **) ppNew );
	BAIL_ON_FAILURE(hr);

Exit:
	if ( FAILED(hr) ) {
		delete pNew;
	}

	return hr;
}

HRESULT 
CTcpAccessException::CreateNew ( 
	DWORD dwIpAddress, 
	DWORD dwIpMask, 
	ITcpAccessException ** ppNew 
	)
{
	HRESULT		hr;
	CComObject<CTcpAccessException> *	pNew	= NULL;

	hr = CComObject<CTcpAccessException>::CreateInstance ( &pNew );
	BAIL_ON_FAILURE(hr);

	hr = pNew->put_IpAddress ( (long) dwIpAddress );
	hr = pNew->put_IpMask ( (long) dwIpMask );

	hr = pNew->QueryInterface ( IID_ITcpAccessException, (void **) ppNew );
	BAIL_ON_FAILURE(hr);

Exit:
	if ( FAILED(hr) ) {
		delete pNew;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CTcpAccessException::get_IsDnsName ( BOOL * pfIsDnsName )
{
	return StdPropertyGet ( m_fIsDnsName, pfIsDnsName );
}

STDMETHODIMP CTcpAccessException::get_IsIpAddress ( BOOL * pfIsIpAddress )
{
	return StdPropertyGet ( m_fIsIpAddress, pfIsIpAddress );
}

STDMETHODIMP CTcpAccessException::get_DnsName ( BSTR * pstrDnsName )
{
	return StdPropertyGet ( m_strDnsName, pstrDnsName );
}

STDMETHODIMP CTcpAccessException::put_DnsName ( BSTR strDnsName )
{
	HRESULT		hr;

	hr = StdPropertyPut ( &m_strDnsName, strDnsName );
	if ( SUCCEEDED(hr) ) {
		m_fIsDnsName	= TRUE;
		m_fIsIpAddress	= FALSE;
	}
	return hr;
}

STDMETHODIMP CTcpAccessException::get_IpAddress ( long * plIpAddress )
{
	return StdPropertyGet ( m_dwIpAddress, plIpAddress );
}

STDMETHODIMP CTcpAccessException::put_IpAddress ( long lIpAddress )
{
	HRESULT		hr;

	hr = StdPropertyPut ( &m_dwIpAddress, lIpAddress );
	if ( SUCCEEDED(hr) ) {
		m_fIsDnsName	= FALSE;
		m_fIsIpAddress	= TRUE;
	}
	return hr;
}

STDMETHODIMP CTcpAccessException::get_IpMask ( long * plIpMask )
{
	return StdPropertyGet ( m_dwIpMask, plIpMask );
}

STDMETHODIMP CTcpAccessException::put_IpMask ( long lIpMask )
{
	return StdPropertyPut ( &m_dwIpMask, lIpMask );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\ipaccess.h ===
//
//	Dependencies
//

class ADDRESS_CHECK;
class CTcpAccess;
class CTcpAccessExceptions;
class CTcpAccessException;
class CMetabaseKey;

/////////////////////////////////////////////////////////////////////////////
// The TcpAccess Object

class CTcpAccess : 
	public CComDualImpl<ITcpAccess, &IID_ITcpAccess, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CTcpAccess();
	virtual ~CTcpAccess ();

BEGIN_COM_MAP(CTcpAccess)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ITcpAccess)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CTcpAccess) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// DECLARE_REGISTRY(CTcpAccess, _T("Smtpadm.TcpAccess.1"), _T("Smtpadm.TcpAccess"), IDS_TCPACCESS_DESC, THREADFLAGS_BOTH)
// Private admin object interface:
public:
	HRESULT			GetFromMetabase ( CMetabaseKey * pMB );
	HRESULT			SendToMetabase ( CMetabaseKey * pMB );

// ITcpAccess
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_GrantedList	( ITcpAccessExceptions ** ppGrantedList );
	STDMETHODIMP	get_DeniedList	( ITcpAccessExceptions ** ppDeniedList );
/*
	STDMETHODIMP	put_GrantedList	( ITcpAccessExceptions * pGrantedList );
	STDMETHODIMP	put_DeniedList	( ITcpAccessExceptions * pDeniedList );
*/
	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	CComObject<CTcpAccessExceptions> *	m_pGrantList;
	CComObject<CTcpAccessExceptions> *	m_pDenyList;

	HRESULT	GetAddressCheckFromMetabase ( CMetabaseKey * pMB, ADDRESS_CHECK * pAC );
};

/////////////////////////////////////////////////////////////////////////////
// The TcpAccessExceptions Object

class CTcpAccessExceptions : 
	public CComDualImpl<ITcpAccessExceptions, &IID_ITcpAccessExceptions, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CTcpAccessExceptions();
	virtual ~CTcpAccessExceptions ();

BEGIN_COM_MAP(CTcpAccessExceptions)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ITcpAccessExceptions)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CTcpAccessExceptions) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// DECLARE_REGISTRY(CTcpAccessExceptions, _T("Smtpadm.TcpAccessExceptions.1"), _T("Smtpadm.TcpAccessExceptions"), IDS_TCPACCESSEXCEPTIONS_DESC, THREADFLAGS_BOTH)
//
//	Private admin object interface:
//
	HRESULT FromAddressCheck ( ADDRESS_CHECK * pAC, BOOL fGrant );
	HRESULT ToAddressCheck ( ADDRESS_CHECK * pAC, BOOL fGrant );

// ITcpAccessExceptions
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_Count	( long * pcCount );
	STDMETHODIMP	AddDnsName	( BSTR strDnsName );
	STDMETHODIMP	AddIpAddress( long lIpAddress, long lIpMask );
	STDMETHODIMP	Item		( long index, ITcpAccessException ** ppAccessException );
	STDMETHODIMP	Remove		( long index );
	STDMETHODIMP	FindDnsIndex( BSTR strDnsName, long * pIndex );
	STDMETHODIMP	FindIpIndex	( long lIpAddress, long lIpMask, long * pIndex );
	STDMETHODIMP	Clear		( );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:
	long							m_cCount;
	CComPtr<ITcpAccessException> *	m_rgItems;

	HRESULT	AddItem ( ITcpAccessException * pNew );
};

class CTcpAccessException : 
	public CComDualImpl<ITcpAccessException, &IID_ITcpAccessException, &LIBID_SMTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CTcpAccessException();
	virtual ~CTcpAccessException ();

	static HRESULT CreateNew ( LPWSTR strDnsName, ITcpAccessException ** ppNew );
	static HRESULT CreateNew ( DWORD dwIpAddress, DWORD dwIpMask, ITcpAccessException ** ppNew );

BEGIN_COM_MAP(CTcpAccessException)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ITcpAccessException)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CTcpAccessException) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// DECLARE_REGISTRY(CTcpAccessException, _T("Smtpadm.TcpAccessException.1"), _T("Smtpadm.TcpAccessException"), IDS_TCPACCESSEXCEPTION_DESC, THREADFLAGS_BOTH)
// ITcpAccessException
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_IsDnsName	( BOOL * pfIsDnsName );
	STDMETHODIMP	get_IsIpAddress	( BOOL * pfIsIpAddress );

	STDMETHODIMP	get_DnsName	( BSTR * pstrDnsName );
	STDMETHODIMP	put_DnsName	( BSTR strDnsName );

	STDMETHODIMP	get_IpAddress	( long * plIpAddress );
	STDMETHODIMP	put_IpAddress	( long lIpAddress );

	STDMETHODIMP	get_IpMask	( long * plIpMask );
	STDMETHODIMP	put_IpMask	( long lIpMask );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:
	CComBSTR	m_strDnsName;
	DWORD		m_dwIpAddress;
	DWORD		m_dwIpMask;
	BOOL		m_fIsDnsName;
	BOOL		m_fIsIpAddress;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\metafact.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metafact.cpp

Abstract:

	The CMetabaseFactory class.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "oleutil.h"

#include "metautil.h"
#include "metafact.h"

CMetabaseFactory::CMetabaseFactory ( ) :
	m_wszServerName	( NULL ),
	m_pMetabase		( NULL )
{
}

CMetabaseFactory::~CMetabaseFactory ()
{
	if ( m_wszServerName ) {
		delete m_wszServerName;
		m_wszServerName = NULL;
	}

	DestroyMetabaseObject ( );
}

//$-------------------------------------------------------------------
//
//	CMetabaseFactory::DestroyMetabaseObject
//
//	Description:
//
//		Destroys the current metabase object.  This includes calling
//		the terminate routine on the metabase.
//
//--------------------------------------------------------------------

void CMetabaseFactory::DestroyMetabaseObject ( )
{
	TraceQuietEnter ( "CMetabaseFactory::DestroyMetabaseObject" );
	
	if ( m_pMetabase ) {
		_VERIFY ( m_pMetabase->Release () == 0 );
		m_pMetabase = NULL;
	}
}

//$-------------------------------------------------------------------
//
//	CMetabaseFactory::GetMetabaseObject
//
//	Description:
//
//		Returns an interface to the metabase.  If the metabase object
//		hasn't been created on the same machine, it is created.
//
//	Parameters:
//
//		wszServer - remote machine to create object on, or NULL for local machine.
//		ppMetabaseResult - returns the interface pointer if successful.
//			client has the responsibility to Release this pointer.
//
//	Returns:
//
//		hresult.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseFactory::GetMetabaseObject	( LPCWSTR wszServer, IMSAdminBase ** ppMetabaseResult )
{
	TraceFunctEnter ( "CMetabaseFactory::GetMetabaseObject" );

	// Validate parameters:
	_ASSERT ( ppMetabaseResult != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppMetabaseResult ) );

	if ( ppMetabaseResult == NULL ) {
		FatalTrace ( (LPARAM) this, "Bad Return Pointer" );

		TraceFunctLeave ();
		return E_POINTER;
	}
	
	// Variables:
	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pNewMetabase;

	// Zero the out parameter:
	*ppMetabaseResult = NULL;

	// A server name of "" should be NULL:
	if ( wszServer && (*wszServer == NULL || !lstrcmpi(wszServer, _T("localhost")) ) ) {
		wszServer = NULL;
	}

	if ( IsCachedMetabase ( wszServer ) ) {
		// We've already got this metabase pointer.  Just return it.

		DebugTrace ( (LPARAM) this, "Returning Cached metabase" );
		_ASSERT ( m_pMetabase );

		*ppMetabaseResult = m_pMetabase;
		m_pMetabase->AddRef ();

		hr = NOERROR;
		goto Exit;
	}

	// We have to create the metabase object:
	StateTrace ( (LPARAM) this, "Creating new metabase" );

	// Destroy the old metabase object:
	DestroyMetabaseObject ( );

	// Setup the server name field:
	if ( !SetServerName ( wszServer ) ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// m_wszServer = NULL is valid, it means the local machine.

	hr = CreateMetabaseObject ( m_wszServerName, &pNewMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	// Save the metabase pointer:
	m_pMetabase	= pNewMetabase;
	pNewMetabase->AddRef ();

	// Return the interface pointer:
	*ppMetabaseResult = pNewMetabase;
	pNewMetabase->AddRef ();

Exit:
	TraceFunctLeave ();
	return hr;

	// pMetabase will be released automatically.
}

//$-------------------------------------------------------------------
//
//	CMetabaseFactory::IsCachedMetabase
//
//	Description:
//
//		Returns TRUE if we have a metabase for the given server
//
//	Parameters:
//
//		wszServer - remote machine or NULL
//
//	Returns:
//
//		TRUE if we have a pointer already, FALSE otherwise.
//
//--------------------------------------------------------------------

BOOL CMetabaseFactory::IsCachedMetabase ( LPCWSTR wszServer )
{
	if ( !m_pMetabase ) {
		// We don't even have a cached metabase object.
		return FALSE;
	}

	if (
		// Both are the local machine OR
		( m_wszServerName == NULL && wszServer == NULL ) ||
		// Both are the same remote machine
		( m_wszServerName && wszServer && !lstrcmpi ( m_wszServerName, wszServer ) ) ) {

		// It's a match
		return TRUE;
	}

	// No dice...
	return FALSE;
}

//$-------------------------------------------------------------------
//
//	CMetabaseFactory::SetServerName
//
//	Description:
//
//		Sets the m_wszServerName string.
//
//	Parameters:
//
//		wszServer - The new servername.  Can be NULL.
//
//	Returns:
//
//		FALSE on failure due to lack of memory.
//
//--------------------------------------------------------------------

BOOL CMetabaseFactory::SetServerName ( LPCWSTR wszServer ) 
{
	TraceQuietEnter ( "CMetabaseFactory::SetServerName" );

	delete m_wszServerName;
	m_wszServerName = NULL;

	if ( wszServer != NULL ) {
		_ASSERT ( IS_VALID_STRING ( wszServer ) );

		m_wszServerName = new WCHAR [ lstrlen ( wszServer ) + 1 ];

		if ( m_wszServerName == NULL ) {
			FatalTrace ( (LPARAM) this, "Out of Memory" );
			return FALSE;
		}

		lstrcpy ( m_wszServerName, wszServer );
	}
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\metautil.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metautil.h

Abstract:

	Useful functions for dealing with the metabase.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _METAUTIL_INCLUDED_
#define _METAUTIL_INCLUDED_

// Dependencies:

#include <iiscnfg.h>	// IIS Metabase Values
class CMultiSz;
class CMetabaseKey;

// Defaults:

#define MD_DEFAULT_TIMEOUT	5000

// Creating a metabase object:

HRESULT CreateMetabaseObject	( LPCWSTR wszMachine, IMSAdminBase ** ppMetabase );

// Metabase property manipulation:

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BOOL fDefault, BOOL * pfOut, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, DWORD dwDefault, DWORD * pdwOut, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, LPCWSTR strDefault, BSTR * pstrOut, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, LPCWSTR mszDefault, CMultiSz * pmszOut, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BOOL fValue, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, DWORD dwValue, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BSTR strValue, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );
BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, CMultiSz * pmszValue, LPCWSTR wszPath = _T(""), DWORD dwUserType = IIS_MD_UT_SERVER, DWORD dwFlags = METADATA_INHERIT );

BOOL HasKeyChanged ( IMSAdminBase * pMetabase, METADATA_HANDLE hKey, const FILETIME * pftLastChanged, LPCWSTR wszSubKey = _T("") );

// Metabase lists:

BOOL IsValidIntegerSubKey ( LPCWSTR wszSubKey );



//
//  Needed by mail
//
inline BOOL StdGetMetabaseProp (CMetabaseKey * pMB, 
                                DWORD dwID, 
                                long lDefault, 
                                long * plOut, 
                                LPCWSTR wszPath = _T(""), 
                                DWORD dwUserType = IIS_MD_UT_SERVER, 
                                DWORD dwFlags = METADATA_INHERIT )
{
    return StdGetMetabaseProp( pMB, dwID, (DWORD)lDefault, (DWORD*)plOut, wszPath, dwUserType,dwFlags);
}


inline BOOL StdPutMetabaseProp (CMetabaseKey * pMB, 
                                DWORD dwID, 
                                long lValue,
                                LPCWSTR wszPath = _T(""), 
                                DWORD dwUserType = IIS_MD_UT_SERVER, 
                                DWORD dwFlags = METADATA_INHERIT )
{
    return StdPutMetabaseProp( pMB, dwID, (DWORD)lValue, wszPath, dwUserType, dwFlags );
}


#endif // _METAUTIL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\adminsso\metautil.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metautil.cpp

Abstract:

	Useful functions for dealing with the metabase

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "smtpcmn.h"

#include "cmultisz.h"
#include "oleutil.h"
#include "metautil.h"
#include "metakey.h"

// Metabase property manipulation:

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BOOL fDefault, BOOL * pfOut, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdGetMetabaseProp<BOOL>" );

	HRESULT	hr;
	DWORD	dwTemp;

	hr = pMB->GetDword ( wszPath, dwID, &dwTemp, dwFlags, dwUserType );
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {
		// Couldn't find property, use defaults.
		DebugTraceX ( 0, "Using default for ID: %d", dwID );
		dwTemp = fDefault;
		hr = NOERROR;
	}
	BAIL_ON_FAILURE(hr);

	*pfOut = dwTemp;

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to get metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, DWORD dwDefault, DWORD * pdwOut, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdGetMetabaseProp<DWORD>" );

	DWORD	dwTemp;
	HRESULT	hr;

	hr = pMB->GetDword ( wszPath, dwID, &dwTemp, dwFlags, dwUserType );
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {
		// Couldn't find property, use defaults.

		DebugTraceX ( 0, "Using default for ID: %d", dwID );
		dwTemp = dwDefault;
		hr = NOERROR;
	}
	BAIL_ON_FAILURE(hr);

	*pdwOut = dwTemp;

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to get metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, LPCWSTR wszDefault, BSTR * pstrOut, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdGetMetabaseProp <BSTR>" );

	HRESULT	hr			= NOERROR;
	BSTR	strNew 		= NULL;
	DWORD	cbRequired	= 0;
	DWORD	cchRequired	= 0;
	BOOL	fUseDefault	= FALSE;

	// Get the length of the string to retrieve:
	hr = pMB->GetDataSize ( wszPath, dwID, STRING_METADATA, &cbRequired, dwFlags, dwUserType );
	cchRequired	= cbRequired / sizeof ( WCHAR );

	// Is the value there?
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {

		// No, so use the default that was passed in.
		DebugTraceX ( 0, "Using default for ID: %d", dwID );

		fUseDefault	= TRUE;
		hr = NOERROR;
	}
	BAIL_ON_FAILURE(hr);

	if ( !fUseDefault ) {

		strNew = ::SysAllocStringLen ( NULL, cbRequired );
		if ( !strNew ) {
			FatalTrace ( 0, "Out of memory" );
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}

		// Get the metabase string:
		hr = pMB->GetString ( wszPath, dwID, strNew, cbRequired, dwFlags, dwUserType );
		BAIL_ON_FAILURE(hr);
	}

	if ( fUseDefault ) {
		// Use the default:
		DebugTraceX ( 0, "Using default for ID: %d", dwID );

		strNew = ::SysAllocString ( wszDefault );
		if ( !strNew ) {
			FatalTrace ( 0, "Out of memory" );
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}
	}

	SAFE_FREE_BSTR ( *pstrOut );
	*pstrOut = strNew;

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to get metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}
	return SUCCEEDED(hr);
}

BOOL StdGetMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, LPCWSTR mszDefault, CMultiSz * pmszOut, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdGetMetabaseProp <CMultiSz>" );

	HRESULT	hr			= NOERROR;
	BSTR	strNew 		= NULL;
	DWORD	cbRequired	= 0;
	DWORD	cchRequired	= 0;
	BOOL	fUseDefault	= FALSE;
	LPWSTR	msz			= NULL;

	// Get the length of the string to retrieve:
	hr = pMB->GetDataSize ( wszPath, dwID, MULTISZ_METADATA, &cbRequired, dwFlags, dwUserType );
	cchRequired	= cbRequired / sizeof ( WCHAR );

	// Is the value there?
	if ( hr == MD_ERROR_DATA_NOT_FOUND ) {

		// No, so use the default that was passed in.
		DebugTraceX ( 0, "Using default for ID: %d", dwID );

		fUseDefault	= TRUE;
		hr = NOERROR;
	}
	BAIL_ON_FAILURE(hr);

	if ( !fUseDefault ) {

		msz = new WCHAR [ cchRequired ];
		if ( !msz ) {
			FatalTrace ( 0, "Out of memory" );
			BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
		}

		// Get the metabase string:
		hr = pMB->GetData ( wszPath, dwID, dwUserType, MULTISZ_METADATA, msz, &cbRequired, dwFlags );
		BAIL_ON_FAILURE(hr);

		*pmszOut = msz;
	}

	if ( fUseDefault ) {
		// Use the default:
		DebugTraceX ( 0, "Using default for ID: %d", dwID );

		*pmszOut = mszDefault;
	}

	if ( !*pmszOut ) {
		BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
	}

Exit:
	delete msz;

	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to get metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}
	return SUCCEEDED(hr);
}

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BOOL fValue, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdPutMetabaseProp <BOOL>" );

	HRESULT		hr;

	hr = pMB->SetDword ( wszPath, dwID, fValue, dwFlags, dwUserType );

	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to put metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, DWORD dwValue, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdPutMetabaseProp <DWORD>" );

	HRESULT		hr;

	hr = pMB->SetDword ( wszPath, dwID, dwValue, dwFlags, dwUserType );

	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to put metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, BSTR strValue, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdPutMetabaseProp <BSTR>" );

	_ASSERT ( strValue );

	HRESULT		hr;

	if ( !strValue ) {
		// Just skip it, but log the trace.
		FatalTrace ( 0, "strValue should not be NULL here" );
		return TRUE;
	}

	hr = pMB->SetString ( wszPath, dwID, strValue, dwFlags, dwUserType );
	BAIL_ON_FAILURE (hr);

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to put metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL StdPutMetabaseProp ( CMetabaseKey * pMB, DWORD dwID, CMultiSz * pmszValue, LPCWSTR wszPath, DWORD dwUserType, DWORD dwFlags )
{
	TraceQuietEnter ( "StdPutMetabaseProp <BSTR>" );

	_ASSERT ( pmszValue );

	if ( !*pmszValue ) {
		// Just skip it, but log the trace.
		FatalTrace ( 0, "strValue should not be NULL here" );
		return TRUE;
	}

	HRESULT		hr;
	DWORD		cbMultiSz;
	LPCWSTR		wszValue;

	cbMultiSz	= pmszValue->SizeInBytes ();
	wszValue	= *pmszValue;

	hr = pMB->SetData ( wszPath, dwID, dwUserType, MULTISZ_METADATA, (void *) wszValue, cbMultiSz, dwFlags );
	BAIL_ON_FAILURE (hr);

Exit:
	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "Failed to put metabase property ID: %d, Error: %x", dwID, hr );
		SetLastError ( HRESULTTOWIN32 ( hr ) );
	}

	return SUCCEEDED(hr);
}

BOOL HasKeyChanged ( IMSAdminBase * pMetabase, METADATA_HANDLE hKey, const FILETIME * pftLastChanged, LPCWSTR wszSubKey )
{
	TraceFunctEnter ( "HasKeyChanged" );

	FILETIME		ftNew;
	HRESULT			hr		= NOERROR;
	BOOL			fResult	= FALSE;

	if ( pftLastChanged->dwHighDateTime == 0 && pftLastChanged->dwLowDateTime == 0 ) {
		ErrorTrace ( 0, "Last changed time is NULL" );

		// No setting, so say it hasn't changed:
		goto Exit;
	}

	hr = pMetabase->GetLastChangeTime ( hKey, wszSubKey, &ftNew, FALSE );
	if ( FAILED (hr) ) {
		ErrorTrace ( 0, "Failed to get last change time: %x", hr );

		// This is an unexpected error.  Ignore it.
		goto Exit;
	}

	// Has the metabase been changed since last time?

	// Time can't go backwards:
	_ASSERT ( ftNew.dwHighDateTime >= pftLastChanged->dwHighDateTime );
	_ASSERT ( ftNew.dwLowDateTime >= pftLastChanged->dwLowDateTime ||
			ftNew.dwHighDateTime > pftLastChanged->dwHighDateTime );

	if ( ftNew.dwHighDateTime	!= pftLastChanged->dwHighDateTime ||
		 ftNew.dwLowDateTime	!= pftLastChanged->dwLowDateTime ) {

		fResult = TRUE;
	}

Exit:
	TraceFunctLeave ();
	return FALSE;
}

BOOL IsValidIntegerSubKey ( LPCWSTR wszSubKey )
{
	TraceQuietEnter ( "IsValidIntegerSubKey" );

	WCHAR	wszIntegerKey [ METADATA_MAX_NAME_LEN ];
	DWORD	dwItemValue;

	dwItemValue = _wtoi ( wszSubKey );
	wsprintf ( wszIntegerKey, _T("%d"), dwItemValue );

	// If the key is nonzero AND
	// The key is just the itoa value of the number:
	if ( dwItemValue != 0 &&
		 lstrcmp ( wszIntegerKey, wszSubKey ) == 0 ) {

